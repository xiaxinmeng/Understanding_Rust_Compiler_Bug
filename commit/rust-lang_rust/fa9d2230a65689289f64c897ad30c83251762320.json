{"sha": "fa9d2230a65689289f64c897ad30c83251762320", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhOWQyMjMwYTY1Njg5Mjg5ZjY0Yzg5N2FkMzBjODMyNTE3NjIzMjA=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-02-05T15:02:22Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-02-05T22:47:17Z"}, "message": "make codemap more robust in face of ill-formed spans.\n\nThis can be considered partial work on #8256.\n\nThe main observable change: macro expansion sometimes results in spans\nwhere `lo > hi`; so for now, when we have such a span, do not attempt\nto return a snippet result.\n\n(Longer term, we might think about whether we could still present a\nsnippet for the cases where this arises, e.g. perhaps by showing the\nwhole macro as the snippet, assuming that is the sole cause of such\nspans; or by somehow looking up the closest AST node that holds both\n`lo` and `hi`, and showing that.)\n\nAs a drive-by, revised the API to return a `Result` rather than an\n`Option`, with better information-packed error value that should help\nus (and maybe also our users) identify the causes of such problems in\nthe future.  Ideally the call-sites that really want an actual snippet\nwould be updated to catch the newly added `Err` case and print\nsomething meaningful about it, but that is not part of this PR.", "tree": {"sha": "74fbc5bce88cb1a095021dfd45940b11ee0592ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74fbc5bce88cb1a095021dfd45940b11ee0592ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa9d2230a65689289f64c897ad30c83251762320", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa9d2230a65689289f64c897ad30c83251762320", "html_url": "https://github.com/rust-lang/rust/commit/fa9d2230a65689289f64c897ad30c83251762320", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa9d2230a65689289f64c897ad30c83251762320/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "189930fcae287565dcef856ae8d60a83190a4b92", "url": "https://api.github.com/repos/rust-lang/rust/commits/189930fcae287565dcef856ae8d60a83190a4b92", "html_url": "https://github.com/rust-lang/rust/commit/189930fcae287565dcef856ae8d60a83190a4b92"}], "stats": {"total": 68, "additions": 53, "deletions": 15}, "files": [{"sha": "a724cdc0229d2f465af8865f8cd1ae42951dda33", "filename": "src/librustc_trans/save/span_utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9d2230a65689289f64c897ad30c83251762320/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9d2230a65689289f64c897ad30c83251762320/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs?ref=fa9d2230a65689289f64c897ad30c83251762320", "patch": "@@ -69,8 +69,8 @@ impl<'a> SpanUtils<'a> {\n \n     pub fn snippet(&self, span: Span) -> String {\n         match self.sess.codemap().span_to_snippet(span) {\n-            Some(s) => s,\n-            None => String::new(),\n+            Ok(s) => s,\n+            Err(_) => String::new(),\n         }\n     }\n "}, {"sha": "4d4a2bf48548abf260677929750f807e28ec4881", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa9d2230a65689289f64c897ad30c83251762320/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9d2230a65689289f64c897ad30c83251762320/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=fa9d2230a65689289f64c897ad30c83251762320", "patch": "@@ -1094,7 +1094,7 @@ pub fn get_cleanup_debug_loc_for_ast_node<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         // bodies), in which case we also just want to return the span of the\n         // whole expression.\n         let code_snippet = cx.sess().codemap().span_to_snippet(node_span);\n-        if let Some(code_snippet) = code_snippet {\n+        if let Ok(code_snippet) = code_snippet {\n             let bytes = code_snippet.as_bytes();\n \n             if bytes.len() > 0 && &bytes[bytes.len()-1..] == b\"}\" {"}, {"sha": "611251d4cfae114d895992a24def11931a680168", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9d2230a65689289f64c897ad30c83251762320/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9d2230a65689289f64c897ad30c83251762320/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=fa9d2230a65689289f64c897ad30c83251762320", "patch": "@@ -2301,8 +2301,8 @@ impl ToSource for syntax::codemap::Span {\n     fn to_src(&self, cx: &DocContext) -> String {\n         debug!(\"converting span {:?} to snippet\", self.clean(cx));\n         let sn = match cx.sess().codemap().span_to_snippet(*self) {\n-            Some(x) => x.to_string(),\n-            None    => \"\".to_string()\n+            Ok(x) => x.to_string(),\n+            Err(_) => \"\".to_string()\n         };\n         debug!(\"got snippet {}\", sn);\n         sn"}, {"sha": "3231342cb50c8f37524ca7d44ee66fb163d56344", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 46, "deletions": 8, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/fa9d2230a65689289f64c897ad30c83251762320/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9d2230a65689289f64c897ad30c83251762320/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=fa9d2230a65689289f64c897ad30c83251762320", "patch": "@@ -437,18 +437,35 @@ impl CodeMap {\n         FileLines {file: lo.file, lines: lines}\n     }\n \n-    pub fn span_to_snippet(&self, sp: Span) -> Option<String> {\n+    pub fn span_to_snippet(&self, sp: Span) -> Result<String, SpanSnippetError> {\n+        if sp.lo > sp.hi {\n+            return Err(SpanSnippetError::IllFormedSpan(sp));\n+        }\n+\n         let begin = self.lookup_byte_offset(sp.lo);\n         let end = self.lookup_byte_offset(sp.hi);\n \n-        // FIXME #8256: this used to be an assert but whatever precondition\n-        // it's testing isn't true for all spans in the AST, so to allow the\n-        // caller to not have to panic (and it can't catch it since the CodeMap\n-        // isn't sendable), return None\n         if begin.fm.start_pos != end.fm.start_pos {\n-            None\n+            return Err(SpanSnippetError::DistinctSources(DistinctSources {\n+                begin: (begin.fm.name.clone(),\n+                        begin.fm.start_pos),\n+                end: (end.fm.name.clone(),\n+                      end.fm.start_pos)\n+            }));\n         } else {\n-            Some((&begin.fm.src[begin.pos.to_usize()..end.pos.to_usize()]).to_string())\n+            let start = begin.pos.to_usize();\n+            let limit = end.pos.to_usize();\n+            if start > limit || limit > begin.fm.src.len() {\n+                return Err(SpanSnippetError::MalformedForCodemap(\n+                    MalformedCodemapPositions {\n+                        name: begin.fm.name.clone(),\n+                        source_len: begin.fm.src.len(),\n+                        begin_pos: begin.pos,\n+                        end_pos: end.pos,\n+                    }));\n+            }\n+\n+            return Ok((&begin.fm.src[start..limit]).to_string())\n         }\n     }\n \n@@ -622,6 +639,27 @@ impl CodeMap {\n     }\n }\n \n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub enum SpanSnippetError {\n+    IllFormedSpan(Span),\n+    DistinctSources(DistinctSources),\n+    MalformedForCodemap(MalformedCodemapPositions),\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct DistinctSources {\n+    begin: (String, BytePos),\n+    end: (String, BytePos)\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct MalformedCodemapPositions {\n+    name: String,\n+    source_len: usize,\n+    begin_pos: BytePos,\n+    end_pos: BytePos\n+}\n+\n #[cfg(test)]\n mod test {\n     use super::*;\n@@ -773,7 +811,7 @@ mod test {\n         let span = Span {lo: BytePos(12), hi: BytePos(23), expn_id: NO_EXPANSION};\n         let snippet = cm.span_to_snippet(span);\n \n-        assert_eq!(snippet, Some(\"second line\".to_string()));\n+        assert_eq!(snippet, Ok(\"second line\".to_string()));\n     }\n \n     #[test]"}, {"sha": "9e9ec08da038e68855df48ebc1332b010184513d", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa9d2230a65689289f64c897ad30c83251762320/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa9d2230a65689289f64c897ad30c83251762320/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=fa9d2230a65689289f64c897ad30c83251762320", "patch": "@@ -1233,8 +1233,8 @@ mod test {\n         let span = tts.iter().rev().next().unwrap().get_span();\n \n         match sess.span_diagnostic.cm.span_to_snippet(span) {\n-            Some(s) => assert_eq!(&s[], \"{ body }\"),\n-            None => panic!(\"could not get snippet\"),\n+            Ok(s) => assert_eq!(&s[], \"{ body }\"),\n+            Err(_) => panic!(\"could not get snippet\"),\n         }\n     }\n }"}]}