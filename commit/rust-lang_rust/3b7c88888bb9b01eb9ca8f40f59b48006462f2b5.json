{"sha": "3b7c88888bb9b01eb9ca8f40f59b48006462f2b5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiN2M4ODg4OGJiOWIwMWViOWNhOGY0MGY1OWI0ODAwNjQ2MmYyYjU=", "commit": {"author": {"name": "CYBAI", "email": "cyb.ai.815@gmail.com", "date": "2018-10-07T13:36:42Z"}, "committer": {"name": "CYBAI", "email": "cyb.ai.815@gmail.com", "date": "2018-10-17T03:14:37Z"}, "message": "Add lint for redundant pattern matching for explicit return boolean", "tree": {"sha": "87f05df2f194c348d4a47f8e28cdc61fedb2aa00", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87f05df2f194c348d4a47f8e28cdc61fedb2aa00"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b7c88888bb9b01eb9ca8f40f59b48006462f2b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b7c88888bb9b01eb9ca8f40f59b48006462f2b5", "html_url": "https://github.com/rust-lang/rust/commit/3b7c88888bb9b01eb9ca8f40f59b48006462f2b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b7c88888bb9b01eb9ca8f40f59b48006462f2b5/comments", "author": {"login": "CYBAI", "id": 6782666, "node_id": "MDQ6VXNlcjY3ODI2NjY=", "avatar_url": "https://avatars.githubusercontent.com/u/6782666?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CYBAI", "html_url": "https://github.com/CYBAI", "followers_url": "https://api.github.com/users/CYBAI/followers", "following_url": "https://api.github.com/users/CYBAI/following{/other_user}", "gists_url": "https://api.github.com/users/CYBAI/gists{/gist_id}", "starred_url": "https://api.github.com/users/CYBAI/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CYBAI/subscriptions", "organizations_url": "https://api.github.com/users/CYBAI/orgs", "repos_url": "https://api.github.com/users/CYBAI/repos", "events_url": "https://api.github.com/users/CYBAI/events{/privacy}", "received_events_url": "https://api.github.com/users/CYBAI/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CYBAI", "id": 6782666, "node_id": "MDQ6VXNlcjY3ODI2NjY=", "avatar_url": "https://avatars.githubusercontent.com/u/6782666?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CYBAI", "html_url": "https://github.com/CYBAI", "followers_url": "https://api.github.com/users/CYBAI/followers", "following_url": "https://api.github.com/users/CYBAI/following{/other_user}", "gists_url": "https://api.github.com/users/CYBAI/gists{/gist_id}", "starred_url": "https://api.github.com/users/CYBAI/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CYBAI/subscriptions", "organizations_url": "https://api.github.com/users/CYBAI/orgs", "repos_url": "https://api.github.com/users/CYBAI/repos", "events_url": "https://api.github.com/users/CYBAI/events{/privacy}", "received_events_url": "https://api.github.com/users/CYBAI/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dae7abb16b973ed1c808e2a86644783d23838ab4", "url": "https://api.github.com/repos/rust-lang/rust/commits/dae7abb16b973ed1c808e2a86644783d23838ab4", "html_url": "https://github.com/rust-lang/rust/commit/dae7abb16b973ed1c808e2a86644783d23838ab4"}], "stats": {"total": 278, "additions": 241, "deletions": 37}, "files": [{"sha": "6f786fc565955c2045d48c9d8d838de8f163ee93", "filename": "clippy_lints/src/if_let_redundant_pattern_matching.rs", "status": "modified", "additions": 156, "deletions": 36, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/3b7c88888bb9b01eb9ca8f40f59b48006462f2b5/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b7c88888bb9b01eb9ca8f40f59b48006462f2b5/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs?ref=3b7c88888bb9b01eb9ca8f40f59b48006462f2b5", "patch": "@@ -11,6 +11,8 @@\n use crate::rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use crate::rustc::{declare_tool_lint, lint_array};\n use crate::rustc::hir::*;\n+use crate::syntax::ptr::P;\n+use crate::syntax::ast::LitKind;\n use crate::utils::{match_qpath, paths, snippet, span_lint_and_then};\n use crate::rustc_errors::Applicability;\n \n@@ -58,46 +60,164 @@ impl LintPass for Pass {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     #[allow(clippy::similar_names)]\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprKind::Match(ref op, ref arms, MatchSource::IfLetDesugar { .. }) = expr.node {\n-            if arms[0].pats.len() == 1 {\n-                let good_method = match arms[0].pats[0].node {\n-                    PatKind::TupleStruct(ref path, ref pats, _) if pats.len() == 1 => {\n-                        if let PatKind::Wild = pats[0].node {\n-                            if match_qpath(path, &paths::RESULT_OK) {\n-                                \"is_ok()\"\n-                            } else if match_qpath(path, &paths::RESULT_ERR) {\n-                                \"is_err()\"\n-                            } else if match_qpath(path, &paths::OPTION_SOME) {\n-                                \"is_some()\"\n-                            } else {\n-                                return;\n-                            }\n-                        } else {\n-                            return;\n-                        }\n-                    },\n+        if let ExprKind::Match(ref op, ref arms, ref match_source) = expr.node {\n+            match match_source {\n+                MatchSource::Normal => find_sugg_for_match(cx, expr, op, arms),\n+                MatchSource::IfLetDesugar { .. } => find_sugg_for_if_let(cx, expr, op, arms),\n+                _ => return,\n+            }\n+        }\n+    }\n+}\n \n-                    PatKind::Path(ref path) if match_qpath(path, &paths::OPTION_NONE) => \"is_none()\",\n+fn find_sugg_for_if_let<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    expr: &'tcx Expr,\n+    op: &P<Expr>,\n+    arms: &HirVec<Arm>\n+) {\n+    if arms[0].pats.len() == 1 {\n+        let good_method = match arms[0].pats[0].node {\n+            PatKind::TupleStruct(ref path, ref pats, _) if pats.len() == 1 => {\n+                if let PatKind::Wild = pats[0].node {\n+                    if match_qpath(path, &paths::RESULT_OK) {\n+                        \"is_ok()\"\n+                    } else if match_qpath(path, &paths::RESULT_ERR) {\n+                        \"is_err()\"\n+                    } else if match_qpath(path, &paths::OPTION_SOME) {\n+                        \"is_some()\"\n+                    } else {\n+                        return;\n+                    }\n+                } else {\n+                    return;\n+                }\n+            },\n \n-                    _ => return,\n-                };\n+            PatKind::Path(ref path) if match_qpath(path, &paths::OPTION_NONE) => \"is_none()\",\n \n-                span_lint_and_then(\n-                    cx,\n-                    IF_LET_REDUNDANT_PATTERN_MATCHING,\n-                    arms[0].pats[0].span,\n-                    &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n-                    |db| {\n-                        let span = expr.span.to(op.span);\n-                        db.span_suggestion_with_applicability(\n-                            span,\n-                            \"try this\",\n-                            format!(\"if {}.{}\", snippet(cx, op.span, \"_\"), good_method),\n-                            Applicability::MachineApplicable, // snippet\n-                        );\n-                    },\n+            _ => return,\n+        };\n+\n+        span_lint_and_then(\n+            cx,\n+            IF_LET_REDUNDANT_PATTERN_MATCHING,\n+            arms[0].pats[0].span,\n+            &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n+            |db| {\n+                let span = expr.span.to(op.span);\n+                db.span_suggestion_with_applicability(\n+                    span,\n+                    \"try this\",\n+                    format!(\"if {}.{}\", snippet(cx, op.span, \"_\"), good_method),\n+                    Applicability::MachineApplicable, // snippet\n                 );\n-            }\n+            },\n+        );\n+    } else {\n+        return;\n+    }\n+}\n+\n+fn find_sugg_for_match<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    expr: &'tcx Expr,\n+    op: &P<Expr>,\n+    arms: &HirVec<Arm>\n+) {\n+    if arms.len() == 2 {\n+        let node_pair = (&arms[0].pats[0].node, &arms[1].pats[0].node);\n+\n+        let found_good_method = match node_pair {\n+            (\n+                PatKind::TupleStruct(ref path_left, ref pats_left, _),\n+                PatKind::TupleStruct(ref path_right, ref pats_right, _)\n+            ) if pats_left.len() == 1 && pats_right.len() == 1 => {\n+                if let (PatKind::Wild, PatKind::Wild) = (&pats_left[0].node, &pats_right[0].node) {\n+                    find_good_method_for_match(\n+                        arms,\n+                        path_left,\n+                        path_right,\n+                        &paths::RESULT_OK,\n+                        &paths::RESULT_ERR,\n+                        \"is_ok()\",\n+                        \"is_err()\"\n+                    )\n+                } else {\n+                    None\n+                }\n+            },\n+            (\n+                PatKind::TupleStruct(ref path_left, ref pats, _),\n+                PatKind::Path(ref path_right)\n+            ) | (\n+                PatKind::Path(ref path_left),\n+                PatKind::TupleStruct(ref path_right, ref pats, _)\n+            ) if pats.len() == 1 => {\n+                if let PatKind::Wild = pats[0].node {\n+                    find_good_method_for_match(\n+                        arms,\n+                        path_left,\n+                        path_right,\n+                        &paths::OPTION_SOME,\n+                        &paths::OPTION_NONE,\n+                        \"is_some()\",\n+                        \"is_none()\"\n+                    )\n+                } else {\n+                    None\n+                }\n+            },\n+            _ => None,\n+        };\n+\n+        if let Some(good_method) = found_good_method {\n+            span_lint_and_then(\n+                cx,\n+                IF_LET_REDUNDANT_PATTERN_MATCHING,\n+                expr.span,\n+                &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n+                |db| {\n+                    let span = expr.span.to(op.span);\n+                    db.span_suggestion_with_applicability(\n+                        span,\n+                        \"try this\",\n+                        format!(\"{}.{}\", snippet(cx, op.span, \"_\"), good_method),\n+                        Applicability::MachineApplicable, // snippet\n+                    );\n+                },\n+            );\n         }\n+    } else {\n+        return;\n+    }\n+}\n+\n+fn find_good_method_for_match<'a>(\n+    arms: &HirVec<Arm>,\n+    path_left: &QPath,\n+    path_right: &QPath,\n+    expected_left: &[&str],\n+    expected_right: &[&str],\n+    should_be_left: &'a str,\n+    should_be_right: &'a str\n+) -> Option<&'a str> {\n+    let body_node_pair = if match_qpath(path_left, expected_left) && match_qpath(path_right, expected_right) {\n+        (&(*arms[0].body).node, &(*arms[1].body).node)\n+    } else if match_qpath(path_right, expected_left) && match_qpath(path_left, expected_right) {\n+        (&(*arms[1].body).node, &(*arms[0].body).node)\n+    } else {\n+        return None;\n+    };\n+\n+    match body_node_pair {\n+        (ExprKind::Lit(ref lit_left), ExprKind::Lit(ref lit_right)) => {\n+            match (&lit_left.node, &lit_right.node) {\n+                (LitKind::Bool(true), LitKind::Bool(false)) => Some(should_be_left),\n+                (LitKind::Bool(false), LitKind::Bool(true)) => Some(should_be_right),\n+                _ => None,\n+            }\n+        },\n+        _ => None,\n     }\n }"}, {"sha": "3f7d0c8e1bda76c4ba90b34d46e92be6afe95699", "filename": "tests/ui/if_let_redundant_pattern_matching.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3b7c88888bb9b01eb9ca8f40f59b48006462f2b5/tests%2Fui%2Fif_let_redundant_pattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b7c88888bb9b01eb9ca8f40f59b48006462f2b5/tests%2Fui%2Fif_let_redundant_pattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_let_redundant_pattern_matching.rs?ref=3b7c88888bb9b01eb9ca8f40f59b48006462f2b5", "patch": "@@ -42,4 +42,34 @@ fn main() {\n     if let Ok(x) = Ok::<i32,i32>(42) {\n         println!(\"{}\", x);\n     }\n+\n+    match Ok::<i32, i32>(42) {\n+        Ok(_) => true,\n+        Err(_) => false,\n+    };\n+\n+    match Ok::<i32, i32>(42) {\n+        Ok(_) => false,\n+        Err(_) => true,\n+    };\n+\n+    match Err::<i32, i32>(42) {\n+        Ok(_) => false,\n+        Err(_) => true,\n+    };\n+\n+    match Err::<i32, i32>(42) {\n+        Ok(_) => true,\n+        Err(_) => false,\n+    };\n+\n+    match Some(42) {\n+        Some(_) => true,\n+        None => false,\n+    };\n+\n+    match None::<()> {\n+        Some(_) => false,\n+        None => true,\n+    };\n }"}, {"sha": "93bafa7fcbd5bf7793e205e837c2882852ddee5b", "filename": "tests/ui/if_let_redundant_pattern_matching.stderr", "status": "modified", "additions": 55, "deletions": 1, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3b7c88888bb9b01eb9ca8f40f59b48006462f2b5/tests%2Fui%2Fif_let_redundant_pattern_matching.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3b7c88888bb9b01eb9ca8f40f59b48006462f2b5/tests%2Fui%2Fif_let_redundant_pattern_matching.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_let_redundant_pattern_matching.stderr?ref=3b7c88888bb9b01eb9ca8f40f59b48006462f2b5", "patch": "@@ -30,5 +30,59 @@ error: redundant pattern matching, consider using `is_some()`\n 28 | |     }\n    | |_____- help: try this: `if Some(42).is_some()`\n \n-error: aborting due to 4 previous errors\n+error: redundant pattern matching, consider using `is_ok()`\n+  --> $DIR/if_let_redundant_pattern_matching.rs:46:5\n+   |\n+46 | /     match Ok::<i32, i32>(42) {\n+47 | |         Ok(_) => true,\n+48 | |         Err(_) => false,\n+49 | |     };\n+   | |_____^ help: try this: `Ok::<i32, i32>(42).is_ok()`\n+\n+error: redundant pattern matching, consider using `is_err()`\n+  --> $DIR/if_let_redundant_pattern_matching.rs:51:5\n+   |\n+51 | /     match Ok::<i32, i32>(42) {\n+52 | |         Ok(_) => false,\n+53 | |         Err(_) => true,\n+54 | |     };\n+   | |_____^ help: try this: `Ok::<i32, i32>(42).is_err()`\n+\n+error: redundant pattern matching, consider using `is_err()`\n+  --> $DIR/if_let_redundant_pattern_matching.rs:56:5\n+   |\n+56 | /     match Err::<i32, i32>(42) {\n+57 | |         Ok(_) => false,\n+58 | |         Err(_) => true,\n+59 | |     };\n+   | |_____^ help: try this: `Err::<i32, i32>(42).is_err()`\n+\n+error: redundant pattern matching, consider using `is_ok()`\n+  --> $DIR/if_let_redundant_pattern_matching.rs:61:5\n+   |\n+61 | /     match Err::<i32, i32>(42) {\n+62 | |         Ok(_) => true,\n+63 | |         Err(_) => false,\n+64 | |     };\n+   | |_____^ help: try this: `Err::<i32, i32>(42).is_ok()`\n+\n+error: redundant pattern matching, consider using `is_some()`\n+  --> $DIR/if_let_redundant_pattern_matching.rs:66:5\n+   |\n+66 | /     match Some(42) {\n+67 | |         Some(_) => true,\n+68 | |         None => false,\n+69 | |     };\n+   | |_____^ help: try this: `Some(42).is_some()`\n+\n+error: redundant pattern matching, consider using `is_none()`\n+  --> $DIR/if_let_redundant_pattern_matching.rs:71:5\n+   |\n+71 | /     match None::<()> {\n+72 | |         Some(_) => false,\n+73 | |         None => true,\n+74 | |     };\n+   | |_____^ help: try this: `None::<()>.is_none()`\n+\n+error: aborting due to 10 previous errors\n "}]}