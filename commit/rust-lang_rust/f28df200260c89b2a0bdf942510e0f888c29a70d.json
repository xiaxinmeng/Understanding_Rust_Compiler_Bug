{"sha": "f28df200260c89b2a0bdf942510e0f888c29a70d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyOGRmMjAwMjYwYzg5YjJhMGJkZjk0MjUxMGUwZjg4OGMyOWE3MGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-21T12:32:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-21T12:32:59Z"}, "message": "Auto merge of #45771 - petrochenkov:crate, r=nikomatsakis\n\nSupport `::crate` in paths\n\ncc https://github.com/rust-lang/rust/issues/45477\nFixes https://github.com/rust-lang/rust/issues/45229", "tree": {"sha": "731a918787dcc36a4ce994d5a79626d59b61ee13", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/731a918787dcc36a4ce994d5a79626d59b61ee13"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f28df200260c89b2a0bdf942510e0f888c29a70d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f28df200260c89b2a0bdf942510e0f888c29a70d", "html_url": "https://github.com/rust-lang/rust/commit/f28df200260c89b2a0bdf942510e0f888c29a70d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f28df200260c89b2a0bdf942510e0f888c29a70d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ebda7662dbb79ab0a9feb79d367d0818c23ff1dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/ebda7662dbb79ab0a9feb79d367d0818c23ff1dc", "html_url": "https://github.com/rust-lang/rust/commit/ebda7662dbb79ab0a9feb79d367d0818c23ff1dc"}, {"sha": "90f5cfdfbd3c9e39f897fd2271c7b1c7fdaae58e", "url": "https://api.github.com/repos/rust-lang/rust/commits/90f5cfdfbd3c9e39f897fd2271c7b1c7fdaae58e", "html_url": "https://github.com/rust-lang/rust/commit/90f5cfdfbd3c9e39f897fd2271c7b1c7fdaae58e"}], "stats": {"total": 236, "additions": 187, "deletions": 49}, "files": [{"sha": "3136aeaf8ca1ffd69dd3570d54d1590fecc89395", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f28df200260c89b2a0bdf942510e0f888c29a70d/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f28df200260c89b2a0bdf942510e0f888c29a70d/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=f28df200260c89b2a0bdf942510e0f888c29a70d", "patch": "@@ -21,7 +21,6 @@ use rustc::session::Session;\n use syntax::ast::*;\n use syntax::attr;\n use syntax::codemap::Spanned;\n-use syntax::parse::token;\n use syntax::symbol::keywords;\n use syntax::visit::{self, Visitor};\n use syntax_pos::Span;\n@@ -182,18 +181,6 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         visit::walk_ty(self, ty)\n     }\n \n-    fn visit_path(&mut self, path: &'a Path, _: NodeId) {\n-        if path.segments.len() >= 2 && path.is_global() {\n-            let ident = path.segments[1].identifier;\n-            if token::Ident(ident).is_path_segment_keyword() {\n-                self.err_handler()\n-                    .span_err(path.span, &format!(\"global paths cannot start with `{}`\", ident));\n-            }\n-        }\n-\n-        visit::walk_path(self, path)\n-    }\n-\n     fn visit_item(&mut self, item: &'a Item) {\n         match item.node {\n             ItemKind::Use(ref view_path) => {"}, {"sha": "46513a5740aede76ac59469faa3426aeef7b2bfb", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f28df200260c89b2a0bdf942510e0f888c29a70d/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f28df200260c89b2a0bdf942510e0f888c29a70d/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=f28df200260c89b2a0bdf942510e0f888c29a70d", "patch": "@@ -114,7 +114,7 @@ impl<'a> Resolver<'a> {\n                 // Extract and intern the module part of the path. For\n                 // globs and lists, the path is found directly in the AST;\n                 // for simple paths we have to munge the path a little.\n-                let mut module_path: Vec<_> = match view_path.node {\n+                let module_path: Vec<_> = match view_path.node {\n                     ViewPathSimple(_, ref full_path) => {\n                         full_path.segments\n                                  .split_last()\n@@ -134,14 +134,6 @@ impl<'a> Resolver<'a> {\n                     }\n                 };\n \n-                // This can be removed once warning cycle #36888 is complete.\n-                if module_path.len() >= 2 &&\n-                    module_path[0].node.name == keywords::CrateRoot.name() &&\n-                    token::Ident(module_path[1].node).is_path_segment_keyword()\n-                {\n-                    module_path.remove(0);\n-                }\n-\n                 // Build up the import directives.\n                 let is_prelude = attr::contains_name(&item.attrs, \"prelude_import\");\n "}, {"sha": "42c31a6e47eaa714dbf5796318632382dc0c8d86", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 39, "deletions": 9, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f28df200260c89b2a0bdf942510e0f888c29a70d/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f28df200260c89b2a0bdf942510e0f888c29a70d/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=f28df200260c89b2a0bdf942510e0f888c29a70d", "patch": "@@ -2865,12 +2865,13 @@ impl<'a> Resolver<'a> {\n             debug!(\"resolve_path ident {} {:?}\", i, ident);\n             let is_last = i == path.len() - 1;\n             let ns = if is_last { opt_ns.unwrap_or(TypeNS) } else { TypeNS };\n+            let name = ident.node.name;\n \n-            if i == 0 && ns == TypeNS && ident.node.name == keywords::SelfValue.name() {\n+            if i == 0 && ns == TypeNS && name == keywords::SelfValue.name() {\n                 let mut ctxt = ident.node.ctxt.modern();\n                 module = Some(self.resolve_self(&mut ctxt, self.current_module));\n                 continue\n-            } else if allow_super && ns == TypeNS && ident.node.name == keywords::Super.name() {\n+            } else if allow_super && ns == TypeNS && name == keywords::Super.name() {\n                 let mut ctxt = ident.node.ctxt.modern();\n                 let self_module = match i {\n                     0 => self.resolve_self(&mut ctxt, self.current_module),\n@@ -2886,12 +2887,41 @@ impl<'a> Resolver<'a> {\n             }\n             allow_super = false;\n \n-            if i == 0 && ns == TypeNS && ident.node.name == keywords::CrateRoot.name() {\n-                module = Some(self.resolve_crate_root(ident.node.ctxt.modern()));\n-                continue\n-            } else if i == 0 && ns == TypeNS && ident.node.name == keywords::DollarCrate.name() {\n-                module = Some(self.resolve_crate_root(ident.node.ctxt));\n-                continue\n+            if ns == TypeNS {\n+                if (i == 0 && name == keywords::CrateRoot.name()) ||\n+                   (i == 1 && name == keywords::Crate.name() &&\n+                              path[0].node.name == keywords::CrateRoot.name()) {\n+                    // `::a::b` or `::crate::a::b`\n+                    module = Some(self.resolve_crate_root(ident.node.ctxt.modern()));\n+                    continue\n+                } else if i == 0 && name == keywords::DollarCrate.name() {\n+                    // `$crate::a::b`\n+                    module = Some(self.resolve_crate_root(ident.node.ctxt));\n+                    continue\n+                }\n+            }\n+\n+            // Report special messages for path segment keywords in wrong positions.\n+            if name == keywords::CrateRoot.name() && i != 0 ||\n+               name == keywords::DollarCrate.name() && i != 0 ||\n+               name == keywords::SelfValue.name() && i != 0 ||\n+               name == keywords::SelfType.name() && i != 0 ||\n+               name == keywords::Super.name() && i != 0 ||\n+               name == keywords::Crate.name() && i != 1 &&\n+                    path[0].node.name != keywords::CrateRoot.name() {\n+                let name_str = if name == keywords::CrateRoot.name() {\n+                    format!(\"crate root\")\n+                } else {\n+                    format!(\"`{}`\", name)\n+                };\n+                let msg = if i == 1 && path[0].node.name == keywords::CrateRoot.name() {\n+                    format!(\"global paths cannot start with {}\", name_str)\n+                } else if i == 0 && name == keywords::Crate.name() {\n+                    format!(\"{} can only be used in absolute paths\", name_str)\n+                } else {\n+                    format!(\"{} in paths can only be used in start position\", name_str)\n+                };\n+                return PathResult::Failed(ident.span, msg, false);\n             }\n \n             let binding = if let Some(module) = module {\n@@ -2942,7 +2972,7 @@ impl<'a> Resolver<'a> {\n                     let msg = if module.and_then(ModuleData::def) == self.graph_root.def() {\n                         let is_mod = |def| match def { Def::Mod(..) => true, _ => false };\n                         let mut candidates =\n-                            self.lookup_import_candidates(ident.node.name, TypeNS, is_mod);\n+                            self.lookup_import_candidates(name, TypeNS, is_mod);\n                         candidates.sort_by_key(|c| (c.path.segments.len(), c.path.to_string()));\n                         if let Some(candidate) = candidates.get(0) {\n                             format!(\"Did you mean `{}`?\", candidate.path)"}, {"sha": "d72253e5a8a48fc432108f2675c837b278cdaa87", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f28df200260c89b2a0bdf942510e0f888c29a70d/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f28df200260c89b2a0bdf942510e0f888c29a70d/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=f28df200260c89b2a0bdf942510e0f888c29a70d", "patch": "@@ -606,10 +606,16 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         let module_result = self.resolve_path(&module_path, None, true, span);\n         let module = match module_result {\n             PathResult::Module(module) => module,\n-            PathResult::Failed(span, msg, _) => {\n+            PathResult::Failed(span, msg, false) => {\n+                resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n+                return None;\n+            }\n+            PathResult::Failed(span, msg, true) => {\n                 let (mut self_path, mut self_result) = (module_path.clone(), None);\n                 if !self_path.is_empty() &&\n-                    !token::Ident(self_path[0].node).is_path_segment_keyword()\n+                    !token::Ident(self_path[0].node).is_path_segment_keyword() &&\n+                    !(self_path.len() > 1 &&\n+                      token::Ident(self_path[1].node).is_path_segment_keyword())\n                 {\n                     self_path[0].node.name = keywords::SelfValue.name();\n                     self_result = Some(self.resolve_path(&self_path, None, false, span));"}, {"sha": "ad9d58651207dce71d38c192c27c3339bbe056f6", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f28df200260c89b2a0bdf942510e0f888c29a70d/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f28df200260c89b2a0bdf942510e0f888c29a70d/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=f28df200260c89b2a0bdf942510e0f888c29a70d", "patch": "@@ -96,10 +96,15 @@ impl Path {\n         }\n     }\n \n+    // Add starting \"crate root\" segment to all paths except those that\n+    // already have it or start with `self`, `super`, `Self` or `$crate`.\n     pub fn default_to_global(mut self) -> Path {\n-        if !self.is_global() &&\n-           !::parse::token::Ident(self.segments[0].identifier).is_path_segment_keyword() {\n-            self.segments.insert(0, PathSegment::crate_root(self.span));\n+        if !self.is_global() {\n+            let ident = self.segments[0].identifier;\n+            if !::parse::token::Ident(ident).is_path_segment_keyword() ||\n+               ident.name == keywords::Crate.name() {\n+                self.segments.insert(0, PathSegment::crate_root(self.span));\n+            }\n         }\n         self\n     }"}, {"sha": "036c941499048d4aa1e743ef5cc0d5d2ddb4abca", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f28df200260c89b2a0bdf942510e0f888c29a70d/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f28df200260c89b2a0bdf942510e0f888c29a70d/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=f28df200260c89b2a0bdf942510e0f888c29a70d", "patch": "@@ -33,7 +33,7 @@ use syntax_pos::Span;\n use errors::{DiagnosticBuilder, Handler, FatalError};\n use visit::{self, FnKind, Visitor};\n use parse::ParseSess;\n-use symbol::Symbol;\n+use symbol::{keywords, Symbol};\n \n use std::env;\n \n@@ -420,6 +420,9 @@ declare_features! (\n \n     // #![wasm_import_memory] attribute\n     (active, wasm_import_memory, \"1.22.0\", None),\n+\n+    // `crate` in paths\n+    (active, crate_in_paths, \"1.23.0\", Some(45477)),\n );\n \n declare_features! (\n@@ -1634,6 +1637,17 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         visit::walk_impl_item(self, ii);\n     }\n \n+    fn visit_path(&mut self, path: &'a ast::Path, _id: NodeId) {\n+        for segment in &path.segments {\n+            if segment.identifier.name == keywords::Crate.name() {\n+                gate_feature_post!(&self, crate_in_paths, segment.span,\n+                                   \"`crate` in paths is experimental\");\n+            }\n+        }\n+\n+        visit::walk_path(self, path);\n+    }\n+\n     fn visit_vis(&mut self, vis: &'a ast::Visibility) {\n         if let ast::Visibility::Crate(span, ast::CrateSugar::JustCrate) = *vis {\n             gate_feature_post!(&self, crate_visibility_modifier, span,"}, {"sha": "0b03429ea2e522848d499b86477526c17ceaf25a", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f28df200260c89b2a0bdf942510e0f888c29a70d/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f28df200260c89b2a0bdf942510e0f888c29a70d/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=f28df200260c89b2a0bdf942510e0f888c29a70d", "patch": "@@ -3916,6 +3916,10 @@ impl<'a> Parser<'a> {\n         self.look_ahead(1, |t| t.is_ident() && !t.is_reserved_ident())\n     }\n \n+    fn is_crate_vis(&self) -> bool {\n+        self.token.is_keyword(keywords::Crate) && self.look_ahead(1, |t| t != &token::ModSep)\n+    }\n+\n     fn eat_auto_trait(&mut self) -> bool {\n         if self.token.is_keyword(keywords::Auto)\n             && self.look_ahead(1, |t| t.is_keyword(keywords::Trait))\n@@ -4026,10 +4030,15 @@ impl<'a> Parser<'a> {\n                 node: StmtKind::Item(macro_def),\n                 span: lo.to(self.prev_span),\n             }\n-        // Starts like a simple path, but not a union item.\n+        // Starts like a simple path, but not a union item or item with `crate` visibility.\n+        // Our goal here is to parse an arbitrary path `a::b::c` but not something that starts\n+        // like a path (1 token), but it fact not a path.\n+        // `union::b::c` - path, `union U { ... }` - not a path.\n+        // `crate::b::c` - path, `crate struct S;` - not a path.\n         } else if self.token.is_path_start() &&\n                   !self.token.is_qpath_start() &&\n-                  !self.is_union_item() {\n+                  !self.is_union_item() &&\n+                  !self.is_crate_vis() {\n             let pth = self.parse_path(PathStyle::Expr)?;\n \n             if !self.eat(&token::Not) {\n@@ -5399,7 +5408,9 @@ impl<'a> Parser<'a> {\n     pub fn parse_visibility(&mut self, can_take_tuple: bool) -> PResult<'a, Visibility> {\n         maybe_whole!(self, NtVis, |x| x);\n \n-        if self.eat_keyword(keywords::Crate) {\n+        self.expected_tokens.push(TokenType::Keyword(keywords::Crate));\n+        if self.is_crate_vis() {\n+            self.bump(); // `crate`\n             return Ok(Visibility::Crate(self.prev_span, CrateSugar::JustCrate));\n         }\n "}, {"sha": "ff87f146c0a71616dd2b818f3b03556838aef2b8", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f28df200260c89b2a0bdf942510e0f888c29a70d/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f28df200260c89b2a0bdf942510e0f888c29a70d/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=f28df200260c89b2a0bdf942510e0f888c29a70d", "patch": "@@ -347,6 +347,7 @@ impl Token {\n             Some(id) => id.name == keywords::Super.name() ||\n                         id.name == keywords::SelfValue.name() ||\n                         id.name == keywords::SelfType.name() ||\n+                        id.name == keywords::Crate.name() ||\n                         id.name == keywords::DollarCrate.name(),\n             None => false,\n         }"}, {"sha": "87a29038035815b7934827045e9a2eb81dc8a96f", "filename": "src/test/compile-fail/dollar-crate-is-keyword-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f28df200260c89b2a0bdf942510e0f888c29a70d/src%2Ftest%2Fcompile-fail%2Fdollar-crate-is-keyword-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f28df200260c89b2a0bdf942510e0f888c29a70d/src%2Ftest%2Fcompile-fail%2Fdollar-crate-is-keyword-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdollar-crate-is-keyword-2.rs?ref=f28df200260c89b2a0bdf942510e0f888c29a70d", "patch": "@@ -13,8 +13,8 @@ mod a {}\n macro_rules! m {\n     () => {\n         use a::$crate; //~ ERROR unresolved import `a::$crate`\n-        use a::$crate::b; //~ ERROR unresolved import `a::$crate`\n-        type A = a::$crate; //~ ERROR cannot find type `$crate` in module `a`\n+        use a::$crate::b; //~ ERROR `$crate` in paths can only be used in start position\n+        type A = a::$crate; //~ ERROR `$crate` in paths can only be used in start position\n     }\n }\n "}, {"sha": "75c2a5f5bc4776cf463cb346ae56bfb624413af7", "filename": "src/test/compile-fail/rfc-2126-crate-paths/crate-path-non-absolute.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f28df200260c89b2a0bdf942510e0f888c29a70d/src%2Ftest%2Fcompile-fail%2Frfc-2126-crate-paths%2Fcrate-path-non-absolute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f28df200260c89b2a0bdf942510e0f888c29a70d/src%2Ftest%2Fcompile-fail%2Frfc-2126-crate-paths%2Fcrate-path-non-absolute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frfc-2126-crate-paths%2Fcrate-path-non-absolute.rs?ref=f28df200260c89b2a0bdf942510e0f888c29a70d", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(crate_in_paths)]\n+\n+struct S;\n+\n+mod m {\n+    fn f() {\n+        let s = crate::S; //~ ERROR `crate` can only be used in absolute paths\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "8c5a971c2f756b3e32c7dad30b8581167d22d1fa", "filename": "src/test/compile-fail/rfc-2126-crate-paths/crate-visibility-ambiguity.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f28df200260c89b2a0bdf942510e0f888c29a70d/src%2Ftest%2Fcompile-fail%2Frfc-2126-crate-paths%2Fcrate-visibility-ambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f28df200260c89b2a0bdf942510e0f888c29a70d/src%2Ftest%2Fcompile-fail%2Frfc-2126-crate-paths%2Fcrate-visibility-ambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frfc-2126-crate-paths%2Fcrate-visibility-ambiguity.rs?ref=f28df200260c89b2a0bdf942510e0f888c29a70d", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(crate_in_paths)]\n+#![feature(crate_visibility_modifier)]\n+\n+mod m {\n+    pub struct Z;\n+    pub struct S1(crate (::m::Z)); // OK\n+    pub struct S2(::crate ::m::Z); // OK\n+    pub struct S3(crate ::m::Z); //~ ERROR `crate` can only be used in absolute paths\n+}\n+\n+fn main() {\n+    crate struct S; // OK (item in statement position)\n+}"}, {"sha": "830ec5959b7027e18476d98996c551ba8f1bfa7d", "filename": "src/test/compile-fail/rfc-2126-crate-paths/feature-gate-crate_in_paths.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f28df200260c89b2a0bdf942510e0f888c29a70d/src%2Ftest%2Fcompile-fail%2Frfc-2126-crate-paths%2Ffeature-gate-crate_in_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f28df200260c89b2a0bdf942510e0f888c29a70d/src%2Ftest%2Fcompile-fail%2Frfc-2126-crate-paths%2Ffeature-gate-crate_in_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frfc-2126-crate-paths%2Ffeature-gate-crate_in_paths.rs?ref=f28df200260c89b2a0bdf942510e0f888c29a70d", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct S;\n+\n+fn main() {\n+    let _ = ::crate::S; //~ ERROR `crate` in paths is experimental\n+}"}, {"sha": "2c94f7b0f59df0e28e7e44d701f1d2471f7e165f", "filename": "src/test/compile-fail/rfc-2126-crate-paths/keyword-crate-as-identifier.rs", "status": "renamed", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f28df200260c89b2a0bdf942510e0f888c29a70d/src%2Ftest%2Fcompile-fail%2Frfc-2126-crate-paths%2Fkeyword-crate-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f28df200260c89b2a0bdf942510e0f888c29a70d/src%2Ftest%2Fcompile-fail%2Frfc-2126-crate-paths%2Fkeyword-crate-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frfc-2126-crate-paths%2Fkeyword-crate-as-identifier.rs?ref=f28df200260c89b2a0bdf942510e0f888c29a70d", "patch": "@@ -8,10 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z parse-only\n-\n-// This file was auto-generated using 'src/etc/generate-keyword-tests.py crate'\n+#![feature(crate_in_paths)]\n \n fn main() {\n-    let crate = \"foo\"; //~ error: expected pattern, found keyword `crate`\n+    let crate = 0; //~ ERROR `crate` can only be used in absolute paths\n }", "previous_filename": "src/test/parse-fail/keyword-crate-as-identifier.rs"}, {"sha": "c607711c44f37ba035d16905a71ddd41f9b59a0d", "filename": "src/test/compile-fail/super-at-top-level.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f28df200260c89b2a0bdf942510e0f888c29a70d/src%2Ftest%2Fcompile-fail%2Fsuper-at-top-level.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f28df200260c89b2a0bdf942510e0f888c29a70d/src%2Ftest%2Fcompile-fail%2Fsuper-at-top-level.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsuper-at-top-level.rs?ref=f28df200260c89b2a0bdf942510e0f888c29a70d", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::f; //~ ERROR unresolved import `super` [E0432]\n-              //~^ There are too many initial `super`s.\n+use super::f; //~ ERROR There are too many initial `super`s\n \n fn main() {\n }"}, {"sha": "fc1a72f6f2b90ea9b0d0fc611ba61d2ed6f6c1df", "filename": "src/test/compile-fail/use-super-global-path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f28df200260c89b2a0bdf942510e0f888c29a70d/src%2Ftest%2Fcompile-fail%2Fuse-super-global-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f28df200260c89b2a0bdf942510e0f888c29a70d/src%2Ftest%2Fcompile-fail%2Fuse-super-global-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-super-global-path.rs?ref=f28df200260c89b2a0bdf942510e0f888c29a70d", "patch": "@@ -18,7 +18,7 @@ mod foo {\n \n     pub fn g() {\n         use ::super::main; //~ ERROR global paths cannot start with `super`\n-        main();\n+        main(); //~ ERROR cannot find function `main` in this scope\n     }\n }\n "}, {"sha": "172c34e79d233cb3102590f6fe6f326df570ddb4", "filename": "src/test/run-pass/rfc-2126-crate-paths/crate-path-absolute.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f28df200260c89b2a0bdf942510e0f888c29a70d/src%2Ftest%2Frun-pass%2Frfc-2126-crate-paths%2Fcrate-path-absolute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f28df200260c89b2a0bdf942510e0f888c29a70d/src%2Ftest%2Frun-pass%2Frfc-2126-crate-paths%2Fcrate-path-absolute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc-2126-crate-paths%2Fcrate-path-absolute.rs?ref=f28df200260c89b2a0bdf942510e0f888c29a70d", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(crate_in_paths)]\n+\n+use crate::m::f;\n+\n+mod m {\n+    pub fn f() -> u8 { 1 }\n+    pub fn g() -> u8 { 2 }\n+\n+    // OK, visibilities are implicitly absolute like imports\n+    pub(in crate::m) struct S;\n+}\n+\n+mod n\n+{\n+    use crate::m::f;\n+    pub fn check() {\n+        assert_eq!(f(), 1);\n+        assert_eq!(::crate::m::g(), 2);\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(f(), 1);\n+    assert_eq!(::crate::m::g(), 2);\n+    n::check();\n+}"}]}