{"sha": "875c9ce30b13de02e447ee95cb50b0111894b14a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3NWM5Y2UzMGIxM2RlMDJlNDQ3ZWU5NWNiNTBiMDExMTg5NGIxNGE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-01-31T23:26:59Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-02-01T14:44:49Z"}, "message": "libsyntax: Remove many uses of `token::ident_to_str`", "tree": {"sha": "6d077b61bace996721128faeee4de8e3236c808a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d077b61bace996721128faeee4de8e3236c808a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/875c9ce30b13de02e447ee95cb50b0111894b14a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/875c9ce30b13de02e447ee95cb50b0111894b14a", "html_url": "https://github.com/rust-lang/rust/commit/875c9ce30b13de02e447ee95cb50b0111894b14a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/875c9ce30b13de02e447ee95cb50b0111894b14a/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e534b565e6f101f6ec544f821dec116fed286f3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e534b565e6f101f6ec544f821dec116fed286f3b", "html_url": "https://github.com/rust-lang/rust/commit/e534b565e6f101f6ec544f821dec116fed286f3b"}], "stats": {"total": 76, "additions": 49, "deletions": 27}, "files": [{"sha": "f7419e77ff595a40fd25806714bfef7595b3a434", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/875c9ce30b13de02e447ee95cb50b0111894b14a/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/875c9ce30b13de02e447ee95cb50b0111894b14a/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=875c9ce30b13de02e447ee95cb50b0111894b14a", "patch": "@@ -22,8 +22,8 @@ use codemap::{Span, Spanned, ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n use ext::base::*;\n use fold::*;\n use parse;\n+use parse::token::{fresh_mark, fresh_name, intern};\n use parse::token;\n-use parse::token::{fresh_mark, fresh_name, ident_to_str, intern};\n use visit;\n use visit::Visitor;\n use util::small_vector::SmallVector;\n@@ -310,11 +310,12 @@ pub fn expand_item_mac(it: @ast::Item, fld: &mut MacroExpander)\n \n         Some(&NormalTT(ref expander, span)) => {\n             if it.ident.name != parse::token::special_idents::invalid.name {\n+                let string = token::get_ident(it.ident.name);\n                 fld.cx.span_err(pth.span,\n                                 format!(\"macro {}! expects no ident argument, \\\n                                         given '{}'\",\n                                         extnamestr.get(),\n-                                        ident_to_str(&it.ident)));\n+                                        string.get()));\n                 return SmallVector::zero();\n             }\n             fld.cx.bt_push(ExpnInfo {\n@@ -411,7 +412,10 @@ fn load_extern_macros(crate: &ast::ViewItem, fld: &mut MacroExpander) {\n     let MacroCrate { lib, cnum } = fld.cx.loader.load_crate(crate);\n \n     let crate_name = match crate.node {\n-        ast::ViewItemExternMod(ref name, _, _) => token::ident_to_str(name),\n+        ast::ViewItemExternMod(ref name, _, _) => {\n+            let string = token::get_ident(name.name);\n+            string.get().to_str()\n+        },\n         _ => unreachable!(),\n     };\n     let name = format!(\"<{} macros>\", crate_name);\n@@ -957,7 +961,7 @@ mod test {\n     use fold::*;\n     use ext::base::{CrateLoader, MacroCrate};\n     use parse;\n-    use parse::token::{fresh_mark, gensym, intern, ident_to_str};\n+    use parse::token::{fresh_mark, gensym, intern};\n     use parse::token;\n     use util::parser_testing::{string_to_crate, string_to_crate_and_sess};\n     use util::parser_testing::{string_to_pat, string_to_tts, strs_to_idents};\n@@ -1272,9 +1276,12 @@ mod test {\n                         println!(\"uh oh, matches but shouldn't:\");\n                         println!(\"varref: {:?}\",varref);\n                         // good lord, you can't make a path with 0 segments, can you?\n+                        let string = token::get_ident(varref.segments[0]\n+                                                            .identifier\n+                                                            .name);\n                         println!(\"varref's first segment's uint: {}, and string: \\\"{}\\\"\",\n                                  varref.segments[0].identifier.name,\n-                                 ident_to_str(&varref.segments[0].identifier));\n+                                 string.get());\n                         println!(\"binding: {:?}\", bindings[binding_idx]);\n                         ast_util::display_sctable(get_sctable());\n                     }\n@@ -1296,7 +1303,10 @@ foo_module!()\n         let bindings = name_finder.ident_accumulator;\n \n         let cxbinds : ~[&ast::Ident] =\n-            bindings.iter().filter(|b|{@\"xx\" == (ident_to_str(*b))}).collect();\n+            bindings.iter().filter(|b| {\n+                let string = token::get_ident(b);\n+                \"xx\" == string.get()\n+            }).collect();\n         let cxbind = match cxbinds {\n             [b] => b,\n             _ => fail!(\"expected just one binding for ext_cx\")\n@@ -1308,9 +1318,13 @@ foo_module!()\n         let varrefs = path_finder.path_accumulator;\n \n         // the xx binding should bind all of the xx varrefs:\n-        for (idx,v) in varrefs.iter().filter(|p|{ p.segments.len() == 1\n-                                          && (@\"xx\" == (ident_to_str(&p.segments[0].identifier)))\n-                                     }).enumerate() {\n+        for (idx,v) in varrefs.iter().filter(|p|{\n+            p.segments.len() == 1\n+            && {\n+                let string = token::get_ident(p.segments[0].identifier.name);\n+                \"xx\" == string.get()\n+            }\n+        }).enumerate() {\n             if (mtwt_resolve(v.segments[0].identifier) != resolved_binding) {\n                 println!(\"uh oh, xx binding didn't match xx varref:\");\n                 println!(\"this is xx varref \\\\# {:?}\",idx);"}, {"sha": "6d1b8dd235854254086f12b6c87174ed79480a2b", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/875c9ce30b13de02e447ee95cb50b0111894b14a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/875c9ce30b13de02e447ee95cb50b0111894b14a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=875c9ce30b13de02e447ee95cb50b0111894b14a", "patch": "@@ -18,7 +18,7 @@ use parse::lexer::*; //resolve bug?\n use parse::ParseSess;\n use parse::attr::ParserAttr;\n use parse::parser::{LifetimeAndTypesWithoutColons, Parser};\n-use parse::token::{Token, EOF, to_str, Nonterminal, get_ident_interner, ident_to_str};\n+use parse::token::{Token, EOF, to_str, Nonterminal, get_ident_interner};\n use parse::token;\n \n use std::hashmap::HashMap;\n@@ -183,8 +183,9 @@ pub fn nameize(p_s: @ParseSess, ms: &[Matcher], res: &[@NamedMatch])\n                 node: MatchNonterminal(ref bind_name, _, idx), span: sp\n           } => {\n             if ret_val.contains_key(bind_name) {\n-                p_s.span_diagnostic.span_fatal(sp,\n-                                               \"Duplicated bind name: \"+ ident_to_str(bind_name))\n+                let string = token::get_ident(bind_name.name);\n+                p_s.span_diagnostic\n+                   .span_fatal(sp, \"Duplicated bind name: \" + string.get())\n             }\n             ret_val.insert(*bind_name, res[idx]);\n           }\n@@ -364,8 +365,11 @@ pub fn parse(sess: @ParseSess,\n                 let nts = bb_eis.map(|ei| {\n                     match ei.elts[ei.idx].node {\n                       MatchNonterminal(ref bind,ref name,_) => {\n-                        format!(\"{} ('{}')\", ident_to_str(name),\n-                             ident_to_str(bind))\n+                        let bind_string = token::get_ident(bind.name);\n+                        let name_string = token::get_ident(name.name);\n+                        format!(\"{} ('{}')\",\n+                                name_string.get(),\n+                                bind_string.get())\n                       }\n                       _ => fail!()\n                     } }).connect(\" or \");\n@@ -388,8 +392,9 @@ pub fn parse(sess: @ParseSess,\n                 let mut ei = bb_eis.pop().unwrap();\n                 match ei.elts[ei.idx].node {\n                   MatchNonterminal(_, ref name, idx) => {\n+                    let name_string = token::get_ident(name.name);\n                     ei.matches[idx].push(@MatchedNonterminal(\n-                        parse_nt(&mut rust_parser, ident_to_str(name))));\n+                        parse_nt(&mut rust_parser, name_string.get())));\n                     ei.idx += 1u;\n                   }\n                   _ => fail!()"}, {"sha": "d2fa24b1cfede7b66b7065e61077b5c574c69b95", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/875c9ce30b13de02e447ee95cb50b0111894b14a/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/875c9ce30b13de02e447ee95cb50b0111894b14a/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=875c9ce30b13de02e447ee95cb50b0111894b14a", "patch": "@@ -14,7 +14,7 @@ use codemap::{Span, DUMMY_SP};\n use diagnostic::SpanHandler;\n use ext::tt::macro_parser::{NamedMatch, MatchedSeq, MatchedNonterminal};\n use parse::token::{EOF, INTERPOLATED, IDENT, Token, NtIdent};\n-use parse::token::{ident_to_str};\n+use parse::token;\n use parse::lexer::TokenAndSpan;\n \n use std::cell::{Cell, RefCell};\n@@ -122,9 +122,10 @@ fn lookup_cur_matched(r: &TtReader, name: Ident) -> @NamedMatch {\n     match matched_opt {\n         Some(s) => lookup_cur_matched_by_matched(r, s),\n         None => {\n+            let name_string = token::get_ident(name.name);\n             r.sp_diag.span_fatal(r.cur_span.get(),\n                                  format!(\"unknown macro variable `{}`\",\n-                                         ident_to_str(&name)));\n+                                         name_string.get()));\n         }\n     }\n }\n@@ -145,11 +146,11 @@ fn lis_merge(lhs: LockstepIterSize, rhs: LockstepIterSize) -> LockstepIterSize {\n             LisContradiction(_) => rhs.clone(),\n             LisConstraint(r_len, _) if l_len == r_len => lhs.clone(),\n             LisConstraint(r_len, ref r_id) => {\n-                let l_n = ident_to_str(l_id);\n-                let r_n = ident_to_str(r_id);\n+                let l_n = token::get_ident(l_id.name);\n+                let r_n = token::get_ident(r_id.name);\n                 LisContradiction(format!(\"Inconsistent lockstep iteration: \\\n                                           '{}' has {} items, but '{}' has {}\",\n-                                          l_n, l_len, r_n, r_len))\n+                                          l_n.get(), l_len, r_n.get(), r_len))\n             }\n         }\n     }\n@@ -313,10 +314,11 @@ pub fn tt_next_token(r: &TtReader) -> TokenAndSpan {\n                 return ret_val;\n               }\n               MatchedSeq(..) => {\n+                let string = token::get_ident(ident.name);\n                 r.sp_diag.span_fatal(\n                     r.cur_span.get(), /* blame the macro writer */\n                     format!(\"variable '{}' is still repeating at this depth\",\n-                         ident_to_str(&ident)));\n+                            string.get()));\n               }\n             }\n           }"}, {"sha": "34080ffb62444af0916f25c52e78efe0efd72fc7", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/875c9ce30b13de02e447ee95cb50b0111894b14a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/875c9ce30b13de02e447ee95cb50b0111894b14a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=875c9ce30b13de02e447ee95cb50b0111894b14a", "patch": "@@ -72,9 +72,8 @@ use parse::lexer::Reader;\n use parse::lexer::TokenAndSpan;\n use parse::obsolete::*;\n use parse::token::{INTERPOLATED, InternedString, can_begin_expr, get_ident};\n-use parse::token::{get_ident_interner, ident_to_str, is_ident};\n-use parse::token::{is_ident_or_path, is_plain_ident, keywords};\n-use parse::token::{special_idents, token_to_binop};\n+use parse::token::{get_ident_interner, is_ident, is_ident_or_path};\n+use parse::token::{is_plain_ident, keywords, special_idents, token_to_binop};\n use parse::token;\n use parse::{new_sub_parser_from_file, ParseSess};\n use opt_vec;\n@@ -4534,7 +4533,8 @@ impl Parser {\n             token::LIT_STR(s)\n             | token::LIT_STR_RAW(s, _) => {\n                 self.bump();\n-                let the_string = ident_to_str(&s);\n+                let identifier_string = token::get_ident(s.name);\n+                let the_string = identifier_string.get();\n                 let mut abis = AbiSet::empty();\n                 for word in the_string.words() {\n                     match abi::lookup(word) {"}, {"sha": "93d912e7522b03a86c95f30e619d74ce341200c1", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/875c9ce30b13de02e447ee95cb50b0111894b14a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/875c9ce30b13de02e447ee95cb50b0111894b14a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=875c9ce30b13de02e447ee95cb50b0111894b14a", "patch": "@@ -19,7 +19,7 @@ use codemap::{CodeMap, BytePos};\n use codemap;\n use diagnostic;\n use parse::classify::expr_is_simple_block;\n-use parse::token::{IdentInterner, ident_to_str, interner_get};\n+use parse::token::{IdentInterner, interner_get};\n use parse::{comments, token};\n use parse;\n use print::pp::{break_offset, word, space, zerobreak, hardbreak};\n@@ -1539,7 +1539,8 @@ pub fn print_decl(s: &mut State, decl: &ast::Decl) {\n }\n \n pub fn print_ident(s: &mut State, ident: ast::Ident) {\n-    word(&mut s.s, ident_to_str(&ident));\n+    let string = token::get_ident(ident.name);\n+    word(&mut s.s, string.get());\n }\n \n pub fn print_name(s: &mut State, name: ast::Name) {"}]}