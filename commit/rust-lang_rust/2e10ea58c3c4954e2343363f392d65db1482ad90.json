{"sha": "2e10ea58c3c4954e2343363f392d65db1482ad90", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlMTBlYTU4YzNjNDk1NGUyMzQzMzYzZjM5MmQ2NWRiMTQ4MmFkOTA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-01-25T03:33:48Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-01-28T18:00:32Z"}, "message": "Integrate vec patterns into borrow checker.\n\nThe tail portion of the pattern effectively borrows a vector,\nbut the borrow checker knew nothing about this.\n\nr=catamorphism", "tree": {"sha": "9e68edf5922d00f6acc8d9b744d7295f8b0b87a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e68edf5922d00f6acc8d9b744d7295f8b0b87a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e10ea58c3c4954e2343363f392d65db1482ad90", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e10ea58c3c4954e2343363f392d65db1482ad90", "html_url": "https://github.com/rust-lang/rust/commit/2e10ea58c3c4954e2343363f392d65db1482ad90", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e10ea58c3c4954e2343363f392d65db1482ad90/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4fd30c6ace41638f10e415f6cad175997ec21c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4fd30c6ace41638f10e415f6cad175997ec21c4", "html_url": "https://github.com/rust-lang/rust/commit/d4fd30c6ace41638f10e415f6cad175997ec21c4"}], "stats": {"total": 191, "additions": 144, "deletions": 47}, "files": [{"sha": "0fff0c66a3846d02c864312d0d3793c0cf90db09", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2e10ea58c3c4954e2343363f392d65db1482ad90/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e10ea58c3c4954e2343363f392d65db1482ad90/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=2e10ea58c3c4954e2343363f392d65db1482ad90", "patch": "@@ -591,11 +591,53 @@ impl gather_loan_ctxt {\n                 }\n               }\n \n+              ast::pat_vec(_, Some(tail_pat)) => {\n+                  // The `tail_pat` here creates a slice into the\n+                  // original vector.  This is effectively a borrow of\n+                  // the elements of the vector being matched.\n+\n+                  let tail_ty = self.tcx().ty(tail_pat);\n+                  let (tail_mutbl, tail_r) =\n+                      self.vec_slice_info(tail_pat, tail_ty);\n+                  let mcx = self.bccx.mc_ctxt();\n+                  let cmt_index = mcx.cat_index(tail_pat, cmt);\n+                  self.guarantee_valid(cmt_index, tail_mutbl, tail_r);\n+              }\n+\n               _ => {}\n             }\n         }\n     }\n \n+    fn vec_slice_info(&self,\n+                      pat: @ast::pat,\n+                      tail_ty: ty::t) -> (ast::mutability, ty::Region)\n+    {\n+        /*!\n+         *\n+         * In a pattern like [a, b, ..c], normally `c` has slice type,\n+         * but if you have [a, b, ..ref c], then the type of `ref c`\n+         * will be `&&[]`, so to extract the slice details we have\n+         * to recurse through rptrs.\n+         */\n+\n+        match ty::get(tail_ty).sty {\n+            ty::ty_evec(tail_mt, ty::vstore_slice(tail_r)) => {\n+                (tail_mt.mutbl, tail_r)\n+            }\n+\n+            ty::ty_rptr(_, ref mt) => {\n+                self.vec_slice_info(pat, mt.ty)\n+            }\n+\n+            _ => {\n+                self.tcx().sess.span_bug(\n+                    pat.span,\n+                    fmt!(\"Type of tail pattern is not a slice\"));\n+            }\n+        }\n+    }\n+\n     fn pat_is_variant_or_struct(&self, pat: @ast::pat) -> bool {\n         pat_util::pat_is_variant_or_struct(self.bccx.tcx.def_map, pat)\n     }"}, {"sha": "a01c04a8abf158c7abb1c33cf49806c077ba78f2", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2e10ea58c3c4954e2343363f392d65db1482ad90/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e10ea58c3c4954e2343363f392d65db1482ad90/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=2e10ea58c3c4954e2343363f392d65db1482ad90", "patch": "@@ -504,9 +504,13 @@ impl borrowck_ctxt {\n         return @{cat:cat_discr(cmt, match_id),.. *cmt};\n     }\n \n+    fn mc_ctxt() -> mem_categorization_ctxt {\n+        mem_categorization_ctxt {tcx: self.tcx,\n+                                 method_map: self.method_map}\n+    }\n+\n     fn cat_pattern(cmt: cmt, pat: @ast::pat, op: fn(cmt, @ast::pat)) {\n-        let mc = &mem_categorization_ctxt {tcx: self.tcx,\n-                                           method_map: self.method_map};\n+        let mc = self.mc_ctxt();\n         mc.cat_pattern(cmt, pat, op);\n     }\n "}, {"sha": "7c1e96e5c0e448ff9a4b52dcf14e8643c1aad9e7", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 34, "deletions": 26, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/2e10ea58c3c4954e2343363f392d65db1482ad90/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e10ea58c3c4954e2343363f392d65db1482ad90/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=2e10ea58c3c4954e2343363f392d65db1482ad90", "patch": "@@ -521,8 +521,8 @@ impl &mem_categorization_ctxt {\n           ty: self.tcx.ty(arg)}\n     }\n \n-    fn cat_rvalue(expr: @ast::expr, expr_ty: ty::t) -> cmt {\n-        @{id:expr.id, span:expr.span,\n+    fn cat_rvalue<N: ast_node>(elt: N, expr_ty: ty::t) -> cmt {\n+        @{id:elt.id(), span:elt.span(),\n           cat:cat_rvalue, lp:None,\n           mutbl:m_imm, ty:expr_ty}\n     }\n@@ -643,12 +643,12 @@ impl &mem_categorization_ctxt {\n         }\n     }\n \n-    fn cat_index(expr: @ast::expr, base_cmt: cmt) -> cmt {\n+    fn cat_index<N: ast_node>(elt: N, base_cmt: cmt) -> cmt {\n         let mt = match ty::index(self.tcx, base_cmt.ty) {\n           Some(mt) => mt,\n           None => {\n             self.tcx.sess.span_bug(\n-                expr.span,\n+                elt.span(),\n                 fmt!(\"Explicit index of non-index type `%s`\",\n                      ty_to_str(self.tcx, base_cmt.ty)));\n           }\n@@ -675,25 +675,27 @@ impl &mem_categorization_ctxt {\n             };\n \n             // (c) the deref is explicit in the resulting cmt\n-            let deref_cmt = @{id:expr.id, span:expr.span,\n+            let deref_cmt = @{id:elt.id(), span:elt.span(),\n               cat:cat_deref(base_cmt, 0u, ptr), lp:deref_lp,\n               mutbl:m, ty:mt.ty};\n \n-            comp(expr, deref_cmt, base_cmt.ty, m, mt.ty)\n+            comp(elt, deref_cmt, base_cmt.ty, m, mt.ty)\n           }\n \n           deref_comp(_) => {\n             // fixed-length vectors have no deref\n             let m = self.inherited_mutability(base_cmt.mutbl, mt.mutbl);\n-            comp(expr, base_cmt, base_cmt.ty, m, mt.ty)\n+            comp(elt, base_cmt, base_cmt.ty, m, mt.ty)\n           }\n         };\n \n-        fn comp(expr: @ast::expr, of_cmt: cmt,\n-                vect: ty::t, mutbl: ast::mutability, ty: ty::t) -> cmt {\n+        fn comp<N: ast_node>(elt: N, of_cmt: cmt,\n+                             vect: ty::t, mutbl: ast::mutability,\n+                             ty: ty::t) -> cmt\n+        {\n             let comp = comp_index(vect, mutbl);\n             let index_lp = of_cmt.lp.map(|lp| @lp_comp(*lp, comp) );\n-            @{id:expr.id, span:expr.span,\n+            @{id:elt.id(), span:elt.span(),\n               cat:cat_comp(of_cmt, comp), lp:index_lp,\n               mutbl:mutbl, ty:ty}\n         }\n@@ -723,8 +725,6 @@ impl &mem_categorization_ctxt {\n \n     fn cat_pattern(cmt: cmt, pat: @ast::pat, op: fn(cmt, @ast::pat)) {\n \n-        op(cmt, pat);\n-\n         // Here, `cmt` is the categorization for the value being\n         // matched and pat is the pattern it is being matched against.\n         //\n@@ -759,21 +759,23 @@ impl &mem_categorization_ctxt {\n         // and the id of `local(x)->@->@` is the id of the `y` pattern.\n \n \n-        let _i = indenter();\n         let tcx = self.tcx;\n         debug!(\"cat_pattern: id=%d pat=%s cmt=%s\",\n                pat.id, pprust::pat_to_str(pat, tcx.sess.intr()),\n                self.cmt_to_repr(cmt));\n+        let _i = indenter();\n \n-        match /*bad*/copy pat.node {\n+        op(cmt, pat);\n+\n+        match pat.node {\n           ast::pat_wild => {\n             // _\n           }\n \n           ast::pat_enum(_, None) => {\n             // variant(*)\n           }\n-          ast::pat_enum(_, Some(subpats)) => {\n+          ast::pat_enum(_, Some(ref subpats)) => {\n             match self.tcx.def_map.find(pat.id) {\n                 Some(ast::def_variant(enum_did, _)) => {\n                     // variant(x, y, z)\n@@ -805,23 +807,16 @@ impl &mem_categorization_ctxt {\n               // nullary variant or identifier: ignore\n           }\n \n-          ast::pat_rec(field_pats, _) => {\n+          ast::pat_rec(ref field_pats, _) |\n+          ast::pat_struct(_, ref field_pats, _) => {\n             // {f1: p1, ..., fN: pN}\n             for field_pats.each |fp| {\n                 let cmt_field = self.cat_field(fp.pat, cmt, fp.ident, pat.id);\n                 self.cat_pattern(cmt_field, fp.pat, op);\n             }\n           }\n \n-          ast::pat_struct(_, field_pats, _) => {\n-            // {f1: p1, ..., fN: pN}\n-            for field_pats.each |fp| {\n-                let cmt_field = self.cat_field(fp.pat, cmt, fp.ident, pat.id);\n-                self.cat_pattern(cmt_field, fp.pat, op);\n-            }\n-          }\n-\n-          ast::pat_tup(subpats) => {\n+          ast::pat_tup(ref subpats) => {\n             // (p1, ..., pN)\n             for subpats.each |subpat| {\n                 let subcmt = self.cat_tuple_elt(*subpat, cmt);\n@@ -836,7 +831,20 @@ impl &mem_categorization_ctxt {\n             self.cat_pattern(subcmt, subpat, op);\n           }\n \n-          ast::pat_vec(*) | ast::pat_lit(_) | ast::pat_range(_, _) => {\n+          ast::pat_vec(ref pats, opt_tail_pat) => {\n+              for pats.each |pat| {\n+                  let elt_cmt = self.cat_index(*pat, cmt);\n+                  self.cat_pattern(elt_cmt, *pat, op);\n+              }\n+\n+              for opt_tail_pat.each |tail_pat| {\n+                  let tail_ty = self.tcx.ty(*tail_pat);\n+                  let tail_cmt = self.cat_rvalue(*tail_pat, tail_ty);\n+                  self.cat_pattern(tail_cmt, *tail_pat, op);\n+              }\n+          }\n+\n+          ast::pat_lit(_) | ast::pat_range(_, _) => {\n               /*always ok*/\n           }\n         }"}, {"sha": "840726b804179b4bb8432d562ee75a73322a97d5", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e10ea58c3c4954e2343363f392d65db1482ad90/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e10ea58c3c4954e2343363f392d65db1482ad90/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=2e10ea58c3c4954e2343363f392d65db1482ad90", "patch": "@@ -3017,7 +3017,9 @@ pure fn ty_vstore(ty: t) -> vstore {\n fn ty_region(ty: t) -> Region {\n     match get(ty).sty {\n       ty_rptr(r, _) => r,\n-      ref s => fail fmt!(\"ty_region() invoked on non-rptr: %?\", (*s))\n+      ty_evec(_, vstore_slice(r)) => r,\n+      ty_estr(vstore_slice(r)) => r,\n+      ref s => fail fmt!(\"ty_region() invoked on in appropriate ty: %?\", (*s))\n     }\n }\n "}, {"sha": "a4aa645da0b597fc165fe1e919af9ec7aee104e6", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2e10ea58c3c4954e2343363f392d65db1482ad90/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e10ea58c3c4954e2343363f392d65db1482ad90/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=2e10ea58c3c4954e2343363f392d65db1482ad90", "patch": "@@ -530,6 +530,13 @@ mod guarantor {\n      * but more special purpose.\n      */\n \n+    use core::prelude::*;\n+    use middle::typeck::check::regionck::{rcx, infallibly_mk_subr};\n+    use middle::ty;\n+    use syntax::ast;\n+    use syntax::codemap::span;\n+    use util::ppaux::{ty_to_str};\n+\n     pub fn for_addr_of(rcx: @rcx, expr: @ast::expr, base: @ast::expr) {\n         /*!\n          *\n@@ -726,17 +733,17 @@ mod guarantor {\n \n     fn pointer_categorize(ty: ty::t) -> PointerCat {\n         match ty::get(ty).sty {\n-            ty::ty_rptr(r, _) | ty::ty_evec(_, vstore_slice(r)) |\n-            ty::ty_estr(vstore_slice(r)) => {\n+            ty::ty_rptr(r, _) | ty::ty_evec(_, ty::vstore_slice(r)) |\n+            ty::ty_estr(ty::vstore_slice(r)) => {\n                 BorrowedPointer(r)\n             }\n-            ty::ty_uniq(*) | ty::ty_estr(vstore_uniq) |\n-            ty::ty_evec(_, vstore_uniq) => {\n+            ty::ty_uniq(*) | ty::ty_estr(ty::vstore_uniq) |\n+            ty::ty_evec(_, ty::vstore_uniq) => {\n                 OwnedPointer\n             }\n             ty::ty_box(*) | ty::ty_ptr(*) |\n-            ty::ty_evec(_, vstore_box) |\n-            ty::ty_estr(vstore_box) => {\n+            ty::ty_evec(_, ty::vstore_box) |\n+            ty::ty_estr(ty::vstore_box) => {\n                 OtherPointer\n             }\n             _ => {\n@@ -828,9 +835,9 @@ mod guarantor {\n                 for rcx.resolve_node_type(pat.id).each |vec_ty| {\n                     let vstore = ty::ty_vstore(*vec_ty);\n                     let guarantor1 = match vstore {\n-                        vstore_fixed(_) | vstore_uniq => guarantor,\n-                        vstore_slice(r) => Some(r),\n-                        vstore_box => None\n+                        ty::vstore_fixed(_) | ty::vstore_uniq => guarantor,\n+                        ty::vstore_slice(r) => Some(r),\n+                        ty::vstore_box => None\n                     };\n \n                     link_ref_bindings_in_pats(rcx, ps, guarantor1);\n@@ -844,8 +851,8 @@ mod guarantor {\n     }\n \n     fn link_ref_bindings_in_pats(rcx: @rcx,\n-                      pats: &~[@ast::pat],\n-                      guarantor: Option<ty::Region>)\n+                                 pats: &~[@ast::pat],\n+                                 guarantor: Option<ty::Region>)\n     {\n         for pats.each |pat| {\n             link_ref_bindings_in_pat(rcx, *pat, guarantor);"}, {"sha": "358917de85fb9c1d9c076869669d38ab3ce09988", "filename": "src/test/compile-fail/borrowck-vec-pattern-element-loan.rs", "status": "renamed", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e10ea58c3c4954e2343363f392d65db1482ad90/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-element-loan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e10ea58c3c4954e2343363f392d65db1482ad90/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-element-loan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-element-loan.rs?ref=2e10ea58c3c4954e2343363f392d65db1482ad90", "patch": "@@ -1,9 +1,7 @@\n-// xfail-test\n-\n fn a() -> &[int] {\n     let vec = [1, 2, 3, 4];\n-    let tail = match vec {\n-        [_a, ..tail] => tail, //~ ERROR illegal borrow\n+    let tail = match vec { //~ ERROR illegal borrow\n+        [_a, ..tail] => tail,\n         _ => fail ~\"foo\"\n     };\n     move tail", "previous_filename": "src/test/compile-fail/alt-vec-illegal-tail-loan.rs"}, {"sha": "27902100373a96e938a3caeb24e3443a6b84abfe", "filename": "src/test/compile-fail/borrowck-vec-pattern-loan-from-mut.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2e10ea58c3c4954e2343363f392d65db1482ad90/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-loan-from-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e10ea58c3c4954e2343363f392d65db1482ad90/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-loan-from-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-loan-from-mut.rs?ref=2e10ea58c3c4954e2343363f392d65db1482ad90", "patch": "@@ -0,0 +1,12 @@\n+fn a() {\n+    let mut v = ~[1, 2, 3];\n+    match v {\n+        [_a, ..tail] => {\n+            v.push(tail[0] + tail[1]); //~ ERROR conflicts with prior loan\n+        }\n+        _ => {}\n+    };\n+}\n+\n+fn main() {}\n+"}, {"sha": "50feff707adfa7d7c2bbe5c5b95ba83422d0e155", "filename": "src/test/compile-fail/borrowck-vec-pattern-nesting.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2e10ea58c3c4954e2343363f392d65db1482ad90/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-nesting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e10ea58c3c4954e2343363f392d65db1482ad90/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-nesting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-nesting.rs?ref=2e10ea58c3c4954e2343363f392d65db1482ad90", "patch": "@@ -0,0 +1,21 @@\n+fn a() {\n+    let mut vec = [~1, ~2, ~3];\n+    match vec {\n+        [~ref _a] => {\n+            vec[0] = ~4; //~ ERROR prohibited due to outstanding loan\n+        }\n+        _ => fail ~\"foo\"\n+    }\n+}\n+\n+fn b() {\n+    let mut vec = [~1, ~2, ~3];\n+    match vec {\n+        [.._b] => {\n+            vec[0] = ~4; //~ ERROR prohibited due to outstanding loan\n+        }\n+    }\n+}\n+\n+fn main() {}\n+"}, {"sha": "6477fd9fb2cf9a9e92d413e941a9e715a8ef4c95", "filename": "src/test/compile-fail/borrowck-vec-pattern-tail-element-loan.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e10ea58c3c4954e2343363f392d65db1482ad90/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-tail-element-loan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e10ea58c3c4954e2343363f392d65db1482ad90/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-tail-element-loan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-tail-element-loan.rs?ref=2e10ea58c3c4954e2343363f392d65db1482ad90", "patch": "@@ -1,7 +1,7 @@\n fn a() -> &int {\n     let vec = [1, 2, 3, 4];\n-    let tail = match vec {\n-        [_a, ..tail] => &tail[0], //~ ERROR illegal borrow\n+    let tail = match vec { //~ ERROR illegal borrow\n+        [_a, ..tail] => &tail[0],\n         _ => fail ~\"foo\"\n     };\n     move tail", "previous_filename": "src/test/compile-fail/alt-vec-illegal-tail-element-loan.rs"}, {"sha": "6765c1a11ae782ffa422d82fcb2f8480e34107ca", "filename": "src/test/run-pass/region-dependent-addr-of.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2e10ea58c3c4954e2343363f392d65db1482ad90/src%2Ftest%2Frun-pass%2Fregion-dependent-addr-of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e10ea58c3c4954e2343363f392d65db1482ad90/src%2Ftest%2Frun-pass%2Fregion-dependent-addr-of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregion-dependent-addr-of.rs?ref=2e10ea58c3c4954e2343363f392d65db1482ad90", "patch": "@@ -109,4 +109,7 @@ fn main() {\n \n     let p = get_v6_c(&a, 1);\n     assert *p == a.value.v6.get().f;\n+\n+    let p = get_v5_ref(&a, 1);\n+    assert *p == a.value.v5.f;\n }"}, {"sha": "0d093a1b4b0fdb0962d05b88db710f00a8b852b0", "filename": "src/test/run-pass/vec-matching-legal-tail-element-borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e10ea58c3c4954e2343363f392d65db1482ad90/src%2Ftest%2Frun-pass%2Fvec-matching-legal-tail-element-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e10ea58c3c4954e2343363f392d65db1482ad90/src%2Ftest%2Frun-pass%2Fvec-matching-legal-tail-element-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-matching-legal-tail-element-borrow.rs?ref=2e10ea58c3c4954e2343363f392d65db1482ad90", "patch": "@@ -2,7 +2,7 @@ fn main() {\n     let x = &[1, 2, 3, 4, 5];\n     if !x.is_empty() {\n         let el = match x {\n-            [1, ..ref tail] => &tail[0], \n+            [1, ..ref tail] => &tail[0],\n             _ => ::core::util::unreachable()\n         };\n         io::println(fmt!(\"%d\", *el));"}]}