{"sha": "cd1a765c6f635c7cf9d39a46f42c93a2cbbf1982", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkMWE3NjVjNmY2MzVjN2NmOWQzOWE0NmY0MmM5M2EyY2JiZjE5ODI=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-09-16T01:22:10Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-09-16T01:22:10Z"}, "message": "Add Peter Hull's contributed translation of the fasta shootout benchmark (integer-only version).", "tree": {"sha": "2ac85f1ed7ede99a498f90dd0ecb56239b4e92f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ac85f1ed7ede99a498f90dd0ecb56239b4e92f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd1a765c6f635c7cf9d39a46f42c93a2cbbf1982", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd1a765c6f635c7cf9d39a46f42c93a2cbbf1982", "html_url": "https://github.com/rust-lang/rust/commit/cd1a765c6f635c7cf9d39a46f42c93a2cbbf1982", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd1a765c6f635c7cf9d39a46f42c93a2cbbf1982/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e270ab6fbfcfcca44ac5ee028da2b4d91fe29419", "url": "https://api.github.com/repos/rust-lang/rust/commits/e270ab6fbfcfcca44ac5ee028da2b4d91fe29419", "html_url": "https://github.com/rust-lang/rust/commit/e270ab6fbfcfcca44ac5ee028da2b4d91fe29419"}], "stats": {"total": 133, "additions": 132, "deletions": 1}, "files": [{"sha": "7f54cfb1d8135c7932255eaf0afee09f0276ca41", "filename": "AUTHORS.txt", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cd1a765c6f635c7cf9d39a46f42c93a2cbbf1982/AUTHORS.txt", "raw_url": "https://github.com/rust-lang/rust/raw/cd1a765c6f635c7cf9d39a46f42c93a2cbbf1982/AUTHORS.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/AUTHORS.txt?ref=cd1a765c6f635c7cf9d39a46f42c93a2cbbf1982", "patch": "@@ -17,5 +17,6 @@ Matt Brubeck <mbrubeck@limpet.net>\n Michael Bebenita <mbebenita@mozilla.com>\n Or Brostovski <tohava@gmail.com>\n Patrick Walton <pwalton@mozilla.com>\n+Peter Hull <peterhull90@gmail.com>\n Ralph Giles <giles@thaumas.net>\n Roy Frostig <rfrostig@mozilla.com>"}, {"sha": "669cd809915df4a664fdfd4f73cfb0878fbf52db", "filename": "src/test/bench/shootout/binary-trees.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cd1a765c6f635c7cf9d39a46f42c93a2cbbf1982/src%2Ftest%2Fbench%2Fshootout%2Fbinary-trees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1a765c6f635c7cf9d39a46f42c93a2cbbf1982/src%2Ftest%2Fbench%2Fshootout%2Fbinary-trees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout%2Fbinary-trees.rs?ref=cd1a765c6f635c7cf9d39a46f42c93a2cbbf1982", "patch": "@@ -1,4 +1,7 @@\n-type tree = tag(nil(), node(@tree, @tree, int));\n+tag tree {\n+  nil();\n+  node(@tree, @tree, int);\n+}\n \n fn item_check(&tree t) -> int {\n   alt (t) {"}, {"sha": "ffec6db95ff3b85657cf966a55e2e5d649aef8fd", "filename": "src/test/bench/shootout/fasta.rs", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/cd1a765c6f635c7cf9d39a46f42c93a2cbbf1982/src%2Ftest%2Fbench%2Fshootout%2Ffasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1a765c6f635c7cf9d39a46f42c93a2cbbf1982/src%2Ftest%2Fbench%2Fshootout%2Ffasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout%2Ffasta.rs?ref=cd1a765c6f635c7cf9d39a46f42c93a2cbbf1982", "patch": "@@ -0,0 +1,127 @@\n+/* -*- mode: rust; indent-tabs-mode: nil -*-\n+ * Implementation of 'fasta' benchmark from\n+ * Computer Language Benchmarks Game\n+ * http://shootout.alioth.debian.org/\n+ */\n+use std;\n+import std._vec;\n+import std._str;\n+import std._uint;\n+import std._int;\n+\n+fn LINE_LENGTH() -> uint {\n+  ret 60u;\n+}\n+\n+obj myrandom(mutable u32 last) {\n+  fn next(u32 mx) -> u32 {\n+    last = (last * 3877u32 + 29573u32) % 139968u32;\n+    auto ans = (mx*last) / 139968u32;\n+    ret ans;\n+  }\n+}\n+\n+type aminoacids = tup(char, u32);\n+\n+fn make_cumulative(vec[aminoacids] aa) -> vec[aminoacids] {\n+  let u32 cp = 0u32;\n+  let vec[aminoacids] ans = vec();\n+  for (aminoacids a in aa) {\n+    cp += a._1;\n+    ans += tup(a._0, cp);\n+  }\n+  ret ans;\n+}\n+\n+fn select_random(u32 r, vec[aminoacids] genelist) -> char {\n+  if (r < genelist.(0)._1) {\n+    ret genelist.(0)._0;\n+  }\n+  fn bisect(vec[aminoacids] v, uint lo, uint hi, u32 target) -> char {\n+    if (hi > (lo + 1u)) {\n+      let uint mid = lo + (hi - lo) / 2u;\n+      if (target < v.(mid)._1) {\n+        be bisect(v, lo, mid, target);\n+      }\n+      else {\n+        be bisect(v, mid, hi, target);\n+      }\n+    }\n+    else {\n+      ret v.(hi)._0;\n+    }\n+  }\n+  ret bisect(genelist, 0u, _vec.len[aminoacids](genelist) - 1u, r);\n+}\n+\n+fn make_random_fasta(str id, str desc, vec[aminoacids] genelist, int n) {\n+  log(\">\" + id + \" \" + desc);\n+  auto rng = myrandom(std.rand.mk_rng().next());\n+  let str op = \"\";\n+  for each (uint i in _uint.range(0u, n as uint)) {\n+    op += select_random(rng.next(100u32), genelist) as u8;\n+    if (_str.byte_len(op) >= LINE_LENGTH()) {\n+      log(op);\n+      op = \"\";\n+    }\n+  }\n+  if (_str.byte_len(op) > 0u) {\n+    log(op);\n+  }\n+}\n+\n+fn make_repeat_fasta(str id, str desc, str s, int n) {\n+  log(\">\" + id + \" \" + desc);\n+  let str op = \"\";\n+  let uint sl = _str.byte_len(s);\n+  for each (uint i in _uint.range(0u, n as uint)) {\n+\n+    op += s.(i % sl);\n+    if (_str.byte_len(op) >= LINE_LENGTH()) {\n+      log(op);\n+      op = \"\";\n+    }\n+  }\n+  if (_str.byte_len(op) > 0u) {\n+    log(op);\n+  }\n+}\n+\n+fn main(vec[str] args) {\n+  let vec[aminoacids] iub = make_cumulative(vec(tup( 'a', 27u32 ),\n+                                                tup( 'c', 12u32 ),\n+                                                tup( 'g', 12u32 ),\n+                                                tup( 't', 27u32 ),\n+\n+                                                tup( 'B', 2u32 ),\n+                                                tup( 'D', 2u32 ),\n+                                                tup( 'H', 2u32 ),\n+                                                tup( 'K', 2u32 ),\n+                                                tup( 'M', 2u32 ),\n+                                                tup( 'N', 2u32 ),\n+                                                tup( 'R', 2u32 ),\n+                                                tup( 'S', 2u32 ),\n+                                                tup( 'V', 2u32 ),\n+                                                tup( 'W', 2u32 ),\n+                                                tup( 'Y', 2u32 )));\n+\n+  let vec[aminoacids] homosapiens = make_cumulative(vec(tup( 'a', 30u32 ),\n+                                                        tup( 'c', 20u32 ),\n+                                                        tup( 'g', 20u32 ),\n+                                                        tup( 't', 30u32 )));\n+\n+  let str alu =\n+    \"GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG\" +\n+    \"GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA\" +\n+    \"CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT\" +\n+    \"ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA\" +\n+    \"GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG\" +\n+    \"AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC\" +\n+    \"AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA\";\n+\n+  let int n = 512;\n+\n+  make_repeat_fasta (\"ONE\", \"Homo sapiens alu\", alu, n*2);\n+  make_random_fasta(\"TWO\", \"IUB ambiguity codes\", iub, n*3);\n+  make_random_fasta (\"THREE\", \"Homo sapiens frequency\", homosapiens, n*5);\n+}"}]}