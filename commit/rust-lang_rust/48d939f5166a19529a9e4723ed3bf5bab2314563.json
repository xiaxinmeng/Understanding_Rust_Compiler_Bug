{"sha": "48d939f5166a19529a9e4723ed3bf5bab2314563", "node_id": "C_kwDOAAsO6NoAKDQ4ZDkzOWY1MTY2YTE5NTI5YTllNDcyM2VkM2JmNWJhYjIzMTQ1NjM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-06T18:34:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-06T18:34:27Z"}, "message": "Auto merge of #8042 - camsteffen:peel-blocks, r=xFrednet\n\nPeel blocks and statements utils\n\nchangelog: none\n\n* Rename `remove_blocks` to `peel_blocks`\n* Add `peel_blocks_and_stmts`\n* Various refactors to use the above utils\n* The utils also now check `block.rules`", "tree": {"sha": "4e403bd04c84f0774174771283186d86d8c4b7aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e403bd04c84f0774174771283186d86d8c4b7aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48d939f5166a19529a9e4723ed3bf5bab2314563", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48d939f5166a19529a9e4723ed3bf5bab2314563", "html_url": "https://github.com/rust-lang/rust/commit/48d939f5166a19529a9e4723ed3bf5bab2314563", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48d939f5166a19529a9e4723ed3bf5bab2314563/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e0852705eb74ab5b840715d47226c707808735c", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e0852705eb74ab5b840715d47226c707808735c", "html_url": "https://github.com/rust-lang/rust/commit/9e0852705eb74ab5b840715d47226c707808735c"}, {"sha": "16bbd243f9e5c71ff0481c7168a32f4f442c582f", "url": "https://api.github.com/repos/rust-lang/rust/commits/16bbd243f9e5c71ff0481c7168a32f4f442c582f", "html_url": "https://github.com/rust-lang/rust/commit/16bbd243f9e5c71ff0481c7168a32f4f442c582f"}], "stats": {"total": 516, "additions": 197, "deletions": 319}, "files": [{"sha": "b7f414742f1566bd69731f71ce323c6364c7b947", "filename": "clippy_lints/src/assertions_on_constants.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassertions_on_constants.rs?ref=48d939f5166a19529a9e4723ed3bf5bab2314563", "patch": "@@ -2,7 +2,7 @@ use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::higher;\n use clippy_utils::source::snippet_opt;\n-use clippy_utils::{is_direct_expn_of, is_expn_of, match_panic_call};\n+use clippy_utils::{is_direct_expn_of, is_expn_of, match_panic_call, peel_blocks};\n use if_chain::if_chain;\n use rustc_hir::{Expr, ExprKind, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -122,15 +122,7 @@ fn match_assert_with_message<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>)\n         if let ExprKind::Unary(UnOp::Not, expr) = cond.kind;\n         // bind the first argument of the `assert!` macro\n         if let Some((Constant::Bool(is_true), _)) = constant(cx, cx.typeck_results(), expr);\n-        // block\n-        if let ExprKind::Block(block, _) = then.kind;\n-        if block.stmts.is_empty();\n-        if let Some(block_expr) = &block.expr;\n-        // inner block is optional. unwrap it if it exists, or use the expression as is otherwise.\n-        if let Some(begin_panic_call) = match block_expr.kind {\n-            ExprKind::Block(inner_block, _) => &inner_block.expr,\n-            _ => &block.expr,\n-        };\n+        let begin_panic_call = peel_blocks(then);\n         // function call\n         if let Some(arg) = match_panic_call(cx, begin_panic_call);\n         // bind the second argument of the `assert!` macro if it exists"}, {"sha": "657c1f88c7db5055bd8714fe0329d9a9a9bde694", "filename": "clippy_lints/src/bytecount.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=48d939f5166a19529a9e4723ed3bf5bab2314563", "patch": "@@ -2,7 +2,7 @@ use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::match_type;\n use clippy_utils::visitors::is_local_used;\n-use clippy_utils::{path_to_local_id, paths, peel_ref_operators, remove_blocks, strip_pat_refs};\n+use clippy_utils::{path_to_local_id, paths, peel_blocks, peel_ref_operators, strip_pat_refs};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, Expr, ExprKind, PatKind};\n@@ -55,7 +55,7 @@ impl<'tcx> LateLintPass<'tcx> for ByteCount {\n                        cx.typeck_results().expr_ty(filter_recv).peel_refs(),\n                        &paths::SLICE_ITER);\n             let operand_is_arg = |expr| {\n-                let expr = peel_ref_operators(cx, remove_blocks(expr));\n+                let expr = peel_ref_operators(cx, peel_blocks(expr));\n                 path_to_local_id(expr, arg_id)\n             };\n             let needle = if operand_is_arg(l) {"}, {"sha": "c71e9f10f79ec95c331e71df7a20b254458c6721", "filename": "clippy_lints/src/collapsible_match.rs", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Fcollapsible_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Fcollapsible_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_match.rs?ref=48d939f5166a19529a9e4723ed3bf5bab2314563", "patch": "@@ -1,10 +1,10 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::higher::IfLetOrMatch;\n use clippy_utils::visitors::is_local_used;\n-use clippy_utils::{is_lang_ctor, is_unit_expr, path_to_local, peel_ref_operators, SpanlessEq};\n+use clippy_utils::{is_lang_ctor, is_unit_expr, path_to_local, peel_blocks_with_stmt, peel_ref_operators, SpanlessEq};\n use if_chain::if_chain;\n use rustc_hir::LangItem::OptionNone;\n-use rustc_hir::{Arm, Expr, ExprKind, Guard, HirId, Pat, PatKind, StmtKind};\n+use rustc_hir::{Arm, Expr, Guard, HirId, Pat, PatKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{MultiSpan, Span};\n@@ -75,7 +75,7 @@ fn check_arm<'tcx>(\n     outer_guard: Option<&'tcx Guard<'tcx>>,\n     outer_else_body: Option<&'tcx Expr<'tcx>>,\n ) {\n-    let inner_expr = strip_singleton_blocks(outer_then_body);\n+    let inner_expr = peel_blocks_with_stmt(outer_then_body);\n     if_chain! {\n         if let Some(inner) = IfLetOrMatch::parse(cx, inner_expr);\n         if let Some((inner_scrutinee, inner_then_pat, inner_else_body)) = match inner {\n@@ -138,20 +138,6 @@ fn check_arm<'tcx>(\n     }\n }\n \n-fn strip_singleton_blocks<'hir>(mut expr: &'hir Expr<'hir>) -> &'hir Expr<'hir> {\n-    while let ExprKind::Block(block, _) = expr.kind {\n-        match (block.stmts, block.expr) {\n-            ([stmt], None) => match stmt.kind {\n-                StmtKind::Expr(e) | StmtKind::Semi(e) => expr = e,\n-                _ => break,\n-            },\n-            ([], Some(e)) => expr = e,\n-            _ => break,\n-        }\n-    }\n-    expr\n-}\n-\n /// A \"wild-like\" arm has a wild (`_`) or `None` pattern and no guard. Such arms can be \"collapsed\"\n /// into a single wild arm without any significant loss in semantics or readability.\n fn arm_is_wild_like(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {"}, {"sha": "eccb18982f30da8a74e4f8a8626a94ef7c5e3189", "filename": "clippy_lints/src/derivable_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Fderivable_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Fderivable_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderivable_impls.rs?ref=48d939f5166a19529a9e4723ed3bf5bab2314563", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::{is_automatically_derived, is_default_equivalent, remove_blocks};\n+use clippy_utils::{is_automatically_derived, is_default_equivalent, peel_blocks};\n use rustc_hir::{\n     def::{DefKind, Res},\n     Body, Expr, ExprKind, GenericArg, Impl, ImplItemKind, Item, ItemKind, Node, PathSegment, QPath, TyKind,\n@@ -95,7 +95,7 @@ impl<'tcx> LateLintPass<'tcx> for DerivableImpls {\n                         }\n                     }\n                 }\n-                let should_emit = match remove_blocks(func_expr).kind {\n+                let should_emit = match peel_blocks(func_expr).kind {\n                     ExprKind::Tup(fields) => fields.iter().all(|e| is_default_equivalent(cx, e)),\n                     ExprKind::Call(callee, args)\n                         if is_path_self(callee) => args.iter().all(|e| is_default_equivalent(cx, e)),"}, {"sha": "2de2bfc040b5306c6d62b7d137dd023823834d1d", "filename": "clippy_lints/src/floating_point_arithmetic.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=48d939f5166a19529a9e4723ed3bf5bab2314563", "patch": "@@ -4,7 +4,7 @@ use clippy_utils::consts::{\n };\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::higher;\n-use clippy_utils::{eq_expr_value, get_parent_expr, in_constant, numeric_literal, sugg};\n+use clippy_utils::{eq_expr_value, get_parent_expr, in_constant, numeric_literal, peel_blocks, sugg};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, Expr, ExprKind, PathSegment, UnOp};\n@@ -546,13 +546,9 @@ fn are_negated<'a>(cx: &LateContext<'_>, expr1: &'a Expr<'a>, expr2: &'a Expr<'a\n \n fn check_custom_abs(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {\n-        if let Some(higher::If { cond, then, r#else }) = higher::If::hir(expr);\n-        if let ExprKind::Block(block, _) = then.kind;\n-        if block.stmts.is_empty();\n-        if let Some(if_body_expr) = block.expr;\n-        if let Some(ExprKind::Block(else_block, _)) = r#else.map(|el| &el.kind);\n-        if else_block.stmts.is_empty();\n-        if let Some(else_body_expr) = else_block.expr;\n+        if let Some(higher::If { cond, then, r#else: Some(r#else) }) = higher::If::hir(expr);\n+        let if_body_expr = peel_blocks(then);\n+        let else_body_expr = peel_blocks(r#else);\n         if let Some((if_expr_positive, body)) = are_negated(cx, if_body_expr, else_body_expr);\n         then {\n             let positive_abs_sugg = ("}, {"sha": "16e5c5ca603db450474ce1697cf4e110041bbc6e", "filename": "clippy_lints/src/if_then_some_else_none.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs?ref=48d939f5166a19529a9e4723ed3bf5bab2314563", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::source::snippet_with_macro_callsite;\n-use clippy_utils::{contains_return, higher, is_else_clause, is_lang_ctor, meets_msrv, msrvs};\n+use clippy_utils::{contains_return, higher, is_else_clause, is_lang_ctor, meets_msrv, msrvs, peel_blocks};\n use if_chain::if_chain;\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n use rustc_hir::{Expr, ExprKind, Stmt, StmtKind};\n@@ -77,10 +77,7 @@ impl LateLintPass<'_> for IfThenSomeElseNone {\n             if let ExprKind::Call(then_call, [then_arg]) = then_expr.kind;\n             if let ExprKind::Path(ref then_call_qpath) = then_call.kind;\n             if is_lang_ctor(cx, then_call_qpath, OptionSome);\n-            if let ExprKind::Block(els_block, _) = els.kind;\n-            if els_block.stmts.is_empty();\n-            if let Some(els_expr) = els_block.expr;\n-            if let ExprKind::Path(ref qpath) = els_expr.kind;\n+            if let ExprKind::Path(ref qpath) = peel_blocks(els).kind;\n             if is_lang_ctor(cx, qpath, OptionNone);\n             if !stmts_contains_early_return(then_block.stmts);\n             then {"}, {"sha": "26a196aab5972ca577430009543fa05fa9d53251", "filename": "clippy_lints/src/implicit_saturating_sub.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs?ref=48d939f5166a19529a9e4723ed3bf5bab2314563", "patch": "@@ -1,10 +1,9 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::higher;\n-use clippy_utils::SpanlessEq;\n+use clippy_utils::{higher, peel_blocks_with_stmt, SpanlessEq};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n-use rustc_hir::{lang_items::LangItem, BinOpKind, Expr, ExprKind, QPath, StmtKind};\n+use rustc_hir::{lang_items::LangItem, BinOpKind, Expr, ExprKind, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n@@ -52,13 +51,8 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingSub {\n             // Ensure that the binary operator is >, != and <\n             if BinOpKind::Ne == cond_op.node || BinOpKind::Gt == cond_op.node || BinOpKind::Lt == cond_op.node;\n \n-            // Check if the true condition block has only one statement\n-            if let ExprKind::Block(block, _) = then.kind;\n-            if block.stmts.len() == 1 && block.expr.is_none();\n-\n             // Check if assign operation is done\n-            if let StmtKind::Semi(e) = block.stmts[0].kind;\n-            if let Some(target) = subtracts_one(cx, e);\n+            if let Some(target) = subtracts_one(cx, then);\n \n             // Extracting out the variable name\n             if let ExprKind::Path(QPath::Resolved(_, ares_path)) = target.kind;\n@@ -138,8 +132,8 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingSub {\n     }\n }\n \n-fn subtracts_one<'a>(cx: &LateContext<'_>, expr: &Expr<'a>) -> Option<&'a Expr<'a>> {\n-    match expr.kind {\n+fn subtracts_one<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<&'a Expr<'a>> {\n+    match peel_blocks_with_stmt(expr).kind {\n         ExprKind::AssignOp(ref op1, target, value) => {\n             if_chain! {\n                 if BinOpKind::Sub == op1.node;"}, {"sha": "d276c901059974a54c38d51601f26c3a6d070638", "filename": "clippy_lints/src/loops/manual_flatten.rs", "status": "modified", "additions": 48, "deletions": 64, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs?ref=48d939f5166a19529a9e4723ed3bf5bab2314563", "patch": "@@ -3,11 +3,11 @@ use super::MANUAL_FLATTEN;\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::higher;\n use clippy_utils::visitors::is_local_used;\n-use clippy_utils::{is_lang_ctor, path_to_local_id};\n+use clippy_utils::{is_lang_ctor, path_to_local_id, peel_blocks_with_stmt};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionSome, ResultOk};\n-use rustc_hir::{Expr, ExprKind, Pat, PatKind, StmtKind};\n+use rustc_hir::{Expr, Pat, PatKind};\n use rustc_lint::LateContext;\n use rustc_middle::ty;\n use rustc_span::source_map::Span;\n@@ -21,71 +21,55 @@ pub(super) fn check<'tcx>(\n     body: &'tcx Expr<'_>,\n     span: Span,\n ) {\n-    if let ExprKind::Block(block, _) = body.kind {\n-        // Ensure the `if let` statement is the only expression or statement in the for-loop\n-        let inner_expr = if block.stmts.len() == 1 && block.expr.is_none() {\n-            let match_stmt = &block.stmts[0];\n-            if let StmtKind::Semi(inner_expr) = match_stmt.kind {\n-                Some(inner_expr)\n-            } else {\n-                None\n-            }\n-        } else if block.stmts.is_empty() {\n-            block.expr\n-        } else {\n-            None\n-        };\n+    let inner_expr = peel_blocks_with_stmt(body);\n+    if_chain! {\n+        if let Some(higher::IfLet { let_pat, let_expr, if_then, if_else: None })\n+            = higher::IfLet::hir(cx, inner_expr);\n+        // Ensure match_expr in `if let` statement is the same as the pat from the for-loop\n+        if let PatKind::Binding(_, pat_hir_id, _, _) = pat.kind;\n+        if path_to_local_id(let_expr, pat_hir_id);\n+        // Ensure the `if let` statement is for the `Some` variant of `Option` or the `Ok` variant of `Result`\n+        if let PatKind::TupleStruct(ref qpath, _, _) = let_pat.kind;\n+        let some_ctor = is_lang_ctor(cx, qpath, OptionSome);\n+        let ok_ctor = is_lang_ctor(cx, qpath, ResultOk);\n+        if some_ctor || ok_ctor;\n+        // Ensure expr in `if let` is not used afterwards\n+        if !is_local_used(cx, if_then, pat_hir_id);\n+        then {\n+            let if_let_type = if some_ctor { \"Some\" } else { \"Ok\" };\n+            // Prepare the error message\n+            let msg = format!(\"unnecessary `if let` since only the `{}` variant of the iterator element is used\", if_let_type);\n \n-        if_chain! {\n-            if let Some(inner_expr) = inner_expr;\n-            if let Some(higher::IfLet { let_pat, let_expr, if_then, if_else: None })\n-                = higher::IfLet::hir(cx, inner_expr);\n-            // Ensure match_expr in `if let` statement is the same as the pat from the for-loop\n-            if let PatKind::Binding(_, pat_hir_id, _, _) = pat.kind;\n-            if path_to_local_id(let_expr, pat_hir_id);\n-            // Ensure the `if let` statement is for the `Some` variant of `Option` or the `Ok` variant of `Result`\n-            if let PatKind::TupleStruct(ref qpath, _, _) = let_pat.kind;\n-            let some_ctor = is_lang_ctor(cx, qpath, OptionSome);\n-            let ok_ctor = is_lang_ctor(cx, qpath, ResultOk);\n-            if some_ctor || ok_ctor;\n-            // Ensure epxr in `if let` is not used afterwards\n-            if !is_local_used(cx, if_then, pat_hir_id);\n-            then {\n-                let if_let_type = if some_ctor { \"Some\" } else { \"Ok\" };\n-                // Prepare the error message\n-                let msg = format!(\"unnecessary `if let` since only the `{}` variant of the iterator element is used\", if_let_type);\n-\n-                // Prepare the help message\n-                let mut applicability = Applicability::MaybeIncorrect;\n-                let arg_snippet = make_iterator_snippet(cx, arg, &mut applicability);\n-                let copied = match cx.typeck_results().expr_ty(let_expr).kind() {\n-                    ty::Ref(_, inner, _) => match inner.kind() {\n-                        ty::Ref(..) => \".copied()\",\n-                        _ => \"\"\n-                    }\n+            // Prepare the help message\n+            let mut applicability = Applicability::MaybeIncorrect;\n+            let arg_snippet = make_iterator_snippet(cx, arg, &mut applicability);\n+            let copied = match cx.typeck_results().expr_ty(let_expr).kind() {\n+                ty::Ref(_, inner, _) => match inner.kind() {\n+                    ty::Ref(..) => \".copied()\",\n                     _ => \"\"\n-                };\n+                }\n+                _ => \"\"\n+            };\n \n-                span_lint_and_then(\n-                    cx,\n-                    MANUAL_FLATTEN,\n-                    span,\n-                    &msg,\n-                    |diag| {\n-                        let sugg = format!(\"{}{}.flatten()\", arg_snippet, copied);\n-                        diag.span_suggestion(\n-                            arg.span,\n-                            \"try\",\n-                            sugg,\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                        diag.span_help(\n-                            inner_expr.span,\n-                            \"...and remove the `if let` statement in the for loop\",\n-                        );\n-                    }\n-                );\n-            }\n+            span_lint_and_then(\n+                cx,\n+                MANUAL_FLATTEN,\n+                span,\n+                &msg,\n+                |diag| {\n+                    let sugg = format!(\"{}{}.flatten()\", arg_snippet, copied);\n+                    diag.span_suggestion(\n+                        arg.span,\n+                        \"try\",\n+                        sugg,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                    diag.span_help(\n+                        inner_expr.span,\n+                        \"...and remove the `if let` statement in the for loop\",\n+                    );\n+                }\n+            );\n         }\n     }\n }"}, {"sha": "68ffcd1abfb18240ce55c9bc8be3ddafa92af3fd", "filename": "clippy_lints/src/loops/never_loop.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs?ref=48d939f5166a19529a9e4723ed3bf5bab2314563", "patch": "@@ -92,9 +92,7 @@ fn combine_branches(b1: NeverLoopResult, b2: NeverLoopResult) -> NeverLoopResult\n }\n \n fn never_loop_block(block: &Block<'_>, main_loop_id: HirId) -> NeverLoopResult {\n-    let stmts = block.stmts.iter().map(stmt_to_expr);\n-    let expr = once(block.expr);\n-    let mut iter = stmts.chain(expr).flatten();\n+    let mut iter = block.stmts.iter().filter_map(stmt_to_expr).chain(block.expr);\n     never_loop_expr_seq(&mut iter, main_loop_id)\n }\n "}, {"sha": "34a70ca76c6a2a81df2d5ab1e4b1ec35c4a673ed", "filename": "clippy_lints/src/manual_map.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_map.rs?ref=48d939f5166a19529a9e4723ed3bf5bab2314563", "patch": "@@ -5,7 +5,7 @@ use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n use clippy_utils::ty::{is_type_diagnostic_item, peel_mid_ty_refs_is_mutable, type_is_unsafe_function};\n use clippy_utils::{\n     can_move_expr_to_closure, in_constant, is_else_clause, is_lang_ctor, is_lint_allowed, path_to_local_id,\n-    peel_hir_expr_refs, peel_hir_expr_while, CaptureKind,\n+    peel_blocks, peel_hir_expr_refs, peel_hir_expr_while, CaptureKind,\n };\n use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_errors::Applicability;\n@@ -307,16 +307,5 @@ fn get_some_expr(\n \n // Checks for the `None` value.\n fn is_none_expr(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n-    match expr.kind {\n-        ExprKind::Path(ref qpath) => is_lang_ctor(cx, qpath, OptionNone),\n-        ExprKind::Block(\n-            Block {\n-                stmts: [],\n-                expr: Some(expr),\n-                ..\n-            },\n-            _,\n-        ) => is_none_expr(cx, expr),\n-        _ => false,\n-    }\n+    matches!(peel_blocks(expr).kind, ExprKind::Path(ref qpath) if is_lang_ctor(cx, qpath, OptionNone))\n }"}, {"sha": "174c7da28d3ec1f246deac0c3dd52274aed9e1f9", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=48d939f5166a19529a9e4723ed3bf5bab2314563", "patch": "@@ -1,8 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::is_trait_method;\n-use clippy_utils::remove_blocks;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::{is_copy, is_type_diagnostic_item};\n+use clippy_utils::{is_trait_method, peel_blocks};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n@@ -60,7 +59,7 @@ impl<'tcx> LateLintPass<'tcx> for MapClone {\n             if let hir::ExprKind::Closure(_, _, body_id, _, _) = args[1].kind;\n             then {\n                 let closure_body = cx.tcx.hir().body(body_id);\n-                let closure_expr = remove_blocks(&closure_body.value);\n+                let closure_expr = peel_blocks(&closure_body.value);\n                 match closure_body.params[0].pat.kind {\n                     hir::PatKind::Ref(inner, hir::Mutability::Not) => if let hir::PatKind::Binding(\n                         hir::BindingAnnotation::Unannotated, .., name, None"}, {"sha": "385232f4d7138c1ce68bbfb895024fa0cbcf37d0", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=48d939f5166a19529a9e4723ed3bf5bab2314563", "patch": "@@ -9,7 +9,7 @@ use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, match_type, pe\n use clippy_utils::visitors::is_local_used;\n use clippy_utils::{\n     get_parent_expr, is_expn_of, is_lang_ctor, is_lint_allowed, is_refutable, is_unit_expr, is_wild, meets_msrv, msrvs,\n-    path_to_local, path_to_local_id, peel_hir_pat_refs, peel_n_hir_expr_refs, recurse_or_patterns, remove_blocks,\n+    path_to_local, path_to_local_id, peel_blocks, peel_hir_pat_refs, peel_n_hir_expr_refs, recurse_or_patterns,\n     strip_pat_refs,\n };\n use clippy_utils::{paths, search_same, SpanlessEq, SpanlessHash};\n@@ -659,7 +659,7 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n                 QPath::Resolved(None, variant_name), args, _) = arms[0].pat.kind;\n             if args.len() == 1;\n             if let PatKind::Binding(_, arg, ..) = strip_pat_refs(&args[0]).kind;\n-            let body = remove_blocks(arms[0].body);\n+            let body = peel_blocks(arms[0].body);\n             if path_to_local_id(body, arg);\n \n             then {\n@@ -724,7 +724,7 @@ fn check_single_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], exp\n             return;\n         }\n         let els = arms[1].body;\n-        let els = if is_unit_expr(remove_blocks(els)) {\n+        let els = if is_unit_expr(peel_blocks(els)) {\n             None\n         } else if let ExprKind::Block(Block { stmts, expr: block_expr, .. }, _) = els.kind {\n             if stmts.len() == 1 && block_expr.is_none() || stmts.is_empty() && block_expr.is_some() {\n@@ -1482,7 +1482,7 @@ fn check_match_single_binding<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[A\n \n     let matched_vars = ex.span;\n     let bind_names = arms[0].pat.span;\n-    let match_body = remove_blocks(arms[0].body);\n+    let match_body = peel_blocks(arms[0].body);\n     let mut snippet_body = if match_body.span.from_expansion() {\n         Sugg::hir_with_macro_callsite(cx, match_body, \"..\").to_string()\n     } else {\n@@ -1679,7 +1679,7 @@ fn is_ref_some_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> Option<BindingAnnotat\n         if is_lang_ctor(cx, qpath, OptionSome);\n         if let PatKind::Binding(rb, .., ident, _) = first_pat.kind;\n         if rb == BindingAnnotation::Ref || rb == BindingAnnotation::RefMut;\n-        if let ExprKind::Call(e, args) = remove_blocks(arm.body).kind;\n+        if let ExprKind::Call(e, args) = peel_blocks(arm.body).kind;\n         if let ExprKind::Path(ref some_path) = e.kind;\n         if is_lang_ctor(cx, some_path, OptionSome) && args.len() == 1;\n         if let ExprKind::Path(QPath::Resolved(_, path2)) = args[0].kind;"}, {"sha": "150bafc0f5db228f216127d3382c0be03e8ec353", "filename": "clippy_lints/src/methods/bind_instead_of_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fbind_instead_of_map.rs?ref=48d939f5166a19529a9e4723ed3bf5bab2314563", "patch": "@@ -1,7 +1,7 @@\n use super::{contains_return, BIND_INSTEAD_OF_MAP};\n use clippy_utils::diagnostics::{multispan_sugg_with_applicability, span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::{snippet, snippet_with_macro_callsite};\n-use clippy_utils::{remove_blocks, visitors::find_all_ret_expressions};\n+use clippy_utils::{peel_blocks, visitors::find_all_ret_expressions};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n@@ -152,7 +152,7 @@ pub(crate) trait BindInsteadOfMap {\n         match arg.kind {\n             hir::ExprKind::Closure(_, _, body_id, closure_args_span, _) => {\n                 let closure_body = cx.tcx.hir().body(body_id);\n-                let closure_expr = remove_blocks(&closure_body.value);\n+                let closure_expr = peel_blocks(&closure_body.value);\n \n                 if Self::lint_closure_autofixable(cx, expr, recv, closure_expr, closure_args_span) {\n                     true"}, {"sha": "6d8733c08b43012b5870de5e382410baa783cbfb", "filename": "clippy_lints/src/methods/filter_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map.rs?ref=48d939f5166a19529a9e4723ed3bf5bab2314563", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::{indent_of, reindent_multiline, snippet};\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{is_trait_method, path_to_local_id, remove_blocks, SpanlessEq};\n+use clippy_utils::{is_trait_method, path_to_local_id, peel_blocks, SpanlessEq};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n@@ -25,7 +25,7 @@ fn is_method<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, method_name: Sy\n         },\n         hir::ExprKind::Closure(_, _, c, _, _) => {\n             let body = cx.tcx.hir().body(*c);\n-            let closure_expr = remove_blocks(&body.value);\n+            let closure_expr = peel_blocks(&body.value);\n             let arg_id = body.params[0].pat.hir_id;\n             match closure_expr.kind {\n                 hir::ExprKind::MethodCall(hir::PathSegment { ident, .. }, _, args, _) => {"}, {"sha": "fa74a8f3dc363b8a7df525d59c5df03650153f4f", "filename": "clippy_lints/src/methods/option_as_ref_deref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs?ref=48d939f5166a19529a9e4723ed3bf5bab2314563", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{match_def_path, meets_msrv, msrvs, path_to_local_id, paths, remove_blocks};\n+use clippy_utils::{match_def_path, meets_msrv, msrvs, path_to_local_id, paths, peel_blocks};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n@@ -53,7 +53,7 @@ pub(super) fn check<'tcx>(\n             }),\n         hir::ExprKind::Closure(_, _, body_id, _, _) => {\n             let closure_body = cx.tcx.hir().body(body_id);\n-            let closure_expr = remove_blocks(&closure_body.value);\n+            let closure_expr = peel_blocks(&closure_body.value);\n \n             match &closure_expr.kind {\n                 hir::ExprKind::MethodCall(_, _, args, _) => {"}, {"sha": "47a811996085e59d95fa98475a33a0a367a9f1d8", "filename": "clippy_lints/src/methods/unnecessary_fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_fold.rs?ref=48d939f5166a19529a9e4723ed3bf5bab2314563", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::{is_trait_method, path_to_local_id, remove_blocks, strip_pat_refs};\n+use clippy_utils::{is_trait_method, path_to_local_id, peel_blocks, strip_pat_refs};\n use if_chain::if_chain;\n use rustc_ast::ast;\n use rustc_errors::Applicability;\n@@ -31,7 +31,7 @@ pub(super) fn check(\n             // Extract the body of the closure passed to fold\n             if let hir::ExprKind::Closure(_, _, body_id, _, _) = acc.kind;\n             let closure_body = cx.tcx.hir().body(body_id);\n-            let closure_expr = remove_blocks(&closure_body.value);\n+            let closure_expr = peel_blocks(&closure_body.value);\n \n             // Check if the closure body is of the form `acc <op> some_expr(x)`\n             if let hir::ExprKind::Binary(ref bin_op, left_expr, right_expr) = closure_expr.kind;"}, {"sha": "d391fbecf82e14ea9b2cffde2267704bd6f8ecf4", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 19, "deletions": 44, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=48d939f5166a19529a9e4723ed3bf5bab2314563", "patch": "@@ -6,10 +6,10 @@ use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg};\n use clippy_utils::higher;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::sugg::Sugg;\n-use clippy_utils::{get_parent_node, is_else_clause, is_expn_of};\n+use clippy_utils::{get_parent_node, is_else_clause, is_expn_of, peel_blocks, peel_blocks_with_stmt};\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n-use rustc_hir::{BinOpKind, Block, Expr, ExprKind, HirId, Node, StmtKind, UnOp};\n+use rustc_hir::{BinOpKind, Block, Expr, ExprKind, HirId, Node, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Spanned;\n@@ -143,8 +143,8 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBool {\n                     applicability,\n                 );\n             };\n-            if let ExprKind::Block(then, _) = then.kind {\n-                match (fetch_bool_block(then), fetch_bool_expr(r#else)) {\n+            if let Some((a, b)) = fetch_bool_block(then).and_then(|a| Some((a, fetch_bool_block(r#else)?))) {\n+                match (a, b) {\n                     (RetBool(true), RetBool(true)) | (Bool(true), Bool(true)) => {\n                         span_lint(\n                             cx,\n@@ -167,8 +167,6 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBool {\n                     (Bool(false), Bool(true)) => reduce(false, true),\n                     _ => (),\n                 }\n-            } else {\n-                panic!(\"IfExpr `then` node is not an `ExprKind::Block`\");\n             }\n         }\n     }\n@@ -271,8 +269,6 @@ fn check_comparison<'a, 'tcx>(\n     right_false: Option<(impl FnOnce(Sugg<'a>) -> Sugg<'a>, &str)>,\n     no_literal: Option<(impl FnOnce(Sugg<'a>, Sugg<'a>) -> Sugg<'a>, &str)>,\n ) {\n-    use self::Expression::{Bool, Other};\n-\n     if let ExprKind::Binary(op, left_side, right_side) = e.kind {\n         let (l_ty, r_ty) = (\n             cx.typeck_results().expr_ty(left_side),\n@@ -304,19 +300,19 @@ fn check_comparison<'a, 'tcx>(\n             }\n \n             match (fetch_bool_expr(left_side), fetch_bool_expr(right_side)) {\n-                (Bool(true), Other) => left_true.map_or((), |(h, m)| {\n+                (Some(true), None) => left_true.map_or((), |(h, m)| {\n                     suggest_bool_comparison(cx, e, right_side, applicability, m, h);\n                 }),\n-                (Other, Bool(true)) => right_true.map_or((), |(h, m)| {\n+                (None, Some(true)) => right_true.map_or((), |(h, m)| {\n                     suggest_bool_comparison(cx, e, left_side, applicability, m, h);\n                 }),\n-                (Bool(false), Other) => left_false.map_or((), |(h, m)| {\n+                (Some(false), None) => left_false.map_or((), |(h, m)| {\n                     suggest_bool_comparison(cx, e, right_side, applicability, m, h);\n                 }),\n-                (Other, Bool(false)) => right_false.map_or((), |(h, m)| {\n+                (None, Some(false)) => right_false.map_or((), |(h, m)| {\n                     suggest_bool_comparison(cx, e, left_side, applicability, m, h);\n                 }),\n-                (Other, Other) => no_literal.map_or((), |(h, m)| {\n+                (None, None) => no_literal.map_or((), |(h, m)| {\n                     let left_side = Sugg::hir_with_applicability(cx, left_side, \"..\", &mut applicability);\n                     let right_side = Sugg::hir_with_applicability(cx, right_side, \"..\", &mut applicability);\n                     span_lint_and_sugg(\n@@ -365,41 +361,20 @@ fn suggest_bool_comparison<'a, 'tcx>(\n enum Expression {\n     Bool(bool),\n     RetBool(bool),\n-    Other,\n }\n \n-fn fetch_bool_block(block: &Block<'_>) -> Expression {\n-    match (&*block.stmts, block.expr.as_ref()) {\n-        (&[], Some(e)) => fetch_bool_expr(&**e),\n-        (&[ref e], None) => {\n-            if let StmtKind::Semi(e) = e.kind {\n-                if let ExprKind::Ret(_) = e.kind {\n-                    fetch_bool_expr(e)\n-                } else {\n-                    Expression::Other\n-                }\n-            } else {\n-                Expression::Other\n-            }\n-        },\n-        _ => Expression::Other,\n+fn fetch_bool_block(expr: &Expr<'_>) -> Option<Expression> {\n+    match peel_blocks_with_stmt(expr).kind {\n+        ExprKind::Ret(Some(ret)) => Some(Expression::RetBool(fetch_bool_expr(ret)?)),\n+        _ => Some(Expression::Bool(fetch_bool_expr(expr)?)),\n     }\n }\n \n-fn fetch_bool_expr(expr: &Expr<'_>) -> Expression {\n-    match expr.kind {\n-        ExprKind::Block(block, _) => fetch_bool_block(block),\n-        ExprKind::Lit(ref lit_ptr) => {\n-            if let LitKind::Bool(value) = lit_ptr.node {\n-                Expression::Bool(value)\n-            } else {\n-                Expression::Other\n-            }\n-        },\n-        ExprKind::Ret(Some(expr)) => match fetch_bool_expr(expr) {\n-            Expression::Bool(value) => Expression::RetBool(value),\n-            _ => Expression::Other,\n-        },\n-        _ => Expression::Other,\n+fn fetch_bool_expr(expr: &Expr<'_>) -> Option<bool> {\n+    if let ExprKind::Lit(ref lit_ptr) = peel_blocks(expr).kind {\n+        if let LitKind::Bool(value) = lit_ptr.node {\n+            return Some(value);\n+        }\n     }\n+    None\n }"}, {"sha": "9d5babc5de840d69e3f5941cc0459a5420fd2ed2", "filename": "clippy_lints/src/no_effect.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fno_effect.rs?ref=48d939f5166a19529a9e4723ed3bf5bab2314563", "patch": "@@ -1,5 +1,6 @@\n use clippy_utils::diagnostics::{span_lint_hir, span_lint_hir_and_then};\n use clippy_utils::is_lint_allowed;\n+use clippy_utils::peel_blocks;\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::has_drop;\n use rustc_errors::Applicability;\n@@ -114,7 +115,7 @@ fn has_no_effect(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     if expr.span.from_expansion() {\n         return false;\n     }\n-    match expr.kind {\n+    match peel_blocks(expr).kind {\n         ExprKind::Lit(..) | ExprKind::Closure(..) => true,\n         ExprKind::Path(..) => !has_drop(cx, cx.typeck_results().expr_ty(expr)),\n         ExprKind::Index(a, b) | ExprKind::Binary(_, a, b) => has_no_effect(cx, a) && has_no_effect(cx, b),\n@@ -150,9 +151,6 @@ fn has_no_effect(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n                 false\n             }\n         },\n-        ExprKind::Block(block, _) => {\n-            block.stmts.is_empty() && block.expr.as_ref().map_or(false, |expr| has_no_effect(cx, expr))\n-        },\n         _ => false,\n     }\n }"}, {"sha": "897207ebf50b78a9b0f1da4e4d4da94b7222aac5", "filename": "clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 5, "deletions": 28, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=48d939f5166a19529a9e4723ed3bf5bab2314563", "patch": "@@ -1,15 +1,14 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::higher;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::{\n-    can_move_expr_to_closure, eager_or_lazy, in_constant, is_else_clause, is_lang_ctor, peel_hir_expr_while,\n-    CaptureKind,\n+    can_move_expr_to_closure, eager_or_lazy, higher, in_constant, is_else_clause, is_lang_ctor, peel_blocks,\n+    peel_hir_expr_while, CaptureKind,\n };\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::OptionSome;\n-use rustc_hir::{def::Res, BindingAnnotation, Block, Expr, ExprKind, Mutability, PatKind, Path, QPath, UnOp};\n+use rustc_hir::{def::Res, BindingAnnotation, Expr, ExprKind, Mutability, PatKind, Path, QPath, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n@@ -86,28 +85,6 @@ struct OptionIfLetElseOccurence {\n     none_expr: String,\n }\n \n-/// Extracts the body of a given arm. If the arm contains only an expression,\n-/// then it returns the expression. Otherwise, it returns the entire block\n-fn extract_body_from_expr<'a>(expr: &'a Expr<'a>) -> Option<&'a Expr<'a>> {\n-    if let ExprKind::Block(\n-        Block {\n-            stmts: block_stmts,\n-            expr: Some(block_expr),\n-            ..\n-        },\n-        _,\n-    ) = expr.kind\n-    {\n-        if let [] = block_stmts {\n-            Some(block_expr)\n-        } else {\n-            Some(expr)\n-        }\n-    } else {\n-        None\n-    }\n-}\n-\n fn format_option_in_sugg(cx: &LateContext<'_>, cond_expr: &Expr<'_>, as_ref: bool, as_mut: bool) -> String {\n     format!(\n         \"{}{}\",\n@@ -145,8 +122,8 @@ fn detect_option_if_let_else<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) ->\n \n         then {\n             let capture_mut = if bind_annotation == &BindingAnnotation::Mutable { \"mut \" } else { \"\" };\n-            let some_body = extract_body_from_expr(if_then)?;\n-            let none_body = extract_body_from_expr(if_else)?;\n+            let some_body = peel_blocks(if_then);\n+            let none_body = peel_blocks(if_else);\n             let method_sugg = if eager_or_lazy::switch_to_eager_eval(cx, none_body) { \"map_or\" } else { \"map_or_else\" };\n             let capture_name = id.name.to_ident_string();\n             let (as_ref, as_mut) = match &let_expr.kind {"}, {"sha": "65a962dcd217654c778b149ca6bf27b4db5a9f77", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 7, "deletions": 56, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=48d939f5166a19529a9e4723ed3bf5bab2314563", "patch": "@@ -1,14 +1,13 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::higher;\n-use clippy_utils::is_lang_ctor;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{eq_expr_value, path_to_local, path_to_local_id};\n+use clippy_utils::{eq_expr_value, is_lang_ctor, path_to_local, path_to_local_id, peel_blocks, peel_blocks_with_stmt};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionNone, OptionSome, ResultOk};\n-use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, PatKind, StmtKind};\n+use rustc_hir::{BindingAnnotation, Expr, ExprKind, PatKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n@@ -68,14 +67,8 @@ impl QuestionMark {\n                 let receiver_str = &Sugg::hir_with_applicability(cx, subject, \"..\", &mut applicability);\n                 let mut replacement: Option<String> = None;\n                 if let Some(else_inner) = r#else {\n-                    if_chain! {\n-                        if let ExprKind::Block(block, None) = &else_inner.kind;\n-                        if block.stmts.is_empty();\n-                        if let Some(block_expr) = &block.expr;\n-                        if eq_expr_value(cx, subject, block_expr);\n-                        then {\n-                            replacement = Some(format!(\"Some({}?)\", receiver_str));\n-                        }\n+                    if eq_expr_value(cx, subject, peel_blocks(else_inner)) {\n+                        replacement = Some(format!(\"Some({}?)\", receiver_str));\n                     }\n                 } else if Self::moves_by_default(cx, subject)\n                     && !matches!(subject.kind, ExprKind::Call(..) | ExprKind::MethodCall(..))\n@@ -110,10 +103,7 @@ impl QuestionMark {\n \n             if let PatKind::Binding(annot, bind_id, _, _) = fields[0].kind;\n             let by_ref = matches!(annot, BindingAnnotation::Ref | BindingAnnotation::RefMut);\n-            if let ExprKind::Block(block, None) = if_then.kind;\n-            if block.stmts.is_empty();\n-            if let Some(trailing_expr) = &block.expr;\n-            if path_to_local_id(trailing_expr, bind_id);\n+            if path_to_local_id(peel_blocks(if_then), bind_id);\n             then {\n                 let mut applicability = Applicability::MachineApplicable;\n                 let receiver_str = snippet_with_applicability(cx, let_expr.span, \"..\", &mut applicability);\n@@ -159,59 +149,20 @@ impl QuestionMark {\n     }\n \n     fn expression_returns_none(cx: &LateContext<'_>, expression: &Expr<'_>) -> bool {\n-        match expression.kind {\n-            ExprKind::Block(block, _) => {\n-                if let Some(return_expression) = Self::return_expression(block) {\n-                    return Self::expression_returns_none(cx, return_expression);\n-                }\n-\n-                false\n-            },\n+        match peel_blocks_with_stmt(expression).kind {\n             ExprKind::Ret(Some(expr)) => Self::expression_returns_none(cx, expr),\n             ExprKind::Path(ref qpath) => is_lang_ctor(cx, qpath, OptionNone),\n             _ => false,\n         }\n     }\n \n     fn expression_returns_unmodified_err(cx: &LateContext<'_>, expr: &Expr<'_>, cond_expr: &Expr<'_>) -> bool {\n-        match expr.kind {\n-            ExprKind::Block(block, _) => {\n-                if let Some(return_expression) = Self::return_expression(block) {\n-                    return Self::expression_returns_unmodified_err(cx, return_expression, cond_expr);\n-                }\n-\n-                false\n-            },\n+        match peel_blocks_with_stmt(expr).kind {\n             ExprKind::Ret(Some(ret_expr)) => Self::expression_returns_unmodified_err(cx, ret_expr, cond_expr),\n             ExprKind::Path(_) => path_to_local(expr) == path_to_local(cond_expr),\n             _ => false,\n         }\n     }\n-\n-    fn return_expression<'tcx>(block: &Block<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n-        // Check if last expression is a return statement. Then, return the expression\n-        if_chain! {\n-            if block.stmts.len() == 1;\n-            if let Some(expr) = block.stmts.iter().last();\n-            if let StmtKind::Semi(expr) = expr.kind;\n-            if let ExprKind::Ret(Some(ret_expr)) = expr.kind;\n-\n-            then {\n-                return Some(ret_expr);\n-            }\n-        }\n-\n-        // Check for `return` without a semicolon.\n-        if_chain! {\n-            if block.stmts.is_empty();\n-            if let Some(ExprKind::Ret(Some(ret_expr))) = block.expr.as_ref().map(|e| &e.kind);\n-            then {\n-                return Some(ret_expr);\n-            }\n-        }\n-\n-        None\n-    }\n }\n \n impl<'tcx> LateLintPass<'tcx> for QuestionMark {"}, {"sha": "b03f4583365ea8ca3a68ffccab46bf435ea145cd", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=48d939f5166a19529a9e4723ed3bf5bab2314563", "patch": "@@ -1,8 +1,8 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_sugg};\n use clippy_utils::source::{snippet, snippet_with_applicability};\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::SpanlessEq;\n use clippy_utils::{get_parent_expr, is_lint_allowed, match_function_call, method_calls, paths};\n+use clippy_utils::{peel_blocks, SpanlessEq};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, BorrowKind, Expr, ExprKind, LangItem, QPath};\n@@ -201,17 +201,14 @@ fn is_string(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n }\n \n fn is_add(cx: &LateContext<'_>, src: &Expr<'_>, target: &Expr<'_>) -> bool {\n-    match src.kind {\n+    match peel_blocks(src).kind {\n         ExprKind::Binary(\n             Spanned {\n                 node: BinOpKind::Add, ..\n             },\n             left,\n             _,\n         ) => SpanlessEq::new(cx).eq_expr(target, left),\n-        ExprKind::Block(block, _) => {\n-            block.stmts.is_empty() && block.expr.as_ref().map_or(false, |expr| is_add(cx, expr, target))\n-        },\n         _ => false,\n     }\n }"}, {"sha": "81e9c2e15c97a19b8a4d7220b90576a998b06dc9", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=48d939f5166a19529a9e4723ed3bf5bab2314563", "patch": "@@ -1,11 +1,10 @@\n use clippy_utils::consts::{constant_simple, Constant};\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then};\n-use clippy_utils::higher;\n use clippy_utils::source::snippet;\n use clippy_utils::ty::match_type;\n use clippy_utils::{\n-    is_else_clause, is_expn_of, is_expr_path_def_path, is_lint_allowed, match_def_path, method_calls, path_to_res,\n-    paths, SpanlessEq,\n+    higher, is_else_clause, is_expn_of, is_expr_path_def_path, is_lint_allowed, match_def_path, method_calls,\n+    path_to_res, paths, peel_blocks_with_stmt, SpanlessEq,\n };\n use if_chain::if_chain;\n use rustc_ast as ast;\n@@ -662,10 +661,7 @@ impl<'tcx> LateLintPass<'tcx> for CollapsibleCalls {\n             if and_then_args.len() == 5;\n             if let ExprKind::Closure(_, _, body_id, _, _) = &and_then_args[4].kind;\n             let body = cx.tcx.hir().body(*body_id);\n-            if let ExprKind::Block(block, _) = &body.value.kind;\n-            let stmts = &block.stmts;\n-            if stmts.len() == 1 && block.expr.is_none();\n-            if let StmtKind::Semi(only_expr) = &stmts[0].kind;\n+            let only_expr = peel_blocks_with_stmt(&body.value);\n             if let ExprKind::MethodCall(ps, _, span_call_args, _) = &only_expr.kind;\n             then {\n                 let and_then_snippets = get_and_then_snippets(cx, and_then_args);"}, {"sha": "7707eebd6223e2cb01ab4b0b4bd559ab3fc7aa6c", "filename": "clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=48d939f5166a19529a9e4723ed3bf5bab2314563", "patch": "@@ -8,6 +8,11 @@\n //! during any comparison or mapping. (Please take care of this, it's not fun to spend time on such\n //! a simple mistake)\n \n+use crate::utils::internal_lints::{extract_clippy_version_value, is_lint_ref_type};\n+\n+use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::ty::{match_type, walk_ptrs_ty_depth};\n+use clippy_utils::{last_path_segment, match_def_path, match_function_call, match_path, paths};\n use if_chain::if_chain;\n use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashMap;\n@@ -25,12 +30,6 @@ use std::fs::{self, OpenOptions};\n use std::io::prelude::*;\n use std::path::Path;\n \n-use crate::utils::internal_lints::{extract_clippy_version_value, is_lint_ref_type};\n-use clippy_utils::{\n-    diagnostics::span_lint, last_path_segment, match_def_path, match_function_call, match_path, paths, ty::match_type,\n-    ty::walk_ptrs_ty_depth,\n-};\n-\n /// This is the output file of the lint collector.\n const OUTPUT_FILE: &str = \"../util/gh-pages/lints.json\";\n /// These lints are excluded from the export."}, {"sha": "4e21436143503142ef43a798b79ccba5c8e2cf3e", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 68, "deletions": 18, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d939f5166a19529a9e4723ed3bf5bab2314563/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=48d939f5166a19529a9e4723ed3bf5bab2314563", "patch": "@@ -73,10 +73,10 @@ use rustc_hir::intravisit::{walk_expr, ErasedMap, FnKind, NestedVisitorMap, Visi\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::LangItem::{OptionNone, ResultErr, ResultOk};\n use rustc_hir::{\n-    def, Arm, BindingAnnotation, Block, Body, Constness, Destination, Expr, ExprKind, FnDecl, ForeignItem, GenericArgs,\n-    HirId, Impl, ImplItem, ImplItemKind, IsAsync, Item, ItemKind, LangItem, Local, MatchSource, Mutability, Node,\n-    Param, Pat, PatKind, Path, PathSegment, PrimTy, QPath, Stmt, StmtKind, TraitItem, TraitItemKind, TraitRef, TyKind,\n-    UnOp,\n+    def, Arm, BindingAnnotation, Block, BlockCheckMode, Body, Constness, Destination, Expr, ExprKind, FnDecl,\n+    ForeignItem, GenericArgs, HirId, Impl, ImplItem, ImplItemKind, IsAsync, Item, ItemKind, LangItem, Local,\n+    MatchSource, Mutability, Node, Param, Pat, PatKind, Path, PathSegment, PrimTy, QPath, Stmt, StmtKind, TraitItem,\n+    TraitItemKind, TraitRef, TyKind, UnOp,\n };\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n use rustc_middle::hir::exports::Export;\n@@ -1224,6 +1224,70 @@ pub fn get_parent_as_impl(tcx: TyCtxt<'_>, id: HirId) -> Option<&Impl<'_>> {\n     }\n }\n \n+/// Removes blocks around an expression, only if the block contains just one expression\n+/// and no statements. Unsafe blocks are not removed.\n+///\n+/// Examples:\n+///  * `{}`               -> `{}`\n+///  * `{ x }`            -> `x`\n+///  * `{{ x }}`          -> `x`\n+///  * `{ x; }`           -> `{ x; }`\n+///  * `{ x; y }`         -> `{ x; y }`\n+///  * `{ unsafe { x } }` -> `unsafe { x }`\n+pub fn peel_blocks<'a>(mut expr: &'a Expr<'a>) -> &'a Expr<'a> {\n+    while let ExprKind::Block(\n+        Block {\n+            stmts: [],\n+            expr: Some(inner),\n+            rules: BlockCheckMode::DefaultBlock,\n+            ..\n+        },\n+        _,\n+    ) = expr.kind\n+    {\n+        expr = inner;\n+    }\n+    expr\n+}\n+\n+/// Removes blocks around an expression, only if the block contains just one expression\n+/// or just one expression statement with a semicolon. Unsafe blocks are not removed.\n+///\n+/// Examples:\n+///  * `{}`               -> `{}`\n+///  * `{ x }`            -> `x`\n+///  * `{ x; }`           -> `x`\n+///  * `{{ x; }}`         -> `x`\n+///  * `{ x; y }`         -> `{ x; y }`\n+///  * `{ unsafe { x } }` -> `unsafe { x }`\n+pub fn peel_blocks_with_stmt<'a>(mut expr: &'a Expr<'a>) -> &'a Expr<'a> {\n+    while let ExprKind::Block(\n+        Block {\n+            stmts: [],\n+            expr: Some(inner),\n+            rules: BlockCheckMode::DefaultBlock,\n+            ..\n+        }\n+        | Block {\n+            stmts:\n+                [\n+                    Stmt {\n+                        kind: StmtKind::Expr(inner) | StmtKind::Semi(inner),\n+                        ..\n+                    },\n+                ],\n+            expr: None,\n+            rules: BlockCheckMode::DefaultBlock,\n+            ..\n+        },\n+        _,\n+    ) = expr.kind\n+    {\n+        expr = inner;\n+    }\n+    expr\n+}\n+\n /// Checks if the given expression is the else clause of either an `if` or `if let` expression.\n pub fn is_else_clause(tcx: TyCtxt<'_>, expr: &Expr<'_>) -> bool {\n     let mut iter = tcx.hir().parent_iter(expr.hir_id);\n@@ -1405,20 +1469,6 @@ pub fn is_automatically_derived(attrs: &[ast::Attribute]) -> bool {\n     has_attr(attrs, sym::automatically_derived)\n }\n \n-/// Remove blocks around an expression.\n-///\n-/// Ie. `x`, `{ x }` and `{{{{ x }}}}` all give `x`. `{ x; y }` and `{}` return\n-/// themselves.\n-pub fn remove_blocks<'tcx>(mut expr: &'tcx Expr<'tcx>) -> &'tcx Expr<'tcx> {\n-    while let ExprKind::Block(block, ..) = expr.kind {\n-        match (block.stmts.is_empty(), block.expr.as_ref()) {\n-            (true, Some(e)) => expr = e,\n-            _ => break,\n-        }\n-    }\n-    expr\n-}\n-\n pub fn is_self(slf: &Param<'_>) -> bool {\n     if let PatKind::Binding(.., name, _) = slf.pat.kind {\n         name.name == kw::SelfLower"}]}