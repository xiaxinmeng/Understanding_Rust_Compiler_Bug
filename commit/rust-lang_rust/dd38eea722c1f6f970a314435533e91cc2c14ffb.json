{"sha": "dd38eea722c1f6f970a314435533e91cc2c14ffb", "node_id": "C_kwDOAAsO6NoAKGRkMzhlZWE3MjJjMWY2Zjk3MGEzMTQ0MzU1MzNlOTFjYzJjMTRmZmI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-07T15:33:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-07T15:33:22Z"}, "message": "Auto merge of #95706 - petrochenkov:doclink4, r=GuillaumeGomez\n\nrustdoc: Early doc link resolution fixes and refactorings\n\nA subset of https://github.com/rust-lang/rust/pull/94857 that shouldn't cause perf regressions, but should fix some issues like https://rust-lang.zulipchat.com/#narrow/stream/266220-rustdoc/topic/ICE.20in.20collect_intra_doc_links.2Ers https://github.com/rust-lang/rust/pull/95290 and improve performance in cases like https://github.com/rust-lang/rust/issues/95694.", "tree": {"sha": "c2bb42ec39969e2041f87cf398ba5f5815a7ff03", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2bb42ec39969e2041f87cf398ba5f5815a7ff03"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd38eea722c1f6f970a314435533e91cc2c14ffb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd38eea722c1f6f970a314435533e91cc2c14ffb", "html_url": "https://github.com/rust-lang/rust/commit/dd38eea722c1f6f970a314435533e91cc2c14ffb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd38eea722c1f6f970a314435533e91cc2c14ffb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa723160318fac5f3fa6f4141cfc41c0606a3008", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa723160318fac5f3fa6f4141cfc41c0606a3008", "html_url": "https://github.com/rust-lang/rust/commit/fa723160318fac5f3fa6f4141cfc41c0606a3008"}, {"sha": "69d6c3b2e6daa58e24ccec31961fe9d59fa332bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/69d6c3b2e6daa58e24ccec31961fe9d59fa332bb", "html_url": "https://github.com/rust-lang/rust/commit/69d6c3b2e6daa58e24ccec31961fe9d59fa332bb"}], "stats": {"total": 293, "additions": 180, "deletions": 113}, "files": [{"sha": "3402acccf3f9286b5f861acac75e06cac7ce1524", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dd38eea722c1f6f970a314435533e91cc2c14ffb/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd38eea722c1f6f970a314435533e91cc2c14ffb/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=dd38eea722c1f6f970a314435533e91cc2c14ffb", "patch": "@@ -1169,14 +1169,18 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn get_associated_item_def_ids(self, tcx: TyCtxt<'tcx>, id: DefIndex) -> &'tcx [DefId] {\n-        if let Some(children) = self.root.tables.children.get(self, id) {\n-            tcx.arena.alloc_from_iter(\n-                children.decode((self, tcx.sess)).map(|child_index| self.local_def_id(child_index)),\n-            )\n-        } else {\n-            &[]\n-        }\n+    fn get_associated_item_def_ids(\n+        self,\n+        id: DefIndex,\n+        sess: &'a Session,\n+    ) -> impl Iterator<Item = DefId> + 'a {\n+        self.root\n+            .tables\n+            .children\n+            .get(self, id)\n+            .unwrap_or_else(Lazy::empty)\n+            .decode((self, sess))\n+            .map(move |child_index| self.local_def_id(child_index))\n     }\n \n     fn get_associated_item(self, id: DefIndex) -> ty::AssocItem {"}, {"sha": "63bf929fb86393a7bc4b102dcd54dca606bb9865", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dd38eea722c1f6f970a314435533e91cc2c14ffb/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd38eea722c1f6f970a314435533e91cc2c14ffb/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=dd38eea722c1f6f970a314435533e91cc2c14ffb", "patch": "@@ -160,7 +160,9 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n         let _ = cdata;\n         tcx.calculate_dtor(def_id, |_,_| Ok(()))\n     }\n-    associated_item_def_ids => { cdata.get_associated_item_def_ids(tcx, def_id.index) }\n+    associated_item_def_ids => {\n+        tcx.arena.alloc_from_iter(cdata.get_associated_item_def_ids(def_id.index, tcx.sess))\n+    }\n     associated_item => { cdata.get_associated_item(def_id.index) }\n     inherent_impls => { cdata.get_inherent_implementations_for_type(tcx, def_id.index) }\n     is_foreign_item => { cdata.is_foreign_item(def_id.index) }"}, {"sha": "07d261da8132fd5a46058f36b97c630b137e3122", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dd38eea722c1f6f970a314435533e91cc2c14ffb/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd38eea722c1f6f970a314435533e91cc2c14ffb/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=dd38eea722c1f6f970a314435533e91cc2c14ffb", "patch": "@@ -1248,7 +1248,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             };\n             let binding = (res, vis, span, expansion).to_name_binding(self.r.arenas);\n             self.r.set_binding_parent_module(binding, parent_scope.module);\n-            self.r.all_macros.insert(ident.name, res);\n+            self.r.all_macro_rules.insert(ident.name, res);\n             if is_macro_export {\n                 let module = self.r.graph_root;\n                 self.r.define(module, ident, MacroNS, (res, vis, span, expansion, IsMacroExport));"}, {"sha": "a09a225a2b5d75925bb686430e69cb2fe49abe79", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dd38eea722c1f6f970a314435533e91cc2c14ffb/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd38eea722c1f6f970a314435533e91cc2c14ffb/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=dd38eea722c1f6f970a314435533e91cc2c14ffb", "patch": "@@ -1003,7 +1003,8 @@ pub struct Resolver<'a> {\n     registered_attrs: FxHashSet<Ident>,\n     registered_tools: RegisteredTools,\n     macro_use_prelude: FxHashMap<Symbol, &'a NameBinding<'a>>,\n-    all_macros: FxHashMap<Symbol, Res>,\n+    /// FIXME: The only user of this is a doc link resolution hack for rustdoc.\n+    all_macro_rules: FxHashMap<Symbol, Res>,\n     macro_map: FxHashMap<DefId, Lrc<SyntaxExtension>>,\n     dummy_ext_bang: Lrc<SyntaxExtension>,\n     dummy_ext_derive: Lrc<SyntaxExtension>,\n@@ -1385,7 +1386,7 @@ impl<'a> Resolver<'a> {\n             registered_attrs,\n             registered_tools,\n             macro_use_prelude: FxHashMap::default(),\n-            all_macros: FxHashMap::default(),\n+            all_macro_rules: Default::default(),\n             macro_map: FxHashMap::default(),\n             dummy_ext_bang: Lrc::new(SyntaxExtension::dummy_bang(session.edition())),\n             dummy_ext_derive: Lrc::new(SyntaxExtension::dummy_derive(session.edition())),\n@@ -3311,8 +3312,8 @@ impl<'a> Resolver<'a> {\n     }\n \n     // For rustdoc.\n-    pub fn all_macros(&self) -> &FxHashMap<Symbol, Res> {\n-        &self.all_macros\n+    pub fn take_all_macro_rules(&mut self) -> FxHashMap<Symbol, Res> {\n+        mem::take(&mut self.all_macro_rules)\n     }\n \n     /// For rustdoc."}, {"sha": "9d5ae68b3e46f9913df2c86e171fa61b7cdb2bec", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dd38eea722c1f6f970a314435533e91cc2c14ffb/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd38eea722c1f6f970a314435533e91cc2c14ffb/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=dd38eea722c1f6f970a314435533e91cc2c14ffb", "patch": "@@ -1,3 +1,4 @@\n+use rustc_ast::NodeId;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::{self, Lrc};\n use rustc_errors::emitter::{Emitter, EmitterWriter};\n@@ -17,7 +18,7 @@ use rustc_session::lint;\n use rustc_session::DiagnosticOutput;\n use rustc_session::Session;\n use rustc_span::symbol::sym;\n-use rustc_span::{source_map, Span};\n+use rustc_span::{source_map, Span, Symbol};\n \n use std::cell::RefCell;\n use std::lazy::SyncLazy;\n@@ -38,6 +39,7 @@ crate struct ResolverCaches {\n     crate traits_in_scope: DefIdMap<Vec<TraitCandidate>>,\n     crate all_traits: Option<Vec<DefId>>,\n     crate all_trait_impls: Option<Vec<DefId>>,\n+    crate all_macro_rules: FxHashMap<Symbol, Res<NodeId>>,\n }\n \n crate struct DocContext<'tcx> {"}, {"sha": "0fcfabba4c0a12bec4075833fbad95ba14ed0ddc", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/dd38eea722c1f6f970a314435533e91cc2c14ffb/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd38eea722c1f6f970a314435533e91cc2c14ffb/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=dd38eea722c1f6f970a314435533e91cc2c14ffb", "patch": "@@ -10,6 +10,7 @@\n #![feature(control_flow_enum)]\n #![feature(box_syntax)]\n #![feature(drain_filter)]\n+#![feature(let_chains)]\n #![feature(let_else)]\n #![feature(nll)]\n #![feature(test)]"}, {"sha": "c1b1139ad8cf95ec5ac178662a6fbebe774c5185", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/dd38eea722c1f6f970a314435533e91cc2c14ffb/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd38eea722c1f6f970a314435533e91cc2c14ffb/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=dd38eea722c1f6f970a314435533e91cc2c14ffb", "patch": "@@ -2,13 +2,11 @@\n //!\n //! [RFC 1946]: https://github.com/rust-lang/rfcs/blob/master/text/1946-intra-rustdoc-links.md\n \n+use pulldown_cmark::LinkType;\n use rustc_data_structures::{fx::FxHashMap, intern::Interned, stable_set::FxHashSet};\n use rustc_errors::{Applicability, Diagnostic};\n-use rustc_hir::def::{\n-    DefKind,\n-    Namespace::{self, *},\n-    PerNS,\n-};\n+use rustc_hir::def::Namespace::*;\n+use rustc_hir::def::{DefKind, Namespace, PerNS};\n use rustc_hir::def_id::{DefId, CRATE_DEF_ID};\n use rustc_hir::Mutability;\n use rustc_middle::ty::{DefIdTree, Ty, TyCtxt};\n@@ -19,10 +17,7 @@ use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{BytePos, DUMMY_SP};\n use smallvec::{smallvec, SmallVec};\n \n-use pulldown_cmark::LinkType;\n-\n use std::borrow::Cow;\n-use std::convert::{TryFrom, TryInto};\n use std::fmt::Write;\n use std::mem;\n use std::ops::Range;\n@@ -487,25 +482,13 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         item_id: ItemId,\n         module_id: DefId,\n     ) -> Result<Res, ResolutionFailure<'a>> {\n-        self.cx.enter_resolver(|resolver| {\n-            // NOTE: this needs 2 separate lookups because `resolve_rustdoc_path` doesn't take\n-            // lexical scope into account (it ignores all macros not defined at the mod-level)\n-            debug!(\"resolving {} as a macro in the module {:?}\", path_str, module_id);\n-            if let Some(res) = resolver.resolve_rustdoc_path(path_str, MacroNS, module_id) {\n-                // don't resolve builtins like `#[derive]`\n-                if let Ok(res) = res.try_into() {\n-                    return Ok(res);\n-                }\n-            }\n-            if let Some(&res) = resolver.all_macros().get(&Symbol::intern(path_str)) {\n-                return Ok(res.try_into().unwrap());\n-            }\n-            Err(ResolutionFailure::NotResolved {\n+        self.resolve_path(path_str, MacroNS, item_id, module_id).ok_or_else(|| {\n+            ResolutionFailure::NotResolved {\n                 item_id,\n                 module_id,\n                 partial_res: None,\n                 unresolved: path_str.into(),\n-            })\n+            }\n         })\n     }\n \n@@ -539,6 +522,21 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             })\n     }\n \n+    /// HACK: Try to search the macro name in the list of all `macro_rules` items in the crate.\n+    /// Used when nothing else works, may often give an incorrect result.\n+    fn resolve_macro_rules(&self, path_str: &str, ns: Namespace) -> Option<Res> {\n+        if ns != MacroNS {\n+            return None;\n+        }\n+\n+        self.cx\n+            .resolver_caches\n+            .all_macro_rules\n+            .get(&Symbol::intern(path_str))\n+            .copied()\n+            .and_then(|res| res.try_into().ok())\n+    }\n+\n     /// Convenience wrapper around `resolve_rustdoc_path`.\n     ///\n     /// This also handles resolving `true` and `false` as booleans.\n@@ -560,7 +558,8 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             .cx\n             .enter_resolver(|resolver| resolver.resolve_rustdoc_path(path_str, ns, module_id))\n             .and_then(|res| res.try_into().ok())\n-            .or_else(|| resolve_primitive(path_str, ns));\n+            .or_else(|| resolve_primitive(path_str, ns))\n+            .or_else(|| self.resolve_macro_rules(path_str, ns));\n         debug!(\"{} resolved to {:?} in namespace {:?}\", path_str, result, ns);\n         result\n     }"}, {"sha": "dffceff045d0b6d6e2cc239c422f6e97ff6f8655", "filename": "src/librustdoc/passes/collect_intra_doc_links/early.rs", "status": "modified", "additions": 102, "deletions": 74, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/dd38eea722c1f6f970a314435533e91cc2c14ffb/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd38eea722c1f6f970a314435533e91cc2c14ffb/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs?ref=dd38eea722c1f6f970a314435533e91cc2c14ffb", "patch": "@@ -1,4 +1,4 @@\n-use crate::clean;\n+use crate::clean::Attributes;\n use crate::core::ResolverCaches;\n use crate::html::markdown::markdown_links;\n use crate::passes::collect_intra_doc_links::preprocess_link;\n@@ -24,7 +24,7 @@ crate fn early_resolve_intra_doc_links(\n     externs: Externs,\n     document_private_items: bool,\n ) -> ResolverCaches {\n-    let mut loader = IntraLinkCrateLoader {\n+    let mut link_resolver = EarlyDocLinkResolver {\n         resolver,\n         current_mod: CRATE_DEF_ID,\n         visited_mods: Default::default(),\n@@ -36,27 +36,28 @@ crate fn early_resolve_intra_doc_links(\n \n     // Overridden `visit_item` below doesn't apply to the crate root,\n     // so we have to visit its attributes and reexports separately.\n-    loader.load_links_in_attrs(&krate.attrs);\n-    loader.process_module_children_or_reexports(CRATE_DEF_ID.to_def_id());\n-    visit::walk_crate(&mut loader, krate);\n-    loader.add_foreign_traits_in_scope();\n+    link_resolver.load_links_in_attrs(&krate.attrs);\n+    link_resolver.process_module_children_or_reexports(CRATE_DEF_ID.to_def_id());\n+    visit::walk_crate(&mut link_resolver, krate);\n+    link_resolver.process_extern_impls();\n \n     // FIXME: somehow rustdoc is still missing crates even though we loaded all\n     // the known necessary crates. Load them all unconditionally until we find a way to fix this.\n     // DO NOT REMOVE THIS without first testing on the reproducer in\n     // https://github.com/jyn514/objr/commit/edcee7b8124abf0e4c63873e8422ff81beb11ebb\n     for (extern_name, _) in externs.iter().filter(|(_, entry)| entry.add_prelude) {\n-        loader.resolver.resolve_rustdoc_path(extern_name, TypeNS, CRATE_DEF_ID.to_def_id());\n+        link_resolver.resolver.resolve_rustdoc_path(extern_name, TypeNS, CRATE_DEF_ID.to_def_id());\n     }\n \n     ResolverCaches {\n-        traits_in_scope: loader.traits_in_scope,\n-        all_traits: Some(loader.all_traits),\n-        all_trait_impls: Some(loader.all_trait_impls),\n+        traits_in_scope: link_resolver.traits_in_scope,\n+        all_traits: Some(link_resolver.all_traits),\n+        all_trait_impls: Some(link_resolver.all_trait_impls),\n+        all_macro_rules: link_resolver.resolver.take_all_macro_rules(),\n     }\n }\n \n-struct IntraLinkCrateLoader<'r, 'ra> {\n+struct EarlyDocLinkResolver<'r, 'ra> {\n     resolver: &'r mut Resolver<'ra>,\n     current_mod: LocalDefId,\n     visited_mods: DefIdSet,\n@@ -66,7 +67,7 @@ struct IntraLinkCrateLoader<'r, 'ra> {\n     document_private_items: bool,\n }\n \n-impl IntraLinkCrateLoader<'_, '_> {\n+impl EarlyDocLinkResolver<'_, '_> {\n     fn add_traits_in_scope(&mut self, def_id: DefId) {\n         // Calls to `traits_in_scope` are expensive, so try to avoid them if only possible.\n         // Keys in the `traits_in_scope` cache are always module IDs.\n@@ -101,64 +102,83 @@ impl IntraLinkCrateLoader<'_, '_> {\n     /// That pass filters impls using type-based information, but we don't yet have such\n     /// information here, so we just conservatively calculate traits in scope for *all* modules\n     /// having impls in them.\n-    fn add_foreign_traits_in_scope(&mut self) {\n-        for cnum in Vec::from_iter(self.resolver.cstore().crates_untracked()) {\n-            let all_traits = Vec::from_iter(self.resolver.cstore().traits_in_crate_untracked(cnum));\n-            let all_trait_impls =\n-                Vec::from_iter(self.resolver.cstore().trait_impls_in_crate_untracked(cnum));\n-            let all_inherent_impls =\n-                Vec::from_iter(self.resolver.cstore().inherent_impls_in_crate_untracked(cnum));\n-            let all_incoherent_impls =\n-                Vec::from_iter(self.resolver.cstore().incoherent_impls_in_crate_untracked(cnum));\n-\n-            // Querying traits in scope is expensive so we try to prune the impl and traits lists\n-            // using privacy, private traits and impls from other crates are never documented in\n-            // the current crate, and links in their doc comments are not resolved.\n-            for &def_id in &all_traits {\n-                if self.resolver.cstore().visibility_untracked(def_id) == Visibility::Public {\n-                    self.add_traits_in_parent_scope(def_id);\n+    fn process_extern_impls(&mut self) {\n+        // FIXME: Need to resolve doc links on all these impl and trait items below.\n+        // Resolving links in already existing crates may trigger loading of new crates.\n+        let mut start_cnum = 0;\n+        loop {\n+            let crates = Vec::from_iter(self.resolver.cstore().crates_untracked());\n+            for &cnum in &crates[start_cnum..] {\n+                let all_traits =\n+                    Vec::from_iter(self.resolver.cstore().traits_in_crate_untracked(cnum));\n+                let all_trait_impls =\n+                    Vec::from_iter(self.resolver.cstore().trait_impls_in_crate_untracked(cnum));\n+                let all_inherent_impls =\n+                    Vec::from_iter(self.resolver.cstore().inherent_impls_in_crate_untracked(cnum));\n+                let all_incoherent_impls = Vec::from_iter(\n+                    self.resolver.cstore().incoherent_impls_in_crate_untracked(cnum),\n+                );\n+\n+                // Querying traits in scope is expensive so we try to prune the impl and traits lists\n+                // using privacy, private traits and impls from other crates are never documented in\n+                // the current crate, and links in their doc comments are not resolved.\n+                for &def_id in &all_traits {\n+                    if self.resolver.cstore().visibility_untracked(def_id) == Visibility::Public {\n+                        self.add_traits_in_parent_scope(def_id);\n+                    }\n                 }\n-            }\n-            for &(trait_def_id, impl_def_id, simplified_self_ty) in &all_trait_impls {\n-                if self.resolver.cstore().visibility_untracked(trait_def_id) == Visibility::Public\n-                    && simplified_self_ty.and_then(|ty| ty.def()).map_or(true, |ty_def_id| {\n-                        self.resolver.cstore().visibility_untracked(ty_def_id) == Visibility::Public\n-                    })\n-                {\n-                    self.add_traits_in_parent_scope(impl_def_id);\n+                for &(trait_def_id, impl_def_id, simplified_self_ty) in &all_trait_impls {\n+                    if self.resolver.cstore().visibility_untracked(trait_def_id)\n+                        == Visibility::Public\n+                        && simplified_self_ty.and_then(|ty| ty.def()).map_or(true, |ty_def_id| {\n+                            self.resolver.cstore().visibility_untracked(ty_def_id)\n+                                == Visibility::Public\n+                        })\n+                    {\n+                        self.add_traits_in_parent_scope(impl_def_id);\n+                    }\n                 }\n-            }\n-            for (ty_def_id, impl_def_id) in all_inherent_impls {\n-                if self.resolver.cstore().visibility_untracked(ty_def_id) == Visibility::Public {\n-                    self.add_traits_in_parent_scope(impl_def_id);\n+                for (ty_def_id, impl_def_id) in all_inherent_impls {\n+                    if self.resolver.cstore().visibility_untracked(ty_def_id) == Visibility::Public\n+                    {\n+                        self.add_traits_in_parent_scope(impl_def_id);\n+                    }\n                 }\n-            }\n-            for def_id in all_incoherent_impls {\n-                self.add_traits_in_parent_scope(def_id);\n+                for def_id in all_incoherent_impls {\n+                    self.add_traits_in_parent_scope(def_id);\n+                }\n+\n+                self.all_traits.extend(all_traits);\n+                self.all_trait_impls\n+                    .extend(all_trait_impls.into_iter().map(|(_, def_id, _)| def_id));\n             }\n \n-            self.all_traits.extend(all_traits);\n-            self.all_trait_impls.extend(all_trait_impls.into_iter().map(|(_, def_id, _)| def_id));\n+            if crates.len() > start_cnum {\n+                start_cnum = crates.len();\n+            } else {\n+                break;\n+            }\n         }\n     }\n \n     fn load_links_in_attrs(&mut self, attrs: &[ast::Attribute]) {\n-        // FIXME: this needs to consider reexport inlining.\n-        let attrs = clean::Attributes::from_ast(attrs, None);\n-        for (parent_module, doc) in attrs.collapsed_doc_value_by_module_level() {\n-            let module_id = parent_module.unwrap_or(self.current_mod.to_def_id());\n-\n-            self.add_traits_in_scope(module_id);\n-\n+        let module_id = self.current_mod.to_def_id();\n+        let mut need_traits_in_scope = false;\n+        for (doc_module, doc) in\n+            Attributes::from_ast(attrs, None).collapsed_doc_value_by_module_level()\n+        {\n+            assert_eq!(doc_module, None);\n             for link in markdown_links(&doc.as_str()) {\n-                let path_str = if let Some(Ok(x)) = preprocess_link(&link) {\n-                    x.path_str\n-                } else {\n-                    continue;\n-                };\n-                self.resolver.resolve_rustdoc_path(&path_str, TypeNS, module_id);\n+                if let Some(Ok(pinfo)) = preprocess_link(&link) {\n+                    self.resolver.resolve_rustdoc_path(&pinfo.path_str, TypeNS, module_id);\n+                    need_traits_in_scope = true;\n+                }\n             }\n         }\n+\n+        if need_traits_in_scope {\n+            self.add_traits_in_scope(module_id);\n+        }\n     }\n \n     /// When reexports are inlined, they are replaced with item which they refer to, those items\n@@ -170,32 +190,41 @@ impl IntraLinkCrateLoader<'_, '_> {\n         }\n \n         for child in self.resolver.module_children_or_reexports(module_id) {\n-            if child.vis == Visibility::Public || self.document_private_items {\n-                if let Some(def_id) = child.res.opt_def_id() {\n-                    self.add_traits_in_parent_scope(def_id);\n-                }\n-                if let Res::Def(DefKind::Mod, module_id) = child.res {\n-                    self.process_module_children_or_reexports(module_id);\n+            // This condition should give a superset of `denied` from `fn clean_use_statement`.\n+            if child.vis == Visibility::Public\n+                || self.document_private_items\n+                    && child.vis != Visibility::Restricted(module_id)\n+                    && module_id.is_local()\n+            {\n+                if let Some(def_id) = child.res.opt_def_id() && !def_id.is_local() {\n+                    // FIXME: Need to resolve doc links on all these extern items\n+                    // reached through reexports.\n+                    let scope_id = match child.res {\n+                        Res::Def(DefKind::Variant, ..) => self.resolver.parent(def_id).unwrap(),\n+                        _ => def_id,\n+                    };\n+                    self.add_traits_in_parent_scope(scope_id); // Outer attribute scope\n+                    if let Res::Def(DefKind::Mod, ..) = child.res {\n+                        self.add_traits_in_scope(def_id); // Inner attribute scope\n+                    }\n+                    // Traits are processed in `add_extern_traits_in_scope`.\n+                    if let Res::Def(DefKind::Mod | DefKind::Enum, ..) = child.res {\n+                        self.process_module_children_or_reexports(def_id);\n+                    }\n                 }\n             }\n         }\n     }\n }\n \n-impl Visitor<'_> for IntraLinkCrateLoader<'_, '_> {\n+impl Visitor<'_> for EarlyDocLinkResolver<'_, '_> {\n     fn visit_item(&mut self, item: &ast::Item) {\n+        self.load_links_in_attrs(&item.attrs); // Outer attribute scope\n         if let ItemKind::Mod(..) = item.kind {\n             let old_mod = mem::replace(&mut self.current_mod, self.resolver.local_def_id(item.id));\n-\n-            // A module written with a outline doc comments will resolve traits relative\n-            // to the parent module. Make sure the parent module's traits-in-scope are\n-            // loaded, even if the module itself has no doc comments.\n-            self.add_traits_in_parent_scope(self.current_mod.to_def_id());\n-\n-            self.load_links_in_attrs(&item.attrs);\n+            self.load_links_in_attrs(&item.attrs); // Inner attribute scope\n             self.process_module_children_or_reexports(self.current_mod.to_def_id());\n             visit::walk_item(self, item);\n-\n             self.current_mod = old_mod;\n         } else {\n             match item.kind {\n@@ -207,7 +236,6 @@ impl Visitor<'_> for IntraLinkCrateLoader<'_, '_> {\n                 }\n                 _ => {}\n             }\n-            self.load_links_in_attrs(&item.attrs);\n             visit::walk_item(self, item);\n         }\n     }"}, {"sha": "b4ce3443ccd1898e492e2af079e6084977f12fe9", "filename": "src/test/rustdoc-ui/intra-doc/assoc-mod-inner-outer.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/dd38eea722c1f6f970a314435533e91cc2c14ffb/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fassoc-mod-inner-outer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd38eea722c1f6f970a314435533e91cc2c14ffb/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fassoc-mod-inner-outer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fassoc-mod-inner-outer.rs?ref=dd38eea722c1f6f970a314435533e91cc2c14ffb", "patch": "@@ -0,0 +1,19 @@\n+// Traits in scope are collected for doc links in both outer and inner module attributes.\n+\n+// check-pass\n+// aux-build: assoc-mod-inner-outer-dep.rs\n+\n+extern crate assoc_mod_inner_outer_dep;\n+pub use assoc_mod_inner_outer_dep::*;\n+\n+#[derive(Clone)]\n+pub struct Struct;\n+\n+pub mod outer1 {\n+    /// [crate::Struct::clone]\n+    pub mod inner {}\n+}\n+\n+pub mod outer2 {\n+    //! [crate::Struct::clone]\n+}"}, {"sha": "7a11a165723ff8e5d74df0d999ae39bcfdb41cfb", "filename": "src/test/rustdoc-ui/intra-doc/auxiliary/assoc-mod-inner-outer-dep.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/dd38eea722c1f6f970a314435533e91cc2c14ffb/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fauxiliary%2Fassoc-mod-inner-outer-dep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd38eea722c1f6f970a314435533e91cc2c14ffb/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fauxiliary%2Fassoc-mod-inner-outer-dep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fauxiliary%2Fassoc-mod-inner-outer-dep.rs?ref=dd38eea722c1f6f970a314435533e91cc2c14ffb", "patch": "@@ -0,0 +1,11 @@\n+#[derive(Clone)]\n+pub struct Struct;\n+\n+pub mod dep_outer1 {\n+    /// [crate::Struct::clone]\n+    pub mod inner {}\n+}\n+\n+pub mod dep_outer2 {\n+    //! [crate::Struct::clone]\n+}"}]}