{"sha": "b5c2b79fb21f835fd20f176ca0f9c4d7e89ac095", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1YzJiNzlmYjIxZjgzNWZkMjBmMTc2Y2EwZjljNGQ3ZTg5YWMwOTU=", "commit": {"author": {"name": "Mike Hommey", "email": "mh@glandium.org", "date": "2018-07-11T06:24:24Z"}, "committer": {"name": "Mike Hommey", "email": "mh@glandium.org", "date": "2018-07-12T08:14:53Z"}, "message": "Don't display default generic parameters in diagnostics that compare types.\n\nFixes #52097", "tree": {"sha": "a94dd7b4292eac7d815b1bcd2b1b1dc459f04c9e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a94dd7b4292eac7d815b1bcd2b1b1dc459f04c9e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5c2b79fb21f835fd20f176ca0f9c4d7e89ac095", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5c2b79fb21f835fd20f176ca0f9c4d7e89ac095", "html_url": "https://github.com/rust-lang/rust/commit/b5c2b79fb21f835fd20f176ca0f9c4d7e89ac095", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5c2b79fb21f835fd20f176ca0f9c4d7e89ac095/comments", "author": {"login": "glandium", "id": 1038527, "node_id": "MDQ6VXNlcjEwMzg1Mjc=", "avatar_url": "https://avatars.githubusercontent.com/u/1038527?v=4", "gravatar_id": "", "url": "https://api.github.com/users/glandium", "html_url": "https://github.com/glandium", "followers_url": "https://api.github.com/users/glandium/followers", "following_url": "https://api.github.com/users/glandium/following{/other_user}", "gists_url": "https://api.github.com/users/glandium/gists{/gist_id}", "starred_url": "https://api.github.com/users/glandium/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/glandium/subscriptions", "organizations_url": "https://api.github.com/users/glandium/orgs", "repos_url": "https://api.github.com/users/glandium/repos", "events_url": "https://api.github.com/users/glandium/events{/privacy}", "received_events_url": "https://api.github.com/users/glandium/received_events", "type": "User", "site_admin": false}, "committer": {"login": "glandium", "id": 1038527, "node_id": "MDQ6VXNlcjEwMzg1Mjc=", "avatar_url": "https://avatars.githubusercontent.com/u/1038527?v=4", "gravatar_id": "", "url": "https://api.github.com/users/glandium", "html_url": "https://github.com/glandium", "followers_url": "https://api.github.com/users/glandium/followers", "following_url": "https://api.github.com/users/glandium/following{/other_user}", "gists_url": "https://api.github.com/users/glandium/gists{/gist_id}", "starred_url": "https://api.github.com/users/glandium/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/glandium/subscriptions", "organizations_url": "https://api.github.com/users/glandium/orgs", "repos_url": "https://api.github.com/users/glandium/repos", "events_url": "https://api.github.com/users/glandium/events{/privacy}", "received_events_url": "https://api.github.com/users/glandium/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5336df7e3c8df350c20ec6e3be5a3afffd0a2d54", "url": "https://api.github.com/repos/rust-lang/rust/commits/5336df7e3c8df350c20ec6e3be5a3afffd0a2d54", "html_url": "https://github.com/rust-lang/rust/commit/5336df7e3c8df350c20ec6e3be5a3afffd0a2d54"}], "stats": {"total": 118, "additions": 87, "deletions": 31}, "files": [{"sha": "062145058193d39fa2dfb70bcd6fee7d5192ccab", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 63, "deletions": 7, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/b5c2b79fb21f835fd20f176ca0f9c4d7e89ac095/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5c2b79fb21f835fd20f176ca0f9c4d7e89ac095/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=b5c2b79fb21f835fd20f176ca0f9c4d7e89ac095", "patch": "@@ -60,13 +60,13 @@ use super::{InferCtxt, RegionVariableOrigin, SubregionOrigin, TypeTrace, ValuePa\n use super::region_constraints::GenericKind;\n use super::lexical_region_resolve::RegionResolutionError;\n \n-use std::fmt;\n+use std::{cmp, fmt};\n use hir;\n use hir::map as hir_map;\n use hir::def_id::DefId;\n use middle::region;\n use traits::{ObligationCause, ObligationCauseCode};\n-use ty::{self, Region, Ty, TyCtxt, TypeFoldable, TypeVariants};\n+use ty::{self, subst::Subst, Region, Ty, TyCtxt, TypeFoldable, TypeVariants};\n use ty::error::TypeError;\n use syntax::ast::DUMMY_NODE_ID;\n use syntax_pos::{Pos, Span};\n@@ -672,6 +672,43 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    /// For generic types with parameters with defaults, remove the parameters corresponding to\n+    /// the defaults. This repeats a lot of the logic found in `PrintContext::parameterized`.\n+    fn strip_generic_default_params(\n+        &self,\n+        def_id: DefId,\n+        substs: &ty::subst::Substs<'tcx>\n+    ) -> &'tcx ty::subst::Substs<'tcx> {\n+        let generics = self.tcx.generics_of(def_id);\n+        let mut num_supplied_defaults = 0;\n+        let mut type_params = generics.params.iter().rev().filter_map(|param| match param.kind {\n+            ty::GenericParamDefKind::Lifetime => None,\n+            ty::GenericParamDefKind::Type { has_default, .. } => {\n+                Some((param.def_id, has_default))\n+            }\n+        }).peekable();\n+        let has_default = {\n+            let has_default = type_params.peek().map(|(_, has_default)| has_default);\n+            *has_default.unwrap_or(&false)\n+        };\n+        if has_default {\n+            let types = substs.types().rev();\n+            for ((def_id, has_default), actual) in type_params.zip(types) {\n+                if !has_default {\n+                    break;\n+                }\n+                if self.tcx.type_of(def_id).subst(self.tcx, substs) != actual {\n+                    break;\n+                }\n+                num_supplied_defaults += 1;\n+            }\n+        }\n+        let len = generics.params.len();\n+        let mut generics = generics.clone();\n+        generics.params.truncate(len - num_supplied_defaults);\n+        substs.truncate_to(self.tcx, &generics)\n+    }\n+\n     /// Compare two given types, eliding parts that are the same between them and highlighting\n     /// relevant differences, and return two representation of those types for highlighted printing.\n     fn cmp(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) -> (DiagnosticStyledString, DiagnosticStyledString) {\n@@ -713,6 +750,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         match (&t1.sty, &t2.sty) {\n             (&ty::TyAdt(def1, sub1), &ty::TyAdt(def2, sub2)) => {\n+                let sub_no_defaults_1 = self.strip_generic_default_params(def1.did, sub1);\n+                let sub_no_defaults_2 = self.strip_generic_default_params(def2.did, sub2);\n                 let mut values = (DiagnosticStyledString::new(), DiagnosticStyledString::new());\n                 let path1 = self.tcx.item_path_str(def1.did.clone());\n                 let path2 = self.tcx.item_path_str(def2.did.clone());\n@@ -728,8 +767,19 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     values.0.push_normal(path1);\n                     values.1.push_normal(path2);\n \n+                    // Avoid printing out default generic parameters that are common to both\n+                    // types.\n+                    let len1 = sub_no_defaults_1.len();\n+                    let len2 = sub_no_defaults_2.len();\n+                    let common_len = cmp::min(len1, len2);\n+                    let remainder1: Vec<_> = sub1.types().skip(common_len).collect();\n+                    let remainder2: Vec<_> = sub2.types().skip(common_len).collect();\n+                    let common_default_params =\n+                        remainder1.iter().rev().zip(remainder2.iter().rev())\n+                                               .filter(|(a, b)| a == b).count();\n+                    let len = sub1.len() - common_default_params;\n+\n                     // Only draw `<...>` if there're lifetime/type arguments.\n-                    let len = sub1.len();\n                     if len > 0 {\n                         values.0.push_normal(\"<\");\n                         values.1.push_normal(\"<\");\n@@ -774,7 +824,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     //         ^ elided type as this type argument was the same in both sides\n                     let type_arguments = sub1.types().zip(sub2.types());\n                     let regions_len = sub1.regions().collect::<Vec<_>>().len();\n-                    for (i, (ta1, ta2)) in type_arguments.enumerate() {\n+                    for (i, (ta1, ta2)) in type_arguments.take(len).enumerate() {\n                         let i = i + regions_len;\n                         if ta1 == ta2 {\n                             values.0.push_normal(\"_\");\n@@ -804,7 +854,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         &mut values.0,\n                         &mut values.1,\n                         path1.clone(),\n-                        sub1,\n+                        sub_no_defaults_1,\n                         path2.clone(),\n                         &t2,\n                     ).is_some()\n@@ -816,8 +866,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     //     Bar<Qux>\n                     //     Foo<Bar<Qux>>\n                     //         ------- this type argument is exactly the same as the other type\n-                    if self.cmp_type_arg(&mut values.1, &mut values.0, path2, sub2, path1, &t1)\n-                        .is_some()\n+                    if self.cmp_type_arg(\n+                        &mut values.1,\n+                        &mut values.0,\n+                        path2,\n+                        sub_no_defaults_2,\n+                        path1,\n+                        &t1,\n+                    ).is_some()\n                     {\n                         return values;\n                     }"}, {"sha": "4ba1a7f37c4a14e63a0dd0d594f5346b211e1e89", "filename": "src/test/ui/type-mismatch.stderr", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b5c2b79fb21f835fd20f176ca0f9c4d7e89ac095/src%2Ftest%2Fui%2Ftype-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5c2b79fb21f835fd20f176ca0f9c4d7e89ac095/src%2Ftest%2Fui%2Ftype-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-mismatch.stderr?ref=b5c2b79fb21f835fd20f176ca0f9c4d7e89ac095", "patch": "@@ -112,7 +112,7 @@ error[E0308]: mismatched types\n LL |     want::<Foo<foo>>(f); //~ ERROR mismatched types\n    |                      ^ expected struct `Foo`, found struct `foo`\n    |\n-   = note: expected type `Foo<foo, A, B>`\n+   = note: expected type `Foo<foo>`\n               found type `foo`\n \n error[E0308]: mismatched types\n@@ -121,7 +121,7 @@ error[E0308]: mismatched types\n LL |     want::<Foo<foo, B>>(f); //~ ERROR mismatched types\n    |                         ^ expected struct `Foo`, found struct `foo`\n    |\n-   = note: expected type `Foo<foo, B, B>`\n+   = note: expected type `Foo<foo, B>`\n               found type `foo`\n \n error[E0308]: mismatched types\n@@ -158,7 +158,7 @@ LL |     want::<foo>(f); //~ ERROR mismatched types\n    |                 ^ expected struct `foo`, found struct `Foo`\n    |\n    = note: expected type `foo`\n-              found type `Foo<foo, A, B>`\n+              found type `Foo<foo>`\n \n error[E0308]: mismatched types\n   --> $DIR/type-mismatch.rs:49:17\n@@ -175,44 +175,44 @@ error[E0308]: mismatched types\n LL |     want::<Foo<usize>>(f); //~ ERROR mismatched types\n    |                        ^ expected usize, found struct `foo`\n    |\n-   = note: expected type `Foo<usize, _, _>`\n-              found type `Foo<foo, _, _>`\n+   = note: expected type `Foo<usize>`\n+              found type `Foo<foo>`\n \n error[E0308]: mismatched types\n   --> $DIR/type-mismatch.rs:51:27\n    |\n LL |     want::<Foo<usize, B>>(f); //~ ERROR mismatched types\n    |                           ^ expected usize, found struct `foo`\n    |\n-   = note: expected type `Foo<usize, B, _>`\n-              found type `Foo<foo, A, _>`\n+   = note: expected type `Foo<usize, B>`\n+              found type `Foo<foo, A>`\n \n error[E0308]: mismatched types\n   --> $DIR/type-mismatch.rs:52:25\n    |\n LL |     want::<Foo<foo, B>>(f); //~ ERROR mismatched types\n    |                         ^ expected struct `B`, found struct `A`\n    |\n-   = note: expected type `Foo<_, B, _>`\n-              found type `Foo<_, A, _>`\n+   = note: expected type `Foo<_, B>`\n+              found type `Foo<_, A>`\n \n error[E0308]: mismatched types\n   --> $DIR/type-mismatch.rs:53:22\n    |\n LL |     want::<Foo<bar>>(f); //~ ERROR mismatched types\n    |                      ^ expected struct `bar`, found struct `foo`\n    |\n-   = note: expected type `Foo<bar, _, _>`\n-              found type `Foo<foo, _, _>`\n+   = note: expected type `Foo<bar>`\n+              found type `Foo<foo>`\n \n error[E0308]: mismatched types\n   --> $DIR/type-mismatch.rs:54:25\n    |\n LL |     want::<Foo<bar, B>>(f); //~ ERROR mismatched types\n    |                         ^ expected struct `bar`, found struct `foo`\n    |\n-   = note: expected type `Foo<bar, B, _>`\n-              found type `Foo<foo, A, _>`\n+   = note: expected type `Foo<bar, B>`\n+              found type `Foo<foo, A>`\n \n error[E0308]: mismatched types\n   --> $DIR/type-mismatch.rs:55:23\n@@ -251,7 +251,7 @@ LL |     want::<foo>(f); //~ ERROR mismatched types\n    |                 ^ expected struct `foo`, found struct `Foo`\n    |\n    = note: expected type `foo`\n-              found type `Foo<foo, B, B>`\n+              found type `Foo<foo, B>`\n \n error[E0308]: mismatched types\n   --> $DIR/type-mismatch.rs:62:17\n@@ -268,44 +268,44 @@ error[E0308]: mismatched types\n LL |     want::<Foo<usize>>(f); //~ ERROR mismatched types\n    |                        ^ expected usize, found struct `foo`\n    |\n-   = note: expected type `Foo<usize, A, _>`\n-              found type `Foo<foo, B, _>`\n+   = note: expected type `Foo<usize, A>`\n+              found type `Foo<foo, B>`\n \n error[E0308]: mismatched types\n   --> $DIR/type-mismatch.rs:64:27\n    |\n LL |     want::<Foo<usize, B>>(f); //~ ERROR mismatched types\n    |                           ^ expected usize, found struct `foo`\n    |\n-   = note: expected type `Foo<usize, _, _>`\n-              found type `Foo<foo, _, _>`\n+   = note: expected type `Foo<usize, _>`\n+              found type `Foo<foo, _>`\n \n error[E0308]: mismatched types\n   --> $DIR/type-mismatch.rs:65:22\n    |\n LL |     want::<Foo<foo>>(f); //~ ERROR mismatched types\n    |                      ^ expected struct `A`, found struct `B`\n    |\n-   = note: expected type `Foo<_, A, _>`\n-              found type `Foo<_, B, _>`\n+   = note: expected type `Foo<_, A>`\n+              found type `Foo<_, B>`\n \n error[E0308]: mismatched types\n   --> $DIR/type-mismatch.rs:66:22\n    |\n LL |     want::<Foo<bar>>(f); //~ ERROR mismatched types\n    |                      ^ expected struct `bar`, found struct `foo`\n    |\n-   = note: expected type `Foo<bar, A, _>`\n-              found type `Foo<foo, B, _>`\n+   = note: expected type `Foo<bar, A>`\n+              found type `Foo<foo, B>`\n \n error[E0308]: mismatched types\n   --> $DIR/type-mismatch.rs:67:25\n    |\n LL |     want::<Foo<bar, B>>(f); //~ ERROR mismatched types\n    |                         ^ expected struct `bar`, found struct `foo`\n    |\n-   = note: expected type `Foo<bar, _, _>`\n-              found type `Foo<foo, _, _>`\n+   = note: expected type `Foo<bar, _>`\n+              found type `Foo<foo, _>`\n \n error[E0308]: mismatched types\n   --> $DIR/type-mismatch.rs:68:23"}]}