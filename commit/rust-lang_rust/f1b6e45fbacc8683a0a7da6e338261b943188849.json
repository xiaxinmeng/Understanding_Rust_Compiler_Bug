{"sha": "f1b6e45fbacc8683a0a7da6e338261b943188849", "node_id": "C_kwDOAAsO6NoAKGYxYjZlNDVmYmFjYzg2ODNhMGE3ZGE2ZTMzODI2MWI5NDMxODg4NDk", "commit": {"author": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2022-05-16T17:10:38Z"}, "committer": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2022-05-16T17:10:38Z"}, "message": "Handle getters and setters in documentation template assist", "tree": {"sha": "3262f8222953977d0a8c173e1794eb11663da7ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3262f8222953977d0a8c173e1794eb11663da7ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1b6e45fbacc8683a0a7da6e338261b943188849", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1b6e45fbacc8683a0a7da6e338261b943188849", "html_url": "https://github.com/rust-lang/rust/commit/f1b6e45fbacc8683a0a7da6e338261b943188849", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1b6e45fbacc8683a0a7da6e338261b943188849/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "825ce48180bb9344a198df9361bd43a40b5b13d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/825ce48180bb9344a198df9361bd43a40b5b13d4", "html_url": "https://github.com/rust-lang/rust/commit/825ce48180bb9344a198df9361bd43a40b5b13d4"}], "stats": {"total": 307, "additions": 252, "deletions": 55}, "files": [{"sha": "12e06bf4aca49896f9eadf7c593f8852f36f00aa", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f1b6e45fbacc8683a0a7da6e338261b943188849/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b6e45fbacc8683a0a7da6e338261b943188849/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=f1b6e45fbacc8683a0a7da6e338261b943188849", "patch": "@@ -1466,6 +1466,7 @@ impl Function {\n }\n \n // Note: logically, this belongs to `hir_ty`, but we are not using it there yet.\n+#[derive(Clone, Copy, PartialEq, Eq)]\n pub enum Access {\n     Shared,\n     Exclusive,"}, {"sha": "7864ca2a4e53905eacb69cc585a71f9f8eb2a4f2", "filename": "crates/ide-assists/src/handlers/generate_documentation_template.rs", "status": "modified", "additions": 247, "deletions": 18, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/f1b6e45fbacc8683a0a7da6e338261b943188849/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_documentation_template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b6e45fbacc8683a0a7da6e338261b943188849/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_documentation_template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_documentation_template.rs?ref=f1b6e45fbacc8683a0a7da6e338261b943188849", "patch": "@@ -60,7 +60,7 @@ pub(crate) fn generate_documentation_template(\n         text_range,\n         |builder| {\n             // Introduction / short function description before the sections\n-            let mut doc_lines = vec![introduction_builder(&ast_func, ctx)];\n+            let mut doc_lines = vec![introduction_builder(&ast_func, ctx).unwrap_or(\".\".into())];\n             // Then come the sections\n             if let Some(mut lines) = examples_builder(&ast_func, ctx) {\n                 doc_lines.push(\"\".into());\n@@ -78,26 +78,64 @@ pub(crate) fn generate_documentation_template(\n }\n \n /// Builds an introduction, trying to be smart if the function is `::new()`\n-fn introduction_builder(ast_func: &ast::Fn, ctx: &AssistContext) -> String {\n-    || -> Option<String> {\n-        let hir_func = ctx.sema.to_def(ast_func)?;\n-        let container = hir_func.as_assoc_item(ctx.db())?.container(ctx.db());\n-        if let hir::AssocItemContainer::Impl(implementation) = container {\n-            let ret_ty = hir_func.ret_type(ctx.db());\n-            let self_ty = implementation.self_ty(ctx.db());\n-\n-            let is_new = ast_func.name()?.to_string() == \"new\";\n-            match is_new && ret_ty == self_ty {\n-                true => {\n-                    Some(format!(\"Creates a new [`{}`].\", self_type_without_lifetimes(ast_func)?))\n+fn introduction_builder(ast_func: &ast::Fn, ctx: &AssistContext) -> Option<String> {\n+    let hir_func = ctx.sema.to_def(ast_func)?;\n+    let container = hir_func.as_assoc_item(ctx.db())?.container(ctx.db());\n+    if let hir::AssocItemContainer::Impl(imp) = container {\n+        let ret_ty = hir_func.ret_type(ctx.db());\n+        let self_ty = imp.self_ty(ctx.db());\n+        let name = ast_func.name()?.to_string();\n+\n+        let intro_for_new = || {\n+            let is_new = name == \"new\";\n+            if is_new && ret_ty == self_ty {\n+                Some(format!(\"Creates a new [`{}`].\", self_type_without_lifetimes(ast_func)?))\n+            } else {\n+                None\n+            }\n+        };\n+\n+        let intro_for_getter = || match (\n+            hir_func.self_param(ctx.sema.db),\n+            &*hir_func.params_without_self(ctx.sema.db),\n+        ) {\n+            (Some(self_param), []) if self_param.access(ctx.sema.db) != hir::Access::Owned => {\n+                if name.starts_with(\"as_\") || name.starts_with(\"to_\") || name == \"get\" {\n+                    return None;\n                 }\n-                false => None,\n+                let what = name.trim_end_matches(\"_mut\").replace('_', \" \");\n+                let reference = if ret_ty.is_mutable_reference() {\n+                    \" a mutable reference to\"\n+                } else if ret_ty.is_reference() {\n+                    \" a reference to\"\n+                } else {\n+                    \"\"\n+                };\n+                Some(format!(\"Returns{reference} the {what}.\"))\n             }\n-        } else {\n-            None\n+            _ => None,\n+        };\n+\n+        let intro_for_setter = || {\n+            if !name.starts_with(\"set_\") {\n+                return None;\n+            }\n+\n+            let what = name.trim_start_matches(\"set_\").replace('_', \" \");\n+            Some(format!(\"Sets the {what}.\"))\n+        };\n+\n+        if let Some(intro) = intro_for_new() {\n+            return Some(intro);\n+        }\n+        if let Some(intro) = intro_for_getter() {\n+            return Some(intro);\n         }\n-    }()\n-    .unwrap_or_else(|| \".\".into())\n+        if let Some(intro) = intro_for_setter() {\n+            return Some(intro);\n+        }\n+    }\n+    None\n }\n \n /// Builds an `# Examples` section. An option is returned to be able to manage an error in the AST.\n@@ -1220,6 +1258,197 @@ impl<T> MyGenericStruct<T> {\n         self.x = new_value;\n     }\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn generates_intro_for_getters() {\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+pub struct S;\n+impl S {\n+    pub fn speed$0(&self) -> f32 { 0.0 }\n+}\n+\"#,\n+            r#\"\n+pub struct S;\n+impl S {\n+    /// Returns the speed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use test::S;\n+    ///\n+    /// let s = ;\n+    /// assert_eq!(s.speed(), );\n+    /// ```\n+    pub fn speed(&self) -> f32 { 0.0 }\n+}\n+\"#,\n+        );\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+pub struct S;\n+impl S {\n+    pub fn data$0(&self) -> &[u8] { &[] }\n+}\n+\"#,\n+            r#\"\n+pub struct S;\n+impl S {\n+    /// Returns a reference to the data.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use test::S;\n+    ///\n+    /// let s = ;\n+    /// assert_eq!(s.data(), );\n+    /// ```\n+    pub fn data(&self) -> &[u8] { &[] }\n+}\n+\"#,\n+        );\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+pub struct S;\n+impl S {\n+    pub fn data$0(&mut self) -> &mut [u8] { &mut [] }\n+}\n+\"#,\n+            r#\"\n+pub struct S;\n+impl S {\n+    /// Returns a mutable reference to the data.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use test::S;\n+    ///\n+    /// let mut s = ;\n+    /// assert_eq!(s.data(), );\n+    /// assert_eq!(s, );\n+    /// ```\n+    pub fn data(&mut self) -> &mut [u8] { &mut [] }\n+}\n+\"#,\n+        );\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+pub struct S;\n+impl S {\n+    pub fn data_mut$0(&mut self) -> &mut [u8] { &mut [] }\n+}\n+\"#,\n+            r#\"\n+pub struct S;\n+impl S {\n+    /// Returns a mutable reference to the data.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use test::S;\n+    ///\n+    /// let mut s = ;\n+    /// assert_eq!(s.data_mut(), );\n+    /// assert_eq!(s, );\n+    /// ```\n+    pub fn data_mut(&mut self) -> &mut [u8] { &mut [] }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn no_getter_intro_for_prefixed_methods() {\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+pub struct S;\n+impl S {\n+    pub fn as_bytes$0(&self) -> &[u8] { &[] }\n+}\n+\"#,\n+            r#\"\n+pub struct S;\n+impl S {\n+    /// .\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use test::S;\n+    ///\n+    /// let s = ;\n+    /// assert_eq!(s.as_bytes(), );\n+    /// ```\n+    pub fn as_bytes(&self) -> &[u8] { &[] }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn generates_intro_for_setters() {\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+pub struct S;\n+impl S {\n+    pub fn set_data$0(&mut self, data: Vec<u8>) {}\n+}\n+\"#,\n+            r#\"\n+pub struct S;\n+impl S {\n+    /// Sets the data.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use test::S;\n+    ///\n+    /// let mut s = ;\n+    /// s.set_data(data);\n+    /// assert_eq!(s, );\n+    /// ```\n+    pub fn set_data(&mut self, data: Vec<u8>) {}\n+}\n+\"#,\n+        );\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+pub struct S;\n+impl S {\n+    pub fn set_domain_name$0(&mut self, name: String) {}\n+}\n+\"#,\n+            r#\"\n+pub struct S;\n+impl S {\n+    /// Sets the domain name.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use test::S;\n+    ///\n+    /// let mut s = ;\n+    /// s.set_domain_name(name);\n+    /// assert_eq!(s, );\n+    /// ```\n+    pub fn set_domain_name(&mut self, name: String) {}\n+}\n \"#,\n         );\n     }"}, {"sha": "fead5c9a1238c14a516df9fa0db48e2c7e18ce11", "filename": "crates/ide-assists/src/handlers/generate_getter.rs", "status": "modified", "additions": 4, "deletions": 31, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f1b6e45fbacc8683a0a7da6e338261b943188849/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_getter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b6e45fbacc8683a0a7da6e338261b943188849/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_getter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_getter.rs?ref=f1b6e45fbacc8683a0a7da6e338261b943188849", "patch": "@@ -38,7 +38,6 @@ use crate::{\n // }\n //\n // impl Person {\n-//     /// Get a reference to the person's name.\n //     #[must_use]\n //     fn $0name(&self) -> &str {\n //         self.name.as_ref()\n@@ -65,7 +64,6 @@ pub(crate) fn generate_getter(acc: &mut Assists, ctx: &AssistContext) -> Option<\n // }\n //\n // impl Person {\n-//     /// Get a mutable reference to the person's name.\n //     #[must_use]\n //     fn $0name_mut(&mut self) -> &mut String {\n //         &mut self.name\n@@ -84,7 +82,6 @@ pub(crate) fn generate_getter_impl(\n     let strukt = ctx.find_node_at_offset::<ast::Struct>()?;\n     let field = ctx.find_node_at_offset::<ast::RecordField>()?;\n \n-    let strukt_name = strukt.name()?;\n     let field_name = field.name()?;\n     let field_ty = field.ty()?;\n \n@@ -114,12 +111,8 @@ pub(crate) fn generate_getter_impl(\n             }\n \n             let vis = strukt.visibility().map_or(String::new(), |v| format!(\"{} \", v));\n-            let (ty, body, description) = if mutable {\n-                (\n-                    format!(\"&mut {}\", field_ty),\n-                    format!(\"&mut self.{}\", field_name),\n-                    \"a mutable reference to \",\n-                )\n+            let (ty, body) = if mutable {\n+                (format!(\"&mut {}\", field_ty), format!(\"&mut self.{}\", field_name))\n             } else {\n                 (|| {\n                     let krate = ctx.sema.scope(field_ty.syntax())?.krate();\n@@ -132,25 +125,18 @@ pub(crate) fn generate_getter_impl(\n                             (\n                                 conversion.convert_type(ctx.db()),\n                                 conversion.getter(field_name.to_string()),\n-                                if conversion.is_copy() { \"\" } else { \"a reference to \" },\n                             )\n                         })\n                 })()\n-                .unwrap_or_else(|| {\n-                    (format!(\"&{}\", field_ty), format!(\"&self.{}\", field_name), \"a reference to \")\n-                })\n+                .unwrap_or_else(|| (format!(\"&{}\", field_ty), format!(\"&self.{}\", field_name)))\n             };\n \n             format_to!(\n                 buf,\n-                \"    /// Get {}the {}'s {}.\n-    #[must_use]\n+                \"    #[must_use]\n     {}fn {}(&{}self) -> {} {{\n         {}\n     }}\",\n-                description,\n-                to_lower_snake_case(&strukt_name.to_string()).replace('_', \" \"),\n-                fn_name.trim_end_matches(\"_mut\").replace('_', \" \"),\n                 vis,\n                 fn_name,\n                 mutable.then(|| \"mut \").unwrap_or_default(),\n@@ -196,7 +182,6 @@ struct Context {\n }\n \n impl Context {\n-    /// Get a reference to the context's data.\n     #[must_use]\n     fn $0data(&self) -> &Data {\n         &self.data\n@@ -218,7 +203,6 @@ struct Context {\n }\n \n impl Context {\n-    /// Get a mutable reference to the context's data.\n     #[must_use]\n     fn $0data_mut(&mut self) -> &mut Data {\n         &mut self.data\n@@ -277,7 +261,6 @@ pub(crate) struct Context {\n }\n \n impl Context {\n-    /// Get a reference to the context's data.\n     #[must_use]\n     pub(crate) fn $0data(&self) -> &Data {\n         &self.data\n@@ -298,7 +281,6 @@ struct Context {\n }\n \n impl Context {\n-    /// Get a reference to the context's data.\n     #[must_use]\n     fn data(&self) -> &Data {\n         &self.data\n@@ -312,13 +294,11 @@ struct Context {\n }\n \n impl Context {\n-    /// Get a reference to the context's data.\n     #[must_use]\n     fn data(&self) -> &Data {\n         &self.data\n     }\n \n-    /// Get a reference to the context's count.\n     #[must_use]\n     fn $0count(&self) -> &usize {\n         &self.count\n@@ -345,7 +325,6 @@ pub struct String;\n struct S { foo: String }\n \n impl S {\n-    /// Get a reference to the s's foo.\n     #[must_use]\n     fn $0foo(&self) -> &String {\n         &self.foo\n@@ -370,7 +349,6 @@ struct S { foo: $0bool }\n struct S { foo: bool }\n \n impl S {\n-    /// Get the s's foo.\n     #[must_use]\n     fn $0foo(&self) -> bool {\n         self.foo\n@@ -404,7 +382,6 @@ impl AsRef<str> for String {\n struct S { foo: String }\n \n impl S {\n-    /// Get a reference to the s's foo.\n     #[must_use]\n     fn $0foo(&self) -> &str {\n         self.foo.as_ref()\n@@ -442,7 +419,6 @@ impl<T> AsRef<T> for Box<T> {\n struct S { foo: Box<Sweets> }\n \n impl S {\n-    /// Get a reference to the s's foo.\n     #[must_use]\n     fn $0foo(&self) -> &Sweets {\n         self.foo.as_ref()\n@@ -476,7 +452,6 @@ impl<T> AsRef<[T]> for Vec<T> {\n struct S { foo: Vec<()> }\n \n impl S {\n-    /// Get a reference to the s's foo.\n     #[must_use]\n     fn $0foo(&self) -> &[()] {\n         self.foo.as_ref()\n@@ -500,7 +475,6 @@ struct Failure;\n struct S { foo: Option<Failure> }\n \n impl S {\n-    /// Get a reference to the s's foo.\n     #[must_use]\n     fn $0foo(&self) -> Option<&Failure> {\n         self.foo.as_ref()\n@@ -524,7 +498,6 @@ struct Context {\n }\n \n impl Context {\n-    /// Get a reference to the context's data.\n     #[must_use]\n     fn $0data(&self) -> Result<&bool, &i32> {\n         self.data.as_ref()"}, {"sha": "099d7a43a7f2570ec0bd9fc7ba8207147c80ee91", "filename": "crates/ide-assists/src/tests/generated.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1b6e45fbacc8683a0a7da6e338261b943188849/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b6e45fbacc8683a0a7da6e338261b943188849/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=f1b6e45fbacc8683a0a7da6e338261b943188849", "patch": "@@ -1036,7 +1036,6 @@ struct Person {\n }\n \n impl Person {\n-    /// Get a reference to the person's name.\n     #[must_use]\n     fn $0name(&self) -> &str {\n         self.name.as_ref()\n@@ -1061,7 +1060,6 @@ struct Person {\n }\n \n impl Person {\n-    /// Get a mutable reference to the person's name.\n     #[must_use]\n     fn $0name_mut(&mut self) -> &mut String {\n         &mut self.name"}, {"sha": "1231cf64a017fa55073c06f07f1306850913ebbe", "filename": "crates/ide-assists/src/utils.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1b6e45fbacc8683a0a7da6e338261b943188849/crates%2Fide-assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1b6e45fbacc8683a0a7da6e338261b943188849/crates%2Fide-assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Futils.rs?ref=f1b6e45fbacc8683a0a7da6e338261b943188849", "patch": "@@ -568,10 +568,6 @@ impl ReferenceConversion {\n             | ReferenceConversionType::Result => format!(\"self.{}.as_ref()\", field_name),\n         }\n     }\n-\n-    pub(crate) fn is_copy(&self) -> bool {\n-        matches!(self.conversion, ReferenceConversionType::Copy)\n-    }\n }\n \n // FIXME: It should return a new hir::Type, but currently constructing new types is too cumbersome"}]}