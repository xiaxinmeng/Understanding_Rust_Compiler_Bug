{"sha": "0c5225c5bf31dcca141c36ce1b5850ff2df79b9c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjNTIyNWM1YmYzMWRjY2ExNDFjMzZjZTFiNTg1MGZmMmRmNzliOWM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2015-01-17T21:36:59Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2015-01-20T19:27:15Z"}, "message": "Add error codes to rustc_typeck", "tree": {"sha": "16b865349371efe55af1ad17108b90654a4f9e23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16b865349371efe55af1ad17108b90654a4f9e23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c5225c5bf31dcca141c36ce1b5850ff2df79b9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c5225c5bf31dcca141c36ce1b5850ff2df79b9c", "html_url": "https://github.com/rust-lang/rust/commit/0c5225c5bf31dcca141c36ce1b5850ff2df79b9c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c5225c5bf31dcca141c36ce1b5850ff2df79b9c/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "953d6dfd7e1b1d5c5b17314b6e3bdec15d8e7a01", "url": "https://api.github.com/repos/rust-lang/rust/commits/953d6dfd7e1b1d5c5b17314b6e3bdec15d8e7a01", "html_url": "https://github.com/rust-lang/rust/commit/953d6dfd7e1b1d5c5b17314b6e3bdec15d8e7a01"}], "stats": {"total": 336, "additions": 179, "deletions": 157}, "files": [{"sha": "080959cae0c749c454dacd674f359611bffe1e3b", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 36, "deletions": 48, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/0c5225c5bf31dcca141c36ce1b5850ff2df79b9c/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5225c5bf31dcca141c36ce1b5850ff2df79b9c/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=0c5225c5bf31dcca141c36ce1b5850ff2df79b9c", "patch": "@@ -100,8 +100,7 @@ pub trait AstConv<'tcx> {\n                                         -> Ty<'tcx>\n     {\n         if ty::binds_late_bound_regions(self.tcx(), &poly_trait_ref) {\n-            self.tcx().sess.span_err(\n-                span,\n+            span_err!(self.tcx().sess, span, E0212,\n                 \"cannot extract an associated type from a higher-ranked trait bound \\\n                  in this context\");\n             self.tcx().types.err\n@@ -119,8 +118,7 @@ pub trait AstConv<'tcx> {\n                     _item_name: ast::Name)\n                     -> Ty<'tcx>\n     {\n-        self.tcx().sess.span_err(\n-            span,\n+        span_err!(self.tcx().sess, span, E0213,\n             \"associated types are not accepted in this context\");\n \n         self.tcx().types.err\n@@ -268,8 +266,7 @@ pub fn ast_path_substs_for_ty<'tcx>(\n             convert_angle_bracketed_parameters(this, rscope, data)\n         }\n         ast::ParenthesizedParameters(ref data) => {\n-            tcx.sess.span_err(\n-                path.span,\n+            span_err!(tcx.sess, path.span, E0214,\n                 \"parenthesized parameters may only be used with a trait\");\n             (Vec::new(), convert_parenthesized_parameters(this, data), Vec::new())\n         }\n@@ -610,7 +607,7 @@ fn ast_path_to_trait_ref<'a,'tcx>(\n             if !this.tcx().sess.features.borrow().unboxed_closures &&\n                 this.tcx().lang_items.fn_trait_kind(trait_def_id).is_some()\n             {\n-                this.tcx().sess.span_err(path.span,\n+                span_err!(this.tcx().sess, path.span, E0215,\n                                          \"angle-bracket notation is not stable when \\\n                                          used with the `Fn` family of traits, use parentheses\");\n                 span_help!(this.tcx().sess, path.span,\n@@ -626,7 +623,7 @@ fn ast_path_to_trait_ref<'a,'tcx>(\n             if !this.tcx().sess.features.borrow().unboxed_closures &&\n                 this.tcx().lang_items.fn_trait_kind(trait_def_id).is_none()\n             {\n-                this.tcx().sess.span_err(path.span,\n+                span_err!(this.tcx().sess, path.span, E0216,\n                                          \"parenthetical notation is only stable when \\\n                                          used with the `Fn` family of traits\");\n                 span_help!(this.tcx().sess, path.span,\n@@ -738,32 +735,29 @@ fn ast_type_binding_to_projection_predicate<'tcx>(\n     }\n \n     if candidates.len() > 1 {\n-        tcx.sess.span_err(\n-            binding.span,\n-            format!(\"ambiguous associated type: `{}` defined in multiple supertraits `{}`\",\n+        span_err!(tcx.sess, binding.span, E0217,\n+            \"ambiguous associated type: `{}` defined in multiple supertraits `{}`\",\n                     token::get_name(binding.item_name),\n-                    candidates.user_string(tcx)).as_slice());\n+                    candidates.user_string(tcx));\n         return Err(ErrorReported);\n     }\n \n     let candidate = match candidates.pop() {\n         Some(c) => c,\n         None => {\n-            tcx.sess.span_err(\n-                binding.span,\n-                format!(\"no associated type `{}` defined in `{}`\",\n+            span_err!(tcx.sess, binding.span, E0218,\n+                \"no associated type `{}` defined in `{}`\",\n                         token::get_name(binding.item_name),\n-                        trait_ref.user_string(tcx)).as_slice());\n+                        trait_ref.user_string(tcx));\n             return Err(ErrorReported);\n         }\n     };\n \n     if ty::binds_late_bound_regions(tcx, &candidate) {\n-        tcx.sess.span_err(\n-            binding.span,\n-            format!(\"associated type `{}` defined in higher-ranked supertrait `{}`\",\n+        span_err!(tcx.sess, binding.span, E0219,\n+            \"associated type `{}` defined in higher-ranked supertrait `{}`\",\n                     token::get_name(binding.item_name),\n-                    candidate.user_string(tcx)).as_slice());\n+                    candidate.user_string(tcx));\n         return Err(ErrorReported);\n     }\n \n@@ -964,18 +958,18 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n     }\n \n     if suitable_bounds.len() == 0 {\n-        tcx.sess.span_err(ast_ty.span,\n-                          format!(\"associated type `{}` not found for type parameter `{}`\",\n+        span_err!(tcx.sess, ast_ty.span, E0220,\n+                          \"associated type `{}` not found for type parameter `{}`\",\n                                   token::get_name(assoc_name),\n-                                  token::get_name(ty_param_name)).as_slice());\n+                                  token::get_name(ty_param_name));\n         return this.tcx().types.err;\n     }\n \n     if suitable_bounds.len() > 1 {\n-        tcx.sess.span_err(ast_ty.span,\n-                          format!(\"ambiguous associated type `{}` in bounds of `{}`\",\n+        span_err!(tcx.sess, ast_ty.span, E0221,\n+                          \"ambiguous associated type `{}` in bounds of `{}`\",\n                                   token::get_name(assoc_name),\n-                                  token::get_name(ty_param_name)).as_slice());\n+                                  token::get_name(ty_param_name));\n \n         for suitable_bound in suitable_bounds.iter() {\n             span_note!(this.tcx().sess, ast_ty.span,\n@@ -1093,7 +1087,7 @@ pub fn ast_ty_to_ty<'tcx>(\n             ast::TyParen(ref typ) => ast_ty_to_ty(this, rscope, &**typ),\n             ast::TyBareFn(ref bf) => {\n                 if bf.decl.variadic && bf.abi != abi::C {\n-                    tcx.sess.span_err(ast_ty.span,\n+                    span_err!(tcx.sess, ast_ty.span, E0222,\n                                       \"variadic function must have C calling convention\");\n                 }\n                 let bare_fn = ty_of_bare_fn(this, bf.unsafety, bf.abi, &*bf.decl);\n@@ -1152,8 +1146,8 @@ pub fn ast_ty_to_ty<'tcx>(\n                     def::DefAssociatedTy(trait_type_id) => {\n                         let path_str = tcx.map.path_to_string(\n                             tcx.map.get_parent(trait_type_id.node));\n-                        tcx.sess.span_err(ast_ty.span,\n-                                          &format!(\"ambiguous associated \\\n+                        span_err!(tcx.sess, ast_ty.span, E0223,\n+                                          \"ambiguous associated \\\n                                                    type; specify the type \\\n                                                    using the syntax `<Type \\\n                                                    as {}>::{}`\",\n@@ -1163,7 +1157,7 @@ pub fn ast_ty_to_ty<'tcx>(\n                                                           .last()\n                                                           .unwrap()\n                                                           .identifier)\n-                                                  .get())[]);\n+                                                  .get());\n                         this.tcx().types.err\n                     }\n                     def::DefAssociatedPath(provenance, assoc_ident) => {\n@@ -1557,8 +1551,7 @@ fn conv_ty_poly_trait_ref<'tcx>(\n                                         None,\n                                         &mut projection_bounds))\n     } else {\n-        this.tcx().sess.span_err(\n-            span,\n+        span_err!(this.tcx().sess, span, E0224,\n             \"at least one non-builtin trait is required for an object type\");\n         None\n     };\n@@ -1593,10 +1586,9 @@ pub fn conv_existential_bounds_from_partitioned_bounds<'tcx>(\n \n     if !trait_bounds.is_empty() {\n         let b = &trait_bounds[0];\n-        this.tcx().sess.span_err(\n-            b.trait_ref.path.span,\n-            &format!(\"only the builtin traits can be used \\\n-                     as closure or object bounds\")[]);\n+        span_err!(this.tcx().sess, b.trait_ref.path.span, E0225,\n+            \"only the builtin traits can be used \\\n+                     as closure or object bounds\");\n     }\n \n     let region_bound = compute_region_bound(this,\n@@ -1633,9 +1625,8 @@ fn compute_opt_region_bound<'tcx>(tcx: &ty::ctxt<'tcx>,\n            builtin_bounds.repr(tcx));\n \n     if explicit_region_bounds.len() > 1 {\n-        tcx.sess.span_err(\n-            explicit_region_bounds[1].span,\n-            format!(\"only a single explicit lifetime bound is permitted\").as_slice());\n+        span_err!(tcx.sess, explicit_region_bounds[1].span, E0226,\n+            \"only a single explicit lifetime bound is permitted\");\n     }\n \n     if explicit_region_bounds.len() != 0 {\n@@ -1666,10 +1657,9 @@ fn compute_opt_region_bound<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // error.\n     let r = derived_region_bounds[0];\n     if derived_region_bounds.slice_from(1).iter().any(|r1| r != *r1) {\n-        tcx.sess.span_err(\n-            span,\n-            &format!(\"ambiguous lifetime bound, \\\n-                     explicit lifetime bound required\")[]);\n+        span_err!(tcx.sess, span, E0227,\n+            \"ambiguous lifetime bound, \\\n+                     explicit lifetime bound required\");\n     }\n     return Some(r);\n }\n@@ -1693,9 +1683,8 @@ fn compute_region_bound<'tcx>(\n             match rscope.default_region_bound(span) {\n                 Some(r) => { r }\n                 None => {\n-                    this.tcx().sess.span_err(\n-                        span,\n-                        &format!(\"explicit lifetime bound required\")[]);\n+                    span_err!(this.tcx().sess, span, E0228,\n+                        \"explicit lifetime bound required\");\n                     ty::ReStatic\n                 }\n             }\n@@ -1779,8 +1768,7 @@ fn prohibit_projections<'tcx>(tcx: &ty::ctxt<'tcx>,\n                               bindings: &[ConvertedBinding<'tcx>])\n {\n     for binding in bindings.iter().take(1) {\n-        tcx.sess.span_err(\n-            binding.span,\n+        span_err!(tcx.sess, binding.span, E0229,\n             \"associated type bindings are not allowed here\");\n     }\n }"}, {"sha": "33cce67c7807d8d24819c3d5fc35fccae31a8a53", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0c5225c5bf31dcca141c36ce1b5850ff2df79b9c/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5225c5bf31dcca141c36ce1b5850ff2df79b9c/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=0c5225c5bf31dcca141c36ce1b5850ff2df79b9c", "patch": "@@ -50,10 +50,9 @@ pub fn check_expr_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n \n                     check_unboxed_closure(fcx, expr, kind, decl, body, None);\n \n-                    fcx.ccx.tcx.sess.span_err(\n-                        expr.span,\n+                    span_err!(fcx.ccx.tcx.sess, expr.span, E0187,\n                         \"can't infer the \\\"kind\\\" of the closure, explicitly annotate it. e.g. \\\n-                        `|&:| {}`\");\n+                        `|&:| {{}}`\");\n                 },\n                 Some((sig, kind)) => {\n                     check_unboxed_closure(fcx, expr, kind, decl, body, Some(sig));"}, {"sha": "e3e5d67869fa47afb4a6f93ced61ad4d33505a98", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0c5225c5bf31dcca141c36ce1b5850ff2df79b9c/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5225c5bf31dcca141c36ce1b5850ff2df79b9c/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=0c5225c5bf31dcca141c36ce1b5850ff2df79b9c", "patch": "@@ -59,23 +59,21 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         (&ty::StaticExplicitSelfCategory,\n          &ty::StaticExplicitSelfCategory) => {}\n         (&ty::StaticExplicitSelfCategory, _) => {\n-            tcx.sess.span_err(\n-                impl_m_span,\n-                format!(\"method `{}` has a `{}` declaration in the impl, \\\n+            span_err!(tcx.sess, impl_m_span, E0185,\n+                \"method `{}` has a `{}` declaration in the impl, \\\n                         but not in the trait\",\n                         token::get_name(trait_m.name),\n                         ppaux::explicit_self_category_to_str(\n-                            &impl_m.explicit_self)).as_slice());\n+                            &impl_m.explicit_self));\n             return;\n         }\n         (_, &ty::StaticExplicitSelfCategory) => {\n-            tcx.sess.span_err(\n-                impl_m_span,\n-                format!(\"method `{}` has a `{}` declaration in the trait, \\\n+            span_err!(tcx.sess, impl_m_span, E0186,\n+                \"method `{}` has a `{}` declaration in the trait, \\\n                         but not in the impl\",\n                         token::get_name(trait_m.name),\n                         ppaux::explicit_self_category_to_str(\n-                            &trait_m.explicit_self)).as_slice());\n+                            &trait_m.explicit_self));\n             return;\n         }\n         _ => {\n@@ -400,11 +398,10 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         // are zero. Since I don't quite know how to phrase things at\n         // the moment, give a kind of vague error message.\n         if trait_params.len() != impl_params.len() {\n-            tcx.sess.span_err(\n-                span,\n-                &format!(\"lifetime parameters or bounds on method `{}` do \\\n+            span_err!(tcx.sess, span, E0195,\n+                \"lifetime parameters or bounds on method `{}` do \\\n                          not match the trait declaration\",\n-                         token::get_name(impl_m.name))[]);\n+                         token::get_name(impl_m.name));\n             return false;\n         }\n "}, {"sha": "58b655d758543956f872f658676f1bba00700cf7", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 19, "deletions": 25, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/0c5225c5bf31dcca141c36ce1b5850ff2df79b9c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5225c5bf31dcca141c36ce1b5850ff2df79b9c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=0c5225c5bf31dcca141c36ce1b5850ff2df79b9c", "patch": "@@ -801,24 +801,23 @@ fn check_trait_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         }) {\n                             Some(_) => (),\n                             None => {\n-                                ccx.tcx.sess.span_err(attr.span,\n-                                                 format!(\"there is no type parameter \\\n+                                span_err!(ccx.tcx.sess, attr.span, E0230,\n+                                                 \"there is no type parameter \\\n                                                           {} on trait {}\",\n-                                                           s, item.ident.as_str())\n-                                            .as_slice());\n+                                                           s, item.ident.as_str());\n                             }\n                         },\n                         // `{:1}` and `{}` are not to be used\n                         Position::ArgumentIs(_) | Position::ArgumentNext => {\n-                            ccx.tcx.sess.span_err(attr.span,\n+                            span_err!(ccx.tcx.sess, attr.span, E0231,\n                                                   \"only named substitution \\\n                                                    parameters are allowed\");\n                         }\n                     }\n                 }\n             }\n         } else {\n-            ccx.tcx.sess.span_err(attr.span,\n+            span_err!(ccx.tcx.sess, attr.span, E0232,\n                                   \"this attribute must have a value, \\\n                                    eg `#[rustc_on_unimplemented = \\\"foo\\\"]`\")\n         }\n@@ -2099,8 +2098,8 @@ fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let trait_did = match fcx.tcx().lang_items.require(IteratorItem) {\n         Ok(trait_did) => trait_did,\n         Err(ref err_string) => {\n-            fcx.tcx().sess.span_err(iterator_expr.span,\n-                                    &err_string[]);\n+            span_err!(fcx.tcx().sess, iterator_expr.span, E0233,\n+                                    \"{}\", &err_string[]);\n             return fcx.tcx().types.err\n         }\n     };\n@@ -2123,11 +2122,10 @@ fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n             if !ty::type_is_error(true_expr_type) {\n                 let ty_string = fcx.infcx().ty_to_string(true_expr_type);\n-                fcx.tcx().sess.span_err(iterator_expr.span,\n-                                        &format!(\"`for` loop expression has type `{}` which does \\\n+                span_err!(fcx.tcx().sess, iterator_expr.span, E0234,\n+                                        \"`for` loop expression has type `{}` which does \\\n                                                 not implement the `Iterator` trait; \\\n-                                                maybe try .iter()\",\n-                                                ty_string)[]);\n+                                                maybe try .iter()\", ty_string);\n             }\n             fcx.tcx().types.err\n         }\n@@ -2162,11 +2160,10 @@ fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     fcx.tcx().types.err\n                 }\n                 _ => {\n-                    fcx.tcx().sess.span_err(iterator_expr.span,\n-                                            &format!(\"`next` method of the `Iterator` \\\n+                    span_err!(fcx.tcx().sess, iterator_expr.span, E0239,\n+                                            \"`next` method of the `Iterator` \\\n                                                     trait has an unexpected type `{}`\",\n-                                                    fcx.infcx().ty_to_string(return_type))\n-                                            []);\n+                                                    fcx.infcx().ty_to_string(return_type));\n                     fcx.tcx().types.err\n                 }\n             }\n@@ -3880,18 +3877,16 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 Err(type_error) => {\n                     let type_error_description =\n                         ty::type_err_to_str(tcx, &type_error);\n-                    fcx.tcx()\n-                       .sess\n-                       .span_err(path.span,\n-                                 &format!(\"structure constructor specifies a \\\n+                    span_err!(fcx.tcx().sess, path.span, E0235,\n+                                 \"structure constructor specifies a \\\n                                          structure of type `{}`, but this \\\n                                          structure has type `{}`: {}\",\n                                          fcx.infcx()\n                                             .ty_to_string(type_and_substs.ty),\n                                          fcx.infcx()\n                                             .ty_to_string(\n                                                 actual_structure_type),\n-                                         type_error_description)[]);\n+                                         type_error_description);\n                     ty::note_and_explain_type_err(tcx, &type_error);\n                 }\n             }\n@@ -4012,7 +4007,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n                     ty::mk_struct(tcx, did, tcx.mk_substs(substs))\n                 } else {\n-                    tcx.sess.span_err(expr.span, \"No lang item for range syntax\");\n+                    span_err!(tcx.sess, expr.span, E0236, \"no lang item for range syntax\");\n                     fcx.tcx().types.err\n                 }\n             }\n@@ -4022,7 +4017,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     let substs = Substs::new_type(vec![], vec![]);\n                     ty::mk_struct(tcx, did, tcx.mk_substs(substs))\n                 } else {\n-                    tcx.sess.span_err(expr.span, \"No lang item for range syntax\");\n+                    span_err!(tcx.sess, expr.span, E0237, \"no lang item for range syntax\");\n                     fcx.tcx().types.err\n                 }\n             }\n@@ -4872,8 +4867,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             }\n \n             ast::ParenthesizedParameters(ref data) => {\n-                fcx.tcx().sess.span_err(\n-                    span,\n+                span_err!(fcx.tcx().sess, span, E0238,\n                     \"parenthesized parameters may only be used with a trait\");\n                 push_explicit_parenthesized_parameters_from_segment_to_substs(\n                     fcx, space, span, type_defs, data, substs);"}, {"sha": "41b63830279a8f1b8109d993f0c49a9019771758", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0c5225c5bf31dcca141c36ce1b5850ff2df79b9c/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5225c5bf31dcca141c36ce1b5850ff2df79b9c/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=0c5225c5bf31dcca141c36ce1b5850ff2df79b9c", "patch": "@@ -51,7 +51,7 @@ pub fn check_object_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         {\n             let object_trait = object_trait(&object_trait_ty);\n             if !mutability_allowed(referent_mutbl, target_mutbl) {\n-                fcx.tcx().sess.span_err(source_expr.span,\n+                span_err!(fcx.tcx().sess, source_expr.span, E0188,\n                                         \"types differ in mutability\");\n             } else {\n                 // Ensure that if &'a T is cast to &'b Trait, then T : Trait\n@@ -70,19 +70,17 @@ pub fn check_object_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n \n         (_, &ty::ty_uniq(..)) => {\n-            fcx.ccx.tcx.sess.span_err(\n-                source_expr.span,\n-                &format!(\"can only cast an boxed pointer \\\n+            span_err!(fcx.ccx.tcx.sess, source_expr.span, E0189,\n+                \"can only cast a boxed pointer \\\n                          to a boxed object, not a {}\",\n-                        ty::ty_sort_string(fcx.tcx(), source_ty))[]);\n+                      ty::ty_sort_string(fcx.tcx(), source_ty));\n         }\n \n         (_, &ty::ty_rptr(..)) => {\n-            fcx.ccx.tcx.sess.span_err(\n-                source_expr.span,\n-                &format!(\"can only cast a &-pointer \\\n+            span_err!(fcx.ccx.tcx.sess, source_expr.span, E0190,\n+                \"can only cast a &-pointer \\\n                          to an &-object, not a {}\",\n-                        ty::ty_sort_string(fcx.tcx(), source_ty))[]);\n+                        ty::ty_sort_string(fcx.tcx(), source_ty));\n         }\n \n         _ => {\n@@ -272,11 +270,10 @@ fn check_object_type_binds_all_associated_types<'tcx>(tcx: &ty::ctxt<'tcx>,\n     }\n \n     for (trait_def_id, name) in associated_types.into_iter() {\n-        tcx.sess.span_err(\n-            span,\n-            format!(\"the value of the associated type `{}` (from the trait `{}`) must be specified\",\n+        span_err!(tcx.sess, span, E0191,\n+            \"the value of the associated type `{}` (from the trait `{}`) must be specified\",\n                     name.user_string(tcx),\n-                    ty::item_path_str(tcx, trait_def_id)).as_slice());\n+                    ty::item_path_str(tcx, trait_def_id));\n     }\n }\n "}, {"sha": "60284433ffe457f44cbfe52ccaa410a01ca50059", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0c5225c5bf31dcca141c36ce1b5850ff2df79b9c/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5225c5bf31dcca141c36ce1b5850ff2df79b9c/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=0c5225c5bf31dcca141c36ce1b5850ff2df79b9c", "patch": "@@ -81,10 +81,9 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 match ccx.tcx.lang_items.to_builtin_kind(trait_ref.def_id) {\n                     Some(ty::BoundSend) | Some(ty::BoundSync) => {}\n                     Some(_) | None => {\n-                        ccx.tcx.sess.span_err(\n-                            item.span,\n-                            format!(\"negative impls are currently \\\n-                                     allowed just for `Send` and `Sync`\").as_slice())\n+                        span_err!(ccx.tcx.sess, item.span, E0192,\n+                            \"negative impls are currently \\\n+                                     allowed just for `Send` and `Sync`\")\n                     }\n                 }\n             }\n@@ -302,12 +301,11 @@ fn reject_non_type_param_bounds<'tcx>(tcx: &ty::ctxt<'tcx>,\n     fn report_bound_error<'t>(tcx: &ty::ctxt<'t>,\n                           span: Span,\n                           bounded_ty: ty::Ty<'t>) {\n-        tcx.sess.span_err(\n-            span,\n-            format!(\"cannot bound type `{}`, where clause \\\n+        span_err!(tcx.sess, span, E0193,\n+            \"cannot bound type `{}`, where clause \\\n                 bounds may only be attached to types involving \\\n                 type parameters\",\n-                bounded_ty.repr(tcx)).as_slice())\n+                bounded_ty.repr(tcx))\n     }\n \n     fn is_ty_param(ty: ty::Ty) -> bool {\n@@ -326,10 +324,9 @@ fn reject_shadowing_type_parameters<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     for method_param in generics.types.get_slice(subst::FnSpace).iter() {\n         if impl_params.contains(&method_param.name) {\n-            tcx.sess.span_err(\n-                span,\n-                &*format!(\"type parameter `{}` shadows another type parameter of the same name\",\n-                          token::get_name(method_param.name)));\n+            span_err!(tcx.sess, span, E0194,\n+                \"type parameter `{}` shadows another type parameter of the same name\",\n+                          token::get_name(method_param.name));\n         }\n     }\n }"}, {"sha": "52e81585875abe1a3dce1ba4bb9473f32666c29f", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c5225c5bf31dcca141c36ce1b5850ff2df79b9c/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5225c5bf31dcca141c36ce1b5850ff2df79b9c/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=0c5225c5bf31dcca141c36ce1b5850ff2df79b9c", "patch": "@@ -416,7 +416,7 @@ impl<'cx, 'tcx> Resolver<'cx, 'tcx> {\n \n                 ResolvingUnboxedClosure(_) => {\n                     let span = self.reason.span(self.tcx);\n-                    self.tcx.sess.span_err(span,\n+                    span_err!(self.tcx.sess, span, E0196,\n                                            \"cannot determine a type for this \\\n                                             unboxed closure\")\n                 }"}, {"sha": "e535b86a7bfd1e0cfa72c2cb8e74ed84fcc3e261", "filename": "src/librustc_typeck/coherence/impls.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0c5225c5bf31dcca141c36ce1b5850ff2df79b9c/src%2Flibrustc_typeck%2Fcoherence%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5225c5bf31dcca141c36ce1b5850ff2df79b9c/src%2Flibrustc_typeck%2Fcoherence%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fimpls.rs?ref=0c5225c5bf31dcca141c36ce1b5850ff2df79b9c", "patch": "@@ -34,10 +34,9 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for ImplsChecker<'cx, 'tcx> {\n                     match trait_ref.self_ty().sty {\n                         ty::ty_struct(..) | ty::ty_enum(..) => {}\n                         _ => {\n-                            self.tcx.sess.span_err(\n-                                item.span,\n-                                &format!(\"builtin traits can only be \\\n-                                          implemented on structs or enums\")[]);\n+                            span_err!(self.tcx.sess, item.span, E0209,\n+                                \"builtin traits can only be \\\n+                                          implemented on structs or enums\");\n                         }\n                     }\n                 }"}, {"sha": "7d59c3f9d3ff5f8d785daeeea2259dee3eb0f0c3", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0c5225c5bf31dcca141c36ce1b5850ff2df79b9c/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5225c5bf31dcca141c36ce1b5850ff2df79b9c/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=0c5225c5bf31dcca141c36ce1b5850ff2df79b9c", "patch": "@@ -490,24 +490,21 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             match ty::can_type_implement_copy(&param_env, span, self_type) {\n                 Ok(()) => {}\n                 Err(ty::FieldDoesNotImplementCopy(name)) => {\n-                    tcx.sess\n-                       .span_err(span,\n-                                 &format!(\"the trait `Copy` may not be \\\n+                       span_err!(tcx.sess, span, E0204,\n+                                 \"the trait `Copy` may not be \\\n                                           implemented for this type; field \\\n                                           `{}` does not implement `Copy`\",\n-                                         token::get_name(name))[])\n+                                         token::get_name(name))\n                 }\n                 Err(ty::VariantDoesNotImplementCopy(name)) => {\n-                    tcx.sess\n-                       .span_err(span,\n-                                 &format!(\"the trait `Copy` may not be \\\n+                       span_err!(tcx.sess, span, E0205,\n+                                 \"the trait `Copy` may not be \\\n                                           implemented for this type; variant \\\n                                           `{}` does not implement `Copy`\",\n-                                         token::get_name(name))[])\n+                                         token::get_name(name))\n                 }\n                 Err(ty::TypeIsStructural) => {\n-                    tcx.sess\n-                       .span_err(span,\n+                       span_err!(tcx.sess, span, E0206,\n                                  \"the trait `Copy` may not be implemented \\\n                                   for this type; type is not a structure or \\\n                                   enumeration\")"}, {"sha": "60b1fa5f4cf5d1068b3a9479ee321270d351ce0c", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c5225c5bf31dcca141c36ce1b5850ff2df79b9c/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5225c5bf31dcca141c36ce1b5850ff2df79b9c/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=0c5225c5bf31dcca141c36ce1b5850ff2df79b9c", "patch": "@@ -89,13 +89,11 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OrphanChecker<'cx, 'tcx> {\n                     }\n                     Err(traits::OrphanCheckErr::UncoveredTy(param_ty)) => {\n                         if !ty::has_attr(self.tcx, trait_def_id, \"old_orphan_check\") {\n-                            self.tcx.sess.span_err(\n-                                item.span,\n-                                format!(\n+                            span_err!(self.tcx.sess, item.span, E0210,\n                                     \"type parameter `{}` is not constrained by any local type; \\\n                                      only traits defined in the current crate can be implemented \\\n                                      for a type parameter\",\n-                                    param_ty.user_string(self.tcx)).as_slice());\n+                                    param_ty.user_string(self.tcx));\n                             self.tcx.sess.span_note(\n                                 item.span,\n                                 format!(\"for a limited time, you can add \\"}, {"sha": "867dea9588568b515c68d7f699b258505e9da37c", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0c5225c5bf31dcca141c36ce1b5850ff2df79b9c/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5225c5bf31dcca141c36ce1b5850ff2df79b9c/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=0c5225c5bf31dcca141c36ce1b5850ff2df79b9c", "patch": "@@ -37,8 +37,7 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for UnsafetyChecker<'cx, 'tcx> {\n                         match unsafety {\n                             ast::Unsafety::Normal => { /* OK */ }\n                             ast::Unsafety::Unsafe => {\n-                                self.tcx.sess.span_err(\n-                                    item.span,\n+                                span_err!(self.tcx.sess, item.span, E0197,\n                                     \"inherent impls cannot be declared as unsafe\");\n                             }\n                         }\n@@ -49,24 +48,21 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for UnsafetyChecker<'cx, 'tcx> {\n                         match (trait_def.unsafety, unsafety, polarity) {\n                             (ast::Unsafety::Unsafe,\n                              ast::Unsafety::Unsafe, ast::ImplPolarity::Negative) => {\n-                                self.tcx.sess.span_err(\n-                                    item.span,\n-                                    format!(\"negative implementations are not unsafe\").as_slice());\n+                                span_err!(self.tcx.sess, item.span, E0198,\n+                                    \"negative implementations are not unsafe\");\n                             }\n \n                             (ast::Unsafety::Normal, ast::Unsafety::Unsafe, _) => {\n-                                self.tcx.sess.span_err(\n-                                    item.span,\n-                                    format!(\"implementing the trait `{}` is not unsafe\",\n-                                            trait_ref.user_string(self.tcx)).as_slice());\n+                                span_err!(self.tcx.sess, item.span, E0199,\n+                                    \"implementing the trait `{}` is not unsafe\",\n+                                            trait_ref.user_string(self.tcx));\n                             }\n \n                             (ast::Unsafety::Unsafe,\n                              ast::Unsafety::Normal, ast::ImplPolarity::Positive) => {\n-                                self.tcx.sess.span_err(\n-                                    item.span,\n-                                    format!(\"the trait `{}` requires an `unsafe impl` declaration\",\n-                                            trait_ref.user_string(self.tcx)).as_slice());\n+                                span_err!(self.tcx.sess, item.span, E0200,\n+                                    \"the trait `{}` requires an `unsafe impl` declaration\",\n+                                            trait_ref.user_string(self.tcx));\n                             }\n \n                             (ast::Unsafety::Unsafe,"}, {"sha": "664e5eaa45baeb896ca73e8f0d74f7bbbebb5b80", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0c5225c5bf31dcca141c36ce1b5850ff2df79b9c/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5225c5bf31dcca141c36ce1b5850ff2df79b9c/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=0c5225c5bf31dcca141c36ce1b5850ff2df79b9c", "patch": "@@ -452,7 +452,7 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CollectCtxt<'a, 'tcx>,\n     let mut seen_methods = FnvHashSet();\n     for m in ms {\n         if !seen_methods.insert(m.pe_ident().repr(tcx)) {\n-            tcx.sess.span_err(m.span, \"duplicate method in trait impl\");\n+            span_err!(tcx.sess, m.span, E0201, \"duplicate method in trait impl\");\n         }\n \n         let m_def_id = local_def(m.id);\n@@ -608,7 +608,7 @@ fn convert(ccx: &CollectCtxt, it: &ast::Item) {\n                     }\n                     ast::TypeImplItem(ref typedef) => {\n                         if opt_trait_ref.is_none() {\n-                            tcx.sess.span_err(typedef.span,\n+                            span_err!(tcx.sess, typedef.span, E0202,\n                                               \"associated items are not allowed in inherent impls\");\n                         }\n \n@@ -1160,7 +1160,8 @@ fn add_unsized_bound<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                 assert!(ptr.bound_lifetimes.is_empty());\n                 unbound = Some(ptr.trait_ref.clone());\n             } else {\n-                ccx.tcx.sess.span_err(span, \"type parameter has more than one relaxed default \\\n+                span_err!(ccx.tcx.sess, span, E0203,\n+                          \"type parameter has more than one relaxed default \\\n                                                 bound, only one is supported\");\n             }\n         }\n@@ -1690,11 +1691,10 @@ fn enforce_impl_ty_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n                              impl trait, self type, or predicates\",\n                             param_ty.user_string(tcx)).as_slice());\n             } else {\n-                tcx.sess.span_err(\n-                    ty_param.span,\n-                    format!(\"the type parameter `{}` is not constrained by the \\\n+                span_err!(tcx.sess, ty_param.span, E0207,\n+                    \"the type parameter `{}` is not constrained by the \\\n                              impl trait, self type, or predicates\",\n-                            param_ty.user_string(tcx)).as_slice());\n+                            param_ty.user_string(tcx));\n                 tcx.sess.span_help(\n                     ty_param.span,\n                     format!(\"you can temporarily opt out of this rule by placing \\"}, {"sha": "ce30cb91c91c896e5942a320ae41844487e49225", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 61, "deletions": 1, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/0c5225c5bf31dcca141c36ce1b5850ff2df79b9c/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5225c5bf31dcca141c36ce1b5850ff2df79b9c/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=0c5225c5bf31dcca141c36ce1b5850ff2df79b9c", "patch": "@@ -100,7 +100,67 @@ register_diagnostics! {\n     E0178,\n     E0182,\n     E0183,\n-    E0184\n+    E0184,\n+    E0185,\n+    E0186,\n+    E0187, // can't infer the kind of the closure\n+    E0188, // types differ in mutability\n+    E0189, // can only cast a boxed pointer to a boxed object\n+    E0190, // can only cast a &-pointer to an &-object\n+    E0191, // value of the associated type must be specified\n+    E0192, // negative imples are allowed just fo `Send` and `Sync`\n+    E0193, // cannot bound type where clause bounds may only be attached to types\n+           // involving type parameters\n+    E0194,\n+    E0195, // lifetime parameters or bounds on method do not match the trait declaration\n+    E0196, // cannot determine a type for this unboxed closure\n+    E0197, // inherent impls cannot be declared as unsafe\n+    E0198, // negative implementations are not unsafe\n+    E0199, // implementing trait is not unsafe\n+    E0200, // trait requires an `unsafe impl` declaration\n+    E0201, // duplicate method in trait impl\n+    E0202, // associated items are not allowed in inherint impls\n+    E0203, // type parameter has more than one relaxed default bound,\n+           // and only one is supported\n+    E0204, // trait `Copy` may not be implemented for this type; field\n+           // does not implement `Copy`\n+    E0205, // trait `Copy` may not be implemented for this type; variant\n+           // does not implement `copy`\n+    E0206, // trait `Copy` may not be implemented for this type; type is\n+           // not a structure or enumeration\n+    E0207, // type parameter is not constrained by the impl trait, self type, or predicate\n+    E0208,\n+    E0209, // builtin traits can only be implemented on structs or enums\n+    E0210, // type parameter is not constrained by any local type\n+    E0211,\n+    E0212, // cannot extract an associated type from a higher-ranked trait bound\n+    E0213, // associated types are not accepted in this context\n+    E0214, // parenthesized parameters may only be used with a trait\n+    E0215, // angle-bracket notation is not stable with `Fn`\n+    E0216, // parenthetical notation is only stable with `Fn`\n+    E0217, // ambiguous associated type, defined in multiple supertraits\n+    E0218, // no associated type defined\n+    E0219, // associated type defined in higher-ranked supertrait\n+    E0220, // associated type not found for type parameter\n+    E0221, // ambiguous associated type in bounds\n+    E0222, // variadic function must have C calling convention\n+    E0223, // ambiguous associated type\n+    E0224, // at least one non-builtin train is required for an object type\n+    E0225, // only the builtin traits can be used as closure or object bounds\n+    E0226, // only a single explicit lifetime bound is permitted\n+    E0227, // ambiguous lifetime bound, explicit lifetime bound required\n+    E0228, // explicit lifetime bound required\n+    E0229, // associated type bindings are not allowed here\n+    E0230, // there is no type parameter on trait\n+    E0231, // only named substitution parameters are allowed\n+    E0232, // this attribute must have a value\n+    E0233,\n+    E0234, // `for` loop expression has type which does not implement the `Iterator` trait\n+    E0235, // structure constructor specifies a structure of type but\n+    E0236, // no lang item for range syntax\n+    E0237, // no lang item for range syntax\n+    E0238, // parenthesized parameters may only be used with a trait\n+    E0239  // `next` method of `Iterator` trait has unexpected type\n }\n \n __build_diagnostic_array! { DIAGNOSTICS }"}, {"sha": "aa99549bcd645cb8bfcd7ee2defd72d007f1c40f", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c5225c5bf31dcca141c36ce1b5850ff2df79b9c/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5225c5bf31dcca141c36ce1b5850ff2df79b9c/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=0c5225c5bf31dcca141c36ce1b5850ff2df79b9c", "patch": "@@ -206,11 +206,11 @@ fn require_same_types<'a, 'tcx, M>(tcx: &ty::ctxt<'tcx>,\n     match result {\n         Ok(_) => true,\n         Err(ref terr) => {\n-            tcx.sess.span_err(span,\n-                              &format!(\"{}: {}\",\n+            span_err!(tcx.sess, span, E0211,\n+                              \"{}: {}\",\n                                       msg(),\n                                       ty::type_err_to_str(tcx,\n-                                                          terr))[]);\n+                                                          terr));\n             ty::note_and_explain_type_err(tcx, terr);\n             false\n         }"}, {"sha": "3df3e1bddc5b74364d7990030b4e54ba4759556a", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c5225c5bf31dcca141c36ce1b5850ff2df79b9c/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5225c5bf31dcca141c36ce1b5850ff2df79b9c/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=0c5225c5bf31dcca141c36ce1b5850ff2df79b9c", "patch": "@@ -1055,7 +1055,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n             // attribute and report an error with various results if found.\n             if ty::has_attr(tcx, item_def_id, \"rustc_variance\") {\n                 let found = item_variances.repr(tcx);\n-                tcx.sess.span_err(tcx.map.span(item_id), &found[]);\n+                span_err!(tcx.sess, tcx.map.span(item_id), E0208, \"{}\", &found[]);\n             }\n \n             let newly_added = tcx.item_variance_map.borrow_mut()"}]}