{"sha": "87358728a49034f34ec44c93306c396145d6e77d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3MzU4NzI4YTQ5MDM0ZjM0ZWM0NGM5MzMwNmMzOTYxNDVkNmU3N2Q=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-11-10T01:54:17Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-11-11T03:18:06Z"}, "message": "Remove the mirroring for patterns and just convert them eagerly; then,\npass around references instead of boxed values to save on clone costs.", "tree": {"sha": "9b8bdacecd5242a4fa8b767a686f09a6cfda5c5e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b8bdacecd5242a4fa8b767a686f09a6cfda5c5e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87358728a49034f34ec44c93306c396145d6e77d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87358728a49034f34ec44c93306c396145d6e77d", "html_url": "https://github.com/rust-lang/rust/commit/87358728a49034f34ec44c93306c396145d6e77d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87358728a49034f34ec44c93306c396145d6e77d/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad3bd1b46d52ccb339a09558064b9bf687c47a75", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad3bd1b46d52ccb339a09558064b9bf687c47a75", "html_url": "https://github.com/rust-lang/rust/commit/ad3bd1b46d52ccb339a09558064b9bf687c47a75"}], "stats": {"total": 632, "additions": 287, "deletions": 345}, "files": [{"sha": "ff4e440205a1cfac955a44f60f4b9ee67e2f7706", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 39, "deletions": 40, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/87358728a49034f34ec44c93306c396145d6e77d/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87358728a49034f34ec44c93306c396145d6e77d/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=87358728a49034f34ec44c93306c396145d6e77d", "patch": "@@ -44,7 +44,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         // be unreachable or reachable multiple times.\n         let var_extent = self.extent_of_innermost_scope().unwrap();\n         for arm in &arms {\n-            self.declare_bindings(var_extent, arm.patterns[0].clone());\n+            self.declare_bindings(var_extent, &arm.patterns[0]);\n         }\n \n         let mut arm_blocks = ArmBlocks {\n@@ -64,18 +64,18 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         // highest priority candidate comes last in the list. This the\n         // reverse of the order in which candidates are written in the\n         // source.\n-        let candidates: Vec<Candidate<'tcx>> =\n+        let candidates: Vec<_> =\n             arms.iter()\n                 .enumerate()\n                 .rev() // highest priority comes last\n                 .flat_map(|(arm_index, arm)| {\n                     arm.patterns.iter()\n                                 .rev()\n-                                .map(move |pat| (arm_index, pat.clone(), arm.guard.clone()))\n+                                .map(move |pat| (arm_index, pat, arm.guard.clone()))\n                 })\n                 .map(|(arm_index, pattern, guard)| {\n                     Candidate {\n-                        match_pairs: vec![self.match_pair(discriminant_lvalue.clone(), pattern)],\n+                        match_pairs: vec![MatchPair::new(discriminant_lvalue.clone(), pattern)],\n                         bindings: vec![],\n                         guard: guard,\n                         arm_index: arm_index,\n@@ -102,12 +102,11 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     pub fn expr_into_pattern(&mut self,\n                              mut block: BasicBlock,\n                              var_extent: CodeExtent, // lifetime of vars\n-                             irrefutable_pat: PatternRef<'tcx>,\n+                             irrefutable_pat: Pattern<'tcx>,\n                              initializer: ExprRef<'tcx>)\n                              -> BlockAnd<()> {\n         // optimize the case of `let x = ...`\n-        let irrefutable_pat = self.hir.mirror(irrefutable_pat);\n-        match irrefutable_pat.kind {\n+        match *irrefutable_pat.kind {\n             PatternKind::Binding { mutability,\n                                    name,\n                                    mode: BindingMode::ByValue,\n@@ -128,22 +127,22 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         let lvalue = unpack!(block = self.as_lvalue(block, initializer));\n         self.lvalue_into_pattern(block,\n                                  var_extent,\n-                                 PatternRef::Mirror(Box::new(irrefutable_pat)),\n+                                 irrefutable_pat,\n                                  &lvalue)\n     }\n \n     pub fn lvalue_into_pattern(&mut self,\n                                mut block: BasicBlock,\n                                var_extent: CodeExtent,\n-                               irrefutable_pat: PatternRef<'tcx>,\n+                               irrefutable_pat: Pattern<'tcx>,\n                                initializer: &Lvalue<'tcx>)\n                                -> BlockAnd<()> {\n         // first, creating the bindings\n-        self.declare_bindings(var_extent, irrefutable_pat.clone());\n+        self.declare_bindings(var_extent, &irrefutable_pat);\n \n         // create a dummy candidate\n-        let mut candidate = Candidate::<'tcx> {\n-            match_pairs: vec![self.match_pair(initializer.clone(), irrefutable_pat.clone())],\n+        let mut candidate = Candidate {\n+            match_pairs: vec![MatchPair::new(initializer.clone(), &irrefutable_pat)],\n             bindings: vec![],\n             guard: None,\n             arm_index: 0, // since we don't call `match_candidates`, this field is unused\n@@ -166,29 +165,29 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         block.unit()\n     }\n \n-    pub fn declare_bindings(&mut self, var_extent: CodeExtent, pattern: PatternRef<'tcx>) {\n-        let pattern = self.hir.mirror(pattern);\n-        match pattern.kind {\n-            PatternKind::Binding { mutability, name, mode: _, var, ty, subpattern } => {\n+    pub fn declare_bindings(&mut self, var_extent: CodeExtent, pattern: &Pattern<'tcx>) {\n+        match *pattern.kind {\n+            PatternKind::Binding { mutability, name, mode: _, var, ty, ref subpattern } => {\n                 self.declare_binding(var_extent, mutability, name, var, ty, pattern.span);\n-                if let Some(subpattern) = subpattern {\n+                if let Some(subpattern) = subpattern.as_ref() {\n                     self.declare_bindings(var_extent, subpattern);\n                 }\n             }\n-            PatternKind::Array { prefix, slice, suffix } |\n-            PatternKind::Slice { prefix, slice, suffix } => {\n-                for subpattern in prefix.into_iter().chain(slice).chain(suffix) {\n+            PatternKind::Array { ref prefix, ref slice, ref suffix } |\n+            PatternKind::Slice { ref prefix, ref slice, ref suffix } => {\n+                for subpattern in prefix.iter().chain(slice).chain(suffix) {\n                     self.declare_bindings(var_extent, subpattern);\n                 }\n             }\n-            PatternKind::Constant { .. } | PatternKind::Range { .. } | PatternKind::Wild => {}\n-            PatternKind::Deref { subpattern } => {\n+            PatternKind::Constant { .. } | PatternKind::Range { .. } | PatternKind::Wild => {\n+            }\n+            PatternKind::Deref { ref subpattern } => {\n                 self.declare_bindings(var_extent, subpattern);\n             }\n-            PatternKind::Leaf { subpatterns } |\n-            PatternKind::Variant { subpatterns, .. } => {\n+            PatternKind::Leaf { ref subpatterns } |\n+            PatternKind::Variant { ref subpatterns, .. } => {\n                 for subpattern in subpatterns {\n-                    self.declare_bindings(var_extent, subpattern.pattern);\n+                    self.declare_bindings(var_extent, &subpattern.pattern);\n                 }\n             }\n         }\n@@ -202,9 +201,9 @@ struct ArmBlocks {\n }\n \n #[derive(Clone, Debug)]\n-struct Candidate<'tcx> {\n+struct Candidate<'pat, 'tcx:'pat> {\n     // all of these must be satisfied...\n-    match_pairs: Vec<MatchPair<'tcx>>,\n+    match_pairs: Vec<MatchPair<'pat, 'tcx>>,\n \n     // ...these bindings established...\n     bindings: Vec<Binding<'tcx>>,\n@@ -228,12 +227,12 @@ struct Binding<'tcx> {\n }\n \n #[derive(Clone, Debug)]\n-struct MatchPair<'tcx> {\n+struct MatchPair<'pat, 'tcx:'pat> {\n     // this lvalue...\n     lvalue: Lvalue<'tcx>,\n \n     // ... must match this pattern.\n-    pattern: Pattern<'tcx>,\n+    pattern: &'pat Pattern<'tcx>,\n }\n \n #[derive(Clone, Debug, PartialEq)]\n@@ -280,11 +279,11 @@ struct Test<'tcx> {\n // Main matching algorithm\n \n impl<'a,'tcx> Builder<'a,'tcx> {\n-    fn match_candidates(&mut self,\n-                        span: Span,\n-                        arm_blocks: &mut ArmBlocks,\n-                        mut candidates: Vec<Candidate<'tcx>>,\n-                        mut block: BasicBlock)\n+    fn match_candidates<'pat>(&mut self,\n+                              span: Span,\n+                              arm_blocks: &mut ArmBlocks,\n+                              mut candidates: Vec<Candidate<'pat, 'tcx>>,\n+                              mut block: BasicBlock)\n     {\n         debug!(\"matched_candidate(span={:?}, block={:?}, candidates={:?})\",\n                span, block, candidates);\n@@ -347,7 +346,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         let target_blocks = self.perform_test(block, &match_pair.lvalue, &test);\n \n         for (outcome, target_block) in target_blocks.into_iter().enumerate() {\n-            let applicable_candidates: Vec<Candidate<'tcx>> =\n+            let applicable_candidates: Vec<_> =\n                 candidates.iter()\n                           .filter_map(|candidate| {\n                               self.candidate_under_assumption(&match_pair.lvalue,\n@@ -372,11 +371,11 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     /// bindings, further tests would be a use-after-move (which would\n     /// in turn be detected by the borrowck code that runs on the\n     /// MIR).\n-    fn bind_and_guard_matched_candidate(&mut self,\n-                                        mut block: BasicBlock,\n-                                        arm_blocks: &mut ArmBlocks,\n-                                        candidate: Candidate<'tcx>)\n-                                        -> Option<BasicBlock> {\n+    fn bind_and_guard_matched_candidate<'pat>(&mut self,\n+                                              mut block: BasicBlock,\n+                                              arm_blocks: &mut ArmBlocks,\n+                                              candidate: Candidate<'pat, 'tcx>)\n+                                              -> Option<BasicBlock> {\n         debug!(\"bind_and_guard_matched_candidate(block={:?}, candidate={:?})\",\n                block, candidate);\n "}, {"sha": "e69a04322c201bd40f21b4f321652f3d1700d668", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/87358728a49034f34ec44c93306c396145d6e77d/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87358728a49034f34ec44c93306c396145d6e77d/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=87358728a49034f34ec44c93306c396145d6e77d", "patch": "@@ -30,10 +30,10 @@ use repr::*;\n use std::mem;\n \n impl<'a,'tcx> Builder<'a,'tcx> {\n-    pub fn simplify_candidate(&mut self,\n-                              mut block: BasicBlock,\n-                              candidate: &mut Candidate<'tcx>)\n-                              -> BlockAnd<()> {\n+    pub fn simplify_candidate<'pat>(&mut self,\n+                                    mut block: BasicBlock,\n+                                    candidate: &mut Candidate<'pat, 'tcx>)\n+                                    -> BlockAnd<()> {\n         // repeatedly simplify match pairs until fixed point is reached\n         loop {\n             let match_pairs = mem::replace(&mut candidate.match_pairs, vec![]);\n@@ -60,18 +60,18 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     /// have been pushed into the candidate. If no simplification is\n     /// possible, Err is returned and no changes are made to\n     /// candidate.\n-    fn simplify_match_pair(&mut self,\n-                           mut block: BasicBlock,\n-                           match_pair: MatchPair<'tcx>,\n-                           candidate: &mut Candidate<'tcx>)\n-                           -> Result<BasicBlock, MatchPair<'tcx>> {\n-        match match_pair.pattern.kind {\n+    fn simplify_match_pair<'pat>(&mut self,\n+                                 mut block: BasicBlock,\n+                                 match_pair: MatchPair<'pat, 'tcx>,\n+                                 candidate: &mut Candidate<'pat, 'tcx>)\n+                                 -> Result<BasicBlock, MatchPair<'pat, 'tcx>> {\n+        match *match_pair.pattern.kind {\n             PatternKind::Wild(..) => {\n                 // nothing left to do\n                 Ok(block)\n             }\n \n-            PatternKind::Binding { name, mutability, mode, var, ty, subpattern } => {\n+            PatternKind::Binding { name, mutability, mode, var, ty, ref subpattern } => {\n                 candidate.bindings.push(Binding {\n                     name: name,\n                     mutability: mutability,\n@@ -82,9 +82,8 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                     binding_mode: mode,\n                 });\n \n-                if let Some(subpattern) = subpattern {\n+                if let Some(subpattern) = subpattern.as_ref() {\n                     // this is the `x @ P` case; have to keep matching against `P` now\n-                    let subpattern = self.hir.mirror(subpattern);\n                     candidate.match_pairs.push(MatchPair::new(match_pair.lvalue, subpattern));\n                 }\n \n@@ -96,12 +95,12 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 Err(match_pair)\n             }\n \n-            PatternKind::Array { prefix, slice, suffix } => {\n+            PatternKind::Array { ref prefix, ref slice, ref suffix } => {\n                 unpack!(block = self.prefix_suffix_slice(&mut candidate.match_pairs,\n                                                          block,\n                                                          match_pair.lvalue.clone(),\n                                                          prefix,\n-                                                         slice,\n+                                                         slice.as_ref(),\n                                                          suffix));\n                 Ok(block)\n             }\n@@ -113,16 +112,15 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 Err(match_pair)\n             }\n \n-            PatternKind::Leaf { subpatterns } => {\n+            PatternKind::Leaf { ref subpatterns } => {\n                 // tuple struct, match subpats (if any)\n                 candidate.match_pairs\n                          .extend(self.field_match_pairs(match_pair.lvalue, subpatterns));\n                 Ok(block)\n             }\n \n-            PatternKind::Deref { subpattern } => {\n+            PatternKind::Deref { ref subpattern } => {\n                 let lvalue = match_pair.lvalue.deref();\n-                let subpattern = self.hir.mirror(subpattern);\n                 candidate.match_pairs.push(MatchPair::new(lvalue, subpattern));\n                 Ok(block)\n             }"}, {"sha": "70d70bade21c7cd6e259e00ba98e00418440191e", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/87358728a49034f34ec44c93306c396145d6e77d/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87358728a49034f34ec44c93306c396145d6e77d/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=87358728a49034f34ec44c93306c396145d6e77d", "patch": "@@ -28,8 +28,8 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     /// Identifies what test is needed to decide if `match_pair` is applicable.\n     ///\n     /// It is a bug to call this with a simplifyable pattern.\n-    pub fn test(&mut self, match_pair: &MatchPair<'tcx>) -> Test<'tcx> {\n-        match match_pair.pattern.kind {\n+    pub fn test<'pat>(&mut self, match_pair: &MatchPair<'pat, 'tcx>) -> Test<'tcx> {\n+        match *match_pair.pattern.kind {\n             PatternKind::Variant { ref adt_def, variant_index: _, subpatterns: _ } => {\n                 Test {\n                     span: match_pair.pattern.span,\n@@ -99,19 +99,19 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         }\n     }\n \n-    pub fn add_cases_to_switch(&mut self,\n-                               test_lvalue: &Lvalue<'tcx>,\n-                               candidate: &Candidate<'tcx>,\n-                               switch_ty: Ty<'tcx>,\n-                               options: &mut Vec<ConstVal>,\n-                               indices: &mut FnvHashMap<ConstVal, usize>)\n+    pub fn add_cases_to_switch<'pat>(&mut self,\n+                                     test_lvalue: &Lvalue<'tcx>,\n+                                     candidate: &Candidate<'pat, 'tcx>,\n+                                     switch_ty: Ty<'tcx>,\n+                                     options: &mut Vec<ConstVal>,\n+                                     indices: &mut FnvHashMap<ConstVal, usize>)\n     {\n         let match_pair = match candidate.match_pairs.iter().find(|mp| mp.lvalue == *test_lvalue) {\n             Some(match_pair) => match_pair,\n             _ => { return; }\n         };\n \n-        match match_pair.pattern.kind {\n+        match *match_pair.pattern.kind {\n             PatternKind::Constant { value: Literal::Value { ref value } } => {\n                 // if the lvalues match, the type should match\n                 assert_eq!(match_pair.pattern.ty, switch_ty);\n@@ -282,12 +282,12 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     /// parameter), we would return `None`. But if the test_outcome\n     /// were `Ok`, we would return `Some([x.0.downcast<Ok>.0 @ P1, x.1\n     /// @ 22])`.\n-    pub fn candidate_under_assumption(&mut self,\n-                                      test_lvalue: &Lvalue<'tcx>,\n-                                      test_kind: &TestKind<'tcx>,\n-                                      test_outcome: usize,\n-                                      candidate: &Candidate<'tcx>)\n-                                      -> Option<Candidate<'tcx>> {\n+    pub fn candidate_under_assumption<'pat>(&mut self,\n+                                            test_lvalue: &Lvalue<'tcx>,\n+                                            test_kind: &TestKind<'tcx>,\n+                                            test_outcome: usize,\n+                                            candidate: &Candidate<'pat, 'tcx>)\n+                                            -> Option<Candidate<'pat, 'tcx>> {\n         let candidate = candidate.clone();\n         let match_pairs = candidate.match_pairs;\n         let result = self.match_pairs_under_assumption(test_lvalue,\n@@ -302,12 +302,12 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n \n     /// Helper for candidate_under_assumption that does the actual\n     /// work of transforming the list of match pairs.\n-    fn match_pairs_under_assumption(&mut self,\n-                                    test_lvalue: &Lvalue<'tcx>,\n-                                    test_kind: &TestKind<'tcx>,\n-                                    test_outcome: usize,\n-                                    match_pairs: Vec<MatchPair<'tcx>>)\n-                                    -> Option<Vec<MatchPair<'tcx>>> {\n+    fn match_pairs_under_assumption<'pat>(&mut self,\n+                                          test_lvalue: &Lvalue<'tcx>,\n+                                          test_kind: &TestKind<'tcx>,\n+                                          test_outcome: usize,\n+                                          match_pairs: Vec<MatchPair<'pat, 'tcx>>)\n+                                          -> Option<Vec<MatchPair<'pat, 'tcx>>> {\n         let mut result = vec![];\n \n         for match_pair in match_pairs {\n@@ -357,12 +357,12 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     /// the discriminant equals 4, and we find that it does not,\n     /// but the `match_pair` is testing if the discriminant equals 5,\n     /// that does not help us.\n-    fn test_informs_match_pair(&mut self,\n-                               match_pair: &MatchPair<'tcx>,\n-                               test_kind: &TestKind<'tcx>,\n-                               _test_outcome: usize)\n-                               -> bool {\n-        match match_pair.pattern.kind {\n+    fn test_informs_match_pair<'pat>(&mut self,\n+                                     match_pair: &MatchPair<'pat, 'tcx>,\n+                                     test_kind: &TestKind<'tcx>,\n+                                     _test_outcome: usize)\n+                                     -> bool {\n+        match *match_pair.pattern.kind {\n             PatternKind::Variant { .. } => {\n                 match *test_kind {\n                     TestKind::Switch { .. } => true,\n@@ -444,13 +444,13 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     /// On the second arm, a `None` will be returned, because if we\n     /// observed that `option` has the discriminant `Ok`, then the\n     /// second arm cannot apply.\n-    pub fn consequent_match_pairs_under_assumption(&mut self,\n-                                                   match_pair: MatchPair<'tcx>,\n-                                                   test_kind: &TestKind<'tcx>,\n-                                                   test_outcome: usize)\n-                                                   -> Option<Vec<MatchPair<'tcx>>> {\n-        match match_pair.pattern.kind {\n-            PatternKind::Variant { adt_def, variant_index, subpatterns } => {\n+    pub fn consequent_match_pairs_under_assumption<'pat>(&mut self,\n+                                                         match_pair: MatchPair<'pat, 'tcx>,\n+                                                         test_kind: &TestKind<'tcx>,\n+                                                         test_outcome: usize)\n+                                                         -> Option<Vec<MatchPair<'pat, 'tcx>>> {\n+        match *match_pair.pattern.kind {\n+            PatternKind::Variant { adt_def, variant_index, ref subpatterns } => {\n                 assert!(match *test_kind { TestKind::Switch { .. } => true,\n                                            _ => false });\n \n@@ -464,12 +464,12 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 let elem = ProjectionElem::Downcast(adt_def, variant_index);\n                 let downcast_lvalue = match_pair.lvalue.clone().elem(elem);\n                 let consequent_match_pairs =\n-                    subpatterns.into_iter()\n+                    subpatterns.iter()\n                                .map(|subpattern| {\n                                    let lvalue =\n                                        downcast_lvalue.clone().field(\n                                            subpattern.field);\n-                                   self.match_pair(lvalue, subpattern.pattern)\n+                                   MatchPair::new(lvalue, &subpattern.pattern)\n                                })\n                                .collect();\n                 Some(consequent_match_pairs)\n@@ -516,7 +516,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         }\n     }\n \n-    fn error_simplifyable(&mut self, match_pair: &MatchPair<'tcx>) -> ! {\n+    fn error_simplifyable<'pat>(&mut self, match_pair: &MatchPair<'pat, 'tcx>) -> ! {\n         self.hir.span_bug(match_pair.pattern.span,\n                           &format!(\"simplifyable pattern found: {:?}\", match_pair.pattern))\n     }"}, {"sha": "18dde5537da4dc40c944035f541229d0761ade6c", "filename": "src/librustc_mir/build/matches/util.rs", "status": "modified", "additions": 25, "deletions": 34, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/87358728a49034f34ec44c93306c396145d6e77d/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87358728a49034f34ec44c93306c396145d6e77d/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs?ref=87358728a49034f34ec44c93306c396145d6e77d", "patch": "@@ -15,26 +15,18 @@ use repr::*;\n use std::u32;\n \n impl<'a,'tcx> Builder<'a,'tcx> {\n-    pub fn field_match_pairs(&mut self,\n-                             lvalue: Lvalue<'tcx>,\n-                             subpatterns: Vec<FieldPatternRef<'tcx>>)\n-                             -> Vec<MatchPair<'tcx>> {\n-        subpatterns.into_iter()\n+    pub fn field_match_pairs<'pat>(&mut self,\n+                                   lvalue: Lvalue<'tcx>,\n+                                   subpatterns: &'pat [FieldPattern<'tcx>])\n+                                   -> Vec<MatchPair<'pat, 'tcx>> {\n+        subpatterns.iter()\n                    .map(|fieldpat| {\n                        let lvalue = lvalue.clone().field(fieldpat.field);\n-                       self.match_pair(lvalue, fieldpat.pattern)\n+                       MatchPair::new(lvalue, &fieldpat.pattern)\n                    })\n                    .collect()\n     }\n \n-    pub fn match_pair(&mut self,\n-                      lvalue: Lvalue<'tcx>,\n-                      pattern: PatternRef<'tcx>)\n-                      -> MatchPair<'tcx> {\n-        let pattern = self.hir.mirror(pattern);\n-        MatchPair::new(lvalue, pattern)\n-    }\n-\n     /// When processing an array/slice pattern like `lv @ [x, y, ..s, z]`,\n     /// this function converts the prefix (`x`, `y`) and suffix (`z`) into\n     /// distinct match pairs:\n@@ -49,18 +41,17 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     ///     tmp0 = lv[2..-1] // using the special Rvalue::Slice\n     ///\n     /// and creates a match pair `tmp0 @ s`\n-    pub fn prefix_suffix_slice(&mut self,\n-                               match_pairs: &mut Vec<MatchPair<'tcx>>,\n-                               block: BasicBlock,\n-                               lvalue: Lvalue<'tcx>,\n-                               prefix: Vec<PatternRef<'tcx>>,\n-                               opt_slice: Option<PatternRef<'tcx>>,\n-                               suffix: Vec<PatternRef<'tcx>>)\n-                               -> BlockAnd<()> {\n+    pub fn prefix_suffix_slice<'pat>(&mut self,\n+                                     match_pairs: &mut Vec<MatchPair<'pat, 'tcx>>,\n+                                     block: BasicBlock,\n+                                     lvalue: Lvalue<'tcx>,\n+                                     prefix: &'pat [Pattern<'tcx>],\n+                                     opt_slice: Option<&'pat Pattern<'tcx>>,\n+                                     suffix: &'pat [Pattern<'tcx>])\n+                                     -> BlockAnd<()> {\n         // If there is a `..P` pattern, create a temporary `t0` for\n         // the slice and then a match pair `t0 @ P`:\n         if let Some(slice) = opt_slice {\n-            let slice = self.hir.mirror(slice);\n             let prefix_len = prefix.len();\n             let suffix_len = suffix.len();\n             let rvalue = Rvalue::Slice {\n@@ -79,17 +70,17 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     }\n \n     /// Helper for `prefix_suffix_slice` which just processes the prefix and suffix.\n-    fn prefix_suffix(&mut self,\n-                     match_pairs: &mut Vec<MatchPair<'tcx>>,\n-                     lvalue: Lvalue<'tcx>,\n-                     prefix: Vec<PatternRef<'tcx>>,\n-                     suffix: Vec<PatternRef<'tcx>>) {\n+    fn prefix_suffix<'pat>(&mut self,\n+                           match_pairs: &mut Vec<MatchPair<'pat, 'tcx>>,\n+                           lvalue: Lvalue<'tcx>,\n+                           prefix: &'pat [Pattern<'tcx>],\n+                           suffix: &'pat [Pattern<'tcx>]) {\n         let min_length = prefix.len() + suffix.len();\n         assert!(min_length < u32::MAX as usize);\n         let min_length = min_length as u32;\n \n         let prefix_pairs: Vec<_> =\n-            prefix.into_iter()\n+            prefix.iter()\n                   .enumerate()\n                   .map(|(idx, subpattern)| {\n                       let elem = ProjectionElem::ConstantIndex {\n@@ -98,12 +89,12 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                           from_end: false,\n                       };\n                       let lvalue = lvalue.clone().elem(elem);\n-                      self.match_pair(lvalue, subpattern)\n+                      MatchPair::new(lvalue, subpattern)\n                   })\n                   .collect();\n \n         let suffix_pairs: Vec<_> =\n-            suffix.into_iter()\n+            suffix.iter()\n                   .rev()\n                   .enumerate()\n                   .map(|(idx, subpattern)| {\n@@ -113,16 +104,16 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                           from_end: true,\n                       };\n                       let lvalue = lvalue.clone().elem(elem);\n-                      self.match_pair(lvalue, subpattern)\n+                      MatchPair::new(lvalue, subpattern)\n                   })\n                   .collect();\n \n         match_pairs.extend(prefix_pairs.into_iter().chain(suffix_pairs));\n     }\n }\n \n-impl<'tcx> MatchPair<'tcx> {\n-    pub fn new(lvalue: Lvalue<'tcx>, pattern: Pattern<'tcx>) -> MatchPair<'tcx> {\n+impl<'pat, 'tcx> MatchPair<'pat, 'tcx> {\n+    pub fn new(lvalue: Lvalue<'tcx>, pattern: &'pat Pattern<'tcx>) -> MatchPair<'pat, 'tcx> {\n         MatchPair {\n             lvalue: lvalue,\n             pattern: pattern,"}, {"sha": "eb03727d9b2c02afa81d1012df73e4da80cca56f", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/87358728a49034f34ec44c93306c396145d6e77d/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87358728a49034f34ec44c93306c396145d6e77d/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=87358728a49034f34ec44c93306c396145d6e77d", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use hair;\n-use hair::cx::{Cx, PatNode};\n+use hair::cx::Cx;\n use rustc::middle::region::CodeExtent;\n use rustc::middle::ty::{FnOutput, Ty};\n use rustc_data_structures::fnv::FnvHashMap;\n@@ -78,7 +77,7 @@ macro_rules! unpack {\n pub fn construct<'a,'tcx>(mut hir: Cx<'a,'tcx>,\n                           _span: Span,\n                           implicit_arguments: Vec<Ty<'tcx>>,\n-                          explicit_arguments: Vec<(Ty<'tcx>, PatNode<'tcx>)>,\n+                          explicit_arguments: Vec<(Ty<'tcx>, &'tcx hir::Pat)>,\n                           argument_extent: CodeExtent,\n                           return_ty: FnOutput<'tcx>,\n                           ast_block: &'tcx hir::Block)\n@@ -130,7 +129,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     fn args_and_body(&mut self,\n                      mut block: BasicBlock,\n                      implicit_arguments: Vec<Ty<'tcx>>,\n-                     explicit_arguments: Vec<(Ty<'tcx>, PatNode<'tcx>)>,\n+                     explicit_arguments: Vec<(Ty<'tcx>, &'tcx hir::Pat)>,\n                      argument_extent: CodeExtent,\n                      ast_block: &'tcx hir::Block)\n                      -> BlockAnd<Vec<ArgDecl<'tcx>>>\n@@ -148,9 +147,10 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                     .enumerate()\n                     .map(|(index, (ty, pattern))| {\n                         let lvalue = Lvalue::Arg(index as u32);\n+                        let pattern = this.hir.irrefutable_pat(pattern);\n                         unpack!(block = this.lvalue_into_pattern(block,\n                                                                  argument_extent,\n-                                                                 hair::PatternRef::Hair(pattern),\n+                                                                 pattern,\n                                                                  &lvalue));\n                         ArgDecl { ty: ty }\n                     });"}, {"sha": "0c0816a2d9d28001ca927e7a739eb554e3f548e3", "filename": "src/librustc_mir/build/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87358728a49034f34ec44c93306c396145d6e77d/src%2Flibrustc_mir%2Fbuild%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87358728a49034f34ec44c93306c396145d6e77d/src%2Flibrustc_mir%2Fbuild%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fstmt.rs?ref=87358728a49034f34ec44c93306c396145d6e77d", "patch": "@@ -40,7 +40,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n             StmtKind::Let { remainder_scope, init_scope, pattern, initializer: None, stmts } => {\n                 this.in_scope(remainder_scope, block, |this| {\n                     unpack!(block = this.in_scope(init_scope, block, |this| {\n-                        this.declare_bindings(remainder_scope, pattern);\n+                        this.declare_bindings(remainder_scope, &pattern);\n                         block.unit()\n                     }));\n                     this.stmts(block, stmts)"}, {"sha": "bedcefe3b0dac2171116e17582ab99a07ebd930c", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/87358728a49034f34ec44c93306c396145d6e77d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87358728a49034f34ec44c93306c396145d6e77d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=87358728a49034f34ec44c93306c396145d6e77d", "patch": "@@ -10,7 +10,6 @@\n \n use hair::*;\n use hair::cx::Cx;\n-use hair::cx::pattern::PatNode;\n use hair::cx::to_ref::ToRef;\n use rustc::middle::region::{BlockRemainder, CodeExtentData};\n use rustc_front::hir;\n@@ -65,12 +64,13 @@ fn mirror_stmts<'a,'tcx:'a,STMTS>(cx: &mut Cx<'a,'tcx>,\n                         // they are within the scope of this let:\n                         let following_stmts = mirror_stmts(cx, block_id, stmts);\n \n+                        let pattern = cx.irrefutable_pat(&local.pat);\n                         result.push(StmtRef::Mirror(Box::new(Stmt {\n                             span: stmt.span,\n                             kind: StmtKind::Let {\n                                 remainder_scope: remainder_extent,\n                                 init_scope: cx.tcx.region_maps.node_extent(id),\n-                                pattern: PatNode::irrefutable(&local.pat).to_ref(),\n+                                pattern: pattern,\n                                 initializer: local.init.to_ref(),\n                                 stmts: following_stmts,\n                             },"}, {"sha": "3fd895afa983e8e3a08a335a2b490d67eb0bb18d", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/87358728a49034f34ec44c93306c396145d6e77d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87358728a49034f34ec44c93306c396145d6e77d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=87358728a49034f34ec44c93306c396145d6e77d", "patch": "@@ -11,10 +11,8 @@\n use hair::*;\n use repr::*;\n use rustc_data_structures::fnv::FnvHashMap;\n-use std::rc::Rc;\n use hair::cx::Cx;\n use hair::cx::block;\n-use hair::cx::pattern::PatNode;\n use hair::cx::to_ref::ToRef;\n use rustc::front::map;\n use rustc::middle::const_eval;\n@@ -486,19 +484,20 @@ fn to_borrow_kind(m: hir::Mutability) -> BorrowKind {\n     }\n }\n \n-fn convert_arm<'a, 'tcx: 'a>(cx: &Cx<'a, 'tcx>, arm: &'tcx hir::Arm) -> Arm<'tcx> {\n-    let map = if arm.pats.len() == 1 {\n+fn convert_arm<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, arm: &'tcx hir::Arm) -> Arm<'tcx> {\n+    let mut map;\n+    let opt_map = if arm.pats.len() == 1 {\n         None\n     } else {\n-        let mut map = FnvHashMap();\n+        map = FnvHashMap();\n         pat_util::pat_bindings(&cx.tcx.def_map, &arm.pats[0], |_, p_id, _, path| {\n             map.insert(path.node, p_id);\n         });\n-        Some(Rc::new(map))\n+        Some(&map)\n     };\n \n     Arm {\n-        patterns: arm.pats.iter().map(|p| PatNode::new(p, map.clone()).to_ref()).collect(),\n+        patterns: arm.pats.iter().map(|p| cx.refutable_pat(opt_map, p)).collect(),\n         guard: arm.guard.to_ref(),\n         body: arm.body.to_ref(),\n     }"}, {"sha": "70a64a5653a3c8b6535ef50ce1909ac3b45b534a", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87358728a49034f34ec44c93306c396145d6e77d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87358728a49034f34ec44c93306c396145d6e77d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=87358728a49034f34ec44c93306c396145d6e77d", "patch": "@@ -41,8 +41,6 @@ impl<'a,'tcx> Cx<'a,'tcx> {\n     }\n }\n \n-pub use self::pattern::PatNode;\n-\n impl<'a,'tcx:'a> Cx<'a, 'tcx> {\n     /// Normalizes `ast` into the appropriate `mirror` type.\n     pub fn mirror<M: Mirror<'tcx>>(&mut self, ast: M) -> M::Output {"}, {"sha": "e9b58199023bf4c5229e54bac4e292ba1ae24f4e", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 138, "deletions": 139, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/87358728a49034f34ec44c93306c396145d6e77d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87358728a49034f34ec44c93306c396145d6e77d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=87358728a49034f34ec44c93306c396145d6e77d", "patch": "@@ -10,10 +10,8 @@\n \n use hair::*;\n use hair::cx::Cx;\n-use hair::cx::to_ref::ToRef;\n use repr::*;\n use rustc_data_structures::fnv::FnvHashMap;\n-use std::rc::Rc;\n use rustc::middle::const_eval;\n use rustc::middle::def;\n use rustc::middle::pat_util::{pat_is_resolved_const, pat_is_binding};\n@@ -36,183 +34,111 @@ use syntax::ptr::P;\n ///    _ => { ... }\n /// }\n /// ```\n-#[derive(Clone, Debug)]\n-pub struct PatNode<'tcx> {\n-    pat: &'tcx hir::Pat,\n-    binding_map: Option<Rc<FnvHashMap<ast::Name, ast::NodeId>>>,\n+struct PatCx<'patcx, 'cx: 'patcx, 'tcx: 'cx> {\n+    cx: &'patcx mut Cx<'cx, 'tcx>,\n+    binding_map: Option<&'patcx FnvHashMap<ast::Name, ast::NodeId>>,\n }\n \n-impl<'tcx> PatNode<'tcx> {\n-    pub fn new(pat: &'tcx hir::Pat,\n-               binding_map: Option<Rc<FnvHashMap<ast::Name, ast::NodeId>>>)\n-               -> PatNode<'tcx> {\n-        PatNode {\n-            pat: pat,\n-            binding_map: binding_map,\n-        }\n-    }\n-\n-    pub fn irrefutable(pat: &'tcx hir::Pat) -> PatNode<'tcx> {\n-        PatNode::new(pat, None)\n-    }\n-\n-    fn pat_ref<'a>(&self, pat: &'tcx hir::Pat) -> PatternRef<'tcx> {\n-        PatNode::new(pat, self.binding_map.clone()).to_ref()\n+impl<'cx, 'tcx> Cx<'cx, 'tcx> {\n+    pub fn irrefutable_pat(&mut self, pat: &'tcx hir::Pat) -> Pattern<'tcx> {\n+        PatCx::new(self, None).to_pat(pat)\n     }\n \n-    fn pat_refs<'a>(&self, pats: &'tcx Vec<P<hir::Pat>>) -> Vec<PatternRef<'tcx>> {\n-        pats.iter().map(|p| self.pat_ref(p)).collect()\n-    }\n-\n-    fn opt_pat_ref<'a>(&self, pat: &'tcx Option<P<hir::Pat>>) -> Option<PatternRef<'tcx>> {\n-        pat.as_ref().map(|p| self.pat_ref(p))\n-    }\n-\n-    fn slice_or_array_pattern<'a>(&self,\n-                                  cx: &mut Cx<'a, 'tcx>,\n-                                  ty: Ty<'tcx>,\n-                                  prefix: &'tcx Vec<P<hir::Pat>>,\n-                                  slice: &'tcx Option<P<hir::Pat>>,\n-                                  suffix: &'tcx Vec<P<hir::Pat>>)\n-                                  -> PatternKind<'tcx> {\n-        match ty.sty {\n-            ty::TySlice(..) =>\n-                // matching a slice or fixed-length array\n-                PatternKind::Slice {\n-                    prefix: self.pat_refs(prefix),\n-                    slice: self.opt_pat_ref(slice),\n-                    suffix: self.pat_refs(suffix),\n-                },\n-\n-            ty::TyArray(_, len) => {\n-                // fixed-length array\n-                assert!(len >= prefix.len() + suffix.len());\n-                PatternKind::Array {\n-                    prefix: self.pat_refs(prefix),\n-                    slice: self.opt_pat_ref(slice),\n-                    suffix: self.pat_refs(suffix),\n-                }\n-            }\n-\n-            _ => {\n-                cx.tcx.sess.span_bug(self.pat.span, \"unexpanded macro or bad constant etc\");\n-            }\n-        }\n+    pub fn refutable_pat(&mut self,\n+                         binding_map: Option<&FnvHashMap<ast::Name, ast::NodeId>>,\n+                         pat: &'tcx hir::Pat)\n+                         -> Pattern<'tcx> {\n+        PatCx::new(self, binding_map).to_pat(pat)\n     }\n+}\n \n-    fn variant_or_leaf<'a>(&self,\n-                           cx: &mut Cx<'a, 'tcx>,\n-                           subpatterns: Vec<FieldPatternRef<'tcx>>)\n-                           -> PatternKind<'tcx> {\n-        let def = cx.tcx.def_map.borrow().get(&self.pat.id).unwrap().full_def();\n-        match def {\n-            def::DefVariant(enum_id, variant_id, _) => {\n-                let adt_def = cx.tcx.lookup_adt_def(enum_id);\n-                if adt_def.variants.len() > 1 {\n-                    PatternKind::Variant {\n-                        adt_def: adt_def,\n-                        variant_index: adt_def.variant_index_with_id(variant_id),\n-                        subpatterns: subpatterns,\n-                    }\n-                } else {\n-                    PatternKind::Leaf { subpatterns: subpatterns }\n-                }\n-            }\n-\n-            // NB: resolving to DefStruct means the struct *constructor*,\n-            // not the struct as a type.\n-            def::DefStruct(..) | def::DefTy(..) => {\n-                PatternKind::Leaf { subpatterns: subpatterns }\n-            }\n-\n-            _ => {\n-                cx.tcx.sess.span_bug(self.pat.span,\n-                                     &format!(\"inappropriate def for pattern: {:?}\", def));\n-            }\n+impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n+    fn new(cx: &'patcx mut Cx<'cx, 'tcx>,\n+               binding_map: Option<&'patcx FnvHashMap<ast::Name, ast::NodeId>>)\n+               -> PatCx<'patcx, 'cx, 'tcx> {\n+        PatCx {\n+            cx: cx,\n+            binding_map: binding_map,\n         }\n     }\n-}\n \n-impl<'tcx> Mirror<'tcx> for PatNode<'tcx> {\n-    type Output = Pattern<'tcx>;\n-\n-    fn make_mirror<'a>(self, cx: &mut Cx<'a, 'tcx>) -> Pattern<'tcx> {\n-        let kind = match self.pat.node {\n+    fn to_pat(&mut self, pat: &'tcx hir::Pat) -> Pattern<'tcx> {\n+        let kind = match pat.node {\n             hir::PatWild => PatternKind::Wild,\n \n             hir::PatLit(ref value) => {\n-                let value = const_eval::eval_const_expr(cx.tcx, value);\n+                let value = const_eval::eval_const_expr(self.cx.tcx, value);\n                 let value = Literal::Value { value: value };\n                 PatternKind::Constant { value: value }\n             }\n \n             hir::PatRange(ref lo, ref hi) => {\n-                let lo = const_eval::eval_const_expr(cx.tcx, lo);\n+                let lo = const_eval::eval_const_expr(self.cx.tcx, lo);\n                 let lo = Literal::Value { value: lo };\n-                let hi = const_eval::eval_const_expr(cx.tcx, hi);\n+                let hi = const_eval::eval_const_expr(self.cx.tcx, hi);\n                 let hi = Literal::Value { value: hi };\n                 PatternKind::Range { lo: lo, hi: hi }\n             },\n \n             hir::PatEnum(..) | hir::PatIdent(..) | hir::PatQPath(..)\n-                if pat_is_resolved_const(&cx.tcx.def_map.borrow(), self.pat) =>\n+                if pat_is_resolved_const(&self.cx.tcx.def_map.borrow(), pat) =>\n             {\n-                let def = cx.tcx.def_map.borrow().get(&self.pat.id).unwrap().full_def();\n+                let def = self.cx.tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n                 match def {\n                     def::DefConst(def_id) | def::DefAssociatedConst(def_id) =>\n-                        match const_eval::lookup_const_by_id(cx.tcx, def_id, Some(self.pat.id)) {\n+                        match const_eval::lookup_const_by_id(self.cx.tcx, def_id, Some(pat.id)) {\n                             Some(const_expr) => {\n                                 let opt_value =\n                                     const_eval::eval_const_expr_partial(\n-                                        cx.tcx, const_expr,\n+                                        self.cx.tcx, const_expr,\n                                         const_eval::EvalHint::ExprTypeChecked,\n                                         None);\n                                 let literal = if let Ok(value) = opt_value {\n                                     Literal::Value { value: value }\n                                 } else {\n-                                    let substs = cx.tcx.mk_substs(Substs::empty());\n+                                    let substs = self.cx.tcx.mk_substs(Substs::empty());\n                                     Literal::Item { def_id: def_id, substs: substs }\n                                 };\n                                 PatternKind::Constant { value: literal }\n                             }\n                             None => {\n-                                cx.tcx.sess.span_bug(\n-                                    self.pat.span,\n+                                self.cx.tcx.sess.span_bug(\n+                                    pat.span,\n                                     &format!(\"cannot eval constant: {:?}\", def_id))\n                             }\n                         },\n                     _ =>\n-                        cx.tcx.sess.span_bug(\n-                            self.pat.span,\n+                        self.cx.tcx.sess.span_bug(\n+                            pat.span,\n                             &format!(\"def not a constant: {:?}\", def)),\n                 }\n             }\n \n             hir::PatRegion(ref subpattern, _) |\n             hir::PatBox(ref subpattern) => {\n-                PatternKind::Deref { subpattern: self.pat_ref(subpattern) }\n+                PatternKind::Deref { subpattern: self.to_pat(subpattern) }\n             }\n \n             hir::PatVec(ref prefix, ref slice, ref suffix) => {\n-                let ty = cx.tcx.node_id_to_type(self.pat.id);\n+                let ty = self.cx.tcx.node_id_to_type(pat.id);\n                 match ty.sty {\n                     ty::TyRef(_, mt) =>\n                         PatternKind::Deref {\n                             subpattern: Pattern {\n                                 ty: mt.ty,\n-                                span: self.pat.span,\n-                                kind: self.slice_or_array_pattern(cx, mt.ty, prefix,\n-                                                                  slice, suffix),\n-                            }.to_ref()\n+                                span: pat.span,\n+                                kind: Box::new(self.slice_or_array_pattern(pat, mt.ty, prefix,\n+                                                                           slice, suffix)),\n+                            },\n                         },\n \n                     ty::TySlice(..) |\n                     ty::TyArray(..) =>\n-                        self.slice_or_array_pattern(cx, ty, prefix, slice, suffix),\n+                        self.slice_or_array_pattern(pat, ty, prefix, slice, suffix),\n \n                     ref sty =>\n-                        cx.tcx.sess.span_bug(\n-                            self.pat.span,\n+                        self.cx.tcx.sess.span_bug(\n+                            pat.span,\n                             &format!(\"unexpanded type for vector pattern: {:?}\", sty)),\n                 }\n             }\n@@ -221,23 +147,23 @@ impl<'tcx> Mirror<'tcx> for PatNode<'tcx> {\n                 let subpatterns =\n                     subpatterns.iter()\n                                .enumerate()\n-                               .map(|(i, subpattern)| FieldPatternRef {\n+                               .map(|(i, subpattern)| FieldPattern {\n                                    field: Field::new(i),\n-                                   pattern: self.pat_ref(subpattern),\n+                                   pattern: self.to_pat(subpattern),\n                                })\n                                .collect();\n \n                 PatternKind::Leaf { subpatterns: subpatterns }\n             }\n \n             hir::PatIdent(bm, ref ident, ref sub)\n-                if pat_is_binding(&cx.tcx.def_map.borrow(), self.pat) =>\n+                if pat_is_binding(&self.cx.tcx.def_map.borrow(), pat) =>\n             {\n                 let id = match self.binding_map {\n-                    None => self.pat.id,\n+                    None => pat.id,\n                     Some(ref map) => map[&ident.node.name],\n                 };\n-                let var_ty = cx.tcx.node_id_to_type(self.pat.id);\n+                let var_ty = self.cx.tcx.node_id_to_type(pat.id);\n                 let region = match var_ty.sty {\n                     ty::TyRef(&r, _) => Some(r),\n                     _ => None,\n@@ -258,71 +184,144 @@ impl<'tcx> Mirror<'tcx> for PatNode<'tcx> {\n                     name: ident.node.name,\n                     var: id,\n                     ty: var_ty,\n-                    subpattern: self.opt_pat_ref(sub),\n+                    subpattern: self.to_opt_pat(sub),\n                 }\n             }\n \n             hir::PatIdent(..) => {\n-                self.variant_or_leaf(cx, vec![])\n+                self.variant_or_leaf(pat, vec![])\n             }\n \n             hir::PatEnum(_, ref opt_subpatterns) => {\n                 let subpatterns =\n                     opt_subpatterns.iter()\n                                    .flat_map(|v| v.iter())\n                                    .enumerate()\n-                                   .map(|(i, field)| FieldPatternRef {\n+                                   .map(|(i, field)| FieldPattern {\n                                        field: Field::new(i),\n-                                       pattern: self.pat_ref(field),\n+                                       pattern: self.to_pat(field),\n                                    })\n                                    .collect();\n-                self.variant_or_leaf(cx, subpatterns)\n+                self.variant_or_leaf(pat, subpatterns)\n             }\n \n             hir::PatStruct(_, ref fields, _) => {\n-                let pat_ty = cx.tcx.node_id_to_type(self.pat.id);\n+                let pat_ty = self.cx.tcx.node_id_to_type(pat.id);\n                 let adt_def = match pat_ty.sty {\n                     ty::TyStruct(adt_def, _) | ty::TyEnum(adt_def, _) => adt_def,\n                     _ => {\n-                        cx.tcx.sess.span_bug(\n-                            self.pat.span,\n+                        self.cx.tcx.sess.span_bug(\n+                            pat.span,\n                             \"struct pattern not applied to struct or enum\");\n                     }\n                 };\n \n-                let def = cx.tcx.def_map.borrow().get(&self.pat.id).unwrap().full_def();\n+                let def = self.cx.tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n                 let variant_def = adt_def.variant_of_def(def);\n \n                 let subpatterns =\n                     fields.iter()\n                           .map(|field| {\n                               let index = variant_def.index_of_field_named(field.node.name);\n                               let index = index.unwrap_or_else(|| {\n-                                  cx.tcx.sess.span_bug(\n-                                      self.pat.span,\n+                                  self.cx.tcx.sess.span_bug(\n+                                      pat.span,\n                                       &format!(\"no field with name {:?}\", field.node.name));\n                               });\n-                              FieldPatternRef {\n+                              FieldPattern {\n                                   field: Field::new(index),\n-                                  pattern: self.pat_ref(&field.node.pat),\n+                                  pattern: self.to_pat(&field.node.pat),\n                               }\n                           })\n                           .collect();\n \n-                self.variant_or_leaf(cx, subpatterns)\n+                self.variant_or_leaf(pat, subpatterns)\n             }\n \n             hir::PatQPath(..) => {\n-                cx.tcx.sess.span_bug(self.pat.span, \"unexpanded macro or bad constant etc\");\n+                self.cx.tcx.sess.span_bug(pat.span, \"unexpanded macro or bad constant etc\");\n             }\n         };\n \n-        let ty = cx.tcx.node_id_to_type(self.pat.id);\n+        let ty = self.cx.tcx.node_id_to_type(pat.id);\n \n         Pattern {\n-            span: self.pat.span,\n+            span: pat.span,\n             ty: ty,\n-            kind: kind,\n+            kind: Box::new(kind),\n+        }\n+    }\n+\n+    fn to_pats(&mut self, pats: &'tcx Vec<P<hir::Pat>>) -> Vec<Pattern<'tcx>> {\n+        pats.iter().map(|p| self.to_pat(p)).collect()\n+    }\n+\n+    fn to_opt_pat(&mut self, pat: &'tcx Option<P<hir::Pat>>) -> Option<Pattern<'tcx>> {\n+        pat.as_ref().map(|p| self.to_pat(p))\n+    }\n+\n+    fn slice_or_array_pattern(&mut self,\n+                              pat: &'tcx hir::Pat,\n+                              ty: Ty<'tcx>,\n+                              prefix: &'tcx Vec<P<hir::Pat>>,\n+                              slice: &'tcx Option<P<hir::Pat>>,\n+                              suffix: &'tcx Vec<P<hir::Pat>>)\n+                              -> PatternKind<'tcx> {\n+        match ty.sty {\n+            ty::TySlice(..) => {\n+                // matching a slice or fixed-length array\n+                PatternKind::Slice {\n+                    prefix: self.to_pats(prefix),\n+                    slice: self.to_opt_pat(slice),\n+                    suffix: self.to_pats(suffix),\n+                }\n+            }\n+\n+            ty::TyArray(_, len) => {\n+                // fixed-length array\n+                assert!(len >= prefix.len() + suffix.len());\n+                PatternKind::Array {\n+                    prefix: self.to_pats(prefix),\n+                    slice: self.to_opt_pat(slice),\n+                    suffix: self.to_pats(suffix),\n+                }\n+            }\n+\n+            _ => {\n+                self.cx.tcx.sess.span_bug(pat.span, \"unexpanded macro or bad constant etc\");\n+            }\n+        }\n+    }\n+\n+    fn variant_or_leaf(&mut self,\n+                       pat: &'tcx hir::Pat,\n+                       subpatterns: Vec<FieldPattern<'tcx>>)\n+                       -> PatternKind<'tcx> {\n+        let def = self.cx.tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n+        match def {\n+            def::DefVariant(enum_id, variant_id, _) => {\n+                let adt_def = self.cx.tcx.lookup_adt_def(enum_id);\n+                if adt_def.variants.len() > 1 {\n+                    PatternKind::Variant {\n+                        adt_def: adt_def,\n+                        variant_index: adt_def.variant_index_with_id(variant_id),\n+                        subpatterns: subpatterns,\n+                    }\n+                } else {\n+                    PatternKind::Leaf { subpatterns: subpatterns }\n+                }\n+            }\n+\n+            // NB: resolving to DefStruct means the struct *constructor*,\n+            // not the struct as a type.\n+            def::DefStruct(..) | def::DefTy(..) => {\n+                PatternKind::Leaf { subpatterns: subpatterns }\n+            }\n+\n+            _ => {\n+                self.cx.tcx.sess.span_bug(pat.span,\n+                                          &format!(\"inappropriate def for pattern: {:?}\", def));\n+            }\n         }\n     }\n }"}, {"sha": "da200a8a33f083616333f42641c4a77c9b96fe88", "filename": "src/librustc_mir/hair/cx/to_ref.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/87358728a49034f34ec44c93306c396145d6e77d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fto_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87358728a49034f34ec44c93306c396145d6e77d/src%2Flibrustc_mir%2Fhair%2Fcx%2Fto_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fto_ref.rs?ref=87358728a49034f34ec44c93306c396145d6e77d", "patch": "@@ -10,7 +10,6 @@\n \n use hair::*;\n \n-use hair::cx::pattern::PatNode;\n use rustc_front::hir;\n use syntax::ptr::P;\n \n@@ -43,22 +42,6 @@ impl<'a,'tcx:'a> ToRef for Expr<'tcx> {\n     }\n }\n \n-impl<'a,'tcx:'a> ToRef for PatNode<'tcx> {\n-    type Output = PatternRef<'tcx>;\n-\n-    fn to_ref(self) -> PatternRef<'tcx> {\n-        PatternRef::Hair(self)\n-    }\n-}\n-\n-impl<'a,'tcx:'a> ToRef for Pattern<'tcx> {\n-    type Output = PatternRef<'tcx>;\n-\n-    fn to_ref(self) -> PatternRef<'tcx> {\n-        PatternRef::Mirror(Box::new(self))\n-    }\n-}\n-\n impl<'a,'tcx:'a,T,U> ToRef for &'tcx Option<T>\n     where &'tcx T: ToRef<Output=U>\n {"}, {"sha": "6066791501424336a0fa83ef3886a45d89e1d076", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 16, "deletions": 41, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/87358728a49034f34ec44c93306c396145d6e77d/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87358728a49034f34ec44c93306c396145d6e77d/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=87358728a49034f34ec44c93306c396145d6e77d", "patch": "@@ -22,7 +22,7 @@ use rustc::middle::ty::{AdtDef, ClosureSubsts, Region, Ty};\n use rustc_front::hir;\n use syntax::ast;\n use syntax::codemap::Span;\n-use self::cx::{Cx, PatNode};\n+use self::cx::Cx;\n \n pub mod cx;\n \n@@ -72,7 +72,7 @@ pub enum StmtKind<'tcx> {\n         init_scope: CodeExtent,\n \n         /// let <PAT> = ...\n-        pattern: PatternRef<'tcx>,\n+        pattern: Pattern<'tcx>,\n \n         /// let pat = <INIT> ...\n         initializer: Option<ExprRef<'tcx>>,\n@@ -252,7 +252,7 @@ pub struct FieldExprRef<'tcx> {\n \n #[derive(Clone, Debug)]\n pub struct Arm<'tcx> {\n-    pub patterns: Vec<PatternRef<'tcx>>,\n+    pub patterns: Vec<Pattern<'tcx>>,\n     pub guard: Option<ExprRef<'tcx>>,\n     pub body: ExprRef<'tcx>,\n }\n@@ -261,7 +261,7 @@ pub struct Arm<'tcx> {\n pub struct Pattern<'tcx> {\n     pub ty: Ty<'tcx>,\n     pub span: Span,\n-    pub kind: PatternKind<'tcx>,\n+    pub kind: Box<PatternKind<'tcx>>,\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -281,23 +281,23 @@ pub enum PatternKind<'tcx> {\n         mode: BindingMode,\n         var: ast::NodeId,\n         ty: Ty<'tcx>,\n-        subpattern: Option<PatternRef<'tcx>>,\n+        subpattern: Option<Pattern<'tcx>>,\n     },\n \n     // Foo(...) or Foo{...} or Foo, where `Foo` is a variant name from an adt with >1 variants\n     Variant {\n         adt_def: AdtDef<'tcx>,\n         variant_index: usize,\n-        subpatterns: Vec<FieldPatternRef<'tcx>>,\n+        subpatterns: Vec<FieldPattern<'tcx>>,\n     },\n \n     // (...), Foo(...), Foo{...}, or Foo, where `Foo` is a variant name from an adt with 1 variant\n     Leaf {\n-        subpatterns: Vec<FieldPatternRef<'tcx>>,\n+        subpatterns: Vec<FieldPattern<'tcx>>,\n     },\n \n     Deref {\n-        subpattern: PatternRef<'tcx>,\n+        subpattern: Pattern<'tcx>,\n     }, // box P, &P, &mut P, etc\n \n     Constant {\n@@ -311,16 +311,16 @@ pub enum PatternKind<'tcx> {\n \n     // matches against a slice, checking the length and extracting elements\n     Slice {\n-        prefix: Vec<PatternRef<'tcx>>,\n-        slice: Option<PatternRef<'tcx>>,\n-        suffix: Vec<PatternRef<'tcx>>,\n+        prefix: Vec<Pattern<'tcx>>,\n+        slice: Option<Pattern<'tcx>>,\n+        suffix: Vec<Pattern<'tcx>>,\n     },\n \n     // fixed match against an array, irrefutable\n     Array {\n-        prefix: Vec<PatternRef<'tcx>>,\n-        slice: Option<PatternRef<'tcx>>,\n-        suffix: Vec<PatternRef<'tcx>>,\n+        prefix: Vec<Pattern<'tcx>>,\n+        slice: Option<Pattern<'tcx>>,\n+        suffix: Vec<Pattern<'tcx>>,\n     },\n }\n \n@@ -331,15 +331,9 @@ pub enum BindingMode {\n }\n \n #[derive(Clone, Debug)]\n-pub enum PatternRef<'tcx> {\n-    Hair(PatNode<'tcx>),\n-    Mirror(Box<Pattern<'tcx>>),\n-}\n-\n-#[derive(Clone, Debug)]\n-pub struct FieldPatternRef<'tcx> {\n+pub struct FieldPattern<'tcx> {\n     pub field: Field,\n-    pub pattern: PatternRef<'tcx>,\n+    pub pattern: Pattern<'tcx>,\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -400,25 +394,6 @@ impl<'tcx> Mirror<'tcx> for StmtRef<'tcx> {\n     }\n }\n \n-impl<'tcx> Mirror<'tcx> for Pattern<'tcx> {\n-    type Output = Pattern<'tcx>;\n-\n-    fn make_mirror<'a>(self, _: &mut Cx<'a, 'tcx>) -> Pattern<'tcx> {\n-        self\n-    }\n-}\n-\n-impl<'tcx> Mirror<'tcx> for PatternRef<'tcx> {\n-    type Output = Pattern<'tcx>;\n-\n-    fn make_mirror<'a>(self, hir: &mut Cx<'a, 'tcx>) -> Pattern<'tcx> {\n-        match self {\n-            PatternRef::Hair(h) => h.make_mirror(hir),\n-            PatternRef::Mirror(m) => *m,\n-        }\n-    }\n-}\n-\n impl<'tcx> Mirror<'tcx> for Block<'tcx> {\n     type Output = Block<'tcx>;\n "}, {"sha": "9362aeb6005c148757f4df155a0e8dc1e3a2dda1", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/87358728a49034f34ec44c93306c396145d6e77d/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87358728a49034f34ec44c93306c396145d6e77d/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=87358728a49034f34ec44c93306c396145d6e77d", "patch": "@@ -23,7 +23,7 @@ extern crate rustc_front;\n use build;\n use dot;\n use repr::Mir;\n-use hair::cx::{PatNode, Cx};\n+use hair::cx::Cx;\n use std::fs::File;\n \n use self::rustc::middle::infer;\n@@ -211,7 +211,7 @@ fn build_mir<'a,'tcx:'a>(cx: Cx<'a,'tcx>,\n             .iter()\n             .enumerate()\n             .map(|(index, arg)| {\n-                (fn_sig.inputs[index], PatNode::irrefutable(&arg.pat))\n+                (fn_sig.inputs[index], &*arg.pat)\n             })\n             .collect();\n "}]}