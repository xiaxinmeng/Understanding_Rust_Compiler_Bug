{"sha": "576f7665942414cb95239f8cbec4b654f231f4aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3NmY3NjY1OTQyNDE0Y2I5NTIzOWY4Y2JlYzRiNjU0ZjIzMWY0YWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-08-09T21:04:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-09T21:04:54Z"}, "message": "Auto merge of #35401 - jonathandturner:enable_json_and_new_errors, r=jonathandturner\n\nTurn on new errors and json mode\n\nThis PR is a big-switch, but on a well-worn path:\n\n* Turns on new errors by default (and removes old skool)\n* Moves json output from behind a flag\n\nThe RFC for new errors [landed](https://github.com/rust-lang/rfcs/pull/1644) and as part of that we wanted some bake time.  It's now had a few weeks + all the time leading up to the RFC of people banging on it.  We've also had [editors updating to the new format](https://github.com/saviorisdead/RustyCode/pull/159) and expect more to follow.\n\nWe also have an [issue on old skool](https://github.com/rust-lang/rust/issues/35330) that needs to be fixed as more errors are switched to the new style, but it seems silly to fix old skool errors when we fully intend to throw the switch in the near future.\n\nThis makes it lean towards \"why not just throw the switch now, rather than waiting a couple more weeks?\"  I only know of vim that wanted to try to parse the new format but were not sure how, and I think we can reach out to them and work out something in the 8 weeks before this would appear in a stable release.\n\nWe've [hashed out](https://github.com/rust-lang/rust/issues/35330) stabilizing JSON output, and it seems like people are relatively happy making what we have v1 and then likely adding to it in the future.  The idea is that we'd maintain backward compatibility and just add new fields as needed.  We'll also work on a separate output format that'd be better suited for interactive tools like IDES (since JSON message can get a little long depending on the error).\n\nThis PR stabilizes JSON mode, allowing its use without `-Z unstable-options`\n\nCombined, this gives editors two ways to support errors going forward: parsing the new error format or using the JSON mode.  By moving JSON to stable, we can also add support to Cargo, which plugin authors tell us does help simplify their support story.\n\nr? @nikomatsakis\ncc @rust-lang/tools\n\nCloses https://github.com/rust-lang/rust/issues/34826", "tree": {"sha": "33f5bd4aa0775c88cb716e47ee012eef62d15a89", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33f5bd4aa0775c88cb716e47ee012eef62d15a89"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/576f7665942414cb95239f8cbec4b654f231f4aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/576f7665942414cb95239f8cbec4b654f231f4aa", "html_url": "https://github.com/rust-lang/rust/commit/576f7665942414cb95239f8cbec4b654f231f4aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/576f7665942414cb95239f8cbec4b654f231f4aa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "html_url": "https://github.com/rust-lang/rust/commit/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0"}, {"sha": "9b510ba39a839caeef1badc77ecd2a641465b1bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b510ba39a839caeef1badc77ecd2a641465b1bf", "html_url": "https://github.com/rust-lang/rust/commit/9b510ba39a839caeef1badc77ecd2a641465b1bf"}], "stats": {"total": 630, "additions": 31, "deletions": 599}, "files": [{"sha": "3ad5ef1e0ff6d438720898027ddbed945692dcde", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/576f7665942414cb95239f8cbec4b654f231f4aa/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/576f7665942414cb95239f8cbec4b654f231f4aa/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=576f7665942414cb95239f8cbec4b654f231f4aa", "patch": "@@ -94,7 +94,7 @@ use syntax::ast;\n use syntax::parse::token;\n use syntax::ptr::P;\n use syntax_pos::{self, Pos, Span};\n-use errors::{DiagnosticBuilder, check_old_school};\n+use errors::DiagnosticBuilder;\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn note_and_explain_region(self,\n@@ -541,25 +541,19 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         let span = origin.span();\n \n-        let mut is_simple_error = false;\n-\n         if let Some((expected, found)) = expected_found {\n-            is_simple_error = if let &TypeError::Sorts(ref values) = terr {\n+            let is_simple_error = if let &TypeError::Sorts(ref values) = terr {\n                 values.expected.is_primitive() && values.found.is_primitive()\n             } else {\n                 false\n             };\n \n-            if !is_simple_error || check_old_school() {\n+            if !is_simple_error {\n                 diag.note_expected_found(&\"type\", &expected, &found);\n             }\n         }\n \n-        if !is_simple_error && check_old_school() {\n-            diag.span_note(span, &format!(\"{}\", terr));\n-        } else {\n-            diag.span_label(span, &terr);\n-        }\n+        diag.span_label(span, &terr);\n \n         self.note_error_origin(diag, &origin);\n         self.check_and_note_conflicting_crates(diag, terr, span);"}, {"sha": "3984d2b3d008b676680afc8d57e0091913ab63ed", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/576f7665942414cb95239f8cbec4b654f231f4aa/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/576f7665942414cb95239f8cbec4b654f231f4aa/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=576f7665942414cb95239f8cbec4b654f231f4aa", "patch": "@@ -1057,7 +1057,7 @@ pub fn rustc_optgroups() -> Vec<RustcOptGroup> {\n                      \"NAME=PATH\"),\n         opt::opt_s(\"\", \"sysroot\", \"Override the system root\", \"PATH\"),\n         opt::multi_ubnr(\"Z\", \"\", \"Set internal debugging options\", \"FLAG\"),\n-        opt::opt_ubnr(\"\", \"error-format\",\n+        opt::opt_s(\"\", \"error-format\",\n                       \"How errors and other messages are produced\",\n                       \"human|json\"),\n         opt::opt_s(\"\", \"color\", \"Configure coloring of output:"}, {"sha": "9ab75c8a5a20c8e17a9c47c3d5c70c18d779ccc0", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/576f7665942414cb95239f8cbec4b654f231f4aa/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/576f7665942414cb95239f8cbec4b654f231f4aa/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=576f7665942414cb95239f8cbec4b654f231f4aa", "patch": "@@ -23,7 +23,6 @@ use mir::transform as mir_pass;\n use syntax::ast::{NodeId, Name};\n use errors::{self, DiagnosticBuilder};\n use errors::emitter::{Emitter, EmitterWriter};\n-use errors::snippet::FormatMode;\n use syntax::json::JsonEmitter;\n use syntax::feature_gate;\n use syntax::parse;\n@@ -369,9 +368,7 @@ pub fn build_session_with_codemap(sopts: config::Options,\n     let emitter: Box<Emitter> = match sopts.error_format {\n         config::ErrorOutputType::HumanReadable(color_config) => {\n             Box::new(EmitterWriter::stderr(color_config,\n-                                           Some(registry),\n-                                           Some(codemap.clone()),\n-                                           errors::snippet::FormatMode::EnvironmentSelected))\n+                                           Some(codemap.clone())))\n         }\n         config::ErrorOutputType::Json => {\n             Box::new(JsonEmitter::stderr(Some(registry), codemap.clone()))\n@@ -509,9 +506,7 @@ pub fn early_error(output: config::ErrorOutputType, msg: &str) -> ! {\n     let emitter: Box<Emitter> = match output {\n         config::ErrorOutputType::HumanReadable(color_config) => {\n             Box::new(EmitterWriter::stderr(color_config,\n-                                           None,\n-                                           None,\n-                                           FormatMode::EnvironmentSelected))\n+                                           None))\n         }\n         config::ErrorOutputType::Json => Box::new(JsonEmitter::basic()),\n     };\n@@ -524,9 +519,7 @@ pub fn early_warn(output: config::ErrorOutputType, msg: &str) {\n     let emitter: Box<Emitter> = match output {\n         config::ErrorOutputType::HumanReadable(color_config) => {\n             Box::new(EmitterWriter::stderr(color_config,\n-                                           None,\n-                                           None,\n-                                           FormatMode::EnvironmentSelected))\n+                                           None))\n         }\n         config::ErrorOutputType::Json => Box::new(JsonEmitter::basic()),\n     };"}, {"sha": "9c9453ae3d3145019af640b0fb16d909fd9be910", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/576f7665942414cb95239f8cbec4b654f231f4aa/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/576f7665942414cb95239f8cbec4b654f231f4aa/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=576f7665942414cb95239f8cbec4b654f231f4aa", "patch": "@@ -44,7 +44,7 @@ use std::cmp::Ordering;\n use std::collections::hash_map::Entry::Vacant;\n \n use rustc_const_math::*;\n-use rustc_errors::{DiagnosticBuilder, check_old_school};\n+use rustc_errors::DiagnosticBuilder;\n \n macro_rules! math {\n     ($e:expr, $op:expr) => {\n@@ -378,11 +378,7 @@ pub fn note_const_eval_err<'a, 'tcx>(\n {\n     match err.description() {\n         ConstEvalErrDescription::Simple(message) => {\n-            if check_old_school() {\n-                diag.note(&message);\n-            } else {\n-                diag.span_label(err.span, &message);\n-            }\n+            diag.span_label(err.span, &message);\n         }\n     }\n "}, {"sha": "80f1910906b4c99c72654862f5eaac0e6d4ed45b", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/576f7665942414cb95239f8cbec4b654f231f4aa/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/576f7665942414cb95239f8cbec4b654f231f4aa/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=576f7665942414cb95239f8cbec4b654f231f4aa", "patch": "@@ -100,7 +100,6 @@ use syntax::feature_gate::{GatedCfg, UnstableFeatures};\n use syntax::parse::{self, PResult};\n use syntax_pos::MultiSpan;\n use errors::emitter::Emitter;\n-use errors::snippet::FormatMode;\n \n #[cfg(test)]\n pub mod test;\n@@ -141,9 +140,7 @@ pub fn run(args: Vec<String>) -> isize {\n                     None => {\n                         let emitter =\n                             errors::emitter::EmitterWriter::stderr(errors::ColorConfig::Auto,\n-                                                                   None,\n-                                                                   None,\n-                                                                   FormatMode::EnvironmentSelected);\n+                                                                   None);\n                         let handler = errors::Handler::with_emitter(true, false, Box::new(emitter));\n                         handler.emit(&MultiSpan::new(),\n                                      &abort_msg(err_count),\n@@ -381,10 +378,7 @@ fn check_cfg(sopts: &config::Options,\n              output: ErrorOutputType) {\n     let emitter: Box<Emitter> = match output {\n         config::ErrorOutputType::HumanReadable(color_config) => {\n-            Box::new(errors::emitter::EmitterWriter::stderr(color_config,\n-                                                            None,\n-                                                            None,\n-                                                            FormatMode::EnvironmentSelected))\n+            Box::new(errors::emitter::EmitterWriter::stderr(color_config, None))\n         }\n         config::ErrorOutputType::Json => Box::new(json::JsonEmitter::basic()),\n     };\n@@ -1050,10 +1044,7 @@ pub fn monitor<F: FnOnce() + Send + 'static>(f: F) {\n         // Thread panicked without emitting a fatal diagnostic\n         if !value.is::<errors::FatalError>() {\n             let emitter =\n-                Box::new(errors::emitter::EmitterWriter::stderr(errors::ColorConfig::Auto,\n-                                                       None,\n-                                                       None,\n-                                                       FormatMode::EnvironmentSelected));\n+                Box::new(errors::emitter::EmitterWriter::stderr(errors::ColorConfig::Auto, None));\n             let handler = errors::Handler::with_emitter(true, false, emitter);\n \n             // a .span_bug or .bug call has already printed what"}, {"sha": "981729ddb839581ceecabe70f30093b388313de1", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 8, "deletions": 280, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/576f7665942414cb95239f8cbec4b654f231f4aa/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/576f7665942414cb95239f8cbec4b654f231f4aa/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=576f7665942414cb95239f8cbec4b654f231f4aa", "patch": "@@ -10,16 +10,13 @@\n \n use self::Destination::*;\n \n-use syntax_pos::{COMMAND_LINE_SP, DUMMY_SP, FileMap, Span, MultiSpan, LineInfo, CharPos};\n-use registry;\n+use syntax_pos::{COMMAND_LINE_SP, DUMMY_SP, FileMap, Span, MultiSpan, CharPos};\n \n-use check_old_school;\n use {Level, CodeSuggestion, DiagnosticBuilder, CodeMapper};\n use RenderSpan::*;\n-use snippet::{StyledString, Style, FormatMode, Annotation, Line};\n+use snippet::{StyledString, Style, Annotation, Line};\n use styled_buffer::StyledBuffer;\n \n-use std::cmp;\n use std::io::prelude::*;\n use std::io;\n use std::rc::Rc;\n@@ -33,18 +30,7 @@ pub trait Emitter {\n \n impl Emitter for EmitterWriter {\n     fn emit(&mut self, db: &DiagnosticBuilder) {\n-        // Pick old school mode either from env or let the test dictate the format\n-        let old_school = match self.format_mode {\n-            FormatMode::NewErrorFormat => false,\n-            FormatMode::OriginalErrorFormat => true,\n-            FormatMode::EnvironmentSelected => check_old_school()\n-        };\n-\n-        if old_school {\n-            self.emit_messages_old_school(db);\n-        } else {\n-            self.emit_messages_default(db);\n-        }\n+        self.emit_messages_default(db);\n     }\n }\n \n@@ -70,11 +56,7 @@ impl ColorConfig {\n \n pub struct EmitterWriter {\n     dst: Destination,\n-    registry: Option<registry::Registry>,\n     cm: Option<Rc<CodeMapper>>,\n-\n-    // For now, allow an old-school mode while we transition\n-    format_mode: FormatMode\n }\n \n struct FileWithAnnotatedLines {\n@@ -99,33 +81,23 @@ macro_rules! println_maybe_styled {\n \n impl EmitterWriter {\n     pub fn stderr(color_config: ColorConfig,\n-                  registry: Option<registry::Registry>,\n-                  code_map: Option<Rc<CodeMapper>>,\n-                  format_mode: FormatMode)\n+                  code_map: Option<Rc<CodeMapper>>)\n                   -> EmitterWriter {\n         if color_config.use_color() {\n             let dst = Destination::from_stderr();\n             EmitterWriter { dst: dst,\n-                            registry: registry,\n-                            cm: code_map,\n-                            format_mode: format_mode.clone() }\n+                            cm: code_map}\n         } else {\n             EmitterWriter { dst: Raw(Box::new(io::stderr())),\n-                            registry: registry,\n-                            cm: code_map,\n-                            format_mode: format_mode.clone() }\n+                            cm: code_map}\n         }\n     }\n \n     pub fn new(dst: Box<Write + Send>,\n-               registry: Option<registry::Registry>,\n-               code_map: Option<Rc<CodeMapper>>,\n-               format_mode: FormatMode)\n+               code_map: Option<Rc<CodeMapper>>)\n                -> EmitterWriter {\n         EmitterWriter { dst: Raw(dst),\n-                        registry: registry,\n-                        cm: code_map,\n-                        format_mode: format_mode.clone() }\n+                        cm: code_map}\n     }\n \n     fn preprocess_annotations(&self, msp: &MultiSpan) -> Vec<FileWithAnnotatedLines> {\n@@ -668,240 +640,6 @@ impl EmitterWriter {\n             _ => ()\n         }\n     }\n-    fn emit_message_old_school(&mut self,\n-                               msp: &MultiSpan,\n-                               msg: &str,\n-                               code: &Option<String>,\n-                               level: &Level,\n-                               show_snippet: bool)\n-                               -> io::Result<()> {\n-        let mut buffer = StyledBuffer::new();\n-\n-        let loc = match msp.primary_span() {\n-            Some(COMMAND_LINE_SP) | Some(DUMMY_SP) => \"\".to_string(),\n-            Some(ps) => if let Some(ref cm) = self.cm {\n-                cm.span_to_string(ps)\n-            } else {\n-                \"\".to_string()\n-            },\n-            None => {\n-                \"\".to_string()\n-            }\n-        };\n-        if loc != \"\" {\n-            buffer.append(0, &loc, Style::NoStyle);\n-            buffer.append(0, \" \", Style::NoStyle);\n-        }\n-        buffer.append(0, &level.to_string(), Style::Level(level.clone()));\n-        buffer.append(0, \": \", Style::HeaderMsg);\n-        buffer.append(0, msg, Style::HeaderMsg);\n-        buffer.append(0, \" \", Style::NoStyle);\n-        match code {\n-            &Some(ref code) => {\n-                buffer.append(0, \"[\", Style::ErrorCode);\n-                buffer.append(0, &code, Style::ErrorCode);\n-                buffer.append(0, \"]\", Style::ErrorCode);\n-            }\n-            _ => {}\n-        }\n-\n-        if !show_snippet {\n-            emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n-            return Ok(());\n-        }\n-\n-        // Watch out for various nasty special spans; don't try to\n-        // print any filename or anything for those.\n-        match msp.primary_span() {\n-            Some(COMMAND_LINE_SP) | Some(DUMMY_SP) => {\n-                emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n-                return Ok(());\n-            }\n-            _ => { }\n-        }\n-\n-        let annotated_files = self.preprocess_annotations(msp);\n-\n-        if let (Some(ref cm), Some(ann_file), Some(ref primary_span)) =\n-            (self.cm.as_ref(), annotated_files.first(), msp.primary_span().as_ref()) {\n-\n-            // Next, print the source line and its squiggle\n-            // for old school mode, we will render them to the buffer, then insert the file loc\n-            // (or space the same amount) in front of the line and the squiggle\n-            let source_string = ann_file.file.get_line(ann_file.lines[0].line_index - 1)\n-                .unwrap_or(\"\");\n-\n-            let line_offset = buffer.num_lines();\n-\n-            let lo = cm.lookup_char_pos(primary_span.lo);\n-            //Before each secondary line in old skool-mode, print the label\n-            //as an old-style note\n-            let file_pos = format!(\"{}:{} \", lo.file.name.clone(), lo.line);\n-            let file_pos_len = file_pos.len();\n-\n-            // First create the source line we will highlight.\n-            buffer.puts(line_offset, 0, &file_pos, Style::FileNameStyle);\n-            buffer.puts(line_offset, file_pos_len, &source_string, Style::Quotation);\n-            // Sort the annotations by (start, end col)\n-            let annotations = ann_file.lines[0].annotations.clone();\n-\n-            // Next, create the highlight line.\n-            for annotation in &annotations {\n-                for p in annotation.start_col..annotation.end_col {\n-                    if p == annotation.start_col {\n-                        buffer.putc(line_offset + 1,\n-                                    file_pos_len + p,\n-                                    '^',\n-                                    if annotation.is_primary {\n-                                        Style::UnderlinePrimary\n-                                    } else {\n-                                        Style::OldSchoolNote\n-                                    });\n-                    } else {\n-                        buffer.putc(line_offset + 1,\n-                                    file_pos_len + p,\n-                                    '~',\n-                                    if annotation.is_primary {\n-                                        Style::UnderlinePrimary\n-                                    } else {\n-                                        Style::OldSchoolNote\n-                                    });\n-                    }\n-                }\n-            }\n-        }\n-        if let Some(ref primary_span) = msp.primary_span().as_ref() {\n-            self.render_macro_backtrace_old_school(primary_span, &mut buffer)?;\n-        }\n-\n-        match code {\n-            &Some(ref code) if self.registry.as_ref()\n-                                           .and_then(|registry| registry.find_description(code))\n-                                           .is_some() => {\n-                let msg = \"run `rustc --explain \".to_string() + &code.to_string() +\n-                    \"` to see a detailed explanation\";\n-\n-                let line_offset = buffer.num_lines();\n-                buffer.append(line_offset, &loc, Style::NoStyle);\n-                buffer.append(line_offset, \" \", Style::NoStyle);\n-                buffer.append(line_offset, &Level::Help.to_string(), Style::Level(Level::Help));\n-                buffer.append(line_offset, \": \", Style::HeaderMsg);\n-                buffer.append(line_offset, &msg, Style::HeaderMsg);\n-            }\n-            _ => ()\n-        }\n-\n-        // final step: take our styled buffer, render it, then output it\n-        emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n-        Ok(())\n-    }\n-    fn emit_suggestion_old_school(&mut self,\n-                                  suggestion: &CodeSuggestion,\n-                                  level: &Level,\n-                                  msg: &str)\n-                                  -> io::Result<()> {\n-        use std::borrow::Borrow;\n-\n-        let primary_span = suggestion.msp.primary_span().unwrap();\n-        if let Some(ref cm) = self.cm {\n-            let mut buffer = StyledBuffer::new();\n-\n-            let loc = cm.span_to_string(primary_span);\n-\n-            if loc != \"\" {\n-                buffer.append(0, &loc, Style::NoStyle);\n-                buffer.append(0, \" \", Style::NoStyle);\n-            }\n-\n-            buffer.append(0, &level.to_string(), Style::Level(level.clone()));\n-            buffer.append(0, \": \", Style::HeaderMsg);\n-            buffer.append(0, msg, Style::HeaderMsg);\n-\n-            let lines = cm.span_to_lines(primary_span).unwrap();\n-\n-            assert!(!lines.lines.is_empty());\n-\n-            let complete = suggestion.splice_lines(cm.borrow());\n-            let line_count = cmp::min(lines.lines.len(), MAX_HIGHLIGHT_LINES);\n-            let display_lines = &lines.lines[..line_count];\n-\n-            let fm = &*lines.file;\n-            // Calculate the widest number to format evenly\n-            let max_digits = line_num_max_digits(display_lines.last().unwrap());\n-\n-            // print the suggestion without any line numbers, but leave\n-            // space for them. This helps with lining up with previous\n-            // snippets from the actual error being reported.\n-            let mut lines = complete.lines();\n-            let mut row_num = 1;\n-            for line in lines.by_ref().take(MAX_HIGHLIGHT_LINES) {\n-                buffer.append(row_num, &fm.name, Style::FileNameStyle);\n-                for _ in 0..max_digits+2 {\n-                    buffer.append(row_num, &\" \", Style::NoStyle);\n-                }\n-                buffer.append(row_num, line, Style::NoStyle);\n-                row_num += 1;\n-            }\n-\n-            // if we elided some lines, add an ellipsis\n-            if let Some(_) = lines.next() {\n-                buffer.append(row_num, \"...\", Style::NoStyle);\n-            }\n-            emit_to_destination(&buffer.render(), level, &mut self.dst)?;\n-        }\n-        Ok(())\n-    }\n-\n-    fn emit_messages_old_school(&mut self, db: &DiagnosticBuilder) {\n-        match self.emit_message_old_school(&db.span,\n-                                           &db.message,\n-                                           &db.code,\n-                                           &db.level,\n-                                           true) {\n-            Ok(()) => {\n-                for child in &db.children {\n-                    let (span, show_snippet) = if child.span.primary_spans().is_empty() {\n-                        (db.span.clone(), false)\n-                    } else {\n-                        (child.span.clone(), true)\n-                    };\n-\n-                    match child.render_span {\n-                        Some(FullSpan(_)) => {\n-                            match self.emit_message_old_school(&span,\n-                                                               &child.message,\n-                                                               &None,\n-                                                               &child.level,\n-                                                               show_snippet) {\n-                                Err(e) => panic!(\"failed to emit error: {}\", e),\n-                                _ => ()\n-                            }\n-                        },\n-                        Some(Suggestion(ref cs)) => {\n-                            match self.emit_suggestion_old_school(cs,\n-                                                                  &child.level,\n-                                                                  &child.message) {\n-                                Err(e) => panic!(\"failed to emit error: {}\", e),\n-                                _ => ()\n-                            }\n-                        },\n-                        None => {\n-                            match self.emit_message_old_school(&span,\n-                                                               &child.message,\n-                                                               &None,\n-                                                               &child.level,\n-                                                               show_snippet) {\n-                                Err(e) => panic!(\"failed to emit error: {}\", e),\n-                                _ => ()\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-            Err(e) => panic!(\"failed to emit error: {}\", e)\n-        }\n-    }\n-\n     fn render_macro_backtrace_old_school(&mut self,\n                                          sp: &Span,\n                                          buffer: &mut StyledBuffer) -> io::Result<()> {\n@@ -958,16 +696,6 @@ fn emit_to_destination(rendered_buffer: &Vec<Vec<StyledString>>,\n     Ok(())\n }\n \n-fn line_num_max_digits(line: &LineInfo) -> usize {\n-    let mut max_line_num = line.line_index + 1;\n-    let mut digits = 0;\n-    while max_line_num > 0 {\n-        max_line_num /= 10;\n-        digits += 1;\n-    }\n-    digits\n-}\n-\n #[cfg(unix)]\n fn stderr_isatty() -> bool {\n     use libc;"}, {"sha": "172e27d56d4852b83bb80be3e0ff00112a0c1500", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/576f7665942414cb95239f8cbec4b654f231f4aa/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/576f7665942414cb95239f8cbec4b654f231f4aa/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=576f7665942414cb95239f8cbec4b654f231f4aa", "patch": "@@ -420,13 +420,11 @@ pub struct Handler {\n \n impl Handler {\n     pub fn with_tty_emitter(color_config: ColorConfig,\n-                            registry: Option<registry::Registry>,\n                             can_emit_warnings: bool,\n                             treat_err_as_bug: bool,\n                             cm: Option<Rc<CodeMapper>>)\n                             -> Handler {\n-        let emitter = Box::new(EmitterWriter::stderr(color_config, registry, cm,\n-                               snippet::FormatMode::EnvironmentSelected));\n+        let emitter = Box::new(EmitterWriter::stderr(color_config, cm));\n         Handler::with_emitter(can_emit_warnings, treat_err_as_bug, emitter)\n     }\n \n@@ -750,21 +748,4 @@ pub fn expect<T, M>(diag: &Handler, opt: Option<T>, msg: M) -> T where\n         Some(t) => t,\n         None => diag.bug(&msg()),\n     }\n-}\n-\n-/// True if we should use the old-skool error format style. This is\n-/// the default setting until the new errors are deemed stable enough\n-/// for general use.\n-///\n-/// FIXME(#33240)\n-#[cfg(not(test))]\n-pub fn check_old_school() -> bool {\n-    use std::env;\n-    env::var(\"RUST_NEW_ERROR_FORMAT\").is_err()\n-}\n-\n-/// For unit tests, use the new format.\n-#[cfg(test)]\n-pub fn check_old_school() -> bool {\n-    false\n-}\n+}\n\\ No newline at end of file"}, {"sha": "5ade8cd9bad82be4f2c34b6ffe98fe5d7494e02c", "filename": "src/librustc_errors/snippet.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/576f7665942414cb95239f8cbec4b654f231f4aa/src%2Flibrustc_errors%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/576f7665942414cb95239f8cbec4b654f231f4aa/src%2Flibrustc_errors%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fsnippet.rs?ref=576f7665942414cb95239f8cbec4b654f231f4aa", "patch": "@@ -15,18 +15,10 @@ use CodeMapper;\n use std::rc::Rc;\n use {Level};\n \n-#[derive(Clone)]\n-pub enum FormatMode {\n-    NewErrorFormat,\n-    OriginalErrorFormat,\n-    EnvironmentSelected\n-}\n-\n #[derive(Clone)]\n pub struct SnippetData {\n     codemap: Rc<CodeMapper>,\n-    files: Vec<FileInfo>,\n-    format_mode: FormatMode,\n+    files: Vec<FileInfo>\n }\n \n #[derive(Clone)]\n@@ -41,10 +33,6 @@ pub struct FileInfo {\n     primary_span: Option<Span>,\n \n     lines: Vec<Line>,\n-\n-    /// The type of error format to render.  We keep it here so that\n-    /// it's easy to configure for both tests and regular usage\n-    format_mode: FormatMode,\n }\n \n #[derive(Clone, Debug, PartialOrd, Ord, PartialEq, Eq)]"}, {"sha": "7d8ebc403b08f1c5cc59f050a0df042ce42a5650", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/576f7665942414cb95239f8cbec4b654f231f4aa/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/576f7665942414cb95239f8cbec4b654f231f4aa/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=576f7665942414cb95239f8cbec4b654f231f4aa", "patch": "@@ -128,7 +128,6 @@ pub fn run_core(search_paths: SearchPaths,\n \n     let codemap = Rc::new(codemap::CodeMap::new());\n     let diagnostic_handler = errors::Handler::with_tty_emitter(ColorConfig::Auto,\n-                                                               None,\n                                                                true,\n                                                                false,\n                                                                Some(codemap.clone()));"}, {"sha": "5f1d28c8d316ad35014bd2f4a56f124449a6fdfc", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/576f7665942414cb95239f8cbec4b654f231f4aa/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/576f7665942414cb95239f8cbec4b654f231f4aa/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=576f7665942414cb95239f8cbec4b654f231f4aa", "patch": "@@ -74,7 +74,6 @@ pub fn run(input: &str,\n \n     let codemap = Rc::new(CodeMap::new());\n     let diagnostic_handler = errors::Handler::with_tty_emitter(ColorConfig::Auto,\n-                                                               None,\n                                                                true,\n                                                                false,\n                                                                Some(codemap.clone()));\n@@ -228,9 +227,7 @@ fn runtest(test: &str, cratename: &str, cfgs: Vec<String>, libs: SearchPaths,\n     let data = Arc::new(Mutex::new(Vec::new()));\n     let codemap = Rc::new(CodeMap::new());\n     let emitter = errors::emitter::EmitterWriter::new(box Sink(data.clone()),\n-                                                None,\n-                                                Some(codemap.clone()),\n-                                                errors::snippet::FormatMode::EnvironmentSelected);\n+                                                      Some(codemap.clone()));\n     let old = io::set_panic(box Sink(data.clone()));\n     let _bomb = Bomb(data.clone(), old.unwrap_or(box io::stdout()));\n "}, {"sha": "9e9ea09646088bd2b2726eab8058939a45e6bc44", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/576f7665942414cb95239f8cbec4b654f231f4aa/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/576f7665942414cb95239f8cbec4b654f231f4aa/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=576f7665942414cb95239f8cbec4b654f231f4aa", "patch": "@@ -1685,9 +1685,7 @@ mod tests {\n     fn mk_sh(cm: Rc<CodeMap>) -> errors::Handler {\n         // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n         let emitter = errors::emitter::EmitterWriter::new(Box::new(io::sink()),\n-                                                None,\n-                                                Some(cm),\n-                                                errors::snippet::FormatMode::EnvironmentSelected);\n+                                                Some(cm));\n         errors::Handler::with_emitter(true, false, Box::new(emitter))\n     }\n "}, {"sha": "cd1fdcfe9d130ce94a4e428a9c6d1255222c8190", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/576f7665942414cb95239f8cbec4b654f231f4aa/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/576f7665942414cb95239f8cbec4b654f231f4aa/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=576f7665942414cb95239f8cbec4b654f231f4aa", "patch": "@@ -51,7 +51,6 @@ impl ParseSess {\n     pub fn new() -> ParseSess {\n         let cm = Rc::new(CodeMap::new());\n         let handler = Handler::with_tty_emitter(ColorConfig::Auto,\n-                                                None,\n                                                 true,\n                                                 false,\n                                                 Some(cm.clone()));"}, {"sha": "24ff20ea89242ef7f54009eec003a83d967f2de5", "filename": "src/test/run-make/error-found-staticlib-instead-crate/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/576f7665942414cb95239f8cbec4b654f231f4aa/src%2Ftest%2Frun-make%2Ferror-found-staticlib-instead-crate%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/576f7665942414cb95239f8cbec4b654f231f4aa/src%2Ftest%2Frun-make%2Ferror-found-staticlib-instead-crate%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ferror-found-staticlib-instead-crate%2FMakefile?ref=576f7665942414cb95239f8cbec4b654f231f4aa", "patch": "@@ -2,4 +2,4 @@\n \n all:\n \t$(RUSTC) foo.rs --crate-type staticlib\n-\t$(RUSTC) bar.rs 2>&1 | grep \"error: found staticlib\"\n+\t$(RUSTC) bar.rs 2>&1 | grep \"found staticlib\""}, {"sha": "239b689b52645b8a00fa63e798a4b13c67babc86", "filename": "src/test/run-make/many-crates-but-no-match/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/576f7665942414cb95239f8cbec4b654f231f4aa/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/576f7665942414cb95239f8cbec4b654f231f4aa/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fmany-crates-but-no-match%2FMakefile?ref=576f7665942414cb95239f8cbec4b654f231f4aa", "patch": "@@ -27,7 +27,7 @@ all:\n \tmv $(TMPDIR)/$(call RLIB_GLOB,crateA) $(A3)\n \t# Ensure crateC fails to compile since A1 is \"missing\" and A2/A3 hashes do not match\n \t$(RUSTC) -L $(A2) -L $(A3) crateC.rs >$(LOG) 2>&1 || true\n-\tgrep \"error: found possibly newer version of crate \\`crateA\\` which \\`crateB\\` depends on\" $(LOG)\n+\tgrep \"found possibly newer version of crate \\`crateA\\` which \\`crateB\\` depends on\" $(LOG)\n \tgrep \"note: perhaps that crate needs to be recompiled?\" $(LOG)\n \tgrep \"note: crate \\`crateA\\` path #1:\" $(LOG)\n \tgrep \"note: crate \\`crateA\\` path #2:\" $(LOG)"}, {"sha": "4275c9b3f9fa341e30f06bdf76f9debda6a71eaa", "filename": "src/test/run-make/missing-crate-dependency/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/576f7665942414cb95239f8cbec4b654f231f4aa/src%2Ftest%2Frun-make%2Fmissing-crate-dependency%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/576f7665942414cb95239f8cbec4b654f231f4aa/src%2Ftest%2Frun-make%2Fmissing-crate-dependency%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fmissing-crate-dependency%2FMakefile?ref=576f7665942414cb95239f8cbec4b654f231f4aa", "patch": "@@ -6,4 +6,4 @@ all:\n \t$(call REMOVE_RLIBS,crateA)\n \t# Ensure crateC fails to compile since dependency crateA is missing\n \t$(RUSTC) crateC.rs 2>&1 | \\\n-\t\tgrep \"error: can't find crate for \\`crateA\\` which \\`crateB\\` depends on\"\n+\t\tgrep \"can't find crate for \\`crateA\\` which \\`crateB\\` depends on\""}, {"sha": "f834a85cdcc741c0cc496fa1d55bffd7a3f79974", "filename": "src/test/run-make/unicode-input/Makefile", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Ftest%2Frun-make%2Funicode-input%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Ftest%2Frun-make%2Funicode-input%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2FMakefile?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -1,26 +0,0 @@\n--include ../tools.mk\n-\n-# This test attempts to run rustc itself from the compiled binary; but\n-# that means that you need to set the LD_LIBRARY_PATH for rustc itself\n-# while running multiple_files, and that won't work for stage1.\n-\n-# FIXME ignore windows\n-ifndef IS_WINDOWS\n-ifeq ($(RUST_BUILD_STAGE),1)\n-DOTEST=\n-else\n-DOTEST=dotest\n-endif\n-endif\n-\n-all: $(DOTEST)\n-\n-dotest:\n-\t# check that we don't ICE on unicode input, issue #11178\n-\t$(RUSTC) multiple_files.rs\n-\t$(call RUN,multiple_files)  \"$(RUSTC)\" \"$(TMPDIR)\"\n-\n-\t# check that our multibyte-ident spans are (approximately) the\n-\t# correct length. issue #8706\n-\t$(RUSTC) span_length.rs\n-\t$(call RUN,span_length) \"$(RUSTC)\" \"$(TMPDIR)\""}, {"sha": "b1fe938767dc912cd8a533b7df908799b2e6fd3d", "filename": "src/test/run-make/unicode-input/multiple_files.rs", "status": "removed", "additions": 0, "deletions": 74, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fmultiple_files.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -1,74 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(rand)]\n-\n-use std::fs::File;\n-use std::io::prelude::*;\n-use std::path::Path;\n-use std::process::Command;\n-use std::__rand::{thread_rng, Rng};\n-use std::{char, env};\n-\n-// creates unicode_input_multiple_files_{main,chars}.rs, where the\n-// former imports the latter. `_chars` just contains an identifier\n-// made up of random characters, because will emit an error message\n-// about the ident being in the wrong place, with a span (and creating\n-// this span used to upset the compiler).\n-\n-fn random_char() -> char {\n-    let mut rng = thread_rng();\n-    // a subset of the XID_start Unicode table (ensuring that the\n-    // compiler doesn't fail with an \"unrecognised token\" error)\n-    let (lo, hi): (u32, u32) = match rng.gen_range(1u32, 4u32 + 1) {\n-        1 => (0x41, 0x5a),\n-        2 => (0xf8, 0x1ba),\n-        3 => (0x1401, 0x166c),\n-        _ => (0x10400, 0x1044f)\n-    };\n-\n-    char::from_u32(rng.gen_range(lo, hi + 1)).unwrap()\n-}\n-\n-fn main() {\n-    let args: Vec<String> = env::args().collect();\n-    let rustc = &args[1];\n-    let tmpdir = Path::new(&args[2]);\n-\n-    let main_file = tmpdir.join(\"unicode_input_multiple_files_main.rs\");\n-    {\n-        let _ = File::create(&main_file).unwrap()\n-            .write_all(b\"mod unicode_input_multiple_files_chars;\").unwrap();\n-    }\n-\n-    for _ in 0..100 {\n-        {\n-            let randoms = tmpdir.join(\"unicode_input_multiple_files_chars.rs\");\n-            let mut w = File::create(&randoms).unwrap();\n-            for _ in 0..30 {\n-                write!(&mut w, \"{}\", random_char()).unwrap();\n-            }\n-        }\n-\n-        // rustc is passed to us with --out-dir and -L etc., so we\n-        // can't exec it directly\n-        let result = Command::new(\"sh\")\n-                             .arg(\"-c\")\n-                             .arg(&format!(\"{} {}\",\n-                                           rustc,\n-                                           main_file.display()))\n-                             .output().unwrap();\n-        let err = String::from_utf8_lossy(&result.stderr);\n-\n-        // positive test so that this test will be updated when the\n-        // compiler changes.\n-        assert!(err.contains(\"expected item, found\"))\n-    }\n-}"}, {"sha": "da8769e616c3f0ae545554aebb55edcc0eb6e964", "filename": "src/test/run-make/unicode-input/span_length.rs", "status": "removed", "additions": 0, "deletions": 130, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d2bc2916b5b5840789d7e7fc89e4647063bfa0/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs?ref=e1d2bc2916b5b5840789d7e7fc89e4647063bfa0", "patch": "@@ -1,130 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(rand)]\n-\n-use std::fs::File;\n-use std::io::prelude::*;\n-use std::iter::repeat;\n-use std::path::Path;\n-use std::process::Command;\n-use std::__rand::{thread_rng, Rng};\n-use std::{char, env};\n-\n-pub fn check_old_skool() -> bool {\n-    use std::env;\n-    env::var(\"RUST_NEW_ERROR_FORMAT\").is_err()\n-}\n-\n-// creates a file with `fn main() { <random ident> }` and checks the\n-// compiler emits a span of the appropriate length (for the\n-// \"unresolved name\" message); currently just using the number of code\n-// points, but should be the number of graphemes (FIXME #7043)\n-\n-fn random_char() -> char {\n-    let mut rng = thread_rng();\n-    // a subset of the XID_start Unicode table (ensuring that the\n-    // compiler doesn't fail with an \"unrecognised token\" error)\n-    let (lo, hi): (u32, u32) = match rng.gen_range(1u32, 4u32 + 1) {\n-        1 => (0x41, 0x5a),\n-        2 => (0xf8, 0x1ba),\n-        3 => (0x1401, 0x166c),\n-        _ => (0x10400, 0x1044f)\n-    };\n-\n-    char::from_u32(rng.gen_range(lo, hi + 1)).unwrap()\n-}\n-\n-fn main() {\n-    let args: Vec<String> = env::args().collect();\n-    let rustc = &args[1];\n-    let tmpdir = Path::new(&args[2]);\n-    let main_file = tmpdir.join(\"span_main.rs\");\n-\n-    for _ in 0..100 {\n-        let n = thread_rng().gen_range(3, 20);\n-\n-        {\n-            let _ = write!(&mut File::create(&main_file).unwrap(),\n-                           \"#![feature(non_ascii_idents)] fn main() {{ {} }}\",\n-                           // random string of length n\n-                           (0..n).map(|_| random_char()).collect::<String>());\n-        }\n-\n-        // rustc is passed to us with --out-dir and -L etc., so we\n-        // can't exec it directly\n-        let result = Command::new(\"sh\")\n-                             .arg(\"-c\")\n-                             .arg(&format!(\"{} {}\",\n-                                           rustc,\n-                                           main_file.to_str()\n-                                                    .unwrap()))\n-                             .output().unwrap();\n-\n-        let err = String::from_utf8_lossy(&result.stderr);\n-\n-        if check_old_skool() {\n-            // the span should end the line (e.g no extra ~'s)\n-            let expected_span = format!(\"^{}\\n\", repeat(\"~\").take(n - 1)\n-                                                            .collect::<String>());\n-            assert!(err.contains(&expected_span));\n-        } else {\n-            // the span should end the line (e.g no extra ~'s)\n-            let expected_span = format!(\"^{}\\n\", repeat(\"^\").take(n - 1)\n-                                                            .collect::<String>());\n-            assert!(err.contains(&expected_span));\n-        }\n-    }\n-\n-    // Test multi-column characters and tabs\n-    {\n-        let _ = write!(&mut File::create(&main_file).unwrap(),\n-                       r#\"extern \"\uf937\uf922\uf92ba\u0301\u0301\u0301\" fn foo() {{}} extern \"\uf937\uf922\uf92ba\u0301\u0301\" fn bar() {{}}\"#);\n-    }\n-\n-    let result = Command::new(\"sh\")\n-                         .arg(\"-c\")\n-                         .arg(format!(\"{} {}\",\n-                                      rustc,\n-                                      main_file.display()))\n-                         .output().unwrap();\n-\n-    let err = String::from_utf8_lossy(&result.stderr);\n-\n-    // Test both the length of the snake and the leading spaces up to it\n-\n-    if check_old_skool() {\n-        // Extra characters. Every line is preceded by `filename:lineno <actual code>`\n-        let offset = main_file.to_str().unwrap().len() + 3;\n-\n-        // First snake is 8 ~s long, with 7 preceding spaces (excluding file name/line offset)\n-        let expected_span = format!(\"\\n{}^{}\\n\",\n-                                    repeat(\" \").take(offset + 7).collect::<String>(),\n-                                    repeat(\"~\").take(8).collect::<String>());\n-        assert!(err.contains(&expected_span));\n-        // Second snake is only 7 ~s long, with 36 preceding spaces,\n-        // because rustc counts chars() now rather than width(). This\n-        // is because width() functions are to be removed from\n-        // librustc_unicode\n-        let expected_span = format!(\"\\n{}^{}\\n\",\n-                                    repeat(\" \").take(offset + 36).collect::<String>(),\n-                                    repeat(\"~\").take(7).collect::<String>());\n-        assert!(err.contains(&expected_span));\n-    } else {\n-        let expected_span = format!(\"\\n  |>{}{}\\n\",\n-                                    repeat(\" \").take(8).collect::<String>(),\n-                                    repeat(\"^\").take(9).collect::<String>());\n-        assert!(err.contains(&expected_span));\n-        let expected_span = format!(\"\\n  |>{}{}\\n\",\n-                                    repeat(\" \").take(37).collect::<String>(),\n-                                    repeat(\"^\").take(8).collect::<String>());\n-        assert!(err.contains(&expected_span));\n-    }\n-}"}, {"sha": "acf12dab16aff4d86b8a940cf84f7af88464cc2d", "filename": "src/tools/cargotest/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/576f7665942414cb95239f8cbec4b654f231f4aa/src%2Ftools%2Fcargotest%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/576f7665942414cb95239f8cbec4b654f231f4aa/src%2Ftools%2Fcargotest%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargotest%2Fmain.rs?ref=576f7665942414cb95239f8cbec4b654f231f4aa", "patch": "@@ -24,7 +24,7 @@ struct Test {\n const TEST_REPOS: &'static [Test] = &[Test {\n                                           name: \"cargo\",\n                                           repo: \"https://github.com/rust-lang/cargo\",\n-                                          sha: \"fd90fd642d404d8c66505ca8db742c664ea352f2\",\n+                                          sha: \"2d85908217f99a30aa5f68e05a8980704bb71fad\",\n                                           lock: None,\n                                       },\n                                       Test {"}, {"sha": "ae8e82e4e2f60e36639358d9fa062381431fbe75", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/576f7665942414cb95239f8cbec4b654f231f4aa/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/576f7665942414cb95239f8cbec4b654f231f4aa/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=576f7665942414cb95239f8cbec4b654f231f4aa", "patch": "@@ -1330,9 +1330,7 @@ actual:\\n\\\n                 // patterns still match the raw compiler output.\n                 if self.props.error_patterns.is_empty() {\n                     args.extend([\"--error-format\",\n-                                 \"json\",\n-                                 \"-Z\",\n-                                 \"unstable-options\"]\n+                                 \"json\"]\n                                 .iter()\n                                 .map(|s| s.to_string()));\n                 }"}]}