{"sha": "2d52054fb28a81d351b09330496c749775790b63", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkNTIwNTRmYjI4YTgxZDM1MWIwOTMzMDQ5NmM3NDk3NzU3OTBiNjM=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-07-04T11:16:29Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-07-11T08:32:01Z"}, "message": "Rename Pointer to MemoryPointer", "tree": {"sha": "467375c2a89ecde52878f1246dc4f12fad0af656", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/467375c2a89ecde52878f1246dc4f12fad0af656"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d52054fb28a81d351b09330496c749775790b63", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAllkjQEACgkQpp+NIls6\n19nnzxAAqgofJKqsBAryQeG16iw/LxbDIBL4Hoa7TXTDg4V9dNpyMt06gfJdFCq9\n2zwKpWlNaV1z1G7z9NZ3HsG32YRlimGmeffzuNF4Tz4ksEFZ/KjVD2NTKYDEC8QS\nG4DaLKGoN74fFRtxuRP1JCqclpAU6U6y19letIeynOGkuZWOCVpdotsvLK24VCPJ\nPBTS2bttx5m9aqj8DKAsXtW8eDuDXznoKiz1ln/C4bxA7gYpp/NgflsVzEeFojEa\nftvMbtW1/VfA2pynbiCzNmGZCdwinOVNdD/Nj9FGuQ+pVCToH3I7M+xdgxGVCmL2\n8cr53ZWa/3u1btJtDATVNIQj09WgmGCabUpotD6CCjGciAY9ydsNrOQBx0HjD3c8\njt9dJtwh5UQqzgsSjIuuT1L/MBY+5WXKXuIeU5GJI8RLkH6uKvCt7Pbyy9vn5vLT\ndWlGsoc+D7fcqcDAsagcS+m5GPhDZrCbhmJ7/spY+QXFThhhmP8AcrxabBKza+z8\nj18qqMq1pvRhTj42k6KgvBDbPqLEZkKnMQUrZ6IU2HoCt2qmKAoYexoYV1HvHzXF\nH4EtL9ZYI6Gymka2ThIIZ+QqeyuQaP2YAi8313qTcYpLR1X4MdmVxJP9idUas/SF\nZuBPvdhNfY2gacoU8y5kFQXr6SteRdJRn1oRyHYgww5KiGgg6xk=\n=tLxk\n-----END PGP SIGNATURE-----", "payload": "tree 467375c2a89ecde52878f1246dc4f12fad0af656\nparent 151102345624f6453dfe2474009d202792160afb\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1499166989 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1499761921 +0200\n\nRename Pointer to MemoryPointer\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d52054fb28a81d351b09330496c749775790b63", "html_url": "https://github.com/rust-lang/rust/commit/2d52054fb28a81d351b09330496c749775790b63", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d52054fb28a81d351b09330496c749775790b63/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "151102345624f6453dfe2474009d202792160afb", "url": "https://api.github.com/repos/rust-lang/rust/commits/151102345624f6453dfe2474009d202792160afb", "html_url": "https://github.com/rust-lang/rust/commit/151102345624f6453dfe2474009d202792160afb"}], "stats": {"total": 158, "additions": 79, "deletions": 79}, "files": [{"sha": "801ea5c7da48f6b3348bd6e257d22db5a0c9921a", "filename": "src/error.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2d52054fb28a81d351b09330496c749775790b63/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d52054fb28a81d351b09330496c749775790b63/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=2d52054fb28a81d351b09330496c749775790b63", "patch": "@@ -2,22 +2,22 @@ use std::error::Error;\n use std::fmt;\n use rustc::mir;\n use rustc::ty::{FnSig, Ty, layout};\n-use memory::Pointer;\n+use memory::MemoryPointer;\n use rustc_const_math::ConstMathErr;\n use syntax::codemap::Span;\n \n #[derive(Clone, Debug)]\n pub enum EvalError<'tcx> {\n     FunctionPointerTyMismatch(FnSig<'tcx>, FnSig<'tcx>),\n     NoMirFor(String),\n-    UnterminatedCString(Pointer),\n+    UnterminatedCString(MemoryPointer),\n     DanglingPointerDeref,\n     InvalidMemoryAccess,\n     InvalidFunctionPointer,\n     InvalidBool,\n     InvalidDiscriminant,\n     PointerOutOfBounds {\n-        ptr: Pointer,\n+        ptr: MemoryPointer,\n         access: bool,\n         allocation_size: u64,\n     },"}, {"sha": "c4c89427b40bab66647b811770f8fef26ce793d2", "filename": "src/eval_context.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2d52054fb28a81d351b09330496c749775790b63/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d52054fb28a81d351b09330496c749775790b63/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=2d52054fb28a81d351b09330496c749775790b63", "patch": "@@ -17,7 +17,7 @@ use syntax::abi::Abi;\n \n use error::{EvalError, EvalResult};\n use lvalue::{Global, GlobalId, Lvalue, LvalueExtra};\n-use memory::{Memory, Pointer, TlsKey};\n+use memory::{Memory, MemoryPointer, TlsKey};\n use operator;\n use value::{PrimVal, PrimValKind, Value};\n \n@@ -44,7 +44,7 @@ pub struct EvalContext<'a, 'tcx: 'a> {\n \n     /// Environment variables set by `setenv`\n     /// Miri does not expose env vars from the host to the emulated program\n-    pub(crate) env_vars: HashMap<Vec<u8>, Pointer>,\n+    pub(crate) env_vars: HashMap<Vec<u8>, MemoryPointer>,\n }\n \n /// A stack frame.\n@@ -142,7 +142,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    pub fn alloc_ptr(&mut self, ty: Ty<'tcx>) -> EvalResult<'tcx, Pointer> {\n+    pub fn alloc_ptr(&mut self, ty: Ty<'tcx>) -> EvalResult<'tcx, MemoryPointer> {\n         let substs = self.substs();\n         self.alloc_ptr_with_substs(ty, substs)\n     }\n@@ -151,7 +151,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         &mut self,\n         ty: Ty<'tcx>,\n         substs: &'tcx Substs<'tcx>\n-    ) -> EvalResult<'tcx, Pointer> {\n+    ) -> EvalResult<'tcx, MemoryPointer> {\n         let size = self.type_size_with_substs(ty, substs)?.expect(\"cannot alloc memory for unsized type\");\n         let align = self.type_align_with_substs(ty, substs)?;\n         self.memory.allocate(size, align)\n@@ -313,7 +313,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             set\n         }\n \n-        // Subtract 1 because `local_decls` includes the ReturnPointer, but we don't store a local\n+        // Subtract 1 because `local_decls` includes the ReturnMemoryPointer, but we don't store a local\n         // `Value` for that.\n         let annotated_locals = collect_storage_annotations(mir);\n         let num_locals = mir.local_decls.len() - 1;\n@@ -1197,7 +1197,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         &mut self,\n         a: PrimVal,\n         b: PrimVal,\n-        ptr: Pointer,\n+        ptr: MemoryPointer,\n         mut ty: Ty<'tcx>\n     ) -> EvalResult<'tcx> {\n         while self.get_field_count(ty)? == 1 {\n@@ -1322,7 +1322,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    pub(crate) fn read_ptr(&self, ptr: Pointer, pointee_ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n+    pub(crate) fn read_ptr(&self, ptr: MemoryPointer, pointee_ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n         let p = self.memory.read_ptr(ptr)?;\n         if self.type_is_sized(pointee_ty) {\n             Ok(Value::ByVal(p))"}, {"sha": "bbb271a6b6a79a782e70a6b983662651d3907c61", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2d52054fb28a81d351b09330496c749775790b63/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d52054fb28a81d351b09330496c749775790b63/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=2d52054fb28a81d351b09330496c749775790b63", "patch": "@@ -48,7 +48,7 @@ pub use lvalue::{\n pub use memory::{\n     AllocId,\n     Memory,\n-    Pointer,\n+    MemoryPointer,\n };\n \n pub use value::{"}, {"sha": "de7d4d917160bdab355374dce12e47c14e40cde7", "filename": "src/lvalue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2d52054fb28a81d351b09330496c749775790b63/src%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d52054fb28a81d351b09330496c749775790b63/src%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flvalue.rs?ref=2d52054fb28a81d351b09330496c749775790b63", "patch": "@@ -5,7 +5,7 @@ use rustc_data_structures::indexed_vec::Idx;\n \n use error::{EvalError, EvalResult};\n use eval_context::{EvalContext};\n-use memory::Pointer;\n+use memory::MemoryPointer;\n use value::{PrimVal, Value};\n \n #[derive(Copy, Clone, Debug)]\n@@ -34,7 +34,7 @@ pub enum Lvalue<'tcx> {\n pub enum LvalueExtra {\n     None,\n     Length(u64),\n-    Vtable(Pointer),\n+    Vtable(MemoryPointer),\n     DowncastVariant(usize),\n }\n \n@@ -71,7 +71,7 @@ impl<'tcx> Lvalue<'tcx> {\n         Lvalue::Ptr { ptr, extra: LvalueExtra::None }\n     }\n \n-    pub(crate) fn from_ptr(ptr: Pointer) -> Self {\n+    pub(crate) fn from_ptr(ptr: MemoryPointer) -> Self {\n         Self::from_primval_ptr(PrimVal::Ptr(ptr))\n     }\n \n@@ -83,7 +83,7 @@ impl<'tcx> Lvalue<'tcx> {\n         }\n     }\n \n-    pub(super) fn to_ptr(self) -> EvalResult<'tcx, Pointer> {\n+    pub(super) fn to_ptr(self) -> EvalResult<'tcx, MemoryPointer> {\n         let (ptr, extra) = self.to_ptr_and_extra();\n         assert_eq!(extra, LvalueExtra::None);\n         ptr.to_ptr()"}, {"sha": "568da336f6696322332b6cbaf4ea2ff6d8688eb2", "filename": "src/memory.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/2d52054fb28a81d351b09330496c749775790b63/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d52054fb28a81d351b09330496c749775790b63/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=2d52054fb28a81d351b09330496c749775790b63", "patch": "@@ -50,36 +50,36 @@ pub enum StaticKind {\n }\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n-pub struct Pointer {\n+pub struct MemoryPointer {\n     pub alloc_id: AllocId,\n     pub offset: u64,\n }\n \n-impl Pointer {\n+impl MemoryPointer {\n     pub fn new(alloc_id: AllocId, offset: u64) -> Self {\n-        Pointer { alloc_id, offset }\n+        MemoryPointer { alloc_id, offset }\n     }\n \n     pub fn wrapping_signed_offset<'tcx>(self, i: i64, layout: &TargetDataLayout) -> Self {\n-        Pointer::new(self.alloc_id, value::wrapping_signed_offset(self.offset, i, layout))\n+        MemoryPointer::new(self.alloc_id, value::wrapping_signed_offset(self.offset, i, layout))\n     }\n \n     pub fn overflowing_signed_offset<'tcx>(self, i: i128, layout: &TargetDataLayout) -> (Self, bool) {\n         let (res, over) = value::overflowing_signed_offset(self.offset, i, layout);\n-        (Pointer::new(self.alloc_id, res), over)\n+        (MemoryPointer::new(self.alloc_id, res), over)\n     }\n \n     pub fn signed_offset<'tcx>(self, i: i64, layout: &TargetDataLayout) -> EvalResult<'tcx, Self> {\n-        Ok(Pointer::new(self.alloc_id, value::signed_offset(self.offset, i, layout)?))\n+        Ok(MemoryPointer::new(self.alloc_id, value::signed_offset(self.offset, i, layout)?))\n     }\n \n     pub fn overflowing_offset<'tcx>(self, i: u64, layout: &TargetDataLayout) -> (Self, bool) {\n         let (res, over) = value::overflowing_offset(self.offset, i, layout);\n-        (Pointer::new(self.alloc_id, res), over)\n+        (MemoryPointer::new(self.alloc_id, res), over)\n     }\n \n     pub fn offset<'tcx>(self, i: u64, layout: &TargetDataLayout) -> EvalResult<'tcx, Self> {\n-        Ok(Pointer::new(self.alloc_id, value::offset(self.offset, i, layout)?))\n+        Ok(MemoryPointer::new(self.alloc_id, value::offset(self.offset, i, layout)?))\n     }\n }\n \n@@ -171,21 +171,21 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         self.alloc_map.iter()\n     }\n \n-    pub fn create_fn_alloc(&mut self, instance: ty::Instance<'tcx>) -> Pointer {\n+    pub fn create_fn_alloc(&mut self, instance: ty::Instance<'tcx>) -> MemoryPointer {\n         if let Some(&alloc_id) = self.function_alloc_cache.get(&instance) {\n-            return Pointer::new(alloc_id, 0);\n+            return MemoryPointer::new(alloc_id, 0);\n         }\n         let id = self.next_id;\n         debug!(\"creating fn ptr: {}\", id);\n         self.next_id.0 += 1;\n         self.functions.insert(id, instance);\n         self.function_alloc_cache.insert(instance, id);\n-        Pointer::new(id, 0)\n+        MemoryPointer::new(id, 0)\n     }\n \n-    pub fn allocate_cached(&mut self, bytes: &[u8]) -> EvalResult<'tcx, Pointer> {\n+    pub fn allocate_cached(&mut self, bytes: &[u8]) -> EvalResult<'tcx, MemoryPointer> {\n         if let Some(&alloc_id) = self.literal_alloc_cache.get(bytes) {\n-            return Ok(Pointer::new(alloc_id, 0));\n+            return Ok(MemoryPointer::new(alloc_id, 0));\n         }\n \n         let ptr = self.allocate(bytes.len() as u64, 1)?;\n@@ -195,7 +195,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(ptr)\n     }\n \n-    pub fn allocate(&mut self, size: u64, align: u64) -> EvalResult<'tcx, Pointer> {\n+    pub fn allocate(&mut self, size: u64, align: u64) -> EvalResult<'tcx, MemoryPointer> {\n         assert_ne!(align, 0);\n         assert!(align.is_power_of_two());\n \n@@ -218,12 +218,12 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         let id = self.next_id;\n         self.next_id.0 += 1;\n         self.alloc_map.insert(id, alloc);\n-        Ok(Pointer::new(id, 0))\n+        Ok(MemoryPointer::new(id, 0))\n     }\n \n     // TODO(solson): Track which allocations were returned from __rust_allocate and report an error\n     // when reallocating/deallocating any others.\n-    pub fn reallocate(&mut self, ptr: Pointer, old_size: u64, old_align: u64, new_size: u64, new_align: u64) -> EvalResult<'tcx, Pointer> {\n+    pub fn reallocate(&mut self, ptr: MemoryPointer, old_size: u64, old_align: u64, new_size: u64, new_align: u64) -> EvalResult<'tcx, Pointer> {\n         use std::cmp::min;\n \n         // TODO(solson): Report error about non-__rust_allocate'd pointer.\n@@ -243,7 +243,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     }\n \n     // TODO(solson): See comment on `reallocate`.\n-    pub fn deallocate(&mut self, ptr: Pointer, size_and_align: Option<(u64, u64)>) -> EvalResult<'tcx> {\n+    pub fn deallocate(&mut self, ptr: MemoryPointer, size_and_align: Option<(u64, u64)>) -> EvalResult<'tcx> {\n         if ptr.offset != 0 || self.get(ptr.alloc_id).is_err() {\n             // TODO(solson): Report error about non-__rust_allocate'd pointer.\n             return Err(EvalError::DeallocateNonBasePtr);\n@@ -329,7 +329,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n     }\n \n-    pub(crate) fn check_bounds(&self, ptr: Pointer, access: bool) -> EvalResult<'tcx> {\n+    pub(crate) fn check_bounds(&self, ptr: MemoryPointer, access: bool) -> EvalResult<'tcx> {\n         let alloc = self.get(ptr.alloc_id)?;\n         let allocation_size = alloc.bytes.len() as u64;\n         if ptr.offset > allocation_size {\n@@ -338,7 +338,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(())\n     }\n \n-    pub(crate) fn mark_packed(&mut self, ptr: Pointer, len: u64) {\n+    pub(crate) fn mark_packed(&mut self, ptr: MemoryPointer, len: u64) {\n         self.packed.insert(Entry {\n             alloc_id: ptr.alloc_id,\n             packed_start: ptr.offset,\n@@ -466,7 +466,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n     }\n \n-    pub fn get_fn(&self, ptr: Pointer) -> EvalResult<'tcx, ty::Instance<'tcx>> {\n+    pub fn get_fn(&self, ptr: MemoryPointer) -> EvalResult<'tcx, ty::Instance<'tcx>> {\n         if ptr.offset != 0 {\n             return Err(EvalError::InvalidFunctionPointer);\n         }\n@@ -571,7 +571,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n /// Byte accessors\n impl<'a, 'tcx> Memory<'a, 'tcx> {\n-    fn get_bytes_unchecked(&self, ptr: Pointer, size: u64, align: u64) -> EvalResult<'tcx, &[u8]> {\n+    fn get_bytes_unchecked(&self, ptr: MemoryPointer, size: u64, align: u64) -> EvalResult<'tcx, &[u8]> {\n         if size == 0 {\n             return Ok(&[]);\n         }\n@@ -584,7 +584,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(&alloc.bytes[offset..offset + size as usize])\n     }\n \n-    fn get_bytes_unchecked_mut(&mut self, ptr: Pointer, size: u64, align: u64) -> EvalResult<'tcx, &mut [u8]> {\n+    fn get_bytes_unchecked_mut(&mut self, ptr: MemoryPointer, size: u64, align: u64) -> EvalResult<'tcx, &mut [u8]> {\n         if size == 0 {\n             return Ok(&mut []);\n         }\n@@ -597,7 +597,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(&mut alloc.bytes[offset..offset + size as usize])\n     }\n \n-    fn get_bytes(&self, ptr: Pointer, size: u64, align: u64) -> EvalResult<'tcx, &[u8]> {\n+    fn get_bytes(&self, ptr: MemoryPointer, size: u64, align: u64) -> EvalResult<'tcx, &[u8]> {\n         assert_ne!(size, 0);\n         if self.relocations(ptr, size)?.count() != 0 {\n             return Err(EvalError::ReadPointerAsBytes);\n@@ -606,7 +606,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         self.get_bytes_unchecked(ptr, size, align)\n     }\n \n-    fn get_bytes_mut(&mut self, ptr: Pointer, size: u64, align: u64) -> EvalResult<'tcx, &mut [u8]> {\n+    fn get_bytes_mut(&mut self, ptr: MemoryPointer, size: u64, align: u64) -> EvalResult<'tcx, &mut [u8]> {\n         assert_ne!(size, 0);\n         self.clear_relocations(ptr, size)?;\n         self.mark_definedness(PrimVal::Ptr(ptr), size, true)?;\n@@ -697,7 +697,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(())\n     }\n \n-    pub fn read_c_str(&self, ptr: Pointer) -> EvalResult<'tcx, &[u8]> {\n+    pub fn read_c_str(&self, ptr: MemoryPointer) -> EvalResult<'tcx, &[u8]> {\n         let alloc = self.get(ptr.alloc_id)?;\n         assert_eq!(ptr.offset as usize as u64, ptr.offset);\n         let offset = ptr.offset as usize;\n@@ -738,7 +738,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(())\n     }\n \n-    pub fn read_ptr(&self, ptr: Pointer) -> EvalResult<'tcx, PrimVal> {\n+    pub fn read_ptr(&self, ptr: MemoryPointer) -> EvalResult<'tcx, PrimVal> {\n         let size = self.pointer_size();\n         if self.check_defined(ptr, size).is_err() {\n             return Ok(PrimVal::Undef);\n@@ -750,12 +750,12 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         let offset = offset as u64;\n         let alloc = self.get(ptr.alloc_id)?;\n         match alloc.relocations.get(&ptr.offset) {\n-            Some(&alloc_id) => Ok(PrimVal::Ptr(Pointer::new(alloc_id, offset))),\n+            Some(&alloc_id) => Ok(PrimVal::Ptr(MemoryPointer::new(alloc_id, offset))),\n             None => Ok(PrimVal::Bytes(offset as u128)),\n         }\n     }\n \n-    pub fn write_ptr(&mut self, dest: Pointer, ptr: Pointer) -> EvalResult<'tcx> {\n+    pub fn write_ptr(&mut self, dest: MemoryPointer, ptr: MemoryPointer) -> EvalResult<'tcx> {\n         self.write_usize(dest, ptr.offset as u64)?;\n         self.get_mut(dest.alloc_id)?.relocations.insert(dest.offset, ptr.alloc_id);\n         Ok(())\n@@ -791,7 +791,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n     }\n \n-    pub fn read_bool(&self, ptr: Pointer) -> EvalResult<'tcx, bool> {\n+    pub fn read_bool(&self, ptr: MemoryPointer) -> EvalResult<'tcx, bool> {\n         let bytes = self.get_bytes(ptr, 1, self.layout.i1_align.abi())?;\n         match bytes[0] {\n             0 => Ok(false),\n@@ -800,7 +800,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n     }\n \n-    pub fn write_bool(&mut self, ptr: Pointer, b: bool) -> EvalResult<'tcx> {\n+    pub fn write_bool(&mut self, ptr: MemoryPointer, b: bool) -> EvalResult<'tcx> {\n         let align = self.layout.i1_align.abi();\n         self.get_bytes_mut(ptr, 1, align)\n             .map(|bytes| bytes[0] = b as u8)\n@@ -817,88 +817,88 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n     }\n \n-    pub fn read_int(&self, ptr: Pointer, size: u64) -> EvalResult<'tcx, i128> {\n+    pub fn read_int(&self, ptr: MemoryPointer, size: u64) -> EvalResult<'tcx, i128> {\n         let align = self.int_align(size)?;\n         self.get_bytes(ptr, size, align).map(|b| read_target_int(self.endianess(), b).unwrap())\n     }\n \n-    pub fn write_int(&mut self, ptr: Pointer, n: i128, size: u64) -> EvalResult<'tcx> {\n+    pub fn write_int(&mut self, ptr: MemoryPointer, n: i128, size: u64) -> EvalResult<'tcx> {\n         let align = self.int_align(size)?;\n         let endianess = self.endianess();\n         let b = self.get_bytes_mut(ptr, size, align)?;\n         write_target_int(endianess, b, n).unwrap();\n         Ok(())\n     }\n \n-    pub fn read_uint(&self, ptr: Pointer, size: u64) -> EvalResult<'tcx, u128> {\n+    pub fn read_uint(&self, ptr: MemoryPointer, size: u64) -> EvalResult<'tcx, u128> {\n         let align = self.int_align(size)?;\n         self.get_bytes(ptr, size, align).map(|b| read_target_uint(self.endianess(), b).unwrap())\n     }\n \n-    pub fn write_uint(&mut self, ptr: Pointer, n: u128, size: u64) -> EvalResult<'tcx> {\n+    pub fn write_uint(&mut self, ptr: MemoryPointer, n: u128, size: u64) -> EvalResult<'tcx> {\n         let align = self.int_align(size)?;\n         let endianess = self.endianess();\n         let b = self.get_bytes_mut(ptr, size, align)?;\n         write_target_uint(endianess, b, n).unwrap();\n         Ok(())\n     }\n \n-    pub fn read_isize(&self, ptr: Pointer) -> EvalResult<'tcx, i64> {\n+    pub fn read_isize(&self, ptr: MemoryPointer) -> EvalResult<'tcx, i64> {\n         self.read_int(ptr, self.pointer_size()).map(|i| i as i64)\n     }\n \n-    pub fn write_isize(&mut self, ptr: Pointer, n: i64) -> EvalResult<'tcx> {\n+    pub fn write_isize(&mut self, ptr: MemoryPointer, n: i64) -> EvalResult<'tcx> {\n         let size = self.pointer_size();\n         self.write_int(ptr, n as i128, size)\n     }\n \n-    pub fn read_usize(&self, ptr: Pointer) -> EvalResult<'tcx, u64> {\n+    pub fn read_usize(&self, ptr: MemoryPointer) -> EvalResult<'tcx, u64> {\n         self.read_uint(ptr, self.pointer_size()).map(|i| i as u64)\n     }\n \n-    pub fn write_usize(&mut self, ptr: Pointer, n: u64) -> EvalResult<'tcx> {\n+    pub fn write_usize(&mut self, ptr: MemoryPointer, n: u64) -> EvalResult<'tcx> {\n         let size = self.pointer_size();\n         self.write_uint(ptr, n as u128, size)\n     }\n \n-    pub fn write_f32(&mut self, ptr: Pointer, f: f32) -> EvalResult<'tcx> {\n+    pub fn write_f32(&mut self, ptr: MemoryPointer, f: f32) -> EvalResult<'tcx> {\n         let endianess = self.endianess();\n         let align = self.layout.f32_align.abi();\n         let b = self.get_bytes_mut(ptr, 4, align)?;\n         write_target_f32(endianess, b, f).unwrap();\n         Ok(())\n     }\n \n-    pub fn write_f64(&mut self, ptr: Pointer, f: f64) -> EvalResult<'tcx> {\n+    pub fn write_f64(&mut self, ptr: MemoryPointer, f: f64) -> EvalResult<'tcx> {\n         let endianess = self.endianess();\n         let align = self.layout.f64_align.abi();\n         let b = self.get_bytes_mut(ptr, 8, align)?;\n         write_target_f64(endianess, b, f).unwrap();\n         Ok(())\n     }\n \n-    pub fn read_f32(&self, ptr: Pointer) -> EvalResult<'tcx, f32> {\n+    pub fn read_f32(&self, ptr: MemoryPointer) -> EvalResult<'tcx, f32> {\n         self.get_bytes(ptr, 4, self.layout.f32_align.abi())\n             .map(|b| read_target_f32(self.endianess(), b).unwrap())\n     }\n \n-    pub fn read_f64(&self, ptr: Pointer) -> EvalResult<'tcx, f64> {\n+    pub fn read_f64(&self, ptr: MemoryPointer) -> EvalResult<'tcx, f64> {\n         self.get_bytes(ptr, 8, self.layout.f64_align.abi())\n             .map(|b| read_target_f64(self.endianess(), b).unwrap())\n     }\n }\n \n /// Relocations\n impl<'a, 'tcx> Memory<'a, 'tcx> {\n-    fn relocations(&self, ptr: Pointer, size: u64)\n+    fn relocations(&self, ptr: MemoryPointer, size: u64)\n         -> EvalResult<'tcx, btree_map::Range<u64, AllocId>>\n     {\n         let start = ptr.offset.saturating_sub(self.pointer_size() - 1);\n         let end = ptr.offset + size;\n         Ok(self.get(ptr.alloc_id)?.relocations.range(start..end))\n     }\n \n-    fn clear_relocations(&mut self, ptr: Pointer, size: u64) -> EvalResult<'tcx> {\n+    fn clear_relocations(&mut self, ptr: MemoryPointer, size: u64) -> EvalResult<'tcx> {\n         // Find all relocations overlapping the given range.\n         let keys: Vec<_> = self.relocations(ptr, size)?.map(|(&k, _)| k).collect();\n         if keys.is_empty() { return Ok(()); }\n@@ -922,7 +922,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(())\n     }\n \n-    fn check_relocation_edges(&self, ptr: Pointer, size: u64) -> EvalResult<'tcx> {\n+    fn check_relocation_edges(&self, ptr: MemoryPointer, size: u64) -> EvalResult<'tcx> {\n         let overlapping_start = self.relocations(ptr, 0)?.count();\n         let overlapping_end = self.relocations(ptr.offset(size, self.layout)?, 0)?.count();\n         if overlapping_start + overlapping_end != 0 {\n@@ -931,7 +931,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(())\n     }\n \n-    fn copy_relocations(&mut self, src: Pointer, dest: Pointer, size: u64) -> EvalResult<'tcx> {\n+    fn copy_relocations(&mut self, src: MemoryPointer, dest: MemoryPointer, size: u64) -> EvalResult<'tcx> {\n         let relocations: Vec<_> = self.relocations(src, size)?\n             .map(|(&offset, &alloc_id)| {\n                 // Update relocation offsets for the new positions in the destination allocation.\n@@ -946,7 +946,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n /// Undefined bytes\n impl<'a, 'tcx> Memory<'a, 'tcx> {\n     // FIXME(solson): This is a very naive, slow version.\n-    fn copy_undef_mask(&mut self, src: Pointer, dest: Pointer, size: u64) -> EvalResult<'tcx> {\n+    fn copy_undef_mask(&mut self, src: MemoryPointer, dest: MemoryPointer, size: u64) -> EvalResult<'tcx> {\n         // The bits have to be saved locally before writing to dest in case src and dest overlap.\n         assert_eq!(size as usize as u64, size);\n         let mut v = Vec::with_capacity(size as usize);\n@@ -960,7 +960,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(())\n     }\n \n-    fn check_defined(&self, ptr: Pointer, size: u64) -> EvalResult<'tcx> {\n+    fn check_defined(&self, ptr: MemoryPointer, size: u64) -> EvalResult<'tcx> {\n         let alloc = self.get(ptr.alloc_id)?;\n         if !alloc.undef_mask.is_range_defined(ptr.offset, ptr.offset + size) {\n             return Err(EvalError::ReadUndefBytes);"}, {"sha": "c0369a785b1f2cc1eaa1769a98eca3775e0ba8fa", "filename": "src/operator.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2d52054fb28a81d351b09330496c749775790b63/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d52054fb28a81d351b09330496c749775790b63/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=2d52054fb28a81d351b09330496c749775790b63", "patch": "@@ -3,7 +3,7 @@ use rustc::ty::{self, Ty};\n \n use error::{EvalError, EvalResult};\n use eval_context::EvalContext;\n-use memory::Pointer;\n+use memory::MemoryPointer;\n use lvalue::Lvalue;\n use value::{\n     PrimVal,\n@@ -297,13 +297,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     fn ptr_int_arithmetic(\n         &self,\n         bin_op: mir::BinOp,\n-        left: Pointer,\n+        left: MemoryPointer,\n         right: i128,\n         signed: bool,\n     ) -> EvalResult<'tcx, (PrimVal, bool)> {\n         use rustc::mir::BinOp::*;\n \n-        fn map_to_primval((res, over) : (Pointer, bool)) -> (PrimVal, bool) {\n+        fn map_to_primval((res, over) : (MemoryPointer, bool)) -> (PrimVal, bool) {\n             (PrimVal::Ptr(res), over)\n         }\n \n@@ -321,7 +321,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let right = right as u64;\n                 if right & base_mask == base_mask {\n                     // Case 1: The base address bits are all preserved, i.e., right is all-1 there\n-                    (PrimVal::Ptr(Pointer::new(left.alloc_id, left.offset & right)), false)\n+                    (PrimVal::Ptr(MemoryPointer::new(left.alloc_id, left.offset & right)), false)\n                 } else if right & base_mask == 0 {\n                     // Case 2: The base address bits are all taken away, i.e., right is all-0 there\n                     (PrimVal::from_u128((left.offset & right) as u128), false)"}, {"sha": "ad79767afa256b7c8c5a94a85f4416d6a167e9c2", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2d52054fb28a81d351b09330496c749775790b63/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d52054fb28a81d351b09330496c749775790b63/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=2d52054fb28a81d351b09330496c749775790b63", "patch": "@@ -9,7 +9,7 @@ use syntax::abi::Abi;\n use error::{EvalError, EvalResult};\n use eval_context::{EvalContext, IntegerExt, StackPopCleanup, is_inhabited};\n use lvalue::Lvalue;\n-use memory::{Pointer, TlsKey};\n+use memory::{MemoryPointer, TlsKey};\n use value::PrimVal;\n use value::Value;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -461,7 +461,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(false)\n     }\n \n-    pub fn read_discriminant_value(&self, adt_ptr: Pointer, adt_ty: Ty<'tcx>) -> EvalResult<'tcx, u128> {\n+    pub fn read_discriminant_value(&self, adt_ptr: MemoryPointer, adt_ty: Ty<'tcx>) -> EvalResult<'tcx, u128> {\n         use rustc::ty::layout::Layout::*;\n         let adt_layout = self.type_layout(adt_ty)?;\n         trace!(\"read_discriminant_value {:#?}\", adt_layout);\n@@ -500,7 +500,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(discr_val)\n     }\n \n-    fn read_nonnull_discriminant_value(&self, ptr: Pointer, nndiscr: u128, discr_size: u64) -> EvalResult<'tcx, u128> {\n+    fn read_nonnull_discriminant_value(&self, ptr: MemoryPointer, nndiscr: u128, discr_size: u64) -> EvalResult<'tcx, u128> {\n         trace!(\"read_nonnull_discriminant_value: {:?}, {}, {}\", ptr, nndiscr, discr_size);\n         let not_null = match self.memory.read_uint(ptr, discr_size) {\n             Ok(0) => false,"}, {"sha": "bfb923510bbb368f96ec185f92e919bf0a4bf359", "filename": "src/traits.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2d52054fb28a81d351b09330496c749775790b63/src%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d52054fb28a81d351b09330496c749775790b63/src%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftraits.rs?ref=2d52054fb28a81d351b09330496c749775790b63", "patch": "@@ -1,7 +1,7 @@\n use rustc::traits::{self, Reveal};\n \n use eval_context::EvalContext;\n-use memory::Pointer;\n+use memory::MemoryPointer;\n use value::{Value, PrimVal};\n \n use rustc::hir::def_id::DefId;\n@@ -43,7 +43,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     /// The `trait_ref` encodes the erased self type. Hence if we are\n     /// making an object `Foo<Trait>` from a value of type `Foo<T>`, then\n     /// `trait_ref` would map `T:Trait`.\n-    pub fn get_vtable(&mut self, ty: Ty<'tcx>, trait_ref: ty::PolyTraitRef<'tcx>) -> EvalResult<'tcx, Pointer> {\n+    pub fn get_vtable(&mut self, ty: Ty<'tcx>, trait_ref: ty::PolyTraitRef<'tcx>) -> EvalResult<'tcx, MemoryPointer> {\n         debug!(\"get_vtable(trait_ref={:?})\", trait_ref);\n \n         let size = self.type_size(trait_ref.self_ty())?.expect(\"can't create a vtable for an unsized type\");\n@@ -73,7 +73,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(vtable)\n     }\n \n-    pub fn read_drop_type_from_vtable(&self, vtable: Pointer) -> EvalResult<'tcx, Option<ty::Instance<'tcx>>> {\n+    pub fn read_drop_type_from_vtable(&self, vtable: MemoryPointer) -> EvalResult<'tcx, Option<ty::Instance<'tcx>>> {\n         // we don't care about the pointee type, we just want a pointer\n         match self.read_ptr(vtable, self.tcx.mk_nil_ptr())? {\n             // some values don't need to call a drop impl, so the value is null\n@@ -83,7 +83,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    pub fn read_size_and_align_from_vtable(&self, vtable: Pointer) -> EvalResult<'tcx, (u64, u64)> {\n+    pub fn read_size_and_align_from_vtable(&self, vtable: MemoryPointer) -> EvalResult<'tcx, (u64, u64)> {\n         let pointer_size = self.memory.pointer_size();\n         let size = self.memory.read_usize(vtable.offset(pointer_size, self.memory.layout)?)?;\n         let align = self.memory.read_usize(vtable.offset(pointer_size * 2, self.memory.layout)?)?;"}, {"sha": "a783f989364406b9b1cb788efcb6ce7bd83e8be4", "filename": "src/value.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2d52054fb28a81d351b09330496c749775790b63/src%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d52054fb28a81d351b09330496c749775790b63/src%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue.rs?ref=2d52054fb28a81d351b09330496c749775790b63", "patch": "@@ -5,7 +5,7 @@ use std::mem::transmute;\n use rustc::ty::layout::TargetDataLayout;\n \n use error::{EvalError, EvalResult};\n-use memory::{Memory, Pointer};\n+use memory::{Memory, MemoryPointer};\n \n pub(super) fn bytes_to_f32(bytes: u128) -> f32 {\n     unsafe { transmute::<u32, f32>(bytes as u32) }\n@@ -49,8 +49,8 @@ pub enum PrimVal {\n \n     /// A pointer into an `Allocation`. An `Allocation` in the `memory` module has a list of\n     /// relocations, but a `PrimVal` is only large enough to contain one, so we just represent the\n-    /// relocation and its associated offset together as a `Pointer` here.\n-    Ptr(Pointer),\n+    /// relocation and its associated offset together as a `MemoryPointer` here.\n+    Ptr(MemoryPointer),\n \n     /// An undefined `PrimVal`, for representing values that aren't safe to examine, but are safe\n     /// to copy around, just like undefined bytes in an `Allocation`.\n@@ -80,7 +80,7 @@ impl<'a, 'tcx: 'a> Value {\n     pub(super) fn expect_ptr_vtable_pair(\n         &self,\n         mem: &Memory<'a, 'tcx>\n-    ) -> EvalResult<'tcx, (PrimVal, Pointer)> {\n+    ) -> EvalResult<'tcx, (PrimVal, MemoryPointer)> {\n         use self::Value::*;\n         match *self {\n             ByRef(ref_ptr) => {\n@@ -146,7 +146,7 @@ impl<'tcx> PrimVal {\n         }\n     }\n \n-    pub fn to_ptr(self) -> EvalResult<'tcx, Pointer> {\n+    pub fn to_ptr(self) -> EvalResult<'tcx, MemoryPointer> {\n         match self {\n             PrimVal::Bytes(_) => Err(EvalError::ReadBytesAsPointer),\n             PrimVal::Ptr(p) => Ok(p),"}]}