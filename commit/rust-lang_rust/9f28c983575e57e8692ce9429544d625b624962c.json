{"sha": "9f28c983575e57e8692ce9429544d625b624962c", "node_id": "C_kwDOAAsO6NoAKDlmMjhjOTgzNTc1ZTU3ZTg2OTJjZTk0Mjk1NDRkNjI1YjYyNDk2MmM", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-03-29T19:19:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-03-29T19:19:48Z"}, "message": "Rollup merge of #109511 - compiler-errors:eval-ctxt-infcx-private, r=lcnr\n\nMake `EvalCtxt`'s `infcx` private\n\nTo better protect against people doing bad things with the inner `InferCtxt`\n\nr? `@lcnr`", "tree": {"sha": "230a4b431f63cf53fe3ee89825056171bde688d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/230a4b431f63cf53fe3ee89825056171bde688d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f28c983575e57e8692ce9429544d625b624962c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkJI9UCRBK7hj4Ov3rIwAA79wIAK9Fh5EqgrEtOVuKhOxQhmCD\nVsM0YfIJmJ/QJ1VuHQZBLG+fOoFZbXBkkDbD1H/Txjk3VQ3fFoUvXmcmd9ZasfeU\ne3UxaB+eipTnizD9Mj8pFMQ2nQ1yXnCp49f9xLWfhbQTPgdedRjtsASwdeWx+frI\nB2X6LpaTyhSWg1AF554Tu32lIOHY+6kNTiRakUuRZ0MVoir5WOaNcB2hhqiK8oDC\nANhXAl0OwbBsIObpnjic5vDovERFHlhKmSCvEB6Y0VzmfMasfuFued+L0X/XSukx\npzra+G91Zj8W6Bh5bIDZk3Imksr2//oz2Ss+6Vc6on/aBe8BzMEDY9v6NlKLqa8=\n=34ID\n-----END PGP SIGNATURE-----\n", "payload": "tree 230a4b431f63cf53fe3ee89825056171bde688d3\nparent 57f1d114cdf891e65b6659af1091e2b5b6b6e723\nparent a61616a016aadb41cb18cc898f1ce9ff70709607\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1680117588 +0200\ncommitter GitHub <noreply@github.com> 1680117588 +0200\n\nRollup merge of #109511 - compiler-errors:eval-ctxt-infcx-private, r=lcnr\n\nMake `EvalCtxt`'s `infcx` private\n\nTo better protect against people doing bad things with the inner `InferCtxt`\n\nr? `@lcnr`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f28c983575e57e8692ce9429544d625b624962c", "html_url": "https://github.com/rust-lang/rust/commit/9f28c983575e57e8692ce9429544d625b624962c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f28c983575e57e8692ce9429544d625b624962c/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57f1d114cdf891e65b6659af1091e2b5b6b6e723", "url": "https://api.github.com/repos/rust-lang/rust/commits/57f1d114cdf891e65b6659af1091e2b5b6b6e723", "html_url": "https://github.com/rust-lang/rust/commit/57f1d114cdf891e65b6659af1091e2b5b6b6e723"}, {"sha": "a61616a016aadb41cb18cc898f1ce9ff70709607", "url": "https://api.github.com/repos/rust-lang/rust/commits/a61616a016aadb41cb18cc898f1ce9ff70709607", "html_url": "https://github.com/rust-lang/rust/commit/a61616a016aadb41cb18cc898f1ce9ff70709607"}], "stats": {"total": 134, "additions": 84, "deletions": 50}, "files": [{"sha": "7ee4f33230630d0a55a93f0000985a8301708aa9", "filename": "compiler/rustc_trait_selection/src/solve/canonicalize.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9f28c983575e57e8692ce9429544d625b624962c/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonicalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f28c983575e57e8692ce9429544d625b624962c/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonicalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonicalize.rs?ref=9f28c983575e57e8692ce9429544d625b624962c", "previous_filename": "compiler/rustc_trait_selection/src/solve/canonical/canonicalize.rs"}, {"sha": "e64b4a7656f256dc0bbe5b4230bfc951b719cec1", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 62, "deletions": 7, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/9f28c983575e57e8692ce9429544d625b624962c/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f28c983575e57e8692ce9429544d625b624962c/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=9f28c983575e57e8692ce9429544d625b624962c", "patch": "@@ -6,23 +6,42 @@ use rustc_infer::infer::{\n     DefineOpaqueTypes, InferCtxt, InferOk, LateBoundRegionConversionTime, TyCtxtInferExt,\n };\n use rustc_infer::traits::query::NoSolution;\n-use rustc_infer::traits::solve::{CanonicalGoal, Certainty, MaybeCause, QueryResult};\n use rustc_infer::traits::ObligationCause;\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n+use rustc_middle::traits::solve::{CanonicalGoal, Certainty, MaybeCause, QueryResult};\n use rustc_middle::ty::{\n     self, Ty, TyCtxt, TypeFoldable, TypeSuperVisitable, TypeVisitable, TypeVisitableExt,\n     TypeVisitor,\n };\n use rustc_span::DUMMY_SP;\n use std::ops::ControlFlow;\n \n+use crate::traits::specialization_graph;\n+\n use super::search_graph::{self, OverflowHandler};\n use super::SolverMode;\n use super::{search_graph::SearchGraph, Goal};\n \n+mod canonical;\n+\n pub struct EvalCtxt<'a, 'tcx> {\n-    // FIXME: should be private.\n-    pub(super) infcx: &'a InferCtxt<'tcx>,\n+    /// The inference context that backs (mostly) inference and placeholder terms\n+    /// instantiated while solving goals.\n+    ///\n+    /// NOTE: The `InferCtxt` that backs the `EvalCtxt` is intentionally private,\n+    /// because the `InferCtxt` is much more general than `EvalCtxt`. Methods such\n+    /// as  `take_registered_region_obligations` can mess up query responses,\n+    /// using `At::normalize` is totally wrong, calling `evaluate_root_goal` can\n+    /// cause coinductive unsoundness, etc.\n+    ///\n+    /// Methods that are generally of use for trait solving are *intentionally*\n+    /// re-declared through the `EvalCtxt` below, often with cleaner signatures\n+    /// since we don't care about things like `ObligationCause`s and `Span`s here.\n+    /// If some `InferCtxt` method is missing, please first think defensively about\n+    /// the method's compatibility with this solver, or if an existing one does\n+    /// the job already.\n+    infcx: &'a InferCtxt<'tcx>,\n+\n     pub(super) var_values: CanonicalVarValues<'tcx>,\n     /// The highest universe index nameable by the caller.\n     ///\n@@ -393,7 +412,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n                 if let &ty::Infer(ty::TyVar(vid)) = ty.kind() {\n                     match self.infcx.probe_ty_var(vid) {\n                         Ok(value) => bug!(\"resolved var in query: {goal:?} {value:?}\"),\n-                        Err(universe) => universe == self.universe(),\n+                        Err(universe) => universe == self.infcx.universe(),\n                     }\n                 } else {\n                     false\n@@ -403,7 +422,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n                 if let ty::ConstKind::Infer(ty::InferConst::Var(vid)) = ct.kind() {\n                     match self.infcx.probe_const_var(vid) {\n                         Ok(value) => bug!(\"resolved var in query: {goal:?} {value:?}\"),\n-                        Err(universe) => universe == self.universe(),\n+                        Err(universe) => universe == self.infcx.universe(),\n                     }\n                 } else {\n                     false\n@@ -545,7 +564,43 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         self.infcx.fresh_substs_for_item(DUMMY_SP, def_id)\n     }\n \n-    pub(super) fn universe(&self) -> ty::UniverseIndex {\n-        self.infcx.universe()\n+    pub(super) fn translate_substs(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        source_impl: DefId,\n+        source_substs: ty::SubstsRef<'tcx>,\n+        target_node: specialization_graph::Node,\n+    ) -> ty::SubstsRef<'tcx> {\n+        crate::traits::translate_substs(\n+            self.infcx,\n+            param_env,\n+            source_impl,\n+            source_substs,\n+            target_node,\n+        )\n+    }\n+\n+    pub(super) fn register_ty_outlives(&self, ty: Ty<'tcx>, lt: ty::Region<'tcx>) {\n+        self.infcx.register_region_obligation_with_cause(ty, lt, &ObligationCause::dummy());\n+    }\n+\n+    pub(super) fn register_region_outlives(&self, a: ty::Region<'tcx>, b: ty::Region<'tcx>) {\n+        // `b : a` ==> `a <= b`\n+        // (inlined from `InferCtxt::region_outlives_predicate`)\n+        self.infcx.sub_regions(\n+            rustc_infer::infer::SubregionOrigin::RelateRegionParamBound(DUMMY_SP),\n+            b,\n+            a,\n+        );\n+    }\n+\n+    /// Computes the list of goals required for `arg` to be well-formed\n+    pub(super) fn well_formed_goals(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        arg: ty::GenericArg<'tcx>,\n+    ) -> Option<impl Iterator<Item = Goal<'tcx, ty::Predicate<'tcx>>>> {\n+        crate::traits::wf::unnormalized_obligations(self.infcx, param_env, arg)\n+            .map(|obligations| obligations.into_iter().map(|obligation| obligation.into()))\n     }\n }"}, {"sha": "ee90488730a645cfa941ea5ac18442a2a22b235a", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt/canonical.rs", "status": "renamed", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9f28c983575e57e8692ce9429544d625b624962c/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f28c983575e57e8692ce9429544d625b624962c/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs?ref=9f28c983575e57e8692ce9429544d625b624962c", "patch": "@@ -8,22 +8,19 @@\n /// section of the [rustc-dev-guide][c].\n ///\n /// [c]: https://rustc-dev-guide.rust-lang.org/solve/canonicalization.html\n-use self::canonicalize::{CanonicalizeMode, Canonicalizer};\n use super::{CanonicalGoal, Certainty, EvalCtxt, Goal};\n-use super::{CanonicalResponse, ExternalConstraints, QueryResult, Response};\n+use crate::solve::canonicalize::{CanonicalizeMode, Canonicalizer};\n+use crate::solve::{CanonicalResponse, QueryResult, Response};\n use rustc_infer::infer::canonical::query_response::make_query_region_constraints;\n use rustc_infer::infer::canonical::CanonicalVarValues;\n use rustc_infer::infer::canonical::{CanonicalExt, QueryRegionConstraints};\n-use rustc_infer::traits::query::NoSolution;\n-use rustc_infer::traits::solve::ExternalConstraintsData;\n-use rustc_infer::traits::ObligationCause;\n+use rustc_middle::traits::query::NoSolution;\n+use rustc_middle::traits::solve::{ExternalConstraints, ExternalConstraintsData};\n use rustc_middle::ty::{self, GenericArgKind};\n use rustc_span::DUMMY_SP;\n use std::iter;\n use std::ops::Deref;\n \n-mod canonicalize;\n-\n impl<'tcx> EvalCtxt<'_, 'tcx> {\n     /// Canonicalizes the goal remembering the original values\n     /// for each bound variable.\n@@ -48,7 +45,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n     /// - `external_constraints`: additional constraints which aren't expressable\n     ///   using simple unification of inference variables.\n     #[instrument(level = \"debug\", skip(self))]\n-    pub(super) fn evaluate_added_goals_and_make_canonical_response(\n+    pub(in crate::solve) fn evaluate_added_goals_and_make_canonical_response(\n         &mut self,\n         certainty: Certainty,\n     ) -> QueryResult<'tcx> {\n@@ -219,15 +216,8 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n     fn register_region_constraints(&mut self, region_constraints: &QueryRegionConstraints<'tcx>) {\n         for &(ty::OutlivesPredicate(lhs, rhs), _) in &region_constraints.outlives {\n             match lhs.unpack() {\n-                GenericArgKind::Lifetime(lhs) => self.infcx.region_outlives_predicate(\n-                    &ObligationCause::dummy(),\n-                    ty::Binder::dummy(ty::OutlivesPredicate(lhs, rhs)),\n-                ),\n-                GenericArgKind::Type(lhs) => self.infcx.register_region_obligation_with_cause(\n-                    lhs,\n-                    rhs,\n-                    &ObligationCause::dummy(),\n-                ),\n+                GenericArgKind::Lifetime(lhs) => self.register_region_outlives(lhs, rhs),\n+                GenericArgKind::Type(lhs) => self.register_ty_outlives(lhs, rhs),\n                 GenericArgKind::Const(_) => bug!(\"const outlives: {lhs:?}: {rhs:?}\"),\n             }\n         }", "previous_filename": "compiler/rustc_trait_selection/src/solve/canonical/mod.rs"}, {"sha": "a96ec2c60f0970b85eed9a140d7ed3d1bbdbc8af", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9f28c983575e57e8692ce9429544d625b624962c/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f28c983575e57e8692ce9429544d625b624962c/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=9f28c983575e57e8692ce9429544d625b624962c", "patch": "@@ -13,18 +13,15 @@ use rustc_hir::def_id::DefId;\n use rustc_infer::infer::canonical::{Canonical, CanonicalVarValues};\n use rustc_infer::traits::query::NoSolution;\n use rustc_middle::traits::solve::{\n-    CanonicalGoal, CanonicalResponse, Certainty, ExternalConstraints, ExternalConstraintsData,\n-    Goal, QueryResult, Response,\n+    CanonicalResponse, Certainty, ExternalConstraintsData, Goal, QueryResult, Response,\n };\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::ty::{\n     CoercePredicate, RegionOutlivesPredicate, SubtypePredicate, TypeOutlivesPredicate,\n };\n \n-use crate::traits::ObligationCause;\n-\n mod assembly;\n-mod canonical;\n+mod canonicalize;\n mod eval_ctxt;\n mod fulfill;\n mod project_goals;\n@@ -66,7 +63,7 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         goal: Goal<'tcx, TypeOutlivesPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n         let ty::OutlivesPredicate(ty, lt) = goal.predicate;\n-        self.infcx.register_region_obligation_with_cause(ty, lt, &ObligationCause::dummy());\n+        self.register_ty_outlives(ty, lt);\n         self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n     }\n \n@@ -75,10 +72,8 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         &mut self,\n         goal: Goal<'tcx, RegionOutlivesPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n-        self.infcx.region_outlives_predicate(\n-            &ObligationCause::dummy(),\n-            ty::Binder::dummy(goal.predicate),\n-        );\n+        let ty::OutlivesPredicate(a, b) = goal.predicate;\n+        self.register_region_outlives(a, b);\n         self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n     }\n \n@@ -142,13 +137,9 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         &mut self,\n         goal: Goal<'tcx, ty::GenericArg<'tcx>>,\n     ) -> QueryResult<'tcx> {\n-        match crate::traits::wf::unnormalized_obligations(\n-            self.infcx,\n-            goal.param_env,\n-            goal.predicate,\n-        ) {\n-            Some(obligations) => {\n-                self.add_goals(obligations.into_iter().map(|o| o.into()));\n+        match self.well_formed_goals(goal.param_env, goal.predicate) {\n+            Some(goals) => {\n+                self.add_goals(goals);\n                 self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n             }\n             None => self.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS),"}, {"sha": "48f7d3e3e40239ac0ceafb1fde1c5563fba3af19", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9f28c983575e57e8692ce9429544d625b624962c/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f28c983575e57e8692ce9429544d625b624962c/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=9f28c983575e57e8692ce9429544d625b624962c", "patch": "@@ -1,4 +1,4 @@\n-use crate::traits::{specialization_graph, translate_substs};\n+use crate::traits::specialization_graph;\n \n use super::assembly;\n use super::trait_goals::structural_traits;\n@@ -7,7 +7,6 @@ use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n use rustc_hir::LangItem;\n-use rustc_infer::infer::InferCtxt;\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::specialization_graph::LeafDef;\n use rustc_infer::traits::Reveal;\n@@ -165,7 +164,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n             // return ambiguity this would otherwise be incomplete, resulting in\n             // unsoundness during coherence (#105782).\n             let Some(assoc_def) = fetch_eligible_assoc_item_def(\n-                ecx.infcx,\n+                ecx,\n                 goal.param_env,\n                 goal_trait_ref,\n                 goal.predicate.def_id(),\n@@ -196,8 +195,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 goal_trait_ref.def_id,\n                 impl_substs,\n             );\n-            let substs = translate_substs(\n-                ecx.infcx,\n+            let substs = ecx.translate_substs(\n                 goal.param_env,\n                 impl_def_id,\n                 impl_substs_with_gat,\n@@ -504,15 +502,15 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n ///\n /// FIXME: We should merge these 3 implementations as it's likely that they otherwise\n /// diverge.\n-#[instrument(level = \"debug\", skip(infcx, param_env), ret)]\n+#[instrument(level = \"debug\", skip(ecx, param_env), ret)]\n fn fetch_eligible_assoc_item_def<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n+    ecx: &EvalCtxt<'_, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     goal_trait_ref: ty::TraitRef<'tcx>,\n     trait_assoc_def_id: DefId,\n     impl_def_id: DefId,\n ) -> Result<Option<LeafDef>, NoSolution> {\n-    let node_item = specialization_graph::assoc_def(infcx.tcx, impl_def_id, trait_assoc_def_id)\n+    let node_item = specialization_graph::assoc_def(ecx.tcx(), impl_def_id, trait_assoc_def_id)\n         .map_err(|ErrorGuaranteed { .. }| NoSolution)?;\n \n     let eligible = if node_item.is_final() {\n@@ -524,7 +522,7 @@ fn fetch_eligible_assoc_item_def<'tcx>(\n         // transmute checking and polymorphic MIR optimizations could\n         // get a result which isn't correct for all monomorphizations.\n         if param_env.reveal() == Reveal::All {\n-            let poly_trait_ref = infcx.resolve_vars_if_possible(goal_trait_ref);\n+            let poly_trait_ref = ecx.resolve_vars_if_possible(goal_trait_ref);\n             !poly_trait_ref.still_further_specializable()\n         } else {\n             debug!(?node_item.item.def_id, \"not eligible due to default\");"}]}