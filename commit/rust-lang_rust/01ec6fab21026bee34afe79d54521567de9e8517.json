{"sha": "01ec6fab21026bee34afe79d54521567de9e8517", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxZWM2ZmFiMjEwMjZiZWUzNGFmZTc5ZDU0NTIxNTY3ZGU5ZTg1MTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-18T00:46:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-18T00:46:10Z"}, "message": "auto merge of #16559 : Gankro/rust/bitv, r=pcwalton\n\nThese were the only differing-size-based errors I noticed. Might be more.", "tree": {"sha": "8d56b2c62e963fc461251348ba91768aa5fabea2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d56b2c62e963fc461251348ba91768aa5fabea2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01ec6fab21026bee34afe79d54521567de9e8517", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01ec6fab21026bee34afe79d54521567de9e8517", "html_url": "https://github.com/rust-lang/rust/commit/01ec6fab21026bee34afe79d54521567de9e8517", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01ec6fab21026bee34afe79d54521567de9e8517/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d8738f9b52b62991e9c7b44a9d01a13c1398475", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d8738f9b52b62991e9c7b44a9d01a13c1398475", "html_url": "https://github.com/rust-lang/rust/commit/0d8738f9b52b62991e9c7b44a9d01a13c1398475"}, {"sha": "8c9bdda89b93bcb4c3b0ffb1b91b9c73318c5304", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c9bdda89b93bcb4c3b0ffb1b91b9c73318c5304", "html_url": "https://github.com/rust-lang/rust/commit/8c9bdda89b93bcb4c3b0ffb1b91b9c73318c5304"}], "stats": {"total": 117, "additions": 114, "deletions": 3}, "files": [{"sha": "1b3c6e148cdc456c8f476457e8deae578a7b4773", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 114, "deletions": 3, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/01ec6fab21026bee34afe79d54521567de9e8517/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01ec6fab21026bee34afe79d54521567de9e8517/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=01ec6fab21026bee34afe79d54521567de9e8517", "patch": "@@ -75,6 +75,25 @@ use std::hash;\n use {Mutable, Set, MutableSet, MutableSeq};\n use vec::Vec;\n \n+// Take two BitV's, and return iterators of their words, where the shorter one\n+// has been padded with 0's\n+macro_rules! match_words(\n+    ($a_expr:expr, $b_expr:expr) => ({\n+        let a = $a_expr;\n+        let b = $b_expr;\n+        let a_len = a.storage.len();\n+        let b_len = b.storage.len();\n+\n+        // have to uselessly pretend to pad the longer one for type matching\n+        if a_len < b_len {\n+            (a.mask_words(0).chain(iter::Repeat::new(0u).enumerate().take(b_len).skip(a_len)),\n+             b.mask_words(0).chain(iter::Repeat::new(0u).enumerate().take(0).skip(0)))\n+        } else {\n+            (a.mask_words(0).chain(iter::Repeat::new(0u).enumerate().take(0).skip(0)),\n+             b.mask_words(0).chain(iter::Repeat::new(0u).enumerate().take(a_len).skip(b_len)))\n+        }\n+    })\n+)\n \n static TRUE: bool = true;\n static FALSE: bool = false;\n@@ -969,7 +988,7 @@ impl<'a> RandomAccessIterator<bool> for Bits<'a> {\n /// assert!(bv.eq_vec([true, true, false, true,\n ///                    false, false, false, false]));\n /// ```\n-#[deriving(Clone, PartialEq, Eq, PartialOrd, Ord)]\n+#[deriving(Clone)]\n pub struct BitvSet(Bitv);\n \n impl Default for BitvSet {\n@@ -992,6 +1011,32 @@ impl Extendable<bool> for BitvSet {\n     }\n }\n \n+impl PartialOrd for BitvSet {\n+    #[inline]\n+    fn partial_cmp(&self, other: &BitvSet) -> Option<Ordering> {\n+        let (a_iter, b_iter) = match_words!(self.get_ref(), other.get_ref());\n+        iter::order::partial_cmp(a_iter, b_iter)\n+    }\n+}\n+\n+impl Ord for BitvSet {\n+    #[inline]\n+    fn cmp(&self, other: &BitvSet) -> Ordering {\n+        let (a_iter, b_iter) = match_words!(self.get_ref(), other.get_ref());\n+        iter::order::cmp(a_iter, b_iter)\n+    }\n+}\n+\n+impl cmp::PartialEq for BitvSet {\n+    #[inline]\n+    fn eq(&self, other: &BitvSet) -> bool {\n+        let (a_iter, b_iter) = match_words!(self.get_ref(), other.get_ref());\n+        iter::order::eq(a_iter, b_iter)\n+    }\n+}\n+\n+impl cmp::Eq for BitvSet {}\n+\n impl BitvSet {\n     /// Create a new bit vector set with initially no contents.\n     ///\n@@ -1141,10 +1186,18 @@ impl BitvSet {\n         // Unwrap Bitvs\n         let &BitvSet(ref mut self_bitv) = self;\n         let &BitvSet(ref other_bitv) = other;\n+\n         // Expand the vector if necessary\n         self_bitv.reserve(other_bitv.capacity());\n-        // Apply values\n-        for (i, w) in other_bitv.mask_words(0) {\n+\n+        // virtually pad other with 0's for equal lengths\n+        let self_len = self_bitv.storage.len();\n+        let other_len =  other_bitv.storage.len();\n+        let mut other_words = other_bitv.mask_words(0)\n+         .chain(iter::Repeat::new(0u).enumerate().take(self_len).skip(other_len));\n+\n+        // Apply values found in other\n+        for (i, w) in other_words {\n             let old = self_bitv.storage[i];\n             let new = f(old, w);\n             *self_bitv.storage.get_mut(i) = new;\n@@ -2213,6 +2266,64 @@ mod tests {\n         assert!(set1.is_subset(&set2)); // { 2 }  { 2, 4 }\n     }\n \n+    #[test]\n+    fn test_bitv_set_intersect_with() {\n+        // Explicitly 0'ed bits\n+        let mut a = BitvSet::from_bitv(from_bytes([0b10100010]));\n+        let mut b = BitvSet::from_bitv(from_bytes([0b00000000]));\n+        let c = a.clone();\n+        a.intersect_with(&b);\n+        b.intersect_with(&c);\n+        assert!(a.is_empty());\n+        assert!(b.is_empty());\n+\n+        // Uninitialized bits should behave like 0's\n+        let mut a = BitvSet::from_bitv(from_bytes([0b10100010]));\n+        let mut b = BitvSet::new();\n+        let c = a.clone();\n+        a.intersect_with(&b);\n+        b.intersect_with(&c);\n+        assert!(a.is_empty());\n+        assert!(b.is_empty());\n+\n+        // Standard\n+        let mut a = BitvSet::from_bitv(from_bytes([0b10100010]));\n+        let mut b = BitvSet::from_bitv(from_bytes([0b01100010]));\n+        let c = a.clone();\n+        a.intersect_with(&b);\n+        b.intersect_with(&c);\n+        assert_eq!(a.len(), 2);\n+        assert_eq!(b.len(), 2);\n+    }\n+\n+    #[test]\n+    fn test_bitv_set_eq() {\n+        let a = BitvSet::from_bitv(from_bytes([0b10100010]));\n+        let b = BitvSet::from_bitv(from_bytes([0b00000000]));\n+        let c = BitvSet::new();\n+\n+        assert!(a == a);\n+        assert!(a != b);\n+        assert!(a != c);\n+        assert!(b == b);\n+        assert!(b == c);\n+        assert!(c == c);\n+    }\n+\n+    #[test]\n+    fn test_bitv_set_cmp() {\n+        let a = BitvSet::from_bitv(from_bytes([0b10100010]));\n+        let b = BitvSet::from_bitv(from_bytes([0b00000000]));\n+        let c = BitvSet::new();\n+\n+        assert_eq!(a.cmp(&b), Greater);\n+        assert_eq!(a.cmp(&c), Greater);\n+        assert_eq!(b.cmp(&a), Less);\n+        assert_eq!(b.cmp(&c), Equal);\n+        assert_eq!(c.cmp(&a), Less);\n+        assert_eq!(c.cmp(&b), Equal);\n+    }\n+\n     #[test]\n     fn test_bitv_remove() {\n         let mut a = BitvSet::new();"}]}