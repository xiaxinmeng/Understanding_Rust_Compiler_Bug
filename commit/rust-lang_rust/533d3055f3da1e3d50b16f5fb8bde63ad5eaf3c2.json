{"sha": "533d3055f3da1e3d50b16f5fb8bde63ad5eaf3c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzM2QzMDU1ZjNkYTFlM2Q1MGIxNmY1ZmI4YmRlNjNhZDVlYWYzYzI=", "commit": {"author": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2011-05-19T18:37:17Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-19T19:13:35Z"}, "message": "No functional change. Largely removed the native module/non-native module distinction from resolve.rs", "tree": {"sha": "cb103ffbb4a9b3cec57131420edcc65ef9a25945", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb103ffbb4a9b3cec57131420edcc65ef9a25945"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/533d3055f3da1e3d50b16f5fb8bde63ad5eaf3c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/533d3055f3da1e3d50b16f5fb8bde63ad5eaf3c2", "html_url": "https://github.com/rust-lang/rust/commit/533d3055f3da1e3d50b16f5fb8bde63ad5eaf3c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/533d3055f3da1e3d50b16f5fb8bde63ad5eaf3c2/comments", "author": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38b37fcbdb4d62982e6d326abc0323d75aeceb43", "url": "https://api.github.com/repos/rust-lang/rust/commits/38b37fcbdb4d62982e6d326abc0323d75aeceb43", "html_url": "https://github.com/rust-lang/rust/commit/38b37fcbdb4d62982e6d326abc0323d75aeceb43"}], "stats": {"total": 130, "additions": 45, "deletions": 85}, "files": [{"sha": "853d93cd81f0c99ce953f5cc3bbaa3ca06c5cc1b", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 45, "deletions": 85, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/533d3055f3da1e3d50b16f5fb8bde63ad5eaf3c2/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/533d3055f3da1e3d50b16f5fb8bde63ad5eaf3c2/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=533d3055f3da1e3d50b16f5fb8bde63ad5eaf3c2", "patch": "@@ -70,24 +70,20 @@ fn new_ext_hash() -> ext_hash {\n tag mod_index_entry {\n     mie_view_item(@ast::view_item);\n     mie_item(@ast::item);\n+    mie_native_item(@ast::native_item);\n     mie_tag_variant(@ast::item /* tag item */, uint /* variant index */);\n }\n type mod_index = hashmap[ident,list[mod_index_entry]];\n-type indexed_mod = rec(ast::_mod m, mod_index index);\n+type indexed_mod = rec(option::t[ast::_mod] m, mod_index index);\n+/* native modules can't contain tags, and we don't store their ASTs because we\n+   only need to look at them to determine exports, which they can't control.*/\n \n-tag nmod_index_entry {\n-    nmie_view_item(@ast::view_item);\n-    nmie_item(@ast::native_item);\n-}\n-type nmod_index = hashmap[ident,list[nmod_index_entry]];\n-type indexed_nmod = rec(ast::native_mod m, nmod_index index);\n \n type def_map = hashmap[uint,def];\n \n type env = rec(def_map def_map,\n                hashmap[ast::def_num,import_state] imports,\n                hashmap[ast::def_num,@indexed_mod] mod_map,\n-               hashmap[ast::def_num,@indexed_nmod] nmod_map,\n                hashmap[def_id,vec[ident]] ext_map,\n                ext_hash ext_cache,\n                session sess);\n@@ -106,7 +102,6 @@ fn resolve_crate(session sess, @ast::crate crate) -> def_map {\n     auto e = @rec(def_map = new_uint_hash[def](),\n                   imports = new_int_hash[import_state](),\n                   mod_map = new_int_hash[@indexed_mod](),\n-                  nmod_map = new_int_hash[@indexed_nmod](),\n                   ext_map = new_def_hash[vec[ident]](),\n                   ext_cache = new_ext_hash(),\n                   sess = sess);\n@@ -129,7 +124,7 @@ fn map_crate(&@env e, &ast::crate c) {\n                  visit_item_post = bind pop_env_for_item(cell, _)\n                  with walk::default_visitor());\n     // Register the top-level mod\n-    e.mod_map.insert(-1, @rec(m=c.node.module,\n+    e.mod_map.insert(-1, @rec(m=some(c.node.module),\n                               index=index_mod(c.node.module)));\n     walk::walk_crate(v, c);\n \n@@ -146,11 +141,13 @@ fn map_crate(&@env e, &ast::crate c) {\n         alt (i.node) {\n             case (ast::item_mod(_, ?md, ?defid)) {\n                 auto index = index_mod(md);\n-                e.mod_map.insert(defid._1, @rec(m=md, index=index));\n+                e.mod_map.insert(defid._1, @rec(m=some(md),\n+                                                index=index));\n             }\n             case (ast::item_native_mod(_, ?nmd, ?defid)) {\n                 auto index = index_nmod(nmd);\n-                e.nmod_map.insert(defid._1, @rec(m=nmd, index=index));\n+                e.mod_map.insert(defid._1, @rec(m=none[ast::_mod],\n+                                                index=index));\n             }\n             case (_) {}\n         }\n@@ -438,7 +435,7 @@ fn lookup_in_scope(&env e, list[scope] sc, &span sp, &ident id, namespace ns)\n         alt (s) {\n             case (scope_crate(?c)) {\n                 auto defid = tup(ast::local_crate, -1);\n-                ret lookup_in_regular_mod(e, defid, id, ns, inside);\n+                ret lookup_in_local_mod(e, defid, id, ns, inside);\n             }\n             case (scope_item(?it)) {\n                 alt (it.node) {\n@@ -454,10 +451,10 @@ fn lookup_in_scope(&env e, list[scope] sc, &span sp, &ident id, namespace ns)\n                         }\n                     }\n                     case (ast::item_mod(_, _, ?defid)) {\n-                        ret lookup_in_regular_mod(e, defid, id, ns, inside);\n+                        ret lookup_in_local_mod(e, defid, id, ns, inside);\n                     }\n                     case (ast::item_native_mod(_, ?m, ?defid)) {\n-                        ret lookup_in_native_mod(e, defid, id, ns);\n+                        ret lookup_in_local_native_mod(e, defid, id, ns);\n                     }\n                     case (ast::item_ty(_, _, ?ty_params, _, _)) {\n                         if (ns == ns_type) {\n@@ -524,6 +521,7 @@ fn lookup_in_scope(&env e, list[scope] sc, &span sp, &ident id, namespace ns)\n             }\n         }\n     }\n+    fail;\n }\n \n fn lookup_in_ty_params(&ident id, &vec[ast::ty_param] ty_params)\n@@ -699,10 +697,10 @@ fn lookup_in_mod(&env e, def m, &ident id, namespace ns, dir dr)\n     }\n     alt (m) {\n         case (ast::def_mod(?defid)) {\n-            ret lookup_in_regular_mod(e, defid, id, ns, dr);\n+            ret lookup_in_local_mod(e, defid, id, ns, dr);\n         }\n         case (ast::def_native_mod(?defid)) {\n-            ret lookup_in_native_mod(e, defid, id, ns);\n+            ret lookup_in_local_native_mod(e, defid, id, ns);\n         }\n     }\n }\n@@ -734,14 +732,16 @@ fn lookup_import(&env e, def_id defid, namespace ns) -> option::t[def] {\n                            case (ns_module) { md } };\n         }\n     }\n+    fail;\n }\n \n-fn lookup_in_regular_mod(&env e, def_id defid, &ident id, namespace ns,\n-                         dir dr) -> option::t[def] {\n+fn lookup_in_local_mod(&env e, def_id defid, &ident id, namespace ns,\n+                       dir dr) -> option::t[def] {\n     auto info = e.mod_map.get(defid._1);\n     auto found = info.index.find(id);\n     if (option::is_none(found) || \n-        (dr == outside && !ast::is_exported(id, info.m))) {\n+        (dr == outside && !ast::is_exported(id, option::get(info.m)))) {\n+        // if we're in a native mod, then dr==inside, so info.m is some _mod\n         ret none[def];\n     }\n     auto lst = option::get(found);\n@@ -757,6 +757,7 @@ fn lookup_in_regular_mod(&env e, def_id defid, &ident id, namespace ns,\n             }\n         }\n     }\n+    fail;\n }\n \n fn lookup_in_mie(&env e, &mod_index_entry mie, namespace ns)\n@@ -780,39 +781,8 @@ fn lookup_in_mie(&env e, &mod_index_entry mie, namespace ns)\n                 }\n             }\n         }\n-    }\n-}\n-\n-fn lookup_in_native_mod(&env e, def_id defid, &ident id, namespace ns)\n-    -> option::t[def] {\n-    auto info = e.nmod_map.get(defid._1);\n-    auto found = info.index.find(id);\n-    if (option::is_none(found)) {\n-        ret none[def];\n-    }\n-    auto lst = option::get(found);\n-    while (true) {\n-        alt (lst) {\n-            case (nil[nmod_index_entry]) {\n-                ret none[def];\n-            }\n-            case (cons[nmod_index_entry](?hd, ?tl)) {\n-                auto found = lookup_in_nmie(e, hd, ns);\n-                if (!option::is_none(found)) { ret found; }\n-                lst = *tl;\n-            }\n-        }\n-    }\n-}\n-    \n-fn lookup_in_nmie(&env e, &nmod_index_entry nmie, namespace ns)\n-    -> option::t[def] {\n-    alt (nmie) {\n-        case (nmie_view_item(?view_item)) {\n-            ret found_view_item(e, view_item, ns);\n-        }\n-        case (nmie_item(?item)) {\n-            alt (item.node) {\n+        case (mie_native_item(?native_item)) {\n+            alt (native_item.node) {\n                 case (ast::native_item_ty(_, ?id)) {\n                     if (ns == ns_type) {\n                         ret some(ast::def_native_ty(id));\n@@ -830,6 +800,12 @@ fn lookup_in_nmie(&env e, &nmod_index_entry nmie, namespace ns)\n     ret none[def];\n }\n \n+fn lookup_in_local_native_mod(&env e, def_id defid, &ident id, namespace ns)\n+    -> option::t[def] {\n+    ret lookup_in_local_mod(e, defid, id, ns, inside);\n+}\n+\n+\n // Module indexing\n \n fn add_to_index[T](&hashmap[ident,list[T]] index, &ident id, &T ent) {\n@@ -893,13 +869,13 @@ fn index_mod(&ast::_mod md) -> mod_index {\n     ret index;\n }\n \n-fn index_nmod(&ast::native_mod md) -> nmod_index {\n-    auto index = new_str_hash[list[nmod_index_entry]]();\n+fn index_nmod(&ast::native_mod md) -> mod_index {\n+    auto index = new_str_hash[list[mod_index_entry]]();\n \n     for (@ast::view_item it in md.view_items) {\n         alt (it.node) {\n             case(ast::view_item_import(?def_ident,_,_)) {\n-                add_to_index(index, def_ident, nmie_view_item(it));\n+                add_to_index(index, def_ident, mie_view_item(it));\n             }\n             case(ast::view_item_export(_)) {}\n         }\n@@ -908,10 +884,10 @@ fn index_nmod(&ast::native_mod md) -> nmod_index {\n     for (@ast::native_item it in md.items) {\n         alt (it.node) {\n             case (ast::native_item_ty(?id, _)) {\n-                add_to_index(index, id, nmie_item(it));\n+                add_to_index(index, id, mie_native_item(it));\n             }\n             case (ast::native_item_fn(?id, _, _, _, _, _)) {\n-                add_to_index(index, id, nmie_item(it));\n+                add_to_index(index, id, mie_native_item(it));\n             }\n         }\n     }\n@@ -952,20 +928,11 @@ fn lookup_external(&env e, int cnum, vec[ident] ids, namespace ns)\n // Collision detection\n \n fn check_for_collisions(&@env e, &ast::crate c) {\n-    auto lim = lookup_in_mie;\n     auto msp = mie_span;\n     for each (@tup(ast::def_num, @indexed_mod) m in e.mod_map.items()) {\n         for each (@tup(ident, list[mod_index_entry]) name in\n                   m._1.index.items()) {\n-            check_mod_name(*e, name._0, name._1, lim, msp);\n-        }\n-    }\n-    auto linm = lookup_in_nmie;\n-    auto nmsp = nmie_span;\n-    for each (@tup(ast::def_num, @indexed_nmod) m in e.nmod_map.items()) {\n-        for each (@tup(ident, list[nmod_index_entry]) name in\n-                  m._1.index.items()) {\n-            check_mod_name(*e, name._0, name._1, linm, nmsp);\n+            check_mod_name(*e, name._0, name._1);\n         }\n     }\n     /*\n@@ -977,9 +944,7 @@ fn check_for_collisions(&@env e, &ast::crate c) {\n     }*/\n }\n \n-fn check_mod_name[T](&env e, &ident name, &list[T] entries,\n-                     fn(&env, &T, namespace) -> option::t[def] test,\n-                     fn(&T) -> span get_span) {\n+fn check_mod_name(&env e, &ident name, &list[mod_index_entry] entries) {\n     auto saw_mod = false; auto saw_type = false; auto saw_value = false;\n \n     fn dup(&env e, &span sp, &str word, &ident name) {\n@@ -988,22 +953,22 @@ fn check_mod_name[T](&env e, &ident name, &list[T] entries,\n \n     while (true) {\n         alt (entries) {\n-            case (cons[T](?entry, ?rest)) {\n-                if (!option::is_none(test(e, entry, ns_value))) {\n-                    if (saw_value) { dup(e, get_span(entry), \"\", name); }\n+            case (cons[mod_index_entry](?entry, ?rest)) {\n+                if (!option::is_none(lookup_in_mie(e, entry, ns_value))) {\n+                    if (saw_value) { dup(e, mie_span(entry), \"\", name); }\n                     else { saw_value = true; }\n                 }\n-                if (!option::is_none(test(e, entry, ns_type))) {\n-                    if (saw_type) { dup(e, get_span(entry), \"type \", name); }\n+                if (!option::is_none(lookup_in_mie(e, entry, ns_type))) {\n+                    if (saw_type) { dup(e, mie_span(entry), \"type \", name); }\n                     else { saw_type = true; }\n                 }\n-                if (!option::is_none(test(e, entry, ns_module))) {\n-                    if (saw_mod) { dup(e, get_span(entry), \"module \", name); }\n+                if (!option::is_none(lookup_in_mie(e, entry, ns_module))) {\n+                    if (saw_mod) { dup(e, mie_span(entry), \"module \", name); }\n                     else { saw_mod = true; }\n                 }\n                 entries = *rest;\n             }\n-            case (nil[T]) { break; }\n+            case (nil[mod_index_entry]) { break; }\n         }\n     }\n }\n@@ -1013,15 +978,10 @@ fn mie_span(&mod_index_entry mie) -> span {\n         case (mie_view_item(?item)) { ret item.span; }\n         case (mie_item(?item)) { ret item.span; }\n         case (mie_tag_variant(?item, _)) { ret item.span; }\n+        case (mie_native_item(?item)) { ret item.span; }\n     }\n }\n \n-fn nmie_span(&nmod_index_entry nmie) -> span {\n-    alt (nmie) {\n-        case (nmie_view_item(?item)) { ret item.span; }\n-        case (nmie_item(?item)) { ret item.span; }\n-    }\n-}\n \n // Local Variables:\n // mode: rust"}]}