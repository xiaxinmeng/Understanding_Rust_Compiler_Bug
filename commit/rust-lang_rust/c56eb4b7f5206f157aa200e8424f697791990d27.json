{"sha": "c56eb4b7f5206f157aa200e8424f697791990d27", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1NmViNGI3ZjUyMDZmMTU3YWEyMDBlODQyNGY2OTc3OTE5OTBkMjc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-07-29T20:49:26Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-08-02T09:31:25Z"}, "message": "remap Hir(InlinedDefId) to MetaData(OriginalDefId)\n\nThe way we do HIR inlining introduces reads of the \"Hir\" into the graph,\nbut this Hir in fact belongs to other crates, so when we try to load\nlater, we ICE because the Hir nodes in question don't belond to the\ncrate (and we haven't done inlining yet). This pass rewrites those HIR\nnodes to the metadata from which the inlined HIR was loaded.", "tree": {"sha": "0969dd346e106fc0ac6d0807a886f44133c297ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0969dd346e106fc0ac6d0807a886f44133c297ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c56eb4b7f5206f157aa200e8424f697791990d27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c56eb4b7f5206f157aa200e8424f697791990d27", "html_url": "https://github.com/rust-lang/rust/commit/c56eb4b7f5206f157aa200e8424f697791990d27", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c56eb4b7f5206f157aa200e8424f697791990d27/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9294f8ed0a053af18be8247ef589bc16775bd038", "url": "https://api.github.com/repos/rust-lang/rust/commits/9294f8ed0a053af18be8247ef589bc16775bd038", "html_url": "https://github.com/rust-lang/rust/commit/9294f8ed0a053af18be8247ef589bc16775bd038"}], "stats": {"total": 156, "additions": 124, "deletions": 32}, "files": [{"sha": "eea8ad9926cc1e9a00c0fafca04ea155134b35b0", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c56eb4b7f5206f157aa200e8424f697791990d27/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c56eb4b7f5206f157aa200e8424f697791990d27/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=c56eb4b7f5206f157aa200e8424f697791990d27", "patch": "@@ -204,9 +204,21 @@ pub struct Map<'ast> {\n     /// All NodeIds that are numerically greater or equal to this value come\n     /// from inlined items.\n     local_node_id_watermark: NodeId,\n+\n+    /// All def-indices that are numerically greater or equal to this value come\n+    /// from inlined items.\n+    local_def_id_watermark: usize,\n }\n \n impl<'ast> Map<'ast> {\n+    pub fn is_inlined_def_id(&self, id: DefId) -> bool {\n+        id.is_local() && id.index.as_usize() >= self.local_def_id_watermark\n+    }\n+\n+    pub fn is_inlined_node_id(&self, id: NodeId) -> bool {\n+        id >= self.local_node_id_watermark\n+    }\n+\n     /// Registers a read in the dependency graph of the AST node with\n     /// the given `id`. This needs to be called each time a public\n     /// function returns the HIR for a node -- in other words, when it\n@@ -664,10 +676,6 @@ impl<'ast> Map<'ast> {\n     pub fn node_to_user_string(&self, id: NodeId) -> String {\n         node_id_to_string(self, id, false)\n     }\n-\n-    pub fn is_inlined(&self, id: NodeId) -> bool {\n-        id >= self.local_node_id_watermark\n-    }\n }\n \n pub struct NodesMatchingSuffix<'a, 'ast:'a> {\n@@ -846,13 +854,15 @@ pub fn map_crate<'ast>(forest: &'ast mut Forest,\n     }\n \n     let local_node_id_watermark = map.len() as NodeId;\n+    let local_def_id_watermark = definitions.len();\n \n     Map {\n         forest: forest,\n         dep_graph: forest.dep_graph.clone(),\n         map: RefCell::new(map),\n         definitions: RefCell::new(definitions),\n-        local_node_id_watermark: local_node_id_watermark\n+        local_node_id_watermark: local_node_id_watermark,\n+        local_def_id_watermark: local_def_id_watermark,\n     }\n }\n "}, {"sha": "77cc62060aad939d62513f966435c55b8dd57d96", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c56eb4b7f5206f157aa200e8424f697791990d27/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c56eb4b7f5206f157aa200e8424f697791990d27/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=c56eb4b7f5206f157aa200e8424f697791990d27", "patch": "@@ -525,7 +525,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn retrace_path(self, path: &DefPath) -> Option<DefId> {\n-        debug!(\"retrace_path(path={:?})\", path);\n+        debug!(\"retrace_path(path={:?}, krate={:?})\", path, self.crate_name(path.krate));\n \n         let root_key = DefKey {\n             parent: None,"}, {"sha": "e16371dd0cef9f6ab3ee6525071222b427193a42", "filename": "src/librustc_incremental/persist/hash.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c56eb4b7f5206f157aa200e8424f697791990d27/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c56eb4b7f5206f157aa200e8424f697791990d27/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs?ref=c56eb4b7f5206f157aa200e8424f697791990d27", "patch": "@@ -43,7 +43,6 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n         match *dep_node {\n             // HIR nodes (which always come from our crate) are an input:\n             DepNode::Hir(def_id) => {\n-                assert!(def_id.is_local());\n                 Some(self.hir_hash(def_id))\n             }\n \n@@ -66,7 +65,11 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n     }\n \n     fn hir_hash(&mut self, def_id: DefId) -> u64 {\n-        assert!(def_id.is_local());\n+        assert!(def_id.is_local(),\n+                \"cannot hash HIR for non-local def-id {:?} => {:?}\",\n+                def_id,\n+                self.tcx.item_path_str(def_id));\n+\n         // FIXME(#32753) -- should we use a distinct hash here\n         self.tcx.calculate_item_hash(def_id)\n     }"}, {"sha": "82b1da67a4d6398b7482f92e09be0280d55aef2d", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c56eb4b7f5206f157aa200e8424f697791990d27/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c56eb4b7f5206f157aa200e8424f697791990d27/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=c56eb4b7f5206f157aa200e8424f697791990d27", "patch": "@@ -93,7 +93,6 @@ fn load_data(sess: &Session, path: &Path) -> Option<Vec<u8>> {\n             None\n         }\n     }\n-\n }\n \n /// Decode the dep graph and load the edges/nodes that are still clean\n@@ -108,14 +107,9 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let directory = try!(DefIdDirectory::decode(&mut dep_graph_decoder));\n     let serialized_dep_graph = try!(SerializedDepGraph::decode(&mut dep_graph_decoder));\n \n-    debug!(\"decode_dep_graph: directory = {:#?}\", directory);\n-    debug!(\"decode_dep_graph: serialized_dep_graph = {:#?}\", serialized_dep_graph);\n-\n     // Retrace the paths in the directory to find their current location (if any).\n     let retraced = directory.retrace(tcx);\n \n-    debug!(\"decode_dep_graph: retraced = {:#?}\", retraced);\n-\n     // Compute the set of Hir nodes whose data has changed.\n     let mut dirty_nodes =\n         initial_dirty_nodes(tcx, &serialized_dep_graph.hashes, &retraced);\n@@ -169,6 +163,7 @@ fn initial_dirty_nodes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut items_removed = false;\n     let mut dirty_nodes = FnvHashSet();\n     for hash in hashes {\n+        debug!(\"initial_dirty_nodes: retracing {:?}\", hash);\n         match hash.node.map_def(|&i| retraced.def_id(i)) {\n             Some(dep_node) => {\n                 let current_hash = hcx.hash(&dep_node).unwrap();"}, {"sha": "8bc1e80fc7c164b5be055dcabb57a44dbba435e8", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 65, "deletions": 14, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/c56eb4b7f5206f157aa200e8424f697791990d27/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c56eb4b7f5206f157aa200e8424f697791990d27/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=c56eb4b7f5206f157aa200e8424f697791990d27", "patch": "@@ -9,10 +9,12 @@\n // except according to those terms.\n \n use rbml::opaque::Encoder;\n-use rustc::dep_graph::DepNode;\n+use rustc::dep_graph::{DepGraphQuery, DepNode};\n+use rustc::hir::def_id::DefId;\n use rustc::middle::cstore::LOCAL_CRATE;\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n+use rustc_data_structures::fnv::FnvHashMap;\n use rustc_serialize::{Encodable as RustcEncodable};\n use std::hash::{Hasher, SipHasher};\n use std::io::{self, Cursor, Write};\n@@ -99,15 +101,15 @@ pub fn encode_dep_graph<'a, 'tcx>(hcx: &mut HashContext<'a, 'tcx>,\n {\n     let tcx = hcx.tcx;\n     let query = tcx.dep_graph.query();\n+    let (nodes, edges) = post_process_graph(hcx, query);\n \n     let mut builder = DefIdDirectoryBuilder::new(tcx);\n \n     // Create hashes for inputs.\n     let hashes =\n-        query.nodes()\n-             .into_iter()\n+        nodes.iter()\n              .filter_map(|dep_node| {\n-                 hcx.hash(&dep_node)\n+                 hcx.hash(dep_node)\n                     .map(|hash| {\n                         let node = builder.map(dep_node);\n                         SerializedHash { node: node, hash: hash }\n@@ -117,16 +119,14 @@ pub fn encode_dep_graph<'a, 'tcx>(hcx: &mut HashContext<'a, 'tcx>,\n \n     // Create the serialized dep-graph.\n     let graph = SerializedDepGraph {\n-        nodes: query.nodes().into_iter()\n-                            .map(|node| builder.map(node))\n-                            .collect(),\n-        edges: query.edges().into_iter()\n-                            .map(|(source_node, target_node)| {\n-                                let source = builder.map(source_node);\n-                                let target = builder.map(target_node);\n-                                (source, target)\n-                            })\n-                            .collect(),\n+        nodes: nodes.iter().map(|node| builder.map(node)).collect(),\n+        edges: edges.iter()\n+                    .map(|&(ref source_node, ref target_node)| {\n+                        let source = builder.map(source_node);\n+                        let target = builder.map(target_node);\n+                        (source, target)\n+                    })\n+                    .collect(),\n         hashes: hashes,\n     };\n \n@@ -140,6 +140,57 @@ pub fn encode_dep_graph<'a, 'tcx>(hcx: &mut HashContext<'a, 'tcx>,\n     Ok(())\n }\n \n+pub fn post_process_graph<'a, 'tcx>(hcx: &mut HashContext<'a, 'tcx>,\n+                                    query: DepGraphQuery<DefId>)\n+                                    -> (Vec<DepNode<DefId>>, Vec<(DepNode<DefId>, DepNode<DefId>)>)\n+{\n+    let tcx = hcx.tcx;\n+    let mut cache = FnvHashMap();\n+\n+    let mut uninline_def_id = |def_id: DefId| -> Option<DefId> {\n+        if tcx.map.is_inlined_def_id(def_id) {\n+            Some(\n+                cache.entry(def_id)\n+                     .or_insert_with(|| {\n+                         let def_path = tcx.def_path(def_id);\n+                         debug!(\"post_process_graph: uninlining def-id {:?} to yield {:?}\",\n+                                def_id, def_path);\n+                         let retraced_def_id = tcx.retrace_path(&def_path).unwrap();\n+                         debug!(\"post_process_graph: retraced to {:?}\", retraced_def_id);\n+                         retraced_def_id\n+                     })\n+                     .clone())\n+        } else {\n+            None\n+        }\n+    };\n+\n+    let mut uninline_metadata = |node: &DepNode<DefId>| -> DepNode<DefId> {\n+        match *node {\n+            DepNode::Hir(def_id) => {\n+                match uninline_def_id(def_id) {\n+                    Some(uninlined_def_id) => DepNode::MetaData(uninlined_def_id),\n+                    None => DepNode::Hir(def_id)\n+                }\n+            }\n+            _ => node.clone()\n+        }\n+    };\n+\n+    let nodes = query.nodes()\n+                     .into_iter()\n+                     .map(|node| uninline_metadata(node))\n+                     .collect();\n+\n+    let edges = query.edges()\n+                     .into_iter()\n+                     .map(|(from, to)| (uninline_metadata(from), uninline_metadata(to)))\n+                     .collect();\n+\n+    (nodes, edges)\n+}\n+\n+\n pub fn encode_metadata_hashes<'a, 'tcx>(hcx: &mut HashContext<'a, 'tcx>,\n                                         encoder: &mut Encoder)\n                                         -> io::Result<()>"}, {"sha": "6a1fc6bcffbfcde5bcc939e9282d185de7977c3f", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c56eb4b7f5206f157aa200e8424f697791990d27/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c56eb4b7f5206f157aa200e8424f697791990d27/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=c56eb4b7f5206f157aa200e8424f697791990d27", "patch": "@@ -1244,7 +1244,7 @@ pub fn inlined_variant_def<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }), ..}) => ty,\n         _ => ctor_ty\n     }.ty_adt_def().unwrap();\n-    let variant_def_id = if ccx.tcx().map.is_inlined(inlined_vid) {\n+    let variant_def_id = if ccx.tcx().map.is_inlined_node_id(inlined_vid) {\n         ccx.defid_for_inlined_node(inlined_vid).unwrap()\n     } else {\n         ccx.tcx().map.local_def_id(inlined_vid)"}, {"sha": "84c3b41fd0acb6855c19d98dbb640c5c92e274a0", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c56eb4b7f5206f157aa200e8424f697791990d27/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c56eb4b7f5206f157aa200e8424f697791990d27/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=c56eb4b7f5206f157aa200e8424f697791990d27", "patch": "@@ -1026,7 +1026,7 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n                              .get(TransItem::Static(id))\n                              .expect(\"Local statics should always be in the SymbolMap\");\n                 // Make sure that this is never executed for something inlined.\n-                assert!(!ccx.tcx().map.is_inlined(id));\n+                assert!(!ccx.tcx().map.is_inlined_node_id(id));\n \n                 let defined_in_current_codegen_unit = ccx.codegen_unit()\n                                                          .items()"}, {"sha": "e8051212552d81deaf5687a7303043d4f9aff440", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c56eb4b7f5206f157aa200e8424f697791990d27/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c56eb4b7f5206f157aa200e8424f697791990d27/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=c56eb4b7f5206f157aa200e8424f697791990d27", "patch": "@@ -326,7 +326,7 @@ impl<'tcx> TypeMap<'tcx> {\n             // First, find out the 'real' def_id of the type. Items inlined from\n             // other crates have to be mapped back to their source.\n             let def_id = if let Some(node_id) = cx.tcx().map.as_local_node_id(def_id) {\n-                if cx.tcx().map.is_inlined(node_id) {\n+                if cx.tcx().map.is_inlined_node_id(node_id) {\n                     // The given def_id identifies the inlined copy of a\n                     // type definition, let's take the source of the copy.\n                     cx.defid_for_inlined_node(node_id).unwrap()\n@@ -1845,7 +1845,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     // crate should already contain debuginfo for it. More importantly, the\n     // global might not even exist in un-inlined form anywhere which would lead\n     // to a linker errors.\n-    if cx.tcx().map.is_inlined(node_id) {\n+    if cx.tcx().map.is_inlined_node_id(node_id) {\n         return;\n     }\n "}, {"sha": "a150a8c4df77c8f588148846ba5d3bdd9c18d545", "filename": "src/test/incremental/inlined_hir_34991/main.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c56eb4b7f5206f157aa200e8424f697791990d27/src%2Ftest%2Fincremental%2Finlined_hir_34991%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c56eb4b7f5206f157aa200e8424f697791990d27/src%2Ftest%2Fincremental%2Finlined_hir_34991%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Finlined_hir_34991%2Fmain.rs?ref=c56eb4b7f5206f157aa200e8424f697791990d27", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #34991: an ICE occurred here because we inline\n+// some of the vector routines and give them a local def-id `X`. This\n+// got hashed after trans (`Hir(X)`). When we load back up, we get an\n+// error because the `X` is remapped to the original def-id (in\n+// libstd), and we can't hash a HIR node from std.\n+\n+// revisions:rpass1 rpass2\n+\n+#![feature(rustc_attrs)]\n+\n+use std::vec::Vec;\n+\n+pub fn foo() -> Vec<i32> {\n+    vec![1, 2, 3]\n+}\n+\n+pub fn bar() {\n+    foo();\n+}\n+\n+pub fn main() {\n+    bar();\n+}"}]}