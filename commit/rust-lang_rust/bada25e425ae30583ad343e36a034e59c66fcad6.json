{"sha": "bada25e425ae30583ad343e36a034e59c66fcad6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhZGEyNWU0MjVhZTMwNTgzYWQzNDNlMzZhMDM0ZTU5YzY2ZmNhZDY=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2013-12-23T15:20:52Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2014-01-21T23:48:47Z"}, "message": "[std::vec] Rename .pop_opt() to .pop(), drop the old .pop() behavior", "tree": {"sha": "4e07ddbe72ef54075d401322c8283de064f02b4e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e07ddbe72ef54075d401322c8283de064f02b4e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bada25e425ae30583ad343e36a034e59c66fcad6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bada25e425ae30583ad343e36a034e59c66fcad6", "html_url": "https://github.com/rust-lang/rust/commit/bada25e425ae30583ad343e36a034e59c66fcad6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bada25e425ae30583ad343e36a034e59c66fcad6/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa66b91767ce92c45192ca11718575529d631d21", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa66b91767ce92c45192ca11718575529d631d21", "html_url": "https://github.com/rust-lang/rust/commit/aa66b91767ce92c45192ca11718575529d631d21"}], "stats": {"total": 261, "additions": 128, "deletions": 133}, "files": [{"sha": "ee4d74ce1698b884ae825125c137b104a5a8e2be", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=bada25e425ae30583ad343e36a034e59c66fcad6", "patch": "@@ -159,10 +159,10 @@ fn parse_exec_env(line: &str) -> Option<(~str, ~str)> {\n         let mut strs: ~[~str] = nv.splitn('=', 1).map(|s| s.to_owned()).collect();\n \n         match strs.len() {\n-          1u => (strs.pop(), ~\"\"),\n+          1u => (strs.pop().unwrap(), ~\"\"),\n           2u => {\n-              let end = strs.pop();\n-              (strs.pop(), end)\n+              let end = strs.pop().unwrap();\n+              (strs.pop().unwrap(), end)\n           }\n           n => fail!(\"Expected 1 or 2 strings, not {}\", n)\n         }"}, {"sha": "6f8a3ad83a3ebafa5484a32aa4b8f6b79b4d16dd", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=bada25e425ae30583ad343e36a034e59c66fcad6", "patch": "@@ -917,7 +917,7 @@ fn _arm_exec_compiled_test(config: &config, props: &TestProps,\n \n     // get bare program string\n     let mut tvec: ~[~str] = args.prog.split('/').map(|ts| ts.to_owned()).collect();\n-    let prog_short = tvec.pop();\n+    let prog_short = tvec.pop().unwrap();\n \n     // copy to target\n     let copy_result = procsrv::run(\"\", config.adb_path,"}, {"sha": "009cc53289e43831064de3030e13b02e10a2504d", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=bada25e425ae30583ad343e36a034e59c66fcad6", "patch": "@@ -1049,7 +1049,7 @@ mod tests {\n             match r % 6 {\n                 0 => {\n                     m.pop_back();\n-                    if v.len() > 0 { v.pop(); }\n+                    v.pop();\n                 }\n                 1 => {\n                     m.pop_front();"}, {"sha": "8cce47b03f80b178aa971a7bd79598066abcca65", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=bada25e425ae30583ad343e36a034e59c66fcad6", "patch": "@@ -651,7 +651,7 @@ pub mod writer {\n         }\n \n         pub fn end_tag(&mut self) {\n-            let last_size_pos = self.size_positions.pop();\n+            let last_size_pos = self.size_positions.pop().unwrap();\n             let cur_pos = self.writer.tell();\n             self.writer.seek(last_size_pos as i64, io::SeekSet);\n             let size = (cur_pos as uint - last_size_pos - 4);"}, {"sha": "3e2aa511b81fccd4f172a26f918c942cd192b153", "filename": "src/libextra/glob.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibextra%2Fglob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibextra%2Fglob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fglob.rs?ref=bada25e425ae30583ad343e36a034e59c66fcad6", "patch": "@@ -122,7 +122,7 @@ impl Iterator<Path> for Paths {\n                 return None;\n             }\n \n-            let (path,idx) = self.todo.pop();\n+            let (path,idx) = self.todo.pop().unwrap();\n             let ref pattern = self.dir_patterns[idx];\n \n             if pattern.matches_with(match path.filename_str() {"}, {"sha": "9fcafee8c51bb3900d7caa87fdf88dd860b8e0d8", "filename": "src/libextra/json.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=bada25e425ae30583ad343e36a034e59c66fcad6", "patch": "@@ -1028,7 +1028,7 @@ impl<T : Iterator<char>> Parser<T> {\n         while !self.eof() {\n             self.parse_whitespace();\n \n-            if self.ch != '\\\"' {\n+            if self.ch != '\"' {\n                 return self.error(~\"key must be a string\");\n             }\n \n@@ -1117,7 +1117,7 @@ impl Decoder {\n impl serialize::Decoder for Decoder {\n     fn read_nil(&mut self) -> () {\n         debug!(\"read_nil\");\n-        match self.stack.pop() {\n+        match self.stack.pop().unwrap() {\n             Null => (),\n             value => self.expected(\"null\", &value)\n         }\n@@ -1137,15 +1137,15 @@ impl serialize::Decoder for Decoder {\n \n     fn read_bool(&mut self) -> bool {\n         debug!(\"read_bool\");\n-        match self.stack.pop() {\n+        match self.stack.pop().unwrap() {\n             Boolean(b) => b,\n             value => self.expected(\"boolean\", &value)\n         }\n     }\n \n     fn read_f64(&mut self) -> f64 {\n         debug!(\"read_f64\");\n-        match self.stack.pop() {\n+        match self.stack.pop().unwrap() {\n             Number(f) => f,\n             value => self.expected(\"number\", &value)\n         }\n@@ -1168,7 +1168,7 @@ impl serialize::Decoder for Decoder {\n \n     fn read_str(&mut self) -> ~str {\n         debug!(\"read_str\");\n-        match self.stack.pop() {\n+        match self.stack.pop().unwrap() {\n             String(s) => s,\n             value => self.expected(\"string\", &value)\n         }\n@@ -1184,7 +1184,7 @@ impl serialize::Decoder for Decoder {\n                             f: |&mut Decoder, uint| -> T)\n                             -> T {\n         debug!(\"read_enum_variant(names={:?})\", names);\n-        let name = match self.stack.pop() {\n+        let name = match self.stack.pop().unwrap() {\n             String(s) => s,\n             Object(mut o) => {\n                 let n = match o.pop(&~\"variant\") {\n@@ -1249,7 +1249,7 @@ impl serialize::Decoder for Decoder {\n                       -> T {\n         debug!(\"read_struct(name={}, len={})\", name, len);\n         let value = f(self);\n-        self.stack.pop();\n+        self.stack.pop().unwrap();\n         value\n     }\n \n@@ -1259,7 +1259,7 @@ impl serialize::Decoder for Decoder {\n                             f: |&mut Decoder| -> T)\n                             -> T {\n         debug!(\"read_struct_field(name={}, idx={})\", name, idx);\n-        match self.stack.pop() {\n+        match self.stack.pop().unwrap() {\n             Object(mut obj) => {\n                 let value = match obj.pop(&name.to_owned()) {\n                     None => self.missing_field(name, obj),\n@@ -1302,15 +1302,15 @@ impl serialize::Decoder for Decoder {\n     }\n \n     fn read_option<T>(&mut self, f: |&mut Decoder, bool| -> T) -> T {\n-        match self.stack.pop() {\n+        match self.stack.pop().unwrap() {\n             Null => f(self, false),\n             value => { self.stack.push(value); f(self, true) }\n         }\n     }\n \n     fn read_seq<T>(&mut self, f: |&mut Decoder, uint| -> T) -> T {\n         debug!(\"read_seq()\");\n-        let len = match self.stack.pop() {\n+        let len = match self.stack.pop().unwrap() {\n             List(list) => {\n                 let len = list.len();\n                 for v in list.move_rev_iter() {\n@@ -1330,7 +1330,7 @@ impl serialize::Decoder for Decoder {\n \n     fn read_map<T>(&mut self, f: |&mut Decoder, uint| -> T) -> T {\n         debug!(\"read_map()\");\n-        let len = match self.stack.pop() {\n+        let len = match self.stack.pop().unwrap() {\n             Object(obj) => {\n                 let len = obj.len();\n                 for (key, value) in obj.move_iter() {"}, {"sha": "33b3931e9897a1eb7e5b28677a62d2e74ce910c9", "filename": "src/libextra/priority_queue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibextra%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibextra%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpriority_queue.rs?ref=bada25e425ae30583ad343e36a034e59c66fcad6", "patch": "@@ -59,7 +59,7 @@ impl<T:Ord> PriorityQueue<T> {\n \n     /// Pop the greatest item from the queue - fails if empty\n     pub fn pop(&mut self) -> T {\n-        let mut item = self.data.pop();\n+        let mut item = self.data.pop().unwrap();\n         if !self.is_empty() {\n             swap(&mut item, &mut self.data[0]);\n             self.siftdown(0);\n@@ -235,7 +235,7 @@ mod tests {\n         let mut heap = PriorityQueue::from_vec(data);\n         while !heap.is_empty() {\n             assert_eq!(heap.top(), sorted.last().unwrap());\n-            assert_eq!(heap.pop(), sorted.pop());\n+            assert_eq!(heap.pop(), sorted.pop().unwrap());\n         }\n     }\n "}, {"sha": "bd9eadc078d1bf57fafac98033f68bec5ea8c25c", "filename": "src/libextra/terminfo/parm.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibextra%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibextra%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparm.rs?ref=bada25e425ae30583ad343e36a034e59c66fcad6", "patch": "@@ -121,7 +121,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                 match cur {\n                     '%' => { output.push(c); state = Nothing },\n                     'c' => if stack.len() > 0 {\n-                        match stack.pop() {\n+                        match stack.pop().unwrap() {\n                             // if c is 0, use 0200 (128) for ncurses compatibility\n                             Number(c) => output.push(if c == 0 { 128 } else { c } as u8),\n                             _       => return Err(~\"a non-char was used with %c\")\n@@ -133,104 +133,104 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                     '\\'' => state = CharConstant,\n                     '{' => state = IntConstant(0),\n                     'l' => if stack.len() > 0 {\n-                        match stack.pop() {\n+                        match stack.pop().unwrap() {\n                             String(s) => stack.push(Number(s.len() as int)),\n                             _         => return Err(~\"a non-str was used with %l\")\n                         }\n                     } else { return Err(~\"stack is empty\") },\n                     '+' => if stack.len() > 1 {\n-                        match (stack.pop(), stack.pop()) {\n+                        match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x + y)),\n                             _ => return Err(~\"non-numbers on stack with +\")\n                         }\n                     } else { return Err(~\"stack is empty\") },\n                     '-' => if stack.len() > 1 {\n-                        match (stack.pop(), stack.pop()) {\n+                        match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x - y)),\n                             _ => return Err(~\"non-numbers on stack with -\")\n                         }\n                     } else { return Err(~\"stack is empty\") },\n                     '*' => if stack.len() > 1 {\n-                        match (stack.pop(), stack.pop()) {\n+                        match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x * y)),\n                             _ => return Err(~\"non-numbers on stack with *\")\n                         }\n                     } else { return Err(~\"stack is empty\") },\n                     '/' => if stack.len() > 1 {\n-                        match (stack.pop(), stack.pop()) {\n+                        match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x / y)),\n                             _ => return Err(~\"non-numbers on stack with /\")\n                         }\n                     } else { return Err(~\"stack is empty\") },\n                     'm' => if stack.len() > 1 {\n-                        match (stack.pop(), stack.pop()) {\n+                        match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x % y)),\n                             _ => return Err(~\"non-numbers on stack with %\")\n                         }\n                     } else { return Err(~\"stack is empty\") },\n                     '&' => if stack.len() > 1 {\n-                        match (stack.pop(), stack.pop()) {\n+                        match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x & y)),\n                             _ => return Err(~\"non-numbers on stack with &\")\n                         }\n                     } else { return Err(~\"stack is empty\") },\n                     '|' => if stack.len() > 1 {\n-                        match (stack.pop(), stack.pop()) {\n+                        match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x | y)),\n                             _ => return Err(~\"non-numbers on stack with |\")\n                         }\n                     } else { return Err(~\"stack is empty\") },\n                     '^' => if stack.len() > 1 {\n-                        match (stack.pop(), stack.pop()) {\n+                        match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(x ^ y)),\n                             _ => return Err(~\"non-numbers on stack with ^\")\n                         }\n                     } else { return Err(~\"stack is empty\") },\n                     '=' => if stack.len() > 1 {\n-                        match (stack.pop(), stack.pop()) {\n+                        match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(if x == y { 1 }\n                                                                         else { 0 })),\n                             _ => return Err(~\"non-numbers on stack with =\")\n                         }\n                     } else { return Err(~\"stack is empty\") },\n                     '>' => if stack.len() > 1 {\n-                        match (stack.pop(), stack.pop()) {\n+                        match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(if x > y { 1 }\n                                                                         else { 0 })),\n                             _ => return Err(~\"non-numbers on stack with >\")\n                         }\n                     } else { return Err(~\"stack is empty\") },\n                     '<' => if stack.len() > 1 {\n-                        match (stack.pop(), stack.pop()) {\n+                        match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(y), Number(x)) => stack.push(Number(if x < y { 1 }\n                                                                         else { 0 })),\n                             _ => return Err(~\"non-numbers on stack with <\")\n                         }\n                     } else { return Err(~\"stack is empty\") },\n                     'A' => if stack.len() > 1 {\n-                        match (stack.pop(), stack.pop()) {\n+                        match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(0), Number(_)) => stack.push(Number(0)),\n                             (Number(_), Number(0)) => stack.push(Number(0)),\n                             (Number(_), Number(_)) => stack.push(Number(1)),\n                             _ => return Err(~\"non-numbers on stack with logical and\")\n                         }\n                     } else { return Err(~\"stack is empty\") },\n                     'O' => if stack.len() > 1 {\n-                        match (stack.pop(), stack.pop()) {\n+                        match (stack.pop().unwrap(), stack.pop().unwrap()) {\n                             (Number(0), Number(0)) => stack.push(Number(0)),\n                             (Number(_), Number(_)) => stack.push(Number(1)),\n                             _ => return Err(~\"non-numbers on stack with logical or\")\n                         }\n                     } else { return Err(~\"stack is empty\") },\n                     '!' => if stack.len() > 0 {\n-                        match stack.pop() {\n+                        match stack.pop().unwrap() {\n                             Number(0) => stack.push(Number(1)),\n                             Number(_) => stack.push(Number(0)),\n                             _ => return Err(~\"non-number on stack with logical not\")\n                         }\n                     } else { return Err(~\"stack is empty\") },\n                     '~' => if stack.len() > 0 {\n-                        match stack.pop() {\n+                        match stack.pop().unwrap() {\n                             Number(x) => stack.push(Number(!x)),\n                             _         => return Err(~\"non-number on stack with %~\")\n                         }\n@@ -246,7 +246,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                     // printf-style support for %doxXs\n                     'd'|'o'|'x'|'X'|'s' => if stack.len() > 0 {\n                         let flags = Flags::new();\n-                        let res = format(stack.pop(), FormatOp::from_char(cur), flags);\n+                        let res = format(stack.pop().unwrap(), FormatOp::from_char(cur), flags);\n                         if res.is_err() { return res }\n                         output.push_all(res.unwrap())\n                     } else { return Err(~\"stack is empty\") },\n@@ -270,7 +270,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                     // conditionals\n                     '?' => (),\n                     't' => if stack.len() > 0 {\n-                        match stack.pop() {\n+                        match stack.pop().unwrap() {\n                             Number(0) => state = SeekIfElse(0),\n                             Number(_) => (),\n                             _         => return Err(~\"non-number on stack with conditional\")\n@@ -293,12 +293,12 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                 if cur >= 'A' && cur <= 'Z' {\n                     if stack.len() > 0 {\n                         let idx = (cur as u8) - ('A' as u8);\n-                        vars.sta[idx] = stack.pop();\n+                        vars.sta[idx] = stack.pop().unwrap();\n                     } else { return Err(~\"stack is empty\") }\n                 } else if cur >= 'a' && cur <= 'z' {\n                     if stack.len() > 0 {\n                         let idx = (cur as u8) - ('a' as u8);\n-                        vars.dyn[idx] = stack.pop();\n+                        vars.dyn[idx] = stack.pop().unwrap();\n                     } else { return Err(~\"stack is empty\") }\n                 } else {\n                     return Err(~\"bad variable name in %P\");\n@@ -341,7 +341,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                 old_state = Nothing;\n                 match (*fstate, cur) {\n                     (_,'d')|(_,'o')|(_,'x')|(_,'X')|(_,'s') => if stack.len() > 0 {\n-                        let res = format(stack.pop(), FormatOp::from_char(cur), *flags);\n+                        let res = format(stack.pop().unwrap(), FormatOp::from_char(cur), *flags);\n                         if res.is_err() { return res }\n                         output.push_all(res.unwrap());\n                         old_state = state; // will cause state to go to Nothing"}, {"sha": "5f0270beb80e5b298246613df424936c769703f5", "filename": "src/libextra/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=bada25e425ae30583ad343e36a034e59c66fcad6", "patch": "@@ -753,7 +753,7 @@ fn run_tests(opts: &TestOpts,\n \n     while pending > 0 || !remaining.is_empty() {\n         while pending < concurrency && !remaining.is_empty() {\n-            let test = remaining.pop();\n+            let test = remaining.pop().unwrap();\n             if concurrency == 1 {\n                 // We are doing one test at a time so we can print the name\n                 // of the test before we run it. Useful for debugging tests"}, {"sha": "683fe2e070bb5a41ce5fc74d64d351ff2925cb05", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=bada25e425ae30583ad343e36a034e59c66fcad6", "patch": "@@ -359,7 +359,7 @@ macro_rules! define_iterator {\n                         }\n                         self.stack.push(node);\n                     } else {\n-                        let node = self.stack.pop();\n+                        let node = self.stack.pop().unwrap();\n                         let next_node = if forward {\n                             addr!(& $($addr_mut)* node.right)\n                         } else {\n@@ -496,7 +496,7 @@ impl<K, V> Iterator<(K, V)> for MoveEntries<K,V> {\n                 left: left,\n                 right: right,\n                 level: level\n-            } = self.stack.pop();\n+            } = self.stack.pop().unwrap();\n \n             match left {\n                 Some(~left) => {"}, {"sha": "989b8dc31f8a8d584f8e1a489eabb866cb78f6a0", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=bada25e425ae30583ad343e36a034e59c66fcad6", "patch": "@@ -1285,8 +1285,11 @@ mod test {\n                 ports.push(port);\n             });\n \n-            while !ports.is_empty() {\n-                ports.pop().recv();\n+            loop {\n+                match ports.pop() {\n+                    Some(port) => port.recv(),\n+                    None => break,\n+                }\n             }\n         }\n     }"}, {"sha": "e45ea77b49e1dfcb6d3794974dd68fa3f34a5903", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=bada25e425ae30583ad343e36a034e59c66fcad6", "patch": "@@ -339,7 +339,7 @@ impl<'a> GatherLoanCtxt<'a> {\n     }\n \n     pub fn pop_repeating_id(&mut self, id: ast::NodeId) {\n-        let popped = self.repeating_ids.pop();\n+        let popped = self.repeating_ids.pop().unwrap();\n         assert_eq!(id, popped);\n     }\n "}, {"sha": "835f53a50ac795288ff6e9755c6f5f87c6446647", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=bada25e425ae30583ad343e36a034e59c66fcad6", "patch": "@@ -504,7 +504,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n \n                     // add the bits from any early return via `break`,\n                     // `continue`, or `return` into `func_bits`\n-                    let loop_scope = loop_scopes.pop();\n+                    let loop_scope = loop_scopes.pop().unwrap();\n                     join_bits(&self.dfcx.oper, loop_scope.break_bits, func_bits);\n \n                     // add `func_bits` to the entry bits for `expr`,\n@@ -563,7 +563,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n                 });\n                 self.walk_block(blk, body_bits, loop_scopes);\n                 self.add_to_entry_set(expr.id, body_bits);\n-                let new_loop_scope = loop_scopes.pop();\n+                let new_loop_scope = loop_scopes.pop().unwrap();\n                 copy_bits(new_loop_scope.break_bits, in_out);\n             }\n \n@@ -588,7 +588,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n                 self.walk_block(blk, body_bits, loop_scopes);\n                 self.add_to_entry_set(expr.id, body_bits);\n \n-                let new_loop_scope = loop_scopes.pop();\n+                let new_loop_scope = loop_scopes.pop().unwrap();\n                 assert_eq!(new_loop_scope.loop_id, expr.id);\n                 copy_bits(new_loop_scope.break_bits, in_out);\n             }"}, {"sha": "c333bc58feee12975650a1b9455a70c0f43c58e6", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=bada25e425ae30583ad343e36a034e59c66fcad6", "patch": "@@ -129,7 +129,7 @@ impl MarkSymbolVisitor {\n     fn mark_live_symbols(&mut self) {\n         let mut scanned = HashSet::new();\n         while self.worklist.len() > 0 {\n-            let id = self.worklist.pop();\n+            let id = self.worklist.pop().unwrap();\n             if scanned.contains(&id) {\n                 continue\n             }"}, {"sha": "66d706e3621c10b53d45140e8b10e7bbbd600cff", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=bada25e425ae30583ad343e36a034e59c66fcad6", "patch": "@@ -284,7 +284,7 @@ impl ReachableContext {\n                 if worklist.get().len() == 0 {\n                     break\n                 }\n-                let search_item = worklist.get().pop();\n+                let search_item = worklist.get().pop().unwrap();\n                 if scanned.contains(&search_item) {\n                     continue\n                 }"}, {"sha": "1f0e99de264a86c5a8230caf4587294bdebb2f01", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=bada25e425ae30583ad343e36a034e59c66fcad6", "patch": "@@ -396,8 +396,11 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n         let llbb = self.get_or_create_landing_pad();\n \n         // Push the scopes we removed back on:\n-        while !popped_scopes.is_empty() {\n-            self.push_scope(popped_scopes.pop());\n+        loop {\n+            match popped_scopes.pop() {\n+                Some(scope) => self.push_scope(scope),\n+                None => break\n+            }\n         }\n \n         assert_eq!(self.scopes_len(), orig_scopes_len);\n@@ -470,7 +473,7 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n                self.scopes_len() - 1);\n \n         let mut scopes = self.scopes.borrow_mut();\n-        scopes.get().pop()\n+        scopes.get().pop().unwrap()\n     }\n \n     fn top_scope<R>(&self, f: |&CleanupScope<'a>| -> R) -> R {\n@@ -608,7 +611,7 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n         // At this point, `popped_scopes` is empty, and so the final block\n         // that we return to the user is `Cleanup(AST 24)`.\n         while !popped_scopes.is_empty() {\n-            let mut scope = popped_scopes.pop();\n+            let mut scope = popped_scopes.pop().unwrap();\n \n             if scope.cleanups.iter().any(|c| cleanup_is_suitable_for(*c, label))\n             {"}, {"sha": "01fb18d73c26a5efa6ae110653e34b2847b19c91", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=bada25e425ae30583ad343e36a034e59c66fcad6", "patch": "@@ -2336,7 +2336,7 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n                 seen.push(did);\n                 let fields = struct_fields(cx, did, substs);\n                 let r = fields.iter().any(|f| type_requires(cx, seen, r_ty, f.mt.ty));\n-                seen.pop();\n+                seen.pop().unwrap();\n                 r\n             }\n \n@@ -2357,7 +2357,7 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n                         type_requires(cx, seen, r_ty, sty)\n                     })\n                 });\n-                seen.pop();\n+                seen.pop().unwrap();\n                 r\n             }\n         };"}, {"sha": "daf5bdd9ea3158c5a3468edaadd6282b4c5bcd62", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=bada25e425ae30583ad343e36a034e59c66fcad6", "patch": "@@ -107,7 +107,7 @@ pub fn relate_nested_regions(tcx: ty::ctxt,\n                     self.relate(r);\n                     self.stack.push(r);\n                     ty_fold::super_fold_ty(self, mt.ty);\n-                    self.stack.pop();\n+                    self.stack.pop().unwrap();\n                 }\n \n                 _ => {"}, {"sha": "68fb4b1e579a6d5204398055fd8cd9d5dd8e5b49", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=bada25e425ae30583ad343e36a034e59c66fcad6", "patch": "@@ -489,7 +489,7 @@ pub fn uok() -> ures {\n fn rollback_to<V:Clone + Vid,T:Clone>(vb: &mut ValsAndBindings<V, T>,\n                                       len: uint) {\n     while vb.bindings.len() != len {\n-        let (vid, old_v) = vb.bindings.pop();\n+        let (vid, old_v) = vb.bindings.pop().unwrap();\n         vb.vals.insert(vid.to_uint(), old_v);\n     }\n }"}, {"sha": "536bbd0b20da031b1e62cfe45bf276832ce7abd6", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=bada25e425ae30583ad343e36a034e59c66fcad6", "patch": "@@ -150,22 +150,22 @@ impl RegionVarBindings {\n         debug!(\"RegionVarBindings: commit()\");\n         let mut undo_log = self.undo_log.borrow_mut();\n         while undo_log.get().len() > 0 {\n-            undo_log.get().pop();\n+            undo_log.get().pop().unwrap();\n         }\n     }\n \n     pub fn rollback_to(&self, snapshot: uint) {\n         debug!(\"RegionVarBindings: rollback_to({})\", snapshot);\n         let mut undo_log = self.undo_log.borrow_mut();\n         while undo_log.get().len() > snapshot {\n-            let undo_item = undo_log.get().pop();\n+            let undo_item = undo_log.get().pop().unwrap();\n             debug!(\"undo_item={:?}\", undo_item);\n             match undo_item {\n               Snapshot => {}\n               AddVar(vid) => {\n                 let mut var_origins = self.var_origins.borrow_mut();\n                 assert_eq!(var_origins.get().len(), vid.to_uint() + 1);\n-                var_origins.get().pop();\n+                var_origins.get().pop().unwrap();\n               }\n               AddConstraint(ref constraint) => {\n                 let mut constraints = self.constraints.borrow_mut();\n@@ -1234,7 +1234,7 @@ impl RegionVarBindings {\n         process_edges(self, &mut state, graph, orig_node_idx, dir);\n \n         while !state.stack.is_empty() {\n-            let node_idx = state.stack.pop();\n+            let node_idx = state.stack.pop().unwrap();\n             let classification = var_data[node_idx.to_uint()].classification;\n \n             // check whether we've visited this node on some previous walk"}, {"sha": "85585ecaf5483b005645684fff77b3d5d242b4a1", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=bada25e425ae30583ad343e36a034e59c66fcad6", "patch": "@@ -242,7 +242,7 @@ impl ResolveState {\n                 ty::mk_var(tcx, vid)\n               }\n             };\n-            self.v_seen.pop();\n+            self.v_seen.pop().unwrap();\n             return t1;\n         }\n     }"}, {"sha": "9a9b588fa4782afd66d2f6eb0c5a2d73ec0ce1fd", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=bada25e425ae30583ad343e36a034e59c66fcad6", "patch": "@@ -635,8 +635,8 @@ impl DocFolder for Cache {\n             i => i,\n         };\n \n-        if pushed { self.stack.pop(); }\n-        if parent_pushed { self.parent_stack.pop(); }\n+        if pushed { self.stack.pop().unwrap(); }\n+        if parent_pushed { self.parent_stack.pop().unwrap(); }\n         self.privmod = orig_privmod;\n         return ret;\n     }\n@@ -673,7 +673,7 @@ impl Context {\n         self.dst = prev;\n         let len = self.root_path.len();\n         self.root_path.truncate(len - 3);\n-        self.current.pop();\n+        self.current.pop().unwrap();\n \n         return ret;\n     }\n@@ -693,11 +693,13 @@ impl Context {\n         local_data::set(cache_key, Arc::new(cache));\n \n         let mut work = ~[(self, item)];\n-        while work.len() > 0 {\n-            let (mut cx, item) = work.pop();\n-            cx.item(item, |cx, item| {\n-                work.push((cx.clone(), item));\n-            })\n+        loop {\n+            match work.pop() {\n+                Some((mut cx, item)) => cx.item(item, |cx, item| {\n+                    work.push((cx.clone(), item));\n+                }),\n+                None => break,\n+            }\n         }\n     }\n "}, {"sha": "239abbe546ff0ddfecd1bfe00fb3ae8c196ebfde", "filename": "src/librustpkg/crate_id.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibrustpkg%2Fcrate_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibrustpkg%2Fcrate_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fcrate_id.rs?ref=bada25e425ae30583ad343e36a034e59c66fcad6", "patch": "@@ -121,7 +121,7 @@ impl Iterator<(Path, Path)> for Prefixes {\n             None\n         }\n         else {\n-            let last = self.components.pop();\n+            let last = self.components.pop().unwrap();\n             self.remaining.unshift(last);\n             // converting to str and then back is a little unfortunate\n             Some((Path::new(self.components.connect(\"/\")),"}, {"sha": "a0c451647d34ac04caff8bd5f62208339c64fa17", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=bada25e425ae30583ad343e36a034e59c66fcad6", "patch": "@@ -161,8 +161,11 @@ impl Drop for Process {\n     fn drop(&mut self) {\n         // Close all I/O before exiting to ensure that the child doesn't wait\n         // forever to print some text or something similar.\n-        for _ in range(0, self.io.len()) {\n-            self.io.pop();\n+        loop {\n+            match self.io.pop() {\n+                Some(_) => (),\n+                None => break,\n+            }\n         }\n \n         self.wait();"}, {"sha": "5c35c500e6c243ca6a07e9aceb52f577b172f38f", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=bada25e425ae30583ad343e36a034e59c66fcad6", "patch": "@@ -351,7 +351,7 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Float+Round+\n                 char::from_digit(val, radix).unwrap() as u8\n             };\n \n-            let extra_digit = ascii2value(buf.pop());\n+            let extra_digit = ascii2value(buf.pop().unwrap());\n             if extra_digit >= radix / 2 { // -> need to round\n                 let mut i: int = buf.len() as int - 1;\n                 loop {"}, {"sha": "dc547d702ba29e5da9c28fa9df31500017465b8e", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=bada25e425ae30583ad343e36a034e59c66fcad6", "patch": "@@ -426,7 +426,7 @@ fn normalize_helper<'a>(v: &'a [u8], is_abs: bool) -> Option<~[&'a [u8]]> {\n         else if comp == bytes!(\"..\") {\n             if is_abs && comps.is_empty() { changed = true }\n             else if comps.len() == n_up { comps.push(dot_dot_static); n_up += 1 }\n-            else { comps.pop(); changed = true }\n+            else { comps.pop().unwrap(); changed = true }\n         } else { comps.push(comp) }\n     }\n     if changed {"}, {"sha": "89640add7d05d974282c2e7c1c0db23b31316dcd", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=bada25e425ae30583ad343e36a034e59c66fcad6", "patch": "@@ -1025,7 +1025,7 @@ fn normalize_helper<'a>(s: &'a str, prefix: Option<PathPrefix>) -> (bool,Option<\n             };\n             if (is_abs || has_abs_prefix) && comps.is_empty() { changed = true }\n             else if comps.len() == n_up { comps.push(\"..\"); n_up += 1 }\n-            else { comps.pop(); changed = true }\n+            else { comps.pop().unwrap(); changed = true }\n         } else { comps.push(comp) }\n     }\n     if !changed && !prefix_is_verbatim(prefix) {"}, {"sha": "8f7d01f263dd14dfaf931a4a2ccf416344e19a9f", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=bada25e425ae30583ad343e36a034e59c66fcad6", "patch": "@@ -123,7 +123,7 @@ impl<'a> MovePtr for ReprVisitor<'a> {\n         self.ptr_stk.push(self.ptr);\n     }\n     fn pop_ptr(&mut self) {\n-        self.ptr = self.ptr_stk.pop();\n+        self.ptr = self.ptr_stk.pop().unwrap();\n     }\n }\n \n@@ -471,7 +471,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n                                 n_fields: uint,\n                                 name: &str) -> bool {\n         let mut write = false;\n-        match self.var_stk.pop() {\n+        match self.var_stk.pop().unwrap() {\n             SearchingFor(sought) => {\n                 if disr_val == sought {\n                     self.var_stk.push(Matched);\n@@ -534,7 +534,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n                         _sz: uint,\n                         _align: uint)\n                         -> bool {\n-        match self.var_stk.pop() {\n+        match self.var_stk.pop().unwrap() {\n             SearchingFor(..) => fail!(\"enum value matched no variant\"),\n             _ => true\n         }"}, {"sha": "1dfd2ea560008cbed8258eee3db493d2f783e30e", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 6, "deletions": 25, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=bada25e425ae30583ad343e36a034e59c66fcad6", "patch": "@@ -1381,10 +1381,8 @@ pub trait OwnedVector<T> {\n     /// assert!(a == ~[~1, ~2, ~3, ~4]);\n     /// ```\n     fn push_all_move(&mut self, rhs: ~[T]);\n-    /// Remove the last element from a vector and return it, failing if it is empty\n-    fn pop(&mut self) -> T;\n     /// Remove the last element from a vector and return it, or `None` if it is empty\n-    fn pop_opt(&mut self) -> Option<T>;\n+    fn pop(&mut self) -> Option<T>;\n     /// Removes the first element from a vector and return it\n     fn shift(&mut self) -> T;\n     /// Removes the first element from a vector and return it, or `None` if it is empty\n@@ -1565,7 +1563,7 @@ impl<T> OwnedVector<T> for ~[T] {\n         }\n     }\n \n-    fn pop_opt(&mut self) -> Option<T> {\n+    fn pop(&mut self) -> Option<T> {\n         match self.len() {\n             0  => None,\n             ln => {\n@@ -1579,11 +1577,6 @@ impl<T> OwnedVector<T> for ~[T] {\n     }\n \n \n-    #[inline]\n-    fn pop(&mut self) -> T {\n-        self.pop_opt().expect(\"pop: empty vector\")\n-    }\n-\n     #[inline]\n     fn shift(&mut self) -> T {\n         self.shift_opt().expect(\"shift: empty vector\")\n@@ -3168,28 +3161,16 @@ mod tests {\n         assert_eq!(vec.slice_to(0), &[]);\n     }\n \n-    #[test]\n-    fn test_pop() {\n-        // Test on-heap pop.\n-        let mut v = ~[1, 2, 3, 4, 5];\n-        let e = v.pop();\n-        assert_eq!(v.len(), 4u);\n-        assert_eq!(v[0], 1);\n-        assert_eq!(v[1], 2);\n-        assert_eq!(v[2], 3);\n-        assert_eq!(v[3], 4);\n-        assert_eq!(e, 5);\n-    }\n \n     #[test]\n-    fn test_pop_opt() {\n+    fn test_pop() {\n         let mut v = ~[5];\n-        let e = v.pop_opt();\n+        let e = v.pop();\n         assert_eq!(v.len(), 0);\n         assert_eq!(e, Some(5));\n-        let f = v.pop_opt();\n+        let f = v.pop();\n         assert_eq!(f, None);\n-        let g = v.pop_opt();\n+        let g = v.pop();\n         assert_eq!(g, None);\n     }\n "}, {"sha": "0585f1abecc0c0aab585d1d5b4043883f1f16f42", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=bada25e425ae30583ad343e36a034e59c66fcad6", "patch": "@@ -340,7 +340,7 @@ impl<F: FoldOps> Folder for Ctx<F> {\n             _ => {}\n         }\n \n-        self.path.pop();\n+        self.path.pop().unwrap();\n \n         SmallVector::one(i)\n     }"}, {"sha": "47ae146d19b31b87d4cc1f569391726a6994067f", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=bada25e425ae30583ad343e36a034e59c66fcad6", "patch": "@@ -904,7 +904,7 @@ pub fn mtwt_outer_mark(ctxt: SyntaxContext) -> Mrk {\n /// case pop and discard (so two of the same marks cancel)\n pub fn xorPush(marks: &mut ~[Mrk], mark: Mrk) {\n     if (marks.len() > 0) && (getLast(marks) == mark) {\n-        marks.pop();\n+        marks.pop().unwrap();\n     } else {\n         marks.push(mark);\n     }"}, {"sha": "86982201303507736fd75150af2225fd97178693", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=bada25e425ae30583ad343e36a034e59c66fcad6", "patch": "@@ -356,7 +356,7 @@ impl<'a> ExtCtxt<'a> {\n     pub fn print_backtrace(&self) { }\n     pub fn backtrace(&self) -> Option<@ExpnInfo> { self.backtrace }\n     pub fn mod_push(&mut self, i: ast::Ident) { self.mod_path.push(i); }\n-    pub fn mod_pop(&mut self) { self.mod_path.pop(); }\n+    pub fn mod_pop(&mut self) { self.mod_path.pop().unwrap(); }\n     pub fn mod_path(&self) -> ~[ast::Ident] { self.mod_path.clone() }\n     pub fn bt_push(&mut self, ei: codemap::ExpnInfo) {\n         match ei {"}, {"sha": "3c0d7aaf4f3a82a578870e060341d618ac206c66", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=bada25e425ae30583ad343e36a034e59c66fcad6", "patch": "@@ -253,7 +253,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                 lifetimes: OptVec<ast::Lifetime>,\n                 types: ~[P<ast::Ty>])\n                 -> ast::Path {\n-        let last_identifier = idents.pop();\n+        let last_identifier = idents.pop().unwrap();\n         let mut segments: ~[ast::PathSegment] = idents.move_iter()\n                                                       .map(|ident| {\n             ast::PathSegment {"}, {"sha": "fe519a31efa6b3e656ec8af74eba4ffb8e7a3e0f", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=bada25e425ae30583ad343e36a034e59c66fcad6", "patch": "@@ -841,7 +841,7 @@ impl<'a> MethodDef<'a> {\n                                                      matching,\n                                                      matches_so_far,\n                                                      match_count + 1);\n-                matches_so_far.pop();\n+                matches_so_far.pop().unwrap();\n                 arms.push(cx.arm(trait_.span, ~[ pattern ], arm_expr));\n \n                 if enum_def.variants.len() > 1 {\n@@ -875,7 +875,7 @@ impl<'a> MethodDef<'a> {\n                                                          new_matching,\n                                                          matches_so_far,\n                                                          match_count + 1);\n-                    matches_so_far.pop();\n+                    matches_so_far.pop().unwrap();\n \n                     let arm = cx.arm(trait_.span, ~[ pattern ], arm_expr);\n                     arms.push(arm);"}, {"sha": "1c349c4343ac5697efb870ae60fb8eb4079589ff", "filename": "src/libsyntax/ext/registrar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibsyntax%2Fext%2Fregistrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibsyntax%2Fext%2Fregistrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fregistrar.rs?ref=bada25e425ae30583ad343e36a034e59c66fcad6", "patch": "@@ -42,7 +42,7 @@ pub fn find_macro_registrar(diagnostic: @diagnostic::SpanHandler,\n     match ctx.registrars.len() {\n         0 => None,\n         1 => {\n-            let (node_id, _) = ctx.registrars.pop();\n+            let (node_id, _) = ctx.registrars.pop().unwrap();\n             Some(ast::DefId {\n                 crate: ast::LOCAL_CRATE,\n                 node: node_id"}, {"sha": "492852c6a79760a51c34ea21f68fb572305b4244", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=bada25e425ae30583ad343e36a034e59c66fcad6", "patch": "@@ -238,8 +238,11 @@ pub fn parse(sess: @ParseSess,\n         let TokenAndSpan {tok: tok, sp: sp} = rdr.peek();\n \n         /* we append new items to this while we go */\n-        while !cur_eis.is_empty() { /* for each Earley Item */\n-            let ei = cur_eis.pop();\n+        loop {\n+            let ei = match cur_eis.pop() {\n+                None => break, /* for each Earley Item */\n+                Some(ei) => ei,\n+            };\n \n             let idx = ei.idx;\n             let len = ei.elts.len();\n@@ -347,7 +350,7 @@ pub fn parse(sess: @ParseSess,\n             if eof_eis.len() == 1u {\n                 let mut v = ~[];\n                 for dv in eof_eis[0u].matches.mut_iter() {\n-                    v.push(dv.pop());\n+                    v.push(dv.pop().unwrap());\n                 }\n                 return Success(nameize(sess, ms, v));\n             } else if eof_eis.len() > 1u {\n@@ -376,13 +379,13 @@ pub fn parse(sess: @ParseSess,\n             } else if next_eis.len() > 0u {\n                 /* Now process the next token */\n                 while next_eis.len() > 0u {\n-                    cur_eis.push(next_eis.pop());\n+                    cur_eis.push(next_eis.pop().unwrap());\n                 }\n                 rdr.next_token();\n             } else /* bb_eis.len() == 1 */ {\n                 let mut rust_parser = Parser(sess, cfg.clone(), rdr.dup());\n \n-                let mut ei = bb_eis.pop();\n+                let mut ei = bb_eis.pop().unwrap();\n                 match ei.elts[ei.idx].node {\n                   MatchNonterminal(_, ref name, idx) => {\n                     ei.matches[idx].push(@MatchedNonterminal("}, {"sha": "20d544f52c90f8a035a89f5ad0a9e57064ec52a2", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=bada25e425ae30583ad343e36a034e59c66fcad6", "patch": "@@ -204,8 +204,8 @@ pub fn tt_next_token(r: &TtReader) -> TokenAndSpan {\n                     {\n                         let mut repeat_idx = r.repeat_idx.borrow_mut();\n                         let mut repeat_len = r.repeat_len.borrow_mut();\n-                        repeat_idx.get().pop();\n-                        repeat_len.get().pop();\n+                        repeat_idx.get().pop().unwrap();\n+                        repeat_len.get().pop().unwrap();\n                     }\n                 }\n "}, {"sha": "ce3042cb9cde5d6ea2be5cde9991010f03836b53", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=bada25e425ae30583ad343e36a034e59c66fcad6", "patch": "@@ -48,10 +48,10 @@ impl<T> OptVec<T> {\n         }\n     }\n \n-    pub fn pop(&mut self) -> T {\n+    pub fn pop(&mut self) -> Option<T> {\n         match *self {\n             Vec(ref mut v) => v.pop(),\n-            Empty => fail!(\"pop from empty opt_vec\")\n+            Empty => None\n         }\n     }\n "}, {"sha": "4e1703fe6b0c796e42550234d017f7659a8cb657", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=bada25e425ae30583ad343e36a034e59c66fcad6", "patch": "@@ -2158,7 +2158,7 @@ impl Parser {\n \n                 // Parse the close delimiter.\n                 result.push(parse_any_tt_tok(self));\n-                self.open_braces.pop();\n+                self.open_braces.pop().unwrap();\n \n                 TTDelim(@result)\n             }\n@@ -3593,7 +3593,7 @@ impl Parser {\n                 }\n             );\n \n-        let variadic = match args.pop_opt() {\n+        let variadic = match args.pop() {\n             Some(None) => true,\n             Some(x) => {\n                 // Need to put back that last arg\n@@ -4218,7 +4218,7 @@ impl Parser {\n     }\n \n     fn pop_mod_path(&mut self) {\n-        self.mod_path_stack.pop();\n+        self.mod_path_stack.pop().unwrap();\n     }\n \n     // read a module from a source file."}, {"sha": "902d9e1c28468e16e933c5278a41eb4189367e20", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=bada25e425ae30583ad343e36a034e59c66fcad6", "patch": "@@ -511,7 +511,7 @@ impl Printer {\n             debug!(\"print End -> pop End\");\n             let print_stack = &mut self.print_stack;\n             assert!((print_stack.len() != 0u));\n-            print_stack.pop();\n+            print_stack.pop().unwrap();\n           }\n           Break(b) => {\n             let top = self.get_top();"}, {"sha": "cdfeebd3e1bc88e3df3022ff73ef6c6515c88fa7", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=bada25e425ae30583ad343e36a034e59c66fcad6", "patch": "@@ -78,7 +78,7 @@ pub fn ibox(s: &mut State, u: uint) {\n pub fn end(s: &mut State) {\n     {\n         let mut boxes = s.boxes.borrow_mut();\n-        boxes.get().pop();\n+        boxes.get().pop().unwrap();\n     }\n     pp::end(&mut s.s);\n }\n@@ -1090,11 +1090,11 @@ pub fn print_call_pre(s: &mut State,\n     match sugar {\n         ast::DoSugar => {\n             head(s, \"do\");\n-            Some(base_args.pop())\n+            Some(base_args.pop().unwrap())\n         }\n         ast::ForSugar => {\n             head(s, \"for\");\n-            Some(base_args.pop())\n+            Some(base_args.pop().unwrap())\n         }\n         ast::NoSugar => None\n     }"}, {"sha": "a5838f2017385f56bcda105ce7c03b2e8fe7bfec", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=bada25e425ae30583ad343e36a034e59c66fcad6", "patch": "@@ -40,7 +40,7 @@ fn recv(p: &pipe) -> uint {\n             while state.is_empty() {\n                 cond.wait();\n             }\n-            state.pop()\n+            state.pop().unwrap()\n         })\n     }\n }"}, {"sha": "fa7026b6569f9dfb16eeb6e463b406e267e1a440", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bada25e425ae30583ad343e36a034e59c66fcad6/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=bada25e425ae30583ad343e36a034e59c66fcad6", "patch": "@@ -37,7 +37,7 @@ fn recv(p: &pipe) -> uint {\n         while state.is_empty() {\n             cond.wait();\n         }\n-        state.pop()\n+        state.pop().unwrap()\n     })\n }\n "}]}