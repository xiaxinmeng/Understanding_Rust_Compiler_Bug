{"sha": "cc9999c60992fd751f6224305bde84b7246b680b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjOTk5OWM2MDk5MmZkNzUxZjYyMjQzMDViZGU4NGI3MjQ2YjY4MGI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-30T21:14:58Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-30T21:14:58Z"}, "message": "librustc: De-record the type context. rs=derecordification", "tree": {"sha": "b4ecf1b6ba56983ca49d775aa51dbb4172b698a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4ecf1b6ba56983ca49d775aa51dbb4172b698a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc9999c60992fd751f6224305bde84b7246b680b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc9999c60992fd751f6224305bde84b7246b680b", "html_url": "https://github.com/rust-lang/rust/commit/cc9999c60992fd751f6224305bde84b7246b680b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc9999c60992fd751f6224305bde84b7246b680b/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "684aa2b7fdc22313ffec159711017344d444d75b", "url": "https://api.github.com/repos/rust-lang/rust/commits/684aa2b7fdc22313ffec159711017344d444d75b", "html_url": "https://github.com/rust-lang/rust/commit/684aa2b7fdc22313ffec159711017344d444d75b"}], "stats": {"total": 213, "additions": 108, "deletions": 105}, "files": [{"sha": "6833c82e2d20205ab7d435d2499403c27179cdf3", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 108, "deletions": 105, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/cc9999c60992fd751f6224305bde84b7246b680b/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc9999c60992fd751f6224305bde84b7246b680b/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=cc9999c60992fd751f6224305bde84b7246b680b", "patch": "@@ -233,72 +233,74 @@ pub struct InstantiatedTraitRef {\n     tpt: ty_param_substs_and_ty\n }\n \n-pub type ctxt =\n-    @{diag: syntax::diagnostic::span_handler,\n-      interner: HashMap<intern_key, t_box>,\n-      mut next_id: uint,\n-      vecs_implicitly_copyable: bool,\n-      legacy_modes: bool,\n-      legacy_records: bool,\n-      cstore: metadata::cstore::CStore,\n-      sess: session::Session,\n-      def_map: resolve::DefMap,\n-\n-      region_map: middle::region::region_map,\n-      region_paramd_items: middle::region::region_paramd_items,\n-\n-      // Stores the types for various nodes in the AST.  Note that this table\n-      // is not guaranteed to be populated until after typeck.  See\n-      // typeck::check::fn_ctxt for details.\n-      node_types: node_type_table,\n-\n-      // Stores the type parameters which were substituted to obtain the type\n-      // of this node.  This only applies to nodes that refer to entities\n-      // parameterized by type parameters, such as generic fns, types, or\n-      // other items.\n-      node_type_substs: HashMap<node_id, ~[t]>,\n-\n-      items: ast_map::map,\n-      intrinsic_defs: HashMap<ast::ident, (ast::def_id, t)>,\n-      freevars: freevars::freevar_map,\n-      tcache: type_cache,\n-      rcache: creader_cache,\n-      ccache: constness_cache,\n-      short_names_cache: HashMap<t, @~str>,\n-      needs_drop_cache: HashMap<t, bool>,\n-      needs_unwind_cleanup_cache: HashMap<t, bool>,\n-      kind_cache: HashMap<t, Kind>,\n-      ast_ty_to_ty_cache: HashMap<@ast::Ty, ast_ty_to_ty_cache_entry>,\n-      enum_var_cache: HashMap<def_id, @~[VariantInfo]>,\n-      trait_method_cache: HashMap<def_id, @~[method]>,\n-      ty_param_bounds: HashMap<ast::node_id, param_bounds>,\n-      inferred_modes: HashMap<ast::node_id, ast::mode>,\n-      adjustments: HashMap<ast::node_id, @AutoAdjustment>,\n-      normalized_cache: HashMap<t, t>,\n-      lang_items: middle::lang_items::LanguageItems,\n-      legacy_boxed_traits: HashMap<node_id, ()>,\n-      // A mapping from an implementation ID to the method info and trait\n-      // method ID of the provided (a.k.a. default) methods in the traits that\n-      // that implementation implements.\n-      provided_methods: ProvidedMethodsMap,\n-      provided_method_sources: HashMap<ast::def_id, ProvidedMethodSource>,\n-      supertraits: HashMap<ast::def_id, @~[InstantiatedTraitRef]>,\n-\n-      // A mapping from the def ID of an enum or struct type to the def ID\n-      // of the method that implements its destructor. If the type is not\n-      // present in this map, it does not have a destructor. This map is\n-      // populated during the coherence phase of typechecking.\n-      destructor_for_type: HashMap<ast::def_id, ast::def_id>,\n-\n-      // A method will be in this list if and only if it is a destructor.\n-      destructors: HashMap<ast::def_id, ()>,\n-\n-      // Records the value mode (read, copy, or move) for every value.\n-      value_modes: HashMap<ast::node_id, ValueMode>,\n-\n-      // Maps a trait onto a mapping from self-ty to impl\n-      trait_impls: HashMap<ast::def_id, HashMap<t, @Impl>>\n-      };\n+pub type ctxt = @ctxt_;\n+\n+struct ctxt_ {\n+    diag: syntax::diagnostic::span_handler,\n+    interner: HashMap<intern_key, t_box>,\n+    mut next_id: uint,\n+    vecs_implicitly_copyable: bool,\n+    legacy_modes: bool,\n+    legacy_records: bool,\n+    cstore: metadata::cstore::CStore,\n+    sess: session::Session,\n+    def_map: resolve::DefMap,\n+\n+    region_map: middle::region::region_map,\n+    region_paramd_items: middle::region::region_paramd_items,\n+\n+    // Stores the types for various nodes in the AST.  Note that this table\n+    // is not guaranteed to be populated until after typeck.  See\n+    // typeck::check::fn_ctxt for details.\n+    node_types: node_type_table,\n+\n+    // Stores the type parameters which were substituted to obtain the type\n+    // of this node.  This only applies to nodes that refer to entities\n+    // parameterized by type parameters, such as generic fns, types, or\n+    // other items.\n+    node_type_substs: HashMap<node_id, ~[t]>,\n+\n+    items: ast_map::map,\n+    intrinsic_defs: HashMap<ast::ident, (ast::def_id, t)>,\n+    freevars: freevars::freevar_map,\n+    tcache: type_cache,\n+    rcache: creader_cache,\n+    ccache: constness_cache,\n+    short_names_cache: HashMap<t, @~str>,\n+    needs_drop_cache: HashMap<t, bool>,\n+    needs_unwind_cleanup_cache: HashMap<t, bool>,\n+    kind_cache: HashMap<t, Kind>,\n+    ast_ty_to_ty_cache: HashMap<@ast::Ty, ast_ty_to_ty_cache_entry>,\n+    enum_var_cache: HashMap<def_id, @~[VariantInfo]>,\n+    trait_method_cache: HashMap<def_id, @~[method]>,\n+    ty_param_bounds: HashMap<ast::node_id, param_bounds>,\n+    inferred_modes: HashMap<ast::node_id, ast::mode>,\n+    adjustments: HashMap<ast::node_id, @AutoAdjustment>,\n+    normalized_cache: HashMap<t, t>,\n+    lang_items: middle::lang_items::LanguageItems,\n+    legacy_boxed_traits: HashMap<node_id, ()>,\n+    // A mapping from an implementation ID to the method info and trait\n+    // method ID of the provided (a.k.a. default) methods in the traits that\n+    // that implementation implements.\n+    provided_methods: ProvidedMethodsMap,\n+    provided_method_sources: HashMap<ast::def_id, ProvidedMethodSource>,\n+    supertraits: HashMap<ast::def_id, @~[InstantiatedTraitRef]>,\n+\n+    // A mapping from the def ID of an enum or struct type to the def ID\n+    // of the method that implements its destructor. If the type is not\n+    // present in this map, it does not have a destructor. This map is\n+    // populated during the coherence phase of typechecking.\n+    destructor_for_type: HashMap<ast::def_id, ast::def_id>,\n+\n+    // A method will be in this list if and only if it is a destructor.\n+    destructors: HashMap<ast::def_id, ()>,\n+\n+    // Records the value mode (read, copy, or move) for every value.\n+    value_modes: HashMap<ast::node_id, ValueMode>,\n+\n+    // Maps a trait onto a mapping from self-ty to impl\n+    trait_impls: HashMap<ast::def_id, HashMap<t, @Impl>>\n+}\n \n enum tbox_flag {\n     has_params = 1,\n@@ -833,45 +835,46 @@ pub fn mk_ctxt(s: session::Session,\n     let vecs_implicitly_copyable =\n         get_lint_level(s.lint_settings.default_settings,\n                        lint::vecs_implicitly_copyable) == allow;\n-    @{diag: s.diagnostic(),\n-      interner: interner,\n-      mut next_id: 0u,\n-      vecs_implicitly_copyable: vecs_implicitly_copyable,\n-      legacy_modes: legacy_modes,\n-      legacy_records: legacy_records,\n-      cstore: s.cstore,\n-      sess: s,\n-      def_map: dm,\n-      region_map: region_map,\n-      region_paramd_items: region_paramd_items,\n-      node_types: @smallintmap::mk(),\n-      node_type_substs: map::HashMap(),\n-      items: amap,\n-      intrinsic_defs: map::HashMap(),\n-      freevars: freevars,\n-      tcache: HashMap(),\n-      rcache: mk_rcache(),\n-      ccache: HashMap(),\n-      short_names_cache: new_ty_hash(),\n-      needs_drop_cache: new_ty_hash(),\n-      needs_unwind_cleanup_cache: new_ty_hash(),\n-      kind_cache: new_ty_hash(),\n-      ast_ty_to_ty_cache: HashMap(),\n-      enum_var_cache: HashMap(),\n-      trait_method_cache: HashMap(),\n-      ty_param_bounds: HashMap(),\n-      inferred_modes: HashMap(),\n-      adjustments: HashMap(),\n-      normalized_cache: new_ty_hash(),\n-      lang_items: move lang_items,\n-      legacy_boxed_traits: HashMap(),\n-      provided_methods: HashMap(),\n-      provided_method_sources: HashMap(),\n-      supertraits: HashMap(),\n-      destructor_for_type: HashMap(),\n-      destructors: HashMap(),\n-      value_modes: HashMap(),\n-      trait_impls: HashMap()\n+    @ctxt_ {\n+        diag: s.diagnostic(),\n+        interner: interner,\n+        mut next_id: 0u,\n+        vecs_implicitly_copyable: vecs_implicitly_copyable,\n+        legacy_modes: legacy_modes,\n+        legacy_records: legacy_records,\n+        cstore: s.cstore,\n+        sess: s,\n+        def_map: dm,\n+        region_map: region_map,\n+        region_paramd_items: region_paramd_items,\n+        node_types: @smallintmap::mk(),\n+        node_type_substs: map::HashMap(),\n+        items: amap,\n+        intrinsic_defs: map::HashMap(),\n+        freevars: freevars,\n+        tcache: HashMap(),\n+        rcache: mk_rcache(),\n+        ccache: HashMap(),\n+        short_names_cache: new_ty_hash(),\n+        needs_drop_cache: new_ty_hash(),\n+        needs_unwind_cleanup_cache: new_ty_hash(),\n+        kind_cache: new_ty_hash(),\n+        ast_ty_to_ty_cache: HashMap(),\n+        enum_var_cache: HashMap(),\n+        trait_method_cache: HashMap(),\n+        ty_param_bounds: HashMap(),\n+        inferred_modes: HashMap(),\n+        adjustments: HashMap(),\n+        normalized_cache: new_ty_hash(),\n+        lang_items: move lang_items,\n+        legacy_boxed_traits: HashMap(),\n+        provided_methods: HashMap(),\n+        provided_method_sources: HashMap(),\n+        supertraits: HashMap(),\n+        destructor_for_type: HashMap(),\n+        destructors: HashMap(),\n+        value_modes: HashMap(),\n+        trait_impls: HashMap()\n      }\n }\n "}]}