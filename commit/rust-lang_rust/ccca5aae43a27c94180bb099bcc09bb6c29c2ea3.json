{"sha": "ccca5aae43a27c94180bb099bcc09bb6c29c2ea3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjY2E1YWFlNDNhMjdjOTQxODBiYjA5OWJjYzA5YmI2YzI5YzJlYTM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-12-21T21:52:02Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-12-21T21:52:02Z"}, "message": "scope-based copmletions on original file", "tree": {"sha": "3d6ce58a0e87cb89ef4ca2df29e5f25bac86d0b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d6ce58a0e87cb89ef4ca2df29e5f25bac86d0b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ccca5aae43a27c94180bb099bcc09bb6c29c2ea3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ccca5aae43a27c94180bb099bcc09bb6c29c2ea3", "html_url": "https://github.com/rust-lang/rust/commit/ccca5aae43a27c94180bb099bcc09bb6c29c2ea3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ccca5aae43a27c94180bb099bcc09bb6c29c2ea3/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2136e75c0bce090d104bb5b5006e48e42fb22a0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2136e75c0bce090d104bb5b5006e48e42fb22a0a", "html_url": "https://github.com/rust-lang/rust/commit/2136e75c0bce090d104bb5b5006e48e42fb22a0a"}], "stats": {"total": 545, "additions": 223, "deletions": 322}, "files": [{"sha": "93edcc4c267b94d859177ff2cc7a9f61945f902d", "filename": "crates/ra_analysis/src/completion.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ccca5aae43a27c94180bb099bcc09bb6c29c2ea3/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccca5aae43a27c94180bb099bcc09bb6c29c2ea3/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs?ref=ccca5aae43a27c94180bb099bcc09bb6c29c2ea3", "patch": "@@ -1,10 +1,10 @@\n mod completion_item;\n-mod reference_completion;\n \n mod complete_fn_param;\n mod complete_keyword;\n mod complete_snippet;\n mod complete_path;\n+mod complete_scope;\n \n use ra_editor::find_node_at_offset;\n use ra_text_edit::AtomTextEdit;\n@@ -33,26 +33,16 @@ pub(crate) fn completions(\n     position: FilePosition,\n ) -> Cancelable<Option<Completions>> {\n     let original_file = db.source_file(position.file_id);\n-    // Insert a fake ident to get a valid parse tree\n-    let file = {\n-        let edit = AtomTextEdit::insert(position.offset, \"intellijRulezz\".to_string());\n-        original_file.reparse(&edit)\n-    };\n-    let module = ctry!(source_binder::module_from_position(db, position)?);\n+    let ctx = ctry!(SyntaxContext::new(db, &original_file, position)?);\n \n     let mut acc = Completions::default();\n \n-    // First, let's try to complete a reference to some declaration.\n-    if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(file.syntax(), position.offset) {\n-        reference_completion::completions(&mut acc, db, &module, &file, name_ref)?;\n-    }\n-\n-    let ctx = ctry!(SyntaxContext::new(db, &original_file, position)?);\n     complete_fn_param::complete_fn_param(&mut acc, &ctx);\n     complete_keyword::complete_expr_keyword(&mut acc, &ctx);\n     complete_snippet::complete_expr_snippet(&mut acc, &ctx);\n     complete_snippet::complete_item_snippet(&mut acc, &ctx);\n     complete_path::complete_path(&mut acc, &ctx)?;\n+    complete_scope::complete_scope(&mut acc, &ctx)?;\n \n     Ok(Some(acc))\n }\n@@ -62,6 +52,7 @@ pub(crate) fn completions(\n #[derive(Debug)]\n pub(super) struct SyntaxContext<'a> {\n     db: &'a db::RootDatabase,\n+    offset: TextUnit,\n     leaf: SyntaxNodeRef<'a>,\n     module: Option<hir::Module>,\n     enclosing_fn: Option<ast::FnDef<'a>>,\n@@ -88,6 +79,7 @@ impl<'a> SyntaxContext<'a> {\n         let mut ctx = SyntaxContext {\n             db,\n             leaf,\n+            offset: position.offset,\n             module,\n             enclosing_fn: None,\n             is_param: false,"}, {"sha": "8374ec34612b7f06e6881eb662d19f6f335ad6f3", "filename": "crates/ra_analysis/src/completion/complete_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ccca5aae43a27c94180bb099bcc09bb6c29c2ea3/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccca5aae43a27c94180bb099bcc09bb6c29c2ea3/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_path.rs?ref=ccca5aae43a27c94180bb099bcc09bb6c29c2ea3", "patch": "@@ -9,8 +9,8 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &SyntaxContext) -> Cance\n         _ => return Ok(()),\n     };\n     let def_id = match module.resolve_path(ctx.db, path)? {\n-        None => return Ok(()),\n         Some(it) => it,\n+        None => return Ok(()),\n     };\n     let target_module = match def_id.resolve(ctx.db)? {\n         hir::Def::Module(it) => it,"}, {"sha": "4ffd630165c00c52b44edd33e2433debb0dac625", "filename": "crates/ra_analysis/src/completion/complete_scope.rs", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/ccca5aae43a27c94180bb099bcc09bb6c29c2ea3/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccca5aae43a27c94180bb099bcc09bb6c29c2ea3/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_scope.rs?ref=ccca5aae43a27c94180bb099bcc09bb6c29c2ea3", "patch": "@@ -0,0 +1,171 @@\n+use rustc_hash::FxHashSet;\n+use ra_syntax::TextUnit;\n+\n+use crate::{\n+    completion::{CompletionItem, Completions, CompletionKind::*, SyntaxContext},\n+    Cancelable\n+};\n+\n+pub(super) fn complete_scope(acc: &mut Completions, ctx: &SyntaxContext) -> Cancelable<()> {\n+    if !ctx.is_trivial_path {\n+        return Ok(());\n+    }\n+    if let Some(fn_def) = ctx.enclosing_fn {\n+        let scopes = hir::FnScopes::new(fn_def);\n+        complete_fn(acc, &scopes, ctx.offset);\n+    }\n+\n+    if let Some(module) = &ctx.module {\n+        let module_scope = module.scope(ctx.db)?;\n+        module_scope\n+            .entries()\n+            .filter(|(_name, res)| {\n+                // Don't expose this item\n+                match res.import {\n+                    None => true,\n+                    Some(import) => {\n+                        let range = import.range(ctx.db, module.source().file_id());\n+                        !range.is_subrange(&ctx.leaf.range())\n+                    }\n+                }\n+            })\n+            .for_each(|(name, _res)| {\n+                CompletionItem::new(name.to_string())\n+                    .kind(Reference)\n+                    .add_to(acc)\n+            });\n+    }\n+\n+    Ok(())\n+}\n+\n+fn complete_fn(acc: &mut Completions, scopes: &hir::FnScopes, offset: TextUnit) {\n+    let mut shadowed = FxHashSet::default();\n+    scopes\n+        .scope_chain_for_offset(offset)\n+        .flat_map(|scope| scopes.entries(scope).iter())\n+        .filter(|entry| shadowed.insert(entry.name()))\n+        .for_each(|entry| {\n+            CompletionItem::new(entry.name().to_string())\n+                .kind(Reference)\n+                .add_to(acc)\n+        });\n+    if scopes.self_param.is_some() {\n+        CompletionItem::new(\"self\").kind(Reference).add_to(acc);\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::completion::{CompletionKind, check_completion};\n+\n+    fn check_reference_completion(code: &str, expected_completions: &str) {\n+        check_completion(code, expected_completions, CompletionKind::Reference);\n+    }\n+\n+    #[test]\n+    fn test_completion_let_scope() {\n+        check_reference_completion(\n+            r\"\n+            fn quux(x: i32) {\n+                let y = 92;\n+                1 + <|>;\n+                let z = ();\n+            }\n+            \",\n+            \"y;x;quux\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_if_let_scope() {\n+        check_reference_completion(\n+            r\"\n+            fn quux() {\n+                if let Some(x) = foo() {\n+                    let y = 92;\n+                };\n+                if let Some(a) = bar() {\n+                    let b = 62;\n+                    1 + <|>\n+                }\n+            }\n+            \",\n+            \"b;a;quux\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_for_scope() {\n+        check_reference_completion(\n+            r\"\n+            fn quux() {\n+                for x in &[1, 2, 3] {\n+                    <|>\n+                }\n+            }\n+            \",\n+            \"x;quux\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_mod_scope() {\n+        check_reference_completion(\n+            r\"\n+            struct Foo;\n+            enum Baz {}\n+            fn quux() {\n+                <|>\n+            }\n+            \",\n+            \"quux;Foo;Baz\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_mod_scope_nested() {\n+        check_reference_completion(\n+            r\"\n+            struct Foo;\n+            mod m {\n+                struct Bar;\n+                fn quux() { <|> }\n+            }\n+            \",\n+            \"quux;Bar\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_complete_type() {\n+        check_reference_completion(\n+            r\"\n+            struct Foo;\n+            fn x() -> <|>\n+            \",\n+            \"Foo;x\",\n+        )\n+    }\n+\n+    #[test]\n+    fn test_complete_shadowing() {\n+        check_reference_completion(\n+            r\"\n+            fn foo() -> {\n+                let bar = 92;\n+                {\n+                    let bar = 62;\n+                    <|>\n+                }\n+            }\n+            \",\n+            \"bar;foo\",\n+        )\n+    }\n+\n+    #[test]\n+    fn test_complete_self() {\n+        check_reference_completion(r\"impl S { fn foo(&self) { <|> } }\", \"self\")\n+    }\n+}"}, {"sha": "459ed8f6f763c8c6e8a9feb0b8c38ff704beda02", "filename": "crates/ra_analysis/src/completion/reference_completion.rs", "status": "removed", "additions": 0, "deletions": 307, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/2136e75c0bce090d104bb5b5006e48e42fb22a0a/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2136e75c0bce090d104bb5b5006e48e42fb22a0a/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs?ref=2136e75c0bce090d104bb5b5006e48e42fb22a0a", "patch": "@@ -1,307 +0,0 @@\n-use rustc_hash::FxHashSet;\n-use ra_syntax::{\n-    SourceFileNode, AstNode,\n-    ast,\n-    SyntaxKind::*,\n-};\n-use hir::{\n-    self,\n-    FnScopes, Path\n-};\n-\n-use crate::{\n-    db::RootDatabase,\n-    completion::{CompletionItem, Completions, CompletionKind::*},\n-    Cancelable\n-};\n-\n-pub(super) fn completions(\n-    acc: &mut Completions,\n-    db: &RootDatabase,\n-    module: &hir::Module,\n-    _file: &SourceFileNode,\n-    name_ref: ast::NameRef,\n-) -> Cancelable<()> {\n-    let kind = match classify_name_ref(name_ref) {\n-        Some(it) => it,\n-        None => return Ok(()),\n-    };\n-\n-    match kind {\n-        NameRefKind::LocalRef { enclosing_fn } => {\n-            if let Some(fn_def) = enclosing_fn {\n-                let scopes = FnScopes::new(fn_def);\n-                complete_fn(name_ref, &scopes, acc);\n-            }\n-\n-            let module_scope = module.scope(db)?;\n-            module_scope\n-                .entries()\n-                .filter(|(_name, res)| {\n-                    // Don't expose this item\n-                    match res.import {\n-                        None => true,\n-                        Some(import) => {\n-                            let range = import.range(db, module.source().file_id());\n-                            !range.is_subrange(&name_ref.syntax().range())\n-                        }\n-                    }\n-                })\n-                .for_each(|(name, _res)| {\n-                    CompletionItem::new(name.to_string())\n-                        .kind(Reference)\n-                        .add_to(acc)\n-                });\n-        }\n-        NameRefKind::Path(_) => (),\n-        NameRefKind::BareIdentInMod => (),\n-    }\n-    Ok(())\n-}\n-\n-enum NameRefKind<'a> {\n-    /// NameRef is a part of single-segment path, for example, a refernece to a\n-    /// local variable.\n-    LocalRef {\n-        enclosing_fn: Option<ast::FnDef<'a>>,\n-    },\n-    /// NameRef is the last segment in some path\n-    Path(Path),\n-    /// NameRef is bare identifier at the module's root.\n-    /// Used for keyword completion\n-    BareIdentInMod,\n-}\n-\n-fn classify_name_ref(name_ref: ast::NameRef) -> Option<NameRefKind> {\n-    let name_range = name_ref.syntax().range();\n-    let top_node = name_ref\n-        .syntax()\n-        .ancestors()\n-        .take_while(|it| it.range() == name_range)\n-        .last()\n-        .unwrap();\n-    match top_node.parent().map(|it| it.kind()) {\n-        Some(SOURCE_FILE) | Some(ITEM_LIST) => return Some(NameRefKind::BareIdentInMod),\n-        _ => (),\n-    }\n-\n-    let parent = name_ref.syntax().parent()?;\n-    if let Some(segment) = ast::PathSegment::cast(parent) {\n-        let path = segment.parent_path();\n-        if let Some(path) = Path::from_ast(path) {\n-            if !path.is_ident() {\n-                return Some(NameRefKind::Path(path));\n-            }\n-        }\n-        if path.qualifier().is_none() {\n-            let enclosing_fn = name_ref\n-                .syntax()\n-                .ancestors()\n-                .take_while(|it| it.kind() != SOURCE_FILE && it.kind() != MODULE)\n-                .find_map(ast::FnDef::cast);\n-            return Some(NameRefKind::LocalRef { enclosing_fn });\n-        }\n-    }\n-    None\n-}\n-\n-fn complete_fn(name_ref: ast::NameRef, scopes: &FnScopes, acc: &mut Completions) {\n-    let mut shadowed = FxHashSet::default();\n-    scopes\n-        .scope_chain(name_ref.syntax())\n-        .flat_map(|scope| scopes.entries(scope).iter())\n-        .filter(|entry| shadowed.insert(entry.name()))\n-        .for_each(|entry| {\n-            CompletionItem::new(entry.name().to_string())\n-                .kind(Reference)\n-                .add_to(acc)\n-        });\n-    if scopes.self_param.is_some() {\n-        CompletionItem::new(\"self\").kind(Reference).add_to(acc);\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::completion::{CompletionKind, check_completion};\n-\n-    fn check_reference_completion(code: &str, expected_completions: &str) {\n-        check_completion(code, expected_completions, CompletionKind::Reference);\n-    }\n-\n-    #[test]\n-    fn test_completion_let_scope() {\n-        check_reference_completion(\n-            r\"\n-            fn quux(x: i32) {\n-                let y = 92;\n-                1 + <|>;\n-                let z = ();\n-            }\n-            \",\n-            \"y;x;quux\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_completion_if_let_scope() {\n-        check_reference_completion(\n-            r\"\n-            fn quux() {\n-                if let Some(x) = foo() {\n-                    let y = 92;\n-                };\n-                if let Some(a) = bar() {\n-                    let b = 62;\n-                    1 + <|>\n-                }\n-            }\n-            \",\n-            \"b;a;quux\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_completion_for_scope() {\n-        check_reference_completion(\n-            r\"\n-            fn quux() {\n-                for x in &[1, 2, 3] {\n-                    <|>\n-                }\n-            }\n-            \",\n-            \"x;quux\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_completion_mod_scope() {\n-        check_reference_completion(\n-            r\"\n-            struct Foo;\n-            enum Baz {}\n-            fn quux() {\n-                <|>\n-            }\n-            \",\n-            \"quux;Foo;Baz\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_completion_mod_scope_no_self_use() {\n-        check_reference_completion(\n-            r\"\n-            use foo<|>;\n-            \",\n-            \"\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_completion_self_path() {\n-        check_reference_completion(\n-            r\"\n-            use self::m::<|>;\n-\n-            mod m {\n-                struct Bar;\n-            }\n-            \",\n-            \"Bar\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_completion_mod_scope_nested() {\n-        check_reference_completion(\n-            r\"\n-            struct Foo;\n-            mod m {\n-                struct Bar;\n-                fn quux() { <|> }\n-            }\n-            \",\n-            \"quux;Bar\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_complete_type() {\n-        check_reference_completion(\n-            r\"\n-            struct Foo;\n-            fn x() -> <|>\n-            \",\n-            \"Foo;x\",\n-        )\n-    }\n-\n-    #[test]\n-    fn test_complete_shadowing() {\n-        check_reference_completion(\n-            r\"\n-            fn foo() -> {\n-                let bar = 92;\n-                {\n-                    let bar = 62;\n-                    <|>\n-                }\n-            }\n-            \",\n-            \"bar;foo\",\n-        )\n-    }\n-\n-    #[test]\n-    fn test_complete_self() {\n-        check_reference_completion(r\"impl S { fn foo(&self) { <|> } }\", \"self\")\n-    }\n-\n-    #[test]\n-    fn test_complete_crate_path() {\n-        check_reference_completion(\n-            \"\n-            //- /lib.rs\n-            mod foo;\n-            struct Spam;\n-            //- /foo.rs\n-            use crate::Sp<|>\n-            \",\n-            \"Spam;foo\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_complete_crate_path_with_braces() {\n-        check_reference_completion(\n-            \"\n-            //- /lib.rs\n-            mod foo;\n-            struct Spam;\n-            //- /foo.rs\n-            use crate::{Sp<|>};\n-            \",\n-            \"Spam;foo\",\n-        );\n-    }\n-\n-    #[test]\n-    fn test_complete_crate_path_in_nested_tree() {\n-        check_reference_completion(\n-            \"\n-            //- /lib.rs\n-            mod foo;\n-            pub mod bar {\n-                pub mod baz {\n-                    pub struct Spam;\n-                }\n-            }\n-            //- /foo.rs\n-            use crate::{bar::{baz::Sp<|>}};\n-            \",\n-            \"Spam\",\n-        );\n-    }\n-}"}, {"sha": "9f1aa1ef2d876fc3e0c589a1c3cdda18e9a6b9a1", "filename": "crates/ra_hir/src/function/scope.rs", "status": "modified", "additions": 46, "deletions": 1, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/ccca5aae43a27c94180bb099bcc09bb6c29c2ea3/crates%2Fra_hir%2Fsrc%2Ffunction%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ccca5aae43a27c94180bb099bcc09bb6c29c2ea3/crates%2Fra_hir%2Fsrc%2Ffunction%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffunction%2Fscope.rs?ref=ccca5aae43a27c94180bb099bcc09bb6c29c2ea3", "patch": "@@ -1,7 +1,7 @@\n use rustc_hash::{FxHashMap, FxHashSet};\n \n use ra_syntax::{\n-    AstNode, SmolStr, SyntaxNodeRef, TextRange,\n+    AstNode, SmolStr, SyntaxNodeRef, TextUnit, TextRange,\n     algo::generate,\n     ast::{self, ArgListOwner, LoopBodyOwner, NameOwner},\n };\n@@ -57,6 +57,48 @@ impl FnScopes {\n             self.scopes[scope].parent\n         })\n     }\n+    pub fn scope_chain_for_offset<'a>(\n+        &'a self,\n+        offset: TextUnit,\n+    ) -> impl Iterator<Item = ScopeId> + 'a {\n+        let scope = self\n+            .scope_for\n+            .iter()\n+            // find containin scope\n+            .min_by_key(|(ptr, _scope)| {\n+                (\n+                    !(ptr.range().start() <= offset && offset <= ptr.range().end()),\n+                    ptr.range().len(),\n+                )\n+            })\n+            .map(|(ptr, scope)| self.adjust(*ptr, *scope, offset));\n+\n+        generate(scope, move |&scope| self.scopes[scope].parent)\n+    }\n+    // XXX: during completion, cursor might be outside of any particular\n+    // expression. Try to figure out the correct scope...\n+    fn adjust(&self, ptr: LocalSyntaxPtr, original_scope: ScopeId, offset: TextUnit) -> ScopeId {\n+        let r = ptr.range();\n+        let child_scopes = self\n+            .scope_for\n+            .iter()\n+            .map(|(ptr, scope)| (ptr.range(), scope))\n+            .filter(|(range, _)| range.start() <= offset && range.is_subrange(&r) && *range != r);\n+\n+        child_scopes\n+            .max_by(|(r1, _), (r2, _)| {\n+                if r2.is_subrange(&r1) {\n+                    std::cmp::Ordering::Greater\n+                } else if r1.is_subrange(&r2) {\n+                    std::cmp::Ordering::Less\n+                } else {\n+                    r1.start().cmp(&r2.start())\n+                }\n+            })\n+            .map(|(ptr, scope)| *scope)\n+            .unwrap_or(original_scope)\n+    }\n+\n     pub fn resolve_local_name<'a>(&'a self, name_ref: ast::NameRef) -> Option<&'a ScopeEntry> {\n         let mut shadowed = FxHashSet::default();\n         let ret = self\n@@ -144,6 +186,8 @@ impl ScopeEntry {\n }\n \n fn compute_block_scopes(block: ast::Block, scopes: &mut FnScopes, mut scope: ScopeId) {\n+    // A hack for completion :(\n+    scopes.set_scope(block.syntax(), scope);\n     for stmt in block.statements() {\n         match stmt {\n             ast::Stmt::LetStmt(stmt) => {\n@@ -165,6 +209,7 @@ fn compute_block_scopes(block: ast::Block, scopes: &mut FnScopes, mut scope: Sco\n         }\n     }\n     if let Some(expr) = block.expr() {\n+        eprintln!(\"{:?}\", expr);\n         scopes.set_scope(expr.syntax(), scope);\n         compute_expr_scopes(expr, scopes, scope);\n     }"}]}