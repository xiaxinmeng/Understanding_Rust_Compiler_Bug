{"sha": "388f8ce520b16d73bf682cf6bf3f714bcc35b49d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4OGY4Y2U1MjBiMTZkNzNiZjY4MmNmNmJmM2Y3MTRiY2MzNWI0OWQ=", "commit": {"author": {"name": "Michael Bebenita", "email": "mbebenita@mozilla.com", "date": "2010-09-08T22:16:14Z"}, "committer": {"name": "Michael Bebenita", "email": "mbebenita@mozilla.com", "date": "2010-09-08T22:17:09Z"}, "message": "Cleaned up locking in the kernel.", "tree": {"sha": "d8a6a1180ec715b8dd87239fb5e315149a40a078", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8a6a1180ec715b8dd87239fb5e315149a40a078"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/388f8ce520b16d73bf682cf6bf3f714bcc35b49d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/388f8ce520b16d73bf682cf6bf3f714bcc35b49d", "html_url": "https://github.com/rust-lang/rust/commit/388f8ce520b16d73bf682cf6bf3f714bcc35b49d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/388f8ce520b16d73bf682cf6bf3f714bcc35b49d/comments", "author": {"login": "mbebenita", "id": 311082, "node_id": "MDQ6VXNlcjMxMTA4Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/311082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mbebenita", "html_url": "https://github.com/mbebenita", "followers_url": "https://api.github.com/users/mbebenita/followers", "following_url": "https://api.github.com/users/mbebenita/following{/other_user}", "gists_url": "https://api.github.com/users/mbebenita/gists{/gist_id}", "starred_url": "https://api.github.com/users/mbebenita/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mbebenita/subscriptions", "organizations_url": "https://api.github.com/users/mbebenita/orgs", "repos_url": "https://api.github.com/users/mbebenita/repos", "events_url": "https://api.github.com/users/mbebenita/events{/privacy}", "received_events_url": "https://api.github.com/users/mbebenita/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mbebenita", "id": 311082, "node_id": "MDQ6VXNlcjMxMTA4Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/311082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mbebenita", "html_url": "https://github.com/mbebenita", "followers_url": "https://api.github.com/users/mbebenita/followers", "following_url": "https://api.github.com/users/mbebenita/following{/other_user}", "gists_url": "https://api.github.com/users/mbebenita/gists{/gist_id}", "starred_url": "https://api.github.com/users/mbebenita/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mbebenita/subscriptions", "organizations_url": "https://api.github.com/users/mbebenita/orgs", "repos_url": "https://api.github.com/users/mbebenita/repos", "events_url": "https://api.github.com/users/mbebenita/events{/privacy}", "received_events_url": "https://api.github.com/users/mbebenita/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37cc13960744ad8a7a828da1db6edd4ced454353", "url": "https://api.github.com/repos/rust-lang/rust/commits/37cc13960744ad8a7a828da1db6edd4ced454353", "html_url": "https://github.com/rust-lang/rust/commit/37cc13960744ad8a7a828da1db6edd4ced454353"}], "stats": {"total": 107, "additions": 54, "deletions": 53}, "files": [{"sha": "9f128c3ec92968ccd5548156f1fd5d86def38d20", "filename": "src/rt/rust_kernel.cpp", "status": "modified", "additions": 42, "deletions": 40, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/388f8ce520b16d73bf682cf6bf3f714bcc35b49d/src%2Frt%2Frust_kernel.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/388f8ce520b16d73bf682cf6bf3f714bcc35b49d/src%2Frt%2Frust_kernel.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.cpp?ref=388f8ce520b16d73bf682cf6bf3f714bcc35b49d", "patch": "@@ -12,61 +12,78 @@ rust_kernel::rust_kernel(rust_srv *srv) :\n \n rust_handle<rust_dom> *\n rust_kernel::create_domain(const rust_crate *crate, const char *name) {\n+    LOCK(_kernel_lock);\n     rust_message_queue *message_queue =\n         new (this) rust_message_queue(_srv, this);\n     rust_srv *srv = _srv->clone();\n     rust_dom *dom =\n         new (this) rust_dom(this, message_queue, srv, crate, name);\n-    rust_handle<rust_dom> *handle = get_dom_handle(dom);\n+    rust_handle<rust_dom> *handle = internal_get_dom_handle(dom);\n     message_queue->associate(handle);\n     domains.append(dom);\n     message_queues.append(message_queue);\n+    UNLOCK(_kernel_lock);\n     return handle;\n }\n \n void\n rust_kernel::destroy_domain(rust_dom *dom) {\n+    LOCK(_kernel_lock);\n     log(rust_log::KERN, \"deleting domain: \" PTR \", index: %d, domains %d\",\n         dom, dom->list_index, domains.length());\n     domains.remove(dom);\n     dom->message_queue->disassociate();\n     rust_srv *srv = dom->srv;\n     delete dom;\n     delete srv;\n+    UNLOCK(_kernel_lock);\n }\n \n rust_handle<rust_dom> *\n-rust_kernel::get_dom_handle(rust_dom *dom) {\n+rust_kernel::internal_get_dom_handle(rust_dom *dom) {\n     rust_handle<rust_dom> *handle = NULL;\n-    if (_dom_handles.get(dom, &handle)) {\n-        return handle;\n+    if (_dom_handles.get(dom, &handle) == false) {\n+        handle =\n+            new (this) rust_handle<rust_dom>(this, dom->message_queue, dom);\n+        _dom_handles.put(dom, handle);\n     }\n-    handle = new (this) rust_handle<rust_dom>(this, dom->message_queue, dom);\n-    _dom_handles.put(dom, handle);\n+    return handle;\n+}\n+\n+rust_handle<rust_dom> *\n+rust_kernel::get_dom_handle(rust_dom *dom) {\n+    LOCK(_kernel_lock);\n+    rust_handle<rust_dom> *handle = internal_get_dom_handle(dom);\n+    UNLOCK(_kernel_lock);\n     return handle;\n }\n \n rust_handle<rust_task> *\n rust_kernel::get_task_handle(rust_task *task) {\n+    LOCK(_kernel_lock);\n     rust_handle<rust_task> *handle = NULL;\n-    if (_task_handles.get(task, &handle)) {\n-        return handle;\n+    if (_task_handles.get(task, &handle) == false) {\n+        handle =\n+            new (this) rust_handle<rust_task>(this, task->dom->message_queue,\n+                                              task);\n+        _task_handles.put(task, handle);\n     }\n-    handle = new (this) rust_handle<rust_task>(this, task->dom->message_queue,\n-                                               task);\n-    _task_handles.put(task, handle);\n+    UNLOCK(_kernel_lock);\n     return handle;\n }\n \n rust_handle<rust_port> *\n rust_kernel::get_port_handle(rust_port *port) {\n+    PLOCK(_kernel_lock);\n     rust_handle<rust_port> *handle = NULL;\n-    if (_port_handles.get(port, &handle)) {\n-        return handle;\n+    if (_port_handles.get(port, &handle) == false) {\n+        handle =\n+            new (this) rust_handle<rust_port>(this,\n+                                              port->task->dom->message_queue,\n+                                              port);\n+        _port_handles.put(port, handle);\n     }\n-    handle = new (this) rust_handle<rust_port>(this,\n-       port->task->dom->message_queue, port);\n-    _port_handles.put(port, handle);\n+    PUNLOCK(_kernel_lock);\n     return handle;\n }\n \n@@ -76,6 +93,7 @@ rust_kernel::join_all_domains() {\n     while (domains.length() > 0) {\n         sync::yield();\n     }\n+    log(rust_log::KERN, \"joined domains\");\n }\n \n void\n@@ -92,30 +110,8 @@ rust_kernel::log_all_domain_state() {\n bool\n rust_kernel::is_deadlocked() {\n     return false;\n-//    _lock.lock();\n-//    if (domains.length() != 1) {\n-//        // We can only check for deadlocks when only one domain exists.\n-//        return false;\n-//    }\n-//\n-//    if (domains[0]->running_tasks.length() != 0) {\n-//        // We are making progress and therefore we are not deadlocked.\n-//        return false;\n-//    }\n-//\n-//    if (domains[0]->message_queue->is_empty() &&\n-//        domains[0]->blocked_tasks.length() > 0) {\n-//        // We have no messages to process, no running tasks to schedule\n-//        // and some blocked tasks therefore we are likely in a deadlock.\n-//        log_all_domain_state();\n-//        return true;\n-//    }\n-//\n-//    _lock.unlock();\n-//    return false;\n }\n \n-\n void\n rust_kernel::log(uint32_t type_bits, char const *fmt, ...) {\n     char buf[256];\n@@ -130,7 +126,7 @@ rust_kernel::log(uint32_t type_bits, char const *fmt, ...) {\n \n void\n rust_kernel::pump_message_queues() {\n-    message_queues.global.lock();\n+    LOCK(_kernel_lock);\n     for (size_t i = 0; i < message_queues.length(); i++) {\n         rust_message_queue *queue = message_queues[i];\n         if (queue->is_associated() == false) {\n@@ -141,13 +137,14 @@ rust_kernel::pump_message_queues() {\n             }\n         }\n     }\n-    message_queues.global.unlock();\n+    UNLOCK(_kernel_lock);\n }\n \n void\n rust_kernel::start_kernel_loop() {\n     while (_interrupt_kernel_loop == false) {\n         pump_message_queues();\n+        sync::yield();\n     }\n }\n \n@@ -160,6 +157,7 @@ rust_kernel::run() {\n \n void\n rust_kernel::terminate_kernel_loop() {\n+    log(rust_log::KERN, \"terminating kernel loop\");\n     _interrupt_kernel_loop = true;\n     join();\n }\n@@ -177,10 +175,14 @@ rust_kernel::~rust_kernel() {\n     // messages.\n     pump_message_queues();\n \n+    log(rust_log::KERN, \"freeing handles\");\n+\n     free_handles(_task_handles);\n     free_handles(_port_handles);\n     free_handles(_dom_handles);\n \n+    log(rust_log::KERN, \"freeing queues\");\n+\n     rust_message_queue *queue = NULL;\n     while (message_queues.pop(&queue)) {\n         K(_srv, queue->is_empty(), \"Kernel message queue should be empty \""}, {"sha": "db3ad0687eb82ee2a452b1ba3bba4e338cab8e3c", "filename": "src/rt/rust_kernel.h", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/388f8ce520b16d73bf682cf6bf3f714bcc35b49d/src%2Frt%2Frust_kernel.h", "raw_url": "https://github.com/rust-lang/rust/raw/388f8ce520b16d73bf682cf6bf3f714bcc35b49d/src%2Frt%2Frust_kernel.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.h?ref=388f8ce520b16d73bf682cf6bf3f714bcc35b49d", "patch": "@@ -32,6 +32,12 @@ rust_handle :\n     }\n };\n \n+#define LOCK(x) x.lock();\n+#define UNLOCK(x) x.unlock();\n+\n+#define PLOCK(x) printf(\"LOCKING @ %d\\n\", __LINE__); x.lock();\n+#define PUNLOCK(x) x.unlock(); printf(\"UNLOCKED @ %d\\n\", __LINE__);\n+\n /**\n  * A global object shared by all thread domains. Most of the data structures\n  * in this class are synchronized since they are accessed from multiple\n@@ -55,20 +61,19 @@ class rust_kernel : public rust_thread {\n     void start_kernel_loop();\n     bool volatile _interrupt_kernel_loop;\n \n-    /**\n-     * Lock for the message queue list, so we can safely\n-     */\n-    spin_lock _message_queues_lock;\n+    spin_lock _kernel_lock;\n \n     void terminate_kernel_loop();\n     void pump_message_queues();\n \n+    rust_handle<rust_dom> *internal_get_dom_handle(rust_dom *dom);\n+\n public:\n \n     /**\n      * List of domains that are currently executing.\n      */\n-    synchronized_indexed_list<rust_dom> domains;\n+    indexed_list<rust_dom> domains;\n \n     /**\n      * Message queues are kernel objects and are associated with domains.\n@@ -79,7 +84,7 @@ class rust_kernel : public rust_thread {\n      * Although the message_queues list is synchronized, each individual\n      * message queue is lock free.\n      */\n-    synchronized_indexed_list<rust_message_queue> message_queues;\n+    indexed_list<rust_message_queue> message_queues;\n \n     rust_handle<rust_dom> *get_dom_handle(rust_dom *dom);\n     rust_handle<rust_task> *get_task_handle(rust_task *task);"}, {"sha": "a373db66debf16a454d8461e00f978dd0e9179da", "filename": "src/rt/util/synchronized_indexed_list.h", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/388f8ce520b16d73bf682cf6bf3f714bcc35b49d/src%2Frt%2Futil%2Fsynchronized_indexed_list.h", "raw_url": "https://github.com/rust-lang/rust/raw/388f8ce520b16d73bf682cf6bf3f714bcc35b49d/src%2Frt%2Futil%2Fsynchronized_indexed_list.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Futil%2Fsynchronized_indexed_list.h?ref=388f8ce520b16d73bf682cf6bf3f714bcc35b49d", "patch": "@@ -6,14 +6,8 @@\n template<typename T> class synchronized_indexed_list :\n     public indexed_list<T> {\n     spin_lock _lock;\n-public:\n-    /**\n-     * Clients can use this global lock that is associated with the list to\n-     * perform more coarse grained locking. Internally, the synchronized list\n-     * doesn'tactually make any use of this lock.\n-     */\n-    spin_lock global;\n \n+public:\n     synchronized_indexed_list(memory_region *region) :\n         indexed_list<T>(region) {\n         // Nop."}]}