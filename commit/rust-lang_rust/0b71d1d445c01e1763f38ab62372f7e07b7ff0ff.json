{"sha": "0b71d1d445c01e1763f38ab62372f7e07b7ff0ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiNzFkMWQ0NDVjMDFlMTc2M2YzOGFiNjIzNzJmN2UwN2I3ZmYwZmY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-12T02:07:25Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-12T19:08:27Z"}, "message": "Remove std::io", "tree": {"sha": "4c0dd8b10c31a3308e300431cdf55caeb1d838a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c0dd8b10c31a3308e300431cdf55caeb1d838a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b71d1d445c01e1763f38ab62372f7e07b7ff0ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b71d1d445c01e1763f38ab62372f7e07b7ff0ff", "html_url": "https://github.com/rust-lang/rust/commit/0b71d1d445c01e1763f38ab62372f7e07b7ff0ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b71d1d445c01e1763f38ab62372f7e07b7ff0ff/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82b1e3f5cc0d0fec0f7fbab0f9b8766ce732c792", "url": "https://api.github.com/repos/rust-lang/rust/commits/82b1e3f5cc0d0fec0f7fbab0f9b8766ce732c792", "html_url": "https://github.com/rust-lang/rust/commit/82b1e3f5cc0d0fec0f7fbab0f9b8766ce732c792"}], "stats": {"total": 474, "additions": 0, "deletions": 474}, "files": [{"sha": "645cc5b55f35f3bf823386d7ecc5c6e54eb080aa", "filename": "src/lib/io.rs", "status": "removed", "additions": 0, "deletions": 473, "changes": 473, "blob_url": "https://github.com/rust-lang/rust/blob/82b1e3f5cc0d0fec0f7fbab0f9b8766ce732c792/src%2Flib%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82b1e3f5cc0d0fec0f7fbab0f9b8766ce732c792/src%2Flib%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fio.rs?ref=82b1e3f5cc0d0fec0f7fbab0f9b8766ce732c792", "patch": "@@ -1,473 +0,0 @@\n-\n-import os::libc;\n-\n-native \"rust\" mod rustrt {\n-    fn rust_get_stdin() -> os::libc::FILE;\n-    fn rust_get_stdout() -> os::libc::FILE;\n-}\n-\n-\n-// Reading\n-\n-// FIXME This is all buffered. We might need an unbuffered variant as well\n-tag seek_style { seek_set; seek_end; seek_cur; }\n-\n-\n-// The raw underlying reader class. All readers must implement this.\n-type buf_reader =\n-\n-    // FIXME: Seekable really should be orthogonal. We will need\n-    // inheritance.\n-    obj {\n-        fn read(uint) -> vec[u8] ;\n-        fn read_byte() -> int ;\n-        fn unread_byte(int) ;\n-        fn eof() -> bool ;\n-        fn seek(int, seek_style) ;\n-        fn tell() -> uint ;\n-    };\n-\n-\n-// Convenience methods for reading.\n-type reader =\n-\n-    // FIXME: This should inherit from buf_reader.\n-     // FIXME: eventually u64\n-\n-    obj {\n-        fn get_buf_reader() -> buf_reader ;\n-        fn read_byte() -> int ;\n-        fn unread_byte(int) ;\n-        fn read_bytes(uint) -> vec[u8] ;\n-        fn read_char() -> char ;\n-        fn eof() -> bool ;\n-        fn read_line() -> str ;\n-        fn read_c_str() -> str ;\n-        fn read_le_uint(uint) -> uint ;\n-        fn read_le_int(uint) -> int ;\n-        fn read_be_uint(uint) -> uint ;\n-        fn read_whole_stream() -> vec[u8] ;\n-        fn seek(int, seek_style) ;\n-        fn tell() -> uint ;\n-    };\n-\n-fn convert_whence(whence: seek_style) -> int {\n-    ret alt whence { seek_set. { 0 } seek_cur. { 1 } seek_end. { 2 } };\n-}\n-\n-resource FILE_res(f: os::libc::FILE) {\n-    os::libc::fclose(f);\n-}\n-\n-obj FILE_buf_reader(f: os::libc::FILE, res: option::t[@FILE_res]) {\n-    fn read(len: uint) -> vec[u8] {\n-        let buf = vec::alloc[u8](len);\n-        let read = os::libc::fread(vec::buf[u8](buf), 1u, len, f);\n-        vec::len_set[u8](buf, read);\n-        ret buf;\n-    }\n-    fn read_byte() -> int { ret os::libc::fgetc(f); }\n-    fn unread_byte(byte: int) { os::libc::ungetc(byte, f); }\n-    fn eof() -> bool { ret os::libc::feof(f) != 0; }\n-    fn seek(offset: int, whence: seek_style) {\n-        assert (os::libc::fseek(f, offset, convert_whence(whence)) == 0);\n-    }\n-    fn tell() -> uint {\n-        ret os::libc::ftell(f) as uint;\n-    }\n-}\n-\n-\n-// FIXME: Convert this into pseudomethods on buf_reader.\n-obj new_reader(rdr: buf_reader) {\n-    fn get_buf_reader() -> buf_reader { ret rdr; }\n-    fn read_byte() -> int { ret rdr.read_byte(); }\n-    fn unread_byte(byte: int) { ret rdr.unread_byte(byte); }\n-    fn read_bytes(len: uint) -> vec[u8] { ret rdr.read(len); }\n-    fn read_char() -> char {\n-        let c0 = rdr.read_byte();\n-        if c0 == -1 {\n-            ret -1 as char; // FIXME will this stay valid?\n-\n-        }\n-        let b0 = c0 as u8;\n-        let w = str::utf8_char_width(b0);\n-        assert (w > 0u);\n-        if w == 1u { ret b0 as char; }\n-        let val = 0u;\n-        while w > 1u {\n-            w -= 1u;\n-            let next = rdr.read_byte();\n-            assert (next > -1);\n-            assert (next & 192 == 128);\n-            val <<= 6u;\n-            val += next & 63 as uint;\n-        }\n-        // See str::char_at\n-\n-        val += (b0 << (w + 1u as u8) as uint) << (w - 1u) * 6u - w - 1u;\n-        ret val as char;\n-    }\n-    fn eof() -> bool { ret rdr.eof(); }\n-    fn read_line() -> str {\n-        let buf: vec[u8] = [];\n-        // No break yet in rustc\n-\n-        let go_on = true;\n-        while go_on {\n-            let ch = rdr.read_byte();\n-            if ch == -1 || ch == 10 {\n-                go_on = false;\n-            } else { vec::push[u8](buf, ch as u8); }\n-        }\n-        ret str::unsafe_from_bytes(ivec::from_vec(buf));\n-    }\n-    fn read_c_str() -> str {\n-        let buf: vec[u8] = [];\n-        let go_on = true;\n-        while go_on {\n-            let ch = rdr.read_byte();\n-            if ch < 1 {\n-                go_on = false;\n-            } else { vec::push[u8](buf, ch as u8); }\n-        }\n-        ret str::unsafe_from_bytes(ivec::from_vec(buf));\n-    }\n-\n-    // FIXME deal with eof?\n-    fn read_le_uint(size: uint) -> uint {\n-        let val = 0u;\n-        let pos = 0u;\n-        while size > 0u {\n-            val += (rdr.read_byte() as uint) << pos;\n-            pos += 8u;\n-            size -= 1u;\n-        }\n-        ret val;\n-    }\n-    fn read_le_int(size: uint) -> int {\n-        let val = 0u;\n-        let pos = 0u;\n-        while size > 0u {\n-            val += (rdr.read_byte() as uint) << pos;\n-            pos += 8u;\n-            size -= 1u;\n-        }\n-        ret val as int;\n-    }\n-\n-    // FIXME deal with eof?\n-    fn read_be_uint(sz: uint) -> uint {\n-        let val = 0u;\n-\n-        while sz > 0u {\n-            sz -= 1u;\n-            val += (rdr.read_byte() as uint) << sz * 8u;\n-        }\n-        ret val;\n-    }\n-    fn read_whole_stream() -> vec[u8] {\n-        let buf: vec[u8] = [];\n-        while !rdr.eof() { buf += rdr.read(2048u); }\n-        ret buf;\n-    }\n-    fn seek(offset: int, whence: seek_style) { ret rdr.seek(offset, whence); }\n-    fn tell() -> uint { ret rdr.tell(); }\n-}\n-\n-fn stdin() -> reader {\n-    ret new_reader(FILE_buf_reader(rustrt::rust_get_stdin(), option::none));\n-}\n-\n-fn file_reader(path: str) -> reader {\n-    let f = os::libc::fopen(str::buf(path), str::buf(\"r\"));\n-    if f as uint == 0u { log_err \"error opening \" + path; fail; }\n-    ret new_reader(FILE_buf_reader(f, option::some(@FILE_res(f))));\n-}\n-\n-\n-// FIXME: Remove me once objects are exported.\n-fn new_reader_(bufr: buf_reader) -> reader { ret new_reader(bufr); }\n-\n-\n-// Byte buffer readers\n-\n-// TODO: mutable? u8, but this fails with rustboot.\n-type byte_buf = @{buf: vec[u8], mutable pos: uint};\n-\n-obj byte_buf_reader(bbuf: byte_buf) {\n-    fn read(len: uint) -> vec[u8] {\n-        let rest = vec::len[u8](bbuf.buf) - bbuf.pos;\n-        let to_read = len;\n-        if rest < to_read { to_read = rest; }\n-        let range = vec::slice[u8](bbuf.buf, bbuf.pos, bbuf.pos + to_read);\n-        bbuf.pos += to_read;\n-        ret range;\n-    }\n-    fn read_byte() -> int {\n-        if bbuf.pos == vec::len[u8](bbuf.buf) { ret -1; }\n-        let b = bbuf.buf.(bbuf.pos);\n-        bbuf.pos += 1u;\n-        ret b as int;\n-    }\n-    fn unread_byte(byte: int) { log_err \"TODO: unread_byte\"; fail; }\n-    fn eof() -> bool { ret bbuf.pos == vec::len[u8](bbuf.buf); }\n-    fn seek(offset: int, whence: seek_style) {\n-        let pos = bbuf.pos;\n-        let len = vec::len[u8](bbuf.buf);\n-        bbuf.pos = seek_in_buf(offset, pos, len, whence);\n-    }\n-    fn tell() -> uint { ret bbuf.pos; }\n-}\n-\n-fn new_byte_buf_reader(buf: vec[u8]) -> byte_buf_reader {\n-    ret byte_buf_reader(@{buf: buf, mutable pos: 0u});\n-}\n-\n-\n-// Writing\n-tag fileflag { append; create; truncate; none; }\n-\n-type buf_writer =\n-\n-    // FIXME: Seekable really should be orthogonal. We will need\n-    // inheritance.\n-     // FIXME: eventually u64\n-\n-    obj {\n-        fn write(vec[u8]) ;\n-        fn seek(int, seek_style) ;\n-        fn tell() -> uint ;\n-    };\n-\n-obj FILE_writer(f: os::libc::FILE, res: option::t[@FILE_res]) {\n-    fn write(v: vec[u8]) {\n-        let len = vec::len[u8](v);\n-        let vbuf = vec::buf[u8](v);\n-        let nout = os::libc::fwrite(vbuf, len, 1u, f);\n-        if nout < 1u { log_err \"error dumping buffer\"; }\n-    }\n-    fn seek(offset: int, whence: seek_style) {\n-        assert (os::libc::fseek(f, offset, convert_whence(whence)) == 0);\n-    }\n-    fn tell() -> uint {\n-        ret os::libc::ftell(f) as uint;\n-    }\n-}\n-\n-resource fd_res(fd: int) {\n-    os::libc::close(fd);\n-}\n-\n-obj fd_buf_writer(fd: int, res: option::t[@fd_res]) {\n-    fn write(v: vec[u8]) {\n-        let len = vec::len[u8](v);\n-        let count = 0u;\n-        let vbuf;\n-        while count < len {\n-            vbuf = vec::buf_off[u8](v, count);\n-            let nout = os::libc::write(fd, vbuf, len);\n-            if nout < 0 {\n-                log_err \"error dumping buffer\";\n-                log_err sys::rustrt::last_os_error();\n-                fail;\n-            }\n-            count += nout as uint;\n-        }\n-    }\n-    fn seek(offset: int, whence: seek_style) {\n-        log_err \"need 64-bit native calls for seek, sorry\";\n-        fail;\n-    }\n-    fn tell() -> uint {\n-        log_err \"need 64-bit native calls for tell, sorry\";\n-        fail;\n-    }\n-}\n-\n-fn file_buf_writer(path: str, flags: vec[fileflag]) -> buf_writer {\n-    let fflags: int =\n-        os::libc_constants::O_WRONLY() | os::libc_constants::O_BINARY();\n-    for f: fileflag  in flags {\n-        alt f {\n-          append. { fflags |= os::libc_constants::O_APPEND(); }\n-          create. { fflags |= os::libc_constants::O_CREAT(); }\n-          truncate. { fflags |= os::libc_constants::O_TRUNC(); }\n-          none. { }\n-        }\n-    }\n-    let fd =\n-        os::libc::open(str::buf(path), fflags,\n-                       os::libc_constants::S_IRUSR() |\n-                           os::libc_constants::S_IWUSR());\n-    if fd < 0 {\n-        log_err \"error opening file for writing\";\n-        log_err sys::rustrt::last_os_error();\n-        fail;\n-    }\n-    ret fd_buf_writer(fd, option::some(@fd_res(fd)));\n-}\n-\n-type writer =\n-\n-    // write_str will continue to do utf-8 output only. an alternative\n-    // function will be provided for general encoded string output\n-    obj {\n-        fn get_buf_writer() -> buf_writer ;\n-        fn write_str(str) ;\n-        fn write_line(str) ;\n-        fn write_char(char) ;\n-        fn write_int(int) ;\n-        fn write_uint(uint) ;\n-        fn write_bytes(vec[u8]) ;\n-        fn write_le_uint(uint, uint) ;\n-        fn write_le_int(int, uint) ;\n-        fn write_be_uint(uint, uint) ;\n-    };\n-\n-fn uint_to_le_bytes(n: uint, size: uint) -> vec[u8] {\n-    let bytes: vec[u8] = [];\n-    while size > 0u { bytes += [n & 255u as u8]; n >>= 8u; size -= 1u; }\n-    ret bytes;\n-}\n-\n-fn uint_to_be_bytes(n: uint, size: uint) -> vec[u8] {\n-    let bytes: vec[u8] = [];\n-    let i = size - 1u as int;\n-    while i >= 0 { bytes += [n >> (i * 8 as uint) & 255u as u8]; i -= 1; }\n-    ret bytes;\n-}\n-\n-obj new_writer(out: buf_writer) {\n-    fn get_buf_writer() -> buf_writer { ret out; }\n-    fn write_str(s: str) { out.write(ivec::to_vec(str::bytes(s))); }\n-    fn write_line(s: str) {\n-        out.write(ivec::to_vec(str::bytes(s)));\n-        out.write(ivec::to_vec(str::bytes(\"\\n\")));\n-    }\n-    fn write_char(ch: char) {\n-        // FIXME needlessly consy\n-\n-        out.write(ivec::to_vec(str::bytes(str::from_char(ch))));\n-    }\n-    fn write_int(n: int) {\n-        out.write(ivec::to_vec(str::bytes(int::to_str(n, 10u))));\n-    }\n-    fn write_uint(n: uint) {\n-        out.write(ivec::to_vec(str::bytes(uint::to_str(n, 10u))));\n-    }\n-    fn write_bytes(bytes: vec[u8]) { out.write(bytes); }\n-    fn write_le_uint(n: uint, size: uint) {\n-        out.write(uint_to_le_bytes(n, size));\n-    }\n-    fn write_le_int(n: int, size: uint) {\n-        out.write(uint_to_le_bytes(n as uint, size));\n-    }\n-    fn write_be_uint(n: uint, size: uint) {\n-        out.write(uint_to_be_bytes(n, size));\n-    }\n-}\n-\n-\n-// FIXME: Remove me once objects are exported.\n-fn new_writer_(out: buf_writer) -> writer { ret new_writer(out); }\n-\n-fn file_writer(path: str, flags: vec[fileflag]) -> writer {\n-    ret new_writer(file_buf_writer(path, flags));\n-}\n-\n-\n-// FIXME: fileflags\n-fn buffered_file_buf_writer(path: str) -> buf_writer {\n-    let f = os::libc::fopen(str::buf(path), str::buf(\"w\"));\n-    if f as uint == 0u { log_err \"error opening \" + path; fail; }\n-    ret FILE_writer(f, option::some(@FILE_res(f)));\n-}\n-\n-\n-// FIXME it would be great if this could be a const\n-fn stdout() -> writer { ret new_writer(fd_buf_writer(1, option::none)); }\n-\n-fn stderr() -> writer { ret new_writer(fd_buf_writer(2, option::none)); }\n-\n-type str_writer =\n-    obj {\n-        fn get_writer() -> writer ;\n-        fn get_str() -> str ;\n-    };\n-\n-type mutable_byte_buf = @{mutable buf: vec[mutable u8], mutable pos: uint};\n-\n-obj byte_buf_writer(buf: mutable_byte_buf) {\n-    fn write(v: vec[u8]) {\n-        // Fast path.\n-\n-        if buf.pos == vec::len(buf.buf) {\n-            // FIXME: Fix our type system. There's no reason you shouldn't be\n-            // able to add a mutable vector to an immutable one.\n-\n-            let mv = vec::rustrt::unsafe_vec_to_mut[u8](v);\n-            buf.buf += mv;\n-            buf.pos += vec::len[u8](v);\n-            ret;\n-        }\n-        // FIXME: Optimize: These should be unique pointers.\n-\n-        let vlen = vec::len[u8](v);\n-        let vpos = 0u;\n-        while vpos < vlen {\n-            let b = v.(vpos);\n-            if buf.pos == vec::len(buf.buf) {\n-                buf.buf += [mutable b];\n-            } else { buf.buf.(buf.pos) = b; }\n-            buf.pos += 1u;\n-            vpos += 1u;\n-        }\n-    }\n-    fn seek(offset: int, whence: seek_style) {\n-        let pos = buf.pos;\n-        let len = vec::len(buf.buf);\n-        buf.pos = seek_in_buf(offset, pos, len, whence);\n-    }\n-    fn tell() -> uint { ret buf.pos; }\n-}\n-\n-fn string_writer() -> str_writer {\n-    // FIXME: yikes, this is bad. Needs fixing of mutable syntax.\n-\n-    let b: vec[mutable u8] = [mutable 0u8];\n-    vec::pop(b);\n-    let buf: mutable_byte_buf = @{mutable buf: b, mutable pos: 0u};\n-    obj str_writer_wrap(wr: writer, buf: mutable_byte_buf) {\n-        fn get_writer() -> writer { ret wr; }\n-        fn get_str() -> str {\n-            ret str::unsafe_from_bytes(ivec::from_vec(buf.buf));\n-        }\n-    }\n-    ret str_writer_wrap(new_writer(byte_buf_writer(buf)), buf);\n-}\n-\n-\n-// Utility functions\n-fn seek_in_buf(offset: int, pos: uint, len: uint, whence: seek_style) ->\n-   uint {\n-    let bpos = pos as int;\n-    let blen = len as int;\n-    alt whence {\n-      seek_set. { bpos = offset; }\n-      seek_cur. { bpos += offset; }\n-      seek_end. { bpos = blen + offset; }\n-    }\n-    if bpos < 0 { bpos = 0; } else if (bpos > blen) { bpos = blen; }\n-    ret bpos as uint;\n-}\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n-// End:\n-//"}, {"sha": "6f642e1954b9559772c9807f015268868d8d4c87", "filename": "src/lib/std.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0b71d1d445c01e1763f38ab62372f7e07b7ff0ff/src%2Flib%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/0b71d1d445c01e1763f38ab62372f7e07b7ff0ff/src%2Flib%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstd.rc?ref=0b71d1d445c01e1763f38ab62372f7e07b7ff0ff", "patch": "@@ -20,7 +20,6 @@ mod str;\n \n // General io and system-services modules.\n \n-mod io;\n mod ioivec;\n mod sys;\n mod task;"}]}