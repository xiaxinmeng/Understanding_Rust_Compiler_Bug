{"sha": "27f357106e5a0cc9d2fa98c079f5f3f4ecf30f04", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3ZjM1NzEwNmU1YTBjYzlkMmZhOThjMDc5ZjVmM2Y0ZWNmMzBmMDQ=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-02-18T23:56:35Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-02-22T19:15:10Z"}, "message": "Improve documentation for libcollections/str", "tree": {"sha": "b29a1331e678c1ecd0cb28318a3a97b60a58f756", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b29a1331e678c1ecd0cb28318a3a97b60a58f756"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27f357106e5a0cc9d2fa98c079f5f3f4ecf30f04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27f357106e5a0cc9d2fa98c079f5f3f4ecf30f04", "html_url": "https://github.com/rust-lang/rust/commit/27f357106e5a0cc9d2fa98c079f5f3f4ecf30f04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27f357106e5a0cc9d2fa98c079f5f3f4ecf30f04/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5", "html_url": "https://github.com/rust-lang/rust/commit/dfc5c0f1e8799f47f9033bdcc8a7cd8a217620a5"}], "stats": {"total": 714, "additions": 440, "deletions": 274}, "files": [{"sha": "0b393ab1b5e7830dfacb72fce20701cbc50720f6", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 440, "deletions": 274, "changes": 714, "blob_url": "https://github.com/rust-lang/rust/blob/27f357106e5a0cc9d2fa98c079f5f3f4ecf30f04/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27f357106e5a0cc9d2fa98c079f5f3f4ecf30f04/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=27f357106e5a0cc9d2fa98c079f5f3f4ecf30f04", "patch": "@@ -10,44 +10,39 @@\n //\n // ignore-lexer-test FIXME #15679\n \n-//! Unicode string manipulation (`str` type)\n+//! Unicode string manipulation (the `str` type).\n //!\n-//! # Basic Usage\n+//! Rust's `str` type is one of the core primitive types of the language. `&str` is the borrowed\n+//! string type. This type of string can only be created from other strings, unless it is a static\n+//! string (see below). As the word \"borrowed\" implies, this type of string is owned elsewhere, and\n+//! this string cannot be moved out of.\n //!\n-//! Rust's string type is one of the core primitive types of the language. While\n-//! represented by the name `str`, the name `str` is not actually a valid type in\n-//! Rust. Each string must also be decorated with a pointer. `String` is used\n-//! for an owned string, so there is only one commonly-used `str` type in Rust:\n-//! `&str`.\n+//! # Examples\n //!\n-//! `&str` is the borrowed string type. This type of string can only be created\n-//! from other strings, unless it is a static string (see below). As the word\n-//! \"borrowed\" implies, this type of string is owned elsewhere, and this string\n-//! cannot be moved out of.\n+//! Here's some code that uses a `&str`:\n //!\n-//! As an example, here's some code that uses a string.\n-//!\n-//! ```rust\n-//! fn main() {\n-//!     let borrowed_string = \"This string is borrowed with the 'static lifetime\";\n-//! }\n //! ```\n+//! let s = \"Hello, world.\";\n+//! ```\n+//!\n+//! This `&str` is a `&'static str`, which is the type of string literals. They're `'static`\n+//! because literals are available for the entire lifetime of the program.\n //!\n-//! From the example above, you can guess that Rust's string literals have the\n-//! `'static` lifetime. This is akin to C's concept of a static string.\n-//! More precisely, string literals are immutable views with a 'static lifetime\n-//! (otherwise known as the lifetime of the entire program), and thus have the\n-//! type `&'static str`.\n+//! You can get a non-`'static` `&str` by taking a slice of a `String`:\n+//!\n+//! ```\n+//! # let some_string = \"Hello, world.\".to_string();\n+//! let s = &some_string;\n+//! ```\n //!\n //! # Representation\n //!\n-//! Rust's string type, `str`, is a sequence of Unicode scalar values encoded as a\n-//! stream of UTF-8 bytes. All [strings](../../reference.html#literals) are\n-//! guaranteed to be validly encoded UTF-8 sequences. Additionally, strings are\n-//! not null-terminated and can thus contain null bytes.\n+//! Rust's string type, `str`, is a sequence of Unicode scalar values encoded as a stream of UTF-8\n+//! bytes. All [strings](../../reference.html#literals) are guaranteed to be validly encoded UTF-8\n+//! sequences. Additionally, strings are not null-terminated and can thus contain null bytes.\n //!\n-//! The actual representation of strings have direct mappings to slices: `&str`\n-//! is the same as `&[u8]`.\n+//! The actual representation of `str`s have direct mappings to slices: `&str` is the same as\n+//! `&[u8]`.\n \n #![doc(primitive = \"str\")]\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -164,8 +159,9 @@ enum DecompositionType {\n     Compatible\n }\n \n-/// External iterator for a string's decomposition's characters.\n-/// Use with the `std::iter` module.\n+/// External iterator for a string decomposition's characters.\n+///\n+/// For use with the `std::iter` module.\n #[derive(Clone)]\n #[unstable(feature = \"collections\")]\n pub struct Decompositions<'a> {\n@@ -254,8 +250,9 @@ enum RecompositionState {\n     Finished\n }\n \n-/// External iterator for a string's recomposition's characters.\n-/// Use with the `std::iter` module.\n+/// External iterator for a string recomposition's characters.\n+///\n+/// For use with the `std::iter` module.\n #[derive(Clone)]\n #[unstable(feature = \"collections\")]\n pub struct Recompositions<'a> {\n@@ -352,7 +349,8 @@ impl<'a> Iterator for Recompositions<'a> {\n }\n \n /// External iterator for a string's UTF16 codeunits.\n-/// Use with the `std::iter` module.\n+///\n+/// For use with the `std::iter` module.\n #[derive(Clone)]\n #[unstable(feature = \"collections\")]\n pub struct Utf16Units<'a> {\n@@ -427,23 +425,21 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n \n     /// Replaces all occurrences of one string with another.\n     ///\n-    /// # Arguments\n-    ///\n-    /// * `from` - The string to replace\n-    /// * `to` - The replacement string\n-    ///\n-    /// # Return value\n-    ///\n-    /// The original string with all occurrences of `from` replaced with `to`.\n+    /// `replace` takes two arguments, a sub-`&str` to find in `self`, and a second `&str` to\n+    /// replace it with. If the original `&str` isn't found, no change occurs.\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let s = \"this is old\";\n     ///\n     /// assert_eq!(s.replace(\"old\", \"new\"), \"this is new\");\n+    /// ```\n+    ///\n+    /// When a `&str` isn't found:\n     ///\n-    /// // not found, so no change.\n+    /// ```\n+    /// let s = \"this is old\";\n     /// assert_eq!(s.replace(\"cookie monster\", \"little lamb\"), s);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -517,59 +513,56 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n         }\n     }\n \n-    /// Returns true if a string contains a string pattern.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// - pat - The string pattern to look for\n+    /// Returns `true` if `self` contains another `&str`.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// assert!(\"bananas\".contains(\"nana\"));\n+    ///\n+    /// assert!(!\"bananas\".contains(\"foobar\"));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn contains(&self, pat: &str) -> bool {\n         core_str::StrExt::contains(&self[], pat)\n     }\n \n-    /// Returns true if a string contains a char pattern.\n+    /// Returns `true` if `self` contains a `char`.\n     ///\n-    /// # Arguments\n-    ///\n-    /// - pat - The char pattern to look for\n-    ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// assert!(\"hello\".contains_char('e'));\n+    ///\n+    /// assert!(!\"hello\".contains_char('z'));\n     /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"might get removed in favour of a more generic contains()\")]\n     fn contains_char<P: CharEq>(&self, pat: P) -> bool {\n         core_str::StrExt::contains_char(&self[], pat)\n     }\n \n-    /// An iterator over the characters of `self`. Note, this iterates\n-    /// over Unicode code-points, not Unicode graphemes.\n+    /// An iterator over the codepoints of `self`.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let v: Vec<char> = \"abc \u00e5\u00e4\u00f6\".chars().collect();\n+    ///\n     /// assert_eq!(v, vec!['a', 'b', 'c', ' ', '\u00e5', '\u00e4', '\u00f6']);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn chars(&self) -> Chars {\n         core_str::StrExt::chars(&self[])\n     }\n \n-    /// An iterator over the bytes of `self`\n+    /// An iterator over the bytes of `self`.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let v: Vec<u8> = \"bors\".bytes().collect();\n+    ///\n     /// assert_eq!(v, b\"bors\".to_vec());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -578,47 +571,66 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     }\n \n     /// An iterator over the characters of `self` and their byte offsets.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let v: Vec<(usize, char)> = \"abc\".char_indices().collect();\n+    /// let b = vec![(0, 'a'), (1, 'b'), (2, 'c')];\n+    ///\n+    /// assert_eq!(v, b);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn char_indices(&self) -> CharIndices {\n         core_str::StrExt::char_indices(&self[])\n     }\n \n     /// An iterator over substrings of `self`, separated by characters\n-    /// matched by the pattern `pat`.\n+    /// matched by a pattern.\n     ///\n-    /// # Example\n+    /// The pattern can be a simple `&str`, or a closure that determines\n+    /// the split.\n     ///\n-    /// ```rust\n+    /// # Examples\n+    ///\n+    /// Simple `&str` patterns:\n+    ///\n+    /// ```\n     /// let v: Vec<&str> = \"Mary had a little lamb\".split(' ').collect();\n     /// assert_eq!(v, vec![\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n     ///\n+    /// let v: Vec<&str> = \"\".split('X').collect();\n+    /// assert_eq!(v, vec![\"\"]);\n+    /// ```\n+    ///\n+    /// More complex patterns with a lambda:\n+    ///\n+    /// ```\n     /// let v: Vec<&str> = \"abc1def2ghi\".split(|c: char| c.is_numeric()).collect();\n     /// assert_eq!(v, vec![\"abc\", \"def\", \"ghi\"]);\n     ///\n     /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').collect();\n     /// assert_eq!(v, vec![\"lion\", \"\", \"tiger\", \"leopard\"]);\n-    ///\n-    /// let v: Vec<&str> = \"\".split('X').collect();\n-    /// assert_eq!(v, vec![\"\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn split<P: CharEq>(&self, pat: P) -> Split<P> {\n         core_str::StrExt::split(&self[], pat)\n     }\n \n-    /// An iterator over substrings of `self`, separated by characters\n-    /// matched by the pattern `pat`, restricted to splitting at most `count`\n-    /// times.\n+    /// An iterator over substrings of `self`, separated by characters matched by a pattern,\n+    /// restricted to splitting at most `count` times.\n     ///\n-    /// # Example\n+    /// The pattern can be a simple `&str`, or a closure that determines\n+    /// the split.\n     ///\n-    /// ```rust\n+    /// # Examples\n+    ///\n+    /// Simple `&str` patterns:\n+    ///\n+    /// ```\n     /// let v: Vec<&str> = \"Mary had a little lambda\".splitn(2, ' ').collect();\n     /// assert_eq!(v, vec![\"Mary\", \"had\", \"a little lambda\"]);\n     ///\n-    /// let v: Vec<&str> = \"abc1def2ghi\".splitn(1, |c: char| c.is_numeric()).collect();\n-    /// assert_eq!(v, vec![\"abc\", \"def2ghi\"]);\n-    ///\n     /// let v: Vec<&str> = \"lionXXtigerXleopard\".splitn(2, 'X').collect();\n     /// assert_eq!(v, vec![\"lion\", \"\", \"tigerXleopard\"]);\n     ///\n@@ -628,72 +640,89 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// let v: Vec<&str> = \"\".splitn(1, 'X').collect();\n     /// assert_eq!(v, vec![\"\"]);\n     /// ```\n+    ///\n+    /// More complex patterns with a lambda:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"abc1def2ghi\".splitn(1, |c: char| c.is_numeric()).collect();\n+    /// assert_eq!(v, vec![\"abc\", \"def2ghi\"]);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn splitn<P: CharEq>(&self, count: usize, pat: P) -> SplitN<P> {\n         core_str::StrExt::splitn(&self[], count, pat)\n     }\n \n     /// An iterator over substrings of `self`, separated by characters\n-    /// matched by the pattern `pat`.\n+    /// matched by a pattern.\n     ///\n-    /// Equivalent to `split`, except that the trailing substring\n-    /// is skipped if empty (terminator semantics).\n+    /// Equivalent to `split`, except that the trailing substring is skipped if empty.\n     ///\n-    /// # Example\n+    /// The pattern can be a simple `&str`, or a closure that determines\n+    /// the split.\n     ///\n-    /// ```rust\n+    /// # Examples\n+    ///\n+    /// Simple `&str` patterns:\n+    ///\n+    /// ```\n     /// let v: Vec<&str> = \"A.B.\".split_terminator('.').collect();\n     /// assert_eq!(v, vec![\"A\", \"B\"]);\n     ///\n     /// let v: Vec<&str> = \"A..B..\".split_terminator('.').collect();\n     /// assert_eq!(v, vec![\"A\", \"\", \"B\", \"\"]);\n+    /// ```\n     ///\n-    /// let v: Vec<&str> = \"Mary had a little lamb\".split(' ').rev().collect();\n-    /// assert_eq!(v, vec![\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n-    ///\n-    /// let v: Vec<&str> = \"abc1def2ghi\".split(|c: char| c.is_numeric()).rev().collect();\n-    /// assert_eq!(v, vec![\"ghi\", \"def\", \"abc\"]);\n+    /// More complex patterns with a lambda:\n     ///\n-    /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').rev().collect();\n-    /// assert_eq!(v, vec![\"leopard\", \"tiger\", \"\", \"lion\"]);\n+    /// ```\n+    /// let v: Vec<&str> = \"abc1def2ghi3\".split_terminator(|c: char| c.is_numeric()).collect();\n+    /// assert_eq!(v, vec![\"abc\", \"def\", \"ghi\"]);\n     /// ```\n     #[unstable(feature = \"collections\", reason = \"might get removed\")]\n     fn split_terminator<P: CharEq>(&self, pat: P) -> SplitTerminator<P> {\n         core_str::StrExt::split_terminator(&self[], pat)\n     }\n \n-    /// An iterator over substrings of `self`, separated by characters\n-    /// matched by the pattern `pat`, starting from the end of the string.\n+    /// An iterator over substrings of `self`, separated by characters matched by a pattern,\n+    /// starting from the end of the string.\n+    ///\n     /// Restricted to splitting at most `count` times.\n     ///\n-    /// # Example\n+    /// The pattern can be a simple `&str`, or a closure that determines the split.\n     ///\n-    /// ```rust\n+    /// # Examples\n+    ///\n+    /// Simple `&str` patterns:\n+    ///\n+    /// ```\n     /// let v: Vec<&str> = \"Mary had a little lamb\".rsplitn(2, ' ').collect();\n     /// assert_eq!(v, vec![\"lamb\", \"little\", \"Mary had a\"]);\n     ///\n-    /// let v: Vec<&str> = \"abc1def2ghi\".rsplitn(1, |c: char| c.is_numeric()).collect();\n-    /// assert_eq!(v, vec![\"ghi\", \"abc1def\"]);\n-    ///\n     /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn(2, 'X').collect();\n     /// assert_eq!(v, vec![\"leopard\", \"tiger\", \"lionX\"]);\n     /// ```\n+    ///\n+    /// More complex patterns with a lambda:\n+    ///\n+    /// ```\n+    /// let v: Vec<&str> = \"abc1def2ghi\".rsplitn(1, |c: char| c.is_numeric()).collect();\n+    /// assert_eq!(v, vec![\"ghi\", \"abc1def\"]);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn rsplitn<P: CharEq>(&self, count: usize, pat: P) -> RSplitN<P> {\n         core_str::StrExt::rsplitn(&self[], count, pat)\n     }\n \n-    /// An iterator over the start and end indices of the disjoint\n-    /// matches of the pattern `pat` within `self`.\n+    /// An iterator over the start and end indices of the disjoint matches of a `&str` within\n+    /// `self`.\n     ///\n-    /// That is, each returned value `(start, end)` satisfies\n-    /// `self.slice(start, end) == sep`. For matches of `sep` within\n-    /// `self` that overlap, only the indices corresponding to the\n-    /// first match are returned.\n+    /// That is, each returned value `(start, end)` satisfies `self.slice(start, end) == sep`. For\n+    /// matches of `sep` within `self` that overlap, only the indices corresponding to the first\n+    /// match are returned.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let v: Vec<(usize, usize)> = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\n     /// assert_eq!(v, vec![(0,3), (6,9), (12,15)]);\n     ///\n@@ -709,11 +738,11 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n         core_str::StrExt::match_indices(&self[], pat)\n     }\n \n-    /// An iterator over the substrings of `self` separated by the pattern `sep`.\n+    /// An iterator over the substrings of `self` separated by a `&str`.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let v: Vec<&str> = \"abcXXXabcYYYabc\".split_str(\"abc\").collect();\n     /// assert_eq!(v, vec![\"\", \"XXX\", \"YYY\", \"\"]);\n     ///\n@@ -726,31 +755,51 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n         core_str::StrExt::split_str(&self[], pat)\n     }\n \n-    /// An iterator over the lines of a string (subsequences separated\n-    /// by `\\n`). This does not include the empty string after a\n-    /// trailing `\\n`.\n+    /// An iterator over the lines of a string, separated by `\\n`.\n     ///\n-    /// # Example\n+    /// This does not include the empty string after a trailing `\\n`.\n     ///\n-    /// ```rust\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let four_lines = \"foo\\nbar\\n\\nbaz\";\n+    /// let v: Vec<&str> = four_lines.lines().collect();\n+    ///\n+    /// assert_eq!(v, vec![\"foo\", \"bar\", \"\", \"baz\"]);\n+    /// ```\n+    ///\n+    /// Leaving off the trailing character:\n+    ///\n+    /// ```\n     /// let four_lines = \"foo\\nbar\\n\\nbaz\\n\";\n     /// let v: Vec<&str> = four_lines.lines().collect();\n+    ///\n     /// assert_eq!(v, vec![\"foo\", \"bar\", \"\", \"baz\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn lines(&self) -> Lines {\n         core_str::StrExt::lines(&self[])\n     }\n \n-    /// An iterator over the lines of a string, separated by either\n-    /// `\\n` or `\\r\\n`. As with `.lines()`, this does not include an\n-    /// empty trailing line.\n+    /// An iterator over the lines of a string, separated by either `\\n` or `\\r\\n`.\n     ///\n-    /// # Example\n+    /// As with `.lines()`, this does not include an empty trailing line.\n     ///\n-    /// ```rust\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let four_lines = \"foo\\r\\nbar\\n\\r\\nbaz\";\n+    /// let v: Vec<&str> = four_lines.lines_any().collect();\n+    ///\n+    /// assert_eq!(v, vec![\"foo\", \"bar\", \"\", \"baz\"]);\n+    /// ```\n+    ///\n+    /// Leaving off the trailing character:\n+    ///\n+    /// ```\n     /// let four_lines = \"foo\\r\\nbar\\n\\r\\nbaz\\n\";\n     /// let v: Vec<&str> = four_lines.lines_any().collect();\n+    ///\n     /// assert_eq!(v, vec![\"foo\", \"bar\", \"\", \"baz\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -776,26 +825,25 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     #[deprecated(since = \"1.0.0\", reason = \"use slice notation [..a] instead\")]\n     fn slice_to(&self, end: usize) -> &str;\n \n-    /// Returns a slice of the string from the character range\n-    /// [`begin`..`end`).\n+    /// Returns a slice of the string from the character range [`begin`..`end`).\n     ///\n-    /// That is, start at the `begin`-th code point of the string and\n-    /// continue to the `end`-th code point. This does not detect or\n-    /// handle edge cases such as leaving a combining character as the\n-    /// first code point of the string.\n+    /// That is, start at the `begin`-th code point of the string and continue to the `end`-th code\n+    /// point. This does not detect or handle edge cases such as leaving a combining character as\n+    /// the first code point of the string.\n     ///\n-    /// Due to the design of UTF-8, this operation is `O(end)`.\n-    /// See `slice`, `slice_to` and `slice_from` for `O(1)`\n-    /// variants that use byte indices rather than code point\n-    /// indices.\n+    /// Due to the design of UTF-8, this operation is `O(end)`. See `slice`, `slice_to` and\n+    /// `slice_from` for `O(1)` variants that use byte indices rather than code point indices.\n     ///\n-    /// Panics if `begin` > `end` or the either `begin` or `end` are\n-    /// beyond the last character of the string.\n+    /// # Panics\n     ///\n-    /// # Example\n+    /// Panics if `begin` > `end` or the either `begin` or `end` are beyond the last character of\n+    /// the string.\n     ///\n-    /// ```rust\n+    /// # Examples\n+    ///\n+    /// ```\n     /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n     /// assert_eq!(s.slice_chars(0, 4), \"L\u00f6we\");\n     /// assert_eq!(s.slice_chars(5, 7), \"\u8001\u864e\");\n     /// ```\n@@ -805,32 +853,44 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n         core_str::StrExt::slice_chars(&self[], begin, end)\n     }\n \n-    /// Takes a bytewise (not UTF-8) slice from a string.\n+    /// Takes a bytewise slice from a string.\n     ///\n     /// Returns the substring from [`begin`..`end`).\n     ///\n-    /// Caller must check both UTF-8 character boundaries and the boundaries of\n-    /// the entire slice as well.\n+    /// # Unsafety\n+    ///\n+    /// Caller must check both UTF-8 character boundaries and the boundaries of the entire slice as\n+    /// well.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n+    /// unsafe {\n+    ///     assert_eq!(s.slice_unchecked(0, 21), \"L\u00f6we \u8001\u864e L\u00e9opard\");\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str {\n         core_str::StrExt::slice_unchecked(&self[], begin, end)\n     }\n \n-    /// Returns true if the pattern `pat` is a prefix of the string.\n+    /// Returns `true` if the given `&str` is a prefix of the string.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// assert!(\"banana\".starts_with(\"ba\"));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn starts_with(&self, pat: &str) -> bool {\n         core_str::StrExt::starts_with(&self[], pat)\n     }\n \n-    /// Returns true if the pattern `pat` is a suffix of the string.\n+    /// Returns true if the given `&str` is a suffix of the string.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```rust\n     /// assert!(\"banana\".ends_with(\"nana\"));\n@@ -840,77 +900,92 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n         core_str::StrExt::ends_with(&self[], pat)\n     }\n \n-    /// Returns a string with all pre- and suffixes that match\n-    /// the pattern `pat` repeatedly removed.\n+    /// Returns a string with all pre- and suffixes that match a pattern repeatedly removed.\n     ///\n-    /// # Arguments\n+    /// The pattern can be a simple `&str`, or a closure that determines the split.\n     ///\n-    /// * pat - a string pattern\n+    /// # Examples\n     ///\n-    /// # Example\n+    /// Simple `&str` patterns:\n     ///\n-    /// ```rust\n+    /// ```\n     /// assert_eq!(\"11foo1bar11\".trim_matches('1'), \"foo1bar\");\n+    ///\n     /// let x: &[_] = &['1', '2'];\n     /// assert_eq!(\"12foo1bar12\".trim_matches(x), \"foo1bar\");\n+    /// ```\n+    ///\n+    /// More complex patterns with a lambda:\n+    ///\n+    /// ```\n     /// assert_eq!(\"123foo1bar123\".trim_matches(|c: char| c.is_numeric()), \"foo1bar\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim_matches<P: CharEq>(&self, pat: P) -> &str {\n         core_str::StrExt::trim_matches(&self[], pat)\n     }\n \n-    /// Returns a string with all prefixes that match\n-    /// the pattern `pat` repeatedly removed.\n+    /// Returns a string with all prefixes that match a pattern repeatedly removed.\n     ///\n-    /// # Arguments\n+    /// The pattern can be a simple `&str`, or a closure that determines the split.\n     ///\n-    /// * pat - a string pattern\n+    /// # Examples\n     ///\n-    /// # Example\n+    /// Simple `&str` patterns:\n     ///\n-    /// ```rust\n+    /// ```\n     /// assert_eq!(\"11foo1bar11\".trim_left_matches('1'), \"foo1bar11\");\n+    ///\n     /// let x: &[_] = &['1', '2'];\n     /// assert_eq!(\"12foo1bar12\".trim_left_matches(x), \"foo1bar12\");\n+    /// ```\n+    ///\n+    /// More complex patterns with a lambda:\n+    ///\n+    /// ```\n     /// assert_eq!(\"123foo1bar123\".trim_left_matches(|c: char| c.is_numeric()), \"foo1bar123\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim_left_matches<P: CharEq>(&self, pat: P) -> &str {\n         core_str::StrExt::trim_left_matches(&self[], pat)\n     }\n \n-    /// Returns a string with all suffixes that match\n-    /// the pattern `pat` repeatedly removed.\n+    /// Returns a string with all suffixes that match a pattern repeatedly removed.\n     ///\n-    /// # Arguments\n+    /// The pattern can be a simple `&str`, or a closure that determines the split.\n     ///\n-    /// * pat - a string pattern\n+    /// # Examples\n     ///\n-    /// # Example\n+    /// Simple `&str` patterns:\n     ///\n-    /// ```rust\n+    /// ```\n     /// assert_eq!(\"11foo1bar11\".trim_right_matches('1'), \"11foo1bar\");\n     /// let x: &[_] = &['1', '2'];\n     /// assert_eq!(\"12foo1bar12\".trim_right_matches(x), \"12foo1bar\");\n+    /// ```\n+    ///\n+    /// More complex patterns with a lambda:\n+    ///\n+    /// ```\n     /// assert_eq!(\"123foo1bar123\".trim_right_matches(|c: char| c.is_numeric()), \"123foo1bar\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim_right_matches<P: CharEq>(&self, pat: P) -> &str {\n         core_str::StrExt::trim_right_matches(&self[], pat)\n     }\n \n-    /// Check that `index`-th byte lies at the start and/or end of a\n-    /// UTF-8 code point sequence.\n+    /// Check that `index`-th byte lies at the start and/or end of a UTF-8 code point sequence.\n     ///\n-    /// The start and end of the string (when `index == self.len()`)\n-    /// are considered to be boundaries.\n+    /// The start and end of the string (when `index == self.len()`) are considered to be\n+    /// boundaries.\n+    ///\n+    /// # Panics\n     ///\n     /// Panics if `index` is greater than `self.len()`.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n     /// assert!(s.is_char_boundary(0));\n     /// // start of `\u8001`\n@@ -929,19 +1004,21 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n         core_str::StrExt::is_char_boundary(&self[], index)\n     }\n \n-    /// Pluck a character out of a string and return the index of the next\n-    /// character.\n+    /// Given a byte position, return the next char and its index.\n     ///\n-    /// This function can be used to iterate over the Unicode characters of a\n-    /// string.\n+    /// This can be used to iterate over the Unicode characters of a string.\n     ///\n-    /// # Example\n+    /// # Panics\n     ///\n-    /// This example manually iterates through the characters of a\n-    /// string; this should normally be done by `.chars()` or\n-    /// `.char_indices`.\n+    /// If `i` is greater than or equal to the length of the string.\n+    /// If `i` is not the index of the beginning of a valid UTF-8 character.\n     ///\n-    /// ```rust\n+    /// # Examples\n+    ///\n+    /// This example manually iterates through the characters of a string; this should normally be\n+    /// done by `.chars()` or `.char_indices()`.\n+    ///\n+    /// ```\n     /// use std::str::CharRange;\n     ///\n     /// let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n@@ -967,28 +1044,13 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// 14: a\n     /// 15: m\n     /// ```\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * s - The string\n-    /// * i - The byte offset of the char to extract\n-    ///\n-    /// # Return value\n-    ///\n-    /// A record {ch: char, next: usize} containing the char value and the byte\n-    /// index of the next Unicode character.\n-    ///\n-    /// # Panics\n-    ///\n-    /// If `i` is greater than or equal to the length of the string.\n-    /// If `i` is not the index of the beginning of a valid UTF-8 character.\n     #[unstable(feature = \"collections\",\n                reason = \"naming is uncertain with container conventions\")]\n     fn char_range_at(&self, start: usize) -> CharRange {\n         core_str::StrExt::char_range_at(&self[], start)\n     }\n \n-    /// Given a byte position and a str, return the previous char and its position.\n+    /// Given a byte position, return the previous `char` and its position.\n     ///\n     /// This function can be used to iterate over a Unicode string in reverse.\n     ///\n@@ -998,127 +1060,184 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     ///\n     /// If `i` is greater than the length of the string.\n     /// If `i` is not an index following a valid UTF-8 character.\n+    ///\n+    /// # Examples\n+    ///\n+    /// This example manually iterates through the characters of a string; this should normally be\n+    /// done by `.chars().rev()` or `.char_indices()`.\n+    ///\n+    /// ```\n+    /// use std::str::CharRange;\n+    ///\n+    /// let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n+    /// let mut i = s.len();\n+    /// while i < 0 {\n+    ///     let CharRange {ch, next} = s.char_range_at_reverse(i);\n+    ///     println!(\"{}: {}\", i, ch);\n+    ///     i = next;\n+    /// }\n+    /// ```\n+    ///\n+    /// This outputs:\n+    ///\n+    /// ```text\n+    /// 16: m\n+    /// 15: a\n+    /// 14: N\n+    /// 13:\n+    /// 12: t\n+    /// 11: \u1ec7\n+    /// 8: i\n+    /// 7: V\n+    /// 6: \u534e\n+    /// 3: \u4e2d\n+    /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"naming is uncertain with container conventions\")]\n     fn char_range_at_reverse(&self, start: usize) -> CharRange {\n         core_str::StrExt::char_range_at_reverse(&self[], start)\n     }\n \n-    /// Plucks the character starting at the `i`th byte of a string.\n+    /// Given a byte position, return the `char` at that position.\n     ///\n-    /// # Example\n+    /// # Panics\n     ///\n-    /// ```rust\n+    /// If `i` is greater than or equal to the length of the string.\n+    /// If `i` is not the index of the beginning of a valid UTF-8 character.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n     /// let s = \"ab\u03c0c\";\n     /// assert_eq!(s.char_at(1), 'b');\n     /// assert_eq!(s.char_at(2), '\u03c0');\n-    /// assert_eq!(s.char_at(4), 'c');\n     /// ```\n-    ///\n-    /// # Panics\n-    ///\n-    /// If `i` is greater than or equal to the length of the string.\n-    /// If `i` is not the index of the beginning of a valid UTF-8 character.\n     #[unstable(feature = \"collections\",\n                reason = \"naming is uncertain with container conventions\")]\n     fn char_at(&self, i: usize) -> char {\n         core_str::StrExt::char_at(&self[], i)\n     }\n \n-    /// Plucks the character ending at the `i`th byte of a string.\n+    /// Given a byte position, return the `char` at that position, counting from the end.\n     ///\n     /// # Panics\n     ///\n     /// If `i` is greater than the length of the string.\n     /// If `i` is not an index following a valid UTF-8 character.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s = \"ab\u03c0c\";\n+    /// assert_eq!(s.char_at_reverse(1), 'a');\n+    /// assert_eq!(s.char_at_reverse(2), 'b');\n+    /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"naming is uncertain with container conventions\")]\n     fn char_at_reverse(&self, i: usize) -> char {\n         core_str::StrExt::char_at_reverse(&self[], i)\n     }\n \n-    /// Work with the byte buffer of a string as a byte slice.\n+    /// Convert `self` to a byte slice.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// assert_eq!(\"bors\".as_bytes(), b\"bors\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn as_bytes(&self) -> &[u8] {\n         core_str::StrExt::as_bytes(&self[])\n     }\n \n-    /// Returns the byte index of the first character of `self` that\n-    /// matches the pattern `pat`.\n+    /// Returns the byte index of the first character of `self` that matches the pattern, if it\n+    /// exists.\n     ///\n-    /// # Return value\n+    /// Returns `None` if it doesn't exist.\n     ///\n-    /// `Some` containing the byte index of the last matching character\n-    /// or `None` if there is no match\n+    /// The pattern can be a simple `&str`, or a closure that determines the split.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// Simple `&str` patterns:\n+    ///\n+    /// ```\n     /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n     ///\n     /// assert_eq!(s.find('L'), Some(0));\n     /// assert_eq!(s.find('\u00e9'), Some(14));\n     ///\n-    /// // the first space\n+    /// ```\n+    ///\n+    /// More complex patterns with a lambda:\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    ///\n     /// assert_eq!(s.find(|c: char| c.is_whitespace()), Some(5));\n+    /// ```\n     ///\n-    /// // neither are found\n+    /// Not finding the pattern:\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n     /// let x: &[_] = &['1', '2'];\n+    ///\n     /// assert_eq!(s.find(x), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn find<P: CharEq>(&self, pat: P) -> Option<usize> {\n         core_str::StrExt::find(&self[], pat)\n     }\n \n-    /// Returns the byte index of the last character of `self` that\n-    /// matches the pattern `pat`.\n+    /// Returns the byte index of the last character of `self` that matches the pattern, if it\n+    /// exists.\n     ///\n-    /// # Return value\n+    /// Returns `None` if it doesn't exist.\n     ///\n-    /// `Some` containing the byte index of the last matching character\n-    /// or `None` if there is no match.\n+    /// The pattern can be a simple `&str`, or a closure that determines the split.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// Simple `&str` patterns:\n+    ///\n+    /// ```\n     /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n     ///\n     /// assert_eq!(s.rfind('L'), Some(13));\n     /// assert_eq!(s.rfind('\u00e9'), Some(14));\n+    /// ```\n+    ///\n+    /// More complex patterns with a lambda:\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n     ///\n-    /// // the second space\n     /// assert_eq!(s.rfind(|c: char| c.is_whitespace()), Some(12));\n+    /// ```\n+    ///\n+    /// Not finding the pattern:\n     ///\n-    /// // searches for an occurrence of either `1` or `2`, but neither are found\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n     /// let x: &[_] = &['1', '2'];\n+    ///\n     /// assert_eq!(s.rfind(x), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn rfind<P: CharEq>(&self, pat: P) -> Option<usize> {\n         core_str::StrExt::rfind(&self[], pat)\n     }\n \n-    /// Returns the byte index of the first matching substring\n+    /// Returns the byte index of the first matching substring if it exists.\n     ///\n-    /// # Arguments\n+    /// Returns `None` if it doesn't exist.\n     ///\n-    /// * `needle` - The string to search for\n+    /// The pattern can be a simple `&str`, or a closure that determines the split.\n     ///\n-    /// # Return value\n-    ///\n-    /// `Some` containing the byte index of the first matching substring\n-    /// or `None` if there is no match.\n-    ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n     ///\n     /// assert_eq!(s.find_str(\"\u8001\u864e L\"), Some(6));\n@@ -1130,21 +1249,24 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n         core_str::StrExt::find_str(&self[], needle)\n     }\n \n-    /// Retrieves the first character from a string slice and returns\n-    /// it. This does not allocate a new string; instead, it returns a\n-    /// slice that point one character beyond the character that was\n-    /// shifted. If the string does not contain any characters,\n-    /// None is returned instead.\n+    /// Retrieves the first character from a `&str` and returns it.\n     ///\n-    /// # Example\n+    /// This does not allocate a new string; instead, it returns a slice that points one character\n+    /// beyond the character that was shifted.\n     ///\n-    /// ```rust\n+    /// If the slice does not contain any characters, None is returned instead.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n     /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n     /// let (c, s1) = s.slice_shift_char().unwrap();\n+    ///\n     /// assert_eq!(c, 'L');\n     /// assert_eq!(s1, \"\u00f6we \u8001\u864e L\u00e9opard\");\n     ///\n     /// let (c, s2) = s1.slice_shift_char().unwrap();\n+    ///\n     /// assert_eq!(c, '\u00f6');\n     /// assert_eq!(s2, \"we \u8001\u864e L\u00e9opard\");\n     /// ```\n@@ -1156,11 +1278,13 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n \n     /// Returns the byte offset of an inner slice relative to an enclosing outer slice.\n     ///\n+    /// # Panics\n+    ///\n     /// Panics if `inner` is not a direct slice contained within self.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let string = \"a\\nb\\nc\";\n     /// let lines: Vec<&str> = string.lines().collect();\n     ///\n@@ -1174,11 +1298,17 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n         core_str::StrExt::subslice_offset(&self[], inner)\n     }\n \n-    /// Return an unsafe pointer to the strings buffer.\n+    /// Return an unsafe pointer to the `&str`'s buffer.\n+    ///\n+    /// The caller must ensure that the string outlives this pointer, and that it is not\n+    /// reallocated (e.g. by pushing to the string).\n     ///\n-    /// The caller must ensure that the string outlives this pointer,\n-    /// and that it is not reallocated (e.g. by pushing to the\n-    /// string).\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s = \"Hello\";\n+    /// let p = s.as_ptr();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn as_ptr(&self) -> *const u8 {\n@@ -1192,23 +1322,23 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n         Utf16Units { encoder: Utf16Encoder::new(self[].chars()) }\n     }\n \n-    /// Return the number of bytes in this string\n+    /// Returns the length of `self` in bytes.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// assert_eq!(\"foo\".len(), 3);\n-    /// assert_eq!(\"\u0192oo\".len(), 4);\n+    /// assert_eq!(\"\u0192oo\".len(), 4); // fancy f!\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     fn len(&self) -> usize {\n         core_str::StrExt::len(&self[])\n     }\n \n-    /// Returns true if this slice contains no bytes\n+    /// Returns true if this slice has a length of zero bytes.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n     /// ```\n     /// assert!(\"\".is_empty());\n@@ -1219,12 +1349,21 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n         core_str::StrExt::is_empty(&self[])\n     }\n \n-    /// Parse this string into the specified type.\n+    /// Parses `self` into the specified type.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Will return `Err` if it's not possible to parse `self` into the type.\n     ///\n     /// # Example\n     ///\n     /// ```\n     /// assert_eq!(\"4\".parse::<u32>(), Ok(4));\n+    /// ```\n+    ///\n+    /// Failing:\n+    ///\n+    /// ```\n     /// assert!(\"j\".parse::<u32>().is_err());\n     /// ```\n     #[inline]\n@@ -1233,23 +1372,26 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n         core_str::StrExt::parse(&self[])\n     }\n \n-    /// Returns an iterator over the\n-    /// [grapheme clusters](http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries)\n-    /// of the string.\n+    /// Returns an iterator over the [grapheme clusters][graphemes] of `self`.\n+    ///\n+    /// [graphemes]: http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries\n     ///\n     /// If `is_extended` is true, the iterator is over the *extended grapheme clusters*;\n     /// otherwise, the iterator is over the *legacy grapheme clusters*.\n     /// [UAX#29](http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries)\n     /// recommends extended grapheme cluster boundaries for general processing.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let gr1 = \"a\\u{310}e\\u{301}o\\u{308}\\u{332}\".graphemes(true).collect::<Vec<&str>>();\n     /// let b: &[_] = &[\"a\\u{310}\", \"e\\u{301}\", \"o\\u{308}\\u{332}\"];\n+    ///\n     /// assert_eq!(gr1.as_slice(), b);\n+    ///\n     /// let gr2 = \"a\\r\\nb\ud83c\uddf7\ud83c\uddfa\ud83c\uddf8\ud83c\uddf9\".graphemes(true).collect::<Vec<&str>>();\n     /// let b: &[_] = &[\"a\", \"\\r\\n\", \"b\", \"\ud83c\uddf7\ud83c\uddfa\ud83c\uddf8\ud83c\uddf9\"];\n+    ///\n     /// assert_eq!(gr2.as_slice(), b);\n     /// ```\n     #[unstable(feature = \"collections\",\n@@ -1258,14 +1400,15 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n         UnicodeStr::graphemes(&self[], is_extended)\n     }\n \n-    /// Returns an iterator over the grapheme clusters of self and their byte offsets.\n-    /// See `graphemes()` method for more information.\n+    /// Returns an iterator over the grapheme clusters of `self` and their byte offsets. See\n+    /// `graphemes()` for more information.\n     ///\n-    /// # Example\n+    /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// let gr_inds = \"a\u0310e\u0301o\u0308\u0332\\r\\n\".grapheme_indices(true).collect::<Vec<(usize, &str)>>();\n     /// let b: &[_] = &[(0, \"a\u0310\"), (3, \"e\u0301\"), (6, \"o\u0308\u0332\"), (11, \"\\r\\n\")];\n+    ///\n     /// assert_eq!(gr_inds.as_slice(), b);\n     /// ```\n     #[unstable(feature = \"collections\",\n@@ -1274,15 +1417,17 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n         UnicodeStr::grapheme_indices(&self[], is_extended)\n     }\n \n-    /// An iterator over the words of a string (subsequences separated\n-    /// by any sequence of whitespace). Sequences of whitespace are\n-    /// collapsed, so empty \"words\" are not included.\n+    /// An iterator over the non-empty words of `self`.\n     ///\n-    /// # Example\n+    /// A 'word' is a subsequence separated by any sequence of whitespace. Sequences of whitespace\n+    /// are collapsed, so empty \"words\" are not included.\n     ///\n-    /// ```rust\n+    /// # Examples\n+    ///\n+    /// ```\n     /// let some_words = \" Mary   had\\ta little  \\n\\t lamb\";\n     /// let v: Vec<&str> = some_words.words().collect();\n+    ///\n     /// assert_eq!(v, vec![\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n     /// ```\n     #[unstable(feature = \"str_words\",\n@@ -1291,34 +1436,55 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n         UnicodeStr::words(&self[])\n     }\n \n-    /// Returns a string's displayed width in columns, treating control\n-    /// characters as zero-width.\n+    /// Returns a string's displayed width in columns.\n+    ///\n+    /// Control characters have zero width.\n     ///\n-    /// `is_cjk` determines behavior for characters in the Ambiguous category:\n-    /// if `is_cjk` is `true`, these are 2 columns wide; otherwise, they are 1.\n-    /// In CJK locales, `is_cjk` should be `true`, else it should be `false`.\n-    /// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)\n-    /// recommends that these characters be treated as 1 column (i.e.,\n-    /// `is_cjk` = `false`) if the locale is unknown.\n+    /// `is_cjk` determines behavior for characters in the Ambiguous category: if `is_cjk` is\n+    /// `true`, these are 2 columns wide; otherwise, they are 1. In CJK locales, `is_cjk` should be\n+    /// `true`, else it should be `false`. [Unicode Standard Annex\n+    /// #11](http://www.unicode.org/reports/tr11/) recommends that these characters be treated as 1\n+    /// column (i.e., `is_cjk` = `false`) if the locale is unknown.\n     #[unstable(feature = \"collections\",\n                reason = \"this functionality may only be provided by libunicode\")]\n     fn width(&self, is_cjk: bool) -> usize {\n         UnicodeStr::width(&self[], is_cjk)\n     }\n \n-    /// Returns a string with leading and trailing whitespace removed.\n+    /// Returns a `&str` with leading and trailing whitespace removed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s = \" Hello\\tworld\\t\";\n+    /// assert_eq!(s.trim(), \"Hello\\tworld\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim(&self) -> &str {\n         UnicodeStr::trim(&self[])\n     }\n \n-    /// Returns a string with leading whitespace removed.\n+    /// Returns a `&str` with leading whitespace removed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s = \" Hello\\tworld\\t\";\n+    /// assert_eq!(s.trim_left(), \"Hello\\tworld\\t\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim_left(&self) -> &str {\n         UnicodeStr::trim_left(&self[])\n     }\n \n-    /// Returns a string with trailing whitespace removed.\n+    /// Returns a `&str` with trailing whitespace removed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s = \" Hello\\tworld\\t\";\n+    /// assert_eq!(s.trim_right(), \" Hello\\tworld\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn trim_right(&self) -> &str {\n         UnicodeStr::trim_right(&self[])"}]}