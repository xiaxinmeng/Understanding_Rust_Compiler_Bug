{"sha": "48a5999fceeea84a8971634355287faa349909d4", "node_id": "C_kwDOAAsO6NoAKDQ4YTU5OTlmY2VlZWE4NGE4OTcxNjM0MzU1Mjg3ZmFhMzQ5OTA5ZDQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-01T20:14:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-12-01T20:14:07Z"}, "message": "Auto merge of #91433 - matthiaskrgr:rollup-118ql06, r=matthiaskrgr\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #88502 (Add slice take methods)\n - #91313 (expand: Turn `ast::Crate` into a first class expansion target)\n - #91424 (Update LLVM with patches for better llvm-cov diagnostics)\n - #91425 (Include lint errors in error count for `-Ztreat-err-as-bug`)\n - #91430 (Add tests for `normalize-docs` overflow errors)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "9ad663ffaf4c2f4fa545f7123dc7b3bba066ff2d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ad663ffaf4c2f4fa545f7123dc7b3bba066ff2d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48a5999fceeea84a8971634355287faa349909d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48a5999fceeea84a8971634355287faa349909d4", "html_url": "https://github.com/rust-lang/rust/commit/48a5999fceeea84a8971634355287faa349909d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48a5999fceeea84a8971634355287faa349909d4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c51718ae7ae3160058e220b879d2a69533973a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c51718ae7ae3160058e220b879d2a69533973a7", "html_url": "https://github.com/rust-lang/rust/commit/3c51718ae7ae3160058e220b879d2a69533973a7"}, {"sha": "4ae75cfa2e01f383ba610038aca2356197f8ac75", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ae75cfa2e01f383ba610038aca2356197f8ac75", "html_url": "https://github.com/rust-lang/rust/commit/4ae75cfa2e01f383ba610038aca2356197f8ac75"}], "stats": {"total": 832, "additions": 656, "deletions": 176}, "files": [{"sha": "4d4c6217ad07ac1e4afec6e55ed867f7fc50b4de", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/48a5999fceeea84a8971634355287faa349909d4/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a5999fceeea84a8971634355287faa349909d4/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=48a5999fceeea84a8971634355287faa349909d4", "patch": "@@ -517,6 +517,8 @@ pub struct Crate {\n     pub attrs: Vec<Attribute>,\n     pub items: Vec<P<Item>>,\n     pub span: Span,\n+    // Placeholder ID if the crate node is a macro placeholder.\n+    pub is_placeholder: Option<NodeId>,\n }\n \n /// Possible values inside of compile-time attribute lists."}, {"sha": "b9c397974a163b5330014dd2247e6916c4be0c65", "filename": "compiler/rustc_ast/src/ast_like.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/48a5999fceeea84a8971634355287faa349909d4/compiler%2Frustc_ast%2Fsrc%2Fast_like.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a5999fceeea84a8971634355287faa349909d4/compiler%2Frustc_ast%2Fsrc%2Fast_like.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast_like.rs?ref=48a5999fceeea84a8971634355287faa349909d4", "patch": "@@ -1,7 +1,7 @@\n use super::ptr::P;\n use super::token::Nonterminal;\n use super::tokenstream::LazyTokenStream;\n-use super::{Arm, ExprField, FieldDef, GenericParam, Param, PatField, Variant};\n+use super::{Arm, Crate, ExprField, FieldDef, GenericParam, Param, PatField, Variant};\n use super::{AssocItem, Expr, ForeignItem, Item, Local, MacCallStmt};\n use super::{AttrItem, AttrKind, Block, Pat, Path, Ty, Visibility};\n use super::{AttrVec, Attribute, Stmt, StmtKind};\n@@ -276,7 +276,7 @@ derive_has_tokens_and_attrs! {\n // These ast nodes only support inert attributes, so they don't\n // store tokens (since nothing can observe them)\n derive_has_attrs_no_tokens! {\n-    FieldDef, Arm, ExprField, PatField, Variant, Param, GenericParam\n+    FieldDef, Arm, ExprField, PatField, Variant, Param, GenericParam, Crate\n }\n \n // These AST nodes don't support attributes, but can"}, {"sha": "205625573a6d930fc75d8338e452e63f04db5d43", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 8, "deletions": 29, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/48a5999fceeea84a8971634355287faa349909d4/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a5999fceeea84a8971634355287faa349909d4/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=48a5999fceeea84a8971634355287faa349909d4", "patch": "@@ -284,6 +284,10 @@ pub trait MutVisitor: Sized {\n /// Use a map-style function (`FnOnce(T) -> T`) to overwrite a `&mut T`. Useful\n /// when using a `flat_map_*` or `filter_map_*` method within a `visit_`\n /// method. Abort the program if the closure panics.\n+///\n+/// FIXME: Abort on panic means that any fatal error inside `visit_clobber` will abort the compiler.\n+/// Instead of aborting on catching a panic we need to reset the visited node to some valid but\n+/// possibly meaningless value and rethrow the panic.\n //\n // No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n pub fn visit_clobber<T, F>(t: &mut T, f: F)\n@@ -1105,36 +1109,11 @@ pub fn noop_visit_fn_header<T: MutVisitor>(header: &mut FnHeader, vis: &mut T) {\n     visit_unsafety(unsafety, vis);\n }\n \n-// FIXME: Avoid visiting the crate as a `Mod` item, flat map only the inner items if possible,\n-// or make crate visiting first class if necessary.\n pub fn noop_visit_crate<T: MutVisitor>(krate: &mut Crate, vis: &mut T) {\n-    visit_clobber(krate, |Crate { attrs, items, span }| {\n-        let item_vis =\n-            Visibility { kind: VisibilityKind::Public, span: span.shrink_to_lo(), tokens: None };\n-        let item = P(Item {\n-            ident: Ident::empty(),\n-            attrs,\n-            id: DUMMY_NODE_ID,\n-            vis: item_vis,\n-            span,\n-            kind: ItemKind::Mod(Unsafe::No, ModKind::Loaded(items, Inline::Yes, span)),\n-            tokens: None,\n-        });\n-        let items = vis.flat_map_item(item);\n-\n-        let len = items.len();\n-        if len == 0 {\n-            Crate { attrs: vec![], items: vec![], span }\n-        } else if len == 1 {\n-            let Item { attrs, span, kind, .. } = items.into_iter().next().unwrap().into_inner();\n-            match kind {\n-                ItemKind::Mod(_, ModKind::Loaded(items, ..)) => Crate { attrs, items, span },\n-                _ => panic!(\"visitor converted a module to not a module\"),\n-            }\n-        } else {\n-            panic!(\"a crate cannot expand to more than one item\");\n-        }\n-    });\n+    let Crate { attrs, items, span, is_placeholder: _ } = krate;\n+    visit_attrs(attrs, vis);\n+    items.flat_map_in_place(|item| vis.flat_map_item(item));\n+    vis.visit_span(span);\n }\n \n // Mutates one item into possibly many items."}, {"sha": "6840f092da61ba8d7e678f11609c761fa26dcf1a", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/48a5999fceeea84a8971634355287faa349909d4/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a5999fceeea84a8971634355287faa349909d4/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=48a5999fceeea84a8971634355287faa349909d4", "patch": "@@ -211,6 +211,9 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_pat_field(&mut self, fp: &'ast PatField) {\n         walk_pat_field(self, fp)\n     }\n+    fn visit_crate(&mut self, krate: &'ast Crate) {\n+        walk_crate(self, krate)\n+    }\n }\n \n #[macro_export]"}, {"sha": "4b5703a429e718cc7db732f884fa080783bb27ab", "filename": "compiler/rustc_ast_pretty/src/pprust/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/48a5999fceeea84a8971634355287faa349909d4/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a5999fceeea84a8971634355287faa349909d4/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fmod.rs?ref=48a5999fceeea84a8971634355287faa349909d4", "patch": "@@ -75,3 +75,12 @@ pub fn attribute_to_string(attr: &ast::Attribute) -> String {\n pub fn to_string(f: impl FnOnce(&mut State<'_>)) -> String {\n     State::new().to_string(f)\n }\n+\n+pub fn crate_to_string_for_macros(krate: &ast::Crate) -> String {\n+    State::new().to_string(|s| {\n+        s.print_inner_attributes(&krate.attrs);\n+        for item in &krate.items {\n+            s.print_item(item);\n+        }\n+    })\n+}"}, {"sha": "5933a49ea58033cfc291532b3e1e9263ad7dee2a", "filename": "compiler/rustc_builtin_macros/src/cfg_eval.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/48a5999fceeea84a8971634355287faa349909d4/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a5999fceeea84a8971634355287faa349909d4/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs?ref=48a5999fceeea84a8971634355287faa349909d4", "patch": "@@ -77,6 +77,10 @@ fn flat_map_annotatable(\n         Annotatable::Param(param) => vis.flat_map_param(param).pop().map(Annotatable::Param),\n         Annotatable::FieldDef(sf) => vis.flat_map_field_def(sf).pop().map(Annotatable::FieldDef),\n         Annotatable::Variant(v) => vis.flat_map_variant(v).pop().map(Annotatable::Variant),\n+        Annotatable::Crate(mut krate) => {\n+            vis.visit_crate(&mut krate);\n+            Some(Annotatable::Crate(krate))\n+        }\n     }\n }\n \n@@ -101,6 +105,7 @@ impl CfgFinder {\n             Annotatable::Param(param) => finder.visit_param(&param),\n             Annotatable::FieldDef(field) => finder.visit_field_def(&field),\n             Annotatable::Variant(variant) => finder.visit_variant(&variant),\n+            Annotatable::Crate(krate) => finder.visit_crate(krate),\n         };\n         finder.has_cfg_or_cfg_attr\n     }"}, {"sha": "418729e78436fc028e5ee902a581376bff319859", "filename": "compiler/rustc_builtin_macros/src/test_harness.rs", "status": "modified", "additions": 30, "deletions": 28, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/48a5999fceeea84a8971634355287faa349909d4/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a5999fceeea84a8971634355287faa349909d4/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs?ref=48a5999fceeea84a8971634355287faa349909d4", "patch": "@@ -84,9 +84,35 @@ struct TestHarnessGenerator<'a> {\n     tests: Vec<Test>,\n }\n \n+impl TestHarnessGenerator<'_> {\n+    fn add_test_cases(&mut self, node_id: ast::NodeId, span: Span, prev_tests: Vec<Test>) {\n+        let mut tests = mem::replace(&mut self.tests, prev_tests);\n+\n+        if !tests.is_empty() {\n+            // Create an identifier that will hygienically resolve the test\n+            // case name, even in another module.\n+            let expn_id = self.cx.ext_cx.resolver.expansion_for_ast_pass(\n+                span,\n+                AstPass::TestHarness,\n+                &[],\n+                Some(node_id),\n+            );\n+            for test in &mut tests {\n+                // See the comment on `mk_main` for why we're using\n+                // `apply_mark` directly.\n+                test.ident.span =\n+                    test.ident.span.apply_mark(expn_id.to_expn_id(), Transparency::Opaque);\n+            }\n+            self.cx.test_cases.extend(tests);\n+        }\n+    }\n+}\n+\n impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n     fn visit_crate(&mut self, c: &mut ast::Crate) {\n+        let prev_tests = mem::take(&mut self.tests);\n         noop_visit_crate(c, self);\n+        self.add_test_cases(ast::CRATE_NODE_ID, c.span, prev_tests);\n \n         // Create a main function to run our tests\n         c.items.push(mk_main(&mut self.cx));\n@@ -103,34 +129,10 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n \n         // We don't want to recurse into anything other than mods, since\n         // mods or tests inside of functions will break things\n-        if let ast::ItemKind::Mod(..) = item.kind {\n-            let tests = mem::take(&mut self.tests);\n+        if let ast::ItemKind::Mod(_, ModKind::Loaded(.., span)) = item.kind {\n+            let prev_tests = mem::take(&mut self.tests);\n             noop_visit_item_kind(&mut item.kind, self);\n-            let mut tests = mem::replace(&mut self.tests, tests);\n-\n-            if !tests.is_empty() {\n-                let parent =\n-                    if item.id == ast::DUMMY_NODE_ID { ast::CRATE_NODE_ID } else { item.id };\n-                // Create an identifier that will hygienically resolve the test\n-                // case name, even in another module.\n-                let inner_span = match item.kind {\n-                    ast::ItemKind::Mod(_, ModKind::Loaded(.., span)) => span,\n-                    _ => unreachable!(),\n-                };\n-                let expn_id = self.cx.ext_cx.resolver.expansion_for_ast_pass(\n-                    inner_span,\n-                    AstPass::TestHarness,\n-                    &[],\n-                    Some(parent),\n-                );\n-                for test in &mut tests {\n-                    // See the comment on `mk_main` for why we're using\n-                    // `apply_mark` directly.\n-                    test.ident.span =\n-                        test.ident.span.apply_mark(expn_id.to_expn_id(), Transparency::Opaque);\n-                }\n-                self.cx.test_cases.extend(tests);\n-            }\n+            self.add_test_cases(item.id, span, prev_tests);\n         }\n         smallvec![P(item)]\n     }\n@@ -146,7 +148,7 @@ fn entry_point_type(sess: &Session, item: &ast::Item, depth: usize) -> EntryPoin\n             } else if sess.contains_name(&item.attrs, sym::rustc_main) {\n                 EntryPointType::MainAttr\n             } else if item.ident.name == sym::main {\n-                if depth == 1 {\n+                if depth == 0 {\n                     // This is a top-level function so can be 'main'\n                     EntryPointType::MainNamed\n                 } else {"}, {"sha": "82a02c3e54335588d96ba91965fb5022d38df688", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/48a5999fceeea84a8971634355287faa349909d4/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a5999fceeea84a8971634355287faa349909d4/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=48a5999fceeea84a8971634355287faa349909d4", "patch": "@@ -1013,7 +1013,9 @@ impl HandlerInner {\n     }\n \n     fn treat_err_as_bug(&self) -> bool {\n-        self.flags.treat_err_as_bug.map_or(false, |c| self.err_count() >= c.get())\n+        self.flags\n+            .treat_err_as_bug\n+            .map_or(false, |c| self.err_count() + self.lint_err_count >= c.get())\n     }\n \n     fn print_error_count(&mut self, registry: &Registry) {\n@@ -1205,7 +1207,10 @@ impl HandlerInner {\n \n     fn panic_if_treat_err_as_bug(&self) {\n         if self.treat_err_as_bug() {\n-            match (self.err_count(), self.flags.treat_err_as_bug.map(|c| c.get()).unwrap_or(0)) {\n+            match (\n+                self.err_count() + self.lint_err_count,\n+                self.flags.treat_err_as_bug.map(|c| c.get()).unwrap_or(0),\n+            ) {\n                 (1, 1) => panic!(\"aborting due to `-Z treat-err-as-bug=1`\"),\n                 (0, _) | (1, _) => {}\n                 (count, as_bug) => panic!("}, {"sha": "07b5e20b2ddc59360fd620d7ec30c2e66063c6bc", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/48a5999fceeea84a8971634355287faa349909d4/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a5999fceeea84a8971634355287faa349909d4/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=48a5999fceeea84a8971634355287faa349909d4", "patch": "@@ -48,6 +48,7 @@ pub enum Annotatable {\n     Param(ast::Param),\n     FieldDef(ast::FieldDef),\n     Variant(ast::Variant),\n+    Crate(ast::Crate),\n }\n \n impl Annotatable {\n@@ -66,6 +67,7 @@ impl Annotatable {\n             Annotatable::Param(ref p) => p.span,\n             Annotatable::FieldDef(ref sf) => sf.span,\n             Annotatable::Variant(ref v) => v.span,\n+            Annotatable::Crate(ref c) => c.span,\n         }\n     }\n \n@@ -84,6 +86,7 @@ impl Annotatable {\n             Annotatable::Param(p) => p.visit_attrs(f),\n             Annotatable::FieldDef(sf) => sf.visit_attrs(f),\n             Annotatable::Variant(v) => v.visit_attrs(f),\n+            Annotatable::Crate(c) => c.visit_attrs(f),\n         }\n     }\n \n@@ -102,6 +105,7 @@ impl Annotatable {\n             Annotatable::Param(p) => visitor.visit_param(p),\n             Annotatable::FieldDef(sf) => visitor.visit_field_def(sf),\n             Annotatable::Variant(v) => visitor.visit_variant(v),\n+            Annotatable::Crate(c) => visitor.visit_crate(c),\n         }\n     }\n \n@@ -122,7 +126,8 @@ impl Annotatable {\n             | Annotatable::GenericParam(..)\n             | Annotatable::Param(..)\n             | Annotatable::FieldDef(..)\n-            | Annotatable::Variant(..) => panic!(\"unexpected annotatable\"),\n+            | Annotatable::Variant(..)\n+            | Annotatable::Crate(..) => panic!(\"unexpected annotatable\"),\n         }\n     }\n \n@@ -220,6 +225,13 @@ impl Annotatable {\n             _ => panic!(\"expected variant\"),\n         }\n     }\n+\n+    pub fn expect_crate(self) -> ast::Crate {\n+        match self {\n+            Annotatable::Crate(krate) => krate,\n+            _ => panic!(\"expected krate\"),\n+        }\n+    }\n }\n \n /// Result of an expansion that may need to be retried.\n@@ -419,6 +431,11 @@ pub trait MacResult {\n     fn make_variants(self: Box<Self>) -> Option<SmallVec<[ast::Variant; 1]>> {\n         None\n     }\n+\n+    fn make_crate(self: Box<Self>) -> Option<ast::Crate> {\n+        // Fn-like macros cannot produce a crate.\n+        unreachable!()\n+    }\n }\n \n macro_rules! make_MacEager {"}, {"sha": "ba675daac41db488d9b1631bceffdf9527619605", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 63, "deletions": 75, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/48a5999fceeea84a8971634355287faa349909d4/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a5999fceeea84a8971634355287faa349909d4/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=48a5999fceeea84a8971634355287faa349909d4", "patch": "@@ -14,13 +14,13 @@ use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n use rustc_ast::{AstLike, Block, Inline, ItemKind, MacArgs, MacCall};\n use rustc_ast::{MacCallStmt, MacStmtStyle, MetaItemKind, ModKind, NestedMetaItem};\n-use rustc_ast::{NodeId, PatKind, Path, StmtKind, Unsafe};\n+use rustc_ast::{NodeId, PatKind, Path, StmtKind};\n use rustc_ast_pretty::pprust;\n use rustc_attr::is_builtin_attr;\n use rustc_data_structures::map_in_place::MapInPlace;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::{Applicability, FatalError, PResult};\n+use rustc_errors::{Applicability, PResult};\n use rustc_feature::Features;\n use rustc_parse::parser::{\n     AttemptLocalParseRecovery, ForceCollect, Parser, RecoverColon, RecoverComma,\n@@ -33,7 +33,7 @@ use rustc_session::Limit;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::{FileName, LocalExpnId, Span};\n \n-use smallvec::{smallvec, SmallVec};\n+use smallvec::SmallVec;\n use std::ops::DerefMut;\n use std::path::PathBuf;\n use std::rc::Rc;\n@@ -205,6 +205,7 @@ ast_fragments! {\n     Variants(SmallVec<[ast::Variant; 1]>) {\n         \"variant\"; many fn flat_map_variant; fn visit_variant(); fn make_variants;\n     }\n+    Crate(ast::Crate) { \"crate\"; one fn visit_crate; fn visit_crate; fn make_crate; }\n }\n \n pub enum SupportsMacroExpansion {\n@@ -227,9 +228,8 @@ impl AstFragmentKind {\n             AstFragmentKind::Items\n             | AstFragmentKind::TraitItems\n             | AstFragmentKind::ImplItems\n-            | AstFragmentKind::ForeignItems => {\n-                SupportsMacroExpansion::Yes { supports_inner_attrs: true }\n-            }\n+            | AstFragmentKind::ForeignItems\n+            | AstFragmentKind::Crate => SupportsMacroExpansion::Yes { supports_inner_attrs: true },\n             AstFragmentKind::Arms\n             | AstFragmentKind::Fields\n             | AstFragmentKind::FieldPats\n@@ -288,6 +288,9 @@ impl AstFragmentKind {\n             AstFragmentKind::OptExpr => {\n                 AstFragment::OptExpr(items.next().map(Annotatable::expect_expr))\n             }\n+            AstFragmentKind::Crate => {\n+                AstFragment::Crate(items.next().expect(\"expected exactly one crate\").expect_crate())\n+            }\n             AstFragmentKind::Pat | AstFragmentKind::Ty => {\n                 panic!(\"patterns and types aren't annotatable\")\n             }\n@@ -359,9 +362,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         MacroExpander { cx, monotonic }\n     }\n \n-    // FIXME: Avoid visiting the crate as a `Mod` item,\n-    // make crate a first class expansion target instead.\n-    pub fn expand_crate(&mut self, mut krate: ast::Crate) -> ast::Crate {\n+    pub fn expand_crate(&mut self, krate: ast::Crate) -> ast::Crate {\n         let file_path = match self.cx.source_map().span_to_filename(krate.span) {\n             FileName::Real(name) => name\n                 .into_local_path()\n@@ -375,52 +376,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             file_path_stack: vec![file_path],\n             dir_path,\n         });\n-\n-        let krate_item = AstFragment::Items(smallvec![P(ast::Item {\n-            attrs: krate.attrs,\n-            span: krate.span,\n-            kind: ast::ItemKind::Mod(\n-                Unsafe::No,\n-                ModKind::Loaded(krate.items, Inline::Yes, krate.span)\n-            ),\n-            ident: Ident::empty(),\n-            id: ast::DUMMY_NODE_ID,\n-            vis: ast::Visibility {\n-                span: krate.span.shrink_to_lo(),\n-                kind: ast::VisibilityKind::Public,\n-                tokens: None,\n-            },\n-            tokens: None,\n-        })]);\n-\n-        match self.fully_expand_fragment(krate_item).make_items().pop().map(P::into_inner) {\n-            Some(ast::Item {\n-                attrs,\n-                kind: ast::ItemKind::Mod(_, ModKind::Loaded(items, ..)),\n-                ..\n-            }) => {\n-                krate.attrs = attrs;\n-                krate.items = items;\n-            }\n-            None => {\n-                // Resolution failed so we return an empty expansion\n-                krate.attrs = vec![];\n-                krate.items = vec![];\n-            }\n-            Some(ast::Item { span, kind, .. }) => {\n-                krate.attrs = vec![];\n-                krate.items = vec![];\n-                self.cx.span_err(\n-                    span,\n-                    &format!(\n-                        \"expected crate top-level item to be a module after macro expansion, found {} {}\",\n-                        kind.article(), kind.descr()\n-                    ),\n-                );\n-                // FIXME: this workaround issue #84569\n-                FatalError.raise();\n-            }\n-        };\n+        let krate = self.fully_expand_fragment(AstFragment::Crate(krate)).make_crate();\n         self.cx.trace_macros_diag();\n         krate\n     }\n@@ -708,26 +664,32 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 SyntaxExtensionKind::Attr(expander) => {\n                     self.gate_proc_macro_input(&item);\n                     self.gate_proc_macro_attr_item(span, &item);\n-                    let mut fake_tokens = false;\n-                    if let Annotatable::Item(item_inner) = &item {\n-                        if let ItemKind::Mod(_, mod_kind) = &item_inner.kind {\n-                            // FIXME: Collect tokens and use them instead of generating\n-                            // fake ones. These are unstable, so it needs to be\n-                            // fixed prior to stabilization\n-                            // Fake tokens when we are invoking an inner attribute, and:\n-                            fake_tokens = matches!(attr.style, ast::AttrStyle::Inner) &&\n-                                // We are invoking an attribute on the crate root, or an outline\n-                                // module\n-                                (item_inner.ident.name.is_empty() || !matches!(mod_kind, ast::ModKind::Loaded(_, Inline::Yes, _)));\n-                        }\n-                    }\n-                    let tokens = if fake_tokens {\n-                        rustc_parse::fake_token_stream(\n+                    let tokens = match &item {\n+                        // FIXME: Collect tokens and use them instead of generating\n+                        // fake ones. These are unstable, so it needs to be\n+                        // fixed prior to stabilization\n+                        // Fake tokens when we are invoking an inner attribute, and\n+                        // we are invoking it on an out-of-line module or crate.\n+                        Annotatable::Crate(krate) => rustc_parse::fake_token_stream_for_crate(\n                             &self.cx.sess.parse_sess,\n-                            &item.into_nonterminal(),\n-                        )\n-                    } else {\n-                        item.into_tokens(&self.cx.sess.parse_sess)\n+                            krate,\n+                        ),\n+                        Annotatable::Item(item_inner)\n+                            if matches!(attr.style, ast::AttrStyle::Inner)\n+                                && matches!(\n+                                    item_inner.kind,\n+                                    ItemKind::Mod(\n+                                        _,\n+                                        ModKind::Unloaded | ModKind::Loaded(_, Inline::No, _),\n+                                    )\n+                                ) =>\n+                        {\n+                            rustc_parse::fake_token_stream(\n+                                &self.cx.sess.parse_sess,\n+                                &item.into_nonterminal(),\n+                            )\n+                        }\n+                        _ => item.into_tokens(&self.cx.sess.parse_sess),\n                     };\n                     let attr_item = attr.unwrap_normal_item();\n                     if let MacArgs::Eq(..) = attr_item.args {\n@@ -804,7 +766,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             Annotatable::Item(_)\n             | Annotatable::TraitItem(_)\n             | Annotatable::ImplItem(_)\n-            | Annotatable::ForeignItem(_) => return,\n+            | Annotatable::ForeignItem(_)\n+            | Annotatable::Crate(..) => return,\n             Annotatable::Stmt(stmt) => {\n                 // Attributes are stable on item statements,\n                 // but unstable on all other kinds of statements\n@@ -949,6 +912,7 @@ pub fn parse_ast_fragment<'a>(\n             RecoverComma::No,\n             RecoverColon::Yes,\n         )?),\n+        AstFragmentKind::Crate => AstFragment::Crate(this.parse_crate_mod()?),\n         AstFragmentKind::Arms\n         | AstFragmentKind::Fields\n         | AstFragmentKind::FieldPats\n@@ -1195,6 +1159,30 @@ macro_rules! assign_id {\n }\n \n impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n+    fn visit_crate(&mut self, krate: &mut ast::Crate) {\n+        let span = krate.span;\n+        let empty_crate =\n+            || ast::Crate { attrs: Vec::new(), items: Vec::new(), span, is_placeholder: None };\n+        let mut fold_crate = |krate: ast::Crate| {\n+            let mut krate = match self.configure(krate) {\n+                Some(krate) => krate,\n+                None => return empty_crate(),\n+            };\n+\n+            if let Some(attr) = self.take_first_attr(&mut krate) {\n+                return self\n+                    .collect_attr(attr, Annotatable::Crate(krate), AstFragmentKind::Crate)\n+                    .make_crate();\n+            }\n+\n+            noop_visit_crate(&mut krate, self);\n+            krate\n+        };\n+\n+        // Cannot use `visit_clobber` here, see the FIXME on it.\n+        *krate = fold_crate(mem::replace(krate, empty_crate()));\n+    }\n+\n     fn visit_expr(&mut self, expr: &mut P<ast::Expr>) {\n         self.cfg.configure_expr(expr);\n         visit_clobber(expr.deref_mut(), |mut expr| {"}, {"sha": "25b3a5820e60aaaed52d6b42e870f672a23154a3", "filename": "compiler/rustc_expand/src/placeholders.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/48a5999fceeea84a8971634355287faa349909d4/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a5999fceeea84a8971634355287faa349909d4/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs?ref=48a5999fceeea84a8971634355287faa349909d4", "patch": "@@ -46,6 +46,12 @@ pub fn placeholder(\n         || P(ast::Pat { id, kind: ast::PatKind::MacCall(mac_placeholder()), span, tokens: None });\n \n     match kind {\n+        AstFragmentKind::Crate => AstFragment::Crate(ast::Crate {\n+            attrs: Default::default(),\n+            items: Default::default(),\n+            span,\n+            is_placeholder: Some(id),\n+        }),\n         AstFragmentKind::Expr => AstFragment::Expr(expr_placeholder()),\n         AstFragmentKind::OptExpr => AstFragment::OptExpr(Some(expr_placeholder())),\n         AstFragmentKind::Items => AstFragment::Items(smallvec![P(ast::Item {\n@@ -354,4 +360,12 @@ impl MutVisitor for PlaceholderExpander {\n             _ => noop_visit_ty(ty, self),\n         }\n     }\n+\n+    fn visit_crate(&mut self, krate: &mut ast::Crate) {\n+        if let Some(id) = krate.is_placeholder {\n+            *krate = self.remove(id).make_crate();\n+        } else {\n+            noop_visit_crate(krate, self)\n+        }\n+    }\n }"}, {"sha": "dbee92cf598b5b855e9fa25a4354feeb1966e346", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/48a5999fceeea84a8971634355287faa349909d4/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a5999fceeea84a8971634355287faa349909d4/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=48a5999fceeea84a8971634355287faa349909d4", "patch": "@@ -323,7 +323,7 @@ pub fn configure_and_expand(\n \n         let crate_attrs = krate.attrs.clone();\n         let extern_mod_loaded = |ident: Ident, attrs, items, span| {\n-            let krate = ast::Crate { attrs, items, span };\n+            let krate = ast::Crate { attrs, items, span, is_placeholder: None };\n             pre_expansion_lint(sess, lint_store, &krate, &crate_attrs, &ident.name.as_str());\n             (krate.attrs, krate.items)\n         };"}, {"sha": "2b1b2f3fce496f9eff9f95254ff0b9628ae29be9", "filename": "compiler/rustc_parse/src/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/48a5999fceeea84a8971634355287faa349909d4/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a5999fceeea84a8971634355287faa349909d4/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flib.rs?ref=48a5999fceeea84a8971634355287faa349909d4", "patch": "@@ -326,6 +326,12 @@ pub fn fake_token_stream(sess: &ParseSess, nt: &Nonterminal) -> TokenStream {\n     parse_stream_from_source_str(filename, source, sess, Some(nt.span()))\n }\n \n+pub fn fake_token_stream_for_crate(sess: &ParseSess, krate: &ast::Crate) -> TokenStream {\n+    let source = pprust::crate_to_string_for_macros(krate);\n+    let filename = FileName::macro_expansion_source_code(&source);\n+    parse_stream_from_source_str(filename, source, sess, Some(krate.span))\n+}\n+\n pub fn parse_cfg_attr(\n     attr: &Attribute,\n     parse_sess: &ParseSess,"}, {"sha": "cbeaf675be4e5657863ce3199814dd24b9da8f6e", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/48a5999fceeea84a8971634355287faa349909d4/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a5999fceeea84a8971634355287faa349909d4/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=48a5999fceeea84a8971634355287faa349909d4", "patch": "@@ -26,7 +26,7 @@ impl<'a> Parser<'a> {\n     /// Parses a source module as a crate. This is the main entry point for the parser.\n     pub fn parse_crate_mod(&mut self) -> PResult<'a, ast::Crate> {\n         let (attrs, items, span) = self.parse_mod(&token::Eof)?;\n-        Ok(ast::Crate { attrs, items, span })\n+        Ok(ast::Crate { attrs, items, span, is_placeholder: None })\n     }\n \n     /// Parses a `mod <foo> { ... }` or `mod <foo>;` item."}, {"sha": "26a5260b93fd256d7d8e655ffcc8e1734f65ce7b", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/48a5999fceeea84a8971634355287faa349909d4/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a5999fceeea84a8971634355287faa349909d4/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=48a5999fceeea84a8971634355287faa349909d4", "patch": "@@ -651,11 +651,6 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n \n     /// Constructs the reduced graph for one item.\n     fn build_reduced_graph_for_item(&mut self, item: &'b Item) {\n-        if matches!(item.kind, ItemKind::Mod(..)) && item.ident.name == kw::Empty {\n-            // Fake crate root item from expand.\n-            return;\n-        }\n-\n         let parent_scope = &self.parent_scope;\n         let parent = parent_scope.module;\n         let expansion = parent_scope.expansion;\n@@ -1499,4 +1494,13 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n \n         visit::walk_variant(self, variant);\n     }\n+\n+    fn visit_crate(&mut self, krate: &'b ast::Crate) {\n+        if let Some(id) = krate.is_placeholder {\n+            self.visit_invoc_in_module(id);\n+        } else {\n+            visit::walk_crate(self, krate);\n+            self.contains_macro_use(&krate.attrs);\n+        }\n+    }\n }"}, {"sha": "391baa85c61db99f0f85f63dce33f2065786521c", "filename": "compiler/rustc_resolve/src/def_collector.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/48a5999fceeea84a8971634355287faa349909d4/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a5999fceeea84a8971634355287faa349909d4/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs?ref=48a5999fceeea84a8971634355287faa349909d4", "patch": "@@ -7,7 +7,7 @@ use rustc_expand::expand::AstFragment;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::definitions::*;\n use rustc_span::hygiene::LocalExpnId;\n-use rustc_span::symbol::{kw, sym};\n+use rustc_span::symbol::sym;\n use rustc_span::Span;\n use tracing::debug;\n \n@@ -92,10 +92,6 @@ impl<'a, 'b> visit::Visitor<'a> for DefCollector<'a, 'b> {\n         // information we encapsulate into, the better\n         let def_data = match &i.kind {\n             ItemKind::Impl { .. } => DefPathData::Impl,\n-            ItemKind::Mod(..) if i.ident.name == kw::Empty => {\n-                // Fake crate root item from expand.\n-                return visit::walk_item(self, i);\n-            }\n             ItemKind::Mod(..)\n             | ItemKind::Trait(..)\n             | ItemKind::TraitAlias(..)\n@@ -346,4 +342,12 @@ impl<'a, 'b> visit::Visitor<'a> for DefCollector<'a, 'b> {\n     fn visit_field_def(&mut self, field: &'a FieldDef) {\n         self.collect_field(field, None);\n     }\n+\n+    fn visit_crate(&mut self, krate: &'a Crate) {\n+        if let Some(id) = krate.is_placeholder {\n+            self.visit_macro_invoc(id)\n+        } else {\n+            visit::walk_crate(self, krate)\n+        }\n+    }\n }"}, {"sha": "6c8660313708d7ca053d213029b569e9722e58df", "filename": "library/core/src/ops/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/48a5999fceeea84a8971634355287faa349909d4/library%2Fcore%2Fsrc%2Fops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a5999fceeea84a8971634355287faa349909d4/library%2Fcore%2Fsrc%2Fops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fmod.rs?ref=48a5999fceeea84a8971634355287faa349909d4", "patch": "@@ -181,6 +181,9 @@ pub use self::range::{Range, RangeFrom, RangeFull, RangeTo};\n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n pub use self::range::{Bound, RangeBounds, RangeInclusive, RangeToInclusive};\n \n+#[unstable(feature = \"one_sided_range\", issue = \"69780\")]\n+pub use self::range::OneSidedRange;\n+\n #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n pub use self::try_trait::{FromResidual, Try};\n "}, {"sha": "1136722067874250be22bfba32ef44aa126a213b", "filename": "library/core/src/ops/range.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/48a5999fceeea84a8971634355287faa349909d4/library%2Fcore%2Fsrc%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a5999fceeea84a8971634355287faa349909d4/library%2Fcore%2Fsrc%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Frange.rs?ref=48a5999fceeea84a8971634355287faa349909d4", "patch": "@@ -971,3 +971,21 @@ impl<T> RangeBounds<T> for RangeToInclusive<&T> {\n         Included(self.end)\n     }\n }\n+\n+/// `OneSidedRange` is implemented for built-in range types that are unbounded\n+/// on one side. For example, `a..`, `..b` and `..=c` implement `OneSidedRange`,\n+/// but `..`, `d..e`, and `f..=g` do not.\n+///\n+/// Types that implement `OneSidedRange<T>` must return `Bound::Unbounded`\n+/// from one of `RangeBounds::start_bound` or `RangeBounds::end_bound`.\n+#[unstable(feature = \"one_sided_range\", issue = \"69780\")]\n+pub trait OneSidedRange<T: ?Sized>: RangeBounds<T> {}\n+\n+#[unstable(feature = \"one_sided_range\", issue = \"69780\")]\n+impl<T> OneSidedRange<T> for RangeTo<T> where Self: RangeBounds<T> {}\n+\n+#[unstable(feature = \"one_sided_range\", issue = \"69780\")]\n+impl<T> OneSidedRange<T> for RangeFrom<T> where Self: RangeBounds<T> {}\n+\n+#[unstable(feature = \"one_sided_range\", issue = \"69780\")]\n+impl<T> OneSidedRange<T> for RangeToInclusive<T> where Self: RangeBounds<T> {}"}, {"sha": "a3f59d307595485aeeb6e0c0df7db95899c0032c", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 263, "deletions": 1, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/48a5999fceeea84a8971634355287faa349909d4/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a5999fceeea84a8971634355287faa349909d4/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=48a5999fceeea84a8971634355287faa349909d4", "patch": "@@ -10,7 +10,7 @@ use crate::cmp::Ordering::{self, Greater, Less};\n use crate::marker::Copy;\n use crate::mem;\n use crate::num::NonZeroUsize;\n-use crate::ops::{FnMut, Range, RangeBounds};\n+use crate::ops::{Bound, FnMut, OneSidedRange, Range, RangeBounds};\n use crate::option::Option;\n use crate::option::Option::{None, Some};\n use crate::ptr;\n@@ -82,6 +82,29 @@ pub use index::range;\n #[unstable(feature = \"inherent_ascii_escape\", issue = \"77174\")]\n pub use ascii::EscapeAscii;\n \n+/// Calculates the direction and split point of a one-sided range.\n+///\n+/// This is a helper function for `take` and `take_mut` that returns\n+/// the direction of the split (front or back) as well as the index at\n+/// which to split. Returns `None` if the split index would overflow.\n+#[inline]\n+fn split_point_of(range: impl OneSidedRange<usize>) -> Option<(Direction, usize)> {\n+    use Bound::*;\n+\n+    Some(match (range.start_bound(), range.end_bound()) {\n+        (Unbounded, Excluded(i)) => (Direction::Front, *i),\n+        (Unbounded, Included(i)) => (Direction::Front, i.checked_add(1)?),\n+        (Excluded(i), Unbounded) => (Direction::Back, i.checked_add(1)?),\n+        (Included(i), Unbounded) => (Direction::Back, *i),\n+        _ => unreachable!(),\n+    })\n+}\n+\n+enum Direction {\n+    Front,\n+    Back,\n+}\n+\n #[lang = \"slice\"]\n #[cfg(not(test))]\n impl<T> [T] {\n@@ -3517,6 +3540,245 @@ impl<T> [T] {\n     {\n         self.binary_search_by(|x| if pred(x) { Less } else { Greater }).unwrap_or_else(|i| i)\n     }\n+\n+    /// Removes the subslice corresponding to the given range\n+    /// and returns a reference to it.\n+    ///\n+    /// Returns `None` and does not modify the slice if the given\n+    /// range is out of bounds.\n+    ///\n+    /// Note that this method only accepts one-sided ranges such as\n+    /// `2..` or `..6`, but not `2..6`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Taking the first three elements of a slice:\n+    ///\n+    /// ```\n+    /// #![feature(slice_take)]\n+    ///\n+    /// let mut slice: &[_] = &['a', 'b', 'c', 'd'];\n+    /// let mut first_three = slice.take(..3).unwrap();\n+    ///\n+    /// assert_eq!(slice, &['d']);\n+    /// assert_eq!(first_three, &['a', 'b', 'c']);\n+    /// ```\n+    ///\n+    /// Taking the last two elements of a slice:\n+    ///\n+    /// ```\n+    /// #![feature(slice_take)]\n+    ///\n+    /// let mut slice: &[_] = &['a', 'b', 'c', 'd'];\n+    /// let mut tail = slice.take(2..).unwrap();\n+    ///\n+    /// assert_eq!(slice, &['a', 'b']);\n+    /// assert_eq!(tail, &['c', 'd']);\n+    /// ```\n+    ///\n+    /// Getting `None` when `range` is out of bounds:\n+    ///\n+    /// ```\n+    /// #![feature(slice_take)]\n+    ///\n+    /// let mut slice: &[_] = &['a', 'b', 'c', 'd'];\n+    ///\n+    /// assert_eq!(None, slice.take(5..));\n+    /// assert_eq!(None, slice.take(..5));\n+    /// assert_eq!(None, slice.take(..=4));\n+    /// let expected: &[char] = &['a', 'b', 'c', 'd'];\n+    /// assert_eq!(Some(expected), slice.take(..4));\n+    /// ```\n+    #[inline]\n+    #[must_use = \"method does not modify the slice if the range is out of bounds\"]\n+    #[unstable(feature = \"slice_take\", issue = \"62280\")]\n+    pub fn take<'a, R: OneSidedRange<usize>>(self: &mut &'a Self, range: R) -> Option<&'a Self> {\n+        let (direction, split_index) = split_point_of(range)?;\n+        if split_index > self.len() {\n+            return None;\n+        }\n+        let (front, back) = self.split_at(split_index);\n+        match direction {\n+            Direction::Front => {\n+                *self = back;\n+                Some(front)\n+            }\n+            Direction::Back => {\n+                *self = front;\n+                Some(back)\n+            }\n+        }\n+    }\n+\n+    /// Removes the subslice corresponding to the given range\n+    /// and returns a mutable reference to it.\n+    ///\n+    /// Returns `None` and does not modify the slice if the given\n+    /// range is out of bounds.\n+    ///\n+    /// Note that this method only accepts one-sided ranges such as\n+    /// `2..` or `..6`, but not `2..6`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Taking the first three elements of a slice:\n+    ///\n+    /// ```\n+    /// #![feature(slice_take)]\n+    ///\n+    /// let mut slice: &mut [_] = &mut ['a', 'b', 'c', 'd'];\n+    /// let mut first_three = slice.take_mut(..3).unwrap();\n+    ///\n+    /// assert_eq!(slice, &mut ['d']);\n+    /// assert_eq!(first_three, &mut ['a', 'b', 'c']);\n+    /// ```\n+    ///\n+    /// Taking the last two elements of a slice:\n+    ///\n+    /// ```\n+    /// #![feature(slice_take)]\n+    ///\n+    /// let mut slice: &mut [_] = &mut ['a', 'b', 'c', 'd'];\n+    /// let mut tail = slice.take_mut(2..).unwrap();\n+    ///\n+    /// assert_eq!(slice, &mut ['a', 'b']);\n+    /// assert_eq!(tail, &mut ['c', 'd']);\n+    /// ```\n+    ///\n+    /// Getting `None` when `range` is out of bounds:\n+    ///\n+    /// ```\n+    /// #![feature(slice_take)]\n+    ///\n+    /// let mut slice: &mut [_] = &mut ['a', 'b', 'c', 'd'];\n+    ///\n+    /// assert_eq!(None, slice.take_mut(5..));\n+    /// assert_eq!(None, slice.take_mut(..5));\n+    /// assert_eq!(None, slice.take_mut(..=4));\n+    /// let expected: &mut [_] = &mut ['a', 'b', 'c', 'd'];\n+    /// assert_eq!(Some(expected), slice.take_mut(..4));\n+    /// ```\n+    #[inline]\n+    #[must_use = \"method does not modify the slice if the range is out of bounds\"]\n+    #[unstable(feature = \"slice_take\", issue = \"62280\")]\n+    pub fn take_mut<'a, R: OneSidedRange<usize>>(\n+        self: &mut &'a mut Self,\n+        range: R,\n+    ) -> Option<&'a mut Self> {\n+        let (direction, split_index) = split_point_of(range)?;\n+        if split_index > self.len() {\n+            return None;\n+        }\n+        let (front, back) = mem::take(self).split_at_mut(split_index);\n+        match direction {\n+            Direction::Front => {\n+                *self = back;\n+                Some(front)\n+            }\n+            Direction::Back => {\n+                *self = front;\n+                Some(back)\n+            }\n+        }\n+    }\n+\n+    /// Removes the first element of the slice and returns a reference\n+    /// to it.\n+    ///\n+    /// Returns `None` if the slice is empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_take)]\n+    ///\n+    /// let mut slice: &[_] = &['a', 'b', 'c'];\n+    /// let first = slice.take_first().unwrap();\n+    ///\n+    /// assert_eq!(slice, &['b', 'c']);\n+    /// assert_eq!(first, &'a');\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"slice_take\", issue = \"62280\")]\n+    pub fn take_first<'a>(self: &mut &'a Self) -> Option<&'a T> {\n+        let (first, rem) = self.split_first()?;\n+        *self = rem;\n+        Some(first)\n+    }\n+\n+    /// Removes the first element of the slice and returns a mutable\n+    /// reference to it.\n+    ///\n+    /// Returns `None` if the slice is empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_take)]\n+    ///\n+    /// let mut slice: &mut [_] = &mut ['a', 'b', 'c'];\n+    /// let first = slice.take_first_mut().unwrap();\n+    /// *first = 'd';\n+    ///\n+    /// assert_eq!(slice, &['b', 'c']);\n+    /// assert_eq!(first, &'d');\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"slice_take\", issue = \"62280\")]\n+    pub fn take_first_mut<'a>(self: &mut &'a mut Self) -> Option<&'a mut T> {\n+        let (first, rem) = mem::take(self).split_first_mut()?;\n+        *self = rem;\n+        Some(first)\n+    }\n+\n+    /// Removes the last element of the slice and returns a reference\n+    /// to it.\n+    ///\n+    /// Returns `None` if the slice is empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_take)]\n+    ///\n+    /// let mut slice: &[_] = &['a', 'b', 'c'];\n+    /// let last = slice.take_last().unwrap();\n+    ///\n+    /// assert_eq!(slice, &['a', 'b']);\n+    /// assert_eq!(last, &'c');\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"slice_take\", issue = \"62280\")]\n+    pub fn take_last<'a>(self: &mut &'a Self) -> Option<&'a T> {\n+        let (last, rem) = self.split_last()?;\n+        *self = rem;\n+        Some(last)\n+    }\n+\n+    /// Removes the last element of the slice and returns a mutable\n+    /// reference to it.\n+    ///\n+    /// Returns `None` if the slice is empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_take)]\n+    ///\n+    /// let mut slice: &mut [_] = &mut ['a', 'b', 'c'];\n+    /// let last = slice.take_last_mut().unwrap();\n+    /// *last = 'd';\n+    ///\n+    /// assert_eq!(slice, &['a', 'b']);\n+    /// assert_eq!(last, &'d');\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"slice_take\", issue = \"62280\")]\n+    pub fn take_last_mut<'a>(self: &mut &'a mut Self) -> Option<&'a mut T> {\n+        let (last, rem) = mem::take(self).split_last_mut()?;\n+        *self = rem;\n+        Some(last)\n+    }\n }\n \n trait CloneFromSpec<T> {"}, {"sha": "414995e8f7a7422914e516534b3ce36dbe907e37", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/48a5999fceeea84a8971634355287faa349909d4/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a5999fceeea84a8971634355287faa349909d4/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=48a5999fceeea84a8971634355287faa349909d4", "patch": "@@ -36,6 +36,7 @@\n #![feature(pattern)]\n #![feature(sort_internals)]\n #![feature(slice_partition_at_index)]\n+#![feature(slice_take)]\n #![feature(maybe_uninit_uninit_array)]\n #![feature(maybe_uninit_array_assume_init)]\n #![feature(maybe_uninit_extra)]"}, {"sha": "7ba01caeefd7ceef26ef462739d07fb1b91d0fbc", "filename": "library/core/tests/slice.rs", "status": "modified", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/48a5999fceeea84a8971634355287faa349909d4/library%2Fcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a5999fceeea84a8971634355287faa349909d4/library%2Fcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fslice.rs?ref=48a5999fceeea84a8971634355287faa349909d4", "patch": "@@ -2234,3 +2234,112 @@ fn slice_split_array_mut_out_of_bounds() {\n \n     v.split_array_mut::<7>();\n }\n+\n+macro_rules! take_tests {\n+    (slice: &[], $($tts:tt)*) => {\n+        take_tests!(ty: &[()], slice: &[], $($tts)*);\n+    };\n+    (slice: &mut [], $($tts:tt)*) => {\n+        take_tests!(ty: &mut [()], slice: &mut [], $($tts)*);\n+    };\n+    (slice: &$slice:expr, $($tts:tt)*) => {\n+        take_tests!(ty: &[_], slice: &$slice, $($tts)*);\n+    };\n+    (slice: &mut $slice:expr, $($tts:tt)*) => {\n+        take_tests!(ty: &mut [_], slice: &mut $slice, $($tts)*);\n+    };\n+    (ty: $ty:ty, slice: $slice:expr, method: $method:ident, $(($test_name:ident, ($($args:expr),*), $output:expr, $remaining:expr),)*) => {\n+        $(\n+            #[test]\n+            fn $test_name() {\n+                let mut slice: $ty = $slice;\n+                assert_eq!($output, slice.$method($($args)*));\n+                let remaining: $ty = $remaining;\n+                assert_eq!(remaining, slice);\n+            }\n+        )*\n+    };\n+}\n+\n+take_tests! {\n+    slice: &[0, 1, 2, 3], method: take,\n+    (take_in_bounds_range_to, (..1), Some(&[0] as _), &[1, 2, 3]),\n+    (take_in_bounds_range_to_inclusive, (..=0), Some(&[0] as _), &[1, 2, 3]),\n+    (take_in_bounds_range_from, (2..), Some(&[2, 3] as _), &[0, 1]),\n+    (take_oob_range_to, (..5), None, &[0, 1, 2, 3]),\n+    (take_oob_range_to_inclusive, (..=4), None, &[0, 1, 2, 3]),\n+    (take_oob_range_from, (5..), None, &[0, 1, 2, 3]),\n+}\n+\n+take_tests! {\n+    slice: &mut [0, 1, 2, 3], method: take_mut,\n+    (take_mut_in_bounds_range_to, (..1), Some(&mut [0] as _), &mut [1, 2, 3]),\n+    (take_mut_in_bounds_range_to_inclusive, (..=0), Some(&mut [0] as _), &mut [1, 2, 3]),\n+    (take_mut_in_bounds_range_from, (2..), Some(&mut [2, 3] as _), &mut [0, 1]),\n+    (take_mut_oob_range_to, (..5), None, &mut [0, 1, 2, 3]),\n+    (take_mut_oob_range_to_inclusive, (..=4), None, &mut [0, 1, 2, 3]),\n+    (take_mut_oob_range_from, (5..), None, &mut [0, 1, 2, 3]),\n+}\n+\n+take_tests! {\n+    slice: &[1, 2], method: take_first,\n+    (take_first_nonempty, (), Some(&1), &[2]),\n+}\n+\n+take_tests! {\n+    slice: &mut [1, 2], method: take_first_mut,\n+    (take_first_mut_nonempty, (), Some(&mut 1), &mut [2]),\n+}\n+\n+take_tests! {\n+    slice: &[1, 2], method: take_last,\n+    (take_last_nonempty, (), Some(&2), &[1]),\n+}\n+\n+take_tests! {\n+    slice: &mut [1, 2], method: take_last_mut,\n+    (take_last_mut_nonempty, (), Some(&mut 2), &mut [1]),\n+}\n+\n+take_tests! {\n+    slice: &[], method: take_first,\n+    (take_first_empty, (), None, &[]),\n+}\n+\n+take_tests! {\n+    slice: &mut [], method: take_first_mut,\n+    (take_first_mut_empty, (), None, &mut []),\n+}\n+\n+take_tests! {\n+    slice: &[], method: take_last,\n+    (take_last_empty, (), None, &[]),\n+}\n+\n+take_tests! {\n+    slice: &mut [], method: take_last_mut,\n+    (take_last_mut_empty, (), None, &mut []),\n+}\n+\n+const EMPTY_MAX: &'static [()] = &[(); usize::MAX];\n+\n+// can't be a constant due to const mutability rules\n+macro_rules! empty_max_mut {\n+    () => {\n+        &mut [(); usize::MAX] as _\n+    };\n+}\n+\n+take_tests! {\n+    slice: &[(); usize::MAX], method: take,\n+    (take_in_bounds_max_range_to, (..usize::MAX), Some(EMPTY_MAX), &[(); 0]),\n+    (take_oob_max_range_to_inclusive, (..=usize::MAX), None, EMPTY_MAX),\n+    (take_in_bounds_max_range_from, (usize::MAX..), Some(&[] as _), EMPTY_MAX),\n+}\n+\n+take_tests! {\n+    slice: &mut [(); usize::MAX], method: take_mut,\n+    (take_mut_in_bounds_max_range_to, (..usize::MAX), Some(empty_max_mut!()), &mut [(); 0]),\n+    (take_mut_oob_max_range_to_inclusive, (..=usize::MAX), None, empty_max_mut!()),\n+    (take_mut_in_bounds_max_range_from, (usize::MAX..), Some(&mut [] as _), empty_max_mut!()),\n+}"}, {"sha": "e131089f361838d24a86781d536877fa294605b7", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/48a5999fceeea84a8971634355287faa349909d4/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a5999fceeea84a8971634355287faa349909d4/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=48a5999fceeea84a8971634355287faa349909d4", "patch": "@@ -1337,25 +1337,15 @@ fn normalize(cx: &mut DocContext<'tcx>, ty: Ty<'_>) -> Option<Ty<'tcx>> {\n         return None;\n     }\n \n-    use crate::rustc_trait_selection::infer::TyCtxtInferExt;\n-    use crate::rustc_trait_selection::traits::query::normalize::AtExt;\n-    use rustc_middle::traits::ObligationCause;\n-\n     // Try to normalize `<X as Y>::T` to a type\n     let lifted = ty.lift_to_tcx(cx.tcx).unwrap();\n-    let normalized = cx.tcx.infer_ctxt().enter(|infcx| {\n-        infcx\n-            .at(&ObligationCause::dummy(), cx.param_env)\n-            .normalize(lifted)\n-            .map(|resolved| infcx.resolve_vars_if_possible(resolved.value))\n-    });\n-    match normalized {\n+    match cx.tcx.try_normalize_erasing_regions(cx.param_env, lifted) {\n         Ok(normalized_value) => {\n-            debug!(\"normalized {:?} to {:?}\", ty, normalized_value);\n+            trace!(\"normalized {:?} to {:?}\", ty, normalized_value);\n             Some(normalized_value)\n         }\n         Err(err) => {\n-            debug!(\"failed to normalize {:?}: {:?}\", ty, err);\n+            info!(\"failed to normalize {:?}: {:?}\", ty, err);\n             None\n         }\n     }"}, {"sha": "01c8b654f9a01371414d1fd69cba38b289510a9e", "filename": "src/llvm-project", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm-project?ref=48a5999fceeea84a8971634355287faa349909d4", "patch": "@@ -1 +1 @@\n-Subproject commit f9b03d0e2d7378f8dd5697ceb72b310060f7598f\n+Subproject commit 01c8b654f9a01371414d1fd69cba38b289510a9e"}, {"sha": "ff65936bec95e51f46672e8f913caab1933e9567", "filename": "src/test/rustdoc-ui/auxiliary/overflow.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/48a5999fceeea84a8971634355287faa349909d4/src%2Ftest%2Frustdoc-ui%2Fauxiliary%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a5999fceeea84a8971634355287faa349909d4/src%2Ftest%2Frustdoc-ui%2Fauxiliary%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fauxiliary%2Foverflow.rs?ref=48a5999fceeea84a8971634355287faa349909d4", "patch": "@@ -0,0 +1,20 @@\n+pub struct B0;\n+pub struct B1;\n+use std::ops::Shl;\n+use std::ops::Sub;\n+pub type Shleft<A, B> = <A as Shl<B>>::Output;\n+pub type Sub1<A> = <A as Sub<B1>>::Output;\n+pub struct UInt<U, B> {\n+    pub(crate) msb: U,\n+    pub(crate) lsb: B,\n+}\n+impl<U, B, Ur, Br> Shl<UInt<Ur, Br>> for UInt<U, B>\n+where\n+    UInt<Ur, Br>: Sub<B1>,\n+    UInt<UInt<U, B>, B0>: Shl<Sub1<UInt<Ur, Br>>>,\n+{\n+    type Output = Shleft<UInt<UInt<U, B>, B0>, Sub1<UInt<Ur, Br>>>;\n+    fn shl(self, rhs: UInt<Ur, Br>) -> Self::Output {\n+        unimplemented!()\n+    }\n+}"}, {"sha": "f48cad373cdedc9b083305b0cd552df1bbd0f8e7", "filename": "src/test/rustdoc-ui/normalize-cycle.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/48a5999fceeea84a8971634355287faa349909d4/src%2Ftest%2Frustdoc-ui%2Fnormalize-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a5999fceeea84a8971634355287faa349909d4/src%2Ftest%2Frustdoc-ui%2Fnormalize-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fnormalize-cycle.rs?ref=48a5999fceeea84a8971634355287faa349909d4", "patch": "@@ -0,0 +1,25 @@\n+// check-pass\n+// Regresion test for <https://github.com/rust-lang/rust/issues/79459>.\n+pub trait Query {}\n+\n+pub trait AsQuery {\n+    type Query;\n+}\n+\n+impl<T: Query> AsQuery for T {\n+    type Query = T;\n+}\n+\n+pub trait SelectDsl<Selection> {\n+    type Output;\n+}\n+\n+impl<T, Selection> SelectDsl<Selection> for T\n+where\n+    T: AsQuery,\n+    T::Query: SelectDsl<Selection>,\n+{\n+    type Output = <T::Query as SelectDsl<Selection>>::Output;\n+}\n+\n+pub type Select<Source, Selection> = <Source as SelectDsl<Selection>>::Output;"}, {"sha": "0cdcc88e3141fc4136f777e9a2a8ba5de5be9492", "filename": "src/test/rustdoc-ui/normalize-overflow.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/48a5999fceeea84a8971634355287faa349909d4/src%2Ftest%2Frustdoc-ui%2Fnormalize-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a5999fceeea84a8971634355287faa349909d4/src%2Ftest%2Frustdoc-ui%2Fnormalize-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fnormalize-overflow.rs?ref=48a5999fceeea84a8971634355287faa349909d4", "patch": "@@ -0,0 +1,3 @@\n+// aux-crate:overflow=overflow.rs\n+// check-pass\n+// Regression test for <https://github.com/rust-lang/rust/issues/79506>."}, {"sha": "22484ba6378d32af0660dc36c60bfec20a740313", "filename": "src/test/ui/ast-json/ast-json-noexpand-output.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/48a5999fceeea84a8971634355287faa349909d4/src%2Ftest%2Fui%2Fast-json%2Fast-json-noexpand-output.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/48a5999fceeea84a8971634355287faa349909d4/src%2Ftest%2Fui%2Fast-json%2Fast-json-noexpand-output.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fast-json%2Fast-json-noexpand-output.stdout?ref=48a5999fceeea84a8971634355287faa349909d4", "patch": "@@ -1 +1 @@\n-{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"crate_type\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"args\":{\"variant\":\"Eq\",\"fields\":[{\"lo\":0,\"hi\":0},{\"kind\":{\"variant\":\"Interpolated\",\"fields\":[{\"variant\":\"NtExpr\",\"fields\":[{\"id\":0,\"kind\":{\"variant\":\"Lit\",\"fields\":[{\"token\":{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null},\"kind\":{\"variant\":\"Str\",\"fields\":[\"lib\",\"Cooked\"]},\"span\":{\"lo\":0,\"hi\":0}}]},\"span\":{\"lo\":0,\"hi\":0},\"attrs\":{\"0\":null},\"tokens\":{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"]]}}]}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"tokens\":null},{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Pound\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Joint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Not\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Delimited\",\"fields\":[{\"open\":{\"lo\":0,\"hi\":0},\"close\":{\"lo\":0,\"hi\":0}},\"Bracket\",{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"crate_type\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Eq\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"]]}]},\"Alone\"]]}]},\"id\":null,\"style\":\"Inner\",\"span\":{\"lo\":0,\"hi\":0}}],\"items\":[{\"attrs\":[],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null},\"ident\":{\"name\":\"core\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null}],\"span\":{\"lo\":0,\"hi\":0}}\n+{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"crate_type\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"args\":{\"variant\":\"Eq\",\"fields\":[{\"lo\":0,\"hi\":0},{\"kind\":{\"variant\":\"Interpolated\",\"fields\":[{\"variant\":\"NtExpr\",\"fields\":[{\"id\":0,\"kind\":{\"variant\":\"Lit\",\"fields\":[{\"token\":{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null},\"kind\":{\"variant\":\"Str\",\"fields\":[\"lib\",\"Cooked\"]},\"span\":{\"lo\":0,\"hi\":0}}]},\"span\":{\"lo\":0,\"hi\":0},\"attrs\":{\"0\":null},\"tokens\":{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"]]}}]}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"tokens\":null},{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Pound\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Joint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Not\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Delimited\",\"fields\":[{\"open\":{\"lo\":0,\"hi\":0},\"close\":{\"lo\":0,\"hi\":0}},\"Bracket\",{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"crate_type\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Eq\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"]]}]},\"Alone\"]]}]},\"id\":null,\"style\":\"Inner\",\"span\":{\"lo\":0,\"hi\":0}}],\"items\":[{\"attrs\":[],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null},\"ident\":{\"name\":\"core\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null}],\"span\":{\"lo\":0,\"hi\":0},\"is_placeholder\":null}"}, {"sha": "ae56bef35ffe70497effb35bc69f15324a97cf0d", "filename": "src/test/ui/ast-json/ast-json-output.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/48a5999fceeea84a8971634355287faa349909d4/src%2Ftest%2Fui%2Fast-json%2Fast-json-output.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/48a5999fceeea84a8971634355287faa349909d4/src%2Ftest%2Fui%2Fast-json%2Fast-json-output.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fast-json%2Fast-json-output.stdout?ref=48a5999fceeea84a8971634355287faa349909d4", "patch": "@@ -1 +1 @@\n-{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"crate_type\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"args\":{\"variant\":\"Eq\",\"fields\":[{\"lo\":0,\"hi\":0},{\"kind\":{\"variant\":\"Interpolated\",\"fields\":[{\"variant\":\"NtExpr\",\"fields\":[{\"id\":0,\"kind\":{\"variant\":\"Lit\",\"fields\":[{\"token\":{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null},\"kind\":{\"variant\":\"Str\",\"fields\":[\"lib\",\"Cooked\"]},\"span\":{\"lo\":0,\"hi\":0}}]},\"span\":{\"lo\":0,\"hi\":0},\"attrs\":{\"0\":null},\"tokens\":{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"]]}}]}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"tokens\":null},{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Pound\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Joint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Not\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Delimited\",\"fields\":[{\"open\":{\"lo\":0,\"hi\":0},\"close\":{\"lo\":0,\"hi\":0}},\"Bracket\",{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"crate_type\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Eq\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"]]}]},\"Alone\"]]}]},\"id\":null,\"style\":\"Inner\",\"span\":{\"lo\":0,\"hi\":0}}],\"items\":[{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"prelude_import\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"args\":\"Empty\",\"tokens\":null},null]},\"id\":null,\"style\":\"Outer\",\"span\":{\"lo\":0,\"hi\":0}}],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null},\"ident\":{\"name\":\"\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"Use\",\"fields\":[{\"prefix\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"{{root}}\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"std\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"prelude\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"rust_2015\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"kind\":\"Glob\",\"span\":{\"lo\":0,\"hi\":0}}]},\"tokens\":null},{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"macro_use\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"args\":\"Empty\",\"tokens\":null},null]},\"id\":null,\"style\":\"Outer\",\"span\":{\"lo\":0,\"hi\":0}}],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null},\"ident\":{\"name\":\"std\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null},{\"attrs\":[],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null},\"ident\":{\"name\":\"core\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null}],\"span\":{\"lo\":0,\"hi\":0}}\n+{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"crate_type\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"args\":{\"variant\":\"Eq\",\"fields\":[{\"lo\":0,\"hi\":0},{\"kind\":{\"variant\":\"Interpolated\",\"fields\":[{\"variant\":\"NtExpr\",\"fields\":[{\"id\":0,\"kind\":{\"variant\":\"Lit\",\"fields\":[{\"token\":{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null},\"kind\":{\"variant\":\"Str\",\"fields\":[\"lib\",\"Cooked\"]},\"span\":{\"lo\":0,\"hi\":0}}]},\"span\":{\"lo\":0,\"hi\":0},\"attrs\":{\"0\":null},\"tokens\":{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"]]}}]}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"tokens\":null},{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Pound\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Joint\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Not\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Delimited\",\"fields\":[{\"open\":{\"lo\":0,\"hi\":0},\"close\":{\"lo\":0,\"hi\":0}},\"Bracket\",{\"0\":[[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Ident\",\"fields\":[\"crate_type\",false]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":\"Eq\",\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"],[{\"variant\":\"Token\",\"fields\":[{\"kind\":{\"variant\":\"Literal\",\"fields\":[{\"kind\":\"Str\",\"symbol\":\"lib\",\"suffix\":null}]},\"span\":{\"lo\":0,\"hi\":0}}]},\"Alone\"]]}]},\"Alone\"]]}]},\"id\":null,\"style\":\"Inner\",\"span\":{\"lo\":0,\"hi\":0}}],\"items\":[{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"prelude_import\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"args\":\"Empty\",\"tokens\":null},null]},\"id\":null,\"style\":\"Outer\",\"span\":{\"lo\":0,\"hi\":0}}],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null},\"ident\":{\"name\":\"\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"Use\",\"fields\":[{\"prefix\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"{{root}}\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"std\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"prelude\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null},{\"ident\":{\"name\":\"rust_2015\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"kind\":\"Glob\",\"span\":{\"lo\":0,\"hi\":0}}]},\"tokens\":null},{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"macro_use\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":0,\"args\":null}],\"tokens\":null},\"args\":\"Empty\",\"tokens\":null},null]},\"id\":null,\"style\":\"Outer\",\"span\":{\"lo\":0,\"hi\":0}}],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null},\"ident\":{\"name\":\"std\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null},{\"attrs\":[],\"id\":0,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null},\"ident\":{\"name\":\"core\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null}],\"span\":{\"lo\":0,\"hi\":0},\"is_placeholder\":null}"}, {"sha": "29a0eca4172812044f0470ee45f8dde30c4aa36e", "filename": "src/test/ui/proc-macro/crate-attrs-multiple.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/48a5999fceeea84a8971634355287faa349909d4/src%2Ftest%2Fui%2Fproc-macro%2Fcrate-attrs-multiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a5999fceeea84a8971634355287faa349909d4/src%2Ftest%2Fui%2Fproc-macro%2Fcrate-attrs-multiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fcrate-attrs-multiple.rs?ref=48a5999fceeea84a8971634355287faa349909d4", "patch": "@@ -0,0 +1,14 @@\n+// Multiple custom crate-level attributes, both inert and active.\n+\n+// check-pass\n+// aux-crate:test_macros=test-macros.rs\n+\n+#![feature(custom_inner_attributes)]\n+#![feature(prelude_import)]\n+\n+#![test_macros::identity_attr]\n+#![rustfmt::skip]\n+#![test_macros::identity_attr]\n+#![rustfmt::skip]\n+\n+fn main() {}"}, {"sha": "a4161d4fc3dcc8625bf7788ecff9c2134ed6a72b", "filename": "src/test/ui/proc-macro/issue-59191-replace-root-with-fn.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/48a5999fceeea84a8971634355287faa349909d4/src%2Ftest%2Fui%2Fproc-macro%2Fissue-59191-replace-root-with-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48a5999fceeea84a8971634355287faa349909d4/src%2Ftest%2Fui%2Fproc-macro%2Fissue-59191-replace-root-with-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fissue-59191-replace-root-with-fn.rs?ref=48a5999fceeea84a8971634355287faa349909d4", "patch": "@@ -1,7 +1,10 @@\n-// edition:2018\n-// aux-crate:issue_59191=issue-59191.rs\n // Test that using a macro to replace the entire crate tree with a non-'mod' item errors out nicely.\n // `issue_59191::no_main` replaces whatever's passed in with `fn main() {}`.\n+\n+// edition:2018\n+// aux-crate:issue_59191=issue-59191.rs\n+// error-pattern: requires `sized` lang_item\n+\n #![feature(custom_inner_attributes)]\n #![issue_59191::no_main]\n-//~^ ERROR expected crate top-level item to be a module after macro expansion, found a function\n+#![issue_59191::no_main]"}, {"sha": "f7516c7d377dab1ff50429237150044408aa9e26", "filename": "src/test/ui/proc-macro/issue-59191-replace-root-with-fn.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/48a5999fceeea84a8971634355287faa349909d4/src%2Ftest%2Fui%2Fproc-macro%2Fissue-59191-replace-root-with-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/48a5999fceeea84a8971634355287faa349909d4/src%2Ftest%2Fui%2Fproc-macro%2Fissue-59191-replace-root-with-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fissue-59191-replace-root-with-fn.stderr?ref=48a5999fceeea84a8971634355287faa349909d4", "patch": "@@ -1,10 +1,4 @@\n-error: expected crate top-level item to be a module after macro expansion, found a function\n-  --> $DIR/issue-59191-replace-root-with-fn.rs:6:1\n-   |\n-LL | #![issue_59191::no_main]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: this error originates in the attribute macro `issue_59191::no_main` (in Nightly builds, run with -Z macro-backtrace for more info)\n+error: requires `sized` lang_item\n \n error: aborting due to previous error\n "}]}