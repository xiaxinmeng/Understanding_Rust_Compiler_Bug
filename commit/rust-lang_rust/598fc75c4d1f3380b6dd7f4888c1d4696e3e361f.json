{"sha": "598fc75c4d1f3380b6dd7f4888c1d4696e3e361f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5OGZjNzVjNGQxZjMzODBiNmRkN2Y0ODg4YzFkNDY5NmUzZTM2MWY=", "commit": {"author": {"name": "Flavio Percoco", "email": "flaper87@gmail.com", "date": "2014-03-14T21:59:50Z"}, "committer": {"name": "Flavio Percoco", "email": "flaper87@gmail.com", "date": "2014-03-20T09:17:29Z"}, "message": "Make atomics interior Unsafe<T>", "tree": {"sha": "c55d8e1e5f91e7af0389a3d016d069a4c09a2892", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c55d8e1e5f91e7af0389a3d016d069a4c09a2892"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/598fc75c4d1f3380b6dd7f4888c1d4696e3e361f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/598fc75c4d1f3380b6dd7f4888c1d4696e3e361f", "html_url": "https://github.com/rust-lang/rust/commit/598fc75c4d1f3380b6dd7f4888c1d4696e3e361f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/598fc75c4d1f3380b6dd7f4888c1d4696e3e361f/comments", "author": {"login": "flaper87", "id": 13816, "node_id": "MDQ6VXNlcjEzODE2", "avatar_url": "https://avatars.githubusercontent.com/u/13816?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flaper87", "html_url": "https://github.com/flaper87", "followers_url": "https://api.github.com/users/flaper87/followers", "following_url": "https://api.github.com/users/flaper87/following{/other_user}", "gists_url": "https://api.github.com/users/flaper87/gists{/gist_id}", "starred_url": "https://api.github.com/users/flaper87/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flaper87/subscriptions", "organizations_url": "https://api.github.com/users/flaper87/orgs", "repos_url": "https://api.github.com/users/flaper87/repos", "events_url": "https://api.github.com/users/flaper87/events{/privacy}", "received_events_url": "https://api.github.com/users/flaper87/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flaper87", "id": 13816, "node_id": "MDQ6VXNlcjEzODE2", "avatar_url": "https://avatars.githubusercontent.com/u/13816?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flaper87", "html_url": "https://github.com/flaper87", "followers_url": "https://api.github.com/users/flaper87/followers", "following_url": "https://api.github.com/users/flaper87/following{/other_user}", "gists_url": "https://api.github.com/users/flaper87/gists{/gist_id}", "starred_url": "https://api.github.com/users/flaper87/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flaper87/subscriptions", "organizations_url": "https://api.github.com/users/flaper87/orgs", "repos_url": "https://api.github.com/users/flaper87/repos", "events_url": "https://api.github.com/users/flaper87/events{/privacy}", "received_events_url": "https://api.github.com/users/flaper87/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68a3ec08b3a829d64e6bc452c0b11fbd01e70eaf", "url": "https://api.github.com/repos/rust-lang/rust/commits/68a3ec08b3a829d64e6bc452c0b11fbd01e70eaf", "html_url": "https://github.com/rust-lang/rust/commit/68a3ec08b3a829d64e6bc452c0b11fbd01e70eaf"}], "stats": {"total": 110, "additions": 60, "deletions": 50}, "files": [{"sha": "cbdb38c1c58b6d95104d9c44571f3eb8fb0ecc72", "filename": "src/libstd/sync/atomics.rs", "status": "modified", "additions": 60, "deletions": 50, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/598fc75c4d1f3380b6dd7f4888c1d4696e3e361f/src%2Flibstd%2Fsync%2Fatomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/598fc75c4d1f3380b6dd7f4888c1d4696e3e361f/src%2Flibstd%2Fsync%2Fatomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fatomics.rs?ref=598fc75c4d1f3380b6dd7f4888c1d4696e3e361f", "patch": "@@ -114,35 +114,36 @@ use cast;\n use std::kinds::marker;\n use option::{Option,Some,None};\n use ops::Drop;\n+use ty::Unsafe;\n \n /// An atomic boolean type.\n pub struct AtomicBool {\n-    priv v: uint,\n+    priv v: Unsafe<uint>,\n     priv nopod: marker::NoPod\n }\n \n /// A signed atomic integer type, supporting basic atomic arithmetic operations\n pub struct AtomicInt {\n-    priv v: int,\n+    priv v: Unsafe<int>,\n     priv nopod: marker::NoPod\n }\n \n /// An unsigned atomic integer type, supporting basic atomic arithmetic operations\n pub struct AtomicUint {\n-    priv v: uint,\n+    priv v: Unsafe<uint>,\n     priv nopod: marker::NoPod\n }\n \n /// An unsigned atomic integer type that is forced to be 64-bits. This does not\n /// support all operations.\n pub struct AtomicU64 {\n-    priv v: u64,\n+    priv v: Unsafe<u64>,\n     priv nopod: marker::NoPod\n }\n \n /// An unsafe atomic pointer. Only supports basic atomic operations\n pub struct AtomicPtr<T> {\n-    priv p: uint,\n+    priv p: Unsafe<uint>,\n     priv nopod: marker::NoPod\n }\n \n@@ -152,7 +153,7 @@ pub struct AtomicPtr<T> {\n /// owned heap objects across tasks.\n #[unsafe_no_drop_flag]\n pub struct AtomicOption<T> {\n-    priv p: uint,\n+    priv p: Unsafe<uint>,\n }\n \n /// Atomic memory orderings\n@@ -186,13 +187,21 @@ pub enum Ordering {\n }\n \n /// An `AtomicBool` initialized to `false`\n-pub static INIT_ATOMIC_BOOL : AtomicBool = AtomicBool { v: 0, nopod: marker::NoPod };\n+pub static INIT_ATOMIC_BOOL : AtomicBool = AtomicBool { v: Unsafe{value: 0,\n+                                                                  marker1: marker::InvariantType},\n+                                                        nopod: marker::NoPod };\n /// An `AtomicInt` initialized to `0`\n-pub static INIT_ATOMIC_INT  : AtomicInt  = AtomicInt  { v: 0, nopod: marker::NoPod };\n+pub static INIT_ATOMIC_INT  : AtomicInt  = AtomicInt  { v: Unsafe{value: 0,\n+                                                                  marker1: marker::InvariantType},\n+                                                        nopod: marker::NoPod };\n /// An `AtomicUint` initialized to `0`\n-pub static INIT_ATOMIC_UINT : AtomicUint = AtomicUint { v: 0, nopod: marker::NoPod };\n+pub static INIT_ATOMIC_UINT : AtomicUint = AtomicUint { v: Unsafe{value: 0,\n+                                                                  marker1: marker::InvariantType},\n+                                                        nopod: marker::NoPod };\n /// An `AtomicU64` initialized to `0`\n-pub static INIT_ATOMIC_U64 : AtomicU64 = AtomicU64 { v: 0, nopod: marker::NoPod };\n+pub static INIT_ATOMIC_U64 : AtomicU64 = AtomicU64 { v: Unsafe{value: 0,\n+                                                               marker1: marker::InvariantType},\n+                                                     nopod: marker::NoPod };\n \n \n // NB: Needs to be -1 (0b11111111...) to make fetch_nand work correctly\n@@ -201,29 +210,30 @@ static UINT_TRUE: uint = -1;\n impl AtomicBool {\n     /// Create a new `AtomicBool`\n     pub fn new(v: bool) -> AtomicBool {\n-        AtomicBool { v: if v { UINT_TRUE } else { 0 }, nopod: marker::NoPod }\n+        let val = if v { UINT_TRUE } else { 0 };\n+        AtomicBool { v: Unsafe::new(val), nopod: marker::NoPod }\n     }\n \n     /// Load the value\n     #[inline]\n     pub fn load(&self, order: Ordering) -> bool {\n-        unsafe { atomic_load(&self.v, order) > 0 }\n+        unsafe { atomic_load(&*self.v.get(), order) > 0 }\n     }\n \n     /// Store the value\n     #[inline]\n     pub fn store(&mut self, val: bool, order: Ordering) {\n         let val = if val { UINT_TRUE } else { 0 };\n \n-        unsafe { atomic_store(&mut self.v, val, order); }\n+        unsafe { atomic_store(&mut *self.v.get(), val, order); }\n     }\n \n     /// Store a value, returning the old value\n     #[inline]\n     pub fn swap(&mut self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n-        unsafe { atomic_swap(&mut self.v, val, order) > 0 }\n+        unsafe { atomic_swap(&mut *self.v.get(), val, order) > 0 }\n     }\n \n     /// If the current value is the same as expected, store a new value\n@@ -276,7 +286,7 @@ impl AtomicBool {\n         let old = if old { UINT_TRUE } else { 0 };\n         let new = if new { UINT_TRUE } else { 0 };\n \n-        unsafe { atomic_compare_and_swap(&mut self.v, old, new, order) > 0 }\n+        unsafe { atomic_compare_and_swap(&mut *self.v.get(), old, new, order) > 0 }\n     }\n \n     /// A logical \"and\" operation\n@@ -306,7 +316,7 @@ impl AtomicBool {\n     pub fn fetch_and(&mut self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n-        unsafe { atomic_and(&mut self.v, val, order) > 0 }\n+        unsafe { atomic_and(&mut *self.v.get(), val, order) > 0 }\n     }\n \n     /// A logical \"nand\" operation\n@@ -337,7 +347,7 @@ impl AtomicBool {\n     pub fn fetch_nand(&mut self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n-        unsafe { atomic_nand(&mut self.v, val, order) > 0 }\n+        unsafe { atomic_nand(&mut *self.v.get(), val, order) > 0 }\n     }\n \n     /// A logical \"or\" operation\n@@ -367,7 +377,7 @@ impl AtomicBool {\n     pub fn fetch_or(&mut self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n-        unsafe { atomic_or(&mut self.v, val, order) > 0 }\n+        unsafe { atomic_or(&mut *self.v.get(), val, order) > 0 }\n     }\n \n     /// A logical \"xor\" operation\n@@ -397,32 +407,32 @@ impl AtomicBool {\n     pub fn fetch_xor(&mut self, val: bool, order: Ordering) -> bool {\n         let val = if val { UINT_TRUE } else { 0 };\n \n-        unsafe { atomic_xor(&mut self.v, val, order) > 0 }\n+        unsafe { atomic_xor(&mut *self.v.get(), val, order) > 0 }\n     }\n }\n \n impl AtomicInt {\n     /// Create a new `AtomicInt`\n     pub fn new(v: int) -> AtomicInt {\n-        AtomicInt { v:v, nopod: marker::NoPod}\n+        AtomicInt {v: Unsafe::new(v), nopod: marker::NoPod}\n     }\n \n     /// Load the value\n     #[inline]\n     pub fn load(&self, order: Ordering) -> int {\n-        unsafe { atomic_load(&self.v, order) }\n+        unsafe { atomic_load(&*self.v.get(), order) }\n     }\n \n     /// Store the value\n     #[inline]\n     pub fn store(&mut self, val: int, order: Ordering) {\n-        unsafe { atomic_store(&mut self.v, val, order); }\n+        unsafe { atomic_store(&mut *self.v.get(), val, order); }\n     }\n \n     /// Store a value, returning the old value\n     #[inline]\n     pub fn swap(&mut self, val: int, order: Ordering) -> int {\n-        unsafe { atomic_swap(&mut self.v, val, order) }\n+        unsafe { atomic_swap(&mut *self.v.get(), val, order) }\n     }\n \n     /// If the current value is the same as expected, store a new value\n@@ -432,7 +442,7 @@ impl AtomicInt {\n     /// If the return value is equal to `old` then the value was updated.\n     #[inline]\n     pub fn compare_and_swap(&mut self, old: int, new: int, order: Ordering) -> int {\n-        unsafe { atomic_compare_and_swap(&mut self.v, old, new, order) }\n+        unsafe { atomic_compare_and_swap(&mut *self.v.get(), old, new, order) }\n     }\n \n     /// Add to the current value, returning the previous\n@@ -448,7 +458,7 @@ impl AtomicInt {\n     /// ```\n     #[inline]\n     pub fn fetch_add(&mut self, val: int, order: Ordering) -> int {\n-        unsafe { atomic_add(&mut self.v, val, order) }\n+        unsafe { atomic_add(&mut *self.v.get(), val, order) }\n     }\n \n     /// Subtract from the current value, returning the previous\n@@ -464,7 +474,7 @@ impl AtomicInt {\n     /// ```\n     #[inline]\n     pub fn fetch_sub(&mut self, val: int, order: Ordering) -> int {\n-        unsafe { atomic_sub(&mut self.v, val, order) }\n+        unsafe { atomic_sub(&mut *self.v.get(), val, order) }\n     }\n }\n \n@@ -474,62 +484,62 @@ impl AtomicInt {\n #[cfg(not(target_arch = \"mips\"))]\n impl AtomicU64 {\n     pub fn new(v: u64) -> AtomicU64 {\n-        AtomicU64 { v:v, nopod: marker::NoPod }\n+        AtomicU64 { v: Unsafe::new(v), nopod: marker::NoPod }\n     }\n \n     #[inline]\n     pub fn load(&self, order: Ordering) -> u64 {\n-        unsafe { atomic_load(&self.v, order) }\n+        unsafe { atomic_load(&*self.v.get(), order) }\n     }\n \n     #[inline]\n     pub fn store(&mut self, val: u64, order: Ordering) {\n-        unsafe { atomic_store(&mut self.v, val, order); }\n+        unsafe { atomic_store(&mut *self.v.get(), val, order); }\n     }\n \n     #[inline]\n     pub fn swap(&mut self, val: u64, order: Ordering) -> u64 {\n-        unsafe { atomic_swap(&mut self.v, val, order) }\n+        unsafe { atomic_swap(&mut *self.v.get(), val, order) }\n     }\n \n     #[inline]\n     pub fn compare_and_swap(&mut self, old: u64, new: u64, order: Ordering) -> u64 {\n-        unsafe { atomic_compare_and_swap(&mut self.v, old, new, order) }\n+        unsafe { atomic_compare_and_swap(&mut *self.v.get(), old, new, order) }\n     }\n \n     #[inline]\n     pub fn fetch_add(&mut self, val: u64, order: Ordering) -> u64 {\n-        unsafe { atomic_add(&mut self.v, val, order) }\n+        unsafe { atomic_add(&mut *self.v.get(), val, order) }\n     }\n \n     #[inline]\n     pub fn fetch_sub(&mut self, val: u64, order: Ordering) -> u64 {\n-        unsafe { atomic_sub(&mut self.v, val, order) }\n+        unsafe { atomic_sub(&mut *self.v.get(), val, order) }\n     }\n }\n \n impl AtomicUint {\n     /// Create a new `AtomicUint`\n     pub fn new(v: uint) -> AtomicUint {\n-        AtomicUint { v:v, nopod: marker::NoPod }\n+        AtomicUint { v: Unsafe::new(v), nopod: marker::NoPod }\n     }\n \n     /// Load the value\n     #[inline]\n     pub fn load(&self, order: Ordering) -> uint {\n-        unsafe { atomic_load(&self.v, order) }\n+        unsafe { atomic_load(&*self.v.get(), order) }\n     }\n \n     /// Store the value\n     #[inline]\n     pub fn store(&mut self, val: uint, order: Ordering) {\n-        unsafe { atomic_store(&mut self.v, val, order); }\n+        unsafe { atomic_store(&mut *self.v.get(), val, order); }\n     }\n \n     /// Store a value, returning the old value\n     #[inline]\n     pub fn swap(&mut self, val: uint, order: Ordering) -> uint {\n-        unsafe { atomic_swap(&mut self.v, val, order) }\n+        unsafe { atomic_swap(&mut *self.v.get(), val, order) }\n     }\n \n     /// If the current value is the same as expected, store a new value\n@@ -539,7 +549,7 @@ impl AtomicUint {\n     /// If the return value is equal to `old` then the value was updated.\n     #[inline]\n     pub fn compare_and_swap(&mut self, old: uint, new: uint, order: Ordering) -> uint {\n-        unsafe { atomic_compare_and_swap(&mut self.v, old, new, order) }\n+        unsafe { atomic_compare_and_swap(&mut *self.v.get(), old, new, order) }\n     }\n \n     /// Add to the current value, returning the previous\n@@ -555,7 +565,7 @@ impl AtomicUint {\n     /// ```\n     #[inline]\n     pub fn fetch_add(&mut self, val: uint, order: Ordering) -> uint {\n-        unsafe { atomic_add(&mut self.v, val, order) }\n+        unsafe { atomic_add(&mut *self.v.get(), val, order) }\n     }\n \n     /// Subtract from the current value, returning the previous\n@@ -571,34 +581,34 @@ impl AtomicUint {\n     /// ```\n     #[inline]\n     pub fn fetch_sub(&mut self, val: uint, order: Ordering) -> uint {\n-        unsafe { atomic_sub(&mut self.v, val, order) }\n+        unsafe { atomic_sub(&mut *self.v.get(), val, order) }\n     }\n }\n \n impl<T> AtomicPtr<T> {\n     /// Create a new `AtomicPtr`\n     pub fn new(p: *mut T) -> AtomicPtr<T> {\n-        AtomicPtr { p: p as uint, nopod: marker::NoPod }\n+        AtomicPtr { p: Unsafe::new(p as uint), nopod: marker::NoPod }\n     }\n \n     /// Load the value\n     #[inline]\n     pub fn load(&self, order: Ordering) -> *mut T {\n         unsafe {\n-            atomic_load(&self.p, order) as *mut T\n+            atomic_load(&*self.p.get(), order) as *mut T\n         }\n     }\n \n     /// Store the value\n     #[inline]\n     pub fn store(&mut self, ptr: *mut T, order: Ordering) {\n-        unsafe { atomic_store(&mut self.p, ptr as uint, order); }\n+        unsafe { atomic_store(&mut *self.p.get(), ptr as uint, order); }\n     }\n \n     /// Store a value, returning the old value\n     #[inline]\n     pub fn swap(&mut self, ptr: *mut T, order: Ordering) -> *mut T {\n-        unsafe { atomic_swap(&mut self.p, ptr as uint, order) as *mut T }\n+        unsafe { atomic_swap(&mut *self.p.get(), ptr as uint, order) as *mut T }\n     }\n \n     /// If the current value is the same as expected, store a new value\n@@ -609,7 +619,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     pub fn compare_and_swap(&mut self, old: *mut T, new: *mut T, order: Ordering) -> *mut T {\n         unsafe {\n-            atomic_compare_and_swap(&mut self.p, old as uint,\n+            atomic_compare_and_swap(&mut *self.p.get(), old as uint,\n                                     new as uint, order) as *mut T\n         }\n     }\n@@ -618,19 +628,19 @@ impl<T> AtomicPtr<T> {\n impl<T> AtomicOption<T> {\n     /// Create a new `AtomicOption`\n     pub fn new(p: ~T) -> AtomicOption<T> {\n-        unsafe { AtomicOption { p: cast::transmute(p) } }\n+        unsafe { AtomicOption { p: Unsafe::new(cast::transmute(p)) } }\n     }\n \n     /// Create a new `AtomicOption` that doesn't contain a value\n-    pub fn empty() -> AtomicOption<T> { AtomicOption { p: 0 } }\n+    pub fn empty() -> AtomicOption<T> { AtomicOption { p: Unsafe::new(0) } }\n \n     /// Store a value, returning the old value\n     #[inline]\n     pub fn swap(&mut self, val: ~T, order: Ordering) -> Option<~T> {\n         unsafe {\n             let val = cast::transmute(val);\n \n-            let p = atomic_swap(&mut self.p, val, order);\n+            let p = atomic_swap(&mut *self.p.get(), val, order);\n             if p as uint == 0 {\n                 None\n             } else {\n@@ -655,7 +665,7 @@ impl<T> AtomicOption<T> {\n         unsafe {\n             let val = cast::transmute(val);\n             let expected = cast::transmute(0);\n-            let oldval = atomic_compare_and_swap(&mut self.p, expected, val, order);\n+            let oldval = atomic_compare_and_swap(&mut *self.p.get(), expected, val, order);\n             if oldval == expected {\n                 None\n             } else {\n@@ -670,7 +680,7 @@ impl<T> AtomicOption<T> {\n     /// result does not get invalidated by another task after this returns.\n     #[inline]\n     pub fn is_empty(&mut self, order: Ordering) -> bool {\n-        unsafe { atomic_load(&self.p, order) as uint == 0 }\n+        unsafe { atomic_load(&*self.p.get(), order) as uint == 0 }\n     }\n }\n "}]}