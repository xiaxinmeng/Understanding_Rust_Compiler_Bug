{"sha": "71117e6812f87e014bc8e984e195a75e222ac227", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxMTE3ZTY4MTJmODdlMDE0YmM4ZTk4NGUxOTVhNzVlMjIyYWMyMjc=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-05-31T21:01:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-05-31T21:01:52Z"}, "message": "Merge #8717\n\n8717: Update match checking algorithm r=iDawer a=iDawer\n\nI've recently got interest in the match checking to extend the current algo to support reporting witnesses of non-exhaustiveness.\r\nIt appears the algo is outdated from rustc's implementation. I decided to rewrite it based on the latest rustc's version. It is a diff-based port to ra codebase. That means you can diff-compare these files to rustc.\r\nI'm striving to keep minimal ra-related changes in the algo to make it easier to backport future changes from the upstream.\r\n\r\nBased on upstream algorithm of version rust-lang/rust 1.52.0-nightly (25c15cdbe 2021-04-22)\r\nhttps://github.com/rust-lang/rust/blob/25c15cdbe/compiler/rustc_mir_build/src/thir/pattern/usefulness.rs\r\n\r\nThe goal of this PR is to cover the current `missing-match-arm` diagnostic.\r\n\r\nWhat is remaining to do:\r\n- [x] Error handling. The errors that are unrelated to match checking will be handled before the check. Just like how it made in rustc.\r\n  - [x] Lowering `hir_def::expr::Pat` to `hir_ty::diagnostics::match_check::Pat`. rustc's match checking works on top of `rustc_mir_build::thir::Pat`, which is lowered from `hir::Pat` and carries some extra semantics used by the check. All unrelated checks are done there. RA could use this to rule out running the check on unimplemented cases (`Pat::ConstBlock`, etc).\r\n  - [x] ~~Proper~~Loose typecheck of match arm patterns (https://github.com/rust-analyzer/rust-analyzer/pull/8840, https://github.com/rust-analyzer/rust-analyzer/pull/8875).\r\n- [x] Tests from `hir_ty::diagnostics::match_check::tests`.\r\n- [x] Clean up `todo`s\r\n- [x] Test run on real repos https://github.com/rust-analyzer/rust-analyzer/pull/8717#issuecomment-847120265.\n\nCo-authored-by: Dawer <7803845+iDawer@users.noreply.github.com>", "tree": {"sha": "8f5a74076cc2802c5de8fdb1b40e3eaf12252d51", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f5a74076cc2802c5de8fdb1b40e3eaf12252d51"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71117e6812f87e014bc8e984e195a75e222ac227", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgtU7ACRBK7hj4Ov3rIwAAbWcIADJWWXjOkrISrapMnhO9JzK5\nMOYrOAJf+b6ZT+OE9UIKzatR4Gmr7hhjVe4AIhhCyF1ZaSlEneLBMa8IAJypmf27\nGJnv2QhxIssVBBrd/Dn9X/il3EATgTF6rYjstH09FveCptbxkj1SGMyocJuzTUh2\nb21y+VEd/pcBcZbgJithzSHXV08yWBsJlOLN7adXjixEKrGoSjDEnZnH9A1Fncny\nx5NJoUiZpboxqgvZ6AZbgNjdDX4ZjtY8oa/aVX1dd+iL56jIQw40ovpdvupgg5xk\nNlGV5NxAcydZqYhMCbaKRxgP050wCmjLRMegASuC7N+ACMOChPv9IrJ+IndVtPM=\n=xJh7\n-----END PGP SIGNATURE-----\n", "payload": "tree 8f5a74076cc2802c5de8fdb1b40e3eaf12252d51\nparent 42dfdb87cb748e65d2c87687bde4d4712f9a850b\nparent e7c49666be180eba2720cce09d4d2116b1ef4d20\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1622494912 +0000\ncommitter GitHub <noreply@github.com> 1622494912 +0000\n\nMerge #8717\n\n8717: Update match checking algorithm r=iDawer a=iDawer\n\nI've recently got interest in the match checking to extend the current algo to support reporting witnesses of non-exhaustiveness.\r\nIt appears the algo is outdated from rustc's implementation. I decided to rewrite it based on the latest rustc's version. It is a diff-based port to ra codebase. That means you can diff-compare these files to rustc.\r\nI'm striving to keep minimal ra-related changes in the algo to make it easier to backport future changes from the upstream.\r\n\r\nBased on upstream algorithm of version rust-lang/rust 1.52.0-nightly (25c15cdbe 2021-04-22)\r\nhttps://github.com/rust-lang/rust/blob/25c15cdbe/compiler/rustc_mir_build/src/thir/pattern/usefulness.rs\r\n\r\nThe goal of this PR is to cover the current `missing-match-arm` diagnostic.\r\n\r\nWhat is remaining to do:\r\n- [x] Error handling. The errors that are unrelated to match checking will be handled before the check. Just like how it made in rustc.\r\n  - [x] Lowering `hir_def::expr::Pat` to `hir_ty::diagnostics::match_check::Pat`. rustc's match checking works on top of `rustc_mir_build::thir::Pat`, which is lowered from `hir::Pat` and carries some extra semantics used by the check. All unrelated checks are done there. RA could use this to rule out running the check on unimplemented cases (`Pat::ConstBlock`, etc).\r\n  - [x] ~~Proper~~Loose typecheck of match arm patterns (https://github.com/rust-analyzer/rust-analyzer/pull/8840, https://github.com/rust-analyzer/rust-analyzer/pull/8875).\r\n- [x] Tests from `hir_ty::diagnostics::match_check::tests`.\r\n- [x] Clean up `todo`s\r\n- [x] Test run on real repos https://github.com/rust-analyzer/rust-analyzer/pull/8717#issuecomment-847120265.\n\nCo-authored-by: Dawer <7803845+iDawer@users.noreply.github.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71117e6812f87e014bc8e984e195a75e222ac227", "html_url": "https://github.com/rust-lang/rust/commit/71117e6812f87e014bc8e984e195a75e222ac227", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71117e6812f87e014bc8e984e195a75e222ac227/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42dfdb87cb748e65d2c87687bde4d4712f9a850b", "url": "https://api.github.com/repos/rust-lang/rust/commits/42dfdb87cb748e65d2c87687bde4d4712f9a850b", "html_url": "https://github.com/rust-lang/rust/commit/42dfdb87cb748e65d2c87687bde4d4712f9a850b"}, {"sha": "e7c49666be180eba2720cce09d4d2116b1ef4d20", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7c49666be180eba2720cce09d4d2116b1ef4d20", "html_url": "https://github.com/rust-lang/rust/commit/e7c49666be180eba2720cce09d4d2116b1ef4d20"}], "stats": {"total": 3575, "additions": 2769, "deletions": 806}, "files": [{"sha": "4cdb5913deb5affac5c188ddaa1876a7a2b535ee", "filename": "crates/hir_def/src/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71117e6812f87e014bc8e984e195a75e222ac227/crates%2Fhir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71117e6812f87e014bc8e984e195a75e222ac227/crates%2Fhir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fpath.rs?ref=71117e6812f87e014bc8e984e195a75e222ac227", "patch": "@@ -166,7 +166,7 @@ impl Path {\n     }\n \n     /// Converts a known mod path to `Path`.\n-    pub(crate) fn from_known_path(\n+    pub fn from_known_path(\n         path: ModPath,\n         generic_args: Vec<Option<Interned<GenericArgs>>>,\n     ) -> Path {"}, {"sha": "4b714c6d8e4977015794ba943ab064e6e0ab72da", "filename": "crates/hir_ty/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/71117e6812f87e014bc8e984e195a75e222ac227/crates%2Fhir_ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/71117e6812f87e014bc8e984e195a75e222ac227/crates%2Fhir_ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2FCargo.toml?ref=71117e6812f87e014bc8e984e195a75e222ac227", "patch": "@@ -22,6 +22,7 @@ chalk-solve = { version = \"0.68\", default-features = false }\n chalk-ir = \"0.68\"\n chalk-recursive = \"0.68\"\n la-arena = { version = \"0.2.0\", path = \"../../lib/arena\" }\n+once_cell = { version = \"1.5.0\" }\n \n stdx = { path = \"../stdx\", version = \"0.0.0\" }\n hir_def = { path = \"../hir_def\", version = \"0.0.0\" }"}, {"sha": "3efbce77361ebf9dd29d0106385a7e8a2e4a9a94", "filename": "crates/hir_ty/src/diagnostics/expr.rs", "status": "modified", "additions": 86, "deletions": 31, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/71117e6812f87e014bc8e984e195a75e222ac227/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71117e6812f87e014bc8e984e195a75e222ac227/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=71117e6812f87e014bc8e984e195a75e222ac227", "patch": "@@ -2,17 +2,22 @@\n //! through the body using inference results: mismatched arg counts, missing\n //! fields, etc.\n \n-use std::sync::Arc;\n+use std::{cell::RefCell, sync::Arc};\n \n-use hir_def::{expr::Statement, path::path, resolver::HasResolver, AssocItemId, DefWithBodyId};\n+use hir_def::{\n+    expr::Statement, path::path, resolver::HasResolver, AssocItemId, DefWithBodyId, HasModule,\n+};\n use hir_expand::name;\n use rustc_hash::FxHashSet;\n use syntax::{ast, AstPtr};\n \n use crate::{\n     db::HirDatabase,\n     diagnostics::{\n-        match_check::{is_useful, MatchCheckCtx, Matrix, PatStack, Usefulness},\n+        match_check::{\n+            self,\n+            usefulness::{compute_match_usefulness, expand_pattern, MatchCheckCtx, PatternArena},\n+        },\n         MismatchedArgCount, MissingFields, MissingMatchArms, MissingOkOrSomeInTailExpr,\n         MissingPatFields, RemoveThisSemicolon,\n     },\n@@ -294,12 +299,12 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n             &infer.type_of_expr[match_expr]\n         };\n \n-        let cx = MatchCheckCtx { match_expr, body, infer: infer.clone(), db };\n-        let pats = arms.iter().map(|arm| arm.pat);\n+        let pattern_arena = RefCell::new(PatternArena::new());\n \n-        let mut seen = Matrix::empty();\n-        for pat in pats {\n-            if let Some(pat_ty) = infer.type_of_pat.get(pat) {\n+        let mut m_arms = Vec::new();\n+        let mut has_lowering_errors = false;\n+        for arm in arms {\n+            if let Some(pat_ty) = infer.type_of_pat.get(arm.pat) {\n                 // We only include patterns whose type matches the type\n                 // of the match expression. If we had a InvalidMatchArmPattern\n                 // diagnostic or similar we could raise that in an else\n@@ -315,49 +320,99 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n                         .as_reference()\n                         .map(|(match_expr_ty, ..)| match_expr_ty == pat_ty)\n                         .unwrap_or(false))\n-                    && types_of_subpatterns_do_match(pat, &cx.body, &infer)\n+                    && types_of_subpatterns_do_match(arm.pat, &body, &infer)\n                 {\n                     // If we had a NotUsefulMatchArm diagnostic, we could\n                     // check the usefulness of each pattern as we added it\n                     // to the matrix here.\n-                    let v = PatStack::from_pattern(pat);\n-                    seen.push(&cx, v);\n-                    continue;\n+                    let m_arm = match_check::MatchArm {\n+                        pat: self.lower_pattern(\n+                            arm.pat,\n+                            &mut pattern_arena.borrow_mut(),\n+                            db,\n+                            &body,\n+                            &mut has_lowering_errors,\n+                        ),\n+                        has_guard: arm.guard.is_some(),\n+                    };\n+                    m_arms.push(m_arm);\n+                    if !has_lowering_errors {\n+                        continue;\n+                    }\n                 }\n             }\n \n             // If we can't resolve the type of a pattern, or the pattern type doesn't\n             // fit the match expression, we skip this diagnostic. Skipping the entire\n             // diagnostic rather than just not including this match arm is preferred\n             // to avoid the chance of false positives.\n+            #[cfg(test)]\n+            match_check::tests::report_bail_out(db, self.owner, arm.pat, self.sink);\n             return;\n         }\n \n-        match is_useful(&cx, &seen, &PatStack::from_wild()) {\n-            Ok(Usefulness::Useful) => (),\n-            // if a wildcard pattern is not useful, then all patterns are covered\n-            Ok(Usefulness::NotUseful) => return,\n-            // this path is for unimplemented checks, so we err on the side of not\n-            // reporting any errors\n-            _ => return,\n-        }\n+        let cx = MatchCheckCtx {\n+            module: self.owner.module(db.upcast()),\n+            match_expr,\n+            infer: &infer,\n+            db,\n+            pattern_arena: &pattern_arena,\n+            eprint_panic_context: &|| {\n+                use syntax::AstNode;\n+                if let Ok(scrutinee_sptr) = source_map.expr_syntax(match_expr) {\n+                    let root = scrutinee_sptr.file_syntax(db.upcast());\n+                    if let Some(match_ast) = scrutinee_sptr.value.to_node(&root).syntax().parent() {\n+                        eprintln!(\n+                            \"Match checking is about to panic on this expression:\\n{}\",\n+                            match_ast.to_string(),\n+                        );\n+                    }\n+                }\n+            },\n+        };\n+        let report = compute_match_usefulness(&cx, &m_arms);\n \n-        if let Ok(source_ptr) = source_map.expr_syntax(id) {\n-            let root = source_ptr.file_syntax(db.upcast());\n-            if let ast::Expr::MatchExpr(match_expr) = &source_ptr.value.to_node(&root) {\n-                if let (Some(match_expr), Some(arms)) =\n-                    (match_expr.expr(), match_expr.match_arm_list())\n-                {\n-                    self.sink.push(MissingMatchArms {\n-                        file: source_ptr.file_id,\n-                        match_expr: AstPtr::new(&match_expr),\n-                        arms: AstPtr::new(&arms),\n-                    })\n+        // FIXME Report unreacheble arms\n+        // https://github.com/rust-lang/rust/blob/25c15cdbe/compiler/rustc_mir_build/src/thir/pattern/check_match.rs#L200-L201\n+\n+        let witnesses = report.non_exhaustiveness_witnesses;\n+        // FIXME Report witnesses\n+        // eprintln!(\"compute_match_usefulness(..) -> {:?}\", &witnesses);\n+        if !witnesses.is_empty() {\n+            if let Ok(source_ptr) = source_map.expr_syntax(id) {\n+                let root = source_ptr.file_syntax(db.upcast());\n+                if let ast::Expr::MatchExpr(match_expr) = &source_ptr.value.to_node(&root) {\n+                    if let (Some(match_expr), Some(arms)) =\n+                        (match_expr.expr(), match_expr.match_arm_list())\n+                    {\n+                        self.sink.push(MissingMatchArms {\n+                            file: source_ptr.file_id,\n+                            match_expr: AstPtr::new(&match_expr),\n+                            arms: AstPtr::new(&arms),\n+                        })\n+                    }\n                 }\n             }\n         }\n     }\n \n+    fn lower_pattern(\n+        &self,\n+        pat: PatId,\n+        pattern_arena: &mut PatternArena,\n+        db: &dyn HirDatabase,\n+        body: &Body,\n+        have_errors: &mut bool,\n+    ) -> match_check::PatId {\n+        let mut patcx = match_check::PatCtxt::new(db, &self.infer, body);\n+        let pattern = patcx.lower_pattern(pat);\n+        let pattern = pattern_arena.alloc(expand_pattern(pattern));\n+        if !patcx.errors.is_empty() {\n+            *have_errors = true;\n+        }\n+        pattern\n+    }\n+\n     fn validate_results_in_tail_expr(&mut self, body_id: ExprId, id: ExprId, db: &dyn HirDatabase) {\n         // the mismatch will be on the whole block currently\n         let mismatch = match self.infer.type_mismatch_for_expr(body_id) {"}, {"sha": "a9a99f57a249522e82e955a6b35d18f03119d817", "filename": "crates/hir_ty/src/diagnostics/match_check.rs", "status": "modified", "additions": 530, "deletions": 774, "changes": 1304, "blob_url": "https://github.com/rust-lang/rust/blob/71117e6812f87e014bc8e984e195a75e222ac227/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71117e6812f87e014bc8e984e195a75e222ac227/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs?ref=71117e6812f87e014bc8e984e195a75e222ac227", "patch": "@@ -1,871 +1,416 @@\n-//! This module implements match statement exhaustiveness checking and usefulness checking\n-//! for match arms.\n+//! Validation of matches.\n //!\n-//! It is modeled on the rustc module `librustc_mir_build::hair::pattern::_match`, which\n-//! contains very detailed documentation about the algorithms used here. I've duplicated\n-//! most of that documentation below.\n+//! This module provides lowering from [hir_def::expr::Pat] to [self::Pat] and match\n+//! checking algorithm.\n //!\n-//! This file includes the logic for exhaustiveness and usefulness checking for\n-//! pattern-matching. Specifically, given a list of patterns for a type, we can\n-//! tell whether:\n-//! - (a) the patterns cover every possible constructor for the type (exhaustiveness).\n-//! - (b) each pattern is necessary (usefulness).\n-//!\n-//! The algorithm implemented here is a modified version of the one described in\n-//! <http://moscova.inria.fr/~maranget/papers/warn/index.html>.\n-//! However, to save future implementors from reading the original paper, we\n-//! summarize the algorithm here to hopefully save time and be a little clearer\n-//! (without being so rigorous).\n-//!\n-//! The core of the algorithm revolves about a \"usefulness\" check. In particular, we\n-//! are trying to compute a predicate `U(P, p)` where `P` is a list of patterns (we refer to this as\n-//! a matrix). `U(P, p)` represents whether, given an existing list of patterns\n-//! `P_1 ..= P_m`, adding a new pattern `p` will be \"useful\" (that is, cover previously-\n-//! uncovered values of the type).\n-//!\n-//! If we have this predicate, then we can easily compute both exhaustiveness of an\n-//! entire set of patterns and the individual usefulness of each one.\n-//! (a) the set of patterns is exhaustive iff `U(P, _)` is false (i.e., adding a wildcard\n-//! match doesn't increase the number of values we're matching)\n-//! (b) a pattern `P_i` is not useful if `U(P[0..=(i-1), P_i)` is false (i.e., adding a\n-//! pattern to those that have come before it doesn't increase the number of values\n-//! we're matching).\n-//!\n-//! During the course of the algorithm, the rows of the matrix won't just be individual patterns,\n-//! but rather partially-deconstructed patterns in the form of a list of patterns. The paper\n-//! calls those pattern-vectors, and we will call them pattern-stacks. The same holds for the\n-//! new pattern `p`.\n-//!\n-//! For example, say we have the following:\n-//!\n-//! ```ignore\n-//! // x: (Option<bool>, Result<()>)\n-//! match x {\n-//!     (Some(true), _) => (),\n-//!     (None, Err(())) => (),\n-//!     (None, Err(_)) => (),\n-//! }\n-//! ```\n-//!\n-//! Here, the matrix `P` starts as:\n-//!\n-//! ```text\n-//! [\n-//!     [(Some(true), _)],\n-//!     [(None, Err(()))],\n-//!     [(None, Err(_))],\n-//! ]\n-//! ```\n-//!\n-//! We can tell it's not exhaustive, because `U(P, _)` is true (we're not covering\n-//! `[(Some(false), _)]`, for instance). In addition, row 3 is not useful, because\n-//! all the values it covers are already covered by row 2.\n-//!\n-//! A list of patterns can be thought of as a stack, because we are mainly interested in the top of\n-//! the stack at any given point, and we can pop or apply constructors to get new pattern-stacks.\n-//! To match the paper, the top of the stack is at the beginning / on the left.\n-//!\n-//! There are two important operations on pattern-stacks necessary to understand the algorithm:\n-//!\n-//! 1. We can pop a given constructor off the top of a stack. This operation is called\n-//!    `specialize`, and is denoted `S(c, p)` where `c` is a constructor (like `Some` or\n-//!    `None`) and `p` a pattern-stack.\n-//!    If the pattern on top of the stack can cover `c`, this removes the constructor and\n-//!    pushes its arguments onto the stack. It also expands OR-patterns into distinct patterns.\n-//!    Otherwise the pattern-stack is discarded.\n-//!    This essentially filters those pattern-stacks whose top covers the constructor `c` and\n-//!    discards the others.\n-//!\n-//!    For example, the first pattern above initially gives a stack `[(Some(true), _)]`. If we\n-//!    pop the tuple constructor, we are left with `[Some(true), _]`, and if we then pop the\n-//!    `Some` constructor we get `[true, _]`. If we had popped `None` instead, we would get\n-//!    nothing back.\n-//!\n-//!    This returns zero or more new pattern-stacks, as follows. We look at the pattern `p_1`\n-//!    on top of the stack, and we have four cases:\n-//!\n-//!    * 1.1. `p_1 = c(r_1, .., r_a)`, i.e. the top of the stack has constructor `c`. We push onto\n-//!           the stack the arguments of this constructor, and return the result:\n-//!\n-//!          r_1, .., r_a, p_2, .., p_n\n-//!\n-//!    * 1.2. `p_1 = c'(r_1, .., r_a')` where `c \u2260 c'`. We discard the current stack and return\n-//!           nothing.\n-//!    * 1.3. `p_1 = _`. We push onto the stack as many wildcards as the constructor `c` has\n-//!           arguments (its arity), and return the resulting stack:\n-//!\n-//!          _, .., _, p_2, .., p_n\n-//!\n-//!    * 1.4. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting stack:\n-//!\n-//!          S(c, (r_1, p_2, .., p_n))\n-//!          S(c, (r_2, p_2, .., p_n))\n-//!\n-//! 2. We can pop a wildcard off the top of the stack. This is called `D(p)`, where `p` is\n-//!    a pattern-stack.\n-//!    This is used when we know there are missing constructor cases, but there might be\n-//!    existing wildcard patterns, so to check the usefulness of the matrix, we have to check\n-//!    all its *other* components.\n-//!\n-//!    It is computed as follows. We look at the pattern `p_1` on top of the stack,\n-//!    and we have three cases:\n-//!    * 1.1. `p_1 = c(r_1, .., r_a)`. We discard the current stack and return nothing.\n-//!    * 1.2. `p_1 = _`. We return the rest of the stack:\n-//!\n-//!          p_2, .., p_n\n-//!\n-//!    * 1.3. `p_1 = r_1 | r_2`. We expand the OR-pattern and then recurse on each resulting stack:\n-//!\n-//!          D((r_1, p_2, .., p_n))\n-//!          D((r_2, p_2, .., p_n))\n-//!\n-//!    Note that the OR-patterns are not always used directly in Rust, but are used to derive the\n-//!    exhaustive integer matching rules, so they're written here for posterity.\n-//!\n-//! Both those operations extend straightforwardly to a list or pattern-stacks, i.e. a matrix, by\n-//! working row-by-row. Popping a constructor ends up keeping only the matrix rows that start with\n-//! the given constructor, and popping a wildcard keeps those rows that start with a wildcard.\n-//!\n-//!\n-//! The algorithm for computing `U`\n-//! -------------------------------\n-//! The algorithm is inductive (on the number of columns: i.e., components of tuple patterns).\n-//! That means we're going to check the components from left-to-right, so the algorithm\n-//! operates principally on the first component of the matrix and new pattern-stack `p`.\n-//! This algorithm is realized in the `is_useful` function.\n-//!\n-//! Base case (`n = 0`, i.e., an empty tuple pattern):\n-//! - If `P` already contains an empty pattern (i.e., if the number of patterns `m > 0`), then\n-//!   `U(P, p)` is false.\n-//! - Otherwise, `P` must be empty, so `U(P, p)` is true.\n-//!\n-//! Inductive step (`n > 0`, i.e., whether there's at least one column [which may then be expanded\n-//! into further columns later]). We're going to match on the top of the new pattern-stack, `p_1`:\n-//!\n-//! - If `p_1 == c(r_1, .., r_a)`, i.e. we have a constructor pattern.\n-//!   Then, the usefulness of `p_1` can be reduced to whether it is useful when\n-//!   we ignore all the patterns in the first column of `P` that involve other constructors.\n-//!   This is where `S(c, P)` comes in:\n-//!\n-//!   ```text\n-//!   U(P, p) := U(S(c, P), S(c, p))\n-//!   ```\n-//!\n-//!   This special case is handled in `is_useful_specialized`.\n-//!\n-//!   For example, if `P` is:\n-//!\n-//!   ```text\n-//!   [\n-//!       [Some(true), _],\n-//!       [None, 0],\n-//!   ]\n-//!   ```\n-//!\n-//!   and `p` is `[Some(false), 0]`, then we don't care about row 2 since we know `p` only\n-//!   matches values that row 2 doesn't. For row 1 however, we need to dig into the\n-//!   arguments of `Some` to know whether some new value is covered. So we compute\n-//!   `U([[true, _]], [false, 0])`.\n-//!\n-//! - If `p_1 == _`, then we look at the list of constructors that appear in the first component of\n-//!   the rows of `P`:\n-//!     - If there are some constructors that aren't present, then we might think that the\n-//!       wildcard `_` is useful, since it covers those constructors that weren't covered\n-//!       before.\n-//!       That's almost correct, but only works if there were no wildcards in those first\n-//!       components. So we need to check that `p` is useful with respect to the rows that\n-//!       start with a wildcard, if there are any. This is where `D` comes in:\n-//!       `U(P, p) := U(D(P), D(p))`\n-//!\n-//!       For example, if `P` is:\n-//!       ```text\n-//!       [\n-//!           [_, true, _],\n-//!           [None, false, 1],\n-//!       ]\n-//!       ```\n-//!       and `p` is `[_, false, _]`, the `Some` constructor doesn't appear in `P`. So if we\n-//!       only had row 2, we'd know that `p` is useful. However row 1 starts with a\n-//!       wildcard, so we need to check whether `U([[true, _]], [false, 1])`.\n-//!\n-//!     - Otherwise, all possible constructors (for the relevant type) are present. In this\n-//!       case we must check whether the wildcard pattern covers any unmatched value. For\n-//!       that, we can think of the `_` pattern as a big OR-pattern that covers all\n-//!       possible constructors. For `Option`, that would mean `_ = None | Some(_)` for\n-//!       example. The wildcard pattern is useful in this case if it is useful when\n-//!       specialized to one of the possible constructors. So we compute:\n-//!       `U(P, p) := \u2203(k \u03f5 constructors) U(S(k, P), S(k, p))`\n-//!\n-//!       For example, if `P` is:\n-//!       ```text\n-//!       [\n-//!           [Some(true), _],\n-//!           [None, false],\n-//!       ]\n-//!       ```\n-//!       and `p` is `[_, false]`, both `None` and `Some` constructors appear in the first\n-//!       components of `P`. We will therefore try popping both constructors in turn: we\n-//!       compute `U([[true, _]], [_, false])` for the `Some` constructor, and `U([[false]],\n-//!       [false])` for the `None` constructor. The first case returns true, so we know that\n-//!       `p` is useful for `P`. Indeed, it matches `[Some(false), _]` that wasn't matched\n-//!       before.\n-//!\n-//! - If `p_1 == r_1 | r_2`, then the usefulness depends on each `r_i` separately:\n-//!\n-//!   ```text\n-//!   U(P, p) := U(P, (r_1, p_2, .., p_n))\n-//!            || U(P, (r_2, p_2, .., p_n))\n-//!   ```\n-use std::{iter, sync::Arc};\n-\n-use hir_def::{\n-    adt::VariantData,\n-    body::Body,\n-    expr::{Expr, Literal, Pat, PatId},\n-    EnumVariantId, StructId, VariantId,\n-};\n+//! It is modeled on the rustc module `rustc_mir_build::thir::pattern`.\n+\n+mod deconstruct_pat;\n+mod pat_util;\n+pub(crate) mod usefulness;\n+\n+use hir_def::{body::Body, EnumVariantId, LocalFieldId, VariantId};\n use la_arena::Idx;\n-use smallvec::{smallvec, SmallVec};\n-\n-use crate::{db::HirDatabase, AdtId, InferenceResult, Interner, TyExt, TyKind};\n-\n-#[derive(Debug, Clone, Copy)]\n-/// Either a pattern from the source code being analyzed, represented as\n-/// as `PatId`, or a `Wild` pattern which is created as an intermediate\n-/// step in the match checking algorithm and thus is not backed by a\n-/// real `PatId`.\n-///\n-/// Note that it is totally valid for the `PatId` variant to contain\n-/// a `PatId` which resolves to a `Wild` pattern, if that wild pattern\n-/// exists in the source code being analyzed.\n-enum PatIdOrWild {\n-    PatId(PatId),\n-    Wild,\n-}\n \n-impl PatIdOrWild {\n-    fn as_pat(self, cx: &MatchCheckCtx) -> Pat {\n-        match self {\n-            PatIdOrWild::PatId(id) => cx.body.pats[id].clone(),\n-            PatIdOrWild::Wild => Pat::Wild,\n-        }\n-    }\n+use crate::{db::HirDatabase, InferenceResult, Interner, Substitution, Ty, TyKind};\n \n-    fn as_id(self) -> Option<PatId> {\n-        match self {\n-            PatIdOrWild::PatId(id) => Some(id),\n-            PatIdOrWild::Wild => None,\n-        }\n-    }\n-}\n+use self::pat_util::EnumerateAndAdjustIterator;\n \n-impl From<PatId> for PatIdOrWild {\n-    fn from(pat_id: PatId) -> Self {\n-        Self::PatId(pat_id)\n-    }\n-}\n+pub(crate) use self::usefulness::MatchArm;\n \n-impl From<&PatId> for PatIdOrWild {\n-    fn from(pat_id: &PatId) -> Self {\n-        Self::PatId(*pat_id)\n-    }\n-}\n+pub(crate) type PatId = Idx<Pat>;\n \n-#[derive(Debug, Clone, Copy, PartialEq)]\n-pub(super) enum MatchCheckErr {\n-    NotImplemented,\n-    MalformedMatchArm,\n-    /// Used when type inference cannot resolve the type of\n-    /// a pattern or expression.\n-    Unknown,\n+#[derive(Clone, Debug)]\n+pub(crate) enum PatternError {\n+    Unimplemented,\n+    UnresolvedVariant,\n+    MissingField,\n+    ExtraFields,\n }\n \n-/// The return type of `is_useful` is either an indication of usefulness\n-/// of the match arm, or an error in the case the match statement\n-/// is made up of types for which exhaustiveness checking is currently\n-/// not completely implemented.\n-///\n-/// The `std::result::Result` type is used here rather than a custom enum\n-/// to allow the use of `?`.\n-pub(super) type MatchCheckResult<T> = Result<T, MatchCheckErr>;\n+#[derive(Clone, Debug, PartialEq)]\n+pub(crate) struct FieldPat {\n+    pub(crate) field: LocalFieldId,\n+    pub(crate) pattern: Pat,\n+}\n \n-#[derive(Debug)]\n-/// A row in a Matrix.\n-///\n-/// This type is modeled from the struct of the same name in `rustc`.\n-pub(super) struct PatStack(PatStackInner);\n-type PatStackInner = SmallVec<[PatIdOrWild; 2]>;\n+#[derive(Clone, Debug, PartialEq)]\n+pub(crate) struct Pat {\n+    pub(crate) ty: Ty,\n+    pub(crate) kind: Box<PatKind>,\n+}\n \n-impl PatStack {\n-    pub(super) fn from_pattern(pat_id: PatId) -> PatStack {\n-        Self(smallvec!(pat_id.into()))\n+impl Pat {\n+    pub(crate) fn wildcard_from_ty(ty: Ty) -> Self {\n+        Pat { ty, kind: Box::new(PatKind::Wild) }\n     }\n+}\n \n-    pub(super) fn from_wild() -> PatStack {\n-        Self(smallvec!(PatIdOrWild::Wild))\n-    }\n+/// Close relative to `rustc_mir_build::thir::pattern::PatKind`\n+#[derive(Clone, Debug, PartialEq)]\n+pub(crate) enum PatKind {\n+    Wild,\n \n-    fn from_slice(slice: &[PatIdOrWild]) -> PatStack {\n-        Self(SmallVec::from_slice(slice))\n-    }\n+    /// `x`, `ref x`, `x @ P`, etc.\n+    Binding {\n+        subpattern: Option<Pat>,\n+    },\n+\n+    /// `Foo(...)` or `Foo{...}` or `Foo`, where `Foo` is a variant name from an ADT with\n+    /// multiple variants.\n+    Variant {\n+        substs: Substitution,\n+        enum_variant: EnumVariantId,\n+        subpatterns: Vec<FieldPat>,\n+    },\n+\n+    /// `(...)`, `Foo(...)`, `Foo{...}`, or `Foo`, where `Foo` is a variant name from an ADT with\n+    /// a single variant.\n+    Leaf {\n+        subpatterns: Vec<FieldPat>,\n+    },\n+\n+    /// `box P`, `&P`, `&mut P`, etc.\n+    Deref {\n+        subpattern: Pat,\n+    },\n+\n+    // FIXME: for now, only bool literals are implemented\n+    LiteralBool {\n+        value: bool,\n+    },\n+\n+    /// An or-pattern, e.g. `p | q`.\n+    /// Invariant: `pats.len() >= 2`.\n+    Or {\n+        pats: Vec<Pat>,\n+    },\n+}\n \n-    fn from_vec(v: PatStackInner) -> PatStack {\n-        Self(v)\n-    }\n+pub(crate) struct PatCtxt<'a> {\n+    db: &'a dyn HirDatabase,\n+    infer: &'a InferenceResult,\n+    body: &'a Body,\n+    pub(crate) errors: Vec<PatternError>,\n+}\n \n-    fn get_head(&self) -> Option<PatIdOrWild> {\n-        self.0.first().copied()\n+impl<'a> PatCtxt<'a> {\n+    pub(crate) fn new(db: &'a dyn HirDatabase, infer: &'a InferenceResult, body: &'a Body) -> Self {\n+        Self { db, infer, body, errors: Vec::new() }\n     }\n \n-    fn tail(&self) -> &[PatIdOrWild] {\n-        self.0.get(1..).unwrap_or(&[])\n+    pub(crate) fn lower_pattern(&mut self, pat: hir_def::expr::PatId) -> Pat {\n+        // FIXME: implement pattern adjustments (implicit pattern dereference; \"RFC 2005-match-ergonomics\")\n+        // More info https://github.com/rust-lang/rust/issues/42640#issuecomment-313535089\n+        let unadjusted_pat = self.lower_pattern_unadjusted(pat);\n+        unadjusted_pat\n     }\n \n-    fn to_tail(&self) -> PatStack {\n-        Self::from_slice(self.tail())\n-    }\n+    fn lower_pattern_unadjusted(&mut self, pat: hir_def::expr::PatId) -> Pat {\n+        let mut ty = &self.infer[pat];\n+        let variant = self.infer.variant_resolution_for_pat(pat);\n \n-    fn replace_head_with<I, T>(&self, pats: I) -> PatStack\n-    where\n-        I: Iterator<Item = T>,\n-        T: Into<PatIdOrWild>,\n-    {\n-        let mut patterns: PatStackInner = smallvec![];\n-        for pat in pats {\n-            patterns.push(pat.into());\n-        }\n-        for pat in &self.0[1..] {\n-            patterns.push(*pat);\n-        }\n-        PatStack::from_vec(patterns)\n-    }\n+        let kind = match self.body[pat] {\n+            hir_def::expr::Pat::Wild => PatKind::Wild,\n \n-    /// Computes `D(self)`.\n-    ///\n-    /// See the module docs and the associated documentation in rustc for details.\n-    fn specialize_wildcard(&self, cx: &MatchCheckCtx) -> Option<PatStack> {\n-        if matches!(self.get_head()?.as_pat(cx), Pat::Wild) {\n-            Some(self.to_tail())\n-        } else {\n-            None\n-        }\n-    }\n+            hir_def::expr::Pat::Lit(expr) => self.lower_lit(expr),\n \n-    /// Computes `S(constructor, self)`.\n-    ///\n-    /// See the module docs and the associated documentation in rustc for details.\n-    fn specialize_constructor(\n-        &self,\n-        cx: &MatchCheckCtx,\n-        constructor: &Constructor,\n-    ) -> MatchCheckResult<Option<PatStack>> {\n-        let head = match self.get_head() {\n-            Some(head) => head,\n-            None => return Ok(None),\n-        };\n+            hir_def::expr::Pat::Path(ref path) => {\n+                return self.lower_path(pat, path);\n+            }\n \n-        let head_pat = head.as_pat(cx);\n-        let result = match (head_pat, constructor) {\n-            (Pat::Tuple { args: pat_ids, ellipsis }, &Constructor::Tuple { arity }) => {\n-                if let Some(ellipsis) = ellipsis {\n-                    let (pre, post) = pat_ids.split_at(ellipsis);\n-                    let n_wild_pats = arity.saturating_sub(pat_ids.len());\n-                    let pre_iter = pre.iter().map(Into::into);\n-                    let wildcards = iter::repeat(PatIdOrWild::Wild).take(n_wild_pats);\n-                    let post_iter = post.iter().map(Into::into);\n-                    Some(self.replace_head_with(pre_iter.chain(wildcards).chain(post_iter)))\n-                } else {\n-                    Some(self.replace_head_with(pat_ids.iter()))\n-                }\n+            hir_def::expr::Pat::Tuple { ref args, ellipsis } => {\n+                let arity = match *ty.kind(&Interner) {\n+                    TyKind::Tuple(arity, _) => arity,\n+                    _ => panic!(\"unexpected type for tuple pattern: {:?}\", ty),\n+                };\n+                let subpatterns = self.lower_tuple_subpats(args, arity, ellipsis);\n+                PatKind::Leaf { subpatterns }\n             }\n-            (Pat::Lit(lit_expr), Constructor::Bool(constructor_val)) => {\n-                match cx.body.exprs[lit_expr] {\n-                    Expr::Literal(Literal::Bool(pat_val)) if *constructor_val == pat_val => {\n-                        Some(self.to_tail())\n-                    }\n-                    // it was a bool but the value doesn't match\n-                    Expr::Literal(Literal::Bool(_)) => None,\n-                    // perhaps this is actually unreachable given we have\n-                    // already checked that these match arms have the appropriate type?\n-                    _ => return Err(MatchCheckErr::NotImplemented),\n+\n+            hir_def::expr::Pat::Bind { subpat, .. } => {\n+                if let TyKind::Ref(.., rty) = ty.kind(&Interner) {\n+                    ty = rty;\n                 }\n+                PatKind::Binding { subpattern: self.lower_opt_pattern(subpat) }\n             }\n-            (Pat::Wild, constructor) => Some(self.expand_wildcard(cx, constructor)?),\n-            (Pat::Path(_), constructor) => {\n-                // unit enum variants become `Pat::Path`\n-                let pat_id = head.as_id().expect(\"we know this isn't a wild\");\n-                let variant_id: VariantId = match constructor {\n-                    &Constructor::Enum(e) => e.into(),\n-                    &Constructor::Struct(s) => s.into(),\n-                    _ => return Err(MatchCheckErr::NotImplemented),\n-                };\n-                if Some(variant_id) != cx.infer.variant_resolution_for_pat(pat_id) {\n-                    None\n-                } else {\n-                    Some(self.to_tail())\n-                }\n+\n+            hir_def::expr::Pat::TupleStruct { ref args, ellipsis, .. } if variant.is_some() => {\n+                let expected_len = variant.unwrap().variant_data(self.db.upcast()).fields().len();\n+                let subpatterns = self.lower_tuple_subpats(args, expected_len, ellipsis);\n+                self.lower_variant_or_leaf(pat, ty, subpatterns)\n             }\n-            (Pat::TupleStruct { args: ref pat_ids, ellipsis, .. }, constructor) => {\n-                let pat_id = head.as_id().expect(\"we know this isn't a wild\");\n-                let variant_id: VariantId = match constructor {\n-                    &Constructor::Enum(e) => e.into(),\n-                    &Constructor::Struct(s) => s.into(),\n-                    _ => return Err(MatchCheckErr::MalformedMatchArm),\n-                };\n-                if Some(variant_id) != cx.infer.variant_resolution_for_pat(pat_id) {\n-                    None\n-                } else {\n-                    let constructor_arity = constructor.arity(cx)?;\n-                    if let Some(ellipsis_position) = ellipsis {\n-                        // If there are ellipsis in the pattern, the ellipsis must take the place\n-                        // of at least one sub-pattern, so `pat_ids` should be smaller than the\n-                        // constructor arity.\n-                        if pat_ids.len() < constructor_arity {\n-                            let mut new_patterns: Vec<PatIdOrWild> = vec![];\n-\n-                            for pat_id in &pat_ids[0..ellipsis_position] {\n-                                new_patterns.push((*pat_id).into());\n-                            }\n-\n-                            for _ in 0..(constructor_arity - pat_ids.len()) {\n-                                new_patterns.push(PatIdOrWild::Wild);\n-                            }\n-\n-                            for pat_id in &pat_ids[ellipsis_position..pat_ids.len()] {\n-                                new_patterns.push((*pat_id).into());\n-                            }\n-\n-                            Some(self.replace_head_with(new_patterns.into_iter()))\n-                        } else {\n-                            return Err(MatchCheckErr::MalformedMatchArm);\n-                        }\n-                    } else {\n-                        // If there is no ellipsis in the tuple pattern, the number\n-                        // of patterns must equal the constructor arity.\n-                        if pat_ids.len() == constructor_arity {\n-                            Some(self.replace_head_with(pat_ids.into_iter()))\n-                        } else {\n-                            return Err(MatchCheckErr::MalformedMatchArm);\n-                        }\n+\n+            hir_def::expr::Pat::Record { ref args, .. } if variant.is_some() => {\n+                let variant_data = variant.unwrap().variant_data(self.db.upcast());\n+                let subpatterns = args\n+                    .iter()\n+                    .map(|field| {\n+                        // XXX(iDawer): field lookup is inefficient\n+                        variant_data.field(&field.name).map(|lfield_id| FieldPat {\n+                            field: lfield_id,\n+                            pattern: self.lower_pattern(field.pat),\n+                        })\n+                    })\n+                    .collect();\n+                match subpatterns {\n+                    Some(subpatterns) => self.lower_variant_or_leaf(pat, ty, subpatterns),\n+                    None => {\n+                        self.errors.push(PatternError::MissingField);\n+                        PatKind::Wild\n                     }\n                 }\n             }\n-            (Pat::Record { args: ref arg_patterns, .. }, constructor) => {\n-                let pat_id = head.as_id().expect(\"we know this isn't a wild\");\n-                let (variant_id, variant_data) = match constructor {\n-                    &Constructor::Enum(e) => (\n-                        e.into(),\n-                        cx.db.enum_data(e.parent).variants[e.local_id].variant_data.clone(),\n-                    ),\n-                    &Constructor::Struct(s) => {\n-                        (s.into(), cx.db.struct_data(s).variant_data.clone())\n-                    }\n-                    _ => return Err(MatchCheckErr::MalformedMatchArm),\n-                };\n-                if Some(variant_id) != cx.infer.variant_resolution_for_pat(pat_id) {\n-                    None\n-                } else {\n-                    match variant_data.as_ref() {\n-                        VariantData::Record(struct_field_arena) => {\n-                            // Here we treat any missing fields in the record as the wild pattern, as\n-                            // if the record has ellipsis. We want to do this here even if the\n-                            // record does not contain ellipsis, because it allows us to continue\n-                            // enforcing exhaustiveness for the rest of the match statement.\n-                            //\n-                            // Creating the diagnostic for the missing field in the pattern\n-                            // should be done in a different diagnostic.\n-                            let patterns = struct_field_arena.iter().map(|(_, struct_field)| {\n-                                arg_patterns\n-                                    .iter()\n-                                    .find(|pat| pat.name == struct_field.name)\n-                                    .map(|pat| PatIdOrWild::from(pat.pat))\n-                                    .unwrap_or(PatIdOrWild::Wild)\n-                            });\n-\n-                            Some(self.replace_head_with(patterns))\n-                        }\n-                        _ => return Err(MatchCheckErr::Unknown),\n-                    }\n-                }\n+            hir_def::expr::Pat::TupleStruct { .. } | hir_def::expr::Pat::Record { .. } => {\n+                self.errors.push(PatternError::UnresolvedVariant);\n+                PatKind::Wild\n             }\n-            (Pat::Or(_), _) => return Err(MatchCheckErr::NotImplemented),\n-            (_, _) => return Err(MatchCheckErr::NotImplemented),\n-        };\n \n-        Ok(result)\n-    }\n-\n-    /// A special case of `specialize_constructor` where the head of the pattern stack\n-    /// is a Wild pattern.\n-    ///\n-    /// Replaces the Wild pattern at the head of the pattern stack with N Wild patterns\n-    /// (N >= 0), where N is the arity of the given constructor.\n-    fn expand_wildcard(\n-        &self,\n-        cx: &MatchCheckCtx,\n-        constructor: &Constructor,\n-    ) -> MatchCheckResult<PatStack> {\n-        assert_eq!(\n-            Pat::Wild,\n-            self.get_head().expect(\"expand_wildcard called on empty PatStack\").as_pat(cx),\n-            \"expand_wildcard must only be called on PatStack with wild at head\",\n-        );\n+            hir_def::expr::Pat::Or(ref pats) => PatKind::Or { pats: self.lower_patterns(pats) },\n \n-        let mut patterns: PatStackInner = smallvec![];\n+            _ => {\n+                self.errors.push(PatternError::Unimplemented);\n+                PatKind::Wild\n+            }\n+        };\n \n-        for _ in 0..constructor.arity(cx)? {\n-            patterns.push(PatIdOrWild::Wild);\n-        }\n+        Pat { ty: ty.clone(), kind: Box::new(kind) }\n+    }\n \n-        for pat in &self.0[1..] {\n-            patterns.push(*pat);\n+    fn lower_tuple_subpats(\n+        &mut self,\n+        pats: &[hir_def::expr::PatId],\n+        expected_len: usize,\n+        ellipsis: Option<usize>,\n+    ) -> Vec<FieldPat> {\n+        if pats.len() > expected_len {\n+            self.errors.push(PatternError::ExtraFields);\n+            return Vec::new();\n         }\n \n-        Ok(PatStack::from_vec(patterns))\n+        pats.iter()\n+            .enumerate_and_adjust(expected_len, ellipsis)\n+            .map(|(i, &subpattern)| FieldPat {\n+                field: LocalFieldId::from_raw((i as u32).into()),\n+                pattern: self.lower_pattern(subpattern),\n+            })\n+            .collect()\n     }\n-}\n \n-/// A collection of PatStack.\n-///\n-/// This type is modeled from the struct of the same name in `rustc`.\n-pub(super) struct Matrix(Vec<PatStack>);\n+    fn lower_patterns(&mut self, pats: &[hir_def::expr::PatId]) -> Vec<Pat> {\n+        pats.iter().map(|&p| self.lower_pattern(p)).collect()\n+    }\n \n-impl Matrix {\n-    pub(super) fn empty() -> Self {\n-        Self(vec![])\n+    fn lower_opt_pattern(&mut self, pat: Option<hir_def::expr::PatId>) -> Option<Pat> {\n+        pat.map(|p| self.lower_pattern(p))\n     }\n \n-    pub(super) fn push(&mut self, cx: &MatchCheckCtx, row: PatStack) {\n-        if let Some(Pat::Or(pat_ids)) = row.get_head().map(|pat_id| pat_id.as_pat(cx)) {\n-            // Or patterns are expanded here\n-            for pat_id in pat_ids {\n-                self.0.push(row.replace_head_with([pat_id].iter()));\n+    fn lower_variant_or_leaf(\n+        &mut self,\n+        pat: hir_def::expr::PatId,\n+        ty: &Ty,\n+        subpatterns: Vec<FieldPat>,\n+    ) -> PatKind {\n+        let kind = match self.infer.variant_resolution_for_pat(pat) {\n+            Some(variant_id) => {\n+                if let VariantId::EnumVariantId(enum_variant) = variant_id {\n+                    let substs = match ty.kind(&Interner) {\n+                        TyKind::Adt(_, substs) | TyKind::FnDef(_, substs) => substs.clone(),\n+                        TyKind::Error => {\n+                            return PatKind::Wild;\n+                        }\n+                        _ => panic!(\"inappropriate type for def: {:?}\", ty),\n+                    };\n+                    PatKind::Variant { substs, enum_variant, subpatterns }\n+                } else {\n+                    PatKind::Leaf { subpatterns }\n+                }\n             }\n-        } else {\n-            self.0.push(row);\n-        }\n+            None => {\n+                self.errors.push(PatternError::UnresolvedVariant);\n+                PatKind::Wild\n+            }\n+        };\n+        kind\n     }\n \n-    fn is_empty(&self) -> bool {\n-        self.0.is_empty()\n-    }\n+    fn lower_path(&mut self, pat: hir_def::expr::PatId, _path: &hir_def::path::Path) -> Pat {\n+        let ty = &self.infer[pat];\n \n-    fn heads(&self) -> Vec<PatIdOrWild> {\n-        self.0.iter().flat_map(|p| p.get_head()).collect()\n-    }\n+        let pat_from_kind = |kind| Pat { ty: ty.clone(), kind: Box::new(kind) };\n \n-    /// Computes `D(self)` for each contained PatStack.\n-    ///\n-    /// See the module docs and the associated documentation in rustc for details.\n-    fn specialize_wildcard(&self, cx: &MatchCheckCtx) -> Self {\n-        Self::collect(cx, self.0.iter().filter_map(|r| r.specialize_wildcard(cx)))\n+        match self.infer.variant_resolution_for_pat(pat) {\n+            Some(_) => pat_from_kind(self.lower_variant_or_leaf(pat, ty, Vec::new())),\n+            None => {\n+                self.errors.push(PatternError::UnresolvedVariant);\n+                pat_from_kind(PatKind::Wild)\n+            }\n+        }\n     }\n \n-    /// Computes `S(constructor, self)` for each contained PatStack.\n-    ///\n-    /// See the module docs and the associated documentation in rustc for details.\n-    fn specialize_constructor(\n-        &self,\n-        cx: &MatchCheckCtx,\n-        constructor: &Constructor,\n-    ) -> MatchCheckResult<Self> {\n-        let mut new_matrix = Matrix::empty();\n-        for pat in &self.0 {\n-            if let Some(pat) = pat.specialize_constructor(cx, constructor)? {\n-                new_matrix.push(cx, pat);\n+    fn lower_lit(&mut self, expr: hir_def::expr::ExprId) -> PatKind {\n+        use hir_def::expr::{Expr, Literal::Bool};\n+\n+        match self.body[expr] {\n+            Expr::Literal(Bool(value)) => PatKind::LiteralBool { value },\n+            _ => {\n+                self.errors.push(PatternError::Unimplemented);\n+                PatKind::Wild\n             }\n         }\n+    }\n+}\n \n-        Ok(new_matrix)\n+pub(crate) trait PatternFoldable: Sized {\n+    fn fold_with<F: PatternFolder>(&self, folder: &mut F) -> Self {\n+        self.super_fold_with(folder)\n     }\n \n-    fn collect<T: IntoIterator<Item = PatStack>>(cx: &MatchCheckCtx, iter: T) -> Self {\n-        let mut matrix = Matrix::empty();\n+    fn super_fold_with<F: PatternFolder>(&self, folder: &mut F) -> Self;\n+}\n \n-        for pat in iter {\n-            // using push ensures we expand or-patterns\n-            matrix.push(cx, pat);\n-        }\n+pub(crate) trait PatternFolder: Sized {\n+    fn fold_pattern(&mut self, pattern: &Pat) -> Pat {\n+        pattern.super_fold_with(self)\n+    }\n \n-        matrix\n+    fn fold_pattern_kind(&mut self, kind: &PatKind) -> PatKind {\n+        kind.super_fold_with(self)\n     }\n }\n \n-#[derive(Clone, Debug, PartialEq)]\n-/// An indication of the usefulness of a given match arm, where\n-/// usefulness is defined as matching some patterns which were\n-/// not matched by an prior match arms.\n-///\n-/// We may eventually need an `Unknown` variant here.\n-pub(super) enum Usefulness {\n-    Useful,\n-    NotUseful,\n+impl<T: PatternFoldable> PatternFoldable for Box<T> {\n+    fn super_fold_with<F: PatternFolder>(&self, folder: &mut F) -> Self {\n+        let content: T = (**self).fold_with(folder);\n+        Box::new(content)\n+    }\n }\n \n-pub(super) struct MatchCheckCtx<'a> {\n-    pub(super) match_expr: Idx<Expr>,\n-    pub(super) body: Arc<Body>,\n-    pub(super) infer: Arc<InferenceResult>,\n-    pub(super) db: &'a dyn HirDatabase,\n+impl<T: PatternFoldable> PatternFoldable for Vec<T> {\n+    fn super_fold_with<F: PatternFolder>(&self, folder: &mut F) -> Self {\n+        self.iter().map(|t| t.fold_with(folder)).collect()\n+    }\n }\n \n-/// Given a set of patterns `matrix`, and pattern to consider `v`, determines\n-/// whether `v` is useful. A pattern is useful if it covers cases which were\n-/// not previously covered.\n-///\n-/// When calling this function externally (that is, not the recursive calls) it\n-/// expected that you have already type checked the match arms. All patterns in\n-/// matrix should be the same type as v, as well as they should all be the same\n-/// type as the match expression.\n-pub(super) fn is_useful(\n-    cx: &MatchCheckCtx,\n-    matrix: &Matrix,\n-    v: &PatStack,\n-) -> MatchCheckResult<Usefulness> {\n-    // Handle two special cases:\n-    // - enum with no variants\n-    // - `!` type\n-    // In those cases, no match arm is useful.\n-    match cx.infer[cx.match_expr].strip_references().kind(&Interner) {\n-        TyKind::Adt(AdtId(hir_def::AdtId::EnumId(enum_id)), ..) => {\n-            if cx.db.enum_data(*enum_id).variants.is_empty() {\n-                return Ok(Usefulness::NotUseful);\n-            }\n-        }\n-        TyKind::Never => return Ok(Usefulness::NotUseful),\n-        _ => (),\n+impl<T: PatternFoldable> PatternFoldable for Option<T> {\n+    fn super_fold_with<F: PatternFolder>(&self, folder: &mut F) -> Self {\n+        self.as_ref().map(|t| t.fold_with(folder))\n     }\n+}\n \n-    let head = match v.get_head() {\n-        Some(head) => head,\n-        None => {\n-            let result = if matrix.is_empty() { Usefulness::Useful } else { Usefulness::NotUseful };\n-\n-            return Ok(result);\n-        }\n-    };\n-\n-    if let Pat::Or(pat_ids) = head.as_pat(cx) {\n-        let mut found_unimplemented = false;\n-        let any_useful = pat_ids.iter().any(|&pat_id| {\n-            let v = PatStack::from_pattern(pat_id);\n-\n-            match is_useful(cx, matrix, &v) {\n-                Ok(Usefulness::Useful) => true,\n-                Ok(Usefulness::NotUseful) => false,\n-                _ => {\n-                    found_unimplemented = true;\n-                    false\n+macro_rules! clone_impls {\n+    ($($ty:ty),+) => {\n+        $(\n+            impl PatternFoldable for $ty {\n+                fn super_fold_with<F: PatternFolder>(&self, _: &mut F) -> Self {\n+                    Clone::clone(self)\n                 }\n             }\n-        });\n-\n-        return if any_useful {\n-            Ok(Usefulness::Useful)\n-        } else if found_unimplemented {\n-            Err(MatchCheckErr::NotImplemented)\n-        } else {\n-            Ok(Usefulness::NotUseful)\n-        };\n+        )+\n     }\n+}\n \n-    if let Some(constructor) = pat_constructor(cx, head)? {\n-        let matrix = matrix.specialize_constructor(&cx, &constructor)?;\n-        let v = v\n-            .specialize_constructor(&cx, &constructor)?\n-            .expect(\"we know this can't fail because we get the constructor from `v.head()` above\");\n-\n-        is_useful(&cx, &matrix, &v)\n-    } else {\n-        // expanding wildcard\n-        let mut used_constructors: Vec<Constructor> = vec![];\n-        for pat in matrix.heads() {\n-            if let Some(constructor) = pat_constructor(cx, pat)? {\n-                used_constructors.push(constructor);\n-            }\n-        }\n-\n-        // We assume here that the first constructor is the \"correct\" type. Since we\n-        // only care about the \"type\" of the constructor (i.e. if it is a bool we\n-        // don't care about the value), this assumption should be valid as long as\n-        // the match statement is well formed. We currently uphold this invariant by\n-        // filtering match arms before calling `is_useful`, only passing in match arms\n-        // whose type matches the type of the match expression.\n-        match &used_constructors.first() {\n-            Some(constructor) if all_constructors_covered(&cx, constructor, &used_constructors) => {\n-                // If all constructors are covered, then we need to consider whether\n-                // any values are covered by this wildcard.\n-                //\n-                // For example, with matrix '[[Some(true)], [None]]', all\n-                // constructors are covered (`Some`/`None`), so we need\n-                // to perform specialization to see that our wildcard will cover\n-                // the `Some(false)` case.\n-                //\n-                // Here we create a constructor for each variant and then check\n-                // usefulness after specializing for that constructor.\n-                let mut found_unimplemented = false;\n-                for constructor in constructor.all_constructors(cx) {\n-                    let matrix = matrix.specialize_constructor(&cx, &constructor)?;\n-                    let v = v.expand_wildcard(&cx, &constructor)?;\n-\n-                    match is_useful(&cx, &matrix, &v) {\n-                        Ok(Usefulness::Useful) => return Ok(Usefulness::Useful),\n-                        Ok(Usefulness::NotUseful) => continue,\n-                        _ => found_unimplemented = true,\n-                    };\n-                }\n+clone_impls! { LocalFieldId, Ty, Substitution, EnumVariantId }\n \n-                if found_unimplemented {\n-                    Err(MatchCheckErr::NotImplemented)\n-                } else {\n-                    Ok(Usefulness::NotUseful)\n-                }\n-            }\n-            _ => {\n-                // Either not all constructors are covered, or the only other arms\n-                // are wildcards. Either way, this pattern is useful if it is useful\n-                // when compared to those arms with wildcards.\n-                let matrix = matrix.specialize_wildcard(&cx);\n-                let v = v.to_tail();\n-\n-                is_useful(&cx, &matrix, &v)\n-            }\n-        }\n+impl PatternFoldable for FieldPat {\n+    fn super_fold_with<F: PatternFolder>(&self, folder: &mut F) -> Self {\n+        FieldPat { field: self.field.fold_with(folder), pattern: self.pattern.fold_with(folder) }\n     }\n }\n \n-#[derive(Debug, Clone, Copy)]\n-/// Similar to TypeCtor, but includes additional information about the specific\n-/// value being instantiated. For example, TypeCtor::Bool doesn't contain the\n-/// boolean value.\n-enum Constructor {\n-    Bool(bool),\n-    Tuple { arity: usize },\n-    Enum(EnumVariantId),\n-    Struct(StructId),\n-}\n+impl PatternFoldable for Pat {\n+    fn fold_with<F: PatternFolder>(&self, folder: &mut F) -> Self {\n+        folder.fold_pattern(self)\n+    }\n \n-impl Constructor {\n-    fn arity(&self, cx: &MatchCheckCtx) -> MatchCheckResult<usize> {\n-        let arity = match self {\n-            Constructor::Bool(_) => 0,\n-            Constructor::Tuple { arity } => *arity,\n-            Constructor::Enum(e) => {\n-                match cx.db.enum_data(e.parent).variants[e.local_id].variant_data.as_ref() {\n-                    VariantData::Tuple(struct_field_data) => struct_field_data.len(),\n-                    VariantData::Record(struct_field_data) => struct_field_data.len(),\n-                    VariantData::Unit => 0,\n-                }\n-            }\n-            &Constructor::Struct(s) => match cx.db.struct_data(s).variant_data.as_ref() {\n-                VariantData::Tuple(struct_field_data) => struct_field_data.len(),\n-                VariantData::Record(struct_field_data) => struct_field_data.len(),\n-                VariantData::Unit => 0,\n-            },\n-        };\n+    fn super_fold_with<F: PatternFolder>(&self, folder: &mut F) -> Self {\n+        Pat { ty: self.ty.fold_with(folder), kind: self.kind.fold_with(folder) }\n+    }\n+}\n \n-        Ok(arity)\n+impl PatternFoldable for PatKind {\n+    fn fold_with<F: PatternFolder>(&self, folder: &mut F) -> Self {\n+        folder.fold_pattern_kind(self)\n     }\n \n-    fn all_constructors(&self, cx: &MatchCheckCtx) -> Vec<Constructor> {\n+    fn super_fold_with<F: PatternFolder>(&self, folder: &mut F) -> Self {\n         match self {\n-            Constructor::Bool(_) => vec![Constructor::Bool(true), Constructor::Bool(false)],\n-            Constructor::Tuple { .. } | Constructor::Struct(_) => vec![*self],\n-            Constructor::Enum(e) => cx\n-                .db\n-                .enum_data(e.parent)\n-                .variants\n-                .iter()\n-                .map(|(local_id, _)| {\n-                    Constructor::Enum(EnumVariantId { parent: e.parent, local_id })\n-                })\n-                .collect(),\n+            PatKind::Wild => PatKind::Wild,\n+            PatKind::Binding { subpattern } => {\n+                PatKind::Binding { subpattern: subpattern.fold_with(folder) }\n+            }\n+            PatKind::Variant { substs, enum_variant, subpatterns } => PatKind::Variant {\n+                substs: substs.fold_with(folder),\n+                enum_variant: enum_variant.fold_with(folder),\n+                subpatterns: subpatterns.fold_with(folder),\n+            },\n+            PatKind::Leaf { subpatterns } => {\n+                PatKind::Leaf { subpatterns: subpatterns.fold_with(folder) }\n+            }\n+            PatKind::Deref { subpattern } => {\n+                PatKind::Deref { subpattern: subpattern.fold_with(folder) }\n+            }\n+            &PatKind::LiteralBool { value } => PatKind::LiteralBool { value },\n+            PatKind::Or { pats } => PatKind::Or { pats: pats.fold_with(folder) },\n         }\n     }\n }\n \n-/// Returns the constructor for the given pattern. Should only return None\n-/// in the case of a Wild pattern.\n-fn pat_constructor(cx: &MatchCheckCtx, pat: PatIdOrWild) -> MatchCheckResult<Option<Constructor>> {\n-    let res = match pat.as_pat(cx) {\n-        Pat::Wild => None,\n-        Pat::Tuple { .. } => {\n-            let pat_id = pat.as_id().expect(\"we already know this pattern is not a wild\");\n-            Some(Constructor::Tuple {\n-                arity: cx.infer.type_of_pat[pat_id]\n-                    .as_tuple()\n-                    .ok_or(MatchCheckErr::Unknown)?\n-                    .len(&Interner),\n-            })\n-        }\n-        Pat::Lit(lit_expr) => match cx.body.exprs[lit_expr] {\n-            Expr::Literal(Literal::Bool(val)) => Some(Constructor::Bool(val)),\n-            _ => return Err(MatchCheckErr::NotImplemented),\n-        },\n-        Pat::TupleStruct { .. } | Pat::Path(_) | Pat::Record { .. } => {\n-            let pat_id = pat.as_id().expect(\"we already know this pattern is not a wild\");\n-            let variant_id =\n-                cx.infer.variant_resolution_for_pat(pat_id).ok_or(MatchCheckErr::Unknown)?;\n-            match variant_id {\n-                VariantId::EnumVariantId(enum_variant_id) => {\n-                    Some(Constructor::Enum(enum_variant_id))\n-                }\n-                VariantId::StructId(struct_id) => Some(Constructor::Struct(struct_id)),\n-                _ => return Err(MatchCheckErr::NotImplemented),\n-            }\n-        }\n-        _ => return Err(MatchCheckErr::NotImplemented),\n-    };\n+#[cfg(test)]\n+pub(super) mod tests {\n+    mod report {\n+        use std::any::Any;\n \n-    Ok(res)\n-}\n+        use hir_def::{expr::PatId, DefWithBodyId};\n+        use hir_expand::{HirFileId, InFile};\n+        use syntax::SyntaxNodePtr;\n \n-fn all_constructors_covered(\n-    cx: &MatchCheckCtx,\n-    constructor: &Constructor,\n-    used_constructors: &[Constructor],\n-) -> bool {\n-    match constructor {\n-        Constructor::Tuple { arity } => {\n-            used_constructors.iter().any(|constructor| match constructor {\n-                Constructor::Tuple { arity: used_arity } => arity == used_arity,\n-                _ => false,\n-            })\n-        }\n-        Constructor::Bool(_) => {\n-            if used_constructors.is_empty() {\n-                return false;\n-            }\n+        use crate::{\n+            db::HirDatabase,\n+            diagnostics_sink::{Diagnostic, DiagnosticCode, DiagnosticSink},\n+        };\n \n-            let covers_true =\n-                used_constructors.iter().any(|c| matches!(c, Constructor::Bool(true)));\n-            let covers_false =\n-                used_constructors.iter().any(|c| matches!(c, Constructor::Bool(false)));\n+        /// In tests, match check bails out loudly.\n+        /// This helps to catch incorrect tests that pass due to false negatives.\n+        pub(crate) fn report_bail_out(\n+            db: &dyn HirDatabase,\n+            def: DefWithBodyId,\n+            pat: PatId,\n+            sink: &mut DiagnosticSink,\n+        ) {\n+            let (_, source_map) = db.body_with_source_map(def);\n+            if let Ok(source_ptr) = source_map.pat_syntax(pat) {\n+                let pat_syntax_ptr = source_ptr.value.either(Into::into, Into::into);\n+                sink.push(BailedOut { file: source_ptr.file_id, pat_syntax_ptr });\n+            }\n+        }\n \n-            covers_true && covers_false\n+        #[derive(Debug)]\n+        struct BailedOut {\n+            file: HirFileId,\n+            pat_syntax_ptr: SyntaxNodePtr,\n         }\n-        Constructor::Enum(e) => cx.db.enum_data(e.parent).variants.iter().all(|(id, _)| {\n-            for constructor in used_constructors {\n-                if let Constructor::Enum(e) = constructor {\n-                    if id == e.local_id {\n-                        return true;\n-                    }\n-                }\n-            }\n \n-            false\n-        }),\n-        &Constructor::Struct(s) => used_constructors.iter().any(|constructor| match constructor {\n-            &Constructor::Struct(sid) => sid == s,\n-            _ => false,\n-        }),\n+        impl Diagnostic for BailedOut {\n+            fn code(&self) -> DiagnosticCode {\n+                DiagnosticCode(\"internal:match-check-bailed-out\")\n+            }\n+            fn message(&self) -> String {\n+                format!(\"Internal: match check bailed out\")\n+            }\n+            fn display_source(&self) -> InFile<SyntaxNodePtr> {\n+                InFile { file_id: self.file, value: self.pat_syntax_ptr.clone() }\n+            }\n+            fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+                self\n+            }\n+        }\n     }\n-}\n \n-#[cfg(test)]\n-mod tests {\n     use crate::diagnostics::tests::check_diagnostics;\n \n+    pub(crate) use self::report::report_bail_out;\n+\n     #[test]\n     fn empty_tuple() {\n         check_diagnostics(\n@@ -1113,14 +658,18 @@ enum Either2 { C, D }\n fn main() {\n     match Either::A {\n         Either2::C => (),\n+    //  ^^^^^^^^^^ Internal: match check bailed out\n         Either2::D => (),\n     }\n     match (true, false) {\n         (true, false, true) => (),\n+    //  ^^^^^^^^^^^^^^^^^^^ Internal: match check bailed out\n         (true) => (),\n     }\n     match (true, false) { (true,) => {} }\n+    //                    ^^^^^^^ Internal: match check bailed out\n     match (0) { () => () }\n+            //  ^^ Internal: match check bailed out\n     match Unresolved::Bar { Unresolved::Baz => () }\n }\n         \"#,\n@@ -1133,7 +682,9 @@ fn main() {\n             r#\"\n fn main() {\n     match false { true | () => {} }\n+    //            ^^^^^^^^^ Internal: match check bailed out\n     match (false,) { (true | (),) => {} }\n+    //               ^^^^^^^^^^^^ Internal: match check bailed out\n }\n \"#,\n         );\n@@ -1157,6 +708,25 @@ fn main() {\n         );\n     }\n \n+    #[test]\n+    fn malformed_match_arm_extra_fields() {\n+        check_diagnostics(\n+            r#\"\n+enum A { B(isize, isize), C }\n+fn main() {\n+    match A::B(1, 2) {\n+        A::B(_, _, _) => (),\n+    //  ^^^^^^^^^^^^^ Internal: match check bailed out\n+    }\n+    match A::B(1, 2) {\n+        A::C(_) => (),\n+    //  ^^^^^^^ Internal: match check bailed out\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn expr_diverges() {\n         check_diagnostics(\n@@ -1166,10 +736,12 @@ enum Either { A, B }\n fn main() {\n     match loop {} {\n         Either::A => (),\n+    //  ^^^^^^^^^ Internal: match check bailed out\n         Either::B => (),\n     }\n     match loop {} {\n         Either::A => (),\n+    //  ^^^^^^^^^ Internal: match check bailed out\n     }\n     match loop { break Foo::A } {\n         //^^^^^^^^^^^^^^^^^^^^^ Missing match arm\n@@ -1357,6 +929,7 @@ fn enum_(never: Never) {\n }\n fn enum_ref(never: &Never) {\n     match never {}\n+        //^^^^^ Missing match arm\n }\n fn bang(never: !) {\n     match never {}\n@@ -1376,6 +949,11 @@ fn main() {\n     match Option::<Never>::None {\n         None => (),\n         Some(never) => match never {},\n+    //  ^^^^^^^^^^^ Internal: match check bailed out\n+    }\n+    match Option::<Never>::None {\n+        //^^^^^^^^^^^^^^^^^^^^^ Missing match arm\n+        Option::Some(_never) => {},\n     }\n }\n \"#,\n@@ -1513,6 +1091,151 @@ fn main() {\n \"#,\n         );\n     }\n+\n+    #[test]\n+    fn no_panic_at_unimplemented_subpattern_type() {\n+        check_diagnostics(\n+            r#\"\n+struct S { a: char}\n+fn main(v: S) {\n+    match v { S{ a }      => {} }\n+    match v { S{ a: _x }  => {} }\n+    match v { S{ a: 'a' } => {} }\n+            //^^^^^^^^^^^ Internal: match check bailed out\n+    match v { S{..}       => {} }\n+    match v { _           => {} }\n+    match v { }\n+        //^ Missing match arm\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn binding() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    match true {\n+        _x @ true => {}\n+        false     => {}\n+    }\n+    match true { _x @ true => {} }\n+        //^^^^ Missing match arm\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn binding_ref_has_correct_type() {\n+        // Asserts `PatKind::Binding(ref _x): bool`, not &bool.\n+        // If that's not true match checking will panic with \"incompatible constructors\"\n+        // FIXME: make facilities to test this directly like `tests::check_infer(..)`\n+        check_diagnostics(\n+            r#\"\n+enum Foo { A }\n+fn main() {\n+    // FIXME: this should not bail out but current behavior is such as the old algorithm.\n+    // ExprValidator::validate_match(..) checks types of top level patterns incorrecly.\n+    match Foo::A {\n+        ref _x => {}\n+    //  ^^^^^^ Internal: match check bailed out\n+        Foo::A => {}\n+    }\n+    match (true,) {\n+        (ref _x,) => {}\n+        (true,) => {}\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn enum_non_exhaustive() {\n+        check_diagnostics(\n+            r#\"\n+//- /lib.rs crate:lib\n+#[non_exhaustive]\n+pub enum E { A, B }\n+fn _local() {\n+    match E::A { _ => {} }\n+    match E::A {\n+        E::A => {}\n+        E::B => {}\n+    }\n+    match E::A {\n+        E::A | E::B => {}\n+    }\n+}\n+\n+//- /main.rs crate:main deps:lib\n+use lib::E;\n+fn main() {\n+    match E::A { _ => {} }\n+    match E::A {\n+        //^^^^ Missing match arm\n+        E::A => {}\n+        E::B => {}\n+    }\n+    match E::A {\n+        //^^^^ Missing match arm\n+        E::A | E::B => {}\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn match_guard() {\n+        check_diagnostics(\n+            r#\"\n+fn main() {\n+    match true {\n+        true if false => {}\n+        true          => {}\n+        false         => {}\n+    }\n+    match true {\n+        //^^^^ Missing match arm\n+        true if false => {}\n+        false         => {}\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn pattern_type_is_of_substitution() {\n+        cov_mark::check!(match_check_wildcard_expanded_to_substitutions);\n+        check_diagnostics(\n+            r#\"\n+struct Foo<T>(T);\n+struct Bar;\n+fn main() {\n+    match Foo(Bar) {\n+        _ | Foo(Bar) => {}\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn record_struct_no_such_field() {\n+        check_diagnostics(\n+            r#\"\n+struct Foo { }\n+fn main(f: Foo) {\n+    match f { Foo { bar } => () }\n+    //        ^^^^^^^^^^^ Internal: match check bailed out\n+}\n+\"#,\n+        );\n+    }\n+\n     mod false_negatives {\n         //! The implementation of match checking here is a work in progress. As we roll this out, we\n         //! prefer false negatives to false positives (ideally there would be no false positives). This\n@@ -1533,11 +1256,44 @@ fn main() {\n fn main() {\n     match 5 {\n         10 => (),\n+    //  ^^ Internal: match check bailed out\n         11..20 => (),\n     }\n }\n \"#,\n             );\n         }\n+\n+        #[test]\n+        fn reference_patterns_at_top_level() {\n+            check_diagnostics(\n+                r#\"\n+fn main() {\n+    match &false {\n+        &true => {}\n+    //  ^^^^^ Internal: match check bailed out\n+    }\n+}\n+            \"#,\n+            );\n+        }\n+\n+        #[test]\n+        fn reference_patterns_in_fields() {\n+            check_diagnostics(\n+                r#\"\n+fn main() {\n+    match (&false,) {\n+        (true,) => {}\n+    //  ^^^^^^^ Internal: match check bailed out\n+    }\n+    match (&false,) {\n+        (&true,) => {}\n+    //  ^^^^^^^^ Internal: match check bailed out\n+    }\n+}\n+            \"#,\n+            );\n+        }\n     }\n }"}, {"sha": "1f4219b4226e4751942438946af077a855cb5945", "filename": "crates/hir_ty/src/diagnostics/match_check/deconstruct_pat.rs", "status": "added", "additions": 907, "deletions": 0, "changes": 907, "blob_url": "https://github.com/rust-lang/rust/blob/71117e6812f87e014bc8e984e195a75e222ac227/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71117e6812f87e014bc8e984e195a75e222ac227/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs?ref=71117e6812f87e014bc8e984e195a75e222ac227", "patch": "@@ -0,0 +1,907 @@\n+//! [`super::usefulness`] explains most of what is happening in this file. As explained there,\n+//! values and patterns are made from constructors applied to fields. This file defines a\n+//! `Constructor` enum, a `Fields` struct, and various operations to manipulate them and convert\n+//! them from/to patterns.\n+//!\n+//! There's one idea that is not detailed in [`super::usefulness`] because the details are not\n+//! needed there: _constructor splitting_.\n+//!\n+//! # Constructor splitting\n+//!\n+//! The idea is as follows: given a constructor `c` and a matrix, we want to specialize in turn\n+//! with all the value constructors that are covered by `c`, and compute usefulness for each.\n+//! Instead of listing all those constructors (which is intractable), we group those value\n+//! constructors together as much as possible. Example:\n+//!\n+//! ```\n+//! match (0, false) {\n+//!     (0 ..=100, true) => {} // `p_1`\n+//!     (50..=150, false) => {} // `p_2`\n+//!     (0 ..=200, _) => {} // `q`\n+//! }\n+//! ```\n+//!\n+//! The naive approach would try all numbers in the range `0..=200`. But we can be a lot more\n+//! clever: `0` and `1` for example will match the exact same rows, and return equivalent\n+//! witnesses. In fact all of `0..50` would. We can thus restrict our exploration to 4\n+//! constructors: `0..50`, `50..=100`, `101..=150` and `151..=200`. That is enough and infinitely\n+//! more tractable.\n+//!\n+//! We capture this idea in a function `split(p_1 ... p_n, c)` which returns a list of constructors\n+//! `c'` covered by `c`. Given such a `c'`, we require that all value ctors `c''` covered by `c'`\n+//! return an equivalent set of witnesses after specializing and computing usefulness.\n+//! In the example above, witnesses for specializing by `c''` covered by `0..50` will only differ\n+//! in their first element.\n+//!\n+//! We usually also ask that the `c'` together cover all of the original `c`. However we allow\n+//! skipping some constructors as long as it doesn't change whether the resulting list of witnesses\n+//! is empty of not. We use this in the wildcard `_` case.\n+//!\n+//! Splitting is implemented in the [`Constructor::split`] function. We don't do splitting for\n+//! or-patterns; instead we just try the alternatives one-by-one. For details on splitting\n+//! wildcards, see [`SplitWildcard`]; for integer ranges, see [`SplitIntRange`]; for slices, see\n+//! [`SplitVarLenSlice`].\n+\n+use std::{\n+    cmp::{max, min},\n+    iter::once,\n+    ops::RangeInclusive,\n+};\n+\n+use hir_def::{EnumVariantId, HasModule, LocalFieldId, VariantId};\n+use smallvec::{smallvec, SmallVec};\n+\n+use crate::{AdtId, Interner, Scalar, Ty, TyExt, TyKind};\n+\n+use super::{\n+    usefulness::{MatchCheckCtx, PatCtxt},\n+    FieldPat, Pat, PatId, PatKind,\n+};\n+\n+use self::Constructor::*;\n+\n+/// [Constructor] uses this in umimplemented variants.\n+/// It allows porting match expressions from upstream algorithm without losing semantics.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub(super) enum Void {}\n+\n+/// An inclusive interval, used for precise integer exhaustiveness checking.\n+/// `IntRange`s always store a contiguous range. This means that values are\n+/// encoded such that `0` encodes the minimum value for the integer,\n+/// regardless of the signedness.\n+/// For example, the pattern `-128..=127i8` is encoded as `0..=255`.\n+/// This makes comparisons and arithmetic on interval endpoints much more\n+/// straightforward. See `signed_bias` for details.\n+///\n+/// `IntRange` is never used to encode an empty range or a \"range\" that wraps\n+/// around the (offset) space: i.e., `range.lo <= range.hi`.\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub(super) struct IntRange {\n+    range: RangeInclusive<u128>,\n+}\n+\n+impl IntRange {\n+    #[inline]\n+    fn is_integral(ty: &Ty) -> bool {\n+        match ty.kind(&Interner) {\n+            TyKind::Scalar(Scalar::Char)\n+            | TyKind::Scalar(Scalar::Int(_))\n+            | TyKind::Scalar(Scalar::Uint(_))\n+            | TyKind::Scalar(Scalar::Bool) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    fn is_singleton(&self) -> bool {\n+        self.range.start() == self.range.end()\n+    }\n+\n+    fn boundaries(&self) -> (u128, u128) {\n+        (*self.range.start(), *self.range.end())\n+    }\n+\n+    #[inline]\n+    fn from_bool(value: bool) -> IntRange {\n+        let val = value as u128;\n+        IntRange { range: val..=val }\n+    }\n+\n+    #[inline]\n+    fn from_range(lo: u128, hi: u128, scalar_ty: Scalar) -> IntRange {\n+        if let Scalar::Bool = scalar_ty {\n+            IntRange { range: lo..=hi }\n+        } else {\n+            unimplemented!()\n+        }\n+    }\n+\n+    fn is_subrange(&self, other: &Self) -> bool {\n+        other.range.start() <= self.range.start() && self.range.end() <= other.range.end()\n+    }\n+\n+    fn intersection(&self, other: &Self) -> Option<Self> {\n+        let (lo, hi) = self.boundaries();\n+        let (other_lo, other_hi) = other.boundaries();\n+        if lo <= other_hi && other_lo <= hi {\n+            Some(IntRange { range: max(lo, other_lo)..=min(hi, other_hi) })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// See `Constructor::is_covered_by`\n+    fn is_covered_by(&self, other: &Self) -> bool {\n+        if self.intersection(other).is_some() {\n+            // Constructor splitting should ensure that all intersections we encounter are actually\n+            // inclusions.\n+            assert!(self.is_subrange(other));\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+/// Represents a border between 2 integers. Because the intervals spanning borders must be able to\n+/// cover every integer, we need to be able to represent 2^128 + 1 such borders.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n+enum IntBorder {\n+    JustBefore(u128),\n+    AfterMax,\n+}\n+\n+/// A range of integers that is partitioned into disjoint subranges. This does constructor\n+/// splitting for integer ranges as explained at the top of the file.\n+///\n+/// This is fed multiple ranges, and returns an output that covers the input, but is split so that\n+/// the only intersections between an output range and a seen range are inclusions. No output range\n+/// straddles the boundary of one of the inputs.\n+///\n+/// The following input:\n+/// ```\n+///   |-------------------------| // `self`\n+/// |------|  |----------|   |----|\n+///    |-------| |-------|\n+/// ```\n+/// would be iterated over as follows:\n+/// ```\n+///   ||---|--||-|---|---|---|--|\n+/// ```\n+#[derive(Debug, Clone)]\n+struct SplitIntRange {\n+    /// The range we are splitting\n+    range: IntRange,\n+    /// The borders of ranges we have seen. They are all contained within `range`. This is kept\n+    /// sorted.\n+    borders: Vec<IntBorder>,\n+}\n+\n+impl SplitIntRange {\n+    fn new(range: IntRange) -> Self {\n+        SplitIntRange { range, borders: Vec::new() }\n+    }\n+\n+    /// Internal use\n+    fn to_borders(r: IntRange) -> [IntBorder; 2] {\n+        use IntBorder::*;\n+        let (lo, hi) = r.boundaries();\n+        let lo = JustBefore(lo);\n+        let hi = match hi.checked_add(1) {\n+            Some(m) => JustBefore(m),\n+            None => AfterMax,\n+        };\n+        [lo, hi]\n+    }\n+\n+    /// Add ranges relative to which we split.\n+    fn split(&mut self, ranges: impl Iterator<Item = IntRange>) {\n+        let this_range = &self.range;\n+        let included_ranges = ranges.filter_map(|r| this_range.intersection(&r));\n+        let included_borders = included_ranges.flat_map(|r| {\n+            let borders = Self::to_borders(r);\n+            once(borders[0]).chain(once(borders[1]))\n+        });\n+        self.borders.extend(included_borders);\n+        self.borders.sort_unstable();\n+    }\n+\n+    /// Iterate over the contained ranges.\n+    fn iter(&self) -> impl Iterator<Item = IntRange> + '_ {\n+        use IntBorder::*;\n+\n+        let self_range = Self::to_borders(self.range.clone());\n+        // Start with the start of the range.\n+        let mut prev_border = self_range[0];\n+        self.borders\n+            .iter()\n+            .copied()\n+            // End with the end of the range.\n+            .chain(once(self_range[1]))\n+            // List pairs of adjacent borders.\n+            .map(move |border| {\n+                let ret = (prev_border, border);\n+                prev_border = border;\n+                ret\n+            })\n+            // Skip duplicates.\n+            .filter(|(prev_border, border)| prev_border != border)\n+            // Finally, convert to ranges.\n+            .map(|(prev_border, border)| {\n+                let range = match (prev_border, border) {\n+                    (JustBefore(n), JustBefore(m)) if n < m => n..=(m - 1),\n+                    (JustBefore(n), AfterMax) => n..=u128::MAX,\n+                    _ => unreachable!(), // Ruled out by the sorting and filtering we did\n+                };\n+                IntRange { range }\n+            })\n+    }\n+}\n+\n+/// A constructor for array and slice patterns.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub(super) struct Slice {\n+    _unimplemented: Void,\n+}\n+\n+impl Slice {\n+    /// See `Constructor::is_covered_by`\n+    fn is_covered_by(self, _other: Self) -> bool {\n+        unimplemented!() // never called as Slice contains Void\n+    }\n+}\n+\n+/// A value can be decomposed into a constructor applied to some fields. This struct represents\n+/// the constructor. See also `Fields`.\n+///\n+/// `pat_constructor` retrieves the constructor corresponding to a pattern.\n+/// `specialize_constructor` returns the list of fields corresponding to a pattern, given a\n+/// constructor. `Constructor::apply` reconstructs the pattern from a pair of `Constructor` and\n+/// `Fields`.\n+#[allow(dead_code)]\n+#[derive(Clone, Debug, PartialEq)]\n+pub(super) enum Constructor {\n+    /// The constructor for patterns that have a single constructor, like tuples, struct patterns\n+    /// and fixed-length arrays.\n+    Single,\n+    /// Enum variants.\n+    Variant(EnumVariantId),\n+    /// Ranges of integer literal values (`2`, `2..=5` or `2..5`).\n+    IntRange(IntRange),\n+    /// Ranges of floating-point literal values (`2.0..=5.2`).\n+    FloatRange(Void),\n+    /// String literals. Strings are not quite the same as `&[u8]` so we treat them separately.\n+    Str(Void),\n+    /// Array and slice patterns.\n+    Slice(Slice),\n+    /// Constants that must not be matched structurally. They are treated as black\n+    /// boxes for the purposes of exhaustiveness: we must not inspect them, and they\n+    /// don't count towards making a match exhaustive.\n+    Opaque,\n+    /// Fake extra constructor for enums that aren't allowed to be matched exhaustively. Also used\n+    /// for those types for which we cannot list constructors explicitly, like `f64` and `str`.\n+    NonExhaustive,\n+    /// Stands for constructors that are not seen in the matrix, as explained in the documentation\n+    /// for [`SplitWildcard`].\n+    Missing,\n+    /// Wildcard pattern.\n+    Wildcard,\n+}\n+\n+impl Constructor {\n+    pub(super) fn is_wildcard(&self) -> bool {\n+        matches!(self, Wildcard)\n+    }\n+\n+    fn as_int_range(&self) -> Option<&IntRange> {\n+        match self {\n+            IntRange(range) => Some(range),\n+            _ => None,\n+        }\n+    }\n+\n+    fn as_slice(&self) -> Option<Slice> {\n+        match self {\n+            Slice(slice) => Some(*slice),\n+            _ => None,\n+        }\n+    }\n+\n+    fn variant_id_for_adt(&self, adt: hir_def::AdtId) -> VariantId {\n+        match *self {\n+            Variant(id) => id.into(),\n+            Single => {\n+                assert!(!matches!(adt, hir_def::AdtId::EnumId(_)));\n+                match adt {\n+                    hir_def::AdtId::EnumId(_) => unreachable!(),\n+                    hir_def::AdtId::StructId(id) => id.into(),\n+                    hir_def::AdtId::UnionId(id) => id.into(),\n+                }\n+            }\n+            _ => panic!(\"bad constructor {:?} for adt {:?}\", self, adt),\n+        }\n+    }\n+\n+    /// Determines the constructor that the given pattern can be specialized to.\n+    pub(super) fn from_pat(cx: &MatchCheckCtx<'_>, pat: PatId) -> Self {\n+        match cx.pattern_arena.borrow()[pat].kind.as_ref() {\n+            PatKind::Binding { .. } | PatKind::Wild => Wildcard,\n+            PatKind::Leaf { .. } | PatKind::Deref { .. } => Single,\n+            &PatKind::Variant { enum_variant, .. } => Variant(enum_variant),\n+            &PatKind::LiteralBool { value } => IntRange(IntRange::from_bool(value)),\n+            PatKind::Or { .. } => cx.bug(\"Or-pattern should have been expanded earlier on.\"),\n+        }\n+    }\n+\n+    /// Some constructors (namely `Wildcard`, `IntRange` and `Slice`) actually stand for a set of actual\n+    /// constructors (like variants, integers or fixed-sized slices). When specializing for these\n+    /// constructors, we want to be specialising for the actual underlying constructors.\n+    /// Naively, we would simply return the list of constructors they correspond to. We instead are\n+    /// more clever: if there are constructors that we know will behave the same wrt the current\n+    /// matrix, we keep them grouped. For example, all slices of a sufficiently large length\n+    /// will either be all useful or all non-useful with a given matrix.\n+    ///\n+    /// See the branches for details on how the splitting is done.\n+    ///\n+    /// This function may discard some irrelevant constructors if this preserves behavior and\n+    /// diagnostics. Eg. for the `_` case, we ignore the constructors already present in the\n+    /// matrix, unless all of them are.\n+    pub(super) fn split<'a>(\n+        &self,\n+        pcx: PatCtxt<'_>,\n+        ctors: impl Iterator<Item = &'a Constructor> + Clone,\n+    ) -> SmallVec<[Self; 1]> {\n+        match self {\n+            Wildcard => {\n+                let mut split_wildcard = SplitWildcard::new(pcx);\n+                split_wildcard.split(pcx, ctors);\n+                split_wildcard.into_ctors(pcx)\n+            }\n+            // Fast-track if the range is trivial. In particular, we don't do the overlapping\n+            // ranges check.\n+            IntRange(ctor_range) if !ctor_range.is_singleton() => {\n+                let mut split_range = SplitIntRange::new(ctor_range.clone());\n+                let int_ranges = ctors.filter_map(|ctor| ctor.as_int_range());\n+                split_range.split(int_ranges.cloned());\n+                split_range.iter().map(IntRange).collect()\n+            }\n+            Slice(_) => unimplemented!(),\n+            // Any other constructor can be used unchanged.\n+            _ => smallvec![self.clone()],\n+        }\n+    }\n+\n+    /// Returns whether `self` is covered by `other`, i.e. whether `self` is a subset of `other`.\n+    /// For the simple cases, this is simply checking for equality. For the \"grouped\" constructors,\n+    /// this checks for inclusion.\n+    // We inline because this has a single call site in `Matrix::specialize_constructor`.\n+    #[inline]\n+    pub(super) fn is_covered_by(&self, pcx: PatCtxt<'_>, other: &Self) -> bool {\n+        // This must be kept in sync with `is_covered_by_any`.\n+        match (self, other) {\n+            // Wildcards cover anything\n+            (_, Wildcard) => true,\n+            // The missing ctors are not covered by anything in the matrix except wildcards.\n+            (Missing, _) | (Wildcard, _) => false,\n+\n+            (Single, Single) => true,\n+            (Variant(self_id), Variant(other_id)) => self_id == other_id,\n+\n+            (IntRange(self_range), IntRange(other_range)) => self_range.is_covered_by(other_range),\n+            (FloatRange(..), FloatRange(..)) => {\n+                unimplemented!()\n+            }\n+            (Str(..), Str(..)) => {\n+                unimplemented!()\n+            }\n+            (Slice(self_slice), Slice(other_slice)) => self_slice.is_covered_by(*other_slice),\n+\n+            // We are trying to inspect an opaque constant. Thus we skip the row.\n+            (Opaque, _) | (_, Opaque) => false,\n+            // Only a wildcard pattern can match the special extra constructor.\n+            (NonExhaustive, _) => false,\n+\n+            _ => pcx.cx.bug(&format!(\n+                \"trying to compare incompatible constructors {:?} and {:?}\",\n+                self, other\n+            )),\n+        }\n+    }\n+\n+    /// Faster version of `is_covered_by` when applied to many constructors. `used_ctors` is\n+    /// assumed to be built from `matrix.head_ctors()` with wildcards filtered out, and `self` is\n+    /// assumed to have been split from a wildcard.\n+    fn is_covered_by_any(&self, pcx: PatCtxt<'_>, used_ctors: &[Constructor]) -> bool {\n+        if used_ctors.is_empty() {\n+            return false;\n+        }\n+\n+        // This must be kept in sync with `is_covered_by`.\n+        match self {\n+            // If `self` is `Single`, `used_ctors` cannot contain anything else than `Single`s.\n+            Single => !used_ctors.is_empty(),\n+            Variant(_) => used_ctors.iter().any(|c| c == self),\n+            IntRange(range) => used_ctors\n+                .iter()\n+                .filter_map(|c| c.as_int_range())\n+                .any(|other| range.is_covered_by(other)),\n+            Slice(slice) => used_ctors\n+                .iter()\n+                .filter_map(|c| c.as_slice())\n+                .any(|other| slice.is_covered_by(other)),\n+            // This constructor is never covered by anything else\n+            NonExhaustive => false,\n+            Str(..) | FloatRange(..) | Opaque | Missing | Wildcard => {\n+                pcx.cx.bug(&format!(\"found unexpected ctor in all_ctors: {:?}\", self))\n+            }\n+        }\n+    }\n+}\n+\n+/// A wildcard constructor that we split relative to the constructors in the matrix, as explained\n+/// at the top of the file.\n+///\n+/// A constructor that is not present in the matrix rows will only be covered by the rows that have\n+/// wildcards. Thus we can group all of those constructors together; we call them \"missing\n+/// constructors\". Splitting a wildcard would therefore list all present constructors individually\n+/// (or grouped if they are integers or slices), and then all missing constructors together as a\n+/// group.\n+///\n+/// However we can go further: since any constructor will match the wildcard rows, and having more\n+/// rows can only reduce the amount of usefulness witnesses, we can skip the present constructors\n+/// and only try the missing ones.\n+/// This will not preserve the whole list of witnesses, but will preserve whether the list is empty\n+/// or not. In fact this is quite natural from the point of view of diagnostics too. This is done\n+/// in `to_ctors`: in some cases we only return `Missing`.\n+#[derive(Debug)]\n+pub(super) struct SplitWildcard {\n+    /// Constructors seen in the matrix.\n+    matrix_ctors: Vec<Constructor>,\n+    /// All the constructors for this type\n+    all_ctors: SmallVec<[Constructor; 1]>,\n+}\n+\n+impl SplitWildcard {\n+    pub(super) fn new(pcx: PatCtxt<'_>) -> Self {\n+        let cx = pcx.cx;\n+        let make_range = |start, end, scalar| IntRange(IntRange::from_range(start, end, scalar));\n+\n+        // Unhandled types are treated as non-exhaustive. Being explicit here instead of falling\n+        // to catchall arm to ease further implementation.\n+        let unhandled = || smallvec![NonExhaustive];\n+\n+        // This determines the set of all possible constructors for the type `pcx.ty`. For numbers,\n+        // arrays and slices we use ranges and variable-length slices when appropriate.\n+        //\n+        // If the `exhaustive_patterns` feature is enabled, we make sure to omit constructors that\n+        // are statically impossible. E.g., for `Option<!>`, we do not include `Some(_)` in the\n+        // returned list of constructors.\n+        // Invariant: this is empty if and only if the type is uninhabited (as determined by\n+        // `cx.is_uninhabited()`).\n+        let all_ctors = match pcx.ty.kind(&Interner) {\n+            TyKind::Scalar(Scalar::Bool) => smallvec![make_range(0, 1, Scalar::Bool)],\n+            // TyKind::Array(..) if ... => unhandled(),\n+            TyKind::Array(..) | TyKind::Slice(..) => unhandled(),\n+            &TyKind::Adt(AdtId(hir_def::AdtId::EnumId(enum_id)), ref _substs) => {\n+                let enum_data = cx.db.enum_data(enum_id);\n+\n+                // If the enum is declared as `#[non_exhaustive]`, we treat it as if it had an\n+                // additional \"unknown\" constructor.\n+                // There is no point in enumerating all possible variants, because the user can't\n+                // actually match against them all themselves. So we always return only the fictitious\n+                // constructor.\n+                // E.g., in an example like:\n+                //\n+                // ```\n+                //     let err: io::ErrorKind = ...;\n+                //     match err {\n+                //         io::ErrorKind::NotFound => {},\n+                //     }\n+                // ```\n+                //\n+                // we don't want to show every possible IO error, but instead have only `_` as the\n+                // witness.\n+                let is_declared_nonexhaustive = cx.is_foreign_non_exhaustive_enum(enum_id);\n+\n+                // If `exhaustive_patterns` is disabled and our scrutinee is an empty enum, we treat it\n+                // as though it had an \"unknown\" constructor to avoid exposing its emptiness. The\n+                // exception is if the pattern is at the top level, because we want empty matches to be\n+                // considered exhaustive.\n+                let is_secretly_empty = enum_data.variants.is_empty()\n+                    && !cx.feature_exhaustive_patterns()\n+                    && !pcx.is_top_level;\n+\n+                if is_secretly_empty || is_declared_nonexhaustive {\n+                    smallvec![NonExhaustive]\n+                } else if cx.feature_exhaustive_patterns() {\n+                    unimplemented!() // see MatchCheckCtx.feature_exhaustive_patterns()\n+                } else {\n+                    enum_data\n+                        .variants\n+                        .iter()\n+                        .map(|(local_id, ..)| Variant(EnumVariantId { parent: enum_id, local_id }))\n+                        .collect()\n+                }\n+            }\n+            TyKind::Scalar(Scalar::Char) => unhandled(),\n+            TyKind::Scalar(Scalar::Int(..)) | TyKind::Scalar(Scalar::Uint(..)) => unhandled(),\n+            TyKind::Never if !cx.feature_exhaustive_patterns() && !pcx.is_top_level => {\n+                smallvec![NonExhaustive]\n+            }\n+            TyKind::Never => SmallVec::new(),\n+            _ if cx.is_uninhabited(&pcx.ty) => SmallVec::new(),\n+            TyKind::Adt(..) | TyKind::Tuple(..) | TyKind::Ref(..) => smallvec![Single],\n+            // This type is one for which we cannot list constructors, like `str` or `f64`.\n+            _ => smallvec![NonExhaustive],\n+        };\n+        SplitWildcard { matrix_ctors: Vec::new(), all_ctors }\n+    }\n+\n+    /// Pass a set of constructors relative to which to split this one. Don't call twice, it won't\n+    /// do what you want.\n+    pub(super) fn split<'a>(\n+        &mut self,\n+        pcx: PatCtxt<'_>,\n+        ctors: impl Iterator<Item = &'a Constructor> + Clone,\n+    ) {\n+        // Since `all_ctors` never contains wildcards, this won't recurse further.\n+        self.all_ctors =\n+            self.all_ctors.iter().flat_map(|ctor| ctor.split(pcx, ctors.clone())).collect();\n+        self.matrix_ctors = ctors.filter(|c| !c.is_wildcard()).cloned().collect();\n+    }\n+\n+    /// Whether there are any value constructors for this type that are not present in the matrix.\n+    fn any_missing(&self, pcx: PatCtxt<'_>) -> bool {\n+        self.iter_missing(pcx).next().is_some()\n+    }\n+\n+    /// Iterate over the constructors for this type that are not present in the matrix.\n+    pub(super) fn iter_missing<'a>(\n+        &'a self,\n+        pcx: PatCtxt<'a>,\n+    ) -> impl Iterator<Item = &'a Constructor> {\n+        self.all_ctors.iter().filter(move |ctor| !ctor.is_covered_by_any(pcx, &self.matrix_ctors))\n+    }\n+\n+    /// Return the set of constructors resulting from splitting the wildcard. As explained at the\n+    /// top of the file, if any constructors are missing we can ignore the present ones.\n+    fn into_ctors(self, pcx: PatCtxt<'_>) -> SmallVec<[Constructor; 1]> {\n+        if self.any_missing(pcx) {\n+            // Some constructors are missing, thus we can specialize with the special `Missing`\n+            // constructor, which stands for those constructors that are not seen in the matrix,\n+            // and matches the same rows as any of them (namely the wildcard rows). See the top of\n+            // the file for details.\n+            // However, when all constructors are missing we can also specialize with the full\n+            // `Wildcard` constructor. The difference will depend on what we want in diagnostics.\n+\n+            // If some constructors are missing, we typically want to report those constructors,\n+            // e.g.:\n+            // ```\n+            //     enum Direction { N, S, E, W }\n+            //     let Direction::N = ...;\n+            // ```\n+            // we can report 3 witnesses: `S`, `E`, and `W`.\n+            //\n+            // However, if the user didn't actually specify a constructor\n+            // in this arm, e.g., in\n+            // ```\n+            //     let x: (Direction, Direction, bool) = ...;\n+            //     let (_, _, false) = x;\n+            // ```\n+            // we don't want to show all 16 possible witnesses `(<direction-1>, <direction-2>,\n+            // true)` - we are satisfied with `(_, _, true)`. So if all constructors are missing we\n+            // prefer to report just a wildcard `_`.\n+            //\n+            // The exception is: if we are at the top-level, for example in an empty match, we\n+            // sometimes prefer reporting the list of constructors instead of just `_`.\n+            let report_when_all_missing = pcx.is_top_level && !IntRange::is_integral(pcx.ty);\n+            let ctor = if !self.matrix_ctors.is_empty() || report_when_all_missing {\n+                Missing\n+            } else {\n+                Wildcard\n+            };\n+            return smallvec![ctor];\n+        }\n+\n+        // All the constructors are present in the matrix, so we just go through them all.\n+        self.all_ctors\n+    }\n+}\n+\n+/// A value can be decomposed into a constructor applied to some fields. This struct represents\n+/// those fields, generalized to allow patterns in each field. See also `Constructor`.\n+/// This is constructed from a constructor using [`Fields::wildcards()`].\n+///\n+/// If a private or `non_exhaustive` field is uninhabited, the code mustn't observe that it is\n+/// uninhabited. For that, we filter these fields out of the matrix. This is handled automatically\n+/// in `Fields`. This filtering is uncommon in practice, because uninhabited fields are rarely used,\n+/// so we avoid it when possible to preserve performance.\n+#[derive(Debug, Clone)]\n+pub(super) enum Fields {\n+    /// Lists of patterns that don't contain any filtered fields.\n+    /// `Slice` and `Vec` behave the same; the difference is only to avoid allocating and\n+    /// triple-dereferences when possible. Frankly this is premature optimization, I (Nadrieril)\n+    /// have not measured if it really made a difference.\n+    Vec(SmallVec<[PatId; 2]>),\n+}\n+\n+impl Fields {\n+    /// Internal use. Use `Fields::wildcards()` instead.\n+    /// Must not be used if the pattern is a field of a struct/tuple/variant.\n+    fn from_single_pattern(pat: PatId) -> Self {\n+        Fields::Vec(smallvec![pat])\n+    }\n+\n+    /// Convenience; internal use.\n+    fn wildcards_from_tys(cx: &MatchCheckCtx<'_>, tys: impl IntoIterator<Item = Ty>) -> Self {\n+        let wilds = tys.into_iter().map(Pat::wildcard_from_ty);\n+        let pats = wilds.map(|pat| cx.alloc_pat(pat)).collect();\n+        Fields::Vec(pats)\n+    }\n+\n+    /// Creates a new list of wildcard fields for a given constructor.\n+    pub(crate) fn wildcards(pcx: PatCtxt<'_>, constructor: &Constructor) -> Self {\n+        let ty = pcx.ty;\n+        let cx = pcx.cx;\n+        let wildcard_from_ty = |ty: &Ty| cx.alloc_pat(Pat::wildcard_from_ty(ty.clone()));\n+\n+        let ret = match constructor {\n+            Single | Variant(_) => match ty.kind(&Interner) {\n+                TyKind::Tuple(_, substs) => {\n+                    let tys = substs.iter(&Interner).map(|ty| ty.assert_ty_ref(&Interner));\n+                    Fields::wildcards_from_tys(cx, tys.cloned())\n+                }\n+                TyKind::Ref(.., rty) => Fields::from_single_pattern(wildcard_from_ty(rty)),\n+                &TyKind::Adt(AdtId(adt), ref substs) => {\n+                    if adt_is_box(adt, cx) {\n+                        // Use T as the sub pattern type of Box<T>.\n+                        let subst_ty = substs.at(&Interner, 0).assert_ty_ref(&Interner);\n+                        Fields::from_single_pattern(wildcard_from_ty(subst_ty))\n+                    } else {\n+                        let variant_id = constructor.variant_id_for_adt(adt);\n+                        let adt_is_local =\n+                            variant_id.module(cx.db.upcast()).krate() == cx.module.krate();\n+                        // Whether we must not match the fields of this variant exhaustively.\n+                        let is_non_exhaustive =\n+                            is_field_list_non_exhaustive(variant_id, cx) && !adt_is_local;\n+\n+                        cov_mark::hit!(match_check_wildcard_expanded_to_substitutions);\n+                        let field_ty_data = cx.db.field_types(variant_id);\n+                        let field_tys = || {\n+                            field_ty_data\n+                                .iter()\n+                                .map(|(_, binders)| binders.clone().substitute(&Interner, substs))\n+                        };\n+\n+                        // In the following cases, we don't need to filter out any fields. This is\n+                        // the vast majority of real cases, since uninhabited fields are uncommon.\n+                        let has_no_hidden_fields = (matches!(adt, hir_def::AdtId::EnumId(_))\n+                            && !is_non_exhaustive)\n+                            || !field_tys().any(|ty| cx.is_uninhabited(&ty));\n+\n+                        if has_no_hidden_fields {\n+                            Fields::wildcards_from_tys(cx, field_tys())\n+                        } else {\n+                            //FIXME(iDawer): see MatchCheckCtx::is_uninhabited, has_no_hidden_fields is always true\n+                            unimplemented!(\"exhaustive_patterns feature\")\n+                        }\n+                    }\n+                }\n+                ty_kind => {\n+                    cx.bug(&format!(\"Unexpected type for `Single` constructor: {:?}\", ty_kind))\n+                }\n+            },\n+            Slice(..) => {\n+                unimplemented!()\n+            }\n+            Str(..) | FloatRange(..) | IntRange(..) | NonExhaustive | Opaque | Missing\n+            | Wildcard => Fields::Vec(Default::default()),\n+        };\n+        ret\n+    }\n+\n+    /// Apply a constructor to a list of patterns, yielding a new pattern. `self`\n+    /// must have as many elements as this constructor's arity.\n+    ///\n+    /// This is roughly the inverse of `specialize_constructor`.\n+    ///\n+    /// Examples:\n+    /// `ctor`: `Constructor::Single`\n+    /// `ty`: `Foo(u32, u32, u32)`\n+    /// `self`: `[10, 20, _]`\n+    /// returns `Foo(10, 20, _)`\n+    ///\n+    /// `ctor`: `Constructor::Variant(Option::Some)`\n+    /// `ty`: `Option<bool>`\n+    /// `self`: `[false]`\n+    /// returns `Some(false)`\n+    pub(super) fn apply(self, pcx: PatCtxt<'_>, ctor: &Constructor) -> Pat {\n+        let subpatterns_and_indices = self.patterns_and_indices();\n+        let mut subpatterns =\n+            subpatterns_and_indices.iter().map(|&(_, p)| pcx.cx.pattern_arena.borrow()[p].clone());\n+        // FIXME(iDawer) witnesses are not yet used\n+        const UNHANDLED: PatKind = PatKind::Wild;\n+\n+        let pat = match ctor {\n+            Single | Variant(_) => match pcx.ty.kind(&Interner) {\n+                TyKind::Adt(..) | TyKind::Tuple(..) => {\n+                    // We want the real indices here.\n+                    let subpatterns = subpatterns_and_indices\n+                        .iter()\n+                        .map(|&(field, pat)| FieldPat {\n+                            field,\n+                            pattern: pcx.cx.pattern_arena.borrow()[pat].clone(),\n+                        })\n+                        .collect();\n+\n+                    if let Some((adt, substs)) = pcx.ty.as_adt() {\n+                        if let hir_def::AdtId::EnumId(_) = adt {\n+                            let enum_variant = match ctor {\n+                                &Variant(id) => id,\n+                                _ => unreachable!(),\n+                            };\n+                            PatKind::Variant { substs: substs.clone(), enum_variant, subpatterns }\n+                        } else {\n+                            PatKind::Leaf { subpatterns }\n+                        }\n+                    } else {\n+                        PatKind::Leaf { subpatterns }\n+                    }\n+                }\n+                // Note: given the expansion of `&str` patterns done in `expand_pattern`, we should\n+                // be careful to reconstruct the correct constant pattern here. However a string\n+                // literal pattern will never be reported as a non-exhaustiveness witness, so we\n+                // can ignore this issue.\n+                TyKind::Ref(..) => PatKind::Deref { subpattern: subpatterns.next().unwrap() },\n+                TyKind::Slice(..) | TyKind::Array(..) => {\n+                    pcx.cx.bug(&format!(\"bad slice pattern {:?} {:?}\", ctor, pcx.ty))\n+                }\n+                _ => PatKind::Wild,\n+            },\n+            Constructor::Slice(_) => UNHANDLED,\n+            Str(_) => UNHANDLED,\n+            FloatRange(..) => UNHANDLED,\n+            Constructor::IntRange(_) => UNHANDLED,\n+            NonExhaustive => PatKind::Wild,\n+            Wildcard => return Pat::wildcard_from_ty(pcx.ty.clone()),\n+            Opaque => pcx.cx.bug(\"we should not try to apply an opaque constructor\"),\n+            Missing => pcx.cx.bug(\n+                \"trying to apply the `Missing` constructor;\\\n+                this should have been done in `apply_constructors`\",\n+            ),\n+        };\n+\n+        Pat { ty: pcx.ty.clone(), kind: Box::new(pat) }\n+    }\n+\n+    /// Returns the number of patterns. This is the same as the arity of the constructor used to\n+    /// construct `self`.\n+    pub(super) fn len(&self) -> usize {\n+        match self {\n+            Fields::Vec(pats) => pats.len(),\n+        }\n+    }\n+\n+    /// Returns the list of patterns along with the corresponding field indices.\n+    fn patterns_and_indices(&self) -> SmallVec<[(LocalFieldId, PatId); 2]> {\n+        match self {\n+            Fields::Vec(pats) => pats\n+                .iter()\n+                .copied()\n+                .enumerate()\n+                .map(|(i, p)| (LocalFieldId::from_raw((i as u32).into()), p))\n+                .collect(),\n+        }\n+    }\n+\n+    pub(super) fn into_patterns(self) -> SmallVec<[PatId; 2]> {\n+        match self {\n+            Fields::Vec(pats) => pats,\n+        }\n+    }\n+\n+    /// Overrides some of the fields with the provided patterns. Exactly like\n+    /// `replace_fields_indexed`, except that it takes `FieldPat`s as input.\n+    fn replace_with_fieldpats(\n+        &self,\n+        new_pats: impl IntoIterator<Item = (LocalFieldId, PatId)>,\n+    ) -> Self {\n+        self.replace_fields_indexed(\n+            new_pats.into_iter().map(|(field, pat)| (u32::from(field.into_raw()) as usize, pat)),\n+        )\n+    }\n+\n+    /// Overrides some of the fields with the provided patterns. This is used when a pattern\n+    /// defines some fields but not all, for example `Foo { field1: Some(_), .. }`: here we start\n+    /// with a `Fields` that is just one wildcard per field of the `Foo` struct, and override the\n+    /// entry corresponding to `field1` with the pattern `Some(_)`. This is also used for slice\n+    /// patterns for the same reason.\n+    fn replace_fields_indexed(&self, new_pats: impl IntoIterator<Item = (usize, PatId)>) -> Self {\n+        let mut fields = self.clone();\n+\n+        match &mut fields {\n+            Fields::Vec(pats) => {\n+                for (i, pat) in new_pats {\n+                    if let Some(p) = pats.get_mut(i) {\n+                        *p = pat;\n+                    }\n+                }\n+            }\n+        }\n+        fields\n+    }\n+\n+    /// Replaces contained fields with the given list of patterns. There must be `len()` patterns\n+    /// in `pats`.\n+    pub(super) fn replace_fields(\n+        &self,\n+        cx: &MatchCheckCtx<'_>,\n+        pats: impl IntoIterator<Item = Pat>,\n+    ) -> Self {\n+        let pats = pats.into_iter().map(|pat| cx.alloc_pat(pat)).collect();\n+\n+        match self {\n+            Fields::Vec(_) => Fields::Vec(pats),\n+        }\n+    }\n+\n+    /// Replaces contained fields with the arguments of the given pattern. Only use on a pattern\n+    /// that is compatible with the constructor used to build `self`.\n+    /// This is meant to be used on the result of `Fields::wildcards()`. The idea is that\n+    /// `wildcards` constructs a list of fields where all entries are wildcards, and the pattern\n+    /// provided to this function fills some of the fields with non-wildcards.\n+    /// In the following example `Fields::wildcards` would return `[_, _, _, _]`. If we call\n+    /// `replace_with_pattern_arguments` on it with the pattern, the result will be `[Some(0), _,\n+    /// _, _]`.\n+    /// ```rust\n+    /// let x: [Option<u8>; 4] = foo();\n+    /// match x {\n+    ///     [Some(0), ..] => {}\n+    /// }\n+    /// ```\n+    /// This is guaranteed to preserve the number of patterns in `self`.\n+    pub(super) fn replace_with_pattern_arguments(\n+        &self,\n+        pat: PatId,\n+        cx: &MatchCheckCtx<'_>,\n+    ) -> Self {\n+        // FIXME(iDawer): Factor out pattern deep cloning. See discussion:\n+        // https://github.com/rust-analyzer/rust-analyzer/pull/8717#discussion_r633086640\n+        let mut arena = cx.pattern_arena.borrow_mut();\n+        match arena[pat].kind.as_ref() {\n+            PatKind::Deref { subpattern } => {\n+                assert_eq!(self.len(), 1);\n+                let subpattern = subpattern.clone();\n+                Fields::from_single_pattern(arena.alloc(subpattern))\n+            }\n+            PatKind::Leaf { subpatterns } | PatKind::Variant { subpatterns, .. } => {\n+                let subpatterns = subpatterns.clone();\n+                let subpatterns = subpatterns\n+                    .iter()\n+                    .map(|field_pat| (field_pat.field, arena.alloc(field_pat.pattern.clone())));\n+                self.replace_with_fieldpats(subpatterns)\n+            }\n+\n+            PatKind::Wild\n+            | PatKind::Binding { .. }\n+            | PatKind::LiteralBool { .. }\n+            | PatKind::Or { .. } => self.clone(),\n+        }\n+    }\n+}\n+\n+fn is_field_list_non_exhaustive(variant_id: VariantId, cx: &MatchCheckCtx<'_>) -> bool {\n+    let attr_def_id = match variant_id {\n+        VariantId::EnumVariantId(id) => id.into(),\n+        VariantId::StructId(id) => id.into(),\n+        VariantId::UnionId(id) => id.into(),\n+    };\n+    cx.db.attrs(attr_def_id).by_key(\"non_exhaustive\").exists()\n+}\n+\n+fn adt_is_box(adt: hir_def::AdtId, cx: &MatchCheckCtx<'_>) -> bool {\n+    use hir_def::lang_item::LangItemTarget;\n+    match cx.db.lang_item(cx.module.krate(), \"owned_box\".into()) {\n+        Some(LangItemTarget::StructId(box_id)) => adt == box_id.into(),\n+        _ => false,\n+    }\n+}"}, {"sha": "b89b4f2bfb7d91c6a339a90aafc6e2c989bab4e7", "filename": "crates/hir_ty/src/diagnostics/match_check/pat_util.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/71117e6812f87e014bc8e984e195a75e222ac227/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71117e6812f87e014bc8e984e195a75e222ac227/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fpat_util.rs?ref=71117e6812f87e014bc8e984e195a75e222ac227", "patch": "@@ -0,0 +1,56 @@\n+//! Pattern untilities.\n+//!\n+//! Originates from `rustc_hir::pat_util`\n+\n+use std::iter::{Enumerate, ExactSizeIterator};\n+\n+pub(crate) struct EnumerateAndAdjust<I> {\n+    enumerate: Enumerate<I>,\n+    gap_pos: usize,\n+    gap_len: usize,\n+}\n+\n+impl<I> Iterator for EnumerateAndAdjust<I>\n+where\n+    I: Iterator,\n+{\n+    type Item = (usize, <I as Iterator>::Item);\n+\n+    fn next(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n+        self.enumerate\n+            .next()\n+            .map(|(i, elem)| (if i < self.gap_pos { i } else { i + self.gap_len }, elem))\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.enumerate.size_hint()\n+    }\n+}\n+\n+pub(crate) trait EnumerateAndAdjustIterator {\n+    fn enumerate_and_adjust(\n+        self,\n+        expected_len: usize,\n+        gap_pos: Option<usize>,\n+    ) -> EnumerateAndAdjust<Self>\n+    where\n+        Self: Sized;\n+}\n+\n+impl<T: ExactSizeIterator> EnumerateAndAdjustIterator for T {\n+    fn enumerate_and_adjust(\n+        self,\n+        expected_len: usize,\n+        gap_pos: Option<usize>,\n+    ) -> EnumerateAndAdjust<Self>\n+    where\n+        Self: Sized,\n+    {\n+        let actual_len = self.len();\n+        EnumerateAndAdjust {\n+            enumerate: self.enumerate(),\n+            gap_pos: gap_pos.unwrap_or(expected_len),\n+            gap_len: expected_len - actual_len,\n+        }\n+    }\n+}"}, {"sha": "83b094a893831b77d098613b1cbdc681d67c5f0c", "filename": "crates/hir_ty/src/diagnostics/match_check/usefulness.rs", "status": "added", "additions": 1188, "deletions": 0, "changes": 1188, "blob_url": "https://github.com/rust-lang/rust/blob/71117e6812f87e014bc8e984e195a75e222ac227/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71117e6812f87e014bc8e984e195a75e222ac227/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fusefulness.rs?ref=71117e6812f87e014bc8e984e195a75e222ac227", "patch": "@@ -0,0 +1,1188 @@\n+//! Based on rust-lang/rust 1.52.0-nightly (25c15cdbe 2021-04-22)\n+//! https://github.com/rust-lang/rust/blob/25c15cdbe/compiler/rustc_mir_build/src/thir/pattern/usefulness.rs\n+//!\n+//! -----\n+//!\n+//! This file includes the logic for exhaustiveness and reachability checking for pattern-matching.\n+//! Specifically, given a list of patterns for a type, we can tell whether:\n+//! (a) each pattern is reachable (reachability)\n+//! (b) the patterns cover every possible value for the type (exhaustiveness)\n+//!\n+//! The algorithm implemented here is a modified version of the one described in [this\n+//! paper](http://moscova.inria.fr/~maranget/papers/warn/index.html). We have however generalized\n+//! it to accommodate the variety of patterns that Rust supports. We thus explain our version here,\n+//! without being as rigorous.\n+//!\n+//!\n+//! # Summary\n+//!\n+//! The core of the algorithm is the notion of \"usefulness\". A pattern `q` is said to be *useful*\n+//! relative to another pattern `p` of the same type if there is a value that is matched by `q` and\n+//! not matched by `p`. This generalizes to many `p`s: `q` is useful w.r.t. a list of patterns\n+//! `p_1 .. p_n` if there is a value that is matched by `q` and by none of the `p_i`. We write\n+//! `usefulness(p_1 .. p_n, q)` for a function that returns a list of such values. The aim of this\n+//! file is to compute it efficiently.\n+//!\n+//! This is enough to compute reachability: a pattern in a `match` expression is reachable iff it\n+//! is useful w.r.t. the patterns above it:\n+//! ```rust\n+//! match x {\n+//!     Some(_) => ...,\n+//!     None => ..., // reachable: `None` is matched by this but not the branch above\n+//!     Some(0) => ..., // unreachable: all the values this matches are already matched by\n+//!                     // `Some(_)` above\n+//! }\n+//! ```\n+//!\n+//! This is also enough to compute exhaustiveness: a match is exhaustive iff the wildcard `_`\n+//! pattern is _not_ useful w.r.t. the patterns in the match. The values returned by `usefulness`\n+//! are used to tell the user which values are missing.\n+//! ```rust\n+//! match x {\n+//!     Some(0) => ...,\n+//!     None => ...,\n+//!     // not exhaustive: `_` is useful because it matches `Some(1)`\n+//! }\n+//! ```\n+//!\n+//! The entrypoint of this file is the [`compute_match_usefulness`] function, which computes\n+//! reachability for each match branch and exhaustiveness for the whole match.\n+//!\n+//!\n+//! # Constructors and fields\n+//!\n+//! Note: we will often abbreviate \"constructor\" as \"ctor\".\n+//!\n+//! The idea that powers everything that is done in this file is the following: a (matcheable)\n+//! value is made from a constructor applied to a number of subvalues. Examples of constructors are\n+//! `Some`, `None`, `(,)` (the 2-tuple constructor), `Foo {..}` (the constructor for a struct\n+//! `Foo`), and `2` (the constructor for the number `2`). This is natural when we think of\n+//! pattern-matching, and this is the basis for what follows.\n+//!\n+//! Some of the ctors listed above might feel weird: `None` and `2` don't take any arguments.\n+//! That's ok: those are ctors that take a list of 0 arguments; they are the simplest case of\n+//! ctors. We treat `2` as a ctor because `u64` and other number types behave exactly like a huge\n+//! `enum`, with one variant for each number. This allows us to see any matcheable value as made up\n+//! from a tree of ctors, each having a set number of children. For example: `Foo { bar: None,\n+//! baz: Ok(0) }` is made from 4 different ctors, namely `Foo{..}`, `None`, `Ok` and `0`.\n+//!\n+//! This idea can be extended to patterns: they are also made from constructors applied to fields.\n+//! A pattern for a given type is allowed to use all the ctors for values of that type (which we\n+//! call \"value constructors\"), but there are also pattern-only ctors. The most important one is\n+//! the wildcard (`_`), and the others are integer ranges (`0..=10`), variable-length slices (`[x,\n+//! ..]`), and or-patterns (`Ok(0) | Err(_)`). Examples of valid patterns are `42`, `Some(_)`, `Foo\n+//! { bar: Some(0) | None, baz: _ }`. Note that a binder in a pattern (e.g. `Some(x)`) matches the\n+//! same values as a wildcard (e.g. `Some(_)`), so we treat both as wildcards.\n+//!\n+//! From this deconstruction we can compute whether a given value matches a given pattern; we\n+//! simply look at ctors one at a time. Given a pattern `p` and a value `v`, we want to compute\n+//! `matches!(v, p)`. It's mostly straightforward: we compare the head ctors and when they match\n+//! we compare their fields recursively. A few representative examples:\n+//!\n+//! - `matches!(v, _) := true`\n+//! - `matches!((v0,  v1), (p0,  p1)) := matches!(v0, p0) && matches!(v1, p1)`\n+//! - `matches!(Foo { bar: v0, baz: v1 }, Foo { bar: p0, baz: p1 }) := matches!(v0, p0) && matches!(v1, p1)`\n+//! - `matches!(Ok(v0), Ok(p0)) := matches!(v0, p0)`\n+//! - `matches!(Ok(v0), Err(p0)) := false` (incompatible variants)\n+//! - `matches!(v, 1..=100) := matches!(v, 1) || ... || matches!(v, 100)`\n+//! - `matches!([v0], [p0, .., p1]) := false` (incompatible lengths)\n+//! - `matches!([v0, v1, v2], [p0, .., p1]) := matches!(v0, p0) && matches!(v2, p1)`\n+//! - `matches!(v, p0 | p1) := matches!(v, p0) || matches!(v, p1)`\n+//!\n+//! Constructors, fields and relevant operations are defined in the [`super::deconstruct_pat`] module.\n+//!\n+//! Note: this constructors/fields distinction may not straightforwardly apply to every Rust type.\n+//! For example a value of type `Rc<u64>` can't be deconstructed that way, and `&str` has an\n+//! infinitude of constructors. There are also subtleties with visibility of fields and\n+//! uninhabitedness and various other things. The constructors idea can be extended to handle most\n+//! of these subtleties though; caveats are documented where relevant throughout the code.\n+//!\n+//! Whether constructors cover each other is computed by [`Constructor::is_covered_by`].\n+//!\n+//!\n+//! # Specialization\n+//!\n+//! Recall that we wish to compute `usefulness(p_1 .. p_n, q)`: given a list of patterns `p_1 ..\n+//! p_n` and a pattern `q`, all of the same type, we want to find a list of values (called\n+//! \"witnesses\") that are matched by `q` and by none of the `p_i`. We obviously don't just\n+//! enumerate all possible values. From the discussion above we see that we can proceed\n+//! ctor-by-ctor: for each value ctor of the given type, we ask \"is there a value that starts with\n+//! this constructor and matches `q` and none of the `p_i`?\". As we saw above, there's a lot we can\n+//! say from knowing only the first constructor of our candidate value.\n+//!\n+//! Let's take the following example:\n+//! ```\n+//! match x {\n+//!     Enum::Variant1(_) => {} // `p1`\n+//!     Enum::Variant2(None, 0) => {} // `p2`\n+//!     Enum::Variant2(Some(_), 0) => {} // `q`\n+//! }\n+//! ```\n+//!\n+//! We can easily see that if our candidate value `v` starts with `Variant1` it will not match `q`.\n+//! If `v = Variant2(v0, v1)` however, whether or not it matches `p2` and `q` will depend on `v0`\n+//! and `v1`. In fact, such a `v` will be a witness of usefulness of `q` exactly when the tuple\n+//! `(v0, v1)` is a witness of usefulness of `q'` in the following reduced match:\n+//!\n+//! ```\n+//! match x {\n+//!     (None, 0) => {} // `p2'`\n+//!     (Some(_), 0) => {} // `q'`\n+//! }\n+//! ```\n+//!\n+//! This motivates a new step in computing usefulness, that we call _specialization_.\n+//! Specialization consist of filtering a list of patterns for those that match a constructor, and\n+//! then looking into the constructor's fields. This enables usefulness to be computed recursively.\n+//!\n+//! Instead of acting on a single pattern in each row, we will consider a list of patterns for each\n+//! row, and we call such a list a _pattern-stack_. The idea is that we will specialize the\n+//! leftmost pattern, which amounts to popping the constructor and pushing its fields, which feels\n+//! like a stack. We note a pattern-stack simply with `[p_1 ... p_n]`.\n+//! Here's a sequence of specializations of a list of pattern-stacks, to illustrate what's\n+//! happening:\n+//! ```\n+//! [Enum::Variant1(_)]\n+//! [Enum::Variant2(None, 0)]\n+//! [Enum::Variant2(Some(_), 0)]\n+//! //==>> specialize with `Variant2`\n+//! [None, 0]\n+//! [Some(_), 0]\n+//! //==>> specialize with `Some`\n+//! [_, 0]\n+//! //==>> specialize with `true` (say the type was `bool`)\n+//! [0]\n+//! //==>> specialize with `0`\n+//! []\n+//! ```\n+//!\n+//! The function `specialize(c, p)` takes a value constructor `c` and a pattern `p`, and returns 0\n+//! or more pattern-stacks. If `c` does not match the head constructor of `p`, it returns nothing;\n+//! otherwise if returns the fields of the constructor. This only returns more than one\n+//! pattern-stack if `p` has a pattern-only constructor.\n+//!\n+//! - Specializing for the wrong constructor returns nothing\n+//!\n+//!   `specialize(None, Some(p0)) := []`\n+//!\n+//! - Specializing for the correct constructor returns a single row with the fields\n+//!\n+//!   `specialize(Variant1, Variant1(p0, p1, p2)) := [[p0, p1, p2]]`\n+//!\n+//!   `specialize(Foo{..}, Foo { bar: p0, baz: p1 }) := [[p0, p1]]`\n+//!\n+//! - For or-patterns, we specialize each branch and concatenate the results\n+//!\n+//!   `specialize(c, p0 | p1) := specialize(c, p0) ++ specialize(c, p1)`\n+//!\n+//! - We treat the other pattern constructors as if they were a large or-pattern of all the\n+//!   possibilities:\n+//!\n+//!   `specialize(c, _) := specialize(c, Variant1(_) | Variant2(_, _) | ...)`\n+//!\n+//!   `specialize(c, 1..=100) := specialize(c, 1 | ... | 100)`\n+//!\n+//!   `specialize(c, [p0, .., p1]) := specialize(c, [p0, p1] | [p0, _, p1] | [p0, _, _, p1] | ...)`\n+//!\n+//! - If `c` is a pattern-only constructor, `specialize` is defined on a case-by-case basis. See\n+//!   the discussion about constructor splitting in [`super::deconstruct_pat`].\n+//!\n+//!\n+//! We then extend this function to work with pattern-stacks as input, by acting on the first\n+//! column and keeping the other columns untouched.\n+//!\n+//! Specialization for the whole matrix is done in [`Matrix::specialize_constructor`]. Note that\n+//! or-patterns in the first column are expanded before being stored in the matrix. Specialization\n+//! for a single patstack is done from a combination of [`Constructor::is_covered_by`] and\n+//! [`PatStack::pop_head_constructor`]. The internals of how it's done mostly live in the\n+//! [`Fields`] struct.\n+//!\n+//!\n+//! # Computing usefulness\n+//!\n+//! We now have all we need to compute usefulness. The inputs to usefulness are a list of\n+//! pattern-stacks `p_1 ... p_n` (one per row), and a new pattern_stack `q`. The paper and this\n+//! file calls the list of patstacks a _matrix_. They must all have the same number of columns and\n+//! the patterns in a given column must all have the same type. `usefulness` returns a (possibly\n+//! empty) list of witnesses of usefulness. These witnesses will also be pattern-stacks.\n+//!\n+//! - base case: `n_columns == 0`.\n+//!     Since a pattern-stack functions like a tuple of patterns, an empty one functions like the\n+//!     unit type. Thus `q` is useful iff there are no rows above it, i.e. if `n == 0`.\n+//!\n+//! - inductive case: `n_columns > 0`.\n+//!     We need a way to list the constructors we want to try. We will be more clever in the next\n+//!     section but for now assume we list all value constructors for the type of the first column.\n+//!\n+//!     - for each such ctor `c`:\n+//!\n+//!         - for each `q'` returned by `specialize(c, q)`:\n+//!\n+//!             - we compute `usefulness(specialize(c, p_1) ... specialize(c, p_n), q')`\n+//!\n+//!         - for each witness found, we revert specialization by pushing the constructor `c` on top.\n+//!\n+//!     - We return the concatenation of all the witnesses found, if any.\n+//!\n+//! Example:\n+//! ```\n+//! [Some(true)] // p_1\n+//! [None] // p_2\n+//! [Some(_)] // q\n+//! //==>> try `None`: `specialize(None, q)` returns nothing\n+//! //==>> try `Some`: `specialize(Some, q)` returns a single row\n+//! [true] // p_1'\n+//! [_] // q'\n+//! //==>> try `true`: `specialize(true, q')` returns a single row\n+//! [] // p_1''\n+//! [] // q''\n+//! //==>> base case; `n != 0` so `q''` is not useful.\n+//! //==>> go back up a step\n+//! [true] // p_1'\n+//! [_] // q'\n+//! //==>> try `false`: `specialize(false, q')` returns a single row\n+//! [] // q''\n+//! //==>> base case; `n == 0` so `q''` is useful. We return the single witness `[]`\n+//! witnesses:\n+//! []\n+//! //==>> undo the specialization with `false`\n+//! witnesses:\n+//! [false]\n+//! //==>> undo the specialization with `Some`\n+//! witnesses:\n+//! [Some(false)]\n+//! //==>> we have tried all the constructors. The output is the single witness `[Some(false)]`.\n+//! ```\n+//!\n+//! This computation is done in [`is_useful`]. In practice we don't care about the list of\n+//! witnesses when computing reachability; we only need to know whether any exist. We do keep the\n+//! witnesses when computing exhaustiveness to report them to the user.\n+//!\n+//!\n+//! # Making usefulness tractable: constructor splitting\n+//!\n+//! We're missing one last detail: which constructors do we list? Naively listing all value\n+//! constructors cannot work for types like `u64` or `&str`, so we need to be more clever. The\n+//! first obvious insight is that we only want to list constructors that are covered by the head\n+//! constructor of `q`. If it's a value constructor, we only try that one. If it's a pattern-only\n+//! constructor, we use the final clever idea for this algorithm: _constructor splitting_, where we\n+//! group together constructors that behave the same.\n+//!\n+//! The details are not necessary to understand this file, so we explain them in\n+//! [`super::deconstruct_pat`]. Splitting is done by the [`Constructor::split`] function.\n+\n+use std::{cell::RefCell, iter::FromIterator};\n+\n+use hir_def::{expr::ExprId, HasModule, ModuleId};\n+use la_arena::Arena;\n+use once_cell::unsync::OnceCell;\n+use rustc_hash::FxHashMap;\n+use smallvec::{smallvec, SmallVec};\n+\n+use crate::{db::HirDatabase, InferenceResult, Interner, Ty};\n+\n+use super::{\n+    deconstruct_pat::{Constructor, Fields, SplitWildcard},\n+    Pat, PatId, PatKind, PatternFoldable, PatternFolder,\n+};\n+\n+use self::{helper::PatIdExt, Usefulness::*, WitnessPreference::*};\n+\n+pub(crate) struct MatchCheckCtx<'a> {\n+    pub(crate) module: ModuleId,\n+    pub(crate) match_expr: ExprId,\n+    pub(crate) infer: &'a InferenceResult,\n+    pub(crate) db: &'a dyn HirDatabase,\n+    /// Lowered patterns from arms plus generated by the check.\n+    pub(crate) pattern_arena: &'a RefCell<PatternArena>,\n+    pub(crate) eprint_panic_context: &'a dyn Fn(),\n+}\n+\n+impl<'a> MatchCheckCtx<'a> {\n+    pub(super) fn is_uninhabited(&self, _ty: &Ty) -> bool {\n+        // FIXME(iDawer) implement exhaustive_patterns feature. More info in:\n+        // Tracking issue for RFC 1872: exhaustive_patterns feature https://github.com/rust-lang/rust/issues/51085\n+        false\n+    }\n+\n+    /// Returns whether the given type is an enum from another crate declared `#[non_exhaustive]`.\n+    pub(super) fn is_foreign_non_exhaustive_enum(&self, enum_id: hir_def::EnumId) -> bool {\n+        let has_non_exhaustive_attr =\n+            self.db.attrs(enum_id.into()).by_key(\"non_exhaustive\").exists();\n+        let is_local =\n+            hir_def::AdtId::from(enum_id).module(self.db.upcast()).krate() == self.module.krate();\n+        has_non_exhaustive_attr && !is_local\n+    }\n+\n+    // Rust feature described as \"Allows exhaustive pattern matching on types that contain uninhabited types.\"\n+    pub(super) fn feature_exhaustive_patterns(&self) -> bool {\n+        // FIXME see MatchCheckCtx::is_uninhabited\n+        false\n+    }\n+\n+    pub(super) fn alloc_pat(&self, pat: Pat) -> PatId {\n+        self.pattern_arena.borrow_mut().alloc(pat)\n+    }\n+\n+    /// Get type of a pattern. Handles expanded patterns.\n+    pub(super) fn type_of(&self, pat: PatId) -> Ty {\n+        self.pattern_arena.borrow()[pat].ty.clone()\n+    }\n+\n+    #[track_caller]\n+    pub(super) fn bug(&self, info: &str) -> ! {\n+        (self.eprint_panic_context)();\n+        panic!(\"bug: {}\", info);\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+pub(super) struct PatCtxt<'a> {\n+    pub(super) cx: &'a MatchCheckCtx<'a>,\n+    /// Type of the current column under investigation.\n+    pub(super) ty: &'a Ty,\n+    /// Whether the current pattern is the whole pattern as found in a match arm, or if it's a\n+    /// subpattern.\n+    pub(super) is_top_level: bool,\n+}\n+\n+pub(crate) fn expand_pattern(pat: Pat) -> Pat {\n+    LiteralExpander.fold_pattern(&pat)\n+}\n+\n+struct LiteralExpander;\n+\n+impl PatternFolder for LiteralExpander {\n+    fn fold_pattern(&mut self, pat: &Pat) -> Pat {\n+        match (pat.ty.kind(&Interner), pat.kind.as_ref()) {\n+            (_, PatKind::Binding { subpattern: Some(s), .. }) => s.fold_with(self),\n+            _ => pat.super_fold_with(self),\n+        }\n+    }\n+}\n+\n+impl Pat {\n+    fn _is_wildcard(&self) -> bool {\n+        matches!(*self.kind, PatKind::Binding { subpattern: None, .. } | PatKind::Wild)\n+    }\n+}\n+\n+impl PatIdExt for PatId {\n+    fn is_or_pat(self, cx: &MatchCheckCtx<'_>) -> bool {\n+        matches!(*cx.pattern_arena.borrow()[self].kind, PatKind::Or { .. })\n+    }\n+\n+    /// Recursively expand this pattern into its subpatterns. Only useful for or-patterns.\n+    fn expand_or_pat(self, cx: &MatchCheckCtx<'_>) -> Vec<Self> {\n+        fn expand(pat: PatId, vec: &mut Vec<PatId>, pat_arena: &mut PatternArena) {\n+            if let PatKind::Or { pats } = pat_arena[pat].kind.as_ref() {\n+                // FIXME(iDawer): Factor out pattern deep cloning. See discussion:\n+                // https://github.com/rust-analyzer/rust-analyzer/pull/8717#discussion_r633086640\n+                let pats = pats.clone();\n+                for pat in pats {\n+                    let pat = pat_arena.alloc(pat.clone());\n+                    expand(pat, vec, pat_arena);\n+                }\n+            } else {\n+                vec.push(pat)\n+            }\n+        }\n+\n+        let mut pat_arena = cx.pattern_arena.borrow_mut();\n+        let mut pats = Vec::new();\n+        expand(self, &mut pats, &mut pat_arena);\n+        pats\n+    }\n+}\n+\n+/// A row of a matrix. Rows of len 1 are very common, which is why `SmallVec[_; 2]`\n+/// works well.\n+#[derive(Clone)]\n+pub(super) struct PatStack {\n+    pats: SmallVec<[PatId; 2]>,\n+    /// Cache for the constructor of the head\n+    head_ctor: OnceCell<Constructor>,\n+}\n+\n+impl PatStack {\n+    fn from_pattern(pat: PatId) -> Self {\n+        Self::from_vec(smallvec![pat])\n+    }\n+\n+    fn from_vec(vec: SmallVec<[PatId; 2]>) -> Self {\n+        PatStack { pats: vec, head_ctor: OnceCell::new() }\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.pats.is_empty()\n+    }\n+\n+    fn len(&self) -> usize {\n+        self.pats.len()\n+    }\n+\n+    fn head(&self) -> PatId {\n+        self.pats[0]\n+    }\n+\n+    #[inline]\n+    fn head_ctor(&self, cx: &MatchCheckCtx<'_>) -> &Constructor {\n+        self.head_ctor.get_or_init(|| Constructor::from_pat(cx, self.head()))\n+    }\n+\n+    // Recursively expand the first pattern into its subpatterns. Only useful if the pattern is an\n+    // or-pattern. Panics if `self` is empty.\n+    fn expand_or_pat(&self, cx: &MatchCheckCtx<'_>) -> impl Iterator<Item = PatStack> + '_ {\n+        self.head().expand_or_pat(cx).into_iter().map(move |pat| {\n+            let mut new_patstack = PatStack::from_pattern(pat);\n+            new_patstack.pats.extend_from_slice(&self.pats[1..]);\n+            new_patstack\n+        })\n+    }\n+\n+    /// This computes `S(self.head_ctor(), self)`. See top of the file for explanations.\n+    ///\n+    /// Structure patterns with a partial wild pattern (Foo { a: 42, .. }) have their missing\n+    /// fields filled with wild patterns.\n+    ///\n+    /// This is roughly the inverse of `Constructor::apply`.\n+    fn pop_head_constructor(\n+        &self,\n+        ctor_wild_subpatterns: &Fields,\n+        cx: &MatchCheckCtx<'_>,\n+    ) -> PatStack {\n+        // We pop the head pattern and push the new fields extracted from the arguments of\n+        // `self.head()`.\n+        let mut new_fields =\n+            ctor_wild_subpatterns.replace_with_pattern_arguments(self.head(), cx).into_patterns();\n+        new_fields.extend_from_slice(&self.pats[1..]);\n+        PatStack::from_vec(new_fields)\n+    }\n+}\n+\n+impl Default for PatStack {\n+    fn default() -> Self {\n+        Self::from_vec(smallvec![])\n+    }\n+}\n+\n+impl PartialEq for PatStack {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.pats == other.pats\n+    }\n+}\n+\n+impl FromIterator<PatId> for PatStack {\n+    fn from_iter<T>(iter: T) -> Self\n+    where\n+        T: IntoIterator<Item = PatId>,\n+    {\n+        Self::from_vec(iter.into_iter().collect())\n+    }\n+}\n+\n+/// A 2D matrix.\n+#[derive(Clone)]\n+pub(super) struct Matrix {\n+    patterns: Vec<PatStack>,\n+}\n+\n+impl Matrix {\n+    fn empty() -> Self {\n+        Matrix { patterns: vec![] }\n+    }\n+\n+    /// Number of columns of this matrix. `None` is the matrix is empty.\n+    pub(super) fn _column_count(&self) -> Option<usize> {\n+        self.patterns.get(0).map(|r| r.len())\n+    }\n+\n+    /// Pushes a new row to the matrix. If the row starts with an or-pattern, this recursively\n+    /// expands it.\n+    fn push(&mut self, row: PatStack, cx: &MatchCheckCtx<'_>) {\n+        if !row.is_empty() && row.head().is_or_pat(cx) {\n+            for row in row.expand_or_pat(cx) {\n+                self.patterns.push(row);\n+            }\n+        } else {\n+            self.patterns.push(row);\n+        }\n+    }\n+\n+    /// Iterate over the first component of each row\n+    fn heads(&self) -> impl Iterator<Item = PatId> + '_ {\n+        self.patterns.iter().map(|r| r.head())\n+    }\n+\n+    /// Iterate over the first constructor of each row.\n+    fn head_ctors<'a>(\n+        &'a self,\n+        cx: &'a MatchCheckCtx<'_>,\n+    ) -> impl Iterator<Item = &'a Constructor> + Clone {\n+        self.patterns.iter().map(move |r| r.head_ctor(cx))\n+    }\n+\n+    /// This computes `S(constructor, self)`. See top of the file for explanations.\n+    fn specialize_constructor(\n+        &self,\n+        pcx: PatCtxt<'_>,\n+        ctor: &Constructor,\n+        ctor_wild_subpatterns: &Fields,\n+    ) -> Matrix {\n+        let rows = self\n+            .patterns\n+            .iter()\n+            .filter(|r| ctor.is_covered_by(pcx, r.head_ctor(pcx.cx)))\n+            .map(|r| r.pop_head_constructor(ctor_wild_subpatterns, pcx.cx));\n+        Matrix::from_iter(rows, pcx.cx)\n+    }\n+\n+    fn from_iter(rows: impl IntoIterator<Item = PatStack>, cx: &MatchCheckCtx<'_>) -> Matrix {\n+        let mut matrix = Matrix::empty();\n+        for x in rows {\n+            // Using `push` ensures we correctly expand or-patterns.\n+            matrix.push(x, cx);\n+        }\n+        matrix\n+    }\n+}\n+\n+/// Given a pattern or a pattern-stack, this struct captures a set of its subpatterns. We use that\n+/// to track reachable sub-patterns arising from or-patterns. In the absence of or-patterns this\n+/// will always be either `Empty` (the whole pattern is unreachable) or `Full` (the whole pattern\n+/// is reachable). When there are or-patterns, some subpatterns may be reachable while others\n+/// aren't. In this case the whole pattern still counts as reachable, but we will lint the\n+/// unreachable subpatterns.\n+///\n+/// This supports a limited set of operations, so not all possible sets of subpatterns can be\n+/// represented. That's ok, we only want the ones that make sense for our usage.\n+///\n+/// What we're doing is illustrated by this:\n+/// ```\n+/// match (true, 0) {\n+///     (true, 0) => {}\n+///     (_, 1) => {}\n+///     (true | false, 0 | 1) => {}\n+/// }\n+/// ```\n+/// When we try the alternatives of the `true | false` or-pattern, the last `0` is reachable in the\n+/// `false` alternative but not the `true`. So overall it is reachable. By contrast, the last `1`\n+/// is not reachable in either alternative, so we want to signal this to the user.\n+/// Therefore we take the union of sets of reachable patterns coming from different alternatives in\n+/// order to figure out which subpatterns are overall reachable.\n+///\n+/// Invariant: we try to construct the smallest representation we can. In particular if\n+/// `self.is_empty()` we ensure that `self` is `Empty`, and same with `Full`. This is not important\n+/// for correctness currently.\n+#[derive(Debug, Clone)]\n+enum SubPatSet {\n+    /// The empty set. This means the pattern is unreachable.\n+    Empty,\n+    /// The set containing the full pattern.\n+    Full,\n+    /// If the pattern is a pattern with a constructor or a pattern-stack, we store a set for each\n+    /// of its subpatterns. Missing entries in the map are implicitly full, because that's the\n+    /// common case.\n+    Seq { subpats: FxHashMap<usize, SubPatSet> },\n+    /// If the pattern is an or-pattern, we store a set for each of its alternatives. Missing\n+    /// entries in the map are implicitly empty. Note: we always flatten nested or-patterns.\n+    Alt {\n+        subpats: FxHashMap<usize, SubPatSet>,\n+        /// Counts the total number of alternatives in the pattern\n+        alt_count: usize,\n+        /// We keep the pattern around to retrieve spans.\n+        pat: PatId,\n+    },\n+}\n+\n+impl SubPatSet {\n+    fn full() -> Self {\n+        SubPatSet::Full\n+    }\n+\n+    fn empty() -> Self {\n+        SubPatSet::Empty\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        match self {\n+            SubPatSet::Empty => true,\n+            SubPatSet::Full => false,\n+            // If any subpattern in a sequence is unreachable, the whole pattern is unreachable.\n+            SubPatSet::Seq { subpats } => subpats.values().any(|set| set.is_empty()),\n+            // An or-pattern is reachable if any of its alternatives is.\n+            SubPatSet::Alt { subpats, .. } => subpats.values().all(|set| set.is_empty()),\n+        }\n+    }\n+\n+    fn is_full(&self) -> bool {\n+        match self {\n+            SubPatSet::Empty => false,\n+            SubPatSet::Full => true,\n+            // The whole pattern is reachable only when all its alternatives are.\n+            SubPatSet::Seq { subpats } => subpats.values().all(|sub_set| sub_set.is_full()),\n+            // The whole or-pattern is reachable only when all its alternatives are.\n+            SubPatSet::Alt { subpats, alt_count, .. } => {\n+                subpats.len() == *alt_count && subpats.values().all(|set| set.is_full())\n+            }\n+        }\n+    }\n+\n+    /// Union `self` with `other`, mutating `self`.\n+    fn union(&mut self, other: Self) {\n+        use SubPatSet::*;\n+        // Union with full stays full; union with empty changes nothing.\n+        if self.is_full() || other.is_empty() {\n+            return;\n+        } else if self.is_empty() {\n+            *self = other;\n+            return;\n+        } else if other.is_full() {\n+            *self = Full;\n+            return;\n+        }\n+\n+        match (&mut *self, other) {\n+            (Seq { subpats: s_set }, Seq { subpats: mut o_set }) => {\n+                s_set.retain(|i, s_sub_set| {\n+                    // Missing entries count as full.\n+                    let o_sub_set = o_set.remove(&i).unwrap_or(Full);\n+                    s_sub_set.union(o_sub_set);\n+                    // We drop full entries.\n+                    !s_sub_set.is_full()\n+                });\n+                // Everything left in `o_set` is missing from `s_set`, i.e. counts as full. Since\n+                // unioning with full returns full, we can drop those entries.\n+            }\n+            (Alt { subpats: s_set, .. }, Alt { subpats: mut o_set, .. }) => {\n+                s_set.retain(|i, s_sub_set| {\n+                    // Missing entries count as empty.\n+                    let o_sub_set = o_set.remove(&i).unwrap_or(Empty);\n+                    s_sub_set.union(o_sub_set);\n+                    // We drop empty entries.\n+                    !s_sub_set.is_empty()\n+                });\n+                // Everything left in `o_set` is missing from `s_set`, i.e. counts as empty. Since\n+                // unioning with empty changes nothing, we can take those entries as is.\n+                s_set.extend(o_set);\n+            }\n+            _ => panic!(\"bug\"),\n+        }\n+\n+        if self.is_full() {\n+            *self = Full;\n+        }\n+    }\n+\n+    /// Returns a list of the unreachable subpatterns. If `self` is empty (i.e. the\n+    /// whole pattern is unreachable) we return `None`.\n+    fn list_unreachable_subpatterns(&self, cx: &MatchCheckCtx<'_>) -> Option<Vec<PatId>> {\n+        /// Panics if `set.is_empty()`.\n+        fn fill_subpats(\n+            set: &SubPatSet,\n+            unreachable_pats: &mut Vec<PatId>,\n+            cx: &MatchCheckCtx<'_>,\n+        ) {\n+            match set {\n+                SubPatSet::Empty => panic!(\"bug\"),\n+                SubPatSet::Full => {}\n+                SubPatSet::Seq { subpats } => {\n+                    for (_, sub_set) in subpats {\n+                        fill_subpats(sub_set, unreachable_pats, cx);\n+                    }\n+                }\n+                SubPatSet::Alt { subpats, pat, alt_count, .. } => {\n+                    let expanded = pat.expand_or_pat(cx);\n+                    for i in 0..*alt_count {\n+                        let sub_set = subpats.get(&i).unwrap_or(&SubPatSet::Empty);\n+                        if sub_set.is_empty() {\n+                            // Found a unreachable subpattern.\n+                            unreachable_pats.push(expanded[i]);\n+                        } else {\n+                            fill_subpats(sub_set, unreachable_pats, cx);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        if self.is_empty() {\n+            return None;\n+        }\n+        if self.is_full() {\n+            // No subpatterns are unreachable.\n+            return Some(Vec::new());\n+        }\n+        let mut unreachable_pats = Vec::new();\n+        fill_subpats(self, &mut unreachable_pats, cx);\n+        Some(unreachable_pats)\n+    }\n+\n+    /// When `self` refers to a patstack that was obtained from specialization, after running\n+    /// `unspecialize` it will refer to the original patstack before specialization.\n+    fn unspecialize(self, arity: usize) -> Self {\n+        use SubPatSet::*;\n+        match self {\n+            Full => Full,\n+            Empty => Empty,\n+            Seq { subpats } => {\n+                // We gather the first `arity` subpatterns together and shift the remaining ones.\n+                let mut new_subpats = FxHashMap::default();\n+                let mut new_subpats_first_col = FxHashMap::default();\n+                for (i, sub_set) in subpats {\n+                    if i < arity {\n+                        // The first `arity` indices are now part of the pattern in the first\n+                        // column.\n+                        new_subpats_first_col.insert(i, sub_set);\n+                    } else {\n+                        // Indices after `arity` are simply shifted\n+                        new_subpats.insert(i - arity + 1, sub_set);\n+                    }\n+                }\n+                // If `new_subpats_first_col` has no entries it counts as full, so we can omit it.\n+                if !new_subpats_first_col.is_empty() {\n+                    new_subpats.insert(0, Seq { subpats: new_subpats_first_col });\n+                }\n+                Seq { subpats: new_subpats }\n+            }\n+            Alt { .. } => panic!(\"bug\"), // `self` is a patstack\n+        }\n+    }\n+\n+    /// When `self` refers to a patstack that was obtained from splitting an or-pattern, after\n+    /// running `unspecialize` it will refer to the original patstack before splitting.\n+    ///\n+    /// For example:\n+    /// ```\n+    /// match Some(true) {\n+    ///     Some(true) => {}\n+    ///     None | Some(true | false) => {}\n+    /// }\n+    /// ```\n+    /// Here `None` would return the full set and `Some(true | false)` would return the set\n+    /// containing `false`. After `unsplit_or_pat`, we want the set to contain `None` and `false`.\n+    /// This is what this function does.\n+    fn unsplit_or_pat(mut self, alt_id: usize, alt_count: usize, pat: PatId) -> Self {\n+        use SubPatSet::*;\n+        if self.is_empty() {\n+            return Empty;\n+        }\n+\n+        // Subpatterns coming from inside the or-pattern alternative itself, e.g. in `None | Some(0\n+        // | 1)`.\n+        let set_first_col = match &mut self {\n+            Full => Full,\n+            Seq { subpats } => subpats.remove(&0).unwrap_or(Full),\n+            Empty => unreachable!(),\n+            Alt { .. } => panic!(\"bug\"), // `self` is a patstack\n+        };\n+        let mut subpats_first_col = FxHashMap::default();\n+        subpats_first_col.insert(alt_id, set_first_col);\n+        let set_first_col = Alt { subpats: subpats_first_col, pat, alt_count };\n+\n+        let mut subpats = match self {\n+            Full => FxHashMap::default(),\n+            Seq { subpats } => subpats,\n+            Empty => unreachable!(),\n+            Alt { .. } => panic!(\"bug\"), // `self` is a patstack\n+        };\n+        subpats.insert(0, set_first_col);\n+        Seq { subpats }\n+    }\n+}\n+\n+/// This carries the results of computing usefulness, as described at the top of the file. When\n+/// checking usefulness of a match branch, we use the `NoWitnesses` variant, which also keeps track\n+/// of potential unreachable sub-patterns (in the presence of or-patterns). When checking\n+/// exhaustiveness of a whole match, we use the `WithWitnesses` variant, which carries a list of\n+/// witnesses of non-exhaustiveness when there are any.\n+/// Which variant to use is dictated by `WitnessPreference`.\n+#[derive(Clone, Debug)]\n+enum Usefulness {\n+    /// Carries a set of subpatterns that have been found to be reachable. If empty, this indicates\n+    /// the whole pattern is unreachable. If not, this indicates that the pattern is reachable but\n+    /// that some sub-patterns may be unreachable (due to or-patterns). In the absence of\n+    /// or-patterns this will always be either `Empty` (the whole pattern is unreachable) or `Full`\n+    /// (the whole pattern is reachable).\n+    NoWitnesses(SubPatSet),\n+    /// Carries a list of witnesses of non-exhaustiveness. If empty, indicates that the whole\n+    /// pattern is unreachable.\n+    WithWitnesses(Vec<Witness>),\n+}\n+\n+impl Usefulness {\n+    fn new_useful(preference: WitnessPreference) -> Self {\n+        match preference {\n+            ConstructWitness => WithWitnesses(vec![Witness(vec![])]),\n+            LeaveOutWitness => NoWitnesses(SubPatSet::full()),\n+        }\n+    }\n+    fn new_not_useful(preference: WitnessPreference) -> Self {\n+        match preference {\n+            ConstructWitness => WithWitnesses(vec![]),\n+            LeaveOutWitness => NoWitnesses(SubPatSet::empty()),\n+        }\n+    }\n+\n+    /// Combine usefulnesses from two branches. This is an associative operation.\n+    fn extend(&mut self, other: Self) {\n+        match (&mut *self, other) {\n+            (WithWitnesses(_), WithWitnesses(o)) if o.is_empty() => {}\n+            (WithWitnesses(s), WithWitnesses(o)) if s.is_empty() => *self = WithWitnesses(o),\n+            (WithWitnesses(s), WithWitnesses(o)) => s.extend(o),\n+            (NoWitnesses(s), NoWitnesses(o)) => s.union(o),\n+            _ => unreachable!(),\n+        }\n+    }\n+\n+    /// When trying several branches and each returns a `Usefulness`, we need to combine the\n+    /// results together.\n+    fn merge(pref: WitnessPreference, usefulnesses: impl Iterator<Item = Self>) -> Self {\n+        let mut ret = Self::new_not_useful(pref);\n+        for u in usefulnesses {\n+            ret.extend(u);\n+            if let NoWitnesses(subpats) = &ret {\n+                if subpats.is_full() {\n+                    // Once we reach the full set, more unions won't change the result.\n+                    return ret;\n+                }\n+            }\n+        }\n+        ret\n+    }\n+\n+    /// After calculating the usefulness for a branch of an or-pattern, call this to make this\n+    /// usefulness mergeable with those from the other branches.\n+    fn unsplit_or_pat(self, alt_id: usize, alt_count: usize, pat: PatId) -> Self {\n+        match self {\n+            NoWitnesses(subpats) => NoWitnesses(subpats.unsplit_or_pat(alt_id, alt_count, pat)),\n+            WithWitnesses(_) => panic!(\"bug\"),\n+        }\n+    }\n+\n+    /// After calculating usefulness after a specialization, call this to recontruct a usefulness\n+    /// that makes sense for the matrix pre-specialization. This new usefulness can then be merged\n+    /// with the results of specializing with the other constructors.\n+    fn apply_constructor(\n+        self,\n+        pcx: PatCtxt<'_>,\n+        matrix: &Matrix,\n+        ctor: &Constructor,\n+        ctor_wild_subpatterns: &Fields,\n+    ) -> Self {\n+        match self {\n+            WithWitnesses(witnesses) if witnesses.is_empty() => WithWitnesses(witnesses),\n+            WithWitnesses(witnesses) => {\n+                let new_witnesses = if matches!(ctor, Constructor::Missing) {\n+                    let mut split_wildcard = SplitWildcard::new(pcx);\n+                    split_wildcard.split(pcx, matrix.head_ctors(pcx.cx));\n+                    // Construct for each missing constructor a \"wild\" version of this\n+                    // constructor, that matches everything that can be built with\n+                    // it. For example, if `ctor` is a `Constructor::Variant` for\n+                    // `Option::Some`, we get the pattern `Some(_)`.\n+                    let new_patterns: Vec<_> = split_wildcard\n+                        .iter_missing(pcx)\n+                        .map(|missing_ctor| {\n+                            Fields::wildcards(pcx, missing_ctor).apply(pcx, missing_ctor)\n+                        })\n+                        .collect();\n+                    witnesses\n+                        .into_iter()\n+                        .flat_map(|witness| {\n+                            new_patterns.iter().map(move |pat| {\n+                                let mut witness = witness.clone();\n+                                witness.0.push(pat.clone());\n+                                witness\n+                            })\n+                        })\n+                        .collect()\n+                } else {\n+                    witnesses\n+                        .into_iter()\n+                        .map(|witness| witness.apply_constructor(pcx, &ctor, ctor_wild_subpatterns))\n+                        .collect()\n+                };\n+                WithWitnesses(new_witnesses)\n+            }\n+            NoWitnesses(subpats) => NoWitnesses(subpats.unspecialize(ctor_wild_subpatterns.len())),\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+enum WitnessPreference {\n+    ConstructWitness,\n+    LeaveOutWitness,\n+}\n+\n+/// A witness of non-exhaustiveness for error reporting, represented\n+/// as a list of patterns (in reverse order of construction) with\n+/// wildcards inside to represent elements that can take any inhabitant\n+/// of the type as a value.\n+///\n+/// A witness against a list of patterns should have the same types\n+/// and length as the pattern matched against. Because Rust `match`\n+/// is always against a single pattern, at the end the witness will\n+/// have length 1, but in the middle of the algorithm, it can contain\n+/// multiple patterns.\n+///\n+/// For example, if we are constructing a witness for the match against\n+///\n+/// ```\n+/// struct Pair(Option<(u32, u32)>, bool);\n+///\n+/// match (p: Pair) {\n+///    Pair(None, _) => {}\n+///    Pair(_, false) => {}\n+/// }\n+/// ```\n+///\n+/// We'll perform the following steps:\n+/// 1. Start with an empty witness\n+///     `Witness(vec![])`\n+/// 2. Push a witness `true` against the `false`\n+///     `Witness(vec![true])`\n+/// 3. Push a witness `Some(_)` against the `None`\n+///     `Witness(vec![true, Some(_)])`\n+/// 4. Apply the `Pair` constructor to the witnesses\n+///     `Witness(vec![Pair(Some(_), true)])`\n+///\n+/// The final `Pair(Some(_), true)` is then the resulting witness.\n+#[derive(Clone, Debug)]\n+pub(crate) struct Witness(Vec<Pat>);\n+\n+impl Witness {\n+    /// Asserts that the witness contains a single pattern, and returns it.\n+    fn single_pattern(self) -> Pat {\n+        assert_eq!(self.0.len(), 1);\n+        self.0.into_iter().next().unwrap()\n+    }\n+\n+    /// Constructs a partial witness for a pattern given a list of\n+    /// patterns expanded by the specialization step.\n+    ///\n+    /// When a pattern P is discovered to be useful, this function is used bottom-up\n+    /// to reconstruct a complete witness, e.g., a pattern P' that covers a subset\n+    /// of values, V, where each value in that set is not covered by any previously\n+    /// used patterns and is covered by the pattern P'. Examples:\n+    ///\n+    /// left_ty: tuple of 3 elements\n+    /// pats: [10, 20, _]           => (10, 20, _)\n+    ///\n+    /// left_ty: struct X { a: (bool, &'static str), b: usize}\n+    /// pats: [(false, \"foo\"), 42]  => X { a: (false, \"foo\"), b: 42 }\n+    fn apply_constructor(\n+        mut self,\n+        pcx: PatCtxt<'_>,\n+        ctor: &Constructor,\n+        ctor_wild_subpatterns: &Fields,\n+    ) -> Self {\n+        let pat = {\n+            let len = self.0.len();\n+            let arity = ctor_wild_subpatterns.len();\n+            let pats = self.0.drain((len - arity)..).rev();\n+            ctor_wild_subpatterns.replace_fields(pcx.cx, pats).apply(pcx, ctor)\n+        };\n+\n+        self.0.push(pat);\n+\n+        self\n+    }\n+}\n+\n+/// Algorithm from <http://moscova.inria.fr/~maranget/papers/warn/index.html>.\n+/// The algorithm from the paper has been modified to correctly handle empty\n+/// types. The changes are:\n+///   (0) We don't exit early if the pattern matrix has zero rows. We just\n+///       continue to recurse over columns.\n+///   (1) all_constructors will only return constructors that are statically\n+///       possible. E.g., it will only return `Ok` for `Result<T, !>`.\n+///\n+/// This finds whether a (row) vector `v` of patterns is 'useful' in relation\n+/// to a set of such vectors `m` - this is defined as there being a set of\n+/// inputs that will match `v` but not any of the sets in `m`.\n+///\n+/// All the patterns at each column of the `matrix ++ v` matrix must have the same type.\n+///\n+/// This is used both for reachability checking (if a pattern isn't useful in\n+/// relation to preceding patterns, it is not reachable) and exhaustiveness\n+/// checking (if a wildcard pattern is useful in relation to a matrix, the\n+/// matrix isn't exhaustive).\n+///\n+/// `is_under_guard` is used to inform if the pattern has a guard. If it\n+/// has one it must not be inserted into the matrix. This shouldn't be\n+/// relied on for soundness.\n+fn is_useful(\n+    cx: &MatchCheckCtx<'_>,\n+    matrix: &Matrix,\n+    v: &PatStack,\n+    witness_preference: WitnessPreference,\n+    is_under_guard: bool,\n+    is_top_level: bool,\n+) -> Usefulness {\n+    let Matrix { patterns: rows, .. } = matrix;\n+\n+    // The base case. We are pattern-matching on () and the return value is\n+    // based on whether our matrix has a row or not.\n+    // NOTE: This could potentially be optimized by checking rows.is_empty()\n+    // first and then, if v is non-empty, the return value is based on whether\n+    // the type of the tuple we're checking is inhabited or not.\n+    if v.is_empty() {\n+        let ret = if rows.is_empty() {\n+            Usefulness::new_useful(witness_preference)\n+        } else {\n+            Usefulness::new_not_useful(witness_preference)\n+        };\n+        return ret;\n+    }\n+\n+    assert!(rows.iter().all(|r| r.len() == v.len()));\n+\n+    // FIXME(Nadrieril): Hack to work around type normalization issues (see rust-lang/rust#72476).\n+    let ty = matrix.heads().next().map_or(cx.type_of(v.head()), |r| cx.type_of(r));\n+    let pcx = PatCtxt { cx, ty: &ty, is_top_level };\n+\n+    // If the first pattern is an or-pattern, expand it.\n+    let ret = if v.head().is_or_pat(cx) {\n+        //expanding or-pattern\n+        let v_head = v.head();\n+        let vs: Vec<_> = v.expand_or_pat(cx).collect();\n+        let alt_count = vs.len();\n+        // We try each or-pattern branch in turn.\n+        let mut matrix = matrix.clone();\n+        let usefulnesses = vs.into_iter().enumerate().map(|(i, v)| {\n+            let usefulness = is_useful(cx, &matrix, &v, witness_preference, is_under_guard, false);\n+            // If pattern has a guard don't add it to the matrix.\n+            if !is_under_guard {\n+                // We push the already-seen patterns into the matrix in order to detect redundant\n+                // branches like `Some(_) | Some(0)`.\n+                matrix.push(v, cx);\n+            }\n+            usefulness.unsplit_or_pat(i, alt_count, v_head)\n+        });\n+        Usefulness::merge(witness_preference, usefulnesses)\n+    } else {\n+        let v_ctor = v.head_ctor(cx);\n+        // if let Constructor::IntRange(ctor_range) = v_ctor {\n+        //     // Lint on likely incorrect range patterns (#63987)\n+        //     ctor_range.lint_overlapping_range_endpoints(\n+        //         pcx,\n+        //         matrix.head_ctors_and_spans(cx),\n+        //         matrix.column_count().unwrap_or(0),\n+        //         hir_id,\n+        //     )\n+        // }\n+\n+        // We split the head constructor of `v`.\n+        let split_ctors = v_ctor.split(pcx, matrix.head_ctors(cx));\n+        // For each constructor, we compute whether there's a value that starts with it that would\n+        // witness the usefulness of `v`.\n+        let start_matrix = matrix;\n+        let usefulnesses = split_ctors.into_iter().map(|ctor| {\n+            // debug!(\"specialize({:?})\", ctor);\n+            // We cache the result of `Fields::wildcards` because it is used a lot.\n+            let ctor_wild_subpatterns = Fields::wildcards(pcx, &ctor);\n+            let spec_matrix =\n+                start_matrix.specialize_constructor(pcx, &ctor, &ctor_wild_subpatterns);\n+            let v = v.pop_head_constructor(&ctor_wild_subpatterns, cx);\n+            let usefulness =\n+                is_useful(cx, &spec_matrix, &v, witness_preference, is_under_guard, false);\n+            usefulness.apply_constructor(pcx, start_matrix, &ctor, &ctor_wild_subpatterns)\n+        });\n+        Usefulness::merge(witness_preference, usefulnesses)\n+    };\n+\n+    ret\n+}\n+\n+/// The arm of a match expression.\n+#[derive(Clone, Copy)]\n+pub(crate) struct MatchArm {\n+    pub(crate) pat: PatId,\n+    pub(crate) has_guard: bool,\n+}\n+\n+/// Indicates whether or not a given arm is reachable.\n+#[derive(Clone, Debug)]\n+pub(crate) enum Reachability {\n+    /// The arm is reachable. This additionally carries a set of or-pattern branches that have been\n+    /// found to be unreachable despite the overall arm being reachable. Used only in the presence\n+    /// of or-patterns, otherwise it stays empty.\n+    Reachable(Vec<PatId>),\n+    /// The arm is unreachable.\n+    Unreachable,\n+}\n+\n+/// The output of checking a match for exhaustiveness and arm reachability.\n+pub(crate) struct UsefulnessReport {\n+    /// For each arm of the input, whether that arm is reachable after the arms above it.\n+    pub(crate) _arm_usefulness: Vec<(MatchArm, Reachability)>,\n+    /// If the match is exhaustive, this is empty. If not, this contains witnesses for the lack of\n+    /// exhaustiveness.\n+    pub(crate) non_exhaustiveness_witnesses: Vec<Pat>,\n+}\n+\n+/// The entrypoint for the usefulness algorithm. Computes whether a match is exhaustive and which\n+/// of its arms are reachable.\n+///\n+/// Note: the input patterns must have been lowered through\n+/// `check_match::MatchVisitor::lower_pattern`.\n+pub(crate) fn compute_match_usefulness(\n+    cx: &MatchCheckCtx<'_>,\n+    arms: &[MatchArm],\n+) -> UsefulnessReport {\n+    let mut matrix = Matrix::empty();\n+    let arm_usefulness: Vec<_> = arms\n+        .iter()\n+        .copied()\n+        .map(|arm| {\n+            let v = PatStack::from_pattern(arm.pat);\n+            let usefulness = is_useful(cx, &matrix, &v, LeaveOutWitness, arm.has_guard, true);\n+            if !arm.has_guard {\n+                matrix.push(v, cx);\n+            }\n+            let reachability = match usefulness {\n+                NoWitnesses(subpats) if subpats.is_empty() => Reachability::Unreachable,\n+                NoWitnesses(subpats) => {\n+                    Reachability::Reachable(subpats.list_unreachable_subpatterns(cx).unwrap())\n+                }\n+                WithWitnesses(..) => panic!(\"bug\"),\n+            };\n+            (arm, reachability)\n+        })\n+        .collect();\n+\n+    let wild_pattern =\n+        cx.pattern_arena.borrow_mut().alloc(Pat::wildcard_from_ty(cx.infer[cx.match_expr].clone()));\n+    let v = PatStack::from_pattern(wild_pattern);\n+    let usefulness = is_useful(cx, &matrix, &v, ConstructWitness, false, true);\n+    let non_exhaustiveness_witnesses = match usefulness {\n+        WithWitnesses(pats) => pats.into_iter().map(Witness::single_pattern).collect(),\n+        NoWitnesses(_) => panic!(\"bug\"),\n+    };\n+    UsefulnessReport { _arm_usefulness: arm_usefulness, non_exhaustiveness_witnesses }\n+}\n+\n+pub(crate) type PatternArena = Arena<Pat>;\n+\n+mod helper {\n+    use super::MatchCheckCtx;\n+\n+    pub(super) trait PatIdExt: Sized {\n+        // fn is_wildcard(self, cx: &MatchCheckCtx<'_>) -> bool;\n+        fn is_or_pat(self, cx: &MatchCheckCtx<'_>) -> bool;\n+        fn expand_or_pat(self, cx: &MatchCheckCtx<'_>) -> Vec<Self>;\n+    }\n+\n+    // Copy-pasted from rust/compiler/rustc_data_structures/src/captures.rs\n+    /// \"Signaling\" trait used in impl trait to tag lifetimes that you may\n+    /// need to capture but don't really need for other reasons.\n+    /// Basically a workaround; see [this comment] for details.\n+    ///\n+    /// [this comment]: https://github.com/rust-lang/rust/issues/34511#issuecomment-373423999\n+    // FIXME(eddyb) false positive, the lifetime parameter is \"phantom\" but needed.\n+    #[allow(unused_lifetimes)]\n+    pub(crate) trait Captures<'a> {}\n+\n+    impl<'a, T: ?Sized> Captures<'a> for T {}\n+}"}]}