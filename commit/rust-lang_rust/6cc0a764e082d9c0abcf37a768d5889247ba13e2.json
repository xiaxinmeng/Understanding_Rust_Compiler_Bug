{"sha": "6cc0a764e082d9c0abcf37a768d5889247ba13e2", "node_id": "C_kwDOAAsO6NoAKDZjYzBhNzY0ZTA4MmQ5YzBhYmNmMzdhNzY4ZDU4ODkyNDdiYTEzZTI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-15T22:31:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-15T22:31:53Z"}, "message": "Auto merge of #85379 - mdaverde:uds-abstract, r=joshtriplett\n\nAdd abstract namespace support for Unix domain sockets\n\nHello! The other day I wanted to mess around with UDS in Rust and found that abstract namespaces ([unix(7)](https://man7.org/linux/man-pages/man7/unix.7.html)) on Linux still needed development. I took the approach of adding `_addr` specific public functions to reduce conflicts.\n\nFeature name: `unix_socket_abstract`\nTracking issue: #85410\nFurther context: #42048\n\n## Non-platform specific additions\n\n`UnixListener::bind_addr(&SocketAddr) -> Result<UnixListener>`\n\n`UnixStream::connect_addr(&SocketAddr) -> Result<()>`\n\n`UnixDatagram::bind_addr(&SocketAddr) -> Result<UnixDatagram>`\n\n`UnixDatagram::connect_addr(&SocketAddr) -> Result<()>`\n\n`UnixDatagram::send_to_addr(&self, &[u8], &SocketAddr) -> Result<usize>`\n\n## Platform-specific (Linux) additions\n\n`SocketAddr::from_abstract_namespace(&[u8]) -> SocketAddr`\n\n`SockerAddr::as_abstract_namespace() -> Option<&[u8]>`\n\n## Example\n\n```rust\n#![feature(unix_socket_abstract)]\nuse std::os::unix::net::{UnixListener, SocketAddr};\n\nfn main() -> std::io::Result<()> {\n    let addr = SocketAddr::from_abstract_namespace(b\"namespace\")?; // Linux only\n    let listener = match UnixListener::bind_addr(&addr) {\n        Ok(sock) => sock,\n        Err(err) => {\n            println!(\"Couldn't bind: {:?}\", err);\n            return Err(err);\n        }\n    };\n    Ok(())\n}\n```\n\n## Further Details\n\nThe main inspiration for the implementation came from the [nix-rust](https://github.com/nix-rust/nix/blob/master/src/sys/socket/addr.rs#L558) crate but there are also other [historical](https://github.com/rust-lang/rust/commit/c4db0685b181f12c4285dac3d932f1859bba74f5) [attempts](https://github.com/tormol/uds/blob/master/src/addr.rs#L324) with similar approaches.\n\nA comment I did have was with this change, we now allow a `SocketAddr` to be constructed explicitly rather than just used almost as a handle for the return of `peer_addr` and `local_addr`. We could consider adding other explicit constructors (e.g. `SocketAddr::from_pathname`, `SockerAddr::from_unnamed`).\n\nCheers!", "tree": {"sha": "c656fc92d3f26919a8c805cafe6ed7efed5a7156", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c656fc92d3f26919a8c805cafe6ed7efed5a7156"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6cc0a764e082d9c0abcf37a768d5889247ba13e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6cc0a764e082d9c0abcf37a768d5889247ba13e2", "html_url": "https://github.com/rust-lang/rust/commit/6cc0a764e082d9c0abcf37a768d5889247ba13e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6cc0a764e082d9c0abcf37a768d5889247ba13e2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1026539bd22e9d070988deaa47b1360cbc76436", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1026539bd22e9d070988deaa47b1360cbc76436", "html_url": "https://github.com/rust-lang/rust/commit/c1026539bd22e9d070988deaa47b1360cbc76436"}, {"sha": "15b119897c40cbc76f5e1c65370930773dfdc741", "url": "https://api.github.com/repos/rust-lang/rust/commits/15b119897c40cbc76f5e1c65370930773dfdc741", "html_url": "https://github.com/rust-lang/rust/commit/15b119897c40cbc76f5e1c65370930773dfdc741"}], "stats": {"total": 420, "additions": 416, "deletions": 4}, "files": [{"sha": "887f605993918da58f6c156882f96c27be843744", "filename": "library/std/src/os/unix/net/addr.rs", "status": "modified", "additions": 86, "deletions": 2, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/6cc0a764e082d9c0abcf37a768d5889247ba13e2/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cc0a764e082d9c0abcf37a768d5889247ba13e2/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Faddr.rs?ref=6cc0a764e082d9c0abcf37a768d5889247ba13e2", "patch": "@@ -92,8 +92,8 @@ impl<'a> fmt::Display for AsciiEscaped<'a> {\n #[derive(Clone)]\n #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n pub struct SocketAddr {\n-    addr: libc::sockaddr_un,\n-    len: libc::socklen_t,\n+    pub(super) addr: libc::sockaddr_un,\n+    pub(super) len: libc::socklen_t,\n }\n \n impl SocketAddr {\n@@ -198,6 +198,31 @@ impl SocketAddr {\n         if let AddressKind::Pathname(path) = self.address() { Some(path) } else { None }\n     }\n \n+    /// Returns the contents of this address if it is an abstract namespace\n+    /// without the leading null byte.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_abstract)]\n+    /// use std::os::unix::net::{UnixListener, SocketAddr};\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let namespace = b\"hidden\";\n+    ///     let namespace_addr = SocketAddr::from_abstract_namespace(&namespace[..])?;\n+    ///     let socket = UnixListener::bind_addr(&namespace_addr)?;\n+    ///     let local_addr = socket.local_addr().expect(\"Couldn't get local address\");\n+    ///     assert_eq!(local_addr.as_abstract_namespace(), Some(&namespace[..]));\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[doc(cfg(any(target_os = \"android\", target_os = \"linux\")))]\n+    #[cfg(any(doc, target_os = \"android\", target_os = \"linux\",))]\n+    #[unstable(feature = \"unix_socket_abstract\", issue = \"85410\")]\n+    pub fn as_abstract_namespace(&self) -> Option<&[u8]> {\n+        if let AddressKind::Abstract(name) = self.address() { Some(name) } else { None }\n+    }\n+\n     fn address(&self) -> AddressKind<'_> {\n         let len = self.len as usize - sun_path_offset(&self.addr);\n         let path = unsafe { mem::transmute::<&[libc::c_char], &[u8]>(&self.addr.sun_path) };\n@@ -214,6 +239,65 @@ impl SocketAddr {\n             AddressKind::Pathname(OsStr::from_bytes(&path[..len - 1]).as_ref())\n         }\n     }\n+\n+    /// Creates an abstract domain socket address from a namespace\n+    ///\n+    /// An abstract address does not create a file unlike traditional path-based\n+    /// Unix sockets. The advantage of this is that the address will disappear when\n+    /// the socket bound to it is closed, so no filesystem clean up is required.\n+    ///\n+    /// The leading null byte for the abstract namespace is automatically added.\n+    ///\n+    /// This is a Linux-specific extension. See more at [`unix(7)`].\n+    ///\n+    /// [`unix(7)`]: https://man7.org/linux/man-pages/man7/unix.7.html\n+    ///\n+    /// # Errors\n+    ///\n+    /// This will return an error if the given namespace is too long\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_abstract)]\n+    /// use std::os::unix::net::{UnixListener, SocketAddr};\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let addr = SocketAddr::from_abstract_namespace(b\"hidden\")?;\n+    ///     let listener = match UnixListener::bind_addr(&addr) {\n+    ///         Ok(sock) => sock,\n+    ///         Err(err) => {\n+    ///             println!(\"Couldn't bind: {:?}\", err);\n+    ///             return Err(err);\n+    ///         }\n+    ///     };\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[doc(cfg(any(target_os = \"android\", target_os = \"linux\")))]\n+    #[cfg(any(doc, target_os = \"android\", target_os = \"linux\",))]\n+    #[unstable(feature = \"unix_socket_abstract\", issue = \"85410\")]\n+    pub fn from_abstract_namespace(namespace: &[u8]) -> io::Result<SocketAddr> {\n+        unsafe {\n+            let mut addr: libc::sockaddr_un = mem::zeroed();\n+            addr.sun_family = libc::AF_UNIX as libc::sa_family_t;\n+\n+            if namespace.len() + 1 > addr.sun_path.len() {\n+                return Err(io::Error::new_const(\n+                    io::ErrorKind::InvalidInput,\n+                    &\"namespace must be shorter than SUN_LEN\",\n+                ));\n+            }\n+\n+            crate::ptr::copy_nonoverlapping(\n+                namespace.as_ptr(),\n+                addr.sun_path.as_mut_ptr().offset(1) as *mut u8,\n+                namespace.len(),\n+            );\n+            let len = (sun_path_offset(&addr) + 1 + namespace.len()) as libc::socklen_t;\n+            SocketAddr::from_parts(addr, len)\n+        }\n+    }\n }\n \n #[stable(feature = \"unix_socket\", since = \"1.10.0\")]"}, {"sha": "a2caccc7849170f5ae3e8f68bea8ee2fb1b7ade3", "filename": "library/std/src/os/unix/net/datagram.rs", "status": "modified", "additions": 107, "deletions": 1, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/6cc0a764e082d9c0abcf37a768d5889247ba13e2/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fdatagram.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cc0a764e082d9c0abcf37a768d5889247ba13e2/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fdatagram.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fdatagram.rs?ref=6cc0a764e082d9c0abcf37a768d5889247ba13e2", "patch": "@@ -112,6 +112,41 @@ impl UnixDatagram {\n         }\n     }\n \n+    /// Creates a Unix datagram socket bound to an address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_abstract)]\n+    /// use std::os::unix::net::{UnixDatagram};\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock1 = UnixDatagram::bind(\"path/to/socket\")?;\n+    ///     let addr = sock1.local_addr()?;\n+    ///\n+    ///     let sock2 = match UnixDatagram::bind_addr(&addr) {\n+    ///         Ok(sock) => sock,\n+    ///         Err(err) => {\n+    ///             println!(\"Couldn't bind: {:?}\", err);\n+    ///             return Err(err);\n+    ///         }\n+    ///     };\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"unix_socket_abstract\", issue = \"85410\")]\n+    pub fn bind_addr(socket_addr: &SocketAddr) -> io::Result<UnixDatagram> {\n+        unsafe {\n+            let socket = UnixDatagram::unbound()?;\n+            cvt(libc::bind(\n+                socket.as_raw_fd(),\n+                &socket_addr.addr as *const _ as *const _,\n+                socket_addr.len as _,\n+            ))?;\n+            Ok(socket)\n+        }\n+    }\n+\n     /// Creates a Unix Datagram socket which is not bound to any address.\n     ///\n     /// # Examples\n@@ -156,7 +191,7 @@ impl UnixDatagram {\n         Ok((UnixDatagram(i1), UnixDatagram(i2)))\n     }\n \n-    /// Connects the socket to the specified address.\n+    /// Connects the socket to the specified path address.\n     ///\n     /// The [`send`] method may be used to send data to the specified address.\n     /// [`recv`] and [`recv_from`] will only receive data from that address.\n@@ -192,6 +227,41 @@ impl UnixDatagram {\n         Ok(())\n     }\n \n+    /// Connects the socket to an address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_abstract)]\n+    /// use std::os::unix::net::{UnixDatagram};\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let bound = UnixDatagram::bind(\"/path/to/socket\")?;\n+    ///     let addr = bound.local_addr()?;\n+    ///\n+    ///     let sock = UnixDatagram::unbound()?;\n+    ///     match sock.connect_addr(&addr) {\n+    ///         Ok(sock) => sock,\n+    ///         Err(e) => {\n+    ///             println!(\"Couldn't connect: {:?}\", e);\n+    ///             return Err(e)\n+    ///         }\n+    ///     };\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"unix_socket_abstract\", issue = \"85410\")]\n+    pub fn connect_addr(&self, socket_addr: &SocketAddr) -> io::Result<()> {\n+        unsafe {\n+            cvt(libc::connect(\n+                self.as_raw_fd(),\n+                &socket_addr.addr as *const _ as *const _,\n+                socket_addr.len,\n+            ))?;\n+        }\n+        Ok(())\n+    }\n+\n     /// Creates a new independently owned handle to the underlying socket.\n     ///\n     /// The returned `UnixDatagram` is a reference to the same socket that this\n@@ -473,6 +543,42 @@ impl UnixDatagram {\n         }\n     }\n \n+    /// Sends data on the socket to the specified [SocketAddr].\n+    ///\n+    /// On success, returns the number of bytes written.\n+    ///\n+    /// [SocketAddr]: crate::os::unix::net::SocketAddr\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_abstract)]\n+    /// use std::os::unix::net::{UnixDatagram};\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let bound = UnixDatagram::bind(\"/path/to/socket\")?;\n+    ///     let addr = bound.local_addr()?;\n+    ///\n+    ///     let sock = UnixDatagram::unbound()?;\n+    ///     sock.send_to_addr(b\"bacon egg and cheese\", &addr).expect(\"send_to_addr function failed\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"unix_socket_abstract\", issue = \"85410\")]\n+    pub fn send_to_addr(&self, buf: &[u8], socket_addr: &SocketAddr) -> io::Result<usize> {\n+        unsafe {\n+            let count = cvt(libc::sendto(\n+                self.as_raw_fd(),\n+                buf.as_ptr() as *const _,\n+                buf.len(),\n+                MSG_NOSIGNAL,\n+                &socket_addr.addr as *const _ as *const _,\n+                socket_addr.len,\n+            ))?;\n+            Ok(count as usize)\n+        }\n+    }\n+\n     /// Sends data on the socket to the socket's peer.\n     ///\n     /// The peer address may be set by the `connect` method, and this method"}, {"sha": "97348afe7de12823e7c8e9388c15ac84b0290283", "filename": "library/std/src/os/unix/net/listener.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6cc0a764e082d9c0abcf37a768d5889247ba13e2/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Flistener.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cc0a764e082d9c0abcf37a768d5889247ba13e2/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Flistener.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Flistener.rs?ref=6cc0a764e082d9c0abcf37a768d5889247ba13e2", "patch": "@@ -81,6 +81,44 @@ impl UnixListener {\n         }\n     }\n \n+    /// Creates a new `UnixListener` bound to the specified [`socket address`].\n+    ///\n+    /// [`socket address`]: crate::os::unix::net::SocketAddr\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_abstract)]\n+    /// use std::os::unix::net::{UnixListener};\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let listener1 = UnixListener::bind(\"path/to/socket\")?;\n+    ///     let addr = listener1.local_addr()?;\n+    ///\n+    ///     let listener2 = match UnixListener::bind_addr(&addr) {\n+    ///         Ok(sock) => sock,\n+    ///         Err(err) => {\n+    ///             println!(\"Couldn't bind: {:?}\", err);\n+    ///             return Err(err);\n+    ///         }\n+    ///     };\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"unix_socket_abstract\", issue = \"85410\")]\n+    pub fn bind_addr(socket_addr: &SocketAddr) -> io::Result<UnixListener> {\n+        unsafe {\n+            let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_STREAM)?;\n+            cvt(libc::bind(\n+                inner.as_raw_fd(),\n+                &socket_addr.addr as *const _ as *const _,\n+                socket_addr.len as _,\n+            ))?;\n+            cvt(libc::listen(inner.as_raw_fd(), 128))?;\n+            Ok(UnixListener(inner))\n+        }\n+    }\n+\n     /// Accepts a new incoming connection to this listener.\n     ///\n     /// This function will block the calling thread until a new Unix connection"}, {"sha": "6120d557227afba8d7940a67232e92dfc0fc82a0", "filename": "library/std/src/os/unix/net/stream.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6cc0a764e082d9c0abcf37a768d5889247ba13e2/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cc0a764e082d9c0abcf37a768d5889247ba13e2/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fstream.rs?ref=6cc0a764e082d9c0abcf37a768d5889247ba13e2", "patch": "@@ -106,6 +106,43 @@ impl UnixStream {\n         }\n     }\n \n+    /// Connects to the socket specified by [`address`].\n+    ///\n+    /// [`address`]: crate::os::unix::net::SocketAddr\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_abstract)]\n+    /// use std::os::unix::net::{UnixListener, UnixStream};\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let listener = UnixListener::bind(\"/path/to/the/socket\")?;\n+    ///     let addr = listener.local_addr()?;\n+    ///\n+    ///     let sock = match UnixStream::connect_addr(&addr) {\n+    ///         Ok(sock) => sock,\n+    ///         Err(e) => {\n+    ///             println!(\"Couldn't connect: {:?}\", e);\n+    ///             return Err(e)\n+    ///         }\n+    ///     };\n+    ///     Ok(())\n+    /// }\n+    /// ````\n+    #[unstable(feature = \"unix_socket_abstract\", issue = \"85410\")]\n+    pub fn connect_addr(socket_addr: &SocketAddr) -> io::Result<UnixStream> {\n+        unsafe {\n+            let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_STREAM)?;\n+            cvt(libc::connect(\n+                inner.as_raw_fd(),\n+                &socket_addr.addr as *const _ as *const _,\n+                socket_addr.len,\n+            ))?;\n+            Ok(UnixStream(inner))\n+        }\n+    }\n+\n     /// Creates an unnamed pair of connected sockets.\n     ///\n     /// Returns two `UnixStream`s which are connected to each other."}, {"sha": "7ad4a02611e0726a05f889affb57cbd2230ee5e6", "filename": "library/std/src/os/unix/net/tests.rs", "status": "modified", "additions": 148, "deletions": 1, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/6cc0a764e082d9c0abcf37a768d5889247ba13e2/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cc0a764e082d9c0abcf37a768d5889247ba13e2/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Ftests.rs?ref=6cc0a764e082d9c0abcf37a768d5889247ba13e2", "patch": "@@ -303,6 +303,30 @@ fn test_unnamed_unix_datagram() {\n     assert_eq!(msg, &buf[..]);\n }\n \n+#[test]\n+fn test_unix_datagram_connect_to_recv_addr() {\n+    let dir = tmpdir();\n+    let path1 = dir.path().join(\"sock1\");\n+    let path2 = dir.path().join(\"sock2\");\n+\n+    let sock1 = or_panic!(UnixDatagram::bind(&path1));\n+    let sock2 = or_panic!(UnixDatagram::bind(&path2));\n+\n+    let msg = b\"hello world\";\n+    let sock1_addr = or_panic!(sock1.local_addr());\n+    or_panic!(sock2.send_to_addr(msg, &sock1_addr));\n+    let mut buf = [0; 11];\n+    let (_, addr) = or_panic!(sock1.recv_from(&mut buf));\n+\n+    let new_msg = b\"hello back\";\n+    let mut new_buf = [0; 10];\n+    or_panic!(sock2.connect_addr(&addr));\n+    or_panic!(sock2.send(new_msg)); // set by connect_addr\n+    let usize = or_panic!(sock2.recv(&mut new_buf));\n+    assert_eq!(usize, 10);\n+    assert_eq!(new_msg, &new_buf[..]);\n+}\n+\n #[test]\n fn test_connect_unix_datagram() {\n     let dir = tmpdir();\n@@ -388,10 +412,133 @@ fn test_unix_datagram_timeout_zero_duration() {\n }\n \n #[test]\n-fn abstract_namespace_not_allowed() {\n+fn abstract_namespace_not_allowed_connect() {\n     assert!(UnixStream::connect(\"\\0asdf\").is_err());\n }\n \n+#[cfg(any(target_os = \"android\", target_os = \"linux\"))]\n+#[test]\n+fn test_abstract_stream_connect() {\n+    let msg1 = b\"hello\";\n+    let msg2 = b\"world\";\n+\n+    let socket_addr = or_panic!(SocketAddr::from_abstract_namespace(b\"namespace\"));\n+    let listener = or_panic!(UnixListener::bind_addr(&socket_addr));\n+\n+    let thread = thread::spawn(move || {\n+        let mut stream = or_panic!(listener.accept()).0;\n+        let mut buf = [0; 5];\n+        or_panic!(stream.read(&mut buf));\n+        assert_eq!(&msg1[..], &buf[..]);\n+        or_panic!(stream.write_all(msg2));\n+    });\n+\n+    let mut stream = or_panic!(UnixStream::connect_addr(&socket_addr));\n+\n+    let peer = or_panic!(stream.peer_addr());\n+    assert_eq!(peer.as_abstract_namespace().unwrap(), b\"namespace\");\n+\n+    or_panic!(stream.write_all(msg1));\n+    let mut buf = vec![];\n+    or_panic!(stream.read_to_end(&mut buf));\n+    assert_eq!(&msg2[..], &buf[..]);\n+    drop(stream);\n+\n+    thread.join().unwrap();\n+}\n+\n+#[cfg(any(target_os = \"android\", target_os = \"linux\"))]\n+#[test]\n+fn test_abstract_stream_iter() {\n+    let addr = or_panic!(SocketAddr::from_abstract_namespace(b\"hidden\"));\n+    let listener = or_panic!(UnixListener::bind_addr(&addr));\n+\n+    let thread = thread::spawn(move || {\n+        for stream in listener.incoming().take(2) {\n+            let mut stream = or_panic!(stream);\n+            let mut buf = [0];\n+            or_panic!(stream.read(&mut buf));\n+        }\n+    });\n+\n+    for _ in 0..2 {\n+        let mut stream = or_panic!(UnixStream::connect_addr(&addr));\n+        or_panic!(stream.write_all(&[0]));\n+    }\n+\n+    thread.join().unwrap();\n+}\n+\n+#[cfg(any(target_os = \"android\", target_os = \"linux\"))]\n+#[test]\n+fn test_abstract_datagram_bind_send_to_addr() {\n+    let addr1 = or_panic!(SocketAddr::from_abstract_namespace(b\"ns1\"));\n+    let sock1 = or_panic!(UnixDatagram::bind_addr(&addr1));\n+\n+    let local = or_panic!(sock1.local_addr());\n+    assert_eq!(local.as_abstract_namespace().unwrap(), b\"ns1\");\n+\n+    let addr2 = or_panic!(SocketAddr::from_abstract_namespace(b\"ns2\"));\n+    let sock2 = or_panic!(UnixDatagram::bind_addr(&addr2));\n+\n+    let msg = b\"hello world\";\n+    or_panic!(sock1.send_to_addr(msg, &addr2));\n+    let mut buf = [0; 11];\n+    let (len, addr) = or_panic!(sock2.recv_from(&mut buf));\n+    assert_eq!(msg, &buf[..]);\n+    assert_eq!(len, 11);\n+    assert_eq!(addr.as_abstract_namespace().unwrap(), b\"ns1\");\n+}\n+\n+#[cfg(any(target_os = \"android\", target_os = \"linux\"))]\n+#[test]\n+fn test_abstract_datagram_connect_addr() {\n+    let addr1 = or_panic!(SocketAddr::from_abstract_namespace(b\"ns3\"));\n+    let bsock1 = or_panic!(UnixDatagram::bind_addr(&addr1));\n+\n+    let sock = or_panic!(UnixDatagram::unbound());\n+    or_panic!(sock.connect_addr(&addr1));\n+\n+    let msg = b\"hello world\";\n+    or_panic!(sock.send(msg));\n+    let mut buf = [0; 11];\n+    let (len, addr) = or_panic!(bsock1.recv_from(&mut buf));\n+    assert_eq!(len, 11);\n+    assert_eq!(addr.is_unnamed(), true);\n+    assert_eq!(msg, &buf[..]);\n+\n+    let addr2 = or_panic!(SocketAddr::from_abstract_namespace(b\"ns4\"));\n+    let bsock2 = or_panic!(UnixDatagram::bind_addr(&addr2));\n+\n+    or_panic!(sock.connect_addr(&addr2));\n+    or_panic!(sock.send(msg));\n+    or_panic!(bsock2.recv_from(&mut buf));\n+}\n+\n+#[cfg(any(target_os = \"android\", target_os = \"linux\"))]\n+#[test]\n+fn test_abstract_namespace_too_long() {\n+    match SocketAddr::from_abstract_namespace(\n+        b\"abcdefghijklmnopqrstuvwxyzabcdefghijklmn\\\n+        opqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghi\\\n+        jklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz\",\n+    ) {\n+        Err(ref e) if e.kind() == io::ErrorKind::InvalidInput => {}\n+        Err(e) => panic!(\"unexpected error {}\", e),\n+        Ok(_) => panic!(\"unexpected success\"),\n+    }\n+}\n+\n+#[cfg(any(target_os = \"android\", target_os = \"linux\"))]\n+#[test]\n+fn test_abstract_namespace_no_pathname_and_not_unnamed() {\n+    let namespace = b\"local\";\n+    let addr = or_panic!(SocketAddr::from_abstract_namespace(&namespace[..]));\n+    assert_eq!(addr.as_pathname(), None);\n+    assert_eq!(addr.as_abstract_namespace(), Some(&namespace[..]));\n+    assert_eq!(addr.is_unnamed(), false);\n+}\n+\n #[test]\n fn test_unix_stream_peek() {\n     let (txdone, rxdone) = crate::sync::mpsc::channel();"}]}