{"sha": "33f90f213d4c5495bba988b9d81982d73553096e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzZjkwZjIxM2Q0YzU0OTViYmE5ODhiOWQ4MTk4MmQ3MzU1MzA5NmU=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-05-19T19:09:59Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-05-22T16:38:20Z"}, "message": "Check for upper bound universe errors more carefully", "tree": {"sha": "fc8a5aa71f32e2cc4fc8b454b02a68fbdc2bb833", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc8a5aa71f32e2cc4fc8b454b02a68fbdc2bb833"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33f90f213d4c5495bba988b9d81982d73553096e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33f90f213d4c5495bba988b9d81982d73553096e", "html_url": "https://github.com/rust-lang/rust/commit/33f90f213d4c5495bba988b9d81982d73553096e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33f90f213d4c5495bba988b9d81982d73553096e/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9ca1ec9280ca1e5020edd699917c3367a30a798", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9ca1ec9280ca1e5020edd699917c3367a30a798", "html_url": "https://github.com/rust-lang/rust/commit/a9ca1ec9280ca1e5020edd699917c3367a30a798"}], "stats": {"total": 44, "additions": 26, "deletions": 18}, "files": [{"sha": "5d64a987cbd0ab8842fe1908da212dcbcdbb8111", "filename": "src/librustc_infer/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/33f90f213d4c5495bba988b9d81982d73553096e/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33f90f213d4c5495bba988b9d81982d73553096e/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=33f90f213d4c5495bba988b9d81982d73553096e", "patch": "@@ -49,7 +49,10 @@ pub fn resolve<'tcx>(\n             let mut values = resolver.infer_variable_values(&mut errors);\n             let re_erased = region_rels.tcx.lifetimes.re_erased;\n \n-            values.values.iter_mut().for_each(|v| *v = VarValue::Value(re_erased));\n+            values.values.iter_mut().for_each(|v| match *v {\n+                VarValue::Value(ref mut r) => *r = re_erased,\n+                VarValue::ErrorValue => {}\n+            });\n             (values, errors)\n         }\n         RegionckMode::Erase { suppress_errors: true } => {\n@@ -290,8 +293,8 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n \n         // Find all the \"upper bounds\" -- that is, each region `b` such that\n         // `r0 <= b` must hold.\n-        let (member_upper_bounds, _) =\n-            self.collect_concrete_regions(graph, member_vid, OUTGOING, None);\n+        let (member_upper_bounds, ..) =\n+            self.collect_bounding_regions(graph, member_vid, OUTGOING, None);\n \n         // Get an iterator over the *available choice* -- that is,\n         // each choice region `c` where `lb <= c` and `c <= ub` for all the\n@@ -716,7 +719,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         graph: &RegionGraph<'tcx>,\n         errors: &mut Vec<RegionResolutionError<'tcx>>,\n     ) {\n-        debug!(\"collect_var_errors\");\n+        debug!(\"collect_var_errors, var_data = {:#?}\", var_data.values);\n \n         // This is the best way that I have found to suppress\n         // duplicate and related errors. Basically we keep a set of\n@@ -815,10 +818,10 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n     ) {\n         // Errors in expanding nodes result from a lower-bound that is\n         // not contained by an upper-bound.\n-        let (mut lower_bounds, lower_dup) =\n-            self.collect_concrete_regions(graph, node_idx, INCOMING, Some(dup_vec));\n-        let (mut upper_bounds, upper_dup) =\n-            self.collect_concrete_regions(graph, node_idx, OUTGOING, Some(dup_vec));\n+        let (mut lower_bounds, lower_vid_bounds, lower_dup) =\n+            self.collect_bounding_regions(graph, node_idx, INCOMING, Some(dup_vec));\n+        let (mut upper_bounds, _, upper_dup) =\n+            self.collect_bounding_regions(graph, node_idx, OUTGOING, Some(dup_vec));\n \n         if lower_dup || upper_dup {\n             return;\n@@ -874,15 +877,22 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         // If we have a scenario like `exists<'a> { forall<'b> { 'b:\n         // 'a } }`, we wind up without any lower-bound -- all we have\n         // are placeholders as upper bounds, but the universe of the\n-        // variable `'a` doesn't permit those placeholders.\n+        // variable `'a`, or some variable that `'a` has to outlive, doesn't\n+        // permit those placeholders.\n+        let min_universe = lower_vid_bounds\n+            .into_iter()\n+            .map(|vid| self.var_infos[vid].universe)\n+            .min()\n+            .expect(\"lower_vid_bounds should at least include `node_idx`\");\n+\n         for upper_bound in &upper_bounds {\n             if let ty::RePlaceholder(p) = upper_bound.region {\n-                if node_universe.cannot_name(p.universe) {\n+                if min_universe.cannot_name(p.universe) {\n                     let origin = self.var_infos[node_idx].origin;\n                     errors.push(RegionResolutionError::UpperBoundUniverseConflict(\n                         node_idx,\n                         origin,\n-                        node_universe,\n+                        min_universe,\n                         upper_bound.origin.clone(),\n                         upper_bound.region,\n                     ));\n@@ -904,13 +914,13 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         );\n     }\n \n-    fn collect_concrete_regions(\n+    fn collect_bounding_regions(\n         &self,\n         graph: &RegionGraph<'tcx>,\n         orig_node_idx: RegionVid,\n         dir: Direction,\n         mut dup_vec: Option<&mut IndexVec<RegionVid, Option<RegionVid>>>,\n-    ) -> (Vec<RegionAndOrigin<'tcx>>, bool) {\n+    ) -> (Vec<RegionAndOrigin<'tcx>>, FxHashSet<RegionVid>, bool) {\n         struct WalkState<'tcx> {\n             set: FxHashSet<RegionVid>,\n             stack: Vec<RegionVid>,\n@@ -929,9 +939,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         // direction specified\n         process_edges(&self.data, &mut state, graph, orig_node_idx, dir);\n \n-        while !state.stack.is_empty() {\n-            let node_idx = state.stack.pop().unwrap();\n-\n+        while let Some(node_idx) = state.stack.pop() {\n             // check whether we've visited this node on some previous walk\n             if let Some(dup_vec) = &mut dup_vec {\n                 if dup_vec[node_idx].is_none() {\n@@ -949,8 +957,8 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             process_edges(&self.data, &mut state, graph, node_idx, dir);\n         }\n \n-        let WalkState { result, dup_found, .. } = state;\n-        return (result, dup_found);\n+        let WalkState { result, dup_found, set, .. } = state;\n+        return (result, set, dup_found);\n \n         fn process_edges<'tcx>(\n             this: &RegionConstraintData<'tcx>,"}]}