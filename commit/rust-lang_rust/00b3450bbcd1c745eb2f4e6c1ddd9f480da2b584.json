{"sha": "00b3450bbcd1c745eb2f4e6c1ddd9f480da2b584", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwYjM0NTBiYmNkMWM3NDVlYjJmNGU2YzFkZGQ5ZjQ4MGRhMmI1ODQ=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-10-01T23:25:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-01T23:25:11Z"}, "message": "Rollup merge of #76979 - fusion-engineering-forks:windows-fallback-check, r=dtolnay\n\nImprove std::sys::windows::compat\n\nImproves the compat_fn macro in sys::windows, which is used for conditionally loading APIs that might not be available.\n\n- The module (dll) name can now be any string, not just an ident. (Not all Windows api modules are valid Rust identifiers. E.g. `WaitOnAddress` comes from `API-MS-Win-Core-Synch-l1-2-0.dll`.)\n- Adds `FuncName::is_available()` for checking if a function is really available without having to do a duplicate lookup.\n- Add comment explaining the lack of locking.\n- Use `$_:block` to simplify the macro_rules.\n- Apply `allow(unused_variables)` only to the fallback instead of everything.\n\n---\n\nThe second point (`is_available()`) simplifies code that needs to pick an implementation depening on what is available, like `sys/windows/mutex.rs`. Before this change, it'd do its own lookup and keep its own `AtomicUsize` to track the result. Now it can just use `c::AcquireSRWLockExclusive::is_available()` directly.\n\nThis will also be useful when park/unpark/CondVar/etc. get improved implementations (e.g. from parking_lot or something else), as the best APIs for those are not available before Windows 8.", "tree": {"sha": "201b0c1bee29b2b00f62371ae3aef49b71f171c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/201b0c1bee29b2b00f62371ae3aef49b71f171c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/00b3450bbcd1c745eb2f4e6c1ddd9f480da2b584", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfdmVYCRBK7hj4Ov3rIwAAdHIIACgGJrym3UV1+E97nG7cRPix\nQrx1v0J1kxIdElVDJx8I+frJbh29iEI75sZ/9ZEX8RsrmrxQRMWTSGDtV972QFqa\n1p8myh9sZ28e2R/ROtjS76k7ya1z6qnc6jklNo7mReYB9W4oIvfBSp3xd5PbLDzz\nqp/qGyogtD04xUv3jmhltwyjXchYU6cNc0XC4CmPq0tHLiTyH/b+5EE/fkc4Z40F\nyXYlp6oGHS5IClFgknGZeIsasYToftcegsdYm0Hj/ADgKeUeSY4RbaPf1ldzvaxG\nxRgGxpGBqKj2Wsu8WPD0BP9MwpLhE4gK/JghNn+fYd99Bv44RoXXIaZxcGR0MBk=\n=i6To\n-----END PGP SIGNATURE-----\n", "payload": "tree 201b0c1bee29b2b00f62371ae3aef49b71f171c2\nparent 1fa5f8f05b85a22bb9fb94e5d2f026b124c514f8\nparent 63b6007d5b68023e02a43c2f9c2ed21762cd8011\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1601594711 +0900\ncommitter GitHub <noreply@github.com> 1601594711 +0900\n\nRollup merge of #76979 - fusion-engineering-forks:windows-fallback-check, r=dtolnay\n\nImprove std::sys::windows::compat\n\nImproves the compat_fn macro in sys::windows, which is used for conditionally loading APIs that might not be available.\n\n- The module (dll) name can now be any string, not just an ident. (Not all Windows api modules are valid Rust identifiers. E.g. `WaitOnAddress` comes from `API-MS-Win-Core-Synch-l1-2-0.dll`.)\n- Adds `FuncName::is_available()` for checking if a function is really available without having to do a duplicate lookup.\n- Add comment explaining the lack of locking.\n- Use `$_:block` to simplify the macro_rules.\n- Apply `allow(unused_variables)` only to the fallback instead of everything.\n\n---\n\nThe second point (`is_available()`) simplifies code that needs to pick an implementation depening on what is available, like `sys/windows/mutex.rs`. Before this change, it'd do its own lookup and keep its own `AtomicUsize` to track the result. Now it can just use `c::AcquireSRWLockExclusive::is_available()` directly.\n\nThis will also be useful when park/unpark/CondVar/etc. get improved implementations (e.g. from parking_lot or something else), as the best APIs for those are not available before Windows 8.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/00b3450bbcd1c745eb2f4e6c1ddd9f480da2b584", "html_url": "https://github.com/rust-lang/rust/commit/00b3450bbcd1c745eb2f4e6c1ddd9f480da2b584", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/00b3450bbcd1c745eb2f4e6c1ddd9f480da2b584/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1fa5f8f05b85a22bb9fb94e5d2f026b124c514f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/1fa5f8f05b85a22bb9fb94e5d2f026b124c514f8", "html_url": "https://github.com/rust-lang/rust/commit/1fa5f8f05b85a22bb9fb94e5d2f026b124c514f8"}, {"sha": "63b6007d5b68023e02a43c2f9c2ed21762cd8011", "url": "https://api.github.com/repos/rust-lang/rust/commits/63b6007d5b68023e02a43c2f9c2ed21762cd8011", "html_url": "https://github.com/rust-lang/rust/commit/63b6007d5b68023e02a43c2f9c2ed21762cd8011"}], "stats": {"total": 98, "additions": 53, "deletions": 45}, "files": [{"sha": "559c4dc9c7cd8fc199f1f6ff38f15073ecd02db4", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/00b3450bbcd1c745eb2f4e6c1ddd9f480da2b584/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b3450bbcd1c745eb2f4e6c1ddd9f480da2b584/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=00b3450bbcd1c745eb2f4e6c1ddd9f480da2b584", "patch": "@@ -1032,7 +1032,7 @@ extern \"system\" {\n // Functions that aren't available on every version of Windows that we support,\n // but we still use them and just provide some form of a fallback implementation.\n compat_fn! {\n-    kernel32:\n+    \"kernel32\":\n \n     pub fn CreateSymbolicLinkW(_lpSymlinkFileName: LPCWSTR,\n                                _lpTargetFileName: LPCWSTR,"}, {"sha": "3f25f05e1b9a7e479ce7f8cd766af19e9a532cf8", "filename": "library/std/src/sys/windows/compat.rs", "status": "modified", "additions": 49, "deletions": 26, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/00b3450bbcd1c745eb2f4e6c1ddd9f480da2b584/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b3450bbcd1c745eb2f4e6c1ddd9f480da2b584/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs?ref=00b3450bbcd1c745eb2f4e6c1ddd9f480da2b584", "patch": "@@ -12,7 +12,6 @@\n //! function is available but afterwards it's just a load and a jump.\n \n use crate::ffi::CString;\n-use crate::sync::atomic::{AtomicUsize, Ordering};\n use crate::sys::c;\n \n pub fn lookup(module: &str, symbol: &str) -> Option<usize> {\n@@ -28,45 +27,69 @@ pub fn lookup(module: &str, symbol: &str) -> Option<usize> {\n     }\n }\n \n-pub fn store_func(ptr: &AtomicUsize, module: &str, symbol: &str, fallback: usize) -> usize {\n-    let value = lookup(module, symbol).unwrap_or(fallback);\n-    ptr.store(value, Ordering::SeqCst);\n-    value\n-}\n-\n macro_rules! compat_fn {\n-    ($module:ident: $(\n+    ($module:literal: $(\n         $(#[$meta:meta])*\n-        pub fn $symbol:ident($($argname:ident: $argtype:ty),*)\n-                                  -> $rettype:ty {\n-            $($body:expr);*\n-        }\n+        pub fn $symbol:ident($($argname:ident: $argtype:ty),*) -> $rettype:ty $body:block\n     )*) => ($(\n-        #[allow(unused_variables)]\n         $(#[$meta])*\n-        pub unsafe fn $symbol($($argname: $argtype),*) -> $rettype {\n+        pub mod $symbol {\n+            use super::*;\n             use crate::sync::atomic::{AtomicUsize, Ordering};\n             use crate::mem;\n+\n             type F = unsafe extern \"system\" fn($($argtype),*) -> $rettype;\n \n             static PTR: AtomicUsize = AtomicUsize::new(0);\n \n+            #[allow(unused_variables)]\n+            unsafe extern \"system\" fn fallback($($argname: $argtype),*) -> $rettype $body\n+\n+            /// This address is stored in `PTR` to incidate an unavailable API.\n+            ///\n+            /// This way, call() will end up calling fallback() if it is unavailable.\n+            ///\n+            /// This is a `static` to avoid rustc duplicating `fn fallback()`\n+            /// into both load() and is_available(), which would break\n+            /// is_available()'s comparison. By using the same static variable\n+            /// in both places, they'll refer to the same (copy of the)\n+            /// function.\n+            ///\n+            /// LLVM merging the address of fallback with other functions\n+            /// (because of unnamed_addr) is fine, since it's only compared to\n+            /// an address from GetProcAddress from an external dll.\n+            static FALLBACK: F = fallback;\n+\n+            #[cold]\n             fn load() -> usize {\n-                crate::sys::compat::store_func(&PTR,\n-                                          stringify!($module),\n-                                          stringify!($symbol),\n-                                          fallback as usize)\n+                // There is no locking here. It's okay if this is executed by multiple threads in\n+                // parallel. `lookup` will result in the same value, and it's okay if they overwrite\n+                // eachothers result as long as they do so atomically. We don't need any guarantees\n+                // about memory ordering, as this involves just a single atomic variable which is\n+                // not used to protect or order anything else.\n+                let addr = crate::sys::compat::lookup($module, stringify!($symbol))\n+                    .unwrap_or(FALLBACK as usize);\n+                PTR.store(addr, Ordering::Relaxed);\n+                addr\n             }\n-            unsafe extern \"system\" fn fallback($($argname: $argtype),*)\n-                                               -> $rettype {\n-                $($body);*\n+\n+            fn addr() -> usize {\n+                match PTR.load(Ordering::Relaxed) {\n+                    0 => load(),\n+                    addr => addr,\n+                }\n+            }\n+\n+            #[allow(dead_code)]\n+            pub fn is_available() -> bool {\n+                addr() != FALLBACK as usize\n             }\n \n-            let addr = match PTR.load(Ordering::SeqCst) {\n-                0 => load(),\n-                n => n,\n-            };\n-            mem::transmute::<usize, F>(addr)($($argname),*)\n+            pub unsafe fn call($($argname: $argtype),*) -> $rettype {\n+                mem::transmute::<usize, F>(addr())($($argname),*)\n+            }\n         }\n+\n+        pub use $symbol::call as $symbol;\n     )*)\n }"}, {"sha": "e2aaca59fe2f388b26d54fcf1c8cf5878ad6db26", "filename": "library/std/src/sys/windows/mutex.rs", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/00b3450bbcd1c745eb2f4e6c1ddd9f480da2b584/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00b3450bbcd1c745eb2f4e6c1ddd9f480da2b584/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmutex.rs?ref=00b3450bbcd1c745eb2f4e6c1ddd9f480da2b584", "patch": "@@ -23,7 +23,6 @@ use crate::cell::{Cell, UnsafeCell};\n use crate::mem::{self, MaybeUninit};\n use crate::sync::atomic::{AtomicUsize, Ordering};\n use crate::sys::c;\n-use crate::sys::compat;\n \n pub struct Mutex {\n     // This is either directly an SRWLOCK (if supported), or a Box<Inner> otherwise.\n@@ -40,8 +39,8 @@ struct Inner {\n \n #[derive(Clone, Copy)]\n enum Kind {\n-    SRWLock = 1,\n-    CriticalSection = 2,\n+    SRWLock,\n+    CriticalSection,\n }\n \n #[inline]\n@@ -130,21 +129,7 @@ impl Mutex {\n }\n \n fn kind() -> Kind {\n-    static KIND: AtomicUsize = AtomicUsize::new(0);\n-\n-    let val = KIND.load(Ordering::SeqCst);\n-    if val == Kind::SRWLock as usize {\n-        return Kind::SRWLock;\n-    } else if val == Kind::CriticalSection as usize {\n-        return Kind::CriticalSection;\n-    }\n-\n-    let ret = match compat::lookup(\"kernel32\", \"AcquireSRWLockExclusive\") {\n-        None => Kind::CriticalSection,\n-        Some(..) => Kind::SRWLock,\n-    };\n-    KIND.store(ret as usize, Ordering::SeqCst);\n-    ret\n+    if c::AcquireSRWLockExclusive::is_available() { Kind::SRWLock } else { Kind::CriticalSection }\n }\n \n pub struct ReentrantMutex {"}]}