{"sha": "3743ede404d38586db9d7febca14b8bebcbbe0ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3NDNlZGU0MDRkMzg1ODZkYjlkN2ZlYmNhMTRiOGJlYmNiYmUwZWY=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-03-13T21:44:36Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-03-13T21:44:36Z"}, "message": "Move type lowering methods to TyLoweringContext", "tree": {"sha": "2d70ac00f2228623ac012576bd881df3edc1c077", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d70ac00f2228623ac012576bd881df3edc1c077"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3743ede404d38586db9d7febca14b8bebcbbe0ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3743ede404d38586db9d7febca14b8bebcbbe0ef", "html_url": "https://github.com/rust-lang/rust/commit/3743ede404d38586db9d7febca14b8bebcbbe0ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3743ede404d38586db9d7febca14b8bebcbbe0ef/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3ca2ab959af672e779757dbcab755b61a4ec091", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3ca2ab959af672e779757dbcab755b61a4ec091", "html_url": "https://github.com/rust-lang/rust/commit/d3ca2ab959af672e779757dbcab755b61a4ec091"}], "stats": {"total": 538, "additions": 249, "deletions": 289}, "files": [{"sha": "10b8171bea1fcb5816c8930eec578deb6df30bb9", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3743ede404d38586db9d7febca14b8bebcbbe0ef/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3743ede404d38586db9d7febca14b8bebcbbe0ef/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=3743ede404d38586db9d7febca14b8bebcbbe0ef", "patch": "@@ -802,7 +802,7 @@ impl Function {\n         let krate = self.id.lookup(db.upcast()).container.module(db.upcast()).krate();\n         let ret_type = &db.function_data(self.id).ret_type;\n         let ctx = hir_ty::TyLoweringContext::new(db, &resolver);\n-        let ty = Ty::from_hir_ext(&ctx, ret_type).0;\n+        let ty = ctx.lower_ty(ret_type);\n         Type::new_with_resolver_inner(db, krate, &resolver, ty)\n     }\n \n@@ -825,7 +825,7 @@ impl Function {\n                 let ty = Type {\n                     krate,\n                     ty: InEnvironment {\n-                        value: Ty::from_hir_ext(&ctx, type_ref).0,\n+                        value: ctx.lower_ty(type_ref),\n                         environment: environment.clone(),\n                     },\n                 };\n@@ -1499,7 +1499,7 @@ impl Impl {\n         let resolver = self.id.resolver(db.upcast());\n         let krate = self.id.lookup(db.upcast()).container.krate();\n         let ctx = hir_ty::TyLoweringContext::new(db, &resolver);\n-        let ty = Ty::from_hir(&ctx, &impl_data.target_type);\n+        let ty = ctx.lower_ty(&impl_data.target_type);\n         Type::new_with_resolver_inner(db, krate, &resolver, ty)\n     }\n "}, {"sha": "8cf59821f199422fd7815223b9035478697f6336", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3743ede404d38586db9d7febca14b8bebcbbe0ef/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3743ede404d38586db9d7febca14b8bebcbbe0ef/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=3743ede404d38586db9d7febca14b8bebcbbe0ef", "patch": "@@ -294,7 +294,7 @@ impl<'a> InferenceContext<'a> {\n         // FIXME use right resolver for block\n         let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver)\n             .with_impl_trait_mode(impl_trait_mode);\n-        let ty = Ty::from_hir(&ctx, type_ref);\n+        let ty = ctx.lower_ty(type_ref);\n         let ty = self.insert_type_vars(ty);\n         self.normalize_associated_types_in(ty)\n     }\n@@ -437,19 +437,19 @@ impl<'a> InferenceContext<'a> {\n             };\n         return match resolution {\n             TypeNs::AdtId(AdtId::StructId(strukt)) => {\n-                let substs = Ty::substs_from_path(&ctx, path, strukt.into(), true);\n+                let substs = ctx.substs_from_path(path, strukt.into(), true);\n                 let ty = self.db.ty(strukt.into());\n                 let ty = self.insert_type_vars(ty.subst(&substs));\n                 forbid_unresolved_segments((ty, Some(strukt.into())), unresolved)\n             }\n             TypeNs::AdtId(AdtId::UnionId(u)) => {\n-                let substs = Ty::substs_from_path(&ctx, path, u.into(), true);\n+                let substs = ctx.substs_from_path(path, u.into(), true);\n                 let ty = self.db.ty(u.into());\n                 let ty = self.insert_type_vars(ty.subst(&substs));\n                 forbid_unresolved_segments((ty, Some(u.into())), unresolved)\n             }\n             TypeNs::EnumVariantId(var) => {\n-                let substs = Ty::substs_from_path(&ctx, path, var.into(), true);\n+                let substs = ctx.substs_from_path(path, var.into(), true);\n                 let ty = self.db.ty(var.parent.into());\n                 let ty = self.insert_type_vars(ty.subst(&substs));\n                 forbid_unresolved_segments((ty, Some(var.into())), unresolved)\n@@ -541,7 +541,7 @@ impl<'a> InferenceContext<'a> {\n         let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver)\n             .with_impl_trait_mode(ImplTraitLoweringMode::Param);\n         let param_tys =\n-            data.params.iter().map(|type_ref| Ty::from_hir(&ctx, type_ref)).collect::<Vec<_>>();\n+            data.params.iter().map(|type_ref| ctx.lower_ty(type_ref)).collect::<Vec<_>>();\n         for (ty, pat) in param_tys.into_iter().zip(body.params.iter()) {\n             let ty = self.insert_type_vars(ty);\n             let ty = self.normalize_associated_types_in(ty);"}, {"sha": "af108fb6ceb30ce7e46320d363c0d741e2025737", "filename": "crates/hir_ty/src/infer/path.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3743ede404d38586db9d7febca14b8bebcbbe0ef/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3743ede404d38586db9d7febca14b8bebcbbe0ef/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs?ref=3743ede404d38586db9d7febca14b8bebcbbe0ef", "patch": "@@ -40,7 +40,7 @@ impl<'a> InferenceContext<'a> {\n             let ty = self.make_ty(type_ref);\n             let remaining_segments_for_ty = path.segments().take(path.segments().len() - 1);\n             let ctx = crate::lower::TyLoweringContext::new(self.db, &resolver);\n-            let (ty, _) = Ty::from_type_relative_path(&ctx, ty, None, remaining_segments_for_ty);\n+            let (ty, _) = ctx.lower_ty_relative_path(ty, None, remaining_segments_for_ty);\n             self.resolve_ty_assoc_item(\n                 ty,\n                 &path.segments().last().expect(\"path had at least one segment\").name,\n@@ -96,7 +96,7 @@ impl<'a> InferenceContext<'a> {\n         // self_subst is just for the parent\n         let parent_substs = self_subst.unwrap_or_else(Substs::empty);\n         let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver);\n-        let substs = Ty::substs_from_path(&ctx, path, typable, true);\n+        let substs = ctx.substs_from_path(path, typable, true);\n         let full_substs = Substs::builder(substs.len())\n             .use_parent_substs(&parent_substs)\n             .fill(substs.0[parent_substs.len()..].iter().cloned())\n@@ -126,7 +126,8 @@ impl<'a> InferenceContext<'a> {\n                 let segment =\n                     remaining_segments.last().expect(\"there should be at least one segment here\");\n                 let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver);\n-                let trait_ref = TraitRef::from_resolved_path(&ctx, trait_, resolved_segment, None);\n+                let trait_ref =\n+                    ctx.lower_trait_ref_from_resolved_path(trait_, resolved_segment, None);\n                 self.resolve_trait_assoc_item(trait_ref, segment, id)\n             }\n             (def, _) => {\n@@ -137,8 +138,7 @@ impl<'a> InferenceContext<'a> {\n                 let remaining_segments_for_ty =\n                     remaining_segments.take(remaining_segments.len() - 1);\n                 let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver);\n-                let (ty, _) = Ty::from_partly_resolved_hir_path(\n-                    &ctx,\n+                let (ty, _) = ctx.lower_partly_resolved_path(\n                     def,\n                     resolved_segment,\n                     remaining_segments_for_ty,"}, {"sha": "c32dca9d72efef07aa42fe041af7f42e5e157aa9", "filename": "crates/hir_ty/src/lower.rs", "status": "modified", "additions": 235, "deletions": 275, "changes": 510, "blob_url": "https://github.com/rust-lang/rust/blob/3743ede404d38586db9d7febca14b8bebcbbe0ef/crates%2Fhir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3743ede404d38586db9d7febca14b8bebcbbe0ef/crates%2Fhir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flower.rs?ref=3743ede404d38586db9d7febca14b8bebcbbe0ef", "patch": "@@ -140,44 +140,45 @@ pub enum TypeParamLoweringMode {\n     Variable,\n }\n \n-impl Ty {\n-    pub fn from_hir(ctx: &TyLoweringContext<'_>, type_ref: &TypeRef) -> Self {\n-        Ty::from_hir_ext(ctx, type_ref).0\n+impl<'a> TyLoweringContext<'a> {\n+    pub fn lower_ty(&self, type_ref: &TypeRef) -> Ty {\n+        self.lower_ty_ext(type_ref).0\n     }\n-    pub fn from_hir_ext(ctx: &TyLoweringContext<'_>, type_ref: &TypeRef) -> (Self, Option<TypeNs>) {\n+\n+    fn lower_ty_ext(&self, type_ref: &TypeRef) -> (Ty, Option<TypeNs>) {\n         let mut res = None;\n         let ty = match type_ref {\n             TypeRef::Never => TyKind::Never.intern(&Interner),\n             TypeRef::Tuple(inner) => {\n-                let inner_tys: Arc<[Ty]> = inner.iter().map(|tr| Ty::from_hir(ctx, tr)).collect();\n+                let inner_tys: Arc<[Ty]> = inner.iter().map(|tr| self.lower_ty(tr)).collect();\n                 TyKind::Tuple(inner_tys.len(), Substs(inner_tys)).intern(&Interner)\n             }\n             TypeRef::Path(path) => {\n-                let (ty, res_) = Ty::from_hir_path(ctx, path);\n+                let (ty, res_) = self.lower_path(path);\n                 res = res_;\n                 ty\n             }\n             TypeRef::RawPtr(inner, mutability) => {\n-                let inner_ty = Ty::from_hir(ctx, inner);\n+                let inner_ty = self.lower_ty(inner);\n                 TyKind::Raw(lower_to_chalk_mutability(*mutability), Substs::single(inner_ty))\n                     .intern(&Interner)\n             }\n             TypeRef::Array(inner) => {\n-                let inner_ty = Ty::from_hir(ctx, inner);\n+                let inner_ty = self.lower_ty(inner);\n                 TyKind::Array(Substs::single(inner_ty)).intern(&Interner)\n             }\n             TypeRef::Slice(inner) => {\n-                let inner_ty = Ty::from_hir(ctx, inner);\n+                let inner_ty = self.lower_ty(inner);\n                 TyKind::Slice(Substs::single(inner_ty)).intern(&Interner)\n             }\n             TypeRef::Reference(inner, _, mutability) => {\n-                let inner_ty = Ty::from_hir(ctx, inner);\n+                let inner_ty = self.lower_ty(inner);\n                 TyKind::Ref(lower_to_chalk_mutability(*mutability), Substs::single(inner_ty))\n                     .intern(&Interner)\n             }\n             TypeRef::Placeholder => TyKind::Unknown.intern(&Interner),\n             TypeRef::Fn(params, is_varargs) => {\n-                let substs = Substs(params.iter().map(|tr| Ty::from_hir(ctx, tr)).collect());\n+                let substs = Substs(params.iter().map(|tr| self.lower_ty(tr)).collect());\n                 TyKind::Function(FnPointer {\n                     num_args: substs.len() - 1,\n                     sig: FnSig { variadic: *is_varargs },\n@@ -188,25 +189,22 @@ impl Ty {\n             TypeRef::DynTrait(bounds) => {\n                 let self_ty =\n                     TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0)).intern(&Interner);\n-                let predicates = ctx.with_shifted_in(DebruijnIndex::ONE, |ctx| {\n-                    bounds\n-                        .iter()\n-                        .flat_map(|b| GenericPredicate::from_type_bound(ctx, b, self_ty.clone()))\n-                        .collect()\n+                let predicates = self.with_shifted_in(DebruijnIndex::ONE, |ctx| {\n+                    bounds.iter().flat_map(|b| ctx.lower_type_bound(b, self_ty.clone())).collect()\n                 });\n                 TyKind::Dyn(predicates).intern(&Interner)\n             }\n             TypeRef::ImplTrait(bounds) => {\n-                match ctx.impl_trait_mode {\n+                match self.impl_trait_mode {\n                     ImplTraitLoweringMode::Opaque => {\n-                        let idx = ctx.impl_trait_counter.get();\n-                        ctx.impl_trait_counter.set(idx + 1);\n+                        let idx = self.impl_trait_counter.get();\n+                        self.impl_trait_counter.set(idx + 1);\n \n-                        assert!(idx as usize == ctx.opaque_type_data.borrow().len());\n+                        assert!(idx as usize == self.opaque_type_data.borrow().len());\n                         // this dance is to make sure the data is in the right\n                         // place even if we encounter more opaque types while\n                         // lowering the bounds\n-                        ctx.opaque_type_data\n+                        self.opaque_type_data\n                             .borrow_mut()\n                             .push(ReturnTypeImplTrait { bounds: Binders::new(1, Vec::new()) });\n                         // We don't want to lower the bounds inside the binders\n@@ -218,56 +216,56 @@ impl Ty {\n                         // other, but separately. So if the `T` refers to a type\n                         // parameter of the outer function, it's just one binder\n                         // away instead of two.\n-                        let actual_opaque_type_data = ctx\n+                        let actual_opaque_type_data = self\n                             .with_debruijn(DebruijnIndex::INNERMOST, |ctx| {\n-                                ReturnTypeImplTrait::from_hir(ctx, &bounds)\n+                                ctx.lower_impl_trait(&bounds)\n                             });\n-                        ctx.opaque_type_data.borrow_mut()[idx as usize] = actual_opaque_type_data;\n+                        self.opaque_type_data.borrow_mut()[idx as usize] = actual_opaque_type_data;\n \n-                        let func = match ctx.resolver.generic_def() {\n+                        let func = match self.resolver.generic_def() {\n                             Some(GenericDefId::FunctionId(f)) => f,\n                             _ => panic!(\"opaque impl trait lowering in non-function\"),\n                         };\n                         let impl_trait_id = ImplTraitId::ReturnTypeImplTrait(func, idx);\n-                        let opaque_ty_id = ctx.db.intern_impl_trait_id(impl_trait_id).into();\n-                        let generics = generics(ctx.db.upcast(), func.into());\n-                        let parameters = Substs::bound_vars(&generics, ctx.in_binders);\n+                        let opaque_ty_id = self.db.intern_impl_trait_id(impl_trait_id).into();\n+                        let generics = generics(self.db.upcast(), func.into());\n+                        let parameters = Substs::bound_vars(&generics, self.in_binders);\n                         TyKind::Alias(AliasTy::Opaque(OpaqueTy { opaque_ty_id, parameters }))\n                             .intern(&Interner)\n                     }\n                     ImplTraitLoweringMode::Param => {\n-                        let idx = ctx.impl_trait_counter.get();\n+                        let idx = self.impl_trait_counter.get();\n                         // FIXME we're probably doing something wrong here\n-                        ctx.impl_trait_counter.set(idx + count_impl_traits(type_ref) as u16);\n-                        if let Some(def) = ctx.resolver.generic_def() {\n-                            let generics = generics(ctx.db.upcast(), def);\n+                        self.impl_trait_counter.set(idx + count_impl_traits(type_ref) as u16);\n+                        if let Some(def) = self.resolver.generic_def() {\n+                            let generics = generics(self.db.upcast(), def);\n                             let param = generics\n                                 .iter()\n                                 .filter(|(_, data)| {\n                                     data.provenance == TypeParamProvenance::ArgumentImplTrait\n                                 })\n                                 .nth(idx as usize)\n                                 .map_or(TyKind::Unknown, |(id, _)| {\n-                                    TyKind::Placeholder(to_placeholder_idx(ctx.db, id))\n+                                    TyKind::Placeholder(to_placeholder_idx(self.db, id))\n                                 });\n                             param.intern(&Interner)\n                         } else {\n                             TyKind::Unknown.intern(&Interner)\n                         }\n                     }\n                     ImplTraitLoweringMode::Variable => {\n-                        let idx = ctx.impl_trait_counter.get();\n+                        let idx = self.impl_trait_counter.get();\n                         // FIXME we're probably doing something wrong here\n-                        ctx.impl_trait_counter.set(idx + count_impl_traits(type_ref) as u16);\n+                        self.impl_trait_counter.set(idx + count_impl_traits(type_ref) as u16);\n                         let (parent_params, self_params, list_params, _impl_trait_params) =\n-                            if let Some(def) = ctx.resolver.generic_def() {\n-                                let generics = generics(ctx.db.upcast(), def);\n+                            if let Some(def) = self.resolver.generic_def() {\n+                                let generics = generics(self.db.upcast(), def);\n                                 generics.provenance_split()\n                             } else {\n                                 (0, 0, 0, 0)\n                             };\n                         TyKind::BoundVar(BoundVar::new(\n-                            ctx.in_binders,\n+                            self.in_binders,\n                             idx as usize + parent_params + self_params + list_params,\n                         ))\n                         .intern(&Interner)\n@@ -286,7 +284,7 @@ impl Ty {\n     /// This is only for `generic_predicates_for_param`, where we can't just\n     /// lower the self types of the predicates since that could lead to cycles.\n     /// So we just check here if the `type_ref` resolves to a generic param, and which.\n-    fn from_hir_only_param(ctx: &TyLoweringContext<'_>, type_ref: &TypeRef) -> Option<TypeParamId> {\n+    fn lower_ty_only_param(&self, type_ref: &TypeRef) -> Option<TypeParamId> {\n         let path = match type_ref {\n             TypeRef::Path(path) => path,\n             _ => return None,\n@@ -298,7 +296,7 @@ impl Ty {\n             return None;\n         }\n         let resolution =\n-            match ctx.resolver.resolve_path_in_type_ns(ctx.db.upcast(), path.mod_path()) {\n+            match self.resolver.resolve_path_in_type_ns(self.db.upcast(), path.mod_path()) {\n                 Some((it, None)) => it,\n                 _ => return None,\n             };\n@@ -309,8 +307,8 @@ impl Ty {\n         }\n     }\n \n-    pub(crate) fn from_type_relative_path(\n-        ctx: &TyLoweringContext<'_>,\n+    pub(crate) fn lower_ty_relative_path(\n+        &self,\n         ty: Ty,\n         // We need the original resolution to lower `Self::AssocTy` correctly\n         res: Option<TypeNs>,\n@@ -319,7 +317,7 @@ impl Ty {\n         if remaining_segments.len() == 1 {\n             // resolve unselected assoc types\n             let segment = remaining_segments.first().unwrap();\n-            (Ty::select_associated_type(ctx, res, segment), None)\n+            (self.select_associated_type(res, segment), None)\n         } else if remaining_segments.len() > 1 {\n             // FIXME report error (ambiguous associated type)\n             (TyKind::Unknown.intern(&Interner), None)\n@@ -328,8 +326,8 @@ impl Ty {\n         }\n     }\n \n-    pub(crate) fn from_partly_resolved_hir_path(\n-        ctx: &TyLoweringContext<'_>,\n+    pub(crate) fn lower_partly_resolved_path(\n+        &self,\n         resolution: TypeNs,\n         resolved_segment: PathSegment<'_>,\n         remaining_segments: PathSegments<'_>,\n@@ -347,11 +345,11 @@ impl Ty {\n                     None\n                 };\n                 let trait_ref =\n-                    TraitRef::from_resolved_path(ctx, trait_, resolved_segment, self_ty);\n+                    self.lower_trait_ref_from_resolved_path(trait_, resolved_segment, self_ty);\n                 let ty = if remaining_segments.len() == 1 {\n                     let segment = remaining_segments.first().unwrap();\n                     let found = associated_type_by_name_including_super_traits(\n-                        ctx.db,\n+                        self.db,\n                         trait_ref,\n                         &segment.name,\n                     );\n@@ -380,68 +378,66 @@ impl Ty {\n             }\n             TypeNs::GenericParam(param_id) => {\n                 let generics = generics(\n-                    ctx.db.upcast(),\n-                    ctx.resolver.generic_def().expect(\"generics in scope\"),\n+                    self.db.upcast(),\n+                    self.resolver.generic_def().expect(\"generics in scope\"),\n                 );\n-                match ctx.type_param_mode {\n+                match self.type_param_mode {\n                     TypeParamLoweringMode::Placeholder => {\n-                        TyKind::Placeholder(to_placeholder_idx(ctx.db, param_id))\n+                        TyKind::Placeholder(to_placeholder_idx(self.db, param_id))\n                     }\n                     TypeParamLoweringMode::Variable => {\n                         let idx = generics.param_idx(param_id).expect(\"matching generics\");\n-                        TyKind::BoundVar(BoundVar::new(ctx.in_binders, idx))\n+                        TyKind::BoundVar(BoundVar::new(self.in_binders, idx))\n                     }\n                 }\n                 .intern(&Interner)\n             }\n             TypeNs::SelfType(impl_id) => {\n-                let generics = generics(ctx.db.upcast(), impl_id.into());\n-                let substs = match ctx.type_param_mode {\n+                let generics = generics(self.db.upcast(), impl_id.into());\n+                let substs = match self.type_param_mode {\n                     TypeParamLoweringMode::Placeholder => {\n-                        Substs::type_params_for_generics(ctx.db, &generics)\n+                        Substs::type_params_for_generics(self.db, &generics)\n                     }\n                     TypeParamLoweringMode::Variable => {\n-                        Substs::bound_vars(&generics, ctx.in_binders)\n+                        Substs::bound_vars(&generics, self.in_binders)\n                     }\n                 };\n-                ctx.db.impl_self_ty(impl_id).subst(&substs)\n+                self.db.impl_self_ty(impl_id).subst(&substs)\n             }\n             TypeNs::AdtSelfType(adt) => {\n-                let generics = generics(ctx.db.upcast(), adt.into());\n-                let substs = match ctx.type_param_mode {\n+                let generics = generics(self.db.upcast(), adt.into());\n+                let substs = match self.type_param_mode {\n                     TypeParamLoweringMode::Placeholder => {\n-                        Substs::type_params_for_generics(ctx.db, &generics)\n+                        Substs::type_params_for_generics(self.db, &generics)\n                     }\n                     TypeParamLoweringMode::Variable => {\n-                        Substs::bound_vars(&generics, ctx.in_binders)\n+                        Substs::bound_vars(&generics, self.in_binders)\n                     }\n                 };\n-                ctx.db.ty(adt.into()).subst(&substs)\n+                self.db.ty(adt.into()).subst(&substs)\n             }\n \n-            TypeNs::AdtId(it) => {\n-                Ty::from_hir_path_inner(ctx, resolved_segment, it.into(), infer_args)\n-            }\n+            TypeNs::AdtId(it) => self.lower_path_inner(resolved_segment, it.into(), infer_args),\n             TypeNs::BuiltinType(it) => {\n-                Ty::from_hir_path_inner(ctx, resolved_segment, it.into(), infer_args)\n+                self.lower_path_inner(resolved_segment, it.into(), infer_args)\n             }\n             TypeNs::TypeAliasId(it) => {\n-                Ty::from_hir_path_inner(ctx, resolved_segment, it.into(), infer_args)\n+                self.lower_path_inner(resolved_segment, it.into(), infer_args)\n             }\n             // FIXME: report error\n             TypeNs::EnumVariantId(_) => return (TyKind::Unknown.intern(&Interner), None),\n         };\n-        Ty::from_type_relative_path(ctx, ty, Some(resolution), remaining_segments)\n+        self.lower_ty_relative_path(ty, Some(resolution), remaining_segments)\n     }\n \n-    pub(crate) fn from_hir_path(ctx: &TyLoweringContext<'_>, path: &Path) -> (Ty, Option<TypeNs>) {\n+    pub(crate) fn lower_path(&self, path: &Path) -> (Ty, Option<TypeNs>) {\n         // Resolve the path (in type namespace)\n         if let Some(type_ref) = path.type_anchor() {\n-            let (ty, res) = Ty::from_hir_ext(ctx, &type_ref);\n-            return Ty::from_type_relative_path(ctx, ty, res, path.segments());\n+            let (ty, res) = self.lower_ty_ext(&type_ref);\n+            return self.lower_ty_relative_path(ty, res, path.segments());\n         }\n         let (resolution, remaining_index) =\n-            match ctx.resolver.resolve_path_in_type_ns(ctx.db.upcast(), path.mod_path()) {\n+            match self.resolver.resolve_path_in_type_ns(self.db.upcast(), path.mod_path()) {\n                 Some(it) => it,\n                 None => return (TyKind::Unknown.intern(&Interner), None),\n             };\n@@ -452,31 +448,23 @@ impl Ty {\n             ),\n             Some(i) => (path.segments().get(i - 1).unwrap(), path.segments().skip(i)),\n         };\n-        Ty::from_partly_resolved_hir_path(\n-            ctx,\n-            resolution,\n-            resolved_segment,\n-            remaining_segments,\n-            false,\n-        )\n+        self.lower_partly_resolved_path(resolution, resolved_segment, remaining_segments, false)\n     }\n \n-    fn select_associated_type(\n-        ctx: &TyLoweringContext<'_>,\n-        res: Option<TypeNs>,\n-        segment: PathSegment<'_>,\n-    ) -> Ty {\n+    fn select_associated_type(&self, res: Option<TypeNs>, segment: PathSegment<'_>) -> Ty {\n         if let Some(res) = res {\n-            let ty =\n-                associated_type_shorthand_candidates(ctx.db, res, move |name, t, associated_ty| {\n+            let ty = associated_type_shorthand_candidates(\n+                self.db,\n+                res,\n+                move |name, t, associated_ty| {\n                     if name == segment.name {\n-                        let substs = match ctx.type_param_mode {\n+                        let substs = match self.type_param_mode {\n                             TypeParamLoweringMode::Placeholder => {\n                                 // if we're lowering to placeholders, we have to put\n                                 // them in now\n                                 let s = Substs::type_params(\n-                                    ctx.db,\n-                                    ctx.resolver.generic_def().expect(\n+                                    self.db,\n+                                    self.resolver.generic_def().expect(\n                                         \"there should be generics if there's a generic param\",\n                                     ),\n                                 );\n@@ -486,7 +474,7 @@ impl Ty {\n                         };\n                         // We need to shift in the bound vars, since\n                         // associated_type_shorthand_candidates does not do that\n-                        let substs = substs.shift_bound_vars(ctx.in_binders);\n+                        let substs = substs.shift_bound_vars(self.in_binders);\n                         // FIXME handle type parameters on the segment\n                         return Some(\n                             TyKind::Alias(AliasTy::Projection(ProjectionTy {\n@@ -498,16 +486,17 @@ impl Ty {\n                     }\n \n                     None\n-                });\n+                },\n+            );\n \n             ty.unwrap_or(TyKind::Unknown.intern(&Interner))\n         } else {\n             TyKind::Unknown.intern(&Interner)\n         }\n     }\n \n-    fn from_hir_path_inner(\n-        ctx: &TyLoweringContext<'_>,\n+    fn lower_path_inner(\n+        &self,\n         segment: PathSegment<'_>,\n         typeable: TyDefId,\n         infer_args: bool,\n@@ -517,14 +506,14 @@ impl Ty {\n             TyDefId::AdtId(it) => Some(it.into()),\n             TyDefId::TypeAliasId(it) => Some(it.into()),\n         };\n-        let substs = substs_from_path_segment(ctx, segment, generic_def, infer_args);\n-        ctx.db.ty(typeable).subst(&substs)\n+        let substs = self.substs_from_path_segment(segment, generic_def, infer_args);\n+        self.db.ty(typeable).subst(&substs)\n     }\n \n     /// Collect generic arguments from a path into a `Substs`. See also\n     /// `create_substs_for_ast_path` and `def_to_ty` in rustc.\n     pub(super) fn substs_from_path(\n-        ctx: &TyLoweringContext<'_>,\n+        &self,\n         path: &Path,\n         // Note that we don't call `db.value_type(resolved)` here,\n         // `ValueTyDefId` is just a convenient way to pass generics and\n@@ -554,145 +543,137 @@ impl Ty {\n                 (segment, Some(var.parent.into()))\n             }\n         };\n-        substs_from_path_segment(ctx, segment, generic_def, infer_args)\n+        self.substs_from_path_segment(segment, generic_def, infer_args)\n     }\n-}\n \n-fn substs_from_path_segment(\n-    ctx: &TyLoweringContext<'_>,\n-    segment: PathSegment<'_>,\n-    def_generic: Option<GenericDefId>,\n-    infer_args: bool,\n-) -> Substs {\n-    let mut substs = Vec::new();\n-    let def_generics = def_generic.map(|def| generics(ctx.db.upcast(), def));\n+    fn substs_from_path_segment(\n+        &self,\n+        segment: PathSegment<'_>,\n+        def_generic: Option<GenericDefId>,\n+        infer_args: bool,\n+    ) -> Substs {\n+        let mut substs = Vec::new();\n+        let def_generics = def_generic.map(|def| generics(self.db.upcast(), def));\n \n-    let (parent_params, self_params, type_params, impl_trait_params) =\n-        def_generics.map_or((0, 0, 0, 0), |g| g.provenance_split());\n-    let total_len = parent_params + self_params + type_params + impl_trait_params;\n+        let (parent_params, self_params, type_params, impl_trait_params) =\n+            def_generics.map_or((0, 0, 0, 0), |g| g.provenance_split());\n+        let total_len = parent_params + self_params + type_params + impl_trait_params;\n \n-    substs.extend(iter::repeat(TyKind::Unknown.intern(&Interner)).take(parent_params));\n+        substs.extend(iter::repeat(TyKind::Unknown.intern(&Interner)).take(parent_params));\n \n-    let mut had_explicit_type_args = false;\n+        let mut had_explicit_type_args = false;\n \n-    if let Some(generic_args) = &segment.args_and_bindings {\n-        if !generic_args.has_self_type {\n-            substs.extend(iter::repeat(TyKind::Unknown.intern(&Interner)).take(self_params));\n-        }\n-        let expected_num =\n-            if generic_args.has_self_type { self_params + type_params } else { type_params };\n-        let skip = if generic_args.has_self_type && self_params == 0 { 1 } else { 0 };\n-        // if args are provided, it should be all of them, but we can't rely on that\n-        for arg in generic_args\n-            .args\n-            .iter()\n-            .filter(|arg| matches!(arg, GenericArg::Type(_)))\n-            .skip(skip)\n-            .take(expected_num)\n-        {\n-            match arg {\n-                GenericArg::Type(type_ref) => {\n-                    had_explicit_type_args = true;\n-                    let ty = Ty::from_hir(ctx, type_ref);\n-                    substs.push(ty);\n+        if let Some(generic_args) = &segment.args_and_bindings {\n+            if !generic_args.has_self_type {\n+                substs.extend(iter::repeat(TyKind::Unknown.intern(&Interner)).take(self_params));\n+            }\n+            let expected_num =\n+                if generic_args.has_self_type { self_params + type_params } else { type_params };\n+            let skip = if generic_args.has_self_type && self_params == 0 { 1 } else { 0 };\n+            // if args are provided, it should be all of them, but we can't rely on that\n+            for arg in generic_args\n+                .args\n+                .iter()\n+                .filter(|arg| matches!(arg, GenericArg::Type(_)))\n+                .skip(skip)\n+                .take(expected_num)\n+            {\n+                match arg {\n+                    GenericArg::Type(type_ref) => {\n+                        had_explicit_type_args = true;\n+                        let ty = self.lower_ty(type_ref);\n+                        substs.push(ty);\n+                    }\n+                    GenericArg::Lifetime(_) => {}\n                 }\n-                GenericArg::Lifetime(_) => {}\n             }\n         }\n-    }\n \n-    // handle defaults. In expression or pattern path segments without\n-    // explicitly specified type arguments, missing type arguments are inferred\n-    // (i.e. defaults aren't used).\n-    if !infer_args || had_explicit_type_args {\n-        if let Some(def_generic) = def_generic {\n-            let defaults = ctx.db.generic_defaults(def_generic);\n-            assert_eq!(total_len, defaults.len());\n-\n-            for default_ty in defaults.iter().skip(substs.len()) {\n-                // each default can depend on the previous parameters\n-                let substs_so_far = Substs(substs.clone().into());\n-                substs.push(default_ty.clone().subst(&substs_so_far));\n+        // handle defaults. In expression or pattern path segments without\n+        // explicitly specified type arguments, missing type arguments are inferred\n+        // (i.e. defaults aren't used).\n+        if !infer_args || had_explicit_type_args {\n+            if let Some(def_generic) = def_generic {\n+                let defaults = self.db.generic_defaults(def_generic);\n+                assert_eq!(total_len, defaults.len());\n+\n+                for default_ty in defaults.iter().skip(substs.len()) {\n+                    // each default can depend on the previous parameters\n+                    let substs_so_far = Substs(substs.clone().into());\n+                    substs.push(default_ty.clone().subst(&substs_so_far));\n+                }\n             }\n         }\n-    }\n \n-    // add placeholders for args that were not provided\n-    // FIXME: emit diagnostics in contexts where this is not allowed\n-    for _ in substs.len()..total_len {\n-        substs.push(TyKind::Unknown.intern(&Interner));\n-    }\n-    assert_eq!(substs.len(), total_len);\n+        // add placeholders for args that were not provided\n+        // FIXME: emit diagnostics in contexts where this is not allowed\n+        for _ in substs.len()..total_len {\n+            substs.push(TyKind::Unknown.intern(&Interner));\n+        }\n+        assert_eq!(substs.len(), total_len);\n \n-    Substs(substs.into())\n-}\n+        Substs(substs.into())\n+    }\n \n-impl TraitRef {\n-    fn from_path(\n-        ctx: &TyLoweringContext<'_>,\n+    fn lower_trait_ref_from_path(\n+        &self,\n         path: &Path,\n         explicit_self_ty: Option<Ty>,\n-    ) -> Option<Self> {\n+    ) -> Option<TraitRef> {\n         let resolved =\n-            match ctx.resolver.resolve_path_in_type_ns_fully(ctx.db.upcast(), path.mod_path())? {\n+            match self.resolver.resolve_path_in_type_ns_fully(self.db.upcast(), path.mod_path())? {\n                 TypeNs::TraitId(tr) => tr,\n                 _ => return None,\n             };\n         let segment = path.segments().last().expect(\"path should have at least one segment\");\n-        Some(TraitRef::from_resolved_path(ctx, resolved, segment, explicit_self_ty))\n+        Some(self.lower_trait_ref_from_resolved_path(resolved, segment, explicit_self_ty))\n     }\n \n-    pub(crate) fn from_resolved_path(\n-        ctx: &TyLoweringContext<'_>,\n+    pub(crate) fn lower_trait_ref_from_resolved_path(\n+        &self,\n         resolved: TraitId,\n         segment: PathSegment<'_>,\n         explicit_self_ty: Option<Ty>,\n-    ) -> Self {\n-        let mut substs = TraitRef::substs_from_path(ctx, segment, resolved);\n+    ) -> TraitRef {\n+        let mut substs = self.trait_ref_substs_from_path(segment, resolved);\n         if let Some(self_ty) = explicit_self_ty {\n             make_mut_slice(&mut substs.0)[0] = self_ty;\n         }\n         TraitRef { trait_: resolved, substs }\n     }\n \n-    fn from_hir(\n-        ctx: &TyLoweringContext<'_>,\n+    fn lower_trait_ref(\n+        &self,\n         type_ref: &TypeRef,\n         explicit_self_ty: Option<Ty>,\n-    ) -> Option<Self> {\n+    ) -> Option<TraitRef> {\n         let path = match type_ref {\n             TypeRef::Path(path) => path,\n             _ => return None,\n         };\n-        TraitRef::from_path(ctx, path, explicit_self_ty)\n+        self.lower_trait_ref_from_path(path, explicit_self_ty)\n     }\n \n-    fn substs_from_path(\n-        ctx: &TyLoweringContext<'_>,\n-        segment: PathSegment<'_>,\n-        resolved: TraitId,\n-    ) -> Substs {\n-        substs_from_path_segment(ctx, segment, Some(resolved.into()), false)\n+    fn trait_ref_substs_from_path(&self, segment: PathSegment<'_>, resolved: TraitId) -> Substs {\n+        self.substs_from_path_segment(segment, Some(resolved.into()), false)\n     }\n-}\n \n-impl GenericPredicate {\n-    pub(crate) fn from_where_predicate<'a>(\n-        ctx: &'a TyLoweringContext<'a>,\n+    pub(crate) fn lower_where_predicate(\n+        &'a self,\n         where_predicate: &'a WherePredicate,\n     ) -> impl Iterator<Item = GenericPredicate> + 'a {\n         match where_predicate {\n             WherePredicate::ForLifetime { target, bound, .. }\n             | WherePredicate::TypeBound { target, bound } => {\n                 let self_ty = match target {\n-                    WherePredicateTypeTarget::TypeRef(type_ref) => Ty::from_hir(ctx, type_ref),\n+                    WherePredicateTypeTarget::TypeRef(type_ref) => self.lower_ty(type_ref),\n                     WherePredicateTypeTarget::TypeParam(param_id) => {\n-                        let generic_def = ctx.resolver.generic_def().expect(\"generics in scope\");\n-                        let generics = generics(ctx.db.upcast(), generic_def);\n+                        let generic_def = self.resolver.generic_def().expect(\"generics in scope\");\n+                        let generics = generics(self.db.upcast(), generic_def);\n                         let param_id =\n                             hir_def::TypeParamId { parent: generic_def, local_id: *param_id };\n-                        let placeholder = to_placeholder_idx(ctx.db, param_id);\n-                        match ctx.type_param_mode {\n+                        let placeholder = to_placeholder_idx(self.db, param_id);\n+                        match self.type_param_mode {\n                             TypeParamLoweringMode::Placeholder => TyKind::Placeholder(placeholder),\n                             TypeParamLoweringMode::Variable => {\n                                 let idx = generics.param_idx(param_id).expect(\"matching generics\");\n@@ -702,23 +683,21 @@ impl GenericPredicate {\n                         .intern(&Interner)\n                     }\n                 };\n-                GenericPredicate::from_type_bound(ctx, bound, self_ty)\n-                    .collect::<Vec<_>>()\n-                    .into_iter()\n+                self.lower_type_bound(bound, self_ty).collect::<Vec<_>>().into_iter()\n             }\n             WherePredicate::Lifetime { .. } => vec![].into_iter(),\n         }\n     }\n \n-    pub(crate) fn from_type_bound<'a>(\n-        ctx: &'a TyLoweringContext<'a>,\n+    pub(crate) fn lower_type_bound(\n+        &'a self,\n         bound: &'a TypeBound,\n         self_ty: Ty,\n     ) -> impl Iterator<Item = GenericPredicate> + 'a {\n         let mut bindings = None;\n         let trait_ref = match bound {\n             TypeBound::Path(path) => {\n-                bindings = TraitRef::from_path(ctx, path, Some(self_ty));\n+                bindings = self.lower_trait_ref_from_path(path, Some(self_ty));\n                 Some(\n                     bindings.clone().map_or(GenericPredicate::Error, GenericPredicate::Implemented),\n                 )\n@@ -729,68 +708,62 @@ impl GenericPredicate {\n         trait_ref.into_iter().chain(\n             bindings\n                 .into_iter()\n-                .flat_map(move |tr| assoc_type_bindings_from_type_bound(ctx, bound, tr)),\n+                .flat_map(move |tr| self.assoc_type_bindings_from_type_bound(bound, tr)),\n         )\n     }\n-}\n \n-fn assoc_type_bindings_from_type_bound<'a>(\n-    ctx: &'a TyLoweringContext<'a>,\n-    bound: &'a TypeBound,\n-    trait_ref: TraitRef,\n-) -> impl Iterator<Item = GenericPredicate> + 'a {\n-    let last_segment = match bound {\n-        TypeBound::Path(path) => path.segments().last(),\n-        TypeBound::Error | TypeBound::Lifetime(_) => None,\n-    };\n-    last_segment\n-        .into_iter()\n-        .flat_map(|segment| segment.args_and_bindings.into_iter())\n-        .flat_map(|args_and_bindings| args_and_bindings.bindings.iter())\n-        .flat_map(move |binding| {\n-            let found = associated_type_by_name_including_super_traits(\n-                ctx.db,\n-                trait_ref.clone(),\n-                &binding.name,\n-            );\n-            let (super_trait_ref, associated_ty) = match found {\n-                None => return SmallVec::<[GenericPredicate; 1]>::new(),\n-                Some(t) => t,\n-            };\n-            let projection_ty = ProjectionTy {\n-                associated_ty: to_assoc_type_id(associated_ty),\n-                parameters: super_trait_ref.substs,\n-            };\n-            let mut preds = SmallVec::with_capacity(\n-                binding.type_ref.as_ref().map_or(0, |_| 1) + binding.bounds.len(),\n-            );\n-            if let Some(type_ref) = &binding.type_ref {\n-                let ty = Ty::from_hir(ctx, type_ref);\n-                let projection_predicate =\n-                    ProjectionPredicate { projection_ty: projection_ty.clone(), ty };\n-                preds.push(GenericPredicate::Projection(projection_predicate));\n-            }\n-            for bound in &binding.bounds {\n-                preds.extend(GenericPredicate::from_type_bound(\n-                    ctx,\n-                    bound,\n-                    TyKind::Alias(AliasTy::Projection(projection_ty.clone())).intern(&Interner),\n-                ));\n-            }\n-            preds\n-        })\n-}\n+    fn assoc_type_bindings_from_type_bound(\n+        &'a self,\n+        bound: &'a TypeBound,\n+        trait_ref: TraitRef,\n+    ) -> impl Iterator<Item = GenericPredicate> + 'a {\n+        let last_segment = match bound {\n+            TypeBound::Path(path) => path.segments().last(),\n+            TypeBound::Error | TypeBound::Lifetime(_) => None,\n+        };\n+        last_segment\n+            .into_iter()\n+            .flat_map(|segment| segment.args_and_bindings.into_iter())\n+            .flat_map(|args_and_bindings| args_and_bindings.bindings.iter())\n+            .flat_map(move |binding| {\n+                let found = associated_type_by_name_including_super_traits(\n+                    self.db,\n+                    trait_ref.clone(),\n+                    &binding.name,\n+                );\n+                let (super_trait_ref, associated_ty) = match found {\n+                    None => return SmallVec::<[GenericPredicate; 1]>::new(),\n+                    Some(t) => t,\n+                };\n+                let projection_ty = ProjectionTy {\n+                    associated_ty: to_assoc_type_id(associated_ty),\n+                    parameters: super_trait_ref.substs,\n+                };\n+                let mut preds = SmallVec::with_capacity(\n+                    binding.type_ref.as_ref().map_or(0, |_| 1) + binding.bounds.len(),\n+                );\n+                if let Some(type_ref) = &binding.type_ref {\n+                    let ty = self.lower_ty(type_ref);\n+                    let projection_predicate =\n+                        ProjectionPredicate { projection_ty: projection_ty.clone(), ty };\n+                    preds.push(GenericPredicate::Projection(projection_predicate));\n+                }\n+                for bound in &binding.bounds {\n+                    preds.extend(self.lower_type_bound(\n+                        bound,\n+                        TyKind::Alias(AliasTy::Projection(projection_ty.clone())).intern(&Interner),\n+                    ));\n+                }\n+                preds\n+            })\n+    }\n \n-impl ReturnTypeImplTrait {\n-    fn from_hir(ctx: &TyLoweringContext, bounds: &[TypeBound]) -> Self {\n+    fn lower_impl_trait(&self, bounds: &[TypeBound]) -> ReturnTypeImplTrait {\n         cov_mark::hit!(lower_rpit);\n         let self_ty =\n             TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0)).intern(&Interner);\n-        let predicates = ctx.with_shifted_in(DebruijnIndex::ONE, |ctx| {\n-            bounds\n-                .iter()\n-                .flat_map(|b| GenericPredicate::from_type_bound(ctx, b, self_ty.clone()))\n-                .collect()\n+        let predicates = self.with_shifted_in(DebruijnIndex::ONE, |ctx| {\n+            bounds.iter().flat_map(|b| ctx.lower_type_bound(b, self_ty.clone())).collect()\n         });\n         ReturnTypeImplTrait { bounds: Binders::new(1, predicates) }\n     }\n@@ -886,7 +859,7 @@ pub(crate) fn field_types_query(\n     let ctx =\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n     for (field_id, field_data) in var_data.fields().iter() {\n-        res.insert(field_id, Binders::new(generics.len(), Ty::from_hir(&ctx, &field_data.type_ref)))\n+        res.insert(field_id, Binders::new(generics.len(), ctx.lower_ty(&field_data.type_ref)))\n     }\n     Arc::new(res)\n }\n@@ -914,16 +887,13 @@ pub(crate) fn generic_predicates_for_param_query(\n             WherePredicate::ForLifetime { target, .. }\n             | WherePredicate::TypeBound { target, .. } => match target {\n                 WherePredicateTypeTarget::TypeRef(type_ref) => {\n-                    Ty::from_hir_only_param(&ctx, type_ref) == Some(param_id)\n+                    ctx.lower_ty_only_param(type_ref) == Some(param_id)\n                 }\n                 WherePredicateTypeTarget::TypeParam(local_id) => *local_id == param_id.local_id,\n             },\n             WherePredicate::Lifetime { .. } => false,\n         })\n-        .flat_map(|pred| {\n-            GenericPredicate::from_where_predicate(&ctx, pred)\n-                .map(|p| Binders::new(generics.len(), p))\n-        })\n+        .flat_map(|pred| ctx.lower_where_predicate(pred).map(|p| Binders::new(generics.len(), p)))\n         .collect()\n }\n \n@@ -945,7 +915,7 @@ pub(crate) fn trait_environment_query(\n     let mut traits_in_scope = Vec::new();\n     let mut clauses = Vec::new();\n     for pred in resolver.where_predicates_in_scope() {\n-        for pred in GenericPredicate::from_where_predicate(&ctx, pred) {\n+        for pred in ctx.lower_where_predicate(pred) {\n             if pred.is_error() {\n                 continue;\n             }\n@@ -997,10 +967,7 @@ pub(crate) fn generic_predicates_query(\n     let generics = generics(db.upcast(), def);\n     resolver\n         .where_predicates_in_scope()\n-        .flat_map(|pred| {\n-            GenericPredicate::from_where_predicate(&ctx, pred)\n-                .map(|p| Binders::new(generics.len(), p))\n-        })\n+        .flat_map(|pred| ctx.lower_where_predicate(pred).map(|p| Binders::new(generics.len(), p)))\n         .collect()\n }\n \n@@ -1018,10 +985,8 @@ pub(crate) fn generic_defaults_query(\n         .iter()\n         .enumerate()\n         .map(|(idx, (_, p))| {\n-            let mut ty = p\n-                .default\n-                .as_ref()\n-                .map_or(TyKind::Unknown.intern(&Interner), |t| Ty::from_hir(&ctx, t));\n+            let mut ty =\n+                p.default.as_ref().map_or(TyKind::Unknown.intern(&Interner), |t| ctx.lower_ty(t));\n \n             // Each default can only refer to previous parameters.\n             ty.walk_mut_binders(\n@@ -1052,11 +1017,11 @@ fn fn_sig_for_fn(db: &dyn HirDatabase, def: FunctionId) -> PolyFnSig {\n     let ctx_params = TyLoweringContext::new(db, &resolver)\n         .with_impl_trait_mode(ImplTraitLoweringMode::Variable)\n         .with_type_param_mode(TypeParamLoweringMode::Variable);\n-    let params = data.params.iter().map(|tr| Ty::from_hir(&ctx_params, tr)).collect::<Vec<_>>();\n+    let params = data.params.iter().map(|tr| (&ctx_params).lower_ty(tr)).collect::<Vec<_>>();\n     let ctx_ret = TyLoweringContext::new(db, &resolver)\n         .with_impl_trait_mode(ImplTraitLoweringMode::Opaque)\n         .with_type_param_mode(TypeParamLoweringMode::Variable);\n-    let ret = Ty::from_hir(&ctx_ret, &data.ret_type);\n+    let ret = (&ctx_ret).lower_ty(&data.ret_type);\n     let generics = generics(db.upcast(), def.into());\n     let num_binders = generics.len();\n     Binders::new(num_binders, CallableSig::from_params_and_return(params, ret, data.is_varargs))\n@@ -1081,7 +1046,7 @@ fn type_for_const(db: &dyn HirDatabase, def: ConstId) -> Binders<Ty> {\n     let ctx =\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n \n-    Binders::new(generics.len(), Ty::from_hir(&ctx, &data.type_ref))\n+    Binders::new(generics.len(), ctx.lower_ty(&data.type_ref))\n }\n \n /// Build the declared type of a static.\n@@ -1090,7 +1055,7 @@ fn type_for_static(db: &dyn HirDatabase, def: StaticId) -> Binders<Ty> {\n     let resolver = def.resolver(db.upcast());\n     let ctx = TyLoweringContext::new(db, &resolver);\n \n-    Binders::new(0, Ty::from_hir(&ctx, &data.type_ref))\n+    Binders::new(0, ctx.lower_ty(&data.type_ref))\n }\n \n fn fn_sig_for_struct_constructor(db: &dyn HirDatabase, def: StructId) -> PolyFnSig {\n@@ -1099,8 +1064,7 @@ fn fn_sig_for_struct_constructor(db: &dyn HirDatabase, def: StructId) -> PolyFnS\n     let resolver = def.resolver(db.upcast());\n     let ctx =\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n-    let params =\n-        fields.iter().map(|(_, field)| Ty::from_hir(&ctx, &field.type_ref)).collect::<Vec<_>>();\n+    let params = fields.iter().map(|(_, field)| ctx.lower_ty(&field.type_ref)).collect::<Vec<_>>();\n     let ret = type_for_adt(db, def.into());\n     Binders::new(ret.num_binders, CallableSig::from_params_and_return(params, ret.value, false))\n }\n@@ -1126,8 +1090,7 @@ fn fn_sig_for_enum_variant_constructor(db: &dyn HirDatabase, def: EnumVariantId)\n     let resolver = def.parent.resolver(db.upcast());\n     let ctx =\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n-    let params =\n-        fields.iter().map(|(_, field)| Ty::from_hir(&ctx, &field.type_ref)).collect::<Vec<_>>();\n+    let params = fields.iter().map(|(_, field)| ctx.lower_ty(&field.type_ref)).collect::<Vec<_>>();\n     let ret = type_for_adt(db, def.parent.into());\n     Binders::new(ret.num_binders, CallableSig::from_params_and_return(params, ret.value, false))\n }\n@@ -1163,7 +1126,7 @@ fn type_for_type_alias(db: &dyn HirDatabase, t: TypeAliasId) -> Binders<Ty> {\n     } else {\n         let substs = Substs::bound_vars(&generics, DebruijnIndex::INNERMOST);\n         let type_ref = &db.type_alias_data(t).type_ref;\n-        let inner = Ty::from_hir(&ctx, type_ref.as_ref().unwrap_or(&TypeRef::Error));\n+        let inner = ctx.lower_ty(type_ref.as_ref().unwrap_or(&TypeRef::Error));\n         Binders::new(substs.len(), inner)\n     }\n }\n@@ -1255,7 +1218,7 @@ pub(crate) fn impl_self_ty_query(db: &dyn HirDatabase, impl_id: ImplId) -> Binde\n     let generics = generics(db.upcast(), impl_id.into());\n     let ctx =\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n-    Binders::new(generics.len(), Ty::from_hir(&ctx, &impl_data.target_type))\n+    Binders::new(generics.len(), ctx.lower_ty(&impl_data.target_type))\n }\n \n pub(crate) fn const_param_ty_query(db: &dyn HirDatabase, def: ConstParamId) -> Ty {\n@@ -1264,7 +1227,7 @@ pub(crate) fn const_param_ty_query(db: &dyn HirDatabase, def: ConstParamId) -> T\n     let resolver = def.parent.resolver(db.upcast());\n     let ctx = TyLoweringContext::new(db, &resolver);\n \n-    Ty::from_hir(&ctx, &data.ty)\n+    ctx.lower_ty(&data.ty)\n }\n \n pub(crate) fn impl_self_ty_recover(\n@@ -1283,10 +1246,7 @@ pub(crate) fn impl_trait_query(db: &dyn HirDatabase, impl_id: ImplId) -> Option<\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n     let self_ty = db.impl_self_ty(impl_id);\n     let target_trait = impl_data.target_trait.as_ref()?;\n-    Some(Binders::new(\n-        self_ty.num_binders,\n-        TraitRef::from_hir(&ctx, target_trait, Some(self_ty.value))?,\n-    ))\n+    Some(Binders::new(self_ty.num_binders, ctx.lower_trait_ref(target_trait, Some(self_ty.value))?))\n }\n \n pub(crate) fn return_type_impl_traits(\n@@ -1299,7 +1259,7 @@ pub(crate) fn return_type_impl_traits(\n     let ctx_ret = TyLoweringContext::new(db, &resolver)\n         .with_impl_trait_mode(ImplTraitLoweringMode::Opaque)\n         .with_type_param_mode(TypeParamLoweringMode::Variable);\n-    let _ret = Ty::from_hir(&ctx_ret, &data.ret_type);\n+    let _ret = (&ctx_ret).lower_ty(&data.ret_type);\n     let generics = generics(db.upcast(), def.into());\n     let num_binders = generics.len();\n     let return_type_impl_traits ="}, {"sha": "ef1e6b2df818f661c8bd4aef04bf24f5bfc783bd", "filename": "crates/hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3743ede404d38586db9d7febca14b8bebcbbe0ef/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3743ede404d38586db9d7febca14b8bebcbbe0ef/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=3743ede404d38586db9d7febca14b8bebcbbe0ef", "patch": "@@ -401,7 +401,7 @@ pub(crate) fn associated_ty_data_query(\n     let bounds = type_alias_data\n         .bounds\n         .iter()\n-        .flat_map(|bound| GenericPredicate::from_type_bound(&ctx, bound, self_ty.clone()))\n+        .flat_map(|bound| ctx.lower_type_bound(bound, self_ty.clone()))\n         .filter_map(|pred| generic_predicate_to_inline_bound(db, &pred, &self_ty))\n         .map(|bound| make_binders(bound.shifted_in(&Interner), 0))\n         .collect();"}]}