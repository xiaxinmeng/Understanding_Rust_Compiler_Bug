{"sha": "ab03c1e42218a08f6051e5708e6a538d3db9f1f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiMDNjMWU0MjIxOGEwOGY2MDUxZTU3MDhlNmE1MzhkM2RiOWYxZjM=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-04-01T22:50:58Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-04-28T16:51:14Z"}, "message": "refactoring to split foreign_items from items", "tree": {"sha": "c05736d4533ea80e66838f90308f4e4b5f47d0d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c05736d4533ea80e66838f90308f4e4b5f47d0d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab03c1e42218a08f6051e5708e6a538d3db9f1f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab03c1e42218a08f6051e5708e6a538d3db9f1f3", "html_url": "https://github.com/rust-lang/rust/commit/ab03c1e42218a08f6051e5708e6a538d3db9f1f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab03c1e42218a08f6051e5708e6a538d3db9f1f3/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa5ba17c8962320963bbac1d237babffe4cdb495", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa5ba17c8962320963bbac1d237babffe4cdb495", "html_url": "https://github.com/rust-lang/rust/commit/fa5ba17c8962320963bbac1d237babffe4cdb495"}], "stats": {"total": 333, "additions": 169, "deletions": 164}, "files": [{"sha": "78d0f8320715a0e34f99554c09391e5791bea296", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 169, "deletions": 164, "changes": 333, "blob_url": "https://github.com/rust-lang/rust/blob/ab03c1e42218a08f6051e5708e6a538d3db9f1f3/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab03c1e42218a08f6051e5708e6a538d3db9f1f3/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=ab03c1e42218a08f6051e5708e6a538d3db9f1f3", "patch": "@@ -2552,7 +2552,7 @@ pub impl Parser {\n                                          self.parse_outer_attributes());\n \n             match self.parse_item_or_view_item(/*bad*/ copy item_attrs,\n-                                               true, false, false) {\n+                                                           false) {\n               iovi_item(i) => {\n                 let hi = i.span.hi;\n                 let decl = @spanned(lo, hi, decl_item(i));\n@@ -2642,7 +2642,7 @@ pub impl Parser {\n             items: items,\n             _\n         } = self.parse_items_and_view_items(first_item_attrs,\n-                                            IMPORTS_AND_ITEMS_ALLOWED, false);\n+                                            false, false);\n \n         for items.each |item| {\n             let decl = @spanned(item.span.lo, item.span.hi, decl_item(*item));\n@@ -2763,7 +2763,7 @@ pub impl Parser {\n \n     // matches optbounds = ( ( : ( boundseq )? )? )\n     // where   boundseq  = ( bound + boundseq ) | bound\n-    // and     bound     = ( 'static ) | ty\n+    // and     bound     = 'static | ty\n     fn parse_optional_ty_param_bounds(&self) -> @OptVec<TyParamBound> {\n         if !self.eat(&token::COLON) {\n             return @opt_vec::Empty;\n@@ -3431,8 +3431,7 @@ pub impl Parser {\n             items: starting_items,\n             _\n         } = self.parse_items_and_view_items(first_item_attrs,\n-                                            VIEW_ITEMS_AND_ITEMS_ALLOWED,\n-                                            true);\n+                                            true, true);\n         let mut items: ~[@item] = starting_items;\n         let attrs_remaining_len = attrs_remaining.len();\n \n@@ -3450,8 +3449,6 @@ pub impl Parser {\n                    attrs);\n             match self.parse_item_or_view_item(\n                 /*bad*/ copy attrs,\n-                true, // items allowed\n-                false, // foreign items allowed\n                 true // macros allowed\n             ) {\n               iovi_item(item) => items.push(item),\n@@ -3668,15 +3665,7 @@ pub impl Parser {\n         else { self.unexpected(); }\n     }\n \n-    fn parse_foreign_item(&self, attrs: ~[attribute]) -> @foreign_item {\n-        let vis = self.parse_visibility();\n-        if self.is_keyword(&~\"const\") || self.is_keyword(&~\"static\") {\n-            self.parse_item_foreign_const(vis, attrs)\n-        } else {\n-            self.parse_item_foreign_fn(attrs)\n-        }\n-    }\n-\n+    // how is this different from parse_foreign_items\n     fn parse_foreign_mod_items(&self, sort: ast::foreign_mod_sort,\n                                abis: AbiSet,\n                                first_item_attrs: ~[attribute])\n@@ -3687,23 +3676,14 @@ pub impl Parser {\n             view_items: view_items,\n             items: _,\n             foreign_items: foreign_items\n-        } = self.parse_items_and_view_items(first_item_attrs,\n-                                            FOREIGN_ITEMS_ALLOWED,\n-                                            true);\n-\n-        let mut items: ~[@foreign_item] = foreign_items;\n+        } = self.parse_foreign_items(first_item_attrs, true);\n         let mut initial_attrs = attrs_remaining;\n-        while *self.token != token::RBRACE {\n-            let attrs = vec::append(initial_attrs,\n-                                    self.parse_outer_attributes());\n-            initial_attrs = ~[];\n-            items.push(self.parse_foreign_item(attrs));\n-        }\n+        assert!(*self.token == token::RBRACE);\n         ast::foreign_mod {\n             sort: sort,\n             abis: abis,\n             view_items: view_items,\n-            items: items\n+            items: foreign_items\n         }\n     }\n \n@@ -3965,6 +3945,7 @@ pub impl Parser {\n         }\n     }\n \n+    // parse a string as an ABI spec on an extern type or module\n     fn parse_opt_abis(&self) -> Option<AbiSet> {\n         match *self.token {\n             token::LIT_STR(s) => {\n@@ -4010,31 +3991,53 @@ pub impl Parser {\n \n     // parse one of the items or view items allowed by the\n     // flags; on failure, return iovi_none.\n+    // NB: this function no longer parses the items inside an\n+    // extern mod.\n     fn parse_item_or_view_item(\n         &self,\n         attrs: ~[attribute],\n-        items_allowed: bool,\n-        foreign_items_allowed: bool,\n         macros_allowed: bool\n     ) -> item_or_view_item {\n-        assert!(items_allowed != foreign_items_allowed);\n-\n         maybe_whole!(iovi self, nt_item);\n         let lo = self.span.lo;\n \n-        let visibility;\n-        if self.eat_keyword(&~\"pub\") {\n-            visibility = public;\n-        } else if self.eat_keyword(&~\"priv\") {\n-            visibility = private;\n-        } else {\n-            visibility = inherited;\n+        let visibility = self.parse_visibility();\n+\n+        // must be a view item:\n+        if self.eat_keyword(&~\"use\") {\n+            // USE ITEM (iovi_view_item)\n+            let view_item = self.parse_use();\n+            self.expect(&token::SEMI);\n+            return iovi_view_item(@ast::view_item {\n+                node: view_item,\n+                attrs: attrs,\n+                vis: visibility,\n+                span: mk_sp(lo, self.last_span.hi)\n+            });\n         }\n+        // either a view item or an item:\n+        if self.eat_keyword(&~\"extern\") {\n+            let opt_abis = self.parse_opt_abis();\n \n-        if items_allowed &&\n-                (self.is_keyword(&~\"const\") ||\n-                (self.is_keyword(&~\"static\") &&\n-                    !self.token_is_keyword(&~\"fn\", &self.look_ahead(1)))) {\n+            if self.eat_keyword(&~\"fn\") {\n+                // EXTERN FUNCTION ITEM\n+                let abis = opt_abis.get_or_default(AbiSet::C());\n+                let (ident, item_, extra_attrs) =\n+                    self.parse_item_fn(extern_fn, abis);\n+                return iovi_item(self.mk_item(lo, self.last_span.hi, ident,\n+                                              item_, visibility,\n+                                              maybe_append(attrs,\n+                                                           extra_attrs)));\n+            } else  {\n+                // EXTERN MODULE ITEM (iovi_view_item)\n+                return self.parse_item_foreign_mod(lo, opt_abis, visibility, attrs,\n+                                                   true);\n+            }\n+        }\n+        // the rest are all guaranteed to be items:\n+        if (self.is_keyword(&~\"const\") ||\n+            (self.is_keyword(&~\"static\") &&\n+             !self.token_is_keyword(&~\"fn\", &self.look_ahead(1)))) {\n             // CONST / STATIC ITEM\n             if self.is_keyword(&~\"const\") {\n                 self.obsolete(*self.span, ObsoleteConstItem);\n@@ -4045,13 +4048,7 @@ pub impl Parser {\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         }\n-        if foreign_items_allowed &&\n-                (self.is_keyword(&~\"const\") || self.is_keyword(&~\"static\")) {\n-            // FOREIGN CONST ITEM\n-            let item = self.parse_item_foreign_const(visibility, attrs);\n-            return iovi_foreign_item(item);\n-        }\n-        if items_allowed && self.is_keyword(&~\"fn\") &&\n+        if self.is_keyword(&~\"fn\") &&\n             !self.fn_expr_lookahead(self.look_ahead(1u)) {\n             // FUNCTION ITEM\n             self.bump();\n@@ -4061,7 +4058,7 @@ pub impl Parser {\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         }\n-        if items_allowed && self.eat_keyword(&~\"pure\") {\n+        if self.eat_keyword(&~\"pure\") {\n             // PURE FUNCTION ITEM (obsolete)\n             self.obsolete(*self.last_span, ObsoletePurity);\n             self.expect_keyword(&~\"fn\");\n@@ -4071,16 +4068,9 @@ pub impl Parser {\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         }\n-        if foreign_items_allowed &&\n-            (self.is_keyword(&~\"fn\") || self.is_keyword(&~\"pure\") ||\n-             self.is_keyword(&~\"unsafe\")) {\n-            // FOREIGN FUNCTION ITEM (no items allowed)\n-                let item = self.parse_item_foreign_fn(attrs);\n-                return iovi_foreign_item(item);\n-        }\n-        if items_allowed && self.is_keyword(&~\"unsafe\")\n+        if self.is_keyword(&~\"unsafe\")\n             && self.look_ahead(1u) != token::LBRACE {\n-            // UNSAFE FUNCTION ITEM (where items are allowed)\n+            // UNSAFE FUNCTION ITEM\n             self.bump();\n             self.expect_keyword(&~\"fn\");\n             let (ident, item_, extra_attrs) =\n@@ -4089,80 +4079,86 @@ pub impl Parser {\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         }\n-        if self.eat_keyword(&~\"extern\") {\n-            let opt_abis = self.parse_opt_abis();\n-\n-            if items_allowed && self.eat_keyword(&~\"fn\") {\n-                // EXTERN FUNCTION ITEM\n-                let abis = opt_abis.get_or_default(AbiSet::C());\n-                let (ident, item_, extra_attrs) =\n-                    self.parse_item_fn(extern_fn, abis);\n-                return iovi_item(self.mk_item(lo, self.last_span.hi, ident,\n-                                              item_, visibility,\n-                                              maybe_append(attrs,\n-                                                           extra_attrs)));\n-            }\n-            if items_allowed {\n-                // EXTERN MODULE ITEM\n-                return self.parse_item_foreign_mod(lo, opt_abis, visibility, attrs,\n-                                                   items_allowed);\n-            }\n-        }\n-        if items_allowed && self.eat_keyword(&~\"mod\") {\n+        if self.eat_keyword(&~\"mod\") {\n             // MODULE ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_mod(attrs);\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         }\n-        if items_allowed && self.eat_keyword(&~\"type\") {\n+        if self.eat_keyword(&~\"type\") {\n             // TYPE ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_type();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         }\n-        if items_allowed && self.eat_keyword(&~\"enum\") {\n+        if self.eat_keyword(&~\"enum\") {\n             // ENUM ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_enum();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         }\n-        if items_allowed && self.eat_keyword(&~\"trait\") {\n+        if self.eat_keyword(&~\"trait\") {\n             // TRAIT ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_trait();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         }\n-        if items_allowed && !foreign_items_allowed &&\n-                self.eat_keyword(&~\"impl\") {\n+        if self.eat_keyword(&~\"impl\") {\n             // IMPL ITEM\n             let (ident, item_, extra_attrs) =\n                 self.parse_item_impl(visibility);\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         }\n-        if items_allowed && self.eat_keyword(&~\"struct\") {\n+        if self.eat_keyword(&~\"struct\") {\n             // STRUCT ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_struct();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         }\n-        if items_allowed && self.eat_keyword(&~\"use\") {\n-            // USE ITEM\n-            let view_item = self.parse_use();\n-            self.expect(&token::SEMI);\n-            return iovi_view_item(@ast::view_item {\n-                node: view_item,\n-                attrs: attrs,\n-                vis: visibility,\n-                span: mk_sp(lo, self.last_span.hi)\n-            });\n+        self.parse_macro_use_or_failure(attrs,macros_allowed,lo,visibility)\n+    }\n+\n+    // parse a foreign item; on failure, return iovi_none.\n+    // trying to differentiate this from the other parse_foreign_item....\n+    fn parse_foreign_item(\n+        &self,\n+        attrs: ~[attribute],\n+        macros_allowed: bool\n+    ) -> item_or_view_item {\n+        maybe_whole!(iovi self, nt_item);\n+        let lo = self.span.lo;\n+\n+        let visibility = self.parse_visibility();\n+\n+        if (self.is_keyword(&~\"const\") || self.is_keyword(&~\"static\")) {\n+            // FOREIGN CONST ITEM\n+            let item = self.parse_item_foreign_const(visibility, attrs);\n+            return iovi_foreign_item(item);\n+        }\n+        if (self.is_keyword(&~\"fn\") || self.is_keyword(&~\"pure\") ||\n+             self.is_keyword(&~\"unsafe\")) {\n+            // FOREIGN FUNCTION ITEM\n+                let item = self.parse_item_foreign_fn(attrs);\n+                return iovi_foreign_item(item);\n         }\n+        self.parse_macro_use_or_failure(attrs,macros_allowed,lo,visibility)\n+    }\n+\n+    // this is the fall-through for parsing items.\n+    fn parse_macro_use_or_failure(\n+        &self,\n+        attrs: ~[attribute],\n+        macros_allowed: bool,\n+        lo : BytePos,\n+        visibility : visibility\n+    ) -> item_or_view_item {\n         if macros_allowed && !self.is_any_keyword(&copy *self.token)\n                 && self.look_ahead(1) == token::NOT\n                 && (is_plain_ident(&self.look_ahead(2))\n@@ -4219,7 +4215,7 @@ pub impl Parser {\n     }\n \n     fn parse_item(&self, attrs: ~[attribute]) -> Option<@ast::item> {\n-        match self.parse_item_or_view_item(attrs, true, false, true) {\n+        match self.parse_item_or_view_item(attrs, true) {\n             iovi_none =>\n                 None,\n             iovi_view_item(_) =>\n@@ -4375,101 +4371,73 @@ pub impl Parser {\n \n     // Parses a sequence of items. Stops when it finds program\n     // text that can't be parsed as an item\n-    // - mod_items uses VIEW_ITEMS_AND_ITEMS_ALLOWED\n-    // - block_tail_ uses IMPORTS_AND_ITEMS_ALLOWED\n-    // - foreign_mod_items uses FOREIGN_ITEMS_ALLOWED\n+    // - mod_items uses extern_mod_allowed = true\n+    // - block_tail_ uses extern_mod_allowed = false\n     fn parse_items_and_view_items(&self, first_item_attrs: ~[attribute],\n-                                  mode: view_item_parse_mode,\n+                                  mut extern_mod_allowed: bool,\n                                   macros_allowed: bool)\n                                 -> ParsedItemsAndViewItems {\n         let mut attrs = vec::append(first_item_attrs,\n                                     self.parse_outer_attributes());\n-\n-        let items_allowed = match mode {\n-            VIEW_ITEMS_AND_ITEMS_ALLOWED | IMPORTS_AND_ITEMS_ALLOWED => true,\n-            FOREIGN_ITEMS_ALLOWED => false\n-        };\n-        let foreign_items_allowed = match mode {\n-            FOREIGN_ITEMS_ALLOWED => true,\n-            VIEW_ITEMS_AND_ITEMS_ALLOWED | IMPORTS_AND_ITEMS_ALLOWED => false\n-        };\n-\n         // First, parse view items.\n-        let mut (view_items, items, foreign_items) = (~[], ~[], ~[]);\n+        let mut (view_items, items) = (~[], ~[]);\n         let mut done = false;\n-        if mode != FOREIGN_ITEMS_ALLOWED {\n-            let mut extern_mod_allowed = match mode {\n-                VIEW_ITEMS_AND_ITEMS_ALLOWED => true,\n-                IMPORTS_AND_ITEMS_ALLOWED => false,\n-                FOREIGN_ITEMS_ALLOWED => {\n-                    self.bug(~\"couldn't get here with FOREIGN_ITEMS_ALLOWED\")\n+        // I think this code would probably read better as a single\n+        // loop with a mutable three-state-variable (for extern mods,\n+        // view items, and regular items) ... except that because\n+        // of macros, I'd like to delay that entire check until later.\n+        loop {\n+            match self.parse_item_or_view_item(/*bad*/ copy attrs,\n+                                                           macros_allowed) {\n+                iovi_none => {\n+                    done = true;\n+                    break;\n                 }\n-            };\n-\n-            loop {\n-                match self.parse_item_or_view_item(/*bad*/ copy attrs,\n-                                                   items_allowed,\n-                                                   foreign_items_allowed,\n-                                                   macros_allowed) {\n-                    iovi_none => {\n-                        done = true;\n-                        break;\n-                    }\n-                    iovi_view_item(view_item) => {\n-                        match view_item.node {\n-                            view_item_use(*) => {\n-                                // `extern mod` must precede `use`.\n-                                extern_mod_allowed = false;\n-                            }\n-                            view_item_extern_mod(*)\n-                                    if !extern_mod_allowed => {\n-                                self.span_err(view_item.span,\n-                                              ~\"\\\"extern mod\\\" \\\n-                                                declarations are not \\\n-                                                allowed here\");\n-                            }\n-                            view_item_extern_mod(*) => {}\n+                iovi_view_item(view_item) => {\n+                    match view_item.node {\n+                        view_item_use(*) => {\n+                            // `extern mod` must precede `use`.\n+                            extern_mod_allowed = false;\n                         }\n-                        view_items.push(view_item);\n-                    }\n-                    iovi_item(item) => {\n-                        assert!(items_allowed);\n-                        items.push(item);\n-                        attrs = self.parse_outer_attributes();\n-                        break;\n-                    }\n-                    iovi_foreign_item(foreign_item) => {\n-                        assert!(foreign_items_allowed);\n-                        foreign_items.push(foreign_item);\n-                        attrs = self.parse_outer_attributes();\n-                        break;\n+                        view_item_extern_mod(*)\n+                        if !extern_mod_allowed => {\n+                            self.span_err(view_item.span,\n+                                          ~\"\\\"extern mod\\\" \\\n+                                            declarations are not \\\n+                                            allowed here\");\n+                        }\n+                        view_item_extern_mod(*) => {}\n                     }\n+                    view_items.push(view_item);\n+                }\n+                iovi_item(item) => {\n+                    items.push(item);\n+                    attrs = self.parse_outer_attributes();\n+                    break;\n+                }\n+                iovi_foreign_item(_) => {\n+                    fail!();\n                 }\n-                attrs = self.parse_outer_attributes();\n             }\n+            attrs = self.parse_outer_attributes();\n         }\n \n         // Next, parse items.\n         if !done {\n             loop {\n                 match self.parse_item_or_view_item(/*bad*/ copy attrs,\n-                                                   items_allowed,\n-                                                   foreign_items_allowed,\n                                                    macros_allowed) {\n                     iovi_none => break,\n                     iovi_view_item(view_item) => {\n                         self.span_err(view_item.span,\n                                       ~\"`use` and `extern mod` declarations \\\n                                         must precede items\");\n-                        view_items.push(view_item);\n                     }\n                     iovi_item(item) => {\n-                        assert!(items_allowed);\n                         items.push(item)\n                     }\n-                    iovi_foreign_item(foreign_item) => {\n-                        assert!(foreign_items_allowed);\n-                        foreign_items.push(foreign_item);\n+                    iovi_foreign_item(_) => {\n+                        fail!();\n                     }\n                 }\n                 attrs = self.parse_outer_attributes();\n@@ -4480,6 +4448,43 @@ pub impl Parser {\n             attrs_remaining: attrs,\n             view_items: view_items,\n             items: items,\n+            foreign_items: ~[]\n+        }\n+    }\n+\n+    // splitting parse_items_and_view_items into two functions...\n+    // Parses a sequence of foreign items. Stops when it finds program\n+    // text that can't be parsed as an item\n+    fn parse_foreign_items(&self, first_item_attrs: ~[attribute],\n+                           macros_allowed: bool)\n+        -> ParsedItemsAndViewItems {\n+        let mut attrs = vec::append(first_item_attrs,\n+                                    self.parse_outer_attributes());\n+        let mut foreign_items = ~[];\n+        loop {\n+            match self.parse_foreign_item(/*bad*/ copy attrs, macros_allowed) {\n+                iovi_none => break,\n+                iovi_view_item(view_item) => {\n+                    // I think this can't occur:\n+                    self.span_err(view_item.span,\n+                                  ~\"`use` and `extern mod` declarations \\\n+                                    must precede items\");\n+                }\n+                iovi_item(_) => {\n+                    // FIXME #5668: this will occur for a macro invocation:\n+                    fail!();\n+                }\n+                iovi_foreign_item(foreign_item) => {\n+                    foreign_items.push(foreign_item);\n+                }\n+            }\n+            attrs = self.parse_outer_attributes();\n+        }\n+\n+        ParsedItemsAndViewItems {\n+            attrs_remaining: attrs,\n+            view_items: ~[],\n+            items: ~[],\n             foreign_items: foreign_items\n         }\n     }"}]}