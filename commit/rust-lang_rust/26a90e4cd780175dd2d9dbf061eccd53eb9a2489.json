{"sha": "26a90e4cd780175dd2d9dbf061eccd53eb9a2489", "node_id": "C_kwDOAAsO6NoAKDI2YTkwZTRjZDc4MDE3NWRkMmQ5ZGJmMDYxZWNjZDUzZWI5YTI0ODk", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-01-06T11:01:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-06T11:01:05Z"}, "message": "Rollup merge of #92443 - mdibaiee:90703/resolve-traits-of-primitive-types, r=Manishearth\n\nRustdoc: resolve associated traits for non-generic primitive types\n\nFixes #90703\n\nThis seems to work:\n<img width=\"457\" alt=\"image\" src=\"https://user-images.githubusercontent.com/2807772/147774059-9556ff96-4519-409e-8ed0-c33ecc436171.png\">\n\nI'm just afraid I might have missed some cases / broken previous functionality.\n\nI also have not written tests yet, I will have to take a look to see where tests are and how they are structured, but any help there is also appreciated.", "tree": {"sha": "f2c1551a88fe6e6267efc69fe7f93bd3cdf37fdc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2c1551a88fe6e6267efc69fe7f93bd3cdf37fdc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26a90e4cd780175dd2d9dbf061eccd53eb9a2489", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh1svxCRBK7hj4Ov3rIwAAZI4IAIgNk62TDGhAr4mZG0KwjTod\nDItz+cHJYu38i6WBE49idSrTsOzhUNouk//nElsSmJ6SGhHeF8B7KCYXpxFNSVHK\nZ7+FQ+wEAlq/oZg8oqnkljZeoWTW/ERvumRlFODLyuiCP6Wepp1oE2d/clp6f/yX\n6KQqhmC9ARkR8gysmn4H5/x9MRTjPUxBZhAx4Rq6906L7eR2Rx4xpI5/se5/PbGj\ni9zY8jz7hb6dBDnu3njYdMvr7eJ1sRm+eIhy6HZRGChOsN0mMZgP5oDK/y+Pecw5\nG4nJ5E1HqqOl9ZVvnlzjddWicrKOIPJmPUNQD/7zmsnyRFbwOhplbMeTJLAhZg8=\n=+Ywt\n-----END PGP SIGNATURE-----\n", "payload": "tree f2c1551a88fe6e6267efc69fe7f93bd3cdf37fdc\nparent b510278278304ab961c4bad2ed7119f5d70d0d51\nparent 973cf632d37b55095d1ff47b62de43c1864c4115\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1641466865 +0100\ncommitter GitHub <noreply@github.com> 1641466865 +0100\n\nRollup merge of #92443 - mdibaiee:90703/resolve-traits-of-primitive-types, r=Manishearth\n\nRustdoc: resolve associated traits for non-generic primitive types\n\nFixes #90703\n\nThis seems to work:\n<img width=\"457\" alt=\"image\" src=\"https://user-images.githubusercontent.com/2807772/147774059-9556ff96-4519-409e-8ed0-c33ecc436171.png\">\n\nI'm just afraid I might have missed some cases / broken previous functionality.\n\nI also have not written tests yet, I will have to take a look to see where tests are and how they are structured, but any help there is also appreciated.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26a90e4cd780175dd2d9dbf061eccd53eb9a2489", "html_url": "https://github.com/rust-lang/rust/commit/26a90e4cd780175dd2d9dbf061eccd53eb9a2489", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26a90e4cd780175dd2d9dbf061eccd53eb9a2489/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b510278278304ab961c4bad2ed7119f5d70d0d51", "url": "https://api.github.com/repos/rust-lang/rust/commits/b510278278304ab961c4bad2ed7119f5d70d0d51", "html_url": "https://github.com/rust-lang/rust/commit/b510278278304ab961c4bad2ed7119f5d70d0d51"}, {"sha": "973cf632d37b55095d1ff47b62de43c1864c4115", "url": "https://api.github.com/repos/rust-lang/rust/commits/973cf632d37b55095d1ff47b62de43c1864c4115", "html_url": "https://github.com/rust-lang/rust/commit/973cf632d37b55095d1ff47b62de43c1864c4115"}], "stats": {"total": 149, "additions": 119, "deletions": 30}, "files": [{"sha": "7953008628204f3e72b0ff460d14b7260e06ff3d", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 71, "deletions": 21, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/26a90e4cd780175dd2d9dbf061eccd53eb9a2489/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a90e4cd780175dd2d9dbf061eccd53eb9a2489/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=26a90e4cd780175dd2d9dbf061eccd53eb9a2489", "patch": "@@ -13,7 +13,7 @@ use rustc_hir::def::{\n     PerNS,\n };\n use rustc_hir::def_id::{CrateNum, DefId};\n-use rustc_middle::ty::TyCtxt;\n+use rustc_middle::ty::{Ty, TyCtxt};\n use rustc_middle::{bug, span_bug, ty};\n use rustc_resolve::ParentScope;\n use rustc_session::lint::Lint;\n@@ -618,6 +618,39 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         })\n     }\n \n+    /// Convert a PrimitiveType to a Ty, where possible.\n+    ///\n+    /// This is used for resolving trait impls for primitives\n+    fn primitive_type_to_ty(&mut self, prim: PrimitiveType) -> Option<Ty<'tcx>> {\n+        use PrimitiveType::*;\n+        let tcx = self.cx.tcx;\n+\n+        // FIXME: Only simple types are supported here, see if we can support\n+        // other types such as Tuple, Array, Slice, etc.\n+        // See https://github.com/rust-lang/rust/issues/90703#issuecomment-1004263455\n+        Some(tcx.mk_ty(match prim {\n+            Bool => ty::Bool,\n+            Str => ty::Str,\n+            Char => ty::Char,\n+            Never => ty::Never,\n+            I8 => ty::Int(ty::IntTy::I8),\n+            I16 => ty::Int(ty::IntTy::I16),\n+            I32 => ty::Int(ty::IntTy::I32),\n+            I64 => ty::Int(ty::IntTy::I64),\n+            I128 => ty::Int(ty::IntTy::I128),\n+            Isize => ty::Int(ty::IntTy::Isize),\n+            F32 => ty::Float(ty::FloatTy::F32),\n+            F64 => ty::Float(ty::FloatTy::F64),\n+            U8 => ty::Uint(ty::UintTy::U8),\n+            U16 => ty::Uint(ty::UintTy::U16),\n+            U32 => ty::Uint(ty::UintTy::U32),\n+            U64 => ty::Uint(ty::UintTy::U64),\n+            U128 => ty::Uint(ty::UintTy::U128),\n+            Usize => ty::Uint(ty::UintTy::Usize),\n+            _ => return None,\n+        }))\n+    }\n+\n     /// Returns:\n     /// - None if no associated item was found\n     /// - Some((_, _, Some(_))) if an item was found and should go through a side channel\n@@ -632,7 +665,25 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         let tcx = self.cx.tcx;\n \n         match root_res {\n-            Res::Primitive(prim) => self.resolve_primitive_associated_item(prim, ns, item_name),\n+            Res::Primitive(prim) => {\n+                self.resolve_primitive_associated_item(prim, ns, item_name).or_else(|| {\n+                    let assoc_item = self\n+                        .primitive_type_to_ty(prim)\n+                        .map(|ty| {\n+                            resolve_associated_trait_item(ty, module_id, item_name, ns, self.cx)\n+                        })\n+                        .flatten();\n+\n+                    assoc_item.map(|item| {\n+                        let kind = item.kind;\n+                        let fragment = UrlFragment::from_assoc_item(item_name, kind, false);\n+                        // HACK(jynelson): `clean` expects the type, not the associated item\n+                        // but the disambiguator logic expects the associated item.\n+                        // Store the kind in a side channel so that only the disambiguator logic looks at it.\n+                        (root_res, fragment, Some((kind.as_def_kind(), item.def_id)))\n+                    })\n+                })\n+            }\n             Res::Def(DefKind::TyAlias, did) => {\n                 // Resolve the link on the type the alias points to.\n                 // FIXME: if the associated item is defined directly on the type alias,\n@@ -666,8 +717,13 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     // To handle that properly resolve() would have to support\n                     // something like [`ambi_fn`](<SomeStruct as SomeTrait>::ambi_fn)\n                     .or_else(|| {\n-                        let item =\n-                            resolve_associated_trait_item(did, module_id, item_name, ns, self.cx);\n+                        let item = resolve_associated_trait_item(\n+                            tcx.type_of(did),\n+                            module_id,\n+                            item_name,\n+                            ns,\n+                            self.cx,\n+                        );\n                         debug!(\"got associated item {:?}\", item);\n                         item\n                     });\n@@ -767,20 +823,20 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n /// Given `[std::io::Error::source]`, where `source` is unresolved, this would\n /// find `std::error::Error::source` and return\n /// `<io::Error as error::Error>::source`.\n-fn resolve_associated_trait_item(\n-    did: DefId,\n+fn resolve_associated_trait_item<'a>(\n+    ty: Ty<'a>,\n     module: DefId,\n     item_name: Symbol,\n     ns: Namespace,\n-    cx: &mut DocContext<'_>,\n+    cx: &mut DocContext<'a>,\n ) -> Option<ty::AssocItem> {\n     // FIXME: this should also consider blanket impls (`impl<T> X for T`). Unfortunately\n     // `get_auto_trait_and_blanket_impls` is broken because the caching behavior is wrong. In the\n     // meantime, just don't look for these blanket impls.\n \n     // Next consider explicit impls: `impl MyTrait for MyType`\n     // Give precedence to inherent impls.\n-    let traits = traits_implemented_by(cx, did, module);\n+    let traits = traits_implemented_by(cx, ty, module);\n     debug!(\"considering traits {:?}\", traits);\n     let mut candidates = traits.iter().filter_map(|&trait_| {\n         cx.tcx.associated_items(trait_).find_by_name_and_namespace(\n@@ -799,7 +855,11 @@ fn resolve_associated_trait_item(\n ///\n /// NOTE: this cannot be a query because more traits could be available when more crates are compiled!\n /// So it is not stable to serialize cross-crate.\n-fn traits_implemented_by(cx: &mut DocContext<'_>, type_: DefId, module: DefId) -> FxHashSet<DefId> {\n+fn traits_implemented_by<'a>(\n+    cx: &mut DocContext<'a>,\n+    ty: Ty<'a>,\n+    module: DefId,\n+) -> FxHashSet<DefId> {\n     let mut resolver = cx.resolver.borrow_mut();\n     let in_scope_traits = cx.module_trait_cache.entry(module).or_insert_with(|| {\n         resolver.access(|resolver| {\n@@ -813,7 +873,6 @@ fn traits_implemented_by(cx: &mut DocContext<'_>, type_: DefId, module: DefId) -\n     });\n \n     let tcx = cx.tcx;\n-    let ty = tcx.type_of(type_);\n     let iter = in_scope_traits.iter().flat_map(|&trait_| {\n         trace!(\"considering explicit impl for trait {:?}\", trait_);\n \n@@ -826,19 +885,10 @@ fn traits_implemented_by(cx: &mut DocContext<'_>, type_: DefId, module: DefId) -\n                 \"comparing type {} with kind {:?} against type {:?}\",\n                 impl_type,\n                 impl_type.kind(),\n-                type_\n+                ty\n             );\n             // Fast path: if this is a primitive simple `==` will work\n-            let saw_impl = impl_type == ty\n-                || match impl_type.kind() {\n-                    // Check if these are the same def_id\n-                    ty::Adt(def, _) => {\n-                        debug!(\"adt def_id: {:?}\", def.did);\n-                        def.did == type_\n-                    }\n-                    ty::Foreign(def_id) => *def_id == type_,\n-                    _ => false,\n-                };\n+            let saw_impl = impl_type == ty;\n \n             if saw_impl { Some(trait_) } else { None }\n         })"}, {"sha": "587cbad68486422f1cb4d0ed487b1e011cac02d4", "filename": "src/test/rustdoc-ui/intra-doc/non-path-primitives.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/26a90e4cd780175dd2d9dbf061eccd53eb9a2489/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fnon-path-primitives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a90e4cd780175dd2d9dbf061eccd53eb9a2489/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fnon-path-primitives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fnon-path-primitives.rs?ref=26a90e4cd780175dd2d9dbf061eccd53eb9a2489", "patch": "@@ -28,7 +28,6 @@\n //! [unit::eq] //~ ERROR unresolved\n //! [tuple::eq] //~ ERROR unresolved\n //! [fn::eq] //~ ERROR unresolved\n-//! [never::eq] //~ ERROR unresolved\n \n // FIXME(#78800): This breaks because it's a blanket impl\n // (I think? Might break for other reasons too.)"}, {"sha": "4828a30446355d70b91c605165be598399076039", "filename": "src/test/rustdoc-ui/intra-doc/non-path-primitives.stderr", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/26a90e4cd780175dd2d9dbf061eccd53eb9a2489/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fnon-path-primitives.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/26a90e4cd780175dd2d9dbf061eccd53eb9a2489/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fnon-path-primitives.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-doc%2Fnon-path-primitives.stderr?ref=26a90e4cd780175dd2d9dbf061eccd53eb9a2489", "patch": "@@ -53,17 +53,11 @@ error: unresolved link to `fn::eq`\n LL | //! [fn::eq]\n    |      ^^^^^^ the builtin type `fn` has no associated item named `eq`\n \n-error: unresolved link to `never::eq`\n-  --> $DIR/non-path-primitives.rs:31:6\n-   |\n-LL | //! [never::eq]\n-   |      ^^^^^^^^^ the builtin type `never` has no associated item named `eq`\n-\n error: unresolved link to `reference::deref`\n-  --> $DIR/non-path-primitives.rs:35:6\n+  --> $DIR/non-path-primitives.rs:34:6\n    |\n LL | //! [reference::deref]\n    |      ^^^^^^^^^^^^^^^^ the builtin type `reference` has no associated item named `deref`\n \n-error: aborting due to 9 previous errors\n+error: aborting due to 8 previous errors\n "}, {"sha": "8639a24f7f3864e46410b2b185a38d8382fda71e", "filename": "src/test/rustdoc/intra-doc/prim-associated-traits.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/26a90e4cd780175dd2d9dbf061eccd53eb9a2489/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprim-associated-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26a90e4cd780175dd2d9dbf061eccd53eb9a2489/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprim-associated-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fprim-associated-traits.rs?ref=26a90e4cd780175dd2d9dbf061eccd53eb9a2489", "patch": "@@ -0,0 +1,46 @@\n+#![feature(never_type)]\n+use std::str::FromStr;\n+\n+// @has 'prim_associated_traits/struct.Number.html' '//a[@href=\"{{channel}}/std/primitive.f64.html#method.from_str\"]' 'f64::from_str()'\n+// @has 'prim_associated_traits/struct.Number.html' '//a[@href=\"{{channel}}/std/primitive.f32.html#method.from_str\"]' 'f32::from_str()'\n+// @has 'prim_associated_traits/struct.Number.html' '//a[@href=\"{{channel}}/std/primitive.isize.html#method.from_str\"]' 'isize::from_str()'\n+// @has 'prim_associated_traits/struct.Number.html' '//a[@href=\"{{channel}}/std/primitive.i8.html#method.from_str\"]' 'i8::from_str()'\n+// @has 'prim_associated_traits/struct.Number.html' '//a[@href=\"{{channel}}/std/primitive.i16.html#method.from_str\"]' 'i16::from_str()'\n+// @has 'prim_associated_traits/struct.Number.html' '//a[@href=\"{{channel}}/std/primitive.i32.html#method.from_str\"]' 'i32::from_str()'\n+// @has 'prim_associated_traits/struct.Number.html' '//a[@href=\"{{channel}}/std/primitive.i64.html#method.from_str\"]' 'i64::from_str()'\n+// @has 'prim_associated_traits/struct.Number.html' '//a[@href=\"{{channel}}/std/primitive.i128.html#method.from_str\"]' 'i128::from_str()'\n+// @has 'prim_associated_traits/struct.Number.html' '//a[@href=\"{{channel}}/std/primitive.usize.html#method.from_str\"]' 'usize::from_str()'\n+// @has 'prim_associated_traits/struct.Number.html' '//a[@href=\"{{channel}}/std/primitive.u8.html#method.from_str\"]' 'u8::from_str()'\n+// @has 'prim_associated_traits/struct.Number.html' '//a[@href=\"{{channel}}/std/primitive.u16.html#method.from_str\"]' 'u16::from_str()'\n+// @has 'prim_associated_traits/struct.Number.html' '//a[@href=\"{{channel}}/std/primitive.u32.html#method.from_str\"]' 'u32::from_str()'\n+// @has 'prim_associated_traits/struct.Number.html' '//a[@href=\"{{channel}}/std/primitive.u64.html#method.from_str\"]' 'u64::from_str()'\n+// @has 'prim_associated_traits/struct.Number.html' '//a[@href=\"{{channel}}/std/primitive.u128.html#method.from_str\"]' 'u128::from_str()'\n+// @has 'prim_associated_traits/struct.Number.html' '//a[@href=\"{{channel}}/std/primitive.char.html#method.from_str\"]' 'char::from_str()'\n+// @has 'prim_associated_traits/struct.Number.html' '//a[@href=\"{{channel}}/std/primitive.bool.html#method.from_str\"]' 'bool::from_str()'\n+// @has 'prim_associated_traits/struct.Number.html' '//a[@href=\"{{channel}}/std/primitive.str.html#method.eq\"]' 'str::eq()'\n+// @has 'prim_associated_traits/struct.Number.html' '//a[@href=\"{{channel}}/std/primitive.never.html#method.eq\"]' 'never::eq()'\n+/// [`f64::from_str()`] [`f32::from_str()`] [`isize::from_str()`] [`i8::from_str()`]\n+/// [`i16::from_str()`] [`i32::from_str()`] [`i64::from_str()`] [`i128::from_str()`]\n+/// [`u16::from_str()`] [`u32::from_str()`] [`u64::from_str()`] [`u128::from_str()`]\n+/// [`usize::from_str()`] [`u8::from_str()`] [`char::from_str()`] [`bool::from_str()`]\n+/// [`str::eq()`] [`never::eq()`]\n+pub struct Number {\n+    pub f_64: f64,\n+    pub f_32: f32,\n+    pub i_size: isize,\n+    pub i_8: i8,\n+    pub i_16: i16,\n+    pub i_32: i32,\n+    pub i_64: i64,\n+    pub i_128: i128,\n+    pub u_size: usize,\n+    pub u_8: u8,\n+    pub u_16: u16,\n+    pub u_32: u32,\n+    pub u_64: u64,\n+    pub u_128: u128,\n+    pub ch: char,\n+    pub boolean: bool,\n+    pub string: str,\n+    pub n: !,\n+}"}]}