{"sha": "ce4e09b70951de252a75dc959afc302ca6fd0421", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlNGUwOWI3MDk1MWRlMjUyYTc1ZGM5NTlhZmMzMDJjYTZmZDA0MjE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-09-01T00:36:40Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-09-01T00:36:40Z"}, "message": "doc: Remove some unneeded sections on type inference and generic modes", "tree": {"sha": "ed02948c90c6852de161ac4e55083b3eaab4e73d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed02948c90c6852de161ac4e55083b3eaab4e73d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce4e09b70951de252a75dc959afc302ca6fd0421", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce4e09b70951de252a75dc959afc302ca6fd0421", "html_url": "https://github.com/rust-lang/rust/commit/ce4e09b70951de252a75dc959afc302ca6fd0421", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce4e09b70951de252a75dc959afc302ca6fd0421/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4fc164a549fc342401d9d935c0e663af43d88e4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fc164a549fc342401d9d935c0e663af43d88e4b", "html_url": "https://github.com/rust-lang/rust/commit/4fc164a549fc342401d9d935c0e663af43d88e4b"}], "stats": {"total": 88, "additions": 14, "deletions": 74}, "files": [{"sha": "4743e384633da57ecf5c35014750d82d901c74cd", "filename": "doc/tutorial.md", "status": "modified", "additions": 14, "deletions": 74, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/ce4e09b70951de252a75dc959afc302ca6fd0421/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/ce4e09b70951de252a75dc959afc302ca6fd0421/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=ce4e09b70951de252a75dc959afc302ca6fd0421", "patch": "@@ -1551,14 +1551,13 @@ fn contains(v: ~[int], elt: int) -> bool {\n \n ## Generic functions\n \n-Throughout this tutorial, we've been defining functions like\n-that act only on single data types. It is 2012, and we no longer\n-expect to be defining such functions again and again for every type\n-they apply to.  Thus, Rust allows functions and datatypes to have type\n-parameters.\n+Throughout this tutorial, we've been defining functions that act only on\n+single data types. It's a burden to define such functions again and again for\n+every type they apply to. Thus, Rust allows functions and datatypes to have\n+type parameters.\n \n ~~~~\n-fn map<T, U>(vector: ~[T], function: fn(T) -> U) -> ~[U] {\n+fn map<T, U>(vector: &[T], function: fn(T) -> U) -> ~[U] {\n     let mut accumulator = ~[];\n     for vector.each |element| {\n         vec::push(accumulator, function(element));\n@@ -1577,51 +1576,20 @@ inside them, but you can pass them around.\n \n ## Generic datatypes\n \n-Generic `type` and `enum` declarations follow the same pattern:\n-\n-~~~~\n-type circular_buf<T> = {start: uint,\n-                        end: uint,\n-                        buf: ~[mut T]};\n-\n-enum option<T> { some(T), none }\n-~~~~\n-\n-You can then declare a function to take a `circular_buf<u8>` or return\n-an `option<~str>`, or even an `option<T>` if the function itself is\n-generic.\n-\n-The `option` type given above exists in the core library and is the\n-way Rust programs express the thing that in C would be a nullable\n-pointer. The nice part is that you have to explicitly unpack an\n-`option` type, so accidental null pointer dereferences become\n-impossible.\n-\n-## Type-inference and generics\n-\n-Rust's type inferrer works very well with generics, but there are\n-programs that just can't be typed.\n+Generic `type`, `struct`, and `enum` declarations follow the same pattern:\n \n ~~~~\n-let n = option::None;\n-# option::iter(n, fn&(&&x:int) {})\n-~~~~\n-\n-If you never do anything else with `n`, the compiler will not be able\n-to assign a type to it. (The same goes for `[]`, the empty vector.) If\n-you really want to have such a statement, you'll have to write it like\n-this:\n+struct Stack<T> {\n+    elements: ~[mut T]\n+}\n \n-~~~~\n-let n2: Option<int> = option::None;\n-// or\n-let n = option::None::<int>;\n+enum Maybe<T> {\n+    Just(T),\n+    Nothing\n+}\n ~~~~\n \n-Note that, in a value expression, `<` already has a meaning as a\n-comparison operator, so you'll have to write `::<T>` to explicitly\n-give a type to a name that denotes a generic value. Fortunately, this\n-is rarely necessary.\n+These declarations produce valid types like `Stack<u8>` and `Maybe<int>`.\n \n ## Kinds\n \n@@ -1661,34 +1629,6 @@ resource type. Rust has several kinds that can be used as type bounds:\n > kinds will actually be traits that the compiler has special\n > knowledge about.\n \n-## Generic functions and argument-passing\n-\n-The previous section mentioned that arguments are passed by pointer or\n-by value based on their type. There is one situation in which this is\n-difficult. If you try this program:\n-\n-~~~~{.xfail-test}\n-fn plus1(x: int) -> int { x + 1 }\n-vec::map(~[1, 2, 3], plus1);\n-~~~~\n-\n-You will get an error message about argument passing styles\n-disagreeing. The reason is that generic types are always passed by\n-reference, so `map` expects a function that takes its argument by\n-reference. The `plus1` you defined, however, uses the default,\n-efficient way to pass integers, which is by value. To get around this\n-issue, you have to explicitly mark the arguments to a function that\n-you want to pass to a generic higher-order function as being passed by\n-pointer, using the `&&` sigil:\n-\n-~~~~\n-fn plus1(&&x: int) -> int { x + 1 }\n-vec::map(~[1, 2, 3], plus1);\n-~~~~\n-\n-> ***Note:*** This is inconvenient, and we are hoping to get rid of\n-> this restriction in the future.\n-\n # Modules and crates\n \n The Rust namespace is divided into modules. Each source file starts"}]}