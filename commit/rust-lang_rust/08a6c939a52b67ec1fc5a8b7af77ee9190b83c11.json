{"sha": "08a6c939a52b67ec1fc5a8b7af77ee9190b83c11", "node_id": "C_kwDOAAsO6NoAKDA4YTZjOTM5YTUyYjY3ZWMxZmM1YThiN2FmNzdlZTkxOTBiODNjMTE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-11-29T21:43:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-29T21:43:22Z"}, "message": "Rollup merge of #105066 - lcnr:mv-candidate_from_obligation, r=compiler-errors\n\nmove `candidate_from_obligation` out of assembly\n\nit doesn't belong there as it also does winnowing\n\nr? `@compiler-errors`", "tree": {"sha": "25b7e56a212fa59c381c9ad40b6452e93c80cec4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/25b7e56a212fa59c381c9ad40b6452e93c80cec4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08a6c939a52b67ec1fc5a8b7af77ee9190b83c11", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjhnz6CRBK7hj4Ov3rIwAABdkIAKYHW/cRLuW06ZMiwgkvovO6\n68PXi1yP7FIBQPg+g5ETs6NrZTRg0xVUYPG6n3ldLFzrlzieaoBVQA5AOXag9cFv\nUoOUx+HEW/IOb32CLw9yoKNJ4XhUdgGyRPavVrFQYQa6pDZeJejqMoRmj0TwS4xv\nhuSZj/I5eD7GbikETLrBv6ZDQuh4tzPRXZQ690sGb0lANAZsaVzXXkwl1m/p5zm9\n3qGo28tiwHET0UKIGtQPeTfYRbZ4S6QHuWm3tGA58f3DBaZagxRWw2qiCZolV0Da\nQc7yXRiEgbh9bOhdEImJLJz9D2F1dwPovpPJOVeEv6EcGz3og3SFIPGZ24uvSmo=\n=zNIE\n-----END PGP SIGNATURE-----\n", "payload": "tree 25b7e56a212fa59c381c9ad40b6452e93c80cec4\nparent 5726f1f3ac9e8f1cd3a54c6631f64b7f1ddc14d1\nparent bb982df771d02d2b6d2c30bd56cd2d25ba423a2b\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1669758202 +0100\ncommitter GitHub <noreply@github.com> 1669758202 +0100\n\nRollup merge of #105066 - lcnr:mv-candidate_from_obligation, r=compiler-errors\n\nmove `candidate_from_obligation` out of assembly\n\nit doesn't belong there as it also does winnowing\n\nr? `@compiler-errors`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08a6c939a52b67ec1fc5a8b7af77ee9190b83c11", "html_url": "https://github.com/rust-lang/rust/commit/08a6c939a52b67ec1fc5a8b7af77ee9190b83c11", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08a6c939a52b67ec1fc5a8b7af77ee9190b83c11/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5726f1f3ac9e8f1cd3a54c6631f64b7f1ddc14d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/5726f1f3ac9e8f1cd3a54c6631f64b7f1ddc14d1", "html_url": "https://github.com/rust-lang/rust/commit/5726f1f3ac9e8f1cd3a54c6631f64b7f1ddc14d1"}, {"sha": "bb982df771d02d2b6d2c30bd56cd2d25ba423a2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb982df771d02d2b6d2c30bd56cd2d25ba423a2b", "html_url": "https://github.com/rust-lang/rust/commit/bb982df771d02d2b6d2c30bd56cd2d25ba423a2b"}], "stats": {"total": 417, "additions": 207, "deletions": 210}, "files": [{"sha": "fe5135661b5f8f3996649ee9519849d747ad08e3", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 3, "deletions": 210, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/08a6c939a52b67ec1fc5a8b7af77ee9190b83c11/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a6c939a52b67ec1fc5a8b7af77ee9190b83c11/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=08a6c939a52b67ec1fc5a8b7af77ee9190b83c11", "patch": "@@ -9,225 +9,18 @@ use hir::LangItem;\n use rustc_hir as hir;\n use rustc_infer::traits::ObligationCause;\n use rustc_infer::traits::{Obligation, SelectionError, TraitObligation};\n-use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self, Ty, TypeVisitable};\n use rustc_target::spec::abi::Abi;\n \n use crate::traits;\n-use crate::traits::coherence::Conflict;\n use crate::traits::query::evaluate_obligation::InferCtxtExt;\n-use crate::traits::{util, SelectionResult};\n-use crate::traits::{ErrorReporting, Overflow, Unimplemented};\n+use crate::traits::util;\n \n use super::BuiltinImplConditions;\n-use super::IntercrateAmbiguityCause;\n-use super::OverflowError;\n-use super::SelectionCandidate::{self, *};\n-use super::{EvaluatedCandidate, SelectionCandidateSet, SelectionContext, TraitObligationStack};\n+use super::SelectionCandidate::*;\n+use super::{SelectionCandidateSet, SelectionContext, TraitObligationStack};\n \n impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n-    #[instrument(level = \"debug\", skip(self), ret)]\n-    pub(super) fn candidate_from_obligation<'o>(\n-        &mut self,\n-        stack: &TraitObligationStack<'o, 'tcx>,\n-    ) -> SelectionResult<'tcx, SelectionCandidate<'tcx>> {\n-        // Watch out for overflow. This intentionally bypasses (and does\n-        // not update) the cache.\n-        self.check_recursion_limit(&stack.obligation, &stack.obligation)?;\n-\n-        // Check the cache. Note that we freshen the trait-ref\n-        // separately rather than using `stack.fresh_trait_ref` --\n-        // this is because we want the unbound variables to be\n-        // replaced with fresh types starting from index 0.\n-        let cache_fresh_trait_pred = self.infcx.freshen(stack.obligation.predicate);\n-        debug!(?cache_fresh_trait_pred);\n-        debug_assert!(!stack.obligation.predicate.has_escaping_bound_vars());\n-\n-        if let Some(c) =\n-            self.check_candidate_cache(stack.obligation.param_env, cache_fresh_trait_pred)\n-        {\n-            debug!(\"CACHE HIT\");\n-            return c;\n-        }\n-\n-        // If no match, compute result and insert into cache.\n-        //\n-        // FIXME(nikomatsakis) -- this cache is not taking into\n-        // account cycles that may have occurred in forming the\n-        // candidate. I don't know of any specific problems that\n-        // result but it seems awfully suspicious.\n-        let (candidate, dep_node) =\n-            self.in_task(|this| this.candidate_from_obligation_no_cache(stack));\n-\n-        debug!(\"CACHE MISS\");\n-        self.insert_candidate_cache(\n-            stack.obligation.param_env,\n-            cache_fresh_trait_pred,\n-            dep_node,\n-            candidate.clone(),\n-        );\n-        candidate\n-    }\n-\n-    fn candidate_from_obligation_no_cache<'o>(\n-        &mut self,\n-        stack: &TraitObligationStack<'o, 'tcx>,\n-    ) -> SelectionResult<'tcx, SelectionCandidate<'tcx>> {\n-        if let Err(conflict) = self.is_knowable(stack) {\n-            debug!(\"coherence stage: not knowable\");\n-            if self.intercrate_ambiguity_causes.is_some() {\n-                debug!(\"evaluate_stack: intercrate_ambiguity_causes is some\");\n-                // Heuristics: show the diagnostics when there are no candidates in crate.\n-                if let Ok(candidate_set) = self.assemble_candidates(stack) {\n-                    let mut no_candidates_apply = true;\n-\n-                    for c in candidate_set.vec.iter() {\n-                        if self.evaluate_candidate(stack, &c)?.may_apply() {\n-                            no_candidates_apply = false;\n-                            break;\n-                        }\n-                    }\n-\n-                    if !candidate_set.ambiguous && no_candidates_apply {\n-                        let trait_ref = stack.obligation.predicate.skip_binder().trait_ref;\n-                        let self_ty = trait_ref.self_ty();\n-                        let (trait_desc, self_desc) = with_no_trimmed_paths!({\n-                            let trait_desc = trait_ref.print_only_trait_path().to_string();\n-                            let self_desc = if self_ty.has_concrete_skeleton() {\n-                                Some(self_ty.to_string())\n-                            } else {\n-                                None\n-                            };\n-                            (trait_desc, self_desc)\n-                        });\n-                        let cause = if let Conflict::Upstream = conflict {\n-                            IntercrateAmbiguityCause::UpstreamCrateUpdate { trait_desc, self_desc }\n-                        } else {\n-                            IntercrateAmbiguityCause::DownstreamCrate { trait_desc, self_desc }\n-                        };\n-                        debug!(?cause, \"evaluate_stack: pushing cause\");\n-                        self.intercrate_ambiguity_causes.as_mut().unwrap().insert(cause);\n-                    }\n-                }\n-            }\n-            return Ok(None);\n-        }\n-\n-        let candidate_set = self.assemble_candidates(stack)?;\n-\n-        if candidate_set.ambiguous {\n-            debug!(\"candidate set contains ambig\");\n-            return Ok(None);\n-        }\n-\n-        let candidates = candidate_set.vec;\n-\n-        debug!(?stack, ?candidates, \"assembled {} candidates\", candidates.len());\n-\n-        // At this point, we know that each of the entries in the\n-        // candidate set is *individually* applicable. Now we have to\n-        // figure out if they contain mutual incompatibilities. This\n-        // frequently arises if we have an unconstrained input type --\n-        // for example, we are looking for `$0: Eq` where `$0` is some\n-        // unconstrained type variable. In that case, we'll get a\n-        // candidate which assumes $0 == int, one that assumes `$0 ==\n-        // usize`, etc. This spells an ambiguity.\n-\n-        let mut candidates = self.filter_impls(candidates, stack.obligation);\n-\n-        // If there is more than one candidate, first winnow them down\n-        // by considering extra conditions (nested obligations and so\n-        // forth). We don't winnow if there is exactly one\n-        // candidate. This is a relatively minor distinction but it\n-        // can lead to better inference and error-reporting. An\n-        // example would be if there was an impl:\n-        //\n-        //     impl<T:Clone> Vec<T> { fn push_clone(...) { ... } }\n-        //\n-        // and we were to see some code `foo.push_clone()` where `boo`\n-        // is a `Vec<Bar>` and `Bar` does not implement `Clone`.  If\n-        // we were to winnow, we'd wind up with zero candidates.\n-        // Instead, we select the right impl now but report \"`Bar` does\n-        // not implement `Clone`\".\n-        if candidates.len() == 1 {\n-            return self.filter_reservation_impls(candidates.pop().unwrap(), stack.obligation);\n-        }\n-\n-        // Winnow, but record the exact outcome of evaluation, which\n-        // is needed for specialization. Propagate overflow if it occurs.\n-        let mut candidates = candidates\n-            .into_iter()\n-            .map(|c| match self.evaluate_candidate(stack, &c) {\n-                Ok(eval) if eval.may_apply() => {\n-                    Ok(Some(EvaluatedCandidate { candidate: c, evaluation: eval }))\n-                }\n-                Ok(_) => Ok(None),\n-                Err(OverflowError::Canonical) => Err(Overflow(OverflowError::Canonical)),\n-                Err(OverflowError::ErrorReporting) => Err(ErrorReporting),\n-                Err(OverflowError::Error(e)) => Err(Overflow(OverflowError::Error(e))),\n-            })\n-            .flat_map(Result::transpose)\n-            .collect::<Result<Vec<_>, _>>()?;\n-\n-        debug!(?stack, ?candidates, \"winnowed to {} candidates\", candidates.len());\n-\n-        let needs_infer = stack.obligation.predicate.has_non_region_infer();\n-\n-        // If there are STILL multiple candidates, we can further\n-        // reduce the list by dropping duplicates -- including\n-        // resolving specializations.\n-        if candidates.len() > 1 {\n-            let mut i = 0;\n-            while i < candidates.len() {\n-                let is_dup = (0..candidates.len()).filter(|&j| i != j).any(|j| {\n-                    self.candidate_should_be_dropped_in_favor_of(\n-                        &candidates[i],\n-                        &candidates[j],\n-                        needs_infer,\n-                    )\n-                });\n-                if is_dup {\n-                    debug!(candidate = ?candidates[i], \"Dropping candidate #{}/{}\", i, candidates.len());\n-                    candidates.swap_remove(i);\n-                } else {\n-                    debug!(candidate = ?candidates[i], \"Retaining candidate #{}/{}\", i, candidates.len());\n-                    i += 1;\n-\n-                    // If there are *STILL* multiple candidates, give up\n-                    // and report ambiguity.\n-                    if i > 1 {\n-                        debug!(\"multiple matches, ambig\");\n-                        return Ok(None);\n-                    }\n-                }\n-            }\n-        }\n-\n-        // If there are *NO* candidates, then there are no impls --\n-        // that we know of, anyway. Note that in the case where there\n-        // are unbound type variables within the obligation, it might\n-        // be the case that you could still satisfy the obligation\n-        // from another crate by instantiating the type variables with\n-        // a type from another crate that does have an impl. This case\n-        // is checked for in `evaluate_stack` (and hence users\n-        // who might care about this case, like coherence, should use\n-        // that function).\n-        if candidates.is_empty() {\n-            // If there's an error type, 'downgrade' our result from\n-            // `Err(Unimplemented)` to `Ok(None)`. This helps us avoid\n-            // emitting additional spurious errors, since we're guaranteed\n-            // to have emitted at least one.\n-            if stack.obligation.predicate.references_error() {\n-                debug!(?stack.obligation.predicate, \"found error type in predicate, treating as ambiguous\");\n-                return Ok(None);\n-            }\n-            return Err(Unimplemented);\n-        }\n-\n-        // Just one candidate left.\n-        self.filter_reservation_impls(candidates.pop().unwrap().candidate, stack.obligation)\n-    }\n-\n     #[instrument(skip(self, stack), level = \"debug\")]\n     pub(super) fn assemble_candidates<'o>(\n         &mut self,"}, {"sha": "515f3a34988869a77b50f5ccfa36619197032a47", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/08a6c939a52b67ec1fc5a8b7af77ee9190b83c11/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08a6c939a52b67ec1fc5a8b7af77ee9190b83c11/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=08a6c939a52b67ec1fc5a8b7af77ee9190b83c11", "patch": "@@ -30,6 +30,7 @@ use crate::traits::error_reporting::TypeErrCtxtExt;\n use crate::traits::project::ProjectAndUnifyResult;\n use crate::traits::project::ProjectionCacheKeyExt;\n use crate::traits::ProjectionCacheKey;\n+use crate::traits::Unimplemented;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::fx::{FxHashSet, FxIndexSet};\n use rustc_data_structures::stack::ensure_sufficient_stack;\n@@ -55,6 +56,7 @@ use std::fmt::{self, Display};\n use std::iter;\n \n pub use rustc_middle::traits::select::*;\n+use rustc_middle::ty::print::with_no_trimmed_paths;\n \n mod candidate_assembly;\n mod confirmation;\n@@ -305,6 +307,208 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         self.candidate_from_obligation(&stack)\n     }\n \n+    #[instrument(level = \"debug\", skip(self), ret)]\n+    fn candidate_from_obligation<'o>(\n+        &mut self,\n+        stack: &TraitObligationStack<'o, 'tcx>,\n+    ) -> SelectionResult<'tcx, SelectionCandidate<'tcx>> {\n+        // Watch out for overflow. This intentionally bypasses (and does\n+        // not update) the cache.\n+        self.check_recursion_limit(&stack.obligation, &stack.obligation)?;\n+\n+        // Check the cache. Note that we freshen the trait-ref\n+        // separately rather than using `stack.fresh_trait_ref` --\n+        // this is because we want the unbound variables to be\n+        // replaced with fresh types starting from index 0.\n+        let cache_fresh_trait_pred = self.infcx.freshen(stack.obligation.predicate);\n+        debug!(?cache_fresh_trait_pred);\n+        debug_assert!(!stack.obligation.predicate.has_escaping_bound_vars());\n+\n+        if let Some(c) =\n+            self.check_candidate_cache(stack.obligation.param_env, cache_fresh_trait_pred)\n+        {\n+            debug!(\"CACHE HIT\");\n+            return c;\n+        }\n+\n+        // If no match, compute result and insert into cache.\n+        //\n+        // FIXME(nikomatsakis) -- this cache is not taking into\n+        // account cycles that may have occurred in forming the\n+        // candidate. I don't know of any specific problems that\n+        // result but it seems awfully suspicious.\n+        let (candidate, dep_node) =\n+            self.in_task(|this| this.candidate_from_obligation_no_cache(stack));\n+\n+        debug!(\"CACHE MISS\");\n+        self.insert_candidate_cache(\n+            stack.obligation.param_env,\n+            cache_fresh_trait_pred,\n+            dep_node,\n+            candidate.clone(),\n+        );\n+        candidate\n+    }\n+\n+    fn candidate_from_obligation_no_cache<'o>(\n+        &mut self,\n+        stack: &TraitObligationStack<'o, 'tcx>,\n+    ) -> SelectionResult<'tcx, SelectionCandidate<'tcx>> {\n+        if let Err(conflict) = self.is_knowable(stack) {\n+            debug!(\"coherence stage: not knowable\");\n+            if self.intercrate_ambiguity_causes.is_some() {\n+                debug!(\"evaluate_stack: intercrate_ambiguity_causes is some\");\n+                // Heuristics: show the diagnostics when there are no candidates in crate.\n+                if let Ok(candidate_set) = self.assemble_candidates(stack) {\n+                    let mut no_candidates_apply = true;\n+\n+                    for c in candidate_set.vec.iter() {\n+                        if self.evaluate_candidate(stack, &c)?.may_apply() {\n+                            no_candidates_apply = false;\n+                            break;\n+                        }\n+                    }\n+\n+                    if !candidate_set.ambiguous && no_candidates_apply {\n+                        let trait_ref = stack.obligation.predicate.skip_binder().trait_ref;\n+                        let self_ty = trait_ref.self_ty();\n+                        let (trait_desc, self_desc) = with_no_trimmed_paths!({\n+                            let trait_desc = trait_ref.print_only_trait_path().to_string();\n+                            let self_desc = if self_ty.has_concrete_skeleton() {\n+                                Some(self_ty.to_string())\n+                            } else {\n+                                None\n+                            };\n+                            (trait_desc, self_desc)\n+                        });\n+                        let cause = if let Conflict::Upstream = conflict {\n+                            IntercrateAmbiguityCause::UpstreamCrateUpdate { trait_desc, self_desc }\n+                        } else {\n+                            IntercrateAmbiguityCause::DownstreamCrate { trait_desc, self_desc }\n+                        };\n+                        debug!(?cause, \"evaluate_stack: pushing cause\");\n+                        self.intercrate_ambiguity_causes.as_mut().unwrap().insert(cause);\n+                    }\n+                }\n+            }\n+            return Ok(None);\n+        }\n+\n+        let candidate_set = self.assemble_candidates(stack)?;\n+\n+        if candidate_set.ambiguous {\n+            debug!(\"candidate set contains ambig\");\n+            return Ok(None);\n+        }\n+\n+        let candidates = candidate_set.vec;\n+\n+        debug!(?stack, ?candidates, \"assembled {} candidates\", candidates.len());\n+\n+        // At this point, we know that each of the entries in the\n+        // candidate set is *individually* applicable. Now we have to\n+        // figure out if they contain mutual incompatibilities. This\n+        // frequently arises if we have an unconstrained input type --\n+        // for example, we are looking for `$0: Eq` where `$0` is some\n+        // unconstrained type variable. In that case, we'll get a\n+        // candidate which assumes $0 == int, one that assumes `$0 ==\n+        // usize`, etc. This spells an ambiguity.\n+\n+        let mut candidates = self.filter_impls(candidates, stack.obligation);\n+\n+        // If there is more than one candidate, first winnow them down\n+        // by considering extra conditions (nested obligations and so\n+        // forth). We don't winnow if there is exactly one\n+        // candidate. This is a relatively minor distinction but it\n+        // can lead to better inference and error-reporting. An\n+        // example would be if there was an impl:\n+        //\n+        //     impl<T:Clone> Vec<T> { fn push_clone(...) { ... } }\n+        //\n+        // and we were to see some code `foo.push_clone()` where `boo`\n+        // is a `Vec<Bar>` and `Bar` does not implement `Clone`.  If\n+        // we were to winnow, we'd wind up with zero candidates.\n+        // Instead, we select the right impl now but report \"`Bar` does\n+        // not implement `Clone`\".\n+        if candidates.len() == 1 {\n+            return self.filter_reservation_impls(candidates.pop().unwrap(), stack.obligation);\n+        }\n+\n+        // Winnow, but record the exact outcome of evaluation, which\n+        // is needed for specialization. Propagate overflow if it occurs.\n+        let mut candidates = candidates\n+            .into_iter()\n+            .map(|c| match self.evaluate_candidate(stack, &c) {\n+                Ok(eval) if eval.may_apply() => {\n+                    Ok(Some(EvaluatedCandidate { candidate: c, evaluation: eval }))\n+                }\n+                Ok(_) => Ok(None),\n+                Err(OverflowError::Canonical) => Err(Overflow(OverflowError::Canonical)),\n+                Err(OverflowError::ErrorReporting) => Err(ErrorReporting),\n+                Err(OverflowError::Error(e)) => Err(Overflow(OverflowError::Error(e))),\n+            })\n+            .flat_map(Result::transpose)\n+            .collect::<Result<Vec<_>, _>>()?;\n+\n+        debug!(?stack, ?candidates, \"winnowed to {} candidates\", candidates.len());\n+\n+        let needs_infer = stack.obligation.predicate.has_non_region_infer();\n+\n+        // If there are STILL multiple candidates, we can further\n+        // reduce the list by dropping duplicates -- including\n+        // resolving specializations.\n+        if candidates.len() > 1 {\n+            let mut i = 0;\n+            while i < candidates.len() {\n+                let is_dup = (0..candidates.len()).filter(|&j| i != j).any(|j| {\n+                    self.candidate_should_be_dropped_in_favor_of(\n+                        &candidates[i],\n+                        &candidates[j],\n+                        needs_infer,\n+                    )\n+                });\n+                if is_dup {\n+                    debug!(candidate = ?candidates[i], \"Dropping candidate #{}/{}\", i, candidates.len());\n+                    candidates.swap_remove(i);\n+                } else {\n+                    debug!(candidate = ?candidates[i], \"Retaining candidate #{}/{}\", i, candidates.len());\n+                    i += 1;\n+\n+                    // If there are *STILL* multiple candidates, give up\n+                    // and report ambiguity.\n+                    if i > 1 {\n+                        debug!(\"multiple matches, ambig\");\n+                        return Ok(None);\n+                    }\n+                }\n+            }\n+        }\n+\n+        // If there are *NO* candidates, then there are no impls --\n+        // that we know of, anyway. Note that in the case where there\n+        // are unbound type variables within the obligation, it might\n+        // be the case that you could still satisfy the obligation\n+        // from another crate by instantiating the type variables with\n+        // a type from another crate that does have an impl. This case\n+        // is checked for in `evaluate_stack` (and hence users\n+        // who might care about this case, like coherence, should use\n+        // that function).\n+        if candidates.is_empty() {\n+            // If there's an error type, 'downgrade' our result from\n+            // `Err(Unimplemented)` to `Ok(None)`. This helps us avoid\n+            // emitting additional spurious errors, since we're guaranteed\n+            // to have emitted at least one.\n+            if stack.obligation.predicate.references_error() {\n+                debug!(?stack.obligation.predicate, \"found error type in predicate, treating as ambiguous\");\n+                return Ok(None);\n+            }\n+            return Err(Unimplemented);\n+        }\n+\n+        // Just one candidate left.\n+        self.filter_reservation_impls(candidates.pop().unwrap().candidate, stack.obligation)\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // EVALUATION\n     //"}]}