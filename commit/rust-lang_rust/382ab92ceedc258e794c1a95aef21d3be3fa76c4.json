{"sha": "382ab92ceedc258e794c1a95aef21d3be3fa76c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4MmFiOTJjZWVkYzI1OGU3OTRjMWE5NWFlZjIxZDNiZTNmYTc2YzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-06-04T13:14:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-06-04T13:14:57Z"}, "message": "Auto merge of #33998 - nikomatsakis:incr-comp-dep-node-trait, r=mw\n\nIncr. comp. dep-node for traits, tests\n\nIntroduce new tests and also make dep-node for trait selection a bit more selective.\n\nFixes #33850\n\nr? @michaelwoerister", "tree": {"sha": "1a92fa8fecfd029cdb323e312001863987993c77", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a92fa8fecfd029cdb323e312001863987993c77"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/382ab92ceedc258e794c1a95aef21d3be3fa76c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/382ab92ceedc258e794c1a95aef21d3be3fa76c4", "html_url": "https://github.com/rust-lang/rust/commit/382ab92ceedc258e794c1a95aef21d3be3fa76c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/382ab92ceedc258e794c1a95aef21d3be3fa76c4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4fb145867b817ae395d3487089254f384c9be163", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fb145867b817ae395d3487089254f384c9be163", "html_url": "https://github.com/rust-lang/rust/commit/4fb145867b817ae395d3487089254f384c9be163"}, {"sha": "e548c46c7067010f203db0a9c69e5c6fae058545", "url": "https://api.github.com/repos/rust-lang/rust/commits/e548c46c7067010f203db0a9c69e5c6fae058545", "html_url": "https://github.com/rust-lang/rust/commit/e548c46c7067010f203db0a9c69e5c6fae058545"}], "stats": {"total": 529, "additions": 447, "deletions": 82}, "files": [{"sha": "73b96651b05e27826c031d55267cff16415a7bf1", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/382ab92ceedc258e794c1a95aef21d3be3fa76c4/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/382ab92ceedc258e794c1a95aef21d3be3fa76c4/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=382ab92ceedc258e794c1a95aef21d3be3fa76c4", "patch": "@@ -10,7 +10,16 @@\n \n use std::fmt::Debug;\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+macro_rules! try_opt {\n+    ($e:expr) => (\n+        match $e {\n+            Some(r) => r,\n+            None => return None,\n+        }\n+    )\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum DepNode<D: Clone + Debug> {\n     // The `D` type is \"how definitions are identified\".\n     // During compilation, it is always `DefId`, but when serializing\n@@ -116,7 +125,7 @@ pub enum DepNode<D: Clone + Debug> {\n     // which would yield an overly conservative dep-graph.\n     TraitItems(D),\n     ReprHints(D),\n-    TraitSelect(D),\n+    TraitSelect(D, Vec<D>),\n }\n \n impl<D: Clone + Debug> DepNode<D> {\n@@ -212,7 +221,11 @@ impl<D: Clone + Debug> DepNode<D> {\n             TraitImpls(ref d) => op(d).map(TraitImpls),\n             TraitItems(ref d) => op(d).map(TraitItems),\n             ReprHints(ref d) => op(d).map(ReprHints),\n-            TraitSelect(ref d) => op(d).map(TraitSelect),\n+            TraitSelect(ref d, ref type_ds) => {\n+                let d = try_opt!(op(d));\n+                let type_ds = try_opt!(type_ds.iter().map(|d| op(d)).collect());\n+                Some(TraitSelect(d, type_ds))\n+            }\n         }\n     }\n }"}, {"sha": "7a780c1d4ae2478bc6d80d2e9c932bb0063e4b1e", "filename": "src/librustc/dep_graph/query.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/382ab92ceedc258e794c1a95aef21d3be3fa76c4/src%2Flibrustc%2Fdep_graph%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/382ab92ceedc258e794c1a95aef21d3be3fa76c4/src%2Flibrustc%2Fdep_graph%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fquery.rs?ref=382ab92ceedc258e794c1a95aef21d3be3fa76c4", "patch": "@@ -47,26 +47,26 @@ impl<D: Clone + Debug + Hash + Eq> DepGraphQuery<D> {\n         self.indices.contains_key(&node)\n     }\n \n-    pub fn nodes(&self) -> Vec<DepNode<D>> {\n+    pub fn nodes(&self) -> Vec<&DepNode<D>> {\n         self.graph.all_nodes()\n                   .iter()\n-                  .map(|n| n.data.clone())\n+                  .map(|n| &n.data)\n                   .collect()\n     }\n \n-    pub fn edges(&self) -> Vec<(DepNode<D>,DepNode<D>)> {\n+    pub fn edges(&self) -> Vec<(&DepNode<D>,&DepNode<D>)> {\n         self.graph.all_edges()\n                   .iter()\n                   .map(|edge| (edge.source(), edge.target()))\n-                  .map(|(s, t)| (self.graph.node_data(s).clone(),\n-                                 self.graph.node_data(t).clone()))\n+                  .map(|(s, t)| (self.graph.node_data(s),\n+                                 self.graph.node_data(t)))\n                   .collect()\n     }\n \n-    fn reachable_nodes(&self, node: DepNode<D>, direction: Direction) -> Vec<DepNode<D>> {\n-        if let Some(&index) = self.indices.get(&node) {\n+    fn reachable_nodes(&self, node: &DepNode<D>, direction: Direction) -> Vec<&DepNode<D>> {\n+        if let Some(&index) = self.indices.get(node) {\n             self.graph.depth_traverse(index, direction)\n-                      .map(|s| self.graph.node_data(s).clone())\n+                      .map(|s| self.graph.node_data(s))\n                       .collect()\n         } else {\n             vec![]\n@@ -75,20 +75,20 @@ impl<D: Clone + Debug + Hash + Eq> DepGraphQuery<D> {\n \n     /// All nodes reachable from `node`. In other words, things that\n     /// will have to be recomputed if `node` changes.\n-    pub fn transitive_successors(&self, node: DepNode<D>) -> Vec<DepNode<D>> {\n+    pub fn transitive_successors(&self, node: &DepNode<D>) -> Vec<&DepNode<D>> {\n         self.reachable_nodes(node, OUTGOING)\n     }\n \n     /// All nodes that can reach `node`.\n-    pub fn transitive_predecessors(&self, node: DepNode<D>) -> Vec<DepNode<D>> {\n+    pub fn transitive_predecessors(&self, node: &DepNode<D>) -> Vec<&DepNode<D>> {\n         self.reachable_nodes(node, INCOMING)\n     }\n \n     /// Just the outgoing edges from `node`.\n-    pub fn immediate_successors(&self, node: DepNode<D>) -> Vec<DepNode<D>> {\n+    pub fn immediate_successors(&self, node: &DepNode<D>) -> Vec<&DepNode<D>> {\n         if let Some(&index) = self.indices.get(&node) {\n             self.graph.successor_nodes(index)\n-                      .map(|s| self.graph.node_data(s).clone())\n+                      .map(|s| self.graph.node_data(s))\n                       .collect()\n         } else {\n             vec![]"}, {"sha": "c43d493d176757b023c0b6a73435bf4b999a4d94", "filename": "src/librustc/dep_graph/raii.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/382ab92ceedc258e794c1a95aef21d3be3fa76c4/src%2Flibrustc%2Fdep_graph%2Fraii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/382ab92ceedc258e794c1a95aef21d3be3fa76c4/src%2Flibrustc%2Fdep_graph%2Fraii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fraii.rs?ref=382ab92ceedc258e794c1a95aef21d3be3fa76c4", "patch": "@@ -14,20 +14,20 @@ use super::thread::{DepGraphThreadData, DepMessage};\n \n pub struct DepTask<'graph> {\n     data: &'graph DepGraphThreadData,\n-    key: DepNode<DefId>,\n+    key: Option<DepNode<DefId>>,\n }\n \n impl<'graph> DepTask<'graph> {\n     pub fn new(data: &'graph DepGraphThreadData, key: DepNode<DefId>)\n                -> DepTask<'graph> {\n-        data.enqueue(DepMessage::PushTask(key));\n-        DepTask { data: data, key: key }\n+        data.enqueue(DepMessage::PushTask(key.clone()));\n+        DepTask { data: data, key: Some(key) }\n     }\n }\n \n impl<'graph> Drop for DepTask<'graph> {\n     fn drop(&mut self) {\n-        self.data.enqueue(DepMessage::PopTask(self.key));\n+        self.data.enqueue(DepMessage::PopTask(self.key.take().unwrap()));\n     }\n }\n "}, {"sha": "5dd71db2f1832870b8e87171499b772c32acf02e", "filename": "src/librustc/dep_graph/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/382ab92ceedc258e794c1a95aef21d3be3fa76c4/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/382ab92ceedc258e794c1a95aef21d3be3fa76c4/src%2Flibrustc%2Fdep_graph%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fvisit.rs?ref=382ab92ceedc258e794c1a95aef21d3be3fa76c4", "patch": "@@ -39,7 +39,7 @@ pub fn visit_all_items_in_krate<'a, 'tcx, V, F>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         fn visit_item(&mut self, i: &'tcx hir::Item) {\n             let item_def_id = self.tcx.map.local_def_id(i.id);\n             let task_id = (self.dep_node_fn)(item_def_id);\n-            let _task = self.tcx.dep_graph.in_task(task_id);\n+            let _task = self.tcx.dep_graph.in_task(task_id.clone());\n             debug!(\"Started task {:?}\", task_id);\n             self.tcx.dep_graph.read(DepNode::Hir(item_def_id));\n             self.visitor.visit_item(i);"}, {"sha": "454f524e4da37189a616b268ee77aa5c57d4a0c1", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/382ab92ceedc258e794c1a95aef21d3be3fa76c4/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/382ab92ceedc258e794c1a95aef21d3be3fa76c4/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=382ab92ceedc258e794c1a95aef21d3be3fa76c4", "patch": "@@ -946,7 +946,28 @@ impl<'tcx> TraitPredicate<'tcx> {\n \n     /// Creates the dep-node for selecting/evaluating this trait reference.\n     fn dep_node(&self) -> DepNode<DefId> {\n-        DepNode::TraitSelect(self.def_id())\n+        // Ideally, the dep-node would just have all the input types\n+        // in it.  But they are limited to including def-ids. So as an\n+        // approximation we include the def-ids for all nominal types\n+        // found somewhere. This means that we will e.g. conflate the\n+        // dep-nodes for `u32: SomeTrait` and `u64: SomeTrait`, but we\n+        // would have distinct dep-nodes for `Vec<u32>: SomeTrait`,\n+        // `Rc<u32>: SomeTrait`, and `(Vec<u32>, Rc<u32>): SomeTrait`.\n+        // Note that it's always sound to conflate dep-nodes, it just\n+        // leads to more recompilation.\n+        let def_ids: Vec<_> =\n+            self.input_types()\n+                .iter()\n+                .flat_map(|t| t.walk())\n+                .filter_map(|t| match t.sty {\n+                    ty::TyStruct(adt_def, _) |\n+                    ty::TyEnum(adt_def, _) =>\n+                        Some(adt_def.did),\n+                    _ =>\n+                        None\n+                })\n+                .collect();\n+        DepNode::TraitSelect(self.def_id(), def_ids)\n     }\n \n     pub fn input_types(&self) -> &[Ty<'tcx>] {\n@@ -1768,9 +1789,8 @@ impl<'a, 'tcx> AdtDefData<'tcx, 'tcx> {\n                                         stack: &mut Vec<AdtDefMaster<'tcx>>)\n     {\n \n-        let dep_node = DepNode::SizedConstraint(self.did);\n-\n-        if self.sized_constraint.get(dep_node).is_some() {\n+        let dep_node = || DepNode::SizedConstraint(self.did);\n+        if self.sized_constraint.get(dep_node()).is_some() {\n             return;\n         }\n \n@@ -1780,7 +1800,7 @@ impl<'a, 'tcx> AdtDefData<'tcx, 'tcx> {\n             //\n             // Consider the type as Sized in the meanwhile to avoid\n             // further errors.\n-            self.sized_constraint.fulfill(dep_node, tcx.types.err);\n+            self.sized_constraint.fulfill(dep_node(), tcx.types.err);\n             return;\n         }\n \n@@ -1803,14 +1823,14 @@ impl<'a, 'tcx> AdtDefData<'tcx, 'tcx> {\n             _ => tcx.mk_tup(tys)\n         };\n \n-        match self.sized_constraint.get(dep_node) {\n+        match self.sized_constraint.get(dep_node()) {\n             Some(old_ty) => {\n                 debug!(\"calculate_sized_constraint: {:?} recurred\", self);\n                 assert_eq!(old_ty, tcx.types.err)\n             }\n             None => {\n                 debug!(\"calculate_sized_constraint: {:?} => {:?}\", self, ty);\n-                self.sized_constraint.fulfill(dep_node, ty)\n+                self.sized_constraint.fulfill(dep_node(), ty)\n             }\n         }\n     }"}, {"sha": "1c0274cdcca9a68bf19d5cf8c431b8e0a64fca4e", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/382ab92ceedc258e794c1a95aef21d3be3fa76c4/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/382ab92ceedc258e794c1a95aef21d3be3fa76c4/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=382ab92ceedc258e794c1a95aef21d3be3fa76c4", "patch": "@@ -195,7 +195,7 @@ fn check_paths<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n         };\n \n-        for &(_, source_def_id, source_dep_node) in sources {\n+        for &(_, source_def_id, ref source_dep_node) in sources {\n             let dependents = query.transitive_successors(source_dep_node);\n             for &(target_span, ref target_pass, _, ref target_dep_node) in targets {\n                 if !dependents.contains(&target_dep_node) {\n@@ -239,7 +239,7 @@ fn dump_graph(tcx: TyCtxt) {\n     { // dump a .txt file with just the edges:\n         let txt_path = format!(\"{}.txt\", path);\n         let mut file = File::create(&txt_path).unwrap();\n-        for &(source, target) in &edges {\n+        for &(ref source, ref target) in &edges {\n             write!(file, \"{:?} -> {:?}\\n\", source, target).unwrap();\n         }\n     }\n@@ -252,51 +252,51 @@ fn dump_graph(tcx: TyCtxt) {\n     }\n }\n \n-pub struct GraphvizDepGraph(FnvHashSet<DepNode<DefId>>,\n-                            Vec<(DepNode<DefId>, DepNode<DefId>)>);\n+pub struct GraphvizDepGraph<'q>(FnvHashSet<&'q DepNode<DefId>>,\n+                                Vec<(&'q DepNode<DefId>, &'q DepNode<DefId>)>);\n \n-impl<'a, 'tcx> dot::GraphWalk<'a> for GraphvizDepGraph {\n-    type Node = DepNode<DefId>;\n-    type Edge = (DepNode<DefId>, DepNode<DefId>);\n-    fn nodes(&self) -> dot::Nodes<DepNode<DefId>> {\n+impl<'a, 'tcx, 'q> dot::GraphWalk<'a> for GraphvizDepGraph<'q> {\n+    type Node = &'q DepNode<DefId>;\n+    type Edge = (&'q DepNode<DefId>, &'q DepNode<DefId>);\n+    fn nodes(&self) -> dot::Nodes<&'q DepNode<DefId>> {\n         let nodes: Vec<_> = self.0.iter().cloned().collect();\n         nodes.into_cow()\n     }\n-    fn edges(&self) -> dot::Edges<(DepNode<DefId>, DepNode<DefId>)> {\n+    fn edges(&self) -> dot::Edges<(&'q DepNode<DefId>, &'q DepNode<DefId>)> {\n         self.1[..].into_cow()\n     }\n-    fn source(&self, edge: &(DepNode<DefId>, DepNode<DefId>)) -> DepNode<DefId> {\n+    fn source(&self, edge: &(&'q DepNode<DefId>, &'q DepNode<DefId>)) -> &'q DepNode<DefId> {\n         edge.0\n     }\n-    fn target(&self, edge: &(DepNode<DefId>, DepNode<DefId>)) -> DepNode<DefId> {\n+    fn target(&self, edge: &(&'q DepNode<DefId>, &'q DepNode<DefId>)) -> &'q DepNode<DefId> {\n         edge.1\n     }\n }\n \n-impl<'a, 'tcx> dot::Labeller<'a> for GraphvizDepGraph {\n-    type Node = DepNode<DefId>;\n-    type Edge = (DepNode<DefId>, DepNode<DefId>);\n+impl<'a, 'tcx, 'q> dot::Labeller<'a> for GraphvizDepGraph<'q> {\n+    type Node = &'q DepNode<DefId>;\n+    type Edge = (&'q DepNode<DefId>, &'q DepNode<DefId>);\n     fn graph_id(&self) -> dot::Id {\n         dot::Id::new(\"DependencyGraph\").unwrap()\n     }\n-    fn node_id(&self, n: &DepNode<DefId>) -> dot::Id {\n+    fn node_id(&self, n: &&'q DepNode<DefId>) -> dot::Id {\n         let s: String =\n             format!(\"{:?}\", n).chars()\n                               .map(|c| if c == '_' || c.is_alphanumeric() { c } else { '_' })\n                               .collect();\n         debug!(\"n={:?} s={:?}\", n, s);\n         dot::Id::new(s).unwrap()\n     }\n-    fn node_label(&self, n: &DepNode<DefId>) -> dot::LabelText {\n+    fn node_label(&self, n: &&'q DepNode<DefId>) -> dot::LabelText {\n         dot::LabelText::label(format!(\"{:?}\", n))\n     }\n }\n \n // Given an optional filter like `\"x,y,z\"`, returns either `None` (no\n // filter) or the set of nodes whose labels contain all of those\n // substrings.\n-fn node_set(query: &DepGraphQuery<DefId>, filter: &DepNodeFilter)\n-            -> Option<FnvHashSet<DepNode<DefId>>>\n+fn node_set<'q>(query: &'q DepGraphQuery<DefId>, filter: &DepNodeFilter)\n+                -> Option<FnvHashSet<&'q DepNode<DefId>>>\n {\n     debug!(\"node_set(filter={:?})\", filter);\n \n@@ -307,10 +307,10 @@ fn node_set(query: &DepGraphQuery<DefId>, filter: &DepNodeFilter)\n     Some(query.nodes().into_iter().filter(|n| filter.test(n)).collect())\n }\n \n-fn filter_nodes(query: &DepGraphQuery<DefId>,\n-                sources: &Option<FnvHashSet<DepNode<DefId>>>,\n-                targets: &Option<FnvHashSet<DepNode<DefId>>>)\n-                -> FnvHashSet<DepNode<DefId>>\n+fn filter_nodes<'q>(query: &'q DepGraphQuery<DefId>,\n+                    sources: &Option<FnvHashSet<&'q DepNode<DefId>>>,\n+                    targets: &Option<FnvHashSet<&'q DepNode<DefId>>>)\n+                    -> FnvHashSet<&'q DepNode<DefId>>\n {\n     if let &Some(ref sources) = sources {\n         if let &Some(ref targets) = targets {\n@@ -325,21 +325,21 @@ fn filter_nodes(query: &DepGraphQuery<DefId>,\n     }\n }\n \n-fn walk_nodes(query: &DepGraphQuery<DefId>,\n-              starts: &FnvHashSet<DepNode<DefId>>,\n-              direction: Direction)\n-              -> FnvHashSet<DepNode<DefId>>\n+fn walk_nodes<'q>(query: &'q DepGraphQuery<DefId>,\n+                  starts: &FnvHashSet<&'q DepNode<DefId>>,\n+                  direction: Direction)\n+                  -> FnvHashSet<&'q DepNode<DefId>>\n {\n     let mut set = FnvHashSet();\n-    for start in starts {\n+    for &start in starts {\n         debug!(\"walk_nodes: start={:?} outgoing?={:?}\", start, direction == OUTGOING);\n-        if set.insert(*start) {\n+        if set.insert(start) {\n             let mut stack = vec![query.indices[start]];\n             while let Some(index) = stack.pop() {\n                 for (_, edge) in query.graph.adjacent_edges(index, direction) {\n                     let neighbor_index = edge.source_or_target(direction);\n                     let neighbor = query.graph.node_data(neighbor_index);\n-                    if set.insert(*neighbor) {\n+                    if set.insert(neighbor) {\n                         stack.push(neighbor_index);\n                     }\n                 }\n@@ -349,10 +349,10 @@ fn walk_nodes(query: &DepGraphQuery<DefId>,\n     set\n }\n \n-fn walk_between(query: &DepGraphQuery<DefId>,\n-                sources: &FnvHashSet<DepNode<DefId>>,\n-                targets: &FnvHashSet<DepNode<DefId>>)\n-                -> FnvHashSet<DepNode<DefId>>\n+fn walk_between<'q>(query: &'q DepGraphQuery<DefId>,\n+                    sources: &FnvHashSet<&'q DepNode<DefId>>,\n+                    targets: &FnvHashSet<&'q DepNode<DefId>>)\n+                    -> FnvHashSet<&'q DepNode<DefId>>\n {\n     // This is a bit tricky. We want to include a node only if it is:\n     // (a) reachable from a source and (b) will reach a target. And we\n@@ -365,16 +365,16 @@ fn walk_between(query: &DepGraphQuery<DefId>,\n     let mut node_states = vec![State::Undecided; query.graph.len_nodes()];\n \n     for &target in targets {\n-        node_states[query.indices[&target].0] = State::Included;\n+        node_states[query.indices[target].0] = State::Included;\n     }\n \n-    for source in sources.iter().map(|n| query.indices[n]) {\n+    for source in sources.iter().map(|&n| query.indices[n]) {\n         recurse(query, &mut node_states, source);\n     }\n \n     return query.nodes()\n                 .into_iter()\n-                .filter(|n| {\n+                .filter(|&n| {\n                     let index = query.indices[n];\n                     node_states[index.0] == State::Included\n                 })\n@@ -417,12 +417,12 @@ fn walk_between(query: &DepGraphQuery<DefId>,\n     }\n }\n \n-fn filter_edges(query: &DepGraphQuery<DefId>,\n-                nodes: &FnvHashSet<DepNode<DefId>>)\n-                -> Vec<(DepNode<DefId>, DepNode<DefId>)>\n+fn filter_edges<'q>(query: &'q DepGraphQuery<DefId>,\n+                    nodes: &FnvHashSet<&'q DepNode<DefId>>)\n+                    -> Vec<(&'q DepNode<DefId>, &'q DepNode<DefId>)>\n {\n     query.edges()\n          .into_iter()\n-         .filter(|&(source, target)| nodes.contains(&source) && nodes.contains(&target))\n+         .filter(|&(source, target)| nodes.contains(source) && nodes.contains(target))\n          .collect()\n }"}, {"sha": "2fd6973909a8ec59c33a146658b60913049be8a2", "filename": "src/librustc_incremental/persist/directory.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/382ab92ceedc258e794c1a95aef21d3be3fa76c4/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/382ab92ceedc258e794c1a95aef21d3be3fa76c4/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs?ref=382ab92ceedc258e794c1a95aef21d3be3fa76c4", "patch": "@@ -57,7 +57,7 @@ impl RetracedDefIdDirectory {\n         self.ids[index.index as usize]\n     }\n \n-    pub fn map(&self, node: DepNode<DefPathIndex>) -> Option<DepNode<DefId>> {\n+    pub fn map(&self, node: &DepNode<DefPathIndex>) -> Option<DepNode<DefId>> {\n         node.map_def(|&index| self.def_id(index))\n     }\n }\n@@ -91,7 +91,7 @@ impl<'a,'tcx> DefIdDirectoryBuilder<'a,'tcx> {\n                  .clone()\n     }\n \n-    pub fn map(&mut self, node: DepNode<DefId>) -> DepNode<DefPathIndex> {\n+    pub fn map(&mut self, node: &DepNode<DefId>) -> DepNode<DefPathIndex> {\n         node.map_def(|&def_id| Some(self.add(def_id))).unwrap()\n     }\n "}, {"sha": "99119dd184c8b3929045d5e75afa08134e3a776a", "filename": "src/librustc_incremental/persist/hash.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/382ab92ceedc258e794c1a95aef21d3be3fa76c4/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/382ab92ceedc258e794c1a95aef21d3be3fa76c4/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs?ref=382ab92ceedc258e794c1a95aef21d3be3fa76c4", "patch": "@@ -39,8 +39,8 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n         }\n     }\n \n-    pub fn hash(&mut self, dep_node: DepNode<DefId>) -> Option<u64> {\n-        match dep_node {\n+    pub fn hash(&mut self, dep_node: &DepNode<DefId>) -> Option<u64> {\n+        match *dep_node {\n             // HIR nodes (which always come from our crate) are an input:\n             DepNode::Hir(def_id) => {\n                 assert!(def_id.is_local());"}, {"sha": "0ac1018462ee7a7eb06a2e6cc2b75a01eacda4db", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/382ab92ceedc258e794c1a95aef21d3be3fa76c4/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/382ab92ceedc258e794c1a95aef21d3be3fa76c4/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=382ab92ceedc258e794c1a95aef21d3be3fa76c4", "patch": "@@ -114,15 +114,15 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let clean_nodes =\n         serialized_dep_graph.nodes\n                             .iter()\n-                            .filter_map(|&node| retraced.map(node))\n+                            .filter_map(|node| retraced.map(node))\n                             .filter(|node| !dirty_nodes.contains(node))\n-                            .map(|node| (node, node));\n+                            .map(|node| (node.clone(), node));\n \n     // Add nodes and edges that are not dirty into our main graph.\n     let dep_graph = tcx.dep_graph.clone();\n     for (source, target) in clean_edges.into_iter().chain(clean_nodes) {\n-        let _task = dep_graph.in_task(target);\n-        dep_graph.read(source);\n+        let _task = dep_graph.in_task(target.clone());\n+        dep_graph.read(source.clone());\n \n         debug!(\"decode_dep_graph: clean edge: {:?} -> {:?}\", source, target);\n     }\n@@ -140,7 +140,7 @@ fn initial_dirty_nodes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     for hash in hashes {\n         match hash.node.map_def(|&i| retraced.def_id(i)) {\n             Some(dep_node) => {\n-                let current_hash = hcx.hash(dep_node).unwrap();\n+                let current_hash = hcx.hash(&dep_node).unwrap();\n                 debug!(\"initial_dirty_nodes: hash of {:?} is {:?}, was {:?}\",\n                        dep_node, current_hash, hash.hash);\n                 if current_hash != hash.hash {\n@@ -171,7 +171,7 @@ fn compute_clean_edges(serialized_edges: &[(SerializedEdge)],\n     // target) if neither node has been removed. If the source has\n     // been removed, add target to the list of dirty nodes.\n     let mut clean_edges = Vec::with_capacity(serialized_edges.len());\n-    for &(serialized_source, serialized_target) in serialized_edges {\n+    for &(ref serialized_source, ref serialized_target) in serialized_edges {\n         if let Some(target) = retraced.map(serialized_target) {\n             if let Some(source) = retraced.map(serialized_source) {\n                 clean_edges.push((source, target))"}, {"sha": "99f4d4f3072989b6b74a4c561bd9f32f086a0871", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/382ab92ceedc258e794c1a95aef21d3be3fa76c4/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/382ab92ceedc258e794c1a95aef21d3be3fa76c4/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=382ab92ceedc258e794c1a95aef21d3be3fa76c4", "patch": "@@ -99,7 +99,7 @@ pub fn encode_dep_graph<'a, 'tcx>(hcx: &mut HashContext<'a, 'tcx>,\n         query.nodes()\n              .into_iter()\n              .filter_map(|dep_node| {\n-                 hcx.hash(dep_node)\n+                 hcx.hash(&dep_node)\n                     .map(|hash| {\n                         let node = builder.map(dep_node);\n                         SerializedHash { node: node, hash: hash }\n@@ -147,7 +147,7 @@ pub fn encode_metadata_hashes<'a, 'tcx>(hcx: &mut HashContext<'a, 'tcx>,\n         let meta_data_def_ids =\n             query.nodes()\n                  .into_iter()\n-                 .filter_map(|dep_node| match dep_node {\n+                 .filter_map(|dep_node| match *dep_node {\n                      DepNode::MetaData(def_id) if def_id.is_local() => Some(def_id),\n                      _ => None,\n                  });\n@@ -165,8 +165,8 @@ pub fn encode_metadata_hashes<'a, 'tcx>(hcx: &mut HashContext<'a, 'tcx>,\n                 let dep_node = DepNode::MetaData(def_id);\n                 let mut state = SipHasher::new();\n                 debug!(\"save: computing metadata hash for {:?}\", dep_node);\n-                for node in query.transitive_predecessors(dep_node) {\n-                    if let Some(hash) = hcx.hash(node) {\n+                for node in query.transitive_predecessors(&dep_node) {\n+                    if let Some(hash) = hcx.hash(&node) {\n                         debug!(\"save: predecessor {:?} has hash {}\", node, hash);\n                         state.write_u64(hash.to_le());\n                     } else {"}, {"sha": "cc8ef8aedd77bbcf4472c882ba6f45a9f830e525", "filename": "src/test/incremental/struct_add_field.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/382ab92ceedc258e794c1a95aef21d3be3fa76c4/src%2Ftest%2Fincremental%2Fstruct_add_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/382ab92ceedc258e794c1a95aef21d3be3fa76c4/src%2Ftest%2Fincremental%2Fstruct_add_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstruct_add_field.rs?ref=382ab92ceedc258e794c1a95aef21d3be3fa76c4", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test incremental compilation tracking where we change field names\n+// in between revisions (hashing should be stable).\n+\n+// revisions:rpass1 rpass2\n+\n+#![feature(rustc_attrs)]\n+\n+pub struct X {\n+    pub x: u32,\n+\n+    #[cfg(rpass2)]\n+    pub x2: u32,\n+}\n+\n+pub struct EmbedX {\n+    x: X\n+}\n+\n+pub struct Y {\n+    pub y: char\n+}\n+\n+#[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+pub fn use_X(x: X) -> u32 {\n+    x.x as u32\n+}\n+\n+#[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+pub fn use_EmbedX(embed: EmbedX) -> u32 {\n+    embed.x.x as u32\n+}\n+\n+#[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+pub fn use_Y() {\n+    let x: Y = Y { y: 'c' };\n+}\n+\n+pub fn main() { }"}, {"sha": "fe29ad66b5fd8da5b8f4ee5621ef99cbfa251b17", "filename": "src/test/incremental/struct_change_field_name.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/382ab92ceedc258e794c1a95aef21d3be3fa76c4/src%2Ftest%2Fincremental%2Fstruct_change_field_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/382ab92ceedc258e794c1a95aef21d3be3fa76c4/src%2Ftest%2Fincremental%2Fstruct_change_field_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstruct_change_field_name.rs?ref=382ab92ceedc258e794c1a95aef21d3be3fa76c4", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test incremental compilation tracking where we change field names\n+// in between revisions (hashing should be stable).\n+\n+// revisions:rpass1 cfail2\n+\n+#![feature(rustc_attrs)]\n+\n+#[cfg(rpass1)]\n+pub struct X {\n+    pub x: u32\n+}\n+\n+#[cfg(cfail2)]\n+pub struct X {\n+    pub y: u32\n+}\n+\n+pub struct EmbedX {\n+    x: X\n+}\n+\n+pub struct Y {\n+    pub y: char\n+}\n+\n+#[rustc_dirty(label=\"TypeckItemBody\", cfg=\"cfail2\")]\n+pub fn use_X() -> u32 {\n+    let x: X = X { x: 22 };\n+    //[cfail2]~^ ERROR structure `X` has no field named `x`\n+    x.x as u32\n+    //[cfail2]~^ ERROR attempted access of field `x`\n+}\n+\n+#[rustc_dirty(label=\"TypeckItemBody\", cfg=\"cfail2\")]\n+pub fn use_EmbedX(embed: EmbedX) -> u32 {\n+    embed.x.x as u32\n+    //[cfail2]~^ ERROR attempted access of field `x`\n+}\n+\n+#[rustc_clean(label=\"TypeckItemBody\", cfg=\"cfail2\")]\n+pub fn use_Y() {\n+    let x: Y = Y { y: 'c' };\n+}\n+\n+pub fn main() { }"}, {"sha": "1a50d515db6d07c08d568c23494b7279e2f9a19c", "filename": "src/test/incremental/struct_change_field_type.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/382ab92ceedc258e794c1a95aef21d3be3fa76c4/src%2Ftest%2Fincremental%2Fstruct_change_field_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/382ab92ceedc258e794c1a95aef21d3be3fa76c4/src%2Ftest%2Fincremental%2Fstruct_change_field_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstruct_change_field_type.rs?ref=382ab92ceedc258e794c1a95aef21d3be3fa76c4", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test incremental compilation tracking where we change nothing\n+// in between revisions (hashing should be stable).\n+\n+// revisions:rpass1 rpass2\n+\n+#![feature(rustc_attrs)]\n+\n+#[cfg(rpass1)]\n+pub struct X {\n+    pub x: u32\n+}\n+\n+#[cfg(rpass2)]\n+pub struct X {\n+    pub x: i32\n+}\n+\n+pub struct EmbedX {\n+    x: X\n+}\n+\n+pub struct Y {\n+    pub y: char\n+}\n+\n+#[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+pub fn use_X() -> u32 {\n+    let x: X = X { x: 22 };\n+    x.x as u32\n+}\n+\n+#[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+pub fn use_EmbedX(x: EmbedX) -> u32 {\n+    let x: X = X { x: 22 };\n+    x.x as u32\n+}\n+\n+#[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+pub fn use_Y() {\n+    let x: Y = Y { y: 'c' };\n+}\n+\n+pub fn main() { }"}, {"sha": "2ddcaf157210dfef38201bad5d729743d5527db4", "filename": "src/test/incremental/struct_change_field_type_cross_crate/auxiliary/a.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/382ab92ceedc258e794c1a95aef21d3be3fa76c4/src%2Ftest%2Fincremental%2Fstruct_change_field_type_cross_crate%2Fauxiliary%2Fa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/382ab92ceedc258e794c1a95aef21d3be3fa76c4/src%2Ftest%2Fincremental%2Fstruct_change_field_type_cross_crate%2Fauxiliary%2Fa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstruct_change_field_type_cross_crate%2Fauxiliary%2Fa.rs?ref=382ab92ceedc258e794c1a95aef21d3be3fa76c4", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type=\"rlib\"]\n+\n+ #[cfg(rpass1)]\n+pub struct X {\n+    pub x: u32\n+}\n+\n+#[cfg(rpass2)]\n+pub struct X {\n+    pub x: i32\n+}\n+\n+pub struct EmbedX {\n+    pub x: X\n+}\n+\n+pub struct Y {\n+    pub y: char\n+}"}, {"sha": "7a4900d1d9a903c5aedcd996ae4a13bdebaf87f6", "filename": "src/test/incremental/struct_change_field_type_cross_crate/b.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/382ab92ceedc258e794c1a95aef21d3be3fa76c4/src%2Ftest%2Fincremental%2Fstruct_change_field_type_cross_crate%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/382ab92ceedc258e794c1a95aef21d3be3fa76c4/src%2Ftest%2Fincremental%2Fstruct_change_field_type_cross_crate%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstruct_change_field_type_cross_crate%2Fb.rs?ref=382ab92ceedc258e794c1a95aef21d3be3fa76c4", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:a.rs\n+// revisions:rpass1 rpass2\n+\n+#![feature(rustc_attrs)]\n+\n+extern crate a;\n+\n+use a::*;\n+\n+#[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+pub fn use_X() -> u32 {\n+    let x: X = X { x: 22 };\n+    x.x as u32\n+}\n+\n+#[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+pub fn use_EmbedX(embed: EmbedX) -> u32 {\n+    embed.x.x as u32\n+}\n+\n+#[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+pub fn use_Y() {\n+    let x: Y = Y { y: 'c' };\n+}\n+\n+pub fn main() { }"}, {"sha": "8095e1ecd84a095cc1aca02506ed707981c23530", "filename": "src/test/incremental/struct_change_nothing.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/382ab92ceedc258e794c1a95aef21d3be3fa76c4/src%2Ftest%2Fincremental%2Fstruct_change_nothing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/382ab92ceedc258e794c1a95aef21d3be3fa76c4/src%2Ftest%2Fincremental%2Fstruct_change_nothing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstruct_change_nothing.rs?ref=382ab92ceedc258e794c1a95aef21d3be3fa76c4", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test incremental compilation tracking where we change nothing\n+// in between revisions (hashing should be stable).\n+\n+// revisions:rpass1 rpass2\n+\n+#![feature(rustc_attrs)]\n+\n+#[cfg(rpass1)]\n+pub struct X {\n+    pub x: u32\n+}\n+\n+#[cfg(rpass2)]\n+pub struct X {\n+    pub x: u32\n+}\n+\n+pub struct EmbedX {\n+    x: X\n+}\n+\n+pub struct Y {\n+    pub y: char\n+}\n+\n+#[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+pub fn use_X() -> u32 {\n+    let x: X = X { x: 22 };\n+    x.x as u32\n+}\n+\n+#[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+pub fn use_EmbedX(x: EmbedX) -> u32 {\n+    let x: X = X { x: 22 };\n+    x.x as u32\n+}\n+\n+#[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+pub fn use_Y() {\n+    let x: Y = Y { y: 'c' };\n+}\n+\n+pub fn main() { }"}, {"sha": "ae6399463b81b138ebb25adb4221b9875aaa48da", "filename": "src/test/incremental/struct_remove_field.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/382ab92ceedc258e794c1a95aef21d3be3fa76c4/src%2Ftest%2Fincremental%2Fstruct_remove_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/382ab92ceedc258e794c1a95aef21d3be3fa76c4/src%2Ftest%2Fincremental%2Fstruct_remove_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstruct_remove_field.rs?ref=382ab92ceedc258e794c1a95aef21d3be3fa76c4", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test incremental compilation tracking where we change field names\n+// in between revisions (hashing should be stable).\n+\n+// revisions:rpass1 rpass2\n+\n+#![feature(rustc_attrs)]\n+\n+#[cfg(rpass1)]\n+pub struct X {\n+    pub x: u32,\n+    pub x2: u32,\n+}\n+\n+#[cfg(rpass2)]\n+pub struct X {\n+    pub x: u32,\n+}\n+\n+pub struct EmbedX {\n+    x: X\n+}\n+\n+pub struct Y {\n+    pub y: char\n+}\n+\n+#[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+pub fn use_X(x: X) -> u32 {\n+    x.x as u32\n+}\n+\n+#[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+pub fn use_EmbedX(embed: EmbedX) -> u32 {\n+    embed.x.x as u32\n+}\n+\n+#[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+pub fn use_Y() {\n+    let x: Y = Y { y: 'c' };\n+}\n+\n+pub fn main() { }"}, {"sha": "e1dba1317703d6c448b969d1327a3884b8cc113c", "filename": "src/test/incremental/type_alias_cross_crate/auxiliary/a.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/382ab92ceedc258e794c1a95aef21d3be3fa76c4/src%2Ftest%2Fincremental%2Ftype_alias_cross_crate%2Fauxiliary%2Fa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/382ab92ceedc258e794c1a95aef21d3be3fa76c4/src%2Ftest%2Fincremental%2Ftype_alias_cross_crate%2Fauxiliary%2Fa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Ftype_alias_cross_crate%2Fauxiliary%2Fa.rs?ref=382ab92ceedc258e794c1a95aef21d3be3fa76c4", "patch": "@@ -16,4 +16,8 @@ pub type X = u32;\n #[cfg(rpass2)]\n pub type X = i32;\n \n+// this version doesn't actually change anything:\n+#[cfg(rpass3)]\n+pub type X = i32;\n+\n pub type Y = char;"}, {"sha": "c5421fcbf5cb2310362327ad5ffe0f9e1e8b470e", "filename": "src/test/incremental/type_alias_cross_crate/b.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/382ab92ceedc258e794c1a95aef21d3be3fa76c4/src%2Ftest%2Fincremental%2Ftype_alias_cross_crate%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/382ab92ceedc258e794c1a95aef21d3be3fa76c4/src%2Ftest%2Fincremental%2Ftype_alias_cross_crate%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Ftype_alias_cross_crate%2Fb.rs?ref=382ab92ceedc258e794c1a95aef21d3be3fa76c4", "patch": "@@ -9,19 +9,21 @@\n // except according to those terms.\n \n // aux-build:a.rs\n-// revisions:rpass1 rpass2\n+// revisions:rpass1 rpass2 rpass3\n \n #![feature(rustc_attrs)]\n \n extern crate a;\n \n #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+#[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass3\")]\n pub fn use_X() -> u32 {\n     let x: a::X = 22;\n     x as u32\n }\n \n #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+#[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass3\")]\n pub fn use_Y() {\n     let x: a::Y = 'c';\n }"}]}