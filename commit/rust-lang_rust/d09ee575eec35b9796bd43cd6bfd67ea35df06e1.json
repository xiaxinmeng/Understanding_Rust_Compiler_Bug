{"sha": "d09ee575eec35b9796bd43cd6bfd67ea35df06e1", "node_id": "C_kwDOAAsO6NoAKGQwOWVlNTc1ZWVjMzViOTc5NmJkNDNjZDZiZmQ2N2VhMzVkZjA2ZTE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-05-24T19:36:57Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-05-24T19:36:57Z"}, "message": "Rollup merge of #111862 - compiler-errors:opq, r=lcnr\n\nSplit out opaque collection from from `type_of`\n\nrequested by lcnr\n\nr? `@lcnr`", "tree": {"sha": "d16855009f273c1c683d9d568c369dcd4ac608f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d16855009f273c1c683d9d568c369dcd4ac608f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d09ee575eec35b9796bd43cd6bfd67ea35df06e1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkbmdZCRBK7hj4Ov3rIwAAODMIAC3ZA36usDoKABUepRM2YjQ+\nQO9BxRno/HZ2axKXJV2buV/xTkOZDMipOXskV5PzWkyk2WUEurPUuw1pAeSs74UO\nyZJib6AtKehkKGxoe2Fa98gny3z7T0VGcktERW9Mk4O0OzC8qP++OCJmGM3i4WwN\nssYMfJVUJHa4ZqNnCChUWU990O+eYEYYi8k6gVW7BHIiyCXTXtaKtFz0J7uAuxj/\nVDQ7SsC9AqspxxrWa2Ie81av2SAyMuKX/4brtl5Xoo7eMUAjRhYPHbpLd5I5MCC5\ni6cn+HDT3e5u2chBk2UO56ly/H7TcLO3Sy76Oaaj0yTmBtFsWaZzaPzkrXPhDR0=\n=tSyf\n-----END PGP SIGNATURE-----\n", "payload": "tree d16855009f273c1c683d9d568c369dcd4ac608f2\nparent 092352f6fd4d539040136068ee237f01b99d3630\nparent d7ccbdd69627dc574f569aef51fa979157cd25d8\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1684957017 +0200\ncommitter GitHub <noreply@github.com> 1684957017 +0200\n\nRollup merge of #111862 - compiler-errors:opq, r=lcnr\n\nSplit out opaque collection from from `type_of`\n\nrequested by lcnr\n\nr? `@lcnr`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d09ee575eec35b9796bd43cd6bfd67ea35df06e1", "html_url": "https://github.com/rust-lang/rust/commit/d09ee575eec35b9796bd43cd6bfd67ea35df06e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d09ee575eec35b9796bd43cd6bfd67ea35df06e1/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "092352f6fd4d539040136068ee237f01b99d3630", "url": "https://api.github.com/repos/rust-lang/rust/commits/092352f6fd4d539040136068ee237f01b99d3630", "html_url": "https://github.com/rust-lang/rust/commit/092352f6fd4d539040136068ee237f01b99d3630"}, {"sha": "d7ccbdd69627dc574f569aef51fa979157cd25d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7ccbdd69627dc574f569aef51fa979157cd25d8", "html_url": "https://github.com/rust-lang/rust/commit/d7ccbdd69627dc574f569aef51fa979157cd25d8"}], "stats": {"total": 608, "additions": 303, "deletions": 305}, "files": [{"sha": "8e082d3c5328b786faf1e5d07767072b278d9503", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 5, "deletions": 305, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/d09ee575eec35b9796bd43cd6bfd67ea35df06e1/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09ee575eec35b9796bd43cd6bfd67ea35df06e1/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=d09ee575eec35b9796bd43cd6bfd67ea35df06e1", "patch": "@@ -1,10 +1,7 @@\n use rustc_errors::{Applicability, StashKey};\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n-use rustc_hir::intravisit;\n-use rustc_hir::intravisit::Visitor;\n-use rustc_hir::{HirId, Node};\n-use rustc_middle::hir::nested_filter;\n+use rustc_hir::HirId;\n use rustc_middle::ty::print::with_forced_trimmed_paths;\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::util::IntTypeExt;\n@@ -14,7 +11,8 @@ use rustc_span::{Span, DUMMY_SP};\n \n use super::ItemCtxt;\n use super::{bad_placeholder, is_suggestable_infer_ty};\n-use crate::errors::UnconstrainedOpaqueType;\n+\n+mod opaque;\n \n fn anon_const_type_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> Ty<'tcx> {\n     use hir::*;\n@@ -429,7 +427,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::EarlyBinder<Ty\n                 ItemKind::OpaqueTy(OpaqueTy {\n                     origin: hir::OpaqueTyOrigin::TyAlias { .. },\n                     ..\n-                }) => find_opaque_ty_constraints_for_tait(tcx, def_id),\n+                }) => opaque::find_opaque_ty_constraints_for_tait(tcx, def_id),\n                 // Opaque types desugared from `impl Trait`.\n                 ItemKind::OpaqueTy(OpaqueTy {\n                     origin:\n@@ -443,7 +441,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::EarlyBinder<Ty\n                             \"tried to get type of this RPITIT with no definition\"\n                         );\n                     }\n-                    find_opaque_ty_constraints_for_rpit(tcx, def_id, owner)\n+                    opaque::find_opaque_ty_constraints_for_rpit(tcx, def_id, owner)\n                 }\n                 ItemKind::Trait(..)\n                 | ItemKind::TraitAlias(..)\n@@ -502,304 +500,6 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::EarlyBinder<Ty\n     ty::EarlyBinder(output)\n }\n \n-#[instrument(skip(tcx), level = \"debug\")]\n-/// Checks \"defining uses\" of opaque `impl Trait` types to ensure that they meet the restrictions\n-/// laid for \"higher-order pattern unification\".\n-/// This ensures that inference is tractable.\n-/// In particular, definitions of opaque types can only use other generics as arguments,\n-/// and they cannot repeat an argument. Example:\n-///\n-/// ```ignore (illustrative)\n-/// type Foo<A, B> = impl Bar<A, B>;\n-///\n-/// // Okay -- `Foo` is applied to two distinct, generic types.\n-/// fn a<T, U>() -> Foo<T, U> { .. }\n-///\n-/// // Not okay -- `Foo` is applied to `T` twice.\n-/// fn b<T>() -> Foo<T, T> { .. }\n-///\n-/// // Not okay -- `Foo` is applied to a non-generic type.\n-/// fn b<T>() -> Foo<T, u32> { .. }\n-/// ```\n-///\n-fn find_opaque_ty_constraints_for_tait(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n-    use rustc_hir::{Expr, ImplItem, Item, TraitItem};\n-\n-    struct ConstraintLocator<'tcx> {\n-        tcx: TyCtxt<'tcx>,\n-\n-        /// def_id of the opaque type whose defining uses are being checked\n-        def_id: LocalDefId,\n-\n-        /// as we walk the defining uses, we are checking that all of them\n-        /// define the same hidden type. This variable is set to `Some`\n-        /// with the first type that we find, and then later types are\n-        /// checked against it (we also carry the span of that first\n-        /// type).\n-        found: Option<ty::OpaqueHiddenType<'tcx>>,\n-\n-        /// In the presence of dead code, typeck may figure out a hidden type\n-        /// while borrowck will not. We collect these cases here and check at\n-        /// the end that we actually found a type that matches (modulo regions).\n-        typeck_types: Vec<ty::OpaqueHiddenType<'tcx>>,\n-    }\n-\n-    impl ConstraintLocator<'_> {\n-        #[instrument(skip(self), level = \"debug\")]\n-        fn check(&mut self, item_def_id: LocalDefId) {\n-            // Don't try to check items that cannot possibly constrain the type.\n-            if !self.tcx.has_typeck_results(item_def_id) {\n-                debug!(\"no constraint: no typeck results\");\n-                return;\n-            }\n-            // Calling `mir_borrowck` can lead to cycle errors through\n-            // const-checking, avoid calling it if we don't have to.\n-            // ```rust\n-            // type Foo = impl Fn() -> usize; // when computing type for this\n-            // const fn bar() -> Foo {\n-            //     || 0usize\n-            // }\n-            // const BAZR: Foo = bar(); // we would mir-borrowck this, causing cycles\n-            // // because we again need to reveal `Foo` so we can check whether the\n-            // // constant does not contain interior mutability.\n-            // ```\n-            let tables = self.tcx.typeck(item_def_id);\n-            if let Some(guar) = tables.tainted_by_errors {\n-                self.found =\n-                    Some(ty::OpaqueHiddenType { span: DUMMY_SP, ty: self.tcx.ty_error(guar) });\n-                return;\n-            }\n-            let Some(&typeck_hidden_ty) = tables.concrete_opaque_types.get(&self.def_id) else {\n-                debug!(\"no constraints in typeck results\");\n-                return;\n-            };\n-            if self.typeck_types.iter().all(|prev| prev.ty != typeck_hidden_ty.ty) {\n-                self.typeck_types.push(typeck_hidden_ty);\n-            }\n-\n-            // Use borrowck to get the type with unerased regions.\n-            let concrete_opaque_types = &self.tcx.mir_borrowck(item_def_id).concrete_opaque_types;\n-            debug!(?concrete_opaque_types);\n-            if let Some(&concrete_type) = concrete_opaque_types.get(&self.def_id) {\n-                debug!(?concrete_type, \"found constraint\");\n-                if let Some(prev) = &mut self.found {\n-                    if concrete_type.ty != prev.ty && !(concrete_type, prev.ty).references_error() {\n-                        let guar =\n-                            prev.report_mismatch(&concrete_type, self.def_id, self.tcx).emit();\n-                        prev.ty = self.tcx.ty_error(guar);\n-                    }\n-                } else {\n-                    self.found = Some(concrete_type);\n-                }\n-            }\n-        }\n-    }\n-\n-    impl<'tcx> intravisit::Visitor<'tcx> for ConstraintLocator<'tcx> {\n-        type NestedFilter = nested_filter::All;\n-\n-        fn nested_visit_map(&mut self) -> Self::Map {\n-            self.tcx.hir()\n-        }\n-        fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n-            if let hir::ExprKind::Closure(closure) = ex.kind {\n-                self.check(closure.def_id);\n-            }\n-            intravisit::walk_expr(self, ex);\n-        }\n-        fn visit_item(&mut self, it: &'tcx Item<'tcx>) {\n-            trace!(?it.owner_id);\n-            // The opaque type itself or its children are not within its reveal scope.\n-            if it.owner_id.def_id != self.def_id {\n-                self.check(it.owner_id.def_id);\n-                intravisit::walk_item(self, it);\n-            }\n-        }\n-        fn visit_impl_item(&mut self, it: &'tcx ImplItem<'tcx>) {\n-            trace!(?it.owner_id);\n-            // The opaque type itself or its children are not within its reveal scope.\n-            if it.owner_id.def_id != self.def_id {\n-                self.check(it.owner_id.def_id);\n-                intravisit::walk_impl_item(self, it);\n-            }\n-        }\n-        fn visit_trait_item(&mut self, it: &'tcx TraitItem<'tcx>) {\n-            trace!(?it.owner_id);\n-            self.check(it.owner_id.def_id);\n-            intravisit::walk_trait_item(self, it);\n-        }\n-    }\n-\n-    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-    let scope = tcx.hir().get_defining_scope(hir_id);\n-    let mut locator = ConstraintLocator { def_id, tcx, found: None, typeck_types: vec![] };\n-\n-    debug!(?scope);\n-\n-    if scope == hir::CRATE_HIR_ID {\n-        tcx.hir().walk_toplevel_module(&mut locator);\n-    } else {\n-        trace!(\"scope={:#?}\", tcx.hir().get(scope));\n-        match tcx.hir().get(scope) {\n-            // We explicitly call `visit_*` methods, instead of using `intravisit::walk_*` methods\n-            // This allows our visitor to process the defining item itself, causing\n-            // it to pick up any 'sibling' defining uses.\n-            //\n-            // For example, this code:\n-            // ```\n-            // fn foo() {\n-            //     type Blah = impl Debug;\n-            //     let my_closure = || -> Blah { true };\n-            // }\n-            // ```\n-            //\n-            // requires us to explicitly process `foo()` in order\n-            // to notice the defining usage of `Blah`.\n-            Node::Item(it) => locator.visit_item(it),\n-            Node::ImplItem(it) => locator.visit_impl_item(it),\n-            Node::TraitItem(it) => locator.visit_trait_item(it),\n-            other => bug!(\"{:?} is not a valid scope for an opaque type item\", other),\n-        }\n-    }\n-\n-    let Some(hidden) = locator.found else {\n-        let reported = tcx.sess.emit_err(UnconstrainedOpaqueType {\n-            span: tcx.def_span(def_id),\n-            name: tcx.item_name(tcx.local_parent(def_id).to_def_id()),\n-            what: match tcx.hir().get(scope) {\n-                _ if scope == hir::CRATE_HIR_ID => \"module\",\n-                Node::Item(hir::Item { kind: hir::ItemKind::Mod(_), .. }) => \"module\",\n-                Node::Item(hir::Item { kind: hir::ItemKind::Impl(_), .. }) => \"impl\",\n-                _ => \"item\",\n-            },\n-        });\n-        return tcx.ty_error(reported);\n-    };\n-\n-    // Only check against typeck if we didn't already error\n-    if !hidden.ty.references_error() {\n-        for concrete_type in locator.typeck_types {\n-            if concrete_type.ty != tcx.erase_regions(hidden.ty)\n-                && !(concrete_type, hidden).references_error()\n-            {\n-                hidden.report_mismatch(&concrete_type, def_id, tcx).emit();\n-            }\n-        }\n-    }\n-\n-    hidden.ty\n-}\n-\n-fn find_opaque_ty_constraints_for_rpit(\n-    tcx: TyCtxt<'_>,\n-    def_id: LocalDefId,\n-    owner_def_id: LocalDefId,\n-) -> Ty<'_> {\n-    use rustc_hir::{Expr, ImplItem, Item, TraitItem};\n-\n-    struct ConstraintChecker<'tcx> {\n-        tcx: TyCtxt<'tcx>,\n-\n-        /// def_id of the opaque type whose defining uses are being checked\n-        def_id: LocalDefId,\n-\n-        found: ty::OpaqueHiddenType<'tcx>,\n-    }\n-\n-    impl ConstraintChecker<'_> {\n-        #[instrument(skip(self), level = \"debug\")]\n-        fn check(&self, def_id: LocalDefId) {\n-            // Use borrowck to get the type with unerased regions.\n-            let concrete_opaque_types = &self.tcx.mir_borrowck(def_id).concrete_opaque_types;\n-            debug!(?concrete_opaque_types);\n-            for (&def_id, &concrete_type) in concrete_opaque_types {\n-                if def_id != self.def_id {\n-                    // Ignore constraints for other opaque types.\n-                    continue;\n-                }\n-\n-                debug!(?concrete_type, \"found constraint\");\n-\n-                if concrete_type.ty != self.found.ty\n-                    && !(concrete_type, self.found).references_error()\n-                {\n-                    self.found.report_mismatch(&concrete_type, self.def_id, self.tcx).emit();\n-                }\n-            }\n-        }\n-    }\n-\n-    impl<'tcx> intravisit::Visitor<'tcx> for ConstraintChecker<'tcx> {\n-        type NestedFilter = nested_filter::OnlyBodies;\n-\n-        fn nested_visit_map(&mut self) -> Self::Map {\n-            self.tcx.hir()\n-        }\n-        fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n-            if let hir::ExprKind::Closure(closure) = ex.kind {\n-                self.check(closure.def_id);\n-            }\n-            intravisit::walk_expr(self, ex);\n-        }\n-        fn visit_item(&mut self, it: &'tcx Item<'tcx>) {\n-            trace!(?it.owner_id);\n-            // The opaque type itself or its children are not within its reveal scope.\n-            if it.owner_id.def_id != self.def_id {\n-                self.check(it.owner_id.def_id);\n-                intravisit::walk_item(self, it);\n-            }\n-        }\n-        fn visit_impl_item(&mut self, it: &'tcx ImplItem<'tcx>) {\n-            trace!(?it.owner_id);\n-            // The opaque type itself or its children are not within its reveal scope.\n-            if it.owner_id.def_id != self.def_id {\n-                self.check(it.owner_id.def_id);\n-                intravisit::walk_impl_item(self, it);\n-            }\n-        }\n-        fn visit_trait_item(&mut self, it: &'tcx TraitItem<'tcx>) {\n-            trace!(?it.owner_id);\n-            self.check(it.owner_id.def_id);\n-            intravisit::walk_trait_item(self, it);\n-        }\n-    }\n-\n-    let concrete = tcx.mir_borrowck(owner_def_id).concrete_opaque_types.get(&def_id).copied();\n-\n-    if let Some(concrete) = concrete {\n-        let scope = tcx.hir().local_def_id_to_hir_id(owner_def_id);\n-        debug!(?scope);\n-        let mut locator = ConstraintChecker { def_id, tcx, found: concrete };\n-\n-        match tcx.hir().get(scope) {\n-            Node::Item(it) => intravisit::walk_item(&mut locator, it),\n-            Node::ImplItem(it) => intravisit::walk_impl_item(&mut locator, it),\n-            Node::TraitItem(it) => intravisit::walk_trait_item(&mut locator, it),\n-            other => bug!(\"{:?} is not a valid scope for an opaque type item\", other),\n-        }\n-    }\n-\n-    concrete.map(|concrete| concrete.ty).unwrap_or_else(|| {\n-        let table = tcx.typeck(owner_def_id);\n-        if let Some(guar) = table.tainted_by_errors {\n-            // Some error in the\n-            // owner fn prevented us from populating\n-            // the `concrete_opaque_types` table.\n-            tcx.ty_error(guar)\n-        } else {\n-            table.concrete_opaque_types.get(&def_id).map(|ty| ty.ty).unwrap_or_else(|| {\n-                // We failed to resolve the opaque type or it\n-                // resolves to itself. We interpret this as the\n-                // no values of the hidden type ever being constructed,\n-                // so we can just make the hidden type be `!`.\n-                // For backwards compatibility reasons, we fall back to\n-                // `()` until we the diverging default is changed.\n-                tcx.mk_diverging_default()\n-            })\n-        }\n-    })\n-}\n-\n fn infer_placeholder_type<'a>(\n     tcx: TyCtxt<'a>,\n     def_id: LocalDefId,"}, {"sha": "f7c5b44678f72f0877ceab58f1175f72e1f5c29b", "filename": "compiler/rustc_hir_analysis/src/collect/type_of/opaque.rs", "status": "added", "additions": 298, "deletions": 0, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/d09ee575eec35b9796bd43cd6bfd67ea35df06e1/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d09ee575eec35b9796bd43cd6bfd67ea35df06e1/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of%2Fopaque.rs?ref=d09ee575eec35b9796bd43cd6bfd67ea35df06e1", "patch": "@@ -0,0 +1,298 @@\n+use rustc_hir::def_id::LocalDefId;\n+use rustc_hir::intravisit::{self, Visitor};\n+use rustc_hir::{self as hir, Expr, ImplItem, Item, Node, TraitItem};\n+use rustc_middle::hir::nested_filter;\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitableExt};\n+use rustc_span::DUMMY_SP;\n+\n+use crate::errors::UnconstrainedOpaqueType;\n+\n+/// Checks \"defining uses\" of opaque `impl Trait` types to ensure that they meet the restrictions\n+/// laid for \"higher-order pattern unification\".\n+/// This ensures that inference is tractable.\n+/// In particular, definitions of opaque types can only use other generics as arguments,\n+/// and they cannot repeat an argument. Example:\n+///\n+/// ```ignore (illustrative)\n+/// type Foo<A, B> = impl Bar<A, B>;\n+///\n+/// // Okay -- `Foo` is applied to two distinct, generic types.\n+/// fn a<T, U>() -> Foo<T, U> { .. }\n+///\n+/// // Not okay -- `Foo` is applied to `T` twice.\n+/// fn b<T>() -> Foo<T, T> { .. }\n+///\n+/// // Not okay -- `Foo` is applied to a non-generic type.\n+/// fn b<T>() -> Foo<T, u32> { .. }\n+/// ```\n+#[instrument(skip(tcx), level = \"debug\")]\n+pub(super) fn find_opaque_ty_constraints_for_tait(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+    let scope = tcx.hir().get_defining_scope(hir_id);\n+    let mut locator = TaitConstraintLocator { def_id, tcx, found: None, typeck_types: vec![] };\n+\n+    debug!(?scope);\n+\n+    if scope == hir::CRATE_HIR_ID {\n+        tcx.hir().walk_toplevel_module(&mut locator);\n+    } else {\n+        trace!(\"scope={:#?}\", tcx.hir().get(scope));\n+        match tcx.hir().get(scope) {\n+            // We explicitly call `visit_*` methods, instead of using `intravisit::walk_*` methods\n+            // This allows our visitor to process the defining item itself, causing\n+            // it to pick up any 'sibling' defining uses.\n+            //\n+            // For example, this code:\n+            // ```\n+            // fn foo() {\n+            //     type Blah = impl Debug;\n+            //     let my_closure = || -> Blah { true };\n+            // }\n+            // ```\n+            //\n+            // requires us to explicitly process `foo()` in order\n+            // to notice the defining usage of `Blah`.\n+            Node::Item(it) => locator.visit_item(it),\n+            Node::ImplItem(it) => locator.visit_impl_item(it),\n+            Node::TraitItem(it) => locator.visit_trait_item(it),\n+            other => bug!(\"{:?} is not a valid scope for an opaque type item\", other),\n+        }\n+    }\n+\n+    let Some(hidden) = locator.found else {\n+        let reported = tcx.sess.emit_err(UnconstrainedOpaqueType {\n+            span: tcx.def_span(def_id),\n+            name: tcx.item_name(tcx.local_parent(def_id).to_def_id()),\n+            what: match tcx.hir().get(scope) {\n+                _ if scope == hir::CRATE_HIR_ID => \"module\",\n+                Node::Item(hir::Item { kind: hir::ItemKind::Mod(_), .. }) => \"module\",\n+                Node::Item(hir::Item { kind: hir::ItemKind::Impl(_), .. }) => \"impl\",\n+                _ => \"item\",\n+            },\n+        });\n+        return tcx.ty_error(reported);\n+    };\n+\n+    // Only check against typeck if we didn't already error\n+    if !hidden.ty.references_error() {\n+        for concrete_type in locator.typeck_types {\n+            if concrete_type.ty != tcx.erase_regions(hidden.ty)\n+                && !(concrete_type, hidden).references_error()\n+            {\n+                hidden.report_mismatch(&concrete_type, def_id, tcx).emit();\n+            }\n+        }\n+    }\n+\n+    hidden.ty\n+}\n+\n+struct TaitConstraintLocator<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+\n+    /// def_id of the opaque type whose defining uses are being checked\n+    def_id: LocalDefId,\n+\n+    /// as we walk the defining uses, we are checking that all of them\n+    /// define the same hidden type. This variable is set to `Some`\n+    /// with the first type that we find, and then later types are\n+    /// checked against it (we also carry the span of that first\n+    /// type).\n+    found: Option<ty::OpaqueHiddenType<'tcx>>,\n+\n+    /// In the presence of dead code, typeck may figure out a hidden type\n+    /// while borrowck will not. We collect these cases here and check at\n+    /// the end that we actually found a type that matches (modulo regions).\n+    typeck_types: Vec<ty::OpaqueHiddenType<'tcx>>,\n+}\n+\n+impl TaitConstraintLocator<'_> {\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn check(&mut self, item_def_id: LocalDefId) {\n+        // Don't try to check items that cannot possibly constrain the type.\n+        if !self.tcx.has_typeck_results(item_def_id) {\n+            debug!(\"no constraint: no typeck results\");\n+            return;\n+        }\n+        // Calling `mir_borrowck` can lead to cycle errors through\n+        // const-checking, avoid calling it if we don't have to.\n+        // ```rust\n+        // type Foo = impl Fn() -> usize; // when computing type for this\n+        // const fn bar() -> Foo {\n+        //     || 0usize\n+        // }\n+        // const BAZR: Foo = bar(); // we would mir-borrowck this, causing cycles\n+        // // because we again need to reveal `Foo` so we can check whether the\n+        // // constant does not contain interior mutability.\n+        // ```\n+        let tables = self.tcx.typeck(item_def_id);\n+        if let Some(guar) = tables.tainted_by_errors {\n+            self.found = Some(ty::OpaqueHiddenType { span: DUMMY_SP, ty: self.tcx.ty_error(guar) });\n+            return;\n+        }\n+        let Some(&typeck_hidden_ty) = tables.concrete_opaque_types.get(&self.def_id) else {\n+            debug!(\"no constraints in typeck results\");\n+            return;\n+        };\n+        if self.typeck_types.iter().all(|prev| prev.ty != typeck_hidden_ty.ty) {\n+            self.typeck_types.push(typeck_hidden_ty);\n+        }\n+\n+        // Use borrowck to get the type with unerased regions.\n+        let concrete_opaque_types = &self.tcx.mir_borrowck(item_def_id).concrete_opaque_types;\n+        debug!(?concrete_opaque_types);\n+        if let Some(&concrete_type) = concrete_opaque_types.get(&self.def_id) {\n+            debug!(?concrete_type, \"found constraint\");\n+            if let Some(prev) = &mut self.found {\n+                if concrete_type.ty != prev.ty && !(concrete_type, prev.ty).references_error() {\n+                    let guar = prev.report_mismatch(&concrete_type, self.def_id, self.tcx).emit();\n+                    prev.ty = self.tcx.ty_error(guar);\n+                }\n+            } else {\n+                self.found = Some(concrete_type);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> intravisit::Visitor<'tcx> for TaitConstraintLocator<'tcx> {\n+    type NestedFilter = nested_filter::All;\n+\n+    fn nested_visit_map(&mut self) -> Self::Map {\n+        self.tcx.hir()\n+    }\n+    fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n+        if let hir::ExprKind::Closure(closure) = ex.kind {\n+            self.check(closure.def_id);\n+        }\n+        intravisit::walk_expr(self, ex);\n+    }\n+    fn visit_item(&mut self, it: &'tcx Item<'tcx>) {\n+        trace!(?it.owner_id);\n+        // The opaque type itself or its children are not within its reveal scope.\n+        if it.owner_id.def_id != self.def_id {\n+            self.check(it.owner_id.def_id);\n+            intravisit::walk_item(self, it);\n+        }\n+    }\n+    fn visit_impl_item(&mut self, it: &'tcx ImplItem<'tcx>) {\n+        trace!(?it.owner_id);\n+        // The opaque type itself or its children are not within its reveal scope.\n+        if it.owner_id.def_id != self.def_id {\n+            self.check(it.owner_id.def_id);\n+            intravisit::walk_impl_item(self, it);\n+        }\n+    }\n+    fn visit_trait_item(&mut self, it: &'tcx TraitItem<'tcx>) {\n+        trace!(?it.owner_id);\n+        self.check(it.owner_id.def_id);\n+        intravisit::walk_trait_item(self, it);\n+    }\n+}\n+\n+pub(super) fn find_opaque_ty_constraints_for_rpit(\n+    tcx: TyCtxt<'_>,\n+    def_id: LocalDefId,\n+    owner_def_id: LocalDefId,\n+) -> Ty<'_> {\n+    let concrete = tcx.mir_borrowck(owner_def_id).concrete_opaque_types.get(&def_id).copied();\n+\n+    if let Some(concrete) = concrete {\n+        let scope = tcx.hir().local_def_id_to_hir_id(owner_def_id);\n+        debug!(?scope);\n+        let mut locator = RpitConstraintChecker { def_id, tcx, found: concrete };\n+\n+        match tcx.hir().get(scope) {\n+            Node::Item(it) => intravisit::walk_item(&mut locator, it),\n+            Node::ImplItem(it) => intravisit::walk_impl_item(&mut locator, it),\n+            Node::TraitItem(it) => intravisit::walk_trait_item(&mut locator, it),\n+            other => bug!(\"{:?} is not a valid scope for an opaque type item\", other),\n+        }\n+    }\n+\n+    concrete.map(|concrete| concrete.ty).unwrap_or_else(|| {\n+        let table = tcx.typeck(owner_def_id);\n+        if let Some(guar) = table.tainted_by_errors {\n+            // Some error in the\n+            // owner fn prevented us from populating\n+            // the `concrete_opaque_types` table.\n+            tcx.ty_error(guar)\n+        } else {\n+            table.concrete_opaque_types.get(&def_id).map(|ty| ty.ty).unwrap_or_else(|| {\n+                // We failed to resolve the opaque type or it\n+                // resolves to itself. We interpret this as the\n+                // no values of the hidden type ever being constructed,\n+                // so we can just make the hidden type be `!`.\n+                // For backwards compatibility reasons, we fall back to\n+                // `()` until we the diverging default is changed.\n+                tcx.mk_diverging_default()\n+            })\n+        }\n+    })\n+}\n+\n+struct RpitConstraintChecker<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+\n+    /// def_id of the opaque type whose defining uses are being checked\n+    def_id: LocalDefId,\n+\n+    found: ty::OpaqueHiddenType<'tcx>,\n+}\n+\n+impl RpitConstraintChecker<'_> {\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn check(&self, def_id: LocalDefId) {\n+        // Use borrowck to get the type with unerased regions.\n+        let concrete_opaque_types = &self.tcx.mir_borrowck(def_id).concrete_opaque_types;\n+        debug!(?concrete_opaque_types);\n+        for (&def_id, &concrete_type) in concrete_opaque_types {\n+            if def_id != self.def_id {\n+                // Ignore constraints for other opaque types.\n+                continue;\n+            }\n+\n+            debug!(?concrete_type, \"found constraint\");\n+\n+            if concrete_type.ty != self.found.ty && !(concrete_type, self.found).references_error()\n+            {\n+                self.found.report_mismatch(&concrete_type, self.def_id, self.tcx).emit();\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> intravisit::Visitor<'tcx> for RpitConstraintChecker<'tcx> {\n+    type NestedFilter = nested_filter::OnlyBodies;\n+\n+    fn nested_visit_map(&mut self) -> Self::Map {\n+        self.tcx.hir()\n+    }\n+    fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n+        if let hir::ExprKind::Closure(closure) = ex.kind {\n+            self.check(closure.def_id);\n+        }\n+        intravisit::walk_expr(self, ex);\n+    }\n+    fn visit_item(&mut self, it: &'tcx Item<'tcx>) {\n+        trace!(?it.owner_id);\n+        // The opaque type itself or its children are not within its reveal scope.\n+        if it.owner_id.def_id != self.def_id {\n+            self.check(it.owner_id.def_id);\n+            intravisit::walk_item(self, it);\n+        }\n+    }\n+    fn visit_impl_item(&mut self, it: &'tcx ImplItem<'tcx>) {\n+        trace!(?it.owner_id);\n+        // The opaque type itself or its children are not within its reveal scope.\n+        if it.owner_id.def_id != self.def_id {\n+            self.check(it.owner_id.def_id);\n+            intravisit::walk_impl_item(self, it);\n+        }\n+    }\n+    fn visit_trait_item(&mut self, it: &'tcx TraitItem<'tcx>) {\n+        trace!(?it.owner_id);\n+        self.check(it.owner_id.def_id);\n+        intravisit::walk_trait_item(self, it);\n+    }\n+}"}]}