{"sha": "1cc938a69adddc4b8b529c12aec62909c35dd704", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjYzkzOGE2OWFkZGRjNGI4YjUyOWMxMmFlYzYyOTA5YzM1ZGQ3MDQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-10-27T16:07:56Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-10-27T22:12:45Z"}, "message": "rollup merge of #18337 : bkoropoff/unboxed-imm-upvar-fixes", "tree": {"sha": "f52280d693524b338ff9cf499d46ad999e0fe31c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f52280d693524b338ff9cf499d46ad999e0fe31c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1cc938a69adddc4b8b529c12aec62909c35dd704", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1cc938a69adddc4b8b529c12aec62909c35dd704", "html_url": "https://github.com/rust-lang/rust/commit/1cc938a69adddc4b8b529c12aec62909c35dd704", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1cc938a69adddc4b8b529c12aec62909c35dd704/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "175d6a74355ea1b9470866818c9b47d1a50900c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/175d6a74355ea1b9470866818c9b47d1a50900c7", "html_url": "https://github.com/rust-lang/rust/commit/175d6a74355ea1b9470866818c9b47d1a50900c7"}, {"sha": "5662bbad0726811be241f88086781208875b05e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/5662bbad0726811be241f88086781208875b05e1", "html_url": "https://github.com/rust-lang/rust/commit/5662bbad0726811be241f88086781208875b05e1"}], "stats": {"total": 250, "additions": 174, "deletions": 76}, "files": [{"sha": "de61f4f2b404c78a46b7defe3b9d719c2e572e9c", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 31, "deletions": 8, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/1cc938a69adddc4b8b529c12aec62909c35dd704/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cc938a69adddc4b8b529c12aec62909c35dd704/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=1cc938a69adddc4b8b529c12aec62909c35dd704", "patch": "@@ -777,13 +777,28 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         // Otherwise, just a plain error.\n         match assignee_cmt.note {\n             mc::NoteClosureEnv(upvar_id) => {\n-                self.bccx.span_err(\n-                    assignment_span,\n-                    format!(\"cannot assign to {}\",\n-                            self.bccx.cmt_to_string(&*assignee_cmt)).as_slice());\n-                self.bccx.span_note(\n-                    self.tcx().map.span(upvar_id.closure_expr_id),\n-                    \"consider changing this closure to take self by mutable reference\");\n+                // If this is an `Fn` closure, it simply can't mutate upvars.\n+                // If it's an `FnMut` closure, the original variable was declared immutable.\n+                // We need to determine which is the case here.\n+                let kind = match assignee_cmt.upvar().unwrap().cat {\n+                    mc::cat_upvar(mc::Upvar { kind, .. }) => kind,\n+                    _ => unreachable!()\n+                };\n+                if kind == ty::FnUnboxedClosureKind {\n+                    self.bccx.span_err(\n+                        assignment_span,\n+                        format!(\"cannot assign to {}\",\n+                                self.bccx.cmt_to_string(&*assignee_cmt)).as_slice());\n+                    self.bccx.span_note(\n+                        self.tcx().map.span(upvar_id.closure_expr_id),\n+                        \"consider changing this closure to take self by mutable reference\");\n+                } else {\n+                    self.bccx.span_err(\n+                        assignment_span,\n+                        format!(\"cannot assign to {} {}\",\n+                                assignee_cmt.mutbl.to_user_str(),\n+                                self.bccx.cmt_to_string(&*assignee_cmt)).as_slice());\n+                }\n             }\n             _ => match opt_loan_path(&assignee_cmt) {\n                 Some(lp) => {\n@@ -825,12 +840,20 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                     mc::cat_rvalue(..) |\n                     mc::cat_static_item |\n                     mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n-                    mc::cat_deref(_, _, mc::BorrowedPtr(..)) |\n                     mc::cat_deref(_, _, mc::Implicit(..)) => {\n                         assert_eq!(cmt.mutbl, mc::McDeclared);\n                         return;\n                     }\n \n+                    mc::cat_deref(_, _, mc::BorrowedPtr(..)) => {\n+                        assert_eq!(cmt.mutbl, mc::McDeclared);\n+                        // We need to drill down to upvar if applicable\n+                        match cmt.upvar() {\n+                            Some(b) => cmt = b,\n+                            None => return\n+                        }\n+                    }\n+\n                     mc::cat_deref(b, _, mc::OwnedPtr) => {\n                         assert_eq!(cmt.mutbl, mc::McInherited);\n                         cmt = b;"}, {"sha": "b09e9105f3f6be4102905f05b1fd38fc56bc8329", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1cc938a69adddc4b8b529c12aec62909c35dd704/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cc938a69adddc4b8b529c12aec62909c35dd704/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=1cc938a69adddc4b8b529c12aec62909c35dd704", "patch": "@@ -625,7 +625,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         match err.code {\n             err_mutbl => {\n                 let descr = match err.cmt.note {\n-                    mc::NoteClosureEnv(_) => {\n+                    mc::NoteClosureEnv(_) | mc::NoteUpvarRef(_) => {\n                         self.cmt_to_string(&*err.cmt)\n                     }\n                     _ => match opt_loan_path(&err.cmt) {\n@@ -761,11 +761,20 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         match code {\n             err_mutbl(..) => {\n                 match err.cmt.note {\n-                    mc::NoteClosureEnv(upvar_id) => {\n-                        self.tcx.sess.span_note(\n-                            self.tcx.map.span(upvar_id.closure_expr_id),\n-                            \"consider changing this closure to take \\\n-                             self by mutable reference\");\n+                    mc::NoteClosureEnv(upvar_id) | mc::NoteUpvarRef(upvar_id) => {\n+                        // If this is an `Fn` closure, it simply can't mutate upvars.\n+                        // If it's an `FnMut` closure, the original variable was declared immutable.\n+                        // We need to determine which is the case here.\n+                        let kind = match err.cmt.upvar().unwrap().cat {\n+                            mc::cat_upvar(mc::Upvar { kind, .. }) => kind,\n+                            _ => unreachable!()\n+                        };\n+                        if kind == ty::FnUnboxedClosureKind {\n+                            self.tcx.sess.span_note(\n+                                self.tcx.map.span(upvar_id.closure_expr_id),\n+                                \"consider changing this closure to take \\\n+                                 self by mutable reference\");\n+                        }\n                     }\n                     _ => {}\n                 }"}, {"sha": "08e14e8034e9eff6d57ee30005978d76ce31b263", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 69, "deletions": 62, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/1cc938a69adddc4b8b529c12aec62909c35dd704/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cc938a69adddc4b8b529c12aec62909c35dd704/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=1cc938a69adddc4b8b529c12aec62909c35dd704", "patch": "@@ -655,51 +655,54 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         // FnOnce         | copied               | upvar -> &'up bk\n         // old stack      | N/A                  | upvar -> &'env mut -> &'up bk\n         // old proc/once  | copied               | N/A\n+        let var_ty = if_ok!(self.node_ty(var_id));\n+\n         let upvar_id = ty::UpvarId { var_id: var_id,\n                                      closure_expr_id: fn_node_id };\n \n-        // Do we need to deref through an env reference?\n-        let has_env_deref = kind != ty::FnOnceUnboxedClosureKind;\n-\n         // Mutability of original variable itself\n         let var_mutbl = MutabilityCategory::from_local(self.tcx(), var_id);\n \n-        // Mutability of environment dereference\n-        let env_mutbl = match kind {\n-            ty::FnOnceUnboxedClosureKind => var_mutbl,\n-            ty::FnMutUnboxedClosureKind => McInherited,\n-            ty::FnUnboxedClosureKind => McImmutable\n+        // Construct information about env pointer dereference, if any\n+        let mutbl = match kind {\n+            ty::FnOnceUnboxedClosureKind => None, // None, env is by-value\n+            ty::FnMutUnboxedClosureKind => match mode { // Depends on capture type\n+                ast::CaptureByValue => Some(var_mutbl), // Mutable if the original var is\n+                ast::CaptureByRef => Some(McDeclared) // Mutable regardless\n+            },\n+            ty::FnUnboxedClosureKind => Some(McImmutable) // Never mutable\n         };\n+        let env_info = mutbl.map(|env_mutbl| {\n+            // Look up the node ID of the closure body so we can construct\n+            // a free region within it\n+            let fn_body_id = {\n+                let fn_expr = match self.tcx().map.find(fn_node_id) {\n+                    Some(ast_map::NodeExpr(e)) => e,\n+                    _ => unreachable!()\n+                };\n \n-        // Look up the node ID of the closure body so we can construct\n-        // a free region within it\n-        let fn_body_id = {\n-            let fn_expr = match self.tcx().map.find(fn_node_id) {\n-                Some(ast_map::NodeExpr(e)) => e,\n-                _ => unreachable!()\n+                match fn_expr.node {\n+                    ast::ExprFnBlock(_, _, ref body) |\n+                    ast::ExprProc(_, ref body) |\n+                    ast::ExprUnboxedFn(_, _, _, ref body) => body.id,\n+                    _ => unreachable!()\n+                }\n             };\n \n-            match fn_expr.node {\n-                ast::ExprFnBlock(_, _, ref body) |\n-                ast::ExprProc(_, ref body) |\n-                ast::ExprUnboxedFn(_, _, _, ref body) => body.id,\n-                _ => unreachable!()\n-            }\n-        };\n+            // Region of environment pointer\n+            let env_region = ty::ReFree(ty::FreeRegion {\n+                scope_id: fn_body_id,\n+                bound_region: ty::BrEnv\n+            });\n \n-        // Region of environment pointer\n-        let env_region = ty::ReFree(ty::FreeRegion {\n-            scope_id: fn_body_id,\n-            bound_region: ty::BrEnv\n-        });\n-\n-        let env_ptr = BorrowedPtr(if env_mutbl.is_mutable() {\n-            ty::MutBorrow\n-        } else {\n-            ty::ImmBorrow\n-        }, env_region);\n+            let env_ptr = BorrowedPtr(if env_mutbl.is_mutable() {\n+                ty::MutBorrow\n+            } else {\n+                ty::ImmBorrow\n+            }, env_region);\n \n-        let var_ty = if_ok!(self.node_ty(var_id));\n+            (env_mutbl, env_ptr)\n+        });\n \n         // First, switch by capture mode\n         Ok(match mode {\n@@ -717,25 +720,27 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                     note: NoteNone\n                 };\n \n-                if has_env_deref {\n-                    // We need to add the env deref.  This means that\n-                    // the above is actually immutable and has a ref\n-                    // type.  However, nothing should actually look at\n-                    // the type, so we can get away with stuffing a\n-                    // `ty_err` in there instead of bothering to\n-                    // construct a proper one.\n-                    base.mutbl = McImmutable;\n-                    base.ty = ty::mk_err();\n-                    Rc::new(cmt_ {\n-                        id: id,\n-                        span: span,\n-                        cat: cat_deref(Rc::new(base), 0, env_ptr),\n-                        mutbl: env_mutbl,\n-                        ty: var_ty,\n-                        note: NoteClosureEnv(upvar_id)\n-                    })\n-                } else {\n-                    Rc::new(base)\n+                match env_info {\n+                    Some((env_mutbl, env_ptr)) => {\n+                        // We need to add the env deref.  This means\n+                        // that the above is actually immutable and\n+                        // has a ref type.  However, nothing should\n+                        // actually look at the type, so we can get\n+                        // away with stuffing a `ty_err` in there\n+                        // instead of bothering to construct a proper\n+                        // one.\n+                        base.mutbl = McImmutable;\n+                        base.ty = ty::mk_err();\n+                        Rc::new(cmt_ {\n+                            id: id,\n+                            span: span,\n+                            cat: cat_deref(Rc::new(base), 0, env_ptr),\n+                            mutbl: env_mutbl,\n+                            ty: var_ty,\n+                            note: NoteClosureEnv(upvar_id)\n+                        })\n+                    }\n+                    None => Rc::new(base)\n                 }\n             },\n             ast::CaptureByRef => {\n@@ -755,16 +760,18 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                     note: NoteNone\n                 };\n \n-                // As in the by-value case, add env deref if needed\n-                if has_env_deref {\n-                    base = cmt_ {\n-                        id: id,\n-                        span: span,\n-                        cat: cat_deref(Rc::new(base), 0, env_ptr),\n-                        mutbl: env_mutbl,\n-                        ty: ty::mk_err(),\n-                        note: NoteClosureEnv(upvar_id)\n-                    };\n+                match env_info {\n+                    Some((env_mutbl, env_ptr)) => {\n+                        base = cmt_ {\n+                            id: id,\n+                            span: span,\n+                            cat: cat_deref(Rc::new(base), 0, env_ptr),\n+                            mutbl: env_mutbl,\n+                            ty: ty::mk_err(),\n+                            note: NoteClosureEnv(upvar_id)\n+                        };\n+                    }\n+                    None => {}\n                 }\n \n                 // Look up upvar borrow so we can get its region"}, {"sha": "e28abaf2b1fd6a85078769b20af8569b9d58d2b3", "filename": "src/test/compile-fail/unboxed-closure-immutable-capture.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1cc938a69adddc4b8b529c12aec62909c35dd704/src%2Ftest%2Fcompile-fail%2Funboxed-closure-immutable-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cc938a69adddc4b8b529c12aec62909c35dd704/src%2Ftest%2Fcompile-fail%2Funboxed-closure-immutable-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-immutable-capture.rs?ref=1cc938a69adddc4b8b529c12aec62909c35dd704", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unboxed_closures)]\n+\n+// Test that even unboxed closures that are capable of mutating their\n+// environment cannot mutate captured variables that have not been\n+// declared mutable (#18335)\n+\n+fn set(x: &mut uint) { *x = 0; }\n+\n+fn main() {\n+    let x = 0u;\n+    move |&mut:| x = 1; //~ ERROR cannot assign\n+    move |&mut:| set(&mut x); //~ ERROR cannot borrow\n+    move |:| x = 1; //~ ERROR cannot assign\n+    move |:| set(&mut x); //~ ERROR cannot borrow\n+    |&mut:| x = 1; //~ ERROR cannot assign\n+    // FIXME: this should be `cannot borrow` (issue #18330)\n+    |&mut:| set(&mut x); //~ ERROR cannot assign\n+    |:| x = 1; //~ ERROR cannot assign\n+    // FIXME: this should be `cannot borrow` (issue #18330)\n+    |:| set(&mut x); //~ ERROR cannot assign\n+}"}, {"sha": "f7e1e46e54d65dad51322605a1bbec8a8557e9c0", "filename": "src/test/run-pass/unboxed-closures-move-mutable.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1cc938a69adddc4b8b529c12aec62909c35dd704/src%2Ftest%2Frun-pass%2Funboxed-closures-move-mutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cc938a69adddc4b8b529c12aec62909c35dd704/src%2Ftest%2Frun-pass%2Funboxed-closures-move-mutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-move-mutable.rs?ref=1cc938a69adddc4b8b529c12aec62909c35dd704", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unboxed_closures)]\n+#![deny(unused_mut)]\n+\n+// Test that mutating a mutable upvar in a capture-by-value unboxed\n+// closure does not ice (issue #18238) and marks the upvar as used\n+// mutably so we do not get a spurious warning about it not needing to\n+// be declared mutable (issue #18336).\n+\n+fn main() {\n+    {\n+        let mut x = 0u;\n+        move |&mut:| x += 1;\n+    }\n+    {\n+        let mut x = 0u;\n+        move |:| x += 1;\n+    }\n+}"}]}