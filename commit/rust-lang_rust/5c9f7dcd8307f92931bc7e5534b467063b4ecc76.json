{"sha": "5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjOWY3ZGNkODMwN2Y5MjkzMWJjN2U1NTM0YjQ2NzA2M2I0ZWNjNzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-13T12:22:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-13T12:22:30Z"}, "message": "Auto merge of #55649 - scalexm:chalk-bound-ty, r=nikomatsakis\n\nUse bound types in `librustc_traits`\n\nr? @nikomatsakis\nsee the tests which now move the higher-ranked binders to the left in implied bound rules!", "tree": {"sha": "d633d2c23f6b5c294e318c5e603e6a526bd3f43e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d633d2c23f6b5c294e318c5e603e6a526bd3f43e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "html_url": "https://github.com/rust-lang/rust/commit/5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "485397e49a02a3b7ff77c17e4a3f16c653925cb3", "url": "https://api.github.com/repos/rust-lang/rust/commits/485397e49a02a3b7ff77c17e4a3f16c653925cb3", "html_url": "https://github.com/rust-lang/rust/commit/485397e49a02a3b7ff77c17e4a3f16c653925cb3"}, {"sha": "8d0b9697b5739c1e6bb6e9eea513218e5a60cb1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d0b9697b5739c1e6bb6e9eea513218e5a60cb1a", "html_url": "https://github.com/rust-lang/rust/commit/8d0b9697b5739c1e6bb6e9eea513218e5a60cb1a"}], "stats": {"total": 1836, "additions": 1179, "deletions": 657}, "files": [{"sha": "0c08e35c18df33d53a1ea3b6a82480ca1da76423", "filename": "src/Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "patch": "@@ -2419,6 +2419,7 @@ dependencies = [\n  \"log 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n+ \"rustc_target 0.0.0\",\n  \"smallvec 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\","}, {"sha": "70ce5d0d8dc0c13e6bd6a6a02c3690c9319ca383", "filename": "src/librustc/infer/canonical/substitute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fsubstitute.rs?ref=5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "patch": "@@ -80,6 +80,6 @@ where\n             }\n         };\n \n-        tcx.replace_escaping_bound_vars(value, fld_r, fld_t)\n+        tcx.replace_escaping_bound_vars(value, fld_r, fld_t).0\n     }\n }"}, {"sha": "642382bcf0fa31311e17bb035a75c552b17ed31d", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "patch": "@@ -59,11 +59,11 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n             // with a fresh region variable. These region variables --\n             // but no other pre-existing region variables -- can name\n             // the placeholders.\n-            let (a_prime, _) =\n-                self.infcx.replace_late_bound_regions_with_fresh_var(\n-                    span,\n-                    HigherRankedType,\n-                    a);\n+            let (a_prime, _) = self.infcx.replace_bound_vars_with_fresh_vars(\n+                span,\n+                HigherRankedType,\n+                a\n+            );\n \n             debug!(\"a_prime={:?}\", a_prime);\n             debug!(\"b_prime={:?}\", b_prime);"}, {"sha": "4ddf47c88ddbaa8e21cba5b59f59be173195da62", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "patch": "@@ -1328,18 +1328,18 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.report_and_explain_type_error(trace, &err)\n     }\n \n-    pub fn replace_late_bound_regions_with_fresh_var<T>(\n+    pub fn replace_bound_vars_with_fresh_vars<T>(\n         &self,\n         span: Span,\n         lbrct: LateBoundRegionConversionTime,\n-        value: &ty::Binder<T>,\n+        value: &ty::Binder<T>\n     ) -> (T, BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n     where\n-        T: TypeFoldable<'tcx>,\n+        T: TypeFoldable<'tcx>\n     {\n-        self.tcx.replace_late_bound_regions(value, |br| {\n-            self.next_region_var(LateBoundRegion(span, br, lbrct))\n-        })\n+        let fld_r = |br| self.next_region_var(LateBoundRegion(span, br, lbrct));\n+        let fld_t = |_| self.next_ty_var(TypeVariableOrigin::MiscVariable(span));\n+        self.tcx.replace_bound_vars(value, fld_r, fld_t)\n     }\n \n     /// Given a higher-ranked projection predicate like:"}, {"sha": "2761a954cea88deb69adb23334728fb9cb839698", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "patch": "@@ -212,10 +212,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             // cause I have no idea for a good error message.\n             if let ty::Predicate::Projection(ref data) = predicate {\n                 let mut selcx = SelectionContext::new(self);\n-                let (data, _) = self.replace_late_bound_regions_with_fresh_var(\n+                let (data, _) = self.replace_bound_vars_with_fresh_vars(\n                     obligation.cause.span,\n                     infer::LateBoundRegionConversionTime::HigherRankedType,\n-                    data);\n+                    data\n+                );\n                 let mut obligations = vec![];\n                 let normalized_ty = super::normalize_projection_type(\n                     &mut selcx,"}, {"sha": "3e417f10c4494833340e5c582c47fbf1798d2a3a", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 371, "deletions": 202, "changes": 573, "blob_url": "https://github.com/rust-lang/rust/blob/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "patch": "@@ -14,9 +14,11 @@ use traits;\n use traits::project::Normalized;\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use ty::{self, Lift, TyCtxt};\n+use syntax::symbol::InternedString;\n \n use std::fmt;\n use std::rc::Rc;\n+use std::collections::{BTreeSet, BTreeMap};\n \n // structural impls for the structs in traits\n \n@@ -169,6 +171,290 @@ impl<'tcx> fmt::Debug for traits::MismatchedProjectionTypes<'tcx> {\n     }\n }\n \n+impl<'tcx> fmt::Display for traits::WhereClause<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use traits::WhereClause::*;\n+\n+        // Bypass ppaux because it does not print out anonymous regions.\n+        fn write_region_name<'tcx>(\n+            r: ty::Region<'tcx>,\n+            fmt: &mut fmt::Formatter<'_>\n+        ) -> fmt::Result {\n+            match r {\n+                ty::ReLateBound(index, br) => match br {\n+                    ty::BoundRegion::BrNamed(_, name) => write!(fmt, \"{}\", name),\n+                    ty::BoundRegion::BrAnon(var) => {\n+                        if *index == ty::INNERMOST {\n+                            write!(fmt, \"'^{}\", var)\n+                        } else {\n+                            write!(fmt, \"'^{}_{}\", index.index(), var)\n+                        }\n+                    }\n+                    _ => write!(fmt, \"'_\"),\n+                }\n+\n+                _ => write!(fmt, \"{}\", r),\n+            }\n+        }\n+\n+        match self {\n+            Implemented(trait_ref) => write!(fmt, \"Implemented({})\", trait_ref),\n+            ProjectionEq(projection) => write!(fmt, \"ProjectionEq({})\", projection),\n+            RegionOutlives(predicate) => {\n+                write!(fmt, \"RegionOutlives({}: \", predicate.0)?;\n+                write_region_name(predicate.1, fmt)?;\n+                write!(fmt, \")\")\n+            }\n+            TypeOutlives(predicate) => {\n+                write!(fmt, \"TypeOutlives({}: \", predicate.0)?;\n+                write_region_name(predicate.1, fmt)?;\n+                write!(fmt, \")\")\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for traits::WellFormed<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use traits::WellFormed::*;\n+\n+        match self {\n+            Trait(trait_ref) => write!(fmt, \"WellFormed({})\", trait_ref),\n+            Ty(ty) => write!(fmt, \"WellFormed({})\", ty),\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for traits::FromEnv<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use traits::FromEnv::*;\n+\n+        match self {\n+            Trait(trait_ref) => write!(fmt, \"FromEnv({})\", trait_ref),\n+            Ty(ty) => write!(fmt, \"FromEnv({})\", ty),\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for traits::DomainGoal<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use traits::DomainGoal::*;\n+\n+        match self {\n+            Holds(wc) => write!(fmt, \"{}\", wc),\n+            WellFormed(wf) => write!(fmt, \"{}\", wf),\n+            FromEnv(from_env) => write!(fmt, \"{}\", from_env),\n+            Normalize(projection) => write!(\n+                fmt,\n+                \"Normalize({} -> {})\",\n+                projection.projection_ty,\n+                projection.ty\n+            ),\n+        }\n+    }\n+}\n+\n+impl fmt::Display for traits::QuantifierKind {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use traits::QuantifierKind::*;\n+\n+        match self {\n+            Universal => write!(fmt, \"forall\"),\n+            Existential => write!(fmt, \"exists\"),\n+        }\n+    }\n+}\n+\n+/// Collect names for regions / types bound by a quantified goal / clause.\n+/// This collector does not try to do anything clever like in ppaux, it's just used\n+/// for debug output in tests anyway.\n+struct BoundNamesCollector {\n+    // Just sort by name because `BoundRegion::BrNamed` does not have a `BoundVar` index anyway.\n+    regions: BTreeSet<InternedString>,\n+\n+    // Sort by `BoundVar` index, so usually this should be equivalent to the order given\n+    // by the list of type parameters.\n+    types: BTreeMap<u32, InternedString>,\n+\n+    binder_index: ty::DebruijnIndex,\n+}\n+\n+impl BoundNamesCollector {\n+    fn new() -> Self {\n+        BoundNamesCollector {\n+            regions: BTreeSet::new(),\n+            types: BTreeMap::new(),\n+            binder_index: ty::INNERMOST,\n+        }\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.regions.is_empty() && self.types.is_empty()\n+    }\n+\n+    fn write_names(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let mut start = true;\n+        for r in &self.regions {\n+            if !start {\n+                write!(fmt, \", \")?;\n+            }\n+            start = false;\n+            write!(fmt, \"{}\", r)?;\n+        }\n+        for (_, t) in &self.types {\n+            if !start {\n+                write!(fmt, \", \")?;\n+            }\n+            start = false;\n+            write!(fmt, \"{}\", t)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl<'tcx> TypeVisitor<'tcx> for BoundNamesCollector {\n+    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> bool {\n+        self.binder_index.shift_in(1);\n+        let result = t.super_visit_with(self);\n+        self.binder_index.shift_out(1);\n+        result\n+    }\n+\n+    fn visit_ty(&mut self, t: ty::Ty<'tcx>) -> bool {\n+        use syntax::symbol::Symbol;\n+\n+        match t.sty {\n+            ty::Bound(bound_ty) if bound_ty.index == self.binder_index => {\n+                self.types.insert(\n+                    bound_ty.var.as_u32(),\n+                    match bound_ty.kind {\n+                        ty::BoundTyKind::Param(name) => name,\n+                        ty::BoundTyKind::Anon => Symbol::intern(\n+                            &format!(\"^{}\", bound_ty.var.as_u32())\n+                        ).as_interned_str(),\n+                    }\n+                );\n+            }\n+\n+            _ => (),\n+        };\n+\n+        t.super_visit_with(self)\n+    }\n+\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n+        use syntax::symbol::Symbol;\n+\n+        match r {\n+            ty::ReLateBound(index, br) if *index == self.binder_index => {\n+                match br {\n+                    ty::BoundRegion::BrNamed(_, name) => {\n+                        self.regions.insert(*name);\n+                    }\n+\n+                    ty::BoundRegion::BrAnon(var) => {\n+                        self.regions.insert(Symbol::intern(\n+                            &format!(\"'^{}\", var)\n+                        ).as_interned_str());\n+                    }\n+\n+                    _ => (),\n+                }\n+            }\n+\n+            _ => (),\n+        };\n+\n+        r.super_visit_with(self)\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for traits::Goal<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use traits::GoalKind::*;\n+\n+        match self {\n+            Implies(hypotheses, goal) => {\n+                write!(fmt, \"if (\")?;\n+                for (index, hyp) in hypotheses.iter().enumerate() {\n+                    if index > 0 {\n+                        write!(fmt, \", \")?;\n+                    }\n+                    write!(fmt, \"{}\", hyp)?;\n+                }\n+                write!(fmt, \") {{ {} }}\", goal)\n+            }\n+            And(goal1, goal2) => write!(fmt, \"({} && {})\", goal1, goal2),\n+            Not(goal) => write!(fmt, \"not {{ {} }}\", goal),\n+            DomainGoal(goal) => write!(fmt, \"{}\", goal),\n+            Quantified(qkind, goal) => {\n+                let mut collector = BoundNamesCollector::new();\n+                goal.skip_binder().visit_with(&mut collector);\n+\n+                if !collector.is_empty() {\n+                    write!(fmt, \"{}<\", qkind)?;\n+                    collector.write_names(fmt)?;\n+                    write!(fmt, \"> {{ \")?;\n+                }\n+\n+                write!(fmt, \"{}\", goal.skip_binder())?;\n+\n+                if !collector.is_empty() {\n+                    write!(fmt, \" }}\")?;\n+                }\n+\n+                Ok(())\n+            }\n+            CannotProve => write!(fmt, \"CannotProve\"),\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for traits::ProgramClause<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let traits::ProgramClause { goal, hypotheses, .. } = self;\n+        write!(fmt, \"{}\", goal)?;\n+        if !hypotheses.is_empty() {\n+            write!(fmt, \" :- \")?;\n+            for (index, condition) in hypotheses.iter().enumerate() {\n+                if index > 0 {\n+                    write!(fmt, \", \")?;\n+                }\n+                write!(fmt, \"{}\", condition)?;\n+            }\n+        }\n+        write!(fmt, \".\")\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for traits::Clause<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use traits::Clause::*;\n+\n+        match self {\n+            Implies(clause) => write!(fmt, \"{}\", clause),\n+            ForAll(clause) => {\n+                let mut collector = BoundNamesCollector::new();\n+                clause.skip_binder().visit_with(&mut collector);\n+\n+                if !collector.is_empty() {\n+                    write!(fmt, \"forall<\")?;\n+                    collector.write_names(fmt)?;\n+                    write!(fmt, \"> {{ \")?;\n+                }\n+\n+                write!(fmt, \"{}\", clause.skip_binder())?;\n+\n+                if !collector.is_empty() {\n+                    write!(fmt, \" }}\")?;\n+                }\n+\n+                Ok(())\n+            }\n+        }\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Lift implementations\n \n@@ -348,6 +634,91 @@ impl<'a, 'tcx> Lift<'tcx> for traits::Vtable<'a, ()> {\n     }\n }\n \n+EnumLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for traits::WhereClause<'a> {\n+        type Lifted = traits::WhereClause<'tcx>;\n+        (traits::WhereClause::Implemented)(trait_ref),\n+        (traits::WhereClause::ProjectionEq)(projection),\n+        (traits::WhereClause::TypeOutlives)(ty_outlives),\n+        (traits::WhereClause::RegionOutlives)(region_outlives),\n+    }\n+}\n+\n+EnumLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for traits::WellFormed<'a> {\n+        type Lifted = traits::WellFormed<'tcx>;\n+        (traits::WellFormed::Trait)(trait_ref),\n+        (traits::WellFormed::Ty)(ty),\n+    }\n+}\n+\n+EnumLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for traits::FromEnv<'a> {\n+        type Lifted = traits::FromEnv<'tcx>;\n+        (traits::FromEnv::Trait)(trait_ref),\n+        (traits::FromEnv::Ty)(ty),\n+    }\n+}\n+\n+EnumLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for traits::DomainGoal<'a> {\n+        type Lifted = traits::DomainGoal<'tcx>;\n+        (traits::DomainGoal::Holds)(wc),\n+        (traits::DomainGoal::WellFormed)(wf),\n+        (traits::DomainGoal::FromEnv)(from_env),\n+        (traits::DomainGoal::Normalize)(projection),\n+    }\n+}\n+\n+EnumLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for traits::GoalKind<'a> {\n+        type Lifted = traits::GoalKind<'tcx>;\n+        (traits::GoalKind::Implies)(hypotheses, goal),\n+        (traits::GoalKind::And)(goal1, goal2),\n+        (traits::GoalKind::Not)(goal),\n+        (traits::GoalKind::DomainGoal)(domain_goal),\n+        (traits::GoalKind::Quantified)(kind, goal),\n+        (traits::GoalKind::CannotProve),\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for traits::Environment<'a> {\n+    type Lifted = traits::Environment<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.clauses).map(|clauses| {\n+            traits::Environment {\n+                clauses,\n+            }\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx, G: Lift<'tcx>> Lift<'tcx> for traits::InEnvironment<'a, G> {\n+    type Lifted = traits::InEnvironment<'tcx, G::Lifted>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.environment).and_then(|environment| {\n+            tcx.lift(&self.goal).map(|goal| {\n+                traits::InEnvironment {\n+                    environment,\n+                    goal,\n+                }\n+            })\n+        })\n+    }\n+}\n+\n+impl<'tcx, C> Lift<'tcx> for chalk_engine::ExClause<C>\n+where\n+    C: chalk_engine::context::Context + Clone,\n+    C: traits::ExClauseLift<'tcx>,\n+{\n+    type Lifted = C::LiftedExClause;\n+\n+    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        <C as traits::ExClauseLift>::lift_ex_clause_to_tcx(self, tcx)\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // TypeFoldable implementations.\n \n@@ -436,123 +807,6 @@ BraceStructTypeFoldableImpl! {\n     } where T: TypeFoldable<'tcx>\n }\n \n-impl<'tcx> fmt::Display for traits::WhereClause<'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use traits::WhereClause::*;\n-\n-        match self {\n-            Implemented(trait_ref) => write!(fmt, \"Implemented({})\", trait_ref),\n-            ProjectionEq(projection) => write!(fmt, \"ProjectionEq({})\", projection),\n-            RegionOutlives(predicate) => write!(fmt, \"RegionOutlives({})\", predicate),\n-            TypeOutlives(predicate) => write!(fmt, \"TypeOutlives({})\", predicate),\n-        }\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for traits::WellFormed<'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use traits::WellFormed::*;\n-\n-        match self {\n-            Trait(trait_ref) => write!(fmt, \"WellFormed({})\", trait_ref),\n-            Ty(ty) => write!(fmt, \"WellFormed({})\", ty),\n-        }\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for traits::FromEnv<'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use traits::FromEnv::*;\n-\n-        match self {\n-            Trait(trait_ref) => write!(fmt, \"FromEnv({})\", trait_ref),\n-            Ty(ty) => write!(fmt, \"FromEnv({})\", ty),\n-        }\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for traits::DomainGoal<'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use traits::DomainGoal::*;\n-\n-        match self {\n-            Holds(wc) => write!(fmt, \"{}\", wc),\n-            WellFormed(wf) => write!(fmt, \"{}\", wf),\n-            FromEnv(from_env) => write!(fmt, \"{}\", from_env),\n-            Normalize(projection) => write!(fmt, \"Normalize({})\", projection),\n-        }\n-    }\n-}\n-\n-impl fmt::Display for traits::QuantifierKind {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use traits::QuantifierKind::*;\n-\n-        match self {\n-            Universal => write!(fmt, \"forall\"),\n-            Existential => write!(fmt, \"exists\"),\n-        }\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for traits::Goal<'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use traits::GoalKind::*;\n-\n-        match self {\n-            Implies(hypotheses, goal) => {\n-                write!(fmt, \"if (\")?;\n-                for (index, hyp) in hypotheses.iter().enumerate() {\n-                    if index > 0 {\n-                        write!(fmt, \", \")?;\n-                    }\n-                    write!(fmt, \"{}\", hyp)?;\n-                }\n-                write!(fmt, \") {{ {} }}\", goal)\n-            }\n-            And(goal1, goal2) => write!(fmt, \"({} && {})\", goal1, goal2),\n-            Not(goal) => write!(fmt, \"not {{ {} }}\", goal),\n-            DomainGoal(goal) => write!(fmt, \"{}\", goal),\n-            Quantified(qkind, goal) => {\n-                // FIXME: appropriate binder names\n-                write!(fmt, \"{}<> {{ {} }}\", qkind, goal.skip_binder())\n-            }\n-            CannotProve => write!(fmt, \"CannotProve\"),\n-        }\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for traits::ProgramClause<'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let traits::ProgramClause { goal, hypotheses, .. } = self;\n-        write!(fmt, \"{}\", goal)?;\n-        if !hypotheses.is_empty() {\n-            write!(fmt, \" :- \")?;\n-            for (index, condition) in hypotheses.iter().enumerate() {\n-                if index > 0 {\n-                    write!(fmt, \", \")?;\n-                }\n-                write!(fmt, \"{}\", condition)?;\n-            }\n-        }\n-        write!(fmt, \".\")\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for traits::Clause<'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use traits::Clause::*;\n-\n-        match self {\n-            Implies(clause) => write!(fmt, \"{}\", clause),\n-            ForAll(clause) => {\n-                // FIXME: appropriate binder names\n-                write!(fmt, \"forall<> {{ {} }}\", clause.skip_binder())\n-            }\n-        }\n-    }\n-}\n-\n EnumTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for traits::WhereClause<'tcx> {\n         (traits::WhereClause::Implemented)(trait_ref),\n@@ -562,46 +816,20 @@ EnumTypeFoldableImpl! {\n     }\n }\n \n-EnumLiftImpl! {\n-    impl<'a, 'tcx> Lift<'tcx> for traits::WhereClause<'a> {\n-        type Lifted = traits::WhereClause<'tcx>;\n-        (traits::WhereClause::Implemented)(trait_ref),\n-        (traits::WhereClause::ProjectionEq)(projection),\n-        (traits::WhereClause::TypeOutlives)(ty_outlives),\n-        (traits::WhereClause::RegionOutlives)(region_outlives),\n-    }\n-}\n-\n EnumTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for traits::WellFormed<'tcx> {\n         (traits::WellFormed::Trait)(trait_ref),\n         (traits::WellFormed::Ty)(ty),\n     }\n }\n \n-EnumLiftImpl! {\n-    impl<'a, 'tcx> Lift<'tcx> for traits::WellFormed<'a> {\n-        type Lifted = traits::WellFormed<'tcx>;\n-        (traits::WellFormed::Trait)(trait_ref),\n-        (traits::WellFormed::Ty)(ty),\n-    }\n-}\n-\n EnumTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for traits::FromEnv<'tcx> {\n         (traits::FromEnv::Trait)(trait_ref),\n         (traits::FromEnv::Ty)(ty),\n     }\n }\n \n-EnumLiftImpl! {\n-    impl<'a, 'tcx> Lift<'tcx> for traits::FromEnv<'a> {\n-        type Lifted = traits::FromEnv<'tcx>;\n-        (traits::FromEnv::Trait)(trait_ref),\n-        (traits::FromEnv::Ty)(ty),\n-    }\n-}\n-\n EnumTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for traits::DomainGoal<'tcx> {\n         (traits::DomainGoal::Holds)(wc),\n@@ -611,16 +839,6 @@ EnumTypeFoldableImpl! {\n     }\n }\n \n-EnumLiftImpl! {\n-    impl<'a, 'tcx> Lift<'tcx> for traits::DomainGoal<'a> {\n-        type Lifted = traits::DomainGoal<'tcx>;\n-        (traits::DomainGoal::Holds)(wc),\n-        (traits::DomainGoal::WellFormed)(wf),\n-        (traits::DomainGoal::FromEnv)(from_env),\n-        (traits::DomainGoal::Normalize)(projection),\n-    }\n-}\n-\n CloneTypeFoldableAndLiftImpls! {\n     traits::QuantifierKind,\n }\n@@ -636,18 +854,6 @@ EnumTypeFoldableImpl! {\n     }\n }\n \n-EnumLiftImpl! {\n-    impl<'a, 'tcx> Lift<'tcx> for traits::GoalKind<'a> {\n-        type Lifted = traits::GoalKind<'tcx>;\n-        (traits::GoalKind::Implies)(hypotheses, goal),\n-        (traits::GoalKind::And)(goal1, goal2),\n-        (traits::GoalKind::Not)(goal),\n-        (traits::GoalKind::DomainGoal)(domain_goal),\n-        (traits::GoalKind::Quantified)(kind, goal),\n-        (traits::GoalKind::CannotProve),\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<traits::Goal<'tcx>> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         let v = self.iter()\n@@ -702,31 +908,6 @@ BraceStructTypeFoldableImpl! {\n     } where G: TypeFoldable<'tcx>\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for traits::Environment<'a> {\n-    type Lifted = traits::Environment<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.clauses).map(|clauses| {\n-            traits::Environment {\n-                clauses,\n-            }\n-        })\n-    }\n-}\n-\n-impl<'a, 'tcx, G: Lift<'tcx>> Lift<'tcx> for traits::InEnvironment<'a, G> {\n-    type Lifted = traits::InEnvironment<'tcx, G::Lifted>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.environment).and_then(|environment| {\n-            tcx.lift(&self.goal).map(|goal| {\n-                traits::InEnvironment {\n-                    environment,\n-                    goal,\n-                }\n-            })\n-        })\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for traits::Clauses<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         let v = self.iter()\n@@ -761,18 +942,6 @@ where\n     }\n }\n \n-impl<'tcx, C> Lift<'tcx> for chalk_engine::ExClause<C>\n-where\n-    C: chalk_engine::context::Context + Clone,\n-    C: traits::ExClauseLift<'tcx>,\n-{\n-    type Lifted = C::LiftedExClause;\n-\n-    fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-        <C as traits::ExClauseLift>::lift_ex_clause_to_tcx(self, tcx)\n-    }\n-}\n-\n EnumTypeFoldableImpl! {\n     impl<'tcx, C> TypeFoldable<'tcx> for chalk_engine::DelayedLiteral<C> {\n         (chalk_engine::DelayedLiteral::CannotProve)(a),"}, {"sha": "a897afa0ca663ea1b8979c42045a6a9b3e6f3b35", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "patch": "@@ -520,22 +520,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn replace_late_bound_regions<T, F>(\n         self,\n         value: &Binder<T>,\n-        mut fld_r: F\n+        fld_r: F\n     ) -> (T, BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n         where F: FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n               T: TypeFoldable<'tcx>\n     {\n-        let mut map = BTreeMap::new();\n-        let mut real_fldr = |br| {\n-            *map.entry(br).or_insert_with(|| fld_r(br))\n-        };\n-\n         // identity for bound types\n-        let mut fld_t = |bound_ty| self.mk_ty(ty::Bound(bound_ty));\n-\n-        let mut replacer = BoundVarReplacer::new(self, &mut real_fldr, &mut fld_t);\n-        let result = value.skip_binder().fold_with(&mut replacer);\n-        (result, map)\n+        let fld_t = |bound_ty| self.mk_ty(ty::Bound(bound_ty));\n+        self.replace_escaping_bound_vars(value.skip_binder(), fld_r, fld_t)\n     }\n \n     /// Replace all escaping bound vars. The `fld_r` closure replaces escaping\n@@ -545,17 +537,23 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         value: &T,\n         mut fld_r: F,\n         mut fld_t: G\n-    ) -> T\n+    ) -> (T, BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n         where F: FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n               G: FnMut(ty::BoundTy) -> ty::Ty<'tcx>,\n               T: TypeFoldable<'tcx>\n     {\n+        let mut map = BTreeMap::new();\n+\n         if !value.has_escaping_bound_vars() {\n-            value.clone()\n+            (value.clone(), map)\n         } else {\n-            let mut replacer = BoundVarReplacer::new(self, &mut fld_r, &mut fld_t);\n+            let mut real_fld_r = |br| {\n+                *map.entry(br).or_insert_with(|| fld_r(br))\n+            };\n+\n+            let mut replacer = BoundVarReplacer::new(self, &mut real_fld_r, &mut fld_t);\n             let result = value.fold_with(&mut replacer);\n-            result\n+            (result, map)\n         }\n     }\n \n@@ -567,7 +565,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         value: &Binder<T>,\n         fld_r: F,\n         fld_t: G\n-    ) -> T\n+    ) -> (T, BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n         where F: FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n               G: FnMut(ty::BoundTy) -> ty::Ty<'tcx>,\n               T: TypeFoldable<'tcx>"}, {"sha": "c834166e67d881bdcae92e73212d9a982d9b37f9", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "patch": "@@ -687,7 +687,7 @@ define_queries! { <'tcx>\n         ) -> Clauses<'tcx>,\n \n         // Get the chalk-style environment of the given item.\n-        [] fn environment: Environment(DefId) -> traits::Environment<'tcx>,\n+        [] fn environment: Environment(DefId) -> ty::Binder<traits::Environment<'tcx>>,\n     },\n \n     Linking {"}, {"sha": "b7f1731ba44e5355510d118cacf41667aab139a2", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "patch": "@@ -179,6 +179,34 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n         })\n     }\n \n+    /// Creates a `Substs` that maps each generic parameter to a higher-ranked\n+    /// var bound at index `0`. For types, we use a `BoundVar` index equal to\n+    /// the type parameter index. For regions, we use the `BoundRegion::BrNamed`\n+    /// variant (which has a def-id).\n+    pub fn bound_vars_for_item(\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        def_id: DefId\n+    ) -> &'tcx Substs<'tcx> {\n+        Substs::for_item(tcx, def_id, |param, _| {\n+            match param.kind {\n+                ty::GenericParamDefKind::Type { .. } => {\n+                    tcx.mk_ty(ty::Bound(ty::BoundTy {\n+                        index: ty::INNERMOST,\n+                        var: ty::BoundVar::from(param.index),\n+                        kind: ty::BoundTyKind::Param(param.name),\n+                    })).into()\n+                }\n+\n+                ty::GenericParamDefKind::Lifetime => {\n+                    tcx.mk_region(ty::RegionKind::ReLateBound(\n+                        ty::INNERMOST,\n+                        ty::BoundRegion::BrNamed(param.def_id, param.name)\n+                    )).into()\n+                }\n+            }\n+        })\n+    }\n+\n     /// Creates a `Substs` for generic parameter definitions,\n     /// by calling closures to obtain each kind.\n     /// The closures get to observe the `Substs` as they're"}, {"sha": "e44c0c05bb1a6c78fdc829f2f509cd002a5f3677", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "patch": "@@ -1114,9 +1114,9 @@ define_print! {\n                     match bound_ty.kind {\n                         ty::BoundTyKind::Anon => {\n                             if bound_ty.index == ty::INNERMOST {\n-                                write!(f, \"?{}\", bound_ty.var.index())\n+                                write!(f, \"^{}\", bound_ty.var.index())\n                             } else {\n-                                write!(f, \"?{}_{}\", bound_ty.index.index(), bound_ty.var.index())\n+                                write!(f, \"^{}_{}\", bound_ty.index.index(), bound_ty.var.index())\n                             }\n                         }\n "}, {"sha": "85ea39e538f785a6aee3b9969b4da7872d7bef1b", "filename": "src/librustc_mir/borrow_check/nll/type_check/input_output.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs?ref=5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "patch": "@@ -62,7 +62,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     // \"inside\" the closure.\n                     Some(\n                         self.infcx\n-                            .replace_late_bound_regions_with_fresh_var(\n+                            .replace_bound_vars_with_fresh_vars(\n                                 mir.span,\n                                 LateBoundRegionConversionTime::FnCall,\n                                 &poly_sig,"}, {"sha": "2193dba9fcac8b9053d5b1ee004070308e5f9dcb", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "patch": "@@ -1406,7 +1406,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                         return;\n                     }\n                 };\n-                let (sig, map) = self.infcx.replace_late_bound_regions_with_fresh_var(\n+                let (sig, map) = self.infcx.replace_bound_vars_with_fresh_vars(\n                     term.source_info.span,\n                     LateBoundRegionConversionTime::FnCall,\n                     &sig,"}, {"sha": "f057cbb50334eb07fbc804f4b05cbea288b0fc00", "filename": "src/librustc_traits/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc_traits%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc_traits%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2FCargo.toml?ref=5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "patch": "@@ -14,6 +14,7 @@ graphviz = { path = \"../libgraphviz\" }\n log = { version = \"0.4\" }\n rustc = { path = \"../librustc\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_target = { path = \"../librustc_target\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n chalk-engine = { version = \"0.8.0\", default-features=false }"}, {"sha": "0fd9f607a54628df1e04f18c544644b272ebc9e0", "filename": "src/librustc_traits/chalk_context/mod.rs", "status": "renamed", "additions": 6, "deletions": 230, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs?ref=5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "patch": "@@ -8,30 +8,28 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+mod program_clauses;\n+\n use chalk_engine::fallible::Fallible as ChalkEngineFallible;\n use chalk_engine::{context, hh::HhGoal, DelayedLiteral, ExClause};\n use rustc::infer::canonical::{\n     Canonical, CanonicalVarValues, OriginalQueryValues, QueryRegionConstraint, QueryResponse,\n };\n use rustc::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n use rustc::traits::{\n-    WellFormed,\n-    FromEnv,\n     DomainGoal,\n     ExClauseFold,\n     ExClauseLift,\n     Goal,\n     GoalKind,\n     Clause,\n-    ProgramClauseCategory,\n     QuantifierKind,\n     Environment,\n     InEnvironment,\n };\n use rustc::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use rustc::ty::subst::Kind;\n use rustc::ty::{self, TyCtxt};\n-use rustc::hir::def_id::DefId;\n \n use std::fmt::{self, Debug};\n use std::marker::PhantomData;\n@@ -335,228 +333,7 @@ impl context::UnificationOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n         environment: &Environment<'tcx>,\n         goal: &DomainGoal<'tcx>,\n     ) -> Vec<Clause<'tcx>> {\n-        use rustc::traits::WhereClause::*;\n-\n-        fn assemble_clauses_from_impls<'tcx>(\n-            tcx: ty::TyCtxt<'_, '_, 'tcx>,\n-            trait_def_id: DefId,\n-            clauses: &mut Vec<Clause<'tcx>>\n-        ) {\n-            tcx.for_each_impl(trait_def_id, |impl_def_id| {\n-                clauses.extend(\n-                    tcx.program_clauses_for(impl_def_id)\n-                        .into_iter()\n-                        .cloned()\n-                );\n-            });\n-        }\n-\n-        fn assemble_clauses_from_assoc_ty_values<'tcx>(\n-            tcx: ty::TyCtxt<'_, '_, 'tcx>,\n-            trait_def_id: DefId,\n-            clauses: &mut Vec<Clause<'tcx>>\n-        ) {\n-            tcx.for_each_impl(trait_def_id, |impl_def_id| {\n-                for def_id in tcx.associated_item_def_ids(impl_def_id).iter() {\n-                    clauses.extend(\n-                        tcx.program_clauses_for(*def_id)\n-                            .into_iter()\n-                            .cloned()\n-                    );\n-                }\n-            });\n-        }\n-\n-        let mut clauses = match goal {\n-            DomainGoal::Holds(Implemented(trait_predicate)) => {\n-                // These come from:\n-                // * implementations of the trait itself (rule `Implemented-From-Impl`)\n-                // * the trait decl (rule `Implemented-From-Env`)\n-\n-                let mut clauses = vec![];\n-                assemble_clauses_from_impls(\n-                    self.infcx.tcx,\n-                    trait_predicate.def_id(),\n-                    &mut clauses\n-                );\n-\n-                // FIXME: we need to add special rules for builtin impls:\n-                // * `Copy` / `Clone`\n-                // * `Sized`\n-                // * `Unsize`\n-                // * `Generator`\n-                // * `FnOnce` / `FnMut` / `Fn`\n-                // * trait objects\n-                // * auto traits\n-\n-                // Rule `Implemented-From-Env` will be computed from the environment.\n-                clauses\n-            }\n-\n-            DomainGoal::Holds(ProjectionEq(projection_predicate)) => {\n-                // These come from:\n-                // * the assoc type definition (rule `ProjectionEq-Placeholder`)\n-                // * normalization of the assoc ty values (rule `ProjectionEq-Normalize`)\n-                // * implied bounds from trait definitions (rule `Implied-Bound-From-Trait`)\n-                // * implied bounds from type definitions (rule `Implied-Bound-From-Type`)\n-\n-                let clauses = self.infcx.tcx.program_clauses_for(\n-                    projection_predicate.projection_ty.item_def_id\n-                ).into_iter()\n-\n-                    // only select `ProjectionEq-Placeholder` and `ProjectionEq-Normalize`\n-                    .filter(|clause| clause.category() == ProgramClauseCategory::Other)\n-\n-                    .cloned()\n-                    .collect::<Vec<_>>();\n-\n-                // Rules `Implied-Bound-From-Trait` and `Implied-Bound-From-Type` will be computed\n-                // from the environment.\n-                clauses\n-            }\n-\n-            DomainGoal::Holds(RegionOutlives(..)) => {\n-                // These come from:\n-                // * implied bounds from trait definitions (rule `Implied-Bound-From-Trait`)\n-                // * implied bounds from type definitions (rule `Implied-Bound-From-Type`)\n-\n-                // All of these rules are computed in the environment.\n-                vec![]\n-            }\n-\n-            DomainGoal::Holds(TypeOutlives(..)) => {\n-                // These come from:\n-                // * implied bounds from trait definitions (rule `Implied-Bound-From-Trait`)\n-                // * implied bounds from type definitions (rule `Implied-Bound-From-Type`)\n-\n-                // All of these rules are computed in the environment.\n-                vec![]\n-            }\n-\n-            DomainGoal::WellFormed(WellFormed::Trait(trait_predicate)) => {\n-                // These come from -- the trait decl (rule `WellFormed-TraitRef`).\n-                self.infcx.tcx.program_clauses_for(trait_predicate.def_id())\n-                    .into_iter()\n-\n-                    // only select `WellFormed-TraitRef`\n-                    .filter(|clause| clause.category() == ProgramClauseCategory::WellFormed)\n-\n-                    .cloned()\n-                    .collect()\n-            }\n-\n-            DomainGoal::WellFormed(WellFormed::Ty(ty)) => {\n-                // These come from:\n-                // * the associated type definition if `ty` refers to an unnormalized\n-                //   associated type (rule `WellFormed-AssocTy`)\n-                // * custom rules for built-in types\n-                // * the type definition otherwise (rule `WellFormed-Type`)\n-                let clauses = match ty.sty {\n-                    ty::Projection(data) => {\n-                        self.infcx.tcx.program_clauses_for(data.item_def_id)\n-                    }\n-\n-                    // These types are always WF (recall that we do not check\n-                    // for parameters to be WF)\n-                    ty::Bool |\n-                    ty::Char |\n-                    ty::Int(..) |\n-                    ty::Uint(..) |\n-                    ty::Float(..) |\n-                    ty::Str |\n-                    ty::RawPtr(..) |\n-                    ty::FnPtr(..) |\n-                    ty::Param(..) |\n-                    ty::Never => {\n-                        ty::List::empty()\n-                    }\n-\n-                    // WF if inner type is `Sized`\n-                    ty::Slice(..) |\n-                    ty::Array(..) => {\n-                        ty::List::empty()\n-                    }\n-\n-                    ty::Tuple(..) => {\n-                        ty::List::empty()\n-                    }\n-\n-                    // WF if `sub_ty` outlives `region`\n-                    ty::Ref(..) => {\n-                        ty::List::empty()\n-                    }\n-\n-                    ty::Dynamic(..) => {\n-                        // FIXME: no rules yet for trait objects\n-                        ty::List::empty()\n-                    }\n-\n-                    ty::Adt(def, ..) => {\n-                        self.infcx.tcx.program_clauses_for(def.did)\n-                    }\n-\n-                    ty::Foreign(def_id) |\n-                    ty::FnDef(def_id, ..) |\n-                    ty::Closure(def_id, ..) |\n-                    ty::Generator(def_id, ..) |\n-                    ty::Opaque(def_id, ..) => {\n-                        self.infcx.tcx.program_clauses_for(def_id)\n-                    }\n-\n-                    ty::GeneratorWitness(..) |\n-                    ty::UnnormalizedProjection(..) |\n-                    ty::Infer(..) |\n-                    ty::Bound(..) |\n-                    ty::Error => {\n-                        bug!(\"unexpected type {:?}\", ty)\n-                    }\n-                };\n-\n-                clauses.into_iter()\n-                    .filter(|clause| clause.category() == ProgramClauseCategory::WellFormed)\n-                    .cloned()\n-                    .collect()\n-            }\n-\n-            DomainGoal::FromEnv(FromEnv::Trait(..)) => {\n-                // These come from:\n-                // * implied bounds from trait definitions (rule `Implied-Bound-From-Trait`)\n-                // * implied bounds from type definitions (rule `Implied-Bound-From-Type`)\n-                // * implied bounds from assoc type defs (rules `Implied-Trait-From-AssocTy`,\n-                //   `Implied-Bound-From-AssocTy` and `Implied-WC-From-AssocTy`)\n-\n-                // All of these rules are computed in the environment.\n-                vec![]\n-            }\n-\n-            DomainGoal::FromEnv(FromEnv::Ty(..)) => {\n-                // There are no `FromEnv::Ty(..) :- ...` rules (this predicate only\n-                // comes from the environment).\n-                vec![]\n-            }\n-\n-            DomainGoal::Normalize(projection_predicate) => {\n-                // These come from -- assoc ty values (rule `Normalize-From-Impl`).\n-                let mut clauses = vec![];\n-\n-                assemble_clauses_from_assoc_ty_values(\n-                    self.infcx.tcx,\n-                    projection_predicate.projection_ty.trait_ref(self.infcx.tcx).def_id,\n-                    &mut clauses\n-                );\n-\n-                clauses\n-            }\n-        };\n-\n-        let environment = self.infcx.tcx.lift_to_global(environment)\n-            .expect(\"environment is not global\");\n-        clauses.extend(\n-            self.infcx.tcx.program_clauses_for_env(environment)\n-                .into_iter()\n-                .cloned()\n-        );\n-        clauses\n+        self.program_clauses_impl(environment, goal)\n     }\n \n     fn instantiate_binders_universally(\n@@ -570,12 +347,11 @@ impl context::UnificationOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n         &mut self,\n         arg: &ty::Binder<Goal<'tcx>>,\n     ) -> Goal<'tcx> {\n-        let (value, _map) = self.infcx.replace_late_bound_regions_with_fresh_var(\n+        self.infcx.replace_bound_vars_with_fresh_vars(\n             DUMMY_SP,\n             LateBoundRegionConversionTime::HigherRankedType,\n-            arg,\n-        );\n-        value\n+            arg\n+        ).0\n     }\n \n     fn debug_ex_clause(&mut self, value: &'v ChalkExClause<'tcx>) -> Box<dyn Debug + 'v> {", "previous_filename": "src/librustc_traits/chalk_context.rs"}, {"sha": "31f97b72e1927d1686489ac2555935a71854f498", "filename": "src/librustc_traits/chalk_context/program_clauses.rs", "status": "added", "additions": 476, "deletions": 0, "changes": 476, "blob_url": "https://github.com/rust-lang/rust/blob/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses.rs?ref=5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "patch": "@@ -0,0 +1,476 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::traits::{\n+    WellFormed,\n+    FromEnv,\n+    DomainGoal,\n+    GoalKind,\n+    Clause,\n+    Clauses,\n+    ProgramClause,\n+    ProgramClauseCategory,\n+    Environment,\n+};\n+use rustc::ty;\n+use rustc::hir;\n+use rustc::hir::def_id::DefId;\n+use rustc_target::spec::abi;\n+use super::ChalkInferenceContext;\n+use crate::lowering::Lower;\n+use std::iter;\n+\n+fn assemble_clauses_from_impls<'tcx>(\n+    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n+    trait_def_id: DefId,\n+    clauses: &mut Vec<Clause<'tcx>>\n+) {\n+    tcx.for_each_impl(trait_def_id, |impl_def_id| {\n+        clauses.extend(\n+            tcx.program_clauses_for(impl_def_id)\n+                .into_iter()\n+                .cloned()\n+        );\n+    });\n+}\n+\n+fn assemble_clauses_from_assoc_ty_values<'tcx>(\n+    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n+    trait_def_id: DefId,\n+    clauses: &mut Vec<Clause<'tcx>>\n+) {\n+    tcx.for_each_impl(trait_def_id, |impl_def_id| {\n+        for def_id in tcx.associated_item_def_ids(impl_def_id).iter() {\n+            clauses.extend(\n+                tcx.program_clauses_for(*def_id)\n+                    .into_iter()\n+                    .cloned()\n+            );\n+        }\n+    });\n+}\n+\n+fn program_clauses_for_raw_ptr<'tcx>(tcx: ty::TyCtxt<'_, '_, 'tcx>) -> Clauses<'tcx> {\n+    let ty = ty::Bound(\n+        ty::BoundTy::new(ty::INNERMOST, ty::BoundVar::from_u32(0))\n+    );\n+    let ty = tcx.mk_ty(ty);\n+\n+    let ptr_ty = tcx.mk_ptr(ty::TypeAndMut {\n+        ty,\n+        mutbl: hir::Mutability::MutImmutable,\n+    });\n+\n+    let wf_clause = ProgramClause {\n+        goal: DomainGoal::WellFormed(WellFormed::Ty(ptr_ty)),\n+        hypotheses: ty::List::empty(),\n+        category: ProgramClauseCategory::WellFormed,\n+    };\n+    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n+\n+    // `forall<T> { WellFormed(*const T). }`\n+    tcx.mk_clauses(iter::once(wf_clause))\n+}\n+\n+fn program_clauses_for_fn_ptr<'tcx>(\n+    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n+    arity_and_output: usize,\n+    variadic: bool,\n+    unsafety: hir::Unsafety,\n+    abi: abi::Abi\n+) -> Clauses<'tcx> {\n+    let inputs_and_output = tcx.mk_type_list(\n+        (0..arity_and_output).into_iter()\n+            // DebruijnIndex(1) because we are going to inject these in a `PolyFnSig`\n+            .map(|i| ty::BoundTy::new(ty::DebruijnIndex::from(1usize), ty::BoundVar::from(i)))\n+            .map(|t| tcx.mk_ty(ty::Bound(t)))\n+    );\n+\n+    let fn_sig = ty::Binder::bind(ty::FnSig {\n+        inputs_and_output,\n+        variadic,\n+        unsafety,\n+        abi,\n+    });\n+    let fn_ptr = tcx.mk_fn_ptr(fn_sig);\n+\n+    let wf_clause = ProgramClause {\n+        goal: DomainGoal::WellFormed(WellFormed::Ty(fn_ptr)),\n+        hypotheses: ty::List::empty(),\n+        category: ProgramClauseCategory::WellFormed,\n+    };\n+    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n+\n+    // `forall <T1, ..., Tn+1> { WellFormed(for<> fn(T1, ..., Tn) -> Tn+1). }`\n+    // where `n + 1` == `arity_and_output`\n+    tcx.mk_clauses(iter::once(wf_clause))\n+}\n+\n+fn program_clauses_for_slice<'tcx>(tcx: ty::TyCtxt<'_, '_, 'tcx>) -> Clauses<'tcx> {\n+    let ty = ty::Bound(\n+        ty::BoundTy::new(ty::INNERMOST, ty::BoundVar::from_u32(0))\n+    );\n+    let ty = tcx.mk_ty(ty);\n+\n+    let slice_ty = tcx.mk_slice(ty);\n+\n+    let sized_trait = match tcx.lang_items().sized_trait() {\n+        Some(def_id) => def_id,\n+        None => return ty::List::empty(),\n+    };\n+    let sized_implemented = ty::TraitRef {\n+        def_id: sized_trait,\n+        substs: tcx.mk_substs_trait(ty, ty::List::empty()),\n+    };\n+    let sized_implemented: DomainGoal = ty::TraitPredicate {\n+        trait_ref: sized_implemented\n+    }.lower();\n+\n+    let wf_clause = ProgramClause {\n+        goal: DomainGoal::WellFormed(WellFormed::Ty(slice_ty)),\n+        hypotheses: tcx.mk_goals(\n+            iter::once(tcx.mk_goal(GoalKind::DomainGoal(sized_implemented)))\n+        ),\n+        category: ProgramClauseCategory::WellFormed,\n+    };\n+    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n+\n+    // `forall<T> { WellFormed([T]) :- Implemented(T: Sized). }`\n+    tcx.mk_clauses(iter::once(wf_clause))\n+}\n+\n+fn program_clauses_for_array<'tcx>(\n+    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n+    length: &'tcx ty::Const<'tcx>\n+) -> Clauses<'tcx> {\n+    let ty = ty::Bound(\n+        ty::BoundTy::new(ty::INNERMOST, ty::BoundVar::from_u32(0))\n+    );\n+    let ty = tcx.mk_ty(ty);\n+\n+    let array_ty = tcx.mk_ty(ty::Array(ty, length));\n+\n+    let sized_trait = match tcx.lang_items().sized_trait() {\n+        Some(def_id) => def_id,\n+        None => return ty::List::empty(),\n+    };\n+    let sized_implemented = ty::TraitRef {\n+        def_id: sized_trait,\n+        substs: tcx.mk_substs_trait(ty, ty::List::empty()),\n+    };\n+    let sized_implemented: DomainGoal = ty::TraitPredicate {\n+        trait_ref: sized_implemented\n+    }.lower();\n+\n+    let wf_clause = ProgramClause {\n+        goal: DomainGoal::WellFormed(WellFormed::Ty(array_ty)),\n+        hypotheses: tcx.mk_goals(\n+            iter::once(tcx.mk_goal(GoalKind::DomainGoal(sized_implemented)))\n+        ),\n+        category: ProgramClauseCategory::WellFormed,\n+    };\n+    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n+\n+    // `forall<T> { WellFormed([T; length]) :- Implemented(T: Sized). }`\n+    tcx.mk_clauses(iter::once(wf_clause))\n+}\n+\n+fn program_clauses_for_tuple<'tcx>(\n+    tcx: ty::TyCtxt<'_, '_, 'tcx>,\n+    arity: usize\n+) -> Clauses<'tcx> {\n+    let type_list = tcx.mk_type_list(\n+        (0..arity).into_iter()\n+            .map(|i| ty::BoundTy::new(ty::INNERMOST, ty::BoundVar::from(i)))\n+            .map(|t| tcx.mk_ty(ty::Bound(t)))\n+    );\n+\n+    let tuple_ty = tcx.mk_ty(ty::Tuple(type_list));\n+\n+    let sized_trait = match tcx.lang_items().sized_trait() {\n+        Some(def_id) => def_id,\n+        None => return ty::List::empty(),\n+    };\n+    let sized_implemented = type_list[0..arity - 1].iter()\n+        .map(|ty| ty::TraitRef {\n+            def_id: sized_trait,\n+            substs: tcx.mk_substs_trait(*ty, ty::List::empty()),\n+        })\n+        .map(|trait_ref| ty::TraitPredicate { trait_ref })\n+        .map(|predicate| predicate.lower());\n+\n+    let wf_clause = ProgramClause {\n+        goal: DomainGoal::WellFormed(WellFormed::Ty(tuple_ty)),\n+        hypotheses: tcx.mk_goals(\n+            sized_implemented.map(|domain_goal| {\n+                tcx.mk_goal(GoalKind::DomainGoal(domain_goal))\n+            })\n+        ),\n+        category: ProgramClauseCategory::WellFormed,\n+    };\n+    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n+\n+    // ```\n+    // forall<T1, ..., Tn-1, Tn> {\n+    //     WellFormed((T1, ..., Tn)) :-\n+    //         Implemented(T1: Sized),\n+    //         ...\n+    //         Implemented(Tn-1: Sized).\n+    // }\n+    // ```\n+    tcx.mk_clauses(iter::once(wf_clause))\n+}\n+\n+fn program_clauses_for_ref<'tcx>(tcx: ty::TyCtxt<'_, '_, 'tcx>) -> Clauses<'tcx> {\n+    let region = tcx.mk_region(\n+        ty::ReLateBound(ty::INNERMOST, ty::BoundRegion::BrAnon(0))\n+    );\n+    let ty = tcx.mk_ty(\n+        ty::Bound(ty::BoundTy::new(ty::INNERMOST, ty::BoundVar::from_u32(1)))\n+    );\n+\n+    let ref_ty = tcx.mk_ref(region, ty::TypeAndMut {\n+        ty,\n+        mutbl: hir::Mutability::MutImmutable,\n+    });\n+\n+    let outlives: DomainGoal = ty::OutlivesPredicate(ty, region).lower();\n+    let wf_clause = ProgramClause {\n+        goal: DomainGoal::WellFormed(WellFormed::Ty(ref_ty)),\n+        hypotheses: tcx.mk_goals(\n+            iter::once(tcx.mk_goal(outlives.into_goal()))\n+        ),\n+        category: ProgramClauseCategory::ImpliedBound,\n+    };\n+    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n+\n+    // `forall<'a, T> { WellFormed(&'a T) :- Outlives(T: 'a). }`\n+    tcx.mk_clauses(iter::once(wf_clause))\n+}\n+\n+impl ChalkInferenceContext<'cx, 'gcx, 'tcx> {\n+    pub(super) fn program_clauses_impl(\n+        &self,\n+        environment: &Environment<'tcx>,\n+        goal: &DomainGoal<'tcx>,\n+    ) -> Vec<Clause<'tcx>> {\n+        use rustc::traits::WhereClause::*;\n+\n+        let mut clauses = match goal {\n+            DomainGoal::Holds(Implemented(trait_predicate)) => {\n+                // These come from:\n+                // * implementations of the trait itself (rule `Implemented-From-Impl`)\n+                // * the trait decl (rule `Implemented-From-Env`)\n+\n+                let mut clauses = vec![];\n+                assemble_clauses_from_impls(\n+                    self.infcx.tcx,\n+                    trait_predicate.def_id(),\n+                    &mut clauses\n+                );\n+\n+                // FIXME: we need to add special rules for builtin impls:\n+                // * `Copy` / `Clone`\n+                // * `Sized`\n+                // * `Unsize`\n+                // * `Generator`\n+                // * `FnOnce` / `FnMut` / `Fn`\n+                // * trait objects\n+                // * auto traits\n+\n+                // Rule `Implemented-From-Env` will be computed from the environment.\n+                clauses\n+            }\n+\n+            DomainGoal::Holds(ProjectionEq(projection_predicate)) => {\n+                // These come from:\n+                // * the assoc type definition (rule `ProjectionEq-Placeholder`)\n+                // * normalization of the assoc ty values (rule `ProjectionEq-Normalize`)\n+                // * implied bounds from trait definitions (rule `Implied-Bound-From-Trait`)\n+                // * implied bounds from type definitions (rule `Implied-Bound-From-Type`)\n+\n+                let clauses = self.infcx.tcx.program_clauses_for(\n+                    projection_predicate.projection_ty.item_def_id\n+                ).into_iter()\n+\n+                    // only select `ProjectionEq-Placeholder` and `ProjectionEq-Normalize`\n+                    .filter(|clause| clause.category() == ProgramClauseCategory::Other)\n+\n+                    .cloned()\n+                    .collect::<Vec<_>>();\n+\n+                // Rules `Implied-Bound-From-Trait` and `Implied-Bound-From-Type` will be computed\n+                // from the environment.\n+                clauses\n+            }\n+\n+            DomainGoal::Holds(RegionOutlives(..)) => {\n+                // These come from:\n+                // * implied bounds from trait definitions (rule `Implied-Bound-From-Trait`)\n+                // * implied bounds from type definitions (rule `Implied-Bound-From-Type`)\n+\n+                // All of these rules are computed in the environment.\n+                vec![]\n+            }\n+\n+            DomainGoal::Holds(TypeOutlives(..)) => {\n+                // These come from:\n+                // * implied bounds from trait definitions (rule `Implied-Bound-From-Trait`)\n+                // * implied bounds from type definitions (rule `Implied-Bound-From-Type`)\n+\n+                // All of these rules are computed in the environment.\n+                vec![]\n+            }\n+\n+            DomainGoal::WellFormed(WellFormed::Trait(trait_predicate)) => {\n+                // These come from -- the trait decl (rule `WellFormed-TraitRef`).\n+                self.infcx.tcx.program_clauses_for(trait_predicate.def_id())\n+                    .into_iter()\n+\n+                    // only select `WellFormed-TraitRef`\n+                    .filter(|clause| clause.category() == ProgramClauseCategory::WellFormed)\n+\n+                    .cloned()\n+                    .collect()\n+            }\n+\n+            DomainGoal::WellFormed(WellFormed::Ty(ty)) => {\n+                // These come from:\n+                // * the associated type definition if `ty` refers to an unnormalized\n+                //   associated type (rule `WellFormed-AssocTy`)\n+                // * custom rules for built-in types\n+                // * the type definition otherwise (rule `WellFormed-Type`)\n+                let clauses = match ty.sty {\n+                    ty::Projection(data) => {\n+                        self.infcx.tcx.program_clauses_for(data.item_def_id)\n+                    }\n+\n+                    // These types are always WF and non-parametric.\n+                    ty::Bool |\n+                    ty::Char |\n+                    ty::Int(..) |\n+                    ty::Uint(..) |\n+                    ty::Float(..) |\n+                    ty::Str |\n+                    ty::Never => {\n+                        let wf_clause = ProgramClause {\n+                            goal: DomainGoal::WellFormed(WellFormed::Ty(ty)),\n+                            hypotheses: ty::List::empty(),\n+                            category: ProgramClauseCategory::WellFormed,\n+                        };\n+                        let wf_clause = Clause::ForAll(ty::Binder::dummy(wf_clause));\n+\n+                        self.infcx.tcx.mk_clauses(iter::once(wf_clause))\n+                    }\n+\n+                    // Always WF (recall that we do not check for parameters to be WF).\n+                    ty::RawPtr(..) => program_clauses_for_raw_ptr(self.infcx.tcx),\n+\n+                    // Always WF (recall that we do not check for parameters to be WF).\n+                    ty::FnPtr(fn_ptr) => {\n+                        let fn_ptr = fn_ptr.skip_binder();\n+                        program_clauses_for_fn_ptr(\n+                            self.infcx.tcx,\n+                            fn_ptr.inputs_and_output.len(),\n+                            fn_ptr.variadic,\n+                            fn_ptr.unsafety,\n+                            fn_ptr.abi\n+                        )\n+                    }\n+\n+                    // WF if inner type is `Sized`.\n+                    ty::Slice(..) => program_clauses_for_slice(self.infcx.tcx),\n+\n+                    // WF if inner type is `Sized`.\n+                    ty::Array(_, length) => program_clauses_for_array(self.infcx.tcx, length),\n+\n+                    // WF if all types but the last one are `Sized`.\n+                    ty::Tuple(types) => program_clauses_for_tuple(\n+                        self.infcx.tcx,\n+                        types.len()\n+                    ),\n+\n+                    // WF if `sub_ty` outlives `region`.\n+                    ty::Ref(..) => program_clauses_for_ref(self.infcx.tcx),\n+\n+                    ty::Dynamic(..) => {\n+                        // FIXME: no rules yet for trait objects\n+                        ty::List::empty()\n+                    }\n+\n+                    ty::Adt(def, ..) => {\n+                        self.infcx.tcx.program_clauses_for(def.did)\n+                    }\n+\n+                    ty::Foreign(def_id) |\n+                    ty::FnDef(def_id, ..) |\n+                    ty::Closure(def_id, ..) |\n+                    ty::Generator(def_id, ..) |\n+                    ty::Opaque(def_id, ..) => {\n+                        self.infcx.tcx.program_clauses_for(def_id)\n+                    }\n+\n+                    ty::GeneratorWitness(..) |\n+                    ty::UnnormalizedProjection(..) |\n+                    ty::Infer(..) |\n+                    ty::Bound(..) |\n+                    ty::Param(..) |\n+                    ty::Error => {\n+                        bug!(\"unexpected type {:?}\", ty)\n+                    }\n+                };\n+\n+                clauses.into_iter()\n+                    .filter(|clause| clause.category() == ProgramClauseCategory::WellFormed)\n+                    .cloned()\n+                    .collect()\n+            }\n+\n+            DomainGoal::FromEnv(FromEnv::Trait(..)) => {\n+                // These come from:\n+                // * implied bounds from trait definitions (rule `Implied-Bound-From-Trait`)\n+                // * implied bounds from type definitions (rule `Implied-Bound-From-Type`)\n+                // * implied bounds from assoc type defs (rules `Implied-Trait-From-AssocTy`,\n+                //   `Implied-Bound-From-AssocTy` and `Implied-WC-From-AssocTy`)\n+\n+                // All of these rules are computed in the environment.\n+                vec![]\n+            }\n+\n+            DomainGoal::FromEnv(FromEnv::Ty(..)) => {\n+                // There are no `FromEnv::Ty(..) :- ...` rules (this predicate only\n+                // comes from the environment).\n+                vec![]\n+            }\n+\n+            DomainGoal::Normalize(projection_predicate) => {\n+                // These come from -- assoc ty values (rule `Normalize-From-Impl`).\n+                let mut clauses = vec![];\n+\n+                assemble_clauses_from_assoc_ty_values(\n+                    self.infcx.tcx,\n+                    projection_predicate.projection_ty.trait_ref(self.infcx.tcx).def_id,\n+                    &mut clauses\n+                );\n+\n+                clauses\n+            }\n+        };\n+\n+        let environment = self.infcx.tcx.lift_to_global(environment)\n+            .expect(\"environment is not global\");\n+        clauses.extend(\n+            self.infcx.tcx.program_clauses_for_env(environment)\n+                .into_iter()\n+                .cloned()\n+        );\n+        clauses\n+    }\n+}"}, {"sha": "4a3806d6cb68074a23998da7cb9bf26025a08a4f", "filename": "src/librustc_traits/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc_traits%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc_traits%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flib.rs?ref=5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "patch": "@@ -23,6 +23,7 @@ extern crate log;\n #[macro_use]\n extern crate rustc;\n extern crate rustc_data_structures;\n+extern crate rustc_target;\n extern crate syntax;\n extern crate syntax_pos;\n extern crate smallvec;"}, {"sha": "54f0c6e8da78a5e984bc8e986bc48ae6dd71f960", "filename": "src/librustc_traits/lowering/environment.rs", "status": "modified", "additions": 61, "deletions": 19, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs?ref=5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "patch": "@@ -20,6 +20,8 @@ use rustc::traits::{\n use rustc::ty::{self, TyCtxt, Ty};\n use rustc::hir::def_id::DefId;\n use rustc_data_structures::fx::FxHashSet;\n+use super::Lower;\n+use std::iter;\n \n struct ClauseVisitor<'set, 'a, 'tcx: 'a + 'set> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -45,9 +47,32 @@ impl ClauseVisitor<'set, 'a, 'tcx> {\n                 );\n             }\n \n-            // forall<'a, T> { `Outlives(T, 'a) :- FromEnv(&'a T)` }\n-            ty::Ref(_region, _sub_ty, ..) => {\n-                // FIXME: we'd need bound tys in order to properly write the above rule\n+            // forall<'a, T> { `Outlives(T: 'a) :- FromEnv(&'a T)` }\n+            ty::Ref(..) => {\n+                use rustc::hir;\n+\n+                let region = self.tcx.mk_region(\n+                    ty::ReLateBound(ty::INNERMOST, ty::BoundRegion::BrAnon(0))\n+                );\n+                let ty = self.tcx.mk_ty(\n+                    ty::Bound(ty::BoundTy::new(ty::INNERMOST, ty::BoundVar::from_u32(1)))\n+                );\n+\n+                let ref_ty = self.tcx.mk_ref(region, ty::TypeAndMut {\n+                    ty,\n+                    mutbl: hir::Mutability::MutImmutable,\n+                });\n+                let from_env = DomainGoal::FromEnv(FromEnv::Ty(ref_ty));\n+\n+                let clause = ProgramClause {\n+                    goal: ty::OutlivesPredicate(ty, region).lower(),\n+                    hypotheses: self.tcx.mk_goals(\n+                        iter::once(self.tcx.mk_goal(from_env.into_goal()))\n+                    ),\n+                    category: ProgramClauseCategory::ImpliedBound,\n+                };\n+                let clause = Clause::ForAll(ty::Binder::bind(clause));\n+                self.round.insert(clause);\n             }\n \n             ty::Dynamic(..) => {\n@@ -88,12 +113,12 @@ impl ClauseVisitor<'set, 'a, 'tcx> {\n             ty::FnPtr(..) |\n             ty::Tuple(..) |\n             ty::Never |\n-            ty::Param(..) => (),\n+            ty::Infer(..) |\n+            ty::Bound(..) => (),\n \n             ty::GeneratorWitness(..) |\n             ty::UnnormalizedProjection(..) |\n-            ty::Infer(..) |\n-            ty::Bound(..) |\n+            ty::Param(..) |\n             ty::Error => {\n                 bug!(\"unexpected type {:?}\", ty);\n             }\n@@ -173,21 +198,28 @@ crate fn program_clauses_for_env<'a, 'tcx>(\n     );\n }\n \n-crate fn environment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Environment<'tcx> {\n+crate fn environment<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    def_id: DefId\n+) -> ty::Binder<Environment<'tcx>> {\n     use super::{Lower, IntoFromEnvGoal};\n     use rustc::hir::{Node, TraitItemKind, ImplItemKind, ItemKind, ForeignItemKind};\n+    use rustc::ty::subst::{Subst, Substs};\n \n     // The environment of an impl Trait type is its defining function's environment.\n     if let Some(parent) = ty::is_impl_trait_defn(tcx, def_id) {\n         return environment(tcx, parent);\n     }\n \n+    let bound_vars = Substs::bound_vars_for_item(tcx, def_id);\n+\n     // Compute the bounds on `Self` and the type parameters.\n-    let ty::InstantiatedPredicates { predicates } =\n-        tcx.predicates_of(def_id).instantiate_identity(tcx);\n+    let ty::InstantiatedPredicates { predicates } = tcx.predicates_of(def_id)\n+        .instantiate_identity(tcx);\n \n     let clauses = predicates.into_iter()\n         .map(|predicate| predicate.lower())\n+        .map(|predicate| predicate.subst(tcx, bound_vars))\n         .map(|domain_goal| domain_goal.map_bound(|bound| bound.into_from_env_goal()))\n         .map(|domain_goal| domain_goal.map_bound(|bound| bound.into_program_clause()))\n \n@@ -228,33 +260,43 @@ crate fn environment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> En\n \n     let mut input_tys = FxHashSet::default();\n \n-    // In an impl, we assume that the receiver type and all its constituents\n+    // In an impl, we assume that the header trait ref and all its constituents\n     // are well-formed.\n     if is_impl {\n-        let trait_ref = tcx.impl_trait_ref(def_id).expect(\"not an impl\");\n-        input_tys.extend(trait_ref.self_ty().walk());\n+        let trait_ref = tcx.impl_trait_ref(def_id)\n+            .expect(\"not an impl\")\n+            .subst(tcx, bound_vars);\n+\n+        input_tys.extend(\n+            trait_ref.substs.types().flat_map(|ty| ty.walk())\n+        );\n     }\n \n     // In an fn, we assume that the arguments and all their constituents are\n     // well-formed.\n     if is_fn {\n-        let fn_sig = tcx.fn_sig(def_id);\n+        // `skip_binder` because we move region parameters to the root binder,\n+        // restored in the return type of this query\n+        let fn_sig = tcx.fn_sig(def_id).skip_binder().subst(tcx, bound_vars);\n+\n         input_tys.extend(\n-            // FIXME: `skip_binder` seems ok for now? In a real setting,\n-            // the late bound regions would next be instantiated with things\n-            // in the inference table.\n-            fn_sig.skip_binder().inputs().iter().flat_map(|ty| ty.walk())\n+            fn_sig.inputs().iter().flat_map(|ty| ty.walk())\n         );\n     }\n \n     let clauses = clauses.chain(\n         input_tys.into_iter()\n+            // Filter out type parameters\n+            .filter(|ty| match ty.sty {\n+                ty::Bound(..) => false,\n+                _ => true,\n+            })\n             .map(|ty| DomainGoal::FromEnv(FromEnv::Ty(ty)))\n             .map(|domain_goal| domain_goal.into_program_clause())\n             .map(Clause::Implies)\n     );\n \n-    Environment {\n+    ty::Binder::bind(Environment {\n         clauses: tcx.mk_clauses(clauses),\n-    }\n+    })\n }"}, {"sha": "471c0e7abbca6711a8144ca0531debd6b4d849cf", "filename": "src/librustc_traits/lowering/mod.rs", "status": "modified", "additions": 96, "deletions": 60, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fmod.rs?ref=5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "patch": "@@ -28,6 +28,7 @@ use rustc::traits::{\n };\n use rustc::ty::query::Providers;\n use rustc::ty::{self, List, TyCtxt};\n+use rustc::ty::subst::{Subst, Substs};\n use syntax::ast;\n \n use std::iter;\n@@ -112,13 +113,14 @@ impl<'tcx> Lower<PolyDomainGoal<'tcx>> for ty::Predicate<'tcx> {\n             Predicate::RegionOutlives(predicate) => predicate.lower(),\n             Predicate::TypeOutlives(predicate) => predicate.lower(),\n             Predicate::Projection(predicate) => predicate.lower(),\n-            Predicate::WellFormed(ty) => {\n-                ty::Binder::dummy(DomainGoal::WellFormed(WellFormed::Ty(*ty)))\n+\n+            Predicate::WellFormed(..) |\n+            Predicate::ObjectSafe(..) |\n+            Predicate::ClosureKind(..) |\n+            Predicate::Subtype(..) |\n+            Predicate::ConstEvaluatable(..) => {\n+                bug!(\"unexpected predicate {}\", self)\n             }\n-            Predicate::ObjectSafe(..)\n-            | Predicate::ClosureKind(..)\n-            | Predicate::Subtype(..)\n-            | Predicate::ConstEvaluatable(..) => unimplemented!(),\n         }\n     }\n }\n@@ -189,9 +191,14 @@ fn program_clauses_for_trait<'a, 'tcx>(\n     // }\n     // ```\n \n+    let bound_vars = Substs::bound_vars_for_item(tcx, def_id);\n+\n     // `Self: Trait<P1..Pn>`\n     let trait_pred = ty::TraitPredicate {\n-        trait_ref: ty::TraitRef::identity(tcx, def_id),\n+        trait_ref: ty::TraitRef {\n+            def_id,\n+            substs: bound_vars,\n+        },\n     };\n \n     // `Implemented(Self: Trait<P1..Pn>)`\n@@ -208,11 +215,12 @@ fn program_clauses_for_trait<'a, 'tcx>(\n         category: ProgramClauseCategory::ImpliedBound,\n     };\n \n-    let clauses = iter::once(Clause::ForAll(ty::Binder::dummy(implemented_from_env)));\n+    let implemented_from_env = Clause::ForAll(ty::Binder::bind(implemented_from_env));\n \n     let where_clauses = &tcx.predicates_defined_on(def_id).predicates\n         .into_iter()\n         .map(|(wc, _)| wc.lower())\n+        .map(|wc| wc.subst(tcx, bound_vars))\n         .collect::<Vec<_>>();\n \n     // Rule Implied-Bound-From-Trait\n@@ -230,11 +238,22 @@ fn program_clauses_for_trait<'a, 'tcx>(\n         .cloned()\n \n         // `FromEnv(WC) :- FromEnv(Self: Trait<P1..Pn>)`\n-        .map(|wc| wc.map_bound(|goal| ProgramClause {\n-            goal: goal.into_from_env_goal(),\n-            hypotheses,\n-            category: ProgramClauseCategory::ImpliedBound,\n-        }))\n+        .map(|wc| {\n+            // we move binders to the left\n+            wc.map_bound(|goal| ProgramClause {\n+                goal: goal.into_from_env_goal(),\n+\n+                // FIXME: As where clauses can only bind lifetimes for now,\n+                // and that named bound regions have a def-id, it is safe\n+                // to just inject `hypotheses` (which contains named vars bound at index `0`)\n+                // into this binding level. This may change if we ever allow where clauses\n+                // to bind types (e.g. for GATs things), because bound types only use a `BoundVar`\n+                // index (no def-id).\n+                hypotheses,\n+\n+                category: ProgramClauseCategory::ImpliedBound,\n+            })\n+        })\n         .map(Clause::ForAll);\n \n     // Rule WellFormed-TraitRef\n@@ -246,28 +265,27 @@ fn program_clauses_for_trait<'a, 'tcx>(\n     // }\n     // ```\n \n-    // `Implemented(Self: Trait<P1..Pn>) && WellFormed(WC)`\n-    let wf_conditions = iter::once(ty::Binder::dummy(trait_pred.lower()))\n-        .chain(\n-            where_clauses\n-                .into_iter()\n-                .map(|wc| wc.map_bound(|goal| goal.into_well_formed_goal()))\n-        );\n+    // `WellFormed(WC)`\n+    let wf_conditions = where_clauses\n+        .into_iter()\n+        .map(|wc| wc.map_bound(|goal| goal.into_well_formed_goal()));\n \n     // `WellFormed(Self: Trait<P1..Pn>) :- Implemented(Self: Trait<P1..Pn>) && WellFormed(WC)`\n     let wf_clause = ProgramClause {\n         goal: DomainGoal::WellFormed(WellFormed::Trait(trait_pred)),\n         hypotheses: tcx.mk_goals(\n-            wf_conditions.map(|wc| tcx.mk_goal(GoalKind::from_poly_domain_goal(wc, tcx))),\n+            iter::once(tcx.mk_goal(GoalKind::DomainGoal(impl_trait))).chain(\n+                wf_conditions.map(|wc| tcx.mk_goal(GoalKind::from_poly_domain_goal(wc, tcx)))\n+            )\n         ),\n         category: ProgramClauseCategory::WellFormed,\n     };\n-    let wf_clause = iter::once(Clause::ForAll(ty::Binder::dummy(wf_clause)));\n+    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n \n     tcx.mk_clauses(\n-        clauses\n+        iter::once(implemented_from_env)\n             .chain(implied_bound_clauses)\n-            .chain(wf_clause)\n+            .chain(iter::once(wf_clause))\n     )\n }\n \n@@ -286,15 +304,20 @@ fn program_clauses_for_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId\n     // }\n     // ```\n \n-    let trait_ref = tcx.impl_trait_ref(def_id).expect(\"not an impl\");\n+    let bound_vars = Substs::bound_vars_for_item(tcx, def_id);\n+\n+    let trait_ref = tcx.impl_trait_ref(def_id)\n+        .expect(\"not an impl\")\n+        .subst(tcx, bound_vars);\n \n     // `Implemented(A0: Trait<A1..An>)`\n     let trait_pred = ty::TraitPredicate { trait_ref }.lower();\n \n     // `WC`\n     let where_clauses = tcx.predicates_of(def_id).predicates\n         .into_iter()\n-        .map(|(wc, _)| wc.lower());\n+        .map(|(wc, _)| wc.lower())\n+        .map(|wc| wc.subst(tcx, bound_vars));\n \n     // `Implemented(A0: Trait<A1..An>) :- WC`\n     let clause = ProgramClause {\n@@ -305,7 +328,7 @@ fn program_clauses_for_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId\n         ),\n         category: ProgramClauseCategory::Other,\n     };\n-    tcx.mk_clauses(iter::once(Clause::ForAll(ty::Binder::dummy(clause))))\n+    tcx.mk_clauses(iter::once(Clause::ForAll(ty::Binder::bind(clause))))\n }\n \n pub fn program_clauses_for_type_def<'a, 'tcx>(\n@@ -322,17 +345,20 @@ pub fn program_clauses_for_type_def<'a, 'tcx>(\n     // }\n     // ```\n \n+    let bound_vars = Substs::bound_vars_for_item(tcx, def_id);\n+\n     // `Ty<...>`\n-    let ty = tcx.type_of(def_id);\n+    let ty = tcx.type_of(def_id).subst(tcx, bound_vars);\n \n     // `WC`\n     let where_clauses = tcx.predicates_of(def_id).predicates\n         .into_iter()\n         .map(|(wc, _)| wc.lower())\n+        .map(|wc| wc.subst(tcx, bound_vars))\n         .collect::<Vec<_>>();\n \n     // `WellFormed(Ty<...>) :- WC1, ..., WCm`\n-    let well_formed = ProgramClause {\n+    let well_formed_clause = ProgramClause {\n         goal: DomainGoal::WellFormed(WellFormed::Ty(ty)),\n         hypotheses: tcx.mk_goals(\n             where_clauses\n@@ -342,10 +368,9 @@ pub fn program_clauses_for_type_def<'a, 'tcx>(\n         ),\n         category: ProgramClauseCategory::WellFormed,\n     };\n+    let well_formed_clause = Clause::ForAll(ty::Binder::bind(well_formed_clause));\n \n-    let well_formed_clause = iter::once(Clause::ForAll(ty::Binder::dummy(well_formed)));\n-\n-    // Rule FromEnv-Type\n+    // Rule Implied-Bound-From-Type\n     //\n     // For each where clause `WC`:\n     // ```\n@@ -363,22 +388,30 @@ pub fn program_clauses_for_type_def<'a, 'tcx>(\n         .into_iter()\n \n         // `FromEnv(WC) :- FromEnv(Ty<...>)`\n-        .map(|wc| wc.map_bound(|goal| ProgramClause {\n-            goal: goal.into_from_env_goal(),\n-            hypotheses,\n-            category: ProgramClauseCategory::ImpliedBound,\n-        }))\n+        .map(|wc| {\n+            // move the binders to the left\n+            wc.map_bound(|goal| ProgramClause {\n+                goal: goal.into_from_env_goal(),\n+\n+                // FIXME: we inject `hypotheses` into this binding level,\n+                // which may be incorrect in the future: see the FIXME in\n+                // `program_clauses_for_trait`\n+                hypotheses,\n+\n+                category: ProgramClauseCategory::ImpliedBound,\n+            })\n+        })\n \n         .map(Clause::ForAll);\n \n-    tcx.mk_clauses(well_formed_clause.chain(from_env_clauses))\n+    tcx.mk_clauses(iter::once(well_formed_clause).chain(from_env_clauses))\n }\n \n pub fn program_clauses_for_associated_type_def<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     item_id: DefId,\n ) -> Clauses<'tcx> {\n-    // Rule ProjectionEq-Skolemize\n+    // Rule ProjectionEq-Placeholder\n     //\n     // ```\n     // trait Trait<P1..Pn> {\n@@ -403,7 +436,12 @@ pub fn program_clauses_for_associated_type_def<'a, 'tcx>(\n         ty::AssociatedItemContainer::TraitContainer(trait_id) => trait_id,\n         _ => bug!(\"not an trait container\"),\n     };\n-    let trait_ref = ty::TraitRef::identity(tcx, trait_id);\n+\n+    let trait_bound_vars = Substs::bound_vars_for_item(tcx, trait_id);\n+    let trait_ref = ty::TraitRef {\n+        def_id: trait_id,\n+        substs: trait_bound_vars,\n+    };\n \n     let projection_ty = ty::ProjectionTy::from_ref_and_name(tcx, trait_ref, item.ident);\n     let placeholder_ty = tcx.mk_ty(ty::UnnormalizedProjection(projection_ty));\n@@ -417,6 +455,7 @@ pub fn program_clauses_for_associated_type_def<'a, 'tcx>(\n         hypotheses: ty::List::empty(),\n         category: ProgramClauseCategory::Other,\n     };\n+    let projection_eq_clause = Clause::ForAll(ty::Binder::bind(projection_eq_clause));\n \n     // Rule WellFormed-AssocTy\n     // ```\n@@ -430,11 +469,13 @@ pub fn program_clauses_for_associated_type_def<'a, 'tcx>(\n     let hypothesis = tcx.mk_goal(\n         DomainGoal::Holds(WhereClause::Implemented(trait_predicate)).into_goal()\n     );\n+\n     let wf_clause = ProgramClause {\n         goal: DomainGoal::WellFormed(WellFormed::Ty(placeholder_ty)),\n         hypotheses: tcx.mk_goals(iter::once(hypothesis)),\n         category: ProgramClauseCategory::WellFormed,\n     };\n+    let wf_clause = Clause::ForAll(ty::Binder::bind(wf_clause));\n \n     // Rule Implied-Trait-From-AssocTy\n     // ```\n@@ -447,16 +488,17 @@ pub fn program_clauses_for_associated_type_def<'a, 'tcx>(\n     let hypothesis = tcx.mk_goal(\n         DomainGoal::FromEnv(FromEnv::Ty(placeholder_ty)).into_goal()\n     );\n+\n     let from_env_clause = ProgramClause {\n         goal: DomainGoal::FromEnv(FromEnv::Trait(trait_predicate)),\n         hypotheses: tcx.mk_goals(iter::once(hypothesis)),\n         category: ProgramClauseCategory::ImpliedBound,\n     };\n+    let from_env_clause = Clause::ForAll(ty::Binder::bind(from_env_clause));\n \n     let clauses = iter::once(projection_eq_clause)\n         .chain(iter::once(wf_clause))\n         .chain(iter::once(from_env_clause));\n-    let clauses = clauses.map(|clause| Clause::ForAll(ty::Binder::dummy(clause)));\n     tcx.mk_clauses(clauses)\n }\n \n@@ -490,17 +532,18 @@ pub fn program_clauses_for_associated_type_value<'a, 'tcx>(\n         _ => bug!(\"not an impl container\"),\n     };\n \n+    let impl_bound_vars = Substs::bound_vars_for_item(tcx, impl_id);\n+\n     // `A0 as Trait<A1..An>`\n-    let trait_ref = tcx.impl_trait_ref(impl_id).unwrap();\n+    let trait_ref = tcx.impl_trait_ref(impl_id)\n+        .unwrap()\n+        .subst(tcx, impl_bound_vars);\n \n     // `T`\n     let ty = tcx.type_of(item_id);\n \n     // `Implemented(A0: Trait<A1..An>)`\n-    let trait_implemented = ty::Binder::dummy(ty::TraitPredicate { trait_ref }.lower());\n-\n-    // `Implemented(A0: Trait<A1..An>)`\n-    let hypotheses = vec![trait_implemented];\n+    let trait_implemented: DomainGoal = ty::TraitPredicate { trait_ref }.lower();\n \n     // `<A0 as Trait<A1..An>>::AssocType<Pn+1..Pm>`\n     let projection_ty = ty::ProjectionTy::from_ref_and_name(tcx, trait_ref, item.ident);\n@@ -509,16 +552,16 @@ pub fn program_clauses_for_associated_type_value<'a, 'tcx>(\n     let normalize_goal = DomainGoal::Normalize(ty::ProjectionPredicate { projection_ty, ty });\n \n     // `Normalize(... -> T) :- ...`\n-    let clause = ProgramClause {\n+    let normalize_clause = ProgramClause {\n         goal: normalize_goal,\n         hypotheses: tcx.mk_goals(\n-            hypotheses\n-                .into_iter()\n-                .map(|wc| tcx.mk_goal(GoalKind::from_poly_domain_goal(wc, tcx))),\n+            iter::once(tcx.mk_goal(GoalKind::DomainGoal(trait_implemented)))\n         ),\n         category: ProgramClauseCategory::Other,\n     };\n-    tcx.mk_clauses(iter::once(Clause::ForAll(ty::Binder::dummy(clause))))\n+    let normalize_clause = Clause::ForAll(ty::Binder::bind(normalize_clause));\n+\n+    tcx.mk_clauses(iter::once(normalize_clause))\n }\n \n pub fn dump_program_clauses<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n@@ -548,7 +591,7 @@ impl<'a, 'tcx> ClauseDumper<'a, 'tcx> {\n \n             if attr.check_name(\"rustc_dump_env_program_clauses\") {\n                 let environment = self.tcx.environment(def_id);\n-                clauses = Some(self.tcx.program_clauses_for_env(environment));\n+                clauses = Some(self.tcx.program_clauses_for_env(*environment.skip_binder()));\n             }\n \n             if let Some(clauses) = clauses {\n@@ -559,14 +602,7 @@ impl<'a, 'tcx> ClauseDumper<'a, 'tcx> {\n \n                 let mut strings: Vec<_> = clauses\n                     .iter()\n-                    .map(|clause| {\n-                        // Skip the top-level binder for a less verbose output\n-                        let program_clause = match clause {\n-                            Clause::Implies(program_clause) => program_clause,\n-                            Clause::ForAll(program_clause) => program_clause.skip_binder(),\n-                        };\n-                        program_clause.to_string()\n-                    })\n+                    .map(|clause| clause.to_string())\n                     .collect();\n \n                 strings.sort();"}, {"sha": "411583b36b9e36aa280210bdb15a0516c1e9caa4", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "patch": "@@ -110,10 +110,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // fnmut vs fnonce. If so, we have to defer further processing.\n                 if self.closure_kind(def_id, substs).is_none() {\n                     let closure_ty = self.closure_sig(def_id, substs);\n-                    let fn_sig = self.replace_late_bound_regions_with_fresh_var(call_expr.span,\n-                                                                   infer::FnCall,\n-                                                                   &closure_ty)\n-                        .0;\n+                    let fn_sig = self.replace_bound_vars_with_fresh_vars(\n+                        call_expr.span,\n+                        infer::FnCall,\n+                        &closure_ty\n+                    ).0;\n                     let adjustments = autoderef.adjust_steps(Needs::None);\n                     self.record_deferred_call_resolution(def_id, DeferredCallResolution {\n                         call_expr,\n@@ -284,7 +285,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // previously appeared within a `Binder<>` and hence would not\n         // have been normalized before.\n         let fn_sig =\n-            self.replace_late_bound_regions_with_fresh_var(call_expr.span, infer::FnCall, &fn_sig)\n+            self.replace_bound_vars_with_fresh_vars(call_expr.span, infer::FnCall, &fn_sig)\n                 .0;\n         let fn_sig = self.normalize_associated_types_in(call_expr.span, &fn_sig);\n "}, {"sha": "10ac2448d007b01c73d65dd33f2bcdce8dbac6fe", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "patch": "@@ -564,7 +564,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // `liberated_sig` is E'.\n             {\n                 // Instantiate (this part of..) S to S', i.e., with fresh variables.\n-                let (supplied_ty, _) = self.infcx.replace_late_bound_regions_with_fresh_var(\n+                let (supplied_ty, _) = self.infcx.replace_bound_vars_with_fresh_vars(\n                     hir_ty.span,\n                     LateBoundRegionConversionTime::FnCall,\n                     &ty::Binder::bind(supplied_ty),\n@@ -605,7 +605,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 );\n             }\n \n-            let (supplied_output_ty, _) = self.infcx.replace_late_bound_regions_with_fresh_var(\n+            let (supplied_output_ty, _) = self.infcx.replace_bound_vars_with_fresh_vars(\n                 decl.output.span(),\n                 LateBoundRegionConversionTime::FnCall,\n                 &supplied_sig.output(),"}, {"sha": "e30ebe07e54185a26a704dc0a289d6b7c838f376", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "patch": "@@ -233,7 +233,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let mut selcx = traits::SelectionContext::new(&infcx);\n \n         let impl_m_own_bounds = impl_m_predicates.instantiate_own(tcx, impl_to_skol_substs);\n-        let (impl_m_own_bounds, _) = infcx.replace_late_bound_regions_with_fresh_var(\n+        let (impl_m_own_bounds, _) = infcx.replace_bound_vars_with_fresh_vars(\n             impl_m_span,\n             infer::HigherRankedType,\n             &ty::Binder::bind(impl_m_own_bounds.predicates)\n@@ -262,10 +262,11 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // Compute placeholder form of impl and trait method tys.\n         let tcx = infcx.tcx;\n \n-        let (impl_sig, _) =\n-            infcx.replace_late_bound_regions_with_fresh_var(impl_m_span,\n-                                                            infer::HigherRankedType,\n-                                                            &tcx.fn_sig(impl_m.def_id));\n+        let (impl_sig, _) = infcx.replace_bound_vars_with_fresh_vars(\n+            impl_m_span,\n+            infer::HigherRankedType,\n+            &tcx.fn_sig(impl_m.def_id)\n+        );\n         let impl_sig =\n             inh.normalize_associated_types_in(impl_m_span,\n                                               impl_m_node_id,"}, {"sha": "5144f3e41d4a9ad4a7c8fc32955fcd21354510d9", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "patch": "@@ -245,7 +245,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                     let original_poly_trait_ref = principal.with_self_ty(this.tcx, object_ty);\n                     let upcast_poly_trait_ref = this.upcast(original_poly_trait_ref, trait_def_id);\n                     let upcast_trait_ref =\n-                        this.replace_late_bound_regions_with_fresh_var(&upcast_poly_trait_ref);\n+                        this.replace_bound_vars_with_fresh_vars(&upcast_poly_trait_ref);\n                     debug!(\"original_poly_trait_ref={:?} upcast_trait_ref={:?} target_trait={:?}\",\n                            original_poly_trait_ref,\n                            upcast_trait_ref,\n@@ -268,7 +268,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             probe::WhereClausePick(ref poly_trait_ref) => {\n                 // Where clauses can have bound regions in them. We need to instantiate\n                 // those to convert from a poly-trait-ref to a trait-ref.\n-                self.replace_late_bound_regions_with_fresh_var(&poly_trait_ref).substs\n+                self.replace_bound_vars_with_fresh_vars(&poly_trait_ref).substs\n             }\n         }\n     }\n@@ -398,7 +398,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         // NB: Instantiate late-bound regions first so that\n         // `instantiate_type_scheme` can normalize associated types that\n         // may reference those regions.\n-        let method_sig = self.replace_late_bound_regions_with_fresh_var(&sig);\n+        let method_sig = self.replace_bound_vars_with_fresh_vars(&sig);\n         debug!(\"late-bound lifetimes from method instantiated, method_sig={:?}\",\n                method_sig);\n \n@@ -633,11 +633,9 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         upcast_trait_refs.into_iter().next().unwrap()\n     }\n \n-    fn replace_late_bound_regions_with_fresh_var<T>(&self, value: &ty::Binder<T>) -> T\n+    fn replace_bound_vars_with_fresh_vars<T>(&self, value: &ty::Binder<T>) -> T\n         where T: TypeFoldable<'tcx>\n     {\n-        self.fcx\n-            .replace_late_bound_regions_with_fresh_var(self.span, infer::FnCall, value)\n-            .0\n+        self.fcx.replace_bound_vars_with_fresh_vars(self.span, infer::FnCall, value).0\n     }\n }"}, {"sha": "ac338ba667865204cf25deb0658583934cb2b835", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "patch": "@@ -311,9 +311,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // `instantiate_type_scheme` can normalize associated types that\n         // may reference those regions.\n         let fn_sig = tcx.fn_sig(def_id);\n-        let fn_sig = self.replace_late_bound_regions_with_fresh_var(span,\n-                                                                    infer::FnCall,\n-                                                                    &fn_sig).0;\n+        let fn_sig = self.replace_bound_vars_with_fresh_vars(\n+            span,\n+            infer::FnCall,\n+            &fn_sig\n+        ).0;\n         let fn_sig = fn_sig.subst(self.tcx, substs);\n         let fn_sig = match self.normalize_associated_types_in_as_infer_ok(span, &fn_sig) {\n             InferOk { value, obligations: o } => {"}, {"sha": "4c06cae1d0752391595ad13a18595749b7e1a810", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "patch": "@@ -755,8 +755,11 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 self.probe(|_| {\n                     let substs = self.fresh_substs_for_item(self.span, method.def_id);\n                     let fty = fty.subst(self.tcx, substs);\n-                    let (fty, _) = self.replace_late_bound_regions_with_fresh_var(\n-                        self.span, infer::FnCall, &fty);\n+                    let (fty, _) = self.replace_bound_vars_with_fresh_vars(\n+                        self.span,\n+                        infer::FnCall,\n+                        &fty\n+                    );\n \n                     if let Some(self_ty) = self_ty {\n                         if self.at(&ObligationCause::dummy(), self.param_env)"}, {"sha": "41e0c6c0a19722f45d057f611869cee78e5185c3", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "patch": "@@ -1921,11 +1921,11 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n                                         poly_trait_ref: ty::PolyTraitRef<'tcx>)\n                                         -> Ty<'tcx>\n     {\n-        let (trait_ref, _) =\n-            self.replace_late_bound_regions_with_fresh_var(\n-                span,\n-                infer::LateBoundRegionConversionTime::AssocTypeProjection(item_def_id),\n-                &poly_trait_ref);\n+        let (trait_ref, _) = self.replace_bound_vars_with_fresh_vars(\n+            span,\n+            infer::LateBoundRegionConversionTime::AssocTypeProjection(item_def_id),\n+            &poly_trait_ref\n+        );\n \n         self.tcx().mk_projection(item_def_id, trait_ref.substs)\n     }"}, {"sha": "d2dc226aca2501fd9e14da18b08cd795770e1365", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "patch": "@@ -1857,8 +1857,9 @@ fn explicit_predicates_of<'a, 'tcx>(\n             &hir::WherePredicate::BoundPredicate(ref bound_pred) => {\n                 let ty = icx.to_ty(&bound_pred.bounded_ty);\n \n-                // Keep the type around in a WF predicate, in case of no bounds.\n-                // That way, `where Ty:` is not a complete noop (see #53696).\n+                // Keep the type around in a dummy predicate, in case of no bounds.\n+                // That way, `where Ty:` is not a complete noop (see #53696) and `Ty`\n+                // is still checked for WF.\n                 if bound_pred.bounds.is_empty() {\n                     if let ty::Param(_) = ty.sty {\n                         // This is a `where T:`, which can be in the HIR from the\n@@ -1869,7 +1870,10 @@ fn explicit_predicates_of<'a, 'tcx>(\n                         // compiler/tooling bugs from not handling WF predicates.\n                     } else {\n                         let span = bound_pred.bounded_ty.span;\n-                        predicates.push((ty::Predicate::WellFormed(ty), span));\n+                        let predicate = ty::OutlivesPredicate(ty, tcx.mk_region(ty::ReEmpty));\n+                        predicates.push(\n+                            (ty::Predicate::TypeOutlives(ty::Binder::dummy(predicate)), span)\n+                        );\n                     }\n                 }\n "}, {"sha": "77782c19b725238b881eedc0290a3bbf878b934b", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "patch": "@@ -1325,15 +1325,10 @@ impl<'a> Clean<WherePredicate> for ty::Predicate<'a> {\n             Predicate::RegionOutlives(ref pred) => pred.clean(cx),\n             Predicate::TypeOutlives(ref pred) => pred.clean(cx),\n             Predicate::Projection(ref pred) => pred.clean(cx),\n-            Predicate::WellFormed(ty) => {\n-                // This comes from `where Ty:` (i.e. no bounds) (see #53696).\n-                WherePredicate::BoundPredicate {\n-                    ty: ty.clean(cx),\n-                    bounds: vec![],\n-                }\n-            }\n-            Predicate::ObjectSafe(_) => panic!(\"not user writable\"),\n-            Predicate::ClosureKind(..) => panic!(\"not user writable\"),\n+\n+            Predicate::WellFormed(..) |\n+            Predicate::ObjectSafe(..) |\n+            Predicate::ClosureKind(..) |\n             Predicate::ConstEvaluatable(..) => panic!(\"not user writable\"),\n         }\n     }"}, {"sha": "b772db5ca5523f21f3b2400158cc1161886843d5", "filename": "src/test/ui/chalkify/lower_env1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Ftest%2Fui%2Fchalkify%2Flower_env1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Ftest%2Fui%2Fchalkify%2Flower_env1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_env1.rs?ref=5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "patch": "@@ -17,7 +17,7 @@ trait Foo { }\n trait Bar where Self: Foo { }\n \n #[rustc_dump_env_program_clauses] //~ ERROR program clause dump\n-fn bar<T: Bar>() {\n+fn bar<T: Bar + ?Sized>() {\n }\n \n fn main() {"}, {"sha": "4aa40bae3193231210f05d596eb19eb7942b2915", "filename": "src/test/ui/chalkify/lower_env1.stderr", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Ftest%2Fui%2Fchalkify%2Flower_env1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Ftest%2Fui%2Fchalkify%2Flower_env1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_env1.stderr?ref=5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "patch": "@@ -4,20 +4,19 @@ error: program clause dump\n LL | #[rustc_dump_program_clauses] //~ ERROR program clause dump\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: FromEnv(Self: Foo) :- FromEnv(Self: Bar).\n-   = note: Implemented(Self: Bar) :- FromEnv(Self: Bar).\n-   = note: WellFormed(Self: Bar) :- Implemented(Self: Bar), WellFormed(Self: Foo).\n+   = note: forall<Self> { FromEnv(Self: Foo) :- FromEnv(Self: Bar). }\n+   = note: forall<Self> { Implemented(Self: Bar) :- FromEnv(Self: Bar). }\n+   = note: forall<Self> { WellFormed(Self: Bar) :- Implemented(Self: Bar), WellFormed(Self: Foo). }\n \n error: program clause dump\n   --> $DIR/lower_env1.rs:19:1\n    |\n LL | #[rustc_dump_env_program_clauses] //~ ERROR program clause dump\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: FromEnv(Self: Foo) :- FromEnv(Self: Bar).\n-   = note: Implemented(Self: Bar) :- FromEnv(Self: Bar).\n-   = note: Implemented(Self: Foo) :- FromEnv(Self: Foo).\n-   = note: Implemented(Self: std::marker::Sized) :- FromEnv(Self: std::marker::Sized).\n+   = note: forall<Self> { FromEnv(Self: Foo) :- FromEnv(Self: Bar). }\n+   = note: forall<Self> { Implemented(Self: Bar) :- FromEnv(Self: Bar). }\n+   = note: forall<Self> { Implemented(Self: Foo) :- FromEnv(Self: Foo). }\n \n error: aborting due to 2 previous errors\n "}, {"sha": "2328db5b4f687cf833f256c2b41fecd7ab90967d", "filename": "src/test/ui/chalkify/lower_env2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Ftest%2Fui%2Fchalkify%2Flower_env2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Ftest%2Fui%2Fchalkify%2Flower_env2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_env2.rs?ref=5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "patch": "@@ -14,12 +14,12 @@\n trait Foo { }\n \n #[rustc_dump_program_clauses] //~ ERROR program clause dump\n-struct S<'a, T> where T: Foo {\n+struct S<'a, T: ?Sized> where T: Foo {\n     data: &'a T,\n }\n \n #[rustc_dump_env_program_clauses] //~ ERROR program clause dump\n-fn bar<'a, T: Foo>(x: S<T>) {\n+fn bar<T: Foo>(_x: S<'_, T>) { // note that we have an implicit `T: Sized` bound\n }\n \n fn main() {"}, {"sha": "74833ef064f9d24039d0c37f56ccec536a10c64f", "filename": "src/test/ui/chalkify/lower_env2.stderr", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Ftest%2Fui%2Fchalkify%2Flower_env2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Ftest%2Fui%2Fchalkify%2Flower_env2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_env2.stderr?ref=5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "patch": "@@ -4,22 +4,20 @@ error: program clause dump\n LL | #[rustc_dump_program_clauses] //~ ERROR program clause dump\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: FromEnv(T: Foo) :- FromEnv(S<'a, T>).\n-   = note: FromEnv(T: std::marker::Sized) :- FromEnv(S<'a, T>).\n-   = note: TypeOutlives(T : 'a) :- FromEnv(S<'a, T>).\n-   = note: WellFormed(S<'a, T>) :- Implemented(T: std::marker::Sized), Implemented(T: Foo), TypeOutlives(T : 'a).\n+   = note: forall<'a, T> { FromEnv(T: Foo) :- FromEnv(S<'a, T>). }\n+   = note: forall<'a, T> { TypeOutlives(T: 'a) :- FromEnv(S<'a, T>). }\n+   = note: forall<'a, T> { WellFormed(S<'a, T>) :- Implemented(T: Foo), TypeOutlives(T: 'a). }\n \n error: program clause dump\n   --> $DIR/lower_env2.rs:21:1\n    |\n LL | #[rustc_dump_env_program_clauses] //~ ERROR program clause dump\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: FromEnv(T: Foo) :- FromEnv(S<'a, T>).\n-   = note: FromEnv(T: std::marker::Sized) :- FromEnv(S<'a, T>).\n-   = note: Implemented(Self: Foo) :- FromEnv(Self: Foo).\n-   = note: Implemented(Self: std::marker::Sized) :- FromEnv(Self: std::marker::Sized).\n-   = note: TypeOutlives(T : 'a) :- FromEnv(S<'a, T>).\n+   = note: forall<'a, T> { FromEnv(T: Foo) :- FromEnv(S<'a, T>). }\n+   = note: forall<'a, T> { TypeOutlives(T: 'a) :- FromEnv(S<'a, T>). }\n+   = note: forall<Self> { Implemented(Self: Foo) :- FromEnv(Self: Foo). }\n+   = note: forall<Self> { Implemented(Self: std::marker::Sized) :- FromEnv(Self: std::marker::Sized). }\n \n error: aborting due to 2 previous errors\n "}, {"sha": "eef6405f8f805e916217566dcb4152e1c8febc61", "filename": "src/test/ui/chalkify/lower_env3.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Ftest%2Fui%2Fchalkify%2Flower_env3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Ftest%2Fui%2Fchalkify%2Flower_env3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_env3.stderr?ref=5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "patch": "@@ -4,17 +4,19 @@ error: program clause dump\n LL |     #[rustc_dump_env_program_clauses] //~ ERROR program clause dump\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: Implemented(Self: Foo) :- FromEnv(Self: Foo).\n+   = note: forall<'^0, ^1> { TypeOutlives(^1: '^0) :- FromEnv(&^1). }\n+   = note: forall<Self> { Implemented(Self: Foo) :- FromEnv(Self: Foo). }\n \n error: program clause dump\n   --> $DIR/lower_env3.rs:20:5\n    |\n LL |     #[rustc_dump_env_program_clauses] //~ ERROR program clause dump\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: FromEnv(Self: std::marker::Sized) :- FromEnv(Self: std::clone::Clone).\n-   = note: Implemented(Self: std::clone::Clone) :- FromEnv(Self: std::clone::Clone).\n-   = note: Implemented(Self: std::marker::Sized) :- FromEnv(Self: std::marker::Sized).\n+   = note: forall<'^0, ^1> { TypeOutlives(^1: '^0) :- FromEnv(&^1). }\n+   = note: forall<Self> { FromEnv(Self: std::marker::Sized) :- FromEnv(Self: std::clone::Clone). }\n+   = note: forall<Self> { Implemented(Self: std::clone::Clone) :- FromEnv(Self: std::clone::Clone). }\n+   = note: forall<Self> { Implemented(Self: std::marker::Sized) :- FromEnv(Self: std::marker::Sized). }\n \n error: aborting due to 2 previous errors\n "}, {"sha": "92a209f673d5c1143ab52f9d6765cf33ccf6e5b9", "filename": "src/test/ui/chalkify/lower_impl.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Ftest%2Fui%2Fchalkify%2Flower_impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Ftest%2Fui%2Fchalkify%2Flower_impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_impl.stderr?ref=5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "patch": "@@ -4,15 +4,15 @@ error: program clause dump\n LL | #[rustc_dump_program_clauses] //~ ERROR program clause dump\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: Implemented(T: Foo) :- ProjectionEq(<T as std::iter::Iterator>::Item == i32), TypeOutlives(T : 'static), Implemented(T: std::iter::Iterator), Implemented(T: std::marker::Sized).\n+   = note: forall<T> { Implemented(T: Foo) :- ProjectionEq(<T as std::iter::Iterator>::Item == i32), TypeOutlives(T: 'static), Implemented(T: std::iter::Iterator), Implemented(T: std::marker::Sized). }\n \n error: program clause dump\n   --> $DIR/lower_impl.rs:23:5\n    |\n LL |     #[rustc_dump_program_clauses] //~ ERROR program clause dump\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: Normalize(<T as Bar>::Assoc == std::vec::Vec<T>) :- Implemented(T: Bar).\n+   = note: forall<T> { Normalize(<T as Bar>::Assoc -> std::vec::Vec<T>) :- Implemented(T: Bar). }\n \n error: aborting due to 2 previous errors\n "}, {"sha": "9b4bba67112ea82df67855cdf71adebbea28f23c", "filename": "src/test/ui/chalkify/lower_struct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Ftest%2Fui%2Fchalkify%2Flower_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Ftest%2Fui%2Fchalkify%2Flower_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_struct.rs?ref=5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "patch": "@@ -11,8 +11,8 @@\n #![feature(rustc_attrs)]\n \n #[rustc_dump_program_clauses] //~ ERROR program clause dump\n-struct Foo<T> where Box<T>: Clone {\n-    _x: std::marker::PhantomData<T>,\n+struct Foo<'a, T> where Box<T>: Clone {\n+    _x: std::marker::PhantomData<&'a T>,\n }\n \n fn main() { }"}, {"sha": "a0dd9369700af63d3d81de46f7376261a0d54594", "filename": "src/test/ui/chalkify/lower_struct.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Ftest%2Fui%2Fchalkify%2Flower_struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Ftest%2Fui%2Fchalkify%2Flower_struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_struct.stderr?ref=5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "patch": "@@ -4,9 +4,10 @@ error: program clause dump\n LL | #[rustc_dump_program_clauses] //~ ERROR program clause dump\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: FromEnv(T: std::marker::Sized) :- FromEnv(Foo<T>).\n-   = note: FromEnv(std::boxed::Box<T>: std::clone::Clone) :- FromEnv(Foo<T>).\n-   = note: WellFormed(Foo<T>) :- Implemented(T: std::marker::Sized), Implemented(std::boxed::Box<T>: std::clone::Clone).\n+   = note: forall<'a, T> { FromEnv(T: std::marker::Sized) :- FromEnv(Foo<'a, T>). }\n+   = note: forall<'a, T> { FromEnv(std::boxed::Box<T>: std::clone::Clone) :- FromEnv(Foo<'a, T>). }\n+   = note: forall<'a, T> { TypeOutlives(T: 'a) :- FromEnv(Foo<'a, T>). }\n+   = note: forall<'a, T> { WellFormed(Foo<'a, T>) :- Implemented(T: std::marker::Sized), Implemented(std::boxed::Box<T>: std::clone::Clone), TypeOutlives(T: 'a). }\n \n error: aborting due to previous error\n "}, {"sha": "6a3f7aa63765f20f16a0d23f822d36484c34f7c8", "filename": "src/test/ui/chalkify/lower_trait.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Ftest%2Fui%2Fchalkify%2Flower_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Ftest%2Fui%2Fchalkify%2Flower_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_trait.stderr?ref=5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "patch": "@@ -4,20 +4,20 @@ error: program clause dump\n LL | #[rustc_dump_program_clauses] //~ ERROR program clause dump\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: FromEnv(<Self as Foo<S, T>>::Assoc: Bar) :- FromEnv(Self: Foo<S, T>).\n-   = note: FromEnv(S: std::marker::Sized) :- FromEnv(Self: Foo<S, T>).\n-   = note: Implemented(Self: Foo<S, T>) :- FromEnv(Self: Foo<S, T>).\n-   = note: WellFormed(Self: Foo<S, T>) :- Implemented(Self: Foo<S, T>), WellFormed(S: std::marker::Sized), WellFormed(<Self as Foo<S, T>>::Assoc: Bar).\n+   = note: forall<Self, S, T> { FromEnv(<Self as Foo<S, T>>::Assoc: Bar) :- FromEnv(Self: Foo<S, T>). }\n+   = note: forall<Self, S, T> { FromEnv(S: std::marker::Sized) :- FromEnv(Self: Foo<S, T>). }\n+   = note: forall<Self, S, T> { Implemented(Self: Foo<S, T>) :- FromEnv(Self: Foo<S, T>). }\n+   = note: forall<Self, S, T> { WellFormed(Self: Foo<S, T>) :- Implemented(Self: Foo<S, T>), WellFormed(S: std::marker::Sized), WellFormed(<Self as Foo<S, T>>::Assoc: Bar). }\n \n error: program clause dump\n   --> $DIR/lower_trait.rs:17:5\n    |\n LL |     #[rustc_dump_program_clauses] //~ ERROR program clause dump\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: FromEnv(Self: Foo<S, T>) :- FromEnv(Unnormalized(<Self as Foo<S, T>>::Assoc)).\n-   = note: ProjectionEq(<Self as Foo<S, T>>::Assoc == Unnormalized(<Self as Foo<S, T>>::Assoc)).\n-   = note: WellFormed(Unnormalized(<Self as Foo<S, T>>::Assoc)) :- Implemented(Self: Foo<S, T>).\n+   = note: forall<Self, S, T> { FromEnv(Self: Foo<S, T>) :- FromEnv(Unnormalized(<Self as Foo<S, T>>::Assoc)). }\n+   = note: forall<Self, S, T> { ProjectionEq(<Self as Foo<S, T>>::Assoc == Unnormalized(<Self as Foo<S, T>>::Assoc)). }\n+   = note: forall<Self, S, T> { WellFormed(Unnormalized(<Self as Foo<S, T>>::Assoc)) :- Implemented(Self: Foo<S, T>). }\n \n error: aborting due to 2 previous errors\n "}, {"sha": "c0e1d8fc4c828ef54c61957998be39894c682c70", "filename": "src/test/ui/chalkify/lower_trait_higher_rank.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Ftest%2Fui%2Fchalkify%2Flower_trait_higher_rank.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Ftest%2Fui%2Fchalkify%2Flower_trait_higher_rank.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_trait_higher_rank.rs?ref=5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "patch": "@@ -11,9 +11,8 @@\n #![feature(rustc_attrs)]\n \n #[rustc_dump_program_clauses] //~ ERROR program clause dump\n-trait Foo<F> where for<'a> F: Fn(&'a (u8, u16)) -> &'a u8\n+trait Foo<F: ?Sized> where for<'a> F: Fn(&'a (u8, u16)) -> &'a u8\n {\n-    fn s(_: F) -> F;\n }\n \n fn main() {"}, {"sha": "6d3e0ec55b276f966be12bbfe4f57427207ff253", "filename": "src/test/ui/chalkify/lower_trait_higher_rank.stderr", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Ftest%2Fui%2Fchalkify%2Flower_trait_higher_rank.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Ftest%2Fui%2Fchalkify%2Flower_trait_higher_rank.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_trait_higher_rank.stderr?ref=5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "patch": "@@ -4,11 +4,10 @@ error: program clause dump\n LL | #[rustc_dump_program_clauses] //~ ERROR program clause dump\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: FromEnv(F: std::marker::Sized) :- FromEnv(Self: Foo<F>).\n-   = note: FromEnv(F: std::ops::Fn<(&'a (u8, u16),)>) :- FromEnv(Self: Foo<F>).\n-   = note: Implemented(Self: Foo<F>) :- FromEnv(Self: Foo<F>).\n-   = note: ProjectionEq(<F as std::ops::FnOnce<(&'a (u8, u16),)>>::Output == &'a u8) :- FromEnv(Self: Foo<F>).\n-   = note: WellFormed(Self: Foo<F>) :- Implemented(Self: Foo<F>), WellFormed(F: std::marker::Sized), forall<> { WellFormed(F: std::ops::Fn<(&'a (u8, u16),)>) }, forall<> { ProjectionEq(<F as std::ops::FnOnce<(&'a (u8, u16),)>>::Output == &'a u8) }.\n+   = note: forall<'a, Self, F> { FromEnv(F: std::ops::Fn<(&'a (u8, u16),)>) :- FromEnv(Self: Foo<F>). }\n+   = note: forall<'a, Self, F> { ProjectionEq(<F as std::ops::FnOnce<(&'a (u8, u16),)>>::Output == &'a u8) :- FromEnv(Self: Foo<F>). }\n+   = note: forall<Self, F> { Implemented(Self: Foo<F>) :- FromEnv(Self: Foo<F>). }\n+   = note: forall<Self, F> { WellFormed(Self: Foo<F>) :- Implemented(Self: Foo<F>), forall<'a> { WellFormed(F: std::ops::Fn<(&'a (u8, u16),)>) }, forall<'a> { ProjectionEq(<F as std::ops::FnOnce<(&'a (u8, u16),)>>::Output == &'a u8) }. }\n \n error: aborting due to previous error\n "}, {"sha": "ac58c0bf2fe37778e477db7d5b954bd8c22d0377", "filename": "src/test/ui/chalkify/lower_trait_where_clause.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Ftest%2Fui%2Fchalkify%2Flower_trait_where_clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Ftest%2Fui%2Fchalkify%2Flower_trait_where_clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_trait_where_clause.rs?ref=5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "patch": "@@ -10,22 +10,16 @@\n \n #![feature(rustc_attrs)]\n \n-use std::fmt::{Debug, Display};\n use std::borrow::Borrow;\n \n #[rustc_dump_program_clauses] //~ ERROR program clause dump\n-trait Foo<'a, 'b, S, T, U>\n+trait Foo<'a, 'b, T, U>\n where\n-    S: Debug,\n-    T: Borrow<U>,\n-    U: ?Sized,\n+    T: Borrow<U> + ?Sized,\n+    U: ?Sized + 'b,\n     'a: 'b,\n-    U: 'b,\n-    Vec<T>:, // NOTE(#53696) this checks an empty list of bounds.\n+    Box<T>:, // NOTE(#53696) this checks an empty list of bounds.\n {\n-    fn s(_: S) -> S;\n-    fn t(_: T) -> T;\n-    fn u(_: U) -> U;\n }\n \n fn main() {"}, {"sha": "fcd516c89ba3326ede1278e5a9ee42259bd6c7d9", "filename": "src/test/ui/chalkify/lower_trait_where_clause.stderr", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Ftest%2Fui%2Fchalkify%2Flower_trait_where_clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Ftest%2Fui%2Fchalkify%2Flower_trait_where_clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Flower_trait_where_clause.stderr?ref=5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "patch": "@@ -1,18 +1,15 @@\n error: program clause dump\n-  --> $DIR/lower_trait_where_clause.rs:16:1\n+  --> $DIR/lower_trait_where_clause.rs:15:1\n    |\n LL | #[rustc_dump_program_clauses] //~ ERROR program clause dump\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: FromEnv(S: std::fmt::Debug) :- FromEnv(Self: Foo<'a, 'b, S, T, U>).\n-   = note: FromEnv(S: std::marker::Sized) :- FromEnv(Self: Foo<'a, 'b, S, T, U>).\n-   = note: FromEnv(T: std::borrow::Borrow<U>) :- FromEnv(Self: Foo<'a, 'b, S, T, U>).\n-   = note: FromEnv(T: std::marker::Sized) :- FromEnv(Self: Foo<'a, 'b, S, T, U>).\n-   = note: Implemented(Self: Foo<'a, 'b, S, T, U>) :- FromEnv(Self: Foo<'a, 'b, S, T, U>).\n-   = note: RegionOutlives('a : 'b) :- FromEnv(Self: Foo<'a, 'b, S, T, U>).\n-   = note: TypeOutlives(U : 'b) :- FromEnv(Self: Foo<'a, 'b, S, T, U>).\n-   = note: WellFormed(Self: Foo<'a, 'b, S, T, U>) :- Implemented(Self: Foo<'a, 'b, S, T, U>), WellFormed(S: std::marker::Sized), WellFormed(T: std::marker::Sized), WellFormed(S: std::fmt::Debug), WellFormed(T: std::borrow::Borrow<U>), RegionOutlives('a : 'b), TypeOutlives(U : 'b), WellFormed(std::vec::Vec<T>).\n-   = note: WellFormed(std::vec::Vec<T>) :- FromEnv(Self: Foo<'a, 'b, S, T, U>).\n+   = note: forall<'a, 'b, Self, T, U> { FromEnv(T: std::borrow::Borrow<U>) :- FromEnv(Self: Foo<'a, 'b, T, U>). }\n+   = note: forall<'a, 'b, Self, T, U> { Implemented(Self: Foo<'a, 'b, T, U>) :- FromEnv(Self: Foo<'a, 'b, T, U>). }\n+   = note: forall<'a, 'b, Self, T, U> { RegionOutlives('a: 'b) :- FromEnv(Self: Foo<'a, 'b, T, U>). }\n+   = note: forall<'a, 'b, Self, T, U> { TypeOutlives(U: 'b) :- FromEnv(Self: Foo<'a, 'b, T, U>). }\n+   = note: forall<'a, 'b, Self, T, U> { TypeOutlives(std::boxed::Box<T>: '<empty>) :- FromEnv(Self: Foo<'a, 'b, T, U>). }\n+   = note: forall<'a, 'b, Self, T, U> { WellFormed(Self: Foo<'a, 'b, T, U>) :- Implemented(Self: Foo<'a, 'b, T, U>), WellFormed(T: std::borrow::Borrow<U>), TypeOutlives(U: 'b), RegionOutlives('a: 'b), TypeOutlives(std::boxed::Box<T>: '<empty>). }\n \n error: aborting due to previous error\n "}, {"sha": "ef5fb8eadc355284e9ed7d2295b0a7a2459e800d", "filename": "src/test/ui/nll/user-annotations/dump-fn-method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-fn-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-fn-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-fn-method.rs?ref=5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "patch": "@@ -39,7 +39,7 @@ fn main() {\n     // Here: we only want the `T` to be given, the rest should be variables.\n     //\n     // (`T` refers to the declaration of `Bazoom`)\n-    let x = <_ as Bazoom<u32>>::method::<_>; //~ ERROR [?0, u32, ?1]\n+    let x = <_ as Bazoom<u32>>::method::<_>; //~ ERROR [^0, u32, ^1]\n     x(&22, 44, 66);\n \n     // Here: all are given\n@@ -51,7 +51,7 @@ fn main() {\n     //\n     // (`U` refers to the declaration of `Bazoom`)\n     let y = 22_u32;\n-    y.method::<u32>(44, 66); //~ ERROR [?0, ?1, u32]\n+    y.method::<u32>(44, 66); //~ ERROR [^0, ^1, u32]\n \n     // Here: nothing is given, so we don't have any annotation.\n     let y = 22_u32;"}, {"sha": "359423d0cfbea4b31a8254da8c0233709427e57f", "filename": "src/test/ui/nll/user-annotations/dump-fn-method.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-fn-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5c9f7dcd8307f92931bc7e5534b467063b4ecc76/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-fn-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-fn-method.stderr?ref=5c9f7dcd8307f92931bc7e5534b467063b4ecc76", "patch": "@@ -4,10 +4,10 @@ error: user substs: Canonical { max_universe: U0, variables: [], value: UserSubs\n LL |     let x = foo::<u32>; //~ ERROR [u32]\n    |             ^^^^^^^^^^\n \n-error: user substs: Canonical { max_universe: U0, variables: [CanonicalVarInfo { kind: Ty(General) }, CanonicalVarInfo { kind: Ty(General) }], value: UserSubsts { substs: [?0, u32, ?1], user_self_ty: None } }\n+error: user substs: Canonical { max_universe: U0, variables: [CanonicalVarInfo { kind: Ty(General) }, CanonicalVarInfo { kind: Ty(General) }], value: UserSubsts { substs: [^0, u32, ^1], user_self_ty: None } }\n   --> $DIR/dump-fn-method.rs:42:13\n    |\n-LL |     let x = <_ as Bazoom<u32>>::method::<_>; //~ ERROR [?0, u32, ?1]\n+LL |     let x = <_ as Bazoom<u32>>::method::<_>; //~ ERROR [^0, u32, ^1]\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: user substs: Canonical { max_universe: U0, variables: [], value: UserSubsts { substs: [u8, u16, u32], user_self_ty: None } }\n@@ -16,10 +16,10 @@ error: user substs: Canonical { max_universe: U0, variables: [], value: UserSubs\n LL |     let x = <u8 as Bazoom<u16>>::method::<u32>; //~ ERROR [u8, u16, u32]\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: user substs: Canonical { max_universe: U0, variables: [CanonicalVarInfo { kind: Ty(General) }, CanonicalVarInfo { kind: Ty(General) }], value: UserSubsts { substs: [?0, ?1, u32], user_self_ty: None } }\n+error: user substs: Canonical { max_universe: U0, variables: [CanonicalVarInfo { kind: Ty(General) }, CanonicalVarInfo { kind: Ty(General) }], value: UserSubsts { substs: [^0, ^1, u32], user_self_ty: None } }\n   --> $DIR/dump-fn-method.rs:54:5\n    |\n-LL |     y.method::<u32>(44, 66); //~ ERROR [?0, ?1, u32]\n+LL |     y.method::<u32>(44, 66); //~ ERROR [^0, ^1, u32]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 4 previous errors"}]}