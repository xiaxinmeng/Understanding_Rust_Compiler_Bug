{"sha": "6cd02a85f1e40f8feac4f09c987baba0821b7756", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjZDAyYTg1ZjFlNDBmOGZlYWM0ZjA5Yzk4N2JhYmEwODIxYjc3NTY=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-11-21T18:44:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-21T18:44:07Z"}, "message": "Rollup merge of #77844 - RalfJung:zst-box, r=nikomatsakis\n\nclarify rules for ZST Boxes\n\nLLVM's rules around `getelementptr inbounds` with offset 0 are a bit annoying, and as a consequence we have no choice but say that a `Box<()>` pointing to previously allocated memory that has since been freed is UB. Clarify the docs to reflect this.\n\nThis is based on conversations on the LLVM mailing list.\n* Here's my initial mail: https://lists.llvm.org/pipermail/llvm-dev/2019-February/130452.html\n* The first email of the March part of that thread: https://lists.llvm.org/pipermail/llvm-dev/2019-March/130831.html\n* First email of the April part: https://lists.llvm.org/pipermail/llvm-dev/2019-April/131693.html\n\nThe conclusion for me at least was that `getelementptr inbounds` with offset 0 is *not* the identity function, but can sometimes return `poison` even when the input is a regular pointer -- specifically, it returns `poison` when this pointer points into something that LLVM \"knows has been deallocated\", i.e., a former LLVM-managed allocation. It is however the identity function on pointers obtained by casting integers.\n\nNote that there [are formal proposals](https://people.mpi-sws.org/~jung/twinsem/twinsem.pdf) for LLVM semantics where `getelementptr inbounds` with offset 0 isn't quite the identity function but never returns `poison` (it affects the provenance of the pointer but in a way that doesn't matter if this pointer is never used for memory accesses), and indeed this is likely necessary to consistently describe LLVM semantics. But with the informal LLVM LangRef that we have right now, and with LLVM devs insisting otherwise, it seems unwise to rely on this.", "tree": {"sha": "6f79a5964fe3c568e925b7ce3c81ab3ffb0ed91a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f79a5964fe3c568e925b7ce3c81ab3ffb0ed91a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6cd02a85f1e40f8feac4f09c987baba0821b7756", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfuV/4CRBK7hj4Ov3rIwAAdHIIAIIiHn+wFCS1uHThxKjnwwQ1\nfnm1bbwrPKO1R45+0u6W+w0ss6FCPQoC8wxAm+NB65kU38PSuAeDswRwKN3pNoDR\ntBQKbvzS2F98w6EdE8aYQS44XPn1zHbNl4e7OUxtEeRHxym1QmcKDISKLPkvrnLo\n9TCQlKwTeuQPNb0Ttj5+P+dDtiDjXHmWooA8whsRrzjhaBwh/EuhBxeyuwB7x7KV\nBQiFOQE0YHtsGu4afI0qjsTTJgudEdNbpHuZ+06r/lkfSoCRypwqbjIdkB0cauY0\nAiEyhGToT1Bn8vZdjPiefgc1APfD4NFlY10dU9w8xVb5Ll2U9GAG+UFJGWYpVOQ=\n=CId0\n-----END PGP SIGNATURE-----\n", "payload": "tree 6f79a5964fe3c568e925b7ce3c81ab3ffb0ed91a\nparent d806d656578c2d6b34cf96809862e8cffb293a68\nparent a7677f77146bd69b26b5fb5eaa8f88ac080ff347\nauthor Dylan DPC <dylan.dpc@gmail.com> 1605984247 +0100\ncommitter GitHub <noreply@github.com> 1605984247 +0100\n\nRollup merge of #77844 - RalfJung:zst-box, r=nikomatsakis\n\nclarify rules for ZST Boxes\n\nLLVM's rules around `getelementptr inbounds` with offset 0 are a bit annoying, and as a consequence we have no choice but say that a `Box<()>` pointing to previously allocated memory that has since been freed is UB. Clarify the docs to reflect this.\n\nThis is based on conversations on the LLVM mailing list.\n* Here's my initial mail: https://lists.llvm.org/pipermail/llvm-dev/2019-February/130452.html\n* The first email of the March part of that thread: https://lists.llvm.org/pipermail/llvm-dev/2019-March/130831.html\n* First email of the April part: https://lists.llvm.org/pipermail/llvm-dev/2019-April/131693.html\n\nThe conclusion for me at least was that `getelementptr inbounds` with offset 0 is *not* the identity function, but can sometimes return `poison` even when the input is a regular pointer -- specifically, it returns `poison` when this pointer points into something that LLVM \"knows has been deallocated\", i.e., a former LLVM-managed allocation. It is however the identity function on pointers obtained by casting integers.\n\nNote that there [are formal proposals](https://people.mpi-sws.org/~jung/twinsem/twinsem.pdf) for LLVM semantics where `getelementptr inbounds` with offset 0 isn't quite the identity function but never returns `poison` (it affects the provenance of the pointer but in a way that doesn't matter if this pointer is never used for memory accesses), and indeed this is likely necessary to consistently describe LLVM semantics. But with the informal LLVM LangRef that we have right now, and with LLVM devs insisting otherwise, it seems unwise to rely on this.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6cd02a85f1e40f8feac4f09c987baba0821b7756", "html_url": "https://github.com/rust-lang/rust/commit/6cd02a85f1e40f8feac4f09c987baba0821b7756", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6cd02a85f1e40f8feac4f09c987baba0821b7756/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d806d656578c2d6b34cf96809862e8cffb293a68", "url": "https://api.github.com/repos/rust-lang/rust/commits/d806d656578c2d6b34cf96809862e8cffb293a68", "html_url": "https://github.com/rust-lang/rust/commit/d806d656578c2d6b34cf96809862e8cffb293a68"}, {"sha": "a7677f77146bd69b26b5fb5eaa8f88ac080ff347", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7677f77146bd69b26b5fb5eaa8f88ac080ff347", "html_url": "https://github.com/rust-lang/rust/commit/a7677f77146bd69b26b5fb5eaa8f88ac080ff347"}], "stats": {"total": 19, "additions": 17, "deletions": 2}, "files": [{"sha": "b9490c44f4b25867a68d9336499e60259fd30bc4", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6cd02a85f1e40f8feac4f09c987baba0821b7756/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cd02a85f1e40f8feac4f09c987baba0821b7756/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=6cd02a85f1e40f8feac4f09c987baba0821b7756", "patch": "@@ -62,6 +62,13 @@\n //! T` obtained from [`Box::<T>::into_raw`] may be deallocated using the\n //! [`Global`] allocator with [`Layout::for_value(&*value)`].\n //!\n+//! For zero-sized values, the `Box` pointer still has to be [valid] for reads\n+//! and writes and sufficiently aligned. In particular, casting any aligned\n+//! non-zero integer literal to a raw pointer produces a valid pointer, but a\n+//! pointer pointing into previously allocated memory that since got freed is\n+//! not valid. The recommended way to build a Box to a ZST if `Box::new` cannot\n+//! be used is to use [`ptr::NonNull::dangling`].\n+//!\n //! So long as `T: Sized`, a `Box<T>` is guaranteed to be represented\n //! as a single pointer and is also ABI-compatible with C pointers\n //! (i.e. the C type `T*`). This means that if you have extern \"C\"\n@@ -125,6 +132,7 @@\n //! [`Global`]: crate::alloc::Global\n //! [`Layout`]: crate::alloc::Layout\n //! [`Layout::for_value(&*value)`]: crate::alloc::Layout::for_value\n+//! [valid]: ptr#safety\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -530,7 +538,10 @@ impl<T: ?Sized> Box<T> {\n     /// memory problems. For example, a double-free may occur if the\n     /// function is called twice on the same raw pointer.\n     ///\n+    /// The safety conditions are described in the [memory layout] section.\n+    ///\n     /// # Examples\n+    ///\n     /// Recreate a `Box` which was previously converted to a raw pointer\n     /// using [`Box::into_raw`]:\n     /// ```"}, {"sha": "27d49529a5ec20f13702df386b892c9d09e9ba06", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6cd02a85f1e40f8feac4f09c987baba0821b7756/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cd02a85f1e40f8feac4f09c987baba0821b7756/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=6cd02a85f1e40f8feac4f09c987baba0821b7756", "patch": "@@ -16,12 +16,16 @@\n //! provided at this point are very minimal:\n //!\n //! * A [null] pointer is *never* valid, not even for accesses of [size zero][zst].\n-//! * All pointers (except for the null pointer) are valid for all operations of\n-//!   [size zero][zst].\n //! * For a pointer to be valid, it is necessary, but not always sufficient, that the pointer\n //!   be *dereferenceable*: the memory range of the given size starting at the pointer must all be\n //!   within the bounds of a single allocated object. Note that in Rust,\n //!   every (stack-allocated) variable is considered a separate allocated object.\n+//! * Even for operations of [size zero][zst], the pointer must not be pointing to deallocated\n+//!   memory, i.e., deallocation makes pointers invalid even for zero-sized operations. However,\n+//!   casting any non-zero integer *literal* to a pointer is valid for zero-sized accesses, even if\n+//!   some memory happens to exist at that address and gets deallocated. This corresponds to writing\n+//!   your own allocator: allocating zero-sized objects is not very hard. The canonical way to\n+//!   obtain a pointer that is valid for zero-sized accesses is [`NonNull::dangling`].\n //! * All accesses performed by functions in this module are *non-atomic* in the sense\n //!   of [atomic operations] used to synchronize between threads. This means it is\n //!   undefined behavior to perform two concurrent accesses to the same location from different"}]}