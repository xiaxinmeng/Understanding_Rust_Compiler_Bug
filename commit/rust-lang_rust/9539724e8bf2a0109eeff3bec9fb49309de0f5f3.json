{"sha": "9539724e8bf2a0109eeff3bec9fb49309de0f5f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1Mzk3MjRlOGJmMmEwMTA5ZWVmZjNiZWM5ZmI0OTMwOWRlMGY1ZjM=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-10-14T00:07:14Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-11-21T00:39:30Z"}, "message": "Remove parentheses from closure argument types", "tree": {"sha": "7b0cdbb708a1278ae33cf7b0b10d3ac027313b07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b0cdbb708a1278ae33cf7b0b10d3ac027313b07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9539724e8bf2a0109eeff3bec9fb49309de0f5f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9539724e8bf2a0109eeff3bec9fb49309de0f5f3", "html_url": "https://github.com/rust-lang/rust/commit/9539724e8bf2a0109eeff3bec9fb49309de0f5f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9539724e8bf2a0109eeff3bec9fb49309de0f5f3/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "497a8b54b5b3f9daf0ec735d443c443ac29afeab", "url": "https://api.github.com/repos/rust-lang/rust/commits/497a8b54b5b3f9daf0ec735d443c443ac29afeab", "html_url": "https://github.com/rust-lang/rust/commit/497a8b54b5b3f9daf0ec735d443c443ac29afeab"}], "stats": {"total": 52, "additions": 26, "deletions": 26}, "files": [{"sha": "a8b0c117b8c1acb9734efc6569c6bbece80911a4", "filename": "src/libcore/either.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9539724e8bf2a0109eeff3bec9fb49309de0f5f3/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9539724e8bf2a0109eeff3bec9fb49309de0f5f3/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=9539724e8bf2a0109eeff3bec9fb49309de0f5f3", "patch": "@@ -13,8 +13,8 @@ pub enum Either<T, U> {\n     Right(U)\n }\n \n-pub fn either<T, U, V>(f_left: fn((&T)) -> V,\n-                       f_right: fn((&U)) -> V, value: &Either<T, U>) -> V {\n+pub fn either<T, U, V>(f_left: fn(&T) -> V,\n+                       f_right: fn(&U) -> V, value: &Either<T, U>) -> V {\n     /*!\n      * Applies a function based on the given either value\n      *"}, {"sha": "33878fdd4781d4854a715de5fa57719e5a40d5a0", "filename": "src/libcore/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9539724e8bf2a0109eeff3bec9fb49309de0f5f3/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9539724e8bf2a0109eeff3bec9fb49309de0f5f3/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=9539724e8bf2a0109eeff3bec9fb49309de0f5f3", "patch": "@@ -489,11 +489,11 @@ pub fn tmpdir() -> Path {\n     }\n }\n /// Recursively walk a directory structure\n-pub fn walk_dir(p: &Path, f: fn((&Path)) -> bool) {\n+pub fn walk_dir(p: &Path, f: fn(&Path) -> bool) {\n \n     walk_dir_(p, f);\n \n-    fn walk_dir_(p: &Path, f: fn((&Path)) -> bool) -> bool {\n+    fn walk_dir_(p: &Path, f: fn(&Path) -> bool) -> bool {\n         let mut keepgoing = true;\n         do list_dir(p).each |q| {\n             let path = &p.push(*q);"}, {"sha": "0eee413cdad00b356c48128fab33565dc04d9a3e", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9539724e8bf2a0109eeff3bec9fb49309de0f5f3/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9539724e8bf2a0109eeff3bec9fb49309de0f5f3/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=9539724e8bf2a0109eeff3bec9fb49309de0f5f3", "patch": "@@ -140,7 +140,7 @@ impl ReprVisitor {\n     // Various helpers for the TyVisitor impl\n \n     #[inline(always)]\n-    fn get<T>(f: fn((&T))) -> bool {\n+    fn get<T>(f: fn(&T)) -> bool {\n         unsafe {\n             f(transmute::<*c_void,&T>(copy self.ptr));\n         }"}, {"sha": "5c59f429fd4668808c82f31fef8992bac58b23ae", "filename": "src/libcore/result.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9539724e8bf2a0109eeff3bec9fb49309de0f5f3/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9539724e8bf2a0109eeff3bec9fb49309de0f5f3/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=9539724e8bf2a0109eeff3bec9fb49309de0f5f3", "patch": "@@ -143,7 +143,7 @@ pub fn chain_err<T, U, V>(\n  *         print_buf(buf)\n  *     }\n  */\n-pub fn iter<T, E>(res: &Result<T, E>, f: fn((&T))) {\n+pub fn iter<T, E>(res: &Result<T, E>, f: fn(&T)) {\n     match *res {\n       Ok(ref t) => f(t),\n       Err(_) => ()\n@@ -158,7 +158,7 @@ pub fn iter<T, E>(res: &Result<T, E>, f: fn((&T))) {\n  * This function can be used to pass through a successful result while\n  * handling an error.\n  */\n-pub fn iter_err<T, E>(res: &Result<T, E>, f: fn((&E))) {\n+pub fn iter_err<T, E>(res: &Result<T, E>, f: fn(&E)) {\n     match *res {\n       Ok(_) => (),\n       Err(ref e) => f(e)\n@@ -179,7 +179,7 @@ pub fn iter_err<T, E>(res: &Result<T, E>, f: fn((&E))) {\n  *         parse_bytes(buf)\n  *     }\n  */\n-pub fn map<T, E: Copy, U: Copy>(res: &Result<T, E>, op: fn((&T)) -> U)\n+pub fn map<T, E: Copy, U: Copy>(res: &Result<T, E>, op: fn(&T) -> U)\n   -> Result<U, E> {\n     match *res {\n       Ok(ref t) => Ok(op(t)),\n@@ -195,7 +195,7 @@ pub fn map<T, E: Copy, U: Copy>(res: &Result<T, E>, op: fn((&T)) -> U)\n  * is immediately returned.  This function can be used to pass through a\n  * successful result while handling an error.\n  */\n-pub fn map_err<T: Copy, E, F: Copy>(res: &Result<T, E>, op: fn((&E)) -> F)\n+pub fn map_err<T: Copy, E, F: Copy>(res: &Result<T, E>, op: fn(&E) -> F)\n   -> Result<T, F> {\n     match *res {\n       Ok(copy t) => Ok(t),\n@@ -210,14 +210,14 @@ impl<T, E> Result<T, E> {\n \n     pure fn is_err() -> bool { is_err(&self) }\n \n-    pure fn iter(f: fn((&T))) {\n+    pure fn iter(f: fn(&T)) {\n         match self {\n           Ok(ref t) => f(t),\n           Err(_) => ()\n         }\n     }\n \n-    fn iter_err(f: fn((&E))) {\n+    fn iter_err(f: fn(&E)) {\n         match self {\n           Ok(_) => (),\n           Err(ref e) => f(e)\n@@ -228,7 +228,7 @@ impl<T, E> Result<T, E> {\n impl<T: Copy, E> Result<T, E> {\n     pure fn get() -> T { get(&self) }\n \n-    fn map_err<F:Copy>(op: fn((&E)) -> F) -> Result<T,F> {\n+    fn map_err<F:Copy>(op: fn(&E) -> F) -> Result<T,F> {\n         match self {\n           Ok(copy t) => Ok(t),\n           Err(ref e) => Err(op(e))\n@@ -239,7 +239,7 @@ impl<T: Copy, E> Result<T, E> {\n impl<T, E: Copy> Result<T, E> {\n     pure fn get_err() -> E { get_err(&self) }\n \n-    fn map<U:Copy>(op: fn((&T)) -> U) -> Result<U,E> {\n+    fn map<U:Copy>(op: fn(&T) -> U) -> Result<U,E> {\n         match self {\n           Ok(ref t) => Ok(op(t)),\n           Err(copy e) => Err(e)\n@@ -277,7 +277,7 @@ impl<T: Copy, E: Copy> Result<T, E> {\n  *     }\n  */\n pub fn map_vec<T,U:Copy,V:Copy>(\n-    ts: &[T], op: fn((&T)) -> Result<V,U>) -> Result<~[V],U> {\n+    ts: &[T], op: fn(&T) -> Result<V,U>) -> Result<~[V],U> {\n \n     let mut vs: ~[V] = vec::with_capacity(vec::len(ts));\n     for vec::each(ts) |t| {\n@@ -290,7 +290,7 @@ pub fn map_vec<T,U:Copy,V:Copy>(\n }\n \n pub fn map_opt<T,U:Copy,V:Copy>(\n-    o_t: &Option<T>, op: fn((&T)) -> Result<V,U>) -> Result<Option<V>,U> {\n+    o_t: &Option<T>, op: fn(&T) -> Result<V,U>) -> Result<Option<V>,U> {\n \n     match *o_t {\n       None => Ok(None),\n@@ -311,7 +311,7 @@ pub fn map_opt<T,U:Copy,V:Copy>(\n  * to accommodate an error like the vectors being of different lengths.\n  */\n pub fn map_vec2<S,T,U:Copy,V:Copy>(ss: &[S], ts: &[T],\n-                op: fn((&S),(&T)) -> Result<V,U>) -> Result<~[V],U> {\n+                op: fn(&S,&T) -> Result<V,U>) -> Result<~[V],U> {\n \n     assert vec::same_length(ss, ts);\n     let n = vec::len(ts);\n@@ -333,7 +333,7 @@ pub fn map_vec2<S,T,U:Copy,V:Copy>(ss: &[S], ts: &[T],\n  * on its own as no result vector is built.\n  */\n pub fn iter_vec2<S,T,U:Copy>(ss: &[S], ts: &[T],\n-                         op: fn((&S),(&T)) -> Result<(),U>) -> Result<(),U> {\n+                         op: fn(&S,&T) -> Result<(),U>) -> Result<(),U> {\n \n     assert vec::same_length(ss, ts);\n     let n = vec::len(ts);"}, {"sha": "2d8d1cd9fd868f7ecc5e3aba25794fefb42a6285", "filename": "src/libcore/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9539724e8bf2a0109eeff3bec9fb49309de0f5f3/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9539724e8bf2a0109eeff3bec9fb49309de0f5f3/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=9539724e8bf2a0109eeff3bec9fb49309de0f5f3", "patch": "@@ -1845,7 +1845,7 @@ const tag_six_b: uint = 252u;\n  * let i = str::as_bytes(\"Hello World\") { |bytes| vec::len(bytes) };\n  * ~~~\n  */\n-pub pure fn as_bytes<T>(s: &const ~str, f: fn((&~[u8])) -> T) -> T {\n+pub pure fn as_bytes<T>(s: &const ~str, f: fn(&~[u8]) -> T) -> T {\n     unsafe {\n         let v: *~[u8] = cast::transmute(copy s);\n         f(&*v)"}, {"sha": "8e99317468def6f632a2c01e0d1f5b816e325017", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9539724e8bf2a0109eeff3bec9fb49309de0f5f3/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9539724e8bf2a0109eeff3bec9fb49309de0f5f3/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=9539724e8bf2a0109eeff3bec9fb49309de0f5f3", "patch": "@@ -1099,7 +1099,7 @@ pub pure fn reversed<T: Copy>(v: &[const T]) -> ~[T] {\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pub pure fn each<T>(v: &r/[T], f: fn((&r/T)) -> bool) {\n+pub pure fn each<T>(v: &r/[T], f: fn(&r/T) -> bool) {\n     //             ^^^^\n     // NB---this CANNOT be &[const T]!  The reason\n     // is that you are passing it to `f()` using"}, {"sha": "200193a48a8cf4b0c965519b520e5897ba5ad06f", "filename": "src/libstd/fun_treemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9539724e8bf2a0109eeff3bec9fb49309de0f5f3/src%2Flibstd%2Ffun_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9539724e8bf2a0109eeff3bec9fb49309de0f5f3/src%2Flibstd%2Ffun_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffun_treemap.rs?ref=9539724e8bf2a0109eeff3bec9fb49309de0f5f3", "patch": "@@ -53,7 +53,7 @@ pub fn find<K: Eq Ord, V: Copy>(m: Treemap<K, V>, k: K) -> Option<V> {\n }\n \n /// Visit all pairs in the map in order.\n-pub fn traverse<K, V: Copy>(m: Treemap<K, V>, f: fn((&K), (&V))) {\n+pub fn traverse<K, V: Copy>(m: Treemap<K, V>, f: fn(&K, &V)) {\n     match *m {\n       Empty => (),\n       /*"}, {"sha": "31144740c8ade482a288df25e278dfdfc076f983", "filename": "src/libstd/future.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9539724e8bf2a0109eeff3bec9fb49309de0f5f3/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9539724e8bf2a0109eeff3bec9fb49309de0f5f3/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=9539724e8bf2a0109eeff3bec9fb49309de0f5f3", "patch": "@@ -51,7 +51,7 @@ impl<A> Future<A> {\n         get_ref(self)\n     }\n \n-    fn with<B>(blk: fn((&A)) -> B) -> B {\n+    fn with<B>(blk: fn(&A) -> B) -> B {\n         //! Work with the value without copying it\n \n         with(&self, blk)\n@@ -164,7 +164,7 @@ pub fn get<A:Copy>(future: &Future<A>) -> A {\n     *get_ref(future)\n }\n \n-pub fn with<A,B>(future: &Future<A>, blk: fn((&A)) -> B) -> B {\n+pub fn with<A,B>(future: &Future<A>, blk: fn(&A) -> B) -> B {\n     //! Work with the value without copying it\n \n     blk(get_ref(future))"}, {"sha": "35b9a92f5a816e9d49f7fadf425b41647eaab0f2", "filename": "src/libstd/list.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9539724e8bf2a0109eeff3bec9fb49309de0f5f3/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9539724e8bf2a0109eeff3bec9fb49309de0f5f3/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=9539724e8bf2a0109eeff3bec9fb49309de0f5f3", "patch": "@@ -29,7 +29,7 @@ pub fn from_vec<T: Copy>(v: &[T]) -> @List<T> {\n  * * z - The initial value\n  * * f - The function to apply\n  */\n-pub fn foldl<T: Copy, U>(z: T, ls: @List<U>, f: fn((&T), (&U)) -> T) -> T {\n+pub fn foldl<T: Copy, U>(z: T, ls: @List<U>, f: fn(&T, &U) -> T) -> T {\n     let mut accum: T = z;\n     do iter(ls) |elt| { accum = f(&accum, elt);}\n     accum\n@@ -42,7 +42,7 @@ pub fn foldl<T: Copy, U>(z: T, ls: @List<U>, f: fn((&T), (&U)) -> T) -> T {\n  * When function `f` returns true then an option containing the element\n  * is returned. If `f` matches no elements then none is returned.\n  */\n-pub fn find<T: Copy>(ls: @List<T>, f: fn((&T)) -> bool) -> Option<T> {\n+pub fn find<T: Copy>(ls: @List<T>, f: fn(&T) -> bool) -> Option<T> {\n     let mut ls = ls;\n     loop {\n         ls = match *ls {\n@@ -120,7 +120,7 @@ pure fn push<T: Copy>(ll: &mut @list<T>, vv: T) {\n */\n \n /// Iterate over a list\n-pub fn iter<T>(l: @List<T>, f: fn((&T))) {\n+pub fn iter<T>(l: @List<T>, f: fn(&T)) {\n     let mut cur = l;\n     loop {\n         cur = match *cur {\n@@ -134,7 +134,7 @@ pub fn iter<T>(l: @List<T>, f: fn((&T))) {\n }\n \n /// Iterate over a list\n-pub fn each<T>(l: @List<T>, f: fn((&T)) -> bool) {\n+pub fn each<T>(l: @List<T>, f: fn(&T) -> bool) {\n     let mut cur = l;\n     loop {\n         cur = match *cur {"}]}