{"sha": "87c529c43a41e0c04a468cd2b301013df629b040", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3YzUyOWM0M2E0MWUwYzA0YTQ2OGNkMmIzMDEwMTNkZjYyOWIwNDA=", "commit": {"author": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2014-06-15T05:53:55Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-19T00:01:34Z"}, "message": "Add a ByteOrder trait for abstracting over endian conversions\n\nThe `Bitwise::swap_bytes` method was also moved into the `ByteOrder` trait. This was because it works on the byte level rather than the bit level.", "tree": {"sha": "e6e5397fe42d407f92a0683303f13ca88eb561a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6e5397fe42d407f92a0683303f13ca88eb561a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87c529c43a41e0c04a468cd2b301013df629b040", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87c529c43a41e0c04a468cd2b301013df629b040", "html_url": "https://github.com/rust-lang/rust/commit/87c529c43a41e0c04a468cd2b301013df629b040", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87c529c43a41e0c04a468cd2b301013df629b040/comments", "author": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1273f94cbb19608e6a4e02c54d8543f6fe648a47", "url": "https://api.github.com/repos/rust-lang/rust/commits/1273f94cbb19608e6a4e02c54d8543f6fe648a47", "html_url": "https://github.com/rust-lang/rust/commit/1273f94cbb19608e6a4e02c54d8543f6fe648a47"}], "stats": {"total": 430, "additions": 263, "deletions": 167}, "files": [{"sha": "6b08a32944c960d4ce6d296fb0ebd94c879ec235", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 239, "deletions": 97, "changes": 336, "blob_url": "https://github.com/rust-lang/rust/blob/87c529c43a41e0c04a468cd2b301013df629b040/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87c529c43a41e0c04a468cd2b301013df629b040/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=87c529c43a41e0c04a468cd2b301013df629b040", "patch": "@@ -13,6 +13,7 @@\n //! This module contains functions for querying the size and alignment of\n //! types, initializing and manipulating memory.\n \n+use clone::Clone;\n use ptr;\n use intrinsics;\n use intrinsics::{bswap16, bswap32, bswap64};\n@@ -169,151 +170,238 @@ pub unsafe fn move_val_init<T>(dst: &mut T, src: T) {\n     ptr::write(dst, src)\n }\n \n-/// Convert an u16 to little endian from the target's endianness.\n-///\n-/// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] pub fn to_le16(x: u16) -> u16 { x }\n+/// A type that can have its bytes re-ordered.\n+pub trait ByteOrder: Clone {\n+    /// Reverses the byte order of the value.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::mem::ByteOrder;\n+    ///\n+    /// let n = 0x0123456789ABCDEFu64;\n+    /// let m = 0xEFCDAB8967452301u64;\n+    ///\n+    /// assert_eq!(n.swap_bytes(), m);\n+    /// ```\n+    fn swap_bytes(&self) -> Self;\n+\n+    /// Convert a value from big endian to the target's endianness.\n+    ///\n+    /// On big endian this is a no-op. On little endian the bytes are swapped.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::mem::ByteOrder;\n+    ///\n+    /// let n = 0x0123456789ABCDEFu64;\n+    ///\n+    /// if cfg!(target_endian = \"big\") {\n+    ///     assert_eq!(ByteOrder::from_big_endian(n), n)\n+    /// } else {\n+    ///     assert_eq!(ByteOrder::from_big_endian(n), n.swap_bytes())\n+    /// }\n+    /// ```\n+    #[inline]\n+    fn from_big_endian(x: Self) -> Self {\n+        if cfg!(target_endian = \"big\") { x } else { x.swap_bytes() }\n+    }\n \n-/// Convert an u16 to little endian from the target's endianness.\n-///\n-/// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")] #[inline] #[stable]\n-pub fn to_le16(x: u16) -> u16 { unsafe { bswap16(x) } }\n+    /// Convert a value from little endian to the target's endianness.\n+    ///\n+    /// On little endian this is a no-op. On big endian the bytes are swapped.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::mem::ByteOrder;\n+    ///\n+    /// let n = 0x0123456789ABCDEFu64;\n+    ///\n+    /// if cfg!(target_endian = \"little\") {\n+    ///     assert_eq!(ByteOrder::from_little_endian(n), n)\n+    /// } else {\n+    ///     assert_eq!(ByteOrder::from_little_endian(n), n.swap_bytes())\n+    /// }\n+    /// ```\n+    #[inline]\n+    fn from_little_endian(x: Self) -> Self {\n+        if cfg!(target_endian = \"little\") { x } else { x.swap_bytes() }\n+    }\n \n-/// Convert an u32 to little endian from the target's endianness.\n-///\n-/// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] #[stable]\n-pub fn to_le32(x: u32) -> u32 { x }\n+    /// Convert the value to big endian from the target's endianness.\n+    ///\n+    /// On big endian this is a no-op. On little endian the bytes are swapped.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::mem::ByteOrder;\n+    ///\n+    /// let n = 0x0123456789ABCDEFu64;\n+    ///\n+    /// if cfg!(target_endian = \"big\") {\n+    ///     assert_eq!(n.to_big_endian(), n)\n+    /// } else {\n+    ///     assert_eq!(n.to_big_endian(), n.swap_bytes())\n+    /// }\n+    /// ```\n+    #[inline]\n+    fn to_big_endian(&self) -> Self {\n+        if cfg!(target_endian = \"big\") { self.clone() } else { self.swap_bytes() }\n+    }\n \n-/// Convert an u32 to little endian from the target's endianness.\n+    /// Convert the value to little endian from the target's endianness.\n+    ///\n+    /// On little endian this is a no-op. On big endian the bytes are swapped.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::mem::ByteOrder;\n+    ///\n+    /// let n = 0x0123456789ABCDEFu64;\n+    ///\n+    /// if cfg!(target_endian = \"little\") {\n+    ///     assert_eq!(n.to_little_endian(), n)\n+    /// } else {\n+    ///     assert_eq!(n.to_little_endian(), n.swap_bytes())\n+    /// }\n+    /// ```\n+    #[inline]\n+    fn to_little_endian(&self) -> Self {\n+        if cfg!(target_endian = \"little\") { self.clone() } else { self.swap_bytes() }\n+    }\n+}\n+\n+impl ByteOrder for u8 {\n+    #[inline]\n+    fn swap_bytes(&self) -> u8 {\n+        *self // swapping a single byte does nothing\n+    }\n+}\n+\n+impl ByteOrder for u16 {\n+    #[inline]\n+    fn swap_bytes(&self) -> u16 {\n+        unsafe { intrinsics::bswap16(*self) }\n+    }\n+}\n+\n+impl ByteOrder for u32 {\n+    #[inline]\n+    fn swap_bytes(&self) -> u32 {\n+        unsafe { intrinsics::bswap32(*self) }\n+    }\n+}\n+\n+impl ByteOrder for u64 {\n+    #[inline]\n+    fn swap_bytes(&self) -> u64 {\n+        unsafe { intrinsics::bswap64(*self) }\n+    }\n+}\n+\n+#[cfg(target_word_size = \"32\")]\n+impl ByteOrder for uint {\n+    #[inline]\n+    fn swap_bytes(&self) -> uint {\n+        (*self as u32).swap_bytes() as uint\n+    }\n+}\n+\n+#[cfg(target_word_size = \"64\")]\n+impl ByteOrder for uint {\n+    #[inline]\n+    fn swap_bytes(&self) -> uint {\n+        (*self as u64).swap_bytes() as uint\n+    }\n+}\n+\n+/// Convert an u16 to little endian from the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")] #[inline] #[stable]\n-pub fn to_le32(x: u32) -> u32 { unsafe { bswap32(x) } }\n+#[inline]\n+#[stable]\n+pub fn to_le16(x: u16) -> u16 { x.to_little_endian() }\n \n-/// Convert an u64 to little endian from the target's endianness.\n+/// Convert an u32 to little endian from the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] #[stable]\n-pub fn to_le64(x: u64) -> u64 { x }\n+#[inline]\n+#[stable]\n+pub fn to_le32(x: u32) -> u32 { x.to_little_endian() }\n \n /// Convert an u64 to little endian from the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")] #[inline] #[stable]\n-pub fn to_le64(x: u64) -> u64 { unsafe { bswap64(x) } }\n-\n-\n-/// Convert an u16 to big endian from the target's endianness.\n-///\n-/// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] #[stable]\n-pub fn to_be16(x: u16) -> u16 { unsafe { bswap16(x) } }\n+#[inline]\n+#[stable]\n+pub fn to_le64(x: u64) -> u64 { x.to_little_endian() }\n \n /// Convert an u16 to big endian from the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")] #[inline] #[stable]\n-pub fn to_be16(x: u16) -> u16 { x }\n-\n-/// Convert an u32 to big endian from the target's endianness.\n-///\n-/// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] #[stable]\n-pub fn to_be32(x: u32) -> u32 { unsafe { bswap32(x) } }\n+#[inline]\n+#[stable]\n+pub fn to_be16(x: u16) -> u16 { x.to_big_endian() }\n \n /// Convert an u32 to big endian from the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")] #[inline] #[stable]\n-pub fn to_be32(x: u32) -> u32 { x }\n-\n-/// Convert an u64 to big endian from the target's endianness.\n-///\n-/// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] #[stable]\n-pub fn to_be64(x: u64) -> u64 { unsafe { bswap64(x) } }\n+#[inline]\n+#[stable]\n+pub fn to_be32(x: u32) -> u32 { x.to_big_endian() }\n \n /// Convert an u64 to big endian from the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")] #[inline] #[stable]\n-pub fn to_be64(x: u64) -> u64 { x }\n-\n-\n-/// Convert an u16 from little endian to the target's endianness.\n-///\n-/// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] #[stable]\n-pub fn from_le16(x: u16) -> u16 { x }\n+#[inline]\n+#[stable]\n+pub fn to_be64(x: u64) -> u64 { x.to_big_endian() }\n \n /// Convert an u16 from little endian to the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")] #[inline] #[stable]\n-pub fn from_le16(x: u16) -> u16 { unsafe { bswap16(x) } }\n-\n-/// Convert an u32 from little endian to the target's endianness.\n-///\n-/// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] #[stable]\n-pub fn from_le32(x: u32) -> u32 { x }\n+#[inline]\n+#[stable]\n+pub fn from_le16(x: u16) -> u16 { ByteOrder::from_little_endian(x) }\n \n /// Convert an u32 from little endian to the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")] #[inline] #[stable]\n-pub fn from_le32(x: u32) -> u32 { unsafe { bswap32(x) } }\n-\n-/// Convert an u64 from little endian to the target's endianness.\n-///\n-/// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] #[stable]\n-pub fn from_le64(x: u64) -> u64 { x }\n+#[inline]\n+#[stable]\n+pub fn from_le32(x: u32) -> u32 { ByteOrder::from_little_endian(x) }\n \n /// Convert an u64 from little endian to the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")] #[inline] #[stable]\n-pub fn from_le64(x: u64) -> u64 { unsafe { bswap64(x) } }\n-\n-\n-/// Convert an u16 from big endian to the target's endianness.\n-///\n-/// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] #[stable]\n-pub fn from_be16(x: u16) -> u16 { unsafe { bswap16(x) } }\n+#[inline]\n+#[stable]\n+pub fn from_le64(x: u64) -> u64 { ByteOrder::from_little_endian(x) }\n \n /// Convert an u16 from big endian to the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")] #[inline] #[stable]\n-pub fn from_be16(x: u16) -> u16 { x }\n-\n-/// Convert an u32 from big endian to the target's endianness.\n-///\n-/// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] #[stable]\n-pub fn from_be32(x: u32) -> u32 { unsafe { bswap32(x) } }\n+#[inline]\n+#[stable]\n+pub fn from_be16(x: u16) -> u16 { ByteOrder::from_big_endian(x) }\n \n /// Convert an u32 from big endian to the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")] #[inline] #[stable]\n-pub fn from_be32(x: u32) -> u32 { x }\n-\n-/// Convert an u64 from big endian to the target's endianness.\n-///\n-/// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] #[stable]\n-pub fn from_be64(x: u64) -> u64 { unsafe { bswap64(x) } }\n+#[inline]\n+#[stable]\n+pub fn from_be32(x: u32) -> u32 { ByteOrder::from_big_endian(x) }\n \n /// Convert an u64 from big endian to the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")] #[inline] #[stable]\n-pub fn from_be64(x: u64) -> u64 { x }\n+#[inline]\n+#[stable]\n+pub fn from_be64(x: u64) -> u64 { ByteOrder::from_big_endian(x) }\n \n /**\n  * Swap the values at two mutable locations of the same type, without\n@@ -558,6 +646,60 @@ mod tests {\n             assert!(Vec::from_slice([76u8]) == transmute(\"L\".to_string()));\n         }\n     }\n+\n+    macro_rules! test_byte_order {\n+        ($T:ident) => {\n+            mod $T {\n+                use mem::ByteOrder;\n+\n+                static A: $T = 0b0101100;\n+                static B: $T = 0b0100001;\n+                static C: $T = 0b1111001;\n+\n+                static _0: $T = 0;\n+                static _1: $T = !0;\n+\n+                #[test]\n+                fn test_swap_bytes() {\n+                    assert_eq!(A.swap_bytes().swap_bytes(), A);\n+                    assert_eq!(B.swap_bytes().swap_bytes(), B);\n+                    assert_eq!(C.swap_bytes().swap_bytes(), C);\n+\n+                    // Swapping these should make no difference\n+                    assert_eq!(_0.swap_bytes(), _0);\n+                    assert_eq!(_1.swap_bytes(), _1);\n+                }\n+\n+                #[test]\n+                fn test_little_endian() {\n+                    assert_eq!(ByteOrder::from_little_endian(A.to_little_endian()), A);\n+                    assert_eq!(ByteOrder::from_little_endian(B.to_little_endian()), B);\n+                    assert_eq!(ByteOrder::from_little_endian(C.to_little_endian()), C);\n+                    assert_eq!(ByteOrder::from_little_endian(_0), _0);\n+                    assert_eq!(ByteOrder::from_little_endian(_1), _1);\n+                    assert_eq!(_0.to_little_endian(), _0);\n+                    assert_eq!(_1.to_little_endian(), _1);\n+                }\n+\n+                #[test]\n+                fn test_big_endian() {\n+                    assert_eq!(ByteOrder::from_big_endian(A.to_big_endian()), A);\n+                    assert_eq!(ByteOrder::from_big_endian(B.to_big_endian()), B);\n+                    assert_eq!(ByteOrder::from_big_endian(C.to_big_endian()), C);\n+                    assert_eq!(ByteOrder::from_big_endian(_0), _0);\n+                    assert_eq!(ByteOrder::from_big_endian(_1), _1);\n+                    assert_eq!(_0.to_big_endian(), _0);\n+                    assert_eq!(_1.to_big_endian(), _1);\n+                }\n+            }\n+        }\n+    }\n+\n+    test_byte_order!(u8)\n+    test_byte_order!(u16)\n+    test_byte_order!(u32)\n+    test_byte_order!(u64)\n+    test_byte_order!(uint)\n }\n \n // FIXME #13642 (these benchmarks should be in another place)"}, {"sha": "8a1bd66aa1acceafd444f901680ed285bc1b348b", "filename": "src/libcore/num/int_macros.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/87c529c43a41e0c04a468cd2b301013df629b040/src%2Flibcore%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87c529c43a41e0c04a468cd2b301013df629b040/src%2Flibcore%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint_macros.rs?ref=87c529c43a41e0c04a468cd2b301013df629b040", "patch": "@@ -113,17 +113,6 @@ mod tests {\n         assert!((0b1111001 as $T).count_zeros() == BITS as $T - 5);\n     }\n \n-    #[test]\n-    fn test_swap_bytes() {\n-        let n: $T = 0b0101100; assert_eq!(n.swap_bytes().swap_bytes(), n);\n-        let n: $T = 0b0100001; assert_eq!(n.swap_bytes().swap_bytes(), n);\n-        let n: $T = 0b1111001; assert_eq!(n.swap_bytes().swap_bytes(), n);\n-\n-        // Swapping these should make no difference\n-        let n: $T = 0;   assert_eq!(n.swap_bytes(), n);\n-        let n: $T = -1;  assert_eq!(n.swap_bytes(), n);\n-    }\n-\n     #[test]\n     fn test_rotate() {\n         let n: $T = 0b0101100; assert_eq!(n.rotate_left(6).rotate_right(2).rotate_right(4), n);"}, {"sha": "696abc05ed27506c391522d510f8677c9c6a87ee", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 24, "deletions": 48, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/87c529c43a41e0c04a468cd2b301013df629b040/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87c529c43a41e0c04a468cd2b301013df629b040/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=87c529c43a41e0c04a468cd2b301013df629b040", "patch": "@@ -437,19 +437,6 @@ pub trait Bitwise: Bounded\n     /// ```\n     fn trailing_zeros(&self) -> Self;\n \n-    /// Reverses the byte order of a binary number.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::num::Bitwise;\n-    ///\n-    /// let n = 0x0123456789ABCDEFu64;\n-    /// let m = 0xEFCDAB8967452301u64;\n-    /// assert_eq!(n.swap_bytes(), m);\n-    /// ```\n-    fn swap_bytes(&self) -> Self;\n-\n     /// Shifts the bits to the left by a specified amount amount, `r`, wrapping\n     /// the truncated bits to the end of the resulting value.\n     ///\n@@ -479,25 +466,17 @@ pub trait Bitwise: Bounded\n     fn rotate_right(&self, r: uint) -> Self;\n }\n \n-/// Swapping a single byte does nothing. This is unsafe to be consistent with\n-/// the other `bswap` intrinsics.\n-#[inline]\n-unsafe fn bswap8(x: u8) -> u8 { x }\n-\n-macro_rules! bitwise_impl(\n-    ($t:ty, $bits:expr, $co:ident, $lz:ident, $tz:ident, $bs:path) => {\n+macro_rules! bitwise_impl {\n+    ($t:ty, $bits:expr, $co:path, $lz:path, $tz:path) => {\n         impl Bitwise for $t {\n             #[inline]\n-            fn count_ones(&self) -> $t { unsafe { intrinsics::$co(*self) } }\n-\n-            #[inline]\n-            fn leading_zeros(&self) -> $t { unsafe { intrinsics::$lz(*self) } }\n+            fn count_ones(&self) -> $t { unsafe { $co(*self) } }\n \n             #[inline]\n-            fn trailing_zeros(&self) -> $t { unsafe { intrinsics::$tz(*self) } }\n+            fn leading_zeros(&self) -> $t { unsafe { $lz(*self) } }\n \n             #[inline]\n-            fn swap_bytes(&self) -> $t { unsafe { $bs(*self) } }\n+            fn trailing_zeros(&self) -> $t { unsafe { $tz(*self) } }\n \n             #[inline]\n             fn rotate_left(&self, r: uint) -> $t {\n@@ -514,22 +493,19 @@ macro_rules! bitwise_impl(\n             }\n         }\n     }\n-)\n+}\n \n-macro_rules! bitwise_cast_impl(\n-    ($t:ty, $t_cast:ty, $bits:expr,  $co:ident, $lz:ident, $tz:ident, $bs:path) => {\n+macro_rules! bitwise_cast_impl {\n+    ($t:ty, $t_cast:ty, $bits:expr, $co:path, $lz:path, $tz:path) => {\n         impl Bitwise for $t {\n             #[inline]\n-            fn count_ones(&self) -> $t { unsafe { intrinsics::$co(*self as $t_cast) as $t } }\n+            fn count_ones(&self) -> $t { unsafe { $co(*self as $t_cast) as $t } }\n \n             #[inline]\n-            fn leading_zeros(&self) -> $t { unsafe { intrinsics::$lz(*self as $t_cast) as $t } }\n+            fn leading_zeros(&self) -> $t { unsafe { $lz(*self as $t_cast) as $t } }\n \n             #[inline]\n-            fn trailing_zeros(&self) -> $t { unsafe { intrinsics::$tz(*self as $t_cast) as $t } }\n-\n-            #[inline]\n-            fn swap_bytes(&self) -> $t { unsafe { $bs(*self as $t_cast) as $t } }\n+            fn trailing_zeros(&self) -> $t { unsafe { $tz(*self as $t_cast) as $t } }\n \n             #[inline]\n             fn rotate_left(&self, r: uint) -> $t {\n@@ -544,27 +520,27 @@ macro_rules! bitwise_cast_impl(\n             }\n         }\n     }\n-)\n+}\n \n #[cfg(target_word_size = \"32\")]\n-bitwise_cast_impl!(uint, u32, 32, ctpop32, ctlz32, cttz32, intrinsics::bswap32)\n+bitwise_cast_impl!(uint, u32, 32, intrinsics::ctpop32, intrinsics::ctlz32, intrinsics::cttz32)\n #[cfg(target_word_size = \"64\")]\n-bitwise_cast_impl!(uint, u64, 64, ctpop64, ctlz64, cttz64, intrinsics::bswap64)\n+bitwise_cast_impl!(uint, u64, 64, intrinsics::ctpop64, intrinsics::ctlz64, intrinsics::cttz64)\n \n-bitwise_impl!(u8, 8, ctpop8, ctlz8, cttz8, bswap8)\n-bitwise_impl!(u16, 16, ctpop16, ctlz16, cttz16, intrinsics::bswap16)\n-bitwise_impl!(u32, 32, ctpop32, ctlz32, cttz32, intrinsics::bswap32)\n-bitwise_impl!(u64, 64, ctpop64, ctlz64, cttz64, intrinsics::bswap64)\n+bitwise_impl!(u8, 8, intrinsics::ctpop8, intrinsics::ctlz8, intrinsics::cttz8)\n+bitwise_impl!(u16, 16, intrinsics::ctpop16, intrinsics::ctlz16, intrinsics::cttz16)\n+bitwise_impl!(u32, 32, intrinsics::ctpop32, intrinsics::ctlz32, intrinsics::cttz32)\n+bitwise_impl!(u64, 64, intrinsics::ctpop64, intrinsics::ctlz64, intrinsics::cttz64)\n \n #[cfg(target_word_size = \"32\")]\n-bitwise_cast_impl!(int, u32, 32, ctpop32, ctlz32, cttz32, intrinsics::bswap32)\n+bitwise_cast_impl!(int, u32, 32, intrinsics::ctpop32, intrinsics::ctlz32, intrinsics::cttz32)\n #[cfg(target_word_size = \"64\")]\n-bitwise_cast_impl!(int, u64, 64, ctpop64, ctlz64, cttz64, intrinsics::bswap64)\n+bitwise_cast_impl!(int, u64, 64, intrinsics::ctpop64, intrinsics::ctlz64, intrinsics::cttz64)\n \n-bitwise_cast_impl!(i8, u8, 8, ctpop8, ctlz8, cttz8, bswap8)\n-bitwise_cast_impl!(i16, u16, 16, ctpop16, ctlz16, cttz16, intrinsics::bswap16)\n-bitwise_cast_impl!(i32, u32, 32, ctpop32, ctlz32, cttz32, intrinsics::bswap32)\n-bitwise_cast_impl!(i64, u64, 64, ctpop64, ctlz64, cttz64, intrinsics::bswap64)\n+bitwise_cast_impl!(i8, u8, 8, intrinsics::ctpop8, intrinsics::ctlz8, intrinsics::cttz8)\n+bitwise_cast_impl!(i16, u16, 16, intrinsics::ctpop16, intrinsics::ctlz16, intrinsics::cttz16)\n+bitwise_cast_impl!(i32, u32, 32, intrinsics::ctpop32, intrinsics::ctlz32, intrinsics::cttz32)\n+bitwise_cast_impl!(i64, u64, 64, intrinsics::ctpop64, intrinsics::ctlz64, intrinsics::cttz64)\n \n /// Specifies the available operations common to all of Rust's core numeric primitives.\n /// These may not always make sense from a purely mathematical point of view, but"}, {"sha": "8548b141053945ef9b7c06cbc48b579a0deb37bb", "filename": "src/libcore/num/uint_macros.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/87c529c43a41e0c04a468cd2b301013df629b040/src%2Flibcore%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87c529c43a41e0c04a468cd2b301013df629b040/src%2Flibcore%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint_macros.rs?ref=87c529c43a41e0c04a468cd2b301013df629b040", "patch": "@@ -64,17 +64,6 @@ mod tests {\n         assert!((0b1111001 as $T).count_zeros() == BITS as $T - 5);\n     }\n \n-    #[test]\n-    fn test_swap_bytes() {\n-        let n: $T = 0b0101100; assert_eq!(n.swap_bytes().swap_bytes(), n);\n-        let n: $T = 0b0100001; assert_eq!(n.swap_bytes().swap_bytes(), n);\n-        let n: $T = 0b1111001; assert_eq!(n.swap_bytes().swap_bytes(), n);\n-\n-        // Swapping these should make no difference\n-        let n: $T = 0;   assert_eq!(n.swap_bytes(), n);\n-        let n: $T = MAX; assert_eq!(n.swap_bytes(), n);\n-    }\n-\n     #[test]\n     fn test_rotate() {\n         let n: $T = 0b0101100; assert_eq!(n.rotate_left(6).rotate_right(2).rotate_right(4), n);"}]}