{"sha": "d9fb01f803671bfb6fca6b873bd140d8177ecb1c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5ZmIwMWY4MDM2NzFiZmI2ZmNhNmI4NzNiZDE0MGQ4MTc3ZWNiMWM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-11-04T17:21:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-04T17:21:41Z"}, "message": "Merge #2173\n\n2173: MBE: Add TokenId shift in macro_rules r=matklad a=edwin0cheng\n\nAs discussed in #2169 , for fixing duplication TokenId during expansion :\r\n\r\n> What we can do here is to re-number the tokens during expansion. Specifically:\r\n> * when we create macro_rules, we note the highest id of the token we have as shift>\r\n> * when we expand macro rules, if we need to output a token from definition, we just re-use its id\r\n> * if we need to output a token from the argument, we increase its id by shift (so it's guaranteed to not to collide with anything from the definition)\r\n> * finally, when we have a HirFileId of the expansion, we can look up the original value of shift and classify node to the arg/def by comparing it's id with shift.\r\n> \r\n\r\nThis PR implement first 3 points of above solution. \n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>", "tree": {"sha": "9a1a0b696749d4d079ff0744272f78f497caae29", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a1a0b696749d4d079ff0744272f78f497caae29"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d9fb01f803671bfb6fca6b873bd140d8177ecb1c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdwF4lCRBK7hj4Ov3rIwAAdHIIAEA2z7qG/nHC7anQ5W5cy/S0\nPj26wBVJMseTqdL96B6eIRiOKkV90FALj+yH7ZJfifIxXj0x1Ml6vd5azVVosKp6\nx0nyCSmO9PRI+lJZ1N0qmVSINSWPdygwyiJlDCBdCbUy0/duFFSN7OC1GY8NIPAJ\nt7GURAdfQZL4tOD8ugtvDfrURbm7vpcOUixQ0eYe7IfTzD7phkGz+Fv7DBLivYg7\nGXA3DIDDlu58ZAZelmjnIg4YV8XExlclR7N0ANP+MqEgaaFe9T27cGsDvWn/OB50\nv4fh2r2wPAbt9gXMoJPlkvbf9fqVPM0WSS28SwIgXj2pCotppw9445ZV75XVd3k=\n=pqqS\n-----END PGP SIGNATURE-----\n", "payload": "tree 9a1a0b696749d4d079ff0744272f78f497caae29\nparent cc2d75d0f88bdcb1b3e20db36decb6ee6eca517a\nparent a5839662f448602d6aa2d724432844fc2d08947e\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1572888101 +0000\ncommitter GitHub <noreply@github.com> 1572888101 +0000\n\nMerge #2173\n\n2173: MBE: Add TokenId shift in macro_rules r=matklad a=edwin0cheng\n\nAs discussed in #2169 , for fixing duplication TokenId during expansion :\r\n\r\n> What we can do here is to re-number the tokens during expansion. Specifically:\r\n> * when we create macro_rules, we note the highest id of the token we have as shift>\r\n> * when we expand macro rules, if we need to output a token from definition, we just re-use its id\r\n> * if we need to output a token from the argument, we increase its id by shift (so it's guaranteed to not to collide with anything from the definition)\r\n> * finally, when we have a HirFileId of the expansion, we can look up the original value of shift and classify node to the arg/def by comparing it's id with shift.\r\n> \r\n\r\nThis PR implement first 3 points of above solution. \n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d9fb01f803671bfb6fca6b873bd140d8177ecb1c", "html_url": "https://github.com/rust-lang/rust/commit/d9fb01f803671bfb6fca6b873bd140d8177ecb1c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d9fb01f803671bfb6fca6b873bd140d8177ecb1c/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc2d75d0f88bdcb1b3e20db36decb6ee6eca517a", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc2d75d0f88bdcb1b3e20db36decb6ee6eca517a", "html_url": "https://github.com/rust-lang/rust/commit/cc2d75d0f88bdcb1b3e20db36decb6ee6eca517a"}, {"sha": "a5839662f448602d6aa2d724432844fc2d08947e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5839662f448602d6aa2d724432844fc2d08947e", "html_url": "https://github.com/rust-lang/rust/commit/a5839662f448602d6aa2d724432844fc2d08947e"}], "stats": {"total": 72, "additions": 70, "deletions": 2}, "files": [{"sha": "15f000175559d8581c3cfed09e7b16f91e71d641", "filename": "crates/ra_mbe/src/lib.rs", "status": "modified", "additions": 43, "deletions": 2, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d9fb01f803671bfb6fca6b873bd140d8177ecb1c/crates%2Fra_mbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9fb01f803671bfb6fca6b873bd140d8177ecb1c/crates%2Fra_mbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Flib.rs?ref=d9fb01f803671bfb6fca6b873bd140d8177ecb1c", "patch": "@@ -42,6 +42,8 @@ pub use crate::syntax_bridge::{\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub struct MacroRules {\n     pub(crate) rules: Vec<Rule>,\n+    /// Highest id of the token we have in TokenMap\n+    pub(crate) shift: u32,\n }\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n@@ -50,6 +52,38 @@ pub(crate) struct Rule {\n     pub(crate) rhs: tt::Subtree,\n }\n \n+// Find the max token id inside a subtree\n+fn max_id(subtree: &tt::Subtree) -> Option<u32> {\n+    subtree\n+        .token_trees\n+        .iter()\n+        .filter_map(|tt| match tt {\n+            tt::TokenTree::Subtree(subtree) => max_id(subtree),\n+            tt::TokenTree::Leaf(tt::Leaf::Ident(ident))\n+                if ident.id != tt::TokenId::unspecified() =>\n+            {\n+                Some(ident.id.0)\n+            }\n+            _ => None,\n+        })\n+        .max()\n+}\n+\n+/// Shift given TokenTree token id\n+fn shift_subtree(tt: &mut tt::Subtree, shift: u32) {\n+    for t in tt.token_trees.iter_mut() {\n+        match t {\n+            tt::TokenTree::Leaf(leaf) => match leaf {\n+                tt::Leaf::Ident(ident) if ident.id != tt::TokenId::unspecified() => {\n+                    ident.id.0 += shift;\n+                }\n+                _ => (),\n+            },\n+            tt::TokenTree::Subtree(tt) => shift_subtree(tt, shift),\n+        }\n+    }\n+}\n+\n impl MacroRules {\n     pub fn parse(tt: &tt::Subtree) -> Result<MacroRules, ParseError> {\n         // Note: this parsing can be implemented using mbe machinery itself, by\n@@ -72,10 +106,17 @@ impl MacroRules {\n             validate(&rule.lhs)?;\n         }\n \n-        Ok(MacroRules { rules })\n+        // Note that TokenId is started from zero,\n+        // We have to add 1 to prevent duplication.\n+        let shift = max_id(tt).map_or(0, |it| it + 1);\n+        Ok(MacroRules { rules, shift })\n     }\n+\n     pub fn expand(&self, tt: &tt::Subtree) -> Result<tt::Subtree, ExpandError> {\n-        mbe_expander::expand(self, tt)\n+        // apply shift\n+        let mut tt = tt.clone();\n+        shift_subtree(&mut tt, self.shift);\n+        mbe_expander::expand(self, &tt)\n     }\n }\n "}, {"sha": "a23e3afe3e7afe10a02ae7a95327e5ba78321880", "filename": "crates/ra_mbe/src/tests.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d9fb01f803671bfb6fca6b873bd140d8177ecb1c/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9fb01f803671bfb6fca6b873bd140d8177ecb1c/crates%2Fra_mbe%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Ftests.rs?ref=d9fb01f803671bfb6fca6b873bd140d8177ecb1c", "patch": "@@ -58,6 +58,33 @@ mod rule_parsing {\n // * Port the test to rust and add it to this module\n // * Make it pass :-)\n \n+#[test]\n+fn test_token_id_shift() {\n+    let macro_definition = r#\"\n+macro_rules! foobar {\n+    ($e:ident) => { foo bar $e }\n+}\n+\"#;\n+    let rules = create_rules(macro_definition);\n+    let expansion = expand(&rules, \"foobar!(baz);\");\n+\n+    fn get_id(t: &tt::TokenTree) -> Option<u32> {\n+        if let tt::TokenTree::Leaf(tt::Leaf::Ident(ident)) = t {\n+            return Some(ident.id.0);\n+        }\n+        None\n+    }\n+\n+    assert_eq!(expansion.token_trees.len(), 3);\n+    // ($e:ident) => { foo bar $e }\n+    //   0 1            2   3   4\n+    assert_eq!(get_id(&expansion.token_trees[0]), Some(2));\n+    assert_eq!(get_id(&expansion.token_trees[1]), Some(3));\n+\n+    // So baz should be 5\n+    assert_eq!(get_id(&expansion.token_trees[2]), Some(5));\n+}\n+\n #[test]\n fn test_convert_tt() {\n     let macro_definition = r#\""}]}