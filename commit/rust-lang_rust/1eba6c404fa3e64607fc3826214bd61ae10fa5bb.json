{"sha": "1eba6c404fa3e64607fc3826214bd61ae10fa5bb", "node_id": "C_kwDOAAsO6NoAKDFlYmE2YzQwNGZhM2U2NDYwN2ZjMzgyNjIxNGJkNjFhZTEwZmE1YmI", "commit": {"author": {"name": "Lukas Markeffsky", "email": "@", "date": "2022-12-25T21:16:04Z"}, "committer": {"name": "Lukas Markeffsky", "email": "@", "date": "2022-12-26T15:35:21Z"}, "message": "address review comments + better tests", "tree": {"sha": "939b08823ed2fc38a4f1deb7e488cb251247b808", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/939b08823ed2fc38a4f1deb7e488cb251247b808"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1eba6c404fa3e64607fc3826214bd61ae10fa5bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1eba6c404fa3e64607fc3826214bd61ae10fa5bb", "html_url": "https://github.com/rust-lang/rust/commit/1eba6c404fa3e64607fc3826214bd61ae10fa5bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1eba6c404fa3e64607fc3826214bd61ae10fa5bb/comments", "author": null, "committer": null, "parents": [{"sha": "83e653920d694a010fad8c7d87d302c2d5b3a177", "url": "https://api.github.com/repos/rust-lang/rust/commits/83e653920d694a010fad8c7d87d302c2d5b3a177", "html_url": "https://github.com/rust-lang/rust/commit/83e653920d694a010fad8c7d87d302c2d5b3a177"}], "stats": {"total": 503, "additions": 405, "deletions": 98}, "files": [{"sha": "294ffec8a5ec4cc95fe31b9d06741df23efd4624", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1eba6c404fa3e64607fc3826214bd61ae10fa5bb/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eba6c404fa3e64607fc3826214bd61ae10fa5bb/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=1eba6c404fa3e64607fc3826214bd61ae10fa5bb", "patch": "@@ -1316,6 +1316,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 param.id,\n                 &param.kind,\n                 &param.bounds,\n+                param.colon_span,\n+                generics.span,\n                 itctx,\n                 PredicateOrigin::GenericParam,\n             )\n@@ -1365,6 +1367,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         id: NodeId,\n         kind: &GenericParamKind,\n         bounds: &[GenericBound],\n+        colon_span: Option<Span>,\n+        parent_span: Span,\n         itctx: &ImplTraitContext,\n         origin: PredicateOrigin,\n     ) -> Option<hir::WherePredicate<'hir>> {\n@@ -1377,8 +1381,17 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         let ident = self.lower_ident(ident);\n         let param_span = ident.span;\n-        let span =\n-            bounds.iter().fold(param_span.shrink_to_hi(), |span, bound| span.to(bound.span()));\n+\n+        // Reconstruct the span of the entire predicate from the individual generic bounds.\n+        let span_start = colon_span.unwrap_or_else(|| param_span.shrink_to_hi());\n+        let span = bounds.iter().fold(span_start, |span_accum, bound| {\n+            match bound.span().find_ancestor_inside(parent_span) {\n+                Some(bound_span) => span_accum.to(bound_span),\n+                None => span_accum,\n+            }\n+        });\n+        let span = self.lower_span(span);\n+\n         match kind {\n             GenericParamKind::Const { .. } => None,\n             GenericParamKind::Type { .. } => {"}, {"sha": "a2b0f112e3b839d599fb211204c7c5a55a49b802", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1eba6c404fa3e64607fc3826214bd61ae10fa5bb/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eba6c404fa3e64607fc3826214bd61ae10fa5bb/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=1eba6c404fa3e64607fc3826214bd61ae10fa5bb", "patch": "@@ -2247,14 +2247,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     ) -> (hir::GenericParam<'hir>, Option<hir::WherePredicate<'hir>>, hir::TyKind<'hir>) {\n         // Add a definition for the in-band `Param`.\n         let def_id = self.local_def_id(node_id);\n+        let span = self.lower_span(span);\n \n         // Set the name to `impl Bound1 + Bound2`.\n         let param = hir::GenericParam {\n             hir_id: self.lower_node_id(node_id),\n             def_id,\n             name: ParamName::Plain(self.lower_ident(ident)),\n             pure_wrt_drop: false,\n-            span: self.lower_span(span),\n+            span,\n             kind: hir::GenericParamKind::Type { default: None, synthetic: true },\n             colon_span: None,\n         };\n@@ -2264,6 +2265,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             node_id,\n             &GenericParamKind::Type { default: None },\n             bounds,\n+            /* colon_span */ None,\n+            span,\n             &ImplTraitContext::Universal,\n             hir::PredicateOrigin::ImplTrait,\n         );\n@@ -2273,7 +2276,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let ty = hir::TyKind::Path(hir::QPath::Resolved(\n             None,\n             self.arena.alloc(hir::Path {\n-                span: self.lower_span(span),\n+                span,\n                 res,\n                 segments:\n                     arena_vec![self; hir::PathSegment::new(self.lower_ident(ident), hir_id, res)],"}, {"sha": "cdb901b7f8603b65329e31ff6e14e7385db6c222", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 63, "deletions": 51, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/1eba6c404fa3e64607fc3826214bd61ae10fa5bb/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eba6c404fa3e64607fc3826214bd61ae10fa5bb/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=1eba6c404fa3e64607fc3826214bd61ae10fa5bb", "patch": "@@ -55,7 +55,7 @@ use rustc_session::lint::{BuiltinLintDiagnostics, FutureIncompatibilityReason};\n use rustc_span::edition::Edition;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_span::{BytePos, InnerSpan, Span, SyntaxContext};\n+use rustc_span::{BytePos, InnerSpan, Span};\n use rustc_target::abi::{Abi, VariantIdx};\n use rustc_trait_selection::infer::{InferCtxtExt, TyCtxtInferExt};\n use rustc_trait_selection::traits::{self, misc::can_type_implement_copy, EvaluationResult};\n@@ -2184,7 +2184,7 @@ impl ExplicitOutlivesRequirements {\n         tcx: TyCtxt<'tcx>,\n         bounds: &hir::GenericBounds<'_>,\n         inferred_outlives: &[ty::Region<'tcx>],\n-        span_cx: SyntaxContext,\n+        predicate_span: Span,\n     ) -> Vec<(usize, Span)> {\n         use rustc_middle::middle::resolve_lifetime::Region;\n \n@@ -2207,8 +2207,8 @@ impl ExplicitOutlivesRequirements {\n                     return None;\n                 }\n \n-                let span = bound.span();\n-                if span.ctxt() != span_cx || in_external_macro(tcx.sess, span) {\n+                let span = bound.span().find_ancestor_inside(predicate_span)?;\n+                if in_external_macro(tcx.sess, span) {\n                     return None;\n                 }\n \n@@ -2279,9 +2279,9 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n         use rustc_middle::middle::resolve_lifetime::Region;\n \n         let def_id = item.owner_id.def_id;\n-        if let hir::ItemKind::Struct(_, ref hir_generics)\n-        | hir::ItemKind::Enum(_, ref hir_generics)\n-        | hir::ItemKind::Union(_, ref hir_generics) = item.kind\n+        if let hir::ItemKind::Struct(_, hir_generics)\n+        | hir::ItemKind::Enum(_, hir_generics)\n+        | hir::ItemKind::Union(_, hir_generics) = item.kind\n         {\n             let inferred_outlives = cx.tcx.inferred_outlives_of(def_id);\n             if inferred_outlives.is_empty() {\n@@ -2296,47 +2296,48 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n             let mut dropped_predicate_count = 0;\n             let num_predicates = hir_generics.predicates.len();\n             for (i, where_predicate) in hir_generics.predicates.iter().enumerate() {\n-                let (relevant_lifetimes, bounds, span, in_where_clause) = match where_predicate {\n-                    hir::WherePredicate::RegionPredicate(predicate) => {\n-                        if let Some(Region::EarlyBound(region_def_id)) =\n-                            cx.tcx.named_region(predicate.lifetime.hir_id)\n-                        {\n-                            (\n-                                Self::lifetimes_outliving_lifetime(\n-                                    inferred_outlives,\n-                                    region_def_id,\n-                                ),\n-                                &predicate.bounds,\n-                                predicate.span,\n-                                predicate.in_where_clause,\n-                            )\n-                        } else {\n-                            continue;\n-                        }\n-                    }\n-                    hir::WherePredicate::BoundPredicate(predicate) => {\n-                        // FIXME we can also infer bounds on associated types,\n-                        // and should check for them here.\n-                        match predicate.bounded_ty.kind {\n-                            hir::TyKind::Path(hir::QPath::Resolved(None, path)) => {\n-                                let Res::Def(DefKind::TyParam, def_id) = path.res else {\n-                                    continue;\n-                                };\n-                                let index = ty_generics.param_def_id_to_index[&def_id];\n+                let (relevant_lifetimes, bounds, predicate_span, in_where_clause) =\n+                    match where_predicate {\n+                        hir::WherePredicate::RegionPredicate(predicate) => {\n+                            if let Some(Region::EarlyBound(region_def_id)) =\n+                                cx.tcx.named_region(predicate.lifetime.hir_id)\n+                            {\n                                 (\n-                                    Self::lifetimes_outliving_type(inferred_outlives, index),\n+                                    Self::lifetimes_outliving_lifetime(\n+                                        inferred_outlives,\n+                                        region_def_id,\n+                                    ),\n                                     &predicate.bounds,\n                                     predicate.span,\n-                                    predicate.origin == PredicateOrigin::WhereClause,\n+                                    predicate.in_where_clause,\n                                 )\n-                            }\n-                            _ => {\n+                            } else {\n                                 continue;\n                             }\n                         }\n-                    }\n-                    _ => continue,\n-                };\n+                        hir::WherePredicate::BoundPredicate(predicate) => {\n+                            // FIXME we can also infer bounds on associated types,\n+                            // and should check for them here.\n+                            match predicate.bounded_ty.kind {\n+                                hir::TyKind::Path(hir::QPath::Resolved(None, path)) => {\n+                                    let Res::Def(DefKind::TyParam, def_id) = path.res else {\n+                                    continue;\n+                                };\n+                                    let index = ty_generics.param_def_id_to_index[&def_id];\n+                                    (\n+                                        Self::lifetimes_outliving_type(inferred_outlives, index),\n+                                        &predicate.bounds,\n+                                        predicate.span,\n+                                        predicate.origin == PredicateOrigin::WhereClause,\n+                                    )\n+                                }\n+                                _ => {\n+                                    continue;\n+                                }\n+                            }\n+                        }\n+                        _ => continue,\n+                    };\n                 if relevant_lifetimes.is_empty() {\n                     continue;\n                 }\n@@ -2345,7 +2346,7 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n                     cx.tcx,\n                     bounds,\n                     &relevant_lifetimes,\n-                    span.ctxt(),\n+                    predicate_span,\n                 );\n                 bound_count += bound_spans.len();\n \n@@ -2355,15 +2356,15 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n                 }\n \n                 if drop_predicate && !in_where_clause {\n-                    lint_spans.push(span);\n+                    lint_spans.push(predicate_span);\n                 } else if drop_predicate && i + 1 < num_predicates {\n                     // If all the bounds on a predicate were inferable and there are\n                     // further predicates, we want to eat the trailing comma.\n                     let next_predicate_span = hir_generics.predicates[i + 1].span();\n-                    where_lint_spans.push(span.to(next_predicate_span.shrink_to_lo()));\n+                    where_lint_spans.push(predicate_span.to(next_predicate_span.shrink_to_lo()));\n                 } else {\n                     where_lint_spans.extend(self.consolidate_outlives_bound_spans(\n-                        span.shrink_to_lo(),\n+                        predicate_span.shrink_to_lo(),\n                         bounds,\n                         bound_spans,\n                     ));\n@@ -2384,24 +2385,35 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n                     } else {\n                         hir_generics.span.shrink_to_hi().to(where_span)\n                     };\n-                lint_spans.push(full_where_span);\n+\n+                // Due to macro expansions, the `full_where_span` might not actually contain all predicates.\n+                if where_lint_spans.iter().all(|&sp| full_where_span.contains(sp)) {\n+                    lint_spans.push(full_where_span);\n+                } else {\n+                    lint_spans.extend(where_lint_spans);\n+                }\n             } else {\n                 lint_spans.extend(where_lint_spans);\n             }\n \n             if !lint_spans.is_empty() {\n+                // Do not automatically delete outlives requirements from macros.\n+                let applicability = if lint_spans.iter().all(|sp| sp.can_be_used_for_suggestions())\n+                {\n+                    Applicability::MachineApplicable\n+                } else {\n+                    Applicability::MaybeIncorrect\n+                };\n+\n                 cx.struct_span_lint(\n                     EXPLICIT_OUTLIVES_REQUIREMENTS,\n                     lint_spans.clone(),\n                     fluent::lint_builtin_explicit_outlives,\n                     |lint| {\n                         lint.set_arg(\"count\", bound_count).multipart_suggestion(\n                             fluent::suggestion,\n-                            lint_spans\n-                                .into_iter()\n-                                .map(|span| (span, String::new()))\n-                                .collect::<Vec<_>>(),\n-                            Applicability::MachineApplicable,\n+                            lint_spans.into_iter().map(|span| (span, String::new())).collect(),\n+                            applicability,\n                         )\n                     },\n                 );"}, {"sha": "8cdb08e81b907510778ca216879214f4a7df3990", "filename": "src/test/ui/rust-2018/edition-lint-infer-outlives-macro.fixed", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/1eba6c404fa3e64607fc3826214bd61ae10fa5bb/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-macro.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/1eba6c404fa3e64607fc3826214bd61ae10fa5bb/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-macro.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-macro.fixed?ref=1eba6c404fa3e64607fc3826214bd61ae10fa5bb", "patch": "@@ -0,0 +1,137 @@\n+// edition:2018\n+// aux-build:edition-lint-infer-outlives-macro.rs\n+// run-rustfix\n+\n+#![deny(explicit_outlives_requirements)]\n+#![allow(dead_code)]\n+\n+#[macro_use]\n+extern crate edition_lint_infer_outlives_macro;\n+\n+// Test that the lint does not fire if the predicate is from the local crate,\n+// but all the bounds are from an external macro.\n+macro_rules! make_foo {\n+    ($a:tt) => {\n+        struct Foo<$a, 'b: $a> {\n+            foo: &$a &'b (),\n+        }\n+\n+        struct FooWhere<$a, 'b> where 'b: $a {\n+            foo: &$a &'b (),\n+        }\n+    }\n+}\n+\n+gimme_a! {make_foo!}\n+\n+struct Bar<'a, 'b> {\n+    //~^ ERROR: outlives requirements can be inferred\n+    bar: &'a &'b (),\n+}\n+\n+struct BarWhere<'a, 'b> {\n+    //~^ ERROR: outlives requirements can be inferred\n+    bar: &'a &'b (),\n+}\n+\n+// Test that the lint *does* fire if the predicate is contained in a local macro.\n+mod everything_inside {\n+    macro_rules! m {\n+        ('b: 'a) => {\n+            struct Foo<'a, 'b>(&'a &'b ());\n+            //~^ ERROR: outlives requirements can be inferred\n+            struct Bar<'a, 'b>(&'a &'b ()) ;\n+            //~^ ERROR: outlives requirements can be inferred\n+            struct Baz<'a, 'b>(&'a &'b ()) where (): Sized, ;\n+            //~^ ERROR: outlives requirements can be inferred\n+        };\n+    }\n+    m!('b: 'a);\n+}\n+\n+mod inner_lifetime_outside_colon_inside {\n+    macro_rules! m {\n+        ($b:lifetime: 'a) => {\n+            struct Foo<'a, $b>(&'a &$b ());\n+            //~^ ERROR: outlives requirements can be inferred\n+            struct Bar<'a, $b>(&'a &$b ()) ;\n+            //~^ ERROR: outlives requirements can be inferred\n+            struct Baz<'a, $b>(&'a &$b ()) where (): Sized, ;\n+            //~^ ERROR: outlives requirements can be inferred\n+        }\n+    }\n+    m!('b: 'a);\n+}\n+\n+mod outer_lifetime_outside_colon_inside {\n+    macro_rules! m {\n+        ('b: $a:lifetime) => {\n+            struct Foo<$a, 'b: $a>(&$a &'b ());\n+            struct Bar<$a, 'b>(&$a &'b ()) where 'b: $a;\n+            struct Baz<$a, 'b>(&$a &'b ()) where (): Sized, 'b: $a;\n+        }\n+    }\n+    m!('b: 'a);\n+}\n+\n+mod both_lifetimes_outside_colon_inside {\n+    macro_rules! m {\n+        ($b:lifetime: $a:lifetime) => {\n+            struct Foo<$a, $b: $a>(&$a &$b ());\n+            struct Bar<$a, $b>(&$a &$b ()) where $b: $a;\n+            struct Baz<$a, $b>(&$a &$b ()) where (): Sized, $b: $a;\n+        }\n+    }\n+    m!('b: 'a);\n+}\n+\n+mod everything_outside {\n+    macro_rules! m {\n+        ($b:lifetime $colon:tt $a:lifetime) => {\n+            struct Foo<$a, $b $colon $a>(&$a &$b ());\n+            struct Bar<$a, $b>(&$a &$b ()) where $b $colon $a;\n+            struct Baz<$a, $b>(&$a &$b ()) where (): Sized, $b $colon $a;\n+        }\n+    }\n+    m!('b: 'a);\n+}\n+\n+mod everything_outside_with_tt_inner {\n+    macro_rules! m {\n+        ($b:tt $colon:tt $a:lifetime) => {\n+            struct Foo<$a, $b $colon $a>(&$a &$b ());\n+            struct Bar<$a, $b>(&$a &$b ()) where $b $colon $a;\n+            struct Baz<$a, $b>(&$a &$b ()) where (): Sized, $b $colon $a;\n+        }\n+    }\n+    m!('b: 'a);\n+}\n+\n+// FIXME: These should be consistent.\n+mod everything_outside_with_tt_outer {\n+    macro_rules! m {\n+        ($b:lifetime $colon:tt $a:tt) => {\n+            struct Foo<$a, $b >(&$a &$b ());\n+            //~^ ERROR: outlives requirements can be inferred\n+            struct Bar<$a, $b>(&$a &$b ()) where $b $colon $a;\n+            struct Baz<$a, $b>(&$a &$b ()) where (): Sized, $b $colon $a;\n+        }\n+    }\n+    m!('b: 'a);\n+}\n+\n+mod everything_outside_with_tt_both {\n+    macro_rules! m {\n+        ($b:tt $colon:tt $a:tt) => {\n+            struct Foo<$a, $b >(&$a &$b ());\n+            //~^ ERROR: outlives requirements can be inferred\n+            struct Bar<$a, $b>(&$a &$b ()) where ;\n+            //~^ ERROR: outlives requirements can be inferred\n+            struct Baz<$a, $b>(&$a &$b ()) where (): Sized, ;\n+            //~^ ERROR: outlives requirements can be inferred\n+        }\n+    }\n+    m!('b: 'a);\n+}\n+\n+fn main() {}"}, {"sha": "647906c2dc228366e713dc40217f98e907d5a8b1", "filename": "src/test/ui/rust-2018/edition-lint-infer-outlives-macro.rs", "status": "modified", "additions": 97, "deletions": 29, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/1eba6c404fa3e64607fc3826214bd61ae10fa5bb/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eba6c404fa3e64607fc3826214bd61ae10fa5bb/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-macro.rs?ref=1eba6c404fa3e64607fc3826214bd61ae10fa5bb", "patch": "@@ -1,25 +1,25 @@\n // edition:2018\n // aux-build:edition-lint-infer-outlives-macro.rs\n-\n-// Test that the lint does not fire if the where predicate\n-// is from the local crate, but all the bounds are from an\n-// external macro.\n+// run-rustfix\n \n #![deny(explicit_outlives_requirements)]\n+#![allow(dead_code)]\n \n #[macro_use]\n extern crate edition_lint_infer_outlives_macro;\n \n+// Test that the lint does not fire if the predicate is from the local crate,\n+// but all the bounds are from an external macro.\n macro_rules! make_foo {\n     ($a:tt) => {\n-        struct Foo<$a, 'b> where 'b: $a {\n+        struct Foo<$a, 'b: $a> {\n             foo: &$a &'b (),\n         }\n \n-        struct Foo2<$a, 'b: $a> {\n+        struct FooWhere<$a, 'b> where 'b: $a {\n             foo: &$a &'b (),\n         }\n-    };\n+    }\n }\n \n gimme_a! {make_foo!}\n@@ -29,41 +29,109 @@ struct Bar<'a, 'b: 'a> {\n     bar: &'a &'b (),\n }\n \n-macro_rules! make_quux {\n-    () => {\n-        struct Quux<'a, 'b> where 'b: 'a {\n+struct BarWhere<'a, 'b> where 'b: 'a {\n+    //~^ ERROR: outlives requirements can be inferred\n+    bar: &'a &'b (),\n+}\n+\n+// Test that the lint *does* fire if the predicate is contained in a local macro.\n+mod everything_inside {\n+    macro_rules! m {\n+        ('b: 'a) => {\n+            struct Foo<'a, 'b: 'a>(&'a &'b ());\n             //~^ ERROR: outlives requirements can be inferred\n-            baz: &'a &'b (),\n-        }\n+            struct Bar<'a, 'b>(&'a &'b ()) where 'b: 'a;\n+            //~^ ERROR: outlives requirements can be inferred\n+            struct Baz<'a, 'b>(&'a &'b ()) where (): Sized, 'b: 'a;\n+            //~^ ERROR: outlives requirements can be inferred\n+        };\n+    }\n+    m!('b: 'a);\n+}\n \n-        struct Quux2<'a, 'b: 'a> {\n+mod inner_lifetime_outside_colon_inside {\n+    macro_rules! m {\n+        ($b:lifetime: 'a) => {\n+            struct Foo<'a, $b: 'a>(&'a &$b ());\n             //~^ ERROR: outlives requirements can be inferred\n-            baz: &'a &'b (),\n+            struct Bar<'a, $b>(&'a &$b ()) where $b: 'a;\n+            //~^ ERROR: outlives requirements can be inferred\n+            struct Baz<'a, $b>(&'a &$b ()) where (): Sized, $b: 'a;\n+            //~^ ERROR: outlives requirements can be inferred\n+        }\n+    }\n+    m!('b: 'a);\n+}\n+\n+mod outer_lifetime_outside_colon_inside {\n+    macro_rules! m {\n+        ('b: $a:lifetime) => {\n+            struct Foo<$a, 'b: $a>(&$a &'b ());\n+            struct Bar<$a, 'b>(&$a &'b ()) where 'b: $a;\n+            struct Baz<$a, 'b>(&$a &'b ()) where (): Sized, 'b: $a;\n         }\n-    };\n+    }\n+    m!('b: 'a);\n }\n \n-make_quux!{}\n+mod both_lifetimes_outside_colon_inside {\n+    macro_rules! m {\n+        ($b:lifetime: $a:lifetime) => {\n+            struct Foo<$a, $b: $a>(&$a &$b ());\n+            struct Bar<$a, $b>(&$a &$b ()) where $b: $a;\n+            struct Baz<$a, $b>(&$a &$b ()) where (): Sized, $b: $a;\n+        }\n+    }\n+    m!('b: 'a);\n+}\n \n-macro_rules! make_baz {\n-    () => {\n-        make_baz!{ 'a }\n-    };\n-    ($a:lifetime) => {\n-        struct Baz<$a, 'b> where 'b: $a {\n-            baz: &$a &'b (),\n+mod everything_outside {\n+    macro_rules! m {\n+        ($b:lifetime $colon:tt $a:lifetime) => {\n+            struct Foo<$a, $b $colon $a>(&$a &$b ());\n+            struct Bar<$a, $b>(&$a &$b ()) where $b $colon $a;\n+            struct Baz<$a, $b>(&$a &$b ()) where (): Sized, $b $colon $a;\n         }\n+    }\n+    m!('b: 'a);\n+}\n \n-        struct Baz2<$a, 'b: $a> {\n-            baz: &$a &'b (),\n+mod everything_outside_with_tt_inner {\n+    macro_rules! m {\n+        ($b:tt $colon:tt $a:lifetime) => {\n+            struct Foo<$a, $b $colon $a>(&$a &$b ());\n+            struct Bar<$a, $b>(&$a &$b ()) where $b $colon $a;\n+            struct Baz<$a, $b>(&$a &$b ()) where (): Sized, $b $colon $a;\n         }\n-    };\n+    }\n+    m!('b: 'a);\n }\n \n-make_baz!{ 'a }\n+// FIXME: These should be consistent.\n+mod everything_outside_with_tt_outer {\n+    macro_rules! m {\n+        ($b:lifetime $colon:tt $a:tt) => {\n+            struct Foo<$a, $b $colon $a>(&$a &$b ());\n+            //~^ ERROR: outlives requirements can be inferred\n+            struct Bar<$a, $b>(&$a &$b ()) where $b $colon $a;\n+            struct Baz<$a, $b>(&$a &$b ()) where (): Sized, $b $colon $a;\n+        }\n+    }\n+    m!('b: 'a);\n+}\n \n-mod baz {\n-    make_baz!{}\n+mod everything_outside_with_tt_both {\n+    macro_rules! m {\n+        ($b:tt $colon:tt $a:tt) => {\n+            struct Foo<$a, $b $colon $a>(&$a &$b ());\n+            //~^ ERROR: outlives requirements can be inferred\n+            struct Bar<$a, $b>(&$a &$b ()) where $b $colon $a;\n+            //~^ ERROR: outlives requirements can be inferred\n+            struct Baz<$a, $b>(&$a &$b ()) where (): Sized, $b $colon $a;\n+            //~^ ERROR: outlives requirements can be inferred\n+        }\n+    }\n+    m!('b: 'a);\n }\n \n fn main() {}"}, {"sha": "734ae687978936e022a177b7be164aee75d60f4a", "filename": "src/test/ui/rust-2018/edition-lint-infer-outlives-macro.stderr", "status": "modified", "additions": 88, "deletions": 14, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/1eba6c404fa3e64607fc3826214bd61ae10fa5bb/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1eba6c404fa3e64607fc3826214bd61ae10fa5bb/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Fedition-lint-infer-outlives-macro.stderr?ref=1eba6c404fa3e64607fc3826214bd61ae10fa5bb", "patch": "@@ -5,32 +5,106 @@ LL | struct Bar<'a, 'b: 'a> {\n    |                  ^^^^ help: remove this bound\n    |\n note: the lint level is defined here\n-  --> $DIR/edition-lint-infer-outlives-macro.rs:8:9\n+  --> $DIR/edition-lint-infer-outlives-macro.rs:5:9\n    |\n LL | #![deny(explicit_outlives_requirements)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives-macro.rs:34:28\n+  --> $DIR/edition-lint-infer-outlives-macro.rs:32:24\n    |\n-LL |         struct Quux<'a, 'b> where 'b: 'a {\n-   |                            ^^^^^^^^^^^^^ help: remove this bound\n+LL | struct BarWhere<'a, 'b> where 'b: 'a {\n+   |                        ^^^^^^^^^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-macro.rs:41:30\n+   |\n+LL |             struct Foo<'a, 'b: 'a>(&'a &'b ());\n+   |                              ^^^^ help: remove this bound\n+...\n+LL |     m!('b: 'a);\n+   |     ---------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `m` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-macro.rs:43:44\n+   |\n+LL |             struct Bar<'a, 'b>(&'a &'b ()) where 'b: 'a;\n+   |                                            ^^^^^^^^^^^^ help: remove this bound\n+...\n+LL |     m!('b: 'a);\n+   |     ---------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `m` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-macro.rs:45:61\n+   |\n+LL |             struct Baz<'a, 'b>(&'a &'b ()) where (): Sized, 'b: 'a;\n+   |                                                             ^^^^^^ help: remove this bound\n+...\n+LL |     m!('b: 'a);\n+   |     ---------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `m` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-macro.rs:55:30\n+   |\n+LL |             struct Foo<'a, $b: 'a>(&'a &$b ());\n+   |                              ^^^^ help: remove this bound\n ...\n-LL | make_quux!{}\n-   | ------------ in this macro invocation\n+LL |     m!('b: 'a);\n+   |     ---------- in this macro invocation\n    |\n-   = note: this error originates in the macro `make_quux` (in Nightly builds, run with -Z macro-backtrace for more info)\n+   = note: this error originates in the macro `m` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: outlives requirements can be inferred\n-  --> $DIR/edition-lint-infer-outlives-macro.rs:39:28\n+  --> $DIR/edition-lint-infer-outlives-macro.rs:57:44\n    |\n-LL |         struct Quux2<'a, 'b: 'a> {\n-   |                            ^^^^ help: remove this bound\n+LL |             struct Bar<'a, $b>(&'a &$b ()) where $b: 'a;\n+   |                                            ^^^^^^^^^^^^ help: remove this bound\n ...\n-LL | make_quux!{}\n-   | ------------ in this macro invocation\n+LL |     m!('b: 'a);\n+   |     ---------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `m` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-macro.rs:59:61\n+   |\n+LL |             struct Baz<'a, $b>(&'a &$b ()) where (): Sized, $b: 'a;\n+   |                                                             ^^^^^^ help: remove this bound\n+...\n+LL |     m!('b: 'a);\n+   |     ---------- in this macro invocation\n+   |\n+   = note: this error originates in the macro `m` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-macro.rs:114:31\n+   |\n+LL |             struct Foo<$a, $b $colon $a>(&$a &$b ());\n+   |                               ^^^^^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-macro.rs:126:31\n+   |\n+LL |             struct Foo<$a, $b $colon $a>(&$a &$b ());\n+   |                               ^^^^^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-macro.rs:128:50\n+   |\n+LL |             struct Bar<$a, $b>(&$a &$b ()) where $b $colon $a;\n+   |                                                  ^^^^^^^^^^^^ help: remove this bound\n+\n+error: outlives requirements can be inferred\n+  --> $DIR/edition-lint-infer-outlives-macro.rs:130:61\n    |\n-   = note: this error originates in the macro `make_quux` (in Nightly builds, run with -Z macro-backtrace for more info)\n+LL |             struct Baz<$a, $b>(&$a &$b ()) where (): Sized, $b $colon $a;\n+   |                                                             ^^^^^^^^^^^^ help: remove this bound\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 12 previous errors\n "}]}