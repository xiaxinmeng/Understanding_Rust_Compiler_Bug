{"sha": "c446cb086bfaf098730b310d386853adf7f5240a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0NDZjYjA4NmJmYWYwOTg3MzBiMzEwZDM4Njg1M2FkZjdmNTI0MGE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-04-14T19:30:06Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-04-21T21:26:53Z"}, "message": "just take `tcx` where we can\n\nThe more we can things dependent on just tcx, the easier it will\nbe to make queries etc later on.", "tree": {"sha": "6ebbcabc1f4f64ceca16063395e864f7fbc60d8e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ebbcabc1f4f64ceca16063395e864f7fbc60d8e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c446cb086bfaf098730b310d386853adf7f5240a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c446cb086bfaf098730b310d386853adf7f5240a", "html_url": "https://github.com/rust-lang/rust/commit/c446cb086bfaf098730b310d386853adf7f5240a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c446cb086bfaf098730b310d386853adf7f5240a/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39a58c38a0b9ac9e822a1732f073abe8ddf65cfb", "url": "https://api.github.com/repos/rust-lang/rust/commits/39a58c38a0b9ac9e822a1732f073abe8ddf65cfb", "html_url": "https://github.com/rust-lang/rust/commit/39a58c38a0b9ac9e822a1732f073abe8ddf65cfb"}], "stats": {"total": 128, "additions": 62, "deletions": 66}, "files": [{"sha": "221c52141a8323de0193f3d2a926599df704a5b9", "filename": "src/librustc_trans/back/symbol_export.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c446cb086bfaf098730b310d386853adf7f5240a/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c446cb086bfaf098730b310d386853adf7f5240a/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs?ref=c446cb086bfaf098730b310d386853adf7f5240a", "patch": "@@ -53,7 +53,7 @@ impl ExportedSymbols {\n                 scx.tcx().hir.local_def_id(node_id)\n             })\n             .map(|def_id| {\n-                let name = symbol_for_def_id(scx, def_id, symbol_map);\n+                let name = symbol_for_def_id(scx.tcx(), def_id, symbol_map);\n                 let export_level = export_level(scx, def_id);\n                 debug!(\"EXPORTED SYMBOL (local): {} ({:?})\", name, export_level);\n                 (name, export_level)\n@@ -108,7 +108,7 @@ impl ExportedSymbols {\n                 .exported_symbols(cnum)\n                 .iter()\n                 .map(|&def_id| {\n-                    let name = symbol_name(Instance::mono(scx.tcx(), def_id), scx);\n+                    let name = symbol_name(Instance::mono(scx.tcx(), def_id), scx.tcx());\n                     let export_level = if special_runtime_crate {\n                         // We can probably do better here by just ensuring that\n                         // it has hidden visibility rather than public\n@@ -214,21 +214,21 @@ pub fn is_below_threshold(level: SymbolExportLevel,\n     }\n }\n \n-fn symbol_for_def_id<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+fn symbol_for_def_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                def_id: DefId,\n                                symbol_map: &SymbolMap<'tcx>)\n                                -> String {\n     // Just try to look things up in the symbol map. If nothing's there, we\n     // recompute.\n-    if let Some(node_id) = scx.tcx().hir.as_local_node_id(def_id) {\n+    if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n         if let Some(sym) = symbol_map.get(TransItem::Static(node_id)) {\n             return sym.to_owned();\n         }\n     }\n \n-    let instance = Instance::mono(scx.tcx(), def_id);\n+    let instance = Instance::mono(tcx, def_id);\n \n     symbol_map.get(TransItem::Fn(instance))\n               .map(str::to_owned)\n-              .unwrap_or_else(|| symbol_name(instance, scx))\n+              .unwrap_or_else(|| symbol_name(instance, tcx))\n }"}, {"sha": "61b95f098adbd2e325c2ae168d4e95f8e055fb4b", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 25, "deletions": 28, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/c446cb086bfaf098730b310d386853adf7f5240a/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c446cb086bfaf098730b310d386853adf7f5240a/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=c446cb086bfaf098730b310d386853adf7f5240a", "patch": "@@ -97,13 +97,12 @@\n //! virtually impossible. Thus, symbol hash generation exclusively relies on\n //! DefPaths which are much more robust in the face of changes to the code base.\n \n-use common::SharedCrateContext;\n use monomorphize::Instance;\n \n use rustc::middle::weak_lang_items;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map as hir_map;\n-use rustc::ty::{self, Ty, TypeFoldable};\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::fold::TypeVisitor;\n use rustc::ty::item_path::{self, ItemPathBuffer, RootMode};\n use rustc::ty::subst::Substs;\n@@ -113,7 +112,7 @@ use rustc::util::common::record_time;\n use syntax::attr;\n use syntax::symbol::{Symbol, InternedString};\n \n-fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+fn get_symbol_hash<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n                              // the DefId of the item this name is for\n                              def_id: Option<DefId>,\n@@ -130,8 +129,6 @@ fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                              -> String {\n     debug!(\"get_symbol_hash(def_id={:?}, parameters={:?})\", def_id, substs);\n \n-    let tcx = scx.tcx();\n-\n     let mut hasher = ty::util::TypeIdHasher::<u64>::new(tcx);\n \n     record_time(&tcx.sess.perf_stats.symbol_hash_time, || {\n@@ -157,8 +154,8 @@ fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n             // in case the same instances is emitted in two crates of the same\n             // project.\n             if substs.types().next().is_some() {\n-                hasher.hash(scx.tcx().crate_name.as_str());\n-                hasher.hash(scx.sess().local_crate_disambiguator().as_str());\n+                hasher.hash(tcx.crate_name.as_str());\n+                hasher.hash(tcx.sess.local_crate_disambiguator().as_str());\n             }\n         }\n     });\n@@ -168,37 +165,37 @@ fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n }\n \n pub fn symbol_name<'a, 'tcx>(instance: Instance<'tcx>,\n-                             scx: &SharedCrateContext<'a, 'tcx>) -> String {\n+                             tcx: TyCtxt<'a, 'tcx, 'tcx>) -> String {\n     let def_id = instance.def_id();\n     let substs = instance.substs;\n \n     debug!(\"symbol_name(def_id={:?}, substs={:?})\",\n            def_id, substs);\n \n-    let node_id = scx.tcx().hir.as_local_node_id(def_id);\n+    let node_id = tcx.hir.as_local_node_id(def_id);\n \n     if let Some(id) = node_id {\n-        if scx.sess().plugin_registrar_fn.get() == Some(id) {\n+        if tcx.sess.plugin_registrar_fn.get() == Some(id) {\n             let idx = def_id.index;\n-            let disambiguator = scx.sess().local_crate_disambiguator();\n-            return scx.sess().generate_plugin_registrar_symbol(disambiguator, idx);\n+            let disambiguator = tcx.sess.local_crate_disambiguator();\n+            return tcx.sess.generate_plugin_registrar_symbol(disambiguator, idx);\n         }\n-        if scx.sess().derive_registrar_fn.get() == Some(id) {\n+        if tcx.sess.derive_registrar_fn.get() == Some(id) {\n             let idx = def_id.index;\n-            let disambiguator = scx.sess().local_crate_disambiguator();\n-            return scx.sess().generate_derive_registrar_symbol(disambiguator, idx);\n+            let disambiguator = tcx.sess.local_crate_disambiguator();\n+            return tcx.sess.generate_derive_registrar_symbol(disambiguator, idx);\n         }\n     }\n \n     // FIXME(eddyb) Precompute a custom symbol name based on attributes.\n-    let attrs = scx.tcx().get_attrs(def_id);\n+    let attrs = tcx.get_attrs(def_id);\n     let is_foreign = if let Some(id) = node_id {\n-        match scx.tcx().hir.get(id) {\n+        match tcx.hir.get(id) {\n             hir_map::NodeForeignItem(_) => true,\n             _ => false\n         }\n     } else {\n-        scx.sess().cstore.is_foreign_item(def_id)\n+        tcx.sess.cstore.is_foreign_item(def_id)\n     };\n \n     if let Some(name) = weak_lang_items::link_name(&attrs) {\n@@ -210,17 +207,17 @@ pub fn symbol_name<'a, 'tcx>(instance: Instance<'tcx>,\n             return name.to_string();\n         }\n         // Don't mangle foreign items.\n-        return scx.tcx().item_name(def_id).as_str().to_string();\n+        return tcx.item_name(def_id).as_str().to_string();\n     }\n \n-    if let Some(name) = attr::find_export_name_attr(scx.sess().diagnostic(), &attrs) {\n+    if let Some(name) = attr::find_export_name_attr(tcx.sess.diagnostic(), &attrs) {\n         // Use provided name\n         return name.to_string();\n     }\n \n     if attr::contains_name(&attrs, \"no_mangle\") {\n         // Don't mangle\n-        return scx.tcx().item_name(def_id).as_str().to_string();\n+        return tcx.item_name(def_id).as_str().to_string();\n     }\n \n     // We want to compute the \"type\" of this item. Unfortunately, some\n@@ -230,11 +227,11 @@ pub fn symbol_name<'a, 'tcx>(instance: Instance<'tcx>,\n     let mut ty_def_id = def_id;\n     let instance_ty;\n     loop {\n-        let key = scx.tcx().def_key(ty_def_id);\n+        let key = tcx.def_key(ty_def_id);\n         match key.disambiguated_data.data {\n             DefPathData::TypeNs(_) |\n             DefPathData::ValueNs(_) => {\n-                instance_ty = scx.tcx().item_type(ty_def_id);\n+                instance_ty = tcx.item_type(ty_def_id);\n                 break;\n             }\n             _ => {\n@@ -251,16 +248,16 @@ pub fn symbol_name<'a, 'tcx>(instance: Instance<'tcx>,\n \n     // Erase regions because they may not be deterministic when hashed\n     // and should not matter anyhow.\n-    let instance_ty = scx.tcx().erase_regions(&instance_ty);\n+    let instance_ty = tcx.erase_regions(&instance_ty);\n \n-    let hash = get_symbol_hash(scx, Some(def_id), instance_ty, Some(substs));\n+    let hash = get_symbol_hash(tcx, Some(def_id), instance_ty, Some(substs));\n \n     let mut buffer = SymbolPathBuffer {\n         names: Vec::new()\n     };\n \n     item_path::with_forced_absolute_paths(|| {\n-        scx.tcx().push_item_path(&mut buffer, def_id);\n+        tcx.push_item_path(&mut buffer, def_id);\n     });\n \n     mangle(buffer.names.into_iter(), &hash)\n@@ -281,11 +278,11 @@ impl ItemPathBuffer for SymbolPathBuffer {\n     }\n }\n \n-pub fn exported_name_from_type_and_prefix<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n+pub fn exported_name_from_type_and_prefix<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                     t: Ty<'tcx>,\n                                                     prefix: &str)\n                                                     -> String {\n-    let hash = get_symbol_hash(scx, None, t, None);\n+    let hash = get_symbol_hash(tcx, None, t, None);\n     let path = [Symbol::intern(prefix).as_str()];\n     mangle(path.iter().cloned(), &hash)\n }"}, {"sha": "8ee5627e6893b04271a6e96ba469ea9c065414d1", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c446cb086bfaf098730b310d386853adf7f5240a/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c446cb086bfaf098730b310d386853adf7f5240a/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=c446cb086bfaf098730b310d386853adf7f5240a", "patch": "@@ -1139,7 +1139,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         let cgu_name = String::from(cgu.name());\n         let cgu_id = cgu.work_product_id();\n-        let symbol_cache = SymbolCache::new(scx);\n+        let symbol_cache = SymbolCache::new(scx.tcx());\n         let symbol_name_hash = cgu.compute_symbol_name_hash(scx, &symbol_cache);\n \n         // Check whether there is a previous work-product we can\n@@ -1239,7 +1239,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     assert_module_sources::assert_module_sources(tcx, &modules);\n \n-    symbol_names_test::report_symbol_names(&shared_ccx);\n+    symbol_names_test::report_symbol_names(tcx);\n \n     if shared_ccx.sess().trans_stats() {\n         println!(\"--- trans stats ---\");"}, {"sha": "3d614cfbcbf3c5c5f961a0d8b5b361c2df6274e2", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c446cb086bfaf098730b310d386853adf7f5240a/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c446cb086bfaf098730b310d386853adf7f5240a/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=c446cb086bfaf098730b310d386853adf7f5240a", "patch": "@@ -113,7 +113,7 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n             hir_map::NodeForeignItem(&hir::ForeignItem {\n                 ref attrs, span, node: hir::ForeignItemStatic(..), ..\n             }) => {\n-                let sym = symbol_names::symbol_name(instance, ccx.shared());\n+                let sym = symbol_names::symbol_name(instance, ccx.tcx());\n                 let g = if let Some(name) =\n                         attr::first_attr_value_str_by_name(&attrs, \"linkage\") {\n                     // If this is a static with a linkage specified, then we need to handle\n@@ -173,7 +173,7 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n \n         g\n     } else {\n-        let sym = symbol_names::symbol_name(instance, ccx.shared());\n+        let sym = symbol_names::symbol_name(instance, ccx.tcx());\n \n         // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n         // FIXME(nagisa): investigate whether it can be changed into define_global"}, {"sha": "6b89d11cfb68f161e9356ba6934a46e943f306bc", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c446cb086bfaf098730b310d386853adf7f5240a/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c446cb086bfaf098730b310d386853adf7f5240a/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=c446cb086bfaf098730b310d386853adf7f5240a", "patch": "@@ -177,7 +177,7 @@ impl<'tcx> CodegenUnit<'tcx> {\n     pub fn compute_symbol_name_hash<'a>(&self,\n                                         scx: &SharedCrateContext<'a, 'tcx>,\n                                         symbol_cache: &SymbolCache<'a, 'tcx>)\n-                                    -> u64 {\n+                                        -> u64 {\n         let mut state = IchHasher::new();\n         let exported_symbols = scx.exported_symbols();\n         let all_items = self.items_in_deterministic_order(scx.tcx(), symbol_cache);\n@@ -272,14 +272,14 @@ pub fn partition<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n     let mut initial_partitioning = place_root_translation_items(scx,\n                                                                 trans_items);\n \n-    debug_dump(scx, \"INITIAL PARTITONING:\", initial_partitioning.codegen_units.iter());\n+    debug_dump(tcx, \"INITIAL PARTITONING:\", initial_partitioning.codegen_units.iter());\n \n     // If the partitioning should produce a fixed count of codegen units, merge\n     // until that count is reached.\n     if let PartitioningStrategy::FixedUnitCount(count) = strategy {\n         merge_codegen_units(&mut initial_partitioning, count, &tcx.crate_name.as_str());\n \n-        debug_dump(scx, \"POST MERGING:\", initial_partitioning.codegen_units.iter());\n+        debug_dump(tcx, \"POST MERGING:\", initial_partitioning.codegen_units.iter());\n     }\n \n     // In the next step, we use the inlining map to determine which addtional\n@@ -289,7 +289,7 @@ pub fn partition<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n     let post_inlining = place_inlined_translation_items(initial_partitioning,\n                                                         inlining_map);\n \n-    debug_dump(scx, \"POST INLINING:\", post_inlining.0.iter());\n+    debug_dump(tcx, \"POST INLINING:\", post_inlining.0.iter());\n \n     // Finally, sort by codegen unit name, so that we get deterministic results\n     let mut result = post_inlining.0;\n@@ -529,15 +529,15 @@ fn numbered_codegen_unit_name(crate_name: &str, index: usize) -> InternedString\n     Symbol::intern(&format!(\"{}{}{}\", crate_name, NUMBERED_CODEGEN_UNIT_MARKER, index)).as_str()\n }\n \n-fn debug_dump<'a, 'b, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n+fn debug_dump<'a, 'b, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                label: &str,\n                                cgus: I)\n     where I: Iterator<Item=&'b CodegenUnit<'tcx>>,\n           'tcx: 'a + 'b\n {\n     if cfg!(debug_assertions) {\n         debug!(\"{}\", label);\n-        let symbol_cache = SymbolCache::new(scx);\n+        let symbol_cache = SymbolCache::new(tcx);\n         for cgu in cgus {\n             debug!(\"CodegenUnit {}:\", cgu.name);\n \n@@ -548,7 +548,7 @@ fn debug_dump<'a, 'b, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n                                                    .unwrap_or(\"<no hash>\");\n \n                 debug!(\" - {} [{:?}] [{}]\",\n-                       trans_item.to_string(scx.tcx()),\n+                       trans_item.to_string(tcx),\n                        linkage,\n                        symbol_hash);\n             }"}, {"sha": "a838c3a2c4cb55778bb12297e0e28ec2c1736ee3", "filename": "src/librustc_trans/symbol_cache.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c446cb086bfaf098730b310d386853adf7f5240a/src%2Flibrustc_trans%2Fsymbol_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c446cb086bfaf098730b310d386853adf7f5240a/src%2Flibrustc_trans%2Fsymbol_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsymbol_cache.rs?ref=c446cb086bfaf098730b310d386853adf7f5240a", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use context::SharedCrateContext;\n use std::cell::RefCell;\n use std::rc::Rc;\n+use rustc::ty::TyCtxt;\n use trans_item::TransItem;\n use util::nodemap::FxHashMap;\n \n@@ -21,22 +21,22 @@ use util::nodemap::FxHashMap;\n // Thus they can always be recomputed if needed.\n \n pub struct SymbolCache<'a, 'tcx: 'a> {\n-    scx: &'a SharedCrateContext<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     index: RefCell<FxHashMap<TransItem<'tcx>, Rc<String>>>,\n }\n \n impl<'a, 'tcx> SymbolCache<'a, 'tcx> {\n-    pub fn new(scx: &'a SharedCrateContext<'a, 'tcx>) -> Self {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n         SymbolCache {\n-            scx,\n+            tcx: tcx,\n             index: RefCell::new(FxHashMap())\n         }\n     }\n \n     pub fn get(&self, trans_item: TransItem<'tcx>) -> Rc<String> {\n         let mut index = self.index.borrow_mut();\n         index.entry(trans_item)\n-             .or_insert_with(|| Rc::new(trans_item.compute_symbol_name(self.scx)))\n+             .or_insert_with(|| Rc::new(trans_item.compute_symbol_name(self.tcx)))\n              .clone()\n     }\n }"}, {"sha": "9d3e62888a2df1fadb22b8088c4d2a2de74875a2", "filename": "src/librustc_trans/symbol_map.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c446cb086bfaf098730b310d386853adf7f5240a/src%2Flibrustc_trans%2Fsymbol_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c446cb086bfaf098730b310d386853adf7f5240a/src%2Flibrustc_trans%2Fsymbol_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsymbol_map.rs?ref=c446cb086bfaf098730b310d386853adf7f5240a", "patch": "@@ -34,8 +34,9 @@ impl<'tcx> SymbolMap<'tcx> {\n         where I: Iterator<Item=TransItem<'tcx>>\n     {\n         // Check for duplicate symbol names\n+        let tcx = scx.tcx();\n         let mut symbols: Vec<_> = trans_items.map(|trans_item| {\n-            (trans_item, trans_item.compute_symbol_name(scx))\n+            (trans_item, trans_item.compute_symbol_name(tcx))\n         }).collect();\n \n         (&mut symbols[..]).sort_by(|&(_, ref sym1), &(_, ref sym2)|{\n@@ -124,7 +125,7 @@ impl<'tcx> SymbolMap<'tcx> {\n         if let Some(sym) = self.get(trans_item) {\n             Cow::from(sym)\n         } else {\n-            Cow::from(trans_item.compute_symbol_name(scx))\n+            Cow::from(trans_item.compute_symbol_name(scx.tcx()))\n         }\n     }\n }"}, {"sha": "fd817cb94c1c1db1251d73e7ea84c6832a300d47", "filename": "src/librustc_trans/symbol_names_test.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c446cb086bfaf098730b310d386853adf7f5240a/src%2Flibrustc_trans%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c446cb086bfaf098730b310d386853adf7f5240a/src%2Flibrustc_trans%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsymbol_names_test.rs?ref=c446cb086bfaf098730b310d386853adf7f5240a", "patch": "@@ -17,43 +17,42 @@\n use back::symbol_names;\n use rustc::hir;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use rustc::ty::TyCtxt;\n use syntax::ast;\n \n-use common::SharedCrateContext;\n use monomorphize::Instance;\n \n const SYMBOL_NAME: &'static str = \"rustc_symbol_name\";\n const ITEM_PATH: &'static str = \"rustc_item_path\";\n \n-pub fn report_symbol_names(scx: &SharedCrateContext) {\n+pub fn report_symbol_names<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     // if the `rustc_attrs` feature is not enabled, then the\n     // attributes we are interested in cannot be present anyway, so\n     // skip the walk.\n-    let tcx = scx.tcx();\n     if !tcx.sess.features.borrow().rustc_attrs {\n         return;\n     }\n \n     let _ignore = tcx.dep_graph.in_ignore();\n-    let mut visitor = SymbolNamesTest { scx: scx };\n+    let mut visitor = SymbolNamesTest { tcx: tcx };\n     // FIXME(#37712) could use ItemLikeVisitor if trait items were item-like\n     tcx.hir.krate().visit_all_item_likes(&mut visitor.as_deep_visitor());\n }\n \n struct SymbolNamesTest<'a, 'tcx:'a> {\n-    scx: &'a SharedCrateContext<'a, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n impl<'a, 'tcx> SymbolNamesTest<'a, 'tcx> {\n     fn process_attrs(&mut self,\n                      node_id: ast::NodeId) {\n-        let tcx = self.scx.tcx();\n+        let tcx = self.tcx;\n         let def_id = tcx.hir.local_def_id(node_id);\n         for attr in tcx.get_attrs(def_id).iter() {\n             if attr.check_name(SYMBOL_NAME) {\n                 // for now, can only use on monomorphic names\n                 let instance = Instance::mono(tcx, def_id);\n-                let name = symbol_names::symbol_name(instance, self.scx);\n+                let name = symbol_names::symbol_name(instance, self.tcx);\n                 tcx.sess.span_err(attr.span, &format!(\"symbol-name({})\", name));\n             } else if attr.check_name(ITEM_PATH) {\n                 let path = tcx.item_path_str(def_id);"}, {"sha": "de35d1b7dd4c96330d46d06e479386e179c27a32", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c446cb086bfaf098730b310d386853adf7f5240a/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c446cb086bfaf098730b310d386853adf7f5240a/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=c446cb086bfaf098730b310d386853adf7f5240a", "patch": "@@ -18,7 +18,7 @@ use asm;\n use attributes;\n use base;\n use consts;\n-use context::{CrateContext, SharedCrateContext};\n+use context::CrateContext;\n use common;\n use declare;\n use llvm;\n@@ -184,16 +184,15 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         ccx.instances().borrow_mut().insert(instance, lldecl);\n     }\n \n-    pub fn compute_symbol_name(&self,\n-                               scx: &SharedCrateContext<'a, 'tcx>) -> String {\n+    pub fn compute_symbol_name(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> String {\n         match *self {\n-            TransItem::Fn(instance) => symbol_names::symbol_name(instance, scx),\n+            TransItem::Fn(instance) => symbol_names::symbol_name(instance, tcx),\n             TransItem::Static(node_id) => {\n-                let def_id = scx.tcx().hir.local_def_id(node_id);\n-                symbol_names::symbol_name(Instance::mono(scx.tcx(), def_id), scx)\n+                let def_id = tcx.hir.local_def_id(node_id);\n+                symbol_names::symbol_name(Instance::mono(tcx, def_id), tcx)\n             }\n             TransItem::GlobalAsm(node_id) => {\n-                let def_id = scx.tcx().hir.local_def_id(node_id);\n+                let def_id = tcx.hir.local_def_id(node_id);\n                 format!(\"global_asm_{:?}\", def_id)\n             }\n         }"}]}