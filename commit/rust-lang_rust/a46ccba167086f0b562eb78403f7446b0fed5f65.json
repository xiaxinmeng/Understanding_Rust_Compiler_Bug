{"sha": "a46ccba167086f0b562eb78403f7446b0fed5f65", "node_id": "C_kwDOAAsO6NoAKGE0NmNjYmExNjcwODZmMGI1NjJlYjc4NDAzZjc0NDZiMGZlZDVmNjU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-25T18:02:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-25T18:02:23Z"}, "message": "Auto merge of #2618 - RalfJung:rustup, r=RalfJung\n\nRustup", "tree": {"sha": "657acfd56be3293586f6d81d3e35ed543137b54c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/657acfd56be3293586f6d81d3e35ed543137b54c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a46ccba167086f0b562eb78403f7446b0fed5f65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a46ccba167086f0b562eb78403f7446b0fed5f65", "html_url": "https://github.com/rust-lang/rust/commit/a46ccba167086f0b562eb78403f7446b0fed5f65", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a46ccba167086f0b562eb78403f7446b0fed5f65/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cfd99a2bbe83ae35ad0eb9d963ca97cf6c34471a", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfd99a2bbe83ae35ad0eb9d963ca97cf6c34471a", "html_url": "https://github.com/rust-lang/rust/commit/cfd99a2bbe83ae35ad0eb9d963ca97cf6c34471a"}, {"sha": "5a5a3e4ef4b4c450991459415c0c7a963ba2d278", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a5a3e4ef4b4c450991459415c0c7a963ba2d278", "html_url": "https://github.com/rust-lang/rust/commit/5a5a3e4ef4b4c450991459415c0c7a963ba2d278"}], "stats": {"total": 31155, "additions": 20813, "deletions": 10342}, "files": [{"sha": "dab693419a95d7ac1c634b892c13bc2635256dd7", "filename": "Cargo.lock", "status": "modified", "additions": 47, "deletions": 10, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -1843,9 +1843,9 @@ dependencies = [\n \n [[package]]\n name = \"itertools\"\n-version = \"0.10.1\"\n+version = \"0.10.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"69ddb889f9d0d08a67338271fa9b62996bc788c7796a5c18cf057420aaed5eaf\"\n+checksum = \"b0fd2260e829bddf4cb6ea802289de2f86d6a7a690192fbe91b3f46e0f2c8473\"\n dependencies = [\n  \"either\",\n ]\n@@ -1935,9 +1935,9 @@ checksum = \"830d08ce1d1d941e6b30645f1a0eb5643013d835ce3779a5fc208261dbe10f55\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.131\"\n+version = \"0.2.135\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"04c3b4822ccebfa39c02fc03d1534441b22ead323fa0f48bb7ddd8e6ba076a40\"\n+checksum = \"68783febc7782c6c5cb401fbda4de5a9898be1762314da0bb2c10ced61f18b0c\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -3569,6 +3569,32 @@ dependencies = [\n  \"rustc_target\",\n ]\n \n+[[package]]\n+name = \"rustc_hir_typeck\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"rustc_ast\",\n+ \"rustc_data_structures\",\n+ \"rustc_errors\",\n+ \"rustc_graphviz\",\n+ \"rustc_hir\",\n+ \"rustc_hir_analysis\",\n+ \"rustc_hir_pretty\",\n+ \"rustc_index\",\n+ \"rustc_infer\",\n+ \"rustc_lint\",\n+ \"rustc_macros\",\n+ \"rustc_middle\",\n+ \"rustc_serialize\",\n+ \"rustc_session\",\n+ \"rustc_span\",\n+ \"rustc_target\",\n+ \"rustc_trait_selection\",\n+ \"rustc_type_ir\",\n+ \"smallvec\",\n+ \"tracing\",\n+]\n+\n [[package]]\n name = \"rustc_incremental\"\n version = \"0.0.0\"\n@@ -3638,6 +3664,7 @@ dependencies = [\n  \"rustc_expand\",\n  \"rustc_hir\",\n  \"rustc_hir_analysis\",\n+ \"rustc_hir_typeck\",\n  \"rustc_incremental\",\n  \"rustc_lint\",\n  \"rustc_macros\",\n@@ -4449,9 +4476,9 @@ dependencies = [\n \n [[package]]\n name = \"serde\"\n-version = \"1.0.143\"\n+version = \"1.0.147\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"53e8e5d5b70924f74ff5c6d64d9a5acd91422117c60f48c4e07855238a254553\"\n+checksum = \"d193d69bae983fc11a79df82342761dfbf28a99fc8d203dca4c3c1b590948965\"\n dependencies = [\n  \"serde_derive\",\n ]\n@@ -4468,9 +4495,9 @@ dependencies = [\n \n [[package]]\n name = \"serde_derive\"\n-version = \"1.0.143\"\n+version = \"1.0.147\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d3d8e8de557aee63c26b85b947f5e59b690d0454c753f3adeb5cd7835ab88391\"\n+checksum = \"4f1d362ca8fc9c3e3a7484440752472d68a6caa98f1ab81d99b5dfe517cec852\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -4953,17 +4980,27 @@ dependencies = [\n  \"serde\",\n ]\n \n+[[package]]\n+name = \"toml_datetime\"\n+version = \"0.5.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"808b51e57d0ef8f71115d8f3a01e7d3750d01c79cac4b3eda910f4389fdf92fd\"\n+dependencies = [\n+ \"serde\",\n+]\n+\n [[package]]\n name = \"toml_edit\"\n-version = \"0.14.3\"\n+version = \"0.15.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ba98375fd631b83696f87c64e4ed8e29e6a1f3404d6aed95fa95163bad38e705\"\n+checksum = \"b1541ba70885967e662f69d31ab3aeca7b1aaecfcd58679590b893e9239c3646\"\n dependencies = [\n  \"combine\",\n  \"indexmap\",\n  \"itertools\",\n  \"kstring\",\n  \"serde\",\n+ \"toml_datetime\",\n ]\n \n [[package]]"}, {"sha": "e21c9b660444083c001c5ca26c6087d956157a36", "filename": "compiler/rustc/src/main.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc%2Fsrc%2Fmain.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -1,3 +1,5 @@\n+#![feature(unix_sigpipe)]\n+\n // A note about jemalloc: rustc uses jemalloc when built for CI and\n // distribution. The obvious way to do this is with the `#[global_allocator]`\n // mechanism. However, for complicated reasons (see\n@@ -23,6 +25,7 @@\n // libraries. So we must reference jemalloc symbols one way or another, because\n // this file is the only object code in the rustc executable.\n \n+#[unix_sigpipe = \"sig_dfl\"]\n fn main() {\n     // See the comment at the top of this file for an explanation of this.\n     #[cfg(feature = \"jemalloc-sys\")]\n@@ -58,6 +61,5 @@ fn main() {\n         }\n     }\n \n-    rustc_driver::set_sigpipe_handler();\n     rustc_driver::main()\n }"}, {"sha": "157f46501e145eddc0c71f76c103cf6b53d33c1c", "filename": "compiler/rustc_ast_lowering/src/errors.rs", "status": "modified", "additions": 66, "deletions": 89, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Ferrors.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -1,12 +1,9 @@\n-use rustc_errors::{\n-    fluent, AddToDiagnostic, Applicability, Diagnostic, DiagnosticArgFromDisplay,\n-    SubdiagnosticMessage,\n-};\n+use rustc_errors::DiagnosticArgFromDisplay;\n use rustc_macros::{Diagnostic, Subdiagnostic};\n use rustc_span::{symbol::Ident, Span, Symbol};\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::generic_type_with_parentheses, code = \"E0214\")]\n+#[diag(ast_lowering_generic_type_with_parentheses, code = \"E0214\")]\n pub struct GenericTypeWithParentheses {\n     #[primary_span]\n     #[label]\n@@ -15,27 +12,17 @@ pub struct GenericTypeWithParentheses {\n     pub sub: Option<UseAngleBrackets>,\n }\n \n-#[derive(Clone, Copy)]\n+#[derive(Clone, Copy, Subdiagnostic)]\n+#[multipart_suggestion(ast_lowering_use_angle_brackets, applicability = \"maybe-incorrect\")]\n pub struct UseAngleBrackets {\n+    #[suggestion_part(code = \"<\")]\n     pub open_param: Span,\n+    #[suggestion_part(code = \">\")]\n     pub close_param: Span,\n }\n \n-impl AddToDiagnostic for UseAngleBrackets {\n-    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n-    where\n-        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n-    {\n-        diag.multipart_suggestion(\n-            fluent::ast_lowering::use_angle_brackets,\n-            vec![(self.open_param, String::from(\"<\")), (self.close_param, String::from(\">\"))],\n-            Applicability::MaybeIncorrect,\n-        );\n-    }\n-}\n-\n #[derive(Diagnostic)]\n-#[diag(ast_lowering::invalid_abi, code = \"E0703\")]\n+#[diag(ast_lowering_invalid_abi, code = \"E0703\")]\n #[note]\n pub struct InvalidAbi {\n     #[primary_span]\n@@ -49,7 +36,7 @@ pub struct InvalidAbi {\n \n #[derive(Subdiagnostic)]\n #[suggestion(\n-    ast_lowering::invalid_abi_suggestion,\n+    ast_lowering_invalid_abi_suggestion,\n     code = \"{suggestion}\",\n     applicability = \"maybe-incorrect\"\n )]\n@@ -60,134 +47,124 @@ pub struct InvalidAbiSuggestion {\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::assoc_ty_parentheses)]\n+#[diag(ast_lowering_assoc_ty_parentheses)]\n pub struct AssocTyParentheses {\n     #[primary_span]\n     pub span: Span,\n     #[subdiagnostic]\n     pub sub: AssocTyParenthesesSub,\n }\n \n-#[derive(Clone, Copy)]\n+#[derive(Clone, Copy, Subdiagnostic)]\n pub enum AssocTyParenthesesSub {\n-    Empty { parentheses_span: Span },\n-    NotEmpty { open_param: Span, close_param: Span },\n-}\n-\n-impl AddToDiagnostic for AssocTyParenthesesSub {\n-    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n-    where\n-        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n-    {\n-        match self {\n-            Self::Empty { parentheses_span } => diag.multipart_suggestion(\n-                fluent::ast_lowering::remove_parentheses,\n-                vec![(parentheses_span, String::new())],\n-                Applicability::MaybeIncorrect,\n-            ),\n-            Self::NotEmpty { open_param, close_param } => diag.multipart_suggestion(\n-                fluent::ast_lowering::use_angle_brackets,\n-                vec![(open_param, String::from(\"<\")), (close_param, String::from(\">\"))],\n-                Applicability::MaybeIncorrect,\n-            ),\n-        };\n-    }\n+    #[multipart_suggestion(ast_lowering_remove_parentheses)]\n+    Empty {\n+        #[suggestion_part(code = \"\")]\n+        parentheses_span: Span,\n+    },\n+    #[multipart_suggestion(ast_lowering_use_angle_brackets)]\n+    NotEmpty {\n+        #[suggestion_part(code = \"<\")]\n+        open_param: Span,\n+        #[suggestion_part(code = \">\")]\n+        close_param: Span,\n+    },\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_lowering::misplaced_impl_trait, code = \"E0562\")]\n+#[diag(ast_lowering_misplaced_impl_trait, code = \"E0562\")]\n pub struct MisplacedImplTrait<'a> {\n     #[primary_span]\n     pub span: Span,\n     pub position: DiagnosticArgFromDisplay<'a>,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::rustc_box_attribute_error)]\n+#[diag(ast_lowering_rustc_box_attribute_error)]\n pub struct RustcBoxAttributeError {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::underscore_expr_lhs_assign)]\n+#[diag(ast_lowering_underscore_expr_lhs_assign)]\n pub struct UnderscoreExprLhsAssign {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::base_expression_double_dot)]\n+#[diag(ast_lowering_base_expression_double_dot)]\n pub struct BaseExpressionDoubleDot {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::await_only_in_async_fn_and_blocks, code = \"E0728\")]\n+#[diag(ast_lowering_await_only_in_async_fn_and_blocks, code = \"E0728\")]\n pub struct AwaitOnlyInAsyncFnAndBlocks {\n     #[primary_span]\n     #[label]\n     pub dot_await_span: Span,\n-    #[label(ast_lowering::this_not_async)]\n+    #[label(ast_lowering_this_not_async)]\n     pub item_span: Option<Span>,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::generator_too_many_parameters, code = \"E0628\")]\n+#[diag(ast_lowering_generator_too_many_parameters, code = \"E0628\")]\n pub struct GeneratorTooManyParameters {\n     #[primary_span]\n     pub fn_decl_span: Span,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::closure_cannot_be_static, code = \"E0697\")]\n+#[diag(ast_lowering_closure_cannot_be_static, code = \"E0697\")]\n pub struct ClosureCannotBeStatic {\n     #[primary_span]\n     pub fn_decl_span: Span,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n #[help]\n-#[diag(ast_lowering::async_non_move_closure_not_supported, code = \"E0708\")]\n+#[diag(ast_lowering_async_non_move_closure_not_supported, code = \"E0708\")]\n pub struct AsyncNonMoveClosureNotSupported {\n     #[primary_span]\n     pub fn_decl_span: Span,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::functional_record_update_destructuring_assignment)]\n+#[diag(ast_lowering_functional_record_update_destructuring_assignment)]\n pub struct FunctionalRecordUpdateDestructuringAssignemnt {\n     #[primary_span]\n     #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n     pub span: Span,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::async_generators_not_supported, code = \"E0727\")]\n+#[diag(ast_lowering_async_generators_not_supported, code = \"E0727\")]\n pub struct AsyncGeneratorsNotSupported {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::inline_asm_unsupported_target, code = \"E0472\")]\n+#[diag(ast_lowering_inline_asm_unsupported_target, code = \"E0472\")]\n pub struct InlineAsmUnsupportedTarget {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::att_syntax_only_x86)]\n+#[diag(ast_lowering_att_syntax_only_x86)]\n pub struct AttSyntaxOnlyX86 {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::abi_specified_multiple_times)]\n+#[diag(ast_lowering_abi_specified_multiple_times)]\n pub struct AbiSpecifiedMultipleTimes {\n     #[primary_span]\n     pub abi_span: Span,\n@@ -199,23 +176,23 @@ pub struct AbiSpecifiedMultipleTimes {\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::clobber_abi_not_supported)]\n+#[diag(ast_lowering_clobber_abi_not_supported)]\n pub struct ClobberAbiNotSupported {\n     #[primary_span]\n     pub abi_span: Span,\n }\n \n #[derive(Diagnostic)]\n #[note]\n-#[diag(ast_lowering::invalid_abi_clobber_abi)]\n+#[diag(ast_lowering_invalid_abi_clobber_abi)]\n pub struct InvalidAbiClobberAbi {\n     #[primary_span]\n     pub abi_span: Span,\n     pub supported_abis: String,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::invalid_register)]\n+#[diag(ast_lowering_invalid_register)]\n pub struct InvalidRegister<'a> {\n     #[primary_span]\n     pub op_span: Span,\n@@ -224,7 +201,7 @@ pub struct InvalidRegister<'a> {\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::invalid_register_class)]\n+#[diag(ast_lowering_invalid_register_class)]\n pub struct InvalidRegisterClass<'a> {\n     #[primary_span]\n     pub op_span: Span,\n@@ -233,60 +210,60 @@ pub struct InvalidRegisterClass<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_lowering::invalid_asm_template_modifier_reg_class)]\n+#[diag(ast_lowering_invalid_asm_template_modifier_reg_class)]\n pub struct InvalidAsmTemplateModifierRegClass {\n     #[primary_span]\n-    #[label(ast_lowering::template_modifier)]\n+    #[label(ast_lowering_template_modifier)]\n     pub placeholder_span: Span,\n-    #[label(ast_lowering::argument)]\n+    #[label(ast_lowering_argument)]\n     pub op_span: Span,\n     #[subdiagnostic]\n     pub sub: InvalidAsmTemplateModifierRegClassSub,\n }\n \n #[derive(Subdiagnostic)]\n pub enum InvalidAsmTemplateModifierRegClassSub {\n-    #[note(ast_lowering::support_modifiers)]\n+    #[note(ast_lowering_support_modifiers)]\n     SupportModifier { class_name: Symbol, modifiers: String },\n-    #[note(ast_lowering::does_not_support_modifiers)]\n+    #[note(ast_lowering_does_not_support_modifiers)]\n     DoesNotSupportModifier { class_name: Symbol },\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::invalid_asm_template_modifier_const)]\n+#[diag(ast_lowering_invalid_asm_template_modifier_const)]\n pub struct InvalidAsmTemplateModifierConst {\n     #[primary_span]\n-    #[label(ast_lowering::template_modifier)]\n+    #[label(ast_lowering_template_modifier)]\n     pub placeholder_span: Span,\n-    #[label(ast_lowering::argument)]\n+    #[label(ast_lowering_argument)]\n     pub op_span: Span,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::invalid_asm_template_modifier_sym)]\n+#[diag(ast_lowering_invalid_asm_template_modifier_sym)]\n pub struct InvalidAsmTemplateModifierSym {\n     #[primary_span]\n-    #[label(ast_lowering::template_modifier)]\n+    #[label(ast_lowering_template_modifier)]\n     pub placeholder_span: Span,\n-    #[label(ast_lowering::argument)]\n+    #[label(ast_lowering_argument)]\n     pub op_span: Span,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::register_class_only_clobber)]\n+#[diag(ast_lowering_register_class_only_clobber)]\n pub struct RegisterClassOnlyClobber {\n     #[primary_span]\n     pub op_span: Span,\n     pub reg_class_name: Symbol,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::register_conflict)]\n+#[diag(ast_lowering_register_conflict)]\n pub struct RegisterConflict<'a> {\n     #[primary_span]\n-    #[label(ast_lowering::register1)]\n+    #[label(ast_lowering_register1)]\n     pub op_span1: Span,\n-    #[label(ast_lowering::register2)]\n+    #[label(ast_lowering_register2)]\n     pub op_span2: Span,\n     pub reg1_name: &'a str,\n     pub reg2_name: &'a str,\n@@ -296,12 +273,12 @@ pub struct RegisterConflict<'a> {\n \n #[derive(Diagnostic, Clone, Copy)]\n #[help]\n-#[diag(ast_lowering::sub_tuple_binding)]\n+#[diag(ast_lowering_sub_tuple_binding)]\n pub struct SubTupleBinding<'a> {\n     #[primary_span]\n     #[label]\n     #[suggestion_verbose(\n-        ast_lowering::sub_tuple_binding_suggestion,\n+        ast_lowering_sub_tuple_binding_suggestion,\n         code = \"..\",\n         applicability = \"maybe-incorrect\"\n     )]\n@@ -312,56 +289,56 @@ pub struct SubTupleBinding<'a> {\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::extra_double_dot)]\n+#[diag(ast_lowering_extra_double_dot)]\n pub struct ExtraDoubleDot<'a> {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[label(ast_lowering::previously_used_here)]\n+    #[label(ast_lowering_previously_used_here)]\n     pub prev_span: Span,\n     pub ctx: &'a str,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n #[note]\n-#[diag(ast_lowering::misplaced_double_dot)]\n+#[diag(ast_lowering_misplaced_double_dot)]\n pub struct MisplacedDoubleDot {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::misplaced_relax_trait_bound)]\n+#[diag(ast_lowering_misplaced_relax_trait_bound)]\n pub struct MisplacedRelaxTraitBound {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::not_supported_for_lifetime_binder_async_closure)]\n+#[diag(ast_lowering_not_supported_for_lifetime_binder_async_closure)]\n pub struct NotSupportedForLifetimeBinderAsyncClosure {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::arbitrary_expression_in_pattern)]\n+#[diag(ast_lowering_arbitrary_expression_in_pattern)]\n pub struct ArbitraryExpressionInPattern {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::inclusive_range_with_no_end)]\n+#[diag(ast_lowering_inclusive_range_with_no_end)]\n pub struct InclusiveRangeWithNoEnd {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic, Clone, Copy)]\n-#[diag(ast_lowering::trait_fn_async, code = \"E0706\")]\n+#[diag(ast_lowering_trait_fn_async, code = \"E0706\")]\n #[note]\n-#[note(ast_lowering::note2)]\n+#[note(note2)]\n pub struct TraitFnAsync {\n     #[primary_span]\n     pub fn_span: Span,"}, {"sha": "0366432440445e46e3f750aeddbd021aeff9a047", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 10, "deletions": 53, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -14,6 +14,7 @@ use rustc_ast::*;\n use rustc_ast_pretty::pprust::{self, State};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{error_code, fluent, pluralize, struct_span_err, Applicability};\n+use rustc_macros::Subdiagnostic;\n use rustc_parse::validate_attr;\n use rustc_session::lint::builtin::{\n     DEPRECATED_WHERE_CLAUSE_LOCATION, MISSING_ABI, PATTERNS_IN_FNS_WITHOUT_BODY,\n@@ -169,7 +170,7 @@ impl<'a> AstValidator<'a> {\n                 DEPRECATED_WHERE_CLAUSE_LOCATION,\n                 id,\n                 where_clauses.0.1,\n-                fluent::ast_passes::deprecated_where_clause_location,\n+                fluent::ast_passes_deprecated_where_clause_location,\n                 BuiltinLintDiagnostics::DeprecatedWhereclauseLocation(\n                     where_clauses.1.1.shrink_to_hi(),\n                     suggestion,\n@@ -251,20 +252,6 @@ impl<'a> AstValidator<'a> {\n         }\n     }\n \n-    fn visit_struct_field_def(&mut self, field: &'a FieldDef) {\n-        if let Some(ident) = field.ident {\n-            if ident.name == kw::Underscore {\n-                self.visit_vis(&field.vis);\n-                self.visit_ident(ident);\n-                self.visit_ty_common(&field.ty);\n-                self.walk_ty(&field.ty);\n-                walk_list!(self, visit_attribute, &field.attrs);\n-                return;\n-            }\n-        }\n-        self.visit_field_def(field);\n-    }\n-\n     fn err_handler(&self) -> &rustc_errors::Handler {\n         &self.session.diagnostic()\n     }\n@@ -1005,8 +992,8 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         visit::walk_lifetime(self, lifetime);\n     }\n \n-    fn visit_field_def(&mut self, s: &'a FieldDef) {\n-        visit::walk_field_def(self, s)\n+    fn visit_field_def(&mut self, field: &'a FieldDef) {\n+        visit::walk_field_def(self, field)\n     }\n \n     fn visit_item(&mut self, item: &'a Item) {\n@@ -1194,42 +1181,10 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     self.check_mod_file_item_asciionly(item.ident);\n                 }\n             }\n-            ItemKind::Struct(ref vdata, ref generics) => match vdata {\n-                // Duplicating the `Visitor` logic allows catching all cases\n-                // of `Anonymous(Struct, Union)` outside of a field struct or union.\n-                //\n-                // Inside `visit_ty` the validator catches every `Anonymous(Struct, Union)` it\n-                // encounters, and only on `ItemKind::Struct` and `ItemKind::Union`\n-                // it uses `visit_ty_common`, which doesn't contain that specific check.\n-                VariantData::Struct(ref fields, ..) => {\n-                    self.visit_vis(&item.vis);\n-                    self.visit_ident(item.ident);\n-                    self.visit_generics(generics);\n-                    self.with_banned_assoc_ty_bound(|this| {\n-                        walk_list!(this, visit_struct_field_def, fields);\n-                    });\n-                    walk_list!(self, visit_attribute, &item.attrs);\n-                    return;\n-                }\n-                _ => {}\n-            },\n-            ItemKind::Union(ref vdata, ref generics) => {\n+            ItemKind::Union(ref vdata, ..) => {\n                 if vdata.fields().is_empty() {\n                     self.err_handler().span_err(item.span, \"unions cannot have zero fields\");\n                 }\n-                match vdata {\n-                    VariantData::Struct(ref fields, ..) => {\n-                        self.visit_vis(&item.vis);\n-                        self.visit_ident(item.ident);\n-                        self.visit_generics(generics);\n-                        self.with_banned_assoc_ty_bound(|this| {\n-                            walk_list!(this, visit_struct_field_def, fields);\n-                        });\n-                        walk_list!(self, visit_attribute, &item.attrs);\n-                        return;\n-                    }\n-                    _ => {}\n-                }\n             }\n             ItemKind::Const(def, .., None) => {\n                 self.check_defaultness(item.span, def);\n@@ -1805,15 +1760,17 @@ pub fn check_crate(session: &Session, krate: &Crate, lints: &mut LintBuffer) ->\n }\n \n /// Used to forbid `let` expressions in certain syntactic locations.\n-#[derive(Clone, Copy)]\n+#[derive(Clone, Copy, Subdiagnostic)]\n pub(crate) enum ForbiddenLetReason {\n     /// `let` is not valid and the source environment is not important\n     GenericForbidden,\n     /// A let chain with the `||` operator\n-    NotSupportedOr(Span),\n+    #[note(not_supported_or)]\n+    NotSupportedOr(#[primary_span] Span),\n     /// A let chain with invalid parentheses\n     ///\n     /// For example, `let 1 = 1 && (expr && expr)` is allowed\n     /// but `(let 1 = 1 && (let 1 = 1 && (let 1 = 1))) && let a = 1` is not\n-    NotSupportedParentheses(Span),\n+    #[note(not_supported_parentheses)]\n+    NotSupportedParentheses(#[primary_span] Span),\n }"}, {"sha": "59f582f10d989be097f5f44eb6ad86827dfd8100", "filename": "compiler/rustc_ast_passes/src/errors.rs", "status": "modified", "additions": 27, "deletions": 44, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ferrors.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -7,7 +7,7 @@ use rustc_span::{Span, Symbol};\n use crate::ast_validation::ForbiddenLetReason;\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::forbidden_let)]\n+#[diag(ast_passes_forbidden_let)]\n #[note]\n pub struct ForbiddenLet {\n     #[primary_span]\n@@ -16,133 +16,116 @@ pub struct ForbiddenLet {\n     pub(crate) reason: ForbiddenLetReason,\n }\n \n-impl AddToDiagnostic for ForbiddenLetReason {\n-    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n-    where\n-        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n-    {\n-        match self {\n-            Self::GenericForbidden => {}\n-            Self::NotSupportedOr(span) => {\n-                diag.span_note(span, fluent::ast_passes::not_supported_or);\n-            }\n-            Self::NotSupportedParentheses(span) => {\n-                diag.span_note(span, fluent::ast_passes::not_supported_parentheses);\n-            }\n-        }\n-    }\n-}\n-\n #[derive(Diagnostic)]\n-#[diag(ast_passes::forbidden_let_stable)]\n+#[diag(ast_passes_forbidden_let_stable)]\n #[note]\n pub struct ForbiddenLetStable {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::forbidden_assoc_constraint)]\n+#[diag(ast_passes_forbidden_assoc_constraint)]\n pub struct ForbiddenAssocConstraint {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::keyword_lifetime)]\n+#[diag(ast_passes_keyword_lifetime)]\n pub struct KeywordLifetime {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::invalid_label)]\n+#[diag(ast_passes_invalid_label)]\n pub struct InvalidLabel {\n     #[primary_span]\n     pub span: Span,\n     pub name: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::invalid_visibility, code = \"E0449\")]\n+#[diag(ast_passes_invalid_visibility, code = \"E0449\")]\n pub struct InvalidVisibility {\n     #[primary_span]\n     pub span: Span,\n-    #[label(ast_passes::implied)]\n+    #[label(implied)]\n     pub implied: Option<Span>,\n     #[subdiagnostic]\n     pub note: Option<InvalidVisibilityNote>,\n }\n \n #[derive(Subdiagnostic)]\n pub enum InvalidVisibilityNote {\n-    #[note(ast_passes::individual_impl_items)]\n+    #[note(individual_impl_items)]\n     IndividualImplItems,\n-    #[note(ast_passes::individual_foreign_items)]\n+    #[note(individual_foreign_items)]\n     IndividualForeignItems,\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::trait_fn_const, code = \"E0379\")]\n+#[diag(ast_passes_trait_fn_const, code = \"E0379\")]\n pub struct TraitFnConst {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::forbidden_lifetime_bound)]\n+#[diag(ast_passes_forbidden_lifetime_bound)]\n pub struct ForbiddenLifetimeBound {\n     #[primary_span]\n     pub spans: Vec<Span>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::forbidden_non_lifetime_param)]\n+#[diag(ast_passes_forbidden_non_lifetime_param)]\n pub struct ForbiddenNonLifetimeParam {\n     #[primary_span]\n     pub spans: Vec<Span>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::fn_param_too_many)]\n+#[diag(ast_passes_fn_param_too_many)]\n pub struct FnParamTooMany {\n     #[primary_span]\n     pub span: Span,\n     pub max_num_args: usize,\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::fn_param_c_var_args_only)]\n+#[diag(ast_passes_fn_param_c_var_args_only)]\n pub struct FnParamCVarArgsOnly {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::fn_param_c_var_args_not_last)]\n+#[diag(ast_passes_fn_param_c_var_args_not_last)]\n pub struct FnParamCVarArgsNotLast {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::fn_param_doc_comment)]\n+#[diag(ast_passes_fn_param_doc_comment)]\n pub struct FnParamDocComment {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::fn_param_forbidden_attr)]\n+#[diag(ast_passes_fn_param_forbidden_attr)]\n pub struct FnParamForbiddenAttr {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::fn_param_forbidden_self)]\n+#[diag(ast_passes_fn_param_forbidden_self)]\n #[note]\n pub struct FnParamForbiddenSelf {\n     #[primary_span]\n@@ -151,7 +134,7 @@ pub struct FnParamForbiddenSelf {\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::forbidden_default)]\n+#[diag(ast_passes_forbidden_default)]\n pub struct ForbiddenDefault {\n     #[primary_span]\n     pub span: Span,\n@@ -160,7 +143,7 @@ pub struct ForbiddenDefault {\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::assoc_const_without_body)]\n+#[diag(ast_passes_assoc_const_without_body)]\n pub struct AssocConstWithoutBody {\n     #[primary_span]\n     pub span: Span,\n@@ -169,7 +152,7 @@ pub struct AssocConstWithoutBody {\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::assoc_fn_without_body)]\n+#[diag(ast_passes_assoc_fn_without_body)]\n pub struct AssocFnWithoutBody {\n     #[primary_span]\n     pub span: Span,\n@@ -178,7 +161,7 @@ pub struct AssocFnWithoutBody {\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::assoc_type_without_body)]\n+#[diag(ast_passes_assoc_type_without_body)]\n pub struct AssocTypeWithoutBody {\n     #[primary_span]\n     pub span: Span,\n@@ -187,7 +170,7 @@ pub struct AssocTypeWithoutBody {\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::const_without_body)]\n+#[diag(ast_passes_const_without_body)]\n pub struct ConstWithoutBody {\n     #[primary_span]\n     pub span: Span,\n@@ -196,7 +179,7 @@ pub struct ConstWithoutBody {\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::static_without_body)]\n+#[diag(ast_passes_static_without_body)]\n pub struct StaticWithoutBody {\n     #[primary_span]\n     pub span: Span,\n@@ -205,7 +188,7 @@ pub struct StaticWithoutBody {\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::ty_alias_without_body)]\n+#[diag(ast_passes_ty_alias_without_body)]\n pub struct TyAliasWithoutBody {\n     #[primary_span]\n     pub span: Span,\n@@ -214,7 +197,7 @@ pub struct TyAliasWithoutBody {\n }\n \n #[derive(Diagnostic)]\n-#[diag(ast_passes::fn_without_body)]\n+#[diag(ast_passes_fn_without_body)]\n pub struct FnWithoutBody {\n     #[primary_span]\n     pub span: Span,\n@@ -243,7 +226,7 @@ impl AddToDiagnostic for ExternBlockSuggestion {\n         let end_suggestion = \" }\".to_owned();\n \n         diag.multipart_suggestion(\n-            fluent::ast_passes::extern_block_suggestion,\n+            fluent::extern_block_suggestion,\n             vec![(self.start_span, start_suggestion), (self.end_span, end_suggestion)],\n             Applicability::MaybeIncorrect,\n         );"}, {"sha": "edccfa1c8ffa21f493a914323b419754fa093242", "filename": "compiler/rustc_attr/src/session_diagnostics.rs", "status": "modified", "additions": 43, "deletions": 47, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_attr%2Fsrc%2Fsession_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_attr%2Fsrc%2Fsession_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fsession_diagnostics.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -10,14 +10,14 @@ use rustc_span::{Span, Symbol};\n use crate::UnsupportedLiteralReason;\n \n #[derive(Diagnostic)]\n-#[diag(attr::expected_one_cfg_pattern, code = \"E0536\")]\n+#[diag(attr_expected_one_cfg_pattern, code = \"E0536\")]\n pub(crate) struct ExpectedOneCfgPattern {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::invalid_predicate, code = \"E0537\")]\n+#[diag(attr_invalid_predicate, code = \"E0537\")]\n pub(crate) struct InvalidPredicate {\n     #[primary_span]\n     pub span: Span,\n@@ -26,7 +26,7 @@ pub(crate) struct InvalidPredicate {\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::multiple_item, code = \"E0538\")]\n+#[diag(attr_multiple_item, code = \"E0538\")]\n pub(crate) struct MultipleItem {\n     #[primary_span]\n     pub span: Span,\n@@ -35,7 +35,7 @@ pub(crate) struct MultipleItem {\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::incorrect_meta_item, code = \"E0539\")]\n+#[diag(attr_incorrect_meta_item, code = \"E0539\")]\n pub(crate) struct IncorrectMetaItem {\n     #[primary_span]\n     pub span: Span,\n@@ -54,39 +54,39 @@ impl<'a> IntoDiagnostic<'a> for UnknownMetaItem<'_> {\n         let expected = self.expected.iter().map(|name| format!(\"`{}`\", name)).collect::<Vec<_>>();\n         let mut diag = handler.struct_span_err_with_code(\n             self.span,\n-            fluent::attr::unknown_meta_item,\n+            fluent::attr_unknown_meta_item,\n             error_code!(E0541),\n         );\n         diag.set_arg(\"item\", self.item);\n         diag.set_arg(\"expected\", expected.join(\", \"));\n-        diag.span_label(self.span, fluent::attr::label);\n+        diag.span_label(self.span, fluent::label);\n         diag\n     }\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::missing_since, code = \"E0542\")]\n+#[diag(attr_missing_since, code = \"E0542\")]\n pub(crate) struct MissingSince {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::missing_note, code = \"E0543\")]\n+#[diag(attr_missing_note, code = \"E0543\")]\n pub(crate) struct MissingNote {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::multiple_stability_levels, code = \"E0544\")]\n+#[diag(attr_multiple_stability_levels, code = \"E0544\")]\n pub(crate) struct MultipleStabilityLevels {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::invalid_issue_string, code = \"E0545\")]\n+#[diag(attr_invalid_issue_string, code = \"E0545\")]\n pub(crate) struct InvalidIssueString {\n     #[primary_span]\n     pub span: Span,\n@@ -99,31 +99,31 @@ pub(crate) struct InvalidIssueString {\n // translatable.\n #[derive(Subdiagnostic)]\n pub(crate) enum InvalidIssueStringCause {\n-    #[label(attr::must_not_be_zero)]\n+    #[label(must_not_be_zero)]\n     MustNotBeZero {\n         #[primary_span]\n         span: Span,\n     },\n \n-    #[label(attr::empty)]\n+    #[label(empty)]\n     Empty {\n         #[primary_span]\n         span: Span,\n     },\n \n-    #[label(attr::invalid_digit)]\n+    #[label(invalid_digit)]\n     InvalidDigit {\n         #[primary_span]\n         span: Span,\n     },\n \n-    #[label(attr::pos_overflow)]\n+    #[label(pos_overflow)]\n     PosOverflow {\n         #[primary_span]\n         span: Span,\n     },\n \n-    #[label(attr::neg_overflow)]\n+    #[label(neg_overflow)]\n     NegOverflow {\n         #[primary_span]\n         span: Span,\n@@ -144,21 +144,21 @@ impl InvalidIssueStringCause {\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::missing_feature, code = \"E0546\")]\n+#[diag(attr_missing_feature, code = \"E0546\")]\n pub(crate) struct MissingFeature {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::non_ident_feature, code = \"E0546\")]\n+#[diag(attr_non_ident_feature, code = \"E0546\")]\n pub(crate) struct NonIdentFeature {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::missing_issue, code = \"E0547\")]\n+#[diag(attr_missing_issue, code = \"E0547\")]\n pub(crate) struct MissingIssue {\n     #[primary_span]\n     pub span: Span,\n@@ -167,7 +167,7 @@ pub(crate) struct MissingIssue {\n // FIXME: This diagnostic is identical to `IncorrectMetaItem`, barring the error code. Consider\n // changing this to `IncorrectMetaItem`. See #51489.\n #[derive(Diagnostic)]\n-#[diag(attr::incorrect_meta_item, code = \"E0551\")]\n+#[diag(attr_incorrect_meta_item, code = \"E0551\")]\n pub(crate) struct IncorrectMetaItem2 {\n     #[primary_span]\n     pub span: Span,\n@@ -176,14 +176,14 @@ pub(crate) struct IncorrectMetaItem2 {\n // FIXME: Why is this the same error code as `InvalidReprHintNoParen` and `InvalidReprHintNoValue`?\n // It is more similar to `IncorrectReprFormatGeneric`.\n #[derive(Diagnostic)]\n-#[diag(attr::incorrect_repr_format_packed_one_or_zero_arg, code = \"E0552\")]\n+#[diag(attr_incorrect_repr_format_packed_one_or_zero_arg, code = \"E0552\")]\n pub(crate) struct IncorrectReprFormatPackedOneOrZeroArg {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::invalid_repr_hint_no_paren, code = \"E0552\")]\n+#[diag(attr_invalid_repr_hint_no_paren, code = \"E0552\")]\n pub(crate) struct InvalidReprHintNoParen {\n     #[primary_span]\n     pub span: Span,\n@@ -192,7 +192,7 @@ pub(crate) struct InvalidReprHintNoParen {\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::invalid_repr_hint_no_value, code = \"E0552\")]\n+#[diag(attr_invalid_repr_hint_no_value, code = \"E0552\")]\n pub(crate) struct InvalidReprHintNoValue {\n     #[primary_span]\n     pub span: Span,\n@@ -213,21 +213,21 @@ impl<'a> IntoDiagnostic<'a> for UnsupportedLiteral {\n         let mut diag = handler.struct_span_err_with_code(\n             self.span,\n             match self.reason {\n-                UnsupportedLiteralReason::Generic => fluent::attr::unsupported_literal_generic,\n-                UnsupportedLiteralReason::CfgString => fluent::attr::unsupported_literal_cfg_string,\n+                UnsupportedLiteralReason::Generic => fluent::attr_unsupported_literal_generic,\n+                UnsupportedLiteralReason::CfgString => fluent::attr_unsupported_literal_cfg_string,\n                 UnsupportedLiteralReason::DeprecatedString => {\n-                    fluent::attr::unsupported_literal_deprecated_string\n+                    fluent::attr_unsupported_literal_deprecated_string\n                 }\n                 UnsupportedLiteralReason::DeprecatedKvPair => {\n-                    fluent::attr::unsupported_literal_deprecated_kv_pair\n+                    fluent::attr_unsupported_literal_deprecated_kv_pair\n                 }\n             },\n             error_code!(E0565),\n         );\n         if self.is_bytestr {\n             diag.span_suggestion(\n                 self.start_point_span,\n-                fluent::attr::unsupported_literal_suggestion,\n+                fluent::attr_unsupported_literal_suggestion,\n                 \"\",\n                 Applicability::MaybeIncorrect,\n             );\n@@ -237,15 +237,15 @@ impl<'a> IntoDiagnostic<'a> for UnsupportedLiteral {\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::invalid_repr_align_need_arg, code = \"E0589\")]\n+#[diag(attr_invalid_repr_align_need_arg, code = \"E0589\")]\n pub(crate) struct InvalidReprAlignNeedArg {\n     #[primary_span]\n     #[suggestion(code = \"align(...)\", applicability = \"has-placeholders\")]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::invalid_repr_generic, code = \"E0589\")]\n+#[diag(attr_invalid_repr_generic, code = \"E0589\")]\n pub(crate) struct InvalidReprGeneric<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -255,14 +255,14 @@ pub(crate) struct InvalidReprGeneric<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::incorrect_repr_format_align_one_arg, code = \"E0693\")]\n+#[diag(attr_incorrect_repr_format_align_one_arg, code = \"E0693\")]\n pub(crate) struct IncorrectReprFormatAlignOneArg {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::incorrect_repr_format_generic, code = \"E0693\")]\n+#[diag(attr_incorrect_repr_format_generic, code = \"E0693\")]\n pub(crate) struct IncorrectReprFormatGeneric<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -275,7 +275,7 @@ pub(crate) struct IncorrectReprFormatGeneric<'a> {\n \n #[derive(Subdiagnostic)]\n pub(crate) enum IncorrectReprFormatGenericCause<'a> {\n-    #[suggestion(attr::suggestion, code = \"{name}({int})\", applicability = \"machine-applicable\")]\n+    #[suggestion(suggestion, code = \"{name}({int})\", applicability = \"machine-applicable\")]\n     Int {\n         #[primary_span]\n         span: Span,\n@@ -287,11 +287,7 @@ pub(crate) enum IncorrectReprFormatGenericCause<'a> {\n         int: u128,\n     },\n \n-    #[suggestion(\n-        attr::suggestion,\n-        code = \"{name}({symbol})\",\n-        applicability = \"machine-applicable\"\n-    )]\n+    #[suggestion(suggestion, code = \"{name}({symbol})\", applicability = \"machine-applicable\")]\n     Symbol {\n         #[primary_span]\n         span: Span,\n@@ -317,28 +313,28 @@ impl<'a> IncorrectReprFormatGenericCause<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::rustc_promotable_pairing, code = \"E0717\")]\n+#[diag(attr_rustc_promotable_pairing, code = \"E0717\")]\n pub(crate) struct RustcPromotablePairing {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::rustc_allowed_unstable_pairing, code = \"E0789\")]\n+#[diag(attr_rustc_allowed_unstable_pairing, code = \"E0789\")]\n pub(crate) struct RustcAllowedUnstablePairing {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::cfg_predicate_identifier)]\n+#[diag(attr_cfg_predicate_identifier)]\n pub(crate) struct CfgPredicateIdentifier {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::deprecated_item_suggestion)]\n+#[diag(attr_deprecated_item_suggestion)]\n pub(crate) struct DeprecatedItemSuggestion {\n     #[primary_span]\n     pub span: Span,\n@@ -351,21 +347,21 @@ pub(crate) struct DeprecatedItemSuggestion {\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::expected_single_version_literal)]\n+#[diag(attr_expected_single_version_literal)]\n pub(crate) struct ExpectedSingleVersionLiteral {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::expected_version_literal)]\n+#[diag(attr_expected_version_literal)]\n pub(crate) struct ExpectedVersionLiteral {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::expects_feature_list)]\n+#[diag(attr_expects_feature_list)]\n pub(crate) struct ExpectsFeatureList {\n     #[primary_span]\n     pub span: Span,\n@@ -374,7 +370,7 @@ pub(crate) struct ExpectsFeatureList {\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::expects_features)]\n+#[diag(attr_expects_features)]\n pub(crate) struct ExpectsFeatures {\n     #[primary_span]\n     pub span: Span,\n@@ -383,14 +379,14 @@ pub(crate) struct ExpectsFeatures {\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::soft_no_args)]\n+#[diag(attr_soft_no_args)]\n pub(crate) struct SoftNoArgs {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(attr::unknown_version_literal)]\n+#[diag(attr_unknown_version_literal)]\n pub(crate) struct UnknownVersionLiteral {\n     #[primary_span]\n     pub span: Span,"}, {"sha": "c044dbaba47e2faab5170228d73bd7c571302c0d", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 92, "deletions": 8, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -251,7 +251,8 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n             .or_else(|| self.give_name_if_anonymous_region_appears_in_upvars(fr))\n             .or_else(|| self.give_name_if_anonymous_region_appears_in_output(fr))\n             .or_else(|| self.give_name_if_anonymous_region_appears_in_yield_ty(fr))\n-            .or_else(|| self.give_name_if_anonymous_region_appears_in_impl_signature(fr));\n+            .or_else(|| self.give_name_if_anonymous_region_appears_in_impl_signature(fr))\n+            .or_else(|| self.give_name_if_anonymous_region_appears_in_arg_position_impl_trait(fr));\n \n         if let Some(ref value) = value {\n             self.region_names.try_borrow_mut().unwrap().insert(fr, value.clone());\n@@ -869,13 +870,8 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n             return None;\n         }\n \n-        let mut found = false;\n-        tcx.fold_regions(tcx.type_of(region_parent), |r: ty::Region<'tcx>, _| {\n-            if *r == ty::ReEarlyBound(region) {\n-                found = true;\n-            }\n-            r\n-        });\n+        let found = tcx\n+            .any_free_region_meets(&tcx.type_of(region_parent), |r| *r == ty::ReEarlyBound(region));\n \n         Some(RegionName {\n             name: self.synthesize_region_name(),\n@@ -888,4 +884,92 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n             ),\n         })\n     }\n+\n+    fn give_name_if_anonymous_region_appears_in_arg_position_impl_trait(\n+        &self,\n+        fr: RegionVid,\n+    ) -> Option<RegionName> {\n+        let ty::ReEarlyBound(region) = *self.to_error_region(fr)? else {\n+            return None;\n+        };\n+        if region.has_name() {\n+            return None;\n+        };\n+\n+        let predicates = self\n+            .infcx\n+            .tcx\n+            .predicates_of(self.body.source.def_id())\n+            .instantiate_identity(self.infcx.tcx)\n+            .predicates;\n+\n+        if let Some(upvar_index) = self\n+            .regioncx\n+            .universal_regions()\n+            .defining_ty\n+            .upvar_tys()\n+            .position(|ty| self.any_param_predicate_mentions(&predicates, ty, region))\n+        {\n+            let (upvar_name, upvar_span) = self.regioncx.get_upvar_name_and_span_for_region(\n+                self.infcx.tcx,\n+                &self.upvars,\n+                upvar_index,\n+            );\n+            let region_name = self.synthesize_region_name();\n+\n+            Some(RegionName {\n+                name: region_name,\n+                source: RegionNameSource::AnonRegionFromUpvar(upvar_span, upvar_name),\n+            })\n+        } else if let Some(arg_index) = self\n+            .regioncx\n+            .universal_regions()\n+            .unnormalized_input_tys\n+            .iter()\n+            .position(|ty| self.any_param_predicate_mentions(&predicates, *ty, region))\n+        {\n+            let (arg_name, arg_span) = self.regioncx.get_argument_name_and_span_for_region(\n+                self.body,\n+                &self.local_names,\n+                arg_index,\n+            );\n+            let region_name = self.synthesize_region_name();\n+\n+            Some(RegionName {\n+                name: region_name,\n+                source: RegionNameSource::AnonRegionFromArgument(\n+                    RegionNameHighlight::CannotMatchHirTy(arg_span, arg_name?.to_string()),\n+                ),\n+            })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    fn any_param_predicate_mentions(\n+        &self,\n+        predicates: &[ty::Predicate<'tcx>],\n+        ty: Ty<'tcx>,\n+        region: ty::EarlyBoundRegion,\n+    ) -> bool {\n+        let tcx = self.infcx.tcx;\n+        ty.walk().any(|arg| {\n+            if let ty::GenericArgKind::Type(ty) = arg.unpack()\n+                && let ty::Param(_) = ty.kind()\n+            {\n+                predicates.iter().any(|pred| {\n+                    match pred.kind().skip_binder() {\n+                        ty::PredicateKind::Trait(data) if data.self_ty() == ty => {}\n+                        ty::PredicateKind::Projection(data) if data.projection_ty.self_ty() == ty => {}\n+                        _ => return false,\n+                    }\n+                    tcx.any_free_region_meets(pred, |r| {\n+                        *r == ty::ReEarlyBound(region)\n+                    })\n+                })\n+            } else {\n+                false\n+            }\n+        })\n+    }\n }"}, {"sha": "cff3089c397cb8d16cc8a9597869519ef150230d", "filename": "compiler/rustc_borrowck/src/session_diagnostics.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fsession_diagnostics.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -6,7 +6,7 @@ use rustc_span::Span;\n use crate::diagnostics::RegionName;\n \n #[derive(Diagnostic)]\n-#[diag(borrowck::move_unsized, code = \"E0161\")]\n+#[diag(borrowck_move_unsized, code = \"E0161\")]\n pub(crate) struct MoveUnsized<'tcx> {\n     pub ty: Ty<'tcx>,\n     #[primary_span]\n@@ -15,7 +15,7 @@ pub(crate) struct MoveUnsized<'tcx> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(borrowck::higher_ranked_lifetime_error)]\n+#[diag(borrowck_higher_ranked_lifetime_error)]\n pub(crate) struct HigherRankedLifetimeError {\n     #[subdiagnostic]\n     pub cause: Option<HigherRankedErrorCause>,\n@@ -25,37 +25,37 @@ pub(crate) struct HigherRankedLifetimeError {\n \n #[derive(Subdiagnostic)]\n pub(crate) enum HigherRankedErrorCause {\n-    #[note(borrowck::could_not_prove)]\n+    #[note(borrowck_could_not_prove)]\n     CouldNotProve { predicate: String },\n-    #[note(borrowck::could_not_normalize)]\n+    #[note(borrowck_could_not_normalize)]\n     CouldNotNormalize { value: String },\n }\n \n #[derive(Diagnostic)]\n-#[diag(borrowck::higher_ranked_subtype_error)]\n+#[diag(borrowck_higher_ranked_subtype_error)]\n pub(crate) struct HigherRankedSubtypeError {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(borrowck::generic_does_not_live_long_enough)]\n+#[diag(borrowck_generic_does_not_live_long_enough)]\n pub(crate) struct GenericDoesNotLiveLongEnough {\n     pub kind: String,\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(borrowck::var_does_not_need_mut)]\n+#[diag(borrowck_var_does_not_need_mut)]\n pub(crate) struct VarNeedNotMut {\n     #[suggestion_short(applicability = \"machine-applicable\", code = \"\")]\n     pub span: Span,\n }\n #[derive(Diagnostic)]\n-#[diag(borrowck::var_cannot_escape_closure)]\n+#[diag(borrowck_var_cannot_escape_closure)]\n #[note]\n-#[note(borrowck::cannot_escape)]\n+#[note(cannot_escape)]\n pub(crate) struct FnMutError {\n     #[primary_span]\n     pub span: Span,\n@@ -65,17 +65,17 @@ pub(crate) struct FnMutError {\n \n #[derive(Subdiagnostic)]\n pub(crate) enum VarHereDenote {\n-    #[label(borrowck::var_here_captured)]\n+    #[label(borrowck_var_here_captured)]\n     Captured {\n         #[primary_span]\n         span: Span,\n     },\n-    #[label(borrowck::var_here_defined)]\n+    #[label(borrowck_var_here_defined)]\n     Defined {\n         #[primary_span]\n         span: Span,\n     },\n-    #[label(borrowck::closure_inferred_mut)]\n+    #[label(borrowck_closure_inferred_mut)]\n     FnMutInferred {\n         #[primary_span]\n         span: Span,\n@@ -84,41 +84,41 @@ pub(crate) enum VarHereDenote {\n \n #[derive(Subdiagnostic)]\n pub(crate) enum FnMutReturnTypeErr {\n-    #[label(borrowck::returned_closure_escaped)]\n+    #[label(borrowck_returned_closure_escaped)]\n     ReturnClosure {\n         #[primary_span]\n         span: Span,\n     },\n-    #[label(borrowck::returned_async_block_escaped)]\n+    #[label(borrowck_returned_async_block_escaped)]\n     ReturnAsyncBlock {\n         #[primary_span]\n         span: Span,\n     },\n-    #[label(borrowck::returned_ref_escaped)]\n+    #[label(borrowck_returned_ref_escaped)]\n     ReturnRef {\n         #[primary_span]\n         span: Span,\n     },\n }\n \n #[derive(Diagnostic)]\n-#[diag(borrowck::lifetime_constraints_error)]\n+#[diag(borrowck_lifetime_constraints_error)]\n pub(crate) struct LifetimeOutliveErr {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Subdiagnostic)]\n pub(crate) enum LifetimeReturnCategoryErr<'a> {\n-    #[label(borrowck::returned_lifetime_wrong)]\n+    #[label(borrowck_returned_lifetime_wrong)]\n     WrongReturn {\n         #[primary_span]\n         span: Span,\n         mir_def_name: &'a str,\n         outlived_fr_name: RegionName,\n         fr_name: &'a RegionName,\n     },\n-    #[label(borrowck::returned_lifetime_short)]\n+    #[label(borrowck_returned_lifetime_short)]\n     ShortReturn {\n         #[primary_span]\n         span: Span,\n@@ -142,7 +142,7 @@ impl IntoDiagnosticArg for RegionName {\n \n #[derive(Subdiagnostic)]\n pub(crate) enum RequireStaticErr {\n-    #[note(borrowck::used_impl_require_static)]\n+    #[note(borrowck_used_impl_require_static)]\n     UsedImpl {\n         #[primary_span]\n         multi_span: MultiSpan,"}, {"sha": "5638c2f6180cb8d29355b88bcb9c1559ce8b3921", "filename": "compiler/rustc_builtin_macros/src/cfg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -36,15 +36,15 @@ pub fn expand_cfg(\n }\n \n #[derive(Diagnostic)]\n-#[diag(builtin_macros::requires_cfg_pattern)]\n+#[diag(builtin_macros_requires_cfg_pattern)]\n struct RequiresCfgPattern {\n     #[primary_span]\n     #[label]\n     span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(builtin_macros::expected_one_cfg_pattern)]\n+#[diag(builtin_macros_expected_one_cfg_pattern)]\n struct OneCfgPattern {\n     #[primary_span]\n     span: Span,"}, {"sha": "fee5d04cdae857c7972a343afb6ff7920803c000", "filename": "compiler/rustc_builtin_macros/src/test.rs", "status": "modified", "additions": 25, "deletions": 12, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -36,13 +36,22 @@ pub fn expand_test_case(\n     let sp = ecx.with_def_site_ctxt(attr_sp);\n     let mut item = anno_item.expect_item();\n     item = item.map(|mut item| {\n+        let test_path_symbol = Symbol::intern(&item_path(\n+            // skip the name of the root module\n+            &ecx.current_expansion.module.mod_path[1..],\n+            &item.ident,\n+        ));\n         item.vis = ast::Visibility {\n             span: item.vis.span,\n             kind: ast::VisibilityKind::Public,\n             tokens: None,\n         };\n         item.ident.span = item.ident.span.with_ctxt(sp.ctxt());\n-        item.attrs.push(ecx.attribute(ecx.meta_word(sp, sym::rustc_test_marker)));\n+        item.attrs.push(ecx.attribute(attr::mk_name_value_item_str(\n+            Ident::new(sym::rustc_test_marker, sp),\n+            test_path_symbol,\n+            sp,\n+        )));\n         item\n     });\n \n@@ -215,6 +224,12 @@ pub fn expand_test_or_bench(\n         )\n     };\n \n+    let test_path_symbol = Symbol::intern(&item_path(\n+        // skip the name of the root module\n+        &cx.current_expansion.module.mod_path[1..],\n+        &item.ident,\n+    ));\n+\n     let mut test_const = cx.item(\n         sp,\n         Ident::new(item.ident.name, sp),\n@@ -224,9 +239,14 @@ pub fn expand_test_or_bench(\n                 Ident::new(sym::cfg, attr_sp),\n                 vec![attr::mk_nested_word_item(Ident::new(sym::test, attr_sp))],\n             )),\n-            // #[rustc_test_marker]\n-            cx.attribute(cx.meta_word(attr_sp, sym::rustc_test_marker)),\n-        ],\n+            // #[rustc_test_marker = \"test_case_sort_key\"]\n+            cx.attribute(attr::mk_name_value_item_str(\n+                Ident::new(sym::rustc_test_marker, attr_sp),\n+                test_path_symbol,\n+                attr_sp,\n+            )),\n+        ]\n+        .into(),\n         // const $ident: test::TestDescAndFn =\n         ast::ItemKind::Const(\n             ast::Defaultness::Final,\n@@ -250,14 +270,7 @@ pub fn expand_test_or_bench(\n                                         cx.expr_call(\n                                             sp,\n                                             cx.expr_path(test_path(\"StaticTestName\")),\n-                                            vec![cx.expr_str(\n-                                                sp,\n-                                                Symbol::intern(&item_path(\n-                                                    // skip the name of the root module\n-                                                    &cx.current_expansion.module.mod_path[1..],\n-                                                    &item.ident,\n-                                                )),\n-                                            )],\n+                                            vec![cx.expr_str(sp, test_path_symbol)],\n                                         ),\n                                     ),\n                                     // ignore: true | false"}, {"sha": "b8b8351a36f4158986b084d3c7c3d9144efd92ce", "filename": "compiler/rustc_builtin_macros/src/test_harness.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -18,9 +18,11 @@ use thin_vec::thin_vec;\n \n use std::{iter, mem};\n \n+#[derive(Clone)]\n struct Test {\n     span: Span,\n     ident: Ident,\n+    name: Symbol,\n }\n \n struct TestCtxt<'a> {\n@@ -120,10 +122,10 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n \n     fn flat_map_item(&mut self, i: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n         let mut item = i.into_inner();\n-        if is_test_case(&self.cx.ext_cx.sess, &item) {\n+        if let Some(name) = get_test_name(&self.cx.ext_cx.sess, &item) {\n             debug!(\"this is a test item\");\n \n-            let test = Test { span: item.span, ident: item.ident };\n+            let test = Test { span: item.span, ident: item.ident, name };\n             self.tests.push(test);\n         }\n \n@@ -357,9 +359,12 @@ fn mk_tests_slice(cx: &TestCtxt<'_>, sp: Span) -> P<ast::Expr> {\n     debug!(\"building test vector from {} tests\", cx.test_cases.len());\n     let ecx = &cx.ext_cx;\n \n+    let mut tests = cx.test_cases.clone();\n+    tests.sort_by(|a, b| a.name.as_str().cmp(&b.name.as_str()));\n+\n     ecx.expr_array_ref(\n         sp,\n-        cx.test_cases\n+        tests\n             .iter()\n             .map(|test| {\n                 ecx.expr_addr_of(test.span, ecx.expr_path(ecx.path(test.span, vec![test.ident])))\n@@ -368,8 +373,8 @@ fn mk_tests_slice(cx: &TestCtxt<'_>, sp: Span) -> P<ast::Expr> {\n     )\n }\n \n-fn is_test_case(sess: &Session, i: &ast::Item) -> bool {\n-    sess.contains_name(&i.attrs, sym::rustc_test_marker)\n+fn get_test_name(sess: &Session, i: &ast::Item) -> Option<Symbol> {\n+    sess.first_attr_value_str_by_name(&i.attrs, sym::rustc_test_marker)\n }\n \n fn get_test_runner("}, {"sha": "5061010c86cd3451d4b8e7858b05cecf7efc8631", "filename": "compiler/rustc_codegen_cranelift/.github/workflows/main.yml", "status": "modified", "additions": 68, "deletions": 31, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.github%2Fworkflows%2Fmain.yml?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -29,7 +29,11 @@ jobs:\n       matrix:\n         include:\n           - os: ubuntu-latest\n+            env:\n+              TARGET_TRIPLE: x86_64-unknown-linux-gnu\n           - os: macos-latest\n+            env:\n+              TARGET_TRIPLE: x86_64-apple-darwin\n           # cross-compile from Linux to Windows using mingw\n           - os: ubuntu-latest\n             env:\n@@ -112,7 +116,7 @@ jobs:\n       if: matrix.env.TARGET_TRIPLE != 'x86_64-pc-windows-gnu'\n       uses: actions/upload-artifact@v2\n       with:\n-        name: cg_clif-${{ runner.os }}\n+        name: cg_clif-${{ matrix.env.TARGET_TRIPLE }}\n         path: cg_clif.tar.xz\n \n     - name: Upload prebuilt cg_clif (cross compile)\n@@ -122,56 +126,89 @@ jobs:\n         name: cg_clif-${{ runner.os }}-cross-x86_64-mingw\n         path: cg_clif.tar.xz\n \n-  build_windows:\n-    runs-on: windows-latest\n+  windows:\n+    runs-on: ${{ matrix.os }}\n     timeout-minutes: 60\n \n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        include:\n+          # Native Windows build with MSVC\n+          - os: windows-latest\n+            env:\n+              TARGET_TRIPLE: x86_64-pc-windows-msvc\n+          # cross-compile from Windows to Windows MinGW\n+          - os: windows-latest\n+            env:\n+              TARGET_TRIPLE: x86_64-pc-windows-gnu\n+\n     steps:\n     - uses: actions/checkout@v3\n \n-    #- name: Cache cargo installed crates\n-    #  uses: actions/cache@v2\n-    #  with:\n-    #    path: ~/.cargo/bin\n-    #    key: ${{ runner.os }}-cargo-installed-crates\n-\n-    #- name: Cache cargo registry and index\n-    #  uses: actions/cache@v2\n-    #  with:\n-    #    path: |\n-    #        ~/.cargo/registry\n-    #        ~/.cargo/git\n-    #    key: ${{ runner.os }}-cargo-registry-and-index-${{ hashFiles('**/Cargo.lock') }}\n-\n-    #- name: Cache cargo target dir\n-    #  uses: actions/cache@v2\n-    #  with:\n-    #    path: target\n-    #    key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n+    - name: Cache cargo installed crates\n+      uses: actions/cache@v2\n+      with:\n+        path: ~/.cargo/bin\n+        key: ${{ runner.os }}-${{ matrix.env.TARGET_TRIPLE }}-cargo-installed-crates\n+\n+    - name: Cache cargo registry and index\n+      uses: actions/cache@v2\n+      with:\n+        path: |\n+            ~/.cargo/registry\n+            ~/.cargo/git\n+        key: ${{ runner.os }}-${{ matrix.env.TARGET_TRIPLE }}-cargo-registry-and-index-${{ hashFiles('**/Cargo.lock') }}\n+\n+    - name: Cache cargo target dir\n+      uses: actions/cache@v2\n+      with:\n+        path: target\n+        key: ${{ runner.os }}-${{ matrix.env.TARGET_TRIPLE }}-cargo-build-target-${{ hashFiles('rust-toolchain', '**/Cargo.lock') }}\n+\n+    - name: Set MinGW as the default toolchain\n+      if: matrix.env.TARGET_TRIPLE == 'x86_64-pc-windows-gnu'\n+      run: rustup set default-host x86_64-pc-windows-gnu\n \n     - name: Prepare dependencies\n       run: |\n         git config --global user.email \"user@example.com\"\n         git config --global user.name \"User\"\n         git config --global core.autocrlf false\n-        rustup set default-host x86_64-pc-windows-gnu\n         rustc y.rs -o y.exe -g\n         ./y.exe prepare\n \n+    - name: Build without unstable features\n+      env:\n+        TARGET_TRIPLE: ${{ matrix.env.TARGET_TRIPLE }}\n+      # This is the config rust-lang/rust uses for builds\n+      run: ./y.rs build --no-unstable-features\n+\n     - name: Build\n-      #name: Test\n+      run: ./y.rs build --sysroot none\n+\n+    - name: Test\n       run: |\n         # Enable backtraces for easier debugging\n-        #$Env:RUST_BACKTRACE=1\n+        $Env:RUST_BACKTRACE=1\n \n         # Reduce amount of benchmark runs as they are slow\n-        #$Env:COMPILE_RUNS=2\n-        #$Env:RUN_RUNS=2\n+        $Env:COMPILE_RUNS=2\n+        $Env:RUN_RUNS=2\n \n         # Enable extra checks\n-        #$Env:CG_CLIF_ENABLE_VERIFIER=1\n-\n-        ./y.exe build\n+        $Env:CG_CLIF_ENABLE_VERIFIER=1\n+        \n+        # WIP Disable some tests\n+        \n+        # This fails due to some weird argument handling by hyperfine, not an actual regression\n+        # more of a build system issue\n+        (Get-Content config.txt) -replace '(bench.simple-raytracer)', '# $1' |  Out-File config.txt\n+        \n+        # This fails with a different output than expected \n+        (Get-Content config.txt) -replace '(test.regex-shootout-regex-dna)', '# $1' |  Out-File config.txt\n+\n+        ./y.exe test\n \n     - name: Package prebuilt cg_clif\n       # don't use compression as xzip isn't supported by tar on windows and bzip2 hangs\n@@ -180,5 +217,5 @@ jobs:\n     - name: Upload prebuilt cg_clif\n       uses: actions/upload-artifact@v2\n       with:\n-        name: cg_clif-${{ runner.os }}\n+        name: cg_clif-${{ matrix.env.TARGET_TRIPLE }}\n         path: cg_clif.tar"}, {"sha": "fae09592c6ac0dc91be2641093896c0adc9559d8", "filename": "compiler/rustc_codegen_cranelift/.gitignore", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.gitignore?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -15,8 +15,4 @@ perf.data.old\n /build_sysroot/compiler-builtins\n /build_sysroot/rustc_version\n /rust\n-/rand\n-/regex\n-/simple-raytracer\n-/portable-simd\n-/abi-checker\n+/download"}, {"sha": "13301bf20a5ed7d57051c9b45fa4165a98e8b7b5", "filename": "compiler/rustc_codegen_cranelift/.vscode/settings.json", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2F.vscode%2Fsettings.json?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -7,7 +7,7 @@\n     \"rust-analyzer.cargo.features\": [\"unstable-features\"],\n     \"rust-analyzer.linkedProjects\": [\n         \"./Cargo.toml\",\n-        //\"./build_sysroot/sysroot_src/src/libstd/Cargo.toml\",\n+        //\"./build_sysroot/sysroot_src/library/std/Cargo.toml\",\n         {\n             \"roots\": [\n                 \"./example/mini_core.rs\",\n@@ -36,10 +36,10 @@\n             ]\n         },\n         {\n-            \"roots\": [\"./scripts/filter_profile.rs\"],\n+            \"roots\": [\"./example/std_example.rs\"],\n             \"crates\": [\n                 {\n-                    \"root_module\": \"./scripts/filter_profile.rs\",\n+                    \"root_module\": \"./example/std_example.rs\",\n                     \"edition\": \"2018\",\n                     \"deps\": [{ \"crate\": 1, \"name\": \"std\" }],\n                     \"cfg\": [],"}, {"sha": "3fa9d56cd01a381549991ed9fca4940e2b925d08", "filename": "compiler/rustc_codegen_cranelift/Cargo.lock", "status": "modified", "additions": 38, "deletions": 24, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.lock?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -24,6 +24,12 @@ name = \"ar\"\n version = \"0.8.0\"\n source = \"git+https://github.com/bjorn3/rust-ar.git?branch=do_not_remove_cg_clif_ranlib#de9ab0e56bf3a208381d342aa5b60f9ff2891648\"\n \n+[[package]]\n+name = \"arrayvec\"\n+version = \"0.7.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8da52d66c7071e2e3fa2a1e5c6d088fec47b593032b254f5e980de8ea54454d6\"\n+\n [[package]]\n name = \"autocfg\"\n version = \"1.1.0\"\n@@ -36,6 +42,12 @@ version = \"1.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a\"\n \n+[[package]]\n+name = \"bumpalo\"\n+version = \"3.11.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c1ad822118d20d2c234f427000d5acc36eabe1e29a348c89b63dd60b13f28e5d\"\n+\n [[package]]\n name = \"byteorder\"\n version = \"1.4.3\"\n@@ -50,19 +62,21 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n [[package]]\n name = \"cranelift-bforest\"\n-version = \"0.87.0\"\n+version = \"0.88.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"93945adbccc8d731503d3038814a51e8317497c9e205411820348132fa01a358\"\n+checksum = \"44409ccf2d0f663920cab563d2b79fcd6b2e9a2bcc6e929fef76c8f82ad6c17a\"\n dependencies = [\n  \"cranelift-entity\",\n ]\n \n [[package]]\n name = \"cranelift-codegen\"\n-version = \"0.87.0\"\n+version = \"0.88.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2b482acc9d0d0d1ad3288a90a8150ee648be3dce8dc8c8669ff026f72debdc31\"\n+checksum = \"98de2018ad96eb97f621f7d6b900a0cc661aec8d02ea4a50e56ecb48e5a2fcaf\"\n dependencies = [\n+ \"arrayvec\",\n+ \"bumpalo\",\n  \"cranelift-bforest\",\n  \"cranelift-codegen-meta\",\n  \"cranelift-codegen-shared\",\n@@ -77,30 +91,30 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-codegen-meta\"\n-version = \"0.87.0\"\n+version = \"0.88.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f9ec188d71e663192ef9048f204e410a7283b609942efc9fcc77da6d496edbb8\"\n+checksum = \"5287ce36e6c4758fbaf298bd1a8697ad97a4f2375a3d1b61142ea538db4877e5\"\n dependencies = [\n  \"cranelift-codegen-shared\",\n ]\n \n [[package]]\n name = \"cranelift-codegen-shared\"\n-version = \"0.87.0\"\n+version = \"0.88.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3ad794b1b1c2c7bd9f7b76cfe0f084eaf7753e55d56191c3f7d89e8fa4978b99\"\n+checksum = \"2855c24219e2f08827f3f4ffb2da92e134ae8d8ecc185b11ec8f9878cf5f588e\"\n \n [[package]]\n name = \"cranelift-entity\"\n-version = \"0.87.0\"\n+version = \"0.88.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"342da0d5056f4119d3c311c4aab2460ceb6ee6e127bb395b76dd2279a09ea7a5\"\n+checksum = \"0b65673279d75d34bf11af9660ae2dbd1c22e6d28f163f5c72f4e1dc56d56103\"\n \n [[package]]\n name = \"cranelift-frontend\"\n-version = \"0.87.0\"\n+version = \"0.88.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dfff792f775b07d4d9cfe9f1c767ce755c6cbadda1bbd6db18a1c75ff9f7376a\"\n+checksum = \"3ed2b3d7a4751163f6c4a349205ab1b7d9c00eecf19dcea48592ef1f7688eefc\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"log\",\n@@ -110,15 +124,15 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-isle\"\n-version = \"0.87.0\"\n+version = \"0.88.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8d51089478849f2ac8ef60a8a2d5346c8d4abfec0e45ac5b24530ef9f9499e1e\"\n+checksum = \"3be64cecea9d90105fc6a2ba2d003e98c867c1d6c4c86cc878f97ad9fb916293\"\n \n [[package]]\n name = \"cranelift-jit\"\n-version = \"0.87.0\"\n+version = \"0.88.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"095936e41720f86004b4c57ce88e6a13af28646bb3a6fb4afbebd5ae90c50029\"\n+checksum = \"f98ed42a70a0c9c388e34ec9477f57fc7300f541b1e5136a0e2ea02b1fac6015\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -134,19 +148,19 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-module\"\n-version = \"0.87.0\"\n+version = \"0.88.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"704a1aea4723d97eafe0fb7af110f6f6868b1ac95f5380bbc9adb2a3b8cf97e8\"\n+checksum = \"d658ac7f156708bfccb647216cc8b9387469f50d352ba4ad80150541e4ae2d49\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n ]\n \n [[package]]\n name = \"cranelift-native\"\n-version = \"0.87.0\"\n+version = \"0.88.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"885debe62f2078638d6585f54c9f05f5c2008f22ce5a2a9100ada785fc065dbd\"\n+checksum = \"c4a03a6ac1b063e416ca4b93f6247978c991475e8271465340caa6f92f3c16a4\"\n dependencies = [\n  \"cranelift-codegen\",\n  \"libc\",\n@@ -155,9 +169,9 @@ dependencies = [\n \n [[package]]\n name = \"cranelift-object\"\n-version = \"0.87.0\"\n+version = \"0.88.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"aac1310cf1081ae8eca916c92cd163b977c77cab6e831fa812273c26ff921816\"\n+checksum = \"eef0b4119b645b870a43a036d76c0ada3a076b1f82e8b8487659304c8b09049b\"\n dependencies = [\n  \"anyhow\",\n  \"cranelift-codegen\",\n@@ -232,9 +246,9 @@ checksum = \"505e71a4706fa491e9b1b55f51b95d4037d0821ee40131190475f692b35b009b\"\n \n [[package]]\n name = \"libloading\"\n-version = \"0.6.7\"\n+version = \"0.7.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"351a32417a12d5f7e82c368a66781e307834dae04c6ce0cd4456d52989229883\"\n+checksum = \"efbc0f03f9a775e9f6aed295c6a1ba2253c5757a9e03d55c6caa46a681abcddd\"\n dependencies = [\n  \"cfg-if\",\n  \"winapi\","}, {"sha": "09cf5b4a1edd8482ef98d33c5aeb295600947b6a", "filename": "compiler/rustc_codegen_cranelift/Cargo.toml", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2FCargo.toml?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -8,19 +8,19 @@ crate-type = [\"dylib\"]\n \n [dependencies]\n # These have to be in sync with each other\n-cranelift-codegen = { version = \"0.87.0\", features = [\"unwind\", \"all-arch\"] }\n-cranelift-frontend = \"0.87.0\"\n-cranelift-module = \"0.87.0\"\n-cranelift-native = \"0.87.0\"\n-cranelift-jit = { version = \"0.87.0\", optional = true }\n-cranelift-object = \"0.87.0\"\n+cranelift-codegen = { version = \"0.88.1\", features = [\"unwind\", \"all-arch\"] }\n+cranelift-frontend = \"0.88.1\"\n+cranelift-module = \"0.88.1\"\n+cranelift-native = \"0.88.1\"\n+cranelift-jit = { version = \"0.88.1\", optional = true }\n+cranelift-object = \"0.88.1\"\n target-lexicon = \"0.12.0\"\n gimli = { version = \"0.26.0\", default-features = false, features = [\"write\"]}\n object = { version = \"0.29.0\", default-features = false, features = [\"std\", \"read_core\", \"write\", \"archive\", \"coff\", \"elf\", \"macho\", \"pe\"] }\n \n ar = { git = \"https://github.com/bjorn3/rust-ar.git\", branch = \"do_not_remove_cg_clif_ranlib\" }\n indexmap = \"1.9.1\"\n-libloading = { version = \"0.6.0\", optional = true }\n+libloading = { version = \"0.7.3\", optional = true }\n once_cell = \"1.10.0\"\n smallvec = \"1.8.1\"\n "}, {"sha": "f6a9cb67290c7d88d591a72b2abfafaa2df67c28", "filename": "compiler/rustc_codegen_cranelift/build_sysroot/Cargo.lock", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_sysroot%2FCargo.lock?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -54,11 +54,21 @@ dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n \n+[[package]]\n+name = \"cfg-if\"\n+version = \"1.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n+dependencies = [\n+ \"compiler_builtins\",\n+ \"rustc-std-workspace-core\",\n+]\n+\n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.79\"\n+version = \"0.1.82\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4f873ce2bd3550b0b565f878b3d04ea8253f4259dc3d20223af2e1ba86f5ecca\"\n+checksum = \"18cd7635fea7bb481ea543b392789844c1ad581299da70184c7175ce3af76603\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -123,9 +133,9 @@ dependencies = [\n \n [[package]]\n name = \"hermit-abi\"\n-version = \"0.2.5\"\n+version = \"0.2.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"897cd85af6387be149f55acf168e41be176a02de7872403aaab184afc2f327e6\"\n+checksum = \"ee512640fe35acbfb4bb779db6f0d80704c2cacfa2e39b601ef3e3f47d1ae4c7\"\n dependencies = [\n  \"compiler_builtins\",\n  \"libc\",\n@@ -135,9 +145,9 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.132\"\n+version = \"0.2.135\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8371e4e5341c3a96db127eb2465ac681ced4c433e01dd0e938adbef26ba93ba5\"\n+checksum = \"68783febc7782c6c5cb401fbda4de5a9898be1762314da0bb2c10ced61f18b0c\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -182,7 +192,7 @@ name = \"panic_abort\"\n version = \"0.0.0\"\n dependencies = [\n  \"alloc\",\n- \"cfg-if\",\n+ \"cfg-if 0.1.10\",\n  \"compiler_builtins\",\n  \"core\",\n  \"libc\",\n@@ -193,7 +203,7 @@ name = \"panic_unwind\"\n version = \"0.0.0\"\n dependencies = [\n  \"alloc\",\n- \"cfg-if\",\n+ \"cfg-if 0.1.10\",\n  \"compiler_builtins\",\n  \"core\",\n  \"libc\",\n@@ -245,7 +255,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"addr2line\",\n  \"alloc\",\n- \"cfg-if\",\n+ \"cfg-if 1.0.0\",\n  \"compiler_builtins\",\n  \"core\",\n  \"dlmalloc\",\n@@ -267,7 +277,7 @@ dependencies = [\n name = \"std_detect\"\n version = \"0.1.5\"\n dependencies = [\n- \"cfg-if\",\n+ \"cfg-if 1.0.0\",\n  \"compiler_builtins\",\n  \"libc\",\n  \"rustc-std-workspace-alloc\",\n@@ -289,7 +299,7 @@ dependencies = [\n name = \"test\"\n version = \"0.0.0\"\n dependencies = [\n- \"cfg-if\",\n+ \"cfg-if 0.1.10\",\n  \"core\",\n  \"getopts\",\n  \"libc\",\n@@ -301,9 +311,9 @@ dependencies = [\n \n [[package]]\n name = \"unicode-width\"\n-version = \"0.1.9\"\n+version = \"0.1.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3ed742d4ea2bd1176e236172c8429aaf54486e7ac098db29ffe6529e0ce50973\"\n+checksum = \"c0edd1e5b14653f783770bce4a4dabb4a5108a5370a5f5d8cfe8710c361f6c8b\"\n dependencies = [\n  \"compiler_builtins\",\n  \"rustc-std-workspace-core\",\n@@ -315,7 +325,7 @@ name = \"unwind\"\n version = \"0.0.0\"\n dependencies = [\n  \"cc\",\n- \"cfg-if\",\n+ \"cfg-if 0.1.10\",\n  \"compiler_builtins\",\n  \"core\",\n  \"libc\","}, {"sha": "fae5b27163680badc511023892f92fe462ddfbaf", "filename": "compiler/rustc_codegen_cranelift/build_system/abi_cafe.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fabi_cafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fabi_cafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fabi_cafe.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -0,0 +1,52 @@\n+use std::env;\n+use std::path::Path;\n+\n+use super::build_sysroot;\n+use super::config;\n+use super::prepare;\n+use super::utils::{cargo_command, spawn_and_wait};\n+use super::SysrootKind;\n+\n+pub(crate) fn run(\n+    channel: &str,\n+    sysroot_kind: SysrootKind,\n+    target_dir: &Path,\n+    cg_clif_dylib: &Path,\n+    host_triple: &str,\n+    target_triple: &str,\n+) {\n+    if !config::get_bool(\"testsuite.abi-cafe\") {\n+        eprintln!(\"[SKIP] abi-cafe\");\n+        return;\n+    }\n+\n+    if host_triple != target_triple {\n+        eprintln!(\"[SKIP] abi-cafe (cross-compilation not supported)\");\n+        return;\n+    }\n+\n+    eprintln!(\"Building sysroot for abi-cafe\");\n+    build_sysroot::build_sysroot(\n+        channel,\n+        sysroot_kind,\n+        target_dir,\n+        cg_clif_dylib,\n+        host_triple,\n+        target_triple,\n+    );\n+\n+    eprintln!(\"Running abi-cafe\");\n+    let abi_cafe_path = prepare::ABI_CAFE.source_dir();\n+    env::set_current_dir(abi_cafe_path.clone()).unwrap();\n+\n+    let pairs = [\"rustc_calls_cgclif\", \"cgclif_calls_rustc\", \"cgclif_calls_cc\", \"cc_calls_cgclif\"];\n+\n+    let mut cmd = cargo_command(\"cargo\", \"run\", Some(target_triple), &abi_cafe_path);\n+    cmd.arg(\"--\");\n+    cmd.arg(\"--pairs\");\n+    cmd.args(pairs);\n+    cmd.arg(\"--add-rustc-codegen-backend\");\n+    cmd.arg(format!(\"cgclif:{}\", cg_clif_dylib.display()));\n+\n+    spawn_and_wait(cmd);\n+}"}, {"sha": "67dbd0a38a4fb4d44d0579e907bbc1a4c6bc9de0", "filename": "compiler/rustc_codegen_cranelift/build_system/abi_checker.rs", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/cfd99a2bbe83ae35ad0eb9d963ca97cf6c34471a/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fabi_checker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfd99a2bbe83ae35ad0eb9d963ca97cf6c34471a/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fabi_checker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fabi_checker.rs?ref=cfd99a2bbe83ae35ad0eb9d963ca97cf6c34471a", "patch": "@@ -1,60 +0,0 @@\n-use super::build_sysroot;\n-use super::config;\n-use super::utils::spawn_and_wait;\n-use build_system::SysrootKind;\n-use std::env;\n-use std::path::Path;\n-use std::process::Command;\n-\n-pub(crate) fn run(\n-    channel: &str,\n-    sysroot_kind: SysrootKind,\n-    target_dir: &Path,\n-    cg_clif_build_dir: &Path,\n-    host_triple: &str,\n-    target_triple: &str,\n-) {\n-    if !config::get_bool(\"testsuite.abi-checker\") {\n-        eprintln!(\"[SKIP] abi-checker\");\n-        return;\n-    }\n-\n-    if host_triple != target_triple {\n-        eprintln!(\"[SKIP] abi-checker (cross-compilation not supported)\");\n-        return;\n-    }\n-\n-    eprintln!(\"Building sysroot for abi-checker\");\n-    build_sysroot::build_sysroot(\n-        channel,\n-        sysroot_kind,\n-        target_dir,\n-        cg_clif_build_dir,\n-        host_triple,\n-        target_triple,\n-    );\n-\n-    eprintln!(\"Running abi-checker\");\n-    let mut abi_checker_path = env::current_dir().unwrap();\n-    abi_checker_path.push(\"abi-checker\");\n-    env::set_current_dir(abi_checker_path.clone()).unwrap();\n-\n-    let build_dir = abi_checker_path.parent().unwrap().join(\"build\");\n-    let cg_clif_dylib_path = build_dir.join(if cfg!(windows) { \"bin\" } else { \"lib\" }).join(\n-        env::consts::DLL_PREFIX.to_string() + \"rustc_codegen_cranelift\" + env::consts::DLL_SUFFIX,\n-    );\n-\n-    let pairs = [\"rustc_calls_cgclif\", \"cgclif_calls_rustc\", \"cgclif_calls_cc\", \"cc_calls_cgclif\"];\n-\n-    let mut cmd = Command::new(\"cargo\");\n-    cmd.arg(\"run\");\n-    cmd.arg(\"--target\");\n-    cmd.arg(target_triple);\n-    cmd.arg(\"--\");\n-    cmd.arg(\"--pairs\");\n-    cmd.args(pairs);\n-    cmd.arg(\"--add-rustc-codegen-backend\");\n-    cmd.arg(format!(\"cgclif:{}\", cg_clif_dylib_path.display()));\n-\n-    spawn_and_wait(cmd);\n-}"}, {"sha": "cda468bcfa2dfc2e0bfe494bd5a1a9414a97eed6", "filename": "compiler/rustc_codegen_cranelift/build_system/build_backend.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_backend.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -1,16 +1,16 @@\n use std::env;\n-use std::path::{Path, PathBuf};\n-use std::process::Command;\n+use std::path::PathBuf;\n \n-use super::utils::is_ci;\n+use super::rustc_info::get_file_name;\n+use super::utils::{cargo_command, is_ci};\n \n pub(crate) fn build_backend(\n     channel: &str,\n     host_triple: &str,\n     use_unstable_features: bool,\n ) -> PathBuf {\n-    let mut cmd = Command::new(\"cargo\");\n-    cmd.arg(\"build\").arg(\"--target\").arg(host_triple);\n+    let source_dir = std::env::current_dir().unwrap();\n+    let mut cmd = cargo_command(\"cargo\", \"build\", Some(host_triple), &source_dir);\n \n     cmd.env(\"CARGO_BUILD_INCREMENTAL\", \"true\"); // Force incr comp even in release mode\n \n@@ -41,5 +41,9 @@ pub(crate) fn build_backend(\n     eprintln!(\"[BUILD] rustc_codegen_cranelift\");\n     super::utils::spawn_and_wait(cmd);\n \n-    Path::new(\"target\").join(host_triple).join(channel)\n+    source_dir\n+        .join(\"target\")\n+        .join(host_triple)\n+        .join(channel)\n+        .join(get_file_name(\"rustc_codegen_cranelift\", \"dylib\"))\n }"}, {"sha": "856aecc49fd1c05f476c91232c9bb0b429c4c907", "filename": "compiler/rustc_codegen_cranelift/build_system/build_sysroot.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fbuild_sysroot.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -3,14 +3,14 @@ use std::path::{Path, PathBuf};\n use std::process::{self, Command};\n \n use super::rustc_info::{get_file_name, get_rustc_version, get_wrapper_file_name};\n-use super::utils::{spawn_and_wait, try_hard_link};\n+use super::utils::{cargo_command, spawn_and_wait, try_hard_link};\n use super::SysrootKind;\n \n pub(crate) fn build_sysroot(\n     channel: &str,\n     sysroot_kind: SysrootKind,\n     target_dir: &Path,\n-    cg_clif_build_dir: &Path,\n+    cg_clif_dylib_src: &Path,\n     host_triple: &str,\n     target_triple: &str,\n ) {\n@@ -23,7 +23,6 @@ pub(crate) fn build_sysroot(\n     fs::create_dir_all(target_dir.join(\"lib\")).unwrap();\n \n     // Copy the backend\n-    let cg_clif_dylib = get_file_name(\"rustc_codegen_cranelift\", \"dylib\");\n     let cg_clif_dylib_path = target_dir\n         .join(if cfg!(windows) {\n             // Windows doesn't have rpath support, so the cg_clif dylib needs to be next to the\n@@ -32,8 +31,8 @@ pub(crate) fn build_sysroot(\n         } else {\n             \"lib\"\n         })\n-        .join(&cg_clif_dylib);\n-    try_hard_link(cg_clif_build_dir.join(cg_clif_dylib), &cg_clif_dylib_path);\n+        .join(get_file_name(\"rustc_codegen_cranelift\", \"dylib\"));\n+    try_hard_link(cg_clif_dylib_src, &cg_clif_dylib_path);\n \n     // Build and copy rustc and cargo wrappers\n     for wrapper in [\"rustc-clif\", \"cargo-clif\"] {\n@@ -186,10 +185,10 @@ fn build_clif_sysroot_for_triple(\n     }\n \n     // Build sysroot\n-    let mut build_cmd = Command::new(\"cargo\");\n-    build_cmd.arg(\"build\").arg(\"--target\").arg(triple).current_dir(\"build_sysroot\");\n+    let mut build_cmd = cargo_command(\"cargo\", \"build\", Some(triple), Path::new(\"build_sysroot\"));\n     let mut rustflags = \"-Zforce-unstable-if-unmarked -Cpanic=abort\".to_string();\n     rustflags.push_str(&format!(\" -Zcodegen-backend={}\", cg_clif_dylib_path.to_str().unwrap()));\n+    rustflags.push_str(&format!(\" --sysroot={}\", target_dir.to_str().unwrap()));\n     if channel == \"release\" {\n         build_cmd.arg(\"--release\");\n         rustflags.push_str(\" -Zmir-opt-level=3\");"}, {"sha": "c31784e1097dc25f1b43a8a4dc1f59a4666c192f", "filename": "compiler/rustc_codegen_cranelift/build_system/config.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fconfig.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -1,4 +1,5 @@\n-use std::{fs, process};\n+use std::fs;\n+use std::process;\n \n fn load_config_file() -> Vec<(String, Option<String>)> {\n     fs::read_to_string(\"config.txt\")"}, {"sha": "b25270d832ceb4fd483cfdbad2b6b712a4ee1a50", "filename": "compiler/rustc_codegen_cranelift/build_system/mod.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fmod.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -4,7 +4,7 @@ use std::process;\n \n use self::utils::is_ci;\n \n-mod abi_checker;\n+mod abi_cafe;\n mod build_backend;\n mod build_sysroot;\n mod config;\n@@ -122,32 +122,23 @@ pub fn main() {\n         host_triple.clone()\n     };\n \n-    if target_triple.ends_with(\"-msvc\") {\n-        eprintln!(\"The MSVC toolchain is not yet supported by rustc_codegen_cranelift.\");\n-        eprintln!(\"Switch to the MinGW toolchain for Windows support.\");\n-        eprintln!(\"Hint: You can use `rustup set default-host x86_64-pc-windows-gnu` to\");\n-        eprintln!(\"set the global default target to MinGW\");\n-        process::exit(1);\n-    }\n-\n-    let cg_clif_build_dir =\n-        build_backend::build_backend(channel, &host_triple, use_unstable_features);\n+    let cg_clif_dylib = build_backend::build_backend(channel, &host_triple, use_unstable_features);\n     match command {\n         Command::Test => {\n             tests::run_tests(\n                 channel,\n                 sysroot_kind,\n                 &target_dir,\n-                &cg_clif_build_dir,\n+                &cg_clif_dylib,\n                 &host_triple,\n                 &target_triple,\n             );\n \n-            abi_checker::run(\n+            abi_cafe::run(\n                 channel,\n                 sysroot_kind,\n                 &target_dir,\n-                &cg_clif_build_dir,\n+                &cg_clif_dylib,\n                 &host_triple,\n                 &target_triple,\n             );\n@@ -157,7 +148,7 @@ pub fn main() {\n                 channel,\n                 sysroot_kind,\n                 &target_dir,\n-                &cg_clif_build_dir,\n+                &cg_clif_dylib,\n                 &host_triple,\n                 &target_triple,\n             );"}, {"sha": "3111f62f6c2156eaec0ef00a9a7213acf8950f88", "filename": "compiler/rustc_codegen_cranelift/build_system/prepare.rs", "status": "modified", "additions": 119, "deletions": 67, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Fprepare.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -1,64 +1,63 @@\n use std::env;\n use std::ffi::OsStr;\n-use std::ffi::OsString;\n use std::fs;\n-use std::path::Path;\n+use std::path::{Path, PathBuf};\n use std::process::Command;\n \n use super::rustc_info::{get_file_name, get_rustc_path, get_rustc_version};\n-use super::utils::{copy_dir_recursively, spawn_and_wait};\n+use super::utils::{cargo_command, copy_dir_recursively, spawn_and_wait};\n+\n+pub(crate) const ABI_CAFE: GitRepo =\n+    GitRepo::github(\"Gankra\", \"abi-cafe\", \"4c6dc8c9c687e2b3a760ff2176ce236872b37212\", \"abi-cafe\");\n+\n+pub(crate) const RAND: GitRepo =\n+    GitRepo::github(\"rust-random\", \"rand\", \"0f933f9c7176e53b2a3c7952ded484e1783f0bf1\", \"rand\");\n+\n+pub(crate) const REGEX: GitRepo =\n+    GitRepo::github(\"rust-lang\", \"regex\", \"341f207c1071f7290e3f228c710817c280c8dca1\", \"regex\");\n+\n+pub(crate) const PORTABLE_SIMD: GitRepo = GitRepo::github(\n+    \"rust-lang\",\n+    \"portable-simd\",\n+    \"d5cd4a8112d958bd3a252327e0d069a6363249bd\",\n+    \"portable-simd\",\n+);\n+\n+pub(crate) const SIMPLE_RAYTRACER: GitRepo = GitRepo::github(\n+    \"ebobby\",\n+    \"simple-raytracer\",\n+    \"804a7a21b9e673a482797aa289a18ed480e4d813\",\n+    \"<none>\",\n+);\n \n pub(crate) fn prepare() {\n+    if Path::new(\"download\").exists() {\n+        std::fs::remove_dir_all(Path::new(\"download\")).unwrap();\n+    }\n+    std::fs::create_dir_all(Path::new(\"download\")).unwrap();\n+\n     prepare_sysroot();\n \n+    // FIXME maybe install this only locally?\n     eprintln!(\"[INSTALL] hyperfine\");\n     Command::new(\"cargo\").arg(\"install\").arg(\"hyperfine\").spawn().unwrap().wait().unwrap();\n \n-    clone_repo_shallow_github(\n-        \"abi-checker\",\n-        \"Gankra\",\n-        \"abi-checker\",\n-        \"a2232d45f202846f5c02203c9f27355360f9a2ff\",\n-    );\n-    apply_patches(\"abi-checker\", Path::new(\"abi-checker\"));\n-\n-    clone_repo_shallow_github(\n-        \"rand\",\n-        \"rust-random\",\n-        \"rand\",\n-        \"0f933f9c7176e53b2a3c7952ded484e1783f0bf1\",\n-    );\n-    apply_patches(\"rand\", Path::new(\"rand\"));\n-\n-    clone_repo_shallow_github(\n-        \"regex\",\n-        \"rust-lang\",\n-        \"regex\",\n-        \"341f207c1071f7290e3f228c710817c280c8dca1\",\n-    );\n-\n-    clone_repo_shallow_github(\n-        \"portable-simd\",\n-        \"rust-lang\",\n-        \"portable-simd\",\n-        \"b8d6b6844602f80af79cd96401339ec594d472d8\",\n-    );\n-    apply_patches(\"portable-simd\", Path::new(\"portable-simd\"));\n-\n-    clone_repo_shallow_github(\n-        \"simple-raytracer\",\n-        \"ebobby\",\n-        \"simple-raytracer\",\n-        \"804a7a21b9e673a482797aa289a18ed480e4d813\",\n-    );\n+    ABI_CAFE.fetch();\n+    RAND.fetch();\n+    REGEX.fetch();\n+    PORTABLE_SIMD.fetch();\n+    SIMPLE_RAYTRACER.fetch();\n \n     eprintln!(\"[LLVM BUILD] simple-raytracer\");\n-    let mut build_cmd = Command::new(\"cargo\");\n-    build_cmd.arg(\"build\").env_remove(\"CARGO_TARGET_DIR\").current_dir(\"simple-raytracer\");\n+    let build_cmd = cargo_command(\"cargo\", \"build\", None, &SIMPLE_RAYTRACER.source_dir());\n     spawn_and_wait(build_cmd);\n     fs::copy(\n-        Path::new(\"simple-raytracer/target/debug\").join(get_file_name(\"main\", \"bin\")),\n-        Path::new(\"simple-raytracer\").join(get_file_name(\"raytracer_cg_llvm\", \"bin\")),\n+        SIMPLE_RAYTRACER\n+            .source_dir()\n+            .join(\"target\")\n+            .join(\"debug\")\n+            .join(get_file_name(\"main\", \"bin\")),\n+        SIMPLE_RAYTRACER.source_dir().join(get_file_name(\"raytracer_cg_llvm\", \"bin\")),\n     )\n     .unwrap();\n }\n@@ -90,38 +89,78 @@ fn prepare_sysroot() {\n     apply_patches(\"sysroot\", &sysroot_src);\n }\n \n+pub(crate) struct GitRepo {\n+    url: GitRepoUrl,\n+    rev: &'static str,\n+    patch_name: &'static str,\n+}\n+\n+enum GitRepoUrl {\n+    Github { user: &'static str, repo: &'static str },\n+}\n+\n+impl GitRepo {\n+    const fn github(\n+        user: &'static str,\n+        repo: &'static str,\n+        rev: &'static str,\n+        patch_name: &'static str,\n+    ) -> GitRepo {\n+        GitRepo { url: GitRepoUrl::Github { user, repo }, rev, patch_name }\n+    }\n+\n+    pub(crate) fn source_dir(&self) -> PathBuf {\n+        match self.url {\n+            GitRepoUrl::Github { user: _, repo } => {\n+                std::env::current_dir().unwrap().join(\"download\").join(repo)\n+            }\n+        }\n+    }\n+\n+    fn fetch(&self) {\n+        match self.url {\n+            GitRepoUrl::Github { user, repo } => {\n+                clone_repo_shallow_github(&self.source_dir(), user, repo, self.rev);\n+            }\n+        }\n+        apply_patches(self.patch_name, &self.source_dir());\n+    }\n+}\n+\n #[allow(dead_code)]\n-fn clone_repo(target_dir: &str, repo: &str, rev: &str) {\n+fn clone_repo(download_dir: &Path, repo: &str, rev: &str) {\n     eprintln!(\"[CLONE] {}\", repo);\n     // Ignore exit code as the repo may already have been checked out\n-    Command::new(\"git\").arg(\"clone\").arg(repo).arg(target_dir).spawn().unwrap().wait().unwrap();\n+    Command::new(\"git\").arg(\"clone\").arg(repo).arg(&download_dir).spawn().unwrap().wait().unwrap();\n \n     let mut clean_cmd = Command::new(\"git\");\n-    clean_cmd.arg(\"checkout\").arg(\"--\").arg(\".\").current_dir(target_dir);\n+    clean_cmd.arg(\"checkout\").arg(\"--\").arg(\".\").current_dir(&download_dir);\n     spawn_and_wait(clean_cmd);\n \n     let mut checkout_cmd = Command::new(\"git\");\n-    checkout_cmd.arg(\"checkout\").arg(\"-q\").arg(rev).current_dir(target_dir);\n+    checkout_cmd.arg(\"checkout\").arg(\"-q\").arg(rev).current_dir(download_dir);\n     spawn_and_wait(checkout_cmd);\n }\n \n-fn clone_repo_shallow_github(target_dir: &str, username: &str, repo: &str, rev: &str) {\n+fn clone_repo_shallow_github(download_dir: &Path, user: &str, repo: &str, rev: &str) {\n     if cfg!(windows) {\n         // Older windows doesn't have tar or curl by default. Fall back to using git.\n-        clone_repo(target_dir, &format!(\"https://github.com/{}/{}.git\", username, repo), rev);\n+        clone_repo(download_dir, &format!(\"https://github.com/{}/{}.git\", user, repo), rev);\n         return;\n     }\n \n-    let archive_url = format!(\"https://github.com/{}/{}/archive/{}.tar.gz\", username, repo, rev);\n-    let archive_file = format!(\"{}.tar.gz\", rev);\n-    let archive_dir = format!(\"{}-{}\", repo, rev);\n+    let downloads_dir = std::env::current_dir().unwrap().join(\"download\");\n+\n+    let archive_url = format!(\"https://github.com/{}/{}/archive/{}.tar.gz\", user, repo, rev);\n+    let archive_file = downloads_dir.join(format!(\"{}.tar.gz\", rev));\n+    let archive_dir = downloads_dir.join(format!(\"{}-{}\", repo, rev));\n \n-    eprintln!(\"[DOWNLOAD] {}/{} from {}\", username, repo, archive_url);\n+    eprintln!(\"[DOWNLOAD] {}/{} from {}\", user, repo, archive_url);\n \n     // Remove previous results if they exists\n     let _ = std::fs::remove_file(&archive_file);\n     let _ = std::fs::remove_dir_all(&archive_dir);\n-    let _ = std::fs::remove_dir_all(target_dir);\n+    let _ = std::fs::remove_dir_all(&download_dir);\n \n     // Download zip archive\n     let mut download_cmd = Command::new(\"curl\");\n@@ -130,13 +169,13 @@ fn clone_repo_shallow_github(target_dir: &str, username: &str, repo: &str, rev:\n \n     // Unpack tar archive\n     let mut unpack_cmd = Command::new(\"tar\");\n-    unpack_cmd.arg(\"xf\").arg(&archive_file);\n+    unpack_cmd.arg(\"xf\").arg(&archive_file).current_dir(downloads_dir);\n     spawn_and_wait(unpack_cmd);\n \n     // Rename unpacked dir to the expected name\n-    std::fs::rename(archive_dir, target_dir).unwrap();\n+    std::fs::rename(archive_dir, &download_dir).unwrap();\n \n-    init_git_repo(Path::new(target_dir));\n+    init_git_repo(&download_dir);\n \n     // Cleanup\n     std::fs::remove_file(archive_file).unwrap();\n@@ -156,26 +195,39 @@ fn init_git_repo(repo_dir: &Path) {\n     spawn_and_wait(git_commit_cmd);\n }\n \n-fn get_patches(crate_name: &str) -> Vec<OsString> {\n-    let mut patches: Vec<_> = fs::read_dir(\"patches\")\n+fn get_patches(source_dir: &Path, crate_name: &str) -> Vec<PathBuf> {\n+    let mut patches: Vec<_> = fs::read_dir(source_dir.join(\"patches\"))\n         .unwrap()\n         .map(|entry| entry.unwrap().path())\n         .filter(|path| path.extension() == Some(OsStr::new(\"patch\")))\n-        .map(|path| path.file_name().unwrap().to_owned())\n-        .filter(|file_name| {\n-            file_name.to_str().unwrap().split_once(\"-\").unwrap().1.starts_with(crate_name)\n+        .filter(|path| {\n+            path.file_name()\n+                .unwrap()\n+                .to_str()\n+                .unwrap()\n+                .split_once(\"-\")\n+                .unwrap()\n+                .1\n+                .starts_with(crate_name)\n         })\n         .collect();\n     patches.sort();\n     patches\n }\n \n fn apply_patches(crate_name: &str, target_dir: &Path) {\n-    for patch in get_patches(crate_name) {\n-        eprintln!(\"[PATCH] {:?} <- {:?}\", target_dir.file_name().unwrap(), patch);\n-        let patch_arg = env::current_dir().unwrap().join(\"patches\").join(patch);\n+    if crate_name == \"<none>\" {\n+        return;\n+    }\n+\n+    for patch in get_patches(&std::env::current_dir().unwrap(), crate_name) {\n+        eprintln!(\n+            \"[PATCH] {:?} <- {:?}\",\n+            target_dir.file_name().unwrap(),\n+            patch.file_name().unwrap()\n+        );\n         let mut apply_patch_cmd = Command::new(\"git\");\n-        apply_patch_cmd.arg(\"am\").arg(patch_arg).arg(\"-q\").current_dir(target_dir);\n+        apply_patch_cmd.arg(\"am\").arg(patch).arg(\"-q\").current_dir(target_dir);\n         spawn_and_wait(apply_patch_cmd);\n     }\n }"}, {"sha": "a414b60f4e06b2b79dccc1ee64bc233f32ae6ba1", "filename": "compiler/rustc_codegen_cranelift/build_system/tests.rs", "status": "modified", "additions": 85, "deletions": 94, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Ftests.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -1,7 +1,8 @@\n use super::build_sysroot;\n use super::config;\n+use super::prepare;\n use super::rustc_info::get_wrapper_file_name;\n-use super::utils::{spawn_and_wait, spawn_and_wait_with_input};\n+use super::utils::{cargo_command, hyperfine_command, spawn_and_wait, spawn_and_wait_with_input};\n use build_system::SysrootKind;\n use std::env;\n use std::ffi::OsStr;\n@@ -217,103 +218,95 @@ const BASE_SYSROOT_SUITE: &[TestCase] = &[\n \n const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n     TestCase::new(\"test.rust-random/rand\", &|runner| {\n-        runner.in_dir([\"rand\"], |runner| {\n-            runner.run_cargo([\"clean\"]);\n+        runner.in_dir(prepare::RAND.source_dir(), |runner| {\n+            runner.run_cargo(\"clean\", []);\n \n             if runner.host_triple == runner.target_triple {\n                 eprintln!(\"[TEST] rust-random/rand\");\n-                runner.run_cargo([\"test\", \"--workspace\"]);\n+                runner.run_cargo(\"test\", [\"--workspace\"]);\n             } else {\n                 eprintln!(\"[AOT] rust-random/rand\");\n-                runner.run_cargo([\n-                    \"build\",\n-                    \"--workspace\",\n-                    \"--target\",\n-                    &runner.target_triple,\n-                    \"--tests\",\n-                ]);\n+                runner.run_cargo(\"build\", [\"--workspace\", \"--tests\"]);\n             }\n         });\n     }),\n     TestCase::new(\"bench.simple-raytracer\", &|runner| {\n-        runner.in_dir([\"simple-raytracer\"], |runner| {\n-            let run_runs = env::var(\"RUN_RUNS\").unwrap_or(\"10\".to_string());\n+        runner.in_dir(prepare::SIMPLE_RAYTRACER.source_dir(), |runner| {\n+            let run_runs = env::var(\"RUN_RUNS\").unwrap_or(\"10\".to_string()).parse().unwrap();\n \n             if runner.host_triple == runner.target_triple {\n                 eprintln!(\"[BENCH COMPILE] ebobby/simple-raytracer\");\n-                let mut bench_compile = Command::new(\"hyperfine\");\n-                bench_compile.arg(\"--runs\");\n-                bench_compile.arg(&run_runs);\n-                bench_compile.arg(\"--warmup\");\n-                bench_compile.arg(\"1\");\n-                bench_compile.arg(\"--prepare\");\n-                bench_compile.arg(format!(\"{:?}\", runner.cargo_command([\"clean\"])));\n-\n-                if cfg!(windows) {\n-                    bench_compile.arg(\"cmd /C \\\"set RUSTFLAGS= && cargo build\\\"\");\n-                } else {\n-                    bench_compile.arg(\"RUSTFLAGS='' cargo build\");\n-                }\n+                let prepare = runner.cargo_command(\"clean\", []);\n+\n+                let llvm_build_cmd = cargo_command(\"cargo\", \"build\", None, Path::new(\".\"));\n+\n+                let cargo_clif = runner\n+                    .root_dir\n+                    .clone()\n+                    .join(\"build\")\n+                    .join(get_wrapper_file_name(\"cargo-clif\", \"bin\"));\n+                let clif_build_cmd = cargo_command(cargo_clif, \"build\", None, Path::new(\".\"));\n+\n+                let bench_compile =\n+                    hyperfine_command(1, run_runs, Some(prepare), llvm_build_cmd, clif_build_cmd);\n \n-                bench_compile.arg(format!(\"{:?}\", runner.cargo_command([\"build\"])));\n                 spawn_and_wait(bench_compile);\n \n                 eprintln!(\"[BENCH RUN] ebobby/simple-raytracer\");\n                 fs::copy(PathBuf::from(\"./target/debug/main\"), PathBuf::from(\"raytracer_cg_clif\"))\n                     .unwrap();\n \n-                let mut bench_run = Command::new(\"hyperfine\");\n-                bench_run.arg(\"--runs\");\n-                bench_run.arg(&run_runs);\n-                bench_run.arg(PathBuf::from(\"./raytracer_cg_llvm\"));\n-                bench_run.arg(PathBuf::from(\"./raytracer_cg_clif\"));\n+                let bench_run = hyperfine_command(\n+                    0,\n+                    run_runs,\n+                    None,\n+                    Command::new(\"./raytracer_cg_llvm\"),\n+                    Command::new(\"./raytracer_cg_clif\"),\n+                );\n                 spawn_and_wait(bench_run);\n             } else {\n-                runner.run_cargo([\"clean\"]);\n+                runner.run_cargo(\"clean\", []);\n                 eprintln!(\"[BENCH COMPILE] ebobby/simple-raytracer (skipped)\");\n                 eprintln!(\"[COMPILE] ebobby/simple-raytracer\");\n-                runner.run_cargo([\"build\", \"--target\", &runner.target_triple]);\n+                runner.run_cargo(\"build\", []);\n                 eprintln!(\"[BENCH RUN] ebobby/simple-raytracer (skipped)\");\n             }\n         });\n     }),\n     TestCase::new(\"test.libcore\", &|runner| {\n-        runner.in_dir([\"build_sysroot\", \"sysroot_src\", \"library\", \"core\", \"tests\"], |runner| {\n-            runner.run_cargo([\"clean\"]);\n-\n-            if runner.host_triple == runner.target_triple {\n-                runner.run_cargo([\"test\"]);\n-            } else {\n-                eprintln!(\"Cross-Compiling: Not running tests\");\n-                runner.run_cargo([\"build\", \"--target\", &runner.target_triple, \"--tests\"]);\n-            }\n-        });\n+        runner.in_dir(\n+            std::env::current_dir()\n+                .unwrap()\n+                .join(\"build_sysroot\")\n+                .join(\"sysroot_src\")\n+                .join(\"library\")\n+                .join(\"core\")\n+                .join(\"tests\"),\n+            |runner| {\n+                runner.run_cargo(\"clean\", []);\n+\n+                if runner.host_triple == runner.target_triple {\n+                    runner.run_cargo(\"test\", []);\n+                } else {\n+                    eprintln!(\"Cross-Compiling: Not running tests\");\n+                    runner.run_cargo(\"build\", [\"--tests\"]);\n+                }\n+            },\n+        );\n     }),\n     TestCase::new(\"test.regex-shootout-regex-dna\", &|runner| {\n-        runner.in_dir([\"regex\"], |runner| {\n-            runner.run_cargo([\"clean\"]);\n+        runner.in_dir(prepare::REGEX.source_dir(), |runner| {\n+            runner.run_cargo(\"clean\", []);\n \n             // newer aho_corasick versions throw a deprecation warning\n             let lint_rust_flags = format!(\"{} --cap-lints warn\", runner.rust_flags);\n \n-            let mut build_cmd = runner.cargo_command([\n-                \"build\",\n-                \"--example\",\n-                \"shootout-regex-dna\",\n-                \"--target\",\n-                &runner.target_triple,\n-            ]);\n+            let mut build_cmd = runner.cargo_command(\"build\", [\"--example\", \"shootout-regex-dna\"]);\n             build_cmd.env(\"RUSTFLAGS\", lint_rust_flags.clone());\n             spawn_and_wait(build_cmd);\n \n             if runner.host_triple == runner.target_triple {\n-                let mut run_cmd = runner.cargo_command([\n-                    \"run\",\n-                    \"--example\",\n-                    \"shootout-regex-dna\",\n-                    \"--target\",\n-                    &runner.target_triple,\n-                ]);\n+                let mut run_cmd = runner.cargo_command(\"run\", [\"--example\", \"shootout-regex-dna\"]);\n                 run_cmd.env(\"RUSTFLAGS\", lint_rust_flags);\n \n                 let input =\n@@ -353,41 +346,43 @@ const EXTENDED_SYSROOT_SUITE: &[TestCase] = &[\n         });\n     }),\n     TestCase::new(\"test.regex\", &|runner| {\n-        runner.in_dir([\"regex\"], |runner| {\n-            runner.run_cargo([\"clean\"]);\n+        runner.in_dir(prepare::REGEX.source_dir(), |runner| {\n+            runner.run_cargo(\"clean\", []);\n \n             // newer aho_corasick versions throw a deprecation warning\n             let lint_rust_flags = format!(\"{} --cap-lints warn\", runner.rust_flags);\n \n             if runner.host_triple == runner.target_triple {\n-                let mut run_cmd = runner.cargo_command([\n+                let mut run_cmd = runner.cargo_command(\n                     \"test\",\n-                    \"--tests\",\n-                    \"--\",\n-                    \"--exclude-should-panic\",\n-                    \"--test-threads\",\n-                    \"1\",\n-                    \"-Zunstable-options\",\n-                    \"-q\",\n-                ]);\n+                    [\n+                        \"--tests\",\n+                        \"--\",\n+                        \"--exclude-should-panic\",\n+                        \"--test-threads\",\n+                        \"1\",\n+                        \"-Zunstable-options\",\n+                        \"-q\",\n+                    ],\n+                );\n                 run_cmd.env(\"RUSTFLAGS\", lint_rust_flags);\n                 spawn_and_wait(run_cmd);\n             } else {\n                 eprintln!(\"Cross-Compiling: Not running tests\");\n                 let mut build_cmd =\n-                    runner.cargo_command([\"build\", \"--tests\", \"--target\", &runner.target_triple]);\n+                    runner.cargo_command(\"build\", [\"--tests\", \"--target\", &runner.target_triple]);\n                 build_cmd.env(\"RUSTFLAGS\", lint_rust_flags.clone());\n                 spawn_and_wait(build_cmd);\n             }\n         });\n     }),\n     TestCase::new(\"test.portable-simd\", &|runner| {\n-        runner.in_dir([\"portable-simd\"], |runner| {\n-            runner.run_cargo([\"clean\"]);\n-            runner.run_cargo([\"build\", \"--all-targets\", \"--target\", &runner.target_triple]);\n+        runner.in_dir(prepare::PORTABLE_SIMD.source_dir(), |runner| {\n+            runner.run_cargo(\"clean\", []);\n+            runner.run_cargo(\"build\", [\"--all-targets\", \"--target\", &runner.target_triple]);\n \n             if runner.host_triple == runner.target_triple {\n-                runner.run_cargo([\"test\", \"-q\"]);\n+                runner.run_cargo(\"test\", [\"-q\"]);\n             }\n         });\n     }),\n@@ -397,7 +392,7 @@ pub(crate) fn run_tests(\n     channel: &str,\n     sysroot_kind: SysrootKind,\n     target_dir: &Path,\n-    cg_clif_build_dir: &Path,\n+    cg_clif_dylib: &Path,\n     host_triple: &str,\n     target_triple: &str,\n ) {\n@@ -408,7 +403,7 @@ pub(crate) fn run_tests(\n             channel,\n             SysrootKind::None,\n             &target_dir,\n-            cg_clif_build_dir,\n+            cg_clif_dylib,\n             &host_triple,\n             &target_triple,\n         );\n@@ -427,7 +422,7 @@ pub(crate) fn run_tests(\n             channel,\n             sysroot_kind,\n             &target_dir,\n-            cg_clif_build_dir,\n+            cg_clif_dylib,\n             &host_triple,\n             &target_triple,\n         );\n@@ -521,16 +516,8 @@ impl TestRunner {\n         }\n     }\n \n-    fn in_dir<'a, I, F>(&self, dir: I, callback: F)\n-    where\n-        I: IntoIterator<Item = &'a str>,\n-        F: FnOnce(&TestRunner),\n-    {\n+    fn in_dir(&self, new: impl AsRef<Path>, callback: impl FnOnce(&TestRunner)) {\n         let current = env::current_dir().unwrap();\n-        let mut new = current.clone();\n-        for d in dir {\n-            new.push(d);\n-        }\n \n         env::set_current_dir(new).unwrap();\n         callback(self);\n@@ -595,25 +582,29 @@ impl TestRunner {\n         spawn_and_wait(cmd);\n     }\n \n-    fn cargo_command<I, S>(&self, args: I) -> Command\n+    fn cargo_command<'a, I>(&self, subcommand: &str, args: I) -> Command\n     where\n-        I: IntoIterator<Item = S>,\n-        S: AsRef<OsStr>,\n+        I: IntoIterator<Item = &'a str>,\n     {\n         let mut cargo_clif = self.root_dir.clone();\n         cargo_clif.push(\"build\");\n         cargo_clif.push(get_wrapper_file_name(\"cargo-clif\", \"bin\"));\n \n-        let mut cmd = Command::new(cargo_clif);\n+        let mut cmd = cargo_command(\n+            cargo_clif,\n+            subcommand,\n+            if subcommand == \"clean\" { None } else { Some(&self.target_triple) },\n+            Path::new(\".\"),\n+        );\n         cmd.args(args);\n         cmd.env(\"RUSTFLAGS\", &self.rust_flags);\n         cmd\n     }\n \n-    fn run_cargo<'a, I>(&self, args: I)\n+    fn run_cargo<'a, I>(&self, subcommand: &str, args: I)\n     where\n         I: IntoIterator<Item = &'a str>,\n     {\n-        spawn_and_wait(self.cargo_command(args));\n+        spawn_and_wait(self.cargo_command(subcommand, args));\n     }\n }"}, {"sha": "48da64906e2a4b30189c82535f560a899e547510", "filename": "compiler/rustc_codegen_cranelift/build_system/utils.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fbuild_system%2Futils.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -4,6 +4,52 @@ use std::io::Write;\n use std::path::Path;\n use std::process::{self, Command, Stdio};\n \n+pub(crate) fn cargo_command(\n+    cargo: impl AsRef<Path>,\n+    subcommand: &str,\n+    triple: Option<&str>,\n+    source_dir: &Path,\n+) -> Command {\n+    let mut cmd = Command::new(cargo.as_ref());\n+    cmd.arg(subcommand)\n+        .arg(\"--manifest-path\")\n+        .arg(source_dir.join(\"Cargo.toml\"))\n+        .arg(\"--target-dir\")\n+        .arg(source_dir.join(\"target\"));\n+\n+    if let Some(triple) = triple {\n+        cmd.arg(\"--target\").arg(triple);\n+    }\n+\n+    cmd\n+}\n+\n+pub(crate) fn hyperfine_command(\n+    warmup: u64,\n+    runs: u64,\n+    prepare: Option<Command>,\n+    a: Command,\n+    b: Command,\n+) -> Command {\n+    let mut bench = Command::new(\"hyperfine\");\n+\n+    if warmup != 0 {\n+        bench.arg(\"--warmup\").arg(warmup.to_string());\n+    }\n+\n+    if runs != 0 {\n+        bench.arg(\"--runs\").arg(runs.to_string());\n+    }\n+\n+    if let Some(prepare) = prepare {\n+        bench.arg(\"--prepare\").arg(format!(\"{:?}\", prepare));\n+    }\n+\n+    bench.arg(format!(\"{:?}\", a)).arg(format!(\"{:?}\", b));\n+\n+    bench\n+}\n+\n #[track_caller]\n pub(crate) fn try_hard_link(src: impl AsRef<Path>, dst: impl AsRef<Path>) {\n     let src = src.as_ref();"}, {"sha": "fedab2433aa05f66f33949f35ea62cd88ec3f4ed", "filename": "compiler/rustc_codegen_cranelift/clean_all.sh", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fclean_all.sh?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -3,4 +3,8 @@ set -e\n \n rm -rf build_sysroot/{sysroot_src/,target/,compiler-builtins/,rustc_version}\n rm -rf target/ build/ perf.data{,.old} y.bin\n-rm -rf rand/ regex/ simple-raytracer/ portable-simd/ abi-checker/\n+rm -rf download/\n+\n+# Kept for now in case someone updates their checkout of cg_clif before running clean_all.sh\n+# FIXME remove at some point in the future\n+rm -rf rand/ regex/ simple-raytracer/ portable-simd/ abi-checker/ abi-cafe/"}, {"sha": "0d539191b12f95936b65e6d134d460b31d96c3e6", "filename": "compiler/rustc_codegen_cranelift/config.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fconfig.txt", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fconfig.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fconfig.txt?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -49,4 +49,4 @@ test.regex-shootout-regex-dna\n test.regex\n test.portable-simd\n \n-testsuite.abi-checker\n+testsuite.abi-cafe"}, {"sha": "039100696331b638f7fc52afb60b9a6c6d05c8b8", "filename": "compiler/rustc_codegen_cranelift/example/issue-91827-extern-types.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fexample%2Fissue-91827-extern-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fexample%2Fissue-91827-extern-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fissue-91827-extern-types.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -5,7 +5,6 @@\n // Test that we can handle unsized types with an extern type tail part.\n // Regression test for issue #91827.\n \n-#![feature(const_ptr_offset_from)]\n #![feature(extern_types)]\n \n use std::ptr::addr_of;"}, {"sha": "7f85b52f083a7c2a8de18913a937a65e711474b7", "filename": "compiler/rustc_codegen_cranelift/example/mini_core.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -559,16 +559,22 @@ pub union MaybeUninit<T> {\n \n pub mod intrinsics {\n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n+        #[rustc_safe_intrinsic]\n         pub fn size_of<T>() -> usize;\n         pub fn size_of_val<T: ?::Sized>(val: *const T) -> usize;\n+        #[rustc_safe_intrinsic]\n         pub fn min_align_of<T>() -> usize;\n         pub fn min_align_of_val<T: ?::Sized>(val: *const T) -> usize;\n         pub fn copy<T>(src: *const T, dst: *mut T, count: usize);\n         pub fn transmute<T, U>(e: T) -> U;\n         pub fn ctlz_nonzero<T>(x: T) -> T;\n+        #[rustc_safe_intrinsic]\n         pub fn needs_drop<T: ?::Sized>() -> bool;\n+        #[rustc_safe_intrinsic]\n         pub fn bitreverse<T>(x: T) -> T;\n+        #[rustc_safe_intrinsic]\n         pub fn bswap<T>(x: T) -> T;\n         pub fn write_bytes<T>(dst: *mut T, val: u8, count: usize);\n     }"}, {"sha": "215d3556a17ca8cf2b5eb7a7673b5a090612da70", "filename": "compiler/rustc_codegen_cranelift/example/mini_core_hello_world.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core_hello_world.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -93,6 +93,7 @@ fn start<T: Termination + 'static>(\n     main: fn() -> T,\n     argc: isize,\n     argv: *const *const u8,\n+    _sigpipe: u8,\n ) -> isize {\n     if argc == 3 {\n         unsafe { puts(*argv as *const i8); }"}, {"sha": "0e5e7cdfcdf1a44028d6ada6cc17c59ee28d96f2", "filename": "compiler/rustc_codegen_cranelift/patches/0001-abi-cafe-Disable-some-test-on-x86_64-pc-windows-gnu.patch", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-abi-cafe-Disable-some-test-on-x86_64-pc-windows-gnu.patch", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-abi-cafe-Disable-some-test-on-x86_64-pc-windows-gnu.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-abi-cafe-Disable-some-test-on-x86_64-pc-windows-gnu.patch?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -0,0 +1,29 @@\n+From 2b15fee2bb5fd14e34c7e17e44d99cb34f4c555d Mon Sep 17 00:00:00 2001\n+From: Afonso Bordado <afonsobordado@az8.co>\n+Date: Tue, 27 Sep 2022 07:55:17 +0100\n+Subject: [PATCH] Disable some test on x86_64-pc-windows-gnu\n+\n+---\n+ src/report.rs | 6 ++++++\n+ 1 file changed, 6 insertions(+)\n+\n+diff --git a/src/report.rs b/src/report.rs\n+index eeec614..f582867 100644\n+--- a/src/report.rs\n++++ b/src/report.rs\n+@@ -48,6 +48,12 @@ pub fn get_test_rules(test: &TestKey, caller: &dyn AbiImpl, callee: &dyn AbiImpl\n+     //\n+     // THIS AREA RESERVED FOR VENDORS TO APPLY PATCHES\n+ \n++    // x86_64-pc-windows-gnu has some broken i128 tests that aren't disabled by default\n++    if cfg!(all(target_os = \"windows\", target_env = \"gnu\")) && test.test_name == \"ui128\" {\n++        result.run = Link;\n++        result.check = Pass(Link);\n++    }\n++\n+     // END OF VENDOR RESERVED AREA\n+     //\n+     //\n+-- \n+2.30.1.windows.1\n+"}, {"sha": "526366a7598760b95bb6d107ca3dbf20a8f0f871", "filename": "compiler/rustc_codegen_cranelift/patches/0001-abi-checker-Disable-failing-tests.patch", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/cfd99a2bbe83ae35ad0eb9d963ca97cf6c34471a/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-abi-checker-Disable-failing-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/cfd99a2bbe83ae35ad0eb9d963ca97cf6c34471a/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-abi-checker-Disable-failing-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-abi-checker-Disable-failing-tests.patch?ref=cfd99a2bbe83ae35ad0eb9d963ca97cf6c34471a", "patch": "@@ -1,36 +0,0 @@\n-From 1a315ba225577dbbd1f449d9609f16f984f68708 Mon Sep 17 00:00:00 2001\n-From: Afonso Bordado <afonso360@users.noreply.github.com>\n-Date: Fri, 12 Aug 2022 22:51:58 +0000\n-Subject: [PATCH] Disable abi-checker tests\n-\n----\n- src/report.rs | 14 ++++++++++++++\n- 1 file changed, 14 insertions(+)\n-\n-diff --git a/src/report.rs b/src/report.rs\n-index 7346f5e..8347762 100644\n---- a/src/report.rs\n-+++ b/src/report.rs\n-@@ -45,6 +45,20 @@ pub fn get_test_rules(test: &TestKey, caller: &dyn AbiImpl, callee: &dyn AbiImpl\n-     //\n-     // THIS AREA RESERVED FOR VENDORS TO APPLY PATCHES\n-\n-+    // Currently MSVC has some broken ABI issues. Furthermore, they cause\n-+    // a STATUS_ACCESS_VIOLATION, so we can't even run them. Ensure that they compile and link.\n-+    if cfg!(windows) && (test.test_name == \"bool\" || test.test_name == \"ui128\") {\n-+        result.run = Link;\n-+        result.check = Pass(Link);\n-+    }\n-+\n-+    // structs is broken in the current release of cranelift for aarch64.\n-+    // It has been fixed for cranelift 0.88: https://github.com/bytecodealliance/wasmtime/pull/4634\n-+    if cfg!(target_arch = \"aarch64\") && test.test_name == \"structs\" {\n-+        result.run = Link;\n-+        result.check = Pass(Link);\n-+    }\n-+\n-     // END OF VENDOR RESERVED AREA\n-     //\n-     //\n---\n-2.34.1"}, {"sha": "89e2b61c1fc8553be9c7668525c66e97d5fdcd52", "filename": "compiler/rustc_codegen_cranelift/patches/0001-portable-simd-Disable-unsupported-tests.patch", "status": "modified", "additions": 12, "deletions": 84, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-portable-simd-Disable-unsupported-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-portable-simd-Disable-unsupported-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0001-portable-simd-Disable-unsupported-tests.patch?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -1,107 +1,35 @@\n-From 97c473937382a5b5858d9cce3c947855d23b2dc5 Mon Sep 17 00:00:00 2001\n+From b742f03694b920cc14400727d54424e8e1b60928 Mon Sep 17 00:00:00 2001\n From: bjorn3 <bjorn3@users.noreply.github.com>\n Date: Thu, 18 Nov 2021 19:28:40 +0100\n Subject: [PATCH] Disable unsupported tests\n \n ---\n- crates/core_simd/src/math.rs         | 6 ++++++\n- crates/core_simd/src/vector.rs       | 2 ++\n- crates/core_simd/tests/masks.rs      | 2 ++\n- crates/core_simd/tests/ops_macros.rs | 4 ++++\n- 4 files changed, 14 insertions(+)\n+ crates/core_simd/src/elements/int.rs     | 8 ++++++++\n+ crates/core_simd/src/elements/uint.rs    | 4 ++++\n+ crates/core_simd/src/masks/full_masks.rs | 6 ++++++\n+ crates/core_simd/src/vector.rs           | 2 ++\n+ crates/core_simd/tests/masks.rs          | 3 ---\n+ 5 files changed, 20 insertions(+), 3 deletions(-)\n \n-diff --git a/crates/core_simd/src/math.rs b/crates/core_simd/src/math.rs\n-index 2bae414..2f87499 100644\n---- a/crates/core_simd/src/math.rs\n-+++ b/crates/core_simd/src/math.rs\n-@@ -5,6 +5,7 @@ macro_rules! impl_uint_arith {\n-     ($($ty:ty),+) => {\n-         $( impl<const LANES: usize> Simd<$ty, LANES> where LaneCount<LANES>: SupportedLaneCount {\n- \n-+            /*\n-             /// Lanewise saturating add.\n-             ///\n-             /// # Examples\n-@@ -43,6 +44,7 @@ macro_rules! impl_uint_arith {\n-             pub fn saturating_sub(self, second: Self) -> Self {\n-                 unsafe { simd_saturating_sub(self, second) }\n-             }\n-+            */\n-         })+\n-     }\n- }\n-@@ -51,6 +53,7 @@ macro_rules! impl_int_arith {\n-     ($($ty:ty),+) => {\n-         $( impl<const LANES: usize> Simd<$ty, LANES> where LaneCount<LANES>: SupportedLaneCount {\n- \n-+            /*\n-             /// Lanewise saturating add.\n-             ///\n-             /// # Examples\n-@@ -89,6 +92,7 @@ macro_rules! impl_int_arith {\n-             pub fn saturating_sub(self, second: Self) -> Self {\n-                 unsafe { simd_saturating_sub(self, second) }\n-             }\n-+            */\n- \n-             /// Lanewise absolute value, implemented in Rust.\n-             /// Every lane becomes its absolute value.\n-@@ -109,6 +113,7 @@ macro_rules! impl_int_arith {\n-                 (self^m) - m\n-             }\n- \n-+            /*\n-             /// Lanewise saturating absolute value, implemented in Rust.\n-             /// As abs(), except the MIN value becomes MAX instead of itself.\n-             ///\n-@@ -151,6 +156,7 @@ macro_rules! impl_int_arith {\n-             pub fn saturating_neg(self) -> Self {\n-                 Self::splat(0).saturating_sub(self)\n-             }\n-+            */\n-         })+\n-     }\n- }\n diff --git a/crates/core_simd/src/vector.rs b/crates/core_simd/src/vector.rs\n-index 7c5ec2b..c8631e8 100644\n+index e8e8f68..7173c24 100644\n --- a/crates/core_simd/src/vector.rs\n +++ b/crates/core_simd/src/vector.rs\n-@@ -75,6 +75,7 @@ where\n-         Self(array)\n+@@ -250,6 +250,7 @@ where\n+         unsafe { intrinsics::simd_cast(self) }\n      }\n  \n +    /*\n      /// Reads from potentially discontiguous indices in `slice` to construct a SIMD vector.\n      /// If an index is out-of-bounds, the lane is instead selected from the `or` vector.\n      ///\n-@@ -297,6 +298,7 @@ where\n+@@ -473,6 +474,7 @@ where\n              // Cleared \u2622\ufe0f *mut T Zone\n          }\n      }\n +    */\n  }\n  \n  impl<T, const LANES: usize> Copy for Simd<T, LANES>\n-diff --git a/crates/core_simd/tests/masks.rs b/crates/core_simd/tests/masks.rs\n-index 6a8ecd3..68fcb49 100644\n---- a/crates/core_simd/tests/masks.rs\n-+++ b/crates/core_simd/tests/masks.rs\n-@@ -68,6 +68,7 @@ macro_rules! test_mask_api {\n-                 assert_eq!(core_simd::Mask::<$type, 8>::from_int(int), mask);\n-             }\n- \n-+            /*\n-             #[cfg(feature = \"generic_const_exprs\")]\n-             #[test]\n-             fn roundtrip_bitmask_conversion() {\n-@@ -80,6 +81,7 @@ macro_rules! test_mask_api {\n-                 assert_eq!(bitmask, [0b01001001, 0b10000011]);\n-                 assert_eq!(core_simd::Mask::<$type, 16>::from_bitmask(bitmask), mask);\n-             }\n-+            */\n-         }\n-     }\n- }\n -- \n-2.26.2.7.g19db9cfb68\n-\n+2.25.1"}, {"sha": "d8775e2d022a00d2ac490163670f8bc030c4555b", "filename": "compiler/rustc_codegen_cranelift/patches/0003-rand-Disable-rand-tests-on-mingw.patch", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0003-rand-Disable-rand-tests-on-mingw.patch", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0003-rand-Disable-rand-tests-on-mingw.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fpatches%2F0003-rand-Disable-rand-tests-on-mingw.patch?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -0,0 +1,47 @@\n+From eec874c889b8d24e5ad50faded24288150f057b1 Mon Sep 17 00:00:00 2001\n+From: Afonso Bordado <afonsobordado@az8.co>\n+Date: Tue, 27 Sep 2022 08:13:58 +0100\n+Subject: [PATCH] Disable rand tests on mingw\n+\n+---\n+ rand_distr/src/pareto.rs            | 2 ++\n+ rand_distr/tests/value_stability.rs | 4 ++++\n+ 2 files changed, 6 insertions(+)\n+\n+diff --git a/rand_distr/src/pareto.rs b/rand_distr/src/pareto.rs\n+index 217899e..9cedeb7 100644\n+--- a/rand_distr/src/pareto.rs\n++++ b/rand_distr/src/pareto.rs\n+@@ -107,6 +107,8 @@ mod tests {\n+     }\n+\n+     #[test]\n++    // This is broken on x86_64-pc-windows-gnu presumably due to a broken powf implementation\n++    #[cfg_attr(all(target_os = \"windows\", target_env = \"gnu\"), ignore)]\n+     fn value_stability() {\n+         fn test_samples<F: Float + core::fmt::Debug, D: Distribution<F>>(\n+             distr: D, zero: F, expected: &[F],\n+diff --git a/rand_distr/tests/value_stability.rs b/rand_distr/tests/value_stability.rs\n+index 192ba74..0101ace 100644\n+--- a/rand_distr/tests/value_stability.rs\n++++ b/rand_distr/tests/value_stability.rs\n+@@ -72,6 +72,8 @@ fn unit_disc_stability() {\n+ }\n+\n+ #[test]\n++// This is broken on x86_64-pc-windows-gnu\n++#[cfg_attr(all(target_os = \"windows\", target_env = \"gnu\"), ignore)]\n+ fn pareto_stability() {\n+     test_samples(213, Pareto::new(1.0, 1.0).unwrap(), &[\n+         1.0423688f32, 2.1235929, 4.132709, 1.4679428,\n+@@ -143,6 +145,8 @@ fn inverse_gaussian_stability() {\n+ }\n+\n+ #[test]\n++// This is broken on x86_64-pc-windows-gnu\n++#[cfg_attr(all(target_os = \"windows\", target_env = \"gnu\"), ignore)]\n+ fn gamma_stability() {\n+     // Gamma has 3 cases: shape == 1, shape < 1, shape > 1\n+     test_samples(223, Gamma::new(1.0, 5.0).unwrap(), &[\n+--\n+2.25.1"}, {"sha": "c0a2e7a7883fcb14031a9ea5a38289d564d30d4a", "filename": "compiler/rustc_codegen_cranelift/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Frust-toolchain?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2022-08-24\"\n+channel = \"nightly-2022-10-23\"\n components = [\"rust-src\", \"rustc-dev\", \"llvm-tools-preview\"]"}, {"sha": "d6a37789599fe8d0621de8a2577fc77aa45b1be3", "filename": "compiler/rustc_codegen_cranelift/scripts/setup_rust_fork.sh", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Fsetup_rust_fork.sh?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -10,6 +10,8 @@ git fetch\n git checkout -- .\n git checkout \"$(rustc -V | cut -d' ' -f3 | tr -d '(')\"\n \n+git am ../patches/*-sysroot-*.patch\n+\n git apply - <<EOF\n diff --git a/library/alloc/Cargo.toml b/library/alloc/Cargo.toml\n index d95b5b7f17f..00b6f0e3635 100644\n@@ -66,3 +68,7 @@ popd\n \n # FIXME remove once inline asm is fully supported\n export RUSTFLAGS=\"$RUSTFLAGS --cfg=rustix_use_libc\"\n+\n+# Allow the testsuite to use llvm tools\n+host_triple=$(rustc -vV | grep host | cut -d: -f2 | tr -d \" \")\n+export LLVM_BIN_DIR=\"$(rustc --print sysroot)/lib/rustlib/$host_triple/bin\""}, {"sha": "9b5db3cf81f0e3341f553398f6354c9320cf0640", "filename": "compiler/rustc_codegen_cranelift/scripts/test_rustc_tests.sh", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fscripts%2Ftest_rustc_tests.sh?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -29,10 +29,6 @@ rm src/test/incremental/change_crate_dep_kind.rs\n rm src/test/incremental/issue-80691-bad-eval-cache.rs # -Cpanic=abort causes abort instead of exit(101)\n \n # requires compiling with -Cpanic=unwind\n-rm src/test/ui/test-attrs/test-fn-signature-verification-for-explicit-return-type.rs # \"Cannot run dynamic test fn out-of-process\"\n-rm src/test/ui/async-await/async-fn-size-moved-locals.rs # -Cpanic=abort shrinks some generator by one byte\n-rm src/test/ui/async-await/async-fn-size-uninit-locals.rs # same\n-rm src/test/ui/generator/size-moved-locals.rs # same\n rm -r src/test/ui/macros/rfc-2011-nicer-assert-messages/\n \n # vendor intrinsics\n@@ -67,6 +63,7 @@ rm src/test/ui/target-feature/missing-plusminus.rs # error not implemented\n rm src/test/ui/fn/dyn-fn-alignment.rs # wants a 256 byte alignment\n rm -r src/test/run-make/emit-named-files # requires full --emit support\n rm src/test/ui/abi/stack-probes.rs # stack probes not yet implemented\n+rm src/test/ui/simd/intrinsic/ptr-cast.rs # simd_expose_addr intrinsic unimplemented\n \n # optimization tests\n # ==================\n@@ -110,12 +107,13 @@ rm src/test/ui/simd/intrinsic/generic-reduction-pass.rs # simd_reduce_add_unorde\n # bugs in the test suite\n # ======================\n rm src/test/ui/backtrace.rs # TODO warning\n-rm src/test/ui/empty_global_asm.rs # TODO add needs-asm-support\n rm src/test/ui/simple_global_asm.rs # TODO add needs-asm-support\n rm src/test/ui/test-attrs/test-type.rs # TODO panic message on stderr. correct stdout\n # not sure if this is actually a bug in the test suite, but the symbol list shows the function without leading _ for some reason\n rm -r src/test/run-make/native-link-modifier-bundle\n \n+rm src/test/ui/stdio-is-blocking.rs # really slow with unoptimized libstd\n+\n echo \"[TEST] rustc test suite\"\n RUST_TEST_NOCAPTURE=1 COMPILETEST_FORCE_STAGE0=1 ./x.py test --stage 0 src/test/{codegen-units,run-make,run-pass-valgrind,ui,incremental}\n popd"}, {"sha": "99059e788a074a12450d9022e210d27efc005978", "filename": "compiler/rustc_codegen_cranelift/src/abi/mod.rs", "status": "modified", "additions": 51, "deletions": 2, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -465,7 +465,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n             let sig = clif_sig_from_fn_abi(fx.tcx, fx.target_config.default_call_conv, &fn_abi);\n             let sig = fx.bcx.import_signature(sig);\n \n-            (CallTarget::Indirect(sig, method), Some(ptr))\n+            (CallTarget::Indirect(sig, method), Some(ptr.get_addr(fx)))\n         }\n \n         // Normal call\n@@ -560,7 +560,19 @@ pub(crate) fn codegen_drop<'tcx>(\n         // we don't actually need to drop anything\n     } else {\n         match ty.kind() {\n-            ty::Dynamic(..) => {\n+            ty::Dynamic(_, _, ty::Dyn) => {\n+                // IN THIS ARM, WE HAVE:\n+                // ty = *mut (dyn Trait)\n+                // which is: exists<T> ( *mut T,    Vtable<T: Trait> )\n+                //                       args[0]    args[1]\n+                //\n+                // args = ( Data, Vtable )\n+                //                  |\n+                //                  v\n+                //                /-------\\\n+                //                | ...   |\n+                //                \\-------/\n+                //\n                 let (ptr, vtable) = drop_place.to_ptr_maybe_unsized();\n                 let ptr = ptr.get_addr(fx);\n                 let drop_fn = crate::vtable::drop_fn_of_obj(fx, vtable.unwrap());\n@@ -578,6 +590,43 @@ pub(crate) fn codegen_drop<'tcx>(\n                 let sig = fx.bcx.import_signature(sig);\n                 fx.bcx.ins().call_indirect(sig, drop_fn, &[ptr]);\n             }\n+            ty::Dynamic(_, _, ty::DynStar) => {\n+                // IN THIS ARM, WE HAVE:\n+                // ty = *mut (dyn* Trait)\n+                // which is: *mut exists<T: sizeof(T) == sizeof(usize)> (T, Vtable<T: Trait>)\n+                //\n+                // args = [ * ]\n+                //          |\n+                //          v\n+                //      ( Data, Vtable )\n+                //                |\n+                //                v\n+                //              /-------\\\n+                //              | ...   |\n+                //              \\-------/\n+                //\n+                //\n+                // WE CAN CONVERT THIS INTO THE ABOVE LOGIC BY DOING\n+                //\n+                // data = &(*args[0]).0    // gives a pointer to Data above (really the same pointer)\n+                // vtable = (*args[0]).1   // loads the vtable out\n+                // (data, vtable)          // an equivalent Rust `*mut dyn Trait`\n+                //\n+                // SO THEN WE CAN USE THE ABOVE CODE.\n+                let (data, vtable) = drop_place.to_cvalue(fx).dyn_star_force_data_on_stack(fx);\n+                let drop_fn = crate::vtable::drop_fn_of_obj(fx, vtable);\n+\n+                let virtual_drop = Instance {\n+                    def: ty::InstanceDef::Virtual(drop_instance.def_id(), 0),\n+                    substs: drop_instance.substs,\n+                };\n+                let fn_abi =\n+                    RevealAllLayoutCx(fx.tcx).fn_abi_of_instance(virtual_drop, ty::List::empty());\n+\n+                let sig = clif_sig_from_fn_abi(fx.tcx, fx.target_config.default_call_conv, &fn_abi);\n+                let sig = fx.bcx.import_signature(sig);\n+                fx.bcx.ins().call_indirect(sig, drop_fn, &[data]);\n+            }\n             _ => {\n                 assert!(!matches!(drop_instance.def, InstanceDef::Virtual(_, _)));\n "}, {"sha": "bad8a87b9bee4b809bbb5f20226b07b6cf2805e0", "filename": "compiler/rustc_codegen_cranelift/src/allocator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -78,7 +78,7 @@ fn codegen_inner(\n         let callee_func_id = module.declare_function(&callee_name, Linkage::Import, &sig).unwrap();\n \n         let mut ctx = Context::new();\n-        ctx.func = Function::with_name_signature(ExternalName::user(0, 0), sig.clone());\n+        ctx.func.signature = sig.clone();\n         {\n             let mut func_ctx = FunctionBuilderContext::new();\n             let mut bcx = FunctionBuilder::new(&mut ctx.func, &mut func_ctx);\n@@ -116,7 +116,7 @@ fn codegen_inner(\n     let callee_func_id = module.declare_function(callee_name, Linkage::Import, &sig).unwrap();\n \n     let mut ctx = Context::new();\n-    ctx.func = Function::with_name_signature(ExternalName::user(0, 0), sig);\n+    ctx.func.signature = sig;\n     {\n         let mut func_ctx = FunctionBuilderContext::new();\n         let mut bcx = FunctionBuilder::new(&mut ctx.func, &mut func_ctx);"}, {"sha": "f2e3bf16e61842bae2d73b66ac42c0cec2a01e6e", "filename": "compiler/rustc_codegen_cranelift/src/archive.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -38,6 +38,7 @@ impl ArchiveBuilderBuilder for ArArchiveBuilderBuilder {\n         _lib_name: &str,\n         _dll_imports: &[rustc_session::cstore::DllImport],\n         _tmpdir: &Path,\n+        _is_direct_dependency: bool,\n     ) -> PathBuf {\n         bug!(\"creating dll imports is not supported\");\n     }\n@@ -159,6 +160,8 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n                         let err = err.to_string();\n                         if err == \"Unknown file magic\" {\n                             // Not an object file; skip it.\n+                        } else if object::read::archive::ArchiveFile::parse(&*data).is_ok() {\n+                            // Nested archive file; skip it.\n                         } else {\n                             sess.fatal(&format!(\n                                 \"error parsing `{}` during archive creation: {}\","}, {"sha": "a41b561598f68638f896c90bdbd855219a2c97a2", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -6,6 +6,8 @@ use rustc_middle::ty::adjustment::PointerCast;\n use rustc_middle::ty::layout::FnAbiOf;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n \n+use cranelift_codegen::ir::UserFuncName;\n+\n use crate::constant::ConstantCx;\n use crate::debuginfo::FunctionDebugContext;\n use crate::prelude::*;\n@@ -64,7 +66,7 @@ pub(crate) fn codegen_fn<'tcx>(\n     let mut func_ctx = FunctionBuilderContext::new();\n     let mut func = cached_func;\n     func.clear();\n-    func.name = ExternalName::user(0, func_id.as_u32());\n+    func.name = UserFuncName::user(0, func_id.as_u32());\n     func.signature = sig;\n     func.collect_debug_info();\n \n@@ -706,9 +708,9 @@ fn codegen_stmt<'tcx>(\n                     let operand = codegen_operand(fx, operand);\n                     operand.unsize_value(fx, lval);\n                 }\n-                Rvalue::Cast(CastKind::DynStar, _, _) => {\n-                    // FIXME(dyn-star)\n-                    unimplemented!()\n+                Rvalue::Cast(CastKind::DynStar, ref operand, _) => {\n+                    let operand = codegen_operand(fx, operand);\n+                    operand.coerce_dyn_star(fx, lval);\n                 }\n                 Rvalue::Discriminant(place) => {\n                     let place = codegen_place(fx, place);\n@@ -922,7 +924,7 @@ pub(crate) fn codegen_operand<'tcx>(\n             let cplace = codegen_place(fx, *place);\n             cplace.to_cvalue(fx)\n         }\n-        Operand::Constant(const_) => crate::constant::codegen_constant(fx, const_),\n+        Operand::Constant(const_) => crate::constant::codegen_constant_operand(fx, const_),\n     }\n }\n "}, {"sha": "f855e20e0a1a3732aa1a01374f57ebafd5f4a0b0", "filename": "compiler/rustc_codegen_cranelift/src/concurrency_limiter.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconcurrency_limiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconcurrency_limiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconcurrency_limiter.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -10,6 +10,7 @@ pub(super) struct ConcurrencyLimiter {\n     helper_thread: Option<HelperThread>,\n     state: Arc<Mutex<state::ConcurrencyLimiterState>>,\n     available_token_condvar: Arc<Condvar>,\n+    finished: bool,\n }\n \n impl ConcurrencyLimiter {\n@@ -32,6 +33,7 @@ impl ConcurrencyLimiter {\n             helper_thread: Some(helper_thread),\n             state,\n             available_token_condvar: Arc::new(Condvar::new()),\n+            finished: false,\n         }\n     }\n \n@@ -56,16 +58,23 @@ impl ConcurrencyLimiter {\n         let mut state = self.state.lock().unwrap();\n         state.job_already_done();\n     }\n-}\n \n-impl Drop for ConcurrencyLimiter {\n-    fn drop(&mut self) {\n-        //\n+    pub(crate) fn finished(mut self) {\n         self.helper_thread.take();\n \n         // Assert that all jobs have finished\n         let state = Mutex::get_mut(Arc::get_mut(&mut self.state).unwrap()).unwrap();\n         state.assert_done();\n+\n+        self.finished = true;\n+    }\n+}\n+\n+impl Drop for ConcurrencyLimiter {\n+    fn drop(&mut self) {\n+        if !self.finished && !std::thread::panicking() {\n+            panic!(\"Forgot to call finished() on ConcurrencyLimiter\");\n+        }\n     }\n }\n "}, {"sha": "d4bc3543b2d1338ee0feea0db1543bba1a6ea0ca", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 39, "deletions": 48, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -7,7 +7,6 @@ use rustc_middle::mir::interpret::{\n };\n use rustc_span::DUMMY_SP;\n \n-use cranelift_codegen::ir::GlobalValueData;\n use cranelift_module::*;\n \n use crate::prelude::*;\n@@ -81,53 +80,46 @@ pub(crate) fn codegen_tls_ref<'tcx>(\n     CValue::by_val(tls_ptr, layout)\n }\n \n-fn codegen_static_ref<'tcx>(\n-    fx: &mut FunctionCx<'_, '_, 'tcx>,\n-    def_id: DefId,\n-    layout: TyAndLayout<'tcx>,\n-) -> CPlace<'tcx> {\n-    let data_id = data_id_for_static(fx.tcx, fx.module, def_id, false);\n-    let local_data_id = fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n-    if fx.clif_comments.enabled() {\n-        fx.add_comment(local_data_id, format!(\"{:?}\", def_id));\n-    }\n-    let global_ptr = fx.bcx.ins().global_value(fx.pointer_type, local_data_id);\n-    assert!(!layout.is_unsized(), \"unsized statics aren't supported\");\n-    assert!(\n-        matches!(\n-            fx.bcx.func.global_values[local_data_id],\n-            GlobalValueData::Symbol { tls: false, .. }\n-        ),\n-        \"tls static referenced without Rvalue::ThreadLocalRef\"\n-    );\n-    CPlace::for_ptr(crate::pointer::Pointer::new(global_ptr), layout)\n-}\n-\n-pub(crate) fn codegen_constant<'tcx>(\n+pub(crate) fn eval_mir_constant<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     constant: &Constant<'tcx>,\n-) -> CValue<'tcx> {\n-    let (const_val, ty) = match fx.monomorphize(constant.literal) {\n-        ConstantKind::Ty(const_) => unreachable!(\"{:?}\", const_),\n-        ConstantKind::Unevaluated(mir::UnevaluatedConst { def, substs, promoted }, ty)\n+) -> (ConstValue<'tcx>, Ty<'tcx>) {\n+    let constant_kind = fx.monomorphize(constant.literal);\n+    let uv = match constant_kind {\n+        ConstantKind::Ty(const_) => match const_.kind() {\n+            ty::ConstKind::Unevaluated(uv) => uv.expand(),\n+            ty::ConstKind::Value(val) => {\n+                return (fx.tcx.valtree_to_const_val((const_.ty(), val)), const_.ty());\n+            }\n+            err => span_bug!(\n+                constant.span,\n+                \"encountered bad ConstKind after monomorphizing: {:?}\",\n+                err\n+            ),\n+        },\n+        ConstantKind::Unevaluated(mir::UnevaluatedConst { def, .. }, _)\n             if fx.tcx.is_static(def.did) =>\n         {\n-            assert!(substs.is_empty());\n-            assert!(promoted.is_none());\n-\n-            return codegen_static_ref(fx, def.did, fx.layout_of(ty)).to_cvalue(fx);\n-        }\n-        ConstantKind::Unevaluated(unevaluated, ty) => {\n-            match fx.tcx.const_eval_resolve(ParamEnv::reveal_all(), unevaluated, None) {\n-                Ok(const_val) => (const_val, ty),\n-                Err(_) => {\n-                    span_bug!(constant.span, \"erroneous constant not captured by required_consts\");\n-                }\n-            }\n+            span_bug!(constant.span, \"MIR constant refers to static\");\n         }\n-        ConstantKind::Val(val, ty) => (val, ty),\n+        ConstantKind::Unevaluated(uv, _) => uv,\n+        ConstantKind::Val(val, _) => return (val, constant_kind.ty()),\n     };\n \n+    (\n+        fx.tcx.const_eval_resolve(ty::ParamEnv::reveal_all(), uv, None).unwrap_or_else(|_err| {\n+            span_bug!(constant.span, \"erroneous constant not captured by required_consts\");\n+        }),\n+        constant_kind.ty(),\n+    )\n+}\n+\n+pub(crate) fn codegen_constant_operand<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n+    constant: &Constant<'tcx>,\n+) -> CValue<'tcx> {\n+    let (const_val, ty) = eval_mir_constant(fx, constant);\n+\n     codegen_const_value(fx, const_val, ty)\n }\n \n@@ -244,7 +236,7 @@ pub(crate) fn codegen_const_value<'tcx>(\n     }\n }\n \n-pub(crate) fn pointer_for_allocation<'tcx>(\n+fn pointer_for_allocation<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     alloc: ConstAllocation<'tcx>,\n ) -> crate::pointer::Pointer {\n@@ -467,14 +459,13 @@ pub(crate) fn mir_operand_get_const_val<'tcx>(\n     operand: &Operand<'tcx>,\n ) -> Option<ConstValue<'tcx>> {\n     match operand {\n-        Operand::Constant(const_) => match const_.literal {\n-            ConstantKind::Ty(const_) => fx\n-                .monomorphize(const_)\n-                .eval_for_mir(fx.tcx, ParamEnv::reveal_all())\n-                .try_to_value(fx.tcx),\n+        Operand::Constant(const_) => match fx.monomorphize(const_.literal) {\n+            ConstantKind::Ty(const_) => Some(\n+                const_.eval_for_mir(fx.tcx, ParamEnv::reveal_all()).try_to_value(fx.tcx).unwrap(),\n+            ),\n             ConstantKind::Val(val, _) => Some(val),\n             ConstantKind::Unevaluated(uv, _) => {\n-                fx.tcx.const_eval_resolve(ParamEnv::reveal_all(), uv, None).ok()\n+                Some(fx.tcx.const_eval_resolve(ParamEnv::reveal_all(), uv, None).unwrap())\n             }\n         },\n         // FIXME(rust-lang/rust#85105): Casts like `IMM8 as u32` result in the const being stored"}, {"sha": "f873561c1713f37853821e3548ad6511a7981f58", "filename": "compiler/rustc_codegen_cranelift/src/driver/aot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Faot.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -106,7 +106,7 @@ impl OngoingCodegen {\n             }\n         }\n \n-        drop(self.concurrency_limiter);\n+        self.concurrency_limiter.finished();\n \n         (\n             CodegenResults {"}, {"sha": "6a430b5215e36d11b483213b5bb7e74c75425727", "filename": "compiler/rustc_codegen_cranelift/src/driver/jit.rs", "status": "modified", "additions": 17, "deletions": 34, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -67,13 +67,12 @@ fn create_jit_module(\n     hotswap: bool,\n ) -> (JITModule, CodegenCx) {\n     let crate_info = CrateInfo::new(tcx, \"dummy_target_cpu\".to_string());\n-    let imported_symbols = load_imported_symbols_for_jit(tcx.sess, crate_info);\n \n     let isa = crate::build_isa(tcx.sess, backend_config);\n     let mut jit_builder = JITBuilder::with_isa(isa, cranelift_module::default_libcall_names());\n     jit_builder.hotswap(hotswap);\n     crate::compiler_builtins::register_functions_for_jit(&mut jit_builder);\n-    jit_builder.symbols(imported_symbols);\n+    jit_builder.symbol_lookup_fn(dep_symbol_lookup_fn(tcx.sess, crate_info));\n     jit_builder.symbol(\"__clif_jit_fn\", clif_jit_fn as *const u8);\n     let mut jit_module = JITModule::new(jit_builder);\n \n@@ -286,10 +285,10 @@ fn jit_fn(instance_ptr: *const Instance<'static>, trampoline_ptr: *const u8) ->\n     })\n }\n \n-fn load_imported_symbols_for_jit(\n+fn dep_symbol_lookup_fn(\n     sess: &Session,\n     crate_info: CrateInfo,\n-) -> Vec<(String, *const u8)> {\n+) -> Box<dyn Fn(&str) -> Option<*const u8>> {\n     use rustc_middle::middle::dependency_format::Linkage;\n \n     let mut dylib_paths = Vec::new();\n@@ -316,39 +315,23 @@ fn load_imported_symbols_for_jit(\n         }\n     }\n \n-    let mut imported_symbols = Vec::new();\n-    for path in dylib_paths {\n-        use object::{Object, ObjectSymbol};\n-        let lib = libloading::Library::new(&path).unwrap();\n-        let obj = std::fs::read(path).unwrap();\n-        let obj = object::File::parse(&*obj).unwrap();\n-        imported_symbols.extend(obj.dynamic_symbols().filter_map(|symbol| {\n-            let name = symbol.name().unwrap().to_string();\n-            if name.is_empty() || !symbol.is_global() || symbol.is_undefined() {\n-                return None;\n-            }\n-            if name.starts_with(\"rust_metadata_\") {\n-                // The metadata is part of a section that is not loaded by the dynamic linker in\n-                // case of cg_llvm.\n-                return None;\n-            }\n-            let dlsym_name = if cfg!(target_os = \"macos\") {\n-                // On macOS `dlsym` expects the name without leading `_`.\n-                assert!(name.starts_with('_'), \"{:?}\", name);\n-                &name[1..]\n-            } else {\n-                &name\n-            };\n-            let symbol: libloading::Symbol<'_, *const u8> =\n-                unsafe { lib.get(dlsym_name.as_bytes()) }.unwrap();\n-            Some((name, *symbol))\n-        }));\n-        std::mem::forget(lib)\n-    }\n+    let imported_dylibs = Box::leak(\n+        dylib_paths\n+            .into_iter()\n+            .map(|path| unsafe { libloading::Library::new(&path).unwrap() })\n+            .collect::<Box<[_]>>(),\n+    );\n \n     sess.abort_if_errors();\n \n-    imported_symbols\n+    Box::new(move |sym_name| {\n+        for dylib in &*imported_dylibs {\n+            if let Ok(sym) = unsafe { dylib.get::<*const u8>(sym_name.as_bytes()) } {\n+                return Some(*sym);\n+            }\n+        }\n+        None\n+    })\n }\n \n fn codegen_shim<'tcx>("}, {"sha": "3fcc84d39295f42328b1f1aa515ea7f0932ea543", "filename": "compiler/rustc_codegen_cranelift/src/inline_asm.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Finline_asm.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -27,7 +27,7 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n         }\n \n         // Used by stdarch\n-        if template[0] == InlineAsmTemplatePiece::String(\"movq %rbx, \".to_string())\n+        if template[0] == InlineAsmTemplatePiece::String(\"mov \".to_string())\n             && matches!(\n                 template[1],\n                 InlineAsmTemplatePiece::Placeholder {\n@@ -36,24 +36,26 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n                     span: _\n                 }\n             )\n-            && template[2] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n-            && template[3] == InlineAsmTemplatePiece::String(\"cpuid\".to_string())\n-            && template[4] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n-            && template[5] == InlineAsmTemplatePiece::String(\"xchgq %rbx, \".to_string())\n+            && template[2] == InlineAsmTemplatePiece::String(\", rbx\".to_string())\n+            && template[3] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n+            && template[4] == InlineAsmTemplatePiece::String(\"cpuid\".to_string())\n+            && template[5] == InlineAsmTemplatePiece::String(\"\\n\".to_string())\n+            && template[6] == InlineAsmTemplatePiece::String(\"xchg \".to_string())\n             && matches!(\n-                template[6],\n+                template[7],\n                 InlineAsmTemplatePiece::Placeholder {\n                     operand_idx: 0,\n                     modifier: Some('r'),\n                     span: _\n                 }\n             )\n+            && template[8] == InlineAsmTemplatePiece::String(\", rbx\".to_string())\n         {\n             assert_eq!(operands.len(), 4);\n             let (leaf, eax_place) = match operands[1] {\n                 InlineAsmOperand::InOut {\n                     reg: InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::ax)),\n-                    late: true,\n+                    late: _,\n                     ref in_value,\n                     out_place: Some(out_place),\n                 } => (\n@@ -68,15 +70,15 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n                         InlineAsmRegOrRegClass::RegClass(InlineAsmRegClass::X86(\n                             X86InlineAsmRegClass::reg,\n                         )),\n-                    late: true,\n+                    late: _,\n                     place: Some(place),\n                 } => crate::base::codegen_place(fx, place),\n                 _ => unreachable!(),\n             };\n             let (sub_leaf, ecx_place) = match operands[2] {\n                 InlineAsmOperand::InOut {\n                     reg: InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::cx)),\n-                    late: true,\n+                    late: _,\n                     ref in_value,\n                     out_place: Some(out_place),\n                 } => (\n@@ -88,7 +90,7 @@ pub(crate) fn codegen_inline_asm<'tcx>(\n             let edx_place = match operands[3] {\n                 InlineAsmOperand::Out {\n                     reg: InlineAsmRegOrRegClass::Reg(InlineAsmReg::X86(X86InlineAsmReg::dx)),\n-                    late: true,\n+                    late: _,\n                     place: Some(place),\n                 } => crate::base::codegen_place(fx, place),\n                 _ => unreachable!(),"}, {"sha": "783d426c30bcc0d14cf94bb658b854e1e4b337fb", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/llvm.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fllvm.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -14,6 +14,10 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n     target: Option<BasicBlock>,\n ) {\n     match intrinsic {\n+        \"llvm.x86.sse2.pause\" | \"llvm.aarch64.isb\" => {\n+            // Spin loop hint\n+        }\n+\n         // Used by `_mm_movemask_epi8` and `_mm256_movemask_epi8`\n         \"llvm.x86.sse2.pmovmskb.128\" | \"llvm.x86.avx2.pmovmskb\" | \"llvm.x86.sse2.movmsk.pd\" => {\n             intrinsic_args!(fx, args => (a); intrinsic);\n@@ -25,8 +29,7 @@ pub(crate) fn codegen_llvm_intrinsic_call<'tcx>(\n             let mut res = fx.bcx.ins().iconst(types::I32, 0);\n \n             for lane in (0..lane_count).rev() {\n-                let a_lane =\n-                    a.value_field(fx, mir::Field::new(lane.try_into().unwrap())).load_scalar(fx);\n+                let a_lane = a.value_lane(fx, lane).load_scalar(fx);\n \n                 // cast float to int\n                 let a_lane = match lane_ty {"}, {"sha": "0302b843aa226345328a278674026baa33fda632", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 28, "deletions": 34, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -84,6 +84,30 @@ fn simd_for_each_lane<'tcx>(\n     }\n }\n \n+fn simd_pair_for_each_lane_typed<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n+    x: CValue<'tcx>,\n+    y: CValue<'tcx>,\n+    ret: CPlace<'tcx>,\n+    f: &dyn Fn(&mut FunctionCx<'_, '_, 'tcx>, CValue<'tcx>, CValue<'tcx>) -> CValue<'tcx>,\n+) {\n+    assert_eq!(x.layout(), y.layout());\n+    let layout = x.layout();\n+\n+    let (lane_count, _lane_ty) = layout.ty.simd_size_and_type(fx.tcx);\n+    let (ret_lane_count, _ret_lane_ty) = ret.layout().ty.simd_size_and_type(fx.tcx);\n+    assert_eq!(lane_count, ret_lane_count);\n+\n+    for lane_idx in 0..lane_count {\n+        let x_lane = x.value_lane(fx, lane_idx);\n+        let y_lane = y.value_lane(fx, lane_idx);\n+\n+        let res_lane = f(fx, x_lane, y_lane);\n+\n+        ret.place_lane(fx, lane_idx).write_cvalue(fx, res_lane);\n+    }\n+}\n+\n fn simd_pair_for_each_lane<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     x: CValue<'tcx>,\n@@ -504,37 +528,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n                 _ => unreachable!(),\n             };\n \n-            let signed = type_sign(lhs.layout().ty);\n-\n-            let checked_res = crate::num::codegen_checked_int_binop(fx, bin_op, lhs, rhs);\n-\n-            let (val, has_overflow) = checked_res.load_scalar_pair(fx);\n-            let clif_ty = fx.clif_type(lhs.layout().ty).unwrap();\n-\n-            let (min, max) = type_min_max_value(&mut fx.bcx, clif_ty, signed);\n-\n-            let val = match (intrinsic, signed) {\n-                (sym::saturating_add, false) => fx.bcx.ins().select(has_overflow, max, val),\n-                (sym::saturating_sub, false) => fx.bcx.ins().select(has_overflow, min, val),\n-                (sym::saturating_add, true) => {\n-                    let rhs = rhs.load_scalar(fx);\n-                    let rhs_ge_zero =\n-                        fx.bcx.ins().icmp_imm(IntCC::SignedGreaterThanOrEqual, rhs, 0);\n-                    let sat_val = fx.bcx.ins().select(rhs_ge_zero, max, min);\n-                    fx.bcx.ins().select(has_overflow, sat_val, val)\n-                }\n-                (sym::saturating_sub, true) => {\n-                    let rhs = rhs.load_scalar(fx);\n-                    let rhs_ge_zero =\n-                        fx.bcx.ins().icmp_imm(IntCC::SignedGreaterThanOrEqual, rhs, 0);\n-                    let sat_val = fx.bcx.ins().select(rhs_ge_zero, min, max);\n-                    fx.bcx.ins().select(has_overflow, sat_val, val)\n-                }\n-                _ => unreachable!(),\n-            };\n-\n-            let res = CValue::by_val(val, lhs.layout());\n-\n+            let res = crate::num::codegen_saturating_int_binop(fx, bin_op, lhs, rhs);\n             ret.write_cvalue(fx, res);\n         }\n         sym::rotate_left => {\n@@ -819,8 +813,8 @@ fn codegen_regular_intrinsic_call<'tcx>(\n         sym::ptr_guaranteed_cmp => {\n             intrinsic_args!(fx, args => (a, b); intrinsic);\n \n-            let val = crate::num::codegen_ptr_binop(fx, BinOp::Eq, a, b);\n-            ret.write_cvalue(fx, val);\n+            let val = crate::num::codegen_ptr_binop(fx, BinOp::Eq, a, b).load_scalar(fx);\n+            ret.write_cvalue(fx, CValue::by_val(val, fx.layout_of(fx.tcx.types.u8)));\n         }\n \n         sym::caller_location => {\n@@ -1206,7 +1200,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             // FIXME once unwinding is supported, change this to actually catch panics\n             let f_sig = fx.bcx.func.import_signature(Signature {\n                 call_conv: fx.target_config.default_call_conv,\n-                params: vec![AbiParam::new(fx.bcx.func.dfg.value_type(data))],\n+                params: vec![AbiParam::new(pointer_ty(fx.tcx))],\n                 returns: vec![],\n             });\n "}, {"sha": "51fce8c854bdb5307149680f288fa590ed8a8b53", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/simd.rs", "status": "modified", "additions": 125, "deletions": 3, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fsimd.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -2,6 +2,7 @@\n \n use rustc_middle::ty::subst::SubstsRef;\n use rustc_span::Symbol;\n+use rustc_target::abi::Endian;\n \n use super::*;\n use crate::prelude::*;\n@@ -26,7 +27,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n     span: Span,\n ) {\n     match intrinsic {\n-        sym::simd_cast => {\n+        sym::simd_as | sym::simd_cast => {\n             intrinsic_args!(fx, args => (a); intrinsic);\n \n             if !a.layout().ty.is_simd() {\n@@ -162,6 +163,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                     }\n                 }\n             } else {\n+                // FIXME remove this case\n                 intrinsic.as_str()[\"simd_shuffle\".len()..].parse().unwrap()\n             };\n \n@@ -650,8 +652,128 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n             }\n         }\n \n-        // simd_saturating_*\n-        // simd_bitmask\n+        sym::simd_select_bitmask => {\n+            intrinsic_args!(fx, args => (m, a, b); intrinsic);\n+\n+            if !a.layout().ty.is_simd() {\n+                report_simd_type_validation_error(fx, intrinsic, span, a.layout().ty);\n+                return;\n+            }\n+            assert_eq!(a.layout(), b.layout());\n+\n+            let (lane_count, lane_ty) = a.layout().ty.simd_size_and_type(fx.tcx);\n+            let lane_layout = fx.layout_of(lane_ty);\n+\n+            let m = m.load_scalar(fx);\n+\n+            for lane in 0..lane_count {\n+                let m_lane = fx.bcx.ins().ushr_imm(m, u64::from(lane) as i64);\n+                let m_lane = fx.bcx.ins().band_imm(m_lane, 1);\n+                let a_lane = a.value_lane(fx, lane).load_scalar(fx);\n+                let b_lane = b.value_lane(fx, lane).load_scalar(fx);\n+\n+                let m_lane = fx.bcx.ins().icmp_imm(IntCC::Equal, m_lane, 0);\n+                let res_lane =\n+                    CValue::by_val(fx.bcx.ins().select(m_lane, b_lane, a_lane), lane_layout);\n+\n+                ret.place_lane(fx, lane).write_cvalue(fx, res_lane);\n+            }\n+        }\n+\n+        sym::simd_bitmask => {\n+            intrinsic_args!(fx, args => (a); intrinsic);\n+\n+            let (lane_count, lane_ty) = a.layout().ty.simd_size_and_type(fx.tcx);\n+            let lane_clif_ty = fx.clif_type(lane_ty).unwrap();\n+\n+            // The `fn simd_bitmask(vector) -> unsigned integer` intrinsic takes a\n+            // vector mask and returns the most significant bit (MSB) of each lane in the form\n+            // of either:\n+            // * an unsigned integer\n+            // * an array of `u8`\n+            // If the vector has less than 8 lanes, a u8 is returned with zeroed trailing bits.\n+            //\n+            // The bit order of the result depends on the byte endianness, LSB-first for little\n+            // endian and MSB-first for big endian.\n+            let expected_int_bits = lane_count.max(8);\n+            let expected_bytes = expected_int_bits / 8 + ((expected_int_bits % 8 > 0) as u64);\n+\n+            match lane_ty.kind() {\n+                ty::Int(_) | ty::Uint(_) => {}\n+                _ => {\n+                    fx.tcx.sess.span_fatal(\n+                        span,\n+                        &format!(\n+                            \"invalid monomorphization of `simd_bitmask` intrinsic: \\\n+                            vector argument `{}`'s element type `{}`, expected integer element \\\n+                            type\",\n+                            a.layout().ty,\n+                            lane_ty\n+                        ),\n+                    );\n+                }\n+            }\n+\n+            let res_type =\n+                Type::int_with_byte_size(u16::try_from(expected_bytes).unwrap()).unwrap();\n+            let mut res = fx.bcx.ins().iconst(res_type, 0);\n+\n+            let lanes = match fx.tcx.sess.target.endian {\n+                Endian::Big => Box::new(0..lane_count) as Box<dyn Iterator<Item = u64>>,\n+                Endian::Little => Box::new((0..lane_count).rev()) as Box<dyn Iterator<Item = u64>>,\n+            };\n+            for lane in lanes {\n+                let a_lane = a.value_lane(fx, lane).load_scalar(fx);\n+\n+                // extract sign bit of an int\n+                let a_lane_sign = fx.bcx.ins().ushr_imm(a_lane, i64::from(lane_clif_ty.bits() - 1));\n+\n+                // shift sign bit into result\n+                let a_lane_sign = clif_intcast(fx, a_lane_sign, res_type, false);\n+                res = fx.bcx.ins().ishl_imm(res, 1);\n+                res = fx.bcx.ins().bor(res, a_lane_sign);\n+            }\n+\n+            match ret.layout().ty.kind() {\n+                ty::Uint(i) if i.bit_width() == Some(expected_int_bits) => {}\n+                ty::Array(elem, len)\n+                    if matches!(elem.kind(), ty::Uint(ty::UintTy::U8))\n+                        && len.try_eval_usize(fx.tcx, ty::ParamEnv::reveal_all())\n+                            == Some(expected_bytes) => {}\n+                _ => {\n+                    fx.tcx.sess.span_fatal(\n+                        span,\n+                        &format!(\n+                            \"invalid monomorphization of `simd_bitmask` intrinsic: \\\n+                            cannot return `{}`, expected `u{}` or `[u8; {}]`\",\n+                            ret.layout().ty,\n+                            expected_int_bits,\n+                            expected_bytes\n+                        ),\n+                    );\n+                }\n+            }\n+\n+            let res = CValue::by_val(res, ret.layout());\n+            ret.write_cvalue(fx, res);\n+        }\n+\n+        sym::simd_saturating_add | sym::simd_saturating_sub => {\n+            intrinsic_args!(fx, args => (x, y); intrinsic);\n+\n+            let bin_op = match intrinsic {\n+                sym::simd_saturating_add => BinOp::Add,\n+                sym::simd_saturating_sub => BinOp::Sub,\n+                _ => unreachable!(),\n+            };\n+\n+            // FIXME use vector instructions when possible\n+            simd_pair_for_each_lane_typed(fx, x, y, ret, &|fx, x_lane, y_lane| {\n+                crate::num::codegen_saturating_int_binop(fx, bin_op, x_lane, y_lane)\n+            });\n+        }\n+\n+        // simd_arith_offset\n         // simd_scatter\n         // simd_gather\n         _ => {"}, {"sha": "629d79d501240217d17ac3a6294ff338ed29300c", "filename": "compiler/rustc_codegen_cranelift/src/lib.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -96,8 +96,8 @@ mod prelude {\n     pub(crate) use cranelift_codegen::ir::function::Function;\n     pub(crate) use cranelift_codegen::ir::types;\n     pub(crate) use cranelift_codegen::ir::{\n-        AbiParam, Block, ExternalName, FuncRef, Inst, InstBuilder, MemFlags, Signature, SourceLoc,\n-        StackSlot, StackSlotData, StackSlotKind, TrapCode, Type, Value,\n+        AbiParam, Block, FuncRef, Inst, InstBuilder, MemFlags, Signature, SourceLoc, StackSlot,\n+        StackSlotData, StackSlotKind, TrapCode, Type, Value,\n     };\n     pub(crate) use cranelift_codegen::isa::{self, CallConv};\n     pub(crate) use cranelift_codegen::Context;\n@@ -251,7 +251,6 @@ fn build_isa(sess: &Session, backend_config: &BackendConfig) -> Box<dyn isa::Tar\n \n     let mut flags_builder = settings::builder();\n     flags_builder.enable(\"is_pic\").unwrap();\n-    flags_builder.set(\"enable_probestack\", \"false\").unwrap(); // __cranelift_probestack is not provided\n     let enable_verifier = if backend_config.enable_verifier { \"true\" } else { \"false\" };\n     flags_builder.set(\"enable_verifier\", enable_verifier).unwrap();\n     flags_builder.set(\"regalloc_checker\", enable_verifier).unwrap();\n@@ -279,6 +278,15 @@ fn build_isa(sess: &Session, backend_config: &BackendConfig) -> Box<dyn isa::Tar\n         }\n     }\n \n+    if target_triple.architecture == target_lexicon::Architecture::X86_64 {\n+        // Windows depends on stack probes to grow the committed part of the stack\n+        flags_builder.enable(\"enable_probestack\").unwrap();\n+        flags_builder.set(\"probestack_strategy\", \"inline\").unwrap();\n+    } else {\n+        // __cranelift_probestack is not provided and inline stack probes are only supported on x86_64\n+        flags_builder.set(\"enable_probestack\", \"false\").unwrap();\n+    }\n+\n     let flags = settings::Flags::new(flags_builder);\n \n     let isa_builder = match sess.opts.cg.target_cpu.as_deref() {"}, {"sha": "cae6312a607351d93dc5101562c1760dbdb392a5", "filename": "compiler/rustc_codegen_cranelift/src/main_shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fmain_shim.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -75,7 +75,7 @@ pub(crate) fn maybe_create_entry_wrapper(\n         let main_func_id = m.declare_function(main_name, Linkage::Import, &main_sig).unwrap();\n \n         let mut ctx = Context::new();\n-        ctx.func = Function::with_name_signature(ExternalName::user(0, 0), cmain_sig);\n+        ctx.func.signature = cmain_sig;\n         {\n             let mut func_ctx = FunctionBuilderContext::new();\n             let mut bcx = FunctionBuilder::new(&mut ctx.func, &mut func_ctx);"}, {"sha": "ecbab408ded972889b6cbca8840daee8c2e837f4", "filename": "compiler/rustc_codegen_cranelift/src/num.rs", "status": "modified", "additions": 42, "deletions": 19, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fnum.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -150,18 +150,12 @@ pub(crate) fn codegen_int_binop<'tcx>(\n         BinOp::BitXor => b.bxor(lhs, rhs),\n         BinOp::BitAnd => b.band(lhs, rhs),\n         BinOp::BitOr => b.bor(lhs, rhs),\n-        BinOp::Shl => {\n-            let lhs_ty = fx.bcx.func.dfg.value_type(lhs);\n-            let actual_shift = fx.bcx.ins().band_imm(rhs, i64::from(lhs_ty.bits() - 1));\n-            fx.bcx.ins().ishl(lhs, actual_shift)\n-        }\n+        BinOp::Shl => b.ishl(lhs, rhs),\n         BinOp::Shr => {\n-            let lhs_ty = fx.bcx.func.dfg.value_type(lhs);\n-            let actual_shift = fx.bcx.ins().band_imm(rhs, i64::from(lhs_ty.bits() - 1));\n             if signed {\n-                fx.bcx.ins().sshr(lhs, actual_shift)\n+                b.sshr(lhs, rhs)\n             } else {\n-                fx.bcx.ins().ushr(lhs, actual_shift)\n+                b.ushr(lhs, rhs)\n             }\n         }\n         // Compare binops handles by `codegen_binop`.\n@@ -279,22 +273,15 @@ pub(crate) fn codegen_checked_int_binop<'tcx>(\n             }\n         }\n         BinOp::Shl => {\n-            let lhs_ty = fx.bcx.func.dfg.value_type(lhs);\n-            let masked_shift = fx.bcx.ins().band_imm(rhs, i64::from(lhs_ty.bits() - 1));\n-            let val = fx.bcx.ins().ishl(lhs, masked_shift);\n+            let val = fx.bcx.ins().ishl(lhs, rhs);\n             let ty = fx.bcx.func.dfg.value_type(val);\n             let max_shift = i64::from(ty.bits()) - 1;\n             let has_overflow = fx.bcx.ins().icmp_imm(IntCC::UnsignedGreaterThan, rhs, max_shift);\n             (val, has_overflow)\n         }\n         BinOp::Shr => {\n-            let lhs_ty = fx.bcx.func.dfg.value_type(lhs);\n-            let masked_shift = fx.bcx.ins().band_imm(rhs, i64::from(lhs_ty.bits() - 1));\n-            let val = if !signed {\n-                fx.bcx.ins().ushr(lhs, masked_shift)\n-            } else {\n-                fx.bcx.ins().sshr(lhs, masked_shift)\n-            };\n+            let val =\n+                if !signed { fx.bcx.ins().ushr(lhs, rhs) } else { fx.bcx.ins().sshr(lhs, rhs) };\n             let ty = fx.bcx.func.dfg.value_type(val);\n             let max_shift = i64::from(ty.bits()) - 1;\n             let has_overflow = fx.bcx.ins().icmp_imm(IntCC::UnsignedGreaterThan, rhs, max_shift);\n@@ -309,6 +296,42 @@ pub(crate) fn codegen_checked_int_binop<'tcx>(\n     CValue::by_val_pair(res, has_overflow, out_layout)\n }\n \n+pub(crate) fn codegen_saturating_int_binop<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n+    bin_op: BinOp,\n+    lhs: CValue<'tcx>,\n+    rhs: CValue<'tcx>,\n+) -> CValue<'tcx> {\n+    assert_eq!(lhs.layout().ty, rhs.layout().ty);\n+\n+    let signed = type_sign(lhs.layout().ty);\n+    let clif_ty = fx.clif_type(lhs.layout().ty).unwrap();\n+    let (min, max) = type_min_max_value(&mut fx.bcx, clif_ty, signed);\n+\n+    let checked_res = crate::num::codegen_checked_int_binop(fx, bin_op, lhs, rhs);\n+    let (val, has_overflow) = checked_res.load_scalar_pair(fx);\n+\n+    let val = match (bin_op, signed) {\n+        (BinOp::Add, false) => fx.bcx.ins().select(has_overflow, max, val),\n+        (BinOp::Sub, false) => fx.bcx.ins().select(has_overflow, min, val),\n+        (BinOp::Add, true) => {\n+            let rhs = rhs.load_scalar(fx);\n+            let rhs_ge_zero = fx.bcx.ins().icmp_imm(IntCC::SignedGreaterThanOrEqual, rhs, 0);\n+            let sat_val = fx.bcx.ins().select(rhs_ge_zero, max, min);\n+            fx.bcx.ins().select(has_overflow, sat_val, val)\n+        }\n+        (BinOp::Sub, true) => {\n+            let rhs = rhs.load_scalar(fx);\n+            let rhs_ge_zero = fx.bcx.ins().icmp_imm(IntCC::SignedGreaterThanOrEqual, rhs, 0);\n+            let sat_val = fx.bcx.ins().select(rhs_ge_zero, min, max);\n+            fx.bcx.ins().select(has_overflow, sat_val, val)\n+        }\n+        _ => unreachable!(),\n+    };\n+\n+    CValue::by_val(val, lhs.layout())\n+}\n+\n pub(crate) fn codegen_float_binop<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     bin_op: BinOp,"}, {"sha": "9c88f7dbcda33e424db7b163a8f9d3574699543d", "filename": "compiler/rustc_codegen_cranelift/src/unsize.rs", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -25,7 +25,12 @@ pub(crate) fn unsized_info<'tcx>(\n             .bcx\n             .ins()\n             .iconst(fx.pointer_type, len.eval_usize(fx.tcx, ParamEnv::reveal_all()) as i64),\n-        (&ty::Dynamic(ref data_a, ..), &ty::Dynamic(ref data_b, ..)) => {\n+        (\n+            &ty::Dynamic(ref data_a, _, src_dyn_kind),\n+            &ty::Dynamic(ref data_b, _, target_dyn_kind),\n+        ) => {\n+            assert_eq!(src_dyn_kind, target_dyn_kind);\n+\n             let old_info =\n                 old_info.expect(\"unsized_info: missing old info for trait upcasting coercion\");\n             if data_a.principal_def_id() == data_b.principal_def_id() {\n@@ -101,6 +106,21 @@ fn unsize_ptr<'tcx>(\n     }\n }\n \n+/// Coerces `src` to `dst_ty` which is guaranteed to be a `dyn*` type.\n+pub(crate) fn cast_to_dyn_star<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n+    src: Value,\n+    src_ty_and_layout: TyAndLayout<'tcx>,\n+    dst_ty: Ty<'tcx>,\n+    old_info: Option<Value>,\n+) -> (Value, Value) {\n+    assert!(\n+        matches!(dst_ty.kind(), ty::Dynamic(_, _, ty::DynStar)),\n+        \"destination type must be a dyn*\"\n+    );\n+    (src, unsized_info(fx, src_ty_and_layout.ty, dst_ty, old_info))\n+}\n+\n /// Coerce `src`, which is a reference to a value of type `src_ty`,\n /// to a value of type `dst_ty` and store the result in `dst`\n pub(crate) fn coerce_unsized_into<'tcx>(\n@@ -147,6 +167,24 @@ pub(crate) fn coerce_unsized_into<'tcx>(\n     }\n }\n \n+pub(crate) fn coerce_dyn_star<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n+    src: CValue<'tcx>,\n+    dst: CPlace<'tcx>,\n+) {\n+    let (data, extra) = if let ty::Dynamic(_, _, ty::DynStar) = src.layout().ty.kind() {\n+        let (data, vtable) = src.load_scalar_pair(fx);\n+        (data, Some(vtable))\n+    } else {\n+        let data = src.load_scalar(fx);\n+        (data, None)\n+    };\n+\n+    let (data, vtable) = cast_to_dyn_star(fx, data, src.layout(), dst.layout().ty, extra);\n+\n+    dst.write_cvalue(fx, CValue::by_val_pair(data, vtable, dst.layout()));\n+}\n+\n // Adapted from https://github.com/rust-lang/rust/blob/2a663555ddf36f6b041445894a8c175cd1bc718c/src/librustc_codegen_ssa/glue.rs\n \n pub(crate) fn size_and_align_of_dst<'tcx>("}, {"sha": "c3dfbd37279f9eca6b984156b9d1500a3017ccd4", "filename": "compiler/rustc_codegen_cranelift/src/value_and_place.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -107,6 +107,50 @@ impl<'tcx> CValue<'tcx> {\n         }\n     }\n \n+    // FIXME remove\n+    // Forces the data value of a dyn* value to the stack and returns a pointer to it as well as the\n+    // vtable pointer.\n+    pub(crate) fn dyn_star_force_data_on_stack(\n+        self,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n+    ) -> (Value, Value) {\n+        assert!(self.1.ty.is_dyn_star());\n+\n+        match self.0 {\n+            CValueInner::ByRef(ptr, None) => {\n+                let (a_scalar, b_scalar) = match self.1.abi {\n+                    Abi::ScalarPair(a, b) => (a, b),\n+                    _ => unreachable!(\"dyn_star_force_data_on_stack({:?})\", self),\n+                };\n+                let b_offset = scalar_pair_calculate_b_offset(fx.tcx, a_scalar, b_scalar);\n+                let clif_ty2 = scalar_to_clif_type(fx.tcx, b_scalar);\n+                let mut flags = MemFlags::new();\n+                flags.set_notrap();\n+                let vtable = ptr.offset(fx, b_offset).load(fx, clif_ty2, flags);\n+                (ptr.get_addr(fx), vtable)\n+            }\n+            CValueInner::ByValPair(data, vtable) => {\n+                let stack_slot = fx.bcx.create_sized_stack_slot(StackSlotData {\n+                    kind: StackSlotKind::ExplicitSlot,\n+                    // FIXME Don't force the size to a multiple of 16 bytes once Cranelift gets a way to\n+                    // specify stack slot alignment.\n+                    size: (u32::try_from(fx.target_config.pointer_type().bytes()).unwrap() + 15)\n+                        / 16\n+                        * 16,\n+                });\n+                let data_ptr = Pointer::stack_slot(stack_slot);\n+                let mut flags = MemFlags::new();\n+                flags.set_notrap();\n+                data_ptr.store(fx, data, flags);\n+\n+                (data_ptr.get_addr(fx), vtable)\n+            }\n+            CValueInner::ByRef(_, Some(_)) | CValueInner::ByVal(_) => {\n+                unreachable!(\"dyn_star_force_data_on_stack({:?})\", self)\n+            }\n+        }\n+    }\n+\n     pub(crate) fn try_to_ptr(self) -> Option<(Pointer, Option<Value>)> {\n         match self.0 {\n             CValueInner::ByRef(ptr, meta) => Some((ptr, meta)),\n@@ -236,6 +280,10 @@ impl<'tcx> CValue<'tcx> {\n         crate::unsize::coerce_unsized_into(fx, self, dest);\n     }\n \n+    pub(crate) fn coerce_dyn_star(self, fx: &mut FunctionCx<'_, '_, 'tcx>, dest: CPlace<'tcx>) {\n+        crate::unsize::coerce_dyn_star(fx, self, dest);\n+    }\n+\n     /// If `ty` is signed, `const_val` must already be sign extended.\n     pub(crate) fn const_val(\n         fx: &mut FunctionCx<'_, '_, 'tcx>,"}, {"sha": "f04fb82de8c81f17db8f21f0e48c8d5fcffe5d8a", "filename": "compiler/rustc_codegen_cranelift/src/vtable.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -45,12 +45,26 @@ pub(crate) fn get_ptr_and_method_ref<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     arg: CValue<'tcx>,\n     idx: usize,\n-) -> (Value, Value) {\n-    let (ptr, vtable) = if let Abi::ScalarPair(_, _) = arg.layout().abi {\n-        arg.load_scalar_pair(fx)\n-    } else {\n-        let (ptr, vtable) = arg.try_to_ptr().unwrap();\n-        (ptr.get_addr(fx), vtable.unwrap())\n+) -> (Pointer, Value) {\n+    let (ptr, vtable) = 'block: {\n+        if let ty::Ref(_, ty, _) = arg.layout().ty.kind() {\n+            if ty.is_dyn_star() {\n+                let inner_layout = fx.layout_of(arg.layout().ty.builtin_deref(true).unwrap().ty);\n+                let dyn_star = CPlace::for_ptr(Pointer::new(arg.load_scalar(fx)), inner_layout);\n+                let ptr = dyn_star.place_field(fx, mir::Field::new(0)).to_ptr();\n+                let vtable =\n+                    dyn_star.place_field(fx, mir::Field::new(1)).to_cvalue(fx).load_scalar(fx);\n+                break 'block (ptr, vtable);\n+            }\n+        }\n+\n+        if let Abi::ScalarPair(_, _) = arg.layout().abi {\n+            let (ptr, vtable) = arg.load_scalar_pair(fx);\n+            (Pointer::new(ptr), vtable)\n+        } else {\n+            let (ptr, vtable) = arg.try_to_ptr().unwrap();\n+            (ptr, vtable.unwrap())\n+        }\n     };\n \n     let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes();"}, {"sha": "f18ae7ea5e9b0ff75a07d9567562c9663e5a1f7c", "filename": "compiler/rustc_codegen_gcc/src/archive.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_gcc%2Fsrc%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_gcc%2Fsrc%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Farchive.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -47,6 +47,7 @@ impl ArchiveBuilderBuilder for ArArchiveBuilderBuilder {\n         _lib_name: &str,\n         _dll_imports: &[DllImport],\n         _tmpdir: &Path,\n+        _is_direct_dependency: bool,\n     ) -> PathBuf {\n         unimplemented!();\n     }"}, {"sha": "15ad90f9043c0643f3fd34053c4210394c5f8b5a", "filename": "compiler/rustc_codegen_gcc/src/errors.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_gcc%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_gcc%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ferrors.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -17,7 +17,7 @@ impl IntoDiagnosticArg for ExitCode {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::ranlib_failure)]\n+#[diag(codegen_gcc_ranlib_failure)]\n pub(crate) struct RanlibFailure {\n     exit_code: ExitCode,\n }\n@@ -29,7 +29,7 @@ impl RanlibFailure {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::invalid_monomorphization_basic_integer, code = \"E0511\")]\n+#[diag(codegen_gcc_invalid_monomorphization_basic_integer, code = \"E0511\")]\n pub(crate) struct InvalidMonomorphizationBasicInteger<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -38,7 +38,7 @@ pub(crate) struct InvalidMonomorphizationBasicInteger<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::invalid_monomorphization_invalid_float_vector, code = \"E0511\")]\n+#[diag(codegen_gcc_invalid_monomorphization_invalid_float_vector, code = \"E0511\")]\n pub(crate) struct InvalidMonomorphizationInvalidFloatVector<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -48,7 +48,7 @@ pub(crate) struct InvalidMonomorphizationInvalidFloatVector<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::invalid_monomorphization_not_float, code = \"E0511\")]\n+#[diag(codegen_gcc_invalid_monomorphization_not_float, code = \"E0511\")]\n pub(crate) struct InvalidMonomorphizationNotFloat<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -57,15 +57,15 @@ pub(crate) struct InvalidMonomorphizationNotFloat<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::invalid_monomorphization_unrecognized, code = \"E0511\")]\n+#[diag(codegen_gcc_invalid_monomorphization_unrecognized, code = \"E0511\")]\n pub(crate) struct InvalidMonomorphizationUnrecognized {\n     #[primary_span]\n     pub span: Span,\n     pub name: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::invalid_monomorphization_expected_signed_unsigned, code = \"E0511\")]\n+#[diag(codegen_gcc_invalid_monomorphization_expected_signed_unsigned, code = \"E0511\")]\n pub(crate) struct InvalidMonomorphizationExpectedSignedUnsigned<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -75,7 +75,7 @@ pub(crate) struct InvalidMonomorphizationExpectedSignedUnsigned<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::invalid_monomorphization_unsupported_element, code = \"E0511\")]\n+#[diag(codegen_gcc_invalid_monomorphization_unsupported_element, code = \"E0511\")]\n pub(crate) struct InvalidMonomorphizationUnsupportedElement<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -86,7 +86,7 @@ pub(crate) struct InvalidMonomorphizationUnsupportedElement<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::invalid_monomorphization_invalid_bitmask, code = \"E0511\")]\n+#[diag(codegen_gcc_invalid_monomorphization_invalid_bitmask, code = \"E0511\")]\n pub(crate) struct InvalidMonomorphizationInvalidBitmask<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -97,7 +97,7 @@ pub(crate) struct InvalidMonomorphizationInvalidBitmask<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::invalid_monomorphization_simd_shuffle, code = \"E0511\")]\n+#[diag(codegen_gcc_invalid_monomorphization_simd_shuffle, code = \"E0511\")]\n pub(crate) struct InvalidMonomorphizationSimdShuffle<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -106,7 +106,7 @@ pub(crate) struct InvalidMonomorphizationSimdShuffle<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::invalid_monomorphization_expected_simd, code = \"E0511\")]\n+#[diag(codegen_gcc_invalid_monomorphization_expected_simd, code = \"E0511\")]\n pub(crate) struct InvalidMonomorphizationExpectedSimd<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -116,7 +116,7 @@ pub(crate) struct InvalidMonomorphizationExpectedSimd<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::invalid_monomorphization_mask_type, code = \"E0511\")]\n+#[diag(codegen_gcc_invalid_monomorphization_mask_type, code = \"E0511\")]\n pub(crate) struct InvalidMonomorphizationMaskType<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -125,7 +125,7 @@ pub(crate) struct InvalidMonomorphizationMaskType<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::invalid_monomorphization_return_length, code = \"E0511\")]\n+#[diag(codegen_gcc_invalid_monomorphization_return_length, code = \"E0511\")]\n pub(crate) struct InvalidMonomorphizationReturnLength<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -136,7 +136,7 @@ pub(crate) struct InvalidMonomorphizationReturnLength<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::invalid_monomorphization_return_length_input_type, code = \"E0511\")]\n+#[diag(codegen_gcc_invalid_monomorphization_return_length_input_type, code = \"E0511\")]\n pub(crate) struct InvalidMonomorphizationReturnLengthInputType<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -148,7 +148,7 @@ pub(crate) struct InvalidMonomorphizationReturnLengthInputType<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::invalid_monomorphization_return_element, code = \"E0511\")]\n+#[diag(codegen_gcc_invalid_monomorphization_return_element, code = \"E0511\")]\n pub(crate) struct InvalidMonomorphizationReturnElement<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -160,7 +160,7 @@ pub(crate) struct InvalidMonomorphizationReturnElement<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::invalid_monomorphization_return_type, code = \"E0511\")]\n+#[diag(codegen_gcc_invalid_monomorphization_return_type, code = \"E0511\")]\n pub(crate) struct InvalidMonomorphizationReturnType<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -171,7 +171,7 @@ pub(crate) struct InvalidMonomorphizationReturnType<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::invalid_monomorphization_inserted_type, code = \"E0511\")]\n+#[diag(codegen_gcc_invalid_monomorphization_inserted_type, code = \"E0511\")]\n pub(crate) struct InvalidMonomorphizationInsertedType<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -182,7 +182,7 @@ pub(crate) struct InvalidMonomorphizationInsertedType<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::invalid_monomorphization_return_integer_type, code = \"E0511\")]\n+#[diag(codegen_gcc_invalid_monomorphization_return_integer_type, code = \"E0511\")]\n pub(crate) struct InvalidMonomorphizationReturnIntegerType<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -192,7 +192,7 @@ pub(crate) struct InvalidMonomorphizationReturnIntegerType<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::invalid_monomorphization_mismatched_lengths, code = \"E0511\")]\n+#[diag(codegen_gcc_invalid_monomorphization_mismatched_lengths, code = \"E0511\")]\n pub(crate) struct InvalidMonomorphizationMismatchedLengths {\n     #[primary_span]\n     pub span: Span,\n@@ -202,7 +202,7 @@ pub(crate) struct InvalidMonomorphizationMismatchedLengths {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::invalid_monomorphization_unsupported_cast, code = \"E0511\")]\n+#[diag(codegen_gcc_invalid_monomorphization_unsupported_cast, code = \"E0511\")]\n pub(crate) struct InvalidMonomorphizationUnsupportedCast<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -214,7 +214,7 @@ pub(crate) struct InvalidMonomorphizationUnsupportedCast<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::invalid_monomorphization_unsupported_operation, code = \"E0511\")]\n+#[diag(codegen_gcc_invalid_monomorphization_unsupported_operation, code = \"E0511\")]\n pub(crate) struct InvalidMonomorphizationUnsupportedOperation<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -224,18 +224,18 @@ pub(crate) struct InvalidMonomorphizationUnsupportedOperation<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::linkage_const_or_mut_type)]\n+#[diag(codegen_gcc_linkage_const_or_mut_type)]\n pub(crate) struct LinkageConstOrMutType {\n     #[primary_span]\n     pub span: Span\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::lto_not_supported)]\n+#[diag(codegen_gcc_lto_not_supported)]\n pub(crate) struct LTONotSupported;\n \n #[derive(Diagnostic)]\n-#[diag(codegen_gcc::unwinding_inline_asm)]\n+#[diag(codegen_gcc_unwinding_inline_asm)]\n pub(crate) struct UnwindingInlineAsm {\n     #[primary_span]\n     pub span: Span"}, {"sha": "082665bba3802cc33f56d1ebbc1885964ee2af43", "filename": "compiler/rustc_codegen_llvm/src/back/archive.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -165,10 +165,12 @@ impl ArchiveBuilderBuilder for LlvmArchiveBuilderBuilder {\n         lib_name: &str,\n         dll_imports: &[DllImport],\n         tmpdir: &Path,\n+        is_direct_dependency: bool,\n     ) -> PathBuf {\n+        let name_suffix = if is_direct_dependency { \"_imports\" } else { \"_imports_indirect\" };\n         let output_path = {\n             let mut output_path: PathBuf = tmpdir.to_path_buf();\n-            output_path.push(format!(\"{}_imports\", lib_name));\n+            output_path.push(format!(\"{}{}\", lib_name, name_suffix));\n             output_path.with_extension(\"lib\")\n         };\n \n@@ -195,7 +197,8 @@ impl ArchiveBuilderBuilder for LlvmArchiveBuilderBuilder {\n             // that loaded but crashed with an AV upon calling one of the imported\n             // functions.  Therefore, use binutils to create the import library instead,\n             // by writing a .DEF file to the temp dir and calling binutils's dlltool.\n-            let def_file_path = tmpdir.join(format!(\"{}_imports\", lib_name)).with_extension(\"def\");\n+            let def_file_path =\n+                tmpdir.join(format!(\"{}{}\", lib_name, name_suffix)).with_extension(\"def\");\n \n             let def_file_content = format!(\n                 \"EXPORTS\\n{}\","}, {"sha": "a49cc7f8d662ddd427334895ca2a13e2eb582e78", "filename": "compiler/rustc_codegen_llvm/src/back/lto.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -32,8 +32,8 @@ pub const THIN_LTO_KEYS_INCR_COMP_FILE_NAME: &str = \"thin-lto-past-keys.bin\";\n \n pub fn crate_type_allows_lto(crate_type: CrateType) -> bool {\n     match crate_type {\n-        CrateType::Executable | CrateType::Staticlib | CrateType::Cdylib => true,\n-        CrateType::Dylib | CrateType::Rlib | CrateType::ProcMacro => false,\n+        CrateType::Executable | CrateType::Dylib | CrateType::Staticlib | CrateType::Cdylib => true,\n+        CrateType::Rlib | CrateType::ProcMacro => false,\n     }\n }\n \n@@ -73,17 +73,6 @@ fn prepare_lto(\n     // with either fat or thin LTO\n     let mut upstream_modules = Vec::new();\n     if cgcx.lto != Lto::ThinLocal {\n-        if cgcx.opts.cg.prefer_dynamic {\n-            diag_handler\n-                .struct_err(\"cannot prefer dynamic linking when performing LTO\")\n-                .note(\n-                    \"only 'staticlib', 'bin', and 'cdylib' outputs are \\\n-                               supported with LTO\",\n-                )\n-                .emit();\n-            return Err(FatalError);\n-        }\n-\n         // Make sure we actually can run LTO\n         for crate_type in cgcx.crate_types.iter() {\n             if !crate_type_allows_lto(*crate_type) {\n@@ -92,9 +81,25 @@ fn prepare_lto(\n                                             static library outputs\",\n                 );\n                 return Err(e);\n+            } else if *crate_type == CrateType::Dylib {\n+                if !cgcx.opts.unstable_opts.dylib_lto {\n+                    return Err(diag_handler\n+                        .fatal(\"lto cannot be used for `dylib` crate type without `-Zdylib-lto`\"));\n+                }\n             }\n         }\n \n+        if cgcx.opts.cg.prefer_dynamic && !cgcx.opts.unstable_opts.dylib_lto {\n+            diag_handler\n+                .struct_err(\"cannot prefer dynamic linking when performing LTO\")\n+                .note(\n+                    \"only 'staticlib', 'bin', and 'cdylib' outputs are \\\n+                               supported with LTO\",\n+                )\n+                .emit();\n+            return Err(FatalError);\n+        }\n+\n         for &(cnum, ref path) in cgcx.each_linked_rlib_for_lto.iter() {\n             let exported_symbols =\n                 cgcx.exported_symbols.as_ref().expect(\"needs exported symbols for LTO\");"}, {"sha": "6f0d1b7ce8454ccdd73f7cdecc3aa7f0a6817b6b", "filename": "compiler/rustc_codegen_llvm/src/callee.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -179,7 +179,8 @@ pub fn get_fn<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>, instance: Instance<'tcx>) ->\n             // MinGW: For backward compatibility we rely on the linker to decide whether it\n             // should use dllimport for functions.\n             if cx.use_dll_storage_attrs\n-                && tcx.is_dllimport_foreign_item(instance_def_id)\n+                && let Some(library) = tcx.native_library(instance_def_id)\n+                && library.kind.is_dllimport()\n                 && !matches!(tcx.sess.target.env.as_ref(), \"gnu\" | \"uclibc\")\n             {\n                 llvm::LLVMSetDLLStorageClass(llfn, llvm::DLLStorageClass::DllImport);"}, {"sha": "dd3c43ba5ca7ccb4cf7aef75058b629630757246", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -332,7 +332,10 @@ impl<'ll> CodegenCx<'ll, '_> {\n             }\n         }\n \n-        if self.use_dll_storage_attrs && self.tcx.is_dllimport_foreign_item(def_id) {\n+        if self.use_dll_storage_attrs\n+            && let Some(library) = self.tcx.native_library(def_id)\n+            && library.kind.is_dllimport()\n+        {\n             // For foreign (native) libs we know the exact storage type to use.\n             unsafe {\n                 llvm::LLVMSetDLLStorageClass(g, llvm::DLLStorageClass::DllImport);"}, {"sha": "bb76ca5d2b941a940fdfef8b10cffeda30fee393", "filename": "compiler/rustc_codegen_ssa/src/back/archive.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -25,6 +25,7 @@ pub trait ArchiveBuilderBuilder {\n         lib_name: &str,\n         dll_imports: &[DllImport],\n         tmpdir: &Path,\n+        is_direct_dependency: bool,\n     ) -> PathBuf;\n \n     fn extract_bundled_libs("}, {"sha": "0dc0dee862c7499b2d2b560da48adee126dfcc10", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -11,7 +11,7 @@ use rustc_metadata::find_native_static_library;\n use rustc_metadata::fs::{emit_metadata, METADATA_FILENAME};\n use rustc_middle::middle::dependency_format::Linkage;\n use rustc_middle::middle::exported_symbols::SymbolExportKind;\n-use rustc_session::config::{self, CFGuard, CrateType, DebugInfo, LdImpl, Strip};\n+use rustc_session::config::{self, CFGuard, CrateType, DebugInfo, LdImpl, Lto, Strip};\n use rustc_session::config::{OutputFilenames, OutputType, PrintRequest, SplitDwarfKind};\n use rustc_session::cstore::DllImport;\n use rustc_session::output::{check_file_is_writeable, invalid_output_for_target, out_filename};\n@@ -39,6 +39,7 @@ use cc::windows_registry;\n use regex::Regex;\n use tempfile::Builder as TempFileBuilder;\n \n+use itertools::Itertools;\n use std::borrow::Borrow;\n use std::cell::OnceCell;\n use std::collections::BTreeSet;\n@@ -208,11 +209,29 @@ pub fn link_binary<'a>(\n }\n \n pub fn each_linked_rlib(\n+    sess: &Session,\n     info: &CrateInfo,\n     f: &mut dyn FnMut(CrateNum, &Path),\n ) -> Result<(), errors::LinkRlibError> {\n     let crates = info.used_crates.iter();\n     let mut fmts = None;\n+\n+    let lto_active = matches!(sess.lto(), Lto::Fat | Lto::Thin);\n+    if lto_active {\n+        for combination in info.dependency_formats.iter().combinations(2) {\n+            let (ty1, list1) = &combination[0];\n+            let (ty2, list2) = &combination[1];\n+            if list1 != list2 {\n+                return Err(errors::LinkRlibError::IncompatibleDependencyFormats {\n+                    ty1: format!(\"{ty1:?}\"),\n+                    ty2: format!(\"{ty2:?}\"),\n+                    list1: format!(\"{list1:?}\"),\n+                    list2: format!(\"{list2:?}\"),\n+                });\n+            }\n+        }\n+    }\n+\n     for (ty, list) in info.dependency_formats.iter() {\n         match ty {\n             CrateType::Executable\n@@ -222,6 +241,10 @@ pub fn each_linked_rlib(\n                 fmts = Some(list);\n                 break;\n             }\n+            CrateType::Dylib if lto_active => {\n+                fmts = Some(list);\n+                break;\n+            }\n             _ => {}\n         }\n     }\n@@ -368,13 +391,14 @@ fn link_rlib<'a>(\n     }\n \n     for (raw_dylib_name, raw_dylib_imports) in\n-        collate_raw_dylibs(sess, &codegen_results.crate_info.used_libraries)?\n+        collate_raw_dylibs(sess, codegen_results.crate_info.used_libraries.iter())?\n     {\n         let output_path = archive_builder_builder.create_dll_import_lib(\n             sess,\n             &raw_dylib_name,\n             &raw_dylib_imports,\n             tmpdir.as_ref(),\n+            true,\n         );\n \n         ab.add_archive(&output_path, Box::new(|_| false)).unwrap_or_else(|error| {\n@@ -426,9 +450,9 @@ fn link_rlib<'a>(\n /// then the CodegenResults value contains one NativeLib instance for each block.  However, the\n /// linker appears to expect only a single import library for each library used, so we need to\n /// collate the symbols together by library name before generating the import libraries.\n-fn collate_raw_dylibs(\n-    sess: &Session,\n-    used_libraries: &[NativeLib],\n+fn collate_raw_dylibs<'a, 'b>(\n+    sess: &'a Session,\n+    used_libraries: impl IntoIterator<Item = &'b NativeLib>,\n ) -> Result<Vec<(String, Vec<DllImport>)>, ErrorGuaranteed> {\n     // Use index maps to preserve original order of imports and libraries.\n     let mut dylib_table = FxIndexMap::<String, FxIndexMap<Symbol, &DllImport>>::default();\n@@ -490,7 +514,7 @@ fn link_staticlib<'a>(\n     )?;\n     let mut all_native_libs = vec![];\n \n-    let res = each_linked_rlib(&codegen_results.crate_info, &mut |cnum, path| {\n+    let res = each_linked_rlib(sess, &codegen_results.crate_info, &mut |cnum, path| {\n         let name = codegen_results.crate_info.crate_name[&cnum];\n         let native_libs = &codegen_results.crate_info.native_libraries[&cnum];\n \n@@ -2045,13 +2069,43 @@ fn linker_with_args<'a>(\n \n     // Link with the import library generated for any raw-dylib functions.\n     for (raw_dylib_name, raw_dylib_imports) in\n-        collate_raw_dylibs(sess, &codegen_results.crate_info.used_libraries)?\n+        collate_raw_dylibs(sess, codegen_results.crate_info.used_libraries.iter())?\n+    {\n+        cmd.add_object(&archive_builder_builder.create_dll_import_lib(\n+            sess,\n+            &raw_dylib_name,\n+            &raw_dylib_imports,\n+            tmpdir,\n+            true,\n+        ));\n+    }\n+    // As with add_upstream_native_libraries, we need to add the upstream raw-dylib symbols in case\n+    // they are used within inlined functions or instantiated generic functions. We do this *after*\n+    // handling the raw-dylib symbols in the current crate to make sure that those are chosen first\n+    // by the linker.\n+    let (_, dependency_linkage) = codegen_results\n+        .crate_info\n+        .dependency_formats\n+        .iter()\n+        .find(|(ty, _)| *ty == crate_type)\n+        .expect(\"failed to find crate type in dependency format list\");\n+    let native_libraries_from_nonstatics = codegen_results\n+        .crate_info\n+        .native_libraries\n+        .iter()\n+        .filter_map(|(cnum, libraries)| {\n+            (dependency_linkage[cnum.as_usize() - 1] != Linkage::Static).then(|| libraries)\n+        })\n+        .flatten();\n+    for (raw_dylib_name, raw_dylib_imports) in\n+        collate_raw_dylibs(sess, native_libraries_from_nonstatics)?\n     {\n         cmd.add_object(&archive_builder_builder.create_dll_import_lib(\n             sess,\n             &raw_dylib_name,\n             &raw_dylib_imports,\n             tmpdir,\n+            false,\n         ));\n     }\n "}, {"sha": "99ddd1764785d3c4a649fbad2b2d3844ff652547", "filename": "compiler/rustc_codegen_ssa/src/back/metadata.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -117,6 +117,10 @@ pub(crate) fn create_object_file(sess: &Session) -> Option<write::Object<'static\n         \"riscv32\" => Architecture::Riscv32,\n         \"riscv64\" => Architecture::Riscv64,\n         \"sparc64\" => Architecture::Sparc64,\n+        \"avr\" => Architecture::Avr,\n+        \"msp430\" => Architecture::Msp430,\n+        \"hexagon\" => Architecture::Hexagon,\n+        \"bpf\" => Architecture::Bpf,\n         // Unsupported architecture.\n         _ => return None,\n     };"}, {"sha": "c2ecc41601c8c92bdddacb5b6fa592881d7946f3", "filename": "compiler/rustc_codegen_ssa/src/back/symbol_export.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -13,7 +13,7 @@ use rustc_middle::ty::query::{ExternProviders, Providers};\n use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n use rustc_middle::ty::Instance;\n use rustc_middle::ty::{self, SymbolName, TyCtxt};\n-use rustc_session::config::CrateType;\n+use rustc_session::config::{CrateType, OomStrategy};\n use rustc_target::spec::SanitizerSet;\n \n pub fn threshold(tcx: TyCtxt<'_>) -> SymbolExportLevel {\n@@ -76,7 +76,7 @@ fn reachable_non_generics_provider(tcx: TyCtxt<'_>, cnum: CrateNum) -> DefIdMap<\n             // let it through if it's included statically.\n             match tcx.hir().get_by_def_id(def_id) {\n                 Node::ForeignItem(..) => {\n-                    tcx.is_statically_included_foreign_item(def_id).then_some(def_id)\n+                    tcx.native_library(def_id).map_or(false, |library| library.kind.is_statically_included()).then_some(def_id)\n                 }\n \n                 // Only consider nodes that actually have exported symbols.\n@@ -206,6 +206,15 @@ fn exported_symbols_provider_local<'tcx>(\n                 },\n             ));\n         }\n+\n+        symbols.push((\n+            ExportedSymbol::NoDefId(SymbolName::new(tcx, OomStrategy::SYMBOL)),\n+            SymbolExportInfo {\n+                level: SymbolExportLevel::Rust,\n+                kind: SymbolExportKind::Text,\n+                used: false,\n+            },\n+        ));\n     }\n \n     if tcx.sess.instrument_coverage() || tcx.sess.opts.cg.profile_generate.enabled() {"}, {"sha": "d0ac016b02e151863d263c9223c7c26dba6f2889", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -999,6 +999,14 @@ fn start_executing_work<B: ExtraBackendMethods>(\n     let coordinator_send = tx_to_llvm_workers;\n     let sess = tcx.sess;\n \n+    let mut each_linked_rlib_for_lto = Vec::new();\n+    drop(link::each_linked_rlib(sess, crate_info, &mut |cnum, path| {\n+        if link::ignored_for_lto(sess, crate_info, cnum) {\n+            return;\n+        }\n+        each_linked_rlib_for_lto.push((cnum, path.to_path_buf()));\n+    }));\n+\n     // Compute the set of symbols we need to retain when doing LTO (if we need to)\n     let exported_symbols = {\n         let mut exported_symbols = FxHashMap::default();\n@@ -1020,7 +1028,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n             }\n             Lto::Fat | Lto::Thin => {\n                 exported_symbols.insert(LOCAL_CRATE, copy_symbols(LOCAL_CRATE));\n-                for &cnum in tcx.crates(()).iter() {\n+                for &(cnum, ref _path) in &each_linked_rlib_for_lto {\n                     exported_symbols.insert(cnum, copy_symbols(cnum));\n                 }\n                 Some(Arc::new(exported_symbols))\n@@ -1040,14 +1048,6 @@ fn start_executing_work<B: ExtraBackendMethods>(\n         })\n         .expect(\"failed to spawn helper thread\");\n \n-    let mut each_linked_rlib_for_lto = Vec::new();\n-    drop(link::each_linked_rlib(crate_info, &mut |cnum, path| {\n-        if link::ignored_for_lto(sess, crate_info, cnum) {\n-            return;\n-        }\n-        each_linked_rlib_for_lto.push((cnum, path.to_path_buf()));\n-    }));\n-\n     let ol =\n         if tcx.sess.opts.unstable_opts.no_codegen || !tcx.sess.opts.output_types.should_codegen() {\n             // If we know that we won\u2019t be doing codegen, create target machines without optimisation."}, {"sha": "84b89cd71a6d3047ba3fc9974b40ec6d4eee08c0", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 16, "deletions": 30, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -337,40 +337,26 @@ pub fn coerce_unsized_into<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n \n pub fn cast_shift_expr_rhs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     bx: &mut Bx,\n-    op: hir::BinOpKind,\n-    lhs: Bx::Value,\n-    rhs: Bx::Value,\n-) -> Bx::Value {\n-    cast_shift_rhs(bx, op, lhs, rhs)\n-}\n-\n-fn cast_shift_rhs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n-    bx: &mut Bx,\n-    op: hir::BinOpKind,\n     lhs: Bx::Value,\n     rhs: Bx::Value,\n ) -> Bx::Value {\n     // Shifts may have any size int on the rhs\n-    if op.is_shift() {\n-        let mut rhs_llty = bx.cx().val_ty(rhs);\n-        let mut lhs_llty = bx.cx().val_ty(lhs);\n-        if bx.cx().type_kind(rhs_llty) == TypeKind::Vector {\n-            rhs_llty = bx.cx().element_type(rhs_llty)\n-        }\n-        if bx.cx().type_kind(lhs_llty) == TypeKind::Vector {\n-            lhs_llty = bx.cx().element_type(lhs_llty)\n-        }\n-        let rhs_sz = bx.cx().int_width(rhs_llty);\n-        let lhs_sz = bx.cx().int_width(lhs_llty);\n-        if lhs_sz < rhs_sz {\n-            bx.trunc(rhs, lhs_llty)\n-        } else if lhs_sz > rhs_sz {\n-            // FIXME (#1877: If in the future shifting by negative\n-            // values is no longer undefined then this is wrong.\n-            bx.zext(rhs, lhs_llty)\n-        } else {\n-            rhs\n-        }\n+    let mut rhs_llty = bx.cx().val_ty(rhs);\n+    let mut lhs_llty = bx.cx().val_ty(lhs);\n+    if bx.cx().type_kind(rhs_llty) == TypeKind::Vector {\n+        rhs_llty = bx.cx().element_type(rhs_llty)\n+    }\n+    if bx.cx().type_kind(lhs_llty) == TypeKind::Vector {\n+        lhs_llty = bx.cx().element_type(lhs_llty)\n+    }\n+    let rhs_sz = bx.cx().int_width(rhs_llty);\n+    let lhs_sz = bx.cx().int_width(lhs_llty);\n+    if lhs_sz < rhs_sz {\n+        bx.trunc(rhs, lhs_llty)\n+    } else if lhs_sz > rhs_sz {\n+        // FIXME (#1877: If in the future shifting by negative\n+        // values is no longer undefined then this is wrong.\n+        bx.zext(rhs, lhs_llty)\n     } else {\n         rhs\n     }"}, {"sha": "71f9179d02cca4d8755242083bf1e43b0e27812a", "filename": "compiler/rustc_codegen_ssa/src/common.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcommon.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -1,7 +1,6 @@\n #![allow(non_camel_case_types)]\n \n use rustc_errors::struct_span_err;\n-use rustc_hir as hir;\n use rustc_hir::LangItem;\n use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::ty::{self, layout::TyAndLayout, Ty, TyCtxt};\n@@ -140,7 +139,7 @@ pub fn build_unchecked_lshift<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     lhs: Bx::Value,\n     rhs: Bx::Value,\n ) -> Bx::Value {\n-    let rhs = base::cast_shift_expr_rhs(bx, hir::BinOpKind::Shl, lhs, rhs);\n+    let rhs = base::cast_shift_expr_rhs(bx, lhs, rhs);\n     // #1877, #10183: Ensure that input is always valid\n     let rhs = shift_mask_rhs(bx, rhs);\n     bx.shl(lhs, rhs)\n@@ -152,7 +151,7 @@ pub fn build_unchecked_rshift<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     lhs: Bx::Value,\n     rhs: Bx::Value,\n ) -> Bx::Value {\n-    let rhs = base::cast_shift_expr_rhs(bx, hir::BinOpKind::Shr, lhs, rhs);\n+    let rhs = base::cast_shift_expr_rhs(bx, lhs, rhs);\n     // #1877, #10183: Ensure that input is always valid\n     let rhs = shift_mask_rhs(bx, rhs);\n     let is_signed = lhs_t.is_signed();"}, {"sha": "e05646e1e86a4a04ffc1f31af8abd86ffbe2a818", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -666,10 +666,8 @@ fn push_const_param<'tcx>(tcx: TyCtxt<'tcx>, ct: ty::Const<'tcx>, output: &mut S\n                     hcx.while_hashing_spans(false, |hcx| {\n                         ct.to_valtree().hash_stable(hcx, &mut hasher)\n                     });\n-                    // Note: Don't use `StableHashResult` impl of `u64` here directly, since that\n-                    // would lead to endianness problems.\n-                    let hash: u128 = hasher.finish();\n-                    (hash.to_le() as u64).to_le()\n+                    let hash: u64 = hasher.finish();\n+                    hash\n                 });\n \n                 if cpp_like_debuginfo(tcx) {"}, {"sha": "ebb531f1c43a5e21e9d89c04bd1fc150ec6cbeba", "filename": "compiler/rustc_codegen_ssa/src/errors.rs", "status": "modified", "additions": 65, "deletions": 62, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -13,43 +13,43 @@ use std::path::{Path, PathBuf};\n use std::process::ExitStatus;\n \n #[derive(Diagnostic)]\n-#[diag(codegen_ssa::lib_def_write_failure)]\n+#[diag(codegen_ssa_lib_def_write_failure)]\n pub struct LibDefWriteFailure {\n     pub error: Error,\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_ssa::version_script_write_failure)]\n+#[diag(codegen_ssa_version_script_write_failure)]\n pub struct VersionScriptWriteFailure {\n     pub error: Error,\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_ssa::symbol_file_write_failure)]\n+#[diag(codegen_ssa_symbol_file_write_failure)]\n pub struct SymbolFileWriteFailure {\n     pub error: Error,\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_ssa::ld64_unimplemented_modifier)]\n+#[diag(codegen_ssa_ld64_unimplemented_modifier)]\n pub struct Ld64UnimplementedModifier;\n \n #[derive(Diagnostic)]\n-#[diag(codegen_ssa::linker_unsupported_modifier)]\n+#[diag(codegen_ssa_linker_unsupported_modifier)]\n pub struct LinkerUnsupportedModifier;\n \n #[derive(Diagnostic)]\n-#[diag(codegen_ssa::L4Bender_exporting_symbols_unimplemented)]\n+#[diag(codegen_ssa_L4Bender_exporting_symbols_unimplemented)]\n pub struct L4BenderExportingSymbolsUnimplemented;\n \n #[derive(Diagnostic)]\n-#[diag(codegen_ssa::no_natvis_directory)]\n+#[diag(codegen_ssa_no_natvis_directory)]\n pub struct NoNatvisDirectory {\n     pub error: Error,\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_ssa::copy_path_buf)]\n+#[diag(codegen_ssa_copy_path_buf)]\n pub struct CopyPathBuf {\n     pub source_file: PathBuf,\n     pub output_path: PathBuf,\n@@ -58,7 +58,7 @@ pub struct CopyPathBuf {\n \n // Reports Paths using `Debug` implementation rather than Path's `Display` implementation.\n #[derive(Diagnostic)]\n-#[diag(codegen_ssa::copy_path)]\n+#[diag(codegen_ssa_copy_path)]\n pub struct CopyPath<'a> {\n     from: DebugArgPath<'a>,\n     to: DebugArgPath<'a>,\n@@ -80,36 +80,36 @@ impl IntoDiagnosticArg for DebugArgPath<'_> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_ssa::ignoring_emit_path)]\n+#[diag(codegen_ssa_ignoring_emit_path)]\n pub struct IgnoringEmitPath {\n     pub extension: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_ssa::ignoring_output)]\n+#[diag(codegen_ssa_ignoring_output)]\n pub struct IgnoringOutput {\n     pub extension: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_ssa::create_temp_dir)]\n+#[diag(codegen_ssa_create_temp_dir)]\n pub struct CreateTempDir {\n     pub error: Error,\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_ssa::incompatible_linking_modifiers)]\n+#[diag(codegen_ssa_incompatible_linking_modifiers)]\n pub struct IncompatibleLinkingModifiers;\n \n #[derive(Diagnostic)]\n-#[diag(codegen_ssa::add_native_library)]\n+#[diag(codegen_ssa_add_native_library)]\n pub struct AddNativeLibrary {\n     pub library_path: PathBuf,\n     pub error: Error,\n }\n \n #[derive(Diagnostic)]\n-#[diag(codegen_ssa::multiple_external_func_decl)]\n+#[diag(codegen_ssa_multiple_external_func_decl)]\n pub struct MultipleExternalFuncDecl<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -119,14 +119,17 @@ pub struct MultipleExternalFuncDecl<'a> {\n \n #[derive(Diagnostic)]\n pub enum LinkRlibError {\n-    #[diag(codegen_ssa::rlib_missing_format)]\n+    #[diag(codegen_ssa_rlib_missing_format)]\n     MissingFormat,\n \n-    #[diag(codegen_ssa::rlib_only_rmeta_found)]\n+    #[diag(codegen_ssa_rlib_only_rmeta_found)]\n     OnlyRmetaFound { crate_name: Symbol },\n \n-    #[diag(codegen_ssa::rlib_not_found)]\n+    #[diag(codegen_ssa_rlib_not_found)]\n     NotFound { crate_name: Symbol },\n+\n+    #[diag(codegen_ssa_rlib_incompatible_dependency_formats)]\n+    IncompatibleDependencyFormats { ty1: String, ty2: String, list1: String, list2: String },\n }\n \n pub struct ThorinErrorWrapper(pub thorin::Error);\n@@ -136,188 +139,188 @@ impl IntoDiagnostic<'_> for ThorinErrorWrapper {\n         let mut diag;\n         match self.0 {\n             thorin::Error::ReadInput(_) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_read_input_failure);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_read_input_failure);\n                 diag\n             }\n             thorin::Error::ParseFileKind(_) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_parse_input_file_kind);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_parse_input_file_kind);\n                 diag\n             }\n             thorin::Error::ParseObjectFile(_) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_parse_input_object_file);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_parse_input_object_file);\n                 diag\n             }\n             thorin::Error::ParseArchiveFile(_) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_parse_input_archive_file);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_parse_input_archive_file);\n                 diag\n             }\n             thorin::Error::ParseArchiveMember(_) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_parse_archive_member);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_parse_archive_member);\n                 diag\n             }\n             thorin::Error::InvalidInputKind => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_invalid_input_kind);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_invalid_input_kind);\n                 diag\n             }\n             thorin::Error::DecompressData(_) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_decompress_data);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_decompress_data);\n                 diag\n             }\n             thorin::Error::NamelessSection(_, offset) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_section_without_name);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_section_without_name);\n                 diag.set_arg(\"offset\", format!(\"0x{:08x}\", offset));\n                 diag\n             }\n             thorin::Error::RelocationWithInvalidSymbol(section, offset) => {\n                 diag =\n-                    handler.struct_err(fluent::codegen_ssa::thorin_relocation_with_invalid_symbol);\n+                    handler.struct_err(fluent::codegen_ssa_thorin_relocation_with_invalid_symbol);\n                 diag.set_arg(\"section\", section);\n                 diag.set_arg(\"offset\", format!(\"0x{:08x}\", offset));\n                 diag\n             }\n             thorin::Error::MultipleRelocations(section, offset) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_multiple_relocations);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_multiple_relocations);\n                 diag.set_arg(\"section\", section);\n                 diag.set_arg(\"offset\", format!(\"0x{:08x}\", offset));\n                 diag\n             }\n             thorin::Error::UnsupportedRelocation(section, offset) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_unsupported_relocation);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_unsupported_relocation);\n                 diag.set_arg(\"section\", section);\n                 diag.set_arg(\"offset\", format!(\"0x{:08x}\", offset));\n                 diag\n             }\n             thorin::Error::MissingDwoName(id) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_missing_dwo_name);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_missing_dwo_name);\n                 diag.set_arg(\"id\", format!(\"0x{:08x}\", id));\n                 diag\n             }\n             thorin::Error::NoCompilationUnits => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_no_compilation_units);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_no_compilation_units);\n                 diag\n             }\n             thorin::Error::NoDie => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_no_die);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_no_die);\n                 diag\n             }\n             thorin::Error::TopLevelDieNotUnit => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_top_level_die_not_unit);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_top_level_die_not_unit);\n                 diag\n             }\n             thorin::Error::MissingRequiredSection(section) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_missing_required_section);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_missing_required_section);\n                 diag.set_arg(\"section\", section);\n                 diag\n             }\n             thorin::Error::ParseUnitAbbreviations(_) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_parse_unit_abbreviations);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_parse_unit_abbreviations);\n                 diag\n             }\n             thorin::Error::ParseUnitAttribute(_) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_parse_unit_attribute);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_parse_unit_attribute);\n                 diag\n             }\n             thorin::Error::ParseUnitHeader(_) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_parse_unit_header);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_parse_unit_header);\n                 diag\n             }\n             thorin::Error::ParseUnit(_) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_parse_unit);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_parse_unit);\n                 diag\n             }\n             thorin::Error::IncompatibleIndexVersion(section, format, actual) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_incompatible_index_version);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_incompatible_index_version);\n                 diag.set_arg(\"section\", section);\n                 diag.set_arg(\"actual\", actual);\n                 diag.set_arg(\"format\", format);\n                 diag\n             }\n             thorin::Error::OffsetAtIndex(_, index) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_offset_at_index);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_offset_at_index);\n                 diag.set_arg(\"index\", index);\n                 diag\n             }\n             thorin::Error::StrAtOffset(_, offset) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_str_at_offset);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_str_at_offset);\n                 diag.set_arg(\"offset\", format!(\"0x{:08x}\", offset));\n                 diag\n             }\n             thorin::Error::ParseIndex(_, section) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_parse_index);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_parse_index);\n                 diag.set_arg(\"section\", section);\n                 diag\n             }\n             thorin::Error::UnitNotInIndex(unit) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_unit_not_in_index);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_unit_not_in_index);\n                 diag.set_arg(\"unit\", format!(\"0x{:08x}\", unit));\n                 diag\n             }\n             thorin::Error::RowNotInIndex(_, row) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_row_not_in_index);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_row_not_in_index);\n                 diag.set_arg(\"row\", row);\n                 diag\n             }\n             thorin::Error::SectionNotInRow => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_section_not_in_row);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_section_not_in_row);\n                 diag\n             }\n             thorin::Error::EmptyUnit(unit) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_empty_unit);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_empty_unit);\n                 diag.set_arg(\"unit\", format!(\"0x{:08x}\", unit));\n                 diag\n             }\n             thorin::Error::MultipleDebugInfoSection => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_multiple_debug_info_section);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_multiple_debug_info_section);\n                 diag\n             }\n             thorin::Error::MultipleDebugTypesSection => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_multiple_debug_types_section);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_multiple_debug_types_section);\n                 diag\n             }\n             thorin::Error::NotSplitUnit => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_not_split_unit);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_not_split_unit);\n                 diag\n             }\n             thorin::Error::DuplicateUnit(unit) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_duplicate_unit);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_duplicate_unit);\n                 diag.set_arg(\"unit\", format!(\"0x{:08x}\", unit));\n                 diag\n             }\n             thorin::Error::MissingReferencedUnit(unit) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_missing_referenced_unit);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_missing_referenced_unit);\n                 diag.set_arg(\"unit\", format!(\"0x{:08x}\", unit));\n                 diag\n             }\n             thorin::Error::NoOutputObjectCreated => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_not_output_object_created);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_not_output_object_created);\n                 diag\n             }\n             thorin::Error::MixedInputEncodings => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_mixed_input_encodings);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_mixed_input_encodings);\n                 diag\n             }\n             thorin::Error::Io(e) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_io);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_io);\n                 diag.set_arg(\"error\", format!(\"{e}\"));\n                 diag\n             }\n             thorin::Error::ObjectRead(e) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_object_read);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_object_read);\n                 diag.set_arg(\"error\", format!(\"{e}\"));\n                 diag\n             }\n             thorin::Error::ObjectWrite(e) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_object_write);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_object_write);\n                 diag.set_arg(\"error\", format!(\"{e}\"));\n                 diag\n             }\n             thorin::Error::GimliRead(e) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_gimli_read);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_gimli_read);\n                 diag.set_arg(\"error\", format!(\"{e}\"));\n                 diag\n             }\n             thorin::Error::GimliWrite(e) => {\n-                diag = handler.struct_err(fluent::codegen_ssa::thorin_gimli_write);\n+                diag = handler.struct_err(fluent::codegen_ssa_thorin_gimli_write);\n                 diag.set_arg(\"error\", format!(\"{e}\"));\n                 diag\n             }\n@@ -335,7 +338,7 @@ pub struct LinkingFailed<'a> {\n \n impl IntoDiagnostic<'_> for LinkingFailed<'_> {\n     fn into_diagnostic(self, handler: &Handler) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n-        let mut diag = handler.struct_err(fluent::codegen_ssa::linking_failed);\n+        let mut diag = handler.struct_err(fluent::codegen_ssa_linking_failed);\n         diag.set_arg(\"linker_path\", format!(\"{}\", self.linker_path.display()));\n         diag.set_arg(\"exit_status\", format!(\"{}\", self.exit_status));\n \n@@ -344,9 +347,9 @@ impl IntoDiagnostic<'_> for LinkingFailed<'_> {\n         // Trying to match an error from OS linkers\n         // which by now we have no way to translate.\n         if self.escaped_output.contains(\"undefined reference to\") {\n-            diag.note(fluent::codegen_ssa::extern_funcs_not_found)\n-                .note(fluent::codegen_ssa::specify_libraries_to_link)\n-                .note(fluent::codegen_ssa::use_cargo_directive);\n+            diag.note(fluent::codegen_ssa_extern_funcs_not_found)\n+                .note(fluent::codegen_ssa_specify_libraries_to_link)\n+                .note(fluent::codegen_ssa_use_cargo_directive);\n         }\n         diag\n     }"}, {"sha": "29b7c9b0a8832af029fd84c07812acc057143d9f", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 47, "deletions": 39, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -63,7 +63,9 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n         }\n     }\n \n-    fn lltarget<Bx: BuilderMethods<'a, 'tcx>>(\n+    /// Get a basic block (creating it if necessary), possibly with a landing\n+    /// pad next to it.\n+    fn llbb_with_landing_pad<Bx: BuilderMethods<'a, 'tcx>>(\n         &self,\n         fx: &mut FunctionCx<'a, 'tcx, Bx>,\n         target: mir::BasicBlock,\n@@ -73,32 +75,36 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n         let target_funclet = fx.cleanup_kinds[target].funclet_bb(target);\n         match (self.funclet_bb, target_funclet) {\n             (None, None) => (lltarget, false),\n-            (Some(f), Some(t_f)) if f == t_f || !base::wants_msvc_seh(fx.cx.tcx().sess) => {\n-                (lltarget, false)\n-            }\n             // jump *into* cleanup - need a landing pad if GNU, cleanup pad if MSVC\n             (None, Some(_)) => (fx.landing_pad_for(target), false),\n             (Some(_), None) => span_bug!(span, \"{:?} - jump out of cleanup?\", self.terminator),\n-            (Some(_), Some(_)) => (fx.landing_pad_for(target), true),\n+            (Some(f), Some(t_f)) => {\n+                if f == t_f || !base::wants_msvc_seh(fx.cx.tcx().sess) {\n+                    (lltarget, false)\n+                } else {\n+                    (fx.landing_pad_for(target), true)\n+                }\n+            }\n         }\n     }\n \n-    /// Create a basic block.\n-    fn llblock<Bx: BuilderMethods<'a, 'tcx>>(\n+    /// Get a basic block (creating it if necessary), possibly with cleanup\n+    /// stuff in it or next to it.\n+    fn llbb_with_cleanup<Bx: BuilderMethods<'a, 'tcx>>(\n         &self,\n         fx: &mut FunctionCx<'a, 'tcx, Bx>,\n         target: mir::BasicBlock,\n     ) -> Bx::BasicBlock {\n-        let (lltarget, is_cleanupret) = self.lltarget(fx, target);\n+        let (lltarget, is_cleanupret) = self.llbb_with_landing_pad(fx, target);\n         if is_cleanupret {\n             // MSVC cross-funclet jump - need a trampoline\n-\n-            debug!(\"llblock: creating cleanup trampoline for {:?}\", target);\n+            debug_assert!(base::wants_msvc_seh(fx.cx.tcx().sess));\n+            debug!(\"llbb_with_cleanup: creating cleanup trampoline for {:?}\", target);\n             let name = &format!(\"{:?}_cleanup_trampoline_{:?}\", self.bb, target);\n-            let trampoline = Bx::append_block(fx.cx, fx.llfn, name);\n-            let mut trampoline_bx = Bx::build(fx.cx, trampoline);\n+            let trampoline_llbb = Bx::append_block(fx.cx, fx.llfn, name);\n+            let mut trampoline_bx = Bx::build(fx.cx, trampoline_llbb);\n             trampoline_bx.cleanup_ret(self.funclet(fx).unwrap(), Some(lltarget));\n-            trampoline\n+            trampoline_llbb\n         } else {\n             lltarget\n         }\n@@ -110,10 +116,11 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n         bx: &mut Bx,\n         target: mir::BasicBlock,\n     ) {\n-        let (lltarget, is_cleanupret) = self.lltarget(fx, target);\n+        let (lltarget, is_cleanupret) = self.llbb_with_landing_pad(fx, target);\n         if is_cleanupret {\n-            // micro-optimization: generate a `ret` rather than a jump\n+            // MSVC micro-optimization: generate a `ret` rather than a jump\n             // to a trampoline.\n+            debug_assert!(base::wants_msvc_seh(fx.cx.tcx().sess));\n             bx.cleanup_ret(self.funclet(fx).unwrap(), Some(lltarget));\n         } else {\n             bx.br(lltarget);\n@@ -138,7 +145,7 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n         let fn_ty = bx.fn_decl_backend_type(&fn_abi);\n \n         let unwind_block = if let Some(cleanup) = cleanup.filter(|_| fn_abi.can_unwind) {\n-            Some(self.llblock(fx, cleanup))\n+            Some(self.llbb_with_cleanup(fx, cleanup))\n         } else if fx.mir[self.bb].is_cleanup\n             && fn_abi.can_unwind\n             && !base::wants_msvc_seh(fx.cx.tcx().sess)\n@@ -231,7 +238,7 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n                 options,\n                 line_spans,\n                 instance,\n-                Some((ret_llbb, self.llblock(fx, cleanup), self.funclet(fx))),\n+                Some((ret_llbb, self.llbb_with_cleanup(fx, cleanup), self.funclet(fx))),\n             );\n         } else {\n             bx.codegen_inline_asm(template, &operands, options, line_spans, instance, None);\n@@ -281,8 +288,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         if target_iter.len() == 1 {\n             // If there are two targets (one conditional, one fallback), emit br instead of switch\n             let (test_value, target) = target_iter.next().unwrap();\n-            let lltrue = helper.llblock(self, target);\n-            let llfalse = helper.llblock(self, targets.otherwise());\n+            let lltrue = helper.llbb_with_cleanup(self, target);\n+            let llfalse = helper.llbb_with_cleanup(self, targets.otherwise());\n             if switch_ty == bx.tcx().types.bool {\n                 // Don't generate trivial icmps when switching on bool\n                 match test_value {\n@@ -299,8 +306,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         } else {\n             bx.switch(\n                 discr.immediate(),\n-                helper.llblock(self, targets.otherwise()),\n-                target_iter.map(|(value, target)| (value, helper.llblock(self, target))),\n+                helper.llbb_with_cleanup(self, targets.otherwise()),\n+                target_iter.map(|(value, target)| (value, helper.llbb_with_cleanup(self, target))),\n             );\n         }\n     }\n@@ -530,7 +537,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let cond = bx.expect(cond, expected);\n \n         // Create the failure block and the conditional branch to it.\n-        let lltarget = helper.llblock(self, target);\n+        let lltarget = helper.llbb_with_cleanup(self, target);\n         let panic_block = bx.append_sibling_block(\"panic\");\n         if expected {\n             bx.cond_br(cond, lltarget, panic_block);\n@@ -1459,20 +1466,20 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 //          bar();\n                 //      }\n                 Some(&mir::TerminatorKind::Abort) => {\n-                    let cs_bb =\n+                    let cs_llbb =\n                         Bx::append_block(self.cx, self.llfn, &format!(\"cs_funclet{:?}\", bb));\n-                    let cp_bb =\n+                    let cp_llbb =\n                         Bx::append_block(self.cx, self.llfn, &format!(\"cp_funclet{:?}\", bb));\n-                    ret_llbb = cs_bb;\n+                    ret_llbb = cs_llbb;\n \n-                    let mut cs_bx = Bx::build(self.cx, cs_bb);\n-                    let cs = cs_bx.catch_switch(None, None, &[cp_bb]);\n+                    let mut cs_bx = Bx::build(self.cx, cs_llbb);\n+                    let cs = cs_bx.catch_switch(None, None, &[cp_llbb]);\n \n                     // The \"null\" here is actually a RTTI type descriptor for the\n                     // C++ personality function, but `catch (...)` has no type so\n                     // it's null. The 64 here is actually a bitfield which\n                     // represents that this is a catch-all block.\n-                    let mut cp_bx = Bx::build(self.cx, cp_bb);\n+                    let mut cp_bx = Bx::build(self.cx, cp_llbb);\n                     let null = cp_bx.const_null(\n                         cp_bx.type_i8p_ext(cp_bx.cx().data_layout().instruction_address_space),\n                     );\n@@ -1481,30 +1488,31 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     cp_bx.br(llbb);\n                 }\n                 _ => {\n-                    let cleanup_bb =\n+                    let cleanup_llbb =\n                         Bx::append_block(self.cx, self.llfn, &format!(\"funclet_{:?}\", bb));\n-                    ret_llbb = cleanup_bb;\n-                    let mut cleanup_bx = Bx::build(self.cx, cleanup_bb);\n+                    ret_llbb = cleanup_llbb;\n+                    let mut cleanup_bx = Bx::build(self.cx, cleanup_llbb);\n                     funclet = cleanup_bx.cleanup_pad(None, &[]);\n                     cleanup_bx.br(llbb);\n                 }\n             }\n             self.funclets[bb] = Some(funclet);\n             ret_llbb\n         } else {\n-            let bb = Bx::append_block(self.cx, self.llfn, \"cleanup\");\n-            let mut bx = Bx::build(self.cx, bb);\n+            let cleanup_llbb = Bx::append_block(self.cx, self.llfn, \"cleanup\");\n+            let mut cleanup_bx = Bx::build(self.cx, cleanup_llbb);\n \n             let llpersonality = self.cx.eh_personality();\n             let llretty = self.landing_pad_type();\n-            let lp = bx.cleanup_landing_pad(llretty, llpersonality);\n+            let lp = cleanup_bx.cleanup_landing_pad(llretty, llpersonality);\n \n-            let slot = self.get_personality_slot(&mut bx);\n-            slot.storage_live(&mut bx);\n-            Pair(bx.extract_value(lp, 0), bx.extract_value(lp, 1)).store(&mut bx, slot);\n+            let slot = self.get_personality_slot(&mut cleanup_bx);\n+            slot.storage_live(&mut cleanup_bx);\n+            Pair(cleanup_bx.extract_value(lp, 0), cleanup_bx.extract_value(lp, 1))\n+                .store(&mut cleanup_bx, slot);\n \n-            bx.br(llbb);\n-            bx.llbb()\n+            cleanup_bx.br(llbb);\n+            cleanup_llbb\n         }\n     }\n "}, {"sha": "da9aaf00ecf6e83f4e9c62af5df4e1d054d5a08c", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -148,10 +148,10 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     let debug_context = cx.create_function_debug_context(instance, &fn_abi, llfn, &mir);\n \n     let start_llbb = Bx::append_block(cx, llfn, \"start\");\n-    let mut bx = Bx::build(cx, start_llbb);\n+    let mut start_bx = Bx::build(cx, start_llbb);\n \n     if mir.basic_blocks.iter().any(|bb| bb.is_cleanup) {\n-        bx.set_personality_fn(cx.eh_personality());\n+        start_bx.set_personality_fn(cx.eh_personality());\n     }\n \n     let cleanup_kinds = analyze::cleanup_kinds(&mir);\n@@ -180,7 +180,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         caller_location: None,\n     };\n \n-    fx.per_local_var_debug_info = fx.compute_per_local_var_debug_info(&mut bx);\n+    fx.per_local_var_debug_info = fx.compute_per_local_var_debug_info(&mut start_bx);\n \n     // Evaluate all required consts; codegen later assumes that CTFE will never fail.\n     let mut all_consts_ok = true;\n@@ -206,29 +206,29 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n \n     // Allocate variable and temp allocas\n     fx.locals = {\n-        let args = arg_local_refs(&mut bx, &mut fx, &memory_locals);\n+        let args = arg_local_refs(&mut start_bx, &mut fx, &memory_locals);\n \n         let mut allocate_local = |local| {\n             let decl = &mir.local_decls[local];\n-            let layout = bx.layout_of(fx.monomorphize(decl.ty));\n+            let layout = start_bx.layout_of(fx.monomorphize(decl.ty));\n             assert!(!layout.ty.has_erasable_regions());\n \n             if local == mir::RETURN_PLACE && fx.fn_abi.ret.is_indirect() {\n                 debug!(\"alloc: {:?} (return place) -> place\", local);\n-                let llretptr = bx.get_param(0);\n+                let llretptr = start_bx.get_param(0);\n                 return LocalRef::Place(PlaceRef::new_sized(llretptr, layout));\n             }\n \n             if memory_locals.contains(local) {\n                 debug!(\"alloc: {:?} -> place\", local);\n                 if layout.is_unsized() {\n-                    LocalRef::UnsizedPlace(PlaceRef::alloca_unsized_indirect(&mut bx, layout))\n+                    LocalRef::UnsizedPlace(PlaceRef::alloca_unsized_indirect(&mut start_bx, layout))\n                 } else {\n-                    LocalRef::Place(PlaceRef::alloca(&mut bx, layout))\n+                    LocalRef::Place(PlaceRef::alloca(&mut start_bx, layout))\n                 }\n             } else {\n                 debug!(\"alloc: {:?} -> operand\", local);\n-                LocalRef::new_operand(&mut bx, layout)\n+                LocalRef::new_operand(&mut start_bx, layout)\n             }\n         };\n \n@@ -240,7 +240,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     };\n \n     // Apply debuginfo to the newly allocated locals.\n-    fx.debug_introduce_locals(&mut bx);\n+    fx.debug_introduce_locals(&mut start_bx);\n \n     // Codegen the body of each block using reverse postorder\n     for (bb, _) in traversal::reverse_postorder(&mir) {"}, {"sha": "4b055076742b2f7e0ff60022806873c4f487f846", "filename": "compiler/rustc_const_eval/src/errors.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_const_eval%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_const_eval%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ferrors.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -3,144 +3,144 @@ use rustc_macros::Diagnostic;\n use rustc_span::Span;\n \n #[derive(Diagnostic)]\n-#[diag(const_eval::unstable_in_stable)]\n+#[diag(const_eval_unstable_in_stable)]\n pub(crate) struct UnstableInStable {\n     pub gate: String,\n     #[primary_span]\n     pub span: Span,\n     #[suggestion(\n-        const_eval::unstable_sugg,\n+        unstable_sugg,\n         code = \"#[rustc_const_unstable(feature = \\\"...\\\", issue = \\\"...\\\")]\\n\",\n         applicability = \"has-placeholders\"\n     )]\n     #[suggestion(\n-        const_eval::bypass_sugg,\n+        bypass_sugg,\n         code = \"#[rustc_allow_const_fn_unstable({gate})]\\n\",\n         applicability = \"has-placeholders\"\n     )]\n     pub attr_span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(const_eval::thread_local_access, code = \"E0625\")]\n+#[diag(const_eval_thread_local_access, code = \"E0625\")]\n pub(crate) struct NonConstOpErr {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(const_eval::static_access, code = \"E0013\")]\n+#[diag(const_eval_static_access, code = \"E0013\")]\n #[help]\n pub(crate) struct StaticAccessErr {\n     #[primary_span]\n     pub span: Span,\n     pub kind: ConstContext,\n-    #[note(const_eval::teach_note)]\n-    #[help(const_eval::teach_help)]\n+    #[note(teach_note)]\n+    #[help(teach_help)]\n     pub teach: Option<()>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(const_eval::raw_ptr_to_int)]\n+#[diag(const_eval_raw_ptr_to_int)]\n #[note]\n-#[note(const_eval::note2)]\n+#[note(note2)]\n pub(crate) struct RawPtrToIntErr {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(const_eval::raw_ptr_comparison)]\n+#[diag(const_eval_raw_ptr_comparison)]\n #[note]\n pub(crate) struct RawPtrComparisonErr {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(const_eval::panic_non_str)]\n+#[diag(const_eval_panic_non_str)]\n pub(crate) struct PanicNonStrErr {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(const_eval::mut_deref, code = \"E0658\")]\n+#[diag(const_eval_mut_deref, code = \"E0658\")]\n pub(crate) struct MutDerefErr {\n     #[primary_span]\n     pub span: Span,\n     pub kind: ConstContext,\n }\n \n #[derive(Diagnostic)]\n-#[diag(const_eval::transient_mut_borrow, code = \"E0658\")]\n+#[diag(const_eval_transient_mut_borrow, code = \"E0658\")]\n pub(crate) struct TransientMutBorrowErr {\n     #[primary_span]\n     pub span: Span,\n     pub kind: ConstContext,\n }\n \n #[derive(Diagnostic)]\n-#[diag(const_eval::transient_mut_borrow_raw, code = \"E0658\")]\n+#[diag(const_eval_transient_mut_borrow_raw, code = \"E0658\")]\n pub(crate) struct TransientMutBorrowErrRaw {\n     #[primary_span]\n     pub span: Span,\n     pub kind: ConstContext,\n }\n \n #[derive(Diagnostic)]\n-#[diag(const_eval::max_num_nodes_in_const)]\n+#[diag(const_eval_max_num_nodes_in_const)]\n pub(crate) struct MaxNumNodesInConstErr {\n     #[primary_span]\n     pub span: Span,\n     pub global_const_id: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(const_eval::unallowed_fn_pointer_call)]\n+#[diag(const_eval_unallowed_fn_pointer_call)]\n pub(crate) struct UnallowedFnPointerCall {\n     #[primary_span]\n     pub span: Span,\n     pub kind: ConstContext,\n }\n \n #[derive(Diagnostic)]\n-#[diag(const_eval::unstable_const_fn)]\n+#[diag(const_eval_unstable_const_fn)]\n pub(crate) struct UnstableConstFn {\n     #[primary_span]\n     pub span: Span,\n     pub def_path: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(const_eval::unallowed_mutable_refs, code = \"E0764\")]\n+#[diag(const_eval_unallowed_mutable_refs, code = \"E0764\")]\n pub(crate) struct UnallowedMutableRefs {\n     #[primary_span]\n     pub span: Span,\n     pub kind: ConstContext,\n-    #[note(const_eval::teach_note)]\n+    #[note(teach_note)]\n     pub teach: Option<()>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(const_eval::unallowed_mutable_refs_raw, code = \"E0764\")]\n+#[diag(const_eval_unallowed_mutable_refs_raw, code = \"E0764\")]\n pub(crate) struct UnallowedMutableRefsRaw {\n     #[primary_span]\n     pub span: Span,\n     pub kind: ConstContext,\n-    #[note(const_eval::teach_note)]\n+    #[note(teach_note)]\n     pub teach: Option<()>,\n }\n #[derive(Diagnostic)]\n-#[diag(const_eval::non_const_fmt_macro_call, code = \"E0015\")]\n+#[diag(const_eval_non_const_fmt_macro_call, code = \"E0015\")]\n pub(crate) struct NonConstFmtMacroCall {\n     #[primary_span]\n     pub span: Span,\n     pub kind: ConstContext,\n }\n \n #[derive(Diagnostic)]\n-#[diag(const_eval::non_const_fn_call, code = \"E0015\")]\n+#[diag(const_eval_non_const_fn_call, code = \"E0015\")]\n pub(crate) struct NonConstFnCall {\n     #[primary_span]\n     pub span: Span,\n@@ -149,47 +149,47 @@ pub(crate) struct NonConstFnCall {\n }\n \n #[derive(Diagnostic)]\n-#[diag(const_eval::unallowed_op_in_const_context)]\n+#[diag(const_eval_unallowed_op_in_const_context)]\n pub(crate) struct UnallowedOpInConstContext {\n     #[primary_span]\n     pub span: Span,\n     pub msg: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(const_eval::unallowed_heap_allocations, code = \"E0010\")]\n+#[diag(const_eval_unallowed_heap_allocations, code = \"E0010\")]\n pub(crate) struct UnallowedHeapAllocations {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n     pub kind: ConstContext,\n-    #[note(const_eval::teach_note)]\n+    #[note(teach_note)]\n     pub teach: Option<()>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(const_eval::unallowed_inline_asm, code = \"E0015\")]\n+#[diag(const_eval_unallowed_inline_asm, code = \"E0015\")]\n pub(crate) struct UnallowedInlineAsm {\n     #[primary_span]\n     pub span: Span,\n     pub kind: ConstContext,\n }\n \n #[derive(Diagnostic)]\n-#[diag(const_eval::interior_mutable_data_refer, code = \"E0492\")]\n+#[diag(const_eval_interior_mutable_data_refer, code = \"E0492\")]\n pub(crate) struct InteriorMutableDataRefer {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n     #[help]\n     pub opt_help: Option<()>,\n     pub kind: ConstContext,\n-    #[note(const_eval::teach_note)]\n+    #[note(teach_note)]\n     pub teach: Option<()>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(const_eval::interior_mutability_borrow)]\n+#[diag(const_eval_interior_mutability_borrow)]\n pub(crate) struct InteriorMutabilityBorrow {\n     #[primary_span]\n     pub span: Span,"}, {"sha": "f980e606b932d2ae4640b6b03d4faa6741e08259", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 43, "deletions": 20, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -42,10 +42,22 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let res = self.pointer_from_exposed_address_cast(&src, cast_ty)?;\n                 self.write_immediate(res, dest)?;\n             }\n-            // FIXME: We shouldn't use `misc_cast` for these but handle them separately.\n-            IntToInt | FloatToInt | FloatToFloat | IntToFloat | FnPtrToPtr | PtrToPtr => {\n+\n+            IntToInt | IntToFloat => {\n                 let src = self.read_immediate(src)?;\n-                let res = self.misc_cast(&src, cast_ty)?;\n+                let res = self.int_to_int_or_float(&src, cast_ty)?;\n+                self.write_immediate(res, dest)?;\n+            }\n+\n+            FloatToFloat | FloatToInt => {\n+                let src = self.read_immediate(src)?;\n+                let res = self.float_to_float_or_int(&src, cast_ty)?;\n+                self.write_immediate(res, dest)?;\n+            }\n+\n+            FnPtrToPtr | PtrToPtr => {\n+                let src = self.read_immediate(&src)?;\n+                let res = self.ptr_to_ptr(&src, cast_ty)?;\n                 self.write_immediate(res, dest)?;\n             }\n \n@@ -126,13 +138,27 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    pub fn misc_cast(\n+    pub fn int_to_int_or_float(\n+        &mut self,\n+        src: &ImmTy<'tcx, M::Provenance>,\n+        cast_ty: Ty<'tcx>,\n+    ) -> InterpResult<'tcx, Immediate<M::Provenance>> {\n+        if (src.layout.ty.is_integral() || src.layout.ty.is_char() || src.layout.ty.is_bool())\n+            && (cast_ty.is_floating_point() || cast_ty.is_integral() || cast_ty.is_char())\n+        {\n+            let scalar = src.to_scalar();\n+            Ok(self.cast_from_int_like(scalar, src.layout, cast_ty)?.into())\n+        } else {\n+            bug!(\"Unexpected cast from type {:?}\", src.layout.ty)\n+        }\n+    }\n+\n+    pub fn float_to_float_or_int(\n         &mut self,\n         src: &ImmTy<'tcx, M::Provenance>,\n         cast_ty: Ty<'tcx>,\n     ) -> InterpResult<'tcx, Immediate<M::Provenance>> {\n         use rustc_type_ir::sty::TyKind::*;\n-        trace!(\"Casting {:?}: {:?} to {:?}\", *src, src.layout.ty, cast_ty);\n \n         match src.layout.ty.kind() {\n             // Floating point\n@@ -142,19 +168,18 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Float(FloatTy::F64) => {\n                 return Ok(self.cast_from_float(src.to_scalar().to_f64()?, cast_ty).into());\n             }\n-            // The rest is integer/pointer-\"like\", including fn ptr casts\n-            _ => assert!(\n-                src.layout.ty.is_bool()\n-                    || src.layout.ty.is_char()\n-                    || src.layout.ty.is_integral()\n-                    || src.layout.ty.is_any_ptr(),\n-                \"Unexpected cast from type {:?}\",\n-                src.layout.ty\n-            ),\n+            _ => {\n+                bug!(\"Can't cast 'Float' type into {:?}\", cast_ty);\n+            }\n         }\n+    }\n \n-        // # First handle non-scalar source values.\n-\n+    /// Handles 'FnPtrToPtr' and 'PtrToPtr' casts.\n+    pub fn ptr_to_ptr(\n+        &mut self,\n+        src: &ImmTy<'tcx, M::Provenance>,\n+        cast_ty: Ty<'tcx>,\n+    ) -> InterpResult<'tcx, Immediate<M::Provenance>> {\n         // Handle casting any ptr to raw ptr (might be a fat ptr).\n         if src.layout.ty.is_any_ptr() && cast_ty.is_unsafe_ptr() {\n             let dest_layout = self.layout_of(cast_ty)?;\n@@ -178,11 +203,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     Immediate::Uninit => throw_ub!(InvalidUninitBytes(None)),\n                 };\n             }\n+        } else {\n+            bug!(\"Can't cast 'Ptr' or 'FnPtr' into {:?}\", cast_ty);\n         }\n-\n-        // # The remaining source values are scalar and \"int-like\".\n-        let scalar = src.to_scalar();\n-        Ok(self.cast_from_int_like(scalar, src.layout, cast_ty)?.into())\n     }\n \n     pub fn pointer_expose_address_cast("}, {"sha": "7f78d963e9f0ad74913c69e2cc864a7bfdb2d2ce", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -556,21 +556,36 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 check_kinds!(a, \"Cannot shallow init type {:?}\", ty::RawPtr(..));\n             }\n             Rvalue::Cast(kind, operand, target_type) => {\n+                let op_ty = operand.ty(self.body, self.tcx);\n                 match kind {\n                     CastKind::DynStar => {\n                         // FIXME(dyn-star): make sure nothing needs to be done here.\n                     }\n-                    // Nothing to check here\n+                    // FIXME: Add Checks for these\n                     CastKind::PointerFromExposedAddress\n                     | CastKind::PointerExposeAddress\n                     | CastKind::Pointer(_) => {}\n-                    _ => {\n-                        let op_ty = operand.ty(self.body, self.tcx);\n-                        if op_ty.is_enum() {\n+                    CastKind::IntToInt | CastKind::IntToFloat => {\n+                        let input_valid = op_ty.is_integral() || op_ty.is_char() || op_ty.is_bool();\n+                        let target_valid = target_type.is_numeric() || target_type.is_char();\n+                        if !input_valid || !target_valid {\n+                            self.fail(\n+                                location,\n+                                format!(\"Wrong cast kind {kind:?} for the type {op_ty}\",),\n+                            );\n+                        }\n+                    }\n+                    CastKind::FnPtrToPtr | CastKind::PtrToPtr => {\n+                        if !(op_ty.is_any_ptr() && target_type.is_unsafe_ptr()) {\n+                            self.fail(location, \"Can't cast {op_ty} into 'Ptr'\");\n+                        }\n+                    }\n+                    CastKind::FloatToFloat | CastKind::FloatToInt => {\n+                        if !op_ty.is_floating_point() || !target_type.is_numeric() {\n                             self.fail(\n                                 location,\n                                 format!(\n-                                    \"enum -> int casts should go through `Rvalue::Discriminant`: {operand:?}:{op_ty} as {target_type}\",\n+                                    \"Trying to cast non 'Float' as {kind:?} into {target_type:?}\"\n                                 ),\n                             );\n                         }"}, {"sha": "406f0270dcc1b50587a35354ad677152f7287f47", "filename": "compiler/rustc_data_structures/src/sso/set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsso%2Fset.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -27,7 +27,7 @@ pub struct SsoHashSet<T> {\n     map: SsoHashMap<T, ()>,\n }\n \n-/// Adapter function used ot return\n+/// Adapter function used to return\n /// result if SsoHashMap functions into\n /// result SsoHashSet should return.\n #[inline(always)]"}, {"sha": "c1bc10891144cf6ce07b5c1eea757d01d787288e", "filename": "compiler/rustc_driver/src/session_diagnostics.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_driver%2Fsrc%2Fsession_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_driver%2Fsrc%2Fsession_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Fsession_diagnostics.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -1,39 +1,39 @@\n use rustc_macros::Diagnostic;\n \n #[derive(Diagnostic)]\n-#[diag(driver::rlink_unable_to_read)]\n+#[diag(driver_rlink_unable_to_read)]\n pub(crate) struct RlinkUnableToRead {\n     pub err: std::io::Error,\n }\n \n #[derive(Diagnostic)]\n-#[diag(driver::rlink_wrong_file_type)]\n+#[diag(driver_rlink_wrong_file_type)]\n pub(crate) struct RLinkWrongFileType;\n \n #[derive(Diagnostic)]\n-#[diag(driver::rlink_empty_version_number)]\n+#[diag(driver_rlink_empty_version_number)]\n pub(crate) struct RLinkEmptyVersionNumber;\n \n #[derive(Diagnostic)]\n-#[diag(driver::rlink_encoding_version_mismatch)]\n+#[diag(driver_rlink_encoding_version_mismatch)]\n pub(crate) struct RLinkEncodingVersionMismatch {\n     pub version_array: String,\n     pub rlink_version: u32,\n }\n \n #[derive(Diagnostic)]\n-#[diag(driver::rlink_rustc_version_mismatch)]\n+#[diag(driver_rlink_rustc_version_mismatch)]\n pub(crate) struct RLinkRustcVersionMismatch<'a> {\n     pub rustc_version: String,\n     pub current_version: &'a str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(driver::rlink_no_a_file)]\n+#[diag(driver_rlink_no_a_file)]\n pub(crate) struct RlinkNotAFile;\n \n #[derive(Diagnostic)]\n-#[diag(driver::unpretty_dump_fail)]\n+#[diag(driver_unpretty_dump_fail)]\n pub(crate) struct UnprettyDumpFail {\n     pub path: String,\n     pub err: String,"}, {"sha": "41263e5e3f5ac8381b9dba21e49d1efbfb2a857a", "filename": "compiler/rustc_error_codes/src/error_codes/E0210.md", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0210.md", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0210.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0210.md?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -76,7 +76,5 @@ Let `Ti` be the first such type.\n For information on the design of the orphan rules,\n see [RFC 2451] and [RFC 1023].\n \n-For information on the design of the orphan rules, see [RFC 1023].\n-\n [RFC 2451]: https://rust-lang.github.io/rfcs/2451-re-rebalancing-coherence.html\n [RFC 1023]: https://github.com/rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md"}, {"sha": "966a421bcf08c38fb06637a3837cfc78faa211eb", "filename": "compiler/rustc_error_messages/locales/en-US/codegen_ssa.ftl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_ssa.ftl?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -34,6 +34,8 @@ codegen_ssa_rlib_only_rmeta_found = could not find rlib for: `{$crate_name}`, fo\n \n codegen_ssa_rlib_not_found = could not find rlib for: `{$crate_name}`\n \n+codegen_ssa_rlib_incompatible_dependency_formats = `{$ty1}` and `{$ty2}` do not have equivalent dependency formats (`{$list1}` vs `{$list2}`)\n+\n codegen_ssa_linking_failed = linking with `{$linker_path}` failed: {$exit_status}\n \n codegen_ssa_extern_funcs_not_found = some `extern` functions couldn't be found; some native libraries may need to be installed or have their path specified"}, {"sha": "18b3408b06ab435a75ccead96437e58f08c62378", "filename": "compiler/rustc_error_messages/locales/en-US/infer.ftl", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Finfer.ftl?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -164,7 +164,9 @@ infer_region_explanation = {$pref_kind ->\n }\n \n infer_mismatched_static_lifetime = incompatible lifetime on type\n-infer_msl_impl_note = ...does not necessarily outlive the static lifetime introduced by the compatible `impl`\n+infer_does_not_outlive_static_from_impl = ...does not necessarily outlive the static lifetime introduced by the compatible `impl`\n+infer_implicit_static_lifetime_note = this has an implicit `'static` lifetime requirement\n+infer_implicit_static_lifetime_suggestion = consider relaxing the implicit `'static` requirement\n infer_msl_introduces_static = introduces a `'static` lifetime requirement\n infer_msl_unmet_req = because this has an unmet lifetime requirement\n infer_msl_trait_note = this has an implicit `'static` lifetime requirement"}, {"sha": "e2277923072f9b3eca8c5e1dc6c0a94a0fb5ac23", "filename": "compiler/rustc_error_messages/locales/en-US/session.ftl", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsession.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsession.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fsession.ftl?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -54,3 +54,7 @@ session_crate_name_empty = crate name must not be empty\n session_invalid_character_in_create_name = invalid character `{$character}` in crate name: `{$crate_name}`\n \n session_expr_parentheses_needed = parentheses are required to parse this as an expression\n+\n+session_skipping_const_checks = skipping const checks\n+session_unleashed_feature_help_named = skipping check for `{$gate}` feature\n+session_unleashed_feature_help_unnamed = skipping check that does not even have a feature gate"}, {"sha": "a63fc0ca285da41c3a4bcd20cac3e8ae514936d7", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -567,6 +567,11 @@ impl Diagnostic {\n         style: SuggestionStyle,\n     ) -> &mut Self {\n         assert!(!suggestion.is_empty());\n+        debug_assert!(\n+            !(suggestion.iter().any(|(sp, text)| sp.is_empty() && text.is_empty())),\n+            \"Span must not be empty and have no suggestion\"\n+        );\n+\n         self.push_suggestion(CodeSuggestion {\n             substitutions: vec![Substitution {\n                 parts: suggestion\n@@ -644,6 +649,10 @@ impl Diagnostic {\n         applicability: Applicability,\n         style: SuggestionStyle,\n     ) -> &mut Self {\n+        debug_assert!(\n+            !(sp.is_empty() && suggestion.to_string().is_empty()),\n+            \"Span must not be empty and have no suggestion\"\n+        );\n         self.push_suggestion(CodeSuggestion {\n             substitutions: vec![Substitution {\n                 parts: vec![SubstitutionPart { snippet: suggestion.to_string(), span: sp }],\n@@ -684,6 +693,12 @@ impl Diagnostic {\n     ) -> &mut Self {\n         let mut suggestions: Vec<_> = suggestions.collect();\n         suggestions.sort();\n+\n+        debug_assert!(\n+            !(sp.is_empty() && suggestions.iter().any(|suggestion| suggestion.is_empty())),\n+            \"Span must not be empty and have no suggestion\"\n+        );\n+\n         let substitutions = suggestions\n             .into_iter()\n             .map(|snippet| Substitution { parts: vec![SubstitutionPart { snippet, span: sp }] })\n@@ -705,8 +720,18 @@ impl Diagnostic {\n         suggestions: impl Iterator<Item = Vec<(Span, String)>>,\n         applicability: Applicability,\n     ) -> &mut Self {\n+        let suggestions: Vec<_> = suggestions.collect();\n+        debug_assert!(\n+            !(suggestions\n+                .iter()\n+                .flat_map(|suggs| suggs)\n+                .any(|(sp, suggestion)| sp.is_empty() && suggestion.is_empty())),\n+            \"Span must not be empty and have no suggestion\"\n+        );\n+\n         self.push_suggestion(CodeSuggestion {\n             substitutions: suggestions\n+                .into_iter()\n                 .map(|sugg| Substitution {\n                     parts: sugg\n                         .into_iter()"}, {"sha": "7640b2919f78b6fc30339a666c8a27927b668ebe", "filename": "compiler/rustc_errors/src/diagnostic_impls.rs", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -1,14 +1,14 @@\n use crate::{\n     fluent, DiagnosticArgValue, DiagnosticBuilder, Handler, IntoDiagnostic, IntoDiagnosticArg,\n };\n-use rustc_target::abi::TargetDataLayoutErrors;\n-use rustc_target::spec::{PanicStrategy, SplitDebuginfo, StackProtector, TargetTriple};\n-\n use rustc_ast as ast;\n use rustc_ast_pretty::pprust;\n use rustc_hir as hir;\n+use rustc_lint_defs::Level;\n use rustc_span::edition::Edition;\n use rustc_span::symbol::{Ident, MacroRulesNormalizedIdent, Symbol};\n+use rustc_target::abi::TargetDataLayoutErrors;\n+use rustc_target::spec::{PanicStrategy, SplitDebuginfo, StackProtector, TargetTriple};\n use std::borrow::Cow;\n use std::fmt;\n use std::num::ParseIntError;\n@@ -155,50 +155,65 @@ impl IntoDiagnosticArg for ast::token::TokenKind {\n     }\n }\n \n+impl IntoDiagnosticArg for Level {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Borrowed(match self {\n+            Level::Allow => \"-A\",\n+            Level::Warn => \"-W\",\n+            Level::ForceWarn(_) => \"--force-warn\",\n+            Level::Deny => \"-D\",\n+            Level::Forbid => \"-F\",\n+            Level::Expect(_) => {\n+                unreachable!(\"lints with the level of `expect` should not run this code\");\n+            }\n+        }))\n+    }\n+}\n+\n impl IntoDiagnostic<'_, !> for TargetDataLayoutErrors<'_> {\n     fn into_diagnostic(self, handler: &Handler) -> DiagnosticBuilder<'_, !> {\n         let mut diag;\n         match self {\n             TargetDataLayoutErrors::InvalidAddressSpace { addr_space, err, cause } => {\n-                diag = handler.struct_fatal(fluent::errors::target_invalid_address_space);\n+                diag = handler.struct_fatal(fluent::errors_target_invalid_address_space);\n                 diag.set_arg(\"addr_space\", addr_space);\n                 diag.set_arg(\"cause\", cause);\n                 diag.set_arg(\"err\", err);\n                 diag\n             }\n             TargetDataLayoutErrors::InvalidBits { kind, bit, cause, err } => {\n-                diag = handler.struct_fatal(fluent::errors::target_invalid_bits);\n+                diag = handler.struct_fatal(fluent::errors_target_invalid_bits);\n                 diag.set_arg(\"kind\", kind);\n                 diag.set_arg(\"bit\", bit);\n                 diag.set_arg(\"cause\", cause);\n                 diag.set_arg(\"err\", err);\n                 diag\n             }\n             TargetDataLayoutErrors::MissingAlignment { cause } => {\n-                diag = handler.struct_fatal(fluent::errors::target_missing_alignment);\n+                diag = handler.struct_fatal(fluent::errors_target_missing_alignment);\n                 diag.set_arg(\"cause\", cause);\n                 diag\n             }\n             TargetDataLayoutErrors::InvalidAlignment { cause, err } => {\n-                diag = handler.struct_fatal(fluent::errors::target_invalid_alignment);\n+                diag = handler.struct_fatal(fluent::errors_target_invalid_alignment);\n                 diag.set_arg(\"cause\", cause);\n                 diag.set_arg(\"err\", err);\n                 diag\n             }\n             TargetDataLayoutErrors::InconsistentTargetArchitecture { dl, target } => {\n-                diag = handler.struct_fatal(fluent::errors::target_inconsistent_architecture);\n+                diag = handler.struct_fatal(fluent::errors_target_inconsistent_architecture);\n                 diag.set_arg(\"dl\", dl);\n                 diag.set_arg(\"target\", target);\n                 diag\n             }\n             TargetDataLayoutErrors::InconsistentTargetPointerWidth { pointer_size, target } => {\n-                diag = handler.struct_fatal(fluent::errors::target_inconsistent_pointer_width);\n+                diag = handler.struct_fatal(fluent::errors_target_inconsistent_pointer_width);\n                 diag.set_arg(\"pointer_size\", pointer_size);\n                 diag.set_arg(\"target\", target);\n                 diag\n             }\n             TargetDataLayoutErrors::InvalidBitsSize { err } => {\n-                diag = handler.struct_fatal(fluent::errors::target_invalid_bits_size);\n+                diag = handler.struct_fatal(fluent::errors_target_invalid_bits_size);\n                 diag.set_arg(\"err\", err);\n                 diag\n             }"}, {"sha": "0963ea71f80236ac51c1e7bc70781f069ea8a2ec", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -463,6 +463,9 @@ pub enum StashKey {\n     UnderscoreForArrayLengths,\n     EarlySyntaxWarning,\n     CallIntoMethod,\n+    /// When an invalid lifetime e.g. `'2` should be reinterpreted\n+    /// as a char literal in the parser\n+    LifetimeIsChar,\n }\n \n fn default_track_diagnostic(_: &Diagnostic) {}"}, {"sha": "c8de60ccb89b9830a5000f8ae0f7f970fac5fa1a", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 37, "deletions": 12, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -22,7 +22,7 @@ use rustc_span::edition::Edition;\n use rustc_span::hygiene::{AstPass, ExpnData, ExpnKind, LocalExpnId};\n use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_span::{FileName, Span, DUMMY_SP};\n+use rustc_span::{BytePos, FileName, RealFileName, Span, DUMMY_SP};\n use smallvec::{smallvec, SmallVec};\n \n use std::default::Default;\n@@ -1228,8 +1228,9 @@ pub fn expr_to_spanned_string<'a>(\n             ast::LitKind::Str(s, style) => return Ok((s, style, expr.span)),\n             ast::LitKind::ByteStr(_) => {\n                 let mut err = cx.struct_span_err(l.span, err_msg);\n+                let span = expr.span.shrink_to_lo();\n                 err.span_suggestion(\n-                    expr.span.shrink_to_lo(),\n+                    span.with_hi(span.lo() + BytePos(1)),\n                     \"consider removing the leading `b`\",\n                     \"\",\n                     Applicability::MaybeIncorrect,\n@@ -1422,16 +1423,40 @@ fn pretty_printing_compatibility_hack(item: &Item, sess: &ParseSess) -> bool {\n         if let ast::ItemKind::Enum(enum_def, _) = &item.kind {\n             if let [variant] = &*enum_def.variants {\n                 if variant.ident.name == sym::Input {\n-                    sess.buffer_lint_with_diagnostic(\n-                        &PROC_MACRO_BACK_COMPAT,\n-                        item.ident.span,\n-                        ast::CRATE_NODE_ID,\n-                        \"using `procedural-masquerade` crate\",\n-                        BuiltinLintDiagnostics::ProcMacroBackCompat(\n-                        \"The `procedural-masquerade` crate has been unnecessary since Rust 1.30.0. \\\n-                        Versions of this crate below 0.1.7 will eventually stop compiling.\".to_string())\n-                    );\n-                    return true;\n+                    let filename = sess.source_map().span_to_filename(item.ident.span);\n+                    if let FileName::Real(RealFileName::LocalPath(path)) = filename {\n+                        if let Some(c) = path\n+                            .components()\n+                            .flat_map(|c| c.as_os_str().to_str())\n+                            .find(|c| c.starts_with(\"rental\") || c.starts_with(\"allsorts-rental\"))\n+                        {\n+                            let crate_matches = if c.starts_with(\"allsorts-rental\") {\n+                                true\n+                            } else {\n+                                let mut version = c.trim_start_matches(\"rental-\").split(\".\");\n+                                version.next() == Some(\"0\")\n+                                    && version.next() == Some(\"5\")\n+                                    && version\n+                                        .next()\n+                                        .and_then(|c| c.parse::<u32>().ok())\n+                                        .map_or(false, |v| v < 6)\n+                            };\n+\n+                            if crate_matches {\n+                                sess.buffer_lint_with_diagnostic(\n+                                        &PROC_MACRO_BACK_COMPAT,\n+                                        item.ident.span,\n+                                        ast::CRATE_NODE_ID,\n+                                        \"using an old version of `rental`\",\n+                                        BuiltinLintDiagnostics::ProcMacroBackCompat(\n+                                        \"older versions of the `rental` crate will stop compiling in future versions of Rust; \\\n+                                        please update to `rental` v0.5.6, or switch to one of the `rental` alternatives\".to_string()\n+                                        )\n+                                    );\n+                                return true;\n+                            }\n+                        }\n+                    }\n                 }\n             }\n         }"}, {"sha": "d383f4832f6999469ed43a96dbddd7d7a532b3a7", "filename": "compiler/rustc_expand/src/errors.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_expand%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_expand%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Ferrors.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -3,44 +3,44 @@ use rustc_span::symbol::MacroRulesNormalizedIdent;\n use rustc_span::Span;\n \n #[derive(Diagnostic)]\n-#[diag(expand::expr_repeat_no_syntax_vars)]\n+#[diag(expand_expr_repeat_no_syntax_vars)]\n pub(crate) struct NoSyntaxVarsExprRepeat {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(expand::must_repeat_once)]\n+#[diag(expand_must_repeat_once)]\n pub(crate) struct MustRepeatOnce {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(expand::count_repetition_misplaced)]\n+#[diag(expand_count_repetition_misplaced)]\n pub(crate) struct CountRepetitionMisplaced {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(expand::meta_var_expr_unrecognized_var)]\n+#[diag(expand_meta_var_expr_unrecognized_var)]\n pub(crate) struct MetaVarExprUnrecognizedVar {\n     #[primary_span]\n     pub span: Span,\n     pub key: MacroRulesNormalizedIdent,\n }\n \n #[derive(Diagnostic)]\n-#[diag(expand::var_still_repeating)]\n+#[diag(expand_var_still_repeating)]\n pub(crate) struct VarStillRepeating {\n     #[primary_span]\n     pub span: Span,\n     pub ident: MacroRulesNormalizedIdent,\n }\n \n #[derive(Diagnostic)]\n-#[diag(expand::meta_var_dif_seq_matchers)]\n+#[diag(expand_meta_var_dif_seq_matchers)]\n pub(crate) struct MetaVarsDifSeqMatchers {\n     #[primary_span]\n     pub span: Span,"}, {"sha": "1e268542bcd91ea5b308631a327953698c92ead6", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -598,12 +598,12 @@ pub fn compile_declarative_macro(\n \n #[derive(Subdiagnostic)]\n enum ExplainDocComment {\n-    #[label(expand::explain_doc_comment_inner)]\n+    #[label(expand_explain_doc_comment_inner)]\n     Inner {\n         #[primary_span]\n         span: Span,\n     },\n-    #[label(expand::explain_doc_comment_outer)]\n+    #[label(expand_explain_doc_comment_outer)]\n     Outer {\n         #[primary_span]\n         span: Span,"}, {"sha": "2ead3c2c8d4850127217a9dc585e43c9be9a6717", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -296,20 +296,24 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n \n     // Lints:\n     ungated!(\n-        warn, Normal, template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#), DuplicatesOk\n+        warn, Normal, template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#),\n+        DuplicatesOk, @only_local: true,\n     ),\n     ungated!(\n-        allow, Normal, template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#), DuplicatesOk\n+        allow, Normal, template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#),\n+        DuplicatesOk, @only_local: true,\n     ),\n     gated!(\n         expect, Normal, template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#), DuplicatesOk,\n         lint_reasons, experimental!(expect)\n     ),\n     ungated!(\n-        forbid, Normal, template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#), DuplicatesOk\n+        forbid, Normal, template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#),\n+        DuplicatesOk, @only_local: true,\n     ),\n     ungated!(\n-        deny, Normal, template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#), DuplicatesOk\n+        deny, Normal, template!(List: r#\"lint1, lint2, ..., /*opt*/ reason = \"...\"\"#),\n+        DuplicatesOk, @only_local: true,\n     ),\n     ungated!(must_use, Normal, template!(Word, NameValueStr: \"reason\"), FutureWarnFollowing),\n     gated!(\n@@ -340,7 +344,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     ),\n     ungated!(link_name, Normal, template!(NameValueStr: \"name\"), FutureWarnPreceding),\n     ungated!(no_link, Normal, template!(Word), WarnFollowing),\n-    ungated!(repr, Normal, template!(List: \"C\"), DuplicatesOk),\n+    ungated!(repr, Normal, template!(List: \"C\"), DuplicatesOk, @only_local: true),\n     ungated!(export_name, Normal, template!(NameValueStr: \"name\"), FutureWarnPreceding),\n     ungated!(link_section, Normal, template!(NameValueStr: \"name\"), FutureWarnPreceding),\n     ungated!(no_mangle, Normal, template!(Word), WarnFollowing, @only_local: true),\n@@ -382,7 +386,10 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     ungated!(inline, Normal, template!(Word, List: \"always|never\"), FutureWarnFollowing, @only_local: true),\n     ungated!(cold, Normal, template!(Word), WarnFollowing, @only_local: true),\n     ungated!(no_builtins, CrateLevel, template!(Word), WarnFollowing),\n-    ungated!(target_feature, Normal, template!(List: r#\"enable = \"name\"\"#), DuplicatesOk),\n+    ungated!(\n+        target_feature, Normal, template!(List: r#\"enable = \"name\"\"#),\n+        DuplicatesOk, @only_local: true,\n+    ),\n     ungated!(track_caller, Normal, template!(Word), WarnFollowing),\n     gated!(\n         no_sanitize, Normal,\n@@ -488,18 +495,24 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // Internal attributes: Stability, deprecation, and unsafe:\n     // ==========================================================================\n \n-    ungated!(feature, CrateLevel, template!(List: \"name1, name2, ...\"), DuplicatesOk),\n+    ungated!(\n+        feature, CrateLevel,\n+        template!(List: \"name1, name2, ...\"), DuplicatesOk, @only_local: true,\n+    ),\n     // DuplicatesOk since it has its own validation\n     ungated!(\n-        stable, Normal, template!(List: r#\"feature = \"name\", since = \"version\"\"#), DuplicatesOk,\n+        stable, Normal,\n+        template!(List: r#\"feature = \"name\", since = \"version\"\"#), DuplicatesOk, @only_local: true,\n     ),\n     ungated!(\n         unstable, Normal,\n         template!(List: r#\"feature = \"name\", reason = \"...\", issue = \"N\"\"#), DuplicatesOk,\n     ),\n     ungated!(rustc_const_unstable, Normal, template!(List: r#\"feature = \"name\"\"#), DuplicatesOk),\n-    ungated!(rustc_const_stable, Normal, template!(List: r#\"feature = \"name\"\"#), DuplicatesOk),\n-    ungated!(rustc_safe_intrinsic, Normal, template!(Word), DuplicatesOk),\n+    ungated!(\n+        rustc_const_stable, Normal,\n+        template!(List: r#\"feature = \"name\"\"#), DuplicatesOk, @only_local: true,\n+    ),\n     ungated!(\n         rustc_default_body_unstable, Normal,\n         template!(List: r#\"feature = \"name\", reason = \"...\", issue = \"N\"\"#), DuplicatesOk\n@@ -517,6 +530,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n         allow_internal_unsafe, Normal, template!(Word), WarnFollowing,\n         \"allow_internal_unsafe side-steps the unsafe_code lint\",\n     ),\n+    ungated!(rustc_safe_intrinsic, Normal, template!(Word), DuplicatesOk),\n     rustc_attr!(rustc_allowed_through_unstable_modules, Normal, template!(Word), WarnFollowing,\n     \"rustc_allowed_through_unstable_modules special cases accidental stabilizations of stable items \\\n     through unstable paths\"),\n@@ -732,7 +746,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n          for reserving for `for<T> From<!> for T` impl\"\n     ),\n     rustc_attr!(\n-        rustc_test_marker, Normal, template!(Word), WarnFollowing,\n+        rustc_test_marker, Normal, template!(NameValueStr: \"name\"), WarnFollowing,\n         \"the `#[rustc_test_marker]` attribute is used internally to track tests\",\n     ),\n     rustc_attr!(\n@@ -823,6 +837,8 @@ pub fn is_builtin_attr_name(name: Symbol) -> bool {\n     BUILTIN_ATTRIBUTE_MAP.get(&name).is_some()\n }\n \n+/// Whether this builtin attribute is only used in the local crate.\n+/// If so, it is not encoded in the crate metadata.\n pub fn is_builtin_only_local(name: Symbol) -> bool {\n     BUILTIN_ATTRIBUTE_MAP.get(&name).map_or(false, |attr| attr.only_local)\n }"}, {"sha": "a0350c26d827cda840016a7f94c8e05f4bf8fb67", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -582,7 +582,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         assoc_bindings\n     }\n \n-    pub(crate) fn create_substs_for_associated_item(\n+    pub fn create_substs_for_associated_item(\n         &self,\n         span: Span,\n         item_def_id: DefId,\n@@ -3051,24 +3051,27 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     .map_or(false, |s| s.trim_end().ends_with('<'));\n \n             let is_global = poly_trait_ref.trait_ref.path.is_global();\n-            let sugg = Vec::from_iter([\n-                (\n-                    self_ty.span.shrink_to_lo(),\n-                    format!(\n-                        \"{}dyn {}\",\n-                        if needs_bracket { \"<\" } else { \"\" },\n-                        if is_global { \"(\" } else { \"\" },\n-                    ),\n+\n+            let mut sugg = Vec::from_iter([(\n+                self_ty.span.shrink_to_lo(),\n+                format!(\n+                    \"{}dyn {}\",\n+                    if needs_bracket { \"<\" } else { \"\" },\n+                    if is_global { \"(\" } else { \"\" },\n                 ),\n-                (\n+            )]);\n+\n+            if is_global || needs_bracket {\n+                sugg.push((\n                     self_ty.span.shrink_to_hi(),\n                     format!(\n                         \"{}{}\",\n                         if is_global { \")\" } else { \"\" },\n                         if needs_bracket { \">\" } else { \"\" },\n                     ),\n-                ),\n-            ]);\n+                ));\n+            }\n+\n             if self_ty.span.edition() >= Edition::Edition2021 {\n                 let msg = \"trait objects must include the `dyn` keyword\";\n                 let label = \"add `dyn` keyword before this trait\";"}, {"sha": "a1faf802519573c9a782c1cb532bac049ecc1e9a", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 1, "deletions": 311, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -1,6 +1,5 @@\n use crate::check::intrinsicck::InlineAsmCtxt;\n \n-use super::coercion::CoerceMany;\n use super::compare_method::check_type_bounds;\n use super::compare_method::{compare_impl_method, compare_ty_impl};\n use super::*;\n@@ -10,10 +9,8 @@ use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::Visitor;\n-use rustc_hir::lang_items::LangItem;\n use rustc_hir::{ItemKind, Node, PathSegment};\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n-use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{DefiningAnchor, RegionVariableOrigin, TyCtxtInferExt};\n use rustc_infer::traits::Obligation;\n use rustc_lint::builtin::REPR_TRANSPARENT_EXTERNAL_PRIVATE_FIELDS;\n@@ -34,7 +31,7 @@ use rustc_trait_selection::traits::{self, ObligationCtxt};\n \n use std::ops::ControlFlow;\n \n-pub(super) fn check_abi(tcx: TyCtxt<'_>, hir_id: hir::HirId, span: Span, abi: Abi) {\n+pub fn check_abi(tcx: TyCtxt<'_>, hir_id: hir::HirId, span: Span, abi: Abi) {\n     match tcx.sess.target.is_abi_supported(abi) {\n         Some(true) => (),\n         Some(false) => {\n@@ -69,313 +66,6 @@ pub(super) fn check_abi(tcx: TyCtxt<'_>, hir_id: hir::HirId, span: Span, abi: Ab\n     }\n }\n \n-/// Helper used for fns and closures. Does the grungy work of checking a function\n-/// body and returns the function context used for that purpose, since in the case of a fn item\n-/// there is still a bit more to do.\n-///\n-/// * ...\n-/// * inherited: other fields inherited from the enclosing fn (if any)\n-#[instrument(skip(inherited, body), level = \"debug\")]\n-pub(super) fn check_fn<'a, 'tcx>(\n-    inherited: &'a Inherited<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    fn_sig: ty::FnSig<'tcx>,\n-    decl: &'tcx hir::FnDecl<'tcx>,\n-    fn_id: hir::HirId,\n-    body: &'tcx hir::Body<'tcx>,\n-    can_be_generator: Option<hir::Movability>,\n-    return_type_pre_known: bool,\n-) -> (FnCtxt<'a, 'tcx>, Option<GeneratorTypes<'tcx>>) {\n-    // Create the function context. This is either derived from scratch or,\n-    // in the case of closures, based on the outer context.\n-    let mut fcx = FnCtxt::new(inherited, param_env, body.value.hir_id);\n-    fcx.ps.set(UnsafetyState::function(fn_sig.unsafety, fn_id));\n-    fcx.return_type_pre_known = return_type_pre_known;\n-\n-    let tcx = fcx.tcx;\n-    let hir = tcx.hir();\n-\n-    let declared_ret_ty = fn_sig.output();\n-\n-    let ret_ty =\n-        fcx.register_infer_ok_obligations(fcx.infcx.replace_opaque_types_with_inference_vars(\n-            declared_ret_ty,\n-            body.value.hir_id,\n-            decl.output.span(),\n-            param_env,\n-        ));\n-    // If we replaced declared_ret_ty with infer vars, then we must be inferring\n-    // an opaque type, so set a flag so we can improve diagnostics.\n-    fcx.return_type_has_opaque = ret_ty != declared_ret_ty;\n-\n-    fcx.ret_coercion = Some(RefCell::new(CoerceMany::new(ret_ty)));\n-\n-    let span = body.value.span;\n-\n-    fn_maybe_err(tcx, span, fn_sig.abi);\n-\n-    if fn_sig.abi == Abi::RustCall {\n-        let expected_args = if let ImplicitSelfKind::None = decl.implicit_self { 1 } else { 2 };\n-\n-        let err = || {\n-            let item = match tcx.hir().get(fn_id) {\n-                Node::Item(hir::Item { kind: ItemKind::Fn(header, ..), .. }) => Some(header),\n-                Node::ImplItem(hir::ImplItem {\n-                    kind: hir::ImplItemKind::Fn(header, ..), ..\n-                }) => Some(header),\n-                Node::TraitItem(hir::TraitItem {\n-                    kind: hir::TraitItemKind::Fn(header, ..),\n-                    ..\n-                }) => Some(header),\n-                // Closures are RustCall, but they tuple their arguments, so shouldn't be checked\n-                Node::Expr(hir::Expr { kind: hir::ExprKind::Closure { .. }, .. }) => None,\n-                node => bug!(\"Item being checked wasn't a function/closure: {:?}\", node),\n-            };\n-\n-            if let Some(header) = item {\n-                tcx.sess.span_err(header.span, \"functions with the \\\"rust-call\\\" ABI must take a single non-self argument that is a tuple\");\n-            }\n-        };\n-\n-        if fn_sig.inputs().len() != expected_args {\n-            err()\n-        } else {\n-            // FIXME(CraftSpider) Add a check on parameter expansion, so we don't just make the ICE happen later on\n-            //   This will probably require wide-scale changes to support a TupleKind obligation\n-            //   We can't resolve this without knowing the type of the param\n-            if !matches!(fn_sig.inputs()[expected_args - 1].kind(), ty::Tuple(_) | ty::Param(_)) {\n-                err()\n-            }\n-        }\n-    }\n-\n-    if body.generator_kind.is_some() && can_be_generator.is_some() {\n-        let yield_ty = fcx\n-            .next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::TypeInference, span });\n-        fcx.require_type_is_sized(yield_ty, span, traits::SizedYieldType);\n-\n-        // Resume type defaults to `()` if the generator has no argument.\n-        let resume_ty = fn_sig.inputs().get(0).copied().unwrap_or_else(|| tcx.mk_unit());\n-\n-        fcx.resume_yield_tys = Some((resume_ty, yield_ty));\n-    }\n-\n-    GatherLocalsVisitor::new(&fcx).visit_body(body);\n-\n-    // C-variadic fns also have a `VaList` input that's not listed in `fn_sig`\n-    // (as it's created inside the body itself, not passed in from outside).\n-    let maybe_va_list = if fn_sig.c_variadic {\n-        let span = body.params.last().unwrap().span;\n-        let va_list_did = tcx.require_lang_item(LangItem::VaList, Some(span));\n-        let region = fcx.next_region_var(RegionVariableOrigin::MiscVariable(span));\n-\n-        Some(tcx.bound_type_of(va_list_did).subst(tcx, &[region.into()]))\n-    } else {\n-        None\n-    };\n-\n-    // Add formal parameters.\n-    let inputs_hir = hir.fn_decl_by_hir_id(fn_id).map(|decl| &decl.inputs);\n-    let inputs_fn = fn_sig.inputs().iter().copied();\n-    for (idx, (param_ty, param)) in inputs_fn.chain(maybe_va_list).zip(body.params).enumerate() {\n-        // Check the pattern.\n-        let ty_span = try { inputs_hir?.get(idx)?.span };\n-        fcx.check_pat_top(&param.pat, param_ty, ty_span, false);\n-\n-        // Check that argument is Sized.\n-        // The check for a non-trivial pattern is a hack to avoid duplicate warnings\n-        // for simple cases like `fn foo(x: Trait)`,\n-        // where we would error once on the parameter as a whole, and once on the binding `x`.\n-        if param.pat.simple_ident().is_none() && !tcx.features().unsized_fn_params {\n-            fcx.require_type_is_sized(param_ty, param.pat.span, traits::SizedArgumentType(ty_span));\n-        }\n-\n-        fcx.write_ty(param.hir_id, param_ty);\n-    }\n-\n-    inherited.typeck_results.borrow_mut().liberated_fn_sigs_mut().insert(fn_id, fn_sig);\n-\n-    fcx.in_tail_expr = true;\n-    if let ty::Dynamic(..) = declared_ret_ty.kind() {\n-        // FIXME: We need to verify that the return type is `Sized` after the return expression has\n-        // been evaluated so that we have types available for all the nodes being returned, but that\n-        // requires the coerced evaluated type to be stored. Moving `check_return_expr` before this\n-        // causes unsized errors caused by the `declared_ret_ty` to point at the return expression,\n-        // while keeping the current ordering we will ignore the tail expression's type because we\n-        // don't know it yet. We can't do `check_expr_kind` while keeping `check_return_expr`\n-        // because we will trigger \"unreachable expression\" lints unconditionally.\n-        // Because of all of this, we perform a crude check to know whether the simplest `!Sized`\n-        // case that a newcomer might make, returning a bare trait, and in that case we populate\n-        // the tail expression's type so that the suggestion will be correct, but ignore all other\n-        // possible cases.\n-        fcx.check_expr(&body.value);\n-        fcx.require_type_is_sized(declared_ret_ty, decl.output.span(), traits::SizedReturnType);\n-    } else {\n-        fcx.require_type_is_sized(declared_ret_ty, decl.output.span(), traits::SizedReturnType);\n-        fcx.check_return_expr(&body.value, false);\n-    }\n-    fcx.in_tail_expr = false;\n-\n-    // We insert the deferred_generator_interiors entry after visiting the body.\n-    // This ensures that all nested generators appear before the entry of this generator.\n-    // resolve_generator_interiors relies on this property.\n-    let gen_ty = if let (Some(_), Some(gen_kind)) = (can_be_generator, body.generator_kind) {\n-        let interior = fcx\n-            .next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::MiscVariable, span });\n-        fcx.deferred_generator_interiors.borrow_mut().push((body.id(), interior, gen_kind));\n-\n-        let (resume_ty, yield_ty) = fcx.resume_yield_tys.unwrap();\n-        Some(GeneratorTypes {\n-            resume_ty,\n-            yield_ty,\n-            interior,\n-            movability: can_be_generator.unwrap(),\n-        })\n-    } else {\n-        None\n-    };\n-\n-    // Finalize the return check by taking the LUB of the return types\n-    // we saw and assigning it to the expected return type. This isn't\n-    // really expected to fail, since the coercions would have failed\n-    // earlier when trying to find a LUB.\n-    let coercion = fcx.ret_coercion.take().unwrap().into_inner();\n-    let mut actual_return_ty = coercion.complete(&fcx);\n-    debug!(\"actual_return_ty = {:?}\", actual_return_ty);\n-    if let ty::Dynamic(..) = declared_ret_ty.kind() {\n-        // We have special-cased the case where the function is declared\n-        // `-> dyn Foo` and we don't actually relate it to the\n-        // `fcx.ret_coercion`, so just substitute a type variable.\n-        actual_return_ty =\n-            fcx.next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::DynReturnFn, span });\n-        debug!(\"actual_return_ty replaced with {:?}\", actual_return_ty);\n-    }\n-\n-    // HACK(oli-obk, compiler-errors): We should be comparing this against\n-    // `declared_ret_ty`, but then anything uninferred would be inferred to\n-    // the opaque type itself. That again would cause writeback to assume\n-    // we have a recursive call site and do the sadly stabilized fallback to `()`.\n-    fcx.demand_suptype(span, ret_ty, actual_return_ty);\n-\n-    // Check that a function marked as `#[panic_handler]` has signature `fn(&PanicInfo) -> !`\n-    if let Some(panic_impl_did) = tcx.lang_items().panic_impl()\n-        && panic_impl_did == hir.local_def_id(fn_id).to_def_id()\n-    {\n-        check_panic_info_fn(tcx, panic_impl_did.expect_local(), fn_sig, decl, declared_ret_ty);\n-    }\n-\n-    // Check that a function marked as `#[alloc_error_handler]` has signature `fn(Layout) -> !`\n-    if let Some(alloc_error_handler_did) = tcx.lang_items().oom()\n-        && alloc_error_handler_did == hir.local_def_id(fn_id).to_def_id()\n-    {\n-        check_alloc_error_fn(tcx, alloc_error_handler_did.expect_local(), fn_sig, decl, declared_ret_ty);\n-    }\n-\n-    (fcx, gen_ty)\n-}\n-\n-fn check_panic_info_fn(\n-    tcx: TyCtxt<'_>,\n-    fn_id: LocalDefId,\n-    fn_sig: ty::FnSig<'_>,\n-    decl: &hir::FnDecl<'_>,\n-    declared_ret_ty: Ty<'_>,\n-) {\n-    let Some(panic_info_did) = tcx.lang_items().panic_info() else {\n-        tcx.sess.err(\"language item required, but not found: `panic_info`\");\n-        return;\n-    };\n-\n-    if *declared_ret_ty.kind() != ty::Never {\n-        tcx.sess.span_err(decl.output.span(), \"return type should be `!`\");\n-    }\n-\n-    let inputs = fn_sig.inputs();\n-    if inputs.len() != 1 {\n-        tcx.sess.span_err(tcx.def_span(fn_id), \"function should have one argument\");\n-        return;\n-    }\n-\n-    let arg_is_panic_info = match *inputs[0].kind() {\n-        ty::Ref(region, ty, mutbl) => match *ty.kind() {\n-            ty::Adt(ref adt, _) => {\n-                adt.did() == panic_info_did && mutbl == hir::Mutability::Not && !region.is_static()\n-            }\n-            _ => false,\n-        },\n-        _ => false,\n-    };\n-\n-    if !arg_is_panic_info {\n-        tcx.sess.span_err(decl.inputs[0].span, \"argument should be `&PanicInfo`\");\n-    }\n-\n-    let DefKind::Fn = tcx.def_kind(fn_id) else {\n-        let span = tcx.def_span(fn_id);\n-        tcx.sess.span_err(span, \"should be a function\");\n-        return;\n-    };\n-\n-    let generic_counts = tcx.generics_of(fn_id).own_counts();\n-    if generic_counts.types != 0 {\n-        let span = tcx.def_span(fn_id);\n-        tcx.sess.span_err(span, \"should have no type parameters\");\n-    }\n-    if generic_counts.consts != 0 {\n-        let span = tcx.def_span(fn_id);\n-        tcx.sess.span_err(span, \"should have no const parameters\");\n-    }\n-}\n-\n-fn check_alloc_error_fn(\n-    tcx: TyCtxt<'_>,\n-    fn_id: LocalDefId,\n-    fn_sig: ty::FnSig<'_>,\n-    decl: &hir::FnDecl<'_>,\n-    declared_ret_ty: Ty<'_>,\n-) {\n-    let Some(alloc_layout_did) = tcx.lang_items().alloc_layout() else {\n-        tcx.sess.err(\"language item required, but not found: `alloc_layout`\");\n-        return;\n-    };\n-\n-    if *declared_ret_ty.kind() != ty::Never {\n-        tcx.sess.span_err(decl.output.span(), \"return type should be `!`\");\n-    }\n-\n-    let inputs = fn_sig.inputs();\n-    if inputs.len() != 1 {\n-        tcx.sess.span_err(tcx.def_span(fn_id), \"function should have one argument\");\n-        return;\n-    }\n-\n-    let arg_is_alloc_layout = match inputs[0].kind() {\n-        ty::Adt(ref adt, _) => adt.did() == alloc_layout_did,\n-        _ => false,\n-    };\n-\n-    if !arg_is_alloc_layout {\n-        tcx.sess.span_err(decl.inputs[0].span, \"argument should be `Layout`\");\n-    }\n-\n-    let DefKind::Fn = tcx.def_kind(fn_id) else {\n-        let span = tcx.def_span(fn_id);\n-        tcx.sess.span_err(span, \"`#[alloc_error_handler]` should be a function\");\n-        return;\n-    };\n-\n-    let generic_counts = tcx.generics_of(fn_id).own_counts();\n-    if generic_counts.types != 0 {\n-        let span = tcx.def_span(fn_id);\n-        tcx.sess.span_err(span, \"`#[alloc_error_handler]` function should have no type parameters\");\n-    }\n-    if generic_counts.consts != 0 {\n-        let span = tcx.def_span(fn_id);\n-        tcx.sess\n-            .span_err(span, \"`#[alloc_error_handler]` function should have no const parameters\");\n-    }\n-}\n-\n fn check_struct(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     let def = tcx.adt_def(def_id);\n     let span = tcx.def_span(def_id);"}, {"sha": "e72f18012ab338fce240ac21202e0439e279097a", "filename": "compiler/rustc_hir_analysis/src/check/compare_method.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -598,8 +598,16 @@ pub fn collect_trait_impl_trait_tys<'tcx>(\n                 let num_impl_substs = tcx.generics_of(impl_m.container_id(tcx)).params.len();\n                 let ty = tcx.fold_regions(ty, |region, _| {\n                     let ty::ReFree(_) = region.kind() else { return region; };\n-                    let ty::ReEarlyBound(e) = map[&region.into()].expect_region().kind()\n-                        else { bug!(\"expected ReFree to map to ReEarlyBound\"); };\n+                    let Some(ty::ReEarlyBound(e)) = map.get(&region.into()).map(|r| r.expect_region().kind())\n+                    else {\n+                        tcx\n+                            .sess\n+                            .delay_span_bug(\n+                                return_span,\n+                                \"expected ReFree to map to ReEarlyBound\"\n+                            );\n+                        return tcx.lifetimes.re_static;\n+                    };\n                     tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n                         def_id: e.def_id,\n                         name: e.name,\n@@ -664,10 +672,7 @@ impl<'tcx> TypeFolder<'tcx> for ImplTraitInTraitCollector<'_, 'tcx> {\n             });\n             self.types.insert(proj.item_def_id, (infer_ty, proj.substs));\n             // Recurse into bounds\n-            for pred in self.tcx().bound_explicit_item_bounds(proj.item_def_id).transpose_iter() {\n-                let pred_span = pred.0.1;\n-\n-                let pred = pred.map_bound(|(pred, _)| *pred).subst(self.tcx(), proj.substs);\n+            for (pred, pred_span) in self.tcx().bound_explicit_item_bounds(proj.item_def_id).subst_iter_copied(self.tcx(), proj.substs) {\n                 let pred = pred.fold_with(self);\n                 let pred = self.ocx.normalize(\n                     ObligationCause::misc(self.span, self.body_id),\n@@ -1752,15 +1757,10 @@ pub fn check_type_bounds<'tcx>(\n \n     let obligations = tcx\n         .bound_explicit_item_bounds(trait_ty.def_id)\n-        .transpose_iter()\n-        .map(|e| e.map_bound(|e| *e).transpose_tuple2())\n-        .map(|(bound, span)| {\n-            debug!(?bound);\n-            // this is where opaque type is found\n-            let concrete_ty_bound = bound.subst(tcx, rebased_substs);\n+        .subst_iter_copied(tcx, rebased_substs)\n+        .map(|(concrete_ty_bound, span)| {\n             debug!(\"check_type_bounds: concrete_ty_bound = {:?}\", concrete_ty_bound);\n-\n-            traits::Obligation::new(mk_cause(span.0), param_env, concrete_ty_bound)\n+            traits::Obligation::new(mk_cause(span), param_env, concrete_ty_bound)\n         })\n         .collect();\n     debug!(\"check_type_bounds: item_bounds={:?}\", obligations);"}, {"sha": "a74016e220e629527eec57ff61bb4b99be0ace93", "filename": "compiler/rustc_hir_analysis/src/check/dropck.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -184,21 +184,15 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n             let p = p.kind();\n             match (predicate.skip_binder(), p.skip_binder()) {\n                 (ty::PredicateKind::Trait(a), ty::PredicateKind::Trait(b)) => {\n-                    // Since struct predicates cannot have ~const, project the impl predicate\n-                    // onto one that ignores the constness. This is equivalent to saying that\n-                    // we match a `Trait` bound on the struct with a `Trait` or `~const Trait`\n-                    // in the impl.\n-                    let non_const_a =\n-                        ty::TraitPredicate { constness: ty::BoundConstness::NotConst, ..a };\n-                    relator.relate(predicate.rebind(non_const_a), p.rebind(b)).is_ok()\n+                    relator.relate(predicate.rebind(a), p.rebind(b)).is_ok()\n                 }\n                 (ty::PredicateKind::Projection(a), ty::PredicateKind::Projection(b)) => {\n                     relator.relate(predicate.rebind(a), p.rebind(b)).is_ok()\n                 }\n                 (\n                     ty::PredicateKind::ConstEvaluatable(a),\n                     ty::PredicateKind::ConstEvaluatable(b),\n-                ) => tcx.try_unify_abstract_consts(self_param_env.and((a, b))),\n+                ) => relator.relate(predicate.rebind(a), predicate.rebind(b)).is_ok(),\n                 (\n                     ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty_a, lt_a)),\n                     ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty_b, lt_b)),"}, {"sha": "a026f8033c8cb5029a89602d5b249a48d7aa1e2f", "filename": "compiler/rustc_hir_analysis/src/check/intrinsicck.rs", "status": "modified", "additions": 0, "deletions": 106, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -1,117 +1,11 @@\n-use hir::HirId;\n use rustc_ast::InlineAsmTemplatePiece;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n-use rustc_index::vec::Idx;\n-use rustc_middle::ty::layout::{LayoutError, SizeSkeleton};\n use rustc_middle::ty::{self, Article, FloatTy, IntTy, Ty, TyCtxt, TypeVisitable, UintTy};\n use rustc_session::lint;\n use rustc_span::{Symbol, DUMMY_SP};\n-use rustc_target::abi::{Pointer, VariantIdx};\n use rustc_target::asm::{InlineAsmReg, InlineAsmRegClass, InlineAsmRegOrRegClass, InlineAsmType};\n \n-use super::FnCtxt;\n-\n-/// If the type is `Option<T>`, it will return `T`, otherwise\n-/// the type itself. Works on most `Option`-like types.\n-fn unpack_option_like<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n-    let ty::Adt(def, substs) = *ty.kind() else { return ty };\n-\n-    if def.variants().len() == 2 && !def.repr().c() && def.repr().int.is_none() {\n-        let data_idx;\n-\n-        let one = VariantIdx::new(1);\n-        let zero = VariantIdx::new(0);\n-\n-        if def.variant(zero).fields.is_empty() {\n-            data_idx = one;\n-        } else if def.variant(one).fields.is_empty() {\n-            data_idx = zero;\n-        } else {\n-            return ty;\n-        }\n-\n-        if def.variant(data_idx).fields.len() == 1 {\n-            return def.variant(data_idx).fields[0].ty(tcx, substs);\n-        }\n-    }\n-\n-    ty\n-}\n-\n-impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n-    pub fn check_transmute(&self, from: Ty<'tcx>, to: Ty<'tcx>, hir_id: HirId) {\n-        let tcx = self.tcx;\n-        let span = tcx.hir().span(hir_id);\n-        let normalize = |ty| {\n-            let ty = self.resolve_vars_if_possible(ty);\n-            self.tcx.normalize_erasing_regions(self.param_env, ty)\n-        };\n-        let from = normalize(from);\n-        let to = normalize(to);\n-        trace!(?from, ?to);\n-\n-        // Transmutes that are only changing lifetimes are always ok.\n-        if from == to {\n-            return;\n-        }\n-\n-        let skel = |ty| SizeSkeleton::compute(ty, tcx, self.param_env);\n-        let sk_from = skel(from);\n-        let sk_to = skel(to);\n-        trace!(?sk_from, ?sk_to);\n-\n-        // Check for same size using the skeletons.\n-        if let (Ok(sk_from), Ok(sk_to)) = (sk_from, sk_to) {\n-            if sk_from.same_size(sk_to) {\n-                return;\n-            }\n-\n-            // Special-case transmuting from `typeof(function)` and\n-            // `Option<typeof(function)>` to present a clearer error.\n-            let from = unpack_option_like(tcx, from);\n-            if let (&ty::FnDef(..), SizeSkeleton::Known(size_to)) = (from.kind(), sk_to) && size_to == Pointer.size(&tcx) {\n-                struct_span_err!(tcx.sess, span, E0591, \"can't transmute zero-sized type\")\n-                    .note(&format!(\"source type: {from}\"))\n-                    .note(&format!(\"target type: {to}\"))\n-                    .help(\"cast with `as` to a pointer instead\")\n-                    .emit();\n-                return;\n-            }\n-        }\n-\n-        // Try to display a sensible error with as much information as possible.\n-        let skeleton_string = |ty: Ty<'tcx>, sk| match sk {\n-            Ok(SizeSkeleton::Known(size)) => format!(\"{} bits\", size.bits()),\n-            Ok(SizeSkeleton::Pointer { tail, .. }) => format!(\"pointer to `{tail}`\"),\n-            Err(LayoutError::Unknown(bad)) => {\n-                if bad == ty {\n-                    \"this type does not have a fixed size\".to_owned()\n-                } else {\n-                    format!(\"size can vary because of {bad}\")\n-                }\n-            }\n-            Err(err) => err.to_string(),\n-        };\n-\n-        let mut err = struct_span_err!(\n-            tcx.sess,\n-            span,\n-            E0512,\n-            \"cannot transmute between types of different sizes, \\\n-                                        or dependently-sized types\"\n-        );\n-        if from == to {\n-            err.note(&format!(\"`{from}` does not have a fixed size\"));\n-        } else {\n-            err.note(&format!(\"source type: `{}` ({})\", from, skeleton_string(from, sk_from)))\n-                .note(&format!(\"target type: `{}` ({})\", to, skeleton_string(to, sk_to)));\n-        }\n-        err.emit();\n-    }\n-}\n-\n pub struct InlineAsmCtxt<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,"}, {"sha": "2e7b1025764076f651cb1fe50c54a2e6287c3f98", "filename": "compiler/rustc_hir_analysis/src/check/mod.rs", "status": "modified", "additions": 23, "deletions": 479, "changes": 502, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -62,191 +62,45 @@ a type parameter).\n \n */\n \n-pub mod _match;\n-mod autoderef;\n-mod callee;\n-pub mod cast;\n mod check;\n-mod closure;\n-pub mod coercion;\n mod compare_method;\n-pub mod demand;\n-mod diverges;\n pub mod dropck;\n-mod expectation;\n-mod expr;\n-mod fallback;\n-mod fn_ctxt;\n-mod gather_locals;\n-mod generator_interior;\n-mod inherited;\n pub mod intrinsic;\n-mod intrinsicck;\n-pub mod method;\n-mod op;\n-mod pat;\n-mod place_op;\n+pub mod intrinsicck;\n mod region;\n-pub mod rvalue_scopes;\n-mod upvar;\n pub mod wfcheck;\n-pub mod writeback;\n \n-use check::{check_abi, check_fn, check_mod_item_types};\n-pub use diverges::Diverges;\n-pub use expectation::Expectation;\n-pub use fn_ctxt::*;\n-pub use inherited::{Inherited, InheritedBuilder};\n+pub use check::check_abi;\n \n-use crate::astconv::AstConv;\n-use crate::check::gather_locals::GatherLocalsVisitor;\n+use check::check_mod_item_types;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_errors::{\n-    pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, MultiSpan,\n-};\n+use rustc_errors::{pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder};\n use rustc_hir as hir;\n-use rustc_hir::def::Res;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::Visitor;\n-use rustc_hir::{HirIdMap, ImplicitSelfKind, Node};\n use rustc_index::bit_set::BitSet;\n-use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{self, Ty, TyCtxt, UserType};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::ty::{InternalSubsts, SubstsRef};\n-use rustc_session::config;\n use rustc_session::parse::feature_err;\n-use rustc_session::Session;\n use rustc_span::source_map::DUMMY_SP;\n use rustc_span::symbol::{kw, Ident};\n use rustc_span::{self, BytePos, Span, Symbol};\n use rustc_target::abi::VariantIdx;\n use rustc_target::spec::abi::Abi;\n-use rustc_trait_selection::traits;\n use rustc_trait_selection::traits::error_reporting::suggestions::ReturnsVisitor;\n-use std::cell::RefCell;\n use std::num::NonZeroU32;\n \n use crate::require_c_abi_if_c_variadic;\n use crate::util::common::indenter;\n \n-use self::coercion::DynamicCoerceMany;\n use self::compare_method::collect_trait_impl_trait_tys;\n use self::region::region_scope_tree;\n-pub use self::Expectation::*;\n-\n-#[macro_export]\n-macro_rules! type_error_struct {\n-    ($session:expr, $span:expr, $typ:expr, $code:ident, $($message:tt)*) => ({\n-        let mut err = rustc_errors::struct_span_err!($session, $span, $code, $($message)*);\n-\n-        if $typ.references_error() {\n-            err.downgrade_to_delayed_bug();\n-        }\n-\n-        err\n-    })\n-}\n-\n-/// The type of a local binding, including the revealed type for anon types.\n-#[derive(Copy, Clone, Debug)]\n-pub struct LocalTy<'tcx> {\n-    decl_ty: Ty<'tcx>,\n-    revealed_ty: Ty<'tcx>,\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub enum Needs {\n-    MutPlace,\n-    None,\n-}\n-\n-impl Needs {\n-    fn maybe_mut_place(m: hir::Mutability) -> Self {\n-        match m {\n-            hir::Mutability::Mut => Needs::MutPlace,\n-            hir::Mutability::Not => Needs::None,\n-        }\n-    }\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct UnsafetyState {\n-    pub def: hir::HirId,\n-    pub unsafety: hir::Unsafety,\n-    from_fn: bool,\n-}\n-\n-impl UnsafetyState {\n-    pub fn function(unsafety: hir::Unsafety, def: hir::HirId) -> UnsafetyState {\n-        UnsafetyState { def, unsafety, from_fn: true }\n-    }\n-\n-    pub fn recurse(self, blk: &hir::Block<'_>) -> UnsafetyState {\n-        use hir::BlockCheckMode;\n-        match self.unsafety {\n-            // If this unsafe, then if the outer function was already marked as\n-            // unsafe we shouldn't attribute the unsafe'ness to the block. This\n-            // way the block can be warned about instead of ignoring this\n-            // extraneous block (functions are never warned about).\n-            hir::Unsafety::Unsafe if self.from_fn => self,\n-\n-            unsafety => {\n-                let (unsafety, def) = match blk.rules {\n-                    BlockCheckMode::UnsafeBlock(..) => (hir::Unsafety::Unsafe, blk.hir_id),\n-                    BlockCheckMode::DefaultBlock => (unsafety, self.def),\n-                };\n-                UnsafetyState { def, unsafety, from_fn: false }\n-            }\n-        }\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone)]\n-pub enum PlaceOp {\n-    Deref,\n-    Index,\n-}\n-\n-pub struct BreakableCtxt<'tcx> {\n-    may_break: bool,\n-\n-    // this is `null` for loops where break with a value is illegal,\n-    // such as `while`, `for`, and `while let`\n-    coerce: Option<DynamicCoerceMany<'tcx>>,\n-}\n-\n-pub struct EnclosingBreakables<'tcx> {\n-    stack: Vec<BreakableCtxt<'tcx>>,\n-    by_id: HirIdMap<usize>,\n-}\n-\n-impl<'tcx> EnclosingBreakables<'tcx> {\n-    fn find_breakable(&mut self, target_id: hir::HirId) -> &mut BreakableCtxt<'tcx> {\n-        self.opt_find_breakable(target_id).unwrap_or_else(|| {\n-            bug!(\"could not find enclosing breakable with id {}\", target_id);\n-        })\n-    }\n-\n-    fn opt_find_breakable(&mut self, target_id: hir::HirId) -> Option<&mut BreakableCtxt<'tcx>> {\n-        match self.by_id.get(&target_id) {\n-            Some(ix) => Some(&mut self.stack[*ix]),\n-            None => None,\n-        }\n-    }\n-}\n \n pub fn provide(providers: &mut Providers) {\n-    method::provide(providers);\n     wfcheck::provide(providers);\n     *providers = Providers {\n-        typeck_item_bodies,\n-        typeck_const_arg,\n-        typeck,\n-        diagnostic_only_typeck,\n-        has_typeck_results,\n         adt_destructor,\n-        used_trait_imports,\n         check_mod_item_types,\n         region_scope_tree,\n         collect_trait_impl_trait_tys,\n@@ -259,259 +113,6 @@ fn adt_destructor(tcx: TyCtxt<'_>, def_id: DefId) -> Option<ty::Destructor> {\n     tcx.calculate_dtor(def_id, dropck::check_drop_impl)\n }\n \n-/// If this `DefId` is a \"primary tables entry\", returns\n-/// `Some((body_id, body_ty, fn_sig))`. Otherwise, returns `None`.\n-///\n-/// If this function returns `Some`, then `typeck_results(def_id)` will\n-/// succeed; if it returns `None`, then `typeck_results(def_id)` may or\n-/// may not succeed. In some cases where this function returns `None`\n-/// (notably closures), `typeck_results(def_id)` would wind up\n-/// redirecting to the owning function.\n-fn primary_body_of(\n-    tcx: TyCtxt<'_>,\n-    id: hir::HirId,\n-) -> Option<(hir::BodyId, Option<&hir::Ty<'_>>, Option<&hir::FnSig<'_>>)> {\n-    match tcx.hir().get(id) {\n-        Node::Item(item) => match item.kind {\n-            hir::ItemKind::Const(ty, body) | hir::ItemKind::Static(ty, _, body) => {\n-                Some((body, Some(ty), None))\n-            }\n-            hir::ItemKind::Fn(ref sig, .., body) => Some((body, None, Some(sig))),\n-            _ => None,\n-        },\n-        Node::TraitItem(item) => match item.kind {\n-            hir::TraitItemKind::Const(ty, Some(body)) => Some((body, Some(ty), None)),\n-            hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(body)) => {\n-                Some((body, None, Some(sig)))\n-            }\n-            _ => None,\n-        },\n-        Node::ImplItem(item) => match item.kind {\n-            hir::ImplItemKind::Const(ty, body) => Some((body, Some(ty), None)),\n-            hir::ImplItemKind::Fn(ref sig, body) => Some((body, None, Some(sig))),\n-            _ => None,\n-        },\n-        Node::AnonConst(constant) => Some((constant.body, None, None)),\n-        _ => None,\n-    }\n-}\n-\n-fn has_typeck_results(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-    // Closures' typeck results come from their outermost function,\n-    // as they are part of the same \"inference environment\".\n-    let typeck_root_def_id = tcx.typeck_root_def_id(def_id);\n-    if typeck_root_def_id != def_id {\n-        return tcx.has_typeck_results(typeck_root_def_id);\n-    }\n-\n-    if let Some(def_id) = def_id.as_local() {\n-        let id = tcx.hir().local_def_id_to_hir_id(def_id);\n-        primary_body_of(tcx, id).is_some()\n-    } else {\n-        false\n-    }\n-}\n-\n-fn used_trait_imports(tcx: TyCtxt<'_>, def_id: LocalDefId) -> &FxHashSet<LocalDefId> {\n-    &*tcx.typeck(def_id).used_trait_imports\n-}\n-\n-fn typeck_const_arg<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    (did, param_did): (LocalDefId, DefId),\n-) -> &ty::TypeckResults<'tcx> {\n-    let fallback = move || tcx.type_of(param_did);\n-    typeck_with_fallback(tcx, did, fallback)\n-}\n-\n-fn typeck<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> &ty::TypeckResults<'tcx> {\n-    if let Some(param_did) = tcx.opt_const_param_of(def_id) {\n-        tcx.typeck_const_arg((def_id, param_did))\n-    } else {\n-        let fallback = move || tcx.type_of(def_id.to_def_id());\n-        typeck_with_fallback(tcx, def_id, fallback)\n-    }\n-}\n-\n-/// Used only to get `TypeckResults` for type inference during error recovery.\n-/// Currently only used for type inference of `static`s and `const`s to avoid type cycle errors.\n-fn diagnostic_only_typeck<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> &ty::TypeckResults<'tcx> {\n-    let fallback = move || {\n-        let span = tcx.hir().span(tcx.hir().local_def_id_to_hir_id(def_id));\n-        tcx.ty_error_with_message(span, \"diagnostic only typeck table used\")\n-    };\n-    typeck_with_fallback(tcx, def_id, fallback)\n-}\n-\n-fn typeck_with_fallback<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    def_id: LocalDefId,\n-    fallback: impl Fn() -> Ty<'tcx> + 'tcx,\n-) -> &'tcx ty::TypeckResults<'tcx> {\n-    // Closures' typeck results come from their outermost function,\n-    // as they are part of the same \"inference environment\".\n-    let typeck_root_def_id = tcx.typeck_root_def_id(def_id.to_def_id()).expect_local();\n-    if typeck_root_def_id != def_id {\n-        return tcx.typeck(typeck_root_def_id);\n-    }\n-\n-    let id = tcx.hir().local_def_id_to_hir_id(def_id);\n-    let span = tcx.hir().span(id);\n-\n-    // Figure out what primary body this item has.\n-    let (body_id, body_ty, fn_sig) = primary_body_of(tcx, id).unwrap_or_else(|| {\n-        span_bug!(span, \"can't type-check body of {:?}\", def_id);\n-    });\n-    let body = tcx.hir().body(body_id);\n-\n-    let typeck_results = Inherited::build(tcx, def_id).enter(|inh| {\n-        let param_env = tcx.param_env(def_id);\n-        let mut fcx = if let Some(hir::FnSig { header, decl, .. }) = fn_sig {\n-            let fn_sig = if crate::collect::get_infer_ret_ty(&decl.output).is_some() {\n-                let fcx = FnCtxt::new(&inh, param_env, body.value.hir_id);\n-                <dyn AstConv<'_>>::ty_of_fn(&fcx, id, header.unsafety, header.abi, decl, None, None)\n-            } else {\n-                tcx.fn_sig(def_id)\n-            };\n-\n-            check_abi(tcx, id, span, fn_sig.abi());\n-\n-            // Compute the function signature from point of view of inside the fn.\n-            let fn_sig = tcx.liberate_late_bound_regions(def_id.to_def_id(), fn_sig);\n-            let fn_sig = inh.normalize_associated_types_in(\n-                body.value.span,\n-                body_id.hir_id,\n-                param_env,\n-                fn_sig,\n-            );\n-            check_fn(&inh, param_env, fn_sig, decl, id, body, None, true).0\n-        } else {\n-            let fcx = FnCtxt::new(&inh, param_env, body.value.hir_id);\n-            let expected_type = body_ty\n-                .and_then(|ty| match ty.kind {\n-                    hir::TyKind::Infer => Some(<dyn AstConv<'_>>::ast_ty_to_ty(&fcx, ty)),\n-                    _ => None,\n-                })\n-                .unwrap_or_else(|| match tcx.hir().get(id) {\n-                    Node::AnonConst(_) => match tcx.hir().get(tcx.hir().get_parent_node(id)) {\n-                        Node::Expr(&hir::Expr {\n-                            kind: hir::ExprKind::ConstBlock(ref anon_const),\n-                            ..\n-                        }) if anon_const.hir_id == id => fcx.next_ty_var(TypeVariableOrigin {\n-                            kind: TypeVariableOriginKind::TypeInference,\n-                            span,\n-                        }),\n-                        Node::Ty(&hir::Ty {\n-                            kind: hir::TyKind::Typeof(ref anon_const), ..\n-                        }) if anon_const.hir_id == id => fcx.next_ty_var(TypeVariableOrigin {\n-                            kind: TypeVariableOriginKind::TypeInference,\n-                            span,\n-                        }),\n-                        Node::Expr(&hir::Expr { kind: hir::ExprKind::InlineAsm(asm), .. })\n-                        | Node::Item(&hir::Item { kind: hir::ItemKind::GlobalAsm(asm), .. }) => {\n-                            let operand_ty = asm\n-                                .operands\n-                                .iter()\n-                                .filter_map(|(op, _op_sp)| match op {\n-                                    hir::InlineAsmOperand::Const { anon_const }\n-                                        if anon_const.hir_id == id =>\n-                                    {\n-                                        // Inline assembly constants must be integers.\n-                                        Some(fcx.next_int_var())\n-                                    }\n-                                    hir::InlineAsmOperand::SymFn { anon_const }\n-                                        if anon_const.hir_id == id =>\n-                                    {\n-                                        Some(fcx.next_ty_var(TypeVariableOrigin {\n-                                            kind: TypeVariableOriginKind::MiscVariable,\n-                                            span,\n-                                        }))\n-                                    }\n-                                    _ => None,\n-                                })\n-                                .next();\n-                            operand_ty.unwrap_or_else(fallback)\n-                        }\n-                        _ => fallback(),\n-                    },\n-                    _ => fallback(),\n-                });\n-\n-            let expected_type = fcx.normalize_associated_types_in(body.value.span, expected_type);\n-            fcx.require_type_is_sized(expected_type, body.value.span, traits::ConstSized);\n-\n-            // Gather locals in statics (because of block expressions).\n-            GatherLocalsVisitor::new(&fcx).visit_body(body);\n-\n-            fcx.check_expr_coercable_to_type(&body.value, expected_type, None);\n-\n-            fcx.write_ty(id, expected_type);\n-\n-            fcx\n-        };\n-\n-        let fallback_has_occurred = fcx.type_inference_fallback();\n-\n-        // Even though coercion casts provide type hints, we check casts after fallback for\n-        // backwards compatibility. This makes fallback a stronger type hint than a cast coercion.\n-        fcx.check_casts();\n-        fcx.select_obligations_where_possible(fallback_has_occurred, |_| {});\n-\n-        // Closure and generator analysis may run after fallback\n-        // because they don't constrain other type variables.\n-        // Closure analysis only runs on closures. Therefore they only need to fulfill non-const predicates (as of now)\n-        let prev_constness = fcx.param_env.constness();\n-        fcx.param_env = fcx.param_env.without_const();\n-        fcx.closure_analyze(body);\n-        fcx.param_env = fcx.param_env.with_constness(prev_constness);\n-        assert!(fcx.deferred_call_resolutions.borrow().is_empty());\n-        // Before the generator analysis, temporary scopes shall be marked to provide more\n-        // precise information on types to be captured.\n-        fcx.resolve_rvalue_scopes(def_id.to_def_id());\n-        fcx.resolve_generator_interiors(def_id.to_def_id());\n-\n-        for (ty, span, code) in fcx.deferred_sized_obligations.borrow_mut().drain(..) {\n-            let ty = fcx.normalize_ty(span, ty);\n-            fcx.require_type_is_sized(ty, span, code);\n-        }\n-\n-        fcx.select_all_obligations_or_error();\n-\n-        if !fcx.infcx.is_tainted_by_errors() {\n-            fcx.check_transmutes();\n-        }\n-\n-        fcx.check_asms();\n-\n-        fcx.infcx.skip_region_resolution();\n-\n-        fcx.resolve_type_vars_in_body(body)\n-    });\n-\n-    // Consistency check our TypeckResults instance can hold all ItemLocalIds\n-    // it will need to hold.\n-    assert_eq!(typeck_results.hir_owner, id.owner);\n-\n-    typeck_results\n-}\n-\n-/// When `check_fn` is invoked on a generator (i.e., a body that\n-/// includes yield), it returns back some information about the yield\n-/// points.\n-struct GeneratorTypes<'tcx> {\n-    /// Type of generator argument / values returned by `yield`.\n-    resume_ty: Ty<'tcx>,\n-\n-    /// Type of value that is yielded.\n-    yield_ty: Ty<'tcx>,\n-\n-    /// Types that are captured (see `GeneratorInterior` for more).\n-    interior: Ty<'tcx>,\n-\n-    /// Indicates if the generator is movable or static (immovable).\n-    movability: hir::Movability,\n-}\n-\n /// Given a `DefId` for an opaque type in return position, find its parent item's return\n /// expressions.\n fn get_owner_return_paths<'tcx>(\n@@ -528,9 +129,10 @@ fn get_owner_return_paths<'tcx>(\n     })\n }\n \n-// Forbid defining intrinsics in Rust code,\n-// as they must always be defined by the compiler.\n-fn fn_maybe_err(tcx: TyCtxt<'_>, sp: Span, abi: Abi) {\n+/// Forbid defining intrinsics in Rust code,\n+/// as they must always be defined by the compiler.\n+// FIXME: Move this to a more appropriate place.\n+pub fn fn_maybe_err(tcx: TyCtxt<'_>, sp: Span, abi: Abi) {\n     if let Abi::RustIntrinsic | Abi::PlatformIntrinsic = abi {\n         tcx.sess.span_err(sp, \"intrinsic must be in `extern \\\"rust-intrinsic\\\" { ... }` block\");\n     }\n@@ -824,6 +426,17 @@ fn fn_sig_suggestion<'tcx>(\n     format!(\"{unsafety}fn {ident}{generics}({args}){output}{where_clauses} {{ todo!() }}\")\n }\n \n+pub fn ty_kind_suggestion(ty: Ty<'_>) -> Option<&'static str> {\n+    Some(match ty.kind() {\n+        ty::Bool => \"true\",\n+        ty::Char => \"'a'\",\n+        ty::Int(_) | ty::Uint(_) => \"42\",\n+        ty::Float(_) => \"3.14159\",\n+        ty::Error(_) | ty::Never => return None,\n+        _ => \"value\",\n+    })\n+}\n+\n /// Return placeholder code for the given associated item.\n /// Similar to `ty::AssocItem::suggestion`, but appropriate for use as the code snippet of a\n /// structured suggestion.\n@@ -845,7 +458,7 @@ fn suggestion_signature(assoc: &ty::AssocItem, tcx: TyCtxt<'_>) -> String {\n         ty::AssocKind::Type => format!(\"type {} = Type;\", assoc.name),\n         ty::AssocKind::Const => {\n             let ty = tcx.type_of(assoc.def_id);\n-            let val = expr::ty_kind_suggestion(ty).unwrap_or(\"value\");\n+            let val = ty_kind_suggestion(ty).unwrap_or(\"value\");\n             format!(\"const {}: {} = {};\", assoc.name, ty, val)\n         }\n     }\n@@ -896,76 +509,7 @@ fn bad_non_zero_sized_fields<'tcx>(\n     err.emit();\n }\n \n-fn report_unexpected_variant_res(tcx: TyCtxt<'_>, res: Res, qpath: &hir::QPath<'_>, span: Span) {\n-    struct_span_err!(\n-        tcx.sess,\n-        span,\n-        E0533,\n-        \"expected unit struct, unit variant or constant, found {} `{}`\",\n-        res.descr(),\n-        rustc_hir_pretty::qpath_to_string(qpath),\n-    )\n-    .emit();\n-}\n-\n-/// Controls whether the arguments are tupled. This is used for the call\n-/// operator.\n-///\n-/// Tupling means that all call-side arguments are packed into a tuple and\n-/// passed as a single parameter. For example, if tupling is enabled, this\n-/// function:\n-/// ```\n-/// fn f(x: (isize, isize)) {}\n-/// ```\n-/// Can be called as:\n-/// ```ignore UNSOLVED (can this be done in user code?)\n-/// # fn f(x: (isize, isize)) {}\n-/// f(1, 2);\n-/// ```\n-/// Instead of:\n-/// ```\n-/// # fn f(x: (isize, isize)) {}\n-/// f((1, 2));\n-/// ```\n-#[derive(Clone, Eq, PartialEq)]\n-enum TupleArgumentsFlag {\n-    DontTupleArguments,\n-    TupleArguments,\n-}\n-\n-fn typeck_item_bodies(tcx: TyCtxt<'_>, (): ()) {\n-    tcx.hir().par_body_owners(|body_owner_def_id| tcx.ensure().typeck(body_owner_def_id));\n-}\n-\n-fn fatally_break_rust(sess: &Session) {\n-    let handler = sess.diagnostic();\n-    handler.span_bug_no_panic(\n-        MultiSpan::new(),\n-        \"It looks like you're trying to break rust; would you like some ICE?\",\n-    );\n-    handler.note_without_error(\"the compiler expectedly panicked. this is a feature.\");\n-    handler.note_without_error(\n-        \"we would appreciate a joke overview: \\\n-         https://github.com/rust-lang/rust/issues/43162#issuecomment-320764675\",\n-    );\n-    handler.note_without_error(&format!(\n-        \"rustc {} running on {}\",\n-        option_env!(\"CFG_VERSION\").unwrap_or(\"unknown_version\"),\n-        config::host_triple(),\n-    ));\n-}\n-\n-fn potentially_plural_count(count: usize, word: &str) -> String {\n+// FIXME: Consider moving this method to a more fitting place.\n+pub fn potentially_plural_count(count: usize, word: &str) -> String {\n     format!(\"{} {}{}\", count, word, pluralize!(count))\n }\n-\n-fn has_expected_num_generic_args<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    trait_did: Option<DefId>,\n-    expected: usize,\n-) -> bool {\n-    trait_did.map_or(true, |trait_did| {\n-        let generics = tcx.generics_of(trait_did);\n-        generics.count() == expected + if generics.has_self { 1 } else { 0 }\n-    })\n-}"}, {"sha": "33ed3b96aa81fb9aef9f9bb7321d99bb94424736", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -1101,8 +1101,6 @@ fn check_type_defn<'tcx, F>(\n \n             // Explicit `enum` discriminant values must const-evaluate successfully.\n             if let Some(discr_def_id) = variant.explicit_discr {\n-                let discr_substs = InternalSubsts::identity_for_item(tcx, discr_def_id.to_def_id());\n-\n                 let cause = traits::ObligationCause::new(\n                     tcx.def_span(discr_def_id),\n                     wfcx.body_id,\n@@ -1112,10 +1110,7 @@ fn check_type_defn<'tcx, F>(\n                     cause,\n                     wfcx.param_env,\n                     ty::Binder::dummy(ty::PredicateKind::ConstEvaluatable(\n-                        ty::UnevaluatedConst::new(\n-                            ty::WithOptConstParam::unknown(discr_def_id.to_def_id()),\n-                            discr_substs,\n-                        ),\n+                        ty::Const::from_anon_const(tcx, discr_def_id),\n                     ))\n                     .to_predicate(tcx),\n                 ));"}, {"sha": "66ca7d7aa08f9cd1d23bfb0ab1afa32d4f684453", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -100,13 +100,12 @@ pub fn provide(providers: &mut Providers) {\n /// It's also used for the bodies of items like structs where the body (the fields)\n /// are just signatures.\n ///\n-/// This is in contrast to [`FnCtxt`], which is used to type-check bodies of\n+/// This is in contrast to `FnCtxt`, which is used to type-check bodies of\n /// functions, closures, and `const`s -- anywhere that expressions and statements show up.\n ///\n /// An important thing to note is that `ItemCtxt` does no inference -- it has no [`InferCtxt`] --\n /// while `FnCtxt` does do inference.\n ///\n-/// [`FnCtxt`]: crate::check::FnCtxt\n /// [`InferCtxt`]: rustc_infer::infer::InferCtxt\n ///\n /// # Trait predicates"}, {"sha": "2e84e1d01600708cb699b83f588dce311c135803", "filename": "compiler/rustc_hir_analysis/src/collect/predicates_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -318,10 +318,10 @@ fn const_evaluatable_predicates_of<'tcx>(\n         fn visit_anon_const(&mut self, c: &'tcx hir::AnonConst) {\n             let def_id = self.tcx.hir().local_def_id(c.hir_id);\n             let ct = ty::Const::from_anon_const(self.tcx, def_id);\n-            if let ty::ConstKind::Unevaluated(uv) = ct.kind() {\n+            if let ty::ConstKind::Unevaluated(_) = ct.kind() {\n                 let span = self.tcx.hir().span(c.hir_id);\n                 self.preds.insert((\n-                    ty::Binder::dummy(ty::PredicateKind::ConstEvaluatable(uv))\n+                    ty::Binder::dummy(ty::PredicateKind::ConstEvaluatable(ct))\n                         .to_predicate(self.tcx),\n                     span,\n                 ));"}, {"sha": "9457da32ce65a7c2b31d0510859851e257a42dd3", "filename": "compiler/rustc_hir_analysis/src/errors.rs", "status": "modified", "additions": 31, "deletions": 154, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -1,24 +1,13 @@\n-//! Errors emitted by `hir_analysis`.\n+//! Errors emitted by `rustc_hir_analysis`.\n \n use rustc_errors::IntoDiagnostic;\n use rustc_errors::{error_code, Applicability, DiagnosticBuilder, ErrorGuaranteed, Handler};\n-use rustc_macros::{Diagnostic, LintDiagnostic, Subdiagnostic};\n+use rustc_macros::{Diagnostic, LintDiagnostic};\n use rustc_middle::ty::Ty;\n use rustc_span::{symbol::Ident, Span, Symbol};\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis::field_multiply_specified_in_initializer, code = \"E0062\")]\n-pub struct FieldMultiplySpecifiedInInitializer {\n-    #[primary_span]\n-    #[label]\n-    pub span: Span,\n-    #[label(hir_analysis::previous_use_label)]\n-    pub prev_span: Span,\n-    pub ident: Ident,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(hir_analysis::unrecognized_atomic_operation, code = \"E0092\")]\n+#[diag(hir_analysis_unrecognized_atomic_operation, code = \"E0092\")]\n pub struct UnrecognizedAtomicOperation<'a> {\n     #[primary_span]\n     #[label]\n@@ -27,7 +16,7 @@ pub struct UnrecognizedAtomicOperation<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis::wrong_number_of_generic_arguments_to_intrinsic, code = \"E0094\")]\n+#[diag(hir_analysis_wrong_number_of_generic_arguments_to_intrinsic, code = \"E0094\")]\n pub struct WrongNumberOfGenericArgumentsToIntrinsic<'a> {\n     #[primary_span]\n     #[label]\n@@ -38,7 +27,7 @@ pub struct WrongNumberOfGenericArgumentsToIntrinsic<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis::unrecognized_intrinsic_function, code = \"E0093\")]\n+#[diag(hir_analysis_unrecognized_intrinsic_function, code = \"E0093\")]\n pub struct UnrecognizedIntrinsicFunction {\n     #[primary_span]\n     #[label]\n@@ -47,92 +36,85 @@ pub struct UnrecognizedIntrinsicFunction {\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis::lifetimes_or_bounds_mismatch_on_trait, code = \"E0195\")]\n+#[diag(hir_analysis_lifetimes_or_bounds_mismatch_on_trait, code = \"E0195\")]\n pub struct LifetimesOrBoundsMismatchOnTrait {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[label(hir_analysis::generics_label)]\n+    #[label(generics_label)]\n     pub generics_span: Option<Span>,\n     pub item_kind: &'static str,\n     pub ident: Ident,\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis::drop_impl_on_wrong_item, code = \"E0120\")]\n+#[diag(hir_analysis_drop_impl_on_wrong_item, code = \"E0120\")]\n pub struct DropImplOnWrongItem {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis::field_already_declared, code = \"E0124\")]\n+#[diag(hir_analysis_field_already_declared, code = \"E0124\")]\n pub struct FieldAlreadyDeclared {\n     pub field_name: Ident,\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[label(hir_analysis::previous_decl_label)]\n+    #[label(previous_decl_label)]\n     pub prev_span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis::copy_impl_on_type_with_dtor, code = \"E0184\")]\n+#[diag(hir_analysis_copy_impl_on_type_with_dtor, code = \"E0184\")]\n pub struct CopyImplOnTypeWithDtor {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis::multiple_relaxed_default_bounds, code = \"E0203\")]\n+#[diag(hir_analysis_multiple_relaxed_default_bounds, code = \"E0203\")]\n pub struct MultipleRelaxedDefaultBounds {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis::copy_impl_on_non_adt, code = \"E0206\")]\n+#[diag(hir_analysis_copy_impl_on_non_adt, code = \"E0206\")]\n pub struct CopyImplOnNonAdt {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis::trait_object_declared_with_no_traits, code = \"E0224\")]\n+#[diag(hir_analysis_trait_object_declared_with_no_traits, code = \"E0224\")]\n pub struct TraitObjectDeclaredWithNoTraits {\n     #[primary_span]\n     pub span: Span,\n-    #[label(hir_analysis::alias_span)]\n+    #[label(alias_span)]\n     pub trait_alias_span: Option<Span>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis::ambiguous_lifetime_bound, code = \"E0227\")]\n+#[diag(hir_analysis_ambiguous_lifetime_bound, code = \"E0227\")]\n pub struct AmbiguousLifetimeBound {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis::assoc_type_binding_not_allowed, code = \"E0229\")]\n+#[diag(hir_analysis_assoc_type_binding_not_allowed, code = \"E0229\")]\n pub struct AssocTypeBindingNotAllowed {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis::functional_record_update_on_non_struct, code = \"E0436\")]\n-pub struct FunctionalRecordUpdateOnNonStruct {\n-    #[primary_span]\n-    pub span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(hir_analysis::typeof_reserved_keyword_used, code = \"E0516\")]\n+#[diag(hir_analysis_typeof_reserved_keyword_used, code = \"E0516\")]\n pub struct TypeofReservedKeywordUsed<'tcx> {\n     pub ty: Ty<'tcx>,\n     #[primary_span]\n@@ -143,98 +125,19 @@ pub struct TypeofReservedKeywordUsed<'tcx> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis::return_stmt_outside_of_fn_body, code = \"E0572\")]\n-pub struct ReturnStmtOutsideOfFnBody {\n-    #[primary_span]\n-    pub span: Span,\n-    #[label(hir_analysis::encl_body_label)]\n-    pub encl_body_span: Option<Span>,\n-    #[label(hir_analysis::encl_fn_label)]\n-    pub encl_fn_span: Option<Span>,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(hir_analysis::yield_expr_outside_of_generator, code = \"E0627\")]\n-pub struct YieldExprOutsideOfGenerator {\n-    #[primary_span]\n-    pub span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(hir_analysis::struct_expr_non_exhaustive, code = \"E0639\")]\n-pub struct StructExprNonExhaustive {\n-    #[primary_span]\n-    pub span: Span,\n-    pub what: &'static str,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(hir_analysis::method_call_on_unknown_type, code = \"E0699\")]\n-pub struct MethodCallOnUnknownType {\n-    #[primary_span]\n-    pub span: Span,\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(hir_analysis::value_of_associated_struct_already_specified, code = \"E0719\")]\n+#[diag(hir_analysis_value_of_associated_struct_already_specified, code = \"E0719\")]\n pub struct ValueOfAssociatedStructAlreadySpecified {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[label(hir_analysis::previous_bound_label)]\n+    #[label(previous_bound_label)]\n     pub prev_span: Span,\n     pub item_name: Ident,\n     pub def_path: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis::address_of_temporary_taken, code = \"E0745\")]\n-pub struct AddressOfTemporaryTaken {\n-    #[primary_span]\n-    #[label]\n-    pub span: Span,\n-}\n-\n-#[derive(Subdiagnostic)]\n-pub enum AddReturnTypeSuggestion {\n-    #[suggestion(\n-        hir_analysis::add_return_type_add,\n-        code = \"-> {found} \",\n-        applicability = \"machine-applicable\"\n-    )]\n-    Add {\n-        #[primary_span]\n-        span: Span,\n-        found: String,\n-    },\n-    #[suggestion(\n-        hir_analysis::add_return_type_missing_here,\n-        code = \"-> _ \",\n-        applicability = \"has-placeholders\"\n-    )]\n-    MissingHere {\n-        #[primary_span]\n-        span: Span,\n-    },\n-}\n-\n-#[derive(Subdiagnostic)]\n-pub enum ExpectedReturnTypeLabel<'tcx> {\n-    #[label(hir_analysis::expected_default_return_type)]\n-    Unit {\n-        #[primary_span]\n-        span: Span,\n-    },\n-    #[label(hir_analysis::expected_return_type)]\n-    Other {\n-        #[primary_span]\n-        span: Span,\n-        expected: Ty<'tcx>,\n-    },\n-}\n-\n-#[derive(Diagnostic)]\n-#[diag(hir_analysis::unconstrained_opaque_type)]\n+#[diag(hir_analysis_unconstrained_opaque_type)]\n #[note]\n pub struct UnconstrainedOpaqueType {\n     #[primary_span]\n@@ -255,7 +158,7 @@ impl<'a> IntoDiagnostic<'a> for MissingTypeParams {\n     fn into_diagnostic(self, handler: &'a Handler) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n         let mut err = handler.struct_span_err_with_code(\n             self.span,\n-            rustc_errors::fluent::hir_analysis::missing_type_params,\n+            rustc_errors::fluent::hir_analysis_missing_type_params,\n             error_code!(E0393),\n         );\n         err.set_arg(\"parameterCount\", self.missing_type_params.len());\n@@ -268,7 +171,7 @@ impl<'a> IntoDiagnostic<'a> for MissingTypeParams {\n                 .join(\", \"),\n         );\n \n-        err.span_label(self.def_span, rustc_errors::fluent::hir_analysis::label);\n+        err.span_label(self.def_span, rustc_errors::fluent::label);\n \n         let mut suggested = false;\n         // Don't suggest setting the type params if there are some already: the order is\n@@ -283,7 +186,7 @@ impl<'a> IntoDiagnostic<'a> for MissingTypeParams {\n                 // least we can clue them to the correct syntax `Iterator<Type>`.\n                 err.span_suggestion(\n                     self.span,\n-                    rustc_errors::fluent::hir_analysis::suggestion,\n+                    rustc_errors::fluent::suggestion,\n                     format!(\n                         \"{}<{}>\",\n                         snippet,\n@@ -299,16 +202,16 @@ impl<'a> IntoDiagnostic<'a> for MissingTypeParams {\n             }\n         }\n         if !suggested {\n-            err.span_label(self.span, rustc_errors::fluent::hir_analysis::no_suggestion_label);\n+            err.span_label(self.span, rustc_errors::fluent::no_suggestion_label);\n         }\n \n-        err.note(rustc_errors::fluent::hir_analysis::note);\n+        err.note(rustc_errors::fluent::note);\n         err\n     }\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis::manual_implementation, code = \"E0183\")]\n+#[diag(hir_analysis_manual_implementation, code = \"E0183\")]\n #[help]\n pub struct ManualImplementation {\n     #[primary_span]\n@@ -318,21 +221,21 @@ pub struct ManualImplementation {\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis::substs_on_overridden_impl)]\n+#[diag(hir_analysis_substs_on_overridden_impl)]\n pub struct SubstsOnOverriddenImpl {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(hir_analysis::unused_extern_crate)]\n+#[diag(hir_analysis_unused_extern_crate)]\n pub struct UnusedExternCrate {\n     #[suggestion(applicability = \"machine-applicable\", code = \"\")]\n     pub span: Span,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(hir_analysis::extern_crate_not_idiomatic)]\n+#[diag(hir_analysis_extern_crate_not_idiomatic)]\n pub struct ExternCrateNotIdiomatic {\n     #[suggestion_short(applicability = \"machine-applicable\", code = \"{suggestion_code}\")]\n     pub span: Span,\n@@ -341,34 +244,8 @@ pub struct ExternCrateNotIdiomatic {\n }\n \n #[derive(Diagnostic)]\n-#[diag(hir_analysis::expected_used_symbol)]\n+#[diag(hir_analysis_expected_used_symbol)]\n pub struct ExpectedUsedSymbol {\n     #[primary_span]\n     pub span: Span,\n }\n-\n-#[derive(Diagnostic)]\n-#[diag(hir_analysis::missing_parentheses_in_range, code = \"E0689\")]\n-pub struct MissingParentheseInRange {\n-    #[primary_span]\n-    #[label(hir_analysis::missing_parentheses_in_range)]\n-    pub span: Span,\n-    pub ty_str: String,\n-    pub method_name: String,\n-\n-    #[subdiagnostic]\n-    pub add_missing_parentheses: Option<AddMissingParenthesesInRange>,\n-}\n-\n-#[derive(Subdiagnostic)]\n-#[multipart_suggestion_verbose(\n-    hir_analysis::add_missing_parentheses_in_range,\n-    applicability = \"maybe-incorrect\"\n-)]\n-pub struct AddMissingParenthesesInRange {\n-    pub func_name: String,\n-    #[suggestion_part(code = \"(\")]\n-    pub left: Span,\n-    #[suggestion_part(code = \")\")]\n-    pub right: Span,\n-}"}, {"sha": "dba505149de87f2a3e12a85b57e460e4c772a730", "filename": "compiler/rustc_hir_analysis/src/lib.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -82,20 +82,19 @@ extern crate rustc_middle;\n \n // These are used by Clippy.\n pub mod check;\n-pub mod expr_use_visitor;\n \n-mod astconv;\n+pub mod astconv;\n mod bounds;\n mod check_unused;\n mod coherence;\n-mod collect;\n+// FIXME: This module shouldn't be public.\n+pub mod collect;\n mod constrained_generic_params;\n mod errors;\n pub mod hir_wf_check;\n mod impl_wf_check;\n-mod mem_categorization;\n mod outlives;\n-mod structured_errors;\n+pub mod structured_errors;\n mod variance;\n \n use rustc_errors::{struct_span_err, ErrorGuaranteed};"}, {"sha": "093f9bb84486e267cc72919c00a1f14de33cbf93", "filename": "compiler/rustc_hir_typeck/Cargo.toml", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2FCargo.toml?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -0,0 +1,28 @@\n+[package]\n+name = \"rustc_hir_typeck\"\n+version = \"0.1.0\"\n+edition = \"2021\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]\n+smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n+tracing = \"0.1\"\n+rustc_ast = { path = \"../rustc_ast\" }\n+rustc_data_structures = { path = \"../rustc_data_structures\" }\n+rustc_errors = { path = \"../rustc_errors\" }\n+rustc_graphviz = { path = \"../rustc_graphviz\" }\n+rustc_index = { path = \"../rustc_index\" }\n+rustc_infer = { path = \"../rustc_infer\" }\n+rustc_hir = { path = \"../rustc_hir\" }\n+rustc_hir_analysis = { path = \"../rustc_hir_analysis\" }\n+rustc_hir_pretty = { path = \"../rustc_hir_pretty\" }\n+rustc_lint = { path = \"../rustc_lint\" }\n+rustc_middle = { path = \"../rustc_middle\" }\n+rustc_macros = { path = \"../rustc_macros\" }\n+rustc_serialize = { path = \"../rustc_serialize\" }\n+rustc_session = { path = \"../rustc_session\" }\n+rustc_span = { path = \"../rustc_span\" }\n+rustc_target = { path = \"../rustc_target\" }\n+rustc_trait_selection = { path = \"../rustc_trait_selection\" }\n+rustc_type_ir = { path = \"../rustc_type_ir\" }"}, {"sha": "2b15d4dcd084849def308fecfec0c8f668ebfd2d", "filename": "compiler/rustc_hir_typeck/src/_match.rs", "status": "renamed", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -1,5 +1,5 @@\n-use crate::check::coercion::{AsCoercionSite, CoerceMany};\n-use crate::check::{Diverges, Expectation, FnCtxt, Needs};\n+use crate::coercion::{AsCoercionSite, CoerceMany};\n+use crate::{Diverges, Expectation, FnCtxt, Needs};\n use rustc_errors::{Applicability, MultiSpan};\n use rustc_hir::{self as hir, ExprKind};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n@@ -514,8 +514,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n \n                 for ty in [first_ty, second_ty] {\n-                    for pred in self.tcx.bound_explicit_item_bounds(rpit_def_id).transpose_iter() {\n-                        let pred = pred.map_bound(|(pred, _)| *pred).subst(self.tcx, substs);\n+                    for (pred, _) in self\n+                        .tcx\n+                        .bound_explicit_item_bounds(rpit_def_id)\n+                        .subst_iter_copied(self.tcx, substs)\n+                    {\n                         let pred = match pred.kind().skip_binder() {\n                             ty::PredicateKind::Trait(mut trait_pred) => {\n                                 assert_eq!(trait_pred.trait_ref.self_ty(), opaque_ty);", "previous_filename": "compiler/rustc_hir_analysis/src/check/_match.rs"}, {"sha": "59c366ad7d776cb41868bc18140e042f70ccab60", "filename": "compiler/rustc_hir_typeck/src/autoderef.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fautoderef.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "previous_filename": "compiler/rustc_hir_analysis/src/check/autoderef.rs"}, {"sha": "1b33f2f02b8adf7507c636cadd740c14fff79054", "filename": "compiler/rustc_hir_typeck/src/callee.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -1,8 +1,8 @@\n use super::method::probe::{IsSuggestion, Mode, ProbeScope};\n use super::method::MethodCallee;\n use super::{Expectation, FnCtxt, TupleArgumentsFlag};\n-use crate::type_error_struct;\n \n+use crate::type_error_struct;\n use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_errors::{struct_span_err, Applicability, Diagnostic, StashKey};\n use rustc_hir as hir;", "previous_filename": "compiler/rustc_hir_analysis/src/check/callee.rs"}, {"sha": "0e7576ecf8b0c58db99f94302423f095eec341de", "filename": "compiler/rustc_hir_typeck/src/cast.rs", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -30,9 +30,7 @@\n \n use super::FnCtxt;\n \n-use crate::hir::def_id::DefId;\n use crate::type_error_struct;\n-use hir::def_id::LOCAL_CRATE;\n use rustc_errors::{struct_span_err, Applicability, DelayDm, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_middle::mir::Mutability;\n@@ -43,6 +41,7 @@ use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, Ty, TypeAndMut, TypeVisitable, VariantDef};\n use rustc_session::lint;\n use rustc_session::Session;\n+use rustc_span::def_id::{DefId, LOCAL_CRATE};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n use rustc_trait_selection::infer::InferCtxtExt;\n@@ -527,7 +526,9 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                 err.emit();\n             }\n             CastError::SizedUnsizedCast => {\n-                use crate::structured_errors::{SizedUnsizedCast, StructuredDiagnostic};\n+                use rustc_hir_analysis::structured_errors::{\n+                    SizedUnsizedCast, StructuredDiagnostic,\n+                };\n \n                 SizedUnsizedCast {\n                     sess: &fcx.tcx.sess,", "previous_filename": "compiler/rustc_hir_analysis/src/check/cast.rs"}, {"sha": "7f76364e15a75e2ecc8ae38c64c2c3e336dcfaa2", "filename": "compiler/rustc_hir_typeck/src/check.rs", "status": "added", "additions": 324, "deletions": 0, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -0,0 +1,324 @@\n+use crate::coercion::CoerceMany;\n+use crate::gather_locals::GatherLocalsVisitor;\n+use crate::{FnCtxt, Inherited};\n+use crate::{GeneratorTypes, UnsafetyState};\n+use rustc_hir as hir;\n+use rustc_hir::def::DefKind;\n+use rustc_hir::intravisit::Visitor;\n+use rustc_hir::lang_items::LangItem;\n+use rustc_hir::{ImplicitSelfKind, ItemKind, Node};\n+use rustc_hir_analysis::check::fn_maybe_err;\n+use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc_infer::infer::RegionVariableOrigin;\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_span::def_id::LocalDefId;\n+use rustc_target::spec::abi::Abi;\n+use rustc_trait_selection::traits;\n+use std::cell::RefCell;\n+\n+/// Helper used for fns and closures. Does the grungy work of checking a function\n+/// body and returns the function context used for that purpose, since in the case of a fn item\n+/// there is still a bit more to do.\n+///\n+/// * ...\n+/// * inherited: other fields inherited from the enclosing fn (if any)\n+#[instrument(skip(inherited, body), level = \"debug\")]\n+pub(super) fn check_fn<'a, 'tcx>(\n+    inherited: &'a Inherited<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    fn_sig: ty::FnSig<'tcx>,\n+    decl: &'tcx hir::FnDecl<'tcx>,\n+    fn_id: hir::HirId,\n+    body: &'tcx hir::Body<'tcx>,\n+    can_be_generator: Option<hir::Movability>,\n+    return_type_pre_known: bool,\n+) -> (FnCtxt<'a, 'tcx>, Option<GeneratorTypes<'tcx>>) {\n+    // Create the function context. This is either derived from scratch or,\n+    // in the case of closures, based on the outer context.\n+    let mut fcx = FnCtxt::new(inherited, param_env, body.value.hir_id);\n+    fcx.ps.set(UnsafetyState::function(fn_sig.unsafety, fn_id));\n+    fcx.return_type_pre_known = return_type_pre_known;\n+\n+    let tcx = fcx.tcx;\n+    let hir = tcx.hir();\n+\n+    let declared_ret_ty = fn_sig.output();\n+\n+    let ret_ty =\n+        fcx.register_infer_ok_obligations(fcx.infcx.replace_opaque_types_with_inference_vars(\n+            declared_ret_ty,\n+            body.value.hir_id,\n+            decl.output.span(),\n+            param_env,\n+        ));\n+    // If we replaced declared_ret_ty with infer vars, then we must be inferring\n+    // an opaque type, so set a flag so we can improve diagnostics.\n+    fcx.return_type_has_opaque = ret_ty != declared_ret_ty;\n+\n+    fcx.ret_coercion = Some(RefCell::new(CoerceMany::new(ret_ty)));\n+\n+    let span = body.value.span;\n+\n+    fn_maybe_err(tcx, span, fn_sig.abi);\n+\n+    if fn_sig.abi == Abi::RustCall {\n+        let expected_args = if let ImplicitSelfKind::None = decl.implicit_self { 1 } else { 2 };\n+\n+        let err = || {\n+            let item = match tcx.hir().get(fn_id) {\n+                Node::Item(hir::Item { kind: ItemKind::Fn(header, ..), .. }) => Some(header),\n+                Node::ImplItem(hir::ImplItem {\n+                    kind: hir::ImplItemKind::Fn(header, ..), ..\n+                }) => Some(header),\n+                Node::TraitItem(hir::TraitItem {\n+                    kind: hir::TraitItemKind::Fn(header, ..),\n+                    ..\n+                }) => Some(header),\n+                // Closures are RustCall, but they tuple their arguments, so shouldn't be checked\n+                Node::Expr(hir::Expr { kind: hir::ExprKind::Closure { .. }, .. }) => None,\n+                node => bug!(\"Item being checked wasn't a function/closure: {:?}\", node),\n+            };\n+\n+            if let Some(header) = item {\n+                tcx.sess.span_err(header.span, \"functions with the \\\"rust-call\\\" ABI must take a single non-self argument that is a tuple\");\n+            }\n+        };\n+\n+        if fn_sig.inputs().len() != expected_args {\n+            err()\n+        } else {\n+            // FIXME(CraftSpider) Add a check on parameter expansion, so we don't just make the ICE happen later on\n+            //   This will probably require wide-scale changes to support a TupleKind obligation\n+            //   We can't resolve this without knowing the type of the param\n+            if !matches!(fn_sig.inputs()[expected_args - 1].kind(), ty::Tuple(_) | ty::Param(_)) {\n+                err()\n+            }\n+        }\n+    }\n+\n+    if body.generator_kind.is_some() && can_be_generator.is_some() {\n+        let yield_ty = fcx\n+            .next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::TypeInference, span });\n+        fcx.require_type_is_sized(yield_ty, span, traits::SizedYieldType);\n+\n+        // Resume type defaults to `()` if the generator has no argument.\n+        let resume_ty = fn_sig.inputs().get(0).copied().unwrap_or_else(|| tcx.mk_unit());\n+\n+        fcx.resume_yield_tys = Some((resume_ty, yield_ty));\n+    }\n+\n+    GatherLocalsVisitor::new(&fcx).visit_body(body);\n+\n+    // C-variadic fns also have a `VaList` input that's not listed in `fn_sig`\n+    // (as it's created inside the body itself, not passed in from outside).\n+    let maybe_va_list = if fn_sig.c_variadic {\n+        let span = body.params.last().unwrap().span;\n+        let va_list_did = tcx.require_lang_item(LangItem::VaList, Some(span));\n+        let region = fcx.next_region_var(RegionVariableOrigin::MiscVariable(span));\n+\n+        Some(tcx.bound_type_of(va_list_did).subst(tcx, &[region.into()]))\n+    } else {\n+        None\n+    };\n+\n+    // Add formal parameters.\n+    let inputs_hir = hir.fn_decl_by_hir_id(fn_id).map(|decl| &decl.inputs);\n+    let inputs_fn = fn_sig.inputs().iter().copied();\n+    for (idx, (param_ty, param)) in inputs_fn.chain(maybe_va_list).zip(body.params).enumerate() {\n+        // Check the pattern.\n+        let ty_span = try { inputs_hir?.get(idx)?.span };\n+        fcx.check_pat_top(&param.pat, param_ty, ty_span, false);\n+\n+        // Check that argument is Sized.\n+        // The check for a non-trivial pattern is a hack to avoid duplicate warnings\n+        // for simple cases like `fn foo(x: Trait)`,\n+        // where we would error once on the parameter as a whole, and once on the binding `x`.\n+        if param.pat.simple_ident().is_none() && !tcx.features().unsized_fn_params {\n+            fcx.require_type_is_sized(param_ty, param.pat.span, traits::SizedArgumentType(ty_span));\n+        }\n+\n+        fcx.write_ty(param.hir_id, param_ty);\n+    }\n+\n+    inherited.typeck_results.borrow_mut().liberated_fn_sigs_mut().insert(fn_id, fn_sig);\n+\n+    fcx.in_tail_expr = true;\n+    if let ty::Dynamic(..) = declared_ret_ty.kind() {\n+        // FIXME: We need to verify that the return type is `Sized` after the return expression has\n+        // been evaluated so that we have types available for all the nodes being returned, but that\n+        // requires the coerced evaluated type to be stored. Moving `check_return_expr` before this\n+        // causes unsized errors caused by the `declared_ret_ty` to point at the return expression,\n+        // while keeping the current ordering we will ignore the tail expression's type because we\n+        // don't know it yet. We can't do `check_expr_kind` while keeping `check_return_expr`\n+        // because we will trigger \"unreachable expression\" lints unconditionally.\n+        // Because of all of this, we perform a crude check to know whether the simplest `!Sized`\n+        // case that a newcomer might make, returning a bare trait, and in that case we populate\n+        // the tail expression's type so that the suggestion will be correct, but ignore all other\n+        // possible cases.\n+        fcx.check_expr(&body.value);\n+        fcx.require_type_is_sized(declared_ret_ty, decl.output.span(), traits::SizedReturnType);\n+    } else {\n+        fcx.require_type_is_sized(declared_ret_ty, decl.output.span(), traits::SizedReturnType);\n+        fcx.check_return_expr(&body.value, false);\n+    }\n+    fcx.in_tail_expr = false;\n+\n+    // We insert the deferred_generator_interiors entry after visiting the body.\n+    // This ensures that all nested generators appear before the entry of this generator.\n+    // resolve_generator_interiors relies on this property.\n+    let gen_ty = if let (Some(_), Some(gen_kind)) = (can_be_generator, body.generator_kind) {\n+        let interior = fcx\n+            .next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::MiscVariable, span });\n+        fcx.deferred_generator_interiors.borrow_mut().push((body.id(), interior, gen_kind));\n+\n+        let (resume_ty, yield_ty) = fcx.resume_yield_tys.unwrap();\n+        Some(GeneratorTypes {\n+            resume_ty,\n+            yield_ty,\n+            interior,\n+            movability: can_be_generator.unwrap(),\n+        })\n+    } else {\n+        None\n+    };\n+\n+    // Finalize the return check by taking the LUB of the return types\n+    // we saw and assigning it to the expected return type. This isn't\n+    // really expected to fail, since the coercions would have failed\n+    // earlier when trying to find a LUB.\n+    let coercion = fcx.ret_coercion.take().unwrap().into_inner();\n+    let mut actual_return_ty = coercion.complete(&fcx);\n+    debug!(\"actual_return_ty = {:?}\", actual_return_ty);\n+    if let ty::Dynamic(..) = declared_ret_ty.kind() {\n+        // We have special-cased the case where the function is declared\n+        // `-> dyn Foo` and we don't actually relate it to the\n+        // `fcx.ret_coercion`, so just substitute a type variable.\n+        actual_return_ty =\n+            fcx.next_ty_var(TypeVariableOrigin { kind: TypeVariableOriginKind::DynReturnFn, span });\n+        debug!(\"actual_return_ty replaced with {:?}\", actual_return_ty);\n+    }\n+\n+    // HACK(oli-obk, compiler-errors): We should be comparing this against\n+    // `declared_ret_ty`, but then anything uninferred would be inferred to\n+    // the opaque type itself. That again would cause writeback to assume\n+    // we have a recursive call site and do the sadly stabilized fallback to `()`.\n+    fcx.demand_suptype(span, ret_ty, actual_return_ty);\n+\n+    // Check that a function marked as `#[panic_handler]` has signature `fn(&PanicInfo) -> !`\n+    if let Some(panic_impl_did) = tcx.lang_items().panic_impl()\n+        && panic_impl_did == hir.local_def_id(fn_id).to_def_id()\n+    {\n+        check_panic_info_fn(tcx, panic_impl_did.expect_local(), fn_sig, decl, declared_ret_ty);\n+    }\n+\n+    // Check that a function marked as `#[alloc_error_handler]` has signature `fn(Layout) -> !`\n+    if let Some(alloc_error_handler_did) = tcx.lang_items().oom()\n+        && alloc_error_handler_did == hir.local_def_id(fn_id).to_def_id()\n+    {\n+        check_alloc_error_fn(tcx, alloc_error_handler_did.expect_local(), fn_sig, decl, declared_ret_ty);\n+    }\n+\n+    (fcx, gen_ty)\n+}\n+\n+fn check_panic_info_fn(\n+    tcx: TyCtxt<'_>,\n+    fn_id: LocalDefId,\n+    fn_sig: ty::FnSig<'_>,\n+    decl: &hir::FnDecl<'_>,\n+    declared_ret_ty: Ty<'_>,\n+) {\n+    let Some(panic_info_did) = tcx.lang_items().panic_info() else {\n+        tcx.sess.err(\"language item required, but not found: `panic_info`\");\n+        return;\n+    };\n+\n+    if *declared_ret_ty.kind() != ty::Never {\n+        tcx.sess.span_err(decl.output.span(), \"return type should be `!`\");\n+    }\n+\n+    let inputs = fn_sig.inputs();\n+    if inputs.len() != 1 {\n+        tcx.sess.span_err(tcx.def_span(fn_id), \"function should have one argument\");\n+        return;\n+    }\n+\n+    let arg_is_panic_info = match *inputs[0].kind() {\n+        ty::Ref(region, ty, mutbl) => match *ty.kind() {\n+            ty::Adt(ref adt, _) => {\n+                adt.did() == panic_info_did && mutbl == hir::Mutability::Not && !region.is_static()\n+            }\n+            _ => false,\n+        },\n+        _ => false,\n+    };\n+\n+    if !arg_is_panic_info {\n+        tcx.sess.span_err(decl.inputs[0].span, \"argument should be `&PanicInfo`\");\n+    }\n+\n+    let DefKind::Fn = tcx.def_kind(fn_id) else {\n+        let span = tcx.def_span(fn_id);\n+        tcx.sess.span_err(span, \"should be a function\");\n+        return;\n+    };\n+\n+    let generic_counts = tcx.generics_of(fn_id).own_counts();\n+    if generic_counts.types != 0 {\n+        let span = tcx.def_span(fn_id);\n+        tcx.sess.span_err(span, \"should have no type parameters\");\n+    }\n+    if generic_counts.consts != 0 {\n+        let span = tcx.def_span(fn_id);\n+        tcx.sess.span_err(span, \"should have no const parameters\");\n+    }\n+}\n+\n+fn check_alloc_error_fn(\n+    tcx: TyCtxt<'_>,\n+    fn_id: LocalDefId,\n+    fn_sig: ty::FnSig<'_>,\n+    decl: &hir::FnDecl<'_>,\n+    declared_ret_ty: Ty<'_>,\n+) {\n+    let Some(alloc_layout_did) = tcx.lang_items().alloc_layout() else {\n+        tcx.sess.err(\"language item required, but not found: `alloc_layout`\");\n+        return;\n+    };\n+\n+    if *declared_ret_ty.kind() != ty::Never {\n+        tcx.sess.span_err(decl.output.span(), \"return type should be `!`\");\n+    }\n+\n+    let inputs = fn_sig.inputs();\n+    if inputs.len() != 1 {\n+        tcx.sess.span_err(tcx.def_span(fn_id), \"function should have one argument\");\n+        return;\n+    }\n+\n+    let arg_is_alloc_layout = match inputs[0].kind() {\n+        ty::Adt(ref adt, _) => adt.did() == alloc_layout_did,\n+        _ => false,\n+    };\n+\n+    if !arg_is_alloc_layout {\n+        tcx.sess.span_err(decl.inputs[0].span, \"argument should be `Layout`\");\n+    }\n+\n+    let DefKind::Fn = tcx.def_kind(fn_id) else {\n+        let span = tcx.def_span(fn_id);\n+        tcx.sess.span_err(span, \"`#[alloc_error_handler]` should be a function\");\n+        return;\n+    };\n+\n+    let generic_counts = tcx.generics_of(fn_id).own_counts();\n+    if generic_counts.types != 0 {\n+        let span = tcx.def_span(fn_id);\n+        tcx.sess.span_err(span, \"`#[alloc_error_handler]` function should have no type parameters\");\n+    }\n+    if generic_counts.consts != 0 {\n+        let span = tcx.def_span(fn_id);\n+        tcx.sess\n+            .span_err(span, \"`#[alloc_error_handler]` function should have no const parameters\");\n+    }\n+}"}, {"sha": "a5a45f75e0e240c25a0ec8fb1bcad01d5b6dfa14", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "renamed", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -2,11 +2,11 @@\n \n use super::{check_fn, Expectation, FnCtxt, GeneratorTypes};\n \n-use crate::astconv::AstConv;\n use hir::def::DefKind;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n+use rustc_hir_analysis::astconv::AstConv;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::LateBoundRegionConversionTime;\n use rustc_infer::infer::{InferOk, InferResult};\n@@ -176,24 +176,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         match *expected_ty.kind() {\n             ty::Opaque(def_id, substs) => {\n                 let bounds = self.tcx.bound_explicit_item_bounds(def_id);\n-                let sig = bounds\n-                    .transpose_iter()\n-                    .map(|e| e.map_bound(|e| *e).transpose_tuple2())\n-                    .find_map(|(pred, span)| match pred.0.kind().skip_binder() {\n+                let sig =\n+                    bounds.subst_iter_copied(self.tcx, substs).find_map(|(pred, span)| match pred\n+                        .kind()\n+                        .skip_binder()\n+                    {\n                         ty::PredicateKind::Projection(proj_predicate) => self\n                             .deduce_sig_from_projection(\n-                                Some(span.0),\n-                                pred.0\n-                                    .kind()\n-                                    .rebind(pred.rebind(proj_predicate).subst(self.tcx, substs)),\n+                                Some(span),\n+                                pred.kind().rebind(proj_predicate),\n                             ),\n                         _ => None,\n                     });\n \n                 let kind = bounds\n-                    .transpose_iter()\n-                    .map(|e| e.map_bound(|e| *e).transpose_tuple2())\n-                    .filter_map(|(pred, _)| match pred.0.kind().skip_binder() {\n+                    .0\n+                    .iter()\n+                    .filter_map(|(pred, _)| match pred.kind().skip_binder() {\n                         ty::PredicateKind::Trait(tp) => {\n                             self.tcx.fn_trait_kind_from_lang_item(tp.def_id())\n                         }\n@@ -697,18 +696,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ty::Opaque(def_id, substs) => self\n                 .tcx\n                 .bound_explicit_item_bounds(def_id)\n-                .transpose_iter()\n-                .map(|e| e.map_bound(|e| *e).transpose_tuple2())\n-                .find_map(|(p, s)| get_future_output(p.subst(self.tcx, substs), s.0))?,\n+                .subst_iter_copied(self.tcx, substs)\n+                .find_map(|(p, s)| get_future_output(p, s))?,\n             ty::Error(_) => return None,\n             ty::Projection(proj)\n                 if self.tcx.def_kind(proj.item_def_id) == DefKind::ImplTraitPlaceholder =>\n             {\n                 self.tcx\n                     .bound_explicit_item_bounds(proj.item_def_id)\n-                    .transpose_iter()\n-                    .map(|e| e.map_bound(|e| *e).transpose_tuple2())\n-                    .find_map(|(p, s)| get_future_output(p.subst(self.tcx, proj.substs), s.0))?\n+                    .subst_iter_copied(self.tcx, proj.substs)\n+                    .find_map(|(p, s)| get_future_output(p, s))?\n             }\n             _ => span_bug!(\n                 self.tcx.def_span(expr_def_id),", "previous_filename": "compiler/rustc_hir_analysis/src/check/closure.rs"}, {"sha": "86597a703e833810dafaa5f4a25062d7bbd67a6a", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -35,15 +35,15 @@\n //! // and are then unable to coerce `&7i32` to `&mut i32`.\n //! ```\n \n-use crate::astconv::AstConv;\n-use crate::check::FnCtxt;\n+use crate::FnCtxt;\n use rustc_errors::{\n     struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, MultiSpan,\n };\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::Expr;\n+use rustc_hir_analysis::astconv::AstConv;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{Coercion, InferOk, InferResult};\n use rustc_infer::traits::{Obligation, TraitEngine, TraitEngineExt};", "previous_filename": "compiler/rustc_hir_analysis/src/check/coercion.rs"}, {"sha": "2974ac97f2368fc4dea7598c758061c3a438a2b6", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "renamed", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -1,21 +1,20 @@\n-use crate::check::FnCtxt;\n-use rustc_infer::infer::InferOk;\n-use rustc_middle::middle::stability::EvalResult;\n-use rustc_trait_selection::infer::InferCtxtExt as _;\n-use rustc_trait_selection::traits::ObligationCause;\n-\n+use crate::FnCtxt;\n use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{is_range_literal, Node};\n+use rustc_infer::infer::InferOk;\n use rustc_middle::lint::in_external_macro;\n+use rustc_middle::middle::stability::EvalResult;\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self, Article, AssocItem, Ty, TypeAndMut};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{BytePos, Span};\n+use rustc_trait_selection::infer::InferCtxtExt as _;\n+use rustc_trait_selection::traits::ObligationCause;\n \n use super::method::probe;\n ", "previous_filename": "compiler/rustc_hir_analysis/src/check/demand.rs"}, {"sha": "963a93a95c2bbc386dd026010593d883e6d621f9", "filename": "compiler/rustc_hir_typeck/src/diverges.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fdiverges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fdiverges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdiverges.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "previous_filename": "compiler/rustc_hir_analysis/src/check/diverges.rs"}, {"sha": "175037f9b3a14791288ac72370bed988fc7afc2d", "filename": "compiler/rustc_hir_typeck/src/errors.rs", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -0,0 +1,126 @@\n+//! Errors emitted by `rustc_hir_analysis`.\n+use rustc_macros::{Diagnostic, Subdiagnostic};\n+use rustc_middle::ty::Ty;\n+use rustc_span::{symbol::Ident, Span};\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_field_multiply_specified_in_initializer, code = \"E0062\")]\n+pub struct FieldMultiplySpecifiedInInitializer {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[label(previous_use_label)]\n+    pub prev_span: Span,\n+    pub ident: Ident,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_return_stmt_outside_of_fn_body, code = \"E0572\")]\n+pub struct ReturnStmtOutsideOfFnBody {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label(encl_body_label)]\n+    pub encl_body_span: Option<Span>,\n+    #[label(encl_fn_label)]\n+    pub encl_fn_span: Option<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_yield_expr_outside_of_generator, code = \"E0627\")]\n+pub struct YieldExprOutsideOfGenerator {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_struct_expr_non_exhaustive, code = \"E0639\")]\n+pub struct StructExprNonExhaustive {\n+    #[primary_span]\n+    pub span: Span,\n+    pub what: &'static str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_method_call_on_unknown_type, code = \"E0699\")]\n+pub struct MethodCallOnUnknownType {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_functional_record_update_on_non_struct, code = \"E0436\")]\n+pub struct FunctionalRecordUpdateOnNonStruct {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_address_of_temporary_taken, code = \"E0745\")]\n+pub struct AddressOfTemporaryTaken {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum AddReturnTypeSuggestion {\n+    #[suggestion(\n+        hir_analysis_add_return_type_add,\n+        code = \"-> {found} \",\n+        applicability = \"machine-applicable\"\n+    )]\n+    Add {\n+        #[primary_span]\n+        span: Span,\n+        found: String,\n+    },\n+    #[suggestion(\n+        hir_analysis_add_return_type_missing_here,\n+        code = \"-> _ \",\n+        applicability = \"has-placeholders\"\n+    )]\n+    MissingHere {\n+        #[primary_span]\n+        span: Span,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum ExpectedReturnTypeLabel<'tcx> {\n+    #[label(hir_analysis_expected_default_return_type)]\n+    Unit {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[label(hir_analysis_expected_return_type)]\n+    Other {\n+        #[primary_span]\n+        span: Span,\n+        expected: Ty<'tcx>,\n+    },\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_missing_parentheses_in_range, code = \"E0689\")]\n+pub struct MissingParentheseInRange {\n+    #[primary_span]\n+    #[label(hir_analysis_missing_parentheses_in_range)]\n+    pub span: Span,\n+    pub ty_str: String,\n+    pub method_name: String,\n+    #[subdiagnostic]\n+    pub add_missing_parentheses: Option<AddMissingParenthesesInRange>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion_verbose(\n+    hir_analysis_add_missing_parentheses_in_range,\n+    applicability = \"maybe-incorrect\"\n+)]\n+pub struct AddMissingParenthesesInRange {\n+    pub func_name: String,\n+    #[suggestion_part(code = \"(\")]\n+    pub left: Span,\n+    #[suggestion_part(code = \")\")]\n+    pub right: Span,\n+}"}, {"sha": "e9e810344776b963d52a0eeb85fbd6ecbcc8c376", "filename": "compiler/rustc_hir_typeck/src/expectation.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpectation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpectation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpectation.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "previous_filename": "compiler/rustc_hir_analysis/src/check/expectation.rs"}, {"sha": "41b00fda03ebfffc399ed750cc54b1399e3e1d2f", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "renamed", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -2,23 +2,22 @@\n //!\n //! See `mod.rs` for more context on type checking in general.\n \n-use crate::astconv::AstConv as _;\n-use crate::check::cast;\n-use crate::check::coercion::CoerceMany;\n-use crate::check::fatally_break_rust;\n-use crate::check::method::SelfSource;\n-use crate::check::Expectation::{self, ExpectCastableToType, ExpectHasType, NoExpectation};\n-use crate::check::{\n-    report_unexpected_variant_res, BreakableCtxt, Diverges, DynamicCoerceMany, FnCtxt, Needs,\n-    TupleArgumentsFlag::DontTupleArguments,\n-};\n+use crate::cast;\n+use crate::coercion::CoerceMany;\n+use crate::coercion::DynamicCoerceMany;\n+use crate::errors::{AddressOfTemporaryTaken, ReturnStmtOutsideOfFnBody, StructExprNonExhaustive};\n use crate::errors::{\n     FieldMultiplySpecifiedInInitializer, FunctionalRecordUpdateOnNonStruct,\n     YieldExprOutsideOfGenerator,\n };\n+use crate::fatally_break_rust;\n+use crate::method::SelfSource;\n use crate::type_error_struct;\n-\n-use crate::errors::{AddressOfTemporaryTaken, ReturnStmtOutsideOfFnBody, StructExprNonExhaustive};\n+use crate::Expectation::{self, ExpectCastableToType, ExpectHasType, NoExpectation};\n+use crate::{\n+    report_unexpected_variant_res, BreakableCtxt, Diverges, FnCtxt, Needs,\n+    TupleArgumentsFlag::DontTupleArguments,\n+};\n use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n@@ -32,6 +31,8 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{Closure, ExprKind, HirId, QPath};\n+use rustc_hir_analysis::astconv::AstConv as _;\n+use rustc_hir_analysis::check::ty_kind_suggestion;\n use rustc_infer::infer;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::InferOk;\n@@ -1362,7 +1363,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Create a new function context.\n         let fcx = FnCtxt::new(self, self.param_env.with_const(), body.value.hir_id);\n-        crate::check::GatherLocalsVisitor::new(&fcx).visit_body(body);\n+        crate::GatherLocalsVisitor::new(&fcx).visit_body(body);\n \n         let ty = fcx.check_expr_with_expectation(&body.value, expected);\n         fcx.require_type_is_sized(ty, body.value.span, traits::ConstSized);\n@@ -2885,14 +2886,3 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n }\n-\n-pub(super) fn ty_kind_suggestion(ty: Ty<'_>) -> Option<&'static str> {\n-    Some(match ty.kind() {\n-        ty::Bool => \"true\",\n-        ty::Char => \"'a'\",\n-        ty::Int(_) | ty::Uint(_) => \"42\",\n-        ty::Float(_) => \"3.14159\",\n-        ty::Error(_) | ty::Never => return None,\n-        _ => \"value\",\n-    })\n-}", "previous_filename": "compiler/rustc_hir_analysis/src/check/expr.rs"}, {"sha": "fce2a5888ba24fe8fd710764b64ab644d130c58f", "filename": "compiler/rustc_hir_typeck/src/expr_use_visitor.rs", "status": "renamed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -89,15 +89,6 @@ enum ConsumeMode {\n     Move,\n }\n \n-#[derive(Copy, Clone, PartialEq, Debug)]\n-pub enum MutateMode {\n-    Init,\n-    /// Example: `x = y`\n-    JustWrite,\n-    /// Example: `x += y`\n-    WriteAndRead,\n-}\n-\n /// The ExprUseVisitor type\n ///\n /// This is the code that actually walks the tree.", "previous_filename": "compiler/rustc_hir_analysis/src/expr_use_visitor.rs"}, {"sha": "747ecb036b2a15c7e3bb5183d03850eb6f3fa5a6", "filename": "compiler/rustc_hir_typeck/src/fallback.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Ffallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Ffallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffallback.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -1,4 +1,4 @@\n-use crate::check::FnCtxt;\n+use crate::FnCtxt;\n use rustc_data_structures::{\n     fx::{FxHashMap, FxHashSet},\n     graph::WithSuccessors,", "previous_filename": "compiler/rustc_hir_analysis/src/check/fallback.rs"}, {"sha": "6a1cffe3e6025186e8f4985a53ab29e49874a1bf", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "renamed", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -1,12 +1,7 @@\n-use crate::astconv::{\n-    AstConv, CreateSubstsForGenericArgsCtxt, ExplicitLateBound, GenericArgCountMismatch,\n-    GenericArgCountResult, IsMethodCall, PathSeg,\n-};\n-use crate::check::callee::{self, DeferredCallResolution};\n-use crate::check::method::{self, MethodCallee, SelfSource};\n-use crate::check::rvalue_scopes;\n-use crate::check::{BreakableCtxt, Diverges, Expectation, FnCtxt, LocalTy};\n-\n+use crate::callee::{self, DeferredCallResolution};\n+use crate::method::{self, MethodCallee, SelfSource};\n+use crate::rvalue_scopes;\n+use crate::{BreakableCtxt, Diverges, Expectation, FnCtxt, LocalTy};\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{Applicability, Diagnostic, ErrorGuaranteed, MultiSpan};\n@@ -15,6 +10,10 @@ use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{ExprKind, GenericArg, Node, QPath};\n+use rustc_hir_analysis::astconv::{\n+    AstConv, CreateSubstsForGenericArgsCtxt, ExplicitLateBound, GenericArgCountMismatch,\n+    GenericArgCountResult, IsMethodCall, PathSeg,\n+};\n use rustc_infer::infer::canonical::{Canonical, OriginalQueryValues, QueryResponse};\n use rustc_infer::infer::error_reporting::TypeAnnotationNeeded::E0282;\n use rustc_infer::infer::{InferOk, InferResult};\n@@ -603,9 +602,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut generators = self.deferred_generator_interiors.borrow_mut();\n         for (body_id, interior, kind) in generators.drain(..) {\n             self.select_obligations_where_possible(false, |_| {});\n-            crate::check::generator_interior::resolve_interior(\n-                self, def_id, body_id, interior, kind,\n-            );\n+            crate::generator_interior::resolve_interior(self, def_id, body_id, interior, kind);\n         }\n     }\n ", "previous_filename": "compiler/rustc_hir_analysis/src/check/fn_ctxt/_impl.rs"}, {"sha": "fc83994caf53966aff1ba74745ca44856349f233", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/arg_matrix.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Farg_matrix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Farg_matrix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Farg_matrix.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "previous_filename": "compiler/rustc_hir_analysis/src/check/fn_ctxt/arg_matrix.rs"}, {"sha": "08a3cbccfb05e6e25b80dbf18c2177c3f8b5d4a1", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "renamed", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -1,26 +1,24 @@\n-use crate::astconv::AstConv;\n-use crate::check::coercion::CoerceMany;\n-use crate::check::fn_ctxt::arg_matrix::{\n-    ArgMatrix, Compatibility, Error, ExpectedIdx, ProvidedIdx,\n+use crate::coercion::CoerceMany;\n+use crate::fn_ctxt::arg_matrix::{ArgMatrix, Compatibility, Error, ExpectedIdx, ProvidedIdx};\n+use crate::gather_locals::Declaration;\n+use crate::method::MethodCallee;\n+use crate::Expectation::*;\n+use crate::TupleArgumentsFlag::*;\n+use crate::{\n+    struct_span_err, BreakableCtxt, Diverges, Expectation, FnCtxt, LocalTy, Needs,\n+    TupleArgumentsFlag,\n };\n-use crate::check::gather_locals::Declaration;\n-use crate::check::intrinsicck::InlineAsmCtxt;\n-use crate::check::method::MethodCallee;\n-use crate::check::Expectation::*;\n-use crate::check::TupleArgumentsFlag::*;\n-use crate::check::{\n-    potentially_plural_count, struct_span_err, BreakableCtxt, Diverges, Expectation, FnCtxt,\n-    LocalTy, Needs, TupleArgumentsFlag,\n-};\n-use crate::structured_errors::StructuredDiagnostic;\n-\n use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{pluralize, Applicability, Diagnostic, DiagnosticId, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::{ExprKind, Node, QPath};\n+use rustc_hir_analysis::astconv::AstConv;\n+use rustc_hir_analysis::check::intrinsicck::InlineAsmCtxt;\n+use rustc_hir_analysis::check::potentially_plural_count;\n+use rustc_hir_analysis::structured_errors::StructuredDiagnostic;\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::error_reporting::{FailureCode, ObligationCauseExt};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n@@ -391,7 +389,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     ty: Ty<'tcx>,\n                     cast_ty: &str,\n                 ) {\n-                    use crate::structured_errors::MissingCastForVariadicArg;\n+                    use rustc_hir_analysis::structured_errors::MissingCastForVariadicArg;\n \n                     MissingCastForVariadicArg { sess, span, ty, cast_ty }.diagnostic().emit();\n                 }", "previous_filename": "compiler/rustc_hir_analysis/src/check/fn_ctxt/checks.rs"}, {"sha": "0c600daf4459e8e6886f6042f927eb4b2e78a549", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/mod.rs", "status": "renamed", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -6,12 +6,11 @@ mod suggestions;\n pub use _impl::*;\n pub use suggestions::*;\n \n-use crate::astconv::AstConv;\n-use crate::check::coercion::DynamicCoerceMany;\n-use crate::check::{Diverges, EnclosingBreakables, Inherited, UnsafetyState};\n-\n+use crate::coercion::DynamicCoerceMany;\n+use crate::{Diverges, EnclosingBreakables, Inherited, UnsafetyState};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n+use rustc_hir_analysis::astconv::AstConv;\n use rustc_infer::infer;\n use rustc_infer::infer::error_reporting::TypeErrCtxt;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n@@ -36,7 +35,7 @@ use std::ops::Deref;\n ///\n /// See [`ItemCtxt`]'s docs for more.\n ///\n-/// [`ItemCtxt`]: crate::collect::ItemCtxt\n+/// [`ItemCtxt`]: rustc_hir_analysis::collect::ItemCtxt\n /// [`InferCtxt`]: infer::InferCtxt\n pub struct FnCtxt<'a, 'tcx> {\n     pub(super) body_id: hir::HirId,", "previous_filename": "compiler/rustc_hir_analysis/src/check/fn_ctxt/mod.rs"}, {"sha": "cd2e41aff0f124818e211e9d8a70f0fd214ca0e0", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -1,7 +1,6 @@\n use super::FnCtxt;\n-use crate::astconv::AstConv;\n-use crate::errors::{AddReturnTypeSuggestion, ExpectedReturnTypeLabel};\n \n+use crate::errors::{AddReturnTypeSuggestion, ExpectedReturnTypeLabel};\n use rustc_ast::util::parser::{ExprPrecedence, PREC_POSTFIX};\n use rustc_errors::{Applicability, Diagnostic, MultiSpan};\n use rustc_hir as hir;\n@@ -10,6 +9,7 @@ use rustc_hir::lang_items::LangItem;\n use rustc_hir::{\n     Expr, ExprKind, GenericBound, Node, Path, QPath, Stmt, StmtKind, TyKind, WherePredicate,\n };\n+use rustc_hir_analysis::astconv::AstConv;\n use rustc_infer::infer::{self, TyCtxtInferExt};\n use rustc_infer::traits::{self, StatementAsExpression};\n use rustc_middle::lint::in_external_macro;", "previous_filename": "compiler/rustc_hir_analysis/src/check/fn_ctxt/suggestions.rs"}, {"sha": "9a096f24fac0d965d39546ceaf52e4e529e33f27", "filename": "compiler/rustc_hir_typeck/src/gather_locals.rs", "status": "renamed", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fgather_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fgather_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgather_locals.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -1,9 +1,10 @@\n-use crate::check::{FnCtxt, LocalTy, UserType};\n+use crate::{FnCtxt, LocalTy};\n use rustc_hir as hir;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::PatKind;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_middle::ty::Ty;\n+use rustc_middle::ty::UserType;\n use rustc_span::Span;\n use rustc_trait_selection::traits;\n ", "previous_filename": "compiler/rustc_hir_analysis/src/check/gather_locals.rs"}, {"sha": "122ad7009cb497181c76386740de783fb4ad0001", "filename": "compiler/rustc_hir_typeck/src/generator_interior/drop_ranges/cfg_build.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "previous_filename": "compiler/rustc_hir_analysis/src/check/generator_interior/drop_ranges/cfg_build.rs"}, {"sha": "139d17d2e1ca186d72705afb98d310597a1c09f5", "filename": "compiler/rustc_hir_typeck/src/generator_interior/drop_ranges/cfg_propagate.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_propagate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_propagate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_propagate.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "previous_filename": "compiler/rustc_hir_analysis/src/check/generator_interior/drop_ranges/cfg_propagate.rs"}, {"sha": "c0a0bfe8e1c00a98cb53dd41b5d1e6e9bb7ba82c", "filename": "compiler/rustc_hir_typeck/src/generator_interior/drop_ranges/cfg_visualize.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_visualize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_visualize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_visualize.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "previous_filename": "compiler/rustc_hir_analysis/src/check/generator_interior/drop_ranges/cfg_visualize.rs"}, {"sha": "4f3bdfbe758d90936d807041631fb66aea37422f", "filename": "compiler/rustc_hir_typeck/src/generator_interior/drop_ranges/mod.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fmod.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -14,7 +14,7 @@\n \n use self::cfg_build::build_control_flow_graph;\n use self::record_consumed_borrow::find_consumed_and_borrowed;\n-use crate::check::FnCtxt;\n+use crate::FnCtxt;\n use hir::def_id::DefId;\n use hir::{Body, HirId, HirIdMap, Node};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};", "previous_filename": "compiler/rustc_hir_analysis/src/check/generator_interior/drop_ranges.rs"}, {"sha": "bfe95852aa7b408cd22fc5f6912064fe2eebd67b", "filename": "compiler/rustc_hir_typeck/src/generator_interior/drop_ranges/record_consumed_borrow.rs", "status": "renamed", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -1,13 +1,16 @@\n use super::TrackedValue;\n use crate::{\n-    check::FnCtxt,\n     expr_use_visitor::{self, ExprUseVisitor},\n+    FnCtxt,\n };\n use hir::{def_id::DefId, Body, HirId, HirIdMap};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n-use rustc_middle::hir::place::{PlaceBase, Projection, ProjectionKind};\n use rustc_middle::ty::{ParamEnv, TyCtxt};\n+use rustc_middle::{\n+    hir::place::{PlaceBase, Projection, ProjectionKind},\n+    ty::TypeVisitable,\n+};\n \n pub(super) fn find_consumed_and_borrowed<'a, 'tcx>(\n     fcx: &'a FnCtxt<'a, 'tcx>,\n@@ -198,11 +201,13 @@ impl<'tcx> expr_use_visitor::Delegate<'tcx> for ExprUseDelegate<'tcx> {\n \n         // If the type being assigned needs dropped, then the mutation counts as a borrow\n         // since it is essentially doing `Drop::drop(&mut x); x = new_value;`.\n-        //\n-        // FIXME(drop-tracking): We need to be more responsible about inference\n-        // variables here, since `needs_drop` is a \"raw\" type query, i.e. it\n-        // basically requires types to have been fully resolved.\n-        if assignee_place.place.base_ty.needs_drop(self.tcx, self.param_env) {\n+        let ty = self.tcx.erase_regions(assignee_place.place.base_ty);\n+        if ty.needs_infer() {\n+            self.tcx.sess.delay_span_bug(\n+                self.tcx.hir().span(assignee_place.hir_id),\n+                &format!(\"inference variables in {ty}\"),\n+            );\n+        } else if ty.needs_drop(self.tcx, self.param_env) {\n             self.places\n                 .borrowed\n                 .insert(TrackedValue::from_place_with_projections_allowed(assignee_place));", "previous_filename": "compiler/rustc_hir_analysis/src/check/generator_interior/drop_ranges/record_consumed_borrow.rs"}, {"sha": "b7dd599cd432183b00f9a1233afd83a6bdd03783", "filename": "compiler/rustc_hir_typeck/src/generator_interior/mod.rs", "status": "renamed", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fmod.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -377,15 +377,6 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n         debug!(\"is_borrowed_temporary: {:?}\", self.drop_ranges.is_borrowed_temporary(expr));\n \n         let ty = self.fcx.typeck_results.borrow().expr_ty_adjusted_opt(expr);\n-        let may_need_drop = |ty: Ty<'tcx>| {\n-            // Avoid ICEs in needs_drop.\n-            let ty = self.fcx.resolve_vars_if_possible(ty);\n-            let ty = self.fcx.tcx.erase_regions(ty);\n-            if ty.needs_infer() {\n-                return true;\n-            }\n-            ty.needs_drop(self.fcx.tcx, self.fcx.param_env)\n-        };\n \n         // Typically, the value produced by an expression is consumed by its parent in some way,\n         // so we only have to check if the parent contains a yield (note that the parent may, for\n@@ -403,9 +394,18 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n         // src/test/ui/generator/drop-tracking-parent-expression.rs.\n         let scope = if self.drop_ranges.is_borrowed_temporary(expr)\n             || ty.map_or(true, |ty| {\n-                let needs_drop = may_need_drop(ty);\n-                debug!(?needs_drop, ?ty);\n-                needs_drop\n+                // Avoid ICEs in needs_drop.\n+                let ty = self.fcx.resolve_vars_if_possible(ty);\n+                let ty = self.fcx.tcx.erase_regions(ty);\n+                if ty.needs_infer() {\n+                    self.fcx\n+                        .tcx\n+                        .sess\n+                        .delay_span_bug(expr.span, &format!(\"inference variables in {ty}\"));\n+                    true\n+                } else {\n+                    ty.needs_drop(self.fcx.tcx, self.fcx.param_env)\n+                }\n             }) {\n             self.rvalue_scopes.temporary_scope(self.region_scope_tree, expr.hir_id.local_id)\n         } else {", "previous_filename": "compiler/rustc_hir_analysis/src/check/generator_interior.rs"}, {"sha": "0fb7651b3a1e1decbabc188f605e718ed56367c8", "filename": "compiler/rustc_hir_typeck/src/inherited.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "previous_filename": "compiler/rustc_hir_analysis/src/check/inherited.rs"}, {"sha": "9812d96fcc3c7eec6f125fb68ad6080d7486ce36", "filename": "compiler/rustc_hir_typeck/src/intrinsicck.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fintrinsicck.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -0,0 +1,108 @@\n+use hir::HirId;\n+use rustc_errors::struct_span_err;\n+use rustc_hir as hir;\n+use rustc_index::vec::Idx;\n+use rustc_middle::ty::layout::{LayoutError, SizeSkeleton};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_target::abi::{Pointer, VariantIdx};\n+\n+use super::FnCtxt;\n+\n+/// If the type is `Option<T>`, it will return `T`, otherwise\n+/// the type itself. Works on most `Option`-like types.\n+fn unpack_option_like<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    let ty::Adt(def, substs) = *ty.kind() else { return ty };\n+\n+    if def.variants().len() == 2 && !def.repr().c() && def.repr().int.is_none() {\n+        let data_idx;\n+\n+        let one = VariantIdx::new(1);\n+        let zero = VariantIdx::new(0);\n+\n+        if def.variant(zero).fields.is_empty() {\n+            data_idx = one;\n+        } else if def.variant(one).fields.is_empty() {\n+            data_idx = zero;\n+        } else {\n+            return ty;\n+        }\n+\n+        if def.variant(data_idx).fields.len() == 1 {\n+            return def.variant(data_idx).fields[0].ty(tcx, substs);\n+        }\n+    }\n+\n+    ty\n+}\n+\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    pub fn check_transmute(&self, from: Ty<'tcx>, to: Ty<'tcx>, hir_id: HirId) {\n+        let tcx = self.tcx;\n+        let span = tcx.hir().span(hir_id);\n+        let normalize = |ty| {\n+            let ty = self.resolve_vars_if_possible(ty);\n+            self.tcx.normalize_erasing_regions(self.param_env, ty)\n+        };\n+        let from = normalize(from);\n+        let to = normalize(to);\n+        trace!(?from, ?to);\n+\n+        // Transmutes that are only changing lifetimes are always ok.\n+        if from == to {\n+            return;\n+        }\n+\n+        let skel = |ty| SizeSkeleton::compute(ty, tcx, self.param_env);\n+        let sk_from = skel(from);\n+        let sk_to = skel(to);\n+        trace!(?sk_from, ?sk_to);\n+\n+        // Check for same size using the skeletons.\n+        if let (Ok(sk_from), Ok(sk_to)) = (sk_from, sk_to) {\n+            if sk_from.same_size(sk_to) {\n+                return;\n+            }\n+\n+            // Special-case transmuting from `typeof(function)` and\n+            // `Option<typeof(function)>` to present a clearer error.\n+            let from = unpack_option_like(tcx, from);\n+            if let (&ty::FnDef(..), SizeSkeleton::Known(size_to)) = (from.kind(), sk_to) && size_to == Pointer.size(&tcx) {\n+                struct_span_err!(tcx.sess, span, E0591, \"can't transmute zero-sized type\")\n+                    .note(&format!(\"source type: {from}\"))\n+                    .note(&format!(\"target type: {to}\"))\n+                    .help(\"cast with `as` to a pointer instead\")\n+                    .emit();\n+                return;\n+            }\n+        }\n+\n+        // Try to display a sensible error with as much information as possible.\n+        let skeleton_string = |ty: Ty<'tcx>, sk| match sk {\n+            Ok(SizeSkeleton::Known(size)) => format!(\"{} bits\", size.bits()),\n+            Ok(SizeSkeleton::Pointer { tail, .. }) => format!(\"pointer to `{tail}`\"),\n+            Err(LayoutError::Unknown(bad)) => {\n+                if bad == ty {\n+                    \"this type does not have a fixed size\".to_owned()\n+                } else {\n+                    format!(\"size can vary because of {bad}\")\n+                }\n+            }\n+            Err(err) => err.to_string(),\n+        };\n+\n+        let mut err = struct_span_err!(\n+            tcx.sess,\n+            span,\n+            E0512,\n+            \"cannot transmute between types of different sizes, \\\n+                                        or dependently-sized types\"\n+        );\n+        if from == to {\n+            err.note(&format!(\"`{from}` does not have a fixed size\"));\n+        } else {\n+            err.note(&format!(\"source type: `{}` ({})\", from, skeleton_string(from, sk_from)))\n+                .note(&format!(\"target type: `{}` ({})\", to, skeleton_string(to, sk_to)));\n+        }\n+        err.emit();\n+    }\n+}"}, {"sha": "e862d577573b44808dbb5b4cf977d021d1386391", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "added", "additions": 507, "deletions": 0, "changes": 507, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -0,0 +1,507 @@\n+#![feature(if_let_guard)]\n+#![feature(let_chains)]\n+#![feature(try_blocks)]\n+#![feature(never_type)]\n+#![feature(min_specialization)]\n+#![feature(control_flow_enum)]\n+#![feature(drain_filter)]\n+#![allow(rustc::potential_query_instability)]\n+#![recursion_limit = \"256\"]\n+\n+#[macro_use]\n+extern crate tracing;\n+\n+#[macro_use]\n+extern crate rustc_middle;\n+\n+mod _match;\n+mod autoderef;\n+mod callee;\n+// Used by clippy;\n+pub mod cast;\n+mod check;\n+mod closure;\n+mod coercion;\n+mod demand;\n+mod diverges;\n+mod errors;\n+mod expectation;\n+mod expr;\n+// Used by clippy;\n+pub mod expr_use_visitor;\n+mod fallback;\n+mod fn_ctxt;\n+mod gather_locals;\n+mod generator_interior;\n+mod inherited;\n+mod intrinsicck;\n+mod mem_categorization;\n+mod method;\n+mod op;\n+mod pat;\n+mod place_op;\n+mod rvalue_scopes;\n+mod upvar;\n+mod writeback;\n+\n+pub use diverges::Diverges;\n+pub use expectation::Expectation;\n+pub use fn_ctxt::*;\n+pub use inherited::{Inherited, InheritedBuilder};\n+\n+use crate::check::check_fn;\n+use crate::coercion::DynamicCoerceMany;\n+use crate::gather_locals::GatherLocalsVisitor;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_errors::{struct_span_err, MultiSpan};\n+use rustc_hir as hir;\n+use rustc_hir::def::Res;\n+use rustc_hir::intravisit::Visitor;\n+use rustc_hir::{HirIdMap, Node};\n+use rustc_hir_analysis::astconv::AstConv;\n+use rustc_hir_analysis::check::check_abi;\n+use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc_middle::traits;\n+use rustc_middle::ty::query::Providers;\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_session::config;\n+use rustc_session::Session;\n+use rustc_span::def_id::{DefId, LocalDefId};\n+use rustc_span::Span;\n+\n+#[macro_export]\n+macro_rules! type_error_struct {\n+    ($session:expr, $span:expr, $typ:expr, $code:ident, $($message:tt)*) => ({\n+        let mut err = rustc_errors::struct_span_err!($session, $span, $code, $($message)*);\n+\n+        if $typ.references_error() {\n+            err.downgrade_to_delayed_bug();\n+        }\n+\n+        err\n+    })\n+}\n+\n+/// The type of a local binding, including the revealed type for anon types.\n+#[derive(Copy, Clone, Debug)]\n+pub struct LocalTy<'tcx> {\n+    decl_ty: Ty<'tcx>,\n+    revealed_ty: Ty<'tcx>,\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct UnsafetyState {\n+    pub def: hir::HirId,\n+    pub unsafety: hir::Unsafety,\n+    from_fn: bool,\n+}\n+\n+impl UnsafetyState {\n+    pub fn function(unsafety: hir::Unsafety, def: hir::HirId) -> UnsafetyState {\n+        UnsafetyState { def, unsafety, from_fn: true }\n+    }\n+\n+    pub fn recurse(self, blk: &hir::Block<'_>) -> UnsafetyState {\n+        use hir::BlockCheckMode;\n+        match self.unsafety {\n+            // If this unsafe, then if the outer function was already marked as\n+            // unsafe we shouldn't attribute the unsafe'ness to the block. This\n+            // way the block can be warned about instead of ignoring this\n+            // extraneous block (functions are never warned about).\n+            hir::Unsafety::Unsafe if self.from_fn => self,\n+\n+            unsafety => {\n+                let (unsafety, def) = match blk.rules {\n+                    BlockCheckMode::UnsafeBlock(..) => (hir::Unsafety::Unsafe, blk.hir_id),\n+                    BlockCheckMode::DefaultBlock => (unsafety, self.def),\n+                };\n+                UnsafetyState { def, unsafety, from_fn: false }\n+            }\n+        }\n+    }\n+}\n+\n+/// If this `DefId` is a \"primary tables entry\", returns\n+/// `Some((body_id, body_ty, fn_sig))`. Otherwise, returns `None`.\n+///\n+/// If this function returns `Some`, then `typeck_results(def_id)` will\n+/// succeed; if it returns `None`, then `typeck_results(def_id)` may or\n+/// may not succeed. In some cases where this function returns `None`\n+/// (notably closures), `typeck_results(def_id)` would wind up\n+/// redirecting to the owning function.\n+fn primary_body_of(\n+    tcx: TyCtxt<'_>,\n+    id: hir::HirId,\n+) -> Option<(hir::BodyId, Option<&hir::Ty<'_>>, Option<&hir::FnSig<'_>>)> {\n+    match tcx.hir().get(id) {\n+        Node::Item(item) => match item.kind {\n+            hir::ItemKind::Const(ty, body) | hir::ItemKind::Static(ty, _, body) => {\n+                Some((body, Some(ty), None))\n+            }\n+            hir::ItemKind::Fn(ref sig, .., body) => Some((body, None, Some(sig))),\n+            _ => None,\n+        },\n+        Node::TraitItem(item) => match item.kind {\n+            hir::TraitItemKind::Const(ty, Some(body)) => Some((body, Some(ty), None)),\n+            hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(body)) => {\n+                Some((body, None, Some(sig)))\n+            }\n+            _ => None,\n+        },\n+        Node::ImplItem(item) => match item.kind {\n+            hir::ImplItemKind::Const(ty, body) => Some((body, Some(ty), None)),\n+            hir::ImplItemKind::Fn(ref sig, body) => Some((body, None, Some(sig))),\n+            _ => None,\n+        },\n+        Node::AnonConst(constant) => Some((constant.body, None, None)),\n+        _ => None,\n+    }\n+}\n+\n+fn has_typeck_results(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+    // Closures' typeck results come from their outermost function,\n+    // as they are part of the same \"inference environment\".\n+    let typeck_root_def_id = tcx.typeck_root_def_id(def_id);\n+    if typeck_root_def_id != def_id {\n+        return tcx.has_typeck_results(typeck_root_def_id);\n+    }\n+\n+    if let Some(def_id) = def_id.as_local() {\n+        let id = tcx.hir().local_def_id_to_hir_id(def_id);\n+        primary_body_of(tcx, id).is_some()\n+    } else {\n+        false\n+    }\n+}\n+\n+fn used_trait_imports(tcx: TyCtxt<'_>, def_id: LocalDefId) -> &FxHashSet<LocalDefId> {\n+    &*tcx.typeck(def_id).used_trait_imports\n+}\n+\n+fn typeck_item_bodies(tcx: TyCtxt<'_>, (): ()) {\n+    tcx.hir().par_body_owners(|body_owner_def_id| tcx.ensure().typeck(body_owner_def_id));\n+}\n+\n+fn typeck_const_arg<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    (did, param_did): (LocalDefId, DefId),\n+) -> &ty::TypeckResults<'tcx> {\n+    let fallback = move || tcx.type_of(param_did);\n+    typeck_with_fallback(tcx, did, fallback)\n+}\n+\n+fn typeck<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> &ty::TypeckResults<'tcx> {\n+    if let Some(param_did) = tcx.opt_const_param_of(def_id) {\n+        tcx.typeck_const_arg((def_id, param_did))\n+    } else {\n+        let fallback = move || tcx.type_of(def_id.to_def_id());\n+        typeck_with_fallback(tcx, def_id, fallback)\n+    }\n+}\n+\n+/// Used only to get `TypeckResults` for type inference during error recovery.\n+/// Currently only used for type inference of `static`s and `const`s to avoid type cycle errors.\n+fn diagnostic_only_typeck<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> &ty::TypeckResults<'tcx> {\n+    let fallback = move || {\n+        let span = tcx.hir().span(tcx.hir().local_def_id_to_hir_id(def_id));\n+        tcx.ty_error_with_message(span, \"diagnostic only typeck table used\")\n+    };\n+    typeck_with_fallback(tcx, def_id, fallback)\n+}\n+\n+fn typeck_with_fallback<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: LocalDefId,\n+    fallback: impl Fn() -> Ty<'tcx> + 'tcx,\n+) -> &'tcx ty::TypeckResults<'tcx> {\n+    // Closures' typeck results come from their outermost function,\n+    // as they are part of the same \"inference environment\".\n+    let typeck_root_def_id = tcx.typeck_root_def_id(def_id.to_def_id()).expect_local();\n+    if typeck_root_def_id != def_id {\n+        return tcx.typeck(typeck_root_def_id);\n+    }\n+\n+    let id = tcx.hir().local_def_id_to_hir_id(def_id);\n+    let span = tcx.hir().span(id);\n+\n+    // Figure out what primary body this item has.\n+    let (body_id, body_ty, fn_sig) = primary_body_of(tcx, id).unwrap_or_else(|| {\n+        span_bug!(span, \"can't type-check body of {:?}\", def_id);\n+    });\n+    let body = tcx.hir().body(body_id);\n+\n+    let typeck_results = Inherited::build(tcx, def_id).enter(|inh| {\n+        let param_env = tcx.param_env(def_id);\n+        let mut fcx = if let Some(hir::FnSig { header, decl, .. }) = fn_sig {\n+            let fn_sig = if rustc_hir_analysis::collect::get_infer_ret_ty(&decl.output).is_some() {\n+                let fcx = FnCtxt::new(&inh, param_env, body.value.hir_id);\n+                <dyn AstConv<'_>>::ty_of_fn(&fcx, id, header.unsafety, header.abi, decl, None, None)\n+            } else {\n+                tcx.fn_sig(def_id)\n+            };\n+\n+            check_abi(tcx, id, span, fn_sig.abi());\n+\n+            // Compute the function signature from point of view of inside the fn.\n+            let fn_sig = tcx.liberate_late_bound_regions(def_id.to_def_id(), fn_sig);\n+            let fn_sig = inh.normalize_associated_types_in(\n+                body.value.span,\n+                body_id.hir_id,\n+                param_env,\n+                fn_sig,\n+            );\n+            check_fn(&inh, param_env, fn_sig, decl, id, body, None, true).0\n+        } else {\n+            let fcx = FnCtxt::new(&inh, param_env, body.value.hir_id);\n+            let expected_type = body_ty\n+                .and_then(|ty| match ty.kind {\n+                    hir::TyKind::Infer => Some(<dyn AstConv<'_>>::ast_ty_to_ty(&fcx, ty)),\n+                    _ => None,\n+                })\n+                .unwrap_or_else(|| match tcx.hir().get(id) {\n+                    Node::AnonConst(_) => match tcx.hir().get(tcx.hir().get_parent_node(id)) {\n+                        Node::Expr(&hir::Expr {\n+                            kind: hir::ExprKind::ConstBlock(ref anon_const),\n+                            ..\n+                        }) if anon_const.hir_id == id => fcx.next_ty_var(TypeVariableOrigin {\n+                            kind: TypeVariableOriginKind::TypeInference,\n+                            span,\n+                        }),\n+                        Node::Ty(&hir::Ty {\n+                            kind: hir::TyKind::Typeof(ref anon_const), ..\n+                        }) if anon_const.hir_id == id => fcx.next_ty_var(TypeVariableOrigin {\n+                            kind: TypeVariableOriginKind::TypeInference,\n+                            span,\n+                        }),\n+                        Node::Expr(&hir::Expr { kind: hir::ExprKind::InlineAsm(asm), .. })\n+                        | Node::Item(&hir::Item { kind: hir::ItemKind::GlobalAsm(asm), .. }) => {\n+                            let operand_ty = asm\n+                                .operands\n+                                .iter()\n+                                .filter_map(|(op, _op_sp)| match op {\n+                                    hir::InlineAsmOperand::Const { anon_const }\n+                                        if anon_const.hir_id == id =>\n+                                    {\n+                                        // Inline assembly constants must be integers.\n+                                        Some(fcx.next_int_var())\n+                                    }\n+                                    hir::InlineAsmOperand::SymFn { anon_const }\n+                                        if anon_const.hir_id == id =>\n+                                    {\n+                                        Some(fcx.next_ty_var(TypeVariableOrigin {\n+                                            kind: TypeVariableOriginKind::MiscVariable,\n+                                            span,\n+                                        }))\n+                                    }\n+                                    _ => None,\n+                                })\n+                                .next();\n+                            operand_ty.unwrap_or_else(fallback)\n+                        }\n+                        _ => fallback(),\n+                    },\n+                    _ => fallback(),\n+                });\n+\n+            let expected_type = fcx.normalize_associated_types_in(body.value.span, expected_type);\n+            fcx.require_type_is_sized(expected_type, body.value.span, traits::ConstSized);\n+\n+            // Gather locals in statics (because of block expressions).\n+            GatherLocalsVisitor::new(&fcx).visit_body(body);\n+\n+            fcx.check_expr_coercable_to_type(&body.value, expected_type, None);\n+\n+            fcx.write_ty(id, expected_type);\n+\n+            fcx\n+        };\n+\n+        let fallback_has_occurred = fcx.type_inference_fallback();\n+\n+        // Even though coercion casts provide type hints, we check casts after fallback for\n+        // backwards compatibility. This makes fallback a stronger type hint than a cast coercion.\n+        fcx.check_casts();\n+        fcx.select_obligations_where_possible(fallback_has_occurred, |_| {});\n+\n+        // Closure and generator analysis may run after fallback\n+        // because they don't constrain other type variables.\n+        // Closure analysis only runs on closures. Therefore they only need to fulfill non-const predicates (as of now)\n+        let prev_constness = fcx.param_env.constness();\n+        fcx.param_env = fcx.param_env.without_const();\n+        fcx.closure_analyze(body);\n+        fcx.param_env = fcx.param_env.with_constness(prev_constness);\n+        assert!(fcx.deferred_call_resolutions.borrow().is_empty());\n+        // Before the generator analysis, temporary scopes shall be marked to provide more\n+        // precise information on types to be captured.\n+        fcx.resolve_rvalue_scopes(def_id.to_def_id());\n+        fcx.resolve_generator_interiors(def_id.to_def_id());\n+\n+        for (ty, span, code) in fcx.deferred_sized_obligations.borrow_mut().drain(..) {\n+            let ty = fcx.normalize_ty(span, ty);\n+            fcx.require_type_is_sized(ty, span, code);\n+        }\n+\n+        fcx.select_all_obligations_or_error();\n+\n+        if !fcx.infcx.is_tainted_by_errors() {\n+            fcx.check_transmutes();\n+        }\n+\n+        fcx.check_asms();\n+\n+        fcx.infcx.skip_region_resolution();\n+\n+        fcx.resolve_type_vars_in_body(body)\n+    });\n+\n+    // Consistency check our TypeckResults instance can hold all ItemLocalIds\n+    // it will need to hold.\n+    assert_eq!(typeck_results.hir_owner, id.owner);\n+\n+    typeck_results\n+}\n+\n+/// When `check_fn` is invoked on a generator (i.e., a body that\n+/// includes yield), it returns back some information about the yield\n+/// points.\n+struct GeneratorTypes<'tcx> {\n+    /// Type of generator argument / values returned by `yield`.\n+    resume_ty: Ty<'tcx>,\n+\n+    /// Type of value that is yielded.\n+    yield_ty: Ty<'tcx>,\n+\n+    /// Types that are captured (see `GeneratorInterior` for more).\n+    interior: Ty<'tcx>,\n+\n+    /// Indicates if the generator is movable or static (immovable).\n+    movability: hir::Movability,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum Needs {\n+    MutPlace,\n+    None,\n+}\n+\n+impl Needs {\n+    fn maybe_mut_place(m: hir::Mutability) -> Self {\n+        match m {\n+            hir::Mutability::Mut => Needs::MutPlace,\n+            hir::Mutability::Not => Needs::None,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone)]\n+pub enum PlaceOp {\n+    Deref,\n+    Index,\n+}\n+\n+pub struct BreakableCtxt<'tcx> {\n+    may_break: bool,\n+\n+    // this is `null` for loops where break with a value is illegal,\n+    // such as `while`, `for`, and `while let`\n+    coerce: Option<DynamicCoerceMany<'tcx>>,\n+}\n+\n+pub struct EnclosingBreakables<'tcx> {\n+    stack: Vec<BreakableCtxt<'tcx>>,\n+    by_id: HirIdMap<usize>,\n+}\n+\n+impl<'tcx> EnclosingBreakables<'tcx> {\n+    fn find_breakable(&mut self, target_id: hir::HirId) -> &mut BreakableCtxt<'tcx> {\n+        self.opt_find_breakable(target_id).unwrap_or_else(|| {\n+            bug!(\"could not find enclosing breakable with id {}\", target_id);\n+        })\n+    }\n+\n+    fn opt_find_breakable(&mut self, target_id: hir::HirId) -> Option<&mut BreakableCtxt<'tcx>> {\n+        match self.by_id.get(&target_id) {\n+            Some(ix) => Some(&mut self.stack[*ix]),\n+            None => None,\n+        }\n+    }\n+}\n+\n+fn report_unexpected_variant_res(tcx: TyCtxt<'_>, res: Res, qpath: &hir::QPath<'_>, span: Span) {\n+    struct_span_err!(\n+        tcx.sess,\n+        span,\n+        E0533,\n+        \"expected unit struct, unit variant or constant, found {} `{}`\",\n+        res.descr(),\n+        rustc_hir_pretty::qpath_to_string(qpath),\n+    )\n+    .emit();\n+}\n+\n+/// Controls whether the arguments are tupled. This is used for the call\n+/// operator.\n+///\n+/// Tupling means that all call-side arguments are packed into a tuple and\n+/// passed as a single parameter. For example, if tupling is enabled, this\n+/// function:\n+/// ```\n+/// fn f(x: (isize, isize)) {}\n+/// ```\n+/// Can be called as:\n+/// ```ignore UNSOLVED (can this be done in user code?)\n+/// # fn f(x: (isize, isize)) {}\n+/// f(1, 2);\n+/// ```\n+/// Instead of:\n+/// ```\n+/// # fn f(x: (isize, isize)) {}\n+/// f((1, 2));\n+/// ```\n+#[derive(Clone, Eq, PartialEq)]\n+enum TupleArgumentsFlag {\n+    DontTupleArguments,\n+    TupleArguments,\n+}\n+\n+fn fatally_break_rust(sess: &Session) {\n+    let handler = sess.diagnostic();\n+    handler.span_bug_no_panic(\n+        MultiSpan::new(),\n+        \"It looks like you're trying to break rust; would you like some ICE?\",\n+    );\n+    handler.note_without_error(\"the compiler expectedly panicked. this is a feature.\");\n+    handler.note_without_error(\n+        \"we would appreciate a joke overview: \\\n+         https://github.com/rust-lang/rust/issues/43162#issuecomment-320764675\",\n+    );\n+    handler.note_without_error(&format!(\n+        \"rustc {} running on {}\",\n+        option_env!(\"CFG_VERSION\").unwrap_or(\"unknown_version\"),\n+        config::host_triple(),\n+    ));\n+}\n+\n+fn has_expected_num_generic_args<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_did: Option<DefId>,\n+    expected: usize,\n+) -> bool {\n+    trait_did.map_or(true, |trait_did| {\n+        let generics = tcx.generics_of(trait_did);\n+        generics.count() == expected + if generics.has_self { 1 } else { 0 }\n+    })\n+}\n+\n+pub fn provide(providers: &mut Providers) {\n+    method::provide(providers);\n+    *providers = Providers {\n+        typeck_item_bodies,\n+        typeck_const_arg,\n+        typeck,\n+        diagnostic_only_typeck,\n+        has_typeck_results,\n+        used_trait_imports,\n+        ..*providers\n+    };\n+}"}, {"sha": "362f1c3430041a45e668c263b825e7f790a2fbc9", "filename": "compiler/rustc_hir_typeck/src/mem_categorization.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "previous_filename": "compiler/rustc_hir_analysis/src/mem_categorization.rs"}, {"sha": "be4ea99862222699c51341f1650fe94b81842cb8", "filename": "compiler/rustc_hir_typeck/src/method/confirm.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -1,10 +1,10 @@\n use super::{probe, MethodCallee};\n \n-use crate::astconv::{AstConv, CreateSubstsForGenericArgsCtxt, IsMethodCall};\n-use crate::check::{callee, FnCtxt};\n+use crate::{callee, FnCtxt};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::GenericArg;\n+use rustc_hir_analysis::astconv::{AstConv, CreateSubstsForGenericArgsCtxt, IsMethodCall};\n use rustc_infer::infer::{self, InferOk};\n use rustc_middle::traits::{ObligationCauseCode, UnifyReceiverContext};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, PointerCast};", "previous_filename": "compiler/rustc_hir_analysis/src/check/method/confirm.rs"}, {"sha": "a1278edefbb7140271e2959e53e6314b6c0a505a", "filename": "compiler/rustc_hir_typeck/src/method/mod.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -10,14 +10,14 @@ mod suggest;\n pub use self::suggest::SelfSource;\n pub use self::MethodError::*;\n \n-use crate::check::{Expectation, FnCtxt};\n-use crate::ObligationCause;\n+use crate::{Expectation, FnCtxt};\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, Diagnostic};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Namespace};\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::{self, InferOk};\n+use rustc_middle::traits::ObligationCause;\n use rustc_middle::ty::subst::{InternalSubsts, SubstsRef};\n use rustc_middle::ty::{self, DefIdTree, GenericParamDefKind, ToPredicate, Ty, TypeVisitable};\n use rustc_span::symbol::Ident;", "previous_filename": "compiler/rustc_hir_analysis/src/check/method/mod.rs"}, {"sha": "3c98a2aa3aba3db996a539229510f453d51e1e03", "filename": "compiler/rustc_hir_typeck/src/method/prelude2021.rs", "status": "renamed", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprelude2021.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprelude2021.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprelude2021.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -1,3 +1,7 @@\n+use crate::{\n+    method::probe::{self, Pick},\n+    FnCtxt,\n+};\n use hir::def_id::DefId;\n use hir::HirId;\n use hir::ItemKind;\n@@ -12,11 +16,6 @@ use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n use rustc_trait_selection::infer::InferCtxtExt;\n \n-use crate::check::{\n-    method::probe::{self, Pick},\n-    FnCtxt,\n-};\n-\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub(super) fn lint_dot_call_from_2018(\n         &self,", "previous_filename": "compiler/rustc_hir_analysis/src/check/method/prelude2021.rs"}, {"sha": "74cf2ac32aab270e2f43a88cae14100dd8957eb4", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "renamed", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -3,14 +3,12 @@ use super::CandidateSource;\n use super::MethodError;\n use super::NoMatchData;\n \n-use crate::check::FnCtxt;\n use crate::errors::MethodCallOnUnknownType;\n-use crate::hir::def::DefKind;\n-use crate::hir::def_id::DefId;\n-\n+use crate::FnCtxt;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n+use rustc_hir::def::DefKind;\n use rustc_hir::def::Namespace;\n use rustc_infer::infer::canonical::OriginalQueryValues;\n use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n@@ -23,6 +21,7 @@ use rustc_middle::ty::GenericParamDefKind;\n use rustc_middle::ty::{self, ParamEnvAnd, ToPredicate, Ty, TyCtxt, TypeFoldable, TypeVisitable};\n use rustc_middle::ty::{InternalSubsts, SubstsRef};\n use rustc_session::lint;\n+use rustc_span::def_id::DefId;\n use rustc_span::def_id::LocalDefId;\n use rustc_span::lev_distance::{\n     find_best_match_for_name_with_substrings, lev_distance_with_substrings,", "previous_filename": "compiler/rustc_hir_analysis/src/check/method/probe.rs"}, {"sha": "f4351bfa84aed5a32f1788f4be4c891e31c7b2b2", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -1,8 +1,8 @@\n //! Give useful errors and suggestions to users when an item can't be\n //! found or is otherwise invalid.\n \n-use crate::check::FnCtxt;\n use crate::errors;\n+use crate::FnCtxt;\n use rustc_ast::ast::Mutability;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{", "previous_filename": "compiler/rustc_hir_analysis/src/check/method/suggest.rs"}, {"sha": "89573997693855ffff40d455944fb8018bf3ab67", "filename": "compiler/rustc_hir_typeck/src/op.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -2,7 +2,7 @@\n \n use super::method::MethodCallee;\n use super::{has_expected_num_generic_args, FnCtxt};\n-use crate::check::Expectation;\n+use crate::Expectation;\n use rustc_ast as ast;\n use rustc_errors::{self, struct_span_err, Applicability, Diagnostic};\n use rustc_hir as hir;", "previous_filename": "compiler/rustc_hir_analysis/src/check/op.rs"}, {"sha": "ea90da4a6dc351c559418c2c00558d1e48bec526", "filename": "compiler/rustc_hir_typeck/src/pat.rs", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -1,6 +1,5 @@\n-use crate::check::FnCtxt;\n+use crate::FnCtxt;\n use rustc_ast as ast;\n-\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{\n     pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,", "previous_filename": "compiler/rustc_hir_analysis/src/check/pat.rs"}, {"sha": "ba8cf6926f30b19e1b3800043f7316a2fa6da176", "filename": "compiler/rustc_hir_typeck/src/place_op.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -1,5 +1,5 @@\n-use crate::check::method::MethodCallee;\n-use crate::check::{has_expected_num_generic_args, FnCtxt, PlaceOp};\n+use crate::method::MethodCallee;\n+use crate::{has_expected_num_generic_args, FnCtxt, PlaceOp};\n use rustc_ast as ast;\n use rustc_errors::Applicability;\n use rustc_hir as hir;", "previous_filename": "compiler/rustc_hir_analysis/src/check/place_op.rs"}, {"sha": "22c9e7961070c6d14e6761bd16f230e408b8d3f1", "filename": "compiler/rustc_hir_typeck/src/rvalue_scopes.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Frvalue_scopes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Frvalue_scopes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Frvalue_scopes.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "previous_filename": "compiler/rustc_hir_analysis/src/check/rvalue_scopes.rs"}, {"sha": "4dea40829f6221a2b4e4400789676b9bd5b8b4ce", "filename": "compiler/rustc_hir_typeck/src/upvar.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "previous_filename": "compiler/rustc_hir_analysis/src/check/upvar.rs"}, {"sha": "1e26daa9c2c72fa08054bb812935cbb2f3179f08", "filename": "compiler/rustc_hir_typeck/src/writeback.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -2,7 +2,7 @@\n // unresolved type variables and replaces \"ty_var\" types with their\n // substitutions.\n \n-use crate::check::FnCtxt;\n+use crate::FnCtxt;\n use hir::def_id::LocalDefId;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::ErrorGuaranteed;", "previous_filename": "compiler/rustc_hir_analysis/src/check/writeback.rs"}, {"sha": "2131d19068e50f25a00fa580e8e44383f7987a46", "filename": "compiler/rustc_infer/src/errors/mod.rs", "status": "modified", "additions": 59, "deletions": 72, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fmod.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -18,19 +18,19 @@ use crate::infer::error_reporting::{\n pub mod note_and_explain;\n \n #[derive(Diagnostic)]\n-#[diag(infer::opaque_hidden_type)]\n+#[diag(infer_opaque_hidden_type)]\n pub struct OpaqueHiddenTypeDiag {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[note(infer::opaque_type)]\n+    #[note(opaque_type)]\n     pub opaque_type: Span,\n-    #[note(infer::hidden_type)]\n+    #[note(hidden_type)]\n     pub hidden_type: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(infer::type_annotations_needed, code = \"E0282\")]\n+#[diag(infer_type_annotations_needed, code = \"E0282\")]\n pub struct AnnotationRequired<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -48,7 +48,7 @@ pub struct AnnotationRequired<'a> {\n \n // Copy of `AnnotationRequired` for E0283\n #[derive(Diagnostic)]\n-#[diag(infer::type_annotations_needed, code = \"E0283\")]\n+#[diag(infer_type_annotations_needed, code = \"E0283\")]\n pub struct AmbigousImpl<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -66,7 +66,7 @@ pub struct AmbigousImpl<'a> {\n \n // Copy of `AnnotationRequired` for E0284\n #[derive(Diagnostic)]\n-#[diag(infer::type_annotations_needed, code = \"E0284\")]\n+#[diag(infer_type_annotations_needed, code = \"E0284\")]\n pub struct AmbigousReturn<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -83,7 +83,7 @@ pub struct AmbigousReturn<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(infer::need_type_info_in_generator, code = \"E0698\")]\n+#[diag(infer_need_type_info_in_generator, code = \"E0698\")]\n pub struct NeedTypeInfoInGenerator<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -94,7 +94,7 @@ pub struct NeedTypeInfoInGenerator<'a> {\n \n // Used when a better one isn't available\n #[derive(Subdiagnostic)]\n-#[label(infer::label_bad)]\n+#[label(infer_label_bad)]\n pub struct InferenceBadError<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -110,7 +110,7 @@ pub struct InferenceBadError<'a> {\n #[derive(Subdiagnostic)]\n pub enum SourceKindSubdiag<'a> {\n     #[suggestion_verbose(\n-        infer::source_kind_subdiag_let,\n+        infer_source_kind_subdiag_let,\n         code = \": {type_name}\",\n         applicability = \"has-placeholders\"\n     )]\n@@ -125,7 +125,7 @@ pub enum SourceKindSubdiag<'a> {\n         prefix: &'a str,\n         arg_name: String,\n     },\n-    #[label(infer::source_kind_subdiag_generic_label)]\n+    #[label(infer_source_kind_subdiag_generic_label)]\n     GenericLabel {\n         #[primary_span]\n         span: Span,\n@@ -136,7 +136,7 @@ pub enum SourceKindSubdiag<'a> {\n         parent_name: String,\n     },\n     #[suggestion_verbose(\n-        infer::source_kind_subdiag_generic_suggestion,\n+        infer_source_kind_subdiag_generic_suggestion,\n         code = \"::<{args}>\",\n         applicability = \"has-placeholders\"\n     )]\n@@ -151,7 +151,7 @@ pub enum SourceKindSubdiag<'a> {\n #[derive(Subdiagnostic)]\n pub enum SourceKindMultiSuggestion<'a> {\n     #[multipart_suggestion_verbose(\n-        infer::source_kind_fully_qualified,\n+        infer_source_kind_fully_qualified,\n         applicability = \"has-placeholders\"\n     )]\n     FullyQualified {\n@@ -164,7 +164,7 @@ pub enum SourceKindMultiSuggestion<'a> {\n         successor_pos: &'a str,\n     },\n     #[multipart_suggestion_verbose(\n-        infer::source_kind_closure_return,\n+        infer_source_kind_closure_return,\n         applicability = \"has-placeholders\"\n     )]\n     ClosureReturn {\n@@ -260,7 +260,7 @@ impl AddToDiagnostic for RegionOriginNote<'_> {\n                 requirement,\n                 expected_found: Some((expected, found)),\n             } => {\n-                label_or_note(span, fluent::infer::subtype);\n+                label_or_note(span, fluent::infer_subtype);\n                 diag.set_arg(\"requirement\", requirement);\n \n                 diag.note_expected_found(&\"\", expected, &\"\", found);\n@@ -269,7 +269,7 @@ impl AddToDiagnostic for RegionOriginNote<'_> {\n                 // FIXME: this really should be handled at some earlier stage. Our\n                 // handling of region checking when type errors are present is\n                 // *terrible*.\n-                label_or_note(span, fluent::infer::subtype_2);\n+                label_or_note(span, fluent::infer_subtype_2);\n                 diag.set_arg(\"requirement\", requirement);\n             }\n         };\n@@ -300,9 +300,9 @@ impl AddToDiagnostic for LifetimeMismatchLabels {\n     {\n         match self {\n             LifetimeMismatchLabels::InRet { param_span, ret_span, span, label_var1 } => {\n-                diag.span_label(param_span, fluent::infer::declared_different);\n-                diag.span_label(ret_span, fluent::infer::nothing);\n-                diag.span_label(span, fluent::infer::data_returned);\n+                diag.span_label(param_span, fluent::infer_declared_different);\n+                diag.span_label(ret_span, fluent::infer_nothing);\n+                diag.span_label(span, fluent::infer_data_returned);\n                 diag.set_arg(\"label_var1_exists\", label_var1.is_some());\n                 diag.set_arg(\"label_var1\", label_var1.map(|x| x.to_string()).unwrap_or_default());\n             }\n@@ -315,13 +315,13 @@ impl AddToDiagnostic for LifetimeMismatchLabels {\n                 sub: label_var2,\n             } => {\n                 if hir_equal {\n-                    diag.span_label(ty_sup, fluent::infer::declared_multiple);\n-                    diag.span_label(ty_sub, fluent::infer::nothing);\n-                    diag.span_label(span, fluent::infer::data_lifetime_flow);\n+                    diag.span_label(ty_sup, fluent::infer_declared_multiple);\n+                    diag.span_label(ty_sub, fluent::infer_nothing);\n+                    diag.span_label(span, fluent::infer_data_lifetime_flow);\n                 } else {\n-                    diag.span_label(ty_sup, fluent::infer::types_declared_different);\n-                    diag.span_label(ty_sub, fluent::infer::nothing);\n-                    diag.span_label(span, fluent::infer::data_flows);\n+                    diag.span_label(ty_sup, fluent::infer_types_declared_different);\n+                    diag.span_label(ty_sub, fluent::infer_nothing);\n+                    diag.span_label(span, fluent::infer_data_flows);\n                     diag.set_arg(\"label_var1_exists\", label_var1.is_some());\n                     diag.set_arg(\n                         \"label_var1\",\n@@ -419,21 +419,21 @@ impl AddToDiagnostic for AddLifetimeParamsSuggestion<'_> {\n             }\n \n             diag.multipart_suggestion(\n-                fluent::infer::lifetime_param_suggestion,\n+                fluent::infer_lifetime_param_suggestion,\n                 suggestions,\n                 Applicability::MaybeIncorrect,\n             );\n             diag.set_arg(\"is_impl\", is_impl);\n             true\n         };\n         if mk_suggestion() && self.add_note {\n-            diag.note(fluent::infer::lifetime_param_suggestion_elided);\n+            diag.note(fluent::infer_lifetime_param_suggestion_elided);\n         }\n     }\n }\n \n #[derive(Diagnostic)]\n-#[diag(infer::lifetime_mismatch, code = \"E0623\")]\n+#[diag(infer_lifetime_mismatch, code = \"E0623\")]\n pub struct LifetimeMismatch<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -454,56 +454,43 @@ impl AddToDiagnostic for IntroducesStaticBecauseUnmetLifetimeReq {\n         F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n     {\n         self.unmet_requirements\n-            .push_span_label(self.binding_span, fluent::infer::msl_introduces_static);\n-        diag.span_note(self.unmet_requirements, fluent::infer::msl_unmet_req);\n+            .push_span_label(self.binding_span, fluent::infer_msl_introduces_static);\n+        diag.span_note(self.unmet_requirements, fluent::infer_msl_unmet_req);\n     }\n }\n \n-pub struct ImplNote {\n-    pub impl_span: Option<Span>,\n-}\n-\n-impl AddToDiagnostic for ImplNote {\n-    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n-    where\n-        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n-    {\n-        match self.impl_span {\n-            Some(span) => diag.span_note(span, fluent::infer::msl_impl_note),\n-            None => diag.note(fluent::infer::msl_impl_note),\n-        };\n-    }\n-}\n-\n-pub enum TraitSubdiag {\n-    Note { span: Span },\n-    Sugg { span: Span },\n+// FIXME(#100717): replace with a `Option<Span>` when subdiagnostic supports that\n+#[derive(Subdiagnostic)]\n+pub enum DoesNotOutliveStaticFromImpl {\n+    #[note(infer_does_not_outlive_static_from_impl)]\n+    Spanned {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[note(infer_does_not_outlive_static_from_impl)]\n+    Unspanned,\n }\n \n-// FIXME(#100717) used in `Vec<TraitSubdiag>` so requires eager translation/list support\n-impl AddToDiagnostic for TraitSubdiag {\n-    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n-    where\n-        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n-    {\n-        match self {\n-            TraitSubdiag::Note { span } => {\n-                diag.span_note(span, \"this has an implicit `'static` lifetime requirement\");\n-            }\n-            TraitSubdiag::Sugg { span } => {\n-                diag.span_suggestion_verbose(\n-                    span,\n-                    \"consider relaxing the implicit `'static` requirement\",\n-                    \" + '_\".to_owned(),\n-                    rustc_errors::Applicability::MaybeIncorrect,\n-                );\n-            }\n-        }\n-    }\n+#[derive(Subdiagnostic)]\n+pub enum ImplicitStaticLifetimeSubdiag {\n+    #[note(infer_implicit_static_lifetime_note)]\n+    Note {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[suggestion_verbose(\n+        infer_implicit_static_lifetime_suggestion,\n+        code = \" + '_\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    Sugg {\n+        #[primary_span]\n+        span: Span,\n+    },\n }\n \n #[derive(Diagnostic)]\n-#[diag(infer::mismatched_static_lifetime)]\n+#[diag(infer_mismatched_static_lifetime)]\n pub struct MismatchedStaticLifetime<'a> {\n     #[primary_span]\n     pub cause_span: Span,\n@@ -512,7 +499,7 @@ pub struct MismatchedStaticLifetime<'a> {\n     #[subdiagnostic]\n     pub expl: Option<note_and_explain::RegionExplanation<'a>>,\n     #[subdiagnostic]\n-    pub impl_note: ImplNote,\n-    #[subdiagnostic]\n-    pub trait_subdiags: Vec<TraitSubdiag>,\n+    pub does_not_outlive_static_from_impl: DoesNotOutliveStaticFromImpl,\n+    #[subdiagnostic(eager)]\n+    pub implicit_static_lifetimes: Vec<ImplicitStaticLifetimeSubdiag>,\n }"}, {"sha": "6a29d85627a8446f4060bb4c63f6456321e7abcc", "filename": "compiler/rustc_infer/src/errors/note_and_explain.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ferrors%2Fnote_and_explain.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -166,9 +166,9 @@ impl AddToDiagnostic for RegionExplanation<'_> {\n         F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n     {\n         if let Some(span) = self.desc.span {\n-            diag.span_note(span, fluent::infer::region_explanation);\n+            diag.span_note(span, fluent::infer_region_explanation);\n         } else {\n-            diag.note(fluent::infer::region_explanation);\n+            diag.note(fluent::infer_region_explanation);\n         }\n         self.desc.add_to(diag);\n         diag.set_arg(\"pref_kind\", self.prefix);"}, {"sha": "9ff703e521ff666aa5b2a44d8bb0effe9b776725", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -338,8 +338,7 @@ impl<'tcx> InferCtxt<'tcx> {\n \n             let bounds = self.tcx.bound_explicit_item_bounds(*def_id);\n \n-            for predicate in bounds.transpose_iter().map(|e| e.map_bound(|(p, _)| *p)) {\n-                let predicate = predicate.subst(self.tcx, substs);\n+            for (predicate, _) in bounds.subst_iter_copied(self.tcx, substs) {\n                 let output = predicate\n                     .kind()\n                     .map_bound(|kind| match kind {\n@@ -2272,6 +2271,25 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 struct_span_err!(self.tcx.sess, span, E0580, \"{}\", failure_str)\n             }\n             FailureCode::Error0308(failure_str) => {\n+                fn escape_literal(s: &str) -> String {\n+                    let mut escaped = String::with_capacity(s.len());\n+                    let mut chrs = s.chars().peekable();\n+                    while let Some(first) = chrs.next() {\n+                        match (first, chrs.peek()) {\n+                            ('\\\\', Some(&delim @ '\"') | Some(&delim @ '\\'')) => {\n+                                escaped.push('\\\\');\n+                                escaped.push(delim);\n+                                chrs.next();\n+                            }\n+                            ('\"' | '\\'', _) => {\n+                                escaped.push('\\\\');\n+                                escaped.push(first)\n+                            }\n+                            (c, _) => escaped.push(c),\n+                        };\n+                    }\n+                    escaped\n+                }\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0308, \"{}\", failure_str);\n                 if let Some((expected, found)) = trace.values.ty() {\n                     match (expected.kind(), found.kind()) {\n@@ -2293,7 +2311,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                                 err.span_suggestion(\n                                     span,\n                                     \"if you meant to write a `char` literal, use single quotes\",\n-                                    format!(\"'{}'\", code),\n+                                    format!(\"'{}'\", escape_literal(code)),\n                                     Applicability::MachineApplicable,\n                                 );\n                             }\n@@ -2308,7 +2326,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                                     err.span_suggestion(\n                                         span,\n                                         \"if you meant to write a `str` literal, use double quotes\",\n-                                        format!(\"\\\"{}\\\"\", code),\n+                                        format!(\"\\\"{}\\\"\", escape_literal(code)),\n                                         Applicability::MachineApplicable,\n                                     );\n                                 }"}, {"sha": "c5f2a1a3f7dce687ef0f44c2bb334393edef90b9", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/mismatched_static_lifetime.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -2,7 +2,9 @@\n //! to hold.\n \n use crate::errors::{note_and_explain, IntroducesStaticBecauseUnmetLifetimeReq};\n-use crate::errors::{ImplNote, MismatchedStaticLifetime, TraitSubdiag};\n+use crate::errors::{\n+    DoesNotOutliveStaticFromImpl, ImplicitStaticLifetimeSubdiag, MismatchedStaticLifetime,\n+};\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::{SubregionOrigin, TypeTrace};\n@@ -56,7 +58,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             note_and_explain::SuffixKind::Continues,\n         );\n         let mut impl_span = None;\n-        let mut trait_subdiags = Vec::new();\n+        let mut implicit_static_lifetimes = Vec::new();\n         if let Some(impl_node) = self.tcx().hir().get_if_local(*impl_def_id) {\n             // If an impl is local, then maybe this isn't what they want. Try to\n             // be as helpful as possible with implicit lifetimes.\n@@ -90,10 +92,12 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                 // Otherwise, point at all implicit static lifetimes\n \n                 for span in &traits {\n-                    trait_subdiags.push(TraitSubdiag::Note { span: *span });\n+                    implicit_static_lifetimes\n+                        .push(ImplicitStaticLifetimeSubdiag::Note { span: *span });\n                     // It would be nice to put this immediately under the above note, but they get\n                     // pushed to the end.\n-                    trait_subdiags.push(TraitSubdiag::Sugg { span: span.shrink_to_hi() });\n+                    implicit_static_lifetimes\n+                        .push(ImplicitStaticLifetimeSubdiag::Sugg { span: span.shrink_to_hi() });\n                 }\n             }\n         } else {\n@@ -105,8 +109,10 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             cause_span: cause.span,\n             unmet_lifetime_reqs: multispan_subdiag,\n             expl,\n-            impl_note: ImplNote { impl_span },\n-            trait_subdiags,\n+            does_not_outlive_static_from_impl: impl_span\n+                .map(|span| DoesNotOutliveStaticFromImpl::Spanned { span })\n+                .unwrap_or(DoesNotOutliveStaticFromImpl::Unspanned),\n+            implicit_static_lifetimes,\n         };\n         let reported = self.tcx().sess.emit_err(err);\n         Some(reported)"}, {"sha": "41b115f3377ac879d7287aa3910dcdf492221fc7", "filename": "compiler/rustc_infer/src/infer/error_reporting/note.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -19,26 +19,27 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 expected_found: self.values_str(trace.values),\n             }\n             .add_to_diagnostic(err),\n-            infer::Reborrow(span) => RegionOriginNote::Plain { span, msg: fluent::infer::reborrow }\n-                .add_to_diagnostic(err),\n+            infer::Reborrow(span) => {\n+                RegionOriginNote::Plain { span, msg: fluent::infer_reborrow }.add_to_diagnostic(err)\n+            }\n             infer::ReborrowUpvar(span, ref upvar_id) => {\n                 let var_name = self.tcx.hir().name(upvar_id.var_path.hir_id);\n                 RegionOriginNote::WithName {\n                     span,\n-                    msg: fluent::infer::reborrow,\n+                    msg: fluent::infer_reborrow,\n                     name: &var_name.to_string(),\n                     continues: false,\n                 }\n                 .add_to_diagnostic(err);\n             }\n             infer::RelateObjectBound(span) => {\n-                RegionOriginNote::Plain { span, msg: fluent::infer::relate_object_bound }\n+                RegionOriginNote::Plain { span, msg: fluent::infer_relate_object_bound }\n                     .add_to_diagnostic(err);\n             }\n             infer::DataBorrowed(ty, span) => {\n                 RegionOriginNote::WithName {\n                     span,\n-                    msg: fluent::infer::data_borrowed,\n+                    msg: fluent::infer_data_borrowed,\n                     name: &self.ty_to_string(ty),\n                     continues: false,\n                 }\n@@ -47,7 +48,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n             infer::ReferenceOutlivesReferent(ty, span) => {\n                 RegionOriginNote::WithName {\n                     span,\n-                    msg: fluent::infer::reference_outlives_referent,\n+                    msg: fluent::infer_reference_outlives_referent,\n                     name: &self.ty_to_string(ty),\n                     continues: false,\n                 }\n@@ -56,22 +57,22 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n             infer::RelateParamBound(span, ty, opt_span) => {\n                 RegionOriginNote::WithName {\n                     span,\n-                    msg: fluent::infer::relate_param_bound,\n+                    msg: fluent::infer_relate_param_bound,\n                     name: &self.ty_to_string(ty),\n                     continues: opt_span.is_some(),\n                 }\n                 .add_to_diagnostic(err);\n                 if let Some(span) = opt_span {\n-                    RegionOriginNote::Plain { span, msg: fluent::infer::relate_param_bound_2 }\n+                    RegionOriginNote::Plain { span, msg: fluent::infer_relate_param_bound_2 }\n                         .add_to_diagnostic(err);\n                 }\n             }\n             infer::RelateRegionParamBound(span) => {\n-                RegionOriginNote::Plain { span, msg: fluent::infer::relate_region_param_bound }\n+                RegionOriginNote::Plain { span, msg: fluent::infer_relate_region_param_bound }\n                     .add_to_diagnostic(err);\n             }\n             infer::CompareImplItemObligation { span, .. } => {\n-                RegionOriginNote::Plain { span, msg: fluent::infer::compare_impl_item_obligation }\n+                RegionOriginNote::Plain { span, msg: fluent::infer_compare_impl_item_obligation }\n                     .add_to_diagnostic(err);\n             }\n             infer::CheckAssociatedTypeBounds { ref parent, .. } => {\n@@ -80,7 +81,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n             infer::AscribeUserTypeProvePredicate(span) => {\n                 RegionOriginNote::Plain {\n                     span,\n-                    msg: fluent::infer::ascribe_user_type_prove_predicate,\n+                    msg: fluent::infer_ascribe_user_type_prove_predicate,\n                 }\n                 .add_to_diagnostic(err);\n             }"}, {"sha": "0a4ecc4c033e1ce9ae0d215871a5105e5120a724", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -1,6 +1,7 @@\n use crate::errors::OpaqueHiddenTypeDiag;\n use crate::infer::{DefiningAnchor, InferCtxt, InferOk};\n use crate::traits;\n+use hir::def::DefKind;\n use hir::def_id::{DefId, LocalDefId};\n use hir::{HirId, OpaqueTyOrigin};\n use rustc_data_structures::sync::Lrc;\n@@ -543,16 +544,18 @@ impl<'tcx> InferCtxt<'tcx> {\n \n         let item_bounds = tcx.bound_explicit_item_bounds(def_id.to_def_id());\n \n-        for predicate in item_bounds.transpose_iter().map(|e| e.map_bound(|(p, _)| *p)) {\n-            debug!(?predicate);\n-            let predicate = predicate.subst(tcx, substs);\n-\n+        for (predicate, _) in item_bounds.subst_iter_copied(tcx, substs) {\n             let predicate = predicate.fold_with(&mut BottomUpFolder {\n                 tcx,\n                 ty_op: |ty| match *ty.kind() {\n                     // We can't normalize associated types from `rustc_infer`,\n                     // but we can eagerly register inference variables for them.\n-                    ty::Projection(projection_ty) if !projection_ty.has_escaping_bound_vars() => {\n+                    // FIXME(RPITIT): Don't replace RPITITs with inference vars.\n+                    ty::Projection(projection_ty)\n+                        if !projection_ty.has_escaping_bound_vars()\n+                            && tcx.def_kind(projection_ty.item_def_id)\n+                                != DefKind::ImplTraitPlaceholder =>\n+                    {\n                         self.infer_projection(\n                             param_env,\n                             projection_ty,\n@@ -568,6 +571,12 @@ impl<'tcx> InferCtxt<'tcx> {\n                     {\n                         hidden_ty\n                     }\n+                    // FIXME(RPITIT): This can go away when we move to associated types\n+                    ty::Projection(proj)\n+                        if def_id.to_def_id() == proj.item_def_id && substs == proj.substs =>\n+                    {\n+                        hidden_ty\n+                    }\n                     _ => ty,\n                 },\n                 lt_op: |lt| lt,"}, {"sha": "6a4c5b4d37376e0e7d2582a7fdc3574f0b0a7a8d", "filename": "compiler/rustc_interface/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2FCargo.toml?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -38,6 +38,7 @@ rustc_mir_transform = { path = \"../rustc_mir_transform\" }\n rustc_monomorphize = { path = \"../rustc_monomorphize\" }\n rustc_passes = { path = \"../rustc_passes\" }\n rustc_hir_analysis = { path = \"../rustc_hir_analysis\" }\n+rustc_hir_typeck = { path = \"../rustc_hir_typeck\" }\n rustc_lint = { path = \"../rustc_lint\" }\n rustc_errors = { path = \"../rustc_errors\" }\n rustc_plugin_impl = { path = \"../rustc_plugin_impl\" }"}, {"sha": "f5135c78dc8313c32dfea0a77e564ece5f972c1f", "filename": "compiler/rustc_interface/src/errors.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_interface%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_interface%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ferrors.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -5,7 +5,7 @@ use std::io;\n use std::path::Path;\n \n #[derive(Diagnostic)]\n-#[diag(interface::ferris_identifier)]\n+#[diag(interface_ferris_identifier)]\n pub struct FerrisIdentifier {\n     #[primary_span]\n     pub spans: Vec<Span>,\n@@ -14,75 +14,75 @@ pub struct FerrisIdentifier {\n }\n \n #[derive(Diagnostic)]\n-#[diag(interface::emoji_identifier)]\n+#[diag(interface_emoji_identifier)]\n pub struct EmojiIdentifier {\n     #[primary_span]\n     pub spans: Vec<Span>,\n     pub ident: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(interface::mixed_bin_crate)]\n+#[diag(interface_mixed_bin_crate)]\n pub struct MixedBinCrate;\n \n #[derive(Diagnostic)]\n-#[diag(interface::mixed_proc_macro_crate)]\n+#[diag(interface_mixed_proc_macro_crate)]\n pub struct MixedProcMacroCrate;\n \n #[derive(Diagnostic)]\n-#[diag(interface::proc_macro_doc_without_arg)]\n+#[diag(interface_proc_macro_doc_without_arg)]\n pub struct ProcMacroDocWithoutArg;\n \n #[derive(Diagnostic)]\n-#[diag(interface::error_writing_dependencies)]\n+#[diag(interface_error_writing_dependencies)]\n pub struct ErrorWritingDependencies<'a> {\n     pub path: &'a Path,\n     pub error: io::Error,\n }\n \n #[derive(Diagnostic)]\n-#[diag(interface::input_file_would_be_overwritten)]\n+#[diag(interface_input_file_would_be_overwritten)]\n pub struct InputFileWouldBeOverWritten<'a> {\n     pub path: &'a Path,\n }\n \n #[derive(Diagnostic)]\n-#[diag(interface::generated_file_conflicts_with_directory)]\n+#[diag(interface_generated_file_conflicts_with_directory)]\n pub struct GeneratedFileConflictsWithDirectory<'a> {\n     pub input_path: &'a Path,\n     pub dir_path: &'a Path,\n }\n \n #[derive(Diagnostic)]\n-#[diag(interface::temps_dir_error)]\n+#[diag(interface_temps_dir_error)]\n pub struct TempsDirError;\n \n #[derive(Diagnostic)]\n-#[diag(interface::out_dir_error)]\n+#[diag(interface_out_dir_error)]\n pub struct OutDirError;\n \n #[derive(Diagnostic)]\n-#[diag(interface::cant_emit_mir)]\n+#[diag(interface_cant_emit_mir)]\n pub struct CantEmitMIR {\n     pub error: io::Error,\n }\n \n #[derive(Diagnostic)]\n-#[diag(interface::rustc_error_fatal)]\n+#[diag(interface_rustc_error_fatal)]\n pub struct RustcErrorFatal {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(interface::rustc_error_unexpected_annotation)]\n+#[diag(interface_rustc_error_unexpected_annotation)]\n pub struct RustcErrorUnexpectedAnnotation {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(interface::failed_writing_file)]\n+#[diag(interface_failed_writing_file)]\n pub struct FailedWritingFile<'a> {\n     pub path: &'a Path,\n     pub error: io::Error,"}, {"sha": "a47c3e3253ecdd643cb8cef700da097ee1c3d440", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -736,6 +736,7 @@ pub static DEFAULT_QUERY_PROVIDERS: LazyLock<Providers> = LazyLock::new(|| {\n     rustc_monomorphize::provide(providers);\n     rustc_privacy::provide(providers);\n     rustc_hir_analysis::provide(providers);\n+    rustc_hir_typeck::provide(providers);\n     ty::provide(providers);\n     traits::provide(providers);\n     rustc_passes::provide(providers);"}, {"sha": "eb8e65a6d59d38819736f8ee02df36b805116711", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -648,6 +648,7 @@ fn test_unstable_options_tracking_hash() {\n     untracked!(dump_mir_dir, String::from(\"abc\"));\n     untracked!(dump_mir_exclude_pass_number, true);\n     untracked!(dump_mir_graphviz, true);\n+    untracked!(dylib_lto, true);\n     untracked!(emit_stack_sizes, true);\n     untracked!(future_incompat_test, true);\n     untracked!(hir_stats, true);"}, {"sha": "abebc533cc17ba6f9b0c13865b3ffe405e92d1af", "filename": "compiler/rustc_lint/src/array_into_iter.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -121,25 +121,25 @@ impl<'tcx> LateLintPass<'tcx> for ArrayIntoIter {\n             cx.struct_span_lint(\n                 ARRAY_INTO_ITER,\n                 call.ident.span,\n-                fluent::lint::array_into_iter,\n+                fluent::lint_array_into_iter,\n                 |diag| {\n                     diag.set_arg(\"target\", target);\n                     diag.span_suggestion(\n                         call.ident.span,\n-                        fluent::lint::use_iter_suggestion,\n+                        fluent::use_iter_suggestion,\n                         \"iter\",\n                         Applicability::MachineApplicable,\n                     );\n                     if self.for_expr_span == expr.span {\n                         diag.span_suggestion(\n                             receiver_arg.span.shrink_to_hi().to(expr.span.shrink_to_hi()),\n-                            fluent::lint::remove_into_iter_suggestion,\n+                            fluent::remove_into_iter_suggestion,\n                             \"\",\n                             Applicability::MaybeIncorrect,\n                         );\n                     } else if receiver_ty.is_array() {\n                         diag.multipart_suggestion(\n-                            fluent::lint::use_explicit_into_iter_suggestion,\n+                            fluent::use_explicit_into_iter_suggestion,\n                             vec![\n                                 (expr.span.shrink_to_lo(), \"IntoIterator::into_iter(\".into()),\n                                 ("}, {"sha": "53c4910513422421f6feb8345d4ea435d24199b4", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 83, "deletions": 129, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -106,11 +106,11 @@ impl EarlyLintPass for WhileTrue {\n             cx.struct_span_lint(\n                             WHILE_TRUE,\n                             condition_span,\n-                fluent::lint::builtin_while_true,\n+                fluent::lint_builtin_while_true,\n                             |lint| {\n                     lint.span_suggestion_short(\n                         condition_span,\n-                        fluent::lint::suggestion,\n+                        fluent::suggestion,\n                         format!(\n                             \"{}loop\",\n                             label.map_or_else(String::new, |label| format!(\n@@ -160,7 +160,7 @@ impl BoxPointers {\n                     cx.struct_span_lint(\n                         BOX_POINTERS,\n                         span,\n-                        fluent::lint::builtin_box_pointers,\n+                        fluent::lint_builtin_box_pointers,\n                         |lint| lint.set_arg(\"ty\", ty),\n                     );\n                 }\n@@ -264,13 +264,13 @@ impl<'tcx> LateLintPass<'tcx> for NonShorthandFieldPatterns {\n                         cx.struct_span_lint(\n                             NON_SHORTHAND_FIELD_PATTERNS,\n                             fieldpat.span,\n-                            fluent::lint::builtin_non_shorthand_field_patterns,\n+                            fluent::lint_builtin_non_shorthand_field_patterns,\n                             |lint| {\n                                 let suggested_ident =\n                                     format!(\"{}{}\", binding_annot.prefix_str(), ident);\n                                 lint.set_arg(\"ident\", ident.clone()).span_suggestion(\n                                     fieldpat.span,\n-                                    fluent::lint::suggestion,\n+                                    fluent::suggestion,\n                                     suggested_ident,\n                                     Applicability::MachineApplicable,\n                                 )\n@@ -335,7 +335,7 @@ impl UnsafeCode {\n         msg: DiagnosticMessage,\n     ) {\n         self.report_unsafe(cx, span, msg, |lint| {\n-            lint.note(fluent::lint::builtin_overridden_symbol_name)\n+            lint.note(fluent::lint_builtin_overridden_symbol_name)\n         })\n     }\n \n@@ -346,64 +346,61 @@ impl UnsafeCode {\n         msg: DiagnosticMessage,\n     ) {\n         self.report_unsafe(cx, span, msg, |lint| {\n-            lint.note(fluent::lint::builtin_overridden_symbol_section)\n+            lint.note(fluent::lint_builtin_overridden_symbol_section)\n         })\n     }\n }\n \n impl EarlyLintPass for UnsafeCode {\n     fn check_attribute(&mut self, cx: &EarlyContext<'_>, attr: &ast::Attribute) {\n         if attr.has_name(sym::allow_internal_unsafe) {\n-            self.report_unsafe(\n-                cx,\n-                attr.span,\n-                fluent::lint::builtin_allow_internal_unsafe,\n-                |lint| lint,\n-            );\n+            self.report_unsafe(cx, attr.span, fluent::lint_builtin_allow_internal_unsafe, |lint| {\n+                lint\n+            });\n         }\n     }\n \n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n         if let ast::ExprKind::Block(ref blk, _) = e.kind {\n             // Don't warn about generated blocks; that'll just pollute the output.\n             if blk.rules == ast::BlockCheckMode::Unsafe(ast::UserProvided) {\n-                self.report_unsafe(cx, blk.span, fluent::lint::builtin_unsafe_block, |lint| lint);\n+                self.report_unsafe(cx, blk.span, fluent::lint_builtin_unsafe_block, |lint| lint);\n             }\n         }\n     }\n \n     fn check_item(&mut self, cx: &EarlyContext<'_>, it: &ast::Item) {\n         match it.kind {\n             ast::ItemKind::Trait(box ast::Trait { unsafety: ast::Unsafe::Yes(_), .. }) => {\n-                self.report_unsafe(cx, it.span, fluent::lint::builtin_unsafe_trait, |lint| lint)\n+                self.report_unsafe(cx, it.span, fluent::lint_builtin_unsafe_trait, |lint| lint)\n             }\n \n             ast::ItemKind::Impl(box ast::Impl { unsafety: ast::Unsafe::Yes(_), .. }) => {\n-                self.report_unsafe(cx, it.span, fluent::lint::builtin_unsafe_impl, |lint| lint)\n+                self.report_unsafe(cx, it.span, fluent::lint_builtin_unsafe_impl, |lint| lint)\n             }\n \n             ast::ItemKind::Fn(..) => {\n                 if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::no_mangle) {\n                     self.report_overridden_symbol_name(\n                         cx,\n                         attr.span,\n-                        fluent::lint::builtin_no_mangle_fn,\n+                        fluent::lint_builtin_no_mangle_fn,\n                     );\n                 }\n \n                 if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::export_name) {\n                     self.report_overridden_symbol_name(\n                         cx,\n                         attr.span,\n-                        fluent::lint::builtin_export_name_fn,\n+                        fluent::lint_builtin_export_name_fn,\n                     );\n                 }\n \n                 if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::link_section) {\n                     self.report_overridden_symbol_section(\n                         cx,\n                         attr.span,\n-                        fluent::lint::builtin_link_section_fn,\n+                        fluent::lint_builtin_link_section_fn,\n                     );\n                 }\n             }\n@@ -413,23 +410,23 @@ impl EarlyLintPass for UnsafeCode {\n                     self.report_overridden_symbol_name(\n                         cx,\n                         attr.span,\n-                        fluent::lint::builtin_no_mangle_static,\n+                        fluent::lint_builtin_no_mangle_static,\n                     );\n                 }\n \n                 if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::export_name) {\n                     self.report_overridden_symbol_name(\n                         cx,\n                         attr.span,\n-                        fluent::lint::builtin_export_name_static,\n+                        fluent::lint_builtin_export_name_static,\n                     );\n                 }\n \n                 if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::link_section) {\n                     self.report_overridden_symbol_section(\n                         cx,\n                         attr.span,\n-                        fluent::lint::builtin_link_section_static,\n+                        fluent::lint_builtin_link_section_static,\n                     );\n                 }\n             }\n@@ -444,14 +441,14 @@ impl EarlyLintPass for UnsafeCode {\n                 self.report_overridden_symbol_name(\n                     cx,\n                     attr.span,\n-                    fluent::lint::builtin_no_mangle_method,\n+                    fluent::lint_builtin_no_mangle_method,\n                 );\n             }\n             if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::export_name) {\n                 self.report_overridden_symbol_name(\n                     cx,\n                     attr.span,\n-                    fluent::lint::builtin_export_name_method,\n+                    fluent::lint_builtin_export_name_method,\n                 );\n             }\n         }\n@@ -469,9 +466,9 @@ impl EarlyLintPass for UnsafeCode {\n         {\n             let msg = match ctxt {\n                 FnCtxt::Foreign => return,\n-                FnCtxt::Free => fluent::lint::builtin_decl_unsafe_fn,\n-                FnCtxt::Assoc(_) if body.is_none() => fluent::lint::builtin_decl_unsafe_method,\n-                FnCtxt::Assoc(_) => fluent::lint::builtin_impl_unsafe_method,\n+                FnCtxt::Free => fluent::lint_builtin_decl_unsafe_fn,\n+                FnCtxt::Assoc(_) if body.is_none() => fluent::lint_builtin_decl_unsafe_method,\n+                FnCtxt::Assoc(_) => fluent::lint_builtin_impl_unsafe_method,\n             };\n             self.report_unsafe(cx, span, msg, |lint| lint);\n         }\n@@ -577,7 +574,7 @@ impl MissingDoc {\n             cx.struct_span_lint(\n                 MISSING_DOCS,\n                 cx.tcx.def_span(def_id),\n-                fluent::lint::builtin_missing_doc,\n+                fluent::lint_builtin_missing_doc,\n                 |lint| lint.set_arg(\"article\", article).set_arg(\"desc\", desc),\n             );\n         }\n@@ -769,7 +766,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingCopyImplementations {\n             cx.struct_span_lint(\n                 MISSING_COPY_IMPLEMENTATIONS,\n                 item.span,\n-                fluent::lint::builtin_missing_copy_impl,\n+                fluent::lint_builtin_missing_copy_impl,\n                 |lint| lint,\n             )\n         }\n@@ -848,7 +845,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDebugImplementations {\n             cx.struct_span_lint(\n                 MISSING_DEBUG_IMPLEMENTATIONS,\n                 item.span,\n-                fluent::lint::builtin_missing_debug_impl,\n+                fluent::lint_builtin_missing_debug_impl,\n                 |lint| lint.set_arg(\"debug\", cx.tcx.def_path_str(debug)),\n             );\n         }\n@@ -928,11 +925,11 @@ impl EarlyLintPass for AnonymousParameters {\n                         cx.struct_span_lint(\n                             ANONYMOUS_PARAMETERS,\n                             arg.pat.span,\n-                            fluent::lint::builtin_anonymous_params,\n+                            fluent::lint_builtin_anonymous_params,\n                             |lint| {\n                                 lint.span_suggestion(\n                                     arg.pat.span,\n-                                    fluent::lint::suggestion,\n+                                    fluent::suggestion,\n                                     format!(\"_: {}\", ty_snip),\n                                     appl,\n                                 )\n@@ -976,15 +973,15 @@ impl EarlyLintPass for DeprecatedAttr {\n                     cx.struct_span_lint(\n                         DEPRECATED,\n                         attr.span,\n-                        fluent::lint::builtin_deprecated_attr_link,\n+                        fluent::lint_builtin_deprecated_attr_link,\n                         |lint| {\n                             lint.set_arg(\"name\", name)\n                                 .set_arg(\"reason\", reason)\n                                 .set_arg(\"link\", link)\n                                 .span_suggestion_short(\n                                     attr.span,\n                                     suggestion.map(|s| s.into()).unwrap_or(\n-                                        fluent::lint::builtin_deprecated_attr_default_suggestion,\n+                                        fluent::lint_builtin_deprecated_attr_default_suggestion,\n                                     ),\n                                     \"\",\n                                     Applicability::MachineApplicable,\n@@ -999,12 +996,12 @@ impl EarlyLintPass for DeprecatedAttr {\n             cx.struct_span_lint(\n                 DEPRECATED,\n                 attr.span,\n-                fluent::lint::builtin_deprecated_attr_used,\n+                fluent::lint_builtin_deprecated_attr_used,\n                 |lint| {\n                     lint.set_arg(\"name\", pprust::path_to_string(&attr.get_normal_item().path))\n                         .span_suggestion_short(\n                             attr.span,\n-                            fluent::lint::builtin_deprecated_attr_default_suggestion,\n+                            fluent::lint_builtin_deprecated_attr_default_suggestion,\n                             \"\",\n                             Applicability::MachineApplicable,\n                         )\n@@ -1039,14 +1036,14 @@ fn warn_if_doc(cx: &EarlyContext<'_>, node_span: Span, node_kind: &str, attrs: &\n             cx.struct_span_lint(\n                 UNUSED_DOC_COMMENTS,\n                 span,\n-                fluent::lint::builtin_unused_doc_comment,\n+                fluent::lint_builtin_unused_doc_comment,\n                 |lint| {\n-                    lint.set_arg(\"kind\", node_kind).span_label(node_span, fluent::lint::label).help(\n+                    lint.set_arg(\"kind\", node_kind).span_label(node_span, fluent::label).help(\n                         match attr.kind {\n                             AttrKind::DocComment(CommentKind::Line, _) | AttrKind::Normal(..) => {\n-                                fluent::lint::plain_help\n+                                fluent::plain_help\n                             }\n-                            AttrKind::DocComment(CommentKind::Block, _) => fluent::lint::block_help,\n+                            AttrKind::DocComment(CommentKind::Block, _) => fluent::block_help,\n                         },\n                     )\n                 },\n@@ -1167,11 +1164,11 @@ impl<'tcx> LateLintPass<'tcx> for InvalidNoMangleItems {\n                         cx.struct_span_lint(\n                             NO_MANGLE_GENERIC_ITEMS,\n                             span,\n-                            fluent::lint::builtin_no_mangle_generic,\n+                            fluent::lint_builtin_no_mangle_generic,\n                             |lint| {\n                                 lint.span_suggestion_short(\n                                     no_mangle_attr.span,\n-                                    fluent::lint::suggestion,\n+                                    fluent::suggestion,\n                                     \"\",\n                                     // Use of `#[no_mangle]` suggests FFI intent; correct\n                                     // fix may be to monomorphize source by hand\n@@ -1197,7 +1194,7 @@ impl<'tcx> LateLintPass<'tcx> for InvalidNoMangleItems {\n                     cx.struct_span_lint(\n                         NO_MANGLE_CONST_ITEMS,\n                         it.span,\n-                        fluent::lint::builtin_const_no_mangle,\n+                        fluent::lint_builtin_const_no_mangle,\n                         |lint| {\n                             // account for \"pub const\" (#45562)\n                             let start = cx\n@@ -1211,7 +1208,7 @@ impl<'tcx> LateLintPass<'tcx> for InvalidNoMangleItems {\n                             let const_span = it.span.with_hi(BytePos(it.span.lo().0 + start + 5));\n                             lint.span_suggestion(\n                                 const_span,\n-                                fluent::lint::suggestion,\n+                                fluent::suggestion,\n                                 \"pub static\",\n                                 Applicability::MachineApplicable,\n                             )\n@@ -1279,7 +1276,7 @@ impl<'tcx> LateLintPass<'tcx> for MutableTransmutes {\n                 cx.struct_span_lint(\n                     MUTABLE_TRANSMUTES,\n                     expr.span,\n-                    fluent::lint::builtin_mutable_transmutes,\n+                    fluent::lint_builtin_mutable_transmutes,\n                     |lint| lint,\n                 );\n             }\n@@ -1332,7 +1329,7 @@ impl<'tcx> LateLintPass<'tcx> for UnstableFeatures {\n                     cx.struct_span_lint(\n                         UNSTABLE_FEATURES,\n                         item.span(),\n-                        fluent::lint::builtin_unstable_features,\n+                        fluent::lint_builtin_unstable_features,\n                         |lint| lint,\n                     );\n                 }\n@@ -1396,18 +1393,13 @@ impl UnreachablePub {\n             cx.struct_span_lint(\n                 UNREACHABLE_PUB,\n                 def_span,\n-                fluent::lint::builtin_unreachable_pub,\n+                fluent::lint_builtin_unreachable_pub,\n                 |lint| {\n                     lint.set_arg(\"what\", what);\n \n-                    lint.span_suggestion(\n-                        vis_span,\n-                        fluent::lint::suggestion,\n-                        \"pub(crate)\",\n-                        applicability,\n-                    );\n+                    lint.span_suggestion(vis_span, fluent::suggestion, \"pub(crate)\", applicability);\n                     if exportable {\n-                        lint.help(fluent::lint::help);\n+                        lint.help(fluent::help);\n                     }\n                     lint\n                 },\n@@ -1498,7 +1490,7 @@ impl TypeAliasBounds {\n         impl Visitor<'_> for WalkAssocTypes<'_> {\n             fn visit_qpath(&mut self, qpath: &hir::QPath<'_>, id: hir::HirId, span: Span) {\n                 if TypeAliasBounds::is_type_variable_assoc(qpath) {\n-                    self.err.span_help(span, fluent::lint::builtin_type_alias_bounds_help);\n+                    self.err.span_help(span, fluent::lint_builtin_type_alias_bounds_help);\n                 }\n                 intravisit::walk_qpath(self, qpath, id)\n             }\n@@ -1541,11 +1533,11 @@ impl<'tcx> LateLintPass<'tcx> for TypeAliasBounds {\n \n         let mut suggested_changing_assoc_types = false;\n         if !where_spans.is_empty() {\n-            cx.lint(TYPE_ALIAS_BOUNDS, fluent::lint::builtin_type_alias_where_clause, |lint| {\n+            cx.lint(TYPE_ALIAS_BOUNDS, fluent::lint_builtin_type_alias_where_clause, |lint| {\n                 lint.set_span(where_spans);\n                 lint.span_suggestion(\n                     type_alias_generics.where_clause_span,\n-                    fluent::lint::suggestion,\n+                    fluent::suggestion,\n                     \"\",\n                     Applicability::MachineApplicable,\n                 );\n@@ -1558,10 +1550,10 @@ impl<'tcx> LateLintPass<'tcx> for TypeAliasBounds {\n         }\n \n         if !inline_spans.is_empty() {\n-            cx.lint(TYPE_ALIAS_BOUNDS, fluent::lint::builtin_type_alias_generic_bounds, |lint| {\n+            cx.lint(TYPE_ALIAS_BOUNDS, fluent::lint_builtin_type_alias_generic_bounds, |lint| {\n                 lint.set_span(inline_spans);\n                 lint.multipart_suggestion(\n-                    fluent::lint::suggestion,\n+                    fluent::suggestion,\n                     inline_sugg,\n                     Applicability::MachineApplicable,\n                 );\n@@ -1670,7 +1662,7 @@ impl<'tcx> LateLintPass<'tcx> for TrivialConstraints {\n                     cx.struct_span_lint(\n                         TRIVIAL_BOUNDS,\n                         span,\n-                        fluent::lint::builtin_trivial_bounds,\n+                        fluent::lint_builtin_trivial_bounds,\n                         |lint| {\n                             lint.set_arg(\"predicate_kind_name\", predicate_kind_name)\n                                 .set_arg(\"predicate\", predicate)\n@@ -1775,8 +1767,8 @@ impl EarlyLintPass for EllipsisInclusiveRangePatterns {\n         };\n \n         if let Some((start, end, join)) = endpoints {\n-            let msg = fluent::lint::builtin_ellipsis_inclusive_range_patterns;\n-            let suggestion = fluent::lint::suggestion;\n+            let msg = fluent::lint_builtin_ellipsis_inclusive_range_patterns;\n+            let suggestion = fluent::suggestion;\n             if parenthesise {\n                 self.node_id = Some(pat.id);\n                 let end = expr_to_string(&end);\n@@ -1899,7 +1891,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnameableTestItems {\n             cx.struct_span_lint(\n                 UNNAMEABLE_TEST_ITEMS,\n                 attr.span,\n-                fluent::lint::builtin_unnameable_test_items,\n+                fluent::lint_builtin_unnameable_test_items,\n                 |lint| lint,\n             );\n         }\n@@ -2020,11 +2012,11 @@ impl KeywordIdents {\n         cx.struct_span_lint(\n             KEYWORD_IDENTS,\n             ident.span,\n-            fluent::lint::builtin_keyword_idents,\n+            fluent::lint_builtin_keyword_idents,\n             |lint| {\n                 lint.set_arg(\"kw\", ident.clone()).set_arg(\"next\", next_edition).span_suggestion(\n                     ident.span,\n-                    fluent::lint::suggestion,\n+                    fluent::suggestion,\n                     format!(\"r#{}\", ident),\n                     Applicability::MachineApplicable,\n                 )\n@@ -2283,10 +2275,10 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n                 cx.struct_span_lint(\n                     EXPLICIT_OUTLIVES_REQUIREMENTS,\n                     lint_spans.clone(),\n-                    fluent::lint::builtin_explicit_outlives,\n+                    fluent::lint_builtin_explicit_outlives,\n                     |lint| {\n                         lint.set_arg(\"count\", bound_count).multipart_suggestion(\n-                            fluent::lint::suggestion,\n+                            fluent::suggestion,\n                             lint_spans\n                                 .into_iter()\n                                 .map(|span| (span, String::new()))\n@@ -2344,17 +2336,17 @@ impl EarlyLintPass for IncompleteFeatures {\n                 cx.struct_span_lint(\n                     INCOMPLETE_FEATURES,\n                     span,\n-                    fluent::lint::builtin_incomplete_features,\n+                    fluent::lint_builtin_incomplete_features,\n                     |lint| {\n                         lint.set_arg(\"name\", name);\n                         if let Some(n) =\n                             rustc_feature::find_feature_issue(name, GateIssue::Language)\n                         {\n                             lint.set_arg(\"n\", n);\n-                            lint.note(fluent::lint::note);\n+                            lint.note(fluent::note);\n                         }\n                         if HAS_MIN_FEATURES.contains(&name) {\n-                            lint.help(fluent::lint::help);\n+                            lint.help(fluent::help);\n                         }\n                         lint\n                     },\n@@ -2467,42 +2459,6 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n             None\n         }\n \n-        /// Determines whether the given type is inhabited. `None` means that we don't know.\n-        fn ty_inhabited<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<bool> {\n-            use rustc_type_ir::sty::TyKind::*;\n-            if !cx.tcx.type_uninhabited_from(cx.param_env.and(ty)).is_empty() {\n-                // This is definitely uninhabited from some module.\n-                return Some(false);\n-            }\n-            match ty.kind() {\n-                Never => Some(false),\n-                Int(_) | Uint(_) | Float(_) | Bool | Char | RawPtr(_) => Some(true),\n-                // Fallback for more complicated types. (Note that `&!` might be considered\n-                // uninhabited so references are \"complicated\", too.)\n-                _ => None,\n-            }\n-        }\n-        /// Determines whether a product type formed from a list of types is inhabited.\n-        fn tys_inhabited<'tcx>(\n-            cx: &LateContext<'tcx>,\n-            tys: impl Iterator<Item = Ty<'tcx>>,\n-        ) -> Option<bool> {\n-            let mut definitely_inhabited = true; // with no fields, we are definitely inhabited.\n-            for ty in tys {\n-                match ty_inhabited(cx, ty) {\n-                    // If any type is uninhabited, the product is uninhabited.\n-                    Some(false) => return Some(false),\n-                    // Otherwise go searching for a `None`.\n-                    None => {\n-                        // We don't know.\n-                        definitely_inhabited = false;\n-                    }\n-                    Some(true) => {}\n-                }\n-            }\n-            if definitely_inhabited { Some(true) } else { None }\n-        }\n-\n         fn variant_find_init_error<'tcx>(\n             cx: &LateContext<'tcx>,\n             variant: &VariantDef,\n@@ -2570,7 +2526,10 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n                         // return `Bound::Excluded`.  (And we have tests checking that we\n                         // handle the attribute correctly.)\n                         // We don't add a span since users cannot declare such types anyway.\n-                        (Bound::Included(lo), _) if lo > 0 => {\n+                        (Bound::Included(lo), Bound::Included(hi)) if 0 < lo && lo < hi => {\n+                            return Some((format!(\"`{}` must be non-null\", ty), None));\n+                        }\n+                        (Bound::Included(lo), Bound::Unbounded) if 0 < lo => {\n                             return Some((format!(\"`{}` must be non-null\", ty), None));\n                         }\n                         (Bound::Included(_), _) | (_, Bound::Included(_))\n@@ -2599,11 +2558,11 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n                     // And now, enums.\n                     let span = cx.tcx.def_span(adt_def.did());\n                     let mut potential_variants = adt_def.variants().iter().filter_map(|variant| {\n-                        let inhabited = tys_inhabited(\n-                            cx,\n-                            variant.fields.iter().map(|field| field.ty(cx.tcx, substs)),\n-                        );\n-                        let definitely_inhabited = match inhabited {\n+                        let definitely_inhabited = match variant\n+                            .inhabited_predicate(cx.tcx, *adt_def)\n+                            .subst(cx.tcx, substs)\n+                            .apply_any_module(cx.tcx, cx.param_env)\n+                        {\n                             // Entirely skip uninhbaited variants.\n                             Some(false) => return None,\n                             // Forward the others, but remember which ones are definitely inhabited.\n@@ -3051,9 +3010,9 @@ impl<'tcx> LateLintPass<'tcx> for ClashingExternDeclarations {\n                     // Finally, emit the diagnostic.\n \n                     let msg = if orig.get_name() == this_fi.ident.name {\n-                        fluent::lint::builtin_clashing_extern_same_name\n+                        fluent::lint_builtin_clashing_extern_same_name\n                     } else {\n-                        fluent::lint::builtin_clashing_extern_diff_name\n+                        fluent::lint_builtin_clashing_extern_diff_name\n                     };\n                     tcx.struct_span_lint_hir(\n                         CLASHING_EXTERN_DECLARATIONS,\n@@ -3068,14 +3027,8 @@ impl<'tcx> LateLintPass<'tcx> for ClashingExternDeclarations {\n \n                             lint.set_arg(\"this_fi\", this_fi.ident.name)\n                                 .set_arg(\"orig\", orig.get_name())\n-                                .span_label(\n-                                    get_relevant_span(orig_fi),\n-                                    fluent::lint::previous_decl_label,\n-                                )\n-                                .span_label(\n-                                    get_relevant_span(this_fi),\n-                                    fluent::lint::mismatch_label,\n-                                )\n+                                .span_label(get_relevant_span(orig_fi), fluent::previous_decl_label)\n+                                .span_label(get_relevant_span(this_fi), fluent::mismatch_label)\n                                 // FIXME(davidtwco): translatable expected/found\n                                 .note_expected_found(&\"\", expected_str, &\"\", found_str)\n                         },\n@@ -3161,8 +3114,8 @@ impl<'tcx> LateLintPass<'tcx> for DerefNullPtr {\n                 cx.struct_span_lint(\n                     DEREF_NULLPTR,\n                     expr.span,\n-                    fluent::lint::builtin_deref_nullptr,\n-                    |lint| lint.span_label(expr.span, fluent::lint::label),\n+                    fluent::lint_builtin_deref_nullptr,\n+                    |lint| lint.span_label(expr.span, fluent::label),\n                 );\n             }\n         }\n@@ -3176,6 +3129,7 @@ declare_lint! {\n     /// ### Example\n     ///\n     /// ```rust,compile_fail\n+    /// # #![feature(asm_experimental_arch)]\n     /// use std::arch::asm;\n     ///\n     /// fn main() {\n@@ -3273,7 +3227,7 @@ impl<'tcx> LateLintPass<'tcx> for NamedAsmLabels {\n                     cx.lookup_with_diagnostics(\n                             NAMED_ASM_LABELS,\n                             Some(target_spans),\n-                            fluent::lint::builtin_asm_labels,\n+                            fluent::lint_builtin_asm_labels,\n                             |lint| lint,\n                             BuiltinLintDiagnostics::NamedAsmLabel(\n                                 \"only local labels of the form `<number>:` should be used in inline asm\"\n@@ -3376,8 +3330,8 @@ impl EarlyLintPass for UnexpectedCfgs {\n                     cx.lookup(\n                         UNEXPECTED_CFGS,\n                         None::<MultiSpan>,\n-                        fluent::lint::builtin_unexpected_cli_config_name,\n-                        |diag| diag.help(fluent::lint::help).set_arg(\"name\", name),\n+                        fluent::lint_builtin_unexpected_cli_config_name,\n+                        |diag| diag.help(fluent::help).set_arg(\"name\", name),\n                     );\n                 }\n             }\n@@ -3387,9 +3341,9 @@ impl EarlyLintPass for UnexpectedCfgs {\n                         cx.lookup(\n                             UNEXPECTED_CFGS,\n                             None::<MultiSpan>,\n-                            fluent::lint::builtin_unexpected_cli_config_value,\n+                            fluent::lint_builtin_unexpected_cli_config_value,\n                             |diag| {\n-                                diag.help(fluent::lint::help)\n+                                diag.help(fluent::help)\n                                     .set_arg(\"name\", name)\n                                     .set_arg(\"value\", value)\n                             },"}, {"sha": "f9d7466228ad1fef85711256ceabd2cecc8b12dd", "filename": "compiler/rustc_lint/src/enum_intrinsics_non_enums.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_lint%2Fsrc%2Fenum_intrinsics_non_enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_lint%2Fsrc%2Fenum_intrinsics_non_enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fenum_intrinsics_non_enums.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -53,8 +53,8 @@ fn enforce_mem_discriminant(\n         cx.struct_span_lint(\n             ENUM_INTRINSICS_NON_ENUMS,\n             expr_span,\n-            fluent::lint::enum_intrinsics_mem_discriminant,\n-            |lint| lint.set_arg(\"ty_param\", ty_param).span_note(args_span, fluent::lint::note),\n+            fluent::lint_enum_intrinsics_mem_discriminant,\n+            |lint| lint.set_arg(\"ty_param\", ty_param).span_note(args_span, fluent::note),\n         );\n     }\n }\n@@ -65,8 +65,8 @@ fn enforce_mem_variant_count(cx: &LateContext<'_>, func_expr: &hir::Expr<'_>, sp\n         cx.struct_span_lint(\n             ENUM_INTRINSICS_NON_ENUMS,\n             span,\n-            fluent::lint::enum_intrinsics_mem_variant,\n-            |lint| lint.set_arg(\"ty_param\", ty_param).note(fluent::lint::note),\n+            fluent::lint_enum_intrinsics_mem_variant,\n+            |lint| lint.set_arg(\"ty_param\", ty_param).note(fluent::note),\n         );\n     }\n }"}, {"sha": "a49d1bdacc25b087f200cbae6f7f4efe7fb50e4b", "filename": "compiler/rustc_lint/src/errors.rs", "status": "modified", "additions": 18, "deletions": 39, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_lint%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_lint%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ferrors.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -7,7 +7,7 @@ use rustc_session::lint::Level;\n use rustc_span::{Span, Symbol};\n \n #[derive(Diagnostic)]\n-#[diag(lint::overruled_attribute, code = \"E0453\")]\n+#[diag(lint_overruled_attribute, code = \"E0453\")]\n pub struct OverruledAttribute {\n     #[primary_span]\n     pub span: Span,\n@@ -32,24 +32,24 @@ impl AddToDiagnostic for OverruledAttributeSub {\n     {\n         match self {\n             OverruledAttributeSub::DefaultSource { id } => {\n-                diag.note(fluent::lint::default_source);\n+                diag.note(fluent::lint_default_source);\n                 diag.set_arg(\"id\", id);\n             }\n             OverruledAttributeSub::NodeSource { span, reason } => {\n-                diag.span_label(span, fluent::lint::node_source);\n+                diag.span_label(span, fluent::lint_node_source);\n                 if let Some(rationale) = reason {\n                     diag.note(rationale.as_str());\n                 }\n             }\n             OverruledAttributeSub::CommandLineSource => {\n-                diag.note(fluent::lint::command_line_source);\n+                diag.note(fluent::lint_command_line_source);\n             }\n         }\n     }\n }\n \n #[derive(Diagnostic)]\n-#[diag(lint::malformed_attribute, code = \"E0452\")]\n+#[diag(lint_malformed_attribute, code = \"E0452\")]\n pub struct MalformedAttribute {\n     #[primary_span]\n     pub span: Span,\n@@ -59,16 +59,16 @@ pub struct MalformedAttribute {\n \n #[derive(Subdiagnostic)]\n pub enum MalformedAttributeSub {\n-    #[label(lint::bad_attribute_argument)]\n+    #[label(lint_bad_attribute_argument)]\n     BadAttributeArgument(#[primary_span] Span),\n-    #[label(lint::reason_must_be_string_literal)]\n+    #[label(lint_reason_must_be_string_literal)]\n     ReasonMustBeStringLiteral(#[primary_span] Span),\n-    #[label(lint::reason_must_come_last)]\n+    #[label(lint_reason_must_come_last)]\n     ReasonMustComeLast(#[primary_span] Span),\n }\n \n #[derive(Diagnostic)]\n-#[diag(lint::unknown_tool_in_scoped_lint, code = \"E0710\")]\n+#[diag(lint_unknown_tool_in_scoped_lint, code = \"E0710\")]\n pub struct UnknownToolInScopedLint {\n     #[primary_span]\n     pub span: Option<Span>,\n@@ -79,7 +79,7 @@ pub struct UnknownToolInScopedLint {\n }\n \n #[derive(Diagnostic)]\n-#[diag(lint::builtin_ellipsis_inclusive_range_patterns, code = \"E0783\")]\n+#[diag(lint_builtin_ellipsis_inclusive_range_patterns, code = \"E0783\")]\n pub struct BuiltinEllpisisInclusiveRangePatterns {\n     #[primary_span]\n     pub span: Span,\n@@ -88,36 +88,15 @@ pub struct BuiltinEllpisisInclusiveRangePatterns {\n     pub replace: String,\n }\n \n+#[derive(Subdiagnostic)]\n+#[note(lint_requested_level)]\n pub struct RequestedLevel {\n     pub level: Level,\n     pub lint_name: String,\n }\n \n-impl AddToDiagnostic for RequestedLevel {\n-    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F)\n-    where\n-        F: Fn(&mut Diagnostic, SubdiagnosticMessage) -> SubdiagnosticMessage,\n-    {\n-        diag.note(fluent::lint::requested_level);\n-        diag.set_arg(\n-            \"level\",\n-            match self.level {\n-                Level::Allow => \"-A\",\n-                Level::Warn => \"-W\",\n-                Level::ForceWarn(_) => \"--force-warn\",\n-                Level::Deny => \"-D\",\n-                Level::Forbid => \"-F\",\n-                Level::Expect(_) => {\n-                    unreachable!(\"lints with the level of `expect` should not run this code\");\n-                }\n-            },\n-        );\n-        diag.set_arg(\"lint_name\", self.lint_name);\n-    }\n-}\n-\n #[derive(Diagnostic)]\n-#[diag(lint::unsupported_group, code = \"E0602\")]\n+#[diag(lint_unsupported_group, code = \"E0602\")]\n pub struct UnsupportedGroup {\n     pub lint_group: String,\n }\n@@ -133,10 +112,10 @@ impl IntoDiagnostic<'_> for CheckNameUnknown {\n         self,\n         handler: &Handler,\n     ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n-        let mut diag = handler.struct_err(fluent::lint::check_name_unknown);\n+        let mut diag = handler.struct_err(fluent::lint_check_name_unknown);\n         diag.code(rustc_errors::error_code!(E0602));\n         if let Some(suggestion) = self.suggestion {\n-            diag.help(fluent::lint::help);\n+            diag.help(fluent::help);\n             diag.set_arg(\"suggestion\", suggestion);\n         }\n         diag.set_arg(\"lint_name\", self.lint_name);\n@@ -146,23 +125,23 @@ impl IntoDiagnostic<'_> for CheckNameUnknown {\n }\n \n #[derive(Diagnostic)]\n-#[diag(lint::check_name_unknown_tool, code = \"E0602\")]\n+#[diag(lint_check_name_unknown_tool, code = \"E0602\")]\n pub struct CheckNameUnknownTool {\n     pub tool_name: Symbol,\n     #[subdiagnostic]\n     pub sub: RequestedLevel,\n }\n \n #[derive(Diagnostic)]\n-#[diag(lint::check_name_warning)]\n+#[diag(lint_check_name_warning)]\n pub struct CheckNameWarning {\n     pub msg: String,\n     #[subdiagnostic]\n     pub sub: RequestedLevel,\n }\n \n #[derive(Diagnostic)]\n-#[diag(lint::check_name_deprecated)]\n+#[diag(lint_check_name_deprecated)]\n pub struct CheckNameDeprecated {\n     pub lint_name: String,\n     pub new_name: String,"}, {"sha": "cf8f31bcbd0650780b9374bed416b0cb9c9f95ce", "filename": "compiler/rustc_lint/src/expect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_lint%2Fsrc%2Fexpect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_lint%2Fsrc%2Fexpect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fexpect.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -45,14 +45,14 @@ fn emit_unfulfilled_expectation_lint(\n         builtin::UNFULFILLED_LINT_EXPECTATIONS,\n         hir_id,\n         expectation.emission_span,\n-        fluent::lint::expectation,\n+        fluent::lint_expectation,\n         |lint| {\n             if let Some(rationale) = expectation.reason {\n                 lint.note(rationale.as_str());\n             }\n \n             if expectation.is_unfulfilled_lint_expectations {\n-                lint.note(fluent::lint::note);\n+                lint.note(fluent::note);\n             }\n \n             lint"}, {"sha": "7e884e990ce35b084efa388271cb40d4bccf4491", "filename": "compiler/rustc_lint/src/hidden_unicode_codepoints.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_lint%2Fsrc%2Fhidden_unicode_codepoints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_lint%2Fsrc%2Fhidden_unicode_codepoints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fhidden_unicode_codepoints.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -63,26 +63,26 @@ impl HiddenUnicodeCodepoints {\n         cx.struct_span_lint(\n             TEXT_DIRECTION_CODEPOINT_IN_LITERAL,\n             span,\n-            fluent::lint::hidden_unicode_codepoints,\n+            fluent::lint_hidden_unicode_codepoints,\n             |lint| {\n                 lint.set_arg(\"label\", label);\n                 lint.set_arg(\"count\", spans.len());\n-                lint.span_label(span, fluent::lint::label);\n-                lint.note(fluent::lint::note);\n+                lint.span_label(span, fluent::label);\n+                lint.note(fluent::note);\n                 if point_at_inner_spans {\n                     for (c, span) in &spans {\n                         lint.span_label(*span, format!(\"{:?}\", c));\n                     }\n                 }\n                 if point_at_inner_spans && !spans.is_empty() {\n                     lint.multipart_suggestion_with_style(\n-                        fluent::lint::suggestion_remove,\n+                        fluent::suggestion_remove,\n                         spans.iter().map(|(_, span)| (*span, \"\".to_string())).collect(),\n                         Applicability::MachineApplicable,\n                         SuggestionStyle::HideCodeAlways,\n                     );\n                     lint.multipart_suggestion(\n-                        fluent::lint::suggestion_escape,\n+                        fluent::suggestion_escape,\n                         spans\n                             .into_iter()\n                             .map(|(c, span)| {\n@@ -104,8 +104,8 @@ impl HiddenUnicodeCodepoints {\n                             .collect::<Vec<String>>()\n                             .join(\", \"),\n                     );\n-                    lint.note(fluent::lint::suggestion_remove);\n-                    lint.note(fluent::lint::no_suggestion_note_escape);\n+                    lint.note(fluent::suggestion_remove);\n+                    lint.note(fluent::no_suggestion_note_escape);\n                 }\n                 lint\n             },"}, {"sha": "11e4650cb4b644f0072fc640077f986cb98bde43", "filename": "compiler/rustc_lint/src/internal.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finternal.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -37,11 +37,11 @@ impl LateLintPass<'_> for DefaultHashTypes {\n         cx.struct_span_lint(\n             DEFAULT_HASH_TYPES,\n             path.span,\n-            fluent::lint::default_hash_types,\n+            fluent::lint_default_hash_types,\n             |lint| {\n                 lint.set_arg(\"preferred\", replace)\n                     .set_arg(\"used\", cx.tcx.item_name(def_id))\n-                    .note(fluent::lint::note)\n+                    .note(fluent::note)\n             },\n         );\n     }\n@@ -86,8 +86,8 @@ impl LateLintPass<'_> for QueryStability {\n                 cx.struct_span_lint(\n                     POTENTIAL_QUERY_INSTABILITY,\n                     span,\n-                    fluent::lint::query_instability,\n-                    |lint| lint.set_arg(\"query\", cx.tcx.item_name(def_id)).note(fluent::lint::note),\n+                    fluent::lint_query_instability,\n+                    |lint| lint.set_arg(\"query\", cx.tcx.item_name(def_id)).note(fluent::note),\n                 )\n             }\n         }\n@@ -126,11 +126,11 @@ impl<'tcx> LateLintPass<'tcx> for TyTyKind {\n             let span = path.span.with_hi(\n                 segment.args.map_or(segment.ident.span, |a| a.span_ext).hi()\n             );\n-            cx.struct_span_lint(USAGE_OF_TY_TYKIND, path.span, fluent::lint::tykind_kind, |lint| {\n+            cx.struct_span_lint(USAGE_OF_TY_TYKIND, path.span, fluent::lint_tykind_kind, |lint| {\n                 lint\n                     .span_suggestion(\n                         span,\n-                        fluent::lint::suggestion,\n+                        fluent::suggestion,\n                         \"ty\",\n                         Applicability::MaybeIncorrect, // ty maybe needs an import\n                     )\n@@ -193,10 +193,10 @@ impl<'tcx> LateLintPass<'tcx> for TyTyKind {\n                             cx.struct_span_lint(\n                                 USAGE_OF_TY_TYKIND,\n                                 path.span,\n-                                fluent::lint::tykind_kind,\n+                                fluent::lint_tykind_kind,\n                                 |lint| lint.span_suggestion(\n                                     span,\n-                                    fluent::lint::suggestion,\n+                                    fluent::suggestion,\n                                     \"ty\",\n                                     Applicability::MaybeIncorrect, // ty maybe needs an import\n                                 )\n@@ -205,18 +205,18 @@ impl<'tcx> LateLintPass<'tcx> for TyTyKind {\n                         None => cx.struct_span_lint(\n                             USAGE_OF_TY_TYKIND,\n                             path.span,\n-                            fluent::lint::tykind,\n-                            |lint| lint.help(fluent::lint::help)\n+                            fluent::lint_tykind,\n+                            |lint| lint.help(fluent::help)\n                         )\n                     }\n                 } else if !ty.span.from_expansion() && let Some(t) = is_ty_or_ty_ctxt(cx, &path) {\n                     if path.segments.len() > 1 {\n-                        cx.struct_span_lint(USAGE_OF_QUALIFIED_TY, path.span, fluent::lint::ty_qualified, |lint| {\n+                        cx.struct_span_lint(USAGE_OF_QUALIFIED_TY, path.span, fluent::lint_ty_qualified, |lint| {\n                             lint\n                                 .set_arg(\"ty\", t.clone())\n                                 .span_suggestion(\n                                     path.span,\n-                                    fluent::lint::suggestion,\n+                                    fluent::suggestion,\n                                     t,\n                                     // The import probably needs to be changed\n                                     Applicability::MaybeIncorrect,\n@@ -310,8 +310,8 @@ impl EarlyLintPass for LintPassImpl {\n                         cx.struct_span_lint(\n                             LINT_PASS_IMPL_WITHOUT_MACRO,\n                             lint_pass.path.span,\n-                            fluent::lint::lintpass_by_hand,\n-                            |lint| lint.help(fluent::lint::help),\n+                            fluent::lint_lintpass_by_hand,\n+                            |lint| lint.help(fluent::help),\n                         )\n                     }\n                 }\n@@ -351,8 +351,8 @@ impl<'tcx> LateLintPass<'tcx> for ExistingDocKeyword {\n                         cx.struct_span_lint(\n                             EXISTING_DOC_KEYWORD,\n                             attr.span,\n-                            fluent::lint::non_existant_doc_keyword,\n-                            |lint| lint.set_arg(\"keyword\", v).help(fluent::lint::help),\n+                            fluent::lint_non_existant_doc_keyword,\n+                            |lint| lint.set_arg(\"keyword\", v).help(fluent::help),\n                         );\n                     }\n                 }\n@@ -414,7 +414,7 @@ impl LateLintPass<'_> for Diagnostics {\n             cx.struct_span_lint(\n                 DIAGNOSTIC_OUTSIDE_OF_IMPL,\n                 span,\n-                fluent::lint::diag_out_of_impl,\n+                fluent::lint_diag_out_of_impl,\n                 |lint| lint,\n             )\n         }\n@@ -435,7 +435,7 @@ impl LateLintPass<'_> for Diagnostics {\n             cx.struct_span_lint(\n                 UNTRANSLATABLE_DIAGNOSTIC,\n                 span,\n-                fluent::lint::untranslatable_diag,\n+                fluent::lint_untranslatable_diag,\n                 |lint| lint,\n             )\n         }"}, {"sha": "db0a3419e6a5da4e084a6d1ce32b3b2d4de9de1c", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -960,7 +960,7 @@ impl<'s, P: LintLevelsProvider> LintLevelsBuilder<'s, P> {\n                                         sp,\n                                         \"did you mean\",\n                                         suggestion,\n-                                        Applicability::MachineApplicable,\n+                                        Applicability::MaybeIncorrect,\n                                     );\n                                 }\n                                 lint"}, {"sha": "e2d7d5b49f69358bdd9dcf179dbfcdac80f1fcdb", "filename": "compiler/rustc_lint/src/methods.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_lint%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_lint%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fmethods.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -93,12 +93,12 @@ fn lint_cstring_as_ptr(\n                     cx.struct_span_lint(\n                         TEMPORARY_CSTRING_AS_PTR,\n                         as_ptr_span,\n-                        fluent::lint::cstring_ptr,\n+                        fluent::lint_cstring_ptr,\n                         |diag| {\n-                            diag.span_label(as_ptr_span, fluent::lint::as_ptr_label)\n-                                .span_label(unwrap.span, fluent::lint::unwrap_label)\n-                                .note(fluent::lint::note)\n-                                .help(fluent::lint::help)\n+                            diag.span_label(as_ptr_span, fluent::as_ptr_label)\n+                                .span_label(unwrap.span, fluent::unwrap_label)\n+                                .note(fluent::note)\n+                                .help(fluent::help)\n                         },\n                     );\n                 }"}, {"sha": "dea9506acb200fcec3e4a02afdcd857cf64007e1", "filename": "compiler/rustc_lint/src/non_ascii_idents.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_lint%2Fsrc%2Fnon_ascii_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_lint%2Fsrc%2Fnon_ascii_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnon_ascii_idents.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -183,7 +183,7 @@ impl EarlyLintPass for NonAsciiIdents {\n             cx.struct_span_lint(\n                 NON_ASCII_IDENTS,\n                 sp,\n-                fluent::lint::identifier_non_ascii_char,\n+                fluent::lint_identifier_non_ascii_char,\n                 |lint| lint,\n             );\n             if check_uncommon_codepoints\n@@ -192,7 +192,7 @@ impl EarlyLintPass for NonAsciiIdents {\n                 cx.struct_span_lint(\n                     UNCOMMON_CODEPOINTS,\n                     sp,\n-                    fluent::lint::identifier_uncommon_codepoints,\n+                    fluent::lint_identifier_uncommon_codepoints,\n                     |lint| lint,\n                 )\n             }\n@@ -225,11 +225,11 @@ impl EarlyLintPass for NonAsciiIdents {\n                             cx.struct_span_lint(\n                                 CONFUSABLE_IDENTS,\n                                 sp,\n-                                fluent::lint::confusable_identifier_pair,\n+                                fluent::lint_confusable_identifier_pair,\n                                 |lint| {\n                                     lint.set_arg(\"existing_sym\", *existing_symbol)\n                                         .set_arg(\"sym\", symbol)\n-                                        .span_label(*existing_span, fluent::lint::label)\n+                                        .span_label(*existing_span, fluent::label)\n                                 },\n                             );\n                         }\n@@ -334,7 +334,7 @@ impl EarlyLintPass for NonAsciiIdents {\n                     cx.struct_span_lint(\n                         MIXED_SCRIPT_CONFUSABLES,\n                         sp,\n-                        fluent::lint::mixed_script_confusables,\n+                        fluent::lint_mixed_script_confusables,\n                         |lint| {\n                             let mut includes = String::new();\n                             for (idx, ch) in ch_list.into_iter().enumerate() {\n@@ -346,8 +346,8 @@ impl EarlyLintPass for NonAsciiIdents {\n                             }\n                             lint.set_arg(\"set\", script_set.to_string())\n                                 .set_arg(\"includes\", includes)\n-                                .note(fluent::lint::includes_note)\n-                                .note(fluent::lint::note)\n+                                .note(fluent::includes_note)\n+                                .note(fluent::note)\n                         },\n                     );\n                 }"}, {"sha": "6ad2e0294b9b0af0774f81ed9422479c691e2a0a", "filename": "compiler/rustc_lint/src/non_fmt_panic.rs", "status": "modified", "additions": 30, "deletions": 35, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -119,20 +119,20 @@ fn check_panic<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>, arg: &'tc\n         arg_span = expn.call_site;\n     }\n \n-    cx.struct_span_lint(NON_FMT_PANICS, arg_span, fluent::lint::non_fmt_panic, |lint| {\n+    cx.struct_span_lint(NON_FMT_PANICS, arg_span, fluent::lint_non_fmt_panic, |lint| {\n         lint.set_arg(\"name\", symbol);\n-        lint.note(fluent::lint::note);\n-        lint.note(fluent::lint::more_info_note);\n+        lint.note(fluent::note);\n+        lint.note(fluent::more_info_note);\n         if !is_arg_inside_call(arg_span, span) {\n             // No clue where this argument is coming from.\n             return lint;\n         }\n         if arg_macro.map_or(false, |id| cx.tcx.is_diagnostic_item(sym::format_macro, id)) {\n             // A case of `panic!(format!(..))`.\n-            lint.note(fluent::lint::supports_fmt_note);\n+            lint.note(fluent::supports_fmt_note);\n             if let Some((open, close, _)) = find_delimiters(cx, arg_span) {\n                 lint.multipart_suggestion(\n-                    fluent::lint::supports_fmt_suggestion,\n+                    fluent::supports_fmt_suggestion,\n                     vec![\n                         (arg_span.until(open.shrink_to_hi()), \"\".into()),\n                         (close.until(arg_span.shrink_to_hi()), \"\".into()),\n@@ -178,15 +178,15 @@ fn check_panic<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>, arg: &'tc\n             if suggest_display {\n                 lint.span_suggestion_verbose(\n                     arg_span.shrink_to_lo(),\n-                    fluent::lint::display_suggestion,\n+                    fluent::display_suggestion,\n                     \"\\\"{}\\\", \",\n                     fmt_applicability,\n                 );\n             } else if suggest_debug {\n                 lint.set_arg(\"ty\", ty);\n                 lint.span_suggestion_verbose(\n                     arg_span.shrink_to_lo(),\n-                    fluent::lint::debug_suggestion,\n+                    fluent::debug_suggestion,\n                     \"\\\"{:?}\\\", \",\n                     fmt_applicability,\n                 );\n@@ -196,7 +196,7 @@ fn check_panic<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>, arg: &'tc\n                 if let Some((open, close, del)) = find_delimiters(cx, span) {\n                     lint.set_arg(\"already_suggested\", suggest_display || suggest_debug);\n                     lint.multipart_suggestion(\n-                        fluent::lint::panic_suggestion,\n+                        fluent::panic_suggestion,\n                         if del == '(' {\n                             vec![(span.until(open), \"std::panic::panic_any\".into())]\n                         } else {\n@@ -254,30 +254,25 @@ fn check_panic_str<'tcx>(\n                 .map(|span| fmt_span.from_inner(InnerSpan::new(span.start, span.end)))\n                 .collect(),\n         };\n-        cx.struct_span_lint(\n-            NON_FMT_PANICS,\n-            arg_spans,\n-            fluent::lint::non_fmt_panic_unused,\n-            |lint| {\n-                lint.set_arg(\"count\", n_arguments);\n-                lint.note(fluent::lint::note);\n-                if is_arg_inside_call(arg.span, span) {\n-                    lint.span_suggestion(\n-                        arg.span.shrink_to_hi(),\n-                        fluent::lint::add_args_suggestion,\n-                        \", ...\",\n-                        Applicability::HasPlaceholders,\n-                    );\n-                    lint.span_suggestion(\n-                        arg.span.shrink_to_lo(),\n-                        fluent::lint::add_fmt_suggestion,\n-                        \"\\\"{}\\\", \",\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-                lint\n-            },\n-        );\n+        cx.struct_span_lint(NON_FMT_PANICS, arg_spans, fluent::lint_non_fmt_panic_unused, |lint| {\n+            lint.set_arg(\"count\", n_arguments);\n+            lint.note(fluent::note);\n+            if is_arg_inside_call(arg.span, span) {\n+                lint.span_suggestion(\n+                    arg.span.shrink_to_hi(),\n+                    fluent::add_args_suggestion,\n+                    \", ...\",\n+                    Applicability::HasPlaceholders,\n+                );\n+                lint.span_suggestion(\n+                    arg.span.shrink_to_lo(),\n+                    fluent::add_fmt_suggestion,\n+                    \"\\\"{}\\\", \",\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+            lint\n+        });\n     } else {\n         let brace_spans: Option<Vec<_>> =\n             snippet.filter(|s| s.starts_with('\"') || s.starts_with(\"r#\")).map(|s| {\n@@ -290,14 +285,14 @@ fn check_panic_str<'tcx>(\n         cx.struct_span_lint(\n             NON_FMT_PANICS,\n             brace_spans.unwrap_or_else(|| vec![span]),\n-            fluent::lint::non_fmt_panic_braces,\n+            fluent::lint_non_fmt_panic_braces,\n             |lint| {\n                 lint.set_arg(\"count\", count);\n-                lint.note(fluent::lint::note);\n+                lint.note(fluent::note);\n                 if is_arg_inside_call(arg.span, span) {\n                     lint.span_suggestion(\n                         arg.span.shrink_to_lo(),\n-                        fluent::lint::suggestion,\n+                        fluent::suggestion,\n                         \"\\\"{}\\\", \",\n                         Applicability::MachineApplicable,\n                     );"}, {"sha": "7e50801f80c7bbbf6797b8aa84224ff84dc61b18", "filename": "compiler/rustc_lint/src/nonstandard_style.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -139,20 +139,20 @@ impl NonCamelCaseTypes {\n             cx.struct_span_lint(\n                 NON_CAMEL_CASE_TYPES,\n                 ident.span,\n-                fluent::lint::non_camel_case_type,\n+                fluent::lint_non_camel_case_type,\n                 |lint| {\n                     let cc = to_camel_case(name);\n                     // We cannot provide meaningful suggestions\n                     // if the characters are in the category of \"Lowercase Letter\".\n                     if *name != cc {\n                         lint.span_suggestion(\n                             ident.span,\n-                            fluent::lint::suggestion,\n+                            fluent::suggestion,\n                             to_camel_case(name),\n                             Applicability::MaybeIncorrect,\n                         );\n                     } else {\n-                        lint.span_label(ident.span, fluent::lint::label);\n+                        lint.span_label(ident.span, fluent::label);\n                     }\n \n                     lint.set_arg(\"sort\", sort);\n@@ -284,7 +284,7 @@ impl NonSnakeCase {\n         let name = ident.name.as_str();\n \n         if !is_snake_case(name) {\n-            cx.struct_span_lint(NON_SNAKE_CASE, ident.span, fluent::lint::non_snake_case, |lint| {\n+            cx.struct_span_lint(NON_SNAKE_CASE, ident.span, fluent::lint_non_snake_case, |lint| {\n                 let sc = NonSnakeCase::to_snake_case(name);\n                 // We cannot provide meaningful suggestions\n                 // if the characters are in the category of \"Uppercase Letter\".\n@@ -298,13 +298,13 @@ impl NonSnakeCase {\n                             // Instead, recommend renaming the identifier entirely or, if permitted,\n                             // escaping it to create a raw identifier.\n                             if sc_ident.name.can_be_raw() {\n-                                (fluent::lint::rename_or_convert_suggestion, sc_ident.to_string())\n+                                (fluent::rename_or_convert_suggestion, sc_ident.to_string())\n                             } else {\n-                                lint.note(fluent::lint::cannot_convert_note);\n-                                (fluent::lint::rename_suggestion, String::new())\n+                                lint.note(fluent::cannot_convert_note);\n+                                (fluent::rename_suggestion, String::new())\n                             }\n                         } else {\n-                            (fluent::lint::convert_suggestion, sc.clone())\n+                            (fluent::convert_suggestion, sc.clone())\n                         };\n \n                         lint.span_suggestion(\n@@ -314,10 +314,10 @@ impl NonSnakeCase {\n                             Applicability::MaybeIncorrect,\n                         );\n                     } else {\n-                        lint.help(fluent::lint::help);\n+                        lint.help(fluent::help);\n                     }\n                 } else {\n-                    lint.span_label(ident.span, fluent::lint::label);\n+                    lint.span_label(ident.span, fluent::label);\n                 }\n \n                 lint.set_arg(\"sort\", sort);\n@@ -484,20 +484,20 @@ impl NonUpperCaseGlobals {\n             cx.struct_span_lint(\n                 NON_UPPER_CASE_GLOBALS,\n                 ident.span,\n-                fluent::lint::non_upper_case_global,\n+                fluent::lint_non_upper_case_global,\n                 |lint| {\n                     let uc = NonSnakeCase::to_snake_case(&name).to_uppercase();\n                     // We cannot provide meaningful suggestions\n                     // if the characters are in the category of \"Lowercase Letter\".\n                     if *name != uc {\n                         lint.span_suggestion(\n                             ident.span,\n-                            fluent::lint::suggestion,\n+                            fluent::suggestion,\n                             uc,\n                             Applicability::MaybeIncorrect,\n                         );\n                     } else {\n-                        lint.span_label(ident.span, fluent::lint::label);\n+                        lint.span_label(ident.span, fluent::label);\n                     }\n \n                     lint.set_arg(\"sort\", sort);"}, {"sha": "2ef425a1093121532b516076b83accf15cfc6bc1", "filename": "compiler/rustc_lint/src/noop_method_call.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -85,11 +85,11 @@ impl<'tcx> LateLintPass<'tcx> for NoopMethodCall {\n         }\n         let expr_span = expr.span;\n         let span = expr_span.with_lo(receiver.span.hi());\n-        cx.struct_span_lint(NOOP_METHOD_CALL, span, fluent::lint::noop_method_call, |lint| {\n+        cx.struct_span_lint(NOOP_METHOD_CALL, span, fluent::lint_noop_method_call, |lint| {\n             lint.set_arg(\"method\", call.ident.name)\n                 .set_arg(\"receiver_ty\", receiver_ty)\n-                .span_label(span, fluent::lint::label)\n-                .note(fluent::lint::note)\n+                .span_label(span, fluent::label)\n+                .note(fluent::note)\n         });\n     }\n }"}, {"sha": "7f6f4a0abb4a55413b9dd58b21a1da5d28748d92", "filename": "compiler/rustc_lint/src/opaque_hidden_inferred_bound.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -91,14 +91,12 @@ impl<'tcx> LateLintPass<'tcx> for OpaqueHiddenInferredBound {\n             // For example, in `impl Trait<Assoc = impl Send>`, for all of the bounds on `Assoc`,\n             // e.g. `type Assoc: OtherTrait`, replace `<impl Trait as Trait>::Assoc: OtherTrait`\n             // with `impl Send: OtherTrait`.\n-            for assoc_pred_and_span in\n-                cx.tcx.bound_explicit_item_bounds(proj.projection_ty.item_def_id).transpose_iter()\n+            for (assoc_pred, assoc_pred_span) in cx\n+                .tcx\n+                .bound_explicit_item_bounds(proj.projection_ty.item_def_id)\n+                .subst_iter_copied(cx.tcx, &proj.projection_ty.substs)\n             {\n-                let assoc_pred_span = assoc_pred_and_span.0.1;\n-                let assoc_pred = assoc_pred_and_span\n-                    .map_bound(|(pred, _)| *pred)\n-                    .subst(cx.tcx, &proj.projection_ty.substs)\n-                    .fold_with(proj_replacer);\n+                let assoc_pred = assoc_pred.fold_with(proj_replacer);\n                 let Ok(assoc_pred) = traits::fully_normalize(infcx, traits::ObligationCause::dummy(), cx.param_env, assoc_pred) else {\n                     continue;\n                 };\n@@ -141,19 +139,19 @@ impl<'tcx> LateLintPass<'tcx> for OpaqueHiddenInferredBound {\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(lint::opaque_hidden_inferred_bound)]\n+#[diag(lint_opaque_hidden_inferred_bound)]\n struct OpaqueHiddenInferredBoundLint<'tcx> {\n     ty: Ty<'tcx>,\n     proj_ty: Ty<'tcx>,\n-    #[label(lint::specifically)]\n+    #[label(specifically)]\n     assoc_pred_span: Span,\n     #[subdiagnostic]\n     add_bound: Option<AddBound<'tcx>>,\n }\n \n #[derive(Subdiagnostic)]\n #[suggestion_verbose(\n-    lint::opaque_hidden_inferred_bound_sugg,\n+    lint_opaque_hidden_inferred_bound_sugg,\n     applicability = \"machine-applicable\",\n     code = \" + {trait_ref}\"\n )]"}, {"sha": "01bface718a7802843c08e71a1969272b98a7b56", "filename": "compiler/rustc_lint/src/pass_by_value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -32,11 +32,11 @@ impl<'tcx> LateLintPass<'tcx> for PassByValue {\n                     cx.struct_span_lint(\n                         PASS_BY_VALUE,\n                         ty.span,\n-                        fluent::lint::pass_by_value,\n+                        fluent::lint_pass_by_value,\n                         |lint| {\n                             lint.set_arg(\"ty\", t.clone()).span_suggestion(\n                                 ty.span,\n-                                fluent::lint::suggestion,\n+                                fluent::suggestion,\n                                 t,\n                                 // Changing type of function argument\n                                 Applicability::MaybeIncorrect,"}, {"sha": "3521de7fc08483dcfb48de8d44764b1ad4481dfa", "filename": "compiler/rustc_lint/src/redundant_semicolon.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_lint%2Fsrc%2Fredundant_semicolon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_lint%2Fsrc%2Fredundant_semicolon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fredundant_semicolon.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -51,11 +51,11 @@ fn maybe_lint_redundant_semis(cx: &EarlyContext<'_>, seq: &mut Option<(Span, boo\n         cx.struct_span_lint(\n             REDUNDANT_SEMICOLONS,\n             span,\n-            fluent::lint::redundant_semicolons,\n+            fluent::lint_redundant_semicolons,\n             |lint| {\n                 lint.set_arg(\"multiple\", multiple).span_suggestion(\n                     span,\n-                    fluent::lint::suggestion,\n+                    fluent::suggestion,\n                     \"\",\n                     Applicability::MaybeIncorrect,\n                 )"}, {"sha": "a118dda8b40f16d6e4f5fab2ff064e2d8f8f6b4d", "filename": "compiler/rustc_lint/src/traits.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -106,7 +106,7 @@ impl<'tcx> LateLintPass<'tcx> for DropTraitConstraints {\n                 cx.struct_span_lint(\n                     DROP_BOUNDS,\n                     span,\n-                    fluent::lint::drop_trait_constraints,\n+                    fluent::lint_drop_trait_constraints,\n                     |lint| {\n                         lint.set_arg(\"predicate\", predicate)\n                             .set_arg(\"needs_drop\", cx.tcx.def_path_str(needs_drop))\n@@ -125,7 +125,7 @@ impl<'tcx> LateLintPass<'tcx> for DropTraitConstraints {\n             if cx.tcx.lang_items().drop_trait() == def_id\n                 && let Some(needs_drop) = cx.tcx.get_diagnostic_item(sym::needs_drop)\n             {\n-                cx.struct_span_lint(DYN_DROP, bound.span, fluent::lint::drop_glue, |lint| {\n+                cx.struct_span_lint(DYN_DROP, bound.span, fluent::lint_drop_glue, |lint| {\n                     lint.set_arg(\"needs_drop\", cx.tcx.def_path_str(needs_drop))\n                 });\n             }"}, {"sha": "7c99bb2790fd0705fb551e355b84e6263107a8c1", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 100, "deletions": 98, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -116,8 +116,8 @@ impl TypeLimits {\n     }\n }\n \n-/// Attempts to special-case the overflowing literal lint when it occurs as a range endpoint.\n-/// Returns `true` iff the lint was overridden.\n+/// Attempts to special-case the overflowing literal lint when it occurs as a range endpoint (`expr..MAX+1`).\n+/// Returns `true` iff the lint was emitted.\n fn lint_overflowing_range_endpoint<'tcx>(\n     cx: &LateContext<'tcx>,\n     lit: &hir::Lit,\n@@ -140,44 +140,46 @@ fn lint_overflowing_range_endpoint<'tcx>(\n         return false;\n     }\n \n-    let mut overwritten = false;\n     // We can suggest using an inclusive range\n     // (`..=`) instead only if it is the `end` that is\n     // overflowing and only by 1.\n-    if eps[1].expr.hir_id == expr.hir_id && lit_val - 1 == max\n-        && let Ok(start) = cx.sess().source_map().span_to_snippet(eps[0].span)\n-    {\n-        cx.struct_span_lint(\n-            OVERFLOWING_LITERALS,\n-            struct_expr.span,\n-            fluent::lint::range_endpoint_out_of_range,\n-            |lint| {\n-                use ast::{LitIntType, LitKind};\n-\n-                lint.set_arg(\"ty\", ty);\n-\n-                // We need to preserve the literal's suffix,\n-                // as it may determine typing information.\n-                let suffix = match lit.node {\n-                    LitKind::Int(_, LitIntType::Signed(s)) => s.name_str(),\n-                    LitKind::Int(_, LitIntType::Unsigned(s)) => s.name_str(),\n-                    LitKind::Int(_, LitIntType::Unsuffixed) => \"\",\n-                    _ => bug!(),\n-                };\n-                let suggestion = format!(\"{}..={}{}\", start, lit_val - 1, suffix);\n-                lint.span_suggestion(\n-                    struct_expr.span,\n-                    fluent::lint::suggestion,\n-                    suggestion,\n-                    Applicability::MachineApplicable,\n-                );\n-                overwritten = true;\n+    if !(eps[1].expr.hir_id == expr.hir_id && lit_val - 1 == max) {\n+        return false;\n+    };\n+    let Ok(start) = cx.sess().source_map().span_to_snippet(eps[0].span) else { return false };\n \n-                lint\n-            },\n-        );\n-    }\n-    overwritten\n+    cx.struct_span_lint(\n+        OVERFLOWING_LITERALS,\n+        struct_expr.span,\n+        fluent::lint_range_endpoint_out_of_range,\n+        |lint| {\n+            use ast::{LitIntType, LitKind};\n+\n+            lint.set_arg(\"ty\", ty);\n+\n+            // We need to preserve the literal's suffix,\n+            // as it may determine typing information.\n+            let suffix = match lit.node {\n+                LitKind::Int(_, LitIntType::Signed(s)) => s.name_str(),\n+                LitKind::Int(_, LitIntType::Unsigned(s)) => s.name_str(),\n+                LitKind::Int(_, LitIntType::Unsuffixed) => \"\",\n+                _ => bug!(),\n+            };\n+            let suggestion = format!(\"{}..={}{}\", start, lit_val - 1, suffix);\n+            lint.span_suggestion(\n+                struct_expr.span,\n+                fluent::suggestion,\n+                suggestion,\n+                Applicability::MachineApplicable,\n+            );\n+\n+            lint\n+        },\n+    );\n+\n+    // We've just emitted a lint, special cased for `(...)..MAX+1` ranges,\n+    // return `true` so the callers don't also emit a lint\n+    true\n }\n \n // For `isize` & `usize`, be conservative with the warnings, so that the\n@@ -231,7 +233,7 @@ fn report_bin_hex_error(\n     cx.struct_span_lint(\n         OVERFLOWING_LITERALS,\n         expr.span,\n-        fluent::lint::overflowing_bin_hex,\n+        fluent::lint_overflowing_bin_hex,\n         |lint| {\n             let (t, actually) = match ty {\n                 attr::IntType::SignedInt(t) => {\n@@ -251,10 +253,10 @@ fn report_bin_hex_error(\n             if negative {\n                 // If the value is negative,\n                 // emits a note about the value itself, apart from the literal.\n-                lint.note(fluent::lint::negative_note);\n-                lint.note(fluent::lint::negative_becomes_note);\n+                lint.note(fluent::negative_note);\n+                lint.note(fluent::negative_becomes_note);\n             } else {\n-                lint.note(fluent::lint::positive_note);\n+                lint.note(fluent::positive_note);\n             }\n             if let Some(sugg_ty) =\n                 get_type_suggestion(cx.typeck_results().node_type(expr.hir_id), val, negative)\n@@ -264,12 +266,12 @@ fn report_bin_hex_error(\n                     let (sans_suffix, _) = repr_str.split_at(pos);\n                     lint.span_suggestion(\n                         expr.span,\n-                        fluent::lint::suggestion,\n+                        fluent::suggestion,\n                         format!(\"{}{}\", sans_suffix, sugg_ty),\n                         Applicability::MachineApplicable,\n                     );\n                 } else {\n-                    lint.help(fluent::lint::help);\n+                    lint.help(fluent::help);\n                 }\n             }\n             lint.set_arg(\"ty\", t)\n@@ -358,11 +360,11 @@ fn lint_int_literal<'tcx>(\n         }\n \n         if lint_overflowing_range_endpoint(cx, lit, v, max, e, t.name_str()) {\n-            // The overflowing literal lint was overridden.\n+            // The overflowing literal lint was emited by `lint_overflowing_range_endpoint`.\n             return;\n         }\n \n-        cx.struct_span_lint(OVERFLOWING_LITERALS, e.span, fluent::lint::overflowing_int, |lint| {\n+        cx.struct_span_lint(OVERFLOWING_LITERALS, e.span, fluent::lint_overflowing_int, |lint| {\n             lint.set_arg(\"ty\", t.name_str())\n                 .set_arg(\n                     \"lit\",\n@@ -373,13 +375,13 @@ fn lint_int_literal<'tcx>(\n                 )\n                 .set_arg(\"min\", min)\n                 .set_arg(\"max\", max)\n-                .note(fluent::lint::note);\n+                .note(fluent::note);\n \n             if let Some(sugg_ty) =\n                 get_type_suggestion(cx.typeck_results().node_type(e.hir_id), v, negative)\n             {\n                 lint.set_arg(\"suggestion_ty\", sugg_ty);\n-                lint.help(fluent::lint::help);\n+                lint.help(fluent::help);\n             }\n \n             lint\n@@ -410,11 +412,11 @@ fn lint_uint_literal<'tcx>(\n                         cx.struct_span_lint(\n                             OVERFLOWING_LITERALS,\n                             par_e.span,\n-                            fluent::lint::only_cast_u8_to_char,\n+                            fluent::lint_only_cast_u8_to_char,\n                             |lint| {\n                                 lint.span_suggestion(\n                                     par_e.span,\n-                                    fluent::lint::suggestion,\n+                                    fluent::suggestion,\n                                     format!(\"'\\\\u{{{:X}}}'\", lit_val),\n                                     Applicability::MachineApplicable,\n                                 )\n@@ -427,7 +429,7 @@ fn lint_uint_literal<'tcx>(\n             }\n         }\n         if lint_overflowing_range_endpoint(cx, lit, lit_val, max, e, t.name_str()) {\n-            // The overflowing literal lint was overridden.\n+            // The overflowing literal lint was emited by `lint_overflowing_range_endpoint`.\n             return;\n         }\n         if let Some(repr_str) = get_bin_hex_repr(cx, lit) {\n@@ -441,7 +443,7 @@ fn lint_uint_literal<'tcx>(\n             );\n             return;\n         }\n-        cx.struct_span_lint(OVERFLOWING_LITERALS, e.span, fluent::lint::overflowing_uint, |lint| {\n+        cx.struct_span_lint(OVERFLOWING_LITERALS, e.span, fluent::lint_overflowing_uint, |lint| {\n             lint.set_arg(\"ty\", t.name_str())\n                 .set_arg(\n                     \"lit\",\n@@ -452,7 +454,7 @@ fn lint_uint_literal<'tcx>(\n                 )\n                 .set_arg(\"min\", min)\n                 .set_arg(\"max\", max)\n-                .note(fluent::lint::note)\n+                .note(fluent::note)\n         });\n     }\n }\n@@ -485,7 +487,7 @@ fn lint_literal<'tcx>(\n                 cx.struct_span_lint(\n                     OVERFLOWING_LITERALS,\n                     e.span,\n-                    fluent::lint::overflowing_literal,\n+                    fluent::lint_overflowing_literal,\n                     |lint| {\n                         lint.set_arg(\"ty\", t.name_str())\n                             .set_arg(\n@@ -495,7 +497,7 @@ fn lint_literal<'tcx>(\n                                     .span_to_snippet(lit.span)\n                                     .expect(\"must get snippet from literal\"),\n                             )\n-                            .note(fluent::lint::note)\n+                            .note(fluent::note)\n                     },\n                 );\n             }\n@@ -518,7 +520,7 @@ impl<'tcx> LateLintPass<'tcx> for TypeLimits {\n                     cx.struct_span_lint(\n                         UNUSED_COMPARISONS,\n                         e.span,\n-                        fluent::lint::unused_comparisons,\n+                        fluent::lint_unused_comparisons,\n                         |lint| lint,\n                     );\n                 }\n@@ -840,8 +842,8 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             self.emit_ffi_unsafe_type_lint(\n                 ty,\n                 sp,\n-                fluent::lint::improper_ctypes_array_reason,\n-                Some(fluent::lint::improper_ctypes_array_help),\n+                fluent::lint_improper_ctypes_array_reason,\n+                Some(fluent::lint_improper_ctypes_array_help),\n             );\n             true\n         } else {\n@@ -884,7 +886,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             } else {\n                 // All fields are ZSTs; this means that the type should behave\n                 // like (), which is FFI-unsafe\n-                FfiUnsafe { ty, reason: fluent::lint::improper_ctypes_struct_zst, help: None }\n+                FfiUnsafe { ty, reason: fluent::lint_improper_ctypes_struct_zst, help: None }\n             }\n         } else {\n             // We can't completely trust repr(C) markings; make sure the fields are\n@@ -898,7 +900,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                     FfiPhantom(..) if def.is_enum() => {\n                         return FfiUnsafe {\n                             ty,\n-                            reason: fluent::lint::improper_ctypes_enum_phantomdata,\n+                            reason: fluent::lint_improper_ctypes_enum_phantomdata,\n                             help: None,\n                         };\n                     }\n@@ -934,7 +936,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                     } else {\n                         return FfiUnsafe {\n                             ty,\n-                            reason: fluent::lint::improper_ctypes_box,\n+                            reason: fluent::lint_improper_ctypes_box,\n                             help: None,\n                         };\n                     }\n@@ -948,14 +950,14 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                             return FfiUnsafe {\n                                 ty,\n                                 reason: if def.is_struct() {\n-                                    fluent::lint::improper_ctypes_struct_layout_reason\n+                                    fluent::lint_improper_ctypes_struct_layout_reason\n                                 } else {\n-                                    fluent::lint::improper_ctypes_union_layout_reason\n+                                    fluent::lint_improper_ctypes_union_layout_reason\n                                 },\n                                 help: if def.is_struct() {\n-                                    Some(fluent::lint::improper_ctypes_struct_layout_help)\n+                                    Some(fluent::lint_improper_ctypes_struct_layout_help)\n                                 } else {\n-                                    Some(fluent::lint::improper_ctypes_union_layout_help)\n+                                    Some(fluent::lint_improper_ctypes_union_layout_help)\n                                 },\n                             };\n                         }\n@@ -966,9 +968,9 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                             return FfiUnsafe {\n                                 ty,\n                                 reason: if def.is_struct() {\n-                                    fluent::lint::improper_ctypes_struct_non_exhaustive\n+                                    fluent::lint_improper_ctypes_struct_non_exhaustive\n                                 } else {\n-                                    fluent::lint::improper_ctypes_union_non_exhaustive\n+                                    fluent::lint_improper_ctypes_union_non_exhaustive\n                                 },\n                                 help: None,\n                             };\n@@ -978,14 +980,14 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                             return FfiUnsafe {\n                                 ty,\n                                 reason: if def.is_struct() {\n-                                    fluent::lint::improper_ctypes_struct_fieldless_reason\n+                                    fluent::lint_improper_ctypes_struct_fieldless_reason\n                                 } else {\n-                                    fluent::lint::improper_ctypes_union_fieldless_reason\n+                                    fluent::lint_improper_ctypes_union_fieldless_reason\n                                 },\n                                 help: if def.is_struct() {\n-                                    Some(fluent::lint::improper_ctypes_struct_fieldless_help)\n+                                    Some(fluent::lint_improper_ctypes_struct_fieldless_help)\n                                 } else {\n-                                    Some(fluent::lint::improper_ctypes_union_fieldless_help)\n+                                    Some(fluent::lint_improper_ctypes_union_fieldless_help)\n                                 },\n                             };\n                         }\n@@ -1006,16 +1008,16 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                             if repr_nullable_ptr(self.cx, ty, self.mode).is_none() {\n                                 return FfiUnsafe {\n                                     ty,\n-                                    reason: fluent::lint::improper_ctypes_enum_repr_reason,\n-                                    help: Some(fluent::lint::improper_ctypes_enum_repr_help),\n+                                    reason: fluent::lint_improper_ctypes_enum_repr_reason,\n+                                    help: Some(fluent::lint_improper_ctypes_enum_repr_help),\n                                 };\n                             }\n                         }\n \n                         if def.is_variant_list_non_exhaustive() && !def.did().is_local() {\n                             return FfiUnsafe {\n                                 ty,\n-                                reason: fluent::lint::improper_ctypes_non_exhaustive,\n+                                reason: fluent::lint_improper_ctypes_non_exhaustive,\n                                 help: None,\n                             };\n                         }\n@@ -1026,7 +1028,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                             if is_non_exhaustive && !variant.def_id.is_local() {\n                                 return FfiUnsafe {\n                                     ty,\n-                                    reason: fluent::lint::improper_ctypes_non_exhaustive_variant,\n+                                    reason: fluent::lint_improper_ctypes_non_exhaustive_variant,\n                                     help: None,\n                                 };\n                             }\n@@ -1044,37 +1046,37 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n             ty::Char => FfiUnsafe {\n                 ty,\n-                reason: fluent::lint::improper_ctypes_char_reason,\n-                help: Some(fluent::lint::improper_ctypes_char_help),\n+                reason: fluent::lint_improper_ctypes_char_reason,\n+                help: Some(fluent::lint_improper_ctypes_char_help),\n             },\n \n             ty::Int(ty::IntTy::I128) | ty::Uint(ty::UintTy::U128) => {\n-                FfiUnsafe { ty, reason: fluent::lint::improper_ctypes_128bit, help: None }\n+                FfiUnsafe { ty, reason: fluent::lint_improper_ctypes_128bit, help: None }\n             }\n \n             // Primitive types with a stable representation.\n             ty::Bool | ty::Int(..) | ty::Uint(..) | ty::Float(..) | ty::Never => FfiSafe,\n \n             ty::Slice(_) => FfiUnsafe {\n                 ty,\n-                reason: fluent::lint::improper_ctypes_slice_reason,\n-                help: Some(fluent::lint::improper_ctypes_slice_help),\n+                reason: fluent::lint_improper_ctypes_slice_reason,\n+                help: Some(fluent::lint_improper_ctypes_slice_help),\n             },\n \n             ty::Dynamic(..) => {\n-                FfiUnsafe { ty, reason: fluent::lint::improper_ctypes_dyn, help: None }\n+                FfiUnsafe { ty, reason: fluent::lint_improper_ctypes_dyn, help: None }\n             }\n \n             ty::Str => FfiUnsafe {\n                 ty,\n-                reason: fluent::lint::improper_ctypes_str_reason,\n-                help: Some(fluent::lint::improper_ctypes_str_help),\n+                reason: fluent::lint_improper_ctypes_str_reason,\n+                help: Some(fluent::lint_improper_ctypes_str_help),\n             },\n \n             ty::Tuple(..) => FfiUnsafe {\n                 ty,\n-                reason: fluent::lint::improper_ctypes_tuple_reason,\n-                help: Some(fluent::lint::improper_ctypes_tuple_help),\n+                reason: fluent::lint_improper_ctypes_tuple_reason,\n+                help: Some(fluent::lint_improper_ctypes_tuple_help),\n             },\n \n             ty::RawPtr(ty::TypeAndMut { ty, .. }) | ty::Ref(_, ty, _)\n@@ -1105,8 +1107,8 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                 if self.is_internal_abi(sig.abi()) {\n                     return FfiUnsafe {\n                         ty,\n-                        reason: fluent::lint::improper_ctypes_fnptr_reason,\n-                        help: Some(fluent::lint::improper_ctypes_fnptr_help),\n+                        reason: fluent::lint_improper_ctypes_fnptr_reason,\n+                        help: Some(fluent::lint_improper_ctypes_fnptr_help),\n                     };\n                 }\n \n@@ -1137,7 +1139,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             // While opaque types are checked for earlier, if a projection in a struct field\n             // normalizes to an opaque type, then it will reach this branch.\n             ty::Opaque(..) => {\n-                FfiUnsafe { ty, reason: fluent::lint::improper_ctypes_opaque, help: None }\n+                FfiUnsafe { ty, reason: fluent::lint_improper_ctypes_opaque, help: None }\n             }\n \n             // `extern \"C\" fn` functions can have type parameters, which may or may not be FFI-safe,\n@@ -1171,21 +1173,21 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             CItemKind::Definition => IMPROPER_CTYPES_DEFINITIONS,\n         };\n \n-        self.cx.struct_span_lint(lint, sp, fluent::lint::improper_ctypes, |lint| {\n+        self.cx.struct_span_lint(lint, sp, fluent::lint_improper_ctypes, |lint| {\n             let item_description = match self.mode {\n                 CItemKind::Declaration => \"block\",\n                 CItemKind::Definition => \"fn\",\n             };\n             lint.set_arg(\"ty\", ty);\n             lint.set_arg(\"desc\", item_description);\n-            lint.span_label(sp, fluent::lint::label);\n+            lint.span_label(sp, fluent::label);\n             if let Some(help) = help {\n                 lint.help(help);\n             }\n             lint.note(note);\n             if let ty::Adt(def, _) = ty.kind() {\n                 if let Some(sp) = self.cx.tcx.hir().span_if_local(def.did()) {\n-                    lint.span_note(sp, fluent::lint::note);\n+                    lint.span_note(sp, fluent::note);\n                 }\n             }\n             lint\n@@ -1222,7 +1224,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         }\n \n         if let Some(ty) = ty.visit_with(&mut ProhibitOpaqueTypes { cx: self.cx }).break_value() {\n-            self.emit_ffi_unsafe_type_lint(ty, sp, fluent::lint::improper_ctypes_opaque, None);\n+            self.emit_ffi_unsafe_type_lint(ty, sp, fluent::lint_improper_ctypes_opaque, None);\n             true\n         } else {\n             false\n@@ -1267,7 +1269,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                 self.emit_ffi_unsafe_type_lint(\n                     ty,\n                     sp,\n-                    fluent::lint::improper_ctypes_only_phantomdata,\n+                    fluent::lint_improper_ctypes_only_phantomdata,\n                     None,\n                 );\n             }\n@@ -1401,7 +1403,7 @@ impl<'tcx> LateLintPass<'tcx> for VariantSizeDifferences {\n                 cx.struct_span_lint(\n                     VARIANT_SIZE_DIFFERENCES,\n                     enum_definition.variants[largest_index].span,\n-                    fluent::lint::variant_size_differences,\n+                    fluent::lint_variant_size_differences,\n                     |lint| lint.set_arg(\"largest\", largest),\n                 );\n             }\n@@ -1511,15 +1513,15 @@ impl InvalidAtomicOrdering {\n     fn check_atomic_load_store(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if let Some((method, args)) = Self::inherent_atomic_method_call(cx, expr, &[sym::load, sym::store])\n             && let Some((ordering_arg, invalid_ordering, msg)) = match method {\n-                sym::load => Some((&args[0], sym::Release, fluent::lint::atomic_ordering_load)),\n-                sym::store => Some((&args[1], sym::Acquire, fluent::lint::atomic_ordering_store)),\n+                sym::load => Some((&args[0], sym::Release, fluent::lint_atomic_ordering_load)),\n+                sym::store => Some((&args[1], sym::Acquire, fluent::lint_atomic_ordering_store)),\n                 _ => None,\n             }\n             && let Some(ordering) = Self::match_ordering(cx, ordering_arg)\n             && (ordering == invalid_ordering || ordering == sym::AcqRel)\n         {\n             cx.struct_span_lint(INVALID_ATOMIC_ORDERING, ordering_arg.span, msg, |lint| {\n-                lint.help(fluent::lint::help)\n+                lint.help(fluent::help)\n             });\n         }\n     }\n@@ -1531,9 +1533,9 @@ impl InvalidAtomicOrdering {\n             && matches!(cx.tcx.get_diagnostic_name(def_id), Some(sym::fence | sym::compiler_fence))\n             && Self::match_ordering(cx, &args[0]) == Some(sym::Relaxed)\n         {\n-            cx.struct_span_lint(INVALID_ATOMIC_ORDERING, args[0].span, fluent::lint::atomic_ordering_fence, |lint| {\n+            cx.struct_span_lint(INVALID_ATOMIC_ORDERING, args[0].span, fluent::lint_atomic_ordering_fence, |lint| {\n                 lint\n-                    .help(fluent::lint::help)\n+                    .help(fluent::help)\n             });\n         }\n     }\n@@ -1552,7 +1554,7 @@ impl InvalidAtomicOrdering {\n \n         if matches!(fail_ordering, sym::Release | sym::AcqRel) {\n             #[derive(LintDiagnostic)]\n-            #[diag(lint::atomic_ordering_invalid)]\n+            #[diag(lint_atomic_ordering_invalid)]\n             #[help]\n             struct InvalidAtomicOrderingDiag {\n                 method: Symbol,"}, {"sha": "46706e498445107b8a26a065f167fb7ab5102fe9", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -7,6 +7,7 @@ use rustc_errors::{fluent, pluralize, Applicability, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n+use rustc_infer::traits::util::elaborate_predicates_with_span;\n use rustc_middle::ty::adjustment;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::symbol::Symbol;\n@@ -154,12 +155,12 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n         };\n \n         if let Some(must_use_op) = must_use_op {\n-            cx.struct_span_lint(UNUSED_MUST_USE, expr.span, fluent::lint::unused_op, |lint| {\n+            cx.struct_span_lint(UNUSED_MUST_USE, expr.span, fluent::lint_unused_op, |lint| {\n                 lint.set_arg(\"op\", must_use_op)\n-                    .span_label(expr.span, fluent::lint::label)\n+                    .span_label(expr.span, fluent::label)\n                     .span_suggestion_verbose(\n                         expr.span.shrink_to_lo(),\n-                        fluent::lint::suggestion,\n+                        fluent::suggestion,\n                         \"let _ = \",\n                         Applicability::MachineApplicable,\n                     )\n@@ -168,7 +169,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n         }\n \n         if !(type_permits_lack_of_use || fn_warned || op_warned) {\n-            cx.struct_span_lint(UNUSED_RESULTS, s.span, fluent::lint::unused_result, |lint| {\n+            cx.struct_span_lint(UNUSED_RESULTS, s.span, fluent::lint_unused_result, |lint| {\n                 lint.set_arg(\"ty\", ty)\n             });\n         }\n@@ -204,10 +205,13 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                 ty::Adt(def, _) => check_must_use_def(cx, def.did(), span, descr_pre, descr_post),\n                 ty::Opaque(def, _) => {\n                     let mut has_emitted = false;\n-                    for &(predicate, _) in cx.tcx.explicit_item_bounds(def) {\n+                    for obligation in elaborate_predicates_with_span(\n+                        cx.tcx,\n+                        cx.tcx.explicit_item_bounds(def).iter().cloned(),\n+                    ) {\n                         // We only look at the `DefId`, so it is safe to skip the binder here.\n                         if let ty::PredicateKind::Trait(ref poly_trait_predicate) =\n-                            predicate.kind().skip_binder()\n+                            obligation.predicate.kind().skip_binder()\n                         {\n                             let def_id = poly_trait_predicate.trait_ref.def_id;\n                             let descr_pre =\n@@ -268,14 +272,14 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                     cx.struct_span_lint(\n                         UNUSED_MUST_USE,\n                         span,\n-                        fluent::lint::unused_closure,\n+                        fluent::lint_unused_closure,\n                         |lint| {\n                             // FIXME(davidtwco): this isn't properly translatable because of the\n                             // pre/post strings\n                             lint.set_arg(\"count\", plural_len)\n                                 .set_arg(\"pre\", descr_pre)\n                                 .set_arg(\"post\", descr_post)\n-                                .note(fluent::lint::note)\n+                                .note(fluent::note)\n                         },\n                     );\n                     true\n@@ -284,14 +288,14 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                     cx.struct_span_lint(\n                         UNUSED_MUST_USE,\n                         span,\n-                        fluent::lint::unused_generator,\n+                        fluent::lint_unused_generator,\n                         |lint| {\n                             // FIXME(davidtwco): this isn't properly translatable because of the\n                             // pre/post strings\n                             lint.set_arg(\"count\", plural_len)\n                                 .set_arg(\"pre\", descr_pre)\n                                 .set_arg(\"post\", descr_post)\n-                                .note(fluent::lint::note)\n+                                .note(fluent::note)\n                         },\n                     );\n                     true\n@@ -313,7 +317,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n             descr_post_path: &str,\n         ) -> bool {\n             if let Some(attr) = cx.tcx.get_attr(def_id, sym::must_use) {\n-                cx.struct_span_lint(UNUSED_MUST_USE, span, fluent::lint::unused_def, |lint| {\n+                cx.struct_span_lint(UNUSED_MUST_USE, span, fluent::lint_unused_def, |lint| {\n                     // FIXME(davidtwco): this isn't properly translatable because of the pre/post\n                     // strings\n                     lint.set_arg(\"pre\", descr_pre_path);\n@@ -365,17 +369,17 @@ impl<'tcx> LateLintPass<'tcx> for PathStatements {\n                     cx.struct_span_lint(\n                         PATH_STATEMENTS,\n                         s.span,\n-                        fluent::lint::path_statement_drop,\n+                        fluent::lint_path_statement_drop,\n                         |lint| {\n                             if let Ok(snippet) = cx.sess().source_map().span_to_snippet(expr.span) {\n                                 lint.span_suggestion(\n                                     s.span,\n-                                    fluent::lint::suggestion,\n+                                    fluent::suggestion,\n                                     format!(\"drop({});\", snippet),\n                                     Applicability::MachineApplicable,\n                                 );\n                             } else {\n-                                lint.span_help(s.span, fluent::lint::suggestion);\n+                                lint.span_help(s.span, fluent::suggestion);\n                             }\n                             lint\n                         },\n@@ -384,7 +388,7 @@ impl<'tcx> LateLintPass<'tcx> for PathStatements {\n                     cx.struct_span_lint(\n                         PATH_STATEMENTS,\n                         s.span,\n-                        fluent::lint::path_statement_no_effect,\n+                        fluent::lint_path_statement_no_effect,\n                         |lint| lint,\n                     );\n                 }\n@@ -557,7 +561,7 @@ trait UnusedDelimLint {\n         } else {\n             MultiSpan::from(value_span)\n         };\n-        cx.struct_span_lint(self.lint(), primary_span, fluent::lint::unused_delim, |lint| {\n+        cx.struct_span_lint(self.lint(), primary_span, fluent::lint_unused_delim, |lint| {\n             lint.set_arg(\"delim\", Self::DELIM_STR);\n             lint.set_arg(\"item\", msg);\n             if let Some((lo, hi)) = spans {\n@@ -566,7 +570,7 @@ trait UnusedDelimLint {\n                     (hi, if keep_space.1 { \" \".into() } else { \"\".into() }),\n                 ];\n                 lint.multipart_suggestion(\n-                    fluent::lint::suggestion,\n+                    fluent::suggestion,\n                     replacement,\n                     Applicability::MachineApplicable,\n                 );\n@@ -1142,7 +1146,7 @@ impl UnusedImportBraces {\n             cx.struct_span_lint(\n                 UNUSED_IMPORT_BRACES,\n                 item.span,\n-                fluent::lint::unused_import_braces,\n+                fluent::lint_unused_import_braces,\n                 |lint| lint.set_arg(\"node\", node_name),\n             );\n         }\n@@ -1197,9 +1201,9 @@ impl<'tcx> LateLintPass<'tcx> for UnusedAllocation {\n                     UNUSED_ALLOCATION,\n                     e.span,\n                     match m {\n-                        adjustment::AutoBorrowMutability::Not => fluent::lint::unused_allocation,\n+                        adjustment::AutoBorrowMutability::Not => fluent::lint_unused_allocation,\n                         adjustment::AutoBorrowMutability::Mut { .. } => {\n-                            fluent::lint::unused_allocation_mut\n+                            fluent::lint_unused_allocation_mut\n                         }\n                     },\n                     |lint| lint,"}, {"sha": "61ee467f595770942a2a92addcc400f2fff0e6e4", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -1427,6 +1427,7 @@ declare_lint! {\n     \"trait-object types were treated as different depending on marker-trait order\",\n     @future_incompatible = FutureIncompatibleInfo {\n         reference: \"issue #56484 <https://github.com/rust-lang/rust/issues/56484>\",\n+        reason: FutureIncompatibilityReason::FutureReleaseErrorReportNow,\n     };\n }\n \n@@ -2878,7 +2879,7 @@ declare_lint! {\n     /// ### Example\n     ///\n     /// ```rust\n-    /// #![feature(naked_functions)]\n+    /// #![feature(asm_experimental_arch, naked_functions)]\n     ///\n     /// use std::arch::asm;\n     ///"}, {"sha": "ef1985b960e361ac2e065a60a5f8beec6ba7c3be", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -40,7 +40,7 @@ impl<'a> DiagnosticDerive<'a> {\n                     span_err(builder.span, \"diagnostic slug not specified\")\n                         .help(&format!(\n                             \"specify the slug as the first argument to the `#[diag(...)]` \\\n-                            attribute, such as `#[diag(hir_analysis::example_error)]`\",\n+                            attribute, such as `#[diag(hir_analysis_example_error)]`\",\n                         ))\n                         .emit();\n                     return DiagnosticDeriveError::ErrorHandled.to_compile_error();\n@@ -121,7 +121,7 @@ impl<'a> LintDiagnosticDerive<'a> {\n                     span_err(builder.span, \"diagnostic slug not specified\")\n                         .help(&format!(\n                             \"specify the slug as the first argument to the attribute, such as \\\n-                            `#[diag(compiletest::example)]`\",\n+                            `#[diag(compiletest_example)]`\",\n                         ))\n                         .emit();\n                     return DiagnosticDeriveError::ErrorHandled.to_compile_error();"}, {"sha": "9f7d2661a3e8b425a0ca0057f828961ab7b71ccd", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic_builder.rs", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -5,7 +5,7 @@ use crate::diagnostics::error::{\n     DiagnosticDeriveError,\n };\n use crate::diagnostics::utils::{\n-    build_field_mapping, report_error_if_not_applied_to_span, report_type_error,\n+    build_field_mapping, is_doc_comment, report_error_if_not_applied_to_span, report_type_error,\n     should_generate_set_arg, type_is_unit, type_matches_path, FieldInfo, FieldInnerTy, FieldMap,\n     HasFieldMap, SetOnce, SpannedOption, SubdiagnosticKind,\n };\n@@ -152,8 +152,12 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n     fn parse_subdiag_attribute(\n         &self,\n         attr: &Attribute,\n-    ) -> Result<(SubdiagnosticKind, Path), DiagnosticDeriveError> {\n-        let (subdiag, slug) = SubdiagnosticKind::from_attr(attr, self)?;\n+    ) -> Result<Option<(SubdiagnosticKind, Path)>, DiagnosticDeriveError> {\n+        let Some((subdiag, slug)) = SubdiagnosticKind::from_attr(attr, self)? else {\n+            // Some attributes aren't errors - like documentation comments - but also aren't\n+            // subdiagnostics.\n+            return Ok(None);\n+        };\n \n         if let SubdiagnosticKind::MultipartSuggestion { .. } = subdiag {\n             let meta = attr.parse_meta()?;\n@@ -170,7 +174,7 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n             SubdiagnosticKind::MultipartSuggestion { .. } => unreachable!(),\n         });\n \n-        Ok((subdiag, slug))\n+        Ok(Some((subdiag, slug)))\n     }\n \n     /// Establishes state in the `DiagnosticDeriveBuilder` resulting from the struct\n@@ -182,6 +186,11 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n     ) -> Result<TokenStream, DiagnosticDeriveError> {\n         let diag = &self.parent.diag;\n \n+        // Always allow documentation comments.\n+        if is_doc_comment(attr) {\n+            return Ok(quote! {});\n+        }\n+\n         let name = attr.path.segments.last().unwrap().ident.to_string();\n         let name = name.as_str();\n         let meta = attr.parse_meta()?;\n@@ -250,7 +259,11 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n             return Ok(tokens);\n         }\n \n-        let (subdiag, slug) = self.parse_subdiag_attribute(attr)?;\n+        let Some((subdiag, slug)) = self.parse_subdiag_attribute(attr)? else {\n+            // Some attributes aren't errors - like documentation comments - but also aren't\n+            // subdiagnostics.\n+            return Ok(quote! {});\n+        };\n         let fn_ident = format_ident!(\"{}\", subdiag);\n         match subdiag {\n             SubdiagnosticKind::Note | SubdiagnosticKind::Help | SubdiagnosticKind::Warn => {\n@@ -291,6 +304,11 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n             .attrs\n             .iter()\n             .map(move |attr| {\n+                // Always allow documentation comments.\n+                if is_doc_comment(attr) {\n+                    return quote! {};\n+                }\n+\n                 let name = attr.path.segments.last().unwrap().ident.to_string();\n                 let needs_clone =\n                     name == \"primary_span\" && matches!(inner_ty, FieldInnerTy::Vec(_));\n@@ -397,8 +415,11 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n             _ => (),\n         }\n \n-        let (subdiag, slug) = self.parse_subdiag_attribute(attr)?;\n-\n+        let Some((subdiag, slug)) = self.parse_subdiag_attribute(attr)? else {\n+            // Some attributes aren't errors - like documentation comments - but also aren't\n+            // subdiagnostics.\n+            return Ok(quote! {});\n+        };\n         let fn_ident = format_ident!(\"{}\", subdiag);\n         match subdiag {\n             SubdiagnosticKind::Label => {"}, {"sha": "3e447c94ef1238d3d977356d6ea70e8f3ce9fe3d", "filename": "compiler/rustc_macros/src/diagnostics/fluent.rs", "status": "modified", "additions": 31, "deletions": 34, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -25,18 +25,18 @@ use syn::{\n use unic_langid::langid;\n \n struct Resource {\n-    ident: Ident,\n+    krate: Ident,\n     #[allow(dead_code)]\n     fat_arrow_token: token::FatArrow,\n-    resource: LitStr,\n+    resource_path: LitStr,\n }\n \n impl Parse for Resource {\n     fn parse(input: ParseStream<'_>) -> Result<Self> {\n         Ok(Resource {\n-            ident: input.parse()?,\n+            krate: input.parse()?,\n             fat_arrow_token: input.parse()?,\n-            resource: input.parse()?,\n+            resource_path: input.parse()?,\n         })\n     }\n }\n@@ -94,19 +94,20 @@ pub(crate) fn fluent_messages(input: proc_macro::TokenStream) -> proc_macro::Tok\n     // diagnostics.\n     let mut previous_defns = HashMap::new();\n \n+    // Set of Fluent attribute names already output, to avoid duplicate type errors - any given\n+    // constant created for a given attribute is the same.\n+    let mut previous_attrs = HashSet::new();\n+\n     let mut includes = TokenStream::new();\n     let mut generated = TokenStream::new();\n-    for res in resources.0 {\n-        let ident_span = res.ident.span().unwrap();\n-        let path_span = res.resource.span().unwrap();\n \n-        // Set of Fluent attribute names already output, to avoid duplicate type errors - any given\n-        // constant created for a given attribute is the same.\n-        let mut previous_attrs = HashSet::new();\n+    for res in resources.0 {\n+        let krate_span = res.krate.span().unwrap();\n+        let path_span = res.resource_path.span().unwrap();\n \n-        let relative_ftl_path = res.resource.value();\n+        let relative_ftl_path = res.resource_path.value();\n         let absolute_ftl_path =\n-            invocation_relative_path_to_absolute(ident_span, &relative_ftl_path);\n+            invocation_relative_path_to_absolute(krate_span, &relative_ftl_path);\n         // As this macro also outputs an `include_str!` for this file, the macro will always be\n         // re-executed when the file changes.\n         let mut resource_file = match File::open(absolute_ftl_path) {\n@@ -185,7 +186,7 @@ pub(crate) fn fluent_messages(input: proc_macro::TokenStream) -> proc_macro::Tok\n \n         let mut constants = TokenStream::new();\n         for entry in resource.entries() {\n-            let span = res.ident.span();\n+            let span = res.krate.span();\n             if let Entry::Message(Message { id: Identifier { name }, attributes, .. }) = entry {\n                 let _ = previous_defns.entry(name.to_string()).or_insert(path_span);\n \n@@ -199,29 +200,30 @@ pub(crate) fn fluent_messages(input: proc_macro::TokenStream) -> proc_macro::Tok\n                     .emit();\n                 }\n \n-                // `typeck_foo_bar` => `foo_bar` (in `typeck.ftl`)\n-                // `const_eval_baz` => `baz` (in `const_eval.ftl`)\n+                // Require that the message name starts with the crate name\n+                // `hir_typeck_foo_bar` (in `hir_typeck.ftl`)\n+                // `const_eval_baz` (in `const_eval.ftl`)\n                 // `const-eval-hyphen-having` => `hyphen_having` (in `const_eval.ftl`)\n                 // The last case we error about above, but we want to fall back gracefully\n                 // so that only the error is being emitted and not also one about the macro\n                 // failing.\n-                let crate_prefix = format!(\"{}_\", res.ident);\n+                let crate_prefix = format!(\"{}_\", res.krate);\n \n                 let snake_name = name.replace('-', \"_\");\n-                let snake_name = match snake_name.strip_prefix(&crate_prefix) {\n-                    Some(rest) => Ident::new(rest, span),\n-                    None => {\n-                        Diagnostic::spanned(\n-                            path_span,\n-                            Level::Error,\n-                            format!(\"name `{name}` does not start with the crate name\"),\n-                        )\n-                        .help(format!(\"prepend `{crate_prefix}` to the slug name: `{crate_prefix}{snake_name}`\"))\n-                        .emit();\n-                        Ident::new(&snake_name, span)\n-                    }\n+                if !snake_name.starts_with(&crate_prefix) {\n+                    Diagnostic::spanned(\n+                        path_span,\n+                        Level::Error,\n+                        format!(\"name `{name}` does not start with the crate name\"),\n+                    )\n+                    .help(format!(\n+                        \"prepend `{crate_prefix}` to the slug name: `{crate_prefix}{snake_name}`\"\n+                    ))\n+                    .emit();\n                 };\n \n+                let snake_name = Ident::new(&snake_name, span);\n+\n                 constants.extend(quote! {\n                     pub const #snake_name: crate::DiagnosticMessage =\n                         crate::DiagnosticMessage::FluentIdentifier(\n@@ -275,12 +277,7 @@ pub(crate) fn fluent_messages(input: proc_macro::TokenStream) -> proc_macro::Tok\n \n         includes.extend(quote! { include_str!(#relative_ftl_path), });\n \n-        let ident = res.ident;\n-        generated.extend(quote! {\n-            pub mod #ident {\n-                #constants\n-            }\n-        });\n+        generated.extend(constants);\n     }\n \n     quote! {"}, {"sha": "860340b439061906321dbcfb53b1d38c85faf1d2", "filename": "compiler/rustc_macros/src/diagnostics/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -23,14 +23,14 @@ use synstructure::Structure;\n /// # extern crate rust_middle;\n /// # use rustc_middle::ty::Ty;\n /// #[derive(Diagnostic)]\n-/// #[diag(borrowck::move_out_of_borrow, code = \"E0505\")]\n+/// #[diag(borrowck_move_out_of_borrow, code = \"E0505\")]\n /// pub struct MoveOutOfBorrowError<'tcx> {\n ///     pub name: Ident,\n ///     pub ty: Ty<'tcx>,\n ///     #[primary_span]\n ///     #[label]\n ///     pub span: Span,\n-///     #[label(borrowck::first_borrow_label)]\n+///     #[label(first_borrow_label)]\n ///     pub first_borrow_span: Span,\n ///     #[suggestion(code = \"{name}.clone()\")]\n ///     pub clone_sugg: Option<(Span, Applicability)>\n@@ -67,14 +67,14 @@ pub fn session_diagnostic_derive(s: Structure<'_>) -> TokenStream {\n ///\n /// ```ignore (rust)\n /// #[derive(LintDiagnostic)]\n-/// #[diag(lint::atomic_ordering_invalid_fail_success)]\n+/// #[diag(lint_atomic_ordering_invalid_fail_success)]\n /// pub struct AtomicOrderingInvalidLint {\n ///     method: Symbol,\n ///     success_ordering: Symbol,\n ///     fail_ordering: Symbol,\n-///     #[label(lint::fail_label)]\n+///     #[label(fail_label)]\n ///     fail_order_arg_span: Span,\n-///     #[label(lint::success_label)]\n+///     #[label(success_label)]\n ///     #[suggestion(\n ///         code = \"std::sync::atomic::Ordering::{success_suggestion}\",\n ///         applicability = \"maybe-incorrect\"\n@@ -115,12 +115,12 @@ pub fn lint_diagnostic_derive(s: Structure<'_>) -> TokenStream {\n /// ```ignore (rust)\n /// #[derive(Subdiagnostic)]\n /// pub enum ExpectedIdentifierLabel<'tcx> {\n-///     #[label(parser::expected_identifier)]\n+///     #[label(expected_identifier)]\n ///     WithoutFound {\n ///         #[primary_span]\n ///         span: Span,\n ///     }\n-///     #[label(parser::expected_identifier_found)]\n+///     #[label(expected_identifier_found)]\n ///     WithFound {\n ///         #[primary_span]\n ///         span: Span,"}, {"sha": "d1acb71384220abd1c90a7cdb1885d9db5af3b62", "filename": "compiler/rustc_macros/src/diagnostics/subdiagnostic.rs", "status": "modified", "additions": 37, "deletions": 10, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -5,9 +5,9 @@ use crate::diagnostics::error::{\n     DiagnosticDeriveError,\n };\n use crate::diagnostics::utils::{\n-    build_field_mapping, new_code_ident, report_error_if_not_applied_to_applicability,\n-    report_error_if_not_applied_to_span, FieldInfo, FieldInnerTy, FieldMap, HasFieldMap, SetOnce,\n-    SpannedOption, SubdiagnosticKind,\n+    build_field_mapping, is_doc_comment, new_code_ident,\n+    report_error_if_not_applied_to_applicability, report_error_if_not_applied_to_span, FieldInfo,\n+    FieldInnerTy, FieldMap, HasFieldMap, SetOnce, SpannedOption, SubdiagnosticKind,\n };\n use proc_macro2::TokenStream;\n use quote::{format_ident, quote};\n@@ -41,8 +41,14 @@ impl SubdiagnosticDeriveBuilder {\n                 }\n             }\n \n-            if matches!(ast.data, syn::Data::Enum(..)) {\n+            let is_enum = matches!(ast.data, syn::Data::Enum(..));\n+            if is_enum {\n                 for attr in &ast.attrs {\n+                    // Always allow documentation comments.\n+                    if is_doc_comment(attr) {\n+                        continue;\n+                    }\n+\n                     span_err(\n                         attr.span().unwrap(),\n                         \"unsupported type attribute for subdiagnostic enum\",\n@@ -62,6 +68,7 @@ impl SubdiagnosticDeriveBuilder {\n                     span_field: None,\n                     applicability: None,\n                     has_suggestion_parts: false,\n+                    is_enum,\n                 };\n                 builder.into_tokens().unwrap_or_else(|v| v.to_compile_error())\n             });\n@@ -79,7 +86,7 @@ impl SubdiagnosticDeriveBuilder {\n             gen impl rustc_errors::AddToDiagnostic for @Self {\n                 fn add_to_diagnostic_with<__F>(self, #diag: &mut rustc_errors::Diagnostic, #f: __F)\n                 where\n-                    __F: Fn(\n+                    __F: core::ops::Fn(\n                         &mut rustc_errors::Diagnostic,\n                         rustc_errors::SubdiagnosticMessage\n                     ) -> rustc_errors::SubdiagnosticMessage,\n@@ -122,6 +129,9 @@ struct SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n     /// Set to true when a `#[suggestion_part]` field is encountered, used to generate an error\n     /// during finalization if still `false`.\n     has_suggestion_parts: bool,\n+\n+    /// Set to true when this variant is an enum variant rather than just the body of a struct.\n+    is_enum: bool,\n }\n \n impl<'parent, 'a> HasFieldMap for SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n@@ -173,7 +183,11 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n         let mut kind_slugs = vec![];\n \n         for attr in self.variant.ast().attrs {\n-            let (kind, slug) = SubdiagnosticKind::from_attr(attr, self)?;\n+            let Some((kind, slug)) = SubdiagnosticKind::from_attr(attr, self)? else {\n+                // Some attributes aren't errors - like documentation comments - but also aren't\n+                // subdiagnostics.\n+                continue;\n+            };\n \n             let Some(slug) = slug else {\n                 let name = attr.path.segments.last().unwrap().ident.to_string();\n@@ -227,6 +241,11 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n         ast.attrs\n             .iter()\n             .map(|attr| {\n+                // Always allow documentation comments.\n+                if is_doc_comment(attr) {\n+                    return quote! {};\n+                }\n+\n                 let info = FieldInfo {\n                     binding,\n                     ty: inner_ty.inner_type().unwrap_or(&ast.ty),\n@@ -290,6 +309,8 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n                     report_error_if_not_applied_to_span(attr, &info)?;\n \n                     let binding = info.binding.binding.clone();\n+                    // FIXME(#100717): support `Option<Span>` on `primary_span` like in the\n+                    // diagnostic derive\n                     self.span_field.set_once(binding, span);\n                 }\n \n@@ -443,10 +464,16 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n     pub fn into_tokens(&mut self) -> Result<TokenStream, DiagnosticDeriveError> {\n         let kind_slugs = self.identify_kind()?;\n         if kind_slugs.is_empty() {\n-            throw_span_err!(\n-                self.variant.ast().ident.span().unwrap(),\n-                \"subdiagnostic kind not specified\"\n-            );\n+            if self.is_enum {\n+                // It's okay for a variant to not be a subdiagnostic at all..\n+                return Ok(quote! {});\n+            } else {\n+                // ..but structs should always be _something_.\n+                throw_span_err!(\n+                    self.variant.ast().ident.span().unwrap(),\n+                    \"subdiagnostic kind not specified\"\n+                );\n+            }\n         };\n \n         let kind_stats: KindsStatistics = kind_slugs.iter().map(|(kind, _slug)| kind).collect();"}, {"sha": "61d5007fc30f0a135c7176a56bb355f111c2ce0e", "filename": "compiler/rustc_macros/src/diagnostics/utils.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -477,7 +477,12 @@ impl SubdiagnosticKind {\n     pub(super) fn from_attr(\n         attr: &Attribute,\n         fields: &impl HasFieldMap,\n-    ) -> Result<(SubdiagnosticKind, Option<Path>), DiagnosticDeriveError> {\n+    ) -> Result<Option<(SubdiagnosticKind, Option<Path>)>, DiagnosticDeriveError> {\n+        // Always allow documentation comments.\n+        if is_doc_comment(attr) {\n+            return Ok(None);\n+        }\n+\n         let span = attr.span().unwrap();\n \n         let name = attr.path.segments.last().unwrap().ident.to_string();\n@@ -526,7 +531,9 @@ impl SubdiagnosticKind {\n                     | SubdiagnosticKind::Note\n                     | SubdiagnosticKind::Help\n                     | SubdiagnosticKind::Warn\n-                    | SubdiagnosticKind::MultipartSuggestion { .. } => return Ok((kind, None)),\n+                    | SubdiagnosticKind::MultipartSuggestion { .. } => {\n+                        return Ok(Some((kind, None)));\n+                    }\n                     SubdiagnosticKind::Suggestion { .. } => {\n                         throw_span_err!(span, \"suggestion without `code = \\\"...\\\"`\")\n                     }\n@@ -626,7 +633,7 @@ impl SubdiagnosticKind {\n             | SubdiagnosticKind::MultipartSuggestion { .. } => {}\n         }\n \n-        Ok((kind, slug))\n+        Ok(Some((kind, slug)))\n     }\n }\n \n@@ -654,3 +661,7 @@ impl quote::IdentFragment for SubdiagnosticKind {\n pub(super) fn should_generate_set_arg(field: &Field) -> bool {\n     field.attrs.is_empty()\n }\n+\n+pub(super) fn is_doc_comment(attr: &Attribute) -> bool {\n+    attr.path.segments.last().unwrap().ident.to_string() == \"doc\"\n+}"}, {"sha": "7c387b9a9ecde156409a01d08f83511d1f0a27c5", "filename": "compiler/rustc_metadata/src/errors.rs", "status": "modified", "additions": 93, "deletions": 93, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Ferrors.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -12,128 +12,128 @@ use rustc_target::spec::{PanicStrategy, TargetTriple};\n use crate::locator::CrateFlavor;\n \n #[derive(Diagnostic)]\n-#[diag(metadata::rlib_required)]\n+#[diag(metadata_rlib_required)]\n pub struct RlibRequired {\n     pub crate_name: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::lib_required)]\n+#[diag(metadata_lib_required)]\n pub struct LibRequired<'a> {\n     pub crate_name: Symbol,\n     pub kind: &'a str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::crate_dep_multiple)]\n+#[diag(metadata_crate_dep_multiple)]\n #[help]\n pub struct CrateDepMultiple {\n     pub crate_name: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::two_panic_runtimes)]\n+#[diag(metadata_two_panic_runtimes)]\n pub struct TwoPanicRuntimes {\n     pub prev_name: Symbol,\n     pub cur_name: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::bad_panic_strategy)]\n+#[diag(metadata_bad_panic_strategy)]\n pub struct BadPanicStrategy {\n     pub runtime: Symbol,\n     pub strategy: PanicStrategy,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::required_panic_strategy)]\n+#[diag(metadata_required_panic_strategy)]\n pub struct RequiredPanicStrategy {\n     pub crate_name: Symbol,\n     pub found_strategy: PanicStrategy,\n     pub desired_strategy: PanicStrategy,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::incompatible_panic_in_drop_strategy)]\n+#[diag(metadata_incompatible_panic_in_drop_strategy)]\n pub struct IncompatiblePanicInDropStrategy {\n     pub crate_name: Symbol,\n     pub found_strategy: PanicStrategy,\n     pub desired_strategy: PanicStrategy,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::multiple_names_in_link)]\n+#[diag(metadata_multiple_names_in_link)]\n pub struct MultipleNamesInLink {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::multiple_kinds_in_link)]\n+#[diag(metadata_multiple_kinds_in_link)]\n pub struct MultipleKindsInLink {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::link_name_form)]\n+#[diag(metadata_link_name_form)]\n pub struct LinkNameForm {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::link_kind_form)]\n+#[diag(metadata_link_kind_form)]\n pub struct LinkKindForm {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::link_modifiers_form)]\n+#[diag(metadata_link_modifiers_form)]\n pub struct LinkModifiersForm {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::link_cfg_form)]\n+#[diag(metadata_link_cfg_form)]\n pub struct LinkCfgForm {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::wasm_import_form)]\n+#[diag(metadata_wasm_import_form)]\n pub struct WasmImportForm {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::empty_link_name, code = \"E0454\")]\n+#[diag(metadata_empty_link_name, code = \"E0454\")]\n pub struct EmptyLinkName {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::link_framework_apple, code = \"E0455\")]\n+#[diag(metadata_link_framework_apple, code = \"E0455\")]\n pub struct LinkFrameworkApple {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::framework_only_windows, code = \"E0455\")]\n+#[diag(metadata_framework_only_windows, code = \"E0455\")]\n pub struct FrameworkOnlyWindows {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::unknown_link_kind, code = \"E0458\")]\n+#[diag(metadata_unknown_link_kind, code = \"E0458\")]\n pub struct UnknownLinkKind<'a> {\n     #[primary_span]\n     #[label]\n@@ -142,235 +142,235 @@ pub struct UnknownLinkKind<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::multiple_link_modifiers)]\n+#[diag(metadata_multiple_link_modifiers)]\n pub struct MultipleLinkModifiers {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::multiple_cfgs)]\n+#[diag(metadata_multiple_cfgs)]\n pub struct MultipleCfgs {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::link_cfg_single_predicate)]\n+#[diag(metadata_link_cfg_single_predicate)]\n pub struct LinkCfgSinglePredicate {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::multiple_wasm_import)]\n+#[diag(metadata_multiple_wasm_import)]\n pub struct MultipleWasmImport {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::unexpected_link_arg)]\n+#[diag(metadata_unexpected_link_arg)]\n pub struct UnexpectedLinkArg {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::invalid_link_modifier)]\n+#[diag(metadata_invalid_link_modifier)]\n pub struct InvalidLinkModifier {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::multiple_modifiers)]\n+#[diag(metadata_multiple_modifiers)]\n pub struct MultipleModifiers<'a> {\n     #[primary_span]\n     pub span: Span,\n     pub modifier: &'a str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::bundle_needs_static)]\n+#[diag(metadata_bundle_needs_static)]\n pub struct BundleNeedsStatic {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::whole_archive_needs_static)]\n+#[diag(metadata_whole_archive_needs_static)]\n pub struct WholeArchiveNeedsStatic {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::as_needed_compatibility)]\n+#[diag(metadata_as_needed_compatibility)]\n pub struct AsNeededCompatibility {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::unknown_link_modifier)]\n+#[diag(metadata_unknown_link_modifier)]\n pub struct UnknownLinkModifier<'a> {\n     #[primary_span]\n     pub span: Span,\n     pub modifier: &'a str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::incompatible_wasm_link)]\n+#[diag(metadata_incompatible_wasm_link)]\n pub struct IncompatibleWasmLink {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::link_requires_name, code = \"E0459\")]\n+#[diag(metadata_link_requires_name, code = \"E0459\")]\n pub struct LinkRequiresName {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::raw_dylib_no_nul)]\n+#[diag(metadata_raw_dylib_no_nul)]\n pub struct RawDylibNoNul {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::link_ordinal_raw_dylib)]\n+#[diag(metadata_link_ordinal_raw_dylib)]\n pub struct LinkOrdinalRawDylib {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::lib_framework_apple)]\n+#[diag(metadata_lib_framework_apple)]\n pub struct LibFrameworkApple;\n \n #[derive(Diagnostic)]\n-#[diag(metadata::empty_renaming_target)]\n+#[diag(metadata_empty_renaming_target)]\n pub struct EmptyRenamingTarget<'a> {\n     pub lib_name: &'a str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::renaming_no_link)]\n+#[diag(metadata_renaming_no_link)]\n pub struct RenamingNoLink<'a> {\n     pub lib_name: &'a str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::multiple_renamings)]\n+#[diag(metadata_multiple_renamings)]\n pub struct MultipleRenamings<'a> {\n     pub lib_name: &'a str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::no_link_mod_override)]\n+#[diag(metadata_no_link_mod_override)]\n pub struct NoLinkModOverride {\n     #[primary_span]\n     pub span: Option<Span>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::unsupported_abi_i686)]\n+#[diag(metadata_unsupported_abi_i686)]\n pub struct UnsupportedAbiI686 {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::unsupported_abi)]\n+#[diag(metadata_unsupported_abi)]\n pub struct UnsupportedAbi {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::fail_create_file_encoder)]\n+#[diag(metadata_fail_create_file_encoder)]\n pub struct FailCreateFileEncoder {\n     pub err: Error,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::fail_seek_file)]\n+#[diag(metadata_fail_seek_file)]\n pub struct FailSeekFile {\n     pub err: Error,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::fail_write_file)]\n+#[diag(metadata_fail_write_file)]\n pub struct FailWriteFile {\n     pub err: Error,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::crate_not_panic_runtime)]\n+#[diag(metadata_crate_not_panic_runtime)]\n pub struct CrateNotPanicRuntime {\n     pub crate_name: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::no_panic_strategy)]\n+#[diag(metadata_no_panic_strategy)]\n pub struct NoPanicStrategy {\n     pub crate_name: Symbol,\n     pub strategy: PanicStrategy,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::profiler_builtins_needs_core)]\n+#[diag(metadata_profiler_builtins_needs_core)]\n pub struct ProfilerBuiltinsNeedsCore;\n \n #[derive(Diagnostic)]\n-#[diag(metadata::not_profiler_runtime)]\n+#[diag(metadata_not_profiler_runtime)]\n pub struct NotProfilerRuntime {\n     pub crate_name: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::no_multiple_global_alloc)]\n+#[diag(metadata_no_multiple_global_alloc)]\n pub struct NoMultipleGlobalAlloc {\n     #[primary_span]\n     #[label]\n     pub span2: Span,\n-    #[label(metadata::prev_global_alloc)]\n+    #[label(metadata_prev_global_alloc)]\n     pub span1: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::conflicting_global_alloc)]\n+#[diag(metadata_conflicting_global_alloc)]\n pub struct ConflictingGlobalAlloc {\n     pub crate_name: Symbol,\n     pub other_crate_name: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::global_alloc_required)]\n+#[diag(metadata_global_alloc_required)]\n pub struct GlobalAllocRequired;\n \n #[derive(Diagnostic)]\n-#[diag(metadata::no_transitive_needs_dep)]\n+#[diag(metadata_no_transitive_needs_dep)]\n pub struct NoTransitiveNeedsDep<'a> {\n     pub crate_name: Symbol,\n     pub needs_crate_name: &'a str,\n     pub deps_crate_name: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::failed_write_error)]\n+#[diag(metadata_failed_write_error)]\n pub struct FailedWriteError {\n     pub filename: PathBuf,\n     pub err: Error,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::missing_native_library)]\n+#[diag(metadata_missing_native_library)]\n pub struct MissingNativeLibrary<'a> {\n     libname: &'a str,\n     #[subdiagnostic]\n@@ -404,40 +404,40 @@ impl<'a> MissingNativeLibrary<'a> {\n }\n \n #[derive(Subdiagnostic)]\n-#[help(metadata::only_provide_library_name)]\n+#[help(metadata_only_provide_library_name)]\n pub struct SuggestLibraryName<'a> {\n     suggested_name: &'a str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::failed_create_tempdir)]\n+#[diag(metadata_failed_create_tempdir)]\n pub struct FailedCreateTempdir {\n     pub err: Error,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::failed_create_file)]\n+#[diag(metadata_failed_create_file)]\n pub struct FailedCreateFile<'a> {\n     pub filename: &'a Path,\n     pub err: Error,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::failed_create_encoded_metadata)]\n+#[diag(metadata_failed_create_encoded_metadata)]\n pub struct FailedCreateEncodedMetadata {\n     pub err: Error,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::non_ascii_name)]\n+#[diag(metadata_non_ascii_name)]\n pub struct NonAsciiName {\n     #[primary_span]\n     pub span: Span,\n     pub crate_name: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::extern_location_not_exist)]\n+#[diag(metadata_extern_location_not_exist)]\n pub struct ExternLocationNotExist<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -446,7 +446,7 @@ pub struct ExternLocationNotExist<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::extern_location_not_file)]\n+#[diag(metadata_extern_location_not_file)]\n pub struct ExternLocationNotFile<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -466,7 +466,7 @@ impl IntoDiagnostic<'_> for MultipleCandidates {\n         self,\n         handler: &'_ rustc_errors::Handler,\n     ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n-        let mut diag = handler.struct_err(rustc_errors::fluent::metadata::multiple_candidates);\n+        let mut diag = handler.struct_err(rustc_errors::fluent::metadata_multiple_candidates);\n         diag.set_arg(\"crate_name\", self.crate_name);\n         diag.set_arg(\"flavor\", self.flavor);\n         diag.code(error_code!(E0465));\n@@ -479,7 +479,7 @@ impl IntoDiagnostic<'_> for MultipleCandidates {\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::multiple_matching_crates, code = \"E0464\")]\n+#[diag(metadata_multiple_matching_crates, code = \"E0464\")]\n #[note]\n pub struct MultipleMatchingCrates {\n     #[primary_span]\n@@ -489,23 +489,23 @@ pub struct MultipleMatchingCrates {\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::symbol_conflicts_current, code = \"E0519\")]\n+#[diag(metadata_symbol_conflicts_current, code = \"E0519\")]\n pub struct SymbolConflictsCurrent {\n     #[primary_span]\n     pub span: Span,\n     pub crate_name: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::symbol_conflicts_others, code = \"E0523\")]\n+#[diag(metadata_symbol_conflicts_others, code = \"E0523\")]\n pub struct SymbolConflictsOthers {\n     #[primary_span]\n     pub span: Span,\n     pub crate_name: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::stable_crate_id_collision)]\n+#[diag(metadata_stable_crate_id_collision)]\n pub struct StableCrateIdCollision {\n     #[primary_span]\n     pub span: Span,\n@@ -514,17 +514,17 @@ pub struct StableCrateIdCollision {\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::dl_error)]\n+#[diag(metadata_dl_error)]\n pub struct DlError {\n     #[primary_span]\n     pub span: Span,\n     pub err: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::newer_crate_version, code = \"E0460\")]\n+#[diag(metadata_newer_crate_version, code = \"E0460\")]\n #[note]\n-#[note(metadata::found_crate_versions)]\n+#[note(metadata_found_crate_versions)]\n pub struct NewerCrateVersion {\n     #[primary_span]\n     pub span: Span,\n@@ -534,8 +534,8 @@ pub struct NewerCrateVersion {\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::no_crate_with_triple, code = \"E0461\")]\n-#[note(metadata::found_crate_versions)]\n+#[diag(metadata_no_crate_with_triple, code = \"E0461\")]\n+#[note(metadata_found_crate_versions)]\n pub struct NoCrateWithTriple<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -546,8 +546,8 @@ pub struct NoCrateWithTriple<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::found_staticlib, code = \"E0462\")]\n-#[note(metadata::found_crate_versions)]\n+#[diag(metadata_found_staticlib, code = \"E0462\")]\n+#[note(metadata_found_crate_versions)]\n #[help]\n pub struct FoundStaticlib {\n     #[primary_span]\n@@ -558,8 +558,8 @@ pub struct FoundStaticlib {\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::incompatible_rustc, code = \"E0514\")]\n-#[note(metadata::found_crate_versions)]\n+#[diag(metadata_incompatible_rustc, code = \"E0514\")]\n+#[note(metadata_found_crate_versions)]\n #[help]\n pub struct IncompatibleRustc {\n     #[primary_span]\n@@ -582,7 +582,7 @@ impl IntoDiagnostic<'_> for InvalidMetadataFiles {\n         self,\n         handler: &'_ rustc_errors::Handler,\n     ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n-        let mut diag = handler.struct_err(rustc_errors::fluent::metadata::invalid_meta_files);\n+        let mut diag = handler.struct_err(rustc_errors::fluent::metadata_invalid_meta_files);\n         diag.set_arg(\"crate_name\", self.crate_name);\n         diag.set_arg(\"add_info\", self.add_info);\n         diag.code(error_code!(E0786));\n@@ -610,7 +610,7 @@ impl IntoDiagnostic<'_> for CannotFindCrate {\n         self,\n         handler: &'_ rustc_errors::Handler,\n     ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n-        let mut diag = handler.struct_err(rustc_errors::fluent::metadata::cannot_find_crate);\n+        let mut diag = handler.struct_err(rustc_errors::fluent::metadata_cannot_find_crate);\n         diag.set_arg(\"crate_name\", self.crate_name);\n         diag.set_arg(\"current_crate\", self.current_crate);\n         diag.set_arg(\"add_info\", self.add_info);\n@@ -621,54 +621,54 @@ impl IntoDiagnostic<'_> for CannotFindCrate {\n             && self.locator_triple != TargetTriple::from_triple(config::host_triple())\n         {\n             if self.missing_core {\n-                diag.note(rustc_errors::fluent::metadata::target_not_installed);\n+                diag.note(rustc_errors::fluent::metadata_target_not_installed);\n             } else {\n-                diag.note(rustc_errors::fluent::metadata::target_no_std_support);\n+                diag.note(rustc_errors::fluent::metadata_target_no_std_support);\n             }\n             // NOTE: this suggests using rustup, even though the user may not have it installed.\n             // That's because they could choose to install it; or this may give them a hint which\n             // target they need to install from their distro.\n             if self.missing_core {\n-                diag.help(rustc_errors::fluent::metadata::consider_downloading_target);\n+                diag.help(rustc_errors::fluent::metadata_consider_downloading_target);\n             }\n             // Suggest using #![no_std]. #[no_core] is unstable and not really supported anyway.\n             // NOTE: this is a dummy span if `extern crate std` was injected by the compiler.\n             // If it's not a dummy, that means someone added `extern crate std` explicitly and\n             // `#![no_std]` won't help.\n             if !self.missing_core && self.span.is_dummy() {\n-                diag.note(rustc_errors::fluent::metadata::std_required);\n+                diag.note(rustc_errors::fluent::metadata_std_required);\n             }\n             if self.is_nightly_build {\n-                diag.help(rustc_errors::fluent::metadata::consider_building_std);\n+                diag.help(rustc_errors::fluent::metadata_consider_building_std);\n             }\n         } else if self.crate_name == self.profiler_runtime {\n-            diag.note(rustc_errors::fluent::metadata::compiler_missing_profiler);\n+            diag.note(rustc_errors::fluent::metadata_compiler_missing_profiler);\n         } else if self.crate_name.as_str().starts_with(\"rustc_\") {\n-            diag.help(rustc_errors::fluent::metadata::install_missing_components);\n+            diag.help(rustc_errors::fluent::metadata_install_missing_components);\n         }\n-        diag.span_label(self.span, rustc_errors::fluent::metadata::cant_find_crate);\n+        diag.span_label(self.span, rustc_errors::fluent::metadata_cant_find_crate);\n         diag\n     }\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::no_dylib_plugin, code = \"E0457\")]\n+#[diag(metadata_no_dylib_plugin, code = \"E0457\")]\n pub struct NoDylibPlugin {\n     #[primary_span]\n     pub span: Span,\n     pub crate_name: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::crate_location_unknown_type)]\n+#[diag(metadata_crate_location_unknown_type)]\n pub struct CrateLocationUnknownType<'a> {\n     #[primary_span]\n     pub span: Span,\n     pub path: &'a Path,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::lib_filename_form)]\n+#[diag(metadata_lib_filename_form)]\n pub struct LibFilenameForm<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -677,36 +677,36 @@ pub struct LibFilenameForm<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::multiple_import_name_type)]\n+#[diag(metadata_multiple_import_name_type)]\n pub struct MultipleImportNameType {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::import_name_type_form)]\n+#[diag(metadata_import_name_type_form)]\n pub struct ImportNameTypeForm {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::import_name_type_x86)]\n+#[diag(metadata_import_name_type_x86)]\n pub struct ImportNameTypeX86 {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::unknown_import_name_type)]\n+#[diag(metadata_unknown_import_name_type)]\n pub struct UnknownImportNameType<'a> {\n     #[primary_span]\n     pub span: Span,\n     pub import_name_type: &'a str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(metadata::import_name_type_raw)]\n+#[diag(metadata_import_name_type_raw)]\n pub struct ImportNameTypeRaw {\n     #[primary_span]\n     pub span: Span,"}, {"sha": "a0a0855251b8dc241837ce3e1488a9b8445b1184", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -15,7 +15,6 @@ use rustc_middle::ty::fast_reject::SimplifiedType;\n use rustc_middle::ty::query::{ExternProviders, Providers};\n use rustc_middle::ty::{self, TyCtxt, Visibility};\n use rustc_session::cstore::{CrateSource, CrateStore};\n-use rustc_session::utils::NativeLibKind;\n use rustc_session::{Session, StableCrateId};\n use rustc_span::hygiene::{ExpnHash, ExpnId};\n use rustc_span::source_map::{Span, Spanned};\n@@ -224,6 +223,7 @@ provide! { tcx, def_id, other, cdata,\n     fn_arg_names => { table }\n     generator_kind => { table }\n     trait_def => { table }\n+    deduced_param_attrs => { table }\n     collect_trait_impl_trait_tys => {\n         Ok(cdata\n             .root\n@@ -339,20 +339,10 @@ pub(in crate::rmeta) fn provide(providers: &mut Providers) {\n     // resolve! Does this work? Unsure! That's what the issue is about\n     *providers = Providers {\n         allocator_kind: |tcx, ()| CStore::from_tcx(tcx).allocator_kind(),\n-        is_dllimport_foreign_item: |tcx, id| match tcx.native_library_kind(id) {\n-            Some(\n-                NativeLibKind::Dylib { .. } | NativeLibKind::RawDylib | NativeLibKind::Unspecified,\n-            ) => true,\n-            _ => false,\n-        },\n-        is_statically_included_foreign_item: |tcx, id| {\n-            matches!(tcx.native_library_kind(id), Some(NativeLibKind::Static { .. }))\n-        },\n         is_private_dep: |_tcx, cnum| {\n             assert_eq!(cnum, LOCAL_CRATE);\n             false\n         },\n-        native_library_kind: |tcx, id| tcx.native_library(id).map(|l| l.kind),\n         native_library: |tcx, id| {\n             tcx.native_libraries(id.krate)\n                 .iter()\n@@ -597,11 +587,6 @@ impl CStore {\n         self.get_crate_data(cnum).get_proc_macro_quoted_span(id, sess)\n     }\n \n-    /// Decodes all traits in the crate (for rustdoc).\n-    pub fn traits_in_crate_untracked(&self, cnum: CrateNum) -> impl Iterator<Item = DefId> + '_ {\n-        self.get_crate_data(cnum).get_traits()\n-    }\n-\n     /// Decodes all trait impls in the crate (for rustdoc).\n     pub fn trait_impls_in_crate_untracked(\n         &self,"}, {"sha": "c019211a948e3503eb04a74c689e20cb85d27093", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 57, "deletions": 5, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -3,6 +3,7 @@ use crate::rmeta::def_path_hash_map::DefPathHashMapRef;\n use crate::rmeta::table::TableBuilder;\n use crate::rmeta::*;\n \n+use rustc_ast::Attribute;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n use rustc_data_structures::memmap::{Mmap, MmapMut};\n@@ -30,7 +31,7 @@ use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, SymbolName, Ty, TyCtxt};\n use rustc_middle::util::common::to_readable_str;\n use rustc_serialize::{opaque, Decodable, Decoder, Encodable, Encoder};\n-use rustc_session::config::CrateType;\n+use rustc_session::config::{CrateType, OptLevel};\n use rustc_session::cstore::{ForeignModule, LinkagePreference, NativeLib};\n use rustc_span::hygiene::{ExpnIndex, HygieneEncodeContext, MacroKind};\n use rustc_span::symbol::{sym, Symbol};\n@@ -764,6 +765,40 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n }\n \n+/// Returns whether an attribute needs to be recorded in metadata, that is, if it's usable and\n+/// useful in downstream crates. Local-only attributes are an obvious example, but some\n+/// rustdoc-specific attributes can equally be of use while documenting the current crate only.\n+///\n+/// Removing these superfluous attributes speeds up compilation by making the metadata smaller.\n+///\n+/// Note: the `is_def_id_public` parameter is used to cache whether the given `DefId` has a public\n+/// visibility: this is a piece of data that can be computed once per defid, and not once per\n+/// attribute. Some attributes would only be usable downstream if they are public.\n+#[inline]\n+fn should_encode_attr(\n+    tcx: TyCtxt<'_>,\n+    attr: &Attribute,\n+    def_id: LocalDefId,\n+    is_def_id_public: &mut Option<bool>,\n+) -> bool {\n+    if rustc_feature::is_builtin_only_local(attr.name_or_empty()) {\n+        // Attributes marked local-only don't need to be encoded for downstream crates.\n+        false\n+    } else if attr.doc_str().is_some() {\n+        // We keep all public doc comments because they might be \"imported\" into downstream crates\n+        // if they use `#[doc(inline)]` to copy an item's documentation into their own.\n+        *is_def_id_public.get_or_insert_with(|| {\n+            tcx.privacy_access_levels(()).get_effective_vis(def_id).is_some()\n+        })\n+    } else if attr.has_name(sym::doc) {\n+        // If this is a `doc` attribute, and it's marked `inline` (as in `#[doc(inline)]`), we can\n+        // remove it. It won't be inlinable in downstream crates.\n+        attr.meta_item_list().map(|l| l.iter().any(|l| !l.has_name(sym::inline))).unwrap_or(false)\n+    } else {\n+        true\n+    }\n+}\n+\n fn should_encode_visibility(def_kind: DefKind) -> bool {\n     match def_kind {\n         DefKind::Mod\n@@ -1126,12 +1161,14 @@ fn should_encode_trait_impl_trait_tys<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) ->\n \n impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_attrs(&mut self, def_id: LocalDefId) {\n-        let mut attrs = self\n-            .tcx\n+        let tcx = self.tcx;\n+        let mut is_public: Option<bool> = None;\n+\n+        let mut attrs = tcx\n             .hir()\n-            .attrs(self.tcx.hir().local_def_id_to_hir_id(def_id))\n+            .attrs(tcx.hir().local_def_id_to_hir_id(def_id))\n             .iter()\n-            .filter(|attr| !rustc_feature::is_builtin_only_local(attr.name_or_empty()));\n+            .filter(move |attr| should_encode_attr(tcx, attr, def_id, &mut is_public));\n \n         record_array!(self.tables.attributes[def_id.to_def_id()] <- attrs.clone());\n         if attrs.any(|attr| attr.may_have_doc_links()) {\n@@ -1441,6 +1478,21 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 record!(self.tables.unused_generic_params[def_id.to_def_id()] <- unused);\n             }\n         }\n+\n+        // Encode all the deduced parameter attributes for everything that has MIR, even for items\n+        // that can't be inlined. But don't if we aren't optimizing in non-incremental mode, to\n+        // save the query traffic.\n+        if tcx.sess.opts.output_types.should_codegen()\n+            && tcx.sess.opts.optimize != OptLevel::No\n+            && tcx.sess.opts.incremental.is_none()\n+        {\n+            for &local_def_id in tcx.mir_keys(()) {\n+                if let DefKind::AssocFn | DefKind::Fn = tcx.def_kind(local_def_id) {\n+                    record_array!(self.tables.deduced_param_attrs[local_def_id.to_def_id()] <-\n+                        self.tcx.deduced_param_attrs(local_def_id.to_def_id()));\n+                }\n+            }\n+        }\n     }\n \n     fn encode_stability(&mut self, def_id: DefId) {"}, {"sha": "27dc8ff16ac56e1ca0751249fd83b219496ca5c7", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -23,7 +23,7 @@ use rustc_middle::mir;\n use rustc_middle::ty::fast_reject::SimplifiedType;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, ReprOptions, Ty};\n-use rustc_middle::ty::{GeneratorDiagnosticData, ParameterizedOverTcx, TyCtxt};\n+use rustc_middle::ty::{DeducedParamAttrs, GeneratorDiagnosticData, ParameterizedOverTcx, TyCtxt};\n use rustc_serialize::opaque::FileEncoder;\n use rustc_session::config::SymbolManglingVersion;\n use rustc_session::cstore::{CrateDepKind, ForeignModule, LinkagePreference, NativeLib};\n@@ -402,6 +402,7 @@ define_tables! {\n     macro_definition: Table<DefIndex, LazyValue<ast::MacArgs>>,\n     proc_macro: Table<DefIndex, MacroKind>,\n     module_reexports: Table<DefIndex, LazyArray<ModChild>>,\n+    deduced_param_attrs: Table<DefIndex, LazyArray<DeducedParamAttrs>>,\n \n     trait_impl_trait_tys: Table<DefIndex, LazyValue<FxHashMap<DefId, Ty<'static>>>>,\n }"}, {"sha": "a7a7ac0599d7176a831892136e96f2f4f720f7b3", "filename": "compiler/rustc_middle/src/error.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_middle%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_middle%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ferror.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -4,7 +4,7 @@ use rustc_span::Span;\n use crate::ty::Ty;\n \n #[derive(Diagnostic)]\n-#[diag(middle::drop_check_overflow, code = \"E0320\")]\n+#[diag(middle_drop_check_overflow, code = \"E0320\")]\n #[note]\n pub struct DropCheckOverflow<'tcx> {\n     #[primary_span]\n@@ -14,7 +14,7 @@ pub struct DropCheckOverflow<'tcx> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(middle::opaque_hidden_type_mismatch)]\n+#[diag(middle_opaque_hidden_type_mismatch)]\n pub struct OpaqueHiddenTypeMismatch<'tcx> {\n     pub self_ty: Ty<'tcx>,\n     pub other_ty: Ty<'tcx>,\n@@ -27,20 +27,20 @@ pub struct OpaqueHiddenTypeMismatch<'tcx> {\n \n #[derive(Subdiagnostic)]\n pub enum TypeMismatchReason {\n-    #[label(middle::conflict_types)]\n+    #[label(middle_conflict_types)]\n     ConflictType {\n         #[primary_span]\n         span: Span,\n     },\n-    #[note(middle::previous_use_here)]\n+    #[note(middle_previous_use_here)]\n     PreviousUse {\n         #[primary_span]\n         span: Span,\n     },\n }\n \n #[derive(Diagnostic)]\n-#[diag(middle::limit_invalid)]\n+#[diag(middle_limit_invalid)]\n pub struct LimitInvalid<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -50,7 +50,7 @@ pub struct LimitInvalid<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(middle::const_eval_non_int)]\n+#[diag(middle_const_eval_non_int)]\n pub struct ConstEvalNonIntError {\n     #[primary_span]\n     pub span: Span,"}, {"sha": "a58cbc3767ed658980878daebc399a2cb7a6d672", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -55,6 +55,7 @@\n #![feature(drain_filter)]\n #![feature(intra_doc_pointers)]\n #![feature(yeet_expr)]\n+#![feature(result_option_inspect)]\n #![feature(const_option)]\n #![recursion_limit = \"512\"]\n #![allow(rustc::potential_query_instability)]"}, {"sha": "473894ac1cae8279fe6a31e04e734417e7f296d8", "filename": "compiler/rustc_middle/src/mir/interpret/queries.rs", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -4,7 +4,9 @@ use crate::mir;\n use crate::ty::subst::InternalSubsts;\n use crate::ty::visit::TypeVisitable;\n use crate::ty::{self, query::TyCtxtAt, query::TyCtxtEnsure, TyCtxt};\n+use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n+use rustc_session::lint;\n use rustc_span::{Span, DUMMY_SP};\n \n impl<'tcx> TyCtxt<'tcx> {\n@@ -51,7 +53,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n         match ty::Instance::resolve_opt_const_arg(\n             self, param_env,\n-            // FIXME: maybe have a seperate version for resolving mir::UnevaluatedConst?\n+            // FIXME: maybe have a separate version for resolving mir::UnevaluatedConst?\n             ct.def, ct.substs,\n         ) {\n             Ok(Some(instance)) => {\n@@ -83,7 +85,29 @@ impl<'tcx> TyCtxt<'tcx> {\n         match ty::Instance::resolve_opt_const_arg(self, param_env, ct.def, ct.substs) {\n             Ok(Some(instance)) => {\n                 let cid = GlobalId { instance, promoted: None };\n-                self.const_eval_global_id_for_typeck(param_env, cid, span)\n+                self.const_eval_global_id_for_typeck(param_env, cid, span).inspect(|_| {\n+                    // We are emitting the lint here instead of in `is_const_evaluatable`\n+                    // as we normalize obligations before checking them, and normalization\n+                    // uses this function to evaluate this constant.\n+                    //\n+                    // @lcnr believes that successfully evaluating even though there are\n+                    // used generic parameters is a bug of evaluation, so checking for it\n+                    // here does feel somewhat sensible.\n+                    if !self.features().generic_const_exprs && ct.substs.has_non_region_param() {\n+                        assert!(matches!(self.def_kind(ct.def.did), DefKind::AnonConst));\n+                        let mir_body = self.mir_for_ctfe_opt_const_arg(ct.def);\n+                        if mir_body.is_polymorphic {\n+                            let Some(local_def_id) = ct.def.did.as_local() else { return };\n+                            self.struct_span_lint_hir(\n+                                lint::builtin::CONST_EVALUATABLE_UNCHECKED,\n+                                self.hir().local_def_id_to_hir_id(local_def_id),\n+                                self.def_span(ct.def.did),\n+                                \"cannot use constants which depend on generic parameters in types\",\n+                                |err| err,\n+                            )\n+                        }\n+                    }\n+                })\n             }\n             Ok(None) => Err(ErrorHandled::TooGeneric),\n             Err(error_reported) => Err(ErrorHandled::Reported(error_reported)),"}, {"sha": "2ab3b0d27c88a3104657381961d43f68a1584802", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -1587,16 +1587,6 @@ rustc_queries! {\n         separate_provide_extern\n     }\n \n-    query is_dllimport_foreign_item(def_id: DefId) -> bool {\n-        desc { |tcx| \"checking if `{}` is a a dylib\", tcx.def_path_str(def_id) }\n-    }\n-    query is_statically_included_foreign_item(def_id: DefId) -> bool {\n-        desc { |tcx| \"checking if `{}` is a staticlib\", tcx.def_path_str(def_id) }\n-    }\n-    query native_library_kind(def_id: DefId)\n-        -> Option<NativeLibKind> {\n-        desc { |tcx| \"getting the native library kind of `{}`\", tcx.def_path_str(def_id) }\n-    }\n     query native_library(def_id: DefId) -> Option<&'tcx NativeLib> {\n         desc { |tcx| \"getting the native library for `{}`\", tcx.def_path_str(def_id) }\n     }\n@@ -1653,14 +1643,13 @@ rustc_queries! {\n         separate_provide_extern\n     }\n \n-    /// Computes the set of modules from which this type is visibly uninhabited.\n-    /// To check whether a type is uninhabited at all (not just from a given module), you could\n-    /// check whether the forest is empty.\n-    query type_uninhabited_from(\n-        key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>\n-    ) -> ty::inhabitedness::DefIdForest<'tcx> {\n-        desc { \"computing the inhabitedness of `{}`\", key.value }\n-        remap_env_constness\n+    query inhabited_predicate_adt(key: DefId) -> ty::inhabitedness::InhabitedPredicate<'tcx> {\n+        desc { \"computing the uninhabited predicate of `{:?}`\", key }\n+    }\n+\n+    /// Do not call this query directly: invoke `Ty::inhabited_predicate` instead.\n+    query inhabited_predicate_type(key: Ty<'tcx>) -> ty::inhabitedness::InhabitedPredicate<'tcx> {\n+        desc { \"computing the uninhabited predicate of `{}`\", key }\n     }\n \n     query dep_kind(_: CrateNum) -> CrateDepKind {\n@@ -2127,4 +2116,9 @@ rustc_queries! {\n     ) -> Result<(), ErrorGuaranteed> {\n         desc { |tcx| \"checking assoc const `{}` has the same type as trait item\", tcx.def_path_str(key.0.to_def_id()) }\n     }\n+\n+    query deduced_param_attrs(def_id: DefId) -> &'tcx [ty::DeducedParamAttrs] {\n+        desc { |tcx| \"deducing parameter attributes for {}\", tcx.def_path_str(def_id) }\n+        separate_provide_extern\n+    }\n }"}, {"sha": "14ec88b7e0d7ef15f099a259b2b70b9dd07fc39b", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -455,6 +455,7 @@ impl_arena_copy_decoder! {<'tcx>\n     rustc_span::def_id::DefId,\n     rustc_span::def_id::LocalDefId,\n     (rustc_middle::middle::exported_symbols::ExportedSymbol<'tcx>, rustc_middle::middle::exported_symbols::SymbolExportInfo),\n+    ty::DeducedParamAttrs,\n }\n \n #[macro_export]"}, {"sha": "f998e6083448f136171ac8336296f0b69ae80f4a", "filename": "compiler/rustc_middle/src/ty/consts.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -263,6 +263,10 @@ impl<'tcx> Const<'tcx> {\n         self.try_eval_usize(tcx, param_env)\n             .unwrap_or_else(|| bug!(\"expected usize, got {:#?}\", self))\n     }\n+\n+    pub fn is_ct_infer(self) -> bool {\n+        matches!(self.kind(), ty::ConstKind::Infer(_))\n+    }\n }\n \n pub fn const_param_default<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Const<'tcx> {"}, {"sha": "4ab761e0715cd590dc02a23211ffc79d62e1b595", "filename": "compiler/rustc_middle/src/ty/consts/kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -15,7 +15,7 @@ use super::ScalarInt;\n \n /// An unevaluated (potentially generic) constant used in the type-system.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, TyEncodable, TyDecodable, Lift)]\n-#[derive(Hash, HashStable)]\n+#[derive(Hash, HashStable, TypeFoldable, TypeVisitable)]\n pub struct UnevaluatedConst<'tcx> {\n     pub def: ty::WithOptConstParam<DefId>,\n     pub substs: SubstsRef<'tcx>,"}, {"sha": "0816a5cb8f16eb178be28ad1a1dbc56ea4197b76", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -2954,6 +2954,21 @@ impl<'tcx> TyCtxtAt<'tcx> {\n     }\n }\n \n+/// Parameter attributes that can only be determined by examining the body of a function instead\n+/// of just its signature.\n+///\n+/// These can be useful for optimization purposes when a function is directly called. We compute\n+/// them and store them into the crate metadata so that downstream crates can make use of them.\n+///\n+/// Right now, we only have `read_only`, but `no_capture` and `no_alias` might be useful in the\n+/// future.\n+#[derive(Clone, Copy, PartialEq, Debug, Default, TyDecodable, TyEncodable, HashStable)]\n+pub struct DeducedParamAttrs {\n+    /// The parameter is marked immutable in the function and contains no `UnsafeCell` (i.e. its\n+    /// type is freeze).\n+    pub read_only: bool,\n+}\n+\n // We are comparing types with different invariant lifetimes, so `ptr::eq`\n // won't work for us.\n fn ptr_eq<T, U>(t: *const T, u: *const U) -> bool {"}, {"sha": "b8fd01e6a77975c099a351d990dae5301e69fb96", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -513,7 +513,7 @@ impl<'tcx> TypeVisitor<'tcx> for IsSuggestableVisitor<'tcx> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(borrowck::const_not_used_in_type_alias)]\n+#[diag(borrowck_const_not_used_in_type_alias)]\n pub(super) struct ConstNotUsedTraitAlias {\n     pub ct: String,\n     #[primary_span]"}, {"sha": "7201737be657bc100c9287f5df65e1025fdecbf5", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -34,12 +34,6 @@ impl FlagComputation {\n         result.flags\n     }\n \n-    pub fn for_unevaluated_const(uv: ty::UnevaluatedConst<'_>) -> TypeFlags {\n-        let mut result = FlagComputation::new();\n-        result.add_unevaluated_const(uv);\n-        result.flags\n-    }\n-\n     fn add_flags(&mut self, flags: TypeFlags) {\n         self.flags = self.flags | flags;\n     }\n@@ -256,7 +250,7 @@ impl FlagComputation {\n                 self.add_substs(substs);\n             }\n             ty::PredicateKind::ConstEvaluatable(uv) => {\n-                self.add_unevaluated_const(uv);\n+                self.add_const(uv);\n             }\n             ty::PredicateKind::ConstEquate(expected, found) => {\n                 self.add_const(expected);\n@@ -289,7 +283,10 @@ impl FlagComputation {\n     fn add_const(&mut self, c: ty::Const<'_>) {\n         self.add_ty(c.ty());\n         match c.kind() {\n-            ty::ConstKind::Unevaluated(unevaluated) => self.add_unevaluated_const(unevaluated),\n+            ty::ConstKind::Unevaluated(uv) => {\n+                self.add_substs(uv.substs);\n+                self.add_flags(TypeFlags::HAS_CT_PROJECTION);\n+            }\n             ty::ConstKind::Infer(infer) => {\n                 self.add_flags(TypeFlags::STILL_FURTHER_SPECIALIZABLE);\n                 match infer {\n@@ -313,11 +310,6 @@ impl FlagComputation {\n         }\n     }\n \n-    fn add_unevaluated_const(&mut self, ct: ty::UnevaluatedConst<'_>) {\n-        self.add_substs(ct.substs);\n-        self.add_flags(TypeFlags::HAS_CT_PROJECTION);\n-    }\n-\n     fn add_existential_projection(&mut self, projection: &ty::ExistentialProjection<'_>) {\n         self.add_substs(projection.substs);\n         match projection.term.unpack() {"}, {"sha": "54f1499eb3d1815f758ef3101e62280044c63c67", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -126,13 +126,6 @@ pub trait TypeFolder<'tcx>: FallibleTypeFolder<'tcx, Error = !> {\n         c.super_fold_with(self)\n     }\n \n-    fn fold_ty_unevaluated(\n-        &mut self,\n-        uv: ty::UnevaluatedConst<'tcx>,\n-    ) -> ty::UnevaluatedConst<'tcx> {\n-        uv.super_fold_with(self)\n-    }\n-\n     fn fold_predicate(&mut self, p: ty::Predicate<'tcx>) -> ty::Predicate<'tcx> {\n         p.super_fold_with(self)\n     }\n@@ -169,13 +162,6 @@ pub trait FallibleTypeFolder<'tcx>: Sized {\n         c.try_super_fold_with(self)\n     }\n \n-    fn try_fold_ty_unevaluated(\n-        &mut self,\n-        c: ty::UnevaluatedConst<'tcx>,\n-    ) -> Result<ty::UnevaluatedConst<'tcx>, Self::Error> {\n-        c.try_super_fold_with(self)\n-    }\n-\n     fn try_fold_predicate(\n         &mut self,\n         p: ty::Predicate<'tcx>,\n@@ -215,13 +201,6 @@ where\n         Ok(self.fold_const(c))\n     }\n \n-    fn try_fold_ty_unevaluated(\n-        &mut self,\n-        c: ty::UnevaluatedConst<'tcx>,\n-    ) -> Result<ty::UnevaluatedConst<'tcx>, !> {\n-        Ok(self.fold_ty_unevaluated(c))\n-    }\n-\n     fn try_fold_predicate(&mut self, p: ty::Predicate<'tcx>) -> Result<ty::Predicate<'tcx>, !> {\n         Ok(self.fold_predicate(p))\n     }"}, {"sha": "c4ad698ba763531896eb8d5e1a633c2c4afb0228", "filename": "compiler/rustc_middle/src/ty/inhabitedness/def_id_forest.rs", "status": "removed", "additions": 0, "deletions": 145, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/cfd99a2bbe83ae35ad0eb9d963ca97cf6c34471a/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfd99a2bbe83ae35ad0eb9d963ca97cf6c34471a/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fdef_id_forest.rs?ref=cfd99a2bbe83ae35ad0eb9d963ca97cf6c34471a", "patch": "@@ -1,145 +0,0 @@\n-use crate::ty::context::TyCtxt;\n-use crate::ty::{DefId, DefIdTree};\n-use rustc_span::def_id::CRATE_DEF_ID;\n-use smallvec::SmallVec;\n-use std::mem;\n-\n-use DefIdForest::*;\n-\n-/// Represents a forest of `DefId`s closed under the ancestor relation. That is,\n-/// if a `DefId` representing a module is contained in the forest then all\n-/// `DefId`s defined in that module or submodules are also implicitly contained\n-/// in the forest.\n-///\n-/// This is used to represent a set of modules in which a type is visibly\n-/// uninhabited.\n-///\n-/// We store the minimal set of `DefId`s required to represent the whole set. If A and B are\n-/// `DefId`s in the `DefIdForest`, and A is a parent of B, then only A will be stored. When this is\n-/// used with `type_uninhabited_from`, there will very rarely be more than one `DefId` stored.\n-#[derive(Copy, Clone, HashStable, Debug)]\n-pub enum DefIdForest<'a> {\n-    Empty,\n-    Single(DefId),\n-    /// This variant is very rare.\n-    /// Invariant: >1 elements\n-    Multiple(&'a [DefId]),\n-}\n-\n-/// Tests whether a slice of roots contains a given DefId.\n-#[inline]\n-fn slice_contains<'tcx>(tcx: TyCtxt<'tcx>, slice: &[DefId], id: DefId) -> bool {\n-    slice.iter().any(|root_id| tcx.is_descendant_of(id, *root_id))\n-}\n-\n-impl<'tcx> DefIdForest<'tcx> {\n-    /// Creates an empty forest.\n-    pub fn empty() -> DefIdForest<'tcx> {\n-        DefIdForest::Empty\n-    }\n-\n-    /// Creates a forest consisting of a single tree representing the entire\n-    /// crate.\n-    #[inline]\n-    pub fn full() -> DefIdForest<'tcx> {\n-        DefIdForest::from_id(CRATE_DEF_ID.to_def_id())\n-    }\n-\n-    /// Creates a forest containing a `DefId` and all its descendants.\n-    pub fn from_id(id: DefId) -> DefIdForest<'tcx> {\n-        DefIdForest::Single(id)\n-    }\n-\n-    fn as_slice(&self) -> &[DefId] {\n-        match self {\n-            Empty => &[],\n-            Single(id) => std::slice::from_ref(id),\n-            Multiple(root_ids) => root_ids,\n-        }\n-    }\n-\n-    // Only allocates in the rare `Multiple` case.\n-    fn from_vec(tcx: TyCtxt<'tcx>, root_ids: SmallVec<[DefId; 1]>) -> DefIdForest<'tcx> {\n-        match &root_ids[..] {\n-            [] => Empty,\n-            [id] => Single(*id),\n-            _ => DefIdForest::Multiple(tcx.arena.alloc_from_iter(root_ids)),\n-        }\n-    }\n-\n-    /// Tests whether the forest is empty.\n-    pub fn is_empty(&self) -> bool {\n-        match self {\n-            Empty => true,\n-            Single(..) | Multiple(..) => false,\n-        }\n-    }\n-\n-    /// Iterate over the set of roots.\n-    fn iter(&self) -> impl Iterator<Item = DefId> + '_ {\n-        self.as_slice().iter().copied()\n-    }\n-\n-    /// Tests whether the forest contains a given DefId.\n-    pub fn contains(&self, tcx: TyCtxt<'tcx>, id: DefId) -> bool {\n-        slice_contains(tcx, self.as_slice(), id)\n-    }\n-\n-    /// Calculate the intersection of a collection of forests.\n-    pub fn intersection<I>(tcx: TyCtxt<'tcx>, iter: I) -> DefIdForest<'tcx>\n-    where\n-        I: IntoIterator<Item = DefIdForest<'tcx>>,\n-    {\n-        let mut iter = iter.into_iter();\n-        let mut ret: SmallVec<[_; 1]> = if let Some(first) = iter.next() {\n-            SmallVec::from_slice(first.as_slice())\n-        } else {\n-            return DefIdForest::full();\n-        };\n-\n-        let mut next_ret: SmallVec<[_; 1]> = SmallVec::new();\n-        for next_forest in iter {\n-            // No need to continue if the intersection is already empty.\n-            if ret.is_empty() || next_forest.is_empty() {\n-                return DefIdForest::empty();\n-            }\n-\n-            // We keep the elements in `ret` that are also in `next_forest`.\n-            next_ret.extend(ret.iter().copied().filter(|&id| next_forest.contains(tcx, id)));\n-            // We keep the elements in `next_forest` that are also in `ret`.\n-            next_ret.extend(next_forest.iter().filter(|&id| slice_contains(tcx, &ret, id)));\n-\n-            mem::swap(&mut next_ret, &mut ret);\n-            next_ret.clear();\n-        }\n-        DefIdForest::from_vec(tcx, ret)\n-    }\n-\n-    /// Calculate the union of a collection of forests.\n-    pub fn union<I>(tcx: TyCtxt<'tcx>, iter: I) -> DefIdForest<'tcx>\n-    where\n-        I: IntoIterator<Item = DefIdForest<'tcx>>,\n-    {\n-        let mut ret: SmallVec<[_; 1]> = SmallVec::new();\n-        let mut next_ret: SmallVec<[_; 1]> = SmallVec::new();\n-        for next_forest in iter {\n-            // Union with the empty set is a no-op.\n-            if next_forest.is_empty() {\n-                continue;\n-            }\n-\n-            // We add everything in `ret` that is not in `next_forest`.\n-            next_ret.extend(ret.iter().copied().filter(|&id| !next_forest.contains(tcx, id)));\n-            // We add everything in `next_forest` that we haven't added yet.\n-            for id in next_forest.iter() {\n-                if !slice_contains(tcx, &next_ret, id) {\n-                    next_ret.push(id);\n-                }\n-            }\n-\n-            mem::swap(&mut next_ret, &mut ret);\n-            next_ret.clear();\n-        }\n-        DefIdForest::from_vec(tcx, ret)\n-    }\n-}"}, {"sha": "b7aa455727dae4b717ff750850f68559a0ad6666", "filename": "compiler/rustc_middle/src/ty/inhabitedness/inhabited_predicate.rs", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Finhabited_predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Finhabited_predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Finhabited_predicate.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -0,0 +1,204 @@\n+use crate::ty::context::TyCtxt;\n+use crate::ty::{self, DefId, DefIdTree, ParamEnv, Ty};\n+\n+/// Represents whether some type is inhabited in a given context.\n+/// Examples of uninhabited types are `!`, `enum Void {}`, or a struct\n+/// containing either of those types.\n+/// A type's inhabitedness may depend on the `ParamEnv` as well as what types\n+/// are visible in the current module.\n+#[derive(Clone, Copy, Debug, PartialEq, HashStable)]\n+pub enum InhabitedPredicate<'tcx> {\n+    /// Inhabited\n+    True,\n+    /// Uninhabited\n+    False,\n+    /// Uninhabited when a const value is non-zero. This occurs when there is an\n+    /// array of uninhabited items, but the array is inhabited if it is empty.\n+    ConstIsZero(ty::Const<'tcx>),\n+    /// Uninhabited if within a certain module. This occurs when an uninhabited\n+    /// type has restricted visibility.\n+    NotInModule(DefId),\n+    /// Inhabited if some generic type is inhabited.\n+    /// These are replaced by calling [`Self::subst`].\n+    GenericType(Ty<'tcx>),\n+    /// A AND B\n+    And(&'tcx [InhabitedPredicate<'tcx>; 2]),\n+    /// A OR B\n+    Or(&'tcx [InhabitedPredicate<'tcx>; 2]),\n+}\n+\n+impl<'tcx> InhabitedPredicate<'tcx> {\n+    /// Returns true if the corresponding type is inhabited in the given\n+    /// `ParamEnv` and module\n+    pub fn apply(self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>, module_def_id: DefId) -> bool {\n+        let Ok(result) = self\n+            .apply_inner::<!>(tcx, param_env, &|id| Ok(tcx.is_descendant_of(module_def_id, id)));\n+        result\n+    }\n+\n+    /// Same as `apply`, but returns `None` if self contains a module predicate\n+    pub fn apply_any_module(self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>) -> Option<bool> {\n+        self.apply_inner(tcx, param_env, &|_| Err(())).ok()\n+    }\n+\n+    fn apply_inner<E>(\n+        self,\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ParamEnv<'tcx>,\n+        in_module: &impl Fn(DefId) -> Result<bool, E>,\n+    ) -> Result<bool, E> {\n+        match self {\n+            Self::False => Ok(false),\n+            Self::True => Ok(true),\n+            Self::ConstIsZero(const_) => match const_.try_eval_usize(tcx, param_env) {\n+                None | Some(0) => Ok(true),\n+                Some(1..) => Ok(false),\n+            },\n+            Self::NotInModule(id) => in_module(id).map(|in_mod| !in_mod),\n+            Self::GenericType(_) => Ok(true),\n+            Self::And([a, b]) => try_and(a, b, |x| x.apply_inner(tcx, param_env, in_module)),\n+            Self::Or([a, b]) => try_or(a, b, |x| x.apply_inner(tcx, param_env, in_module)),\n+        }\n+    }\n+\n+    pub fn and(self, tcx: TyCtxt<'tcx>, other: Self) -> Self {\n+        self.reduce_and(tcx, other).unwrap_or_else(|| Self::And(tcx.arena.alloc([self, other])))\n+    }\n+\n+    pub fn or(self, tcx: TyCtxt<'tcx>, other: Self) -> Self {\n+        self.reduce_or(tcx, other).unwrap_or_else(|| Self::Or(tcx.arena.alloc([self, other])))\n+    }\n+\n+    pub fn all(tcx: TyCtxt<'tcx>, iter: impl IntoIterator<Item = Self>) -> Self {\n+        let mut result = Self::True;\n+        for pred in iter {\n+            if matches!(pred, Self::False) {\n+                return Self::False;\n+            }\n+            result = result.and(tcx, pred);\n+        }\n+        result\n+    }\n+\n+    pub fn any(tcx: TyCtxt<'tcx>, iter: impl IntoIterator<Item = Self>) -> Self {\n+        let mut result = Self::False;\n+        for pred in iter {\n+            if matches!(pred, Self::True) {\n+                return Self::True;\n+            }\n+            result = result.or(tcx, pred);\n+        }\n+        result\n+    }\n+\n+    fn reduce_and(self, tcx: TyCtxt<'tcx>, other: Self) -> Option<Self> {\n+        match (self, other) {\n+            (Self::True, a) | (a, Self::True) => Some(a),\n+            (Self::False, _) | (_, Self::False) => Some(Self::False),\n+            (Self::ConstIsZero(a), Self::ConstIsZero(b)) if a == b => Some(Self::ConstIsZero(a)),\n+            (Self::NotInModule(a), Self::NotInModule(b)) if a == b => Some(Self::NotInModule(a)),\n+            (Self::NotInModule(a), Self::NotInModule(b)) if tcx.is_descendant_of(a, b) => {\n+                Some(Self::NotInModule(b))\n+            }\n+            (Self::NotInModule(a), Self::NotInModule(b)) if tcx.is_descendant_of(b, a) => {\n+                Some(Self::NotInModule(a))\n+            }\n+            (Self::GenericType(a), Self::GenericType(b)) if a == b => Some(Self::GenericType(a)),\n+            (Self::And(&[a, b]), c) | (c, Self::And(&[a, b])) => {\n+                if let Some(ac) = a.reduce_and(tcx, c) {\n+                    Some(ac.and(tcx, b))\n+                } else if let Some(bc) = b.reduce_and(tcx, c) {\n+                    Some(Self::And(tcx.arena.alloc([a, bc])))\n+                } else {\n+                    None\n+                }\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    fn reduce_or(self, tcx: TyCtxt<'tcx>, other: Self) -> Option<Self> {\n+        match (self, other) {\n+            (Self::True, _) | (_, Self::True) => Some(Self::True),\n+            (Self::False, a) | (a, Self::False) => Some(a),\n+            (Self::ConstIsZero(a), Self::ConstIsZero(b)) if a == b => Some(Self::ConstIsZero(a)),\n+            (Self::NotInModule(a), Self::NotInModule(b)) if a == b => Some(Self::NotInModule(a)),\n+            (Self::NotInModule(a), Self::NotInModule(b)) if tcx.is_descendant_of(a, b) => {\n+                Some(Self::NotInModule(a))\n+            }\n+            (Self::NotInModule(a), Self::NotInModule(b)) if tcx.is_descendant_of(b, a) => {\n+                Some(Self::NotInModule(b))\n+            }\n+            (Self::GenericType(a), Self::GenericType(b)) if a == b => Some(Self::GenericType(a)),\n+            (Self::Or(&[a, b]), c) | (c, Self::Or(&[a, b])) => {\n+                if let Some(ac) = a.reduce_or(tcx, c) {\n+                    Some(ac.or(tcx, b))\n+                } else if let Some(bc) = b.reduce_or(tcx, c) {\n+                    Some(Self::Or(tcx.arena.alloc([a, bc])))\n+                } else {\n+                    None\n+                }\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    /// Replaces generic types with its corresponding predicate\n+    pub fn subst(self, tcx: TyCtxt<'tcx>, substs: ty::SubstsRef<'tcx>) -> Self {\n+        self.subst_opt(tcx, substs).unwrap_or(self)\n+    }\n+\n+    fn subst_opt(self, tcx: TyCtxt<'tcx>, substs: ty::SubstsRef<'tcx>) -> Option<Self> {\n+        match self {\n+            Self::ConstIsZero(c) => {\n+                let c = ty::EarlyBinder(c).subst(tcx, substs);\n+                let pred = match c.kind().try_to_machine_usize(tcx) {\n+                    Some(0) => Self::True,\n+                    Some(1..) => Self::False,\n+                    None => Self::ConstIsZero(c),\n+                };\n+                Some(pred)\n+            }\n+            Self::GenericType(t) => {\n+                Some(ty::EarlyBinder(t).subst(tcx, substs).inhabited_predicate(tcx))\n+            }\n+            Self::And(&[a, b]) => match a.subst_opt(tcx, substs) {\n+                None => b.subst_opt(tcx, substs).map(|b| a.and(tcx, b)),\n+                Some(InhabitedPredicate::False) => Some(InhabitedPredicate::False),\n+                Some(a) => Some(a.and(tcx, b.subst_opt(tcx, substs).unwrap_or(b))),\n+            },\n+            Self::Or(&[a, b]) => match a.subst_opt(tcx, substs) {\n+                None => b.subst_opt(tcx, substs).map(|b| a.or(tcx, b)),\n+                Some(InhabitedPredicate::True) => Some(InhabitedPredicate::True),\n+                Some(a) => Some(a.or(tcx, b.subst_opt(tcx, substs).unwrap_or(b))),\n+            },\n+            _ => None,\n+        }\n+    }\n+}\n+\n+// this is basically like `f(a)? && f(b)?` but different in the case of\n+// `Ok(false) && Err(_) -> Ok(false)`\n+fn try_and<T, E>(a: T, b: T, f: impl Fn(T) -> Result<bool, E>) -> Result<bool, E> {\n+    let a = f(a);\n+    if matches!(a, Ok(false)) {\n+        return Ok(false);\n+    }\n+    match (a, f(b)) {\n+        (_, Ok(false)) | (Ok(false), _) => Ok(false),\n+        (Ok(true), Ok(true)) => Ok(true),\n+        (Err(e), _) | (_, Err(e)) => Err(e),\n+    }\n+}\n+\n+fn try_or<T, E>(a: T, b: T, f: impl Fn(T) -> Result<bool, E>) -> Result<bool, E> {\n+    let a = f(a);\n+    if matches!(a, Ok(true)) {\n+        return Ok(true);\n+    }\n+    match (a, f(b)) {\n+        (_, Ok(true)) | (Ok(true), _) => Ok(true),\n+        (Ok(false), Ok(false)) => Ok(false),\n+        (Err(e), _) | (_, Err(e)) => Err(e),\n+    }\n+}"}, {"sha": "279a728ea392257d6ed8afb639122c211079dafe", "filename": "compiler/rustc_middle/src/ty/inhabitedness/mod.rs", "status": "modified", "additions": 111, "deletions": 147, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -1,57 +1,60 @@\n-pub use self::def_id_forest::DefIdForest;\n+//! This module contains logic for determining whether a type is inhabited or\n+//! uninhabited. The [`InhabitedPredicate`] type captures the minimum\n+//! information needed to determine whether a type is inhabited given a\n+//! `ParamEnv` and module ID.\n+//!\n+//! # Example\n+//! ```rust\n+//! enum Void {}\n+//! mod a {\n+//!     pub mod b {\n+//!         pub struct SecretlyUninhabited {\n+//!             _priv: !,\n+//!         }\n+//!     }\n+//! }\n+//!\n+//! mod c {\n+//!     pub struct AlsoSecretlyUninhabited {\n+//!         _priv: Void,\n+//!     }\n+//!     mod d {\n+//!     }\n+//! }\n+//!\n+//! struct Foo {\n+//!     x: a::b::SecretlyUninhabited,\n+//!     y: c::AlsoSecretlyUninhabited,\n+//! }\n+//! ```\n+//! In this code, the type `Foo` will only be visibly uninhabited inside the\n+//! modules `b`, `c` and `d`. Calling `uninhabited_predicate` on `Foo` will\n+//! return `NotInModule(b) AND NotInModule(c)`.\n+//!\n+//! We need this information for pattern-matching on `Foo` or types that contain\n+//! `Foo`.\n+//!\n+//! # Example\n+//! ```rust\n+//! let foo_result: Result<T, Foo> = ... ;\n+//! let Ok(t) = foo_result;\n+//! ```\n+//! This code should only compile in modules where the uninhabitedness of `Foo`\n+//! is visible.\n \n-use crate::ty;\n use crate::ty::context::TyCtxt;\n-use crate::ty::{AdtDef, FieldDef, Ty, VariantDef};\n-use crate::ty::{AdtKind, Visibility};\n-use crate::ty::{DefId, SubstsRef};\n+use crate::ty::{self, DefId, Ty, VariantDef, Visibility};\n \n use rustc_type_ir::sty::TyKind::*;\n \n-mod def_id_forest;\n+pub mod inhabited_predicate;\n \n-// The methods in this module calculate `DefIdForest`s of modules in which an\n-// `AdtDef`/`VariantDef`/`FieldDef` is visibly uninhabited.\n-//\n-// # Example\n-// ```rust\n-// enum Void {}\n-// mod a {\n-//     pub mod b {\n-//         pub struct SecretlyUninhabited {\n-//             _priv: !,\n-//         }\n-//     }\n-// }\n-//\n-// mod c {\n-//     pub struct AlsoSecretlyUninhabited {\n-//         _priv: Void,\n-//     }\n-//     mod d {\n-//     }\n-// }\n-//\n-// struct Foo {\n-//     x: a::b::SecretlyUninhabited,\n-//     y: c::AlsoSecretlyUninhabited,\n-// }\n-// ```\n-// In this code, the type `Foo` will only be visibly uninhabited inside the\n-// modules `b`, `c` and `d`. Calling `uninhabited_from` on `Foo` or its `AdtDef` will\n-// return the forest of modules {`b`, `c`->`d`} (represented in a `DefIdForest` by the\n-// set {`b`, `c`}).\n-//\n-// We need this information for pattern-matching on `Foo` or types that contain\n-// `Foo`.\n-//\n-// # Example\n-// ```rust\n-// let foo_result: Result<T, Foo> = ... ;\n-// let Ok(t) = foo_result;\n-// ```\n-// This code should only compile in modules where the uninhabitedness of `Foo` is\n-// visible.\n+pub use inhabited_predicate::InhabitedPredicate;\n+\n+pub(crate) fn provide(providers: &mut ty::query::Providers) {\n+    *providers =\n+        ty::query::Providers { inhabited_predicate_adt, inhabited_predicate_type, ..*providers };\n+}\n \n impl<'tcx> TyCtxt<'tcx> {\n     /// Checks whether a type is visibly uninhabited from a particular module.\n@@ -100,131 +103,92 @@ impl<'tcx> TyCtxt<'tcx> {\n         ty: Ty<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> bool {\n-        // To check whether this type is uninhabited at all (not just from the\n-        // given node), you could check whether the forest is empty.\n-        // ```\n-        // forest.is_empty()\n-        // ```\n-        ty.uninhabited_from(self, param_env).contains(self, module)\n+        !ty.inhabited_predicate(self).apply(self, param_env, module)\n     }\n }\n \n-impl<'tcx> AdtDef<'tcx> {\n-    /// Calculates the forest of `DefId`s from which this ADT is visibly uninhabited.\n-    fn uninhabited_from(\n-        self,\n-        tcx: TyCtxt<'tcx>,\n-        substs: SubstsRef<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-    ) -> DefIdForest<'tcx> {\n-        // Non-exhaustive ADTs from other crates are always considered inhabited.\n-        if self.is_variant_list_non_exhaustive() && !self.did().is_local() {\n-            DefIdForest::empty()\n-        } else {\n-            DefIdForest::intersection(\n-                tcx,\n-                self.variants()\n-                    .iter()\n-                    .map(|v| v.uninhabited_from(tcx, substs, self.adt_kind(), param_env)),\n-            )\n+/// Returns an `InhabitedPredicate` that is generic over type parameters and\n+/// requires calling [`InhabitedPredicate::subst`]\n+fn inhabited_predicate_adt(tcx: TyCtxt<'_>, def_id: DefId) -> InhabitedPredicate<'_> {\n+    if let Some(def_id) = def_id.as_local() {\n+        if matches!(tcx.representability(def_id), ty::Representability::Infinite) {\n+            return InhabitedPredicate::True;\n         }\n     }\n+    let adt = tcx.adt_def(def_id);\n+    InhabitedPredicate::any(\n+        tcx,\n+        adt.variants().iter().map(|variant| variant.inhabited_predicate(tcx, adt)),\n+    )\n }\n \n impl<'tcx> VariantDef {\n     /// Calculates the forest of `DefId`s from which this variant is visibly uninhabited.\n-    pub fn uninhabited_from(\n+    pub fn inhabited_predicate(\n         &self,\n         tcx: TyCtxt<'tcx>,\n-        substs: SubstsRef<'tcx>,\n-        adt_kind: AdtKind,\n-        param_env: ty::ParamEnv<'tcx>,\n-    ) -> DefIdForest<'tcx> {\n-        let is_enum = match adt_kind {\n-            // For now, `union`s are never considered uninhabited.\n-            // The precise semantics of inhabitedness with respect to unions is currently undecided.\n-            AdtKind::Union => return DefIdForest::empty(),\n-            AdtKind::Enum => true,\n-            AdtKind::Struct => false,\n-        };\n-        // Non-exhaustive variants from other crates are always considered inhabited.\n+        adt: ty::AdtDef<'_>,\n+    ) -> InhabitedPredicate<'tcx> {\n+        debug_assert!(!adt.is_union());\n         if self.is_field_list_non_exhaustive() && !self.def_id.is_local() {\n-            DefIdForest::empty()\n-        } else {\n-            DefIdForest::union(\n-                tcx,\n-                self.fields.iter().map(|f| f.uninhabited_from(tcx, substs, is_enum, param_env)),\n-            )\n+            // Non-exhaustive variants from other crates are always considered inhabited.\n+            return InhabitedPredicate::True;\n         }\n-    }\n-}\n-\n-impl<'tcx> FieldDef {\n-    /// Calculates the forest of `DefId`s from which this field is visibly uninhabited.\n-    fn uninhabited_from(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        substs: SubstsRef<'tcx>,\n-        is_enum: bool,\n-        param_env: ty::ParamEnv<'tcx>,\n-    ) -> DefIdForest<'tcx> {\n-        let data_uninhabitedness = move || self.ty(tcx, substs).uninhabited_from(tcx, param_env);\n-        if is_enum {\n-            data_uninhabitedness()\n-        } else {\n-            match self.vis {\n-                Visibility::Restricted(from) => {\n-                    let forest = DefIdForest::from_id(from);\n-                    let iter = Some(forest).into_iter().chain(Some(data_uninhabitedness()));\n-                    DefIdForest::intersection(tcx, iter)\n+        InhabitedPredicate::all(\n+            tcx,\n+            self.fields.iter().map(|field| {\n+                let pred = tcx.type_of(field.did).inhabited_predicate(tcx);\n+                if adt.is_enum() {\n+                    return pred;\n                 }\n-                Visibility::Public => data_uninhabitedness(),\n-            }\n-        }\n+                match field.vis {\n+                    Visibility::Public => pred,\n+                    Visibility::Restricted(from) => {\n+                        pred.or(tcx, InhabitedPredicate::NotInModule(from))\n+                    }\n+                }\n+            }),\n+        )\n     }\n }\n \n impl<'tcx> Ty<'tcx> {\n-    /// Calculates the forest of `DefId`s from which this type is visibly uninhabited.\n-    fn uninhabited_from(\n-        self,\n-        tcx: TyCtxt<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-    ) -> DefIdForest<'tcx> {\n-        tcx.type_uninhabited_from(param_env.and(self))\n+    pub fn inhabited_predicate(self, tcx: TyCtxt<'tcx>) -> InhabitedPredicate<'tcx> {\n+        match self.kind() {\n+            // For now, union`s are always considered inhabited\n+            Adt(adt, _) if adt.is_union() => InhabitedPredicate::True,\n+            // Non-exhaustive ADTs from other crates are always considered inhabited\n+            Adt(adt, _) if adt.is_variant_list_non_exhaustive() && !adt.did().is_local() => {\n+                InhabitedPredicate::True\n+            }\n+            Never => InhabitedPredicate::False,\n+            Param(_) | Projection(_) => InhabitedPredicate::GenericType(self),\n+            Tuple(tys) if tys.is_empty() => InhabitedPredicate::True,\n+            // use a query for more complex cases\n+            Adt(..) | Array(..) | Tuple(_) => tcx.inhabited_predicate_type(self),\n+            // references and other types are inhabited\n+            _ => InhabitedPredicate::True,\n+        }\n     }\n }\n \n-// Query provider for `type_uninhabited_from`.\n-pub(crate) fn type_uninhabited_from<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n-) -> DefIdForest<'tcx> {\n-    let ty = key.value;\n-    let param_env = key.param_env;\n+/// N.B. this query should only be called through `Ty::inhabited_predicate`\n+fn inhabited_predicate_type<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> InhabitedPredicate<'tcx> {\n     match *ty.kind() {\n-        Adt(def, substs) => def.uninhabited_from(tcx, substs, param_env),\n+        Adt(adt, substs) => tcx.inhabited_predicate_adt(adt.did()).subst(tcx, substs),\n \n-        Never => DefIdForest::full(),\n-\n-        Tuple(ref tys) => {\n-            DefIdForest::union(tcx, tys.iter().map(|ty| ty.uninhabited_from(tcx, param_env)))\n+        Tuple(tys) => {\n+            InhabitedPredicate::all(tcx, tys.iter().map(|ty| ty.inhabited_predicate(tcx)))\n         }\n \n-        Array(ty, len) => match len.try_eval_usize(tcx, param_env) {\n-            Some(0) | None => DefIdForest::empty(),\n-            // If the array is definitely non-empty, it's uninhabited if\n-            // the type of its elements is uninhabited.\n-            Some(1..) => ty.uninhabited_from(tcx, param_env),\n+        // If we can evaluate the array length before having a `ParamEnv`, then\n+        // we can simplify the predicate. This is an optimization.\n+        Array(ty, len) => match len.kind().try_to_machine_usize(tcx) {\n+            Some(0) => InhabitedPredicate::True,\n+            Some(1..) => ty.inhabited_predicate(tcx),\n+            None => ty.inhabited_predicate(tcx).or(tcx, InhabitedPredicate::ConstIsZero(len)),\n         },\n \n-        // References to uninitialised memory are valid for any type, including\n-        // uninhabited types, in unsafe code, so we treat all references as\n-        // inhabited.\n-        // The precise semantics of inhabitedness with respect to references is currently\n-        // undecided.\n-        Ref(..) => DefIdForest::empty(),\n-\n-        _ => DefIdForest::empty(),\n+        _ => bug!(\"unexpected TyKind, use `Ty::inhabited_predicate`\"),\n     }\n }"}, {"sha": "0a109fd8f44f85125baa0bcc9f65af9e1f981428", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -196,16 +196,16 @@ impl<'a> IntoDiagnostic<'a, !> for LayoutError<'a> {\n         match self {\n             LayoutError::Unknown(ty) => {\n                 diag.set_arg(\"ty\", ty);\n-                diag.set_primary_message(rustc_errors::fluent::middle::unknown_layout);\n+                diag.set_primary_message(rustc_errors::fluent::middle_unknown_layout);\n             }\n             LayoutError::SizeOverflow(ty) => {\n                 diag.set_arg(\"ty\", ty);\n-                diag.set_primary_message(rustc_errors::fluent::middle::values_too_big);\n+                diag.set_primary_message(rustc_errors::fluent::middle_values_too_big);\n             }\n             LayoutError::NormalizationFailure(ty, e) => {\n                 diag.set_arg(\"ty\", ty);\n                 diag.set_arg(\"failure_ty\", e.get_type_for_failure());\n-                diag.set_primary_message(rustc_errors::fluent::middle::cannot_be_normalized);\n+                diag.set_primary_message(rustc_errors::fluent::middle_cannot_be_normalized);\n             }\n         }\n         diag"}, {"sha": "c2aef8178e2c7fe190f18540b051175235c8413b", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -78,7 +78,7 @@ pub use self::consts::{\n };\n pub use self::context::{\n     tls, CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations,\n-    CtxtInterners, DelaySpanBugEmitted, FreeRegionInfo, GeneratorDiagnosticData,\n+    CtxtInterners, DeducedParamAttrs, DelaySpanBugEmitted, FreeRegionInfo, GeneratorDiagnosticData,\n     GeneratorInteriorTypeCause, GlobalCtxt, Lift, OnDiskCache, TyCtxt, TypeckResults, UserType,\n     UserTypeAnnotationIndex,\n };\n@@ -683,7 +683,7 @@ pub enum PredicateKind<'tcx> {\n     Coerce(CoercePredicate<'tcx>),\n \n     /// Constant initializer must evaluate successfully.\n-    ConstEvaluatable(ty::UnevaluatedConst<'tcx>),\n+    ConstEvaluatable(ty::Const<'tcx>),\n \n     /// Constants must be equal. The first component is the const that is expected.\n     ConstEquate(Const<'tcx>, Const<'tcx>),\n@@ -2694,14 +2694,14 @@ pub fn provide(providers: &mut ty::query::Providers) {\n     closure::provide(providers);\n     context::provide(providers);\n     erase_regions::provide(providers);\n+    inhabitedness::provide(providers);\n     util::provide(providers);\n     print::provide(providers);\n     super::util::bug::provide(providers);\n     super::middle::provide(providers);\n     *providers = ty::query::Providers {\n         trait_impls_of: trait_def::trait_impls_of_provider,\n         incoherent_impls: trait_def::incoherent_impls_provider,\n-        type_uninhabited_from: inhabitedness::type_uninhabited_from,\n         const_param_default: consts::const_param_default,\n         vtable_allocation: vtable::vtable_allocation_provider,\n         ..*providers"}, {"sha": "e1e705a922f9e2243c50eebf817feed13f1296b0", "filename": "compiler/rustc_middle/src/ty/parameterized.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -61,6 +61,7 @@ trivially_parameterized_over_tcx! {\n     crate::middle::resolve_lifetime::ObjectLifetimeDefault,\n     crate::mir::ConstQualifs,\n     ty::AssocItemContainer,\n+    ty::DeducedParamAttrs,\n     ty::Generics,\n     ty::ImplPolarity,\n     ty::ReprOptions,"}, {"sha": "b8ee2b994b1e472ab6d330215587c869c0780fa7", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -16,6 +16,7 @@ use rustc_session::cstore::{ExternCrate, ExternCrateSource};\n use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_target::abi::Size;\n use rustc_target::spec::abi::Abi;\n+use smallvec::SmallVec;\n \n use std::cell::Cell;\n use std::char;\n@@ -794,9 +795,9 @@ pub trait PrettyPrinter<'tcx>:\n         let mut traits = FxIndexMap::default();\n         let mut fn_traits = FxIndexMap::default();\n         let mut is_sized = false;\n+        let mut lifetimes = SmallVec::<[ty::Region<'tcx>; 1]>::new();\n \n-        for predicate in bounds.transpose_iter().map(|e| e.map_bound(|(p, _)| *p)) {\n-            let predicate = predicate.subst(tcx, substs);\n+        for (predicate, _) in bounds.subst_iter_copied(tcx, substs) {\n             let bound_predicate = predicate.kind();\n \n             match bound_predicate.skip_binder() {\n@@ -825,6 +826,9 @@ pub trait PrettyPrinter<'tcx>:\n                         &mut fn_traits,\n                     );\n                 }\n+                ty::PredicateKind::TypeOutlives(outlives) => {\n+                    lifetimes.push(outlives.1);\n+                }\n                 _ => {}\n             }\n         }\n@@ -978,6 +982,11 @@ pub trait PrettyPrinter<'tcx>:\n             write!(self, \"Sized\")?;\n         }\n \n+        for re in lifetimes {\n+            write!(self, \" + \")?;\n+            self = self.print_region(re)?;\n+        }\n+\n         Ok(self)\n     }\n \n@@ -2702,8 +2711,8 @@ define_print_and_forward_display! {\n                 print_value_path(closure_def_id, &[]),\n                 write(\"` implements the trait `{}`\", kind))\n             }\n-            ty::PredicateKind::ConstEvaluatable(uv) => {\n-                p!(\"the constant `\", print_value_path(uv.def.did, uv.substs), \"` can be evaluated\")\n+            ty::PredicateKind::ConstEvaluatable(ct) => {\n+                p!(\"the constant `\", print(ct), \"` can be evaluated\")\n             }\n             ty::PredicateKind::ConstEquate(c1, c2) => {\n                 p!(\"the constant `\", print(c1), \"` equals `\", print(c2), \"`\")"}, {"sha": "9c97ce34f29e4011a5a63b7c6b125309897c6190", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -52,7 +52,6 @@ use rustc_session::config::{EntryFnType, OptLevel, OutputFilenames, SymbolMangli\n use rustc_session::cstore::{CrateDepKind, CrateSource};\n use rustc_session::cstore::{ExternCrate, ForeignModule, LinkagePreference, NativeLib};\n use rustc_session::lint::LintExpectationId;\n-use rustc_session::utils::NativeLibKind;\n use rustc_session::Limits;\n use rustc_span::symbol::Symbol;\n use rustc_span::{Span, DUMMY_SP};"}, {"sha": "2cad333e3f52a515bc7edbf62a1cf5a74cea773a", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 23, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -166,8 +166,8 @@ impl<'tcx> fmt::Debug for ty::PredicateKind<'tcx> {\n             ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind) => {\n                 write!(f, \"ClosureKind({:?}, {:?}, {:?})\", closure_def_id, closure_substs, kind)\n             }\n-            ty::PredicateKind::ConstEvaluatable(uv) => {\n-                write!(f, \"ConstEvaluatable({:?}, {:?})\", uv.def, uv.substs)\n+            ty::PredicateKind::ConstEvaluatable(ct) => {\n+                write!(f, \"ConstEvaluatable({ct:?})\")\n             }\n             ty::PredicateKind::ConstEquate(c1, c2) => write!(f, \"ConstEquate({:?}, {:?})\", c1, c2),\n             ty::PredicateKind::TypeWellFormedFromEnv(ty) => {\n@@ -832,27 +832,6 @@ impl<'tcx> TypeVisitable<'tcx> for InferConst<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::UnevaluatedConst<'tcx> {\n-    fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n-        folder.try_fold_ty_unevaluated(self)\n-    }\n-}\n-\n-impl<'tcx> TypeVisitable<'tcx> for ty::UnevaluatedConst<'tcx> {\n-    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n-        visitor.visit_ty_unevaluated(*self)\n-    }\n-}\n-\n-impl<'tcx> TypeSuperFoldable<'tcx> for ty::UnevaluatedConst<'tcx> {\n-    fn try_super_fold_with<F: FallibleTypeFolder<'tcx>>(\n-        self,\n-        folder: &mut F,\n-    ) -> Result<Self, F::Error> {\n-        Ok(ty::UnevaluatedConst { def: self.def, substs: self.substs.try_fold_with(folder)? })\n-    }\n-}\n-\n impl<'tcx> TypeSuperVisitable<'tcx> for ty::UnevaluatedConst<'tcx> {\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n         self.substs.visit_with(visitor)"}, {"sha": "0660e9b79a700988fe4b20731f8a56af53011c32", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -6,6 +6,7 @@ use crate::ty::sty::{ClosureSubsts, GeneratorSubsts, InlineConstSubsts};\n use crate::ty::visit::{TypeVisitable, TypeVisitor};\n use crate::ty::{self, Lift, List, ParamConst, Ty, TyCtxt};\n \n+use rustc_data_structures::captures::Captures;\n use rustc_data_structures::intern::{Interned, WithStableHash};\n use rustc_hir::def_id::DefId;\n use rustc_macros::HashStable;\n@@ -188,6 +189,14 @@ impl<'tcx> GenericArg<'tcx> {\n             _ => bug!(\"expected a const, but found another kind\"),\n         }\n     }\n+\n+    pub fn is_non_region_infer(self) -> bool {\n+        match self.unpack() {\n+            GenericArgKind::Lifetime(_) => false,\n+            GenericArgKind::Type(ty) => ty.is_ty_infer(),\n+            GenericArgKind::Const(ct) => ct.is_ct_infer(),\n+        }\n+    }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for GenericArg<'a> {\n@@ -550,6 +559,28 @@ impl<T, U> EarlyBinder<(T, U)> {\n     }\n }\n \n+impl<'tcx, 's, T: IntoIterator<Item = I>, I: TypeFoldable<'tcx>> EarlyBinder<T> {\n+    pub fn subst_iter(\n+        self,\n+        tcx: TyCtxt<'tcx>,\n+        substs: &'s [GenericArg<'tcx>],\n+    ) -> impl Iterator<Item = I> + Captures<'s> + Captures<'tcx> {\n+        self.0.into_iter().map(move |t| EarlyBinder(t).subst(tcx, substs))\n+    }\n+}\n+\n+impl<'tcx, 's, 'a, T: IntoIterator<Item = &'a I>, I: Copy + TypeFoldable<'tcx> + 'a>\n+    EarlyBinder<T>\n+{\n+    pub fn subst_iter_copied(\n+        self,\n+        tcx: TyCtxt<'tcx>,\n+        substs: &'s [GenericArg<'tcx>],\n+    ) -> impl Iterator<Item = I> + Captures<'s> + Captures<'tcx> + Captures<'a> {\n+        self.0.into_iter().map(move |t| EarlyBinder(*t).subst(tcx, substs))\n+    }\n+}\n+\n pub struct EarlyBinderIter<T> {\n     t: T,\n }"}, {"sha": "c09f71f9a6d0926e204b30b5511ba6c2ceeca6df", "filename": "compiler/rustc_middle/src/ty/visit.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -197,13 +197,6 @@ pub trait TypeVisitor<'tcx>: Sized {\n         c.super_visit_with(self)\n     }\n \n-    fn visit_ty_unevaluated(\n-        &mut self,\n-        uv: ty::UnevaluatedConst<'tcx>,\n-    ) -> ControlFlow<Self::BreakTy> {\n-        uv.super_visit_with(self)\n-    }\n-\n     fn visit_predicate(&mut self, p: ty::Predicate<'tcx>) -> ControlFlow<Self::BreakTy> {\n         p.super_visit_with(self)\n     }\n@@ -592,21 +585,6 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n         }\n     }\n \n-    #[inline]\n-    #[instrument(level = \"trace\", ret)]\n-    fn visit_ty_unevaluated(\n-        &mut self,\n-        uv: ty::UnevaluatedConst<'tcx>,\n-    ) -> ControlFlow<Self::BreakTy> {\n-        let flags = FlagComputation::for_unevaluated_const(uv);\n-        trace!(r.flags=?flags);\n-        if flags.intersects(self.flags) {\n-            ControlFlow::Break(FoundFlags)\n-        } else {\n-            ControlFlow::CONTINUE\n-        }\n-    }\n-\n     #[inline]\n     #[instrument(level = \"trace\", ret)]\n     fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> ControlFlow<Self::BreakTy> {"}, {"sha": "91db9698c41b2ee30a4735d74f3215ca84f9c302", "filename": "compiler/rustc_middle/src/ty/walk.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -112,6 +112,22 @@ impl<'tcx> Ty<'tcx> {\n     }\n }\n \n+impl<'tcx> ty::Const<'tcx> {\n+    /// Iterator that walks `self` and any types reachable from\n+    /// `self`, in depth-first order. Note that just walks the types\n+    /// that appear in `self`, it does not descend into the fields of\n+    /// structs or variants. For example:\n+    ///\n+    /// ```text\n+    /// isize => { isize }\n+    /// Foo<Bar<isize>> => { Foo<Bar<isize>>, Bar<isize>, isize }\n+    /// [isize] => { [isize], isize }\n+    /// ```\n+    pub fn walk(self) -> TypeWalker<'tcx> {\n+        TypeWalker::new(self.into())\n+    }\n+}\n+\n /// We push `GenericArg`s on the stack in reverse order so as to\n /// maintain a pre-order traversal. As of the time of this\n /// writing, the fact that the traversal is pre-order is not"}, {"sha": "924d2f555b9ef4b1e99966a63975eb1628432582", "filename": "compiler/rustc_mir_build/src/build/matches/simplify.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -264,14 +264,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let irrefutable = adt_def.variants().iter_enumerated().all(|(i, v)| {\n                     i == variant_index || {\n                         self.tcx.features().exhaustive_patterns\n-                            && !v\n-                                .uninhabited_from(\n-                                    self.tcx,\n-                                    substs,\n-                                    adt_def.adt_kind(),\n-                                    self.param_env,\n-                                )\n-                                .is_empty()\n+                            && v.inhabited_predicate(self.tcx, adt_def)\n+                                .subst(self.tcx, substs)\n+                                .apply_any_module(self.tcx, self.param_env)\n+                                != Some(true)\n                     }\n                 }) && (adt_def.did().is_local()\n                     || !adt_def.is_variant_list_non_exhaustive());"}, {"sha": "595abc8f66870d5e6d7be56c88df9dfc0dc2f828", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -988,10 +988,12 @@ impl<'tcx> SplitWildcard<'tcx> {\n                     .filter(|(_, v)| {\n                         // If `exhaustive_patterns` is enabled, we exclude variants known to be\n                         // uninhabited.\n-                        let is_uninhabited = is_exhaustive_pat_feature\n-                            && v.uninhabited_from(cx.tcx, substs, def.adt_kind(), cx.param_env)\n-                                .contains(cx.tcx, cx.module);\n-                        !is_uninhabited\n+                        !is_exhaustive_pat_feature\n+                            || v.inhabited_predicate(cx.tcx, *def).subst(cx.tcx, substs).apply(\n+                                cx.tcx,\n+                                cx.param_env,\n+                                cx.module,\n+                            )\n                     })\n                     .map(|(idx, _)| Variant(idx))\n                     .collect();"}, {"sha": "cfacc0ec370c114f293f6f8969525b57906cb10b", "filename": "compiler/rustc_mir_dataflow/src/errors.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_mir_dataflow%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_mir_dataflow%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Ferrors.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -2,69 +2,69 @@ use rustc_macros::Diagnostic;\n use rustc_span::{Span, Symbol};\n \n #[derive(Diagnostic)]\n-#[diag(mir_dataflow::path_must_end_in_filename)]\n+#[diag(mir_dataflow_path_must_end_in_filename)]\n pub(crate) struct PathMustEndInFilename {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(mir_dataflow::unknown_formatter)]\n+#[diag(mir_dataflow_unknown_formatter)]\n pub(crate) struct UnknownFormatter {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(mir_dataflow::duplicate_values_for)]\n+#[diag(mir_dataflow_duplicate_values_for)]\n pub(crate) struct DuplicateValuesFor {\n     #[primary_span]\n     pub span: Span,\n     pub name: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(mir_dataflow::requires_an_argument)]\n+#[diag(mir_dataflow_requires_an_argument)]\n pub(crate) struct RequiresAnArgument {\n     #[primary_span]\n     pub span: Span,\n     pub name: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(mir_dataflow::stop_after_dataflow_ended_compilation)]\n+#[diag(mir_dataflow_stop_after_dataflow_ended_compilation)]\n pub(crate) struct StopAfterDataFlowEndedCompilation;\n \n #[derive(Diagnostic)]\n-#[diag(mir_dataflow::peek_must_be_place_or_ref_place)]\n+#[diag(mir_dataflow_peek_must_be_place_or_ref_place)]\n pub(crate) struct PeekMustBePlaceOrRefPlace {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(mir_dataflow::peek_must_be_not_temporary)]\n+#[diag(mir_dataflow_peek_must_be_not_temporary)]\n pub(crate) struct PeekMustBeNotTemporary {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(mir_dataflow::peek_bit_not_set)]\n+#[diag(mir_dataflow_peek_bit_not_set)]\n pub(crate) struct PeekBitNotSet {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(mir_dataflow::peek_argument_not_a_local)]\n+#[diag(mir_dataflow_peek_argument_not_a_local)]\n pub(crate) struct PeekArgumentNotALocal {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(mir_dataflow::peek_argument_untracked)]\n+#[diag(mir_dataflow_peek_argument_untracked)]\n pub(crate) struct PeekArgumentUntracked {\n     #[primary_span]\n     pub span: Span,"}, {"sha": "18352fbf675ca83a570ee0d2fac120d5747fe400", "filename": "compiler/rustc_mir_transform/src/deduce_param_attrs.rs", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_mir_transform%2Fsrc%2Fdeduce_param_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_mir_transform%2Fsrc%2Fdeduce_param_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdeduce_param_attrs.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -0,0 +1,249 @@\n+//! Deduces supplementary parameter attributes from MIR.\n+//!\n+//! Deduced parameter attributes are those that can only be soundly determined by examining the\n+//! body of the function instead of just the signature. These can be useful for optimization\n+//! purposes on a best-effort basis. We compute them here and store them into the crate metadata so\n+//! dependent crates can use them.\n+\n+use rustc_hir::def_id::DefId;\n+use rustc_index::bit_set::BitSet;\n+use rustc_middle::mir::visit::{NonMutatingUseContext, PlaceContext, Visitor};\n+use rustc_middle::mir::{Body, Local, Location, Operand, Terminator, TerminatorKind, RETURN_PLACE};\n+use rustc_middle::ty::{self, DeducedParamAttrs, ParamEnv, Ty, TyCtxt};\n+use rustc_session::config::OptLevel;\n+use rustc_span::DUMMY_SP;\n+\n+/// A visitor that determines which arguments have been mutated. We can't use the mutability field\n+/// on LocalDecl for this because it has no meaning post-optimization.\n+struct DeduceReadOnly {\n+    /// Each bit is indexed by argument number, starting at zero (so 0 corresponds to local decl\n+    /// 1). The bit is true if the argument may have been mutated or false if we know it hasn't\n+    /// been up to the point we're at.\n+    mutable_args: BitSet<usize>,\n+}\n+\n+impl DeduceReadOnly {\n+    /// Returns a new DeduceReadOnly instance.\n+    fn new(arg_count: usize) -> Self {\n+        Self { mutable_args: BitSet::new_empty(arg_count) }\n+    }\n+}\n+\n+impl<'tcx> Visitor<'tcx> for DeduceReadOnly {\n+    fn visit_local(&mut self, local: Local, mut context: PlaceContext, _: Location) {\n+        // We're only interested in arguments.\n+        if local == RETURN_PLACE || local.index() > self.mutable_args.domain_size() {\n+            return;\n+        }\n+\n+        // Replace place contexts that are moves with copies. This is safe in all cases except\n+        // function argument position, which we already handled in `visit_terminator()` by using the\n+        // ArgumentChecker. See the comment in that method for more details.\n+        //\n+        // In the future, we might want to move this out into a separate pass, but for now let's\n+        // just do it on the fly because that's faster.\n+        if matches!(context, PlaceContext::NonMutatingUse(NonMutatingUseContext::Move)) {\n+            context = PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy);\n+        }\n+\n+        match context {\n+            PlaceContext::MutatingUse(..)\n+            | PlaceContext::NonMutatingUse(NonMutatingUseContext::Move) => {\n+                // This is a mutation, so mark it as such.\n+                self.mutable_args.insert(local.index() - 1);\n+            }\n+            PlaceContext::NonMutatingUse(..) | PlaceContext::NonUse(..) => {\n+                // Not mutating, so it's fine.\n+            }\n+        }\n+    }\n+\n+    fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n+        // OK, this is subtle. Suppose that we're trying to deduce whether `x` in `f` is read-only\n+        // and we have the following:\n+        //\n+        //     fn f(x: BigStruct) { g(x) }\n+        //     fn g(mut y: BigStruct) { y.foo = 1 }\n+        //\n+        // If, at the generated MIR level, `f` turned into something like:\n+        //\n+        //      fn f(_1: BigStruct) -> () {\n+        //          let mut _0: ();\n+        //          bb0: {\n+        //              _0 = g(move _1) -> bb1;\n+        //          }\n+        //          ...\n+        //      }\n+        //\n+        // then it would be incorrect to mark `x` (i.e. `_1`) as `readonly`, because `g`'s write to\n+        // its copy of the indirect parameter would actually be a write directly to the pointer that\n+        // `f` passes. Note that function arguments are the only situation in which this problem can\n+        // arise: every other use of `move` in MIR doesn't actually write to the value it moves\n+        // from.\n+        //\n+        // Anyway, right now this situation doesn't actually arise in practice. Instead, the MIR for\n+        // that function looks like this:\n+        //\n+        //      fn f(_1: BigStruct) -> () {\n+        //          let mut _0: ();\n+        //          let mut _2: BigStruct;\n+        //          bb0: {\n+        //              _2 = move _1;\n+        //              _0 = g(move _2) -> bb1;\n+        //          }\n+        //          ...\n+        //      }\n+        //\n+        // Because of that extra move that MIR construction inserts, `x` (i.e. `_1`) can *in\n+        // practice* safely be marked `readonly`.\n+        //\n+        // To handle the possibility that other optimizations (for example, destination propagation)\n+        // might someday generate MIR like the first example above, we panic upon seeing an argument\n+        // to *our* function that is directly moved into *another* function as an argument. Having\n+        // eliminated that problematic case, we can safely treat moves as copies in this analysis.\n+        //\n+        // In the future, if MIR optimizations cause arguments of a caller to be directly moved into\n+        // the argument of a callee, we can just add that argument to `mutated_args` instead of\n+        // panicking.\n+        //\n+        // Note that, because the problematic MIR is never actually generated, we can't add a test\n+        // case for this.\n+\n+        if let TerminatorKind::Call { ref args, .. } = terminator.kind {\n+            for arg in args {\n+                if let Operand::Move(_) = *arg {\n+                    // ArgumentChecker panics if a direct move of an argument from a caller to a\n+                    // callee was detected.\n+                    //\n+                    // If, in the future, MIR optimizations cause arguments to be moved directly\n+                    // from callers to callees, change the panic to instead add the argument in\n+                    // question to `mutating_uses`.\n+                    ArgumentChecker::new(self.mutable_args.domain_size())\n+                        .visit_operand(arg, location)\n+                }\n+            }\n+        };\n+\n+        self.super_terminator(terminator, location);\n+    }\n+}\n+\n+/// A visitor that simply panics if a direct move of an argument from a caller to a callee was\n+/// detected.\n+struct ArgumentChecker {\n+    /// The number of arguments to the calling function.\n+    arg_count: usize,\n+}\n+\n+impl ArgumentChecker {\n+    /// Creates a new ArgumentChecker.\n+    fn new(arg_count: usize) -> Self {\n+        Self { arg_count }\n+    }\n+}\n+\n+impl<'tcx> Visitor<'tcx> for ArgumentChecker {\n+    fn visit_local(&mut self, local: Local, context: PlaceContext, _: Location) {\n+        // Check to make sure that, if this local is an argument, we didn't move directly from it.\n+        if matches!(context, PlaceContext::NonMutatingUse(NonMutatingUseContext::Move))\n+            && local != RETURN_PLACE\n+            && local.index() <= self.arg_count\n+        {\n+            // If, in the future, MIR optimizations cause arguments to be moved directly from\n+            // callers to callees, change this panic to instead add the argument in question to\n+            // `mutating_uses`.\n+            panic!(\"Detected a direct move from a caller's argument to a callee's argument!\")\n+        }\n+    }\n+}\n+\n+/// Returns true if values of a given type will never be passed indirectly, regardless of ABI.\n+fn type_will_always_be_passed_directly<'tcx>(ty: Ty<'tcx>) -> bool {\n+    matches!(\n+        ty.kind(),\n+        ty::Bool\n+            | ty::Char\n+            | ty::Float(..)\n+            | ty::Int(..)\n+            | ty::RawPtr(..)\n+            | ty::Ref(..)\n+            | ty::Slice(..)\n+            | ty::Uint(..)\n+    )\n+}\n+\n+/// Returns the deduced parameter attributes for a function.\n+///\n+/// Deduced parameter attributes are those that can only be soundly determined by examining the\n+/// body of the function instead of just the signature. These can be useful for optimization\n+/// purposes on a best-effort basis. We compute them here and store them into the crate metadata so\n+/// dependent crates can use them.\n+pub fn deduced_param_attrs<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx [DeducedParamAttrs] {\n+    // This computation is unfortunately rather expensive, so don't do it unless we're optimizing.\n+    // Also skip it in incremental mode.\n+    if tcx.sess.opts.optimize == OptLevel::No || tcx.sess.opts.incremental.is_some() {\n+        return &[];\n+    }\n+\n+    // If the Freeze language item isn't present, then don't bother.\n+    if tcx.lang_items().freeze_trait().is_none() {\n+        return &[];\n+    }\n+\n+    // Codegen won't use this information for anything if all the function parameters are passed\n+    // directly. Detect that and bail, for compilation speed.\n+    let fn_ty = tcx.type_of(def_id);\n+    if matches!(fn_ty.kind(), ty::FnDef(..)) {\n+        if fn_ty\n+            .fn_sig(tcx)\n+            .inputs()\n+            .skip_binder()\n+            .iter()\n+            .cloned()\n+            .all(type_will_always_be_passed_directly)\n+        {\n+            return &[];\n+        }\n+    }\n+\n+    // Don't deduce any attributes for functions that have no MIR.\n+    if !tcx.is_mir_available(def_id) {\n+        return &[];\n+    }\n+\n+    // Deduced attributes for other crates should be read from the metadata instead of via this\n+    // function.\n+    debug_assert!(def_id.is_local());\n+\n+    // Grab the optimized MIR. Analyze it to determine which arguments have been mutated.\n+    let body: &Body<'tcx> = tcx.optimized_mir(def_id);\n+    let mut deduce_read_only = DeduceReadOnly::new(body.arg_count);\n+    deduce_read_only.visit_body(body);\n+\n+    // Set the `readonly` attribute for every argument that we concluded is immutable and that\n+    // contains no UnsafeCells.\n+    //\n+    // FIXME: This is overly conservative around generic parameters: `is_freeze()` will always\n+    // return false for them. For a description of alternatives that could do a better job here,\n+    // see [1].\n+    //\n+    // [1]: https://github.com/rust-lang/rust/pull/103172#discussion_r999139997\n+    let mut deduced_param_attrs = tcx.arena.alloc_from_iter(\n+        body.local_decls.iter().skip(1).take(body.arg_count).enumerate().map(\n+            |(arg_index, local_decl)| DeducedParamAttrs {\n+                read_only: !deduce_read_only.mutable_args.contains(arg_index)\n+                    && local_decl.ty.is_freeze(tcx.at(DUMMY_SP), ParamEnv::reveal_all()),\n+            },\n+        ),\n+    );\n+\n+    // Trailing parameters past the size of the `deduced_param_attrs` array are assumed to have the\n+    // default set of attributes, so we don't have to store them explicitly. Pop them off to save a\n+    // few bytes in metadata.\n+    while deduced_param_attrs.last() == Some(&DeducedParamAttrs::default()) {\n+        let last_index = deduced_param_attrs.len() - 1;\n+        deduced_param_attrs = &mut deduced_param_attrs[0..last_index];\n+    }\n+\n+    deduced_param_attrs\n+}"}, {"sha": "5c411fa5657846bf017e0247f23493838f8c4844", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -56,6 +56,7 @@ mod const_prop_lint;\n mod coverage;\n mod dead_store_elimination;\n mod deaggregator;\n+mod deduce_param_attrs;\n mod deduplicate_blocks;\n mod deref_separator;\n mod dest_prop;\n@@ -139,6 +140,7 @@ pub fn provide(providers: &mut Providers) {\n         promoted_mir_of_const_arg: |tcx, (did, param_did)| {\n             promoted_mir(tcx, ty::WithOptConstParam { did, const_param_did: Some(param_did) })\n         },\n+        deduced_param_attrs: deduce_param_attrs::deduced_param_attrs,\n         ..*providers\n     };\n }"}, {"sha": "ce097b8d846aa3f41db29948e674683ba1f130a0", "filename": "compiler/rustc_monomorphize/src/errors.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_monomorphize%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_monomorphize%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Ferrors.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -6,34 +6,34 @@ use rustc_macros::{Diagnostic, LintDiagnostic};\n use rustc_span::Span;\n \n #[derive(Diagnostic)]\n-#[diag(monomorphize::recursion_limit)]\n+#[diag(monomorphize_recursion_limit)]\n pub struct RecursionLimit {\n     #[primary_span]\n     pub span: Span,\n     pub shrunk: String,\n     #[note]\n     pub def_span: Span,\n     pub def_path_str: String,\n-    #[note(monomorphize::written_to_path)]\n+    #[note(monomorphize_written_to_path)]\n     pub was_written: Option<()>,\n     pub path: PathBuf,\n }\n \n #[derive(Diagnostic)]\n-#[diag(monomorphize::type_length_limit)]\n-#[help(monomorphize::consider_type_length_limit)]\n+#[diag(monomorphize_type_length_limit)]\n+#[help(monomorphize_consider_type_length_limit)]\n pub struct TypeLengthLimit {\n     #[primary_span]\n     pub span: Span,\n     pub shrunk: String,\n-    #[note(monomorphize::written_to_path)]\n+    #[note(monomorphize_written_to_path)]\n     pub was_written: Option<()>,\n     pub path: PathBuf,\n     pub type_length: usize,\n }\n \n #[derive(Diagnostic)]\n-#[diag(monomorphize::requires_lang_item)]\n+#[diag(monomorphize_requires_lang_item)]\n pub struct RequiresLangItem {\n     pub lang_item: String,\n }\n@@ -49,8 +49,7 @@ impl IntoDiagnostic<'_> for UnusedGenericParams {\n         self,\n         handler: &'_ rustc_errors::Handler,\n     ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n-        let mut diag =\n-            handler.struct_err(rustc_errors::fluent::monomorphize::unused_generic_params);\n+        let mut diag = handler.struct_err(rustc_errors::fluent::monomorphize_unused_generic_params);\n         diag.set_span(self.span);\n         for (span, name) in self.param_spans.into_iter().zip(self.param_names) {\n             // FIXME: I can figure out how to do a label with a fluent string with a fixed message,\n@@ -63,7 +62,7 @@ impl IntoDiagnostic<'_> for UnusedGenericParams {\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(monomorphize::large_assignments)]\n+#[diag(monomorphize_large_assignments)]\n #[note]\n pub struct LargeAssignmentsLint {\n     #[label]\n@@ -73,11 +72,11 @@ pub struct LargeAssignmentsLint {\n }\n \n #[derive(Diagnostic)]\n-#[diag(monomorphize::unknown_partition_strategy)]\n+#[diag(monomorphize_unknown_partition_strategy)]\n pub struct UnknownPartitionStrategy;\n \n #[derive(Diagnostic)]\n-#[diag(monomorphize::symbol_already_defined)]\n+#[diag(monomorphize_symbol_already_defined)]\n pub struct SymbolAlreadyDefined {\n     #[primary_span]\n     pub span: Option<Span>,"}, {"sha": "9b177c5189bfbe426acff8c8410eb8ab6a03512d", "filename": "compiler/rustc_parse/src/errors.rs", "status": "modified", "additions": 170, "deletions": 184, "changes": 354, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -9,7 +9,7 @@ use rustc_span::{Span, Symbol};\n use crate::parser::TokenDescription;\n \n #[derive(Diagnostic)]\n-#[diag(parser::maybe_report_ambiguous_plus)]\n+#[diag(parser_maybe_report_ambiguous_plus)]\n pub(crate) struct AmbiguousPlus {\n     pub sum_ty: String,\n     #[primary_span]\n@@ -18,7 +18,7 @@ pub(crate) struct AmbiguousPlus {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::maybe_recover_from_bad_type_plus, code = \"E0178\")]\n+#[diag(parser_maybe_recover_from_bad_type_plus, code = \"E0178\")]\n pub(crate) struct BadTypePlus {\n     pub ty: String,\n     #[primary_span]\n@@ -30,7 +30,7 @@ pub(crate) struct BadTypePlus {\n #[derive(Subdiagnostic)]\n pub(crate) enum BadTypePlusSub {\n     #[suggestion(\n-        parser::add_paren,\n+        parser_add_paren,\n         code = \"{sum_with_parens}\",\n         applicability = \"machine-applicable\"\n     )]\n@@ -39,20 +39,20 @@ pub(crate) enum BadTypePlusSub {\n         #[primary_span]\n         span: Span,\n     },\n-    #[label(parser::forgot_paren)]\n+    #[label(parser_forgot_paren)]\n     ForgotParen {\n         #[primary_span]\n         span: Span,\n     },\n-    #[label(parser::expect_path)]\n+    #[label(parser_expect_path)]\n     ExpectPath {\n         #[primary_span]\n         span: Span,\n     },\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::maybe_recover_from_bad_qpath_stage_2)]\n+#[diag(parser_maybe_recover_from_bad_qpath_stage_2)]\n pub(crate) struct BadQPathStage2 {\n     #[primary_span]\n     #[suggestion(code = \"\", applicability = \"maybe-incorrect\")]\n@@ -61,7 +61,7 @@ pub(crate) struct BadQPathStage2 {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::incorrect_semicolon)]\n+#[diag(parser_incorrect_semicolon)]\n pub(crate) struct IncorrectSemicolon<'a> {\n     #[primary_span]\n     #[suggestion_short(code = \"\", applicability = \"machine-applicable\")]\n@@ -72,26 +72,26 @@ pub(crate) struct IncorrectSemicolon<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::incorrect_use_of_await)]\n+#[diag(parser_incorrect_use_of_await)]\n pub(crate) struct IncorrectUseOfAwait {\n     #[primary_span]\n-    #[suggestion(parser::parentheses_suggestion, code = \"\", applicability = \"machine-applicable\")]\n+    #[suggestion(parentheses_suggestion, code = \"\", applicability = \"machine-applicable\")]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::incorrect_use_of_await)]\n+#[diag(parser_incorrect_use_of_await)]\n pub(crate) struct IncorrectAwait {\n     #[primary_span]\n     pub span: Span,\n-    #[suggestion(parser::postfix_suggestion, code = \"{expr}.await{question_mark}\")]\n+    #[suggestion(postfix_suggestion, code = \"{expr}.await{question_mark}\")]\n     pub sugg_span: (Span, Applicability),\n     pub expr: String,\n     pub question_mark: &'static str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::in_in_typo)]\n+#[diag(parser_in_in_typo)]\n pub(crate) struct InInTypo {\n     #[primary_span]\n     pub span: Span,\n@@ -100,7 +100,7 @@ pub(crate) struct InInTypo {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::invalid_variable_declaration)]\n+#[diag(parser_invalid_variable_declaration)]\n pub(crate) struct InvalidVariableDeclaration {\n     #[primary_span]\n     pub span: Span,\n@@ -110,26 +110,22 @@ pub(crate) struct InvalidVariableDeclaration {\n \n #[derive(Subdiagnostic)]\n pub(crate) enum InvalidVariableDeclarationSub {\n-    #[suggestion(\n-        parser::switch_mut_let_order,\n-        applicability = \"maybe-incorrect\",\n-        code = \"let mut\"\n-    )]\n+    #[suggestion(parser_switch_mut_let_order, applicability = \"maybe-incorrect\", code = \"let mut\")]\n     SwitchMutLetOrder(#[primary_span] Span),\n     #[suggestion(\n-        parser::missing_let_before_mut,\n+        parser_missing_let_before_mut,\n         applicability = \"machine-applicable\",\n         code = \"let mut\"\n     )]\n     MissingLet(#[primary_span] Span),\n-    #[suggestion(parser::use_let_not_auto, applicability = \"machine-applicable\", code = \"let\")]\n+    #[suggestion(parser_use_let_not_auto, applicability = \"machine-applicable\", code = \"let\")]\n     UseLetNotAuto(#[primary_span] Span),\n-    #[suggestion(parser::use_let_not_var, applicability = \"machine-applicable\", code = \"let\")]\n+    #[suggestion(parser_use_let_not_var, applicability = \"machine-applicable\", code = \"let\")]\n     UseLetNotVar(#[primary_span] Span),\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::invalid_comparison_operator)]\n+#[diag(parser_invalid_comparison_operator)]\n pub(crate) struct InvalidComparisonOperator {\n     #[primary_span]\n     pub span: Span,\n@@ -140,23 +136,19 @@ pub(crate) struct InvalidComparisonOperator {\n \n #[derive(Subdiagnostic)]\n pub(crate) enum InvalidComparisonOperatorSub {\n-    #[suggestion_short(\n-        parser::use_instead,\n-        applicability = \"machine-applicable\",\n-        code = \"{correct}\"\n-    )]\n+    #[suggestion_short(use_instead, applicability = \"machine-applicable\", code = \"{correct}\")]\n     Correctable {\n         #[primary_span]\n         span: Span,\n         invalid: String,\n         correct: String,\n     },\n-    #[label(parser::spaceship_operator_invalid)]\n+    #[label(spaceship_operator_invalid)]\n     Spaceship(#[primary_span] Span),\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::invalid_logical_operator)]\n+#[diag(parser_invalid_logical_operator)]\n #[note]\n pub(crate) struct InvalidLogicalOperator {\n     #[primary_span]\n@@ -169,29 +161,29 @@ pub(crate) struct InvalidLogicalOperator {\n #[derive(Subdiagnostic)]\n pub(crate) enum InvalidLogicalOperatorSub {\n     #[suggestion_short(\n-        parser::use_amp_amp_for_conjunction,\n+        use_amp_amp_for_conjunction,\n         applicability = \"machine-applicable\",\n         code = \"&&\"\n     )]\n     Conjunction(#[primary_span] Span),\n     #[suggestion_short(\n-        parser::use_pipe_pipe_for_disjunction,\n+        use_pipe_pipe_for_disjunction,\n         applicability = \"machine-applicable\",\n         code = \"||\"\n     )]\n     Disjunction(#[primary_span] Span),\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::tilde_is_not_unary_operator)]\n+#[diag(parser_tilde_is_not_unary_operator)]\n pub(crate) struct TildeAsUnaryOperator(\n     #[primary_span]\n     #[suggestion_short(applicability = \"machine-applicable\", code = \"!\")]\n     pub Span,\n );\n \n #[derive(Diagnostic)]\n-#[diag(parser::unexpected_token_after_not)]\n+#[diag(parser_unexpected_token_after_not)]\n pub(crate) struct NotAsNegationOperator {\n     #[primary_span]\n     pub negated: Span,\n@@ -203,29 +195,29 @@ pub(crate) struct NotAsNegationOperator {\n #[derive(Subdiagnostic)]\n pub enum NotAsNegationOperatorSub {\n     #[suggestion_short(\n-        parser::unexpected_token_after_not_default,\n+        parser_unexpected_token_after_not_default,\n         applicability = \"machine-applicable\",\n         code = \"!\"\n     )]\n     SuggestNotDefault(#[primary_span] Span),\n \n     #[suggestion_short(\n-        parser::unexpected_token_after_not_bitwise,\n+        parser_unexpected_token_after_not_bitwise,\n         applicability = \"machine-applicable\",\n         code = \"!\"\n     )]\n     SuggestNotBitwise(#[primary_span] Span),\n \n     #[suggestion_short(\n-        parser::unexpected_token_after_not_logical,\n+        parser_unexpected_token_after_not_logical,\n         applicability = \"machine-applicable\",\n         code = \"!\"\n     )]\n     SuggestNotLogical(#[primary_span] Span),\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::malformed_loop_label)]\n+#[diag(parser_malformed_loop_label)]\n pub(crate) struct MalformedLoopLabel {\n     #[primary_span]\n     #[suggestion(applicability = \"machine-applicable\", code = \"{correct_label}\")]\n@@ -234,7 +226,7 @@ pub(crate) struct MalformedLoopLabel {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::lifetime_in_borrow_expression)]\n+#[diag(parser_lifetime_in_borrow_expression)]\n pub(crate) struct LifetimeInBorrowExpression {\n     #[primary_span]\n     pub span: Span,\n@@ -244,27 +236,27 @@ pub(crate) struct LifetimeInBorrowExpression {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::field_expression_with_generic)]\n+#[diag(parser_field_expression_with_generic)]\n pub(crate) struct FieldExpressionWithGeneric(#[primary_span] pub Span);\n \n #[derive(Diagnostic)]\n-#[diag(parser::macro_invocation_with_qualified_path)]\n+#[diag(parser_macro_invocation_with_qualified_path)]\n pub(crate) struct MacroInvocationWithQualifiedPath(#[primary_span] pub Span);\n \n #[derive(Diagnostic)]\n-#[diag(parser::unexpected_token_after_label)]\n+#[diag(parser_unexpected_token_after_label)]\n pub(crate) struct UnexpectedTokenAfterLabel {\n     #[primary_span]\n-    #[label(parser::unexpected_token_after_label)]\n+    #[label(parser_unexpected_token_after_label)]\n     pub span: Span,\n-    #[suggestion_verbose(parser::suggestion_remove_label, code = \"\")]\n+    #[suggestion_verbose(suggestion_remove_label, code = \"\")]\n     pub remove_label: Option<Span>,\n     #[subdiagnostic]\n     pub enclose_in_block: Option<UnexpectedTokenAfterLabelSugg>,\n }\n \n #[derive(Subdiagnostic)]\n-#[multipart_suggestion(parser::suggestion_enclose_in_block, applicability = \"machine-applicable\")]\n+#[multipart_suggestion(suggestion_enclose_in_block, applicability = \"machine-applicable\")]\n pub(crate) struct UnexpectedTokenAfterLabelSugg {\n     #[suggestion_part(code = \"{{ \")]\n     pub left: Span,\n@@ -273,7 +265,7 @@ pub(crate) struct UnexpectedTokenAfterLabelSugg {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::require_colon_after_labeled_expression)]\n+#[diag(parser_require_colon_after_labeled_expression)]\n #[note]\n pub(crate) struct RequireColonAfterLabeledExpression {\n     #[primary_span]\n@@ -285,7 +277,7 @@ pub(crate) struct RequireColonAfterLabeledExpression {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::do_catch_syntax_removed)]\n+#[diag(parser_do_catch_syntax_removed)]\n #[note]\n pub(crate) struct DoCatchSyntaxRemoved {\n     #[primary_span]\n@@ -294,7 +286,7 @@ pub(crate) struct DoCatchSyntaxRemoved {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::float_literal_requires_integer_part)]\n+#[diag(parser_float_literal_requires_integer_part)]\n pub(crate) struct FloatLiteralRequiresIntegerPart {\n     #[primary_span]\n     #[suggestion(applicability = \"machine-applicable\", code = \"{correct}\")]\n@@ -303,7 +295,7 @@ pub(crate) struct FloatLiteralRequiresIntegerPart {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::invalid_int_literal_width)]\n+#[diag(parser_invalid_int_literal_width)]\n #[help]\n pub(crate) struct InvalidIntLiteralWidth {\n     #[primary_span]\n@@ -312,7 +304,7 @@ pub(crate) struct InvalidIntLiteralWidth {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::invalid_num_literal_base_prefix)]\n+#[diag(parser_invalid_num_literal_base_prefix)]\n #[note]\n pub(crate) struct InvalidNumLiteralBasePrefix {\n     #[primary_span]\n@@ -322,7 +314,7 @@ pub(crate) struct InvalidNumLiteralBasePrefix {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::invalid_num_literal_suffix)]\n+#[diag(parser_invalid_num_literal_suffix)]\n #[help]\n pub(crate) struct InvalidNumLiteralSuffix {\n     #[primary_span]\n@@ -332,7 +324,7 @@ pub(crate) struct InvalidNumLiteralSuffix {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::invalid_float_literal_width)]\n+#[diag(parser_invalid_float_literal_width)]\n #[help]\n pub(crate) struct InvalidFloatLiteralWidth {\n     #[primary_span]\n@@ -341,7 +333,7 @@ pub(crate) struct InvalidFloatLiteralWidth {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::invalid_float_literal_suffix)]\n+#[diag(parser_invalid_float_literal_suffix)]\n #[help]\n pub(crate) struct InvalidFloatLiteralSuffix {\n     #[primary_span]\n@@ -351,14 +343,14 @@ pub(crate) struct InvalidFloatLiteralSuffix {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::int_literal_too_large)]\n+#[diag(parser_int_literal_too_large)]\n pub(crate) struct IntLiteralTooLarge {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::missing_semicolon_before_array)]\n+#[diag(parser_missing_semicolon_before_array)]\n pub(crate) struct MissingSemicolonBeforeArray {\n     #[primary_span]\n     pub open_delim: Span,\n@@ -367,7 +359,7 @@ pub(crate) struct MissingSemicolonBeforeArray {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::invalid_block_macro_segment)]\n+#[diag(parser_invalid_block_macro_segment)]\n pub(crate) struct InvalidBlockMacroSegment {\n     #[primary_span]\n     pub span: Span,\n@@ -376,7 +368,7 @@ pub(crate) struct InvalidBlockMacroSegment {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::if_expression_missing_then_block)]\n+#[diag(parser_if_expression_missing_then_block)]\n pub(crate) struct IfExpressionMissingThenBlock {\n     #[primary_span]\n     pub if_span: Span,\n@@ -386,31 +378,31 @@ pub(crate) struct IfExpressionMissingThenBlock {\n \n #[derive(Subdiagnostic)]\n pub(crate) enum IfExpressionMissingThenBlockSub {\n-    #[help(parser::condition_possibly_unfinished)]\n+    #[help(condition_possibly_unfinished)]\n     UnfinishedCondition(#[primary_span] Span),\n-    #[help(parser::add_then_block)]\n+    #[help(add_then_block)]\n     AddThenBlock(#[primary_span] Span),\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::if_expression_missing_condition)]\n+#[diag(parser_if_expression_missing_condition)]\n pub(crate) struct IfExpressionMissingCondition {\n     #[primary_span]\n-    #[label(parser::condition_label)]\n+    #[label(condition_label)]\n     pub if_span: Span,\n-    #[label(parser::block_label)]\n+    #[label(block_label)]\n     pub block_span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::expected_expression_found_let)]\n+#[diag(parser_expected_expression_found_let)]\n pub(crate) struct ExpectedExpressionFoundLet {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::expected_else_block)]\n+#[diag(parser_expected_else_block)]\n pub(crate) struct ExpectedElseBlock {\n     #[primary_span]\n     pub first_tok_span: Span,\n@@ -422,15 +414,15 @@ pub(crate) struct ExpectedElseBlock {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::outer_attribute_not_allowed_on_if_else)]\n+#[diag(parser_outer_attribute_not_allowed_on_if_else)]\n pub(crate) struct OuterAttributeNotAllowedOnIfElse {\n     #[primary_span]\n     pub last: Span,\n \n-    #[label(parser::branch_label)]\n+    #[label(branch_label)]\n     pub branch_span: Span,\n \n-    #[label(parser::ctx_label)]\n+    #[label(ctx_label)]\n     pub ctx_span: Span,\n     pub ctx: String,\n \n@@ -439,7 +431,7 @@ pub(crate) struct OuterAttributeNotAllowedOnIfElse {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::missing_in_in_for_loop)]\n+#[diag(parser_missing_in_in_for_loop)]\n pub(crate) struct MissingInInForLoop {\n     #[primary_span]\n     pub span: Span,\n@@ -450,30 +442,30 @@ pub(crate) struct MissingInInForLoop {\n #[derive(Subdiagnostic)]\n pub(crate) enum MissingInInForLoopSub {\n     // Has been misleading, at least in the past (closed Issue #48492), thus maybe-incorrect\n-    #[suggestion_short(parser::use_in_not_of, applicability = \"maybe-incorrect\", code = \"in\")]\n+    #[suggestion_short(use_in_not_of, applicability = \"maybe-incorrect\", code = \"in\")]\n     InNotOf(#[primary_span] Span),\n-    #[suggestion_short(parser::add_in, applicability = \"maybe-incorrect\", code = \" in \")]\n+    #[suggestion_short(add_in, applicability = \"maybe-incorrect\", code = \" in \")]\n     AddIn(#[primary_span] Span),\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::missing_comma_after_match_arm)]\n+#[diag(parser_missing_comma_after_match_arm)]\n pub(crate) struct MissingCommaAfterMatchArm {\n     #[primary_span]\n     #[suggestion(applicability = \"machine-applicable\", code = \",\")]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::catch_after_try)]\n+#[diag(parser_catch_after_try)]\n #[help]\n pub(crate) struct CatchAfterTry {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::comma_after_base_struct)]\n+#[diag(parser_comma_after_base_struct)]\n #[note]\n pub(crate) struct CommaAfterBaseStruct {\n     #[primary_span]\n@@ -483,7 +475,7 @@ pub(crate) struct CommaAfterBaseStruct {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::eq_field_init)]\n+#[diag(parser_eq_field_init)]\n pub(crate) struct EqFieldInit {\n     #[primary_span]\n     pub span: Span,\n@@ -492,74 +484,74 @@ pub(crate) struct EqFieldInit {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::dotdotdot)]\n+#[diag(parser_dotdotdot)]\n pub(crate) struct DotDotDot {\n     #[primary_span]\n-    #[suggestion(parser::suggest_exclusive_range, applicability = \"maybe-incorrect\", code = \"..\")]\n-    #[suggestion(parser::suggest_inclusive_range, applicability = \"maybe-incorrect\", code = \"..=\")]\n+    #[suggestion(suggest_exclusive_range, applicability = \"maybe-incorrect\", code = \"..\")]\n+    #[suggestion(suggest_inclusive_range, applicability = \"maybe-incorrect\", code = \"..=\")]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::left_arrow_operator)]\n+#[diag(parser_left_arrow_operator)]\n pub(crate) struct LeftArrowOperator {\n     #[primary_span]\n     #[suggestion(applicability = \"maybe-incorrect\", code = \"< -\")]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::remove_let)]\n+#[diag(parser_remove_let)]\n pub(crate) struct RemoveLet {\n     #[primary_span]\n     #[suggestion(applicability = \"machine-applicable\", code = \"\")]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::use_eq_instead)]\n+#[diag(parser_use_eq_instead)]\n pub(crate) struct UseEqInstead {\n     #[primary_span]\n     #[suggestion_short(applicability = \"machine-applicable\", code = \"=\")]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::use_empty_block_not_semi)]\n+#[diag(parser_use_empty_block_not_semi)]\n pub(crate) struct UseEmptyBlockNotSemi {\n     #[primary_span]\n     #[suggestion_hidden(applicability = \"machine-applicable\", code = \"{{}}\")]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::comparison_interpreted_as_generic)]\n+#[diag(parser_comparison_interpreted_as_generic)]\n pub(crate) struct ComparisonInterpretedAsGeneric {\n     #[primary_span]\n-    #[label(parser::label_comparison)]\n+    #[label(label_comparison)]\n     pub comparison: Span,\n     pub r#type: Path,\n-    #[label(parser::label_args)]\n+    #[label(label_args)]\n     pub args: Span,\n     #[subdiagnostic]\n     pub suggestion: ComparisonOrShiftInterpretedAsGenericSugg,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::shift_interpreted_as_generic)]\n+#[diag(parser_shift_interpreted_as_generic)]\n pub(crate) struct ShiftInterpretedAsGeneric {\n     #[primary_span]\n-    #[label(parser::label_comparison)]\n+    #[label(label_comparison)]\n     pub shift: Span,\n     pub r#type: Path,\n-    #[label(parser::label_args)]\n+    #[label(label_args)]\n     pub args: Span,\n     #[subdiagnostic]\n     pub suggestion: ComparisonOrShiftInterpretedAsGenericSugg,\n }\n \n #[derive(Subdiagnostic)]\n-#[multipart_suggestion(parser::suggestion, applicability = \"machine-applicable\")]\n+#[multipart_suggestion(suggestion, applicability = \"machine-applicable\")]\n pub(crate) struct ComparisonOrShiftInterpretedAsGenericSugg {\n     #[suggestion_part(code = \"(\")]\n     pub left: Span,\n@@ -568,7 +560,7 @@ pub(crate) struct ComparisonOrShiftInterpretedAsGenericSugg {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::found_expr_would_be_stmt)]\n+#[diag(parser_found_expr_would_be_stmt)]\n pub(crate) struct FoundExprWouldBeStmt {\n     #[primary_span]\n     #[label]\n@@ -579,23 +571,19 @@ pub(crate) struct FoundExprWouldBeStmt {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::leading_plus_not_supported)]\n+#[diag(parser_leading_plus_not_supported)]\n pub(crate) struct LeadingPlusNotSupported {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[suggestion_verbose(\n-        parser::suggestion_remove_plus,\n-        code = \"\",\n-        applicability = \"machine-applicable\"\n-    )]\n+    #[suggestion_verbose(suggestion_remove_plus, code = \"\", applicability = \"machine-applicable\")]\n     pub remove_plus: Option<Span>,\n     #[subdiagnostic]\n     pub add_parentheses: Option<ExprParenthesesNeeded>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::parentheses_with_struct_fields)]\n+#[diag(parser_parentheses_with_struct_fields)]\n pub(crate) struct ParenthesesWithStructFields {\n     #[primary_span]\n     pub span: Span,\n@@ -607,7 +595,7 @@ pub(crate) struct ParenthesesWithStructFields {\n }\n \n #[derive(Subdiagnostic)]\n-#[multipart_suggestion(parser::suggestion_braces_for_struct, applicability = \"maybe-incorrect\")]\n+#[multipart_suggestion(suggestion_braces_for_struct, applicability = \"maybe-incorrect\")]\n pub(crate) struct BracesForStructLiteral {\n     #[suggestion_part(code = \" {{ \")]\n     pub first: Span,\n@@ -616,14 +604,14 @@ pub(crate) struct BracesForStructLiteral {\n }\n \n #[derive(Subdiagnostic)]\n-#[multipart_suggestion(parser::suggestion_no_fields_for_fn, applicability = \"maybe-incorrect\")]\n+#[multipart_suggestion(suggestion_no_fields_for_fn, applicability = \"maybe-incorrect\")]\n pub(crate) struct NoFieldsForFnCall {\n     #[suggestion_part(code = \"\")]\n     pub fields: Vec<Span>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::labeled_loop_in_break)]\n+#[diag(parser_labeled_loop_in_break)]\n pub(crate) struct LabeledLoopInBreak {\n     #[primary_span]\n     pub span: Span,\n@@ -633,7 +621,7 @@ pub(crate) struct LabeledLoopInBreak {\n \n #[derive(Subdiagnostic)]\n #[multipart_suggestion(\n-    parser::sugg_wrap_expression_in_parentheses,\n+    parser_sugg_wrap_expression_in_parentheses,\n     applicability = \"machine-applicable\"\n )]\n pub(crate) struct WrapExpressionInParentheses {\n@@ -644,7 +632,7 @@ pub(crate) struct WrapExpressionInParentheses {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::array_brackets_instead_of_braces)]\n+#[diag(parser_array_brackets_instead_of_braces)]\n pub(crate) struct ArrayBracketsInsteadOfSpaces {\n     #[primary_span]\n     pub span: Span,\n@@ -653,7 +641,7 @@ pub(crate) struct ArrayBracketsInsteadOfSpaces {\n }\n \n #[derive(Subdiagnostic)]\n-#[multipart_suggestion(parser::suggestion, applicability = \"maybe-incorrect\")]\n+#[multipart_suggestion(suggestion, applicability = \"maybe-incorrect\")]\n pub(crate) struct ArrayBracketsInsteadOfSpacesSugg {\n     #[suggestion_part(code = \"[\")]\n     pub left: Span,\n@@ -662,12 +650,12 @@ pub(crate) struct ArrayBracketsInsteadOfSpacesSugg {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::match_arm_body_without_braces)]\n+#[diag(parser_match_arm_body_without_braces)]\n pub(crate) struct MatchArmBodyWithoutBraces {\n     #[primary_span]\n-    #[label(parser::label_statements)]\n+    #[label(label_statements)]\n     pub statements: Span,\n-    #[label(parser::label_arrow)]\n+    #[label(label_arrow)]\n     pub arrow: Span,\n     pub num_statements: usize,\n     #[subdiagnostic]\n@@ -676,15 +664,15 @@ pub(crate) struct MatchArmBodyWithoutBraces {\n \n #[derive(Subdiagnostic)]\n pub(crate) enum MatchArmBodyWithoutBracesSugg {\n-    #[multipart_suggestion(parser::suggestion_add_braces, applicability = \"machine-applicable\")]\n+    #[multipart_suggestion(suggestion_add_braces, applicability = \"machine-applicable\")]\n     AddBraces {\n         #[suggestion_part(code = \"{{ \")]\n         left: Span,\n         #[suggestion_part(code = \" }}\")]\n         right: Span,\n     },\n     #[suggestion(\n-        parser::suggestion_use_comma_not_semicolon,\n+        suggestion_use_comma_not_semicolon,\n         code = \",\",\n         applicability = \"machine-applicable\"\n     )]\n@@ -695,7 +683,7 @@ pub(crate) enum MatchArmBodyWithoutBracesSugg {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::struct_literal_not_allowed_here)]\n+#[diag(parser_struct_literal_not_allowed_here)]\n pub(crate) struct StructLiteralNotAllowedHere {\n     #[primary_span]\n     pub span: Span,\n@@ -704,7 +692,7 @@ pub(crate) struct StructLiteralNotAllowedHere {\n }\n \n #[derive(Subdiagnostic)]\n-#[multipart_suggestion(parser::suggestion, applicability = \"machine-applicable\")]\n+#[multipart_suggestion(suggestion, applicability = \"machine-applicable\")]\n pub(crate) struct StructLiteralNotAllowedHereSugg {\n     #[suggestion_part(code = \"(\")]\n     pub left: Span,\n@@ -713,38 +701,38 @@ pub(crate) struct StructLiteralNotAllowedHereSugg {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::invalid_interpolated_expression)]\n+#[diag(parser_invalid_interpolated_expression)]\n pub(crate) struct InvalidInterpolatedExpression {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::hexadecimal_float_literal_not_supported)]\n+#[diag(parser_hexadecimal_float_literal_not_supported)]\n pub(crate) struct HexadecimalFloatLiteralNotSupported {\n     #[primary_span]\n-    #[label(parser::not_supported)]\n+    #[label(parser_not_supported)]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::octal_float_literal_not_supported)]\n+#[diag(parser_octal_float_literal_not_supported)]\n pub(crate) struct OctalFloatLiteralNotSupported {\n     #[primary_span]\n-    #[label(parser::not_supported)]\n+    #[label(parser_not_supported)]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::binary_float_literal_not_supported)]\n+#[diag(parser_binary_float_literal_not_supported)]\n pub(crate) struct BinaryFloatLiteralNotSupported {\n     #[primary_span]\n-    #[label(parser::not_supported)]\n+    #[label(parser_not_supported)]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::invalid_literal_suffix)]\n+#[diag(parser_invalid_literal_suffix)]\n pub(crate) struct InvalidLiteralSuffix {\n     #[primary_span]\n     #[label]\n@@ -755,42 +743,42 @@ pub(crate) struct InvalidLiteralSuffix {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::invalid_literal_suffix_on_tuple_index)]\n+#[diag(parser_invalid_literal_suffix_on_tuple_index)]\n pub(crate) struct InvalidLiteralSuffixOnTupleIndex {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n     pub suffix: Symbol,\n-    #[help(parser::tuple_exception_line_1)]\n-    #[help(parser::tuple_exception_line_2)]\n-    #[help(parser::tuple_exception_line_3)]\n+    #[help(tuple_exception_line_1)]\n+    #[help(tuple_exception_line_2)]\n+    #[help(tuple_exception_line_3)]\n     pub exception: Option<()>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::non_string_abi_literal)]\n+#[diag(parser_non_string_abi_literal)]\n pub(crate) struct NonStringAbiLiteral {\n     #[primary_span]\n     #[suggestion(code = \"\\\"C\\\"\", applicability = \"maybe-incorrect\")]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::mismatched_closing_delimiter)]\n+#[diag(parser_mismatched_closing_delimiter)]\n pub(crate) struct MismatchedClosingDelimiter {\n     #[primary_span]\n     pub spans: Vec<Span>,\n     pub delimiter: String,\n-    #[label(parser::label_unmatched)]\n+    #[label(label_unmatched)]\n     pub unmatched: Span,\n-    #[label(parser::label_opening_candidate)]\n+    #[label(label_opening_candidate)]\n     pub opening_candidate: Option<Span>,\n-    #[label(parser::label_unclosed)]\n+    #[label(label_unclosed)]\n     pub unclosed: Option<Span>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::incorrect_visibility_restriction, code = \"E0704\")]\n+#[diag(parser_incorrect_visibility_restriction, code = \"E0704\")]\n #[help]\n pub(crate) struct IncorrectVisibilityRestriction {\n     #[primary_span]\n@@ -800,21 +788,21 @@ pub(crate) struct IncorrectVisibilityRestriction {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::assignment_else_not_allowed)]\n+#[diag(parser_assignment_else_not_allowed)]\n pub(crate) struct AssignmentElseNotAllowed {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::expected_statement_after_outer_attr)]\n+#[diag(parser_expected_statement_after_outer_attr)]\n pub(crate) struct ExpectedStatementAfterOuterAttr {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::doc_comment_does_not_document_anything, code = \"E0585\")]\n+#[diag(parser_doc_comment_does_not_document_anything, code = \"E0585\")]\n #[help]\n pub(crate) struct DocCommentDoesNotDocumentAnything {\n     #[primary_span]\n@@ -824,15 +812,15 @@ pub(crate) struct DocCommentDoesNotDocumentAnything {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::const_let_mutually_exclusive)]\n+#[diag(parser_const_let_mutually_exclusive)]\n pub(crate) struct ConstLetMutuallyExclusive {\n     #[primary_span]\n     #[suggestion(code = \"const\", applicability = \"maybe-incorrect\")]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::invalid_expression_in_let_else)]\n+#[diag(parser_invalid_expression_in_let_else)]\n pub(crate) struct InvalidExpressionInLetElse {\n     #[primary_span]\n     pub span: Span,\n@@ -842,7 +830,7 @@ pub(crate) struct InvalidExpressionInLetElse {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::invalid_curly_in_let_else)]\n+#[diag(parser_invalid_curly_in_let_else)]\n pub(crate) struct InvalidCurlyInLetElse {\n     #[primary_span]\n     pub span: Span,\n@@ -851,7 +839,7 @@ pub(crate) struct InvalidCurlyInLetElse {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::compound_assignment_expression_in_let)]\n+#[diag(parser_compound_assignment_expression_in_let)]\n #[help]\n pub(crate) struct CompoundAssignmentExpressionInLet {\n     #[primary_span]\n@@ -860,15 +848,15 @@ pub(crate) struct CompoundAssignmentExpressionInLet {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::suffixed_literal_in_attribute)]\n+#[diag(parser_suffixed_literal_in_attribute)]\n #[help]\n pub(crate) struct SuffixedLiteralInAttribute {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::invalid_meta_item)]\n+#[diag(parser_invalid_meta_item)]\n pub(crate) struct InvalidMetaItem {\n     #[primary_span]\n     pub span: Span,\n@@ -877,7 +865,7 @@ pub(crate) struct InvalidMetaItem {\n \n #[derive(Subdiagnostic)]\n #[suggestion_verbose(\n-    parser::sugg_escape_to_use_as_identifier,\n+    parser_sugg_escape_to_use_as_identifier,\n     applicability = \"maybe-incorrect\",\n     code = \"r#\"\n )]\n@@ -888,23 +876,23 @@ pub(crate) struct SuggEscapeToUseAsIdentifier {\n }\n \n #[derive(Subdiagnostic)]\n-#[suggestion(parser::sugg_remove_comma, applicability = \"machine-applicable\", code = \"\")]\n+#[suggestion(parser_sugg_remove_comma, applicability = \"machine-applicable\", code = \"\")]\n pub(crate) struct SuggRemoveComma {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Subdiagnostic)]\n pub(crate) enum ExpectedIdentifierFound {\n-    #[label(parser::expected_identifier_found_reserved_identifier)]\n+    #[label(parser_expected_identifier_found_reserved_identifier)]\n     ReservedIdentifier(#[primary_span] Span),\n-    #[label(parser::expected_identifier_found_keyword)]\n+    #[label(parser_expected_identifier_found_keyword)]\n     Keyword(#[primary_span] Span),\n-    #[label(parser::expected_identifier_found_reserved_keyword)]\n+    #[label(parser_expected_identifier_found_reserved_keyword)]\n     ReservedKeyword(#[primary_span] Span),\n-    #[label(parser::expected_identifier_found_doc_comment)]\n+    #[label(parser_expected_identifier_found_doc_comment)]\n     DocComment(#[primary_span] Span),\n-    #[label(parser::expected_identifier)]\n+    #[label(parser_expected_identifier)]\n     Other(#[primary_span] Span),\n }\n \n@@ -938,18 +926,16 @@ impl<'a, G: EmissionGuarantee> IntoDiagnostic<'a, G> for ExpectedIdentifier {\n \n         let mut diag = handler.struct_diagnostic(match token_descr {\n             Some(TokenDescription::ReservedIdentifier) => {\n-                fluent::parser::expected_identifier_found_reserved_identifier_str\n-            }\n-            Some(TokenDescription::Keyword) => {\n-                fluent::parser::expected_identifier_found_keyword_str\n+                fluent::parser_expected_identifier_found_reserved_identifier_str\n             }\n+            Some(TokenDescription::Keyword) => fluent::parser_expected_identifier_found_keyword_str,\n             Some(TokenDescription::ReservedKeyword) => {\n-                fluent::parser::expected_identifier_found_reserved_keyword_str\n+                fluent::parser_expected_identifier_found_reserved_keyword_str\n             }\n             Some(TokenDescription::DocComment) => {\n-                fluent::parser::expected_identifier_found_doc_comment_str\n+                fluent::parser_expected_identifier_found_doc_comment_str\n             }\n-            None => fluent::parser::expected_identifier_found_str,\n+            None => fluent::parser_expected_identifier_found_str,\n         });\n         diag.set_span(self.span);\n         diag.set_arg(\"token\", self.token);\n@@ -985,22 +971,22 @@ impl<'a, G: EmissionGuarantee> IntoDiagnostic<'a, G> for ExpectedSemi {\n \n         let mut diag = handler.struct_diagnostic(match token_descr {\n             Some(TokenDescription::ReservedIdentifier) => {\n-                fluent::parser::expected_semi_found_reserved_identifier_str\n+                fluent::parser_expected_semi_found_reserved_identifier_str\n             }\n-            Some(TokenDescription::Keyword) => fluent::parser::expected_semi_found_keyword_str,\n+            Some(TokenDescription::Keyword) => fluent::parser_expected_semi_found_keyword_str,\n             Some(TokenDescription::ReservedKeyword) => {\n-                fluent::parser::expected_semi_found_reserved_keyword_str\n+                fluent::parser_expected_semi_found_reserved_keyword_str\n             }\n             Some(TokenDescription::DocComment) => {\n-                fluent::parser::expected_semi_found_doc_comment_str\n+                fluent::parser_expected_semi_found_doc_comment_str\n             }\n-            None => fluent::parser::expected_semi_found_str,\n+            None => fluent::parser_expected_semi_found_str,\n         });\n         diag.set_span(self.span);\n         diag.set_arg(\"token\", self.token);\n \n         if let Some(unexpected_token_label) = self.unexpected_token_label {\n-            diag.span_label(unexpected_token_label, fluent::parser::label_unexpected_token);\n+            diag.span_label(unexpected_token_label, fluent::parser_label_unexpected_token);\n         }\n \n         self.sugg.add_to_diagnostic(&mut diag);\n@@ -1012,17 +998,17 @@ impl<'a, G: EmissionGuarantee> IntoDiagnostic<'a, G> for ExpectedSemi {\n #[derive(Subdiagnostic)]\n pub(crate) enum ExpectedSemiSugg {\n     #[suggestion(\n-        parser::sugg_change_this_to_semi,\n+        parser_sugg_change_this_to_semi,\n         code = \";\",\n         applicability = \"machine-applicable\"\n     )]\n     ChangeToSemi(#[primary_span] Span),\n-    #[suggestion_short(parser::sugg_add_semi, code = \";\", applicability = \"machine-applicable\")]\n+    #[suggestion_short(parser_sugg_add_semi, code = \";\", applicability = \"machine-applicable\")]\n     AddSemi(#[primary_span] Span),\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::struct_literal_body_without_path)]\n+#[diag(parser_struct_literal_body_without_path)]\n pub(crate) struct StructLiteralBodyWithoutPath {\n     #[primary_span]\n     pub span: Span,\n@@ -1031,7 +1017,7 @@ pub(crate) struct StructLiteralBodyWithoutPath {\n }\n \n #[derive(Subdiagnostic)]\n-#[multipart_suggestion(parser::suggestion, applicability = \"has-placeholders\")]\n+#[multipart_suggestion(suggestion, applicability = \"has-placeholders\")]\n pub(crate) struct StructLiteralBodyWithoutPathSugg {\n     #[suggestion_part(code = \"{{ SomeStruct \")]\n     pub before: Span,\n@@ -1040,7 +1026,7 @@ pub(crate) struct StructLiteralBodyWithoutPathSugg {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::unmatched_angle_brackets)]\n+#[diag(parser_unmatched_angle_brackets)]\n pub(crate) struct UnmatchedAngleBrackets {\n     #[primary_span]\n     #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n@@ -1049,7 +1035,7 @@ pub(crate) struct UnmatchedAngleBrackets {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::generic_parameters_without_angle_brackets)]\n+#[diag(parser_generic_parameters_without_angle_brackets)]\n pub(crate) struct GenericParamsWithoutAngleBrackets {\n     #[primary_span]\n     pub span: Span,\n@@ -1058,7 +1044,7 @@ pub(crate) struct GenericParamsWithoutAngleBrackets {\n }\n \n #[derive(Subdiagnostic)]\n-#[multipart_suggestion(parser::suggestion, applicability = \"machine-applicable\")]\n+#[multipart_suggestion(suggestion, applicability = \"machine-applicable\")]\n pub(crate) struct GenericParamsWithoutAngleBracketsSugg {\n     #[suggestion_part(code = \"<\")]\n     pub left: Span,\n@@ -1067,18 +1053,18 @@ pub(crate) struct GenericParamsWithoutAngleBracketsSugg {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::comparison_operators_cannot_be_chained)]\n+#[diag(parser_comparison_operators_cannot_be_chained)]\n pub(crate) struct ComparisonOperatorsCannotBeChained {\n     #[primary_span]\n     pub span: Vec<Span>,\n     #[suggestion_verbose(\n-        parser::sugg_turbofish_syntax,\n+        parser_sugg_turbofish_syntax,\n         code = \"::\",\n         applicability = \"maybe-incorrect\"\n     )]\n     pub suggest_turbofish: Option<Span>,\n-    #[help(parser::sugg_turbofish_syntax)]\n-    #[help(parser::sugg_parentheses_for_function_args)]\n+    #[help(parser_sugg_turbofish_syntax)]\n+    #[help(sugg_parentheses_for_function_args)]\n     pub help_turbofish: Option<()>,\n     #[subdiagnostic]\n     pub chaining_sugg: Option<ComparisonOperatorsCannotBeChainedSugg>,\n@@ -1087,7 +1073,7 @@ pub(crate) struct ComparisonOperatorsCannotBeChained {\n #[derive(Subdiagnostic)]\n pub(crate) enum ComparisonOperatorsCannotBeChainedSugg {\n     #[suggestion_verbose(\n-        parser::sugg_split_comparison,\n+        sugg_split_comparison,\n         code = \" && {middle_term}\",\n         applicability = \"maybe-incorrect\"\n     )]\n@@ -1096,7 +1082,7 @@ pub(crate) enum ComparisonOperatorsCannotBeChainedSugg {\n         span: Span,\n         middle_term: String,\n     },\n-    #[multipart_suggestion(parser::sugg_parenthesize, applicability = \"maybe-incorrect\")]\n+    #[multipart_suggestion(sugg_parenthesize, applicability = \"maybe-incorrect\")]\n     Parenthesize {\n         #[suggestion_part(code = \"(\")]\n         left: Span,\n@@ -1106,7 +1092,7 @@ pub(crate) enum ComparisonOperatorsCannotBeChainedSugg {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::question_mark_in_type)]\n+#[diag(parser_question_mark_in_type)]\n pub(crate) struct QuestionMarkInType {\n     #[primary_span]\n     #[label]\n@@ -1116,7 +1102,7 @@ pub(crate) struct QuestionMarkInType {\n }\n \n #[derive(Subdiagnostic)]\n-#[multipart_suggestion(parser::suggestion, applicability = \"machine-applicable\")]\n+#[multipart_suggestion(suggestion, applicability = \"machine-applicable\")]\n pub(crate) struct QuestionMarkInTypeSugg {\n     #[suggestion_part(code = \"Option<\")]\n     pub left: Span,\n@@ -1125,7 +1111,7 @@ pub(crate) struct QuestionMarkInTypeSugg {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::unexpected_parentheses_in_for_head)]\n+#[diag(parser_unexpected_parentheses_in_for_head)]\n pub(crate) struct ParenthesesInForHead {\n     #[primary_span]\n     pub span: Vec<Span>,\n@@ -1134,7 +1120,7 @@ pub(crate) struct ParenthesesInForHead {\n }\n \n #[derive(Subdiagnostic)]\n-#[multipart_suggestion(parser::suggestion, applicability = \"machine-applicable\")]\n+#[multipart_suggestion(suggestion, applicability = \"machine-applicable\")]\n pub(crate) struct ParenthesesInForHeadSugg {\n     #[suggestion_part(code = \"\")]\n     pub left: Span,\n@@ -1143,39 +1129,39 @@ pub(crate) struct ParenthesesInForHeadSugg {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::doc_comment_on_param_type)]\n+#[diag(parser_doc_comment_on_param_type)]\n pub(crate) struct DocCommentOnParamType {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::attribute_on_param_type)]\n+#[diag(parser_attribute_on_param_type)]\n pub(crate) struct AttributeOnParamType {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::pattern_method_param_without_body, code = \"E0642\")]\n+#[diag(parser_pattern_method_param_without_body, code = \"E0642\")]\n pub(crate) struct PatternMethodParamWithoutBody {\n     #[primary_span]\n     #[suggestion(code = \"_\", applicability = \"machine-applicable\")]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::self_param_not_first)]\n+#[diag(parser_self_param_not_first)]\n pub(crate) struct SelfParamNotFirst {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::const_generic_without_braces)]\n+#[diag(parser_const_generic_without_braces)]\n pub(crate) struct ConstGenericWithoutBraces {\n     #[primary_span]\n     pub span: Span,\n@@ -1184,7 +1170,7 @@ pub(crate) struct ConstGenericWithoutBraces {\n }\n \n #[derive(Subdiagnostic)]\n-#[multipart_suggestion(parser::suggestion, applicability = \"machine-applicable\")]\n+#[multipart_suggestion(suggestion, applicability = \"machine-applicable\")]\n pub(crate) struct ConstGenericWithoutBracesSugg {\n     #[suggestion_part(code = \"{{ \")]\n     pub left: Span,\n@@ -1193,7 +1179,7 @@ pub(crate) struct ConstGenericWithoutBracesSugg {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::unexpected_const_param_declaration)]\n+#[diag(parser_unexpected_const_param_declaration)]\n pub(crate) struct UnexpectedConstParamDeclaration {\n     #[primary_span]\n     #[label]\n@@ -1204,7 +1190,7 @@ pub(crate) struct UnexpectedConstParamDeclaration {\n \n #[derive(Subdiagnostic)]\n pub(crate) enum UnexpectedConstParamDeclarationSugg {\n-    #[multipart_suggestion(parser::suggestion, applicability = \"machine-applicable\")]\n+    #[multipart_suggestion(suggestion, applicability = \"machine-applicable\")]\n     AddParam {\n         #[suggestion_part(code = \"<{snippet}>\")]\n         impl_generics: Span,\n@@ -1213,7 +1199,7 @@ pub(crate) enum UnexpectedConstParamDeclarationSugg {\n         snippet: String,\n         ident: String,\n     },\n-    #[multipart_suggestion(parser::suggestion, applicability = \"machine-applicable\")]\n+    #[multipart_suggestion(suggestion, applicability = \"machine-applicable\")]\n     AppendParam {\n         #[suggestion_part(code = \", {snippet}\")]\n         impl_generics_end: Span,\n@@ -1225,7 +1211,7 @@ pub(crate) enum UnexpectedConstParamDeclarationSugg {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::unexpected_const_in_generic_param)]\n+#[diag(parser_unexpected_const_in_generic_param)]\n pub(crate) struct UnexpectedConstInGenericParam {\n     #[primary_span]\n     pub span: Span,\n@@ -1234,15 +1220,15 @@ pub(crate) struct UnexpectedConstInGenericParam {\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::async_move_order_incorrect)]\n+#[diag(parser_async_move_order_incorrect)]\n pub(crate) struct AsyncMoveOrderIncorrect {\n     #[primary_span]\n     #[suggestion_verbose(code = \"async move\", applicability = \"maybe-incorrect\")]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(parser::double_colon_in_bound)]\n+#[diag(parser_double_colon_in_bound)]\n pub(crate) struct DoubleColonInBound {\n     #[primary_span]\n     pub span: Span,"}, {"sha": "462bce16ad717d424c9a16185f9405d41f19646b", "filename": "compiler/rustc_parse/src/lexer/mod.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -3,7 +3,9 @@ use rustc_ast::ast::{self, AttrStyle};\n use rustc_ast::token::{self, CommentKind, Delimiter, Token, TokenKind};\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::util::unicode::contains_text_flow_control_chars;\n-use rustc_errors::{error_code, Applicability, DiagnosticBuilder, ErrorGuaranteed, PResult};\n+use rustc_errors::{\n+    error_code, Applicability, DiagnosticBuilder, ErrorGuaranteed, PResult, StashKey,\n+};\n use rustc_lexer::unescape::{self, Mode};\n use rustc_lexer::Cursor;\n use rustc_lexer::{Base, DocStyle, RawStrError};\n@@ -203,7 +205,10 @@ impl<'a> StringReader<'a> {\n                     // this is necessary.\n                     let lifetime_name = self.str_from(start);\n                     if starts_with_number {\n-                        self.err_span_(start, self.pos, \"lifetimes cannot start with a number\");\n+                        let span = self.mk_sp(start, self.pos);\n+                        let mut diag = self.sess.struct_err(\"lifetimes cannot start with a number\");\n+                        diag.set_span(span);\n+                        diag.stash(span, StashKey::LifetimeIsChar);\n                     }\n                     let ident = Symbol::intern(lifetime_name);\n                     token::Lifetime(ident)"}, {"sha": "f075de714267688eb0711fe0e631f14cb9c485d3", "filename": "compiler/rustc_parse/src/lexer/unescape_error_reporting.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funescape_error_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funescape_error_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funescape_error_reporting.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -113,11 +113,26 @@ pub(crate) fn emit_unescape_error(\n                 } else {\n                     (\"\", \"if you meant to write a `str` literal, use double quotes\")\n                 };\n-\n+                let mut escaped = String::with_capacity(lit.len());\n+                let mut chrs = lit.chars().peekable();\n+                while let Some(first) = chrs.next() {\n+                    match (first, chrs.peek()) {\n+                        ('\\\\', Some('\"')) => {\n+                            escaped.push('\\\\');\n+                            escaped.push('\"');\n+                            chrs.next();\n+                        }\n+                        ('\"', _) => {\n+                            escaped.push('\\\\');\n+                            escaped.push('\"')\n+                        }\n+                        (c, _) => escaped.push(c),\n+                    };\n+                }\n                 handler.span_suggestion(\n                     span_with_quotes,\n                     msg,\n-                    format!(\"{}\\\"{}\\\"\", prefix, lit),\n+                    format!(\"{prefix}\\\"{escaped}\\\"\"),\n                     Applicability::MachineApplicable,\n                 );\n             }"}, {"sha": "9e45656946b34fe9f86075c103b1cab51a6469dd", "filename": "compiler/rustc_parse/src/parser/attr.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -55,7 +55,7 @@ impl<'a> Parser<'a> {\n                     let span = self.token.span;\n                     let mut err = self.sess.span_diagnostic.struct_span_err_with_code(\n                         span,\n-                        fluent::parser::inner_doc_comment_not_permitted,\n+                        fluent::parser_inner_doc_comment_not_permitted,\n                         error_code!(E0753),\n                     );\n                     if let Some(replacement_span) = self.annotate_following_item_if_applicable(\n@@ -66,10 +66,10 @@ impl<'a> Parser<'a> {\n                             token::CommentKind::Block => OuterAttributeType::DocBlockComment,\n                         },\n                     ) {\n-                        err.note(fluent::parser::note);\n+                        err.note(fluent::note);\n                         err.span_suggestion_verbose(\n                             replacement_span,\n-                            fluent::parser::suggestion,\n+                            fluent::suggestion,\n                             \"\",\n                             rustc_errors::Applicability::MachineApplicable,\n                         );\n@@ -173,10 +173,10 @@ impl<'a> Parser<'a> {\n             Ok(Some(item)) => {\n                 // FIXME(#100717)\n                 err.set_arg(\"item\", item.kind.descr());\n-                err.span_label(item.span, fluent::parser::label_does_not_annotate_this);\n+                err.span_label(item.span, fluent::label_does_not_annotate_this);\n                 err.span_suggestion_verbose(\n                     replacement_span,\n-                    fluent::parser::sugg_change_inner_to_outer,\n+                    fluent::sugg_change_inner_to_outer,\n                     match attr_type {\n                         OuterAttributeType::Attribute => \"\",\n                         OuterAttributeType::DocBlockComment => \"*\",\n@@ -200,27 +200,27 @@ impl<'a> Parser<'a> {\n                 Some(InnerAttrForbiddenReason::AfterOuterDocComment { prev_doc_comment_span }) => {\n                     let mut diag = self.struct_span_err(\n                         attr_sp,\n-                        fluent::parser::inner_attr_not_permitted_after_outer_doc_comment,\n+                        fluent::parser_inner_attr_not_permitted_after_outer_doc_comment,\n                     );\n-                    diag.span_label(attr_sp, fluent::parser::label_attr)\n-                        .span_label(prev_doc_comment_span, fluent::parser::label_prev_doc_comment);\n+                    diag.span_label(attr_sp, fluent::label_attr)\n+                        .span_label(prev_doc_comment_span, fluent::label_prev_doc_comment);\n                     diag\n                 }\n                 Some(InnerAttrForbiddenReason::AfterOuterAttribute { prev_outer_attr_sp }) => {\n                     let mut diag = self.struct_span_err(\n                         attr_sp,\n-                        fluent::parser::inner_attr_not_permitted_after_outer_attr,\n+                        fluent::parser_inner_attr_not_permitted_after_outer_attr,\n                     );\n-                    diag.span_label(attr_sp, fluent::parser::label_attr)\n-                        .span_label(prev_outer_attr_sp, fluent::parser::label_prev_attr);\n+                    diag.span_label(attr_sp, fluent::label_attr)\n+                        .span_label(prev_outer_attr_sp, fluent::label_prev_attr);\n                     diag\n                 }\n                 Some(InnerAttrForbiddenReason::InCodeBlock) | None => {\n-                    self.struct_span_err(attr_sp, fluent::parser::inner_attr_not_permitted)\n+                    self.struct_span_err(attr_sp, fluent::parser_inner_attr_not_permitted)\n                 }\n             };\n \n-            diag.note(fluent::parser::inner_attr_explanation);\n+            diag.note(fluent::parser_inner_attr_explanation);\n             if self\n                 .annotate_following_item_if_applicable(\n                     &mut diag,\n@@ -229,7 +229,7 @@ impl<'a> Parser<'a> {\n                 )\n                 .is_some()\n             {\n-                diag.note(fluent::parser::outer_attr_explanation);\n+                diag.note(fluent::parser_outer_attr_explanation);\n             };\n             diag.emit();\n         }"}, {"sha": "1b16ecb5ec2d6434a52cfc86a5e7b9fabb966a1f", "filename": "compiler/rustc_parse/src/parser/attr_wrapper.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -273,16 +273,23 @@ impl<'a> Parser<'a> {\n         let cursor_snapshot_next_calls = cursor_snapshot.num_next_calls;\n         let mut end_pos = self.token_cursor.num_next_calls;\n \n+        let mut captured_trailing = false;\n+\n         // Capture a trailing token if requested by the callback 'f'\n         match trailing {\n             TrailingToken::None => {}\n+            TrailingToken::Gt => {\n+                assert_eq!(self.token.kind, token::Gt);\n+            }\n             TrailingToken::Semi => {\n                 assert_eq!(self.token.kind, token::Semi);\n                 end_pos += 1;\n+                captured_trailing = true;\n             }\n             TrailingToken::MaybeComma => {\n                 if self.token.kind == token::Comma {\n                     end_pos += 1;\n+                    captured_trailing = true;\n                 }\n             }\n         }\n@@ -292,11 +299,7 @@ impl<'a> Parser<'a> {\n         // was not actually bumped past it. When the `LazyAttrTokenStream` gets converted\n         // into an `AttrTokenStream`, we will create the proper token.\n         if self.token_cursor.break_last_token {\n-            assert_eq!(\n-                trailing,\n-                TrailingToken::None,\n-                \"Cannot set `break_last_token` and have trailing token\"\n-            );\n+            assert!(!captured_trailing, \"Cannot set break_last_token and have trailing token\");\n             end_pos += 1;\n         }\n "}, {"sha": "887a4a6de33b1c3d7722763c63a7de85bf0c44b6", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -926,7 +926,7 @@ impl<'a> Parser<'a> {\n                     if self.eat(&token::Gt) {\n                         e.span_suggestion_verbose(\n                             binop.span.shrink_to_lo(),\n-                            fluent::parser::sugg_turbofish_syntax,\n+                            fluent::parser_sugg_turbofish_syntax,\n                             \"::\",\n                             Applicability::MaybeIncorrect,\n                         )\n@@ -1374,9 +1374,17 @@ impl<'a> Parser<'a> {\n         kind: IncDecRecovery,\n         (pre_span, post_span): (Span, Span),\n     ) -> MultiSugg {\n+        let mut patches = Vec::new();\n+\n+        if !pre_span.is_empty() {\n+            patches.push((pre_span, String::new()));\n+        }\n+\n+        patches.push((post_span, format!(\" {}= 1\", kind.op.chr())));\n+\n         MultiSugg {\n             msg: format!(\"use `{}= 1` instead\", kind.op.chr()),\n-            patches: vec![(pre_span, String::new()), (post_span, format!(\" {}= 1\", kind.op.chr()))],\n+            patches,\n             applicability: Applicability::MachineApplicable,\n         }\n     }"}, {"sha": "ca216b1cd1008ed039331ac998240a4d15dcec76", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 73, "deletions": 9, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -42,8 +42,10 @@ use rustc_ast::{AnonConst, BinOp, BinOpKind, FnDecl, FnRetTy, MacCall, Param, Ty\n use rustc_ast::{Arm, Async, BlockCheckMode, Expr, ExprKind, Label, Movability, RangeLimits};\n use rustc_ast::{ClosureBinder, StmtKind};\n use rustc_ast_pretty::pprust;\n-use rustc_errors::IntoDiagnostic;\n-use rustc_errors::{Applicability, Diagnostic, PResult};\n+use rustc_errors::{\n+    Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, IntoDiagnostic, PResult,\n+    StashKey,\n+};\n use rustc_session::errors::ExprParenthesesNeeded;\n use rustc_session::lint::builtin::BREAK_WITH_LABEL_AND_LOOP;\n use rustc_session::lint::BuiltinLintDiagnostics;\n@@ -1513,11 +1515,11 @@ impl<'a> Parser<'a> {\n     /// Parse `'label: $expr`. The label is already parsed.\n     fn parse_labeled_expr(\n         &mut self,\n-        label: Label,\n+        label_: Label,\n         mut consume_colon: bool,\n     ) -> PResult<'a, P<Expr>> {\n-        let lo = label.ident.span;\n-        let label = Some(label);\n+        let lo = label_.ident.span;\n+        let label = Some(label_);\n         let ate_colon = self.eat(&token::Colon);\n         let expr = if self.eat_keyword(kw::While) {\n             self.parse_while_expr(label, lo)\n@@ -1529,6 +1531,19 @@ impl<'a> Parser<'a> {\n             || self.token.is_whole_block()\n         {\n             self.parse_block_expr(label, lo, BlockCheckMode::Default)\n+        } else if !ate_colon\n+            && (matches!(self.token.kind, token::CloseDelim(_) | token::Comma)\n+                || self.token.is_op())\n+        {\n+            let lit = self.recover_unclosed_char(label_.ident, |self_| {\n+                self_.sess.create_err(UnexpectedTokenAfterLabel {\n+                    span: self_.token.span,\n+                    remove_label: None,\n+                    enclose_in_block: None,\n+                })\n+            });\n+            consume_colon = false;\n+            Ok(self.mk_expr(lo, ExprKind::Lit(lit)))\n         } else if !ate_colon\n             && (self.check_noexpect(&TokenKind::Comma) || self.check_noexpect(&TokenKind::Gt))\n         {\n@@ -1603,6 +1618,39 @@ impl<'a> Parser<'a> {\n         Ok(expr)\n     }\n \n+    /// Emit an error when a char is parsed as a lifetime because of a missing quote\n+    pub(super) fn recover_unclosed_char(\n+        &mut self,\n+        lifetime: Ident,\n+        err: impl FnOnce(&mut Self) -> DiagnosticBuilder<'a, ErrorGuaranteed>,\n+    ) -> ast::Lit {\n+        if let Some(mut diag) =\n+            self.sess.span_diagnostic.steal_diagnostic(lifetime.span, StashKey::LifetimeIsChar)\n+        {\n+            diag.span_suggestion_verbose(\n+                lifetime.span.shrink_to_hi(),\n+                \"add `'` to close the char literal\",\n+                \"'\",\n+                Applicability::MaybeIncorrect,\n+            )\n+            .emit();\n+        } else {\n+            err(self)\n+                .span_suggestion_verbose(\n+                    lifetime.span.shrink_to_hi(),\n+                    \"add `'` to close the char literal\",\n+                    \"'\",\n+                    Applicability::MaybeIncorrect,\n+                )\n+                .emit();\n+        }\n+        ast::Lit {\n+            token_lit: token::Lit::new(token::LitKind::Char, lifetime.name, None),\n+            kind: ast::LitKind::Char(lifetime.name.as_str().chars().next().unwrap_or('_')),\n+            span: lifetime.span,\n+        }\n+    }\n+\n     /// Recover on the syntax `do catch { ... }` suggesting `try { ... }` instead.\n     fn recover_do_catch(&mut self) -> PResult<'a, P<Expr>> {\n         let lo = self.token.span;\n@@ -1728,7 +1776,7 @@ impl<'a> Parser<'a> {\n     }\n \n     pub(super) fn parse_lit(&mut self) -> PResult<'a, Lit> {\n-        self.parse_opt_lit().ok_or_else(|| {\n+        self.parse_opt_lit().ok_or(()).or_else(|()| {\n             if let token::Interpolated(inner) = &self.token.kind {\n                 let expr = match inner.as_ref() {\n                     token::NtExpr(expr) => Some(expr),\n@@ -1740,12 +1788,22 @@ impl<'a> Parser<'a> {\n                         let mut err = InvalidInterpolatedExpression { span: self.token.span }\n                             .into_diagnostic(&self.sess.span_diagnostic);\n                         err.downgrade_to_delayed_bug();\n-                        return err;\n+                        return Err(err);\n                     }\n                 }\n             }\n-            let msg = format!(\"unexpected token: {}\", super::token_descr(&self.token));\n-            self.struct_span_err(self.token.span, &msg)\n+            let token = self.token.clone();\n+            let err = |self_: &mut Self| {\n+                let msg = format!(\"unexpected token: {}\", super::token_descr(&token));\n+                self_.struct_span_err(token.span, &msg)\n+            };\n+            // On an error path, eagerly consider a lifetime to be an unclosed character lit\n+            if self.token.is_lifetime() {\n+                let lt = self.expect_lifetime();\n+                Ok(self.recover_unclosed_char(lt.ident, err))\n+            } else {\n+                Err(err(self))\n+            }\n         })\n     }\n \n@@ -2051,6 +2109,10 @@ impl<'a> Parser<'a> {\n \n         if self.token.kind == TokenKind::Semi\n             && matches!(self.token_cursor.frame.delim_sp, Some((Delimiter::Parenthesis, _)))\n+            // HACK: This is needed so we can detect whether we're inside a macro,\n+            // where regular assumptions about what tokens can follow other tokens\n+            // don't necessarily apply.\n+            && self.subparser_name.is_none()\n         {\n             // It is likely that the closure body is a block but where the\n             // braces have been removed. We will recover and eat the next\n@@ -3080,6 +3142,8 @@ impl<'a> Parser<'a> {\n                 && this.token.kind == token::Semi\n             {\n                 TrailingToken::Semi\n+            } else if this.token.kind == token::Gt {\n+                TrailingToken::Gt\n             } else {\n                 // FIXME - pass this through from the place where we know\n                 // we need a comma, rather than assuming that `#[attr] expr,`"}, {"sha": "89c24920f857d1e9672e52a92cf47c62ac852bb0", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -79,6 +79,7 @@ pub enum ForceCollect {\n pub enum TrailingToken {\n     None,\n     Semi,\n+    Gt,\n     /// If the trailing token is a comma, then capture it\n     /// Otherwise, ignore the trailing token\n     MaybeComma,"}, {"sha": "52c11b4e35f34372b59e21ac27037cc38e9a7269", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -402,6 +402,25 @@ impl<'a> Parser<'a> {\n             } else {\n                 PatKind::Path(qself, path)\n             }\n+        } else if matches!(self.token.kind, token::Lifetime(_))\n+            // In pattern position, we're totally fine with using \"next token isn't colon\"\n+            // as a heuristic. We could probably just always try to recover if it's a lifetime,\n+            // because we never have `'a: label {}` in a pattern position anyways, but it does\n+            // keep us from suggesting something like `let 'a: Ty = ..` => `let 'a': Ty = ..`\n+            && !self.look_ahead(1, |token| matches!(token.kind, token::Colon))\n+        {\n+            // Recover a `'a` as a `'a'` literal\n+            let lt = self.expect_lifetime();\n+            let lit = self.recover_unclosed_char(lt.ident, |self_| {\n+                let expected = expected.unwrap_or(\"pattern\");\n+                let msg =\n+                    format!(\"expected {}, found {}\", expected, super::token_descr(&self_.token));\n+\n+                let mut err = self_.struct_span_err(self_.token.span, &msg);\n+                err.span_label(self_.token.span, format!(\"expected {}\", expected));\n+                err\n+            });\n+            PatKind::Lit(self.mk_expr(lo, ExprKind::Lit(lit)))\n         } else {\n             // Try to parse everything else as literal with optional minus\n             match self.parse_literal_maybe_minus() {\n@@ -799,6 +818,7 @@ impl<'a> Parser<'a> {\n                 || t.kind == token::Dot // e.g. `.5` for recovery;\n                 || t.can_begin_literal_maybe_minus() // e.g. `42`.\n                 || t.is_whole_expr()\n+                || t.is_lifetime() // recover `'a` instead of `'a'`\n             })\n     }\n "}, {"sha": "b19e85427e729d01e93c580b67bd17a6444deae3", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -822,8 +822,8 @@ impl CheckAttrVisitor<'_> {\n             if let Some((prev_inline, prev_span)) = *specified_inline {\n                 if do_inline != prev_inline {\n                     let mut spans = MultiSpan::from_spans(vec![prev_span, meta.span()]);\n-                    spans.push_span_label(prev_span, fluent::passes::doc_inline_conflict_first);\n-                    spans.push_span_label(meta.span(), fluent::passes::doc_inline_conflict_second);\n+                    spans.push_span_label(prev_span, fluent::passes_doc_inline_conflict_first);\n+                    spans.push_span_label(meta.span(), fluent::passes_doc_inline_conflict_second);\n                     self.tcx.sess.emit_err(errors::DocKeywordConflict { spans });\n                     return false;\n                 }\n@@ -873,7 +873,7 @@ impl CheckAttrVisitor<'_> {\n                 INVALID_DOC_ATTRIBUTES,\n                 hir_id,\n                 meta.span(),\n-                fluent::passes::attr_crate_level,\n+                fluent::passes_attr_crate_level,\n                 |err| {\n                     if attr.style == AttrStyle::Outer\n                         && self.tcx.hir().get_parent_item(hir_id) == CRATE_OWNER_ID\n@@ -882,15 +882,15 @@ impl CheckAttrVisitor<'_> {\n                             src.insert(1, '!');\n                             err.span_suggestion_verbose(\n                                 attr.span,\n-                                fluent::passes::suggestion,\n+                                fluent::suggestion,\n                                 src,\n                                 Applicability::MaybeIncorrect,\n                             );\n                         } else {\n-                            err.span_help(attr.span, fluent::passes::help);\n+                            err.span_help(attr.span, fluent::help);\n                         }\n                     }\n-                    err.note(fluent::passes::note);\n+                    err.note(fluent::note);\n                     err\n                 },\n             );"}, {"sha": "adaaf5392425b6805b454ca4acc914484fb7b4d0", "filename": "compiler/rustc_passes/src/errors.rs", "status": "modified", "additions": 200, "deletions": 201, "changes": 401, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -13,37 +13,37 @@ use rustc_span::{Span, Symbol, DUMMY_SP};\n use crate::lang_items::Duplicate;\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::outer_crate_level_attr)]\n+#[diag(passes_outer_crate_level_attr)]\n pub struct OuterCrateLevelAttr;\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::inner_crate_level_attr)]\n+#[diag(passes_inner_crate_level_attr)]\n pub struct InnerCrateLevelAttr;\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::ignored_attr_with_macro)]\n+#[diag(passes_ignored_attr_with_macro)]\n pub struct IgnoredAttrWithMacro<'a> {\n     pub sym: &'a str,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::ignored_attr)]\n+#[diag(passes_ignored_attr)]\n pub struct IgnoredAttr<'a> {\n     pub sym: &'a str,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::inline_ignored_function_prototype)]\n+#[diag(passes_inline_ignored_function_prototype)]\n pub struct IgnoredInlineAttrFnProto;\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::inline_ignored_constants)]\n+#[diag(passes_inline_ignored_constants)]\n #[warning]\n #[note]\n pub struct IgnoredInlineAttrConstants;\n \n #[derive(Diagnostic)]\n-#[diag(passes::inline_not_fn_or_closure, code = \"E0518\")]\n+#[diag(passes_inline_not_fn_or_closure, code = \"E0518\")]\n pub struct InlineNotFnOrClosure {\n     #[primary_span]\n     pub attr_span: Span,\n@@ -52,19 +52,19 @@ pub struct InlineNotFnOrClosure {\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::no_coverage_ignored_function_prototype)]\n+#[diag(passes_no_coverage_ignored_function_prototype)]\n pub struct IgnoredNoCoverageFnProto;\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::no_coverage_propagate)]\n+#[diag(passes_no_coverage_propagate)]\n pub struct IgnoredNoCoveragePropagate;\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::no_coverage_fn_defn)]\n+#[diag(passes_no_coverage_fn_defn)]\n pub struct IgnoredNoCoverageFnDefn;\n \n #[derive(Diagnostic)]\n-#[diag(passes::no_coverage_not_coverable, code = \"E0788\")]\n+#[diag(passes_no_coverage_not_coverable, code = \"E0788\")]\n pub struct IgnoredNoCoverageNotCoverable {\n     #[primary_span]\n     pub attr_span: Span,\n@@ -73,7 +73,7 @@ pub struct IgnoredNoCoverageNotCoverable {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::should_be_applied_to_fn)]\n+#[diag(passes_should_be_applied_to_fn)]\n pub struct AttrShouldBeAppliedToFn {\n     #[primary_span]\n     pub attr_span: Span,\n@@ -82,14 +82,14 @@ pub struct AttrShouldBeAppliedToFn {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::naked_tracked_caller, code = \"E0736\")]\n+#[diag(passes_naked_tracked_caller, code = \"E0736\")]\n pub struct NakedTrackedCaller {\n     #[primary_span]\n     pub attr_span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::should_be_applied_to_fn, code = \"E0739\")]\n+#[diag(passes_should_be_applied_to_fn, code = \"E0739\")]\n pub struct TrackedCallerWrongLocation {\n     #[primary_span]\n     pub attr_span: Span,\n@@ -98,7 +98,7 @@ pub struct TrackedCallerWrongLocation {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::should_be_applied_to_struct_enum, code = \"E0701\")]\n+#[diag(passes_should_be_applied_to_struct_enum, code = \"E0701\")]\n pub struct NonExhaustiveWrongLocation {\n     #[primary_span]\n     pub attr_span: Span,\n@@ -107,7 +107,7 @@ pub struct NonExhaustiveWrongLocation {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::should_be_applied_to_trait)]\n+#[diag(passes_should_be_applied_to_trait)]\n pub struct AttrShouldBeAppliedToTrait {\n     #[primary_span]\n     pub attr_span: Span,\n@@ -116,11 +116,11 @@ pub struct AttrShouldBeAppliedToTrait {\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::target_feature_on_statement)]\n+#[diag(passes_target_feature_on_statement)]\n pub struct TargetFeatureOnStatement;\n \n #[derive(Diagnostic)]\n-#[diag(passes::should_be_applied_to_static)]\n+#[diag(passes_should_be_applied_to_static)]\n pub struct AttrShouldBeAppliedToStatic {\n     #[primary_span]\n     pub attr_span: Span,\n@@ -129,23 +129,23 @@ pub struct AttrShouldBeAppliedToStatic {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::doc_expect_str)]\n+#[diag(passes_doc_expect_str)]\n pub struct DocExpectStr<'a> {\n     #[primary_span]\n     pub attr_span: Span,\n     pub attr_name: &'a str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::doc_alias_empty)]\n+#[diag(passes_doc_alias_empty)]\n pub struct DocAliasEmpty<'a> {\n     #[primary_span]\n     pub span: Span,\n     pub attr_str: &'a str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::doc_alias_bad_char)]\n+#[diag(passes_doc_alias_bad_char)]\n pub struct DocAliasBadChar<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -154,15 +154,15 @@ pub struct DocAliasBadChar<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::doc_alias_start_end)]\n+#[diag(passes_doc_alias_start_end)]\n pub struct DocAliasStartEnd<'a> {\n     #[primary_span]\n     pub span: Span,\n     pub attr_str: &'a str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::doc_alias_bad_location)]\n+#[diag(passes_doc_alias_bad_location)]\n pub struct DocAliasBadLocation<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -171,132 +171,132 @@ pub struct DocAliasBadLocation<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::doc_alias_not_an_alias)]\n+#[diag(passes_doc_alias_not_an_alias)]\n pub struct DocAliasNotAnAlias<'a> {\n     #[primary_span]\n     pub span: Span,\n     pub attr_str: &'a str,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::doc_alias_duplicated)]\n+#[diag(passes_doc_alias_duplicated)]\n pub struct DocAliasDuplicated {\n     #[label]\n     pub first_defn: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::doc_alias_not_string_literal)]\n+#[diag(passes_doc_alias_not_string_literal)]\n pub struct DocAliasNotStringLiteral {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::doc_alias_malformed)]\n+#[diag(passes_doc_alias_malformed)]\n pub struct DocAliasMalformed {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::doc_keyword_empty_mod)]\n+#[diag(passes_doc_keyword_empty_mod)]\n pub struct DocKeywordEmptyMod {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::doc_keyword_not_mod)]\n+#[diag(passes_doc_keyword_not_mod)]\n pub struct DocKeywordNotMod {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::doc_keyword_invalid_ident)]\n+#[diag(passes_doc_keyword_invalid_ident)]\n pub struct DocKeywordInvalidIdent {\n     #[primary_span]\n     pub span: Span,\n     pub doc_keyword: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::doc_fake_variadic_not_valid)]\n+#[diag(passes_doc_fake_variadic_not_valid)]\n pub struct DocFakeVariadicNotValid {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::doc_keyword_only_impl)]\n+#[diag(passes_doc_keyword_only_impl)]\n pub struct DocKeywordOnlyImpl {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::doc_inline_conflict)]\n+#[diag(passes_doc_inline_conflict)]\n #[help]\n pub struct DocKeywordConflict {\n     #[primary_span]\n     pub spans: MultiSpan,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::doc_inline_only_use)]\n+#[diag(passes_doc_inline_only_use)]\n #[note]\n pub struct DocInlineOnlyUse {\n     #[label]\n     pub attr_span: Span,\n-    #[label(passes::not_a_use_item_label)]\n+    #[label(not_a_use_item_label)]\n     pub item_span: Option<Span>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::doc_attr_not_crate_level)]\n+#[diag(passes_doc_attr_not_crate_level)]\n pub struct DocAttrNotCrateLevel<'a> {\n     #[primary_span]\n     pub span: Span,\n     pub attr_name: &'a str,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::doc_test_unknown)]\n+#[diag(passes_doc_test_unknown)]\n pub struct DocTestUnknown {\n     pub path: String,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::doc_test_takes_list)]\n+#[diag(passes_doc_test_takes_list)]\n pub struct DocTestTakesList;\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::doc_cfg_hide_takes_list)]\n+#[diag(passes_doc_cfg_hide_takes_list)]\n pub struct DocCfgHideTakesList;\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::doc_primitive)]\n+#[diag(passes_doc_primitive)]\n pub struct DocPrimitive;\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::doc_test_unknown_any)]\n+#[diag(passes_doc_test_unknown_any)]\n pub struct DocTestUnknownAny {\n     pub path: String,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::doc_test_unknown_spotlight)]\n+#[diag(passes_doc_test_unknown_spotlight)]\n #[note]\n-#[note(passes::no_op_note)]\n+#[note(no_op_note)]\n pub struct DocTestUnknownSpotlight {\n     pub path: String,\n     #[suggestion_short(applicability = \"machine-applicable\", code = \"notable_trait\")]\n     pub span: Span,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::doc_test_unknown_include)]\n+#[diag(passes_doc_test_unknown_include)]\n pub struct DocTestUnknownInclude {\n     pub path: String,\n     pub value: String,\n@@ -306,11 +306,11 @@ pub struct DocTestUnknownInclude {\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::doc_invalid)]\n+#[diag(passes_doc_invalid)]\n pub struct DocInvalid;\n \n #[derive(Diagnostic)]\n-#[diag(passes::pass_by_value)]\n+#[diag(passes_pass_by_value)]\n pub struct PassByValue {\n     #[primary_span]\n     pub attr_span: Span,\n@@ -319,7 +319,7 @@ pub struct PassByValue {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::allow_incoherent_impl)]\n+#[diag(passes_allow_incoherent_impl)]\n pub struct AllowIncoherentImpl {\n     #[primary_span]\n     pub attr_span: Span,\n@@ -328,7 +328,7 @@ pub struct AllowIncoherentImpl {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::has_incoherent_inherent_impl)]\n+#[diag(passes_has_incoherent_inherent_impl)]\n pub struct HasIncoherentInherentImpl {\n     #[primary_span]\n     pub attr_span: Span,\n@@ -337,21 +337,21 @@ pub struct HasIncoherentInherentImpl {\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::must_use_async)]\n+#[diag(passes_must_use_async)]\n pub struct MustUseAsync {\n     #[label]\n     pub span: Span,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::must_use_no_effect)]\n+#[diag(passes_must_use_no_effect)]\n pub struct MustUseNoEffect {\n     pub article: &'static str,\n     pub target: rustc_hir::Target,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::must_not_suspend)]\n+#[diag(passes_must_not_suspend)]\n pub struct MustNotSuspend {\n     #[primary_span]\n     pub attr_span: Span,\n@@ -360,23 +360,23 @@ pub struct MustNotSuspend {\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::cold)]\n+#[diag(passes_cold)]\n #[warning]\n pub struct Cold {\n     #[label]\n     pub span: Span,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::link)]\n+#[diag(passes_link)]\n #[warning]\n pub struct Link {\n     #[label]\n     pub span: Option<Span>,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::link_name)]\n+#[diag(passes_link_name)]\n #[warning]\n pub struct LinkName<'a> {\n     #[help]\n@@ -387,7 +387,7 @@ pub struct LinkName<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::no_link)]\n+#[diag(passes_no_link)]\n pub struct NoLink {\n     #[primary_span]\n     pub attr_span: Span,\n@@ -396,7 +396,7 @@ pub struct NoLink {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::export_name)]\n+#[diag(passes_export_name)]\n pub struct ExportName {\n     #[primary_span]\n     pub attr_span: Span,\n@@ -405,7 +405,7 @@ pub struct ExportName {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::rustc_layout_scalar_valid_range_not_struct)]\n+#[diag(passes_rustc_layout_scalar_valid_range_not_struct)]\n pub struct RustcLayoutScalarValidRangeNotStruct {\n     #[primary_span]\n     pub attr_span: Span,\n@@ -414,14 +414,14 @@ pub struct RustcLayoutScalarValidRangeNotStruct {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::rustc_layout_scalar_valid_range_arg)]\n+#[diag(passes_rustc_layout_scalar_valid_range_arg)]\n pub struct RustcLayoutScalarValidRangeArg {\n     #[primary_span]\n     pub attr_span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::rustc_legacy_const_generics_only)]\n+#[diag(passes_rustc_legacy_const_generics_only)]\n pub struct RustcLegacyConstGenericsOnly {\n     #[primary_span]\n     pub attr_span: Span,\n@@ -430,7 +430,7 @@ pub struct RustcLegacyConstGenericsOnly {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::rustc_legacy_const_generics_index)]\n+#[diag(passes_rustc_legacy_const_generics_index)]\n pub struct RustcLegacyConstGenericsIndex {\n     #[primary_span]\n     pub attr_span: Span,\n@@ -439,7 +439,7 @@ pub struct RustcLegacyConstGenericsIndex {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::rustc_legacy_const_generics_index_exceed)]\n+#[diag(passes_rustc_legacy_const_generics_index_exceed)]\n pub struct RustcLegacyConstGenericsIndexExceed {\n     #[primary_span]\n     #[label]\n@@ -448,29 +448,29 @@ pub struct RustcLegacyConstGenericsIndexExceed {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::rustc_legacy_const_generics_index_negative)]\n+#[diag(passes_rustc_legacy_const_generics_index_negative)]\n pub struct RustcLegacyConstGenericsIndexNegative {\n     #[primary_span]\n     pub invalid_args: Vec<Span>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::rustc_dirty_clean)]\n+#[diag(passes_rustc_dirty_clean)]\n pub struct RustcDirtyClean {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::link_section)]\n+#[diag(passes_link_section)]\n #[warning]\n pub struct LinkSection {\n     #[label]\n     pub span: Span,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::no_mangle_foreign)]\n+#[diag(passes_no_mangle_foreign)]\n #[warning]\n #[note]\n pub struct NoMangleForeign {\n@@ -482,40 +482,40 @@ pub struct NoMangleForeign {\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::no_mangle)]\n+#[diag(passes_no_mangle)]\n #[warning]\n pub struct NoMangle {\n     #[label]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::repr_ident, code = \"E0565\")]\n+#[diag(passes_repr_ident, code = \"E0565\")]\n pub struct ReprIdent {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::repr_conflicting, code = \"E0566\")]\n+#[diag(passes_repr_conflicting, code = \"E0566\")]\n pub struct ReprConflicting;\n \n #[derive(Diagnostic)]\n-#[diag(passes::used_static)]\n+#[diag(passes_used_static)]\n pub struct UsedStatic {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::used_compiler_linker)]\n+#[diag(passes_used_compiler_linker)]\n pub struct UsedCompilerLinker {\n     #[primary_span]\n     pub spans: Vec<Span>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::allow_internal_unstable)]\n+#[diag(passes_allow_internal_unstable)]\n pub struct AllowInternalUnstable {\n     #[primary_span]\n     pub attr_span: Span,\n@@ -524,24 +524,24 @@ pub struct AllowInternalUnstable {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::debug_visualizer_placement)]\n+#[diag(passes_debug_visualizer_placement)]\n pub struct DebugVisualizerPlacement {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::debug_visualizer_invalid)]\n-#[note(passes::note_1)]\n-#[note(passes::note_2)]\n-#[note(passes::note_3)]\n+#[diag(passes_debug_visualizer_invalid)]\n+#[note(note_1)]\n+#[note(note_2)]\n+#[note(note_3)]\n pub struct DebugVisualizerInvalid {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::debug_visualizer_unreadable)]\n+#[diag(passes_debug_visualizer_unreadable)]\n pub struct DebugVisualizerUnreadable<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -550,7 +550,7 @@ pub struct DebugVisualizerUnreadable<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::rustc_allow_const_fn_unstable)]\n+#[diag(passes_rustc_allow_const_fn_unstable)]\n pub struct RustcAllowConstFnUnstable {\n     #[primary_span]\n     pub attr_span: Span,\n@@ -559,7 +559,7 @@ pub struct RustcAllowConstFnUnstable {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::rustc_std_internal_symbol)]\n+#[diag(passes_rustc_std_internal_symbol)]\n pub struct RustcStdInternalSymbol {\n     #[primary_span]\n     pub attr_span: Span,\n@@ -568,56 +568,56 @@ pub struct RustcStdInternalSymbol {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::const_trait)]\n+#[diag(passes_const_trait)]\n pub struct ConstTrait {\n     #[primary_span]\n     pub attr_span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::link_ordinal)]\n+#[diag(passes_link_ordinal)]\n pub struct LinkOrdinal {\n     #[primary_span]\n     pub attr_span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::stability_promotable)]\n+#[diag(passes_stability_promotable)]\n pub struct StabilityPromotable {\n     #[primary_span]\n     pub attr_span: Span,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::deprecated)]\n+#[diag(passes_deprecated)]\n pub struct Deprecated;\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::macro_use)]\n+#[diag(passes_macro_use)]\n pub struct MacroUse {\n     pub name: Symbol,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::macro_export)]\n+#[diag(passes_macro_export)]\n pub struct MacroExport;\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::plugin_registrar)]\n+#[diag(passes_plugin_registrar)]\n pub struct PluginRegistrar;\n \n #[derive(Subdiagnostic)]\n pub enum UnusedNote {\n-    #[note(passes::unused_empty_lints_note)]\n+    #[note(passes_unused_empty_lints_note)]\n     EmptyList { name: Symbol },\n-    #[note(passes::unused_no_lints_note)]\n+    #[note(passes_unused_no_lints_note)]\n     NoLints { name: Symbol },\n-    #[note(passes::unused_default_method_body_const_note)]\n+    #[note(passes_unused_default_method_body_const_note)]\n     DefaultMethodBodyConst,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::unused)]\n+#[diag(passes_unused)]\n pub struct Unused {\n     #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n     pub attr_span: Span,\n@@ -626,15 +626,15 @@ pub struct Unused {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::non_exported_macro_invalid_attrs, code = \"E0518\")]\n+#[diag(passes_non_exported_macro_invalid_attrs, code = \"E0518\")]\n pub struct NonExportedMacroInvalidAttrs {\n     #[primary_span]\n     #[label]\n     pub attr_span: Span,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::unused_duplicate)]\n+#[diag(passes_unused_duplicate)]\n pub struct UnusedDuplicate {\n     #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n     pub this: Span,\n@@ -645,7 +645,7 @@ pub struct UnusedDuplicate {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::unused_multiple)]\n+#[diag(passes_unused_multiple)]\n pub struct UnusedMultiple {\n     #[primary_span]\n     #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n@@ -656,7 +656,7 @@ pub struct UnusedMultiple {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::rustc_lint_opt_ty)]\n+#[diag(passes_rustc_lint_opt_ty)]\n pub struct RustcLintOptTy {\n     #[primary_span]\n     pub attr_span: Span,\n@@ -665,7 +665,7 @@ pub struct RustcLintOptTy {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::rustc_lint_opt_deny_field_access)]\n+#[diag(passes_rustc_lint_opt_deny_field_access)]\n pub struct RustcLintOptDenyFieldAccess {\n     #[primary_span]\n     pub attr_span: Span,\n@@ -674,7 +674,7 @@ pub struct RustcLintOptDenyFieldAccess {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::collapse_debuginfo)]\n+#[diag(passes_collapse_debuginfo)]\n pub struct CollapseDebuginfo {\n     #[primary_span]\n     pub attr_span: Span,\n@@ -683,42 +683,42 @@ pub struct CollapseDebuginfo {\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::deprecated_annotation_has_no_effect)]\n+#[diag(passes_deprecated_annotation_has_no_effect)]\n pub struct DeprecatedAnnotationHasNoEffect {\n     #[suggestion(applicability = \"machine-applicable\", code = \"\")]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::unknown_external_lang_item, code = \"E0264\")]\n+#[diag(passes_unknown_external_lang_item, code = \"E0264\")]\n pub struct UnknownExternLangItem {\n     #[primary_span]\n     pub span: Span,\n     pub lang_item: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::missing_panic_handler)]\n+#[diag(passes_missing_panic_handler)]\n pub struct MissingPanicHandler;\n \n #[derive(Diagnostic)]\n-#[diag(passes::alloc_func_required)]\n+#[diag(passes_alloc_func_required)]\n pub struct AllocFuncRequired;\n \n #[derive(Diagnostic)]\n-#[diag(passes::missing_alloc_error_handler)]\n+#[diag(passes_missing_alloc_error_handler)]\n pub struct MissingAllocErrorHandler;\n \n #[derive(Diagnostic)]\n-#[diag(passes::missing_lang_item)]\n+#[diag(passes_missing_lang_item)]\n #[note]\n #[help]\n pub struct MissingLangItem {\n     pub name: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::lang_item_on_incorrect_target, code = \"E0718\")]\n+#[diag(passes_lang_item_on_incorrect_target, code = \"E0718\")]\n pub struct LangItemOnIncorrectTarget {\n     #[primary_span]\n     #[label]\n@@ -729,7 +729,7 @@ pub struct LangItemOnIncorrectTarget {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::unknown_lang_item, code = \"E0522\")]\n+#[diag(passes_unknown_lang_item, code = \"E0522\")]\n pub struct UnknownLangItem {\n     #[primary_span]\n     #[label]\n@@ -748,8 +748,7 @@ impl IntoDiagnostic<'_> for InvalidAttrAtCrateLevel {\n         self,\n         handler: &'_ rustc_errors::Handler,\n     ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n-        let mut diag =\n-            handler.struct_err(rustc_errors::fluent::passes::invalid_attr_at_crate_level);\n+        let mut diag = handler.struct_err(rustc_errors::fluent::passes_invalid_attr_at_crate_level);\n         diag.set_span(self.span);\n         diag.set_arg(\"name\", self.name);\n         // Only emit an error with a suggestion if we can create a string out\n@@ -758,7 +757,7 @@ impl IntoDiagnostic<'_> for InvalidAttrAtCrateLevel {\n             let replacement = src.replace(\"#!\", \"#\");\n             diag.span_suggestion_verbose(\n                 self.span,\n-                rustc_errors::fluent::passes::suggestion,\n+                rustc_errors::fluent::suggestion,\n                 replacement,\n                 rustc_errors::Applicability::MachineApplicable,\n             );\n@@ -768,17 +767,17 @@ impl IntoDiagnostic<'_> for InvalidAttrAtCrateLevel {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::duplicate_diagnostic_item)]\n+#[diag(passes_duplicate_diagnostic_item)]\n pub struct DuplicateDiagnosticItem {\n     #[primary_span]\n     pub span: Span,\n     pub name: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::duplicate_diagnostic_item_in_crate)]\n+#[diag(passes_duplicate_diagnostic_item_in_crate)]\n pub struct DuplicateDiagnosticItemInCrate {\n-    #[note(passes::diagnostic_item_first_defined)]\n+    #[note(passes_diagnostic_item_first_defined)]\n     pub span: Option<Span>,\n     pub orig_crate_name: Symbol,\n     #[note]\n@@ -788,39 +787,39 @@ pub struct DuplicateDiagnosticItemInCrate {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::abi)]\n+#[diag(passes_abi)]\n pub struct Abi {\n     #[primary_span]\n     pub span: Span,\n     pub abi: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::align)]\n+#[diag(passes_align)]\n pub struct Align {\n     #[primary_span]\n     pub span: Span,\n     pub align: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::size)]\n+#[diag(passes_size)]\n pub struct Size {\n     #[primary_span]\n     pub span: Span,\n     pub size: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::homogeneous_aggregate)]\n+#[diag(passes_homogeneous_aggregate)]\n pub struct HomogeneousAggregate {\n     #[primary_span]\n     pub span: Span,\n     pub homogeneous_aggregate: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::layout_of)]\n+#[diag(passes_layout_of)]\n pub struct LayoutOf {\n     #[primary_span]\n     pub span: Span,\n@@ -829,15 +828,15 @@ pub struct LayoutOf {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::unrecognized_field)]\n+#[diag(passes_unrecognized_field)]\n pub struct UnrecognizedField {\n     #[primary_span]\n     pub span: Span,\n     pub name: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::feature_stable_twice, code = \"E0711\")]\n+#[diag(passes_feature_stable_twice, code = \"E0711\")]\n pub struct FeatureStableTwice {\n     #[primary_span]\n     pub span: Span,\n@@ -847,7 +846,7 @@ pub struct FeatureStableTwice {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::feature_previously_declared, code = \"E0711\")]\n+#[diag(passes_feature_previously_declared, code = \"E0711\")]\n pub struct FeaturePreviouslyDeclared<'a, 'b> {\n     #[primary_span]\n     pub span: Span,\n@@ -857,7 +856,7 @@ pub struct FeaturePreviouslyDeclared<'a, 'b> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::expr_not_allowed_in_context, code = \"E0744\")]\n+#[diag(passes_expr_not_allowed_in_context, code = \"E0744\")]\n pub struct ExprNotAllowedInContext<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -883,17 +882,17 @@ impl<'a> IntoDiagnostic<'_> for BreakNonLoop<'a> {\n     ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n         let mut diag = handler.struct_span_err_with_code(\n             self.span,\n-            rustc_errors::fluent::passes::break_non_loop,\n+            rustc_errors::fluent::passes_break_non_loop,\n             error_code!(E0571),\n         );\n         diag.set_arg(\"kind\", self.kind);\n-        diag.span_label(self.span, rustc_errors::fluent::passes::label);\n+        diag.span_label(self.span, rustc_errors::fluent::label);\n         if let Some(head) = self.head {\n-            diag.span_label(head, rustc_errors::fluent::passes::label2);\n+            diag.span_label(head, rustc_errors::fluent::label2);\n         }\n         diag.span_suggestion(\n             self.span,\n-            rustc_errors::fluent::passes::suggestion,\n+            rustc_errors::fluent::suggestion,\n             self.suggestion,\n             Applicability::MaybeIncorrect,\n         );\n@@ -911,7 +910,7 @@ impl<'a> IntoDiagnostic<'_> for BreakNonLoop<'a> {\n                 _ => {\n                     diag.span_suggestion(\n                         self.break_expr_span,\n-                        rustc_errors::fluent::passes::break_expr_suggestion,\n+                        rustc_errors::fluent::break_expr_suggestion,\n                         label.ident,\n                         Applicability::MaybeIncorrect,\n                     );\n@@ -923,39 +922,39 @@ impl<'a> IntoDiagnostic<'_> for BreakNonLoop<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::continue_labeled_block, code = \"E0696\")]\n+#[diag(passes_continue_labeled_block, code = \"E0696\")]\n pub struct ContinueLabeledBlock {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[label(passes::block_label)]\n+    #[label(block_label)]\n     pub block_span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::break_inside_closure, code = \"E0267\")]\n+#[diag(passes_break_inside_closure, code = \"E0267\")]\n pub struct BreakInsideClosure<'a> {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[label(passes::closure_label)]\n+    #[label(closure_label)]\n     pub closure_span: Span,\n     pub name: &'a str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::break_inside_async_block, code = \"E0267\")]\n+#[diag(passes_break_inside_async_block, code = \"E0267\")]\n pub struct BreakInsideAsyncBlock<'a> {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[label(passes::async_block_label)]\n+    #[label(async_block_label)]\n     pub closure_span: Span,\n     pub name: &'a str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::outside_loop, code = \"E0268\")]\n+#[diag(passes_outside_loop, code = \"E0268\")]\n pub struct OutsideLoop<'a> {\n     #[primary_span]\n     #[label]\n@@ -964,7 +963,7 @@ pub struct OutsideLoop<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::unlabeled_in_labeled_block, code = \"E0695\")]\n+#[diag(passes_unlabeled_in_labeled_block, code = \"E0695\")]\n pub struct UnlabeledInLabeledBlock<'a> {\n     #[primary_span]\n     #[label]\n@@ -973,7 +972,7 @@ pub struct UnlabeledInLabeledBlock<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::unlabeled_cf_in_while_condition, code = \"E0590\")]\n+#[diag(passes_unlabeled_cf_in_while_condition, code = \"E0590\")]\n pub struct UnlabeledCfInWhileCondition<'a> {\n     #[primary_span]\n     #[label]\n@@ -982,25 +981,25 @@ pub struct UnlabeledCfInWhileCondition<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::cannot_inline_naked_function)]\n+#[diag(passes_cannot_inline_naked_function)]\n pub struct CannotInlineNakedFunction {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::undefined_naked_function_abi)]\n+#[diag(passes_undefined_naked_function_abi)]\n pub struct UndefinedNakedFunctionAbi;\n \n #[derive(Diagnostic)]\n-#[diag(passes::no_patterns)]\n+#[diag(passes_no_patterns)]\n pub struct NoPatterns {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::params_not_allowed)]\n+#[diag(passes_params_not_allowed)]\n #[help]\n pub struct ParamsNotAllowed {\n     #[primary_span]\n@@ -1020,36 +1019,36 @@ impl IntoDiagnostic<'_> for NakedFunctionsAsmBlock {\n     ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n         let mut diag = handler.struct_span_err_with_code(\n             self.span,\n-            rustc_errors::fluent::passes::naked_functions_asm_block,\n+            rustc_errors::fluent::passes_naked_functions_asm_block,\n             error_code!(E0787),\n         );\n         for span in self.multiple_asms.iter() {\n-            diag.span_label(*span, rustc_errors::fluent::passes::label_multiple_asm);\n+            diag.span_label(*span, rustc_errors::fluent::label_multiple_asm);\n         }\n         for span in self.non_asms.iter() {\n-            diag.span_label(*span, rustc_errors::fluent::passes::label_non_asm);\n+            diag.span_label(*span, rustc_errors::fluent::label_non_asm);\n         }\n         diag\n     }\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::naked_functions_operands, code = \"E0787\")]\n+#[diag(passes_naked_functions_operands, code = \"E0787\")]\n pub struct NakedFunctionsOperands {\n     #[primary_span]\n     pub unsupported_operands: Vec<Span>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::naked_functions_asm_options, code = \"E0787\")]\n+#[diag(passes_naked_functions_asm_options, code = \"E0787\")]\n pub struct NakedFunctionsAsmOptions {\n     #[primary_span]\n     pub span: Span,\n     pub unsupported_options: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::naked_functions_must_use_noreturn, code = \"E0787\")]\n+#[diag(passes_naked_functions_must_use_noreturn, code = \"E0787\")]\n pub struct NakedFunctionsMustUseNoreturn {\n     #[primary_span]\n     pub span: Span,\n@@ -1058,67 +1057,67 @@ pub struct NakedFunctionsMustUseNoreturn {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::attr_only_on_main)]\n+#[diag(passes_attr_only_on_main)]\n pub struct AttrOnlyOnMain {\n     #[primary_span]\n     pub span: Span,\n     pub attr: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::attr_only_on_root_main)]\n+#[diag(passes_attr_only_on_root_main)]\n pub struct AttrOnlyOnRootMain {\n     #[primary_span]\n     pub span: Span,\n     pub attr: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::attr_only_in_functions)]\n+#[diag(passes_attr_only_in_functions)]\n pub struct AttrOnlyInFunctions {\n     #[primary_span]\n     pub span: Span,\n     pub attr: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::multiple_rustc_main, code = \"E0137\")]\n+#[diag(passes_multiple_rustc_main, code = \"E0137\")]\n pub struct MultipleRustcMain {\n     #[primary_span]\n     pub span: Span,\n-    #[label(passes::first)]\n+    #[label(first)]\n     pub first: Span,\n-    #[label(passes::additional)]\n+    #[label(additional)]\n     pub additional: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::multiple_start_functions, code = \"E0138\")]\n+#[diag(passes_multiple_start_functions, code = \"E0138\")]\n pub struct MultipleStartFunctions {\n     #[primary_span]\n     pub span: Span,\n     #[label]\n     pub labeled: Span,\n-    #[label(passes::previous)]\n+    #[label(previous)]\n     pub previous: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::extern_main)]\n+#[diag(passes_extern_main)]\n pub struct ExternMain {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::unix_sigpipe_values)]\n+#[diag(passes_unix_sigpipe_values)]\n pub struct UnixSigpipeValues {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::no_main_function, code = \"E0601\")]\n+#[diag(passes_no_main_function, code = \"E0601\")]\n pub struct NoMainFunction {\n     #[primary_span]\n     pub span: Span,\n@@ -1143,24 +1142,24 @@ impl<'a> IntoDiagnostic<'a> for NoMainErr {\n     ) -> rustc_errors::DiagnosticBuilder<'a, ErrorGuaranteed> {\n         let mut diag = handler.struct_span_err_with_code(\n             DUMMY_SP,\n-            rustc_errors::fluent::passes::no_main_function,\n+            rustc_errors::fluent::passes_no_main_function,\n             error_code!(E0601),\n         );\n         diag.set_arg(\"crate_name\", self.crate_name);\n         diag.set_arg(\"filename\", self.filename);\n         diag.set_arg(\"has_filename\", self.has_filename);\n         let note = if !self.non_main_fns.is_empty() {\n             for &span in &self.non_main_fns {\n-                diag.span_note(span, rustc_errors::fluent::passes::here_is_main);\n+                diag.span_note(span, rustc_errors::fluent::here_is_main);\n             }\n-            diag.note(rustc_errors::fluent::passes::one_or_more_possible_main);\n-            diag.help(rustc_errors::fluent::passes::consider_moving_main);\n+            diag.note(rustc_errors::fluent::one_or_more_possible_main);\n+            diag.help(rustc_errors::fluent::consider_moving_main);\n             // There were some functions named `main` though. Try to give the user a hint.\n-            rustc_errors::fluent::passes::main_must_be_defined_at_crate\n+            rustc_errors::fluent::main_must_be_defined_at_crate\n         } else if self.has_filename {\n-            rustc_errors::fluent::passes::consider_adding_main_to_file\n+            rustc_errors::fluent::consider_adding_main_to_file\n         } else {\n-            rustc_errors::fluent::passes::consider_adding_main_at_crate\n+            rustc_errors::fluent::consider_adding_main_at_crate\n         };\n         if self.file_empty {\n             diag.note(note);\n@@ -1171,11 +1170,11 @@ impl<'a> IntoDiagnostic<'a> for NoMainErr {\n \n         if let Some(main_def) = self.main_def_opt && main_def.opt_fn_def_id().is_none(){\n             // There is something at `crate::main`, but it is not a function definition.\n-            diag.span_label(main_def.span, rustc_errors::fluent::passes::non_function_main);\n+            diag.span_label(main_def.span, rustc_errors::fluent::non_function_main);\n         }\n \n         if self.add_teach_note {\n-            diag.note(rustc_errors::fluent::passes::teach_note);\n+            diag.note(rustc_errors::fluent::teach_note);\n         }\n         diag\n     }\n@@ -1203,11 +1202,11 @@ impl IntoDiagnostic<'_> for DuplicateLangItem {\n     ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n         let mut diag = handler.struct_err_with_code(\n             match self.duplicate {\n-                Duplicate::Plain => rustc_errors::fluent::passes::duplicate_lang_item,\n+                Duplicate::Plain => rustc_errors::fluent::passes_duplicate_lang_item,\n \n-                Duplicate::Crate => rustc_errors::fluent::passes::duplicate_lang_item_crate,\n+                Duplicate::Crate => rustc_errors::fluent::passes_duplicate_lang_item_crate,\n                 Duplicate::CrateDepends => {\n-                    rustc_errors::fluent::passes::duplicate_lang_item_crate_depends\n+                    rustc_errors::fluent::passes_duplicate_lang_item_crate_depends\n                 }\n             },\n             error_code!(E0152),\n@@ -1223,32 +1222,32 @@ impl IntoDiagnostic<'_> for DuplicateLangItem {\n             diag.set_span(span);\n         }\n         if let Some(span) = self.first_defined_span {\n-            diag.span_note(span, rustc_errors::fluent::passes::first_defined_span);\n+            diag.span_note(span, rustc_errors::fluent::first_defined_span);\n         } else {\n             if self.orig_dependency_of.is_empty() {\n-                diag.note(rustc_errors::fluent::passes::first_defined_crate);\n+                diag.note(rustc_errors::fluent::first_defined_crate);\n             } else {\n-                diag.note(rustc_errors::fluent::passes::first_defined_crate_depends);\n+                diag.note(rustc_errors::fluent::first_defined_crate_depends);\n             }\n \n             if self.orig_is_local {\n-                diag.note(rustc_errors::fluent::passes::first_definition_local);\n+                diag.note(rustc_errors::fluent::first_definition_local);\n             } else {\n-                diag.note(rustc_errors::fluent::passes::first_definition_path);\n+                diag.note(rustc_errors::fluent::first_definition_path);\n             }\n \n             if self.is_local {\n-                diag.note(rustc_errors::fluent::passes::second_definition_local);\n+                diag.note(rustc_errors::fluent::second_definition_local);\n             } else {\n-                diag.note(rustc_errors::fluent::passes::second_definition_path);\n+                diag.note(rustc_errors::fluent::second_definition_path);\n             }\n         }\n         diag\n     }\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::incorrect_target, code = \"E0718\")]\n+#[diag(passes_incorrect_target, code = \"E0718\")]\n pub struct IncorrectTarget<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -1262,29 +1261,29 @@ pub struct IncorrectTarget<'a> {\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::useless_assignment)]\n+#[diag(passes_useless_assignment)]\n pub struct UselessAssignment<'a> {\n     pub is_field_assign: bool,\n     pub ty: Ty<'a>,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(passes::only_has_effect_on)]\n+#[diag(passes_only_has_effect_on)]\n pub struct OnlyHasEffectOn {\n     pub attr_name: Symbol,\n     pub target_name: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::object_lifetime_err)]\n+#[diag(passes_object_lifetime_err)]\n pub struct ObjectLifetimeErr {\n     #[primary_span]\n     pub span: Span,\n     pub repr: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::unrecognized_repr_hint, code = \"E0552\")]\n+#[diag(passes_unrecognized_repr_hint, code = \"E0552\")]\n #[help]\n pub struct UnrecognizedReprHint {\n     #[primary_span]\n@@ -1293,35 +1292,35 @@ pub struct UnrecognizedReprHint {\n \n #[derive(Diagnostic)]\n pub enum AttrApplication {\n-    #[diag(passes::attr_application_enum, code = \"E0517\")]\n+    #[diag(passes_attr_application_enum, code = \"E0517\")]\n     Enum {\n         #[primary_span]\n         hint_span: Span,\n         #[label]\n         span: Span,\n     },\n-    #[diag(passes::attr_application_struct, code = \"E0517\")]\n+    #[diag(passes_attr_application_struct, code = \"E0517\")]\n     Struct {\n         #[primary_span]\n         hint_span: Span,\n         #[label]\n         span: Span,\n     },\n-    #[diag(passes::attr_application_struct_union, code = \"E0517\")]\n+    #[diag(passes_attr_application_struct_union, code = \"E0517\")]\n     StructUnion {\n         #[primary_span]\n         hint_span: Span,\n         #[label]\n         span: Span,\n     },\n-    #[diag(passes::attr_application_struct_enum_union, code = \"E0517\")]\n+    #[diag(passes_attr_application_struct_enum_union, code = \"E0517\")]\n     StructEnumUnion {\n         #[primary_span]\n         hint_span: Span,\n         #[label]\n         span: Span,\n     },\n-    #[diag(passes::attr_application_struct_enum_function_union, code = \"E0517\")]\n+    #[diag(passes_attr_application_struct_enum_function_union, code = \"E0517\")]\n     StructEnumFunctionUnion {\n         #[primary_span]\n         hint_span: Span,\n@@ -1331,102 +1330,102 @@ pub enum AttrApplication {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::transparent_incompatible, code = \"E0692\")]\n+#[diag(passes_transparent_incompatible, code = \"E0692\")]\n pub struct TransparentIncompatible {\n     #[primary_span]\n     pub hint_spans: Vec<Span>,\n     pub target: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::deprecated_attribute, code = \"E0549\")]\n+#[diag(passes_deprecated_attribute, code = \"E0549\")]\n pub struct DeprecatedAttribute {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::useless_stability)]\n+#[diag(passes_useless_stability)]\n pub struct UselessStability {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[label(passes::item)]\n+    #[label(item)]\n     pub item_sp: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::invalid_stability)]\n+#[diag(passes_invalid_stability)]\n pub struct InvalidStability {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[label(passes::item)]\n+    #[label(item)]\n     pub item_sp: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::cannot_stabilize_deprecated)]\n+#[diag(passes_cannot_stabilize_deprecated)]\n pub struct CannotStabilizeDeprecated {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[label(passes::item)]\n+    #[label(item)]\n     pub item_sp: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::invalid_deprecation_version)]\n+#[diag(passes_invalid_deprecation_version)]\n pub struct InvalidDeprecationVersion {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[label(passes::item)]\n+    #[label(item)]\n     pub item_sp: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::missing_stability_attr)]\n+#[diag(passes_missing_stability_attr)]\n pub struct MissingStabilityAttr<'a> {\n     #[primary_span]\n     pub span: Span,\n     pub descr: &'a str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::missing_const_stab_attr)]\n+#[diag(passes_missing_const_stab_attr)]\n pub struct MissingConstStabAttr<'a> {\n     #[primary_span]\n     pub span: Span,\n     pub descr: &'a str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::trait_impl_const_stable)]\n+#[diag(passes_trait_impl_const_stable)]\n #[note]\n pub struct TraitImplConstStable {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::feature_only_on_nightly, code = \"E0554\")]\n+#[diag(passes_feature_only_on_nightly, code = \"E0554\")]\n pub struct FeatureOnlyOnNightly {\n     #[primary_span]\n     pub span: Span,\n     pub release_channel: &'static str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::unknown_feature, code = \"E0635\")]\n+#[diag(passes_unknown_feature, code = \"E0635\")]\n pub struct UnknownFeature {\n     #[primary_span]\n     pub span: Span,\n     pub feature: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::implied_feature_not_exist)]\n+#[diag(passes_implied_feature_not_exist)]\n pub struct ImpliedFeatureNotExist {\n     #[primary_span]\n     pub span: Span,\n@@ -1435,14 +1434,14 @@ pub struct ImpliedFeatureNotExist {\n }\n \n #[derive(Diagnostic)]\n-#[diag(passes::duplicate_feature_err, code = \"E0636\")]\n+#[diag(passes_duplicate_feature_err, code = \"E0636\")]\n pub struct DuplicateFeatureErr {\n     #[primary_span]\n     pub span: Span,\n     pub feature: Symbol,\n }\n #[derive(Diagnostic)]\n-#[diag(passes::missing_const_err)]\n+#[diag(passes_missing_const_err)]\n pub struct MissingConstErr {\n     #[primary_span]\n     #[help]"}, {"sha": "e6a7fc86bee3dc787ae8e0235c60b4acf7ffbb10", "filename": "compiler/rustc_plugin_impl/src/errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_plugin_impl%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_plugin_impl%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_plugin_impl%2Fsrc%2Ferrors.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -4,15 +4,15 @@ use rustc_macros::Diagnostic;\n use rustc_span::Span;\n \n #[derive(Diagnostic)]\n-#[diag(plugin_impl::load_plugin_error)]\n+#[diag(plugin_impl_load_plugin_error)]\n pub struct LoadPluginError {\n     #[primary_span]\n     pub span: Span,\n     pub msg: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(plugin_impl::malformed_plugin_attribute, code = \"E0498\")]\n+#[diag(plugin_impl_malformed_plugin_attribute, code = \"E0498\")]\n pub struct MalformedPluginAttribute {\n     #[primary_span]\n     #[label]"}, {"sha": "a6c95f1a815acc5bed64a4bd147925b84b2ac85e", "filename": "compiler/rustc_privacy/src/errors.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_privacy%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_privacy%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Ferrors.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -3,7 +3,7 @@ use rustc_macros::{Diagnostic, LintDiagnostic, Subdiagnostic};\n use rustc_span::{Span, Symbol};\n \n #[derive(Diagnostic)]\n-#[diag(privacy::field_is_private, code = \"E0451\")]\n+#[diag(privacy_field_is_private, code = \"E0451\")]\n pub struct FieldIsPrivate {\n     #[primary_span]\n     pub span: Span,\n@@ -16,21 +16,21 @@ pub struct FieldIsPrivate {\n \n #[derive(Subdiagnostic)]\n pub enum FieldIsPrivateLabel {\n-    #[label(privacy::field_is_private_is_update_syntax_label)]\n+    #[label(privacy_field_is_private_is_update_syntax_label)]\n     IsUpdateSyntax {\n         #[primary_span]\n         span: Span,\n         field_name: Symbol,\n     },\n-    #[label(privacy::field_is_private_label)]\n+    #[label(privacy_field_is_private_label)]\n     Other {\n         #[primary_span]\n         span: Span,\n     },\n }\n \n #[derive(Diagnostic)]\n-#[diag(privacy::item_is_private)]\n+#[diag(privacy_item_is_private)]\n pub struct ItemIsPrivate<'a> {\n     #[primary_span]\n     #[label]\n@@ -40,7 +40,7 @@ pub struct ItemIsPrivate<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(privacy::unnamed_item_is_private)]\n+#[diag(privacy_unnamed_item_is_private)]\n pub struct UnnamedItemIsPrivate {\n     #[primary_span]\n     pub span: Span,\n@@ -49,50 +49,50 @@ pub struct UnnamedItemIsPrivate {\n \n // Duplicate of `InPublicInterface` but with a different error code, shares the same slug.\n #[derive(Diagnostic)]\n-#[diag(privacy::in_public_interface, code = \"E0445\")]\n+#[diag(privacy_in_public_interface, code = \"E0445\")]\n pub struct InPublicInterfaceTraits<'a> {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n     pub vis_descr: &'static str,\n     pub kind: &'a str,\n     pub descr: DiagnosticArgFromDisplay<'a>,\n-    #[label(privacy::visibility_label)]\n+    #[label(visibility_label)]\n     pub vis_span: Span,\n }\n \n // Duplicate of `InPublicInterfaceTraits` but with a different error code, shares the same slug.\n #[derive(Diagnostic)]\n-#[diag(privacy::in_public_interface, code = \"E0446\")]\n+#[diag(privacy_in_public_interface, code = \"E0446\")]\n pub struct InPublicInterface<'a> {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n     pub vis_descr: &'static str,\n     pub kind: &'a str,\n     pub descr: DiagnosticArgFromDisplay<'a>,\n-    #[label(privacy::visibility_label)]\n+    #[label(visibility_label)]\n     pub vis_span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(privacy::report_effective_visibility)]\n+#[diag(privacy_report_effective_visibility)]\n pub struct ReportEffectiveVisibility {\n     #[primary_span]\n     pub span: Span,\n     pub descr: String,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(privacy::from_private_dep_in_public_interface)]\n+#[diag(privacy_from_private_dep_in_public_interface)]\n pub struct FromPrivateDependencyInPublicInterface<'a> {\n     pub kind: &'a str,\n     pub descr: DiagnosticArgFromDisplay<'a>,\n     pub krate: Symbol,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(privacy::private_in_public_lint)]\n+#[diag(privacy_private_in_public_lint)]\n pub struct PrivateInPublicLint<'a> {\n     pub vis_descr: &'static str,\n     pub kind: &'a str,"}, {"sha": "2636db6dbe1a77b6113089c778029a22e9c1ca81", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 10, "deletions": 25, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -159,34 +159,12 @@ where\n                 ty.visit_with(self)\n             }\n             ty::PredicateKind::RegionOutlives(..) => ControlFlow::CONTINUE,\n-            ty::PredicateKind::ConstEvaluatable(uv)\n-                if self.def_id_visitor.tcx().features().generic_const_exprs =>\n-            {\n-                let tcx = self.def_id_visitor.tcx();\n-                if let Ok(Some(ct)) = AbstractConst::new(tcx, uv) {\n-                    self.visit_abstract_const_expr(tcx, ct)?;\n-                }\n-                ControlFlow::CONTINUE\n-            }\n+            ty::PredicateKind::ConstEvaluatable(ct) => ct.visit_with(self),\n             ty::PredicateKind::WellFormed(arg) => arg.visit_with(self),\n             _ => bug!(\"unexpected predicate: {:?}\", predicate),\n         }\n     }\n \n-    fn visit_abstract_const_expr(\n-        &mut self,\n-        tcx: TyCtxt<'tcx>,\n-        ct: AbstractConst<'tcx>,\n-    ) -> ControlFlow<V::BreakTy> {\n-        walk_abstract_const(tcx, ct, |node| match node.root(tcx) {\n-            ACNode::Leaf(leaf) => self.visit_const(leaf),\n-            ACNode::Cast(_, _, ty) => self.visit_ty(ty),\n-            ACNode::Binop(..) | ACNode::UnaryOp(..) | ACNode::FunctionCall(_, _) => {\n-                ControlFlow::CONTINUE\n-            }\n-        })\n-    }\n-\n     fn visit_predicates(\n         &mut self,\n         predicates: ty::GenericPredicates<'tcx>,\n@@ -309,9 +287,16 @@ where\n         self.visit_ty(c.ty())?;\n         let tcx = self.def_id_visitor.tcx();\n         if let Ok(Some(ct)) = AbstractConst::from_const(tcx, c) {\n-            self.visit_abstract_const_expr(tcx, ct)?;\n+            walk_abstract_const(tcx, ct, |node| match node.root(tcx) {\n+                ACNode::Leaf(leaf) => self.visit_const(leaf),\n+                ACNode::Cast(_, _, ty) => self.visit_ty(ty),\n+                ACNode::Binop(..) | ACNode::UnaryOp(..) | ACNode::FunctionCall(_, _) => {\n+                    ControlFlow::CONTINUE\n+                }\n+            })\n+        } else {\n+            ControlFlow::CONTINUE\n         }\n-        ControlFlow::CONTINUE\n     }\n }\n "}, {"sha": "a592165011273ba44b77782d7290db44b2a3c6be", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -848,6 +848,7 @@ impl_ref_decoder! {<'tcx>\n     rustc_span::def_id::DefId,\n     rustc_span::def_id::LocalDefId,\n     (rustc_middle::middle::exported_symbols::ExportedSymbol<'tcx>, rustc_middle::middle::exported_symbols::SymbolExportInfo),\n+    ty::DeducedParamAttrs,\n }\n \n //- ENCODING -------------------------------------------------------------------"}, {"sha": "7a20eaceba0247682a7ae74451ddcbf3eeeb7772", "filename": "compiler/rustc_query_system/src/error.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_query_system%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_query_system%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Ferror.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -3,7 +3,7 @@ use rustc_session::Limit;\n use rustc_span::{Span, Symbol};\n \n #[derive(Subdiagnostic)]\n-#[note(query_system::cycle_stack_middle)]\n+#[note(query_system_cycle_stack_middle)]\n pub struct CycleStack {\n     #[primary_span]\n     pub span: Span,\n@@ -19,32 +19,32 @@ pub enum HandleCycleError {\n \n #[derive(Subdiagnostic)]\n pub enum StackCount {\n-    #[note(query_system::cycle_stack_single)]\n+    #[note(query_system_cycle_stack_single)]\n     Single,\n-    #[note(query_system::cycle_stack_multiple)]\n+    #[note(query_system_cycle_stack_multiple)]\n     Multiple,\n }\n \n #[derive(Subdiagnostic)]\n pub enum Alias {\n-    #[note(query_system::cycle_recursive_ty_alias)]\n-    #[help(query_system::cycle_recursive_ty_alias_help1)]\n-    #[help(query_system::cycle_recursive_ty_alias_help2)]\n+    #[note(query_system_cycle_recursive_ty_alias)]\n+    #[help(query_system_cycle_recursive_ty_alias_help1)]\n+    #[help(query_system_cycle_recursive_ty_alias_help2)]\n     Ty,\n-    #[note(query_system::cycle_recursive_trait_alias)]\n+    #[note(query_system_cycle_recursive_trait_alias)]\n     Trait,\n }\n \n #[derive(Subdiagnostic)]\n-#[note(query_system::cycle_usage)]\n+#[note(query_system_cycle_usage)]\n pub struct CycleUsage {\n     #[primary_span]\n     pub span: Span,\n     pub usage: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(query_system::cycle, code = \"E0391\")]\n+#[diag(query_system_cycle, code = \"E0391\")]\n pub struct Cycle {\n     #[primary_span]\n     pub span: Span,\n@@ -60,22 +60,22 @@ pub struct Cycle {\n }\n \n #[derive(Diagnostic)]\n-#[diag(query_system::reentrant)]\n+#[diag(query_system_reentrant)]\n pub struct Reentrant;\n \n #[derive(Diagnostic)]\n-#[diag(query_system::increment_compilation)]\n+#[diag(query_system_increment_compilation)]\n #[help]\n-#[note(query_system::increment_compilation_note1)]\n-#[note(query_system::increment_compilation_note2)]\n+#[note(query_system_increment_compilation_note1)]\n+#[note(query_system_increment_compilation_note2)]\n pub struct IncrementCompilation {\n     pub run_cmd: String,\n     pub dep_node: String,\n }\n \n #[derive(Diagnostic)]\n #[help]\n-#[diag(query_system::query_overflow)]\n+#[diag(query_system_query_overflow)]\n pub struct QueryOverflow {\n     #[primary_span]\n     pub span: Option<Span>,\n@@ -86,7 +86,7 @@ pub struct QueryOverflow {\n }\n \n #[derive(Subdiagnostic)]\n-#[note(query_system::layout_of_depth)]\n+#[note(query_system_layout_of_depth)]\n pub struct LayoutOfDepth {\n     pub desc: String,\n     pub depth: usize,"}, {"sha": "257784341e3f8de3ed6d6064d81d2f18168fa437", "filename": "compiler/rustc_resolve/src/access_levels.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_resolve%2Fsrc%2Faccess_levels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_resolve%2Fsrc%2Faccess_levels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Faccess_levels.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -1,5 +1,4 @@\n-use crate::NameBindingKind;\n-use crate::Resolver;\n+use crate::{ImportKind, NameBindingKind, Resolver};\n use rustc_ast::ast;\n use rustc_ast::visit;\n use rustc_ast::visit::Visitor;\n@@ -45,31 +44,40 @@ impl<'r, 'a> AccessLevelsVisitor<'r, 'a> {\n         let module = self.r.get_module(module_id.to_def_id()).unwrap();\n         let resolutions = self.r.resolutions(module);\n \n-        for (key, name_resolution) in resolutions.borrow().iter() {\n+        for (_, name_resolution) in resolutions.borrow().iter() {\n             if let Some(mut binding) = name_resolution.borrow().binding() && !binding.is_ambiguity() {\n                 // Set the given binding access level to `AccessLevel::Public` and\n                 // sets the rest of the `use` chain to `AccessLevel::Exported` until\n                 // we hit the actual exported item.\n \n-                // FIXME: tag and is_public() condition must be deleted,\n-                // but assertion fail occurs in import_id_for_ns\n+                // FIXME: tag and is_public() condition should be removed, but assertions occur.\n                 let tag = if binding.is_import() { AccessLevel::Exported } else { AccessLevel::Public };\n                 if binding.vis.is_public() {\n                     let mut prev_parent_id = module_id;\n                     let mut level = AccessLevel::Public;\n                     while let NameBindingKind::Import { binding: nested_binding, import, .. } =\n                         binding.kind\n                     {\n-                        let id = self.r.local_def_id(self.r.import_id_for_ns(import, key.ns));\n-                        self.update(\n-                            id,\n+                        let mut update = |node_id| self.update(\n+                            self.r.local_def_id(node_id),\n                             binding.vis.expect_local(),\n                             prev_parent_id,\n                             level,\n                         );\n+                        // In theory all the import IDs have individual visibilities and effective\n+                        // visibilities, but in practice these IDs go straigth to HIR where all\n+                        // their few uses assume that their (effective) visibility applies to the\n+                        // whole syntactic `use` item. So we update them all to the maximum value\n+                        // among the potential individual effective visibilities. Maybe HIR for\n+                        // imports shouldn't use three IDs at all.\n+                        update(import.id);\n+                        if let ImportKind::Single { additional_ids, .. } = import.kind {\n+                            update(additional_ids.0);\n+                            update(additional_ids.1);\n+                        }\n \n                         level = AccessLevel::Exported;\n-                        prev_parent_id = id;\n+                        prev_parent_id = self.r.local_def_id(import.id);\n                         binding = nested_binding;\n                     }\n                 }"}, {"sha": "5d868ebec94482d0fdfef0d50dc700c41b56f2b4", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -24,7 +24,7 @@ use rustc_span::hygiene::MacroKind;\n use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_span::{BytePos, Span};\n+use rustc_span::{BytePos, Span, SyntaxContext};\n \n use crate::imports::{Import, ImportKind, ImportResolver};\n use crate::late::{PatternSource, Rib};\n@@ -47,13 +47,15 @@ pub(crate) type Suggestion = (Vec<(Span, String)>, String, Applicability);\n /// similarly named label and whether or not it is reachable.\n pub(crate) type LabelSuggestion = (Ident, bool);\n \n+#[derive(Debug)]\n pub(crate) enum SuggestionTarget {\n     /// The target has a similar name as the name used by the programmer (probably a typo)\n     SimilarlyNamed,\n     /// The target is the only valid item that can be used in the corresponding context\n     SingleItem,\n }\n \n+#[derive(Debug)]\n pub(crate) struct TypoSuggestion {\n     pub candidate: Symbol,\n     pub res: Res,\n@@ -482,11 +484,12 @@ impl<'a> Resolver<'a> {\n         module: Module<'a>,\n         names: &mut Vec<TypoSuggestion>,\n         filter_fn: &impl Fn(Res) -> bool,\n+        ctxt: Option<SyntaxContext>,\n     ) {\n         for (key, resolution) in self.resolutions(module).borrow().iter() {\n             if let Some(binding) = resolution.borrow().binding {\n                 let res = binding.res();\n-                if filter_fn(res) {\n+                if filter_fn(res) && ctxt.map_or(true, |ctxt| ctxt == key.ident.span.ctxt()) {\n                     names.push(TypoSuggestion::typo_from_res(key.ident.name, res));\n                 }\n             }\n@@ -1181,10 +1184,10 @@ impl<'a> Resolver<'a> {\n                 Scope::CrateRoot => {\n                     let root_ident = Ident::new(kw::PathRoot, ident.span);\n                     let root_module = this.resolve_crate_root(root_ident);\n-                    this.add_module_candidates(root_module, &mut suggestions, filter_fn);\n+                    this.add_module_candidates(root_module, &mut suggestions, filter_fn, None);\n                 }\n                 Scope::Module(module, _) => {\n-                    this.add_module_candidates(module, &mut suggestions, filter_fn);\n+                    this.add_module_candidates(module, &mut suggestions, filter_fn, None);\n                 }\n                 Scope::MacroUsePrelude => {\n                     suggestions.extend(this.macro_use_prelude.iter().filter_map(\n@@ -1221,7 +1224,7 @@ impl<'a> Resolver<'a> {\n                 Scope::StdLibPrelude => {\n                     if let Some(prelude) = this.prelude {\n                         let mut tmp_suggestions = Vec::new();\n-                        this.add_module_candidates(prelude, &mut tmp_suggestions, filter_fn);\n+                        this.add_module_candidates(prelude, &mut tmp_suggestions, filter_fn, None);\n                         suggestions.extend(\n                             tmp_suggestions\n                                 .into_iter()"}, {"sha": "f2cc50c199fc8119dda242d66136d406d4e77adf", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 1, "deletions": 26, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -2,7 +2,7 @@\n \n use crate::diagnostics::{import_candidates, Suggestion};\n use crate::Determinacy::{self, *};\n-use crate::Namespace::{self, *};\n+use crate::Namespace::*;\n use crate::{module_to_string, names_to_string, ImportSuggestion};\n use crate::{AmbiguityKind, BindingKey, ModuleKind, ResolutionError, Resolver, Segment};\n use crate::{Finalize, Module, ModuleOrUniformRoot, ParentScope, PerNS, ScopeSet};\n@@ -371,31 +371,6 @@ impl<'a> Resolver<'a> {\n             self.used_imports.insert(import.id);\n         }\n     }\n-\n-    /// Take primary and additional node IDs from an import and select one that corresponds to the\n-    /// given namespace. The logic must match the corresponding logic from `fn lower_use_tree` that\n-    /// assigns resolutons to IDs.\n-    pub(crate) fn import_id_for_ns(&self, import: &Import<'_>, ns: Namespace) -> NodeId {\n-        if let ImportKind::Single { additional_ids: (id1, id2), .. } = import.kind {\n-            if let Some(resolutions) = self.import_res_map.get(&import.id) {\n-                assert!(resolutions[ns].is_some(), \"incorrectly finalized import\");\n-                return match ns {\n-                    TypeNS => import.id,\n-                    ValueNS => match resolutions.type_ns {\n-                        Some(_) => id1,\n-                        None => import.id,\n-                    },\n-                    MacroNS => match (resolutions.type_ns, resolutions.value_ns) {\n-                        (Some(_), Some(_)) => id2,\n-                        (Some(_), None) | (None, Some(_)) => id1,\n-                        (None, None) => import.id,\n-                    },\n-                };\n-            }\n-        }\n-\n-        import.id\n-    }\n }\n \n /// An error that may be transformed into a diagnostic later. Used to combine multiple unresolved"}, {"sha": "58853346a92889e8cdca7d8ddaaf34ef3640e9eb", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -524,6 +524,9 @@ struct DiagnosticMetadata<'ast> {\n     /// Used to detect possible `if let` written without `let` and to provide structured suggestion.\n     in_if_condition: Option<&'ast Expr>,\n \n+    /// Used to detect possible new binding written without `let` and to provide structured suggestion.\n+    in_assignment: Option<&'ast Expr>,\n+\n     /// If we are currently in a trait object definition. Used to point at the bounds when\n     /// encountering a struct or enum.\n     current_trait_object: Option<&'ast [ast::GenericBound]>,\n@@ -3905,6 +3908,11 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 self.resolve_expr(elem, Some(expr));\n                 self.visit_expr(idx);\n             }\n+            ExprKind::Assign(..) => {\n+                let old = self.diagnostic_metadata.in_assignment.replace(expr);\n+                visit::walk_expr(self, expr);\n+                self.diagnostic_metadata.in_assignment = old;\n+            }\n             _ => {\n                 visit::walk_expr(self, expr);\n             }"}, {"sha": "850f023b1c16b4c2b101b9e4771307faa518c79b", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 133, "deletions": 75, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -38,8 +38,8 @@ type Res = def::Res<ast::NodeId>;\n /// A field or associated item from self type suggested in case of resolution failure.\n enum AssocSuggestion {\n     Field,\n-    MethodWithSelf,\n-    AssocFn,\n+    MethodWithSelf { called: bool },\n+    AssocFn { called: bool },\n     AssocType,\n     AssocConst,\n }\n@@ -48,8 +48,14 @@ impl AssocSuggestion {\n     fn action(&self) -> &'static str {\n         match self {\n             AssocSuggestion::Field => \"use the available field\",\n-            AssocSuggestion::MethodWithSelf => \"call the method with the fully-qualified path\",\n-            AssocSuggestion::AssocFn => \"call the associated function\",\n+            AssocSuggestion::MethodWithSelf { called: true } => {\n+                \"call the method with the fully-qualified path\"\n+            }\n+            AssocSuggestion::MethodWithSelf { called: false } => {\n+                \"refer to the method with the fully-qualified path\"\n+            }\n+            AssocSuggestion::AssocFn { called: true } => \"call the associated function\",\n+            AssocSuggestion::AssocFn { called: false } => \"refer to the associated function\",\n             AssocSuggestion::AssocConst => \"use the associated `const`\",\n             AssocSuggestion::AssocType => \"use the associated type\",\n         }\n@@ -131,6 +137,7 @@ pub(super) enum LifetimeElisionCandidate {\n }\n \n /// Only used for diagnostics.\n+#[derive(Debug)]\n struct BaseError {\n     msg: String,\n     fallback_label: String,\n@@ -140,6 +147,22 @@ struct BaseError {\n     suggestion: Option<(Span, &'static str, String)>,\n }\n \n+#[derive(Debug)]\n+enum TypoCandidate {\n+    Typo(TypoSuggestion),\n+    Shadowed(Res),\n+    None,\n+}\n+\n+impl TypoCandidate {\n+    fn to_opt_suggestion(self) -> Option<TypoSuggestion> {\n+        match self {\n+            TypoCandidate::Typo(sugg) => Some(sugg),\n+            TypoCandidate::Shadowed(_) | TypoCandidate::None => None,\n+        }\n+    }\n+}\n+\n impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n     fn def_span(&self, def_id: DefId) -> Option<Span> {\n         match def_id.krate {\n@@ -496,9 +519,12 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         }\n \n         // Try Levenshtein algorithm.\n-        let typo_sugg = self.lookup_typo_candidate(path, source.namespace(), is_expected);\n+        let typo_sugg =\n+            self.lookup_typo_candidate(path, source.namespace(), is_expected).to_opt_suggestion();\n         if path.len() == 1 && self.self_type_is_available() {\n-            if let Some(candidate) = self.lookup_assoc_candidate(ident, ns, is_expected) {\n+            if let Some(candidate) =\n+                self.lookup_assoc_candidate(ident, ns, is_expected, source.is_call())\n+            {\n                 let self_is_available = self.self_value_is_available(path[0].ident.span);\n                 match candidate {\n                     AssocSuggestion::Field => {\n@@ -513,16 +539,21 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                             err.span_label(span, \"a field by this name exists in `Self`\");\n                         }\n                     }\n-                    AssocSuggestion::MethodWithSelf if self_is_available => {\n+                    AssocSuggestion::MethodWithSelf { called } if self_is_available => {\n+                        let msg = if called {\n+                            \"you might have meant to call the method\"\n+                        } else {\n+                            \"you might have meant to refer to the method\"\n+                        };\n                         err.span_suggestion(\n                             span,\n-                            \"you might have meant to call the method\",\n+                            msg,\n                             format!(\"self.{path_str}\"),\n                             Applicability::MachineApplicable,\n                         );\n                     }\n-                    AssocSuggestion::MethodWithSelf\n-                    | AssocSuggestion::AssocFn\n+                    AssocSuggestion::MethodWithSelf { .. }\n+                    | AssocSuggestion::AssocFn { .. }\n                     | AssocSuggestion::AssocConst\n                     | AssocSuggestion::AssocType => {\n                         err.span_suggestion(\n@@ -660,7 +691,18 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         let is_expected = &|res| source.is_expected(res);\n         let ident_span = path.last().map_or(span, |ident| ident.ident.span);\n         let typo_sugg = self.lookup_typo_candidate(path, source.namespace(), is_expected);\n+        if let TypoCandidate::Shadowed(res) = typo_sugg\n+            && let Some(id) = res.opt_def_id()\n+            && let Some(sugg_span) = self.r.opt_span(id)\n+        {\n+            err.span_label(\n+                sugg_span,\n+                format!(\"you might have meant to refer to this {}\", res.descr()),\n+            );\n+            return true;\n+        }\n         let mut fallback = false;\n+        let typo_sugg = typo_sugg.to_opt_suggestion();\n         if !self.r.add_typo_suggestion(err, typo_sugg, ident_span) {\n             fallback = true;\n             match self.diagnostic_metadata.current_let_binding {\n@@ -679,7 +721,9 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n \n             // If the trait has a single item (which wasn't matched by Levenshtein), suggest it\n             let suggestion = self.get_single_associated_item(&path, &source, is_expected);\n-            self.r.add_typo_suggestion(err, suggestion, ident_span);\n+            if !self.r.add_typo_suggestion(err, suggestion, ident_span) {\n+                fallback = !self.let_binding_suggestion(err, ident_span);\n+            }\n         }\n         fallback\n     }\n@@ -1076,41 +1120,14 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         // where a brace being opened means a block is being started. Look\n         // ahead for the next text to see if `span` is followed by a `{`.\n         let sm = self.r.session.source_map();\n-        let mut sp = span;\n-        loop {\n-            sp = sm.next_point(sp);\n-            match sm.span_to_snippet(sp) {\n-                Ok(ref snippet) => {\n-                    if snippet.chars().any(|c| !c.is_whitespace()) {\n-                        break;\n-                    }\n-                }\n-                _ => break,\n-            }\n-        }\n+        let sp = sm.span_look_ahead(span, None, Some(50));\n         let followed_by_brace = matches!(sm.span_to_snippet(sp), Ok(ref snippet) if snippet == \"{\");\n         // In case this could be a struct literal that needs to be surrounded\n         // by parentheses, find the appropriate span.\n-        let mut i = 0;\n-        let mut closing_brace = None;\n-        loop {\n-            sp = sm.next_point(sp);\n-            match sm.span_to_snippet(sp) {\n-                Ok(ref snippet) => {\n-                    if snippet == \"}\" {\n-                        closing_brace = Some(span.to(sp));\n-                        break;\n-                    }\n-                }\n-                _ => break,\n-            }\n-            i += 1;\n-            // The bigger the span, the more likely we're incorrect --\n-            // bound it to 100 chars long.\n-            if i > 100 {\n-                break;\n-            }\n-        }\n+        let closing_span = sm.span_look_ahead(span, Some(\"}\"), Some(50));\n+        let closing_brace: Option<Span> = sm\n+            .span_to_snippet(closing_span)\n+            .map_or(None, |s| if s == \"}\" { Some(span.to(closing_span)) } else { None });\n         (followed_by_brace, closing_brace)\n     }\n \n@@ -1494,6 +1511,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         ident: Ident,\n         ns: Namespace,\n         filter_fn: FilterFn,\n+        called: bool,\n     ) -> Option<AssocSuggestion>\n     where\n         FilterFn: Fn(Res) -> bool,\n@@ -1535,9 +1553,9 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                     return Some(match &assoc_item.kind {\n                         ast::AssocItemKind::Const(..) => AssocSuggestion::AssocConst,\n                         ast::AssocItemKind::Fn(box ast::Fn { sig, .. }) if sig.decl.has_self() => {\n-                            AssocSuggestion::MethodWithSelf\n+                            AssocSuggestion::MethodWithSelf { called }\n                         }\n-                        ast::AssocItemKind::Fn(..) => AssocSuggestion::AssocFn,\n+                        ast::AssocItemKind::Fn(..) => AssocSuggestion::AssocFn { called },\n                         ast::AssocItemKind::Type(..) => AssocSuggestion::AssocType,\n                         ast::AssocItemKind::MacCall(_) => continue,\n                     });\n@@ -1556,10 +1574,12 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 let res = binding.res();\n                 if filter_fn(res) {\n                     if self.r.has_self.contains(&res.def_id()) {\n-                        return Some(AssocSuggestion::MethodWithSelf);\n+                        return Some(AssocSuggestion::MethodWithSelf { called });\n                     } else {\n                         match res {\n-                            Res::Def(DefKind::AssocFn, _) => return Some(AssocSuggestion::AssocFn),\n+                            Res::Def(DefKind::AssocFn, _) => {\n+                                return Some(AssocSuggestion::AssocFn { called });\n+                            }\n                             Res::Def(DefKind::AssocConst, _) => {\n                                 return Some(AssocSuggestion::AssocConst);\n                             }\n@@ -1581,22 +1601,38 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         path: &[Segment],\n         ns: Namespace,\n         filter_fn: &impl Fn(Res) -> bool,\n-    ) -> Option<TypoSuggestion> {\n+    ) -> TypoCandidate {\n         let mut names = Vec::new();\n         if path.len() == 1 {\n+            let mut ctxt = path.last().unwrap().ident.span.ctxt();\n+\n             // Search in lexical scope.\n             // Walk backwards up the ribs in scope and collect candidates.\n             for rib in self.ribs[ns].iter().rev() {\n+                let rib_ctxt = if rib.kind.contains_params() {\n+                    ctxt.normalize_to_macros_2_0()\n+                } else {\n+                    ctxt.normalize_to_macro_rules()\n+                };\n+\n                 // Locals and type parameters\n                 for (ident, &res) in &rib.bindings {\n-                    if filter_fn(res) {\n+                    if filter_fn(res) && ident.span.ctxt() == rib_ctxt {\n                         names.push(TypoSuggestion::typo_from_res(ident.name, res));\n                     }\n                 }\n+\n+                if let RibKind::MacroDefinition(def) = rib.kind && def == self.r.macro_def(ctxt) {\n+                    // If an invocation of this macro created `ident`, give up on `ident`\n+                    // and switch to `ident`'s source from the macro definition.\n+                    ctxt.remove_mark();\n+                    continue;\n+                }\n+\n                 // Items in scope\n                 if let RibKind::ModuleRibKind(module) = rib.kind {\n                     // Items from this module\n-                    self.r.add_module_candidates(module, &mut names, &filter_fn);\n+                    self.r.add_module_candidates(module, &mut names, &filter_fn, Some(ctxt));\n \n                     if let ModuleKind::Block = module.kind {\n                         // We can see through blocks\n@@ -1622,7 +1658,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                             }));\n \n                             if let Some(prelude) = self.r.prelude {\n-                                self.r.add_module_candidates(prelude, &mut names, &filter_fn);\n+                                self.r.add_module_candidates(prelude, &mut names, &filter_fn, None);\n                             }\n                         }\n                         break;\n@@ -1641,7 +1677,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n             if let PathResult::Module(ModuleOrUniformRoot::Module(module)) =\n                 self.resolve_path(mod_path, Some(TypeNS), None)\n             {\n-                self.r.add_module_candidates(module, &mut names, &filter_fn);\n+                self.r.add_module_candidates(module, &mut names, &filter_fn, None);\n             }\n         }\n \n@@ -1654,10 +1690,17 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n             name,\n             None,\n         ) {\n-            Some(found) if found != name => {\n-                names.into_iter().find(|suggestion| suggestion.candidate == found)\n+            Some(found) => {\n+                let Some(sugg) = names.into_iter().find(|suggestion| suggestion.candidate == found) else {\n+                    return TypoCandidate::None;\n+                };\n+                if found == name {\n+                    TypoCandidate::Shadowed(sugg.res)\n+                } else {\n+                    TypoCandidate::Typo(sugg)\n+                }\n             }\n-            _ => None,\n+            _ => TypoCandidate::None,\n         }\n     }\n \n@@ -1727,26 +1770,16 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                             }\n                         }\n                         if let Ok(base_snippet) = base_snippet {\n-                            let mut sp = after_colon_sp;\n-                            for _ in 0..100 {\n-                                // Try to find an assignment\n-                                sp = sm.next_point(sp);\n-                                let snippet = sm.span_to_snippet(sp);\n-                                match snippet {\n-                                    Ok(ref x) if x.as_str() == \"=\" => {\n-                                        err.span_suggestion(\n-                                            base_span,\n-                                            \"maybe you meant to write an assignment here\",\n-                                            format!(\"let {}\", base_snippet),\n-                                            Applicability::MaybeIncorrect,\n-                                        );\n-                                        show_label = false;\n-                                        break;\n-                                    }\n-                                    Ok(ref x) if x.as_str() == \"\\n\" => break,\n-                                    Err(_) => break,\n-                                    Ok(_) => {}\n-                                }\n+                            // Try to find an assignment\n+                            let eq_span = sm.span_look_ahead(after_colon_sp, Some(\"=\"), Some(50));\n+                            if let Ok(ref snippet) = sm.span_to_snippet(eq_span) && snippet == \"=\" {\n+                                err.span_suggestion(\n+                                    base_span,\n+                                    \"maybe you meant to write an assignment here\",\n+                                    format!(\"let {}\", base_snippet),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                                show_label = false;\n                             }\n                         }\n                     }\n@@ -1763,6 +1796,31 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         false\n     }\n \n+    fn let_binding_suggestion(&self, err: &mut Diagnostic, ident_span: Span) -> bool {\n+        // try to give a suggestion for this pattern: `name = 1`, which is common in other languages\n+        let mut added_suggestion = false;\n+        if let Some(Expr { kind: ExprKind::Assign(lhs, _rhs, _), .. }) = self.diagnostic_metadata.in_assignment &&\n+            let ast::ExprKind::Path(None, _) = lhs.kind {\n+                let sm = self.r.session.source_map();\n+                let line_span = sm.span_extend_to_line(ident_span);\n+                let ident_name = sm.span_to_snippet(ident_span).unwrap();\n+                // HACK(chenyukang): make sure ident_name is at the starting of the line to protect against macros\n+                if sm\n+                    .span_to_snippet(line_span)\n+                    .map_or(false, |s| s.trim().starts_with(&ident_name))\n+                {\n+                    err.span_suggestion_verbose(\n+                        ident_span.shrink_to_lo(),\n+                        \"you might have meant to introduce a new binding\",\n+                        \"let \".to_string(),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                    added_suggestion = true;\n+                }\n+            }\n+        added_suggestion\n+    }\n+\n     fn find_module(&mut self, def_id: DefId) -> Option<(Module<'a>, ImportSuggestion)> {\n         let mut result = None;\n         let mut seen_modules = FxHashSet::default();"}, {"sha": "9526296f9511530119db79663bd07f0f61099300", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -12,7 +12,7 @@ use rustc_attr::StabilityLevel;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::intern::Interned;\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::struct_span_err;\n+use rustc_errors::{struct_span_err, Applicability};\n use rustc_expand::base::{Annotatable, DeriveResolutions, Indeterminate, ResolverExpand};\n use rustc_expand::base::{SyntaxExtension, SyntaxExtensionKind};\n use rustc_expand::compile_declarative_macro;\n@@ -694,7 +694,19 @@ impl<'a> Resolver<'a> {\n                     check_consistency(self, &path, path_span, kind, initial_res, res)\n                 }\n                 path_res @ PathResult::NonModule(..) | path_res @ PathResult::Failed { .. } => {\n+                    let mut suggestion = None;\n                     let (span, label) = if let PathResult::Failed { span, label, .. } = path_res {\n+                        // try to suggest if it's not a macro, maybe a function\n+                        if let PathResult::NonModule(partial_res) = self.maybe_resolve_path(&path, Some(ValueNS), &parent_scope)\n+                            && partial_res.unresolved_segments() == 0 {\n+                            let sm = self.session.source_map();\n+                            let exclamation_span = sm.next_point(span);\n+                            suggestion = Some((\n+                                vec![(exclamation_span, \"\".to_string())],\n+                                    format!(\"{} is not a macro, but a {}, try to remove `!`\", Segment::names_to_string(&path), partial_res.base_res().descr()),\n+                                    Applicability::MaybeIncorrect\n+                                ));\n+                        }\n                         (span, label)\n                     } else {\n                         (\n@@ -708,7 +720,7 @@ impl<'a> Resolver<'a> {\n                     };\n                     self.report_error(\n                         span,\n-                        ResolutionError::FailedToResolve { label, suggestion: None },\n+                        ResolutionError::FailedToResolve { label, suggestion },\n                     );\n                 }\n                 PathResult::Module(..) | PathResult::Indeterminate => unreachable!(),"}, {"sha": "585aac8c1c3cc034fabcde0ea890a4e7c1ddb32c", "filename": "compiler/rustc_save_analysis/src/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_save_analysis%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_save_analysis%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Ferrors.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -3,7 +3,7 @@ use rustc_macros::Diagnostic;\n use std::path::Path;\n \n #[derive(Diagnostic)]\n-#[diag(save_analysis::could_not_open)]\n+#[diag(save_analysis_could_not_open)]\n pub(crate) struct CouldNotOpen<'a> {\n     pub file_name: &'a Path,\n     pub err: std::io::Error,"}, {"sha": "53692ad7cc92b8d56ffc5a88a955ddbc6e283a02", "filename": "compiler/rustc_session/src/config/sigpipe.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_session%2Fsrc%2Fconfig%2Fsigpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_session%2Fsrc%2Fconfig%2Fsigpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig%2Fsigpipe.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -1,5 +1,13 @@\n //! NOTE: Keep these constants in sync with `library/std/src/sys/unix/mod.rs`!\n \n+/// The default value if `#[unix_sigpipe]` is not specified. This resolves\n+/// to `SIG_IGN` in `library/std/src/sys/unix/mod.rs`.\n+///\n+/// Note that `SIG_IGN` has been the Rust default since 2014. See\n+/// <https://github.com/rust-lang/rust/issues/62569>.\n+#[allow(dead_code)]\n+pub const DEFAULT: u8 = 0;\n+\n /// Do not touch `SIGPIPE`. Use whatever the parent process uses.\n #[allow(dead_code)]\n pub const INHERIT: u8 = 1;\n@@ -15,8 +23,3 @@ pub const SIG_IGN: u8 = 2;\n /// such as `head -n 1`.\n #[allow(dead_code)]\n pub const SIG_DFL: u8 = 3;\n-\n-/// `SIG_IGN` has been the Rust default since 2014. See\n-/// <https://github.com/rust-lang/rust/issues/62569>.\n-#[allow(dead_code)]\n-pub const DEFAULT: u8 = SIG_IGN;"}, {"sha": "bf542faec41d672eec81641e4a4ef5c5b1103f89", "filename": "compiler/rustc_session/src/errors.rs", "status": "modified", "additions": 50, "deletions": 39, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Ferrors.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -1,15 +1,13 @@\n use std::num::NonZeroU32;\n \n use crate::cgu_reuse_tracker::CguReuse;\n-use rustc_errors::{\n-    fluent, DiagnosticBuilder, ErrorGuaranteed, Handler, IntoDiagnostic, MultiSpan,\n-};\n+use rustc_errors::MultiSpan;\n use rustc_macros::Diagnostic;\n use rustc_span::{Span, Symbol};\n use rustc_target::spec::{SplitDebuginfo, StackProtector, TargetTriple};\n \n #[derive(Diagnostic)]\n-#[diag(session::incorrect_cgu_reuse_type)]\n+#[diag(session_incorrect_cgu_reuse_type)]\n pub struct IncorrectCguReuseType<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -20,114 +18,114 @@ pub struct IncorrectCguReuseType<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(session::cgu_not_recorded)]\n+#[diag(session_cgu_not_recorded)]\n pub struct CguNotRecorded<'a> {\n     pub cgu_user_name: &'a str,\n     pub cgu_name: &'a str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(session::feature_gate_error, code = \"E0658\")]\n+#[diag(session_feature_gate_error, code = \"E0658\")]\n pub struct FeatureGateError<'a> {\n     #[primary_span]\n     pub span: MultiSpan,\n     pub explain: &'a str,\n }\n \n #[derive(Subdiagnostic)]\n-#[note(session::feature_diagnostic_for_issue)]\n+#[note(session_feature_diagnostic_for_issue)]\n pub struct FeatureDiagnosticForIssue {\n     pub n: NonZeroU32,\n }\n \n #[derive(Subdiagnostic)]\n-#[help(session::feature_diagnostic_help)]\n+#[help(session_feature_diagnostic_help)]\n pub struct FeatureDiagnosticHelp {\n     pub feature: Symbol,\n }\n \n #[derive(Diagnostic)]\n-#[diag(session::not_circumvent_feature)]\n+#[diag(session_not_circumvent_feature)]\n pub struct NotCircumventFeature;\n \n #[derive(Diagnostic)]\n-#[diag(session::linker_plugin_lto_windows_not_supported)]\n+#[diag(session_linker_plugin_lto_windows_not_supported)]\n pub struct LinkerPluginToWindowsNotSupported;\n \n #[derive(Diagnostic)]\n-#[diag(session::profile_use_file_does_not_exist)]\n+#[diag(session_profile_use_file_does_not_exist)]\n pub struct ProfileUseFileDoesNotExist<'a> {\n     pub path: &'a std::path::Path,\n }\n \n #[derive(Diagnostic)]\n-#[diag(session::profile_sample_use_file_does_not_exist)]\n+#[diag(session_profile_sample_use_file_does_not_exist)]\n pub struct ProfileSampleUseFileDoesNotExist<'a> {\n     pub path: &'a std::path::Path,\n }\n \n #[derive(Diagnostic)]\n-#[diag(session::target_requires_unwind_tables)]\n+#[diag(session_target_requires_unwind_tables)]\n pub struct TargetRequiresUnwindTables;\n \n #[derive(Diagnostic)]\n-#[diag(session::sanitizer_not_supported)]\n+#[diag(session_sanitizer_not_supported)]\n pub struct SanitizerNotSupported {\n     pub us: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(session::sanitizers_not_supported)]\n+#[diag(session_sanitizers_not_supported)]\n pub struct SanitizersNotSupported {\n     pub us: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(session::cannot_mix_and_match_sanitizers)]\n+#[diag(session_cannot_mix_and_match_sanitizers)]\n pub struct CannotMixAndMatchSanitizers {\n     pub first: String,\n     pub second: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(session::cannot_enable_crt_static_linux)]\n+#[diag(session_cannot_enable_crt_static_linux)]\n pub struct CannotEnableCrtStaticLinux;\n \n #[derive(Diagnostic)]\n-#[diag(session::sanitizer_cfi_enabled)]\n+#[diag(session_sanitizer_cfi_enabled)]\n pub struct SanitizerCfiEnabled;\n \n #[derive(Diagnostic)]\n-#[diag(session::unstable_virtual_function_elimination)]\n+#[diag(session_unstable_virtual_function_elimination)]\n pub struct UnstableVirtualFunctionElimination;\n \n #[derive(Diagnostic)]\n-#[diag(session::unsupported_dwarf_version)]\n+#[diag(session_unsupported_dwarf_version)]\n pub struct UnsupportedDwarfVersion {\n     pub dwarf_version: u32,\n }\n \n #[derive(Diagnostic)]\n-#[diag(session::target_stack_protector_not_supported)]\n+#[diag(session_target_stack_protector_not_supported)]\n pub struct StackProtectorNotSupportedForTarget<'a> {\n     pub stack_protector: StackProtector,\n     pub target_triple: &'a TargetTriple,\n }\n \n #[derive(Diagnostic)]\n-#[diag(session::split_debuginfo_unstable_platform)]\n+#[diag(session_split_debuginfo_unstable_platform)]\n pub struct SplitDebugInfoUnstablePlatform {\n     pub debuginfo: SplitDebuginfo,\n }\n \n #[derive(Diagnostic)]\n-#[diag(session::file_is_not_writeable)]\n+#[diag(session_file_is_not_writeable)]\n pub struct FileIsNotWriteable<'a> {\n     pub file: &'a std::path::Path,\n }\n \n #[derive(Diagnostic)]\n-#[diag(session::crate_name_does_not_match)]\n+#[diag(session_crate_name_does_not_match)]\n pub struct CrateNameDoesNotMatch<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -136,38 +134,29 @@ pub struct CrateNameDoesNotMatch<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(session::crate_name_invalid)]\n+#[diag(session_crate_name_invalid)]\n pub struct CrateNameInvalid<'a> {\n     pub s: &'a str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(session::crate_name_empty)]\n+#[diag(session_crate_name_empty)]\n pub struct CrateNameEmpty {\n     #[primary_span]\n     pub span: Option<Span>,\n }\n \n+#[derive(Diagnostic)]\n+#[diag(session_invalid_character_in_create_name)]\n pub struct InvalidCharacterInCrateName<'a> {\n+    #[primary_span]\n     pub span: Option<Span>,\n     pub character: char,\n     pub crate_name: &'a str,\n }\n \n-impl IntoDiagnostic<'_> for InvalidCharacterInCrateName<'_> {\n-    fn into_diagnostic(self, sess: &Handler) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n-        let mut diag = sess.struct_err(fluent::session::invalid_character_in_create_name);\n-        if let Some(sp) = self.span {\n-            diag.set_span(sp);\n-        }\n-        diag.set_arg(\"character\", self.character);\n-        diag.set_arg(\"crate_name\", self.crate_name);\n-        diag\n-    }\n-}\n-\n #[derive(Subdiagnostic)]\n-#[multipart_suggestion(session::expr_parentheses_needed, applicability = \"machine-applicable\")]\n+#[multipart_suggestion(session_expr_parentheses_needed, applicability = \"machine-applicable\")]\n pub struct ExprParenthesesNeeded {\n     #[suggestion_part(code = \"(\")]\n     pub left: Span,\n@@ -180,3 +169,25 @@ impl ExprParenthesesNeeded {\n         ExprParenthesesNeeded { left: s.shrink_to_lo(), right: s.shrink_to_hi() }\n     }\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(session_skipping_const_checks)]\n+pub struct SkippingConstChecks {\n+    #[subdiagnostic(eager)]\n+    pub unleashed_features: Vec<UnleashedFeatureHelp>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum UnleashedFeatureHelp {\n+    #[help(session_unleashed_feature_help_named)]\n+    Named {\n+        #[primary_span]\n+        span: Span,\n+        gate: Symbol,\n+    },\n+    #[help(session_unleashed_feature_help_unnamed)]\n+    Unnamed {\n+        #[primary_span]\n+        span: Span,\n+    },\n+}"}, {"sha": "3f234a47a3d86bdacdc7c108ffb7070bf42814c9", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -1295,6 +1295,8 @@ options! {\n         an additional `.html` file showing the computed coverage spans.\"),\n     dwarf_version: Option<u32> = (None, parse_opt_number, [TRACKED],\n         \"version of DWARF debug information to emit (default: 2 or 4, depending on platform)\"),\n+    dylib_lto: bool = (false, parse_bool, [UNTRACKED],\n+        \"enables LTO for dylib crate type\"),\n     emit_stack_sizes: bool = (false, parse_bool, [UNTRACKED],\n         \"emit a section containing stack size metadata (default: no)\"),\n     emit_thin_lto: bool = (true, parse_bool, [TRACKED],"}, {"sha": "100c66f63641c6cda1174344062cb72b6d557f2a", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -5,9 +5,10 @@ use crate::config::{self, CrateType, InstrumentCoverage, OptLevel, OutputType, S\n use crate::errors::{\n     CannotEnableCrtStaticLinux, CannotMixAndMatchSanitizers, LinkerPluginToWindowsNotSupported,\n     NotCircumventFeature, ProfileSampleUseFileDoesNotExist, ProfileUseFileDoesNotExist,\n-    SanitizerCfiEnabled, SanitizerNotSupported, SanitizersNotSupported,\n+    SanitizerCfiEnabled, SanitizerNotSupported, SanitizersNotSupported, SkippingConstChecks,\n     SplitDebugInfoUnstablePlatform, StackProtectorNotSupportedForTarget,\n-    TargetRequiresUnwindTables, UnstableVirtualFunctionElimination, UnsupportedDwarfVersion,\n+    TargetRequiresUnwindTables, UnleashedFeatureHelp, UnstableVirtualFunctionElimination,\n+    UnsupportedDwarfVersion,\n };\n use crate::parse::{add_feature_diagnostics, ParseSess};\n use crate::search_paths::{PathKind, SearchPath};\n@@ -232,21 +233,19 @@ impl Session {\n         if !unleashed_features.is_empty() {\n             let mut must_err = false;\n             // Create a diagnostic pointing at where things got unleashed.\n-            // FIXME(#100717): needs eager translation/lists\n-            #[allow(rustc::untranslatable_diagnostic)]\n-            #[allow(rustc::diagnostic_outside_of_impl)]\n-            let mut diag = self.struct_warn(\"skipping const checks\");\n-            for &(span, feature_gate) in unleashed_features.iter() {\n-                // FIXME: `span_label` doesn't do anything, so we use \"help\" as a hack.\n-                if let Some(gate) = feature_gate {\n-                    diag.span_help(span, &format!(\"skipping check for `{gate}` feature\"));\n-                    // The unleash flag must *not* be used to just \"hack around\" feature gates.\n-                    must_err = true;\n-                } else {\n-                    diag.span_help(span, \"skipping check that does not even have a feature gate\");\n-                }\n-            }\n-            diag.emit();\n+            self.emit_warning(SkippingConstChecks {\n+                unleashed_features: unleashed_features\n+                    .iter()\n+                    .map(|(span, gate)| {\n+                        gate.map(|gate| {\n+                            must_err = true;\n+                            UnleashedFeatureHelp::Named { span: *span, gate }\n+                        })\n+                        .unwrap_or(UnleashedFeatureHelp::Unnamed { span: *span })\n+                    })\n+                    .collect(),\n+            });\n+\n             // If we should err, make sure we did.\n             if must_err && self.has_errors().is_none() {\n                 // We have skipped a feature gate, and not run into other errors... reject."}, {"sha": "e65b6891e3221077fe6a50de79c7a37a91b90ee9", "filename": "compiler/rustc_session/src/utils.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_session%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_session%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Futils.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -53,6 +53,17 @@ impl NativeLibKind {\n             NativeLibKind::RawDylib | NativeLibKind::Unspecified | NativeLibKind::LinkArg => false,\n         }\n     }\n+\n+    pub fn is_statically_included(&self) -> bool {\n+        matches!(self, NativeLibKind::Static { .. })\n+    }\n+\n+    pub fn is_dllimport(&self) -> bool {\n+        matches!(\n+            self,\n+            NativeLibKind::Dylib { .. } | NativeLibKind::RawDylib | NativeLibKind::Unspecified\n+        )\n+    }\n }\n \n #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Encodable, Decodable)]"}, {"sha": "842aa98bc9ef7c89a7266285dcdf03c8cede6f24", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -1631,10 +1631,7 @@ impl SourceFile {\n     /// number. If the source_file is empty or the position is located before the\n     /// first line, `None` is returned.\n     pub fn lookup_line(&self, pos: BytePos) -> Option<usize> {\n-        self.lines(|lines| match lines.partition_point(|x| x <= &pos) {\n-            0 => None,\n-            i => Some(i - 1),\n-        })\n+        self.lines(|lines| lines.partition_point(|x| x <= &pos).checked_sub(1))\n     }\n \n     pub fn line_bounds(&self, line_index: usize) -> Range<BytePos> {"}, {"sha": "f9566eeee9465949b17e4c133a7b7f3d5d31e1ff", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -877,6 +877,26 @@ impl SourceMap {\n         Span::new(BytePos(start_of_next_point), end_of_next_point, sp.ctxt(), None)\n     }\n \n+    /// Returns a new span to check next none-whitespace character or some specified expected character\n+    /// If `expect` is none, the first span of non-whitespace character is returned.\n+    /// If `expect` presented, the first span of the character `expect` is returned\n+    /// Otherwise, the span reached to limit is returned.\n+    pub fn span_look_ahead(&self, span: Span, expect: Option<&str>, limit: Option<usize>) -> Span {\n+        let mut sp = span;\n+        for _ in 0..limit.unwrap_or(100 as usize) {\n+            sp = self.next_point(sp);\n+            if let Ok(ref snippet) = self.span_to_snippet(sp) {\n+                if expect.map_or(false, |es| snippet == es) {\n+                    break;\n+                }\n+                if expect.is_none() && snippet.chars().any(|c| !c.is_whitespace()) {\n+                    break;\n+                }\n+            }\n+        }\n+        sp\n+    }\n+\n     /// Finds the width of the character, either before or after the end of provided span,\n     /// depending on the `forwards` parameter.\n     fn find_width_of_character_at_span(&self, sp: Span, forwards: bool) -> u32 {"}, {"sha": "f4d0751f75370ea3c0bf27c96b3744a5a7f6bb3f", "filename": "compiler/rustc_symbol_mangling/src/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_symbol_mangling%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_symbol_mangling%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ferrors.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -5,7 +5,7 @@ use rustc_macros::Diagnostic;\n use rustc_span::Span;\n \n #[derive(Diagnostic)]\n-#[diag(symbol_mangling::test_output)]\n+#[diag(symbol_mangling_test_output)]\n pub struct TestOutput {\n     #[primary_span]\n     pub span: Span,"}, {"sha": "7f8705824445457538a74168409c0750b55ddf2e", "filename": "compiler/rustc_trait_selection/src/errors.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_trait_selection%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_trait_selection%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ferrors.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65", "patch": "@@ -5,7 +5,7 @@ use rustc_session::Limit;\n use rustc_span::{Span, Symbol};\n \n #[derive(Diagnostic)]\n-#[diag(trait_selection::dump_vtable_entries)]\n+#[diag(trait_selection_dump_vtable_entries)]\n pub struct DumpVTableEntries<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -14,7 +14,7 @@ pub struct DumpVTableEntries<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(trait_selection::unable_to_construct_constant_value)]\n+#[diag(trait_selection_unable_to_construct_constant_value)]\n pub struct UnableToConstructConstantValue<'a> {\n     #[primary_span]\n     pub span: Span,\n@@ -23,7 +23,7 @@ pub struct UnableToConstructConstantValue<'a> {\n \n #[derive(Diagnostic)]\n #[help]\n-#[diag(trait_selection::auto_deref_reached_recursion_limit, code = \"E0055\")]\n+#[diag(trait_selection_auto_deref_reached_recursion_limit, code = \"E0055\")]\n pub struct AutoDerefReachedRecursionLimit<'a> {\n     #[primary_span]\n     #[label]\n@@ -34,23 +34,23 @@ pub struct AutoDerefReachedRecursionLimit<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(trait_selection::empty_on_clause_in_rustc_on_unimplemented, code = \"E0232\")]\n+#[diag(trait_selection_empty_on_clause_in_rustc_on_unimplemented, code = \"E0232\")]\n pub struct EmptyOnClauseInOnUnimplemented {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(trait_selection::invalid_on_clause_in_rustc_on_unimplemented, code = \"E0232\")]\n+#[diag(trait_selection_invalid_on_clause_in_rustc_on_unimplemented, code = \"E0232\")]\n pub struct InvalidOnClauseInOnUnimplemented {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(trait_selection::no_value_in_rustc_on_unimplemented, code = \"E0232\")]\n+#[diag(trait_selection_no_value_in_rustc_on_unimplemented, code = \"E0232\")]\n #[note]\n pub struct NoValueInOnUnimplemented {\n     #[primary_span]\n@@ -71,7 +71,7 @@ impl IntoDiagnostic<'_> for NegativePositiveConflict<'_> {\n         self,\n         handler: &Handler,\n     ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n-        let mut diag = handler.struct_err(fluent::trait_selection::negative_positive_conflict);\n+        let mut diag = handler.struct_err(fluent::trait_selection_negative_positive_conflict);\n         diag.set_arg(\"trait_desc\", self.trait_desc);\n         diag.set_arg(\n             \"self_desc\",\n@@ -81,19 +81,19 @@ impl IntoDiagnostic<'_> for NegativePositiveConflict<'_> {\n         diag.code(rustc_errors::error_code!(E0751));\n         match self.negative_impl_span {\n             Ok(span) => {\n-                diag.span_label(span, fluent::trait_selection::negative_implementation_here);\n+                diag.span_label(span, fluent::negative_implementation_here);\n             }\n             Err(cname) => {\n-                diag.note(fluent::trait_selection::negative_implementation_in_crate);\n+                diag.note(fluent::negative_implementation_in_crate);\n                 diag.set_arg(\"negative_impl_cname\", cname.to_string());\n             }\n         }\n         match self.positive_impl_span {\n             Ok(span) => {\n-                diag.span_label(span, fluent::trait_selection::positive_implementation_here);\n+                diag.span_label(span, fluent::positive_implementation_here);\n             }\n             Err(cname) => {\n-                diag.note(fluent::trait_selection::positive_implementation_in_crate);\n+                diag.note(fluent::positive_implementation_in_crate);\n                 diag.set_arg(\"positive_impl_cname\", cname.to_string());\n             }\n         }"}, {"sha": "84038625fb2792038f5243d02584f737d34645b2", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "1217d264a9c1a14625bf9233834fc25bf37e868f", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "a417e1440b9ee1f35c2281a40e25f52ccd4ca228", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "0bb25a74dc8b043846126445fc170919b1a3e2c6", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "c8276854016f0bc273fe044403fdd786f6b1a8f2", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "715f5be8e2f4bbe22dd35ce61078f0aa370c0680", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "0870833cc35ae205579fb2229ce3e100eaec33b3", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "73c7eb6992f075610dd2cac96d23c64c564a1e7a", "filename": "compiler/rustc_ty_utils/src/abi.rs", "status": "modified", "additions": 38, "deletions": 5, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "c05eeb353a84874155684dc4559743394521b91a", "filename": "compiler/rustc_ty_utils/src/errors.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_ty_utils%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/compiler%2Frustc_ty_utils%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Ferrors.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "a46813e4d7a3b825475b743466ee5650ab0174d5", "filename": "config.toml.example", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "83a1385599bec8c70c79d54fdd67f154d238f9fa", "filename": "library/alloc/src/borrow.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Falloc%2Fsrc%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Falloc%2Fsrc%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fborrow.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "9c229665c7e91b4169e2976342df87e7b2356b90", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "c436adf70067ada4bfc043ff8ebb3f6786105ecd", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "e8d9de4fb3ce505750a281a734ecd20a1505cea0", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "bbbdc3aa2a2d36885d8cd4ca11f3a8816797e8cb", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "eae0e1c7618663459a2148fb20ab6baef6606c87", "filename": "library/core/src/array/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fmod.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "89053060fbbea1f0ecc940ec1bf7be1760f04372", "filename": "library/core/src/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fcore%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fcore%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ferror.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "9cbfbbb9f399c67432f8243d2dd218509d3eec21", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "7757c95de9d2a27a9dcf9369a03825c0844561fa", "filename": "library/core/src/mem/maybe_uninit.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "a81dbc6924fb737a3d9891bd7099f6f89ec7a24c", "filename": "library/core/src/option.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "caa10f1818b4d08e6c419fcc4d4b4c98efa267b9", "filename": "library/core/src/ptr/metadata.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fcore%2Fsrc%2Fptr%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fcore%2Fsrc%2Fptr%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmetadata.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "cfffe351a87d99ce71d079ef05f5615eb1236b42", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "0bb2566fd4c98b32f91b5afc9a19cf2e127a0b24", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "7264d57ba6aed02a040518b404bd67d8d984bbb8", "filename": "library/core/src/ptr/non_null.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "94ab13ed2e04f286f91d2554ccd60c7672104d07", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "37c3611d0a908956b9b92f77094da68f6e3aaf25", "filename": "library/core/src/time.rs", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fcore%2Fsrc%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fcore%2Fsrc%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftime.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "51f858adee167edd4453843ef226f3c564a8536b", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "bc10b12ec2af90dddb9d78895e94c1683cfa0973", "filename": "library/std/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2FCargo.toml?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "188ff00e1f8dda454aecd1e3ef4874a5259ddf7b", "filename": "library/std/src/fs.rs", "status": "modified", "additions": 64, "deletions": 3, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fstd%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fstd%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "23a13523fc275be62e588a04935d0ffa12f51d6f", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "385585dada896fd6819a5365a27d1ced963fe6fc", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "9c2f0c1dd3eb669fe04fd01c604363bae111ac38", "filename": "library/std/src/rt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fstd%2Fsrc%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fstd%2Fsrc%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Frt.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "6c66b93a3e1a306e1ae9ca0abc8b3bbbac4ef767", "filename": "library/std/src/sys/solid/fs.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Ffs.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "e22b2f3340af08109d0c63086f8b37fadf9210bf", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 65, "deletions": 20, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "9055a011c515e18bd33b44953477220266f17f23", "filename": "library/std/src/sys/unix/mod.rs", "status": "modified", "additions": 34, "deletions": 8, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "848adca78c076f99fdec48c553410fe7a753c549", "filename": "library/std/src/sys/unix/process/process_common.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "03631e4e33bf5d073993cfc15ecfdb86cc7fac43", "filename": "library/std/src/sys/unix/process/process_common/tests.rs", "status": "modified", "additions": 46, "deletions": 33, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common%2Ftests.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "56a805cef7318fe8e6ed00f57997d90647a03b22", "filename": "library/std/src/sys/unix/process/process_unix.rs", "status": "modified", "additions": 39, "deletions": 33, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "69cd2b500a1f0819cf0aac85f6deb0aa8db73a6d", "filename": "library/std/src/sys/unix/thread.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "be6fc2ebb7a27f73ee3a076b9f19d5de0c58faab", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "2cc34c986b990e59002d37791593e1cc6ea65aef", "filename": "library/std/src/sys/windows/io.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fio.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "6c9ce6fa0ddbd80b6d82c4b54158235283c7da70", "filename": "library/std/src/thread/tests.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fstd%2Fsrc%2Fthread%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fstd%2Fsrc%2Fthread%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Ftests.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "34e18b5fa8778ebb4750284d661f0ca226a40622", "filename": "library/std/src/time.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fstd%2Fsrc%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Fstd%2Fsrc%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ftime.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "b1270c272710dd69a6c74a2adcaf75540225a245", "filename": "library/test/src/console.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Ftest%2Fsrc%2Fconsole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Ftest%2Fsrc%2Fconsole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fconsole.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "4de694557982d21af0a0be75132a6f97e630b15c", "filename": "library/test/src/lib.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Ftest%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Ftest%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Flib.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "a14b0d4f5a96233b18b1e1fe55700dcd41866a86", "filename": "library/test/src/term.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Ftest%2Fsrc%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Ftest%2Fsrc%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fterm.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "55020141a827db9481a720c80df7e3a6ccd0c267", "filename": "library/test/src/term/win.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Ftest%2Fsrc%2Fterm%2Fwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Ftest%2Fsrc%2Fterm%2Fwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fterm%2Fwin.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "b54be64efcfed82707d7abbd64fb5814966f4542", "filename": "library/test/src/tests.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Ftest%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/library%2Ftest%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Ftests.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "e02a10b81640811b88770e6d95d9c378e32604d1", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "a8c403675d82197d618728a179e4e5f3e3a662f1", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "ea236bee56302900ff3605671a17d4585334ee38", "filename": "src/ci/docker/README.md", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/src%2Fci%2Fdocker%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/src%2Fci%2Fdocker%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2FREADME.md?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "eb511b32107923753c10992c4c33ef8570a40c7f", "filename": "src/ci/docker/host-x86_64/dist-mips-linux/Dockerfile", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-mips-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-mips-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-mips-linux%2FDockerfile?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "32612cf6852834123597afbde5a96fd8fac5d227", "filename": "src/ci/docker/host-x86_64/dist-mips-linux/build-mips-toolchain.sh", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-mips-linux%2Fbuild-mips-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-mips-linux%2Fbuild-mips-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-mips-linux%2Fbuild-mips-toolchain.sh?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "575584ef0cf661fb121069794b133ad896aaf410", "filename": "src/ci/docker/host-x86_64/dist-mips-linux/mips-linux-gnu.config", "status": "added", "additions": 740, "deletions": 0, "changes": 740, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-mips-linux%2Fmips-linux-gnu.config", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-mips-linux%2Fmips-linux-gnu.config", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-mips-linux%2Fmips-linux-gnu.config?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "393084df3249aa36d5c05d69dbb48970322dbe00", "filename": "src/ci/docker/host-x86_64/dist-mips-linux/patches/glibc/2.23/0001-MIPS-SPARC-fix-wrong-vfork-aliases-in-libpthread.so.patch", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-mips-linux%2Fpatches%2Fglibc%2F2.23%2F0001-MIPS-SPARC-fix-wrong-vfork-aliases-in-libpthread.so.patch", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-mips-linux%2Fpatches%2Fglibc%2F2.23%2F0001-MIPS-SPARC-fix-wrong-vfork-aliases-in-libpthread.so.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-mips-linux%2Fpatches%2Fglibc%2F2.23%2F0001-MIPS-SPARC-fix-wrong-vfork-aliases-in-libpthread.so.patch?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "e28c7ae99f098899c6750b5df8f6ab9c826dc4a3", "filename": "src/ci/docker/host-x86_64/dist-mips-linux/patches/glibc/2.23/0002-MIPS-SPARC-more-fixes-to-the-vfork-aliases-in-libpth.patch", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-mips-linux%2Fpatches%2Fglibc%2F2.23%2F0002-MIPS-SPARC-more-fixes-to-the-vfork-aliases-in-libpth.patch", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-mips-linux%2Fpatches%2Fglibc%2F2.23%2F0002-MIPS-SPARC-more-fixes-to-the-vfork-aliases-in-libpth.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-mips-linux%2Fpatches%2Fglibc%2F2.23%2F0002-MIPS-SPARC-more-fixes-to-the-vfork-aliases-in-libpth.patch?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}, {"sha": "de862e1df2d6a4a16b61d6c3445d9a021be47824", "filename": "src/ci/docker/host-x86_64/dist-mips64-linux/Dockerfile", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a46ccba167086f0b562eb78403f7446b0fed5f65/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-mips64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a46ccba167086f0b562eb78403f7446b0fed5f65/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-mips64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-mips64-linux%2FDockerfile?ref=a46ccba167086f0b562eb78403f7446b0fed5f65"}]}