{"sha": "d3e9881ed16202e3faab65bf13a19e0581849bfe", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzZTk4ODFlZDE2MjAyZTNmYWFiNjViZjEzYTE5ZTA1ODE4NDliZmU=", "commit": {"author": {"name": "Shotaro Yamada", "email": "sinkuu@sinkuu.xyz", "date": "2017-11-11T09:15:26Z"}, "committer": {"name": "Shotaro Yamada", "email": "sinkuu@sinkuu.xyz", "date": "2017-11-12T02:27:21Z"}, "message": "MIR-borrowck: fix diagnostics for closures", "tree": {"sha": "9c9b371dd67e4d4239eda77c6a531d42ac266d91", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c9b371dd67e4d4239eda77c6a531d42ac266d91"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3e9881ed16202e3faab65bf13a19e0581849bfe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3e9881ed16202e3faab65bf13a19e0581849bfe", "html_url": "https://github.com/rust-lang/rust/commit/d3e9881ed16202e3faab65bf13a19e0581849bfe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3e9881ed16202e3faab65bf13a19e0581849bfe/comments", "author": {"login": "sinkuu", "id": 7091080, "node_id": "MDQ6VXNlcjcwOTEwODA=", "avatar_url": "https://avatars.githubusercontent.com/u/7091080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sinkuu", "html_url": "https://github.com/sinkuu", "followers_url": "https://api.github.com/users/sinkuu/followers", "following_url": "https://api.github.com/users/sinkuu/following{/other_user}", "gists_url": "https://api.github.com/users/sinkuu/gists{/gist_id}", "starred_url": "https://api.github.com/users/sinkuu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sinkuu/subscriptions", "organizations_url": "https://api.github.com/users/sinkuu/orgs", "repos_url": "https://api.github.com/users/sinkuu/repos", "events_url": "https://api.github.com/users/sinkuu/events{/privacy}", "received_events_url": "https://api.github.com/users/sinkuu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sinkuu", "id": 7091080, "node_id": "MDQ6VXNlcjcwOTEwODA=", "avatar_url": "https://avatars.githubusercontent.com/u/7091080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sinkuu", "html_url": "https://github.com/sinkuu", "followers_url": "https://api.github.com/users/sinkuu/followers", "following_url": "https://api.github.com/users/sinkuu/following{/other_user}", "gists_url": "https://api.github.com/users/sinkuu/gists{/gist_id}", "starred_url": "https://api.github.com/users/sinkuu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sinkuu/subscriptions", "organizations_url": "https://api.github.com/users/sinkuu/orgs", "repos_url": "https://api.github.com/users/sinkuu/repos", "events_url": "https://api.github.com/users/sinkuu/events{/privacy}", "received_events_url": "https://api.github.com/users/sinkuu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45caff88d1dabd71aec9431c07c0b4a77b20f203", "url": "https://api.github.com/repos/rust-lang/rust/commits/45caff88d1dabd71aec9431c07c0b4a77b20f203", "html_url": "https://github.com/rust-lang/rust/commit/45caff88d1dabd71aec9431c07c0b4a77b20f203"}], "stats": {"total": 310, "additions": 301, "deletions": 9}, "files": [{"sha": "39e222230e57764ab1630d429f0c1035f5fa5549", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3e9881ed16202e3faab65bf13a19e0581849bfe/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e9881ed16202e3faab65bf13a19e0581849bfe/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=d3e9881ed16202e3faab65bf13a19e0581849bfe", "patch": "@@ -1949,7 +1949,7 @@ impl ForeignItem_ {\n }\n \n /// A free variable referred to in a function.\n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable)]\n pub struct Freevar {\n     /// The variable being accessed free.\n     pub def: Def,"}, {"sha": "cd0176506332aa1a8ee77c2155f3737070e6264a", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3e9881ed16202e3faab65bf13a19e0581849bfe/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e9881ed16202e3faab65bf13a19e0581849bfe/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=d3e9881ed16202e3faab65bf13a19e0581849bfe", "patch": "@@ -267,10 +267,10 @@ impl<'tcx> Mir<'tcx> {\n         let block = &self[location.block];\n         let stmts = &block.statements;\n         let idx = location.statement_index;\n-        if location.statement_index < stmts.len() {\n+        if idx < stmts.len() {\n             &stmts[idx].source_info\n         } else {\n-            assert!(location.statement_index == stmts.len());\n+            assert!(idx == stmts.len());\n             &block.terminator().source_info\n         }\n     }"}, {"sha": "6d4f521e99e22091f8cc7a8292a482064cf09954", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 90, "deletions": 6, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/d3e9881ed16202e3faab65bf13a19e0581849bfe/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e9881ed16202e3faab65bf13a19e0581849bfe/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=d3e9881ed16202e3faab65bf13a19e0581849bfe", "patch": "@@ -1169,8 +1169,70 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n         err.emit();\n     }\n \n+    /// Finds the span of arguments of aclosure (within `maybe_closure_span`) and its usage of\n+    /// the local assigned at `location`.\n+    fn find_closure_span(\n+        &self,\n+        maybe_closure_span: Span,\n+        location: Location,\n+    ) -> Option<(Span, Span)> {\n+        use rustc::hir::ExprClosure;\n+        use rustc::mir::AggregateKind;\n+\n+        let local = if let StatementKind::Assign(Lvalue::Local(local), _) =\n+            self.mir[location.block].statements[location.statement_index].kind\n+        {\n+            local\n+        } else {\n+            return None;\n+        };\n+\n+        for stmt in &self.mir[location.block].statements[location.statement_index + 1..] {\n+            if maybe_closure_span != stmt.source_info.span {\n+                break;\n+            }\n+\n+            if let StatementKind::Assign(_, Rvalue::Aggregate(ref kind, ref lvs)) = stmt.kind {\n+                if let AggregateKind::Closure(def_id, _) = **kind {\n+                    debug!(\"find_closure_span: found closure {:?}\", lvs);\n+\n+                    return if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n+                        let args_span = if let ExprClosure(_, _, _, span, _) =\n+                            self.tcx.hir.expect_expr(node_id).node\n+                        {\n+                            span\n+                        } else {\n+                            return None;\n+                        };\n+\n+                        self.tcx\n+                            .with_freevars(node_id, |freevars| {\n+                                for (v, lv) in freevars.iter().zip(lvs) {\n+                                    if let Operand::Consume(Lvalue::Local(l)) = *lv {\n+                                        if local == l {\n+                                            debug!(\n+                                                \"find_closure_span: found captured local {:?}\",\n+                                                l\n+                                            );\n+                                            return Some(v.span);\n+                                        }\n+                                    }\n+                                }\n+                                None\n+                            })\n+                            .map(|var_span| (args_span, var_span))\n+                    } else {\n+                        None\n+                    };\n+                }\n+            }\n+        }\n+\n+        None\n+    }\n+\n     fn report_conflicting_borrow(&mut self,\n-                                 _context: Context,\n+                                 context: Context,\n                                  common_prefix: &Lvalue,\n                                  (lvalue, span): (&Lvalue, Span),\n                                  gen_borrow_kind: BorrowKind,\n@@ -1183,38 +1245,60 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n \n         let issued_span = self.retrieve_borrow_span(issued_borrow);\n \n+        let new_closure_span = self.find_closure_span(span, context.loc);\n+        let span = new_closure_span.map(|(args, _)| args).unwrap_or(span);\n+        let old_closure_span = self.find_closure_span(issued_span, issued_borrow.location);\n+        let issued_span = old_closure_span.map(|(args, _)| args).unwrap_or(issued_span);\n+\n+        let desc_lvalue = self.describe_lvalue(lvalue);\n+\n         // FIXME: supply non-\"\" `opt_via` when appropriate\n         let mut err = match (gen_borrow_kind, \"immutable\", \"mutable\",\n                              issued_borrow.kind, \"immutable\", \"mutable\") {\n             (BorrowKind::Shared, lft, _, BorrowKind::Mut, _, rgt) |\n             (BorrowKind::Mut, _, lft, BorrowKind::Shared, rgt, _) =>\n                 self.tcx.cannot_reborrow_already_borrowed(\n-                    span, &self.describe_lvalue(lvalue), \"\", lft, issued_span,\n+                    span, &desc_lvalue, \"\", lft, issued_span,\n                     \"it\", rgt, \"\", end_issued_loan_span, Origin::Mir),\n \n             (BorrowKind::Mut, _, _, BorrowKind::Mut, _, _) =>\n                 self.tcx.cannot_mutably_borrow_multiply(\n-                    span, &self.describe_lvalue(lvalue), \"\", issued_span,\n+                    span, &desc_lvalue, \"\", issued_span,\n                     \"\", end_issued_loan_span, Origin::Mir),\n \n             (BorrowKind::Unique, _, _, BorrowKind::Unique, _, _) =>\n                 self.tcx.cannot_uniquely_borrow_by_two_closures(\n-                    span, &self.describe_lvalue(lvalue), issued_span,\n+                    span, &desc_lvalue, issued_span,\n                     end_issued_loan_span, Origin::Mir),\n \n             (BorrowKind::Unique, _, _, _, _, _) =>\n                 self.tcx.cannot_uniquely_borrow_by_one_closure(\n-                    span, &self.describe_lvalue(lvalue), \"\",\n+                    span, &desc_lvalue, \"\",\n                     issued_span, \"it\", \"\", end_issued_loan_span, Origin::Mir),\n \n             (_, _, _, BorrowKind::Unique, _, _) =>\n                 self.tcx.cannot_reborrow_already_uniquely_borrowed(\n-                    span, &self.describe_lvalue(lvalue), \"it\", \"\",\n+                    span, &desc_lvalue, \"it\", \"\",\n                     issued_span, \"\", end_issued_loan_span, Origin::Mir),\n \n             (BorrowKind::Shared, _, _, BorrowKind::Shared, _, _) =>\n                 unreachable!(),\n         };\n+\n+        if let Some((_, var_span)) = old_closure_span {\n+            err.span_label(\n+                var_span,\n+                format!(\"previous borrow occurs due to use of `{}` in closure\", desc_lvalue),\n+            );\n+        }\n+\n+        if let Some((_, var_span)) = new_closure_span {\n+            err.span_label(\n+                var_span,\n+                format!(\"borrow occurs due to use of `{}` in closure\", desc_lvalue),\n+            );\n+        }\n+\n         err.emit();\n     }\n "}, {"sha": "4b6f992f097c2f775510ada28bfcc4ad45a459b5", "filename": "src/test/ui/borrowck/borrowck-closures-two-mut.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/d3e9881ed16202e3faab65bf13a19e0581849bfe/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-two-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3e9881ed16202e3faab65bf13a19e0581849bfe/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-two-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-two-mut.rs?ref=d3e9881ed16202e3faab65bf13a19e0581849bfe", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that two closures cannot simultaneously have mutable\n+// access to the variable, whether that mutable access be used\n+// for direct assignment or for taking mutable ref. Issue #6801.\n+\n+// compile-flags: -Z emit-end-regions -Z borrowck-mir\n+\n+#![feature(box_syntax)]\n+\n+fn to_fn_mut<F: FnMut()>(f: F) -> F { f }\n+\n+fn a() {\n+    let mut x = 3;\n+    let c1 = to_fn_mut(|| x = 4);\n+    let c2 = to_fn_mut(|| x = 5); //~ ERROR cannot borrow `x` as mutable more than once\n+}\n+\n+fn set(x: &mut isize) {\n+    *x = 4;\n+}\n+\n+fn b() {\n+    let mut x = 3;\n+    let c1 = to_fn_mut(|| set(&mut x));\n+    let c2 = to_fn_mut(|| set(&mut x)); //~ ERROR cannot borrow `x` as mutable more than once\n+}\n+\n+fn c() {\n+    let mut x = 3;\n+    let c1 = to_fn_mut(|| x = 5);\n+    let c2 = to_fn_mut(|| set(&mut x)); //~ ERROR cannot borrow `x` as mutable more than once\n+}\n+\n+fn d() {\n+    let mut x = 3;\n+    let c1 = to_fn_mut(|| x = 5);\n+    let c2 = to_fn_mut(|| { let _y = to_fn_mut(|| set(&mut x)); }); // (nested closure)\n+    //~^ ERROR cannot borrow `x` as mutable more than once\n+}\n+\n+fn g() {\n+    struct Foo {\n+        f: Box<isize>\n+    }\n+\n+    let mut x: Box<_> = box Foo { f: box 3 };\n+    let c1 = to_fn_mut(|| set(&mut *x.f));\n+    let c2 = to_fn_mut(|| set(&mut *x.f));\n+    //~^ ERROR cannot borrow `x` as mutable more than once\n+}\n+\n+fn main() {\n+}"}, {"sha": "fc8a7f2ab606002b477b67da0f4c4413c6f7a7b2", "filename": "src/test/ui/borrowck/borrowck-closures-two-mut.stderr", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/d3e9881ed16202e3faab65bf13a19e0581849bfe/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-two-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d3e9881ed16202e3faab65bf13a19e0581849bfe/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-two-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-two-mut.stderr?ref=d3e9881ed16202e3faab65bf13a19e0581849bfe", "patch": "@@ -0,0 +1,146 @@\n+error[E0499]: cannot borrow `x` as mutable more than once at a time (Ast)\n+  --> $DIR/borrowck-closures-two-mut.rs:24:24\n+   |\n+23 |     let c1 = to_fn_mut(|| x = 4);\n+   |                        -- - previous borrow occurs due to use of `x` in closure\n+   |                        |\n+   |                        first mutable borrow occurs here\n+24 |     let c2 = to_fn_mut(|| x = 5); //~ ERROR cannot borrow `x` as mutable more than once\n+   |                        ^^ - borrow occurs due to use of `x` in closure\n+   |                        |\n+   |                        second mutable borrow occurs here\n+25 | }\n+   | - first borrow ends here\n+\n+error[E0499]: cannot borrow `x` as mutable more than once at a time (Ast)\n+  --> $DIR/borrowck-closures-two-mut.rs:34:24\n+   |\n+33 |     let c1 = to_fn_mut(|| set(&mut x));\n+   |                        --          - previous borrow occurs due to use of `x` in closure\n+   |                        |\n+   |                        first mutable borrow occurs here\n+34 |     let c2 = to_fn_mut(|| set(&mut x)); //~ ERROR cannot borrow `x` as mutable more than once\n+   |                        ^^          - borrow occurs due to use of `x` in closure\n+   |                        |\n+   |                        second mutable borrow occurs here\n+35 | }\n+   | - first borrow ends here\n+\n+error[E0499]: cannot borrow `x` as mutable more than once at a time (Ast)\n+  --> $DIR/borrowck-closures-two-mut.rs:40:24\n+   |\n+39 |     let c1 = to_fn_mut(|| x = 5);\n+   |                        -- - previous borrow occurs due to use of `x` in closure\n+   |                        |\n+   |                        first mutable borrow occurs here\n+40 |     let c2 = to_fn_mut(|| set(&mut x)); //~ ERROR cannot borrow `x` as mutable more than once\n+   |                        ^^          - borrow occurs due to use of `x` in closure\n+   |                        |\n+   |                        second mutable borrow occurs here\n+41 | }\n+   | - first borrow ends here\n+\n+error[E0499]: cannot borrow `x` as mutable more than once at a time (Ast)\n+  --> $DIR/borrowck-closures-two-mut.rs:46:24\n+   |\n+45 |     let c1 = to_fn_mut(|| x = 5);\n+   |                        -- - previous borrow occurs due to use of `x` in closure\n+   |                        |\n+   |                        first mutable borrow occurs here\n+46 |     let c2 = to_fn_mut(|| { let _y = to_fn_mut(|| set(&mut x)); }); // (nested closure)\n+   |                        ^^                                  - borrow occurs due to use of `x` in closure\n+   |                        |\n+   |                        second mutable borrow occurs here\n+47 |     //~^ ERROR cannot borrow `x` as mutable more than once\n+48 | }\n+   | - first borrow ends here\n+\n+error[E0499]: cannot borrow `x` as mutable more than once at a time (Ast)\n+  --> $DIR/borrowck-closures-two-mut.rs:57:24\n+   |\n+56 |     let c1 = to_fn_mut(|| set(&mut *x.f));\n+   |                        --           - previous borrow occurs due to use of `x` in closure\n+   |                        |\n+   |                        first mutable borrow occurs here\n+57 |     let c2 = to_fn_mut(|| set(&mut *x.f));\n+   |                        ^^           - borrow occurs due to use of `x` in closure\n+   |                        |\n+   |                        second mutable borrow occurs here\n+58 |     //~^ ERROR cannot borrow `x` as mutable more than once\n+59 | }\n+   | - first borrow ends here\n+\n+error[E0499]: cannot borrow `x` as mutable more than once at a time (Mir)\n+  --> $DIR/borrowck-closures-two-mut.rs:24:24\n+   |\n+23 |     let c1 = to_fn_mut(|| x = 4);\n+   |                        -- - previous borrow occurs due to use of `x` in closure\n+   |                        |\n+   |                        first mutable borrow occurs here\n+24 |     let c2 = to_fn_mut(|| x = 5); //~ ERROR cannot borrow `x` as mutable more than once\n+   |                        ^^ - borrow occurs due to use of `x` in closure\n+   |                        |\n+   |                        second mutable borrow occurs here\n+25 | }\n+   | - first borrow ends here\n+\n+error[E0499]: cannot borrow `x` as mutable more than once at a time (Mir)\n+  --> $DIR/borrowck-closures-two-mut.rs:34:24\n+   |\n+33 |     let c1 = to_fn_mut(|| set(&mut x));\n+   |                        --          - previous borrow occurs due to use of `x` in closure\n+   |                        |\n+   |                        first mutable borrow occurs here\n+34 |     let c2 = to_fn_mut(|| set(&mut x)); //~ ERROR cannot borrow `x` as mutable more than once\n+   |                        ^^          - borrow occurs due to use of `x` in closure\n+   |                        |\n+   |                        second mutable borrow occurs here\n+35 | }\n+   | - first borrow ends here\n+\n+error[E0499]: cannot borrow `x` as mutable more than once at a time (Mir)\n+  --> $DIR/borrowck-closures-two-mut.rs:40:24\n+   |\n+39 |     let c1 = to_fn_mut(|| x = 5);\n+   |                        -- - previous borrow occurs due to use of `x` in closure\n+   |                        |\n+   |                        first mutable borrow occurs here\n+40 |     let c2 = to_fn_mut(|| set(&mut x)); //~ ERROR cannot borrow `x` as mutable more than once\n+   |                        ^^          - borrow occurs due to use of `x` in closure\n+   |                        |\n+   |                        second mutable borrow occurs here\n+41 | }\n+   | - first borrow ends here\n+\n+error[E0499]: cannot borrow `x` as mutable more than once at a time (Mir)\n+  --> $DIR/borrowck-closures-two-mut.rs:46:24\n+   |\n+45 |     let c1 = to_fn_mut(|| x = 5);\n+   |                        -- - previous borrow occurs due to use of `x` in closure\n+   |                        |\n+   |                        first mutable borrow occurs here\n+46 |     let c2 = to_fn_mut(|| { let _y = to_fn_mut(|| set(&mut x)); }); // (nested closure)\n+   |                        ^^                                  - borrow occurs due to use of `x` in closure\n+   |                        |\n+   |                        second mutable borrow occurs here\n+47 |     //~^ ERROR cannot borrow `x` as mutable more than once\n+48 | }\n+   | - first borrow ends here\n+\n+error[E0499]: cannot borrow `x` as mutable more than once at a time (Mir)\n+  --> $DIR/borrowck-closures-two-mut.rs:57:24\n+   |\n+56 |     let c1 = to_fn_mut(|| set(&mut *x.f));\n+   |                        --           - previous borrow occurs due to use of `x` in closure\n+   |                        |\n+   |                        first mutable borrow occurs here\n+57 |     let c2 = to_fn_mut(|| set(&mut *x.f));\n+   |                        ^^           - borrow occurs due to use of `x` in closure\n+   |                        |\n+   |                        second mutable borrow occurs here\n+58 |     //~^ ERROR cannot borrow `x` as mutable more than once\n+59 | }\n+   | - first borrow ends here\n+\n+error: aborting due to 10 previous errors\n+"}]}