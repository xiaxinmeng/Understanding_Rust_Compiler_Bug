{"sha": "086c08d86ac4d63f12961e37ef433a6128ad974b", "node_id": "C_kwDOAAsO6NoAKDA4NmMwOGQ4NmFjNGQ2M2YxMjk2MWUzN2VmNDMzYTYxMjhhZDk3NGI", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2023-04-10T14:33:33Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2023-05-16T11:43:27Z"}, "message": "Switch `OwnedSlice` to use `Lrc` & remove `Lrc` from `MetadataBlob`", "tree": {"sha": "b113f8171533486311ce8b154204c54f84b48e5d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b113f8171533486311ce8b154204c54f84b48e5d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/086c08d86ac4d63f12961e37ef433a6128ad974b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/086c08d86ac4d63f12961e37ef433a6128ad974b", "html_url": "https://github.com/rust-lang/rust/commit/086c08d86ac4d63f12961e37ef433a6128ad974b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/086c08d86ac4d63f12961e37ef433a6128ad974b/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2eef27a6c1808377e84d68c474f8246a2dafda63", "url": "https://api.github.com/repos/rust-lang/rust/commits/2eef27a6c1808377e84d68c474f8246a2dafda63", "html_url": "https://github.com/rust-lang/rust/commit/2eef27a6c1808377e84d68c474f8246a2dafda63"}], "stats": {"total": 60, "additions": 47, "deletions": 13}, "files": [{"sha": "8cf74a98adb71b5b36231435929a4c91315eab19", "filename": "compiler/rustc_data_structures/src/owned_slice.rs", "status": "modified", "additions": 32, "deletions": 3, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/086c08d86ac4d63f12961e37ef433a6128ad974b/compiler%2Frustc_data_structures%2Fsrc%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086c08d86ac4d63f12961e37ef433a6128ad974b/compiler%2Frustc_data_structures%2Fsrc%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fowned_slice.rs?ref=086c08d86ac4d63f12961e37ef433a6128ad974b", "patch": "@@ -1,13 +1,14 @@\n use std::{borrow::Borrow, ops::Deref};\n \n+use crate::sync::Lrc;\n // Use our fake Send/Sync traits when on not parallel compiler,\n // so that `OwnedSlice` only implements/requires Send/Sync\n // for parallel compiler builds.\n use crate::sync::{Send, Sync};\n \n /// An owned slice.\n ///\n-/// This is similar to `Box<[u8]>` but allows slicing and using anything as the\n+/// This is similar to `Lrc<[u8]>` but allows slicing and using anything as the\n /// backing buffer.\n ///\n /// See [`slice_owned`] for `OwnedSlice` construction and examples.\n@@ -16,6 +17,7 @@ use crate::sync::{Send, Sync};\n ///\n /// This is essentially a replacement for `owning_ref` which is a lot simpler\n /// and even sound! \ud83c\udf38\n+#[derive(Clone)]\n pub struct OwnedSlice {\n     /// This is conceptually a `&'self.owner [u8]`.\n     bytes: *const [u8],\n@@ -31,7 +33,7 @@ pub struct OwnedSlice {\n     //       \\/\n     //      \u2282(\u00b4\uff65\u25e1\uff65\u2282 )\u2218\u02da\u02f3\u00b0 (I am the phantom remnant of #97770)\n     #[expect(dead_code)]\n-    owner: Box<dyn Send + Sync>,\n+    owner: Lrc<dyn Send + Sync>,\n }\n \n /// Makes an [`OwnedSlice`] out of an `owner` and a `slicer` function.\n@@ -83,12 +85,39 @@ where\n     // N.B. the HRTB on the `slicer` is important \u2014 without it the caller could provide\n     // a short lived slice, unrelated to the owner.\n \n-    let owner = Box::new(owner);\n+    let owner = Lrc::new(owner);\n     let bytes = slicer(&*owner)?;\n \n     Ok(OwnedSlice { bytes, owner })\n }\n \n+impl OwnedSlice {\n+    /// Slice this slice by `slicer`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// # use rustc_data_structures::owned_slice::{OwnedSlice, slice_owned};\n+    /// let vec = vec![1, 2, 3, 4];\n+    ///\n+    /// // Identical to slicing via `&v[1..3]` but produces an owned slice\n+    /// let slice: OwnedSlice = slice_owned(vec, |v| &v[..]);\n+    /// assert_eq!(&*slice, [1, 2, 3, 4]);\n+    ///\n+    /// let slice = slice.slice(|slice| &slice[1..][..2]);\n+    /// assert_eq!(&*slice, [2, 3]);\n+    /// ```\n+    ///\n+    pub fn slice(self, slicer: impl FnOnce(&[u8]) -> &[u8]) -> OwnedSlice {\n+        // This is basically identical to `try_slice_owned`,\n+        // `slicer` can only return slices of its argument or some static data,\n+        // both of which are valid while `owner` is alive.\n+\n+        let bytes = slicer(&self);\n+        OwnedSlice { bytes, ..self }\n+    }\n+}\n+\n impl Deref for OwnedSlice {\n     type Target = [u8];\n "}, {"sha": "1eb5378cd1ad8058d24557c196f999a3a053b7df", "filename": "compiler/rustc_data_structures/src/owned_slice/tests.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/086c08d86ac4d63f12961e37ef433a6128ad974b/compiler%2Frustc_data_structures%2Fsrc%2Fowned_slice%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086c08d86ac4d63f12961e37ef433a6128ad974b/compiler%2Frustc_data_structures%2Fsrc%2Fowned_slice%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fowned_slice%2Ftests.rs?ref=086c08d86ac4d63f12961e37ef433a6128ad974b", "patch": "@@ -26,7 +26,7 @@ fn static_storage() {\n }\n \n #[test]\n-fn slice_the_slice() {\n+fn slice_owned_the_slice() {\n     let slice = slice_owned(vec![1, 2, 3, 4, 5, 6], Vec::as_slice);\n     let slice = slice_owned(slice, |s| &s[1..][..4]);\n     let slice = slice_owned(slice, |s| s);\n@@ -35,6 +35,16 @@ fn slice_the_slice() {\n     assert_eq!(&*slice, &[1, 2, 3, 4, 5, 6][1..][..4][1..]);\n }\n \n+#[test]\n+fn slice_the_slice() {\n+    let slice = slice_owned(vec![1, 2, 3, 4, 5, 6], Vec::as_slice)\n+        .slice(|s| &s[1..][..4])\n+        .slice(|s| s)\n+        .slice(|s| &s[1..]);\n+\n+    assert_eq!(&*slice, &[1, 2, 3, 4, 5, 6][1..][..4][1..]);\n+}\n+\n #[test]\n fn try_and_fail() {\n     let res = try_slice_owned(vec![0], |v| v.get(12..).ok_or(()));"}, {"sha": "a083e9b5858ad33cb0ee413ca36f58ef1a6611ab", "filename": "compiler/rustc_metadata/src/locator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/086c08d86ac4d63f12961e37ef433a6128ad974b/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086c08d86ac4d63f12961e37ef433a6128ad974b/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs?ref=086c08d86ac4d63f12961e37ef433a6128ad974b", "patch": "@@ -843,7 +843,7 @@ fn get_metadata_section<'p>(\n             slice_owned(mmap, Deref::deref)\n         }\n     };\n-    let blob = MetadataBlob::new(raw_bytes);\n+    let blob = MetadataBlob(raw_bytes);\n     if blob.is_compatible() {\n         Ok(blob)\n     } else {"}, {"sha": "699e1f49ed6ca8cdf8d11e422a60003273eb41f5", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/086c08d86ac4d63f12961e37ef433a6128ad974b/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086c08d86ac4d63f12961e37ef433a6128ad974b/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=086c08d86ac4d63f12961e37ef433a6128ad974b", "patch": "@@ -7,6 +7,7 @@ use crate::rmeta::*;\n use rustc_ast as ast;\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::owned_slice::OwnedSlice;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::{AppendOnlyVec, Lock, Lrc, OnceCell};\n use rustc_data_structures::unhash::UnhashMap;\n@@ -50,7 +51,7 @@ mod cstore_impl;\n /// A `MetadataBlob` internally is just a reference counted pointer to\n /// the actual data, so cloning it is cheap.\n #[derive(Clone)]\n-pub(crate) struct MetadataBlob(Lrc<MetadataRef>);\n+pub(crate) struct MetadataBlob(pub(crate) OwnedSlice);\n \n impl std::ops::Deref for MetadataBlob {\n     type Target = [u8];\n@@ -660,10 +661,6 @@ impl<'a, 'tcx, I: Idx, T> Decodable<DecodeContext<'a, 'tcx>> for LazyTable<I, T>\n implement_ty_decoder!(DecodeContext<'a, 'tcx>);\n \n impl MetadataBlob {\n-    pub(crate) fn new(metadata_ref: MetadataRef) -> MetadataBlob {\n-        MetadataBlob(Lrc::new(metadata_ref))\n-    }\n-\n     pub(crate) fn is_compatible(&self) -> bool {\n         self.blob().starts_with(METADATA_HEADER)\n     }"}, {"sha": "4f280bb9d80e221114bdac6bb8803fa355f31d9e", "filename": "compiler/rustc_metadata/src/rmeta/def_path_hash_map.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/086c08d86ac4d63f12961e37ef433a6128ad974b/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdef_path_hash_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086c08d86ac4d63f12961e37ef433a6128ad974b/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdef_path_hash_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdef_path_hash_map.rs?ref=086c08d86ac4d63f12961e37ef433a6128ad974b", "patch": "@@ -1,6 +1,5 @@\n use crate::rmeta::DecodeContext;\n use crate::rmeta::EncodeContext;\n-use rustc_data_structures::owned_slice::slice_owned;\n use rustc_data_structures::owned_slice::OwnedSlice;\n use rustc_hir::def_path_hash_map::{Config as HashMapConfig, DefPathHashMap};\n use rustc_middle::parameterized_over_tcx;\n@@ -47,7 +46,7 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for DefPathHashMapRef<'static>\n     fn decode(d: &mut DecodeContext<'a, 'tcx>) -> DefPathHashMapRef<'static> {\n         let len = d.read_usize();\n         let pos = d.position();\n-        let o = slice_owned(d.blob().clone(), |blob| &blob[pos..pos + len]);\n+        let o = d.blob().clone().0.slice(|blob| &blob[pos..pos + len]);\n \n         // Although we already have the data we need via the `OwnedSlice`, we still need\n         // to advance the `DecodeContext`'s position so it's in a valid state after"}, {"sha": "b00566081b939dbb5a01fc5a3c304cc2d5b4ed22", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/086c08d86ac4d63f12961e37ef433a6128ad974b/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/086c08d86ac4d63f12961e37ef433a6128ad974b/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=086c08d86ac4d63f12961e37ef433a6128ad974b", "patch": "@@ -7,7 +7,6 @@ use table::TableBuilder;\n use rustc_ast as ast;\n use rustc_attr as attr;\n use rustc_data_structures::svh::Svh;\n-use rustc_data_structures::sync::MetadataRef;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, DocLinkResMap};\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, DefPathHash, StableCrateId};"}]}