{"sha": "2608a6fd3a024206d4776cc391e46ef28c018434", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2MDhhNmZkM2EwMjQyMDZkNDc3NmNjMzkxZTQ2ZWYyOGMwMTg0MzQ=", "commit": {"author": {"name": "Paul Daniel Faria", "email": "Nashenas88@users.noreply.github.com", "date": "2020-05-29T12:55:47Z"}, "committer": {"name": "Paul Daniel Faria", "email": "Nashenas88@users.noreply.github.com", "date": "2020-06-27T14:13:14Z"}, "message": "unsafe: Clean up, improve tracking, add debug_assert\n\nMove unsafe_expressions to unsafe_validation.rs, replace vec tracking of\nchild exprs with inline macro, add debug assert to ensure tracked\nchildren match walked children exactly", "tree": {"sha": "55ab44a0a8c6574b8a27c24863a0badbee063d44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55ab44a0a8c6574b8a27c24863a0badbee063d44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2608a6fd3a024206d4776cc391e46ef28c018434", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2608a6fd3a024206d4776cc391e46ef28c018434", "html_url": "https://github.com/rust-lang/rust/commit/2608a6fd3a024206d4776cc391e46ef28c018434", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2608a6fd3a024206d4776cc391e46ef28c018434/comments", "author": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f678e0d837e472dc2f1421f89f794d33f3ade55c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f678e0d837e472dc2f1421f89f794d33f3ade55c", "html_url": "https://github.com/rust-lang/rust/commit/f678e0d837e472dc2f1421f89f794d33f3ade55c"}], "stats": {"total": 385, "additions": 232, "deletions": 153}, "files": [{"sha": "14a1f4773cda7663d704ce479c089d61216bc3b8", "filename": "crates/ra_hir_def/src/body.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2608a6fd3a024206d4776cc391e46ef28c018434/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2608a6fd3a024206d4776cc391e46ef28c018434/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody.rs?ref=2608a6fd3a024206d4776cc391e46ef28c018434", "patch": "@@ -184,7 +184,7 @@ pub struct Body {\n     /// The `ExprId` of the actual body expression.\n     pub body_expr: ExprId,\n     pub item_scope: ItemScope,\n-    pub parent_map: FxHashMap<ExprId, ExprId>,\n+    pub parent_map: ArenaMap<ExprId, ExprId>,\n }\n \n pub type ExprPtr = AstPtr<ast::Expr>;"}, {"sha": "114b38710d1bde3fe6ba802dad13acb5b4899f87", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 157, "deletions": 80, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/2608a6fd3a024206d4776cc391e46ef28c018434/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2608a6fd3a024206d4776cc391e46ef28c018434/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=2608a6fd3a024206d4776cc391e46ef28c018434", "patch": "@@ -7,15 +7,14 @@ use hir_expand::{\n     name::{name, AsName, Name},\n     HirFileId, MacroDefId, MacroDefKind,\n };\n-use ra_arena::Arena;\n+use ra_arena::{map::ArenaMap, Arena};\n use ra_syntax::{\n     ast::{\n         self, ArgListOwner, ArrayExprKind, LiteralKind, LoopBodyOwner, ModuleItemOwner, NameOwner,\n         SlicePatComponents, TypeAscriptionOwner,\n     },\n     AstNode, AstPtr,\n };\n-use rustc_hash::FxHashMap;\n use test_utils::mark;\n \n use crate::{\n@@ -75,7 +74,7 @@ pub(super) fn lower(\n             params: Vec::new(),\n             body_expr: dummy_expr_id(),\n             item_scope: Default::default(),\n-            parent_map: FxHashMap::default(),\n+            parent_map: ArenaMap::default(),\n         },\n         item_trees: {\n             let mut map = FxHashMap::default();\n@@ -97,6 +96,40 @@ struct ExprCollector<'a> {\n     item_trees: FxHashMap<HirFileId, Arc<ItemTree>>,\n }\n \n+macro_rules! track_parent {\n+    (@build $collector:ident, $parent:expr $(,)?) => {\n+        $parent\n+    };\n+    (@build $collector:ident, $parent:expr, opt $expr:ident $($rest:tt)*) => {\n+        {\n+            if let Some(expr) = $expr {\n+                $collector.body.parent_map.insert(expr, $parent);\n+            }\n+            track_parent!(@build $collector, $parent $($rest)*)\n+        }\n+    };\n+    (@build $collector:ident, $parent:expr, vec $expr:ident $($rest:tt)*) => {\n+        {\n+            for expr in $expr {\n+                $collector.body.parent_map.insert(expr, $parent);\n+            }\n+            track_parent!(@build $collector, $parent $($rest)*)\n+        }\n+    };\n+    (@build $collector:ident, $parent:expr, $expr:ident $($rest:tt)*) => {\n+        {\n+            $collector.body.parent_map.insert($expr, $parent);\n+            track_parent!(@build $collector, $parent $($rest)*)\n+        }\n+    };\n+    ($collector:ident, $parent:expr, $($rest:tt)*) => {\n+        {\n+            let parent = $parent;\n+            track_parent!(@build $collector, parent, $($rest)*)\n+        }\n+    }\n+}\n+\n impl ExprCollector<'_> {\n     fn collect(\n         mut self,\n@@ -185,14 +218,42 @@ impl ExprCollector<'_> {\n     }\n \n     fn collect_expr(&mut self, expr: ast::Expr) -> ExprId {\n-        let parent_and_children = self.collect_expr_inner(expr);\n-        self.update_parent_map(parent_and_children)\n+        let expr_id = self.collect_expr_inner(expr);\n+\n+        debug_assert!({\n+            let mut found_count = 0;\n+            let mut incr = || {\n+                found_count += 1;\n+                true\n+            };\n+            let mut all_children_found = true;\n+            self.body[expr_id].walk_child_exprs(|child| {\n+                all_children_found = all_children_found\n+                    && self\n+                        .body\n+                        .parent_map\n+                        .get(child)\n+                        .map(|parent| *parent == expr_id)\n+                        .unwrap_or(false)\n+                    && incr()\n+            });\n+\n+            if all_children_found {\n+                let child_count_in_map =\n+                    self.body.parent_map.iter().filter(|&(_, parent)| *parent == expr_id).count();\n+                found_count == child_count_in_map\n+            } else {\n+                false\n+            }\n+        });\n+\n+        expr_id\n     }\n \n-    fn collect_expr_inner(&mut self, expr: ast::Expr) -> (ExprId, Vec<ExprId>) {\n+    fn collect_expr_inner(&mut self, expr: ast::Expr) -> ExprId {\n         let syntax_ptr = AstPtr::new(&expr);\n         if !self.expander.is_cfg_enabled(&expr) {\n-            return (self.missing_expr(), vec![]);\n+            return self.missing_expr();\n         }\n \n         match expr {\n@@ -224,48 +285,40 @@ impl ExprCollector<'_> {\n                                     guard: None,\n                                 },\n                             ];\n-                            let children_exprs = if let Some(else_branch) = else_branch {\n-                                vec![match_expr, then_branch, else_branch]\n-                            } else {\n-                                vec![match_expr, then_branch]\n-                            };\n-                            return (\n+                            let arm_exprs = arms.iter().map(|arm| arm.expr).collect::<Vec<_>>();\n+                            return track_parent!(\n+                                self,\n                                 self.alloc_expr(Expr::Match { expr: match_expr, arms }, syntax_ptr),\n-                                children_exprs,\n+                                match_expr, vec arm_exprs\n                             );\n                         }\n                     },\n                 };\n \n-                let children_exprs = if let Some(else_branch) = else_branch {\n-                    vec![then_branch, else_branch, condition]\n-                } else {\n-                    vec![then_branch, condition]\n-                };\n-\n-                (\n+                track_parent!(\n+                    self,\n                     self.alloc_expr(Expr::If { condition, then_branch, else_branch }, syntax_ptr),\n-                    children_exprs,\n+                    then_branch, opt else_branch, condition\n                 )\n             }\n             ast::Expr::EffectExpr(e) => match e.effect() {\n                 ast::Effect::Try(_) => {\n                     let body = self.collect_block_opt(e.block_expr());\n-                    (self.alloc_expr(Expr::TryBlock { body }, syntax_ptr), vec![body])\n+                    track_parent!(self, self.alloc_expr(Expr::TryBlock { body }, syntax_ptr), body)\n                 }\n                 ast::Effect::Unsafe(_) => {\n                     let body = self.collect_block_opt(e.block_expr());\n-                    (self.alloc_expr(Expr::Unsafe { body }, syntax_ptr), vec![body])\n+                    track_parent!(self, self.alloc_expr(Expr::Unsafe { body }, syntax_ptr), body)\n                 }\n                 // FIXME: we need to record these effects somewhere...\n                 ast::Effect::Async(_) | ast::Effect::Label(_) => {\n-                    (self.collect_block_opt(e.block_expr()), vec![])\n+                    self.collect_block_opt(e.block_expr())\n                 }\n             },\n-            ast::Expr::BlockExpr(e) => (self.collect_block(e), vec![]),\n+            ast::Expr::BlockExpr(e) => self.collect_block(e),\n             ast::Expr::LoopExpr(e) => {\n                 let body = self.collect_block_opt(e.loop_body());\n-                (self.alloc_expr(\n+                track_parent!(self, self.alloc_expr(Expr::Loop { body }, syntax_ptr), vec![body])\n                     Expr::Loop {\n                         body,\n                         label: e\n@@ -274,7 +327,7 @@ impl ExprCollector<'_> {\n                             .map(|l| Name::new_lifetime(&l)),\n                     },\n                     syntax_ptr,\n-                ), vec![body])\n+                ), body)\n             }\n             ast::Expr::WhileExpr(e) => {\n                 let body = self.collect_block_opt(e.loop_body());\n@@ -285,7 +338,6 @@ impl ExprCollector<'_> {\n                         None => self.collect_expr_opt(condition.expr()),\n                         // if let -- desugar to match\n                         Some(pat) => {\n-                            // FIXME(pfaria) track the break and arms parents here?\n                             mark::hit!(infer_resolve_while_let);\n                             let pat = self.collect_pat(pat);\n                             let match_expr = self.collect_expr_opt(condition.expr());\n@@ -298,7 +350,7 @@ impl ExprCollector<'_> {\n                             ];\n                             let match_expr =\n                                 self.alloc_expr_desugared(Expr::Match { expr: match_expr, arms });\n-                            return (self.alloc_expr(\n+                            return track_parent!(self, self.alloc_expr(\n                                 Expr::Loop {\n                                     body: match_expr,\n                                     label: e\n@@ -307,12 +359,12 @@ impl ExprCollector<'_> {\n                                         .map(|l| Name::new_lifetime(&l)),\n                                 },\n                                 syntax_ptr,\n-                            ), vec![match_expr]);\n+                            ), match_expr);\n                         }\n                     },\n                 };\n \n-                (self.alloc_expr(\n+                track_parent!(self, self.alloc_expr(\n                     Expr::While {\n                         condition,\n                         body,\n@@ -322,13 +374,13 @@ impl ExprCollector<'_> {\n                             .map(|l| Name::new_lifetime(&l)),\n                     },\n                     syntax_ptr,\n-                ), vec![body, condition])\n+                ), body, condition)\n             }\n             ast::Expr::ForExpr(e) => {\n                 let iterable = self.collect_expr_opt(e.iterable());\n                 let pat = self.collect_pat_opt(e.pat());\n                 let body = self.collect_block_opt(e.loop_body());\n-                (self.alloc_expr(\n+                track_parent!(self, self.alloc_expr(\n                     Expr::For {\n                         iterable,\n                         pat,\n@@ -339,7 +391,7 @@ impl ExprCollector<'_> {\n                             .map(|l| Name::new_lifetime(&l)),\n                     },\n                     syntax_ptr,\n-                ), vec![iterable, body])\n+                ), iterable, body)\n             }\n             ast::Expr::CallExpr(e) => {\n                 let callee = self.collect_expr_opt(e.expr());\n@@ -348,9 +400,7 @@ impl ExprCollector<'_> {\n                 } else {\n                     Vec::new()\n                 };\n-                let mut children_exprs = args.clone();\n-                children_exprs.push(callee);\n-                (self.alloc_expr(Expr::Call { callee, args }, syntax_ptr), children_exprs)\n+                track_parent!(self, self.alloc_expr(Expr::Call { callee, args: args.clone() }, syntax_ptr), callee, vec args)\n             }\n             ast::Expr::MethodCallExpr(e) => {\n                 let receiver = self.collect_expr_opt(e.expr());\n@@ -362,19 +412,24 @@ impl ExprCollector<'_> {\n                 let method_name = e.name_ref().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);\n                 let generic_args =\n                     e.type_arg_list().and_then(|it| GenericArgs::from_ast(&self.ctx(), it));\n-                let mut children_exprs = args.clone();\n-                children_exprs.push(receiver);\n-                (\n+                track_parent!(\n+                    self,\n                     self.alloc_expr(\n-                        Expr::MethodCall { receiver, method_name, args, generic_args },\n+                        Expr::MethodCall {\n+                            receiver,\n+                            method_name,\n+                            args: args.clone(),\n+                            generic_args\n+                        },\n                         syntax_ptr,\n                     ),\n-                    children_exprs,\n+                    receiver,\n+                    vec args\n                 )\n             }\n             ast::Expr::MatchExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n-                let (arms, mut children_exprs): (Vec<_>, Vec<_>) =\n+                let (arms, children_exprs): (Vec<_>, Vec<_>) =\n                     if let Some(match_arm_list) = e.match_arm_list() {\n                         match_arm_list\n                             .arms()\n@@ -396,38 +451,37 @@ impl ExprCollector<'_> {\n                     } else {\n                         (vec![], vec![])\n                     };\n-                children_exprs.push(expr);\n-                (self.alloc_expr(Expr::Match { expr, arms }, syntax_ptr), children_exprs)\n+                track_parent!(self, self.alloc_expr(Expr::Match { expr, arms: arms.clone() }, syntax_ptr), expr, vec children_exprs)\n             }\n             ast::Expr::PathExpr(e) => {\n                 let path = e\n                     .path()\n                     .and_then(|path| self.expander.parse_path(path))\n                     .map(Expr::Path)\n                     .unwrap_or(Expr::Missing);\n-                (self.alloc_expr(path, syntax_ptr), vec![])\n+                self.alloc_expr(path, syntax_ptr)\n             }\n             ast::Expr::ContinueExpr(e) => (self.alloc_expr(\n                 Expr::Continue { label: e.lifetime_token().map(|l| Name::new_lifetime(&l)) },\n                 syntax_ptr,\n             ), vec![]),\n             ast::Expr::BreakExpr(e) => {\n                 let expr = e.expr().map(|e| self.collect_expr(e));\n-                (self.alloc_expr(\n+                track_parent!(self, self.alloc_expr(\n                     Expr::Break { expr, label: e.lifetime_token().map(|l| Name::new_lifetime(&l)) },\n                     syntax_ptr,\n-                ), expr.into_iter().collect())\n+                ), opt expr)\n             }\n             ast::Expr::ParenExpr(e) => {\n                 let inner = self.collect_expr_opt(e.expr());\n                 // make the paren expr point to the inner expression as well\n                 let src = self.expander.to_source(syntax_ptr);\n                 self.source_map.expr_map.insert(src, inner);\n-                (inner, vec![])\n+                inner\n             }\n             ast::Expr::ReturnExpr(e) => {\n                 let expr = e.expr().map(|e| self.collect_expr(e));\n-                (self.alloc_expr(Expr::Return { expr }, syntax_ptr), expr.into_iter().collect())\n+                track_parent!(self, self.alloc_expr(Expr::Return { expr }, syntax_ptr), opt expr)\n             }\n             ast::Expr::RecordLit(e) => {\n                 let path = e.path().and_then(|path| self.expander.parse_path(path));\n@@ -463,28 +517,32 @@ impl ExprCollector<'_> {\n                     let src = self.expander.to_source(ptr);\n                     self.source_map.field_map.insert((res, i), src);\n                 }\n-                (res, children)\n+                track_parent!(self, res, vec children)\n             }\n             ast::Expr::FieldExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n                 let name = match e.field_access() {\n                     Some(kind) => kind.as_name(),\n                     _ => Name::missing(),\n                 };\n-                (self.alloc_expr(Expr::Field { expr, name }, syntax_ptr), vec![expr])\n+                track_parent!(self, self.alloc_expr(Expr::Field { expr, name }, syntax_ptr), expr)\n             }\n             ast::Expr::AwaitExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n-                (self.alloc_expr(Expr::Await { expr }, syntax_ptr), vec![expr])\n+                track_parent!(self, self.alloc_expr(Expr::Await { expr }, syntax_ptr), expr)\n             }\n             ast::Expr::TryExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n-                (self.alloc_expr(Expr::Try { expr }, syntax_ptr), vec![expr])\n+                track_parent!(self, self.alloc_expr(Expr::Try { expr }, syntax_ptr), expr)\n             }\n             ast::Expr::CastExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n                 let type_ref = TypeRef::from_ast_opt(&self.ctx(), e.type_ref());\n-                (self.alloc_expr(Expr::Cast { expr, type_ref }, syntax_ptr), vec![expr])\n+                track_parent!(\n+                    self,\n+                    self.alloc_expr(Expr::Cast { expr, type_ref }, syntax_ptr),\n+                    expr\n+                )\n             }\n             ast::Expr::RefExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n@@ -501,15 +559,22 @@ impl ExprCollector<'_> {\n                     Mutability::from_mutable(e.mut_token().is_some())\n                 };\n                 let rawness = Rawness::from_raw(raw_tok);\n-\n-                self.alloc_expr(Expr::Ref { expr, rawness, mutability }, syntax_ptr)\n+                track_parent!(\n+                    self,\n+                    self.alloc_expr(Expr::Ref { expr, rawness, mutability }, syntax_ptr),\n+                    expr\n+                )\n             }\n             ast::Expr::PrefixExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n                 if let Some(op) = e.op_kind() {\n-                    (self.alloc_expr(Expr::UnaryOp { expr, op }, syntax_ptr), vec![expr])\n+                    track_parent!(\n+                        self,\n+                        self.alloc_expr(Expr::UnaryOp { expr, op }, syntax_ptr),\n+                        expr\n+                    )\n                 } else {\n-                    (self.alloc_expr(Expr::Missing, syntax_ptr), vec![])\n+                    self.alloc_expr(Expr::Missing, syntax_ptr)\n                 }\n             }\n             ast::Expr::LambdaExpr(e) => {\n@@ -529,24 +594,30 @@ impl ExprCollector<'_> {\n                     .and_then(|r| r.type_ref())\n                     .map(|it| TypeRef::from_ast(&self.ctx(), it));\n                 let body = self.collect_expr_opt(e.body());\n-                (\n+                track_parent!(\n+                    self,\n                     self.alloc_expr(Expr::Lambda { args, arg_types, ret_type, body }, syntax_ptr),\n-                    vec![body],\n+                    body,\n                 )\n             }\n             ast::Expr::BinExpr(e) => {\n                 let lhs = self.collect_expr_opt(e.lhs());\n                 let rhs = self.collect_expr_opt(e.rhs());\n                 let op = e.op_kind().map(BinaryOp::from);\n-                (self.alloc_expr(Expr::BinaryOp { lhs, rhs, op }, syntax_ptr), vec![lhs, rhs])\n+                track_parent!(\n+                    self,\n+                    self.alloc_expr(Expr::BinaryOp { lhs, rhs, op }, syntax_ptr),\n+                    lhs,\n+                    rhs\n+                )\n             }\n             ast::Expr::TupleExpr(e) => {\n                 let exprs = e.exprs().map(|expr| self.collect_expr(expr)).collect::<Vec<_>>();\n-                (self.alloc_expr(Expr::Tuple { exprs: exprs.clone() }, syntax_ptr), exprs)\n+                track_parent!(self, self.alloc_expr(Expr::Tuple { exprs: exprs.clone() }, syntax_ptr), vec exprs)\n             }\n             ast::Expr::BoxExpr(e) => {\n                 let expr = self.collect_expr_opt(e.expr());\n-                (self.alloc_expr(Expr::Box { expr }, syntax_ptr), vec![expr])\n+                track_parent!(self, self.alloc_expr(Expr::Box { expr }, syntax_ptr), expr)\n             }\n \n             ast::Expr::ArrayExpr(e) => {\n@@ -555,45 +626,51 @@ impl ExprCollector<'_> {\n                 match kind {\n                     ArrayExprKind::ElementList(e) => {\n                         let exprs = e.map(|expr| self.collect_expr(expr)).collect::<Vec<_>>();\n-                        (\n+                        track_parent!(self,\n                             self.alloc_expr(\n                                 Expr::Array(Array::ElementList(exprs.clone())),\n                                 syntax_ptr,\n                             ),\n-                            exprs,\n+                            vec exprs,\n                         )\n                     }\n                     ArrayExprKind::Repeat { initializer, repeat } => {\n                         let initializer = self.collect_expr_opt(initializer);\n                         let repeat = self.collect_expr_opt(repeat);\n-                        (\n+                        track_parent!(\n+                            self,\n                             self.alloc_expr(\n                                 Expr::Array(Array::Repeat { initializer, repeat }),\n                                 syntax_ptr,\n                             ),\n-                            vec![initializer, repeat],\n+                            initializer,\n+                            repeat,\n                         )\n                     }\n                 }\n             }\n \n-            ast::Expr::Literal(e) => {\n-                (self.alloc_expr(Expr::Literal(e.kind().into()), syntax_ptr), vec![])\n-            }\n+            ast::Expr::Literal(e) => self.alloc_expr(Expr::Literal(e.kind().into()), syntax_ptr),\n             ast::Expr::IndexExpr(e) => {\n                 let base = self.collect_expr_opt(e.base());\n                 let index = self.collect_expr_opt(e.index());\n-                (self.alloc_expr(Expr::Index { base, index }, syntax_ptr), vec![base, index])\n+                track_parent!(\n+                    self,\n+                    self.alloc_expr(Expr::Index { base, index }, syntax_ptr),\n+                    base,\n+                    index\n+                )\n             }\n             ast::Expr::RangeExpr(e) => {\n                 let lhs = e.start().map(|lhs| self.collect_expr(lhs));\n                 let rhs = e.end().map(|rhs| self.collect_expr(rhs));\n                 match e.op_kind() {\n-                    Some(range_type) => (\n+                    Some(range_type) => track_parent!(\n+                        self,\n                         self.alloc_expr(Expr::Range { lhs, rhs, range_type }, syntax_ptr),\n-                        lhs.into_iter().chain(rhs.into_iter()).collect(),\n+                        opt lhs, opt rhs\n                     ),\n-                    None => (self.alloc_expr(Expr::Missing, syntax_ptr), vec![]),\n+                    None => self.alloc_expr(Expr::Missing, syntax_ptr),\n                 }\n             }\n             ast::Expr::MacroCall(e) => {\n@@ -607,7 +684,7 @@ impl ExprCollector<'_> {\n                     self.body.item_scope.define_legacy_macro(name, mac);\n \n                     // FIXME: do we still need to allocate this as missing ?\n-                    (self.alloc_expr(Expr::Missing, syntax_ptr), vec![])\n+                    self.alloc_expr(Expr::Missing, syntax_ptr)\n                 } else {\n                     let macro_call = self.expander.to_source(AstPtr::new(&e));\n                     match self.expander.enter_expand(self.db, Some(&self.body.item_scope), e) {\n@@ -620,15 +697,15 @@ impl ExprCollector<'_> {\n                             self.item_trees.insert(self.expander.current_file_id, item_tree);\n                             let id = self.collect_expr(expansion);\n                             self.expander.exit(self.db, mark);\n-                            (id, vec![])\n+                            id\n                         }\n-                        None => (self.alloc_expr(Expr::Missing, syntax_ptr), vec![]),\n+                        None => self.alloc_expr(Expr::Missing, syntax_ptr),\n                     }\n                 }\n             }\n \n             // FIXME implement HIR for these:\n-            ast::Expr::Label(_e) => (self.alloc_expr(Expr::Missing, syntax_ptr), vec![]),\n+            ast::Expr::Label(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n         }\n     }\n "}, {"sha": "7db928dded28396bdd39b0819172299d816eb393", "filename": "crates/ra_hir_ty/src/expr.rs", "status": "modified", "additions": 1, "deletions": 70, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/2608a6fd3a024206d4776cc391e46ef28c018434/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2608a6fd3a024206d4776cc391e46ef28c018434/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs?ref=2608a6fd3a024206d4776cc391e46ef28c018434", "patch": "@@ -2,15 +2,14 @@\n \n use std::sync::Arc;\n \n-use hir_def::{path::path, resolver::HasResolver, AdtId, DefWithBodyId, FunctionId};\n+use hir_def::{path::path, resolver::HasResolver, AdtId, FunctionId};\n use hir_expand::diagnostics::DiagnosticSink;\n use ra_syntax::{ast, AstPtr};\n use rustc_hash::FxHashSet;\n \n use crate::{\n     db::HirDatabase,\n     diagnostics::{MissingFields, MissingMatchArms, MissingOkInTailExpr, MissingPatFields},\n-    lower::CallableDef,\n     utils::variant_data,\n     ApplicationTy, InferenceResult, Ty, TypeCtor,\n     _match::{is_useful, MatchCheckCtx, Matrix, PatStack, Usefulness},\n@@ -313,71 +312,3 @@ pub fn record_pattern_missing_fields(\n     }\n     Some((variant_def, missed_fields, exhaustive))\n }\n-\n-pub struct UnsafeExpr {\n-    pub expr: ExprId,\n-    pub inside_unsafe_block: bool,\n-}\n-\n-impl UnsafeExpr {\n-    fn new(expr: ExprId) -> Self {\n-        Self { expr, inside_unsafe_block: false }\n-    }\n-}\n-\n-pub fn unsafe_expressions(\n-    db: &dyn HirDatabase,\n-    infer: &InferenceResult,\n-    def: DefWithBodyId,\n-) -> Vec<UnsafeExpr> {\n-    let mut unsafe_exprs = vec![];\n-    let mut unsafe_block_exprs = FxHashSet::default();\n-    let body = db.body(def);\n-    for (id, expr) in body.exprs.iter() {\n-        match expr {\n-            Expr::Unsafe { .. } => {\n-                unsafe_block_exprs.insert(id);\n-            }\n-            Expr::Call { callee, .. } => {\n-                let ty = &infer[*callee];\n-                if let &Ty::Apply(ApplicationTy {\n-                    ctor: TypeCtor::FnDef(CallableDef::FunctionId(func)),\n-                    ..\n-                }) = ty\n-                {\n-                    if db.function_data(func).is_unsafe {\n-                        unsafe_exprs.push(UnsafeExpr::new(id));\n-                    }\n-                }\n-            }\n-            Expr::MethodCall { .. } => {\n-                if infer\n-                    .method_resolution(id)\n-                    .map(|func| db.function_data(func).is_unsafe)\n-                    .unwrap_or(false)\n-                {\n-                    unsafe_exprs.push(UnsafeExpr::new(id));\n-                }\n-            }\n-            Expr::UnaryOp { expr, op: UnaryOp::Deref } => {\n-                if let Ty::Apply(ApplicationTy { ctor: TypeCtor::RawPtr(..), .. }) = &infer[*expr] {\n-                    unsafe_exprs.push(UnsafeExpr::new(id));\n-                }\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    'unsafe_exprs: for unsafe_expr in &mut unsafe_exprs {\n-        let mut child = unsafe_expr.expr;\n-        while let Some(parent) = body.parent_map.get(&child) {\n-            if unsafe_block_exprs.contains(parent) {\n-                unsafe_expr.inside_unsafe_block = true;\n-                continue 'unsafe_exprs;\n-            }\n-            child = *parent;\n-        }\n-    }\n-\n-    unsafe_exprs\n-}"}, {"sha": "430182803e08f73b48735c315d06a433e76ad829", "filename": "crates/ra_hir_ty/src/unsafe_validation.rs", "status": "modified", "additions": 73, "deletions": 2, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/2608a6fd3a024206d4776cc391e46ef28c018434/crates%2Fra_hir_ty%2Fsrc%2Funsafe_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2608a6fd3a024206d4776cc391e46ef28c018434/crates%2Fra_hir_ty%2Fsrc%2Funsafe_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Funsafe_validation.rs?ref=2608a6fd3a024206d4776cc391e46ef28c018434", "patch": "@@ -3,13 +3,16 @@\n \n use std::sync::Arc;\n \n-use hir_def::FunctionId;\n+use hir_def::{DefWithBodyId, FunctionId};\n use hir_expand::diagnostics::DiagnosticSink;\n \n use crate::{\n-    db::HirDatabase, diagnostics::MissingUnsafe, expr::unsafe_expressions, InferenceResult,\n+    db::HirDatabase, diagnostics::MissingUnsafe, lower::CallableDef, ApplicationTy,\n+    InferenceResult, Ty, TypeCtor,\n };\n \n+use rustc_hash::FxHashSet;\n+\n pub use hir_def::{\n     body::{\n         scope::{ExprScopes, ScopeEntry, ScopeId},\n@@ -61,3 +64,71 @@ impl<'a, 'b> UnsafeValidator<'a, 'b> {\n         }\n     }\n }\n+\n+pub struct UnsafeExpr {\n+    pub expr: ExprId,\n+    pub inside_unsafe_block: bool,\n+}\n+\n+impl UnsafeExpr {\n+    fn new(expr: ExprId) -> Self {\n+        Self { expr, inside_unsafe_block: false }\n+    }\n+}\n+\n+pub fn unsafe_expressions(\n+    db: &dyn HirDatabase,\n+    infer: &InferenceResult,\n+    def: DefWithBodyId,\n+) -> Vec<UnsafeExpr> {\n+    let mut unsafe_exprs = vec![];\n+    let mut unsafe_block_exprs = FxHashSet::default();\n+    let body = db.body(def);\n+    for (id, expr) in body.exprs.iter() {\n+        match expr {\n+            Expr::Unsafe { .. } => {\n+                unsafe_block_exprs.insert(id);\n+            }\n+            Expr::Call { callee, .. } => {\n+                let ty = &infer[*callee];\n+                if let &Ty::Apply(ApplicationTy {\n+                    ctor: TypeCtor::FnDef(CallableDef::FunctionId(func)),\n+                    ..\n+                }) = ty\n+                {\n+                    if db.function_data(func).is_unsafe {\n+                        unsafe_exprs.push(UnsafeExpr::new(id));\n+                    }\n+                }\n+            }\n+            Expr::MethodCall { .. } => {\n+                if infer\n+                    .method_resolution(id)\n+                    .map(|func| db.function_data(func).is_unsafe)\n+                    .unwrap_or(false)\n+                {\n+                    unsafe_exprs.push(UnsafeExpr::new(id));\n+                }\n+            }\n+            Expr::UnaryOp { expr, op: UnaryOp::Deref } => {\n+                if let Ty::Apply(ApplicationTy { ctor: TypeCtor::RawPtr(..), .. }) = &infer[*expr] {\n+                    unsafe_exprs.push(UnsafeExpr::new(id));\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    'unsafe_exprs: for unsafe_expr in &mut unsafe_exprs {\n+        let mut child = unsafe_expr.expr;\n+        while let Some(parent) = body.parent_map.get(child) {\n+            if unsafe_block_exprs.contains(parent) {\n+                unsafe_expr.inside_unsafe_block = true;\n+                continue 'unsafe_exprs;\n+            }\n+            child = *parent;\n+        }\n+    }\n+\n+    unsafe_exprs\n+}"}]}