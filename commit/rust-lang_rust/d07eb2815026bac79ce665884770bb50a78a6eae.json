{"sha": "d07eb2815026bac79ce665884770bb50a78a6eae", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwN2ViMjgxNTAyNmJhYzc5Y2U2NjU4ODQ3NzBiYjUwYTc4YTZlYWU=", "commit": {"author": {"name": "cassiersg", "email": "cassiersg@users.noreply.github.com", "date": "2015-08-02T12:51:48Z"}, "committer": {"name": "cassiersg", "email": "cassiersg@users.noreply.github.com", "date": "2015-08-02T12:51:48Z"}, "message": "Merge pull request #162 from cassiersg/sep-mods\n\nMove modules listing outside of FmtVisitor", "tree": {"sha": "abd5ead498571e2866ef8905ed2a3bb7a45d76a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/abd5ead498571e2866ef8905ed2a3bb7a45d76a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d07eb2815026bac79ce665884770bb50a78a6eae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d07eb2815026bac79ce665884770bb50a78a6eae", "html_url": "https://github.com/rust-lang/rust/commit/d07eb2815026bac79ce665884770bb50a78a6eae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d07eb2815026bac79ce665884770bb50a78a6eae/comments", "author": {"login": "cassiersg", "id": 9348542, "node_id": "MDQ6VXNlcjkzNDg1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/9348542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cassiersg", "html_url": "https://github.com/cassiersg", "followers_url": "https://api.github.com/users/cassiersg/followers", "following_url": "https://api.github.com/users/cassiersg/following{/other_user}", "gists_url": "https://api.github.com/users/cassiersg/gists{/gist_id}", "starred_url": "https://api.github.com/users/cassiersg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cassiersg/subscriptions", "organizations_url": "https://api.github.com/users/cassiersg/orgs", "repos_url": "https://api.github.com/users/cassiersg/repos", "events_url": "https://api.github.com/users/cassiersg/events{/privacy}", "received_events_url": "https://api.github.com/users/cassiersg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cassiersg", "id": 9348542, "node_id": "MDQ6VXNlcjkzNDg1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/9348542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cassiersg", "html_url": "https://github.com/cassiersg", "followers_url": "https://api.github.com/users/cassiersg/followers", "following_url": "https://api.github.com/users/cassiersg/following{/other_user}", "gists_url": "https://api.github.com/users/cassiersg/gists{/gist_id}", "starred_url": "https://api.github.com/users/cassiersg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cassiersg/subscriptions", "organizations_url": "https://api.github.com/users/cassiersg/orgs", "repos_url": "https://api.github.com/users/cassiersg/repos", "events_url": "https://api.github.com/users/cassiersg/events{/privacy}", "received_events_url": "https://api.github.com/users/cassiersg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc43b81200e268160f5c945369c377d765142886", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc43b81200e268160f5c945369c377d765142886", "html_url": "https://github.com/rust-lang/rust/commit/bc43b81200e268160f5c945369c377d765142886"}, {"sha": "5a29d2f08153d8132e63f2e41424b063fe3d8be0", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a29d2f08153d8132e63f2e41424b063fe3d8be0", "html_url": "https://github.com/rust-lang/rust/commit/5a29d2f08153d8132e63f2e41424b063fe3d8be0"}], "stats": {"total": 659, "additions": 273, "deletions": 386}, "files": [{"sha": "82dbafd47d62189e52fcd5c70c2bb7ee4a3f392f", "filename": "Cargo.lock", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d07eb2815026bac79ce665884770bb50a78a6eae/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/d07eb2815026bac79ce665884770bb50a78a6eae/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=d07eb2815026bac79ce665884770bb50a78a6eae", "patch": "@@ -2,24 +2,24 @@\n name = \"rustfmt\"\n version = \"0.0.1\"\n dependencies = [\n- \"diff 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 0.1.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"diff 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex 0.1.41 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"strings 0.0.1 (git+https://github.com/nrc/strings.rs.git)\",\n- \"toml 0.1.20 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"toml 0.1.21 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"aho-corasick\"\n-version = \"0.2.1\"\n+version = \"0.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"memchr 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"diff\"\n-version = \"0.1.3\"\n+version = \"0.1.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -37,17 +37,17 @@ dependencies = [\n \n [[package]]\n name = \"regex\"\n-version = \"0.1.38\"\n+version = \"0.1.41\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"aho-corasick 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"aho-corasick 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"memchr 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex-syntax 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"regex-syntax 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"regex-syntax\"\n-version = \"0.1.2\"\n+version = \"0.2.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n@@ -58,11 +58,11 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n [[package]]\n name = \"strings\"\n version = \"0.0.1\"\n-source = \"git+https://github.com/nrc/strings.rs.git#b7f37c4545b7dba24fb28161cd9c405fae978be4\"\n+source = \"git+https://github.com/nrc/strings.rs.git#6d748148fbe3bf2d9e5ac2ede65ac503d7491a4f\"\n \n [[package]]\n name = \"toml\"\n-version = \"0.1.20\"\n+version = \"0.1.21\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"rustc-serialize 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "ab5968dbf76883b098c747beda4672c8c00bfb7b", "filename": "src/changes.rs", "status": "removed", "additions": 0, "deletions": 256, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/bc43b81200e268160f5c945369c377d765142886/src%2Fchanges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc43b81200e268160f5c945369c377d765142886/src%2Fchanges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchanges.rs?ref=bc43b81200e268160f5c945369c377d765142886", "patch": "@@ -1,256 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-// TODO\n-// print to files\n-// tests\n-\n-use strings::string_buffer::StringBuffer;\n-use std::collections::HashMap;\n-use syntax::codemap::{CodeMap, Span, BytePos};\n-use std::fmt;\n-use std::fs::File;\n-use std::io::{Write, stdout};\n-use WriteMode;\n-use NewlineStyle;\n-use config::Config;\n-use utils::round_up_to_power_of_two;\n-\n-// This is basically a wrapper around a bunch of Ropes which makes it convenient\n-// to work with libsyntax. It is badly named.\n-pub struct ChangeSet<'a> {\n-    file_map: HashMap<String, StringBuffer>,\n-    codemap: &'a CodeMap,\n-    file_spans: Vec<(u32, u32)>,\n-}\n-\n-impl<'a> ChangeSet<'a> {\n-    // Create a new ChangeSet for a given libsyntax CodeMap.\n-    pub fn from_codemap(codemap: &'a CodeMap) -> ChangeSet<'a> {\n-        let mut result = ChangeSet {\n-            file_map: HashMap::new(),\n-            codemap: codemap,\n-            file_spans: Vec::with_capacity(codemap.files.borrow().len()),\n-        };\n-\n-        for f in codemap.files.borrow().iter() {\n-            // Use the length of the file as a heuristic for how much space we\n-            // need. Round to the next power of two.\n-            let buffer_cap = round_up_to_power_of_two(f.src.as_ref().unwrap().len());\n-\n-            result.file_map.insert(f.name.clone(), StringBuffer::with_capacity(buffer_cap));\n-            result.file_spans.push((f.start_pos.0, f.end_pos.0));\n-        }\n-\n-        result.file_spans.sort();\n-\n-        result\n-    }\n-\n-    pub fn filespans_for_span(&self, start: BytePos, end: BytePos) -> Vec<(u32, u32)> {\n-        assert!(start.0 <= end.0);\n-\n-        if self.file_spans.len() == 0 {\n-            return Vec::new();\n-        }\n-\n-        // idx is the index into file_spans which indicates the current file, we\n-        // with the file start denotes.\n-        let mut idx = match self.file_spans.binary_search(&(start.0, ::std::u32::MAX)) {\n-            Ok(i) => i,\n-            Err(0) => 0,\n-            Err(i) => i - 1,\n-        };\n-\n-        let mut result = Vec::new();\n-        let mut start = start.0;\n-        loop {\n-            let cur_file = &self.file_spans[idx];\n-            idx += 1;\n-\n-            if idx >= self.file_spans.len() || start >= end.0 {\n-                if start < end.0 {\n-                    result.push((start, end.0));\n-                }\n-                return result;\n-            }\n-\n-            let end = ::std::cmp::min(cur_file.1 - 1, end.0);\n-            if start < end {\n-                result.push((start, end));\n-            }\n-            start = self.file_spans[idx].0;\n-        }\n-    }\n-\n-    pub fn push_str(&mut self, filename: &str, text: &str) {\n-        let buf = self.file_map.get_mut(&*filename).unwrap();\n-        buf.push_str(text)\n-    }\n-\n-    pub fn push_str_span(&mut self, span: Span, text: &str) {\n-        let file_name = self.codemap.span_to_filename(span);\n-        self.push_str(&file_name, text)\n-    }\n-\n-    // Fetch the output buffer for the given file name.\n-    // Panics on unknown files.\n-    pub fn get(&mut self, file_name: &str) -> &StringBuffer {\n-        self.file_map.get(file_name).unwrap()\n-    }\n-\n-    // Fetch a mutable reference to the output buffer for the given file name.\n-    // Panics on unknown files.\n-    pub fn get_mut(&mut self, file_name: &str) -> &mut StringBuffer {\n-        self.file_map.get_mut(file_name).unwrap()\n-    }\n-\n-    pub fn cur_offset(&mut self, filename: &str) -> usize {\n-        self.file_map[&*filename].cur_offset()\n-    }\n-\n-    pub fn cur_offset_span(&mut self, span: Span) -> usize {\n-        let filename = self.codemap.span_to_filename(span);\n-        self.cur_offset(&filename)\n-    }\n-\n-    // Return an iterator over the entire changed text.\n-    pub fn text<'c>(&'c self) -> FileIterator<'c, 'a> {\n-        FileIterator { change_set: self, keys: self.file_map.keys().collect(), cur_key: 0 }\n-    }\n-\n-    // Append a newline to the end of each file.\n-    pub fn append_newlines(&mut self) {\n-        for (_, s) in self.file_map.iter_mut() {\n-            s.push_str(\"\\n\");\n-        }\n-    }\n-\n-    pub fn write_all_files(&self,\n-                           mode: WriteMode,\n-                           config: &Config)\n-                           -> Result<(HashMap<String, String>), ::std::io::Error> {\n-        let mut result = HashMap::new();\n-        for filename in self.file_map.keys() {\n-            let one_result = try!(self.write_file(filename, mode, config));\n-            if let Some(r) = one_result {\n-                result.insert(filename.clone(), r);\n-            }\n-        }\n-\n-        Ok(result)\n-    }\n-\n-    pub fn write_file(&self,\n-                      filename: &str,\n-                      mode: WriteMode,\n-                      config: &Config)\n-                      -> Result<Option<String>, ::std::io::Error> {\n-        let text = &self.file_map[filename];\n-\n-        // prints all newlines either as `\\n` or as `\\r\\n`\n-        fn write_system_newlines<T>(mut writer: T,\n-                                    text: &StringBuffer,\n-                                    config: &Config)\n-                                    -> Result<(), ::std::io::Error>\n-            where T: Write\n-        {\n-            match config.newline_style {\n-                NewlineStyle::Unix => write!(writer, \"{}\", text),\n-                NewlineStyle::Windows => {\n-                    for (c, _) in text.chars() {\n-                        match c {\n-                            '\\n' => try!(write!(writer, \"\\r\\n\")),\n-                            '\\r' => continue,\n-                            c => try!(write!(writer, \"{}\", c)),\n-                        }\n-                    }\n-                    Ok(())\n-                },\n-            }\n-        }\n-\n-        match mode {\n-            WriteMode::Overwrite => {\n-                // Do a little dance to make writing safer - write to a temp file\n-                // rename the original to a .bk, then rename the temp file to the\n-                // original.\n-                let tmp_name = filename.to_owned() + \".tmp\";\n-                let bk_name = filename.to_owned() + \".bk\";\n-                {\n-                    // Write text to temp file\n-                    let tmp_file = try!(File::create(&tmp_name));\n-                    try!(write_system_newlines(tmp_file, text, config));\n-                }\n-\n-                try!(::std::fs::rename(filename, bk_name));\n-                try!(::std::fs::rename(tmp_name, filename));\n-            }\n-            WriteMode::NewFile(extn) => {\n-                let filename = filename.to_owned() + \".\" + extn;\n-                let file = try!(File::create(&filename));\n-                try!(write_system_newlines(file, text, config));\n-            }\n-            WriteMode::Display => {\n-                println!(\"{}:\\n\", filename);\n-                let stdout = stdout();\n-                let stdout_lock = stdout.lock();\n-                try!(write_system_newlines(stdout_lock, text, config));\n-            }\n-            WriteMode::Return(_) => {\n-                // io::Write is not implemented for String, working around with Vec<u8>\n-                let mut v = Vec::new();\n-                try!(write_system_newlines(&mut v, text, config));\n-                // won't panic, we are writing correct utf8\n-                return Ok(Some(String::from_utf8(v).unwrap()));\n-            }\n-        }\n-\n-        Ok(None)\n-    }\n-\n-    pub fn is_changed(&self, filename: &str) -> bool {\n-        self.file_map.get(filename).expect(\"Unknown filename\").len != 0\n-    }\n-}\n-\n-// Iterates over each file in the ChangSet. Yields the filename and the changed\n-// text for that file.\n-pub struct FileIterator<'c, 'a: 'c> {\n-    change_set: &'c ChangeSet<'a>,\n-    keys: Vec<&'c String>,\n-    cur_key: usize,\n-}\n-\n-impl<'c, 'a> Iterator for FileIterator<'c, 'a> {\n-    type Item = (&'c str, &'c StringBuffer);\n-\n-    fn next(&mut self) -> Option<(&'c str, &'c StringBuffer)> {\n-        if self.cur_key >= self.keys.len() {\n-            return None;\n-        }\n-\n-        let key = self.keys[self.cur_key];\n-        self.cur_key += 1;\n-        return Some((&key, &self.change_set.file_map[&*key]))\n-    }\n-}\n-\n-impl<'a> fmt::Display for ChangeSet<'a> {\n-    // Prints the entire changed text.\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n-        for (f, r) in self.text() {\n-            try!(write!(fmt, \"{}:\\n\", f));\n-            try!(write!(fmt, \"{}\\n\\n\", r));\n-        }\n-        Ok(())\n-    }\n-}"}, {"sha": "334c509c59d39f781dddf3b5a3511d0b2d45e63d", "filename": "src/expr.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d07eb2815026bac79ce665884770bb50a78a6eae/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d07eb2815026bac79ce665884770bb50a78a6eae/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=d07eb2815026bac79ce665884770bb50a78a6eae", "patch": "@@ -138,13 +138,9 @@ impl Rewrite for ast::Block {\n \n         // Push text between last block item and end of block\n         let snippet = visitor.snippet(mk_sp(visitor.last_pos, self.span.hi));\n-        visitor.changes.push_str_span(self.span, &snippet);\n+        visitor.buffer.push_str(&snippet);\n \n-        // Stringify visitor\n-        let file_name = context.codemap.span_to_filename(self.span);\n-        let string_buffer = visitor.changes.get(&file_name);\n-\n-        Some(format!(\"{}{}\", prefix, string_buffer))\n+        Some(format!(\"{}{}\", prefix, visitor.buffer))\n     }\n }\n "}, {"sha": "8e09837df0a6284da8f12a19c6016e955e4aa210", "filename": "src/filemap.rs", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/d07eb2815026bac79ce665884770bb50a78a6eae/src%2Ffilemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d07eb2815026bac79ce665884770bb50a78a6eae/src%2Ffilemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffilemap.rs?ref=d07eb2815026bac79ce665884770bb50a78a6eae", "patch": "@@ -0,0 +1,112 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// TODO tests\n+\n+use strings::string_buffer::StringBuffer;\n+use std::collections::HashMap;\n+use std::fs::{self, File};\n+use std::io::{self, Write, stdout};\n+use WriteMode;\n+use NewlineStyle;\n+use config::Config;\n+\n+// A map of the files of a crate, with their new content\n+pub type FileMap = HashMap<String, StringBuffer>;\n+\n+// Append a newline to the end of each file.\n+pub fn append_newlines(file_map: &mut FileMap) {\n+    for (_, s) in file_map.iter_mut() {\n+        s.push_str(\"\\n\");\n+    }\n+}\n+\n+pub fn write_all_files(file_map: &FileMap,\n+                       mode: WriteMode,\n+                       config: &Config)\n+                       -> Result<(HashMap<String, String>), io::Error> {\n+    let mut result = HashMap::new();\n+    for filename in file_map.keys() {\n+        let one_result = try!(write_file(&file_map[filename], filename, mode, config));\n+        if let Some(r) = one_result {\n+            result.insert(filename.clone(), r);\n+        }\n+    }\n+\n+    Ok(result)\n+}\n+\n+fn write_file(text: &StringBuffer,\n+              filename: &str,\n+              mode: WriteMode,\n+              config: &Config)\n+              -> Result<Option<String>, io::Error> {\n+\n+    // prints all newlines either as `\\n` or as `\\r\\n`\n+    fn write_system_newlines<T>(mut writer: T,\n+                                text: &StringBuffer,\n+                                config: &Config)\n+                                -> Result<(), io::Error>\n+        where T: Write\n+    {\n+        match config.newline_style {\n+                NewlineStyle::Unix => write!(writer, \"{}\", text),\n+                NewlineStyle::Windows => {\n+                    for (c, _) in text.chars() {\n+                        match c {\n+                            '\\n' => try!(write!(writer, \"\\r\\n\")),\n+                            '\\r' => continue,\n+                            c => try!(write!(writer, \"{}\", c)),\n+                        }\n+                    }\n+                    Ok(())\n+                },\n+            }\n+    }\n+\n+    match mode {\n+            WriteMode::Overwrite => {\n+                // Do a little dance to make writing safer - write to a temp file\n+                // rename the original to a .bk, then rename the temp file to the\n+                // original.\n+                let tmp_name = filename.to_owned() + \".tmp\";\n+                let bk_name = filename.to_owned() + \".bk\";\n+                {\n+                    // Write text to temp file\n+                    let tmp_file = try!(File::create(&tmp_name));\n+                    try!(write_system_newlines(tmp_file, text, config));\n+                }\n+\n+                try!(fs::rename(filename, bk_name));\n+                try!(fs::rename(tmp_name, filename));\n+            }\n+            WriteMode::NewFile(extn) => {\n+                let filename = filename.to_owned() + \".\" + extn;\n+                let file = try!(File::create(&filename));\n+                try!(write_system_newlines(file, text, config));\n+            }\n+            WriteMode::Display => {\n+                println!(\"{}:\\n\", filename);\n+                let stdout = stdout();\n+                let stdout_lock = stdout.lock();\n+                try!(write_system_newlines(stdout_lock, text, config));\n+            }\n+            WriteMode::Return(_) => {\n+                // io::Write is not implemented for String, working around with Vec<u8>\n+                let mut v = Vec::new();\n+                try!(write_system_newlines(&mut v, text, config));\n+                // won't panic, we are writing correct utf8\n+                return Ok(Some(String::from_utf8(v).unwrap()));\n+            }\n+        }\n+\n+    Ok(None)\n+}"}, {"sha": "378d822d4133d1d13449eed38b243edd13741823", "filename": "src/items.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d07eb2815026bac79ce665884770bb50a78a6eae/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d07eb2815026bac79ce665884770bb50a78a6eae/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=d07eb2815026bac79ce665884770bb50a78a6eae", "patch": "@@ -382,7 +382,7 @@ impl<'a> FmtVisitor<'a> {\n                       generics: &ast::Generics,\n                       span: Span) {\n         let header_str = self.format_header(\"enum \", ident, vis);\n-        self.changes.push_str_span(span, &header_str);\n+        self.buffer.push_str(&header_str);\n \n         let enum_snippet = self.snippet(span);\n         let body_start = span.lo + BytePos(enum_snippet.find_uncommented(\"{\").unwrap() as u32 + 1);\n@@ -391,7 +391,7 @@ impl<'a> FmtVisitor<'a> {\n                                                 self.block_indent + self.config.tab_spaces,\n                                                 codemap::mk_sp(span.lo,\n                                                                body_start));\n-        self.changes.push_str_span(span, &generics_str);\n+        self.buffer.push_str(&generics_str);\n \n         self.last_pos = body_start;\n         self.block_indent += self.config.tab_spaces;\n@@ -407,7 +407,7 @@ impl<'a> FmtVisitor<'a> {\n         self.block_indent -= self.config.tab_spaces;\n \n         self.format_missing_with_indent(span.lo + BytePos(enum_snippet.rfind('}').unwrap() as u32));\n-        self.changes.push_str_span(span, \"}\");\n+        self.buffer.push_str(\"}\");\n     }\n \n     // Variant of an enum\n@@ -421,9 +421,9 @@ impl<'a> FmtVisitor<'a> {\n         let result = match field.node.kind {\n             ast::VariantKind::TupleVariantKind(ref types) => {\n                 let vis = format_visibility(field.node.vis);\n-                self.changes.push_str_span(field.span, vis);\n+                self.buffer.push_str(vis);\n                 let name = field.node.name.to_string();\n-                self.changes.push_str_span(field.span, &name);\n+                self.buffer.push_str(&name);\n \n                 let mut result = String::new();\n \n@@ -491,10 +491,10 @@ impl<'a> FmtVisitor<'a> {\n                                    self.block_indent)\n             }\n         };\n-        self.changes.push_str_span(field.span, &result);\n+        self.buffer.push_str(&result);\n \n         if !last_field || self.config.enum_trailing_comma {\n-            self.changes.push_str_span(field.span, \",\");\n+            self.buffer.push_str(\",\");\n         }\n \n         self.last_pos = field.span.hi + BytePos(1);\n@@ -621,7 +621,7 @@ impl<'a> FmtVisitor<'a> {\n                                         Some(generics),\n                                         span,\n                                         indent);\n-        self.changes.push_str_span(span, &result);\n+        self.buffer.push_str(&result);\n         self.last_pos = span.hi;\n     }\n "}, {"sha": "c0aff9a05b3f2ea72c127ecb63e893098a42688b", "filename": "src/lib.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d07eb2815026bac79ce665884770bb50a78a6eae/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d07eb2815026bac79ce665884770bb50a78a6eae/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=d07eb2815026bac79ce665884770bb50a78a6eae", "patch": "@@ -37,22 +37,21 @@ use rustc_driver::{driver, CompilerCalls, Compilation};\n use syntax::ast;\n use syntax::codemap::CodeMap;\n use syntax::diagnostics;\n-use syntax::visit;\n \n use std::path::PathBuf;\n use std::collections::HashMap;\n use std::fmt;\n use std::mem::swap;\n \n use issues::{BadIssueSeeker, Issue};\n-use changes::ChangeSet;\n+use filemap::FileMap;\n use visitor::FmtVisitor;\n use config::Config;\n \n #[macro_use]\n mod utils;\n pub mod config;\n-mod changes;\n+mod filemap;\n mod visitor;\n mod items;\n mod missed_spans;\n@@ -64,6 +63,7 @@ mod issues;\n mod rewrite;\n mod string;\n mod comment;\n+mod modules;\n \n const MIN_STRING: usize = 10;\n // When we get scoped annotations, we should have rustfmt::skip.\n@@ -196,21 +196,26 @@ impl fmt::Display for FormatReport {\n }\n \n // Formatting which depends on the AST.\n-fn fmt_ast<'a>(krate: &ast::Crate, codemap: &'a CodeMap, config: &'a Config) -> ChangeSet<'a> {\n-    let mut visitor = FmtVisitor::from_codemap(codemap, config);\n-    visit::walk_crate(&mut visitor, krate);\n-    visitor.changes\n+fn fmt_ast(krate: &ast::Crate, codemap: &CodeMap, config: &Config) -> FileMap {\n+    let mut file_map = FileMap::new();\n+    for (path, module) in modules::list_files(krate, codemap) {\n+        let path = path.to_str().unwrap();\n+        let mut visitor = FmtVisitor::from_codemap(codemap, config);\n+        visitor.format_separate_mod(module, path);\n+        file_map.insert(path.to_owned(), visitor.buffer);\n+    }\n+    file_map\n }\n \n // Formatting done on a char by char or line by line basis.\n // TODO warn on bad license\n // TODO other stuff for parity with make tidy\n-fn fmt_lines(changes: &mut ChangeSet, config: &Config) -> FormatReport {\n+fn fmt_lines(file_map: &mut FileMap, config: &Config) -> FormatReport {\n     let mut truncate_todo = Vec::new();\n     let mut report = FormatReport { file_error_map: HashMap::new() };\n \n-    // Iterate over the chars in the change set.\n-    for (f, text) in changes.text() {\n+    // Iterate over the chars in the file map.\n+    for (f, text) in file_map.iter() {\n         let mut trims = vec![];\n         let mut last_wspace: Option<usize> = None;\n         let mut line_len = 0;\n@@ -278,7 +283,7 @@ fn fmt_lines(changes: &mut ChangeSet, config: &Config) -> FormatReport {\n     }\n \n     for (f, l) in truncate_todo {\n-        changes.get_mut(&f).truncate(l);\n+        file_map.get_mut(&f).unwrap().truncate(l);\n     }\n \n     report\n@@ -312,13 +317,13 @@ impl<'a> CompilerCalls<'a> for RustFmtCalls {\n         control.after_parse.callback = Box::new(move |state| {\n             let krate = state.krate.unwrap();\n             let codemap = state.session.codemap();\n-            let mut changes = fmt_ast(krate, codemap, &*config);\n+            let mut file_map = fmt_ast(krate, codemap, &*config);\n             // For some reason, the codemap does not include terminating newlines\n             // so we must add one on for each file. This is sad.\n-            changes.append_newlines();\n-            println!(\"{}\", fmt_lines(&mut changes, &*config));\n+            filemap::append_newlines(&mut file_map);\n+            println!(\"{}\", fmt_lines(&mut file_map, &*config));\n \n-            let result = changes.write_all_files(write_mode, &*config);\n+            let result = filemap::write_all_files(&file_map, write_mode, &*config);\n \n             match result {\n                 Err(msg) => println!(\"Error writing files: {}\", msg),"}, {"sha": "64025550410de61157250f26c61c9f2c4097ecd3", "filename": "src/missed_spans.rs", "status": "modified", "additions": 24, "deletions": 31, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/d07eb2815026bac79ce665884770bb50a78a6eae/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d07eb2815026bac79ce665884770bb50a78a6eae/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=d07eb2815026bac79ce665884770bb50a78a6eae", "patch": "@@ -17,34 +17,33 @@ impl<'a> FmtVisitor<'a> {\n     // TODO these format_missing methods are ugly. Refactor and add unit tests\n     // for the central whitespace stripping loop.\n     pub fn format_missing(&mut self, end: BytePos) {\n-        self.format_missing_inner(end, |this, last_snippet, file_name, _| {\n-            this.changes.push_str(file_name, last_snippet)\n+        self.format_missing_inner(end, |this, last_snippet, _| {\n+            this.buffer.push_str(last_snippet)\n         })\n     }\n \n     pub fn format_missing_with_indent(&mut self, end: BytePos) {\n-        self.format_missing_inner(end, |this, last_snippet, file_name, snippet| {\n-            this.changes.push_str(file_name, last_snippet.trim_right());\n+        self.format_missing_inner(end, |this, last_snippet, snippet| {\n+            this.buffer.push_str(last_snippet.trim_right());\n             if last_snippet == snippet {\n                 // No new lines in the snippet.\n-                this.changes.push_str(file_name, \"\\n\");\n+                this.buffer.push_str(\"\\n\");\n             }\n             let indent = make_indent(this.block_indent);\n-            this.changes.push_str(file_name, &indent);\n+            this.buffer.push_str(&indent);\n         })\n     }\n \n-    fn format_missing_inner<F: Fn(&mut FmtVisitor, &str, &str, &str)>(&mut self,\n-                                                                      end: BytePos,\n-                                                                      process_last_snippet: F) {\n+    fn format_missing_inner<F: Fn(&mut FmtVisitor, &str, &str)>(&mut self,\n+                                                                end: BytePos,\n+                                                                process_last_snippet: F) {\n         let start = self.last_pos;\n         debug!(\"format_missing_inner: {:?} to {:?}\",\n                self.codemap.lookup_char_pos(start),\n                self.codemap.lookup_char_pos(end));\n \n         if start == end {\n-            let file_name = &self.codemap.lookup_char_pos(start).file.name;\n-            process_last_snippet(self, \"\", file_name, \"\");\n+            process_last_snippet(self, \"\", \"\");\n             return;\n         }\n \n@@ -54,24 +53,18 @@ impl<'a> FmtVisitor<'a> {\n                 self.codemap.lookup_char_pos(end));\n \n         self.last_pos = end;\n-        let spans = self.changes.filespans_for_span(start, end);\n-        for (i, &(start, end)) in spans.iter().enumerate() {\n-            let span = codemap::mk_sp(BytePos(start), BytePos(end));\n-            let file_name = &self.codemap.span_to_filename(span);\n-            let snippet = self.snippet(span);\n+        let span = codemap::mk_sp(start, end);\n+        let snippet = self.snippet(span);\n \n-            self.write_snippet(&snippet,\n-                               file_name,\n-                               i == spans.len() - 1,\n-                               &process_last_snippet);\n-        }\n+        self.write_snippet(&snippet,\n+                           true,\n+                           &process_last_snippet);\n     }\n \n-    fn write_snippet<F: Fn(&mut FmtVisitor, &str, &str, &str)>(&mut self,\n-                                                               snippet: &str,\n-                                                               file_name: &str,\n-                                                               last_snippet: bool,\n-                                                               process_last_snippet: F) {\n+    fn write_snippet<F: Fn(&mut FmtVisitor, &str, &str)>(&mut self,\n+                                                         snippet: &str,\n+                                                         last_snippet: bool,\n+                                                         process_last_snippet: F) {\n         // Trim whitespace from the right hand side of each line.\n         // Annoyingly, the library functions for splitting by lines etc. are not\n         // quite right, so we must do it ourselves.\n@@ -80,10 +73,10 @@ impl<'a> FmtVisitor<'a> {\n         for (i, c) in snippet.char_indices() {\n             if c == '\\n' {\n                 if let Some(lw) = last_wspace {\n-                    self.changes.push_str(file_name, &snippet[line_start..lw]);\n-                    self.changes.push_str(file_name, \"\\n\");\n+                    self.buffer.push_str(&snippet[line_start..lw]);\n+                    self.buffer.push_str(\"\\n\");\n                 } else {\n-                    self.changes.push_str(file_name, &snippet[line_start..i+1]);\n+                    self.buffer.push_str(&snippet[line_start..i+1]);\n                 }\n \n                 line_start = i + 1;\n@@ -99,9 +92,9 @@ impl<'a> FmtVisitor<'a> {\n             }\n         }\n         if last_snippet {\n-            process_last_snippet(self, &snippet[line_start..], file_name, snippet);\n+            process_last_snippet(self, &snippet[line_start..], snippet);\n         } else {\n-            self.changes.push_str(file_name, &snippet[line_start..]);\n+            self.buffer.push_str(&snippet[line_start..]);\n         }\n     }\n }"}, {"sha": "2f40fd33a55821314039e3dc398782ef6f03506a", "filename": "src/modules.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/d07eb2815026bac79ce665884770bb50a78a6eae/src%2Fmodules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d07eb2815026bac79ce665884770bb50a78a6eae/src%2Fmodules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmodules.rs?ref=d07eb2815026bac79ce665884770bb50a78a6eae", "patch": "@@ -0,0 +1,72 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use utils;\n+\n+use std::path::{Path, PathBuf};\n+use std::collections::HashMap;\n+\n+use syntax::ast;\n+use syntax::codemap;\n+use syntax::parse::parser;\n+\n+\n+/// List all the files containing modules of a crate.\n+/// If a file is used twice in a crate, it appears only once.\n+pub fn list_files<'a>(krate: &'a ast::Crate,\n+                      codemap: &codemap::CodeMap)\n+                      -> HashMap<PathBuf, &'a ast::Mod> {\n+    let mut result = HashMap::new();\n+    let root_filename: PathBuf = codemap.span_to_filename(krate.span).into();\n+    list_submodules(&krate.module, root_filename.parent().unwrap(), codemap, &mut result);\n+    result.insert(root_filename, &krate.module);\n+    result\n+}\n+\n+/// Recursively list all external modules included in a module.\n+fn list_submodules<'a>(module: &'a ast::Mod,\n+                       search_dir: &Path,\n+                       codemap: &codemap::CodeMap,\n+                       result: &mut HashMap<PathBuf, &'a ast::Mod>) {\n+    debug!(\"list_submodules: search_dir: {:?}\", search_dir);\n+    for item in module.items.iter() {\n+        if let ast::ItemMod(ref sub_mod) = item.node {\n+            if !utils::contains_skip(&item.attrs) {\n+                let is_internal = codemap.span_to_filename(item.span) ==\n+                                  codemap.span_to_filename(sub_mod.inner);\n+                let dir_path = if is_internal {\n+                    search_dir.join(&item.ident.to_string())\n+                } else {\n+                    let mod_path = module_file(item.ident, &item.attrs, search_dir, codemap);\n+                    let dir_path = mod_path.parent().unwrap().to_owned();\n+                    result.insert(mod_path, sub_mod);\n+                    dir_path\n+                };\n+                list_submodules(sub_mod, &dir_path, codemap, result);\n+            }\n+        }\n+    }\n+}\n+\n+/// Find the file corresponding to an external mod\n+fn module_file(id: ast::Ident,\n+               attrs: &[ast::Attribute],\n+               dir_path: &Path,\n+               codemap: &codemap::CodeMap)\n+               -> PathBuf {\n+    if let Some(path) = parser::Parser::submod_path_from_attr(attrs, &dir_path) {\n+        return path;\n+    }\n+\n+    match parser::Parser::default_submod_path(id, &dir_path, codemap).result {\n+        Ok(parser::ModulePathSuccess { path, .. }) => path,\n+        Err(_) => panic!(\"Couldn't find module {}\", id)\n+    }\n+}"}, {"sha": "23908edf8d0517e13e660f8236ee0750a1048b86", "filename": "src/visitor.rs", "status": "modified", "additions": 17, "deletions": 59, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/d07eb2815026bac79ce665884770bb50a78a6eae/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d07eb2815026bac79ce665884770bb50a78a6eae/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=d07eb2815026bac79ce665884770bb50a78a6eae", "patch": "@@ -11,18 +11,16 @@\n use syntax::ast;\n use syntax::codemap::{self, CodeMap, Span, BytePos};\n use syntax::visit;\n-use syntax::parse::parser;\n-use std::path::PathBuf;\n+\n+use strings::string_buffer::StringBuffer;\n \n use utils;\n use config::Config;\n-\n-use changes::ChangeSet;\n use rewrite::{Rewrite, RewriteContext};\n \n pub struct FmtVisitor<'a> {\n     pub codemap: &'a CodeMap,\n-    pub changes: ChangeSet<'a>,\n+    pub buffer: StringBuffer,\n     pub last_pos: BytePos,\n     // TODO RAII util for indenting\n     pub block_indent: usize,\n@@ -35,7 +33,7 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n                self.codemap.lookup_char_pos(ex.span.lo),\n                self.codemap.lookup_char_pos(ex.span.hi));\n         self.format_missing(ex.span.lo);\n-        let offset = self.changes.cur_offset_span(ex.span);\n+        let offset = self.buffer.cur_offset();\n         let context = RewriteContext {\n             codemap: self.codemap,\n             config: self.config,\n@@ -44,7 +42,7 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n         let rewrite = ex.rewrite(&context, self.config.max_width - offset, offset);\n \n         if let Some(new_str) = rewrite {\n-            self.changes.push_str_span(ex.span, &new_str);\n+            self.buffer.push_str(&new_str);\n             self.last_pos = ex.span.hi;\n         }\n     }\n@@ -74,7 +72,7 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n                self.codemap.lookup_char_pos(b.span.lo),\n                self.codemap.lookup_char_pos(b.span.hi));\n \n-        self.changes.push_str_span(b.span, \"{\");\n+        self.buffer.push_str(\"{\");\n         self.last_pos = self.last_pos + BytePos(1);\n         self.block_indent += self.config.tab_spaces;\n \n@@ -93,7 +91,7 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n         self.block_indent -= self.config.tab_spaces;\n         // TODO we should compress any newlines here to just one\n         self.format_missing_with_indent(b.span.hi - BytePos(1));\n-        self.changes.push_str_span(b.span, \"}\");\n+        self.buffer.push_str(\"}\");\n         self.last_pos = b.span.hi;\n     }\n \n@@ -126,7 +124,7 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n                                              abi,\n                                              vis,\n                                              codemap::mk_sp(s.lo, b.span.lo));\n-                self.changes.push_str_span(s, &new_fn);\n+                self.buffer.push_str(&new_fn);\n             }\n             visit::FkMethod(ident, ref sig, vis) => {\n                 let new_fn = self.rewrite_fn(indent,\n@@ -139,7 +137,7 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n                                              &sig.abi,\n                                              vis.unwrap_or(ast::Visibility::Inherited),\n                                              codemap::mk_sp(s.lo, b.span.lo));\n-                self.changes.push_str_span(s, &new_fn);\n+                self.buffer.push_str(&new_fn);\n             }\n             visit::FkFnBlock(..) => {}\n         }\n@@ -175,7 +173,7 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n             ast::Item_::ItemExternCrate(_) => {\n                 self.format_missing_with_indent(item.span.lo);\n                 let new_str = self.snippet(item.span);\n-                self.changes.push_str_span(item.span, &new_str);\n+                self.buffer.push_str(&new_str);\n                 self.last_pos = item.span.hi;\n             }\n             ast::Item_::ItemStruct(ref def, ref generics) => {\n@@ -197,7 +195,7 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n             }\n             ast::Item_::ItemMod(ref module) => {\n                 self.format_missing_with_indent(item.span.lo);\n-                self.format_mod(module, item.span, item.ident, &item.attrs);\n+                self.format_mod(module, item.span, item.ident);\n             }\n             _ => {\n                 visit::walk_item(self, item);\n@@ -219,7 +217,7 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n                                                   sig,\n                                                   ti.span);\n \n-            self.changes.push_str_span(ti.span, &new_fn);\n+            self.buffer.push_str(&new_fn);\n             self.last_pos = ti.span.hi;\n         }\n         // TODO format trait types\n@@ -237,19 +235,13 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n     fn visit_mac(&mut self, mac: &'v ast::Mac) {\n         visit::walk_mac(self, mac)\n     }\n-\n-    fn visit_mod(&mut self, m: &'v ast::Mod, s: Span, _: ast::NodeId) {\n-        // This is only called for the root module\n-        let filename = self.codemap.span_to_filename(s);\n-        self.format_separate_mod(m, &filename);\n-    }\n }\n \n impl<'a> FmtVisitor<'a> {\n     pub fn from_codemap<'b>(codemap: &'b CodeMap, config: &'b Config) -> FmtVisitor<'b> {\n         FmtVisitor {\n             codemap: codemap,\n-            changes: ChangeSet::from_codemap(codemap),\n+            buffer: StringBuffer::new(),\n             last_pos: BytePos(0),\n             block_indent: 0,\n             config: config,\n@@ -281,7 +273,7 @@ impl<'a> FmtVisitor<'a> {\n             true\n         } else {\n             let rewrite = self.rewrite_attrs(attrs, self.block_indent);\n-            self.changes.push_str_span(first.span, &rewrite);\n+            self.buffer.push_str(&rewrite);\n             let last = attrs.last().unwrap();\n             self.last_pos = last.span.hi;\n             false\n@@ -322,7 +314,7 @@ impl<'a> FmtVisitor<'a> {\n         result\n     }\n \n-    fn format_mod(&mut self, m: &ast::Mod, s: Span, ident: ast::Ident, attrs: &[ast::Attribute]) {\n+    fn format_mod(&mut self, m: &ast::Mod, s: Span, ident: ast::Ident) {\n         debug!(\"FmtVisitor::format_mod: ident: {:?}, span: {:?}\", ident, s);\n \n         // Decide whether this is an inline mod or an external mod.\n@@ -337,49 +329,15 @@ impl<'a> FmtVisitor<'a> {\n             visit::walk_mod(self, m);\n             debug!(\"... last_pos after: {:?}\", self.last_pos);\n             self.block_indent -= self.config.tab_spaces;\n-        } else {\n-            debug!(\"FmtVisitor::format_mod: external mod\");\n-            let file_path = self.module_file(ident, attrs, local_file_name);\n-            let filename = file_path.to_str().unwrap();\n-            if self.changes.is_changed(filename) {\n-                // The file has already been reformatted, do nothing\n-            } else {\n-                self.format_separate_mod(m, filename);\n-            }\n-        }\n-\n-        debug!(\"FmtVisitor::format_mod: exit\");\n-    }\n-\n-    /// Find the file corresponding to an external mod\n-    fn module_file(&self, id: ast::Ident, attrs: &[ast::Attribute], filename: String) -> PathBuf {\n-        let dir_path = {\n-            let mut path = PathBuf::from(&filename);\n-            path.pop();\n-            path\n-        };\n-\n-        if let Some(path) = parser::Parser::submod_path_from_attr(attrs, &dir_path) {\n-            return path;\n-        }\n-\n-        match parser::Parser::default_submod_path(id, &dir_path, &self.codemap).result {\n-            Ok(parser::ModulePathSuccess { path, .. }) => path,\n-            _ => panic!(\"Couldn't find module {}\", id)\n         }\n     }\n \n-    /// Format the content of a module into a separate file\n-    fn format_separate_mod(&mut self, m: &ast::Mod, filename: &str) {\n-        let last_pos = self.last_pos;\n-        let block_indent = self.block_indent;\n+    pub fn format_separate_mod(&mut self, m: &ast::Mod, filename: &str) {\n         let filemap = self.codemap.get_filemap(filename);\n         self.last_pos = filemap.start_pos;\n         self.block_indent = 0;\n         visit::walk_mod(self, m);\n         self.format_missing(filemap.end_pos);\n-        self.last_pos = last_pos;\n-        self.block_indent = block_indent;\n     }\n \n     fn format_import(&mut self, vis: ast::Visibility, vp: &ast::ViewPath, span: Span) {\n@@ -405,7 +363,7 @@ impl<'a> FmtVisitor<'a> {\n             Some(ref s) => {\n                 let s = format!(\"{}use {};\", vis, s);\n                 self.format_missing_with_indent(span.lo);\n-                self.changes.push_str_span(span, &s);\n+                self.buffer.push_str(&s);\n                 self.last_pos = span.hi;\n             }\n             None => {"}, {"sha": "d04e49570a4f64b034dc130df6ce61df6ec6dfe7", "filename": "tests/source/nestedmod/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d07eb2815026bac79ce665884770bb50a78a6eae/tests%2Fsource%2Fnestedmod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d07eb2815026bac79ce665884770bb50a78a6eae/tests%2Fsource%2Fnestedmod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fnestedmod%2Fmod.rs?ref=d07eb2815026bac79ce665884770bb50a78a6eae", "patch": "@@ -4,6 +4,7 @@ mod mod2b;\n \n mod mymod1 {\n           use mod2a::{Foo,Bar};\n+mod mod3a;\n }\n \n #[path=\"mod2c.rs\"]"}, {"sha": "f28bde5e56dbbcd3572cf6c65680c6aede221f5c", "filename": "tests/source/nestedmod/mymod1/mod3a.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d07eb2815026bac79ce665884770bb50a78a6eae/tests%2Fsource%2Fnestedmod%2Fmymod1%2Fmod3a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d07eb2815026bac79ce665884770bb50a78a6eae/tests%2Fsource%2Fnestedmod%2Fmymod1%2Fmod3a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fnestedmod%2Fmymod1%2Fmod3a.rs?ref=d07eb2815026bac79ce665884770bb50a78a6eae", "patch": "@@ -0,0 +1,2 @@\n+// Another mod\n+fn a(          ) {       }"}, {"sha": "b3456bf0d0fb9b0de19effc44b365fe3ee973cd8", "filename": "tests/target/nestedmod/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d07eb2815026bac79ce665884770bb50a78a6eae/tests%2Ftarget%2Fnestedmod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d07eb2815026bac79ce665884770bb50a78a6eae/tests%2Ftarget%2Fnestedmod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fnestedmod%2Fmod.rs?ref=d07eb2815026bac79ce665884770bb50a78a6eae", "patch": "@@ -4,6 +4,7 @@ mod mod2b;\n \n mod mymod1 {\n     use mod2a::{Foo, Bar};\n+    mod mod3a;\n }\n \n #[path=\"mod2c.rs\"]"}, {"sha": "a6399f5565d4684b9f9e96a2fcb79ad53144a0b9", "filename": "tests/target/nestedmod/mymod1/mod3a.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d07eb2815026bac79ce665884770bb50a78a6eae/tests%2Ftarget%2Fnestedmod%2Fmymod1%2Fmod3a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d07eb2815026bac79ce665884770bb50a78a6eae/tests%2Ftarget%2Fnestedmod%2Fmymod1%2Fmod3a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fnestedmod%2Fmymod1%2Fmod3a.rs?ref=d07eb2815026bac79ce665884770bb50a78a6eae", "patch": "@@ -0,0 +1,3 @@\n+// Another mod\n+fn a() {\n+}"}]}