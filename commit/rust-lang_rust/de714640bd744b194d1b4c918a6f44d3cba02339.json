{"sha": "de714640bd744b194d1b4c918a6f44d3cba02339", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlNzE0NjQwYmQ3NDRiMTk0ZDFiNGM5MThhNmY0NGQzY2JhMDIzMzk=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-24T14:28:07Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-24T18:05:16Z"}, "message": "Add metrics", "tree": {"sha": "4436429949a9d36aa84c8333a3445135b8a41f6a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4436429949a9d36aa84c8333a3445135b8a41f6a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de714640bd744b194d1b4c918a6f44d3cba02339", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de714640bd744b194d1b4c918a6f44d3cba02339", "html_url": "https://github.com/rust-lang/rust/commit/de714640bd744b194d1b4c918a6f44d3cba02339", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de714640bd744b194d1b4c918a6f44d3cba02339/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14a3a713c74108626fe356dad21d93b84792878a", "url": "https://api.github.com/repos/rust-lang/rust/commits/14a3a713c74108626fe356dad21d93b84792878a", "html_url": "https://github.com/rust-lang/rust/commit/14a3a713c74108626fe356dad21d93b84792878a"}], "stats": {"total": 255, "additions": 255, "deletions": 0}, "files": [{"sha": "e51c62bb4cda0c813ab2927a13fc1e096c9aa844", "filename": ".github/workflows/metrics.yaml", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/de714640bd744b194d1b4c918a6f44d3cba02339/.github%2Fworkflows%2Fmetrics.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/de714640bd744b194d1b4c918a6f44d3cba02339/.github%2Fworkflows%2Fmetrics.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fmetrics.yaml?ref=de714640bd744b194d1b4c918a6f44d3cba02339", "patch": "@@ -0,0 +1,38 @@\n+name: rustdoc\n+on:\n+  push:\n+   branches:\n+   - master\n+\n+env:\n+  CARGO_INCREMENTAL: 0\n+  CARGO_NET_RETRY: 10\n+  RUSTFLAGS: -D warnings\n+  RUSTUP_MAX_RETRIES: 10\n+\n+jobs:\n+  rustdoc:\n+    runs-on: ubuntu-latest\n+\n+    steps:\n+    - name: Checkout repository\n+      uses: actions/checkout@v2\n+\n+    - name: Checkout metrics repository\n+      uses: actions/checkout@v2\n+      with:\n+        repository: \"rust-analyzer/metrics\"\n+        path: \"target/metrics\"\n+\n+    - name: Install Rust toolchain\n+      uses: actions-rs/toolchain@v1\n+      with:\n+        toolchain: stable\n+        profile: minimal\n+        override: true\n+        components: rust-src\n+\n+    - name: Collect metrics\n+      run: cargo xtask metrics\n+      env:\n+        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}"}, {"sha": "2fdb08f2e155b08b5af29cd4eda46d8b3b86c4c5", "filename": "xtask/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/de714640bd744b194d1b4c918a6f44d3cba02339/xtask%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de714640bd744b194d1b4c918a6f44d3cba02339/xtask%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Flib.rs?ref=de714640bd744b194d1b4c918a6f44d3cba02339", "patch": "@@ -7,6 +7,7 @@ pub mod install;\n pub mod release;\n pub mod dist;\n pub mod pre_commit;\n+pub mod metrics;\n \n pub mod codegen;\n mod ast_src;"}, {"sha": "6049542692bf6847a5fedc002a8157f58755f743", "filename": "xtask/src/main.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de714640bd744b194d1b4c918a6f44d3cba02339/xtask%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de714640bd744b194d1b4c918a6f44d3cba02339/xtask%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fmain.rs?ref=de714640bd744b194d1b4c918a6f44d3cba02339", "patch": "@@ -15,6 +15,7 @@ use xtask::{\n     codegen::{self, Mode},\n     dist::DistCmd,\n     install::{ClientOpt, InstallCmd, Malloc, ServerOpt},\n+    metrics::run_metrics,\n     not_bash::pushd,\n     pre_commit, project_root,\n     release::{PromoteCmd, ReleaseCmd},\n@@ -117,6 +118,7 @@ FLAGS:\n             args.finish()?;\n             DistCmd { nightly, client_version }.run()\n         }\n+        \"metrics\" => run_metrics(),\n         _ => {\n             eprintln!(\n                 \"\\"}, {"sha": "c2b6c000f000f5033d641f3ea0a00bc042487348", "filename": "xtask/src/metrics.rs", "status": "added", "additions": 214, "deletions": 0, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/de714640bd744b194d1b4c918a6f44d3cba02339/xtask%2Fsrc%2Fmetrics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de714640bd744b194d1b4c918a6f44d3cba02339/xtask%2Fsrc%2Fmetrics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fmetrics.rs?ref=de714640bd744b194d1b4c918a6f44d3cba02339", "patch": "@@ -0,0 +1,214 @@\n+use std::{\n+    collections::BTreeMap,\n+    env,\n+    fmt::{self, Write as _},\n+    io::Write as _,\n+    time::{Instant, SystemTime, UNIX_EPOCH},\n+};\n+\n+use anyhow::{bail, format_err, Result};\n+\n+use crate::not_bash::{fs2, pushd, rm_rf, run};\n+\n+type Unit = &'static str;\n+\n+pub fn run_metrics() -> Result<()> {\n+    let mut metrics = Metrics::new()?;\n+    metrics.measure_build()?;\n+\n+    {\n+        let _d = pushd(\"target/metrics\");\n+        let mut file = std::fs::OpenOptions::new().append(true).open(\"metrics.json\")?;\n+        writeln!(file, \"{}\", metrics.json())?;\n+        run!(\"git commit -am'\ud83d\udcc8'\")?;\n+\n+        if let Ok(actor) = env::var(\"GITHUB_ACTOR\") {\n+            let token = env::var(\"GITHUB_TOKEN\").unwrap();\n+            let repo = format!(\"https://{}:{}@github.com/rust-analyzer/metrics.git\", actor, token);\n+            run!(\"git push {}\", repo)?;\n+        }\n+    }\n+    eprintln!(\"{:#?}\\n\", metrics);\n+    eprintln!(\"{}\", metrics.json());\n+    Ok(())\n+}\n+\n+impl Metrics {\n+    fn measure_build(&mut self) -> Result<()> {\n+        run!(\"cargo fetch\")?;\n+        rm_rf(\"./target/release\")?;\n+\n+        let build = Instant::now();\n+        run!(\"cargo build --release --package rust-analyzer --bin rust-analyzer\")?;\n+        let build = build.elapsed();\n+        self.report(\"build\", build.as_millis() as u64, \"ms\");\n+        Ok(())\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct Metrics {\n+    host: Host,\n+    timestamp: SystemTime,\n+    revision: String,\n+    metrics: BTreeMap<String, (u64, Unit)>,\n+}\n+\n+#[derive(Debug)]\n+struct Host {\n+    os: String,\n+    cpu: String,\n+    mem: String,\n+}\n+\n+impl Metrics {\n+    fn new() -> Result<Metrics> {\n+        let host = Host::new()?;\n+        let timestamp = SystemTime::now();\n+        let revision = run!(\"git rev-parse HEAD\")?;\n+        Ok(Metrics { host, timestamp, revision, metrics: BTreeMap::new() })\n+    }\n+\n+    fn report(&mut self, name: &str, value: u64, unit: Unit) {\n+        self.metrics.insert(name.into(), (value, unit));\n+    }\n+\n+    fn json(&self) -> Json {\n+        let mut json = Json::default();\n+        self.to_json(&mut json);\n+        json\n+    }\n+    fn to_json(&self, json: &mut Json) {\n+        json.begin_object();\n+        {\n+            json.field(\"host\");\n+            self.host.to_json(json);\n+\n+            json.field(\"timestamp\");\n+            let timestamp = self.timestamp.duration_since(UNIX_EPOCH).unwrap();\n+            json.number(timestamp.as_secs() as f64);\n+\n+            json.field(\"revision\");\n+            json.string(&self.revision);\n+\n+            json.field(\"metrics\");\n+            json.begin_object();\n+            {\n+                for (k, &(value, unit)) in &self.metrics {\n+                    json.field(k);\n+                    json.begin_array();\n+                    {\n+                        json.number(value as f64);\n+                        json.string(unit);\n+                    }\n+                    json.end_array();\n+                }\n+            }\n+            json.end_object()\n+        }\n+        json.end_object();\n+    }\n+}\n+\n+impl Host {\n+    fn new() -> Result<Host> {\n+        if cfg!(not(target_os = \"linux\")) {\n+            bail!(\"can only collect metrics on Linux \");\n+        }\n+\n+        let os = read_field(\"/etc/os-release\", \"PRETTY_NAME=\")?.trim_matches('\"').to_string();\n+\n+        let cpu =\n+            read_field(\"/proc/cpuinfo\", \"model name\")?.trim_start_matches(':').trim().to_string();\n+\n+        let mem = read_field(\"/proc/meminfo\", \"MemTotal:\")?;\n+\n+        return Ok(Host { os, cpu, mem });\n+\n+        fn read_field<'a>(path: &str, field: &str) -> Result<String> {\n+            let text = fs2::read_to_string(path)?;\n+\n+            let line = text\n+                .lines()\n+                .find(|it| it.starts_with(field))\n+                .ok_or_else(|| format_err!(\"can't parse {}\", path))?;\n+            Ok(line[field.len()..].trim().to_string())\n+        }\n+    }\n+    fn to_json(&self, json: &mut Json) {\n+        json.begin_object();\n+        {\n+            json.field(\"os\");\n+            json.string(&self.os);\n+\n+            json.field(\"cpu\");\n+            json.string(&self.cpu);\n+\n+            json.field(\"mem\");\n+            json.string(&self.mem);\n+        }\n+        json.end_object();\n+    }\n+}\n+\n+#[derive(Default)]\n+struct Json {\n+    object_comma: bool,\n+    array_comma: bool,\n+    buf: String,\n+}\n+\n+impl Json {\n+    fn begin_object(&mut self) {\n+        self.object_comma = false;\n+        self.buf.push('{');\n+    }\n+    fn end_object(&mut self) {\n+        self.buf.push('}')\n+    }\n+    fn begin_array(&mut self) {\n+        self.array_comma = false;\n+        self.buf.push('[');\n+    }\n+    fn end_array(&mut self) {\n+        self.buf.push(']')\n+    }\n+    fn field(&mut self, name: &str) {\n+        self.object_comma();\n+        self.string_token(name);\n+        self.buf.push(':');\n+    }\n+    fn string(&mut self, value: &str) {\n+        self.array_comma();\n+        self.string_token(value);\n+    }\n+    fn string_token(&mut self, value: &str) {\n+        self.buf.push('\"');\n+        self.buf.extend(value.escape_default());\n+        self.buf.push('\"');\n+    }\n+    fn number(&mut self, value: f64) {\n+        self.array_comma();\n+        write!(self.buf, \"{}\", value).unwrap();\n+    }\n+\n+    fn array_comma(&mut self) {\n+        if self.array_comma {\n+            self.buf.push(',');\n+        }\n+        self.array_comma = true;\n+    }\n+\n+    fn object_comma(&mut self) {\n+        if self.object_comma {\n+            self.buf.push(',');\n+        }\n+        self.object_comma = true;\n+    }\n+}\n+\n+impl fmt::Display for Json {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}\", self.buf)\n+    }\n+}"}]}