{"sha": "73961709d623cc46ec39458f46a7173e189cda66", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczOTYxNzA5ZDYyM2NjNDZlYzM5NDU4ZjQ2YTcxNzNlMTg5Y2RhNjY=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-12-27T14:02:10Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-12-31T14:56:28Z"}, "message": "Outline combine_stack_addr_with_load_store and remove unused stack_load insts", "tree": {"sha": "5fbf88e52e79967d87c7cdfa60c52af5932f0f0b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5fbf88e52e79967d87c7cdfa60c52af5932f0f0b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73961709d623cc46ec39458f46a7173e189cda66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73961709d623cc46ec39458f46a7173e189cda66", "html_url": "https://github.com/rust-lang/rust/commit/73961709d623cc46ec39458f46a7173e189cda66", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73961709d623cc46ec39458f46a7173e189cda66/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6642e5cd8766c2bd8b6af616529c9ce28722931", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6642e5cd8766c2bd8b6af616529c9ce28722931", "html_url": "https://github.com/rust-lang/rust/commit/b6642e5cd8766c2bd8b6af616529c9ce28722931"}], "stats": {"total": 78, "additions": 48, "deletions": 30}, "files": [{"sha": "d44e5b706bcdf76ad8e93dd85c1848f572ca1ee2", "filename": "src/optimize/stack2reg.rs", "status": "modified", "additions": 48, "deletions": 30, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/73961709d623cc46ec39458f46a7173e189cda66/src%2Foptimize%2Fstack2reg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73961709d623cc46ec39458f46a7173e189cda66/src%2Foptimize%2Fstack2reg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foptimize%2Fstack2reg.rs?ref=73961709d623cc46ec39458f46a7173e189cda66", "patch": "@@ -10,36 +10,7 @@ pub(super) fn optimize_function(\n     clif_comments: &mut crate::pretty_clif::CommentWriter,\n     name: String, // FIXME remove\n ) {\n-    // Turn load and store into stack_load and stack_store when possible.\n-    let mut cursor = FuncCursor::new(func);\n-    while let Some(_ebb) = cursor.next_ebb() {\n-        while let Some(inst) = cursor.next_inst() {\n-            match cursor.func.dfg[inst] {\n-                InstructionData::Load { opcode: Opcode::Load, arg: addr, flags: _, offset } => {\n-                    if cursor.func.dfg.ctrl_typevar(inst) == types::I128 || cursor.func.dfg.ctrl_typevar(inst).is_vector() {\n-                        continue; // WORKAROUD: stack_load.i128 not yet implemented\n-                    }\n-                    if let Some((stack_slot, stack_addr_offset)) = try_get_stack_slot_and_offset_for_addr(cursor.func, addr) {\n-                        if let Some(combined_offset) = offset.try_add_i64(stack_addr_offset.into()) {\n-                            let ty = cursor.func.dfg.ctrl_typevar(inst);\n-                            cursor.func.dfg.replace(inst).stack_load(ty, stack_slot, combined_offset);\n-                        }\n-                    }\n-                }\n-                InstructionData::Store { opcode: Opcode::Store, args: [value, addr], flags: _, offset } => {\n-                    if cursor.func.dfg.ctrl_typevar(inst) == types::I128 || cursor.func.dfg.ctrl_typevar(inst).is_vector() {\n-                        continue; // WORKAROUND: stack_store.i128 not yet implemented\n-                    }\n-                    if let Some((stack_slot, stack_addr_offset)) = try_get_stack_slot_and_offset_for_addr(cursor.func, addr) {\n-                        if let Some(combined_offset) = offset.try_add_i64(stack_addr_offset.into()) {\n-                            cursor.func.dfg.replace(inst).stack_store(value, stack_slot, combined_offset);\n-                        }\n-                    }\n-                }\n-                _ => {}\n-            }\n-        }\n-    }\n+    combine_stack_addr_with_load_store(func);\n \n     // Record all stack_addr, stack_load and stack_store instructions. Also record all stack_addr\n     // and stack_load insts whose result is used.\n@@ -112,6 +83,20 @@ pub(super) fn optimize_function(\n         }\n     }\n \n+    for inst in used_stack_load_insts.keys().filter(|&inst| used_stack_load_insts[inst]) {\n+        assert!(stack_load_insts[inst]);\n+    }\n+\n+    // Replace all unused stack_load instructions with nop.\n+    for inst in stack_load_insts.keys() {\n+        if stack_load_insts[inst] && !used_stack_load_insts[inst] {\n+            func.dfg.detach_results(inst);\n+            func.dfg.replace(inst).nop();\n+            stack_load_insts[inst] = false;\n+        }\n+    }\n+\n+\n     //println!(\"stack_addr (after): [{}]\", bool_secondary_map_to_string(&stack_addr_insts));\n \n     let mut stack_slot_usage_map: SecondaryMap<StackSlot, HashSet<Inst>> = SecondaryMap::new();\n@@ -203,6 +188,39 @@ pub(super) fn optimize_function(\n     }\n }\n \n+fn combine_stack_addr_with_load_store(func: &mut Function) {\n+    // Turn load and store into stack_load and stack_store when possible.\n+    let mut cursor = FuncCursor::new(func);\n+    while let Some(_ebb) = cursor.next_ebb() {\n+        while let Some(inst) = cursor.next_inst() {\n+            match cursor.func.dfg[inst] {\n+                InstructionData::Load { opcode: Opcode::Load, arg: addr, flags: _, offset } => {\n+                    if cursor.func.dfg.ctrl_typevar(inst) == types::I128 || cursor.func.dfg.ctrl_typevar(inst).is_vector() {\n+                        continue; // WORKAROUD: stack_load.i128 not yet implemented\n+                    }\n+                    if let Some((stack_slot, stack_addr_offset)) = try_get_stack_slot_and_offset_for_addr(cursor.func, addr) {\n+                        if let Some(combined_offset) = offset.try_add_i64(stack_addr_offset.into()) {\n+                            let ty = cursor.func.dfg.ctrl_typevar(inst);\n+                            cursor.func.dfg.replace(inst).stack_load(ty, stack_slot, combined_offset);\n+                        }\n+                    }\n+                }\n+                InstructionData::Store { opcode: Opcode::Store, args: [value, addr], flags: _, offset } => {\n+                    if cursor.func.dfg.ctrl_typevar(inst) == types::I128 || cursor.func.dfg.ctrl_typevar(inst).is_vector() {\n+                        continue; // WORKAROUND: stack_store.i128 not yet implemented\n+                    }\n+                    if let Some((stack_slot, stack_addr_offset)) = try_get_stack_slot_and_offset_for_addr(cursor.func, addr) {\n+                        if let Some(combined_offset) = offset.try_add_i64(stack_addr_offset.into()) {\n+                            cursor.func.dfg.replace(inst).stack_store(value, stack_slot, combined_offset);\n+                        }\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+    }\n+}\n+\n fn try_get_stack_slot_and_offset_for_addr(func: &Function, addr: Value) -> Option<(StackSlot, Offset32)> {\n     if let ValueDef::Result(addr_inst, 0) = func.dfg.value_def(addr) {\n         if let InstructionData::StackLoad {"}]}