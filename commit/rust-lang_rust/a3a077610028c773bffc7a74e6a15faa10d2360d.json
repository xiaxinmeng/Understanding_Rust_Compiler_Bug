{"sha": "a3a077610028c773bffc7a74e6a15faa10d2360d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzYTA3NzYxMDAyOGM3NzNiZmZjN2E3NGU2YTE1ZmFhMTBkMjM2MGQ=", "commit": {"author": {"name": "Jorge Aparicio", "email": "jorge.aparicio@ferrous-systems.com", "date": "2020-01-20T07:50:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-01-20T07:50:32Z"}, "message": "Merge branch 'master' into bare-metal-cortex-a", "tree": {"sha": "819cf353c019f421d80d9545aa18583841c34348", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/819cf353c019f421d80d9545aa18583841c34348"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3a077610028c773bffc7a74e6a15faa10d2360d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeJVvICRBK7hj4Ov3rIwAAdHIIAJXWWx+ubIy6kh3jbTKaIz+j\n0DTSMu4Tgw3ad55+cpvEXrXHjzslgTvAJZqEBW9X2tw4u1f40/i5Vec6Wy/9N1R9\nr0grOOIufng0VHt2UIwTlsdoP8BN/+slX34U6V2+CLrN3Fhk3bDXcKypribSstFH\ner4tC/Rsh4c2aKRccSTseX9r432hxGnJ2xDucw0fmhS7sMM7Gim21mzudlXZojR+\nn8pYzmqmbhULbxS3bXir63oHyClUd5lmdTFKpSJAhJZMFWTUR6mgEvY1cyyMbxzm\nFNFEmtosGAQzzl4OzVRVXWXOSelBrtPps4sflVzJ+nWdXioTBt/dbhHotNsYzhU=\n=nTyP\n-----END PGP SIGNATURE-----\n", "payload": "tree 819cf353c019f421d80d9545aa18583841c34348\nparent 470cdf54ac9acee20ab8da46ef7899bae9f58f29\nparent 29b854fb741809c29764e33fc17c32ba9c6523ba\nauthor Jorge Aparicio <jorge.aparicio@ferrous-systems.com> 1579506632 +0000\ncommitter GitHub <noreply@github.com> 1579506632 +0000\n\nMerge branch 'master' into bare-metal-cortex-a"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3a077610028c773bffc7a74e6a15faa10d2360d", "html_url": "https://github.com/rust-lang/rust/commit/a3a077610028c773bffc7a74e6a15faa10d2360d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3a077610028c773bffc7a74e6a15faa10d2360d/comments", "author": {"login": "japaric", "id": 5018213, "node_id": "MDQ6VXNlcjUwMTgyMTM=", "avatar_url": "https://avatars.githubusercontent.com/u/5018213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/japaric", "html_url": "https://github.com/japaric", "followers_url": "https://api.github.com/users/japaric/followers", "following_url": "https://api.github.com/users/japaric/following{/other_user}", "gists_url": "https://api.github.com/users/japaric/gists{/gist_id}", "starred_url": "https://api.github.com/users/japaric/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/japaric/subscriptions", "organizations_url": "https://api.github.com/users/japaric/orgs", "repos_url": "https://api.github.com/users/japaric/repos", "events_url": "https://api.github.com/users/japaric/events{/privacy}", "received_events_url": "https://api.github.com/users/japaric/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "470cdf54ac9acee20ab8da46ef7899bae9f58f29", "url": "https://api.github.com/repos/rust-lang/rust/commits/470cdf54ac9acee20ab8da46ef7899bae9f58f29", "html_url": "https://github.com/rust-lang/rust/commit/470cdf54ac9acee20ab8da46ef7899bae9f58f29"}, {"sha": "29b854fb741809c29764e33fc17c32ba9c6523ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/29b854fb741809c29764e33fc17c32ba9c6523ba", "html_url": "https://github.com/rust-lang/rust/commit/29b854fb741809c29764e33fc17c32ba9c6523ba"}], "stats": {"total": 24232, "additions": 14174, "deletions": 10058}, "files": [{"sha": "d9761ce40927ce92d29daa23b4496e04b9e97e4f", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -34,14 +34,7 @@ __pycache__/\n # Created by default with `src/ci/docker/run.sh`:\n /obj/\n /rustllvm/\n-/src/libcore/unicode/DerivedCoreProperties.txt\n-/src/libcore/unicode/DerivedNormalizationProps.txt\n-/src/libcore/unicode/PropList.txt\n-/src/libcore/unicode/ReadMe.txt\n-/src/libcore/unicode/Scripts.txt\n-/src/libcore/unicode/SpecialCasing.txt\n-/src/libcore/unicode/UnicodeData.txt\n-/src/libcore/unicode/downloaded\n+/unicode-downloads\n /target/\n # Generated by compiletest for incremental:\n /tmp/"}, {"sha": "62cbbdd9a3a0663c13f2df49375eb225ff8079c0", "filename": ".gitmodules", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -40,7 +40,7 @@\n [submodule \"src/llvm-project\"]\n \tpath = src/llvm-project\n \turl = https://github.com/rust-lang/llvm-project.git\n-\tbranch = rustc/9.0-2019-09-19\n+\tbranch = rustc/9.0-2019-12-19\n [submodule \"src/doc/embedded-book\"]\n \tpath = src/doc/embedded-book\n \turl = https://github.com/rust-embedded/book.git"}, {"sha": "f33d7ff12febff8ddad98478bc31215fb2e5f310", "filename": "Cargo.lock", "status": "modified", "additions": 43, "deletions": 9, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -207,6 +207,7 @@ dependencies = [\n  \"serde_json\",\n  \"time\",\n  \"toml\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n@@ -520,9 +521,9 @@ dependencies = [\n \n [[package]]\n name = \"cmake\"\n-version = \"0.1.38\"\n+version = \"0.1.42\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"96210eec534fc3fbfc0452a63769424eaa80205fda6cea98e5b61cb3d97bcec8\"\n+checksum = \"81fb25b677f8bf1eb325017cb6bb8452f87969db0fedb4f757b297bee78a7c62\"\n dependencies = [\n  \"cc\",\n ]\n@@ -576,9 +577,9 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.22\"\n+version = \"0.1.24\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e6f083abf9bb9005a27d2da62706f661245278cb7096da37ab27410eaf60f2c1\"\n+checksum = \"b9975aefa63997ef75ca9cf013ff1bb81487aaa0b622c21053afd3b92979a7af\"\n dependencies = [\n  \"cc\",\n  \"rustc-std-workspace-core\",\n@@ -1587,12 +1588,11 @@ dependencies = [\n \n [[package]]\n name = \"iovec\"\n-version = \"0.1.2\"\n+version = \"0.1.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dbe6e417e7d0975db6512b90796e8ce223145ac4e33c377e4a42882a0e88bb08\"\n+checksum = \"b2b3ea6ff95e175473f8ffe6a7eb7c00d054240321b84c57051175fe3c1e075e\"\n dependencies = [\n  \"libc\",\n- \"winapi 0.2.8\",\n ]\n \n [[package]]\n@@ -1812,9 +1812,9 @@ dependencies = [\n \n [[package]]\n name = \"libssh2-sys\"\n-version = \"0.2.11\"\n+version = \"0.2.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"126a1f4078368b163bfdee65fbab072af08a1b374a5551b21e87ade27b1fbf9d\"\n+checksum = \"36aa6e813339d3a063292b77091dfbbb6152ff9006a459895fa5bebed7d34f10\"\n dependencies = [\n  \"cc\",\n  \"libc\",\n@@ -3497,6 +3497,7 @@ dependencies = [\n  \"serialize\",\n  \"smallvec 1.0.0\",\n  \"stable_deref_trait\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n@@ -3524,6 +3525,7 @@ dependencies = [\n  \"rustc_target\",\n  \"serialize\",\n  \"syntax\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n@@ -3543,6 +3545,7 @@ dependencies = [\n  \"term_size\",\n  \"termcolor\",\n  \"unicode-width\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n@@ -3649,11 +3652,13 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_target\",\n  \"rustc_traits\",\n+ \"rustc_ty\",\n  \"rustc_typeck\",\n  \"serialize\",\n  \"smallvec 1.0.0\",\n  \"syntax\",\n  \"tempfile\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n@@ -3723,6 +3728,7 @@ dependencies = [\n  \"smallvec 1.0.0\",\n  \"stable_deref_trait\",\n  \"syntax\",\n+ \"winapi 0.3.8\",\n ]\n \n [[package]]\n@@ -3948,6 +3954,17 @@ dependencies = [\n  \"syntax\",\n ]\n \n+[[package]]\n+name = \"rustc_ty\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log\",\n+ \"rustc\",\n+ \"rustc_data_structures\",\n+ \"rustc_hir\",\n+ \"rustc_span\",\n+]\n+\n [[package]]\n name = \"rustc_typeck\"\n version = \"0.0.0\"\n@@ -4948,6 +4965,16 @@ version = \"1.10.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"612d636f949607bdf9b123b4a6f6d966dedf3ff669f7f045890d3a4a73948169\"\n \n+[[package]]\n+name = \"ucd-parse\"\n+version = \"0.1.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ca6b52bf4da6512f0f07785a04769222e50d29639e7ecd016b7806fd2de306b4\"\n+dependencies = [\n+ \"lazy_static 1.3.0\",\n+ \"regex\",\n+]\n+\n [[package]]\n name = \"ucd-trie\"\n version = \"0.1.1\"\n@@ -4969,6 +4996,13 @@ dependencies = [\n  \"version_check 0.1.5\",\n ]\n \n+[[package]]\n+name = \"unicode-bdd\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"ucd-parse\",\n+]\n+\n [[package]]\n name = \"unicode-bidi\"\n version = \"0.3.4\""}, {"sha": "9d5c27b96df5d435daaded1ece44d1c8b6b613c1", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -23,6 +23,7 @@ members = [\n   \"src/tools/rustfmt\",\n   \"src/tools/miri\",\n   \"src/tools/rustdoc-themes\",\n+  \"src/tools/unicode-table-generator\",\n ]\n exclude = [\n   \"build\","}, {"sha": "c09f58cc591a69365e2004e8cfe0c298b3b52229", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -49,5 +49,9 @@ lazy_static = \"1.3.0\"\n time = \"0.1\"\n ignore = \"0.4.10\"\n \n+[target.'cfg(windows)'.dependencies.winapi]\n+version = \"0.3\"\n+features = [\"fileapi\", \"ioapiset\", \"jobapi2\", \"handleapi\", \"winioctl\"]\n+\n [dev-dependencies]\n pretty_assertions = \"0.5\""}, {"sha": "efeb86540b7b7215b2c0ce2182022a1514fbe3a4", "filename": "src/bootstrap/job.rs", "status": "modified", "additions": 10, "deletions": 78, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Fbootstrap%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Fbootstrap%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fjob.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -35,84 +35,16 @@ use std::io;\n use std::mem;\n use std::ptr;\n \n-type HANDLE = *mut u8;\n-type BOOL = i32;\n-type DWORD = u32;\n-type LPHANDLE = *mut HANDLE;\n-type LPVOID = *mut u8;\n-type JOBOBJECTINFOCLASS = i32;\n-type SIZE_T = usize;\n-type LARGE_INTEGER = i64;\n-type UINT = u32;\n-type ULONG_PTR = usize;\n-type ULONGLONG = u64;\n-\n-const FALSE: BOOL = 0;\n-const DUPLICATE_SAME_ACCESS: DWORD = 0x2;\n-const PROCESS_DUP_HANDLE: DWORD = 0x40;\n-const JobObjectExtendedLimitInformation: JOBOBJECTINFOCLASS = 9;\n-const JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE: DWORD = 0x2000;\n-const JOB_OBJECT_LIMIT_PRIORITY_CLASS: DWORD = 0x00000020;\n-const SEM_FAILCRITICALERRORS: UINT = 0x0001;\n-const SEM_NOGPFAULTERRORBOX: UINT = 0x0002;\n-const BELOW_NORMAL_PRIORITY_CLASS: DWORD = 0x00004000;\n-\n-extern \"system\" {\n-    fn CreateJobObjectW(lpJobAttributes: *mut u8, lpName: *const u8) -> HANDLE;\n-    fn CloseHandle(hObject: HANDLE) -> BOOL;\n-    fn GetCurrentProcess() -> HANDLE;\n-    fn OpenProcess(dwDesiredAccess: DWORD, bInheritHandle: BOOL, dwProcessId: DWORD) -> HANDLE;\n-    fn DuplicateHandle(\n-        hSourceProcessHandle: HANDLE,\n-        hSourceHandle: HANDLE,\n-        hTargetProcessHandle: HANDLE,\n-        lpTargetHandle: LPHANDLE,\n-        dwDesiredAccess: DWORD,\n-        bInheritHandle: BOOL,\n-        dwOptions: DWORD,\n-    ) -> BOOL;\n-    fn AssignProcessToJobObject(hJob: HANDLE, hProcess: HANDLE) -> BOOL;\n-    fn SetInformationJobObject(\n-        hJob: HANDLE,\n-        JobObjectInformationClass: JOBOBJECTINFOCLASS,\n-        lpJobObjectInformation: LPVOID,\n-        cbJobObjectInformationLength: DWORD,\n-    ) -> BOOL;\n-    fn SetErrorMode(mode: UINT) -> UINT;\n-}\n-\n-#[repr(C)]\n-struct JOBOBJECT_EXTENDED_LIMIT_INFORMATION {\n-    BasicLimitInformation: JOBOBJECT_BASIC_LIMIT_INFORMATION,\n-    IoInfo: IO_COUNTERS,\n-    ProcessMemoryLimit: SIZE_T,\n-    JobMemoryLimit: SIZE_T,\n-    PeakProcessMemoryUsed: SIZE_T,\n-    PeakJobMemoryUsed: SIZE_T,\n-}\n-\n-#[repr(C)]\n-struct IO_COUNTERS {\n-    ReadOperationCount: ULONGLONG,\n-    WriteOperationCount: ULONGLONG,\n-    OtherOperationCount: ULONGLONG,\n-    ReadTransferCount: ULONGLONG,\n-    WriteTransferCount: ULONGLONG,\n-    OtherTransferCount: ULONGLONG,\n-}\n-\n-#[repr(C)]\n-struct JOBOBJECT_BASIC_LIMIT_INFORMATION {\n-    PerProcessUserTimeLimit: LARGE_INTEGER,\n-    PerJobUserTimeLimit: LARGE_INTEGER,\n-    LimitFlags: DWORD,\n-    MinimumWorkingsetSize: SIZE_T,\n-    MaximumWorkingsetSize: SIZE_T,\n-    ActiveProcessLimit: DWORD,\n-    Affinity: ULONG_PTR,\n-    PriorityClass: DWORD,\n-    SchedulingClass: DWORD,\n-}\n+use winapi::shared::minwindef::{DWORD, FALSE, LPVOID};\n+use winapi::um::errhandlingapi::SetErrorMode;\n+use winapi::um::handleapi::{CloseHandle, DuplicateHandle};\n+use winapi::um::jobapi2::{AssignProcessToJobObject, CreateJobObjectW, SetInformationJobObject};\n+use winapi::um::processthreadsapi::{GetCurrentProcess, OpenProcess};\n+use winapi::um::winbase::{BELOW_NORMAL_PRIORITY_CLASS, SEM_NOGPFAULTERRORBOX};\n+use winapi::um::winnt::{\n+    JobObjectExtendedLimitInformation, DUPLICATE_SAME_ACCESS, JOBOBJECT_EXTENDED_LIMIT_INFORMATION,\n+    JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE, JOB_OBJECT_LIMIT_PRIORITY_CLASS, PROCESS_DUP_HANDLE,\n+};\n \n pub unsafe fn setup(build: &mut Build) {\n     // Enable the Windows Error Reporting dialog which msys disables,"}, {"sha": "89e1a7319cf59bb01cb00376fdc143044b167cc6", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -230,6 +230,8 @@ impl Step for Llvm {\n                 cfg.define(\"CMAKE_SYSTEM_NAME\", \"NetBSD\");\n             } else if target.contains(\"freebsd\") {\n                 cfg.define(\"CMAKE_SYSTEM_NAME\", \"FreeBSD\");\n+            } else if target.contains(\"windows\") {\n+                cfg.define(\"CMAKE_SYSTEM_NAME\", \"Windows\");\n             }\n \n             cfg.define(\"LLVM_NATIVE_BUILD\", builder.llvm_out(builder.config.build).join(\"build\"));"}, {"sha": "7d1efe4610f9ce1e2168e255af31205b59f704f0", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 13, "deletions": 49, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -123,37 +123,24 @@ pub fn symlink_dir(config: &Config, src: &Path, dest: &Path) -> io::Result<()> {\n     // what can be found here:\n     //\n     // http://www.flexhex.com/docs/articles/hard-links.phtml\n-    //\n-    // Copied from std\n     #[cfg(windows)]\n-    #[allow(nonstandard_style)]\n     fn symlink_dir_inner(target: &Path, junction: &Path) -> io::Result<()> {\n         use std::ffi::OsStr;\n         use std::os::windows::ffi::OsStrExt;\n         use std::ptr;\n \n-        const MAXIMUM_REPARSE_DATA_BUFFER_SIZE: usize = 16 * 1024;\n-        const GENERIC_WRITE: DWORD = 0x40000000;\n-        const OPEN_EXISTING: DWORD = 3;\n-        const FILE_FLAG_OPEN_REPARSE_POINT: DWORD = 0x00200000;\n-        const FILE_FLAG_BACKUP_SEMANTICS: DWORD = 0x02000000;\n-        const FSCTL_SET_REPARSE_POINT: DWORD = 0x900a4;\n-        const IO_REPARSE_TAG_MOUNT_POINT: DWORD = 0xa0000003;\n-        const FILE_SHARE_DELETE: DWORD = 0x4;\n-        const FILE_SHARE_READ: DWORD = 0x1;\n-        const FILE_SHARE_WRITE: DWORD = 0x2;\n-\n-        type BOOL = i32;\n-        type DWORD = u32;\n-        type HANDLE = *mut u8;\n-        type LPCWSTR = *const u16;\n-        type LPDWORD = *mut DWORD;\n-        type LPOVERLAPPED = *mut u8;\n-        type LPSECURITY_ATTRIBUTES = *mut u8;\n-        type LPVOID = *mut u8;\n-        type WCHAR = u16;\n-        type WORD = u16;\n-\n+        use winapi::shared::minwindef::{DWORD, WORD};\n+        use winapi::um::fileapi::{CreateFileW, OPEN_EXISTING};\n+        use winapi::um::handleapi::CloseHandle;\n+        use winapi::um::ioapiset::DeviceIoControl;\n+        use winapi::um::winbase::{FILE_FLAG_BACKUP_SEMANTICS, FILE_FLAG_OPEN_REPARSE_POINT};\n+        use winapi::um::winioctl::FSCTL_SET_REPARSE_POINT;\n+        use winapi::um::winnt::{\n+            FILE_SHARE_DELETE, FILE_SHARE_READ, FILE_SHARE_WRITE, GENERIC_WRITE,\n+            IO_REPARSE_TAG_MOUNT_POINT, MAXIMUM_REPARSE_DATA_BUFFER_SIZE, WCHAR,\n+        };\n+\n+        #[allow(non_snake_case)]\n         #[repr(C)]\n         struct REPARSE_MOUNTPOINT_DATA_BUFFER {\n             ReparseTag: DWORD,\n@@ -165,29 +152,6 @@ pub fn symlink_dir(config: &Config, src: &Path, dest: &Path) -> io::Result<()> {\n             ReparseTarget: WCHAR,\n         }\n \n-        extern \"system\" {\n-            fn CreateFileW(\n-                lpFileName: LPCWSTR,\n-                dwDesiredAccess: DWORD,\n-                dwShareMode: DWORD,\n-                lpSecurityAttributes: LPSECURITY_ATTRIBUTES,\n-                dwCreationDisposition: DWORD,\n-                dwFlagsAndAttributes: DWORD,\n-                hTemplateFile: HANDLE,\n-            ) -> HANDLE;\n-            fn DeviceIoControl(\n-                hDevice: HANDLE,\n-                dwIoControlCode: DWORD,\n-                lpInBuffer: LPVOID,\n-                nInBufferSize: DWORD,\n-                lpOutBuffer: LPVOID,\n-                nOutBufferSize: DWORD,\n-                lpBytesReturned: LPDWORD,\n-                lpOverlapped: LPOVERLAPPED,\n-            ) -> BOOL;\n-            fn CloseHandle(hObject: HANDLE) -> BOOL;\n-        }\n-\n         fn to_u16s<S: AsRef<OsStr>>(s: S) -> io::Result<Vec<u16>> {\n             Ok(s.as_ref().encode_wide().chain(Some(0)).collect())\n         }\n@@ -212,7 +176,7 @@ pub fn symlink_dir(config: &Config, src: &Path, dest: &Path) -> io::Result<()> {\n                 ptr::null_mut(),\n             );\n \n-            let mut data = [0u8; MAXIMUM_REPARSE_DATA_BUFFER_SIZE];\n+            let mut data = [0u8; MAXIMUM_REPARSE_DATA_BUFFER_SIZE as usize];\n             let db = data.as_mut_ptr() as *mut REPARSE_MOUNTPOINT_DATA_BUFFER;\n             let buf = &mut (*db).ReparseTarget as *mut u16;\n             let mut i = 0;"}, {"sha": "9da18d600ba2fad15bdfe299a85ee818544e8446", "filename": "src/ci/docker/dist-various-1/Dockerfile", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -2,11 +2,24 @@ FROM ubuntu:16.04\n \n RUN apt-get update && apt-get install -y --no-install-recommends \\\n   g++ \\\n+  automake \\\n+  bison \\\n+  bzip2 \\\n+  flex \\\n+  help2man \\\n+  libtool-bin \\\n+  texinfo \\\n+  unzip \\\n+  wget \\\n+  xz-utils \\\n+  libncurses-dev \\\n+  gawk \\\n   make \\\n   file \\\n   curl \\\n   ca-certificates \\\n   python2.7 \\\n+  python3 \\\n   git \\\n   cmake \\\n   sudo \\\n@@ -35,6 +48,18 @@ RUN add-apt-repository ppa:team-gcc-arm-embedded/ppa && \\\n     apt-get update && \\\n     apt-get install -y --no-install-recommends gcc-arm-embedded\n \n+COPY scripts/rustbuild-setup.sh dist-various-1/build-riscv-toolchain.sh dist-various-1/riscv64-unknown-linux-gnu.config dist-various-1/crosstool-ng.sh /build/\n+RUN ./crosstool-ng.sh\n+\n+# Crosstool-ng will refuse to build as root\n+RUN sh ./rustbuild-setup.sh\n+USER rustbuild\n+\n+RUN ./build-riscv-toolchain.sh\n+\n+USER root\n+ENV PATH=/x-tools/riscv64-unknown-linux-gnu/bin:$PATH\n+\n COPY dist-various-1/build-rumprun.sh /build\n RUN ./build-rumprun.sh\n \n@@ -129,6 +154,7 @@ ENV TARGETS=$TARGETS,riscv32imc-unknown-none-elf\n ENV TARGETS=$TARGETS,riscv32imac-unknown-none-elf\n ENV TARGETS=$TARGETS,riscv64imac-unknown-none-elf\n ENV TARGETS=$TARGETS,riscv64gc-unknown-none-elf\n+ENV TARGETS=$TARGETS,riscv64gc-unknown-linux-gnu\n ENV TARGETS=$TARGETS,armebv7r-none-eabi\n ENV TARGETS=$TARGETS,armebv7r-none-eabihf\n ENV TARGETS=$TARGETS,armv7r-none-eabi\n@@ -151,6 +177,9 @@ ENV CC_mipsel_unknown_linux_musl=mipsel-openwrt-linux-gcc \\\n     CXX_thumbv7neon_unknown_linux_gnueabihf=arm-linux-gnueabihf-g++ \\\n     CC_armv7a_none_eabi=arm-none-eabi-gcc \\\n     CC_armv7a_none_eabihf=arm-none-eabi-gcc \\\n+    CC_riscv64gc_unknown_linux_gnu=riscv64-unknown-linux-gnu-gcc \\\n+    AR_riscv64gc_unknown_linux_gnu=riscv64-unknown-linux-gnu-ar \\\n+    CXX_riscv64gc_unknown_linux_gnu=riscv64-unknown-linux-gnu-g++ \\\n     CC_riscv32i_unknown_none_elf=false \\\n     CC_riscv32imc_unknown_none_elf=false \\\n     CC_riscv32imac_unknown_none_elf=false \\"}, {"sha": "9cb5700b3b6fb1eb352863c3a81f7ce833207c3d", "filename": "src/ci/docker/dist-various-1/build-riscv-toolchain.sh", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Fci%2Fdocker%2Fdist-various-1%2Fbuild-riscv-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Fci%2Fdocker%2Fdist-various-1%2Fbuild-riscv-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2Fbuild-riscv-toolchain.sh?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -0,0 +1,27 @@\n+#!/usr/bin/env bash\n+\n+set -ex\n+\n+hide_output() {\n+  set +x\n+  on_err=\"\n+echo ERROR: An error was encountered with the build.\n+cat /tmp/build.log\n+exit 1\n+\"\n+  trap \"$on_err\" ERR\n+  bash -c \"while true; do sleep 30; echo \\$(date) - building ...; done\" &\n+  PING_LOOP_PID=$!\n+  $@ &> /tmp/build.log\n+  rm /tmp/build.log\n+  trap - ERR\n+  kill $PING_LOOP_PID\n+  set -x\n+}\n+\n+mkdir -p /tmp/build-riscv\n+cp riscv64-unknown-linux-gnu.config /tmp/build-riscv/.config\n+cd /tmp/build-riscv\n+hide_output ct-ng build\n+cd ..\n+rm -rf build-riscv"}, {"sha": "b01fdd0bf65e7f355dc1c28207ee3cf13f3f53a8", "filename": "src/ci/docker/dist-various-1/crosstool-ng.sh", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Fci%2Fdocker%2Fdist-various-1%2Fcrosstool-ng.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Fci%2Fdocker%2Fdist-various-1%2Fcrosstool-ng.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2Fcrosstool-ng.sh?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -0,0 +1,13 @@\n+#!/bin/bash\n+set -ex\n+\n+# Mirrored from https://github.com/crosstool-ng/crosstool-ng/archive/crosstool-ng-1.24.0.tar.gz\n+url=\"https://ci-mirrors.rust-lang.org/rustc/crosstool-ng-1.24.0.tar.gz\"\n+curl -Lf $url | tar xzf -\n+cd crosstool-ng-crosstool-ng-1.24.0\n+./bootstrap\n+./configure --prefix=/usr/local\n+make -j$(nproc)\n+make install\n+cd ..\n+rm -rf crosstool-ng-crosstool-ng-1.24.0"}, {"sha": "dd06065b19740a2456d9ebcaf759d483075f4672", "filename": "src/ci/docker/dist-various-1/riscv64-unknown-linux-gnu.config", "status": "added", "additions": 908, "deletions": 0, "changes": 908, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Fci%2Fdocker%2Fdist-various-1%2Friscv64-unknown-linux-gnu.config", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Fci%2Fdocker%2Fdist-various-1%2Friscv64-unknown-linux-gnu.config", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2Friscv64-unknown-linux-gnu.config?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -0,0 +1,908 @@\n+#\n+# Automatically generated file; DO NOT EDIT.\n+# crosstool-NG  Configuration\n+#\n+CT_CONFIGURE_has_static_link=y\n+CT_CONFIGURE_has_cxx11=y\n+CT_CONFIGURE_has_wget=y\n+CT_CONFIGURE_has_curl=y\n+CT_CONFIGURE_has_make_3_81_or_newer=y\n+CT_CONFIGURE_has_make_4_0_or_newer=y\n+CT_CONFIGURE_has_libtool_2_4_or_newer=y\n+CT_CONFIGURE_has_libtoolize_2_4_or_newer=y\n+CT_CONFIGURE_has_autoconf_2_65_or_newer=y\n+CT_CONFIGURE_has_autoreconf_2_65_or_newer=y\n+CT_CONFIGURE_has_automake_1_15_or_newer=y\n+CT_CONFIGURE_has_gnu_m4_1_4_12_or_newer=y\n+CT_CONFIGURE_has_python_3_4_or_newer=y\n+CT_CONFIGURE_has_bison_2_7_or_newer=y\n+CT_CONFIGURE_has_python=y\n+CT_CONFIGURE_has_dtc=y\n+CT_CONFIGURE_has_svn=y\n+CT_CONFIGURE_has_git=y\n+CT_CONFIGURE_has_md5sum=y\n+CT_CONFIGURE_has_sha1sum=y\n+CT_CONFIGURE_has_sha256sum=y\n+CT_CONFIGURE_has_sha512sum=y\n+CT_CONFIGURE_has_install_with_strip_program=y\n+CT_CONFIG_VERSION_CURRENT=\"3\"\n+CT_CONFIG_VERSION=\"3\"\n+CT_MODULES=y\n+\n+#\n+# Paths and misc options\n+#\n+\n+#\n+# crosstool-NG behavior\n+#\n+# CT_OBSOLETE is not set\n+CT_EXPERIMENTAL=y\n+# CT_ALLOW_BUILD_AS_ROOT is not set\n+# CT_DEBUG_CT is not set\n+\n+#\n+# Paths\n+#\n+CT_LOCAL_TARBALLS_DIR=\"${HOME}/src\"\n+CT_SAVE_TARBALLS=y\n+# CT_TARBALLS_BUILDROOT_LAYOUT is not set\n+CT_WORK_DIR=\"${CT_TOP_DIR}/.build\"\n+CT_BUILD_TOP_DIR=\"${CT_WORK_DIR:-${CT_TOP_DIR}/.build}/${CT_HOST:+HOST-${CT_HOST}/}${CT_TARGET}\"\n+CT_PREFIX_DIR=\"/x-tools/${CT_TARGET}\"\n+CT_RM_RF_PREFIX_DIR=y\n+CT_REMOVE_DOCS=y\n+CT_INSTALL_LICENSES=y\n+CT_PREFIX_DIR_RO=y\n+CT_STRIP_HOST_TOOLCHAIN_EXECUTABLES=y\n+# CT_STRIP_TARGET_TOOLCHAIN_EXECUTABLES is not set\n+\n+#\n+# Downloading\n+#\n+CT_DOWNLOAD_AGENT_WGET=y\n+# CT_DOWNLOAD_AGENT_CURL is not set\n+# CT_DOWNLOAD_AGENT_NONE is not set\n+# CT_FORBID_DOWNLOAD is not set\n+# CT_FORCE_DOWNLOAD is not set\n+CT_CONNECT_TIMEOUT=10\n+CT_DOWNLOAD_WGET_OPTIONS=\"--passive-ftp --tries=3 -nc --progress=dot:binary\"\n+# CT_ONLY_DOWNLOAD is not set\n+# CT_USE_MIRROR is not set\n+CT_VERIFY_DOWNLOAD_DIGEST=y\n+CT_VERIFY_DOWNLOAD_DIGEST_SHA512=y\n+# CT_VERIFY_DOWNLOAD_DIGEST_SHA256 is not set\n+# CT_VERIFY_DOWNLOAD_DIGEST_SHA1 is not set\n+# CT_VERIFY_DOWNLOAD_DIGEST_MD5 is not set\n+CT_VERIFY_DOWNLOAD_DIGEST_ALG=\"sha512\"\n+# CT_VERIFY_DOWNLOAD_SIGNATURE is not set\n+\n+#\n+# Extracting\n+#\n+# CT_FORCE_EXTRACT is not set\n+CT_OVERRIDE_CONFIG_GUESS_SUB=y\n+# CT_ONLY_EXTRACT is not set\n+CT_PATCH_BUNDLED=y\n+# CT_PATCH_LOCAL is not set\n+# CT_PATCH_BUNDLED_LOCAL is not set\n+# CT_PATCH_LOCAL_BUNDLED is not set\n+# CT_PATCH_NONE is not set\n+CT_PATCH_ORDER=\"bundled\"\n+\n+#\n+# Build behavior\n+#\n+CT_PARALLEL_JOBS=0\n+CT_LOAD=\"\"\n+CT_USE_PIPES=y\n+CT_EXTRA_CFLAGS_FOR_BUILD=\"\"\n+CT_EXTRA_LDFLAGS_FOR_BUILD=\"\"\n+CT_EXTRA_CFLAGS_FOR_HOST=\"\"\n+CT_EXTRA_LDFLAGS_FOR_HOST=\"\"\n+# CT_CONFIG_SHELL_SH is not set\n+# CT_CONFIG_SHELL_ASH is not set\n+CT_CONFIG_SHELL_BASH=y\n+# CT_CONFIG_SHELL_CUSTOM is not set\n+CT_CONFIG_SHELL=\"${bash}\"\n+\n+#\n+# Logging\n+#\n+# CT_LOG_ERROR is not set\n+# CT_LOG_WARN is not set\n+# CT_LOG_INFO is not set\n+# CT_LOG_EXTRA is not set\n+CT_LOG_ALL=y\n+# CT_LOG_DEBUG is not set\n+CT_LOG_LEVEL_MAX=\"ALL\"\n+# CT_LOG_SEE_TOOLS_WARN is not set\n+CT_LOG_TO_FILE=y\n+CT_LOG_FILE_COMPRESS=y\n+\n+#\n+# Target options\n+#\n+# CT_ARCH_ALPHA is not set\n+# CT_ARCH_ARC is not set\n+# CT_ARCH_ARM is not set\n+# CT_ARCH_AVR is not set\n+# CT_ARCH_M68K is not set\n+# CT_ARCH_MICROBLAZE is not set\n+# CT_ARCH_MIPS is not set\n+# CT_ARCH_MOXIE is not set\n+# CT_ARCH_MSP430 is not set\n+# CT_ARCH_NIOS2 is not set\n+# CT_ARCH_POWERPC is not set\n+CT_ARCH_RISCV=y\n+# CT_ARCH_S390 is not set\n+# CT_ARCH_SH is not set\n+# CT_ARCH_SPARC is not set\n+# CT_ARCH_X86 is not set\n+# CT_ARCH_XTENSA is not set\n+CT_ARCH=\"riscv\"\n+CT_ARCH_CHOICE_KSYM=\"RISCV\"\n+CT_ARCH_TUNE=\"\"\n+CT_ARCH_RISCV_SHOW=y\n+\n+#\n+# Options for riscv\n+#\n+CT_ARCH_RISCV_PKG_KSYM=\"\"\n+CT_ALL_ARCH_CHOICES=\"ALPHA ARC ARM AVR M68K MICROBLAZE MIPS MOXIE MSP430 NIOS2 POWERPC RISCV S390 SH SPARC X86 XTENSA\"\n+CT_ARCH_SUFFIX=\"\"\n+# CT_OMIT_TARGET_VENDOR is not set\n+\n+#\n+# Generic target options\n+#\n+# CT_MULTILIB is not set\n+# CT_DEMULTILIB is not set\n+CT_ARCH_SUPPORTS_BOTH_MMU=y\n+CT_ARCH_USE_MMU=y\n+CT_ARCH_SUPPORTS_32=y\n+CT_ARCH_SUPPORTS_64=y\n+CT_ARCH_DEFAULT_32=y\n+CT_ARCH_BITNESS=64\n+# CT_ARCH_32 is not set\n+CT_ARCH_64=y\n+\n+#\n+# Target optimisations\n+#\n+CT_ARCH_SUPPORTS_WITH_ARCH=y\n+CT_ARCH_SUPPORTS_WITH_ABI=y\n+CT_ARCH_SUPPORTS_WITH_TUNE=y\n+CT_ARCH_ARCH=\"rv64gc\"\n+CT_ARCH_ABI=\"\"\n+CT_TARGET_CFLAGS=\"\"\n+CT_TARGET_LDFLAGS=\"\"\n+\n+#\n+# Toolchain options\n+#\n+\n+#\n+# General toolchain options\n+#\n+CT_FORCE_SYSROOT=y\n+CT_USE_SYSROOT=y\n+CT_SYSROOT_NAME=\"sysroot\"\n+CT_SYSROOT_DIR_PREFIX=\"\"\n+CT_WANTS_STATIC_LINK=y\n+CT_WANTS_STATIC_LINK_CXX=y\n+# CT_STATIC_TOOLCHAIN is not set\n+CT_SHOW_CT_VERSION=y\n+CT_TOOLCHAIN_PKGVERSION=\"\"\n+CT_TOOLCHAIN_BUGURL=\"\"\n+\n+#\n+# Tuple completion and aliasing\n+#\n+CT_TARGET_VENDOR=\"unknown\"\n+CT_TARGET_ALIAS_SED_EXPR=\"\"\n+CT_TARGET_ALIAS=\"\"\n+\n+#\n+# Toolchain type\n+#\n+# CT_NATIVE is not set\n+CT_CROSS=y\n+# CT_CROSS_NATIVE is not set\n+# CT_CANADIAN is not set\n+CT_TOOLCHAIN_TYPE=\"cross\"\n+\n+#\n+# Build system\n+#\n+CT_BUILD=\"\"\n+CT_BUILD_PREFIX=\"\"\n+CT_BUILD_SUFFIX=\"\"\n+\n+#\n+# Misc options\n+#\n+# CT_TOOLCHAIN_ENABLE_NLS is not set\n+\n+#\n+# Operating System\n+#\n+CT_KERNEL_SUPPORTS_SHARED_LIBS=y\n+# CT_KERNEL_BARE_METAL is not set\n+CT_KERNEL_LINUX=y\n+CT_KERNEL=\"linux\"\n+CT_KERNEL_CHOICE_KSYM=\"LINUX\"\n+CT_KERNEL_LINUX_SHOW=y\n+\n+#\n+# Options for linux\n+#\n+CT_KERNEL_LINUX_PKG_KSYM=\"LINUX\"\n+CT_LINUX_DIR_NAME=\"linux\"\n+CT_LINUX_PKG_NAME=\"linux\"\n+CT_LINUX_SRC_RELEASE=y\n+# CT_LINUX_SRC_DEVEL is not set\n+# CT_LINUX_SRC_CUSTOM is not set\n+CT_LINUX_PATCH_GLOBAL=y\n+# CT_LINUX_PATCH_BUNDLED is not set\n+# CT_LINUX_PATCH_LOCAL is not set\n+# CT_LINUX_PATCH_BUNDLED_LOCAL is not set\n+# CT_LINUX_PATCH_LOCAL_BUNDLED is not set\n+# CT_LINUX_PATCH_NONE is not set\n+CT_LINUX_PATCH_ORDER=\"global\"\n+CT_LINUX_V_4_20=y\n+# CT_LINUX_V_4_19 is not set\n+# CT_LINUX_V_4_18 is not set\n+# CT_LINUX_V_4_17 is not set\n+# CT_LINUX_V_4_16 is not set\n+# CT_LINUX_V_4_15 is not set\n+# CT_LINUX_V_4_14 is not set\n+# CT_LINUX_V_4_13 is not set\n+# CT_LINUX_V_4_12 is not set\n+# CT_LINUX_V_4_11 is not set\n+# CT_LINUX_V_4_10 is not set\n+# CT_LINUX_V_4_9 is not set\n+# CT_LINUX_V_4_4 is not set\n+# CT_LINUX_V_4_1 is not set\n+# CT_LINUX_V_3_16 is not set\n+# CT_LINUX_V_3_13 is not set\n+# CT_LINUX_V_3_12 is not set\n+# CT_LINUX_V_3_10 is not set\n+# CT_LINUX_V_3_4 is not set\n+# CT_LINUX_V_3_2 is not set\n+# CT_LINUX_NO_VERSIONS is not set\n+CT_LINUX_VERSION=\"4.20.8\"\n+CT_LINUX_MIRRORS=\"$(CT_Mirrors kernel.org linux ${CT_LINUX_VERSION})\"\n+CT_LINUX_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_LINUX_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_LINUX_ARCHIVE_FORMATS=\".tar.xz .tar.gz\"\n+CT_LINUX_SIGNATURE_FORMAT=\"unpacked/.sign\"\n+CT_LINUX_later_than_4_8=y\n+CT_LINUX_4_8_or_later=y\n+CT_LINUX_later_than_3_7=y\n+CT_LINUX_3_7_or_later=y\n+CT_LINUX_later_than_3_2=y\n+CT_LINUX_3_2_or_later=y\n+CT_LINUX_REQUIRE_3_2_or_later=y\n+CT_KERNEL_LINUX_VERBOSITY_0=y\n+# CT_KERNEL_LINUX_VERBOSITY_1 is not set\n+# CT_KERNEL_LINUX_VERBOSITY_2 is not set\n+CT_KERNEL_LINUX_VERBOSE_LEVEL=0\n+CT_KERNEL_LINUX_INSTALL_CHECK=y\n+CT_ALL_KERNEL_CHOICES=\"BARE_METAL LINUX WINDOWS\"\n+\n+#\n+# Common kernel options\n+#\n+CT_SHARED_LIBS=y\n+\n+#\n+# Binary utilities\n+#\n+CT_ARCH_BINFMT_ELF=y\n+CT_BINUTILS_BINUTILS=y\n+CT_BINUTILS=\"binutils\"\n+CT_BINUTILS_CHOICE_KSYM=\"BINUTILS\"\n+CT_BINUTILS_BINUTILS_SHOW=y\n+\n+#\n+# Options for binutils\n+#\n+CT_BINUTILS_BINUTILS_PKG_KSYM=\"BINUTILS\"\n+CT_BINUTILS_DIR_NAME=\"binutils\"\n+CT_BINUTILS_USE_GNU=y\n+CT_BINUTILS_USE=\"BINUTILS\"\n+CT_BINUTILS_PKG_NAME=\"binutils\"\n+CT_BINUTILS_SRC_RELEASE=y\n+# CT_BINUTILS_SRC_DEVEL is not set\n+# CT_BINUTILS_SRC_CUSTOM is not set\n+CT_BINUTILS_PATCH_GLOBAL=y\n+# CT_BINUTILS_PATCH_BUNDLED is not set\n+# CT_BINUTILS_PATCH_LOCAL is not set\n+# CT_BINUTILS_PATCH_BUNDLED_LOCAL is not set\n+# CT_BINUTILS_PATCH_LOCAL_BUNDLED is not set\n+# CT_BINUTILS_PATCH_NONE is not set\n+CT_BINUTILS_PATCH_ORDER=\"global\"\n+CT_BINUTILS_V_2_32=y\n+# CT_BINUTILS_V_2_31 is not set\n+# CT_BINUTILS_V_2_30 is not set\n+# CT_BINUTILS_V_2_29 is not set\n+# CT_BINUTILS_V_2_28 is not set\n+# CT_BINUTILS_V_2_27 is not set\n+# CT_BINUTILS_V_2_26 is not set\n+# CT_BINUTILS_NO_VERSIONS is not set\n+CT_BINUTILS_VERSION=\"2.32\"\n+CT_BINUTILS_MIRRORS=\"$(CT_Mirrors GNU binutils) $(CT_Mirrors sourceware binutils/releases)\"\n+CT_BINUTILS_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_BINUTILS_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_BINUTILS_ARCHIVE_FORMATS=\".tar.xz .tar.bz2 .tar.gz\"\n+CT_BINUTILS_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_BINUTILS_later_than_2_30=y\n+CT_BINUTILS_2_30_or_later=y\n+CT_BINUTILS_later_than_2_27=y\n+CT_BINUTILS_2_27_or_later=y\n+CT_BINUTILS_later_than_2_25=y\n+CT_BINUTILS_2_25_or_later=y\n+CT_BINUTILS_REQUIRE_2_25_or_later=y\n+CT_BINUTILS_later_than_2_23=y\n+CT_BINUTILS_2_23_or_later=y\n+\n+#\n+# GNU binutils\n+#\n+CT_BINUTILS_HAS_HASH_STYLE=y\n+CT_BINUTILS_HAS_GOLD=y\n+CT_BINUTILS_HAS_PLUGINS=y\n+CT_BINUTILS_HAS_PKGVERSION_BUGURL=y\n+CT_BINUTILS_FORCE_LD_BFD_DEFAULT=y\n+CT_BINUTILS_LINKER_LD=y\n+CT_BINUTILS_LINKERS_LIST=\"ld\"\n+CT_BINUTILS_LINKER_DEFAULT=\"bfd\"\n+# CT_BINUTILS_PLUGINS is not set\n+CT_BINUTILS_RELRO=m\n+CT_BINUTILS_EXTRA_CONFIG_ARRAY=\"\"\n+# CT_BINUTILS_FOR_TARGET is not set\n+CT_ALL_BINUTILS_CHOICES=\"BINUTILS\"\n+\n+#\n+# C-library\n+#\n+CT_LIBC_GLIBC=y\n+# CT_LIBC_MUSL is not set\n+# CT_LIBC_UCLIBC is not set\n+CT_LIBC=\"glibc\"\n+CT_LIBC_CHOICE_KSYM=\"GLIBC\"\n+CT_THREADS=\"nptl\"\n+CT_LIBC_GLIBC_SHOW=y\n+\n+#\n+# Options for glibc\n+#\n+CT_LIBC_GLIBC_PKG_KSYM=\"GLIBC\"\n+CT_GLIBC_DIR_NAME=\"glibc\"\n+CT_GLIBC_USE_GNU=y\n+CT_GLIBC_USE=\"GLIBC\"\n+CT_GLIBC_PKG_NAME=\"glibc\"\n+CT_GLIBC_SRC_RELEASE=y\n+# CT_GLIBC_SRC_DEVEL is not set\n+# CT_GLIBC_SRC_CUSTOM is not set\n+CT_GLIBC_PATCH_GLOBAL=y\n+# CT_GLIBC_PATCH_BUNDLED is not set\n+# CT_GLIBC_PATCH_LOCAL is not set\n+# CT_GLIBC_PATCH_BUNDLED_LOCAL is not set\n+# CT_GLIBC_PATCH_LOCAL_BUNDLED is not set\n+# CT_GLIBC_PATCH_NONE is not set\n+CT_GLIBC_PATCH_ORDER=\"global\"\n+CT_GLIBC_V_2_29=y\n+# CT_GLIBC_NO_VERSIONS is not set\n+CT_GLIBC_VERSION=\"2.29\"\n+CT_GLIBC_MIRRORS=\"$(CT_Mirrors GNU glibc)\"\n+CT_GLIBC_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_GLIBC_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_GLIBC_ARCHIVE_FORMATS=\".tar.xz .tar.bz2 .tar.gz\"\n+CT_GLIBC_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_GLIBC_2_29_or_later=y\n+CT_GLIBC_2_29_or_older=y\n+CT_GLIBC_REQUIRE_2_29_or_later=y\n+CT_GLIBC_later_than_2_27=y\n+CT_GLIBC_2_27_or_later=y\n+CT_GLIBC_later_than_2_26=y\n+CT_GLIBC_2_26_or_later=y\n+CT_GLIBC_later_than_2_25=y\n+CT_GLIBC_2_25_or_later=y\n+CT_GLIBC_later_than_2_24=y\n+CT_GLIBC_2_24_or_later=y\n+CT_GLIBC_later_than_2_23=y\n+CT_GLIBC_2_23_or_later=y\n+CT_GLIBC_later_than_2_20=y\n+CT_GLIBC_2_20_or_later=y\n+CT_GLIBC_later_than_2_17=y\n+CT_GLIBC_2_17_or_later=y\n+CT_GLIBC_later_than_2_14=y\n+CT_GLIBC_2_14_or_later=y\n+CT_GLIBC_DEP_KERNEL_HEADERS_VERSION=y\n+CT_GLIBC_DEP_BINUTILS=y\n+CT_GLIBC_DEP_GCC=y\n+CT_GLIBC_DEP_PYTHON=y\n+CT_GLIBC_BUILD_SSP=y\n+CT_GLIBC_HAS_LIBIDN_ADDON=y\n+# CT_GLIBC_USE_LIBIDN_ADDON is not set\n+CT_GLIBC_NO_SPARC_V8=y\n+CT_GLIBC_HAS_OBSOLETE_RPC=y\n+CT_GLIBC_EXTRA_CONFIG_ARRAY=\"\"\n+CT_GLIBC_CONFIGPARMS=\"\"\n+CT_GLIBC_EXTRA_CFLAGS=\"\"\n+CT_GLIBC_ENABLE_OBSOLETE_RPC=y\n+# CT_GLIBC_ENABLE_FORTIFIED_BUILD is not set\n+# CT_GLIBC_DISABLE_VERSIONING is not set\n+CT_GLIBC_OLDEST_ABI=\"\"\n+CT_GLIBC_FORCE_UNWIND=y\n+# CT_GLIBC_LOCALES is not set\n+CT_GLIBC_KERNEL_VERSION_NONE=y\n+# CT_GLIBC_KERNEL_VERSION_AS_HEADERS is not set\n+# CT_GLIBC_KERNEL_VERSION_CHOSEN is not set\n+CT_GLIBC_MIN_KERNEL=\"\"\n+CT_GLIBC_SSP_DEFAULT=y\n+# CT_GLIBC_SSP_NO is not set\n+# CT_GLIBC_SSP_YES is not set\n+# CT_GLIBC_SSP_ALL is not set\n+# CT_GLIBC_SSP_STRONG is not set\n+# CT_GLIBC_ENABLE_WERROR is not set\n+CT_ALL_LIBC_CHOICES=\"AVR_LIBC BIONIC GLIBC MINGW_W64 MOXIEBOX MUSL NEWLIB NONE UCLIBC\"\n+CT_LIBC_SUPPORT_THREADS_ANY=y\n+CT_LIBC_SUPPORT_THREADS_NATIVE=y\n+\n+#\n+# Common C library options\n+#\n+CT_THREADS_NATIVE=y\n+# CT_CREATE_LDSO_CONF is not set\n+CT_LIBC_XLDD=y\n+\n+#\n+# C compiler\n+#\n+CT_CC_CORE_PASSES_NEEDED=y\n+CT_CC_CORE_PASS_1_NEEDED=y\n+CT_CC_CORE_PASS_2_NEEDED=y\n+CT_CC_SUPPORT_CXX=y\n+CT_CC_SUPPORT_FORTRAN=y\n+CT_CC_SUPPORT_ADA=y\n+CT_CC_SUPPORT_OBJC=y\n+CT_CC_SUPPORT_OBJCXX=y\n+CT_CC_SUPPORT_GOLANG=y\n+CT_CC_GCC=y\n+CT_CC=\"gcc\"\n+CT_CC_CHOICE_KSYM=\"GCC\"\n+CT_CC_GCC_SHOW=y\n+\n+#\n+# Options for gcc\n+#\n+CT_CC_GCC_PKG_KSYM=\"GCC\"\n+CT_GCC_DIR_NAME=\"gcc\"\n+CT_GCC_USE_GNU=y\n+# CT_GCC_USE_LINARO is not set\n+CT_GCC_USE=\"GCC\"\n+CT_GCC_PKG_NAME=\"gcc\"\n+CT_GCC_SRC_RELEASE=y\n+# CT_GCC_SRC_DEVEL is not set\n+# CT_GCC_SRC_CUSTOM is not set\n+CT_GCC_PATCH_GLOBAL=y\n+# CT_GCC_PATCH_BUNDLED is not set\n+# CT_GCC_PATCH_LOCAL is not set\n+# CT_GCC_PATCH_BUNDLED_LOCAL is not set\n+# CT_GCC_PATCH_LOCAL_BUNDLED is not set\n+# CT_GCC_PATCH_NONE is not set\n+CT_GCC_PATCH_ORDER=\"global\"\n+CT_GCC_V_8=y\n+# CT_GCC_V_7 is not set\n+# CT_GCC_NO_VERSIONS is not set\n+CT_GCC_VERSION=\"8.3.0\"\n+CT_GCC_MIRRORS=\"$(CT_Mirrors GNU gcc/gcc-${CT_GCC_VERSION}) $(CT_Mirrors sourceware gcc/releases/gcc-${CT_GCC_VERSION})\"\n+CT_GCC_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_GCC_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_GCC_ARCHIVE_FORMATS=\".tar.xz .tar.gz\"\n+CT_GCC_SIGNATURE_FORMAT=\"\"\n+CT_GCC_later_than_7=y\n+CT_GCC_7_or_later=y\n+CT_GCC_REQUIRE_7_or_later=y\n+CT_GCC_later_than_6=y\n+CT_GCC_6_or_later=y\n+CT_GCC_later_than_5=y\n+CT_GCC_5_or_later=y\n+CT_GCC_REQUIRE_5_or_later=y\n+CT_GCC_later_than_4_9=y\n+CT_GCC_4_9_or_later=y\n+CT_GCC_REQUIRE_4_9_or_later=y\n+CT_GCC_later_than_4_8=y\n+CT_GCC_4_8_or_later=y\n+CT_CC_GCC_HAS_LIBMPX=y\n+CT_CC_GCC_ENABLE_CXX_FLAGS=\"\"\n+CT_CC_GCC_CORE_EXTRA_CONFIG_ARRAY=\"\"\n+CT_CC_GCC_EXTRA_CONFIG_ARRAY=\"\"\n+CT_CC_GCC_STATIC_LIBSTDCXX=y\n+# CT_CC_GCC_SYSTEM_ZLIB is not set\n+CT_CC_GCC_CONFIG_TLS=m\n+\n+#\n+# Optimisation features\n+#\n+CT_CC_GCC_USE_GRAPHITE=y\n+CT_CC_GCC_USE_LTO=y\n+\n+#\n+# Settings for libraries running on target\n+#\n+CT_CC_GCC_ENABLE_TARGET_OPTSPACE=y\n+# CT_CC_GCC_LIBMUDFLAP is not set\n+# CT_CC_GCC_LIBGOMP is not set\n+# CT_CC_GCC_LIBSSP is not set\n+# CT_CC_GCC_LIBQUADMATH is not set\n+# CT_CC_GCC_LIBSANITIZER is not set\n+\n+#\n+# Misc. obscure options.\n+#\n+CT_CC_CXA_ATEXIT=y\n+# CT_CC_GCC_DISABLE_PCH is not set\n+CT_CC_GCC_SJLJ_EXCEPTIONS=m\n+CT_CC_GCC_LDBL_128=m\n+# CT_CC_GCC_BUILD_ID is not set\n+CT_CC_GCC_LNK_HASH_STYLE_DEFAULT=y\n+# CT_CC_GCC_LNK_HASH_STYLE_SYSV is not set\n+# CT_CC_GCC_LNK_HASH_STYLE_GNU is not set\n+# CT_CC_GCC_LNK_HASH_STYLE_BOTH is not set\n+CT_CC_GCC_LNK_HASH_STYLE=\"\"\n+CT_CC_GCC_DEC_FLOAT_AUTO=y\n+# CT_CC_GCC_DEC_FLOAT_BID is not set\n+# CT_CC_GCC_DEC_FLOAT_DPD is not set\n+# CT_CC_GCC_DEC_FLOATS_NO is not set\n+CT_ALL_CC_CHOICES=\"GCC\"\n+\n+#\n+# Additional supported languages:\n+#\n+CT_CC_LANG_CXX=y\n+# CT_CC_LANG_FORTRAN is not set\n+# CT_CC_LANG_ADA is not set\n+# CT_CC_LANG_OBJC is not set\n+# CT_CC_LANG_OBJCXX is not set\n+# CT_CC_LANG_GOLANG is not set\n+CT_CC_LANG_OTHERS=\"\"\n+\n+#\n+# Debug facilities\n+#\n+# CT_DEBUG_DUMA is not set\n+CT_DEBUG_GDB=y\n+CT_DEBUG_GDB_PKG_KSYM=\"GDB\"\n+CT_GDB_DIR_NAME=\"gdb\"\n+CT_GDB_USE_GNU=y\n+CT_GDB_USE=\"GDB\"\n+CT_GDB_PKG_NAME=\"gdb\"\n+CT_GDB_SRC_RELEASE=y\n+# CT_GDB_SRC_DEVEL is not set\n+# CT_GDB_SRC_CUSTOM is not set\n+CT_GDB_PATCH_GLOBAL=y\n+# CT_GDB_PATCH_BUNDLED is not set\n+# CT_GDB_PATCH_LOCAL is not set\n+# CT_GDB_PATCH_BUNDLED_LOCAL is not set\n+# CT_GDB_PATCH_LOCAL_BUNDLED is not set\n+# CT_GDB_PATCH_NONE is not set\n+CT_GDB_PATCH_ORDER=\"global\"\n+CT_GDB_V_8_2=y\n+# CT_GDB_V_8_1 is not set\n+# CT_GDB_V_8_0 is not set\n+# CT_GDB_NO_VERSIONS is not set\n+CT_GDB_VERSION=\"8.2.1\"\n+CT_GDB_MIRRORS=\"$(CT_Mirrors GNU gdb) $(CT_Mirrors sourceware gdb/releases)\"\n+CT_GDB_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_GDB_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_GDB_ARCHIVE_FORMATS=\".tar.xz .tar.gz\"\n+CT_GDB_SIGNATURE_FORMAT=\"\"\n+CT_GDB_later_than_8_0=y\n+CT_GDB_8_0_or_later=y\n+CT_GDB_REQUIRE_8_0_or_later=y\n+CT_GDB_later_than_7_12=y\n+CT_GDB_7_12_or_later=y\n+CT_GDB_later_than_7_2=y\n+CT_GDB_7_2_or_later=y\n+CT_GDB_later_than_7_0=y\n+CT_GDB_7_0_or_later=y\n+CT_GDB_CROSS=y\n+# CT_GDB_CROSS_STATIC is not set\n+# CT_GDB_CROSS_SIM is not set\n+# CT_GDB_CROSS_PYTHON is not set\n+CT_GDB_CROSS_EXTRA_CONFIG_ARRAY=\"\"\n+# CT_GDB_NATIVE is not set\n+# CT_GDB_GDBSERVER is not set\n+CT_GDB_HAS_PKGVERSION_BUGURL=y\n+CT_GDB_HAS_PYTHON=y\n+CT_GDB_INSTALL_GDBINIT=y\n+CT_GDB_HAS_IPA_LIB=y\n+# CT_DEBUG_LTRACE is not set\n+# CT_DEBUG_STRACE is not set\n+CT_ALL_DEBUG_CHOICES=\"DUMA GDB LTRACE STRACE\"\n+\n+#\n+# Companion libraries\n+#\n+# CT_COMPLIBS_CHECK is not set\n+# CT_COMP_LIBS_CLOOG is not set\n+CT_COMP_LIBS_EXPAT=y\n+CT_COMP_LIBS_EXPAT_PKG_KSYM=\"EXPAT\"\n+CT_EXPAT_DIR_NAME=\"expat\"\n+CT_EXPAT_PKG_NAME=\"expat\"\n+CT_EXPAT_SRC_RELEASE=y\n+# CT_EXPAT_SRC_DEVEL is not set\n+# CT_EXPAT_SRC_CUSTOM is not set\n+CT_EXPAT_PATCH_GLOBAL=y\n+# CT_EXPAT_PATCH_BUNDLED is not set\n+# CT_EXPAT_PATCH_LOCAL is not set\n+# CT_EXPAT_PATCH_BUNDLED_LOCAL is not set\n+# CT_EXPAT_PATCH_LOCAL_BUNDLED is not set\n+# CT_EXPAT_PATCH_NONE is not set\n+CT_EXPAT_PATCH_ORDER=\"global\"\n+CT_EXPAT_V_2_2=y\n+# CT_EXPAT_NO_VERSIONS is not set\n+CT_EXPAT_VERSION=\"2.2.6\"\n+CT_EXPAT_MIRRORS=\"http://downloads.sourceforge.net/project/expat/expat/${CT_EXPAT_VERSION}\"\n+CT_EXPAT_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_EXPAT_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_EXPAT_ARCHIVE_FORMATS=\".tar.bz2\"\n+CT_EXPAT_SIGNATURE_FORMAT=\"\"\n+CT_COMP_LIBS_GETTEXT=y\n+CT_COMP_LIBS_GETTEXT_PKG_KSYM=\"GETTEXT\"\n+CT_GETTEXT_DIR_NAME=\"gettext\"\n+CT_GETTEXT_PKG_NAME=\"gettext\"\n+CT_GETTEXT_SRC_RELEASE=y\n+# CT_GETTEXT_SRC_DEVEL is not set\n+# CT_GETTEXT_SRC_CUSTOM is not set\n+CT_GETTEXT_PATCH_GLOBAL=y\n+# CT_GETTEXT_PATCH_BUNDLED is not set\n+# CT_GETTEXT_PATCH_LOCAL is not set\n+# CT_GETTEXT_PATCH_BUNDLED_LOCAL is not set\n+# CT_GETTEXT_PATCH_LOCAL_BUNDLED is not set\n+# CT_GETTEXT_PATCH_NONE is not set\n+CT_GETTEXT_PATCH_ORDER=\"global\"\n+CT_GETTEXT_V_0_19_8_1=y\n+# CT_GETTEXT_NO_VERSIONS is not set\n+CT_GETTEXT_VERSION=\"0.19.8.1\"\n+CT_GETTEXT_MIRRORS=\"$(CT_Mirrors GNU gettext)\"\n+CT_GETTEXT_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_GETTEXT_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_GETTEXT_ARCHIVE_FORMATS=\".tar.xz .tar.lz .tar.gz\"\n+CT_GETTEXT_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_COMP_LIBS_GMP=y\n+CT_COMP_LIBS_GMP_PKG_KSYM=\"GMP\"\n+CT_GMP_DIR_NAME=\"gmp\"\n+CT_GMP_PKG_NAME=\"gmp\"\n+CT_GMP_SRC_RELEASE=y\n+# CT_GMP_SRC_DEVEL is not set\n+# CT_GMP_SRC_CUSTOM is not set\n+CT_GMP_PATCH_GLOBAL=y\n+# CT_GMP_PATCH_BUNDLED is not set\n+# CT_GMP_PATCH_LOCAL is not set\n+# CT_GMP_PATCH_BUNDLED_LOCAL is not set\n+# CT_GMP_PATCH_LOCAL_BUNDLED is not set\n+# CT_GMP_PATCH_NONE is not set\n+CT_GMP_PATCH_ORDER=\"global\"\n+CT_GMP_V_6_1=y\n+# CT_GMP_NO_VERSIONS is not set\n+CT_GMP_VERSION=\"6.1.2\"\n+CT_GMP_MIRRORS=\"https://gmplib.org/download/gmp https://gmplib.org/download/gmp/archive $(CT_Mirrors GNU gmp)\"\n+CT_GMP_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_GMP_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_GMP_ARCHIVE_FORMATS=\".tar.xz .tar.lz .tar.bz2\"\n+CT_GMP_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_GMP_later_than_5_1_0=y\n+CT_GMP_5_1_0_or_later=y\n+CT_GMP_later_than_5_0_0=y\n+CT_GMP_5_0_0_or_later=y\n+CT_GMP_REQUIRE_5_0_0_or_later=y\n+CT_COMP_LIBS_ISL=y\n+CT_COMP_LIBS_ISL_PKG_KSYM=\"ISL\"\n+CT_ISL_DIR_NAME=\"isl\"\n+CT_ISL_PKG_NAME=\"isl\"\n+CT_ISL_SRC_RELEASE=y\n+# CT_ISL_SRC_DEVEL is not set\n+# CT_ISL_SRC_CUSTOM is not set\n+CT_ISL_PATCH_GLOBAL=y\n+# CT_ISL_PATCH_BUNDLED is not set\n+# CT_ISL_PATCH_LOCAL is not set\n+# CT_ISL_PATCH_BUNDLED_LOCAL is not set\n+# CT_ISL_PATCH_LOCAL_BUNDLED is not set\n+# CT_ISL_PATCH_NONE is not set\n+CT_ISL_PATCH_ORDER=\"global\"\n+CT_ISL_V_0_20=y\n+# CT_ISL_V_0_19 is not set\n+# CT_ISL_V_0_18 is not set\n+# CT_ISL_V_0_17 is not set\n+# CT_ISL_V_0_16 is not set\n+# CT_ISL_V_0_15 is not set\n+# CT_ISL_NO_VERSIONS is not set\n+CT_ISL_VERSION=\"0.20\"\n+CT_ISL_MIRRORS=\"http://isl.gforge.inria.fr\"\n+CT_ISL_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_ISL_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_ISL_ARCHIVE_FORMATS=\".tar.xz .tar.bz2 .tar.gz\"\n+CT_ISL_SIGNATURE_FORMAT=\"\"\n+CT_ISL_later_than_0_18=y\n+CT_ISL_0_18_or_later=y\n+CT_ISL_later_than_0_15=y\n+CT_ISL_0_15_or_later=y\n+CT_ISL_REQUIRE_0_15_or_later=y\n+CT_ISL_later_than_0_14=y\n+CT_ISL_0_14_or_later=y\n+CT_ISL_REQUIRE_0_14_or_later=y\n+CT_ISL_later_than_0_13=y\n+CT_ISL_0_13_or_later=y\n+CT_ISL_later_than_0_12=y\n+CT_ISL_0_12_or_later=y\n+CT_ISL_REQUIRE_0_12_or_later=y\n+# CT_COMP_LIBS_LIBELF is not set\n+CT_COMP_LIBS_LIBICONV=y\n+CT_COMP_LIBS_LIBICONV_PKG_KSYM=\"LIBICONV\"\n+CT_LIBICONV_DIR_NAME=\"libiconv\"\n+CT_LIBICONV_PKG_NAME=\"libiconv\"\n+CT_LIBICONV_SRC_RELEASE=y\n+# CT_LIBICONV_SRC_DEVEL is not set\n+# CT_LIBICONV_SRC_CUSTOM is not set\n+CT_LIBICONV_PATCH_GLOBAL=y\n+# CT_LIBICONV_PATCH_BUNDLED is not set\n+# CT_LIBICONV_PATCH_LOCAL is not set\n+# CT_LIBICONV_PATCH_BUNDLED_LOCAL is not set\n+# CT_LIBICONV_PATCH_LOCAL_BUNDLED is not set\n+# CT_LIBICONV_PATCH_NONE is not set\n+CT_LIBICONV_PATCH_ORDER=\"global\"\n+CT_LIBICONV_V_1_15=y\n+# CT_LIBICONV_NO_VERSIONS is not set\n+CT_LIBICONV_VERSION=\"1.15\"\n+CT_LIBICONV_MIRRORS=\"$(CT_Mirrors GNU libiconv)\"\n+CT_LIBICONV_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_LIBICONV_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_LIBICONV_ARCHIVE_FORMATS=\".tar.gz\"\n+CT_LIBICONV_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_COMP_LIBS_MPC=y\n+CT_COMP_LIBS_MPC_PKG_KSYM=\"MPC\"\n+CT_MPC_DIR_NAME=\"mpc\"\n+CT_MPC_PKG_NAME=\"mpc\"\n+CT_MPC_SRC_RELEASE=y\n+# CT_MPC_SRC_DEVEL is not set\n+# CT_MPC_SRC_CUSTOM is not set\n+CT_MPC_PATCH_GLOBAL=y\n+# CT_MPC_PATCH_BUNDLED is not set\n+# CT_MPC_PATCH_LOCAL is not set\n+# CT_MPC_PATCH_BUNDLED_LOCAL is not set\n+# CT_MPC_PATCH_LOCAL_BUNDLED is not set\n+# CT_MPC_PATCH_NONE is not set\n+CT_MPC_PATCH_ORDER=\"global\"\n+CT_MPC_V_1_1=y\n+# CT_MPC_V_1_0 is not set\n+# CT_MPC_NO_VERSIONS is not set\n+CT_MPC_VERSION=\"1.1.0\"\n+CT_MPC_MIRRORS=\"http://www.multiprecision.org/downloads $(CT_Mirrors GNU mpc)\"\n+CT_MPC_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_MPC_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_MPC_ARCHIVE_FORMATS=\".tar.gz\"\n+CT_MPC_SIGNATURE_FORMAT=\"packed/.sig\"\n+CT_MPC_1_1_0_or_later=y\n+CT_MPC_1_1_0_or_older=y\n+CT_COMP_LIBS_MPFR=y\n+CT_COMP_LIBS_MPFR_PKG_KSYM=\"MPFR\"\n+CT_MPFR_DIR_NAME=\"mpfr\"\n+CT_MPFR_PKG_NAME=\"mpfr\"\n+CT_MPFR_SRC_RELEASE=y\n+# CT_MPFR_SRC_DEVEL is not set\n+# CT_MPFR_SRC_CUSTOM is not set\n+CT_MPFR_PATCH_GLOBAL=y\n+# CT_MPFR_PATCH_BUNDLED is not set\n+# CT_MPFR_PATCH_LOCAL is not set\n+# CT_MPFR_PATCH_BUNDLED_LOCAL is not set\n+# CT_MPFR_PATCH_LOCAL_BUNDLED is not set\n+# CT_MPFR_PATCH_NONE is not set\n+CT_MPFR_PATCH_ORDER=\"global\"\n+CT_MPFR_V_4_0=y\n+# CT_MPFR_V_3_1 is not set\n+# CT_MPFR_NO_VERSIONS is not set\n+CT_MPFR_VERSION=\"4.0.2\"\n+CT_MPFR_MIRRORS=\"http://www.mpfr.org/mpfr-${CT_MPFR_VERSION} $(CT_Mirrors GNU mpfr)\"\n+CT_MPFR_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_MPFR_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_MPFR_ARCHIVE_FORMATS=\".tar.xz .tar.bz2 .tar.gz .zip\"\n+CT_MPFR_SIGNATURE_FORMAT=\"packed/.asc\"\n+CT_MPFR_later_than_4_0_0=y\n+CT_MPFR_4_0_0_or_later=y\n+CT_MPFR_later_than_3_0_0=y\n+CT_MPFR_3_0_0_or_later=y\n+CT_MPFR_REQUIRE_3_0_0_or_later=y\n+CT_COMP_LIBS_NCURSES=y\n+CT_COMP_LIBS_NCURSES_PKG_KSYM=\"NCURSES\"\n+CT_NCURSES_DIR_NAME=\"ncurses\"\n+CT_NCURSES_PKG_NAME=\"ncurses\"\n+CT_NCURSES_SRC_RELEASE=y\n+# CT_NCURSES_SRC_DEVEL is not set\n+# CT_NCURSES_SRC_CUSTOM is not set\n+CT_NCURSES_PATCH_GLOBAL=y\n+# CT_NCURSES_PATCH_BUNDLED is not set\n+# CT_NCURSES_PATCH_LOCAL is not set\n+# CT_NCURSES_PATCH_BUNDLED_LOCAL is not set\n+# CT_NCURSES_PATCH_LOCAL_BUNDLED is not set\n+# CT_NCURSES_PATCH_NONE is not set\n+CT_NCURSES_PATCH_ORDER=\"global\"\n+CT_NCURSES_V_6_1=y\n+# CT_NCURSES_V_6_0 is not set\n+# CT_NCURSES_NO_VERSIONS is not set\n+CT_NCURSES_VERSION=\"6.1\"\n+CT_NCURSES_MIRRORS=\"ftp://invisible-island.net/ncurses $(CT_Mirrors GNU ncurses)\"\n+CT_NCURSES_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_NCURSES_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_NCURSES_ARCHIVE_FORMATS=\".tar.gz\"\n+CT_NCURSES_SIGNATURE_FORMAT=\"packed/.sig\"\n+# CT_NCURSES_NEW_ABI is not set\n+CT_NCURSES_HOST_CONFIG_ARGS=\"\"\n+CT_NCURSES_HOST_DISABLE_DB=y\n+CT_NCURSES_HOST_FALLBACKS=\"linux,xterm,xterm-color,xterm-256color,vt100\"\n+CT_NCURSES_TARGET_CONFIG_ARGS=\"\"\n+# CT_NCURSES_TARGET_DISABLE_DB is not set\n+CT_NCURSES_TARGET_FALLBACKS=\"\"\n+CT_COMP_LIBS_ZLIB=y\n+CT_COMP_LIBS_ZLIB_PKG_KSYM=\"ZLIB\"\n+CT_ZLIB_DIR_NAME=\"zlib\"\n+CT_ZLIB_PKG_NAME=\"zlib\"\n+CT_ZLIB_SRC_RELEASE=y\n+# CT_ZLIB_SRC_DEVEL is not set\n+# CT_ZLIB_SRC_CUSTOM is not set\n+CT_ZLIB_PATCH_GLOBAL=y\n+# CT_ZLIB_PATCH_BUNDLED is not set\n+# CT_ZLIB_PATCH_LOCAL is not set\n+# CT_ZLIB_PATCH_BUNDLED_LOCAL is not set\n+# CT_ZLIB_PATCH_LOCAL_BUNDLED is not set\n+# CT_ZLIB_PATCH_NONE is not set\n+CT_ZLIB_PATCH_ORDER=\"global\"\n+CT_ZLIB_V_1_2_11=y\n+# CT_ZLIB_NO_VERSIONS is not set\n+CT_ZLIB_VERSION=\"1.2.11\"\n+CT_ZLIB_MIRRORS=\"http://downloads.sourceforge.net/project/libpng/zlib/${CT_ZLIB_VERSION}\"\n+CT_ZLIB_ARCHIVE_FILENAME=\"@{pkg_name}-@{version}\"\n+CT_ZLIB_ARCHIVE_DIRNAME=\"@{pkg_name}-@{version}\"\n+CT_ZLIB_ARCHIVE_FORMATS=\".tar.xz .tar.gz\"\n+CT_ZLIB_SIGNATURE_FORMAT=\"packed/.asc\"\n+CT_ALL_COMP_LIBS_CHOICES=\"CLOOG EXPAT GETTEXT GMP ISL LIBELF LIBICONV MPC MPFR NCURSES ZLIB\"\n+CT_LIBICONV_NEEDED=y\n+CT_GETTEXT_NEEDED=y\n+CT_GMP_NEEDED=y\n+CT_MPFR_NEEDED=y\n+CT_ISL_NEEDED=y\n+CT_MPC_NEEDED=y\n+CT_EXPAT_NEEDED=y\n+CT_NCURSES_NEEDED=y\n+CT_ZLIB_NEEDED=y\n+CT_LIBICONV=y\n+CT_GETTEXT=y\n+CT_GMP=y\n+CT_MPFR=y\n+CT_ISL=y\n+CT_MPC=y\n+CT_EXPAT=y\n+CT_NCURSES=y\n+CT_ZLIB=y\n+\n+#\n+# Companion tools\n+#\n+# CT_COMP_TOOLS_FOR_HOST is not set\n+# CT_COMP_TOOLS_AUTOCONF is not set\n+# CT_COMP_TOOLS_AUTOMAKE is not set\n+# CT_COMP_TOOLS_BISON is not set\n+# CT_COMP_TOOLS_DTC is not set\n+# CT_COMP_TOOLS_LIBTOOL is not set\n+# CT_COMP_TOOLS_M4 is not set\n+# CT_COMP_TOOLS_MAKE is not set\n+CT_ALL_COMP_TOOLS_CHOICES=\"AUTOCONF AUTOMAKE BISON DTC LIBTOOL M4 MAKE\"\n+\n+#\n+# Test suite\n+#\n+# CT_TEST_SUITE_GCC is not set"}, {"sha": "b8686775642983b6888d3dbd1350a0d0def8fba9", "filename": "src/ci/docker/dist-various-2/build-wasi-toolchain.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-wasi-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-wasi-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-wasi-toolchain.sh?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -12,7 +12,7 @@ export PATH=`pwd`/clang+llvm-9.0.0-x86_64-linux-gnu-ubuntu-14.04/bin:$PATH\n git clone https://github.com/CraneStation/wasi-libc\n \n cd wasi-libc\n-git reset --hard f645f498dfbbbc00a7a97874d33082d3605c3f21\n+git reset --hard 1fad33890a5e299027ce0eab7b6ad5260585e347\n make -j$(nproc) INSTALL_DIR=/wasm32-wasi install\n \n cd .."}, {"sha": "92baf7293dd2d418d2ac4b141b0faa822075d9f7", "filename": "src/doc/rustc-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-guide?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1 +1 @@\n-Subproject commit b5c6babcdd4ce1fa90458b7827a5fde082e79e87\n+Subproject commit 92baf7293dd2d418d2ac4b141b0faa822075d9f7"}, {"sha": "53e01091f754e4f15b22042335ac73001cd1df1b", "filename": "src/doc/unstable-book/src/language-features/infer-static-outlives-requirements.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Finfer-static-outlives-requirements.md", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Finfer-static-outlives-requirements.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Finfer-static-outlives-requirements.md?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,8 +1,8 @@\n # `infer_static_outlives_requirements`\n \n-The tracking issue for this feature is: [#44493]\n+The tracking issue for this feature is: [#54185]\n \n-[#44493]: https://github.com/rust-lang/rust/issues/44493\n+[#54185]: https://github.com/rust-lang/rust/issues/54185\n \n ------------------------\n The `infer_static_outlives_requirements` feature indicates that certain"}, {"sha": "3ba4a3e6b1f02d169c262c23f9b4e2149c4b98ff", "filename": "src/doc/unstable-book/src/language-features/member-constraints.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmember-constraints.md", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmember-constraints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmember-constraints.md?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,8 +1,8 @@\n # `member_constraints`\n \n-The tracking issue for this feature is: [#61977]\n+The tracking issue for this feature is: [#61997]\n \n-[#61977]: https://github.com/rust-lang/rust/issues/61977\n+[#61997]: https://github.com/rust-lang/rust/issues/61997\n \n ------------------------\n "}, {"sha": "146f50ee67b500ee0da555df5581b9233f3b4b79", "filename": "src/doc/unstable-book/src/language-features/repr128.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr128.md", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr128.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr128.md?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,8 +1,8 @@\n # `repr128`\n \n-The tracking issue for this feature is: [#35118]\n+The tracking issue for this feature is: [#56071]\n \n-[#35118]: https://github.com/rust-lang/rust/issues/35118\n+[#56071]: https://github.com/rust-lang/rust/issues/56071\n \n ------------------------\n "}, {"sha": "cdb74495884a8e6e8d027992e147814ed44946ee", "filename": "src/doc/unstable-book/src/language-features/slice-patterns.md", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/470cdf54ac9acee20ab8da46ef7899bae9f58f29/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fslice-patterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/470cdf54ac9acee20ab8da46ef7899bae9f58f29/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fslice-patterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fslice-patterns.md?ref=470cdf54ac9acee20ab8da46ef7899bae9f58f29", "patch": "@@ -1,32 +0,0 @@\n-# `slice_patterns`\n-\n-The tracking issue for this feature is: [#62254]\n-\n-[#62254]: https://github.com/rust-lang/rust/issues/62254\n-\n-------------------------\n-\n-The `slice_patterns` feature gate lets you use `..` to indicate any number of\n-elements inside a pattern matching a slice. This wildcard can only be used once\n-for a given array. If there's an pattern before the `..`, the subslice will be\n-matched against that pattern. For example:\n-\n-```rust\n-#![feature(slice_patterns)]\n-\n-fn is_symmetric(list: &[u32]) -> bool {\n-    match list {\n-        &[] | &[_] => true,\n-        &[x, ref inside @ .., y] if x == y => is_symmetric(inside),\n-        &[..] => false,\n-    }\n-}\n-\n-fn main() {\n-    let sym = &[0, 1, 4, 2, 4, 1, 0];\n-    assert!(is_symmetric(sym));\n-\n-    let not_sym = &[0, 1, 7, 2, 4, 1, 0];\n-    assert!(!is_symmetric(not_sym));\n-}\n-```"}, {"sha": "5c95160ba2d14dba82ea7a57b4fef7b64ef45f88", "filename": "src/liballoc/benches/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Fliballoc%2Fbenches%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Fliballoc%2Fbenches%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fstring.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,5 +1,5 @@\n use std::iter::repeat;\n-use test::Bencher;\n+use test::{black_box, Bencher};\n \n #[bench]\n fn bench_with_capacity(b: &mut Bencher) {"}, {"sha": "b88ca8a0fb0d10870be027d9863fe7224ad61aba", "filename": "src/liballoc/collections/linked_list.rs", "status": "modified", "additions": 555, "deletions": 24, "changes": 579, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -242,6 +242,121 @@ impl<T> LinkedList<T> {\n \n         self.len -= 1;\n     }\n+\n+    /// Splices a series of nodes between two existing nodes.\n+    ///\n+    /// Warning: this will not check that the provided node belongs to the two existing lists.\n+    #[inline]\n+    unsafe fn splice_nodes(\n+        &mut self,\n+        existing_prev: Option<NonNull<Node<T>>>,\n+        existing_next: Option<NonNull<Node<T>>>,\n+        mut splice_start: NonNull<Node<T>>,\n+        mut splice_end: NonNull<Node<T>>,\n+        splice_length: usize,\n+    ) {\n+        // This method takes care not to create multiple mutable references to whole nodes at the same time,\n+        // to maintain validity of aliasing pointers into `element`.\n+        if let Some(mut existing_prev) = existing_prev {\n+            existing_prev.as_mut().next = Some(splice_start);\n+        } else {\n+            self.head = Some(splice_start);\n+        }\n+        if let Some(mut existing_next) = existing_next {\n+            existing_next.as_mut().prev = Some(splice_end);\n+        } else {\n+            self.tail = Some(splice_end);\n+        }\n+        splice_start.as_mut().prev = existing_prev;\n+        splice_end.as_mut().next = existing_next;\n+\n+        self.len += splice_length;\n+    }\n+\n+    /// Detaches all nodes from a linked list as a series of nodes.\n+    #[inline]\n+    fn detach_all_nodes(mut self) -> Option<(NonNull<Node<T>>, NonNull<Node<T>>, usize)> {\n+        let head = self.head.take();\n+        let tail = self.tail.take();\n+        let len = mem::replace(&mut self.len, 0);\n+        if let Some(head) = head {\n+            let tail = tail.unwrap_or_else(|| unsafe { core::hint::unreachable_unchecked() });\n+            Some((head, tail, len))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    unsafe fn split_off_before_node(\n+        &mut self,\n+        split_node: Option<NonNull<Node<T>>>,\n+        at: usize,\n+    ) -> Self {\n+        // The split node is the new head node of the second part\n+        if let Some(mut split_node) = split_node {\n+            let first_part_head;\n+            let first_part_tail;\n+            first_part_tail = split_node.as_mut().prev.take();\n+            if let Some(mut tail) = first_part_tail {\n+                tail.as_mut().next = None;\n+                first_part_head = self.head;\n+            } else {\n+                first_part_head = None;\n+            }\n+\n+            let first_part = LinkedList {\n+                head: first_part_head,\n+                tail: first_part_tail,\n+                len: at,\n+                marker: PhantomData,\n+            };\n+\n+            // Fix the head ptr of the second part\n+            self.head = Some(split_node);\n+            self.len = self.len - at;\n+\n+            first_part\n+        } else {\n+            mem::replace(self, LinkedList::new())\n+        }\n+    }\n+\n+    #[inline]\n+    unsafe fn split_off_after_node(\n+        &mut self,\n+        split_node: Option<NonNull<Node<T>>>,\n+        at: usize,\n+    ) -> Self {\n+        // The split node is the new tail node of the first part and owns\n+        // the head of the second part.\n+        if let Some(mut split_node) = split_node {\n+            let second_part_head;\n+            let second_part_tail;\n+            second_part_head = split_node.as_mut().next.take();\n+            if let Some(mut head) = second_part_head {\n+                head.as_mut().prev = None;\n+                second_part_tail = self.tail;\n+            } else {\n+                second_part_tail = None;\n+            }\n+\n+            let second_part = LinkedList {\n+                head: second_part_head,\n+                tail: second_part_tail,\n+                len: self.len - at,\n+                marker: PhantomData,\n+            };\n+\n+            // Fix the tail ptr of the first part\n+            self.tail = Some(split_node);\n+            self.len = at;\n+\n+            second_part\n+        } else {\n+            mem::replace(self, LinkedList::new())\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -319,6 +434,27 @@ impl<T> LinkedList<T> {\n         }\n     }\n \n+    /// Moves all elements from `other` to the begin of the list.\n+    #[unstable(feature = \"linked_list_prepend\", issue = \"none\")]\n+    pub fn prepend(&mut self, other: &mut Self) {\n+        match self.head {\n+            None => mem::swap(self, other),\n+            Some(mut head) => {\n+                // `as_mut` is okay here because we have exclusive access to the entirety\n+                // of both lists.\n+                if let Some(mut other_tail) = other.tail.take() {\n+                    unsafe {\n+                        head.as_mut().prev = Some(other_tail);\n+                        other_tail.as_mut().next = Some(head);\n+                    }\n+\n+                    self.head = other.head.take();\n+                    self.len += mem::replace(&mut other.len, 0);\n+                }\n+            }\n+        }\n+    }\n+\n     /// Provides a forward iterator.\n     ///\n     /// # Examples\n@@ -373,6 +509,42 @@ impl<T> LinkedList<T> {\n         IterMut { head: self.head, tail: self.tail, len: self.len, list: self }\n     }\n \n+    /// Provides a cursor at the front element.\n+    ///\n+    /// The cursor is pointing to the \"ghost\" non-element if the list is empty.\n+    #[inline]\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn cursor_front(&self) -> Cursor<'_, T> {\n+        Cursor { index: 0, current: self.head, list: self }\n+    }\n+\n+    /// Provides a cursor with editing operations at the front element.\n+    ///\n+    /// The cursor is pointing to the \"ghost\" non-element if the list is empty.\n+    #[inline]\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn cursor_front_mut(&mut self) -> CursorMut<'_, T> {\n+        CursorMut { index: 0, current: self.head, list: self }\n+    }\n+\n+    /// Provides a cursor at the back element.\n+    ///\n+    /// The cursor is pointing to the \"ghost\" non-element if the list is empty.\n+    #[inline]\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn cursor_back(&self) -> Cursor<'_, T> {\n+        Cursor { index: self.len.checked_sub(1).unwrap_or(0), current: self.tail, list: self }\n+    }\n+\n+    /// Provides a cursor with editing operations at the back element.\n+    ///\n+    /// The cursor is pointing to the \"ghost\" non-element if the list is empty.\n+    #[inline]\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn cursor_back_mut(&mut self) -> CursorMut<'_, T> {\n+        CursorMut { index: self.len.checked_sub(1).unwrap_or(0), current: self.tail, list: self }\n+    }\n+\n     /// Returns `true` if the `LinkedList` is empty.\n     ///\n     /// This operation should compute in O(1) time.\n@@ -703,30 +875,7 @@ impl<T> LinkedList<T> {\n             }\n             iter.tail\n         };\n-\n-        // The split node is the new tail node of the first part and owns\n-        // the head of the second part.\n-        let second_part_head;\n-\n-        unsafe {\n-            second_part_head = split_node.unwrap().as_mut().next.take();\n-            if let Some(mut head) = second_part_head {\n-                head.as_mut().prev = None;\n-            }\n-        }\n-\n-        let second_part = LinkedList {\n-            head: second_part_head,\n-            tail: self.tail,\n-            len: len - at,\n-            marker: PhantomData,\n-        };\n-\n-        // Fix the tail ptr of the first part\n-        self.tail = split_node;\n-        self.len = at;\n-\n-        second_part\n+        unsafe { self.split_off_after_node(split_node, at) }\n     }\n \n     /// Creates an iterator which uses a closure to determine if an element should be removed.\n@@ -986,6 +1135,388 @@ impl<T> IterMut<'_, T> {\n     }\n }\n \n+/// A cursor over a `LinkedList`.\n+///\n+/// A `Cursor` is like an iterator, except that it can freely seek back-and-forth.\n+///\n+/// Cursors always rest between two elements in the list, and index in a logically circular way.\n+/// To accommodate this, there is a \"ghost\" non-element that yields `None` between the head and\n+/// tail of the list.\n+///\n+/// When created, cursors start at the front of the list, or the \"ghost\" non-element if the list is empty.\n+#[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+pub struct Cursor<'a, T: 'a> {\n+    index: usize,\n+    current: Option<NonNull<Node<T>>>,\n+    list: &'a LinkedList<T>,\n+}\n+\n+#[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+impl<T: fmt::Debug> fmt::Debug for Cursor<'_, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"Cursor\").field(&self.list).field(&self.index()).finish()\n+    }\n+}\n+\n+/// A cursor over a `LinkedList` with editing operations.\n+///\n+/// A `Cursor` is like an iterator, except that it can freely seek back-and-forth, and can\n+/// safely mutate the list during iteration. This is because the lifetime of its yielded\n+/// references is tied to its own lifetime, instead of just the underlying list. This means\n+/// cursors cannot yield multiple elements at once.\n+///\n+/// Cursors always rest between two elements in the list, and index in a logically circular way.\n+/// To accommodate this, there is a \"ghost\" non-element that yields `None` between the head and\n+/// tail of the list.\n+#[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+pub struct CursorMut<'a, T: 'a> {\n+    index: usize,\n+    current: Option<NonNull<Node<T>>>,\n+    list: &'a mut LinkedList<T>,\n+}\n+\n+#[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+impl<T: fmt::Debug> fmt::Debug for CursorMut<'_, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"CursorMut\").field(&self.list).field(&self.index()).finish()\n+    }\n+}\n+\n+impl<'a, T> Cursor<'a, T> {\n+    /// Returns the cursor position index within the `LinkedList`.\n+    ///\n+    /// This returns `None` if the cursor is currently pointing to the\n+    /// \"ghost\" non-element.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn index(&self) -> Option<usize> {\n+        let _ = self.current?;\n+        Some(self.index)\n+    }\n+\n+    /// Moves the cursor to the next element of the `LinkedList`.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this will move it to\n+    /// the first element of the `LinkedList`. If it is pointing to the last\n+    /// element of the `LinkedList` then this will move it to the \"ghost\" non-element.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn move_next(&mut self) {\n+        match self.current.take() {\n+            // We had no current element; the cursor was sitting at the start position\n+            // Next element should be the head of the list\n+            None => {\n+                self.current = self.list.head;\n+                self.index = 0;\n+            }\n+            // We had a previous element, so let's go to its next\n+            Some(current) => unsafe {\n+                self.current = current.as_ref().next;\n+                self.index += 1;\n+            },\n+        }\n+    }\n+\n+    /// Moves the cursor to the previous element of the `LinkedList`.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this will move it to\n+    /// the last element of the `LinkedList`. If it is pointing to the first\n+    /// element of the `LinkedList` then this will move it to the \"ghost\" non-element.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn move_prev(&mut self) {\n+        match self.current.take() {\n+            // No current. We're at the start of the list. Yield None and jump to the end.\n+            None => {\n+                self.current = self.list.tail;\n+                self.index = self.list.len().checked_sub(1).unwrap_or(0);\n+            }\n+            // Have a prev. Yield it and go to the previous element.\n+            Some(current) => unsafe {\n+                self.current = current.as_ref().prev;\n+                self.index = self.index.checked_sub(1).unwrap_or_else(|| self.list.len());\n+            },\n+        }\n+    }\n+\n+    /// Returns a reference to the element that the cursor is currently\n+    /// pointing to.\n+    ///\n+    /// This returns `None` if the cursor is currently pointing to the\n+    /// \"ghost\" non-element.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn current(&self) -> Option<&'a T> {\n+        unsafe { self.current.map(|current| &(*current.as_ptr()).element) }\n+    }\n+\n+    /// Returns a reference to the next element.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this returns\n+    /// the first element of the `LinkedList`. If it is pointing to the last\n+    /// element of the `LinkedList` then this returns `None`.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn peek_next(&self) -> Option<&'a T> {\n+        unsafe {\n+            let next = match self.current {\n+                None => self.list.head,\n+                Some(current) => current.as_ref().next,\n+            };\n+            next.map(|next| &(*next.as_ptr()).element)\n+        }\n+    }\n+\n+    /// Returns a reference to the previous element.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this returns\n+    /// the last element of the `LinkedList`. If it is pointing to the first\n+    /// element of the `LinkedList` then this returns `None`.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn peek_prev(&self) -> Option<&'a T> {\n+        unsafe {\n+            let prev = match self.current {\n+                None => self.list.tail,\n+                Some(current) => current.as_ref().prev,\n+            };\n+            prev.map(|prev| &(*prev.as_ptr()).element)\n+        }\n+    }\n+}\n+\n+impl<'a, T> CursorMut<'a, T> {\n+    /// Returns the cursor position index within the `LinkedList`.\n+    ///\n+    /// This returns `None` if the cursor is currently pointing to the\n+    /// \"ghost\" non-element.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn index(&self) -> Option<usize> {\n+        let _ = self.current?;\n+        Some(self.index)\n+    }\n+\n+    /// Moves the cursor to the next element of the `LinkedList`.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this will move it to\n+    /// the first element of the `LinkedList`. If it is pointing to the last\n+    /// element of the `LinkedList` then this will move it to the \"ghost\" non-element.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn move_next(&mut self) {\n+        match self.current.take() {\n+            // We had no current element; the cursor was sitting at the start position\n+            // Next element should be the head of the list\n+            None => {\n+                self.current = self.list.head;\n+                self.index = 0;\n+            }\n+            // We had a previous element, so let's go to its next\n+            Some(current) => unsafe {\n+                self.current = current.as_ref().next;\n+                self.index += 1;\n+            },\n+        }\n+    }\n+\n+    /// Moves the cursor to the previous element of the `LinkedList`.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this will move it to\n+    /// the last element of the `LinkedList`. If it is pointing to the first\n+    /// element of the `LinkedList` then this will move it to the \"ghost\" non-element.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn move_prev(&mut self) {\n+        match self.current.take() {\n+            // No current. We're at the start of the list. Yield None and jump to the end.\n+            None => {\n+                self.current = self.list.tail;\n+                self.index = self.list.len().checked_sub(1).unwrap_or(0);\n+            }\n+            // Have a prev. Yield it and go to the previous element.\n+            Some(current) => unsafe {\n+                self.current = current.as_ref().prev;\n+                self.index = self.index.checked_sub(1).unwrap_or_else(|| self.list.len());\n+            },\n+        }\n+    }\n+\n+    /// Returns a reference to the element that the cursor is currently\n+    /// pointing to.\n+    ///\n+    /// This returns `None` if the cursor is currently pointing to the\n+    /// \"ghost\" non-element.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn current(&mut self) -> Option<&mut T> {\n+        unsafe { self.current.map(|current| &mut (*current.as_ptr()).element) }\n+    }\n+\n+    /// Returns a reference to the next element.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this returns\n+    /// the first element of the `LinkedList`. If it is pointing to the last\n+    /// element of the `LinkedList` then this returns `None`.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn peek_next(&mut self) -> Option<&mut T> {\n+        unsafe {\n+            let next = match self.current {\n+                None => self.list.head,\n+                Some(current) => current.as_ref().next,\n+            };\n+            next.map(|next| &mut (*next.as_ptr()).element)\n+        }\n+    }\n+\n+    /// Returns a reference to the previous element.\n+    ///\n+    /// If the cursor is pointing to the \"ghost\" non-element then this returns\n+    /// the last element of the `LinkedList`. If it is pointing to the first\n+    /// element of the `LinkedList` then this returns `None`.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn peek_prev(&mut self) -> Option<&mut T> {\n+        unsafe {\n+            let prev = match self.current {\n+                None => self.list.tail,\n+                Some(current) => current.as_ref().prev,\n+            };\n+            prev.map(|prev| &mut (*prev.as_ptr()).element)\n+        }\n+    }\n+\n+    /// Returns a read-only cursor pointing to the current element.\n+    ///\n+    /// The lifetime of the returned `Cursor` is bound to that of the\n+    /// `CursorMut`, which means it cannot outlive the `CursorMut` and that the\n+    /// `CursorMut` is frozen for the lifetime of the `Cursor`.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn as_cursor<'cm>(&'cm self) -> Cursor<'cm, T> {\n+        Cursor { list: self.list, current: self.current, index: self.index }\n+    }\n+}\n+\n+// Now the list editing operations\n+\n+impl<'a, T> CursorMut<'a, T> {\n+    /// Inserts a new element into the `LinkedList` after the current one.\n+    ///\n+    /// If the cursor is pointing at the \"ghost\" non-element then the new element is\n+    /// inserted at the front of the `LinkedList`.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn insert_after(&mut self, item: T) {\n+        unsafe {\n+            let spliced_node = Box::into_raw_non_null(Box::new(Node::new(item)));\n+            let node_next = match self.current {\n+                None => self.list.head,\n+                Some(node) => node.as_ref().next,\n+            };\n+            self.list.splice_nodes(self.current, node_next, spliced_node, spliced_node, 1);\n+            if self.current.is_none() {\n+                // The \"ghost\" non-element's index has changed.\n+                self.index = self.list.len;\n+            }\n+        }\n+    }\n+\n+    /// Inserts a new element into the `LinkedList` before the current one.\n+    ///\n+    /// If the cursor is pointing at the \"ghost\" non-element then the new element is\n+    /// inserted at the end of the `LinkedList`.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn insert_before(&mut self, item: T) {\n+        unsafe {\n+            let spliced_node = Box::into_raw_non_null(Box::new(Node::new(item)));\n+            let node_prev = match self.current {\n+                None => self.list.tail,\n+                Some(node) => node.as_ref().prev,\n+            };\n+            self.list.splice_nodes(node_prev, self.current, spliced_node, spliced_node, 1);\n+            self.index += 1;\n+        }\n+    }\n+\n+    /// Removes the current element from the `LinkedList`.\n+    ///\n+    /// The element that was removed is returned, and the cursor is\n+    /// moved to point to the next element in the `LinkedList`.\n+    ///\n+    /// If the cursor is currently pointing to the \"ghost\" non-element then no element\n+    /// is removed and `None` is returned.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn remove_current(&mut self) -> Option<T> {\n+        let unlinked_node = self.current?;\n+        unsafe {\n+            self.current = unlinked_node.as_ref().next;\n+            self.list.unlink_node(unlinked_node);\n+            let unlinked_node = Box::from_raw(unlinked_node.as_ptr());\n+            Some(unlinked_node.element)\n+        }\n+    }\n+\n+    /// Inserts the elements from the given `LinkedList` after the current one.\n+    ///\n+    /// If the cursor is pointing at the \"ghost\" non-element then the new elements are\n+    /// inserted at the start of the `LinkedList`.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn splice_after(&mut self, list: LinkedList<T>) {\n+        unsafe {\n+            let (splice_head, splice_tail, splice_len) = match list.detach_all_nodes() {\n+                Some(parts) => parts,\n+                _ => return,\n+            };\n+            let node_next = match self.current {\n+                None => self.list.head,\n+                Some(node) => node.as_ref().next,\n+            };\n+            self.list.splice_nodes(self.current, node_next, splice_head, splice_tail, splice_len);\n+            if self.current.is_none() {\n+                // The \"ghost\" non-element's index has changed.\n+                self.index = self.list.len;\n+            }\n+        }\n+    }\n+\n+    /// Inserts the elements from the given `LinkedList` before the current one.\n+    ///\n+    /// If the cursor is pointing at the \"ghost\" non-element then the new elements are\n+    /// inserted at the end of the `LinkedList`.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn splice_before(&mut self, list: LinkedList<T>) {\n+        unsafe {\n+            let (splice_head, splice_tail, splice_len) = match list.detach_all_nodes() {\n+                Some(parts) => parts,\n+                _ => return,\n+            };\n+            let node_prev = match self.current {\n+                None => self.list.tail,\n+                Some(node) => node.as_ref().prev,\n+            };\n+            self.list.splice_nodes(node_prev, self.current, splice_head, splice_tail, splice_len);\n+            self.index += splice_len;\n+        }\n+    }\n+\n+    /// Splits the list into two after the current element. This will return a\n+    /// new list consisting of everything after the cursor, with the original\n+    /// list retaining everything before.\n+    ///\n+    /// If the cursor is pointing at the \"ghost\" non-element then the entire contents\n+    /// of the `LinkedList` are moved.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn split_after(&mut self) -> LinkedList<T> {\n+        let split_off_idx = if self.index == self.list.len { 0 } else { self.index + 1 };\n+        if self.index == self.list.len {\n+            // The \"ghost\" non-element's index has changed to 0.\n+            self.index = 0;\n+        }\n+        unsafe { self.list.split_off_after_node(self.current, split_off_idx) }\n+    }\n+\n+    /// Splits the list into two before the current element. This will return a\n+    /// new list consisting of everything before the cursor, with the original\n+    /// list retaining everything after.\n+    ///\n+    /// If the cursor is pointing at the \"ghost\" non-element then the entire contents\n+    /// of the `LinkedList` are moved.\n+    #[unstable(feature = \"linked_list_cursors\", issue = \"58533\")]\n+    pub fn split_before(&mut self) -> LinkedList<T> {\n+        let split_off_idx = self.index;\n+        self.index = 0;\n+        unsafe { self.list.split_off_before_node(self.current, split_off_idx) }\n+    }\n+}\n+\n /// An iterator produced by calling `drain_filter` on LinkedList.\n #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n pub struct DrainFilter<'a, T: 'a, F: 'a>"}, {"sha": "085f734ed916a0ca43cc92ad4e257268d48e5ff7", "filename": "src/liballoc/collections/linked_list/tests.rs", "status": "modified", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -304,3 +304,155 @@ fn drain_to_empty_test() {\n     assert_eq!(deleted, &[1, 2, 3, 4, 5, 6]);\n     assert_eq!(m.into_iter().collect::<Vec<_>>(), &[]);\n }\n+\n+#[test]\n+fn test_cursor_move_peek() {\n+    let mut m: LinkedList<u32> = LinkedList::new();\n+    m.extend(&[1, 2, 3, 4, 5, 6]);\n+    let mut cursor = m.cursor_front();\n+    assert_eq!(cursor.current(), Some(&1));\n+    assert_eq!(cursor.peek_next(), Some(&2));\n+    assert_eq!(cursor.peek_prev(), None);\n+    assert_eq!(cursor.index(), Some(0));\n+    cursor.move_prev();\n+    assert_eq!(cursor.current(), None);\n+    assert_eq!(cursor.peek_next(), Some(&1));\n+    assert_eq!(cursor.peek_prev(), Some(&6));\n+    assert_eq!(cursor.index(), None);\n+    cursor.move_next();\n+    cursor.move_next();\n+    assert_eq!(cursor.current(), Some(&2));\n+    assert_eq!(cursor.peek_next(), Some(&3));\n+    assert_eq!(cursor.peek_prev(), Some(&1));\n+    assert_eq!(cursor.index(), Some(1));\n+\n+    let mut cursor = m.cursor_back();\n+    assert_eq!(cursor.current(), Some(&6));\n+    assert_eq!(cursor.peek_next(), None);\n+    assert_eq!(cursor.peek_prev(), Some(&5));\n+    assert_eq!(cursor.index(), Some(5));\n+    cursor.move_next();\n+    assert_eq!(cursor.current(), None);\n+    assert_eq!(cursor.peek_next(), Some(&1));\n+    assert_eq!(cursor.peek_prev(), Some(&6));\n+    assert_eq!(cursor.index(), None);\n+    cursor.move_prev();\n+    cursor.move_prev();\n+    assert_eq!(cursor.current(), Some(&5));\n+    assert_eq!(cursor.peek_next(), Some(&6));\n+    assert_eq!(cursor.peek_prev(), Some(&4));\n+    assert_eq!(cursor.index(), Some(4));\n+\n+    let mut m: LinkedList<u32> = LinkedList::new();\n+    m.extend(&[1, 2, 3, 4, 5, 6]);\n+    let mut cursor = m.cursor_front_mut();\n+    assert_eq!(cursor.current(), Some(&mut 1));\n+    assert_eq!(cursor.peek_next(), Some(&mut 2));\n+    assert_eq!(cursor.peek_prev(), None);\n+    assert_eq!(cursor.index(), Some(0));\n+    cursor.move_prev();\n+    assert_eq!(cursor.current(), None);\n+    assert_eq!(cursor.peek_next(), Some(&mut 1));\n+    assert_eq!(cursor.peek_prev(), Some(&mut 6));\n+    assert_eq!(cursor.index(), None);\n+    cursor.move_next();\n+    cursor.move_next();\n+    assert_eq!(cursor.current(), Some(&mut 2));\n+    assert_eq!(cursor.peek_next(), Some(&mut 3));\n+    assert_eq!(cursor.peek_prev(), Some(&mut 1));\n+    assert_eq!(cursor.index(), Some(1));\n+    let mut cursor2 = cursor.as_cursor();\n+    assert_eq!(cursor2.current(), Some(&2));\n+    assert_eq!(cursor2.index(), Some(1));\n+    cursor2.move_next();\n+    assert_eq!(cursor2.current(), Some(&3));\n+    assert_eq!(cursor2.index(), Some(2));\n+    assert_eq!(cursor.current(), Some(&mut 2));\n+    assert_eq!(cursor.index(), Some(1));\n+\n+    let mut m: LinkedList<u32> = LinkedList::new();\n+    m.extend(&[1, 2, 3, 4, 5, 6]);\n+    let mut cursor = m.cursor_back_mut();\n+    assert_eq!(cursor.current(), Some(&mut 6));\n+    assert_eq!(cursor.peek_next(), None);\n+    assert_eq!(cursor.peek_prev(), Some(&mut 5));\n+    assert_eq!(cursor.index(), Some(5));\n+    cursor.move_next();\n+    assert_eq!(cursor.current(), None);\n+    assert_eq!(cursor.peek_next(), Some(&mut 1));\n+    assert_eq!(cursor.peek_prev(), Some(&mut 6));\n+    assert_eq!(cursor.index(), None);\n+    cursor.move_prev();\n+    cursor.move_prev();\n+    assert_eq!(cursor.current(), Some(&mut 5));\n+    assert_eq!(cursor.peek_next(), Some(&mut 6));\n+    assert_eq!(cursor.peek_prev(), Some(&mut 4));\n+    assert_eq!(cursor.index(), Some(4));\n+    let mut cursor2 = cursor.as_cursor();\n+    assert_eq!(cursor2.current(), Some(&5));\n+    assert_eq!(cursor2.index(), Some(4));\n+    cursor2.move_prev();\n+    assert_eq!(cursor2.current(), Some(&4));\n+    assert_eq!(cursor2.index(), Some(3));\n+    assert_eq!(cursor.current(), Some(&mut 5));\n+    assert_eq!(cursor.index(), Some(4));\n+}\n+\n+#[test]\n+fn test_cursor_mut_insert() {\n+    let mut m: LinkedList<u32> = LinkedList::new();\n+    m.extend(&[1, 2, 3, 4, 5, 6]);\n+    let mut cursor = m.cursor_front_mut();\n+    cursor.insert_before(7);\n+    cursor.insert_after(8);\n+    check_links(&m);\n+    assert_eq!(m.iter().cloned().collect::<Vec<_>>(), &[7, 1, 8, 2, 3, 4, 5, 6]);\n+    let mut cursor = m.cursor_front_mut();\n+    cursor.move_prev();\n+    cursor.insert_before(9);\n+    cursor.insert_after(10);\n+    check_links(&m);\n+    assert_eq!(m.iter().cloned().collect::<Vec<_>>(), &[10, 7, 1, 8, 2, 3, 4, 5, 6, 9]);\n+    let mut cursor = m.cursor_front_mut();\n+    cursor.move_prev();\n+    assert_eq!(cursor.remove_current(), None);\n+    cursor.move_next();\n+    cursor.move_next();\n+    assert_eq!(cursor.remove_current(), Some(7));\n+    cursor.move_prev();\n+    cursor.move_prev();\n+    cursor.move_prev();\n+    assert_eq!(cursor.remove_current(), Some(9));\n+    cursor.move_next();\n+    assert_eq!(cursor.remove_current(), Some(10));\n+    check_links(&m);\n+    assert_eq!(m.iter().cloned().collect::<Vec<_>>(), &[1, 8, 2, 3, 4, 5, 6]);\n+    let mut cursor = m.cursor_front_mut();\n+    let mut p: LinkedList<u32> = LinkedList::new();\n+    p.extend(&[100, 101, 102, 103]);\n+    let mut q: LinkedList<u32> = LinkedList::new();\n+    q.extend(&[200, 201, 202, 203]);\n+    cursor.splice_after(p);\n+    cursor.splice_before(q);\n+    check_links(&m);\n+    assert_eq!(\n+        m.iter().cloned().collect::<Vec<_>>(),\n+        &[200, 201, 202, 203, 1, 100, 101, 102, 103, 8, 2, 3, 4, 5, 6]\n+    );\n+    let mut cursor = m.cursor_front_mut();\n+    cursor.move_prev();\n+    let tmp = cursor.split_before();\n+    assert_eq!(m.into_iter().collect::<Vec<_>>(), &[]);\n+    m = tmp;\n+    let mut cursor = m.cursor_front_mut();\n+    cursor.move_next();\n+    cursor.move_next();\n+    cursor.move_next();\n+    cursor.move_next();\n+    cursor.move_next();\n+    cursor.move_next();\n+    let tmp = cursor.split_after();\n+    assert_eq!(tmp.into_iter().collect::<Vec<_>>(), &[102, 103, 8, 2, 3, 4, 5, 6]);\n+    check_links(&m);\n+    assert_eq!(m.iter().cloned().collect::<Vec<_>>(), &[200, 201, 202, 203, 1, 100, 101]);\n+}"}, {"sha": "b176e0f6e2a6890b59ccbf2b484eb2aa634fc7d3", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -565,9 +565,19 @@ impl<T: ?Sized> Rc<T> {\n     /// ```\n     #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n     pub fn into_raw(this: Self) -> *const T {\n-        let ptr: *const T = &*this;\n+        let ptr: *mut RcBox<T> = NonNull::as_ptr(this.ptr);\n+        let fake_ptr = ptr as *mut T;\n         mem::forget(this);\n-        ptr\n+\n+        // SAFETY: This cannot go through Deref::deref.\n+        // Instead, we manually offset the pointer rather than manifesting a reference.\n+        // This is so that the returned pointer retains the same provenance as our pointer.\n+        // This is required so that e.g. `get_mut` can write through the pointer\n+        // after the Rc is recovered through `from_raw`.\n+        unsafe {\n+            let offset = data_offset(&(*ptr).value);\n+            set_data_ptr(fake_ptr, (ptr as *mut u8).offset(offset))\n+        }\n     }\n \n     /// Constructs an `Rc` from a raw pointer."}, {"sha": "4aa0190b149c108fc35af8f9c897b1908e9b73ac", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -545,9 +545,19 @@ impl<T: ?Sized> Arc<T> {\n     /// ```\n     #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n     pub fn into_raw(this: Self) -> *const T {\n-        let ptr: *const T = &*this;\n+        let ptr: *mut ArcInner<T> = NonNull::as_ptr(this.ptr);\n+        let fake_ptr = ptr as *mut T;\n         mem::forget(this);\n-        ptr\n+\n+        // SAFETY: This cannot go through Deref::deref.\n+        // Instead, we manually offset the pointer rather than manifesting a reference.\n+        // This is so that the returned pointer retains the same provenance as our pointer.\n+        // This is required so that e.g. `get_mut` can write through the pointer\n+        // after the Arc is recovered through `from_raw`.\n+        unsafe {\n+            let offset = data_offset(&(*ptr).data);\n+            set_data_ptr(fake_ptr, (ptr as *mut u8).offset(offset))\n+        }\n     }\n \n     /// Constructs an `Arc` from a raw pointer."}, {"sha": "f5be72c39b20c68356cfab215c554ffe29a4bf1a", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 150, "deletions": 31, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -4,6 +4,7 @@ use std::convert::TryFrom;\n use std::fmt::Debug;\n use std::iter::FromIterator;\n use std::ops::Bound::{self, Excluded, Included, Unbounded};\n+use std::ops::RangeBounds;\n use std::rc::Rc;\n \n use super::DeterministicRng;\n@@ -68,6 +69,11 @@ fn test_basic_small() {\n     assert_eq!(map.last_key_value(), None);\n     assert_eq!(map.keys().count(), 0);\n     assert_eq!(map.values().count(), 0);\n+    assert_eq!(map.range(..).next(), None);\n+    assert_eq!(map.range(..1).next(), None);\n+    assert_eq!(map.range(1..).next(), None);\n+    assert_eq!(map.range(1..=1).next(), None);\n+    assert_eq!(map.range(1..2).next(), None);\n     assert_eq!(map.insert(1, 1), None);\n \n     // 1 key-value pair:\n@@ -118,6 +124,11 @@ fn test_basic_small() {\n     assert_eq!(map.last_key_value(), None);\n     assert_eq!(map.keys().count(), 0);\n     assert_eq!(map.values().count(), 0);\n+    assert_eq!(map.range(..).next(), None);\n+    assert_eq!(map.range(..1).next(), None);\n+    assert_eq!(map.range(1..).next(), None);\n+    assert_eq!(map.range(1..=1).next(), None);\n+    assert_eq!(map.range(1..2).next(), None);\n     assert_eq!(map.remove(&1), None);\n }\n \n@@ -128,7 +139,6 @@ fn test_iter() {\n     #[cfg(miri)]\n     let size = 200;\n \n-    // Forwards\n     let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n     fn test<T>(size: usize, mut iter: T)\n@@ -154,7 +164,6 @@ fn test_iter_rev() {\n     #[cfg(miri)]\n     let size = 200;\n \n-    // Forwards\n     let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n     fn test<T>(size: usize, mut iter: T)\n@@ -275,7 +284,6 @@ fn test_iter_mixed() {\n     #[cfg(miri)]\n     let size = 200;\n \n-    // Forwards\n     let mut map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n \n     fn test<T>(size: usize, mut iter: T)\n@@ -299,27 +307,147 @@ fn test_iter_mixed() {\n     test(size, map.into_iter());\n }\n \n-#[test]\n-fn test_range_small() {\n-    let size = 5;\n-\n-    // Forwards\n-    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n-\n-    let mut j = 0;\n-    for ((&k, &v), i) in map.range(2..).zip(2..size) {\n-        assert_eq!(k, i);\n-        assert_eq!(v, i);\n-        j += 1;\n-    }\n-    assert_eq!(j, size - 2);\n+fn range_keys(map: &BTreeMap<i32, i32>, range: impl RangeBounds<i32>) -> Vec<i32> {\n+    map.range(range)\n+        .map(|(&k, &v)| {\n+            assert_eq!(k, v);\n+            k\n+        })\n+        .collect()\n }\n \n #[test]\n-fn test_range_inclusive() {\n-    let size = 500;\n+fn test_range_small() {\n+    let size = 4;\n+\n+    let map: BTreeMap<_, _> = (1..=size).map(|i| (i, i)).collect();\n+    let all: Vec<_> = (1..=size).collect();\n+    let (first, last) = (vec![all[0]], vec![all[size as usize - 1]]);\n+\n+    assert_eq!(range_keys(&map, (Excluded(0), Excluded(size + 1))), all);\n+    assert_eq!(range_keys(&map, (Excluded(0), Included(size + 1))), all);\n+    assert_eq!(range_keys(&map, (Excluded(0), Included(size))), all);\n+    assert_eq!(range_keys(&map, (Excluded(0), Unbounded)), all);\n+    assert_eq!(range_keys(&map, (Included(0), Excluded(size + 1))), all);\n+    assert_eq!(range_keys(&map, (Included(0), Included(size + 1))), all);\n+    assert_eq!(range_keys(&map, (Included(0), Included(size))), all);\n+    assert_eq!(range_keys(&map, (Included(0), Unbounded)), all);\n+    assert_eq!(range_keys(&map, (Included(1), Excluded(size + 1))), all);\n+    assert_eq!(range_keys(&map, (Included(1), Included(size + 1))), all);\n+    assert_eq!(range_keys(&map, (Included(1), Included(size))), all);\n+    assert_eq!(range_keys(&map, (Included(1), Unbounded)), all);\n+    assert_eq!(range_keys(&map, (Unbounded, Excluded(size + 1))), all);\n+    assert_eq!(range_keys(&map, (Unbounded, Included(size + 1))), all);\n+    assert_eq!(range_keys(&map, (Unbounded, Included(size))), all);\n+    assert_eq!(range_keys(&map, ..), all);\n+\n+    assert_eq!(range_keys(&map, (Excluded(0), Excluded(1))), vec![]);\n+    assert_eq!(range_keys(&map, (Excluded(0), Included(0))), vec![]);\n+    assert_eq!(range_keys(&map, (Included(0), Included(0))), vec![]);\n+    assert_eq!(range_keys(&map, (Included(0), Excluded(1))), vec![]);\n+    assert_eq!(range_keys(&map, (Unbounded, Excluded(1))), vec![]);\n+    assert_eq!(range_keys(&map, (Unbounded, Included(0))), vec![]);\n+    assert_eq!(range_keys(&map, (Excluded(0), Excluded(2))), first);\n+    assert_eq!(range_keys(&map, (Excluded(0), Included(1))), first);\n+    assert_eq!(range_keys(&map, (Included(0), Excluded(2))), first);\n+    assert_eq!(range_keys(&map, (Included(0), Included(1))), first);\n+    assert_eq!(range_keys(&map, (Included(1), Excluded(2))), first);\n+    assert_eq!(range_keys(&map, (Included(1), Included(1))), first);\n+    assert_eq!(range_keys(&map, (Unbounded, Excluded(2))), first);\n+    assert_eq!(range_keys(&map, (Unbounded, Included(1))), first);\n+    assert_eq!(range_keys(&map, (Excluded(size - 1), Excluded(size + 1))), last);\n+    assert_eq!(range_keys(&map, (Excluded(size - 1), Included(size + 1))), last);\n+    assert_eq!(range_keys(&map, (Excluded(size - 1), Included(size))), last);\n+    assert_eq!(range_keys(&map, (Excluded(size - 1), Unbounded)), last);\n+    assert_eq!(range_keys(&map, (Included(size), Excluded(size + 1))), last);\n+    assert_eq!(range_keys(&map, (Included(size), Included(size + 1))), last);\n+    assert_eq!(range_keys(&map, (Included(size), Included(size))), last);\n+    assert_eq!(range_keys(&map, (Included(size), Unbounded)), last);\n+    assert_eq!(range_keys(&map, (Excluded(size), Excluded(size + 1))), vec![]);\n+    assert_eq!(range_keys(&map, (Excluded(size), Included(size))), vec![]);\n+    assert_eq!(range_keys(&map, (Excluded(size), Unbounded)), vec![]);\n+    assert_eq!(range_keys(&map, (Included(size + 1), Excluded(size + 1))), vec![]);\n+    assert_eq!(range_keys(&map, (Included(size + 1), Included(size + 1))), vec![]);\n+    assert_eq!(range_keys(&map, (Included(size + 1), Unbounded)), vec![]);\n+\n+    assert_eq!(range_keys(&map, ..3), vec![1, 2]);\n+    assert_eq!(range_keys(&map, 3..), vec![3, 4]);\n+    assert_eq!(range_keys(&map, 2..=3), vec![2, 3]);\n+}\n+\n+#[test]\n+fn test_range_depth_2() {\n+    // Assuming that node.CAPACITY is 11, having 12 pairs implies a depth 2 tree\n+    // with 2 leaves. Depending on details we don't want or need to rely upon,\n+    // the single key at the root will be 6 or 7.\n+\n+    let map: BTreeMap<_, _> = (1..=12).map(|i| (i, i)).collect();\n+    for &root in &[6, 7] {\n+        assert_eq!(range_keys(&map, (Excluded(root), Excluded(root + 1))), vec![]);\n+        assert_eq!(range_keys(&map, (Excluded(root), Included(root + 1))), vec![root + 1]);\n+        assert_eq!(range_keys(&map, (Included(root), Excluded(root + 1))), vec![root]);\n+        assert_eq!(range_keys(&map, (Included(root), Included(root + 1))), vec![root, root + 1]);\n+\n+        assert_eq!(range_keys(&map, (Excluded(root - 1), Excluded(root))), vec![]);\n+        assert_eq!(range_keys(&map, (Included(root - 1), Excluded(root))), vec![root - 1]);\n+        assert_eq!(range_keys(&map, (Excluded(root - 1), Included(root))), vec![root]);\n+        assert_eq!(range_keys(&map, (Included(root - 1), Included(root))), vec![root - 1, root]);\n+    }\n+}\n+\n+#[test]\n+fn test_range_large() {\n+    let size = 200;\n \n-    let map: BTreeMap<_, _> = (0..=size).map(|i| (i, i)).collect();\n+    let map: BTreeMap<_, _> = (1..=size).map(|i| (i, i)).collect();\n+    let all: Vec<_> = (1..=size).collect();\n+    let (first, last) = (vec![all[0]], vec![all[size as usize - 1]]);\n+\n+    assert_eq!(range_keys(&map, (Excluded(0), Excluded(size + 1))), all);\n+    assert_eq!(range_keys(&map, (Excluded(0), Included(size + 1))), all);\n+    assert_eq!(range_keys(&map, (Excluded(0), Included(size))), all);\n+    assert_eq!(range_keys(&map, (Excluded(0), Unbounded)), all);\n+    assert_eq!(range_keys(&map, (Included(0), Excluded(size + 1))), all);\n+    assert_eq!(range_keys(&map, (Included(0), Included(size + 1))), all);\n+    assert_eq!(range_keys(&map, (Included(0), Included(size))), all);\n+    assert_eq!(range_keys(&map, (Included(0), Unbounded)), all);\n+    assert_eq!(range_keys(&map, (Included(1), Excluded(size + 1))), all);\n+    assert_eq!(range_keys(&map, (Included(1), Included(size + 1))), all);\n+    assert_eq!(range_keys(&map, (Included(1), Included(size))), all);\n+    assert_eq!(range_keys(&map, (Included(1), Unbounded)), all);\n+    assert_eq!(range_keys(&map, (Unbounded, Excluded(size + 1))), all);\n+    assert_eq!(range_keys(&map, (Unbounded, Included(size + 1))), all);\n+    assert_eq!(range_keys(&map, (Unbounded, Included(size))), all);\n+    assert_eq!(range_keys(&map, ..), all);\n+\n+    assert_eq!(range_keys(&map, (Excluded(0), Excluded(1))), vec![]);\n+    assert_eq!(range_keys(&map, (Excluded(0), Included(0))), vec![]);\n+    assert_eq!(range_keys(&map, (Included(0), Included(0))), vec![]);\n+    assert_eq!(range_keys(&map, (Included(0), Excluded(1))), vec![]);\n+    assert_eq!(range_keys(&map, (Unbounded, Excluded(1))), vec![]);\n+    assert_eq!(range_keys(&map, (Unbounded, Included(0))), vec![]);\n+    assert_eq!(range_keys(&map, (Excluded(0), Excluded(2))), first);\n+    assert_eq!(range_keys(&map, (Excluded(0), Included(1))), first);\n+    assert_eq!(range_keys(&map, (Included(0), Excluded(2))), first);\n+    assert_eq!(range_keys(&map, (Included(0), Included(1))), first);\n+    assert_eq!(range_keys(&map, (Included(1), Excluded(2))), first);\n+    assert_eq!(range_keys(&map, (Included(1), Included(1))), first);\n+    assert_eq!(range_keys(&map, (Unbounded, Excluded(2))), first);\n+    assert_eq!(range_keys(&map, (Unbounded, Included(1))), first);\n+    assert_eq!(range_keys(&map, (Excluded(size - 1), Excluded(size + 1))), last);\n+    assert_eq!(range_keys(&map, (Excluded(size - 1), Included(size + 1))), last);\n+    assert_eq!(range_keys(&map, (Excluded(size - 1), Included(size))), last);\n+    assert_eq!(range_keys(&map, (Excluded(size - 1), Unbounded)), last);\n+    assert_eq!(range_keys(&map, (Included(size), Excluded(size + 1))), last);\n+    assert_eq!(range_keys(&map, (Included(size), Included(size + 1))), last);\n+    assert_eq!(range_keys(&map, (Included(size), Included(size))), last);\n+    assert_eq!(range_keys(&map, (Included(size), Unbounded)), last);\n+    assert_eq!(range_keys(&map, (Excluded(size), Excluded(size + 1))), vec![]);\n+    assert_eq!(range_keys(&map, (Excluded(size), Included(size))), vec![]);\n+    assert_eq!(range_keys(&map, (Excluded(size), Unbounded)), vec![]);\n+    assert_eq!(range_keys(&map, (Included(size + 1), Excluded(size + 1))), vec![]);\n+    assert_eq!(range_keys(&map, (Included(size + 1), Included(size + 1))), vec![]);\n+    assert_eq!(range_keys(&map, (Included(size + 1), Unbounded)), vec![]);\n \n     fn check<'a, L, R>(lhs: L, rhs: R)\n     where\n@@ -331,18 +459,9 @@ fn test_range_inclusive() {\n         assert_eq!(lhs, rhs);\n     }\n \n-    check(map.range(size + 1..=size + 1), vec![]);\n-    check(map.range(size..=size), vec![(&size, &size)]);\n-    check(map.range(size..=size + 1), vec![(&size, &size)]);\n-    check(map.range(0..=0), vec![(&0, &0)]);\n-    check(map.range(0..=size - 1), map.range(..size));\n-    check(map.range(-1..=-1), vec![]);\n-    check(map.range(-1..=size), map.range(..));\n-    check(map.range(..=size), map.range(..));\n-    check(map.range(..=200), map.range(..201));\n+    check(map.range(..=100), map.range(..101));\n     check(map.range(5..=8), vec![(&5, &5), (&6, &6), (&7, &7), (&8, &8)]);\n-    check(map.range(-1..=0), vec![(&0, &0)]);\n-    check(map.range(-1..=2), vec![(&0, &0), (&1, &1), (&2, &2)]);\n+    check(map.range(-1..=2), vec![(&1, &1), (&2, &2)]);\n }\n \n #[test]"}, {"sha": "2a3d92edc4956dafc26936d82c8a506ff0e5029a", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 0, "deletions": 73, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -21,7 +21,6 @@\n extern crate alloc;\n \n use rustc_data_structures::cold_path;\n-use rustc_data_structures::sync::MTLock;\n use smallvec::SmallVec;\n \n use std::cell::{Cell, RefCell};\n@@ -116,11 +115,6 @@ impl<T> Default for TypedArena<T> {\n }\n \n impl<T> TypedArena<T> {\n-    pub fn in_arena(&self, ptr: *const T) -> bool {\n-        let ptr = ptr as *const T as *mut T;\n-\n-        self.chunks.borrow().iter().any(|chunk| chunk.start() <= ptr && ptr < chunk.end())\n-    }\n     /// Allocates an object in the `TypedArena`, returning a reference to it.\n     #[inline]\n     pub fn alloc(&self, object: T) -> &mut T {\n@@ -334,12 +328,6 @@ impl Default for DroplessArena {\n }\n \n impl DroplessArena {\n-    pub fn in_arena<T: ?Sized>(&self, ptr: *const T) -> bool {\n-        let ptr = ptr as *const u8 as *mut u8;\n-\n-        self.chunks.borrow().iter().any(|chunk| chunk.start() <= ptr && ptr < chunk.end())\n-    }\n-\n     #[inline]\n     fn align(&self, align: usize) {\n         let final_address = ((self.ptr.get() as usize) + align - 1) & !(align - 1);\n@@ -500,66 +488,5 @@ impl DroplessArena {\n     }\n }\n \n-#[derive(Default)]\n-// FIXME(@Zoxc): this type is entirely unused in rustc\n-pub struct SyncTypedArena<T> {\n-    lock: MTLock<TypedArena<T>>,\n-}\n-\n-impl<T> SyncTypedArena<T> {\n-    #[inline(always)]\n-    pub fn alloc(&self, object: T) -> &mut T {\n-        // Extend the lifetime of the result since it's limited to the lock guard\n-        unsafe { &mut *(self.lock.lock().alloc(object) as *mut T) }\n-    }\n-\n-    #[inline(always)]\n-    pub fn alloc_slice(&self, slice: &[T]) -> &mut [T]\n-    where\n-        T: Copy,\n-    {\n-        // Extend the lifetime of the result since it's limited to the lock guard\n-        unsafe { &mut *(self.lock.lock().alloc_slice(slice) as *mut [T]) }\n-    }\n-\n-    #[inline(always)]\n-    pub fn clear(&mut self) {\n-        self.lock.get_mut().clear();\n-    }\n-}\n-\n-#[derive(Default)]\n-pub struct SyncDroplessArena {\n-    lock: MTLock<DroplessArena>,\n-}\n-\n-impl SyncDroplessArena {\n-    #[inline(always)]\n-    pub fn in_arena<T: ?Sized>(&self, ptr: *const T) -> bool {\n-        self.lock.lock().in_arena(ptr)\n-    }\n-\n-    #[inline(always)]\n-    pub fn alloc_raw(&self, bytes: usize, align: usize) -> &mut [u8] {\n-        // Extend the lifetime of the result since it's limited to the lock guard\n-        unsafe { &mut *(self.lock.lock().alloc_raw(bytes, align) as *mut [u8]) }\n-    }\n-\n-    #[inline(always)]\n-    pub fn alloc<T>(&self, object: T) -> &mut T {\n-        // Extend the lifetime of the result since it's limited to the lock guard\n-        unsafe { &mut *(self.lock.lock().alloc(object) as *mut T) }\n-    }\n-\n-    #[inline(always)]\n-    pub fn alloc_slice<T>(&self, slice: &[T]) -> &mut [T]\n-    where\n-        T: Copy,\n-    {\n-        // Extend the lifetime of the result since it's limited to the lock guard\n-        unsafe { &mut *(self.lock.lock().alloc_slice(slice) as *mut [T]) }\n-    }\n-}\n-\n #[cfg(test)]\n mod tests;"}, {"sha": "af02e84d3fa537f5c7fdb1469e4d45ba29364f33", "filename": "src/libcore/any.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -476,11 +476,15 @@ pub const fn type_name<T: ?Sized>() -> &'static str {\n ///\n /// This is intended for diagnostic use. The exact contents and format of the\n /// string are not specified, other than being a best-effort description of the\n-/// type. For example, `type_name_of::<Option<String>>(None)` could return\n+/// type. For example, `type_name_of_val::<Option<String>>(None)` could return\n /// `\"Option<String>\"` or `\"std::option::Option<std::string::String>\"`, but not\n /// `\"foobar\"`. In addition, the output may change between versions of the\n /// compiler.\n ///\n+/// This function does not resolve trait objects,\n+/// meaning that `type_name_of_val(&7u32 as &dyn Debug)`\n+/// may return `\"dyn Debug\"`, but not `\"u32\"`.\n+///\n /// The type name should not be considered a unique identifier of a type;\n /// multiple types may share the same type name.\n ///"}, {"sha": "e7eecf7540ad74121d4a0c840536afff154a98e5", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -187,8 +187,6 @@\n //! ```\n //!\n \n-// ignore-tidy-undocumented-unsafe\n-\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::cmp::Ordering;\n@@ -368,6 +366,10 @@ impl<T> Cell<T> {\n         if ptr::eq(self, other) {\n             return;\n         }\n+        // SAFETY: This can be risky if called from separate threads, but `Cell`\n+        // is `!Sync` so this won't happen. This also won't invalidate any\n+        // pointers since `Cell` makes sure nothing else will be pointing into\n+        // either of these `Cell`s.\n         unsafe {\n             ptr::swap(self.value.get(), other.value.get());\n         }\n@@ -387,6 +389,8 @@ impl<T> Cell<T> {\n     /// ```\n     #[stable(feature = \"move_cell\", since = \"1.17.0\")]\n     pub fn replace(&self, val: T) -> T {\n+        // SAFETY: This can cause data races if called from a separate thread,\n+        // but `Cell` is `!Sync` so this won't happen.\n         mem::replace(unsafe { &mut *self.value.get() }, val)\n     }\n \n@@ -423,6 +427,8 @@ impl<T: Copy> Cell<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get(&self) -> T {\n+        // SAFETY: This can cause data races if called from a separate thread,\n+        // but `Cell` is `!Sync` so this won't happen.\n         unsafe { *self.value.get() }\n     }\n \n@@ -491,6 +497,9 @@ impl<T: ?Sized> Cell<T> {\n     #[inline]\n     #[stable(feature = \"cell_get_mut\", since = \"1.11.0\")]\n     pub fn get_mut(&mut self) -> &mut T {\n+        // SAFETY: This can cause data races if called from a separate thread,\n+        // but `Cell` is `!Sync` so this won't happen, and `&mut` guarantees\n+        // unique access.\n         unsafe { &mut *self.value.get() }\n     }\n \n@@ -510,6 +519,7 @@ impl<T: ?Sized> Cell<T> {\n     #[inline]\n     #[stable(feature = \"as_cell\", since = \"1.37.0\")]\n     pub fn from_mut(t: &mut T) -> &Cell<T> {\n+        // SAFETY: `&mut` ensures unique access.\n         unsafe { &*(t as *mut T as *const Cell<T>) }\n     }\n }\n@@ -553,6 +563,7 @@ impl<T> Cell<[T]> {\n     /// ```\n     #[stable(feature = \"as_cell\", since = \"1.37.0\")]\n     pub fn as_slice_of_cells(&self) -> &[Cell<T>] {\n+        // SAFETY: `Cell<T>` has the same memory layout as `T`.\n         unsafe { &*(self as *const Cell<[T]> as *const [Cell<T>]) }\n     }\n }\n@@ -816,6 +827,8 @@ impl<T: ?Sized> RefCell<T> {\n     #[inline]\n     pub fn try_borrow(&self) -> Result<Ref<'_, T>, BorrowError> {\n         match BorrowRef::new(&self.borrow) {\n+            // SAFETY: `BorrowRef` ensures that there is only immutable access\n+            // to the value while borrowed.\n             Some(b) => Ok(Ref { value: unsafe { &*self.value.get() }, borrow: b }),\n             None => Err(BorrowError { _private: () }),\n         }\n@@ -891,6 +904,7 @@ impl<T: ?Sized> RefCell<T> {\n     #[inline]\n     pub fn try_borrow_mut(&self) -> Result<RefMut<'_, T>, BorrowMutError> {\n         match BorrowRefMut::new(&self.borrow) {\n+            // SAFETY: `BorrowRef` guarantees unique access.\n             Some(b) => Ok(RefMut { value: unsafe { &mut *self.value.get() }, borrow: b }),\n             None => Err(BorrowMutError { _private: () }),\n         }\n@@ -940,6 +954,7 @@ impl<T: ?Sized> RefCell<T> {\n     #[inline]\n     #[stable(feature = \"cell_get_mut\", since = \"1.11.0\")]\n     pub fn get_mut(&mut self) -> &mut T {\n+        // SAFETY: `&mut` guarantees unique access.\n         unsafe { &mut *self.value.get() }\n     }\n "}, {"sha": "c341bb552a1eaf4c4dc89b4a1246abfaad2bed66", "filename": "src/libcore/char/methods.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -3,7 +3,7 @@\n use crate::slice;\n use crate::str::from_utf8_unchecked_mut;\n use crate::unicode::printable::is_printable;\n-use crate::unicode::tables::{conversions, derived_property, general_category, property};\n+use crate::unicode::{self, conversions};\n \n use super::*;\n \n@@ -552,7 +552,7 @@ impl char {\n     pub fn is_alphabetic(self) -> bool {\n         match self {\n             'a'..='z' | 'A'..='Z' => true,\n-            c => c > '\\x7f' && derived_property::Alphabetic(c),\n+            c => c > '\\x7f' && unicode::Alphabetic(c),\n         }\n     }\n \n@@ -583,7 +583,7 @@ impl char {\n     pub fn is_lowercase(self) -> bool {\n         match self {\n             'a'..='z' => true,\n-            c => c > '\\x7f' && derived_property::Lowercase(c),\n+            c => c > '\\x7f' && unicode::Lowercase(c),\n         }\n     }\n \n@@ -614,7 +614,7 @@ impl char {\n     pub fn is_uppercase(self) -> bool {\n         match self {\n             'A'..='Z' => true,\n-            c => c > '\\x7f' && derived_property::Uppercase(c),\n+            c => c > '\\x7f' && unicode::Uppercase(c),\n         }\n     }\n \n@@ -642,7 +642,7 @@ impl char {\n     pub fn is_whitespace(self) -> bool {\n         match self {\n             ' ' | '\\x09'..='\\x0d' => true,\n-            c => c > '\\x7f' && property::White_Space(c),\n+            c => c > '\\x7f' && unicode::White_Space(c),\n         }\n     }\n \n@@ -693,7 +693,7 @@ impl char {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn is_control(self) -> bool {\n-        general_category::Cc(self)\n+        unicode::Cc(self)\n     }\n \n     /// Returns `true` if this `char` has the `Grapheme_Extend` property.\n@@ -707,7 +707,7 @@ impl char {\n     /// [`DerivedCoreProperties.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/DerivedCoreProperties.txt\n     #[inline]\n     pub(crate) fn is_grapheme_extended(self) -> bool {\n-        derived_property::Grapheme_Extend(self)\n+        unicode::Grapheme_Extend(self)\n     }\n \n     /// Returns `true` if this `char` has one of the general categories for numbers.\n@@ -739,7 +739,7 @@ impl char {\n     pub fn is_numeric(self) -> bool {\n         match self {\n             '0'..='9' => true,\n-            c => c > '\\x7f' && general_category::N(c),\n+            c => c > '\\x7f' && unicode::N(c),\n         }\n     }\n "}, {"sha": "cf5576e549cdfa043ad0b9ea24b238178f19272d", "filename": "src/libcore/char/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibcore%2Fchar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibcore%2Fchar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmod.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -37,9 +37,9 @@ pub use self::decode::{decode_utf16, DecodeUtf16, DecodeUtf16Error};\n \n // unstable re-exports\n #[unstable(feature = \"unicode_version\", issue = \"49726\")]\n-pub use crate::unicode::tables::UNICODE_VERSION;\n-#[unstable(feature = \"unicode_version\", issue = \"49726\")]\n pub use crate::unicode::version::UnicodeVersion;\n+#[unstable(feature = \"unicode_version\", issue = \"49726\")]\n+pub use crate::unicode::UNICODE_VERSION;\n \n use crate::fmt::{self, Write};\n use crate::iter::FusedIterator;"}, {"sha": "dd0f3ccb15841721ca16c28c1288b3e13baccf21", "filename": "src/libcore/fmt/builders.rs", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibcore%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibcore%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fbuilders.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -159,6 +159,62 @@ impl<'a, 'b: 'a> DebugStruct<'a, 'b> {\n         self\n     }\n \n+    /// Marks the struct as non-exhaustive, indicating to the reader that there are some other\n+    /// fields that are not shown in the debug representation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(debug_non_exhaustive)]\n+    /// use std::fmt;\n+    ///\n+    /// struct Bar {\n+    ///     bar: i32,\n+    ///     hidden: f32,\n+    /// }\n+    ///\n+    /// impl fmt::Debug for Bar {\n+    ///     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+    ///         fmt.debug_struct(\"Bar\")\n+    ///            .field(\"bar\", &self.bar)\n+    ///            .finish_non_exhaustive() // Show that some other field(s) exist.\n+    ///     }\n+    /// }\n+    ///\n+    /// assert_eq!(\n+    ///     format!(\"{:?}\", Bar { bar: 10, hidden: 1.0 }),\n+    ///     \"Bar { bar: 10, .. }\",\n+    /// );\n+    /// ```\n+    #[unstable(feature = \"debug_non_exhaustive\", issue = \"67364\")]\n+    pub fn finish_non_exhaustive(&mut self) -> fmt::Result {\n+        self.result = self.result.and_then(|_| {\n+            // Draw non-exhaustive dots (`..`), and open brace if necessary (no fields).\n+            if self.is_pretty() {\n+                if !self.has_fields {\n+                    self.fmt.write_str(\" {\\n\")?;\n+                }\n+                let mut slot = None;\n+                let mut state = Default::default();\n+                let mut writer = PadAdapter::wrap(&mut self.fmt, &mut slot, &mut state);\n+                writer.write_str(\"..\\n\")?;\n+            } else {\n+                if self.has_fields {\n+                    self.fmt.write_str(\", ..\")?;\n+                } else {\n+                    self.fmt.write_str(\" { ..\")?;\n+                }\n+            }\n+            if self.is_pretty() {\n+                self.fmt.write_str(\"}\")?\n+            } else {\n+                self.fmt.write_str(\" }\")?;\n+            }\n+            Ok(())\n+        });\n+        self.result\n+    }\n+\n     /// Finishes output and returns any error encountered.\n     ///\n     /// # Examples"}, {"sha": "e68f3c58a3e07769aedfe787b866d3d1b1733a03", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1244,12 +1244,15 @@ impl<'a> Formatter<'a> {\n             // The sign and prefix goes before the padding if the fill character\n             // is zero\n             Some(min) if self.sign_aware_zero_pad() => {\n-                self.fill = '0';\n-                self.align = rt::v1::Alignment::Right;\n+                let old_fill = crate::mem::replace(&mut self.fill, '0');\n+                let old_align = crate::mem::replace(&mut self.align, rt::v1::Alignment::Right);\n                 write_prefix(self, sign, prefix)?;\n                 let post_padding = self.padding(min - width, rt::v1::Alignment::Right)?;\n                 self.buf.write_str(buf)?;\n-                post_padding.write(self.buf)\n+                post_padding.write(self.buf)?;\n+                self.fill = old_fill;\n+                self.align = old_align;\n+                Ok(())\n             }\n             // Otherwise, the sign and prefix goes after the padding\n             Some(min) => {"}, {"sha": "25dfc573e416abd38a0a9c3e23ae12812e2566b9", "filename": "src/libcore/iter/sources.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibcore%2Fiter%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibcore%2Fiter%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fsources.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -208,6 +208,11 @@ pub fn repeat_with<A, F: FnMut() -> A>(repeater: F) -> RepeatWith<F> {\n #[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n pub struct Empty<T>(marker::PhantomData<T>);\n \n+#[stable(feature = \"iter_empty_send_sync\", since = \"1.42.0\")]\n+unsafe impl<T> Send for Empty<T> {}\n+#[stable(feature = \"iter_empty_send_sync\", since = \"1.42.0\")]\n+unsafe impl<T> Sync for Empty<T> {}\n+\n #[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n impl<T> fmt::Debug for Empty<T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {"}, {"sha": "f77b4d7461e74a164f6df4982150c2854f1f5742", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -44,7 +44,7 @@\n // Here we explicitly #[cfg]-out this whole crate when testing. If we don't do\n // this, both the generated test artifact and the linked libtest (which\n // transitively includes libcore) will both define the same set of lang items,\n-// and this will cause the E0152 \"duplicate lang item found\" error. See\n+// and this will cause the E0152 \"found duplicate lang item\" error. See\n // discussion in #50466 for details.\n //\n // This cfg won't affect doc tests.\n@@ -133,7 +133,7 @@\n #![feature(associated_type_bounds)]\n #![feature(const_type_id)]\n #![feature(const_caller_location)]\n-#![feature(slice_patterns)]\n+#![cfg_attr(bootstrap, feature(slice_patterns))]\n \n #[prelude_import]\n #[allow(unused)]"}, {"sha": "88b2bc551b7d1138e136ff4cf49d95ea63d3e804", "filename": "src/libcore/str/lossy.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibcore%2Fstr%2Flossy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibcore%2Fstr%2Flossy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Flossy.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -3,8 +3,6 @@ use crate::fmt::{self, Write};\n use crate::mem;\n use crate::str as core_str;\n \n-// ignore-tidy-undocumented-unsafe\n-\n /// Lossy UTF-8 string.\n #[unstable(feature = \"str_internals\", issue = \"none\")]\n pub struct Utf8Lossy {\n@@ -17,6 +15,7 @@ impl Utf8Lossy {\n     }\n \n     pub fn from_bytes(bytes: &[u8]) -> &Utf8Lossy {\n+        // SAFETY: Both use the same memory layout, and UTF-8 correctness isn't required.\n         unsafe { mem::transmute(bytes) }\n     }\n \n@@ -60,6 +59,8 @@ impl<'a> Iterator for Utf8LossyChunksIter<'a> {\n         while i < self.source.len() {\n             let i_ = i;\n \n+            // SAFETY: `i` starts at `0`, is less than `self.source.len()`, and\n+            // only increases, so `0 <= i < self.source.len()`.\n             let byte = unsafe { *self.source.get_unchecked(i) };\n             i += 1;\n \n@@ -69,6 +70,7 @@ impl<'a> Iterator for Utf8LossyChunksIter<'a> {\n \n                 macro_rules! error {\n                     () => {{\n+                        // SAFETY: We have checked up to `i` that source is valid UTF-8.\n                         unsafe {\n                             let r = Utf8LossyChunk {\n                                 valid: core_str::from_utf8_unchecked(&self.source[0..i_]),\n@@ -130,6 +132,7 @@ impl<'a> Iterator for Utf8LossyChunksIter<'a> {\n         }\n \n         let r = Utf8LossyChunk {\n+            // SAFETY: We have checked that the entire source is valid UTF-8.\n             valid: unsafe { core_str::from_utf8_unchecked(self.source) },\n             broken: &[],\n         };"}, {"sha": "5a7cddd4041d500200ec22071f1b176ab46bce30", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 43, "deletions": 26, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,5 +1,4 @@\n // ignore-tidy-filelength\n-// ignore-tidy-undocumented-unsafe\n \n //! String manipulation.\n //!\n@@ -341,6 +340,7 @@ impl Utf8Error {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> {\n     run_utf8_validation(v)?;\n+    // SAFETY: Just ran validation.\n     Ok(unsafe { from_utf8_unchecked(v) })\n }\n \n@@ -379,6 +379,7 @@ pub fn from_utf8(v: &[u8]) -> Result<&str, Utf8Error> {\n #[stable(feature = \"str_mut_extras\", since = \"1.20.0\")]\n pub fn from_utf8_mut(v: &mut [u8]) -> Result<&mut str, Utf8Error> {\n     run_utf8_validation(v)?;\n+    // SAFETY: Just ran validation.\n     Ok(unsafe { from_utf8_unchecked_mut(v) })\n }\n \n@@ -581,7 +582,7 @@ impl<'a> Iterator for Chars<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<char> {\n         next_code_point(&mut self.iter).map(|ch| {\n-            // str invariant says `ch` is a valid Unicode Scalar Value\n+            // SAFETY: `str` invariant says `ch` is a valid Unicode Scalar Value.\n             unsafe { char::from_u32_unchecked(ch) }\n         })\n     }\n@@ -628,7 +629,7 @@ impl<'a> DoubleEndedIterator for Chars<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<char> {\n         next_code_point_reverse(&mut self.iter).map(|ch| {\n-            // str invariant says `ch` is a valid Unicode Scalar Value\n+            // SAFETY: `str` invariant says `ch` is a valid Unicode Scalar Value.\n             unsafe { char::from_u32_unchecked(ch) }\n         })\n     }\n@@ -658,6 +659,7 @@ impl<'a> Chars<'a> {\n     #[stable(feature = \"iter_to_slice\", since = \"1.4.0\")]\n     #[inline]\n     pub fn as_str(&self) -> &'a str {\n+        // SAFETY: `Chars` is only made from a str, which guarantees the iter is valid UTF-8.\n         unsafe { from_utf8_unchecked(self.iter.as_slice()) }\n     }\n }\n@@ -1102,6 +1104,7 @@ impl<'a, P: Pattern<'a>> SplitInternal<'a, P> {\n     fn get_end(&mut self) -> Option<&'a str> {\n         if !self.finished && (self.allow_trailing_empty || self.end - self.start > 0) {\n             self.finished = true;\n+            // SAFETY: `self.start` and `self.end` always lie on unicode boundaries.\n             unsafe {\n                 let string = self.matcher.haystack().get_unchecked(self.start..self.end);\n                 Some(string)\n@@ -1119,6 +1122,7 @@ impl<'a, P: Pattern<'a>> SplitInternal<'a, P> {\n \n         let haystack = self.matcher.haystack();\n         match self.matcher.next_match() {\n+            // SAFETY: `Searcher` guarantees that `a` and `b` lie on unicode boundaries.\n             Some((a, b)) => unsafe {\n                 let elt = haystack.get_unchecked(self.start..a);\n                 self.start = b;\n@@ -1151,11 +1155,13 @@ impl<'a, P: Pattern<'a>> SplitInternal<'a, P> {\n \n         let haystack = self.matcher.haystack();\n         match self.matcher.next_match_back() {\n+            // SAFETY: `Searcher` guarantees that `a` and `b` lie on unicode boundaries.\n             Some((a, b)) => unsafe {\n                 let elt = haystack.get_unchecked(b..self.end);\n                 self.end = a;\n                 Some(elt)\n             },\n+            // SAFETY: `self.start` and `self.end` always lie on unicode boundaries.\n             None => unsafe {\n                 self.finished = true;\n                 Some(haystack.get_unchecked(self.start..self.end))\n@@ -1297,6 +1303,7 @@ impl<'a, P: Pattern<'a>> MatchIndicesInternal<'a, P> {\n     fn next(&mut self) -> Option<(usize, &'a str)> {\n         self.0\n             .next_match()\n+            // SAFETY: `Searcher` guarantees that `start` and `end` lie on unicode boundaries.\n             .map(|(start, end)| unsafe { (start, self.0.haystack().get_unchecked(start..end)) })\n     }\n \n@@ -1307,6 +1314,7 @@ impl<'a, P: Pattern<'a>> MatchIndicesInternal<'a, P> {\n     {\n         self.0\n             .next_match_back()\n+            // SAFETY: `Searcher` guarantees that `start` and `end` lie on unicode boundaries.\n             .map(|(start, end)| unsafe { (start, self.0.haystack().get_unchecked(start..end)) })\n     }\n }\n@@ -1348,6 +1356,7 @@ where\n impl<'a, P: Pattern<'a>> MatchesInternal<'a, P> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a str> {\n+        // SAFETY: `Searcher` guarantees that `start` and `end` lie on unicode boundaries.\n         self.0.next_match().map(|(a, b)| unsafe {\n             // Indices are known to be on utf8 boundaries\n             self.0.haystack().get_unchecked(a..b)\n@@ -1359,6 +1368,7 @@ impl<'a, P: Pattern<'a>> MatchesInternal<'a, P> {\n     where\n         P::Searcher: ReverseSearcher<'a>,\n     {\n+        // SAFETY: `Searcher` guarantees that `start` and `end` lie on unicode boundaries.\n         self.0.next_match_back().map(|(a, b)| unsafe {\n             // Indices are known to be on utf8 boundaries\n             self.0.haystack().get_unchecked(a..b)\n@@ -1579,6 +1589,10 @@ fn run_utf8_validation(v: &[u8]) -> Result<(), Utf8Error> {\n             if align != usize::max_value() && align.wrapping_sub(index) % usize_bytes == 0 {\n                 let ptr = v.as_ptr();\n                 while index < blocks_end {\n+                    // SAFETY: since `align - index` and `ascii_block_size` are\n+                    // multiples of `usize_bytes`, `block = ptr.add(index)` is\n+                    // always aligned with a `usize` so it's safe to dereference\n+                    // both `block` and `block.offset(1)`.\n                     unsafe {\n                         let block = ptr.add(index) as *const usize;\n                         // break if there is a nonascii byte\n@@ -1804,6 +1818,7 @@ mod traits {\n                 && slice.is_char_boundary(self.start)\n                 && slice.is_char_boundary(self.end)\n             {\n+                // SAFETY: just checked that `start` and `end` are on a char boundary.\n                 Some(unsafe { self.get_unchecked(slice) })\n             } else {\n                 None\n@@ -1815,6 +1830,7 @@ mod traits {\n                 && slice.is_char_boundary(self.start)\n                 && slice.is_char_boundary(self.end)\n             {\n+                // SAFETY: just checked that `start` and `end` are on a char boundary.\n                 Some(unsafe { self.get_unchecked_mut(slice) })\n             } else {\n                 None\n@@ -1845,6 +1861,7 @@ mod traits {\n                 && slice.is_char_boundary(self.start)\n                 && slice.is_char_boundary(self.end)\n             {\n+                // SAFETY: just checked that `start` and `end` are on a char boundary.\n                 unsafe { self.get_unchecked_mut(slice) }\n             } else {\n                 super::slice_error_fail(slice, self.start, self.end)\n@@ -1873,6 +1890,7 @@ mod traits {\n         #[inline]\n         fn get(self, slice: &str) -> Option<&Self::Output> {\n             if slice.is_char_boundary(self.end) {\n+                // SAFETY: just checked that `end` is on a char boundary.\n                 Some(unsafe { self.get_unchecked(slice) })\n             } else {\n                 None\n@@ -1881,6 +1899,7 @@ mod traits {\n         #[inline]\n         fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n             if slice.is_char_boundary(self.end) {\n+                // SAFETY: just checked that `end` is on a char boundary.\n                 Some(unsafe { self.get_unchecked_mut(slice) })\n             } else {\n                 None\n@@ -1903,8 +1922,8 @@ mod traits {\n         }\n         #[inline]\n         fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n-            // is_char_boundary checks that the index is in [0, .len()]\n             if slice.is_char_boundary(self.end) {\n+                // SAFETY: just checked that `end` is on a char boundary.\n                 unsafe { self.get_unchecked_mut(slice) }\n             } else {\n                 super::slice_error_fail(slice, 0, self.end)\n@@ -1934,6 +1953,7 @@ mod traits {\n         #[inline]\n         fn get(self, slice: &str) -> Option<&Self::Output> {\n             if slice.is_char_boundary(self.start) {\n+                // SAFETY: just checked that `start` is on a char boundary.\n                 Some(unsafe { self.get_unchecked(slice) })\n             } else {\n                 None\n@@ -1942,6 +1962,7 @@ mod traits {\n         #[inline]\n         fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n             if slice.is_char_boundary(self.start) {\n+                // SAFETY: just checked that `start` is on a char boundary.\n                 Some(unsafe { self.get_unchecked_mut(slice) })\n             } else {\n                 None\n@@ -1966,8 +1987,8 @@ mod traits {\n         }\n         #[inline]\n         fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n-            // is_char_boundary checks that the index is in [0, .len()]\n             if slice.is_char_boundary(self.start) {\n+                // SAFETY: just checked that `start` is on a char boundary.\n                 unsafe { self.get_unchecked_mut(slice) }\n             } else {\n                 super::slice_error_fail(slice, self.start, slice.len())\n@@ -2238,7 +2259,6 @@ impl str {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_stable(feature = \"str_as_bytes\", since = \"1.32.0\")]\n     #[inline(always)]\n-    // SAFETY: const sound because we transmute two types with the same layout\n     #[allow(unused_attributes)]\n     #[allow_internal_unstable(const_fn_union)]\n     pub const fn as_bytes(&self) -> &[u8] {\n@@ -2247,6 +2267,7 @@ impl str {\n             str: &'a str,\n             slice: &'a [u8],\n         }\n+        // SAFETY: const sound because we transmute two types with the same layout\n         unsafe { Slices { str: self }.slice }\n     }\n \n@@ -2573,6 +2594,7 @@ impl str {\n     pub fn split_at(&self, mid: usize) -> (&str, &str) {\n         // is_char_boundary checks that the index is in [0, .len()]\n         if self.is_char_boundary(mid) {\n+            // SAFETY: just checked that `mid` is on a char boundary.\n             unsafe { (self.get_unchecked(0..mid), self.get_unchecked(mid..self.len())) }\n         } else {\n             slice_error_fail(self, 0, mid)\n@@ -2617,6 +2639,7 @@ impl str {\n         if self.is_char_boundary(mid) {\n             let len = self.len();\n             let ptr = self.as_mut_ptr();\n+            // SAFETY: just checked that `mid` is on a char boundary.\n             unsafe {\n                 (\n                     from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr, mid)),\n@@ -3805,10 +3828,8 @@ impl str {\n         if let Some((_, b)) = matcher.next_reject_back() {\n             j = b;\n         }\n-        unsafe {\n-            // Searcher is known to return valid indices\n-            self.get_unchecked(i..j)\n-        }\n+        // SAFETY: `Searcher` is known to return valid indices.\n+        unsafe { self.get_unchecked(i..j) }\n     }\n \n     /// Returns a string slice with all prefixes that match a pattern\n@@ -3844,10 +3865,8 @@ impl str {\n         if let Some((a, _)) = matcher.next_reject() {\n             i = a;\n         }\n-        unsafe {\n-            // Searcher is known to return valid indices\n-            self.get_unchecked(i..self.len())\n-        }\n+        // SAFETY: `Searcher` is known to return valid indices.\n+        unsafe { self.get_unchecked(i..self.len()) }\n     }\n \n     /// Returns a string slice with the prefix removed.\n@@ -3878,10 +3897,8 @@ impl str {\n                 \"The first search step from Searcher \\\n                 must include the first character\"\n             );\n-            unsafe {\n-                // Searcher is known to return valid indices.\n-                Some(self.get_unchecked(len..))\n-            }\n+            // SAFETY: `Searcher` is known to return valid indices.\n+            unsafe { Some(self.get_unchecked(len..)) }\n         } else {\n             None\n         }\n@@ -3919,10 +3936,8 @@ impl str {\n                 \"The first search step from ReverseSearcher \\\n                 must include the last character\"\n             );\n-            unsafe {\n-                // Searcher is known to return valid indices.\n-                Some(self.get_unchecked(..start))\n-            }\n+            // SAFETY: `Searcher` is known to return valid indices.\n+            unsafe { Some(self.get_unchecked(..start)) }\n         } else {\n             None\n         }\n@@ -3970,10 +3985,8 @@ impl str {\n         if let Some((_, b)) = matcher.next_reject_back() {\n             j = b;\n         }\n-        unsafe {\n-            // Searcher is known to return valid indices\n-            self.get_unchecked(0..j)\n-        }\n+        // SAFETY: `Searcher` is known to return valid indices.\n+        unsafe { self.get_unchecked(0..j) }\n     }\n \n     /// Returns a string slice with all prefixes that match a pattern\n@@ -4166,6 +4179,7 @@ impl str {\n     /// ```\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     pub fn make_ascii_uppercase(&mut self) {\n+        // SAFETY: safe because we transmute two types with the same layout.\n         let me = unsafe { self.as_bytes_mut() };\n         me.make_ascii_uppercase()\n     }\n@@ -4191,6 +4205,7 @@ impl str {\n     /// ```\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n     pub fn make_ascii_lowercase(&mut self) {\n+        // SAFETY: safe because we transmute two types with the same layout.\n         let me = unsafe { self.as_bytes_mut() };\n         me.make_ascii_lowercase()\n     }\n@@ -4357,6 +4372,7 @@ impl Default for &str {\n impl Default for &mut str {\n     /// Creates an empty mutable str\n     fn default() -> Self {\n+        // SAFETY: The empty string is valid UTF-8.\n         unsafe { from_utf8_unchecked_mut(&mut []) }\n     }\n }\n@@ -4412,6 +4428,7 @@ impl_fn_for_zst! {\n \n     #[derive(Clone)]\n     struct UnsafeBytesToStr impl<'a> Fn = |bytes: &'a [u8]| -> &'a str {\n+        // SAFETY: not safe\n         unsafe { from_utf8_unchecked(bytes) }\n     };\n }"}, {"sha": "ef64d8b0fdf8880883ee168c22a5e0164c72fea7", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -3,8 +3,6 @@\n //! For more details, see the traits [`Pattern`], [`Searcher`],\n //! [`ReverseSearcher`], and [`DoubleEndedSearcher`].\n \n-// ignore-tidy-undocumented-unsafe\n-\n #![unstable(\n     feature = \"pattern\",\n     reason = \"API not fully fleshed out and ready to be stabilized\",\n@@ -271,6 +269,14 @@ unsafe impl<'a> Searcher<'a> for CharSearcher<'a> {\n     #[inline]\n     fn next(&mut self) -> SearchStep {\n         let old_finger = self.finger;\n+        // SAFETY: 1-4 guarantee safety of `get_unchecked`\n+        // 1. `self.finger` and `self.finger_back` are kept on unicode boundaries\n+        //    (this is invariant)\n+        // 2. `self.finger >= 0` since it starts at 0 and only increases\n+        // 3. `self.finger < self.finger_back` because otherwise the char `iter`\n+        //    would return `SearchStep::Done`\n+        // 4. `self.finger` comes before the end of the haystack because `self.finger_back`\n+        //    starts at the end and only decreases\n         let slice = unsafe { self.haystack.get_unchecked(old_finger..self.finger_back) };\n         let mut iter = slice.chars();\n         let old_len = iter.iter.len();\n@@ -293,6 +299,7 @@ unsafe impl<'a> Searcher<'a> for CharSearcher<'a> {\n             // get the haystack after the last character found\n             let bytes = self.haystack.as_bytes().get(self.finger..self.finger_back)?;\n             // the last byte of the utf8 encoded needle\n+            // SAFETY: we have an invariant that `utf8_size < 5`\n             let last_byte = unsafe { *self.utf8_encoded.get_unchecked(self.utf8_size - 1) };\n             if let Some(index) = memchr::memchr(last_byte, bytes) {\n                 // The new finger is the index of the byte we found,\n@@ -336,6 +343,7 @@ unsafe impl<'a> ReverseSearcher<'a> for CharSearcher<'a> {\n     #[inline]\n     fn next_back(&mut self) -> SearchStep {\n         let old_finger = self.finger_back;\n+        // SAFETY: see the comment for next() above\n         let slice = unsafe { self.haystack.get_unchecked(self.finger..old_finger) };\n         let mut iter = slice.chars();\n         let old_len = iter.iter.len();\n@@ -363,6 +371,7 @@ unsafe impl<'a> ReverseSearcher<'a> for CharSearcher<'a> {\n                 return None;\n             };\n             // the last byte of the utf8 encoded needle\n+            // SAFETY: we have an invariant that `utf8_size < 5`\n             let last_byte = unsafe { *self.utf8_encoded.get_unchecked(self.utf8_size - 1) };\n             if let Some(index) = memchr::memrchr(last_byte, bytes) {\n                 // we searched a slice that was offset by self.finger,"}, {"sha": "9d449bb9915071e3453af165045684d205cbacc9", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -112,8 +112,6 @@\n //! println!(\"live threads: {}\", old_thread_count + 1);\n //! ```\n \n-// ignore-tidy-undocumented-unsafe\n-\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![cfg_attr(not(target_has_atomic_load_store = \"8\"), allow(dead_code))]\n #![cfg_attr(not(target_has_atomic_load_store = \"8\"), allow(unused_imports))]\n@@ -350,6 +348,7 @@ impl AtomicBool {\n     #[inline]\n     #[stable(feature = \"atomic_access\", since = \"1.15.0\")]\n     pub fn get_mut(&mut self) -> &mut bool {\n+        // SAFETY: the mutable reference guarantees unique ownership.\n         unsafe { &mut *(self.v.get() as *mut bool) }\n     }\n \n@@ -400,6 +399,8 @@ impl AtomicBool {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn load(&self, order: Ordering) -> bool {\n+        // SAFETY: any data races are prevented by atomic intrinsics and the raw\n+        // pointer passed in is valid because we got it from a reference.\n         unsafe { atomic_load(self.v.get(), order) != 0 }\n     }\n \n@@ -432,6 +433,8 @@ impl AtomicBool {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn store(&self, val: bool, order: Ordering) {\n+        // SAFETY: any data races are prevented by atomic intrinsics and the raw\n+        // pointer passed in is valid because we got it from a reference.\n         unsafe {\n             atomic_store(self.v.get(), val as u8, order);\n         }\n@@ -463,6 +466,7 @@ impl AtomicBool {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[cfg(target_has_atomic = \"8\")]\n     pub fn swap(&self, val: bool, order: Ordering) -> bool {\n+        // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe { atomic_swap(self.v.get(), val as u8, order) != 0 }\n     }\n \n@@ -558,6 +562,7 @@ impl AtomicBool {\n         success: Ordering,\n         failure: Ordering,\n     ) -> Result<bool, bool> {\n+        // SAFETY: data races are prevented by atomic intrinsics.\n         match unsafe {\n             atomic_compare_exchange(self.v.get(), current as u8, new as u8, success, failure)\n         } {\n@@ -615,6 +620,7 @@ impl AtomicBool {\n         success: Ordering,\n         failure: Ordering,\n     ) -> Result<bool, bool> {\n+        // SAFETY: data races are prevented by atomic intrinsics.\n         match unsafe {\n             atomic_compare_exchange_weak(self.v.get(), current as u8, new as u8, success, failure)\n         } {\n@@ -661,6 +667,7 @@ impl AtomicBool {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[cfg(target_has_atomic = \"8\")]\n     pub fn fetch_and(&self, val: bool, order: Ordering) -> bool {\n+        // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe { atomic_and(self.v.get(), val as u8, order) != 0 }\n     }\n \n@@ -756,6 +763,7 @@ impl AtomicBool {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[cfg(target_has_atomic = \"8\")]\n     pub fn fetch_or(&self, val: bool, order: Ordering) -> bool {\n+        // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe { atomic_or(self.v.get(), val as u8, order) != 0 }\n     }\n \n@@ -797,6 +805,7 @@ impl AtomicBool {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[cfg(target_has_atomic = \"8\")]\n     pub fn fetch_xor(&self, val: bool, order: Ordering) -> bool {\n+        // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe { atomic_xor(self.v.get(), val as u8, order) != 0 }\n     }\n \n@@ -872,6 +881,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[stable(feature = \"atomic_access\", since = \"1.15.0\")]\n     pub fn get_mut(&mut self) -> &mut *mut T {\n+        // SAFETY: the mutable reference guarantees unique ownership.\n         unsafe { &mut *self.p.get() }\n     }\n \n@@ -923,6 +933,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn load(&self, order: Ordering) -> *mut T {\n+        // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe { atomic_load(self.p.get() as *mut usize, order) as *mut T }\n     }\n \n@@ -957,6 +968,7 @@ impl<T> AtomicPtr<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn store(&self, ptr: *mut T, order: Ordering) {\n+        // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe {\n             atomic_store(self.p.get() as *mut usize, ptr as usize, order);\n         }\n@@ -990,6 +1002,7 @@ impl<T> AtomicPtr<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[cfg(target_has_atomic = \"ptr\")]\n     pub fn swap(&self, ptr: *mut T, order: Ordering) -> *mut T {\n+        // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe { atomic_swap(self.p.get() as *mut usize, ptr as usize, order) as *mut T }\n     }\n \n@@ -1074,6 +1087,7 @@ impl<T> AtomicPtr<T> {\n         success: Ordering,\n         failure: Ordering,\n     ) -> Result<*mut T, *mut T> {\n+        // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe {\n             let res = atomic_compare_exchange(\n                 self.p.get() as *mut usize,\n@@ -1137,6 +1151,7 @@ impl<T> AtomicPtr<T> {\n         success: Ordering,\n         failure: Ordering,\n     ) -> Result<*mut T, *mut T> {\n+        // SAFETY: data races are prevented by atomic intrinsics.\n         unsafe {\n             let res = atomic_compare_exchange_weak(\n                 self.p.get() as *mut usize,\n@@ -1290,6 +1305,7 @@ assert_eq!(some_var.load(Ordering::SeqCst), 5);\n                 #[inline]\n                 #[$stable_access]\n                 pub fn get_mut(&mut self) -> &mut $int_type {\n+                    // SAFETY: the mutable reference guarantees unique ownership.\n                     unsafe { &mut *self.v.get() }\n                 }\n             }\n@@ -1344,6 +1360,7 @@ assert_eq!(some_var.load(Ordering::Relaxed), 5);\n                 #[inline]\n                 #[$stable]\n                 pub fn load(&self, order: Ordering) -> $int_type {\n+                    // SAFETY: data races are prevented by atomic intrinsics.\n                     unsafe { atomic_load(self.v.get(), order) }\n                 }\n             }\n@@ -1378,6 +1395,7 @@ assert_eq!(some_var.load(Ordering::Relaxed), 10);\n                 #[inline]\n                 #[$stable]\n                 pub fn store(&self, val: $int_type, order: Ordering) {\n+                    // SAFETY: data races are prevented by atomic intrinsics.\n                     unsafe { atomic_store(self.v.get(), val, order); }\n                 }\n             }\n@@ -1408,6 +1426,7 @@ assert_eq!(some_var.swap(10, Ordering::Relaxed), 5);\n                 #[$stable]\n                 #[$cfg_cas]\n                 pub fn swap(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    // SAFETY: data races are prevented by atomic intrinsics.\n                     unsafe { atomic_swap(self.v.get(), val, order) }\n                 }\n             }\n@@ -1510,6 +1529,7 @@ assert_eq!(some_var.load(Ordering::Relaxed), 10);\n                                         new: $int_type,\n                                         success: Ordering,\n                                         failure: Ordering) -> Result<$int_type, $int_type> {\n+                    // SAFETY: data races are prevented by atomic intrinsics.\n                     unsafe { atomic_compare_exchange(self.v.get(), current, new, success, failure) }\n                 }\n             }\n@@ -1562,6 +1582,7 @@ loop {\n                                              new: $int_type,\n                                              success: Ordering,\n                                              failure: Ordering) -> Result<$int_type, $int_type> {\n+                    // SAFETY: data races are prevented by atomic intrinsics.\n                     unsafe {\n                         atomic_compare_exchange_weak(self.v.get(), current, new, success, failure)\n                     }\n@@ -1596,6 +1617,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 10);\n                 #[$stable]\n                 #[$cfg_cas]\n                 pub fn fetch_add(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    // SAFETY: data races are prevented by atomic intrinsics.\n                     unsafe { atomic_add(self.v.get(), val, order) }\n                 }\n             }\n@@ -1628,6 +1650,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 10);\n                 #[$stable]\n                 #[$cfg_cas]\n                 pub fn fetch_sub(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    // SAFETY: data races are prevented by atomic intrinsics.\n                     unsafe { atomic_sub(self.v.get(), val, order) }\n                 }\n             }\n@@ -1663,6 +1686,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 0b100001);\n                 #[$stable]\n                 #[$cfg_cas]\n                 pub fn fetch_and(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    // SAFETY: data races are prevented by atomic intrinsics.\n                     unsafe { atomic_and(self.v.get(), val, order) }\n                 }\n             }\n@@ -1699,6 +1723,7 @@ assert_eq!(foo.load(Ordering::SeqCst), !(0x13 & 0x31));\n                 #[$stable_nand]\n                 #[$cfg_cas]\n                 pub fn fetch_nand(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    // SAFETY: data races are prevented by atomic intrinsics.\n                     unsafe { atomic_nand(self.v.get(), val, order) }\n                 }\n             }\n@@ -1734,6 +1759,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 0b111111);\n                 #[$stable]\n                 #[$cfg_cas]\n                 pub fn fetch_or(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    // SAFETY: data races are prevented by atomic intrinsics.\n                     unsafe { atomic_or(self.v.get(), val, order) }\n                 }\n             }\n@@ -1769,6 +1795,7 @@ assert_eq!(foo.load(Ordering::SeqCst), 0b011110);\n                 #[$stable]\n                 #[$cfg_cas]\n                 pub fn fetch_xor(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    // SAFETY: data races are prevented by atomic intrinsics.\n                     unsafe { atomic_xor(self.v.get(), val, order) }\n                 }\n             }\n@@ -1880,6 +1907,7 @@ assert!(max_foo == 42);\n                        issue = \"48655\")]\n                 #[$cfg_cas]\n                 pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    // SAFETY: data races are prevented by atomic intrinsics.\n                     unsafe { $max_fn(self.v.get(), val, order) }\n                 }\n             }\n@@ -1932,6 +1960,7 @@ assert_eq!(min_foo, 12);\n                        issue = \"48655\")]\n                 #[$cfg_cas]\n                 pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {\n+                    // SAFETY: data races are prevented by atomic intrinsics.\n                     unsafe { $min_fn(self.v.get(), val, order) }\n                 }\n             }\n@@ -1960,7 +1989,9 @@ extern {\n }\n \n let mut atomic = \", stringify!($atomic_type), \"::new(1);\n-unsafe {\n+\",\n+// SAFETY: Safe as long as `my_atomic_op` is atomic.\n+\"unsafe {\n     my_atomic_op(atomic.as_mut_ptr());\n }\n # }\n@@ -2526,6 +2557,7 @@ pub fn fence(order: Ordering) {\n     // https://github.com/WebAssembly/tool-conventions/issues/59. We should\n     // follow that discussion and implement a solution when one comes about!\n     #[cfg(not(target_arch = \"wasm32\"))]\n+    // SAFETY: using an atomic fence is safe.\n     unsafe {\n         match order {\n             Acquire => intrinsics::atomic_fence_acq(),\n@@ -2613,6 +2645,7 @@ pub fn fence(order: Ordering) {\n #[inline]\n #[stable(feature = \"compiler_fences\", since = \"1.21.0\")]\n pub fn compiler_fence(order: Ordering) {\n+    // SAFETY: using an atomic fence is safe.\n     unsafe {\n         match order {\n             Acquire => intrinsics::atomic_singlethreadfence_acq(),"}, {"sha": "129c121e8ceac0f5cd0974a9b15832a14445c5a2", "filename": "src/libcore/tests/fmt/builders.rs", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibcore%2Ftests%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibcore%2Ftests%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ffmt%2Fbuilders.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -89,6 +89,91 @@ mod debug_struct {\n         baz: 10/20,\n     },\n     hello: \\\"world\\\",\n+}\",\n+            format!(\"{:#?}\", Bar)\n+        );\n+    }\n+\n+    #[test]\n+    fn test_only_non_exhaustive() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                fmt.debug_struct(\"Foo\").finish_non_exhaustive()\n+            }\n+        }\n+\n+        assert_eq!(\"Foo { .. }\", format!(\"{:?}\", Foo));\n+        assert_eq!(\n+            \"Foo {\n+    ..\n+}\",\n+            format!(\"{:#?}\", Foo)\n+        );\n+    }\n+\n+    #[test]\n+    fn test_multiple_and_non_exhaustive() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                fmt.debug_struct(\"Foo\")\n+                    .field(\"bar\", &true)\n+                    .field(\"baz\", &format_args!(\"{}/{}\", 10, 20))\n+                    .finish_non_exhaustive()\n+            }\n+        }\n+\n+        assert_eq!(\"Foo { bar: true, baz: 10/20, .. }\", format!(\"{:?}\", Foo));\n+        assert_eq!(\n+            \"Foo {\n+    bar: true,\n+    baz: 10/20,\n+    ..\n+}\",\n+            format!(\"{:#?}\", Foo)\n+        );\n+    }\n+\n+    #[test]\n+    fn test_nested_non_exhaustive() {\n+        struct Foo;\n+\n+        impl fmt::Debug for Foo {\n+            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                fmt.debug_struct(\"Foo\")\n+                    .field(\"bar\", &true)\n+                    .field(\"baz\", &format_args!(\"{}/{}\", 10, 20))\n+                    .finish_non_exhaustive()\n+            }\n+        }\n+\n+        struct Bar;\n+\n+        impl fmt::Debug for Bar {\n+            fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                fmt.debug_struct(\"Bar\")\n+                    .field(\"foo\", &Foo)\n+                    .field(\"hello\", &\"world\")\n+                    .finish_non_exhaustive()\n+            }\n+        }\n+\n+        assert_eq!(\n+            \"Bar { foo: Foo { bar: true, baz: 10/20, .. }, hello: \\\"world\\\", .. }\",\n+            format!(\"{:?}\", Bar)\n+        );\n+        assert_eq!(\n+            \"Bar {\n+    foo: Foo {\n+        bar: true,\n+        baz: 10/20,\n+        ..\n+    },\n+    hello: \\\"world\\\",\n+    ..\n }\",\n             format!(\"{:#?}\", Bar)\n         );"}, {"sha": "7b281ce48e6aa4e102ea048daabaa53708b66080", "filename": "src/libcore/tests/fmt/mod.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibcore%2Ftests%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibcore%2Ftests%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ffmt%2Fmod.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -28,3 +28,18 @@ fn test_estimated_capacity() {\n     assert_eq!(format_args!(\"{}, hello!\", \"World\").estimated_capacity(), 0);\n     assert_eq!(format_args!(\"{}. 16-bytes piece\", \"World\").estimated_capacity(), 32);\n }\n+\n+#[test]\n+fn pad_integral_resets() {\n+    struct Bar;\n+\n+    impl core::fmt::Display for Bar {\n+        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n+            \"1\".fmt(f)?;\n+            f.pad_integral(true, \"\", \"5\")?;\n+            \"1\".fmt(f)\n+        }\n+    }\n+\n+    assert_eq!(format!(\"{:<03}\", Bar), \"1  0051  \");\n+}"}, {"sha": "f0420247acfbd0337ce7f3000bdc7c2127240dce", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -5,6 +5,7 @@\n #![feature(core_private_bignum)]\n #![feature(core_private_diy_float)]\n #![feature(debug_map_key_value)]\n+#![feature(debug_non_exhaustive)]\n #![feature(dec2flt)]\n #![feature(exact_size_is_empty)]\n #![feature(fixed_size_array)]\n@@ -18,7 +19,7 @@\n #![feature(range_is_empty)]\n #![feature(raw)]\n #![feature(saturating_neg)]\n-#![feature(slice_patterns)]\n+#![cfg_attr(bootstrap, feature(slice_patterns))]\n #![feature(sort_internals)]\n #![feature(slice_partition_at_index)]\n #![feature(specialization)]"}, {"sha": "b7fba88a540f9012dbc01efd9b5758d86e30709d", "filename": "src/libcore/unicode/bool_trie.rs", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/470cdf54ac9acee20ab8da46ef7899bae9f58f29/src%2Flibcore%2Funicode%2Fbool_trie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470cdf54ac9acee20ab8da46ef7899bae9f58f29/src%2Flibcore%2Funicode%2Fbool_trie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Fbool_trie.rs?ref=470cdf54ac9acee20ab8da46ef7899bae9f58f29", "patch": "@@ -1,66 +0,0 @@\n-/// BoolTrie is a trie for representing a set of Unicode codepoints. It is\n-/// implemented with postfix compression (sharing of identical child nodes),\n-/// which gives both compact size and fast lookup.\n-///\n-/// The space of Unicode codepoints is divided into 3 subareas, each\n-/// represented by a trie with different depth. In the first (0..0x800), there\n-/// is no trie structure at all; each u64 entry corresponds to a bitvector\n-/// effectively holding 64 bool values.\n-///\n-/// In the second (0x800..0x10000), each child of the root node represents a\n-/// 64-wide subrange, but instead of storing the full 64-bit value of the leaf,\n-/// the trie stores an 8-bit index into a shared table of leaf values. This\n-/// exploits the fact that in reasonable sets, many such leaves can be shared.\n-///\n-/// In the third (0x10000..0x110000), each child of the root node represents a\n-/// 4096-wide subrange, and the trie stores an 8-bit index into a 64-byte slice\n-/// of a child tree. Each of these 64 bytes represents an index into the table\n-/// of shared 64-bit leaf values. This exploits the sparse structure in the\n-/// non-BMP range of most Unicode sets.\n-pub struct BoolTrie {\n-    // 0..0x800 (corresponding to 1 and 2 byte utf-8 sequences)\n-    pub r1: [u64; 32], // leaves\n-\n-    // 0x800..0x10000 (corresponding to 3 byte utf-8 sequences)\n-    pub r2: [u8; 992],      // first level\n-    pub r3: &'static [u64], // leaves\n-\n-    // 0x10000..0x110000 (corresponding to 4 byte utf-8 sequences)\n-    pub r4: [u8; 256],      // first level\n-    pub r5: &'static [u8],  // second level\n-    pub r6: &'static [u64], // leaves\n-}\n-impl BoolTrie {\n-    pub fn lookup(&self, c: char) -> bool {\n-        let c = c as u32;\n-        if c < 0x800 {\n-            trie_range_leaf(c, self.r1[(c >> 6) as usize])\n-        } else if c < 0x10000 {\n-            let child = self.r2[(c >> 6) as usize - 0x20];\n-            trie_range_leaf(c, self.r3[child as usize])\n-        } else {\n-            let child = self.r4[(c >> 12) as usize - 0x10];\n-            let leaf = self.r5[((child as usize) << 6) + ((c >> 6) as usize & 0x3f)];\n-            trie_range_leaf(c, self.r6[leaf as usize])\n-        }\n-    }\n-}\n-\n-pub struct SmallBoolTrie {\n-    pub(crate) r1: &'static [u8],  // first level\n-    pub(crate) r2: &'static [u64], // leaves\n-}\n-\n-impl SmallBoolTrie {\n-    pub fn lookup(&self, c: char) -> bool {\n-        let c = c as u32;\n-        match self.r1.get((c >> 6) as usize) {\n-            Some(&child) => trie_range_leaf(c, self.r2[child as usize]),\n-            None => false,\n-        }\n-    }\n-}\n-\n-fn trie_range_leaf(c: u32, bitmap_chunk: u64) -> bool {\n-    ((bitmap_chunk >> (c & 63)) & 1) != 0\n-}"}, {"sha": "b6eaf06aa7f63be316f86ef76f26ffa0ba935def", "filename": "src/libcore/unicode/mod.rs", "status": "modified", "additions": 49, "deletions": 5, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibcore%2Funicode%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibcore%2Funicode%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Fmod.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,15 +1,59 @@\n #![unstable(feature = \"unicode_internals\", issue = \"none\")]\n #![allow(missing_docs)]\n \n-mod bool_trie;\n pub(crate) mod printable;\n-pub(crate) mod tables;\n+mod unicode_data;\n pub(crate) mod version;\n \n+use version::UnicodeVersion;\n+\n+/// The version of [Unicode](http://www.unicode.org/) that the Unicode parts of\n+/// `char` and `str` methods are based on.\n+#[unstable(feature = \"unicode_version\", issue = \"49726\")]\n+pub const UNICODE_VERSION: UnicodeVersion = UnicodeVersion {\n+    major: unicode_data::UNICODE_VERSION.0,\n+    minor: unicode_data::UNICODE_VERSION.1,\n+    micro: unicode_data::UNICODE_VERSION.2,\n+    _priv: (),\n+};\n+\n // For use in liballoc, not re-exported in libstd.\n pub mod derived_property {\n-    pub use crate::unicode::tables::derived_property::{Case_Ignorable, Cased};\n+    pub use super::{Case_Ignorable, Cased};\n }\n-pub mod conversions {\n-    pub use crate::unicode::tables::conversions::{to_lower, to_upper};\n+\n+pub use unicode_data::alphabetic::lookup as Alphabetic;\n+pub use unicode_data::case_ignorable::lookup as Case_Ignorable;\n+pub use unicode_data::cased::lookup as Cased;\n+pub use unicode_data::cc::lookup as Cc;\n+pub use unicode_data::conversions;\n+pub use unicode_data::grapheme_extend::lookup as Grapheme_Extend;\n+pub use unicode_data::lowercase::lookup as Lowercase;\n+pub use unicode_data::n::lookup as N;\n+pub use unicode_data::uppercase::lookup as Uppercase;\n+pub use unicode_data::white_space::lookup as White_Space;\n+\n+#[inline(always)]\n+fn range_search<const N: usize, const N1: usize, const N2: usize>(\n+    needle: u32,\n+    chunk_idx_map: &[u8; N],\n+    (last_chunk_idx, last_chunk_mapping): (u16, u8),\n+    bitset_chunk_idx: &[[u8; 16]; N1],\n+    bitset: &[u64; N2],\n+) -> bool {\n+    let bucket_idx = (needle / 64) as usize;\n+    let chunk_map_idx = bucket_idx / 16;\n+    let chunk_piece = bucket_idx % 16;\n+    let chunk_idx = if chunk_map_idx >= N {\n+        if chunk_map_idx == last_chunk_idx as usize {\n+            last_chunk_mapping\n+        } else {\n+            return false;\n+        }\n+    } else {\n+        chunk_idx_map[chunk_map_idx]\n+    };\n+    let idx = bitset_chunk_idx[(chunk_idx as usize)][chunk_piece];\n+    let word = bitset[(idx as usize)];\n+    (word & (1 << (needle % 64) as u64)) != 0\n }"}, {"sha": "3fa125e8fea15fc9921ce35af4660c76554f619c", "filename": "src/libcore/unicode/tables.rs", "status": "removed", "additions": 0, "deletions": 2235, "changes": 2235, "blob_url": "https://github.com/rust-lang/rust/blob/470cdf54ac9acee20ab8da46ef7899bae9f58f29/src%2Flibcore%2Funicode%2Ftables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470cdf54ac9acee20ab8da46ef7899bae9f58f29/src%2Flibcore%2Funicode%2Ftables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Ftables.rs?ref=470cdf54ac9acee20ab8da46ef7899bae9f58f29"}, {"sha": "97df92a56da66ea2b0527a35d4a5eb28f6457390", "filename": "src/libcore/unicode/unicode.py", "status": "removed", "additions": 0, "deletions": 878, "changes": 878, "blob_url": "https://github.com/rust-lang/rust/blob/470cdf54ac9acee20ab8da46ef7899bae9f58f29/src%2Flibcore%2Funicode%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/470cdf54ac9acee20ab8da46ef7899bae9f58f29/src%2Flibcore%2Funicode%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Funicode.py?ref=470cdf54ac9acee20ab8da46ef7899bae9f58f29", "patch": "@@ -1,878 +0,0 @@\n-#!/usr/bin/env python\n-\n-\"\"\"\n-Regenerate Unicode tables (tables.rs).\n-\"\"\"\n-\n-# This script uses the Unicode tables as defined\n-# in the UnicodeFiles class.\n-\n-# Since this should not require frequent updates, we just store this\n-# out-of-line and check the tables.rs file into git.\n-\n-# Note that the \"curl\" program is required for operation.\n-# This script is compatible with Python 2.7 and 3.x.\n-\n-import argparse\n-import datetime\n-import fileinput\n-import itertools\n-import os\n-import re\n-import textwrap\n-import subprocess\n-\n-from collections import defaultdict, namedtuple\n-\n-try:\n-    # Python 3\n-    from itertools import zip_longest\n-    from io import StringIO\n-except ImportError:\n-    # Python 2 compatibility\n-    zip_longest = itertools.izip_longest\n-    from StringIO import StringIO\n-\n-try:\n-    # Completely optional type hinting\n-    # (Python 2 compatible using comments,\n-    # see: https://mypy.readthedocs.io/en/latest/python2.html)\n-    # This is very helpful in typing-aware IDE like PyCharm.\n-    from typing import Any, Callable, Dict, Iterable, Iterator, List, Optional, Set, Tuple\n-except ImportError:\n-    pass\n-\n-\n-# We don't use enum.Enum because of Python 2.7 compatibility.\n-class UnicodeFiles(object):\n-    # ReadMe does not contain any Unicode data, we\n-    # only use it to extract versions.\n-    README = \"ReadMe.txt\"\n-\n-    DERIVED_CORE_PROPERTIES = \"DerivedCoreProperties.txt\"\n-    DERIVED_NORMALIZATION_PROPS = \"DerivedNormalizationProps.txt\"\n-    PROPS = \"PropList.txt\"\n-    SCRIPTS = \"Scripts.txt\"\n-    SPECIAL_CASING = \"SpecialCasing.txt\"\n-    UNICODE_DATA = \"UnicodeData.txt\"\n-\n-\n-# The order doesn't really matter (Python < 3.6 won't preserve it),\n-# we only want to aggregate all the file names.\n-ALL_UNICODE_FILES = tuple(\n-    value for name, value in UnicodeFiles.__dict__.items()\n-    if not name.startswith(\"_\")\n-)\n-\n-assert len(ALL_UNICODE_FILES) == 7, \"Unexpected number of unicode files\"\n-\n-# The directory this file is located in.\n-THIS_DIR = os.path.dirname(os.path.realpath(__file__))\n-\n-# Where to download the Unicode data.  The downloaded files\n-# will be placed in sub-directories named after Unicode version.\n-FETCH_DIR = os.path.join(THIS_DIR, \"downloaded\")\n-\n-FETCH_URL_LATEST = \"ftp://ftp.unicode.org/Public/UNIDATA/{filename}\"\n-FETCH_URL_VERSION = \"ftp://ftp.unicode.org/Public/{version}/ucd/{filename}\"\n-\n-PREAMBLE = \"\"\"\\\n-// NOTE: The following code was generated by \"./unicode.py\", do not edit directly\n-\n-#![allow(missing_docs, non_upper_case_globals, non_snake_case, clippy::unreadable_literal)]\n-\n-use crate::unicode::bool_trie::{{BoolTrie, SmallBoolTrie}};\n-use crate::unicode::version::UnicodeVersion;\n-\"\"\".format(year=datetime.datetime.now().year)\n-\n-# Mapping taken from Table 12 from:\n-# http://www.unicode.org/reports/tr44/#General_Category_Values\n-EXPANDED_CATEGORIES = {\n-    \"Lu\": [\"LC\", \"L\"], \"Ll\": [\"LC\", \"L\"], \"Lt\": [\"LC\", \"L\"],\n-    \"Lm\": [\"L\"], \"Lo\": [\"L\"],\n-    \"Mn\": [\"M\"], \"Mc\": [\"M\"], \"Me\": [\"M\"],\n-    \"Nd\": [\"N\"], \"Nl\": [\"N\"], \"No\": [\"N\"],\n-    \"Pc\": [\"P\"], \"Pd\": [\"P\"], \"Ps\": [\"P\"], \"Pe\": [\"P\"],\n-    \"Pi\": [\"P\"], \"Pf\": [\"P\"], \"Po\": [\"P\"],\n-    \"Sm\": [\"S\"], \"Sc\": [\"S\"], \"Sk\": [\"S\"], \"So\": [\"S\"],\n-    \"Zs\": [\"Z\"], \"Zl\": [\"Z\"], \"Zp\": [\"Z\"],\n-    \"Cc\": [\"C\"], \"Cf\": [\"C\"], \"Cs\": [\"C\"], \"Co\": [\"C\"], \"Cn\": [\"C\"],\n-}\n-\n-# This is the (inclusive) range of surrogate codepoints.\n-# These are not valid Rust characters.\n-SURROGATE_CODEPOINTS_RANGE = (0xd800, 0xdfff)\n-\n-UnicodeData = namedtuple(\n-    \"UnicodeData\", (\n-        # Conversions:\n-        \"to_upper\", \"to_lower\", \"to_title\",\n-\n-        # Decompositions: canonical decompositions, compatibility decomp\n-        \"canon_decomp\", \"compat_decomp\",\n-\n-        # Grouped: general categories and combining characters\n-        \"general_categories\", \"combines\",\n-    )\n-)\n-\n-UnicodeVersion = namedtuple(\n-    \"UnicodeVersion\", (\"major\", \"minor\", \"micro\", \"as_str\")\n-)\n-\n-\n-def fetch_files(version=None):\n-    # type: (str) -> UnicodeVersion\n-    \"\"\"\n-    Fetch all the Unicode files from unicode.org.\n-\n-    This will use cached files (stored in `FETCH_DIR`) if they exist,\n-    creating them if they don't.  In any case, the Unicode version\n-    is always returned.\n-\n-    :param version: The desired Unicode version, as string.\n-        (If None, defaults to latest final release available,\n-         querying the unicode.org service).\n-    \"\"\"\n-    have_version = check_stored_version(version)\n-    if have_version:\n-        return have_version\n-\n-    if version:\n-        # Check if the desired version exists on the server.\n-        get_fetch_url = lambda name: FETCH_URL_VERSION.format(version=version, filename=name)\n-    else:\n-        # Extract the latest version.\n-        get_fetch_url = lambda name: FETCH_URL_LATEST.format(filename=name)\n-\n-    readme_url = get_fetch_url(UnicodeFiles.README)\n-\n-    print(\"Fetching: {}\".format(readme_url))\n-    readme_content = subprocess.check_output((\"curl\", readme_url))\n-\n-    unicode_version = parse_readme_unicode_version(\n-        readme_content.decode(\"utf8\")\n-    )\n-\n-    download_dir = get_unicode_dir(unicode_version)\n-    if not os.path.exists(download_dir):\n-        # For 2.7 compat, we don't use `exist_ok=True`.\n-        os.makedirs(download_dir)\n-\n-    for filename in ALL_UNICODE_FILES:\n-        file_path = get_unicode_file_path(unicode_version, filename)\n-\n-        if os.path.exists(file_path):\n-            # Assume file on the server didn't change if it's been saved before.\n-            continue\n-\n-        if filename == UnicodeFiles.README:\n-            with open(file_path, \"wb\") as fd:\n-                fd.write(readme_content)\n-        else:\n-            url = get_fetch_url(filename)\n-            print(\"Fetching: {}\".format(url))\n-            subprocess.check_call((\"curl\", \"-o\", file_path, url))\n-\n-    return unicode_version\n-\n-\n-def check_stored_version(version):\n-    # type: (Optional[str]) -> Optional[UnicodeVersion]\n-    \"\"\"\n-    Given desired Unicode version, return the version\n-    if stored files are all present, and `None` otherwise.\n-    \"\"\"\n-    if not version:\n-        # If no desired version specified, we should check what's the latest\n-        # version, skipping stored version checks.\n-        return None\n-\n-    fetch_dir = os.path.join(FETCH_DIR, version)\n-\n-    for filename in ALL_UNICODE_FILES:\n-        file_path = os.path.join(fetch_dir, filename)\n-\n-        if not os.path.exists(file_path):\n-            return None\n-\n-    with open(os.path.join(fetch_dir, UnicodeFiles.README)) as fd:\n-        return parse_readme_unicode_version(fd.read())\n-\n-\n-def parse_readme_unicode_version(readme_content):\n-    # type: (str) -> UnicodeVersion\n-    \"\"\"\n-    Parse the Unicode version contained in their `ReadMe.txt` file.\n-    \"\"\"\n-    # \"Raw string\" is necessary for \\d not being treated as escape char\n-    # (for the sake of compat with future Python versions).\n-    # See: https://docs.python.org/3.6/whatsnew/3.6.html#deprecated-python-behavior\n-    pattern = r\"for Version (\\d+)\\.(\\d+)\\.(\\d+) of the Unicode\"\n-    groups = re.search(pattern, readme_content).groups()\n-\n-    return UnicodeVersion(*map(int, groups), as_str=\".\".join(groups))\n-\n-\n-def get_unicode_dir(unicode_version):\n-    # type: (UnicodeVersion) -> str\n-    \"\"\"\n-    Indicate in which parent dir the Unicode data files should be stored.\n-\n-    This returns a full, absolute path.\n-    \"\"\"\n-    return os.path.join(FETCH_DIR, unicode_version.as_str)\n-\n-\n-def get_unicode_file_path(unicode_version, filename):\n-    # type: (UnicodeVersion, str) -> str\n-    \"\"\"\n-    Indicate where the Unicode data file should be stored.\n-    \"\"\"\n-    return os.path.join(get_unicode_dir(unicode_version), filename)\n-\n-\n-def is_surrogate(n):\n-    # type: (int) -> bool\n-    \"\"\"\n-    Tell if given codepoint is a surrogate (not a valid Rust character).\n-    \"\"\"\n-    return SURROGATE_CODEPOINTS_RANGE[0] <= n <= SURROGATE_CODEPOINTS_RANGE[1]\n-\n-\n-def load_unicode_data(file_path):\n-    # type: (str) -> UnicodeData\n-    \"\"\"\n-    Load main Unicode data.\n-    \"\"\"\n-    # Conversions\n-    to_lower = {}   # type: Dict[int, Tuple[int, int, int]]\n-    to_upper = {}   # type: Dict[int, Tuple[int, int, int]]\n-    to_title = {}   # type: Dict[int, Tuple[int, int, int]]\n-\n-    # Decompositions\n-    compat_decomp = {}   # type: Dict[int, List[int]]\n-    canon_decomp = {}    # type: Dict[int, List[int]]\n-\n-    # Combining characters\n-    # FIXME: combines are not used\n-    combines = defaultdict(set)   # type: Dict[str, Set[int]]\n-\n-    # Categories\n-    general_categories = defaultdict(set)   # type: Dict[str, Set[int]]\n-    category_assigned_codepoints = set()    # type: Set[int]\n-\n-    all_codepoints = {}\n-\n-    range_start = -1\n-\n-    for line in fileinput.input(file_path):\n-        data = line.split(\";\")\n-        if len(data) != 15:\n-            continue\n-        codepoint = int(data[0], 16)\n-        if is_surrogate(codepoint):\n-            continue\n-        if range_start >= 0:\n-            for i in range(range_start, codepoint):\n-                all_codepoints[i] = data\n-            range_start = -1\n-        if data[1].endswith(\", First>\"):\n-            range_start = codepoint\n-            continue\n-        all_codepoints[codepoint] = data\n-\n-    for code, data in all_codepoints.items():\n-        (code_org, name, gencat, combine, bidi,\n-         decomp, deci, digit, num, mirror,\n-         old, iso, upcase, lowcase, titlecase) = data\n-\n-        # Generate char to char direct common and simple conversions:\n-\n-        # Uppercase to lowercase\n-        if lowcase != \"\" and code_org != lowcase:\n-            to_lower[code] = (int(lowcase, 16), 0, 0)\n-\n-        # Lowercase to uppercase\n-        if upcase != \"\" and code_org != upcase:\n-            to_upper[code] = (int(upcase, 16), 0, 0)\n-\n-        # Title case\n-        if titlecase.strip() != \"\" and code_org != titlecase:\n-            to_title[code] = (int(titlecase, 16), 0, 0)\n-\n-        # Store decomposition, if given\n-        if decomp:\n-            decompositions = decomp.split()[1:]\n-            decomp_code_points = [int(i, 16) for i in decompositions]\n-\n-            if decomp.startswith(\"<\"):\n-                # Compatibility decomposition\n-                compat_decomp[code] = decomp_code_points\n-            else:\n-                # Canonical decomposition\n-                canon_decomp[code] = decomp_code_points\n-\n-        # Place letter in categories as appropriate.\n-        for cat in itertools.chain((gencat, ), EXPANDED_CATEGORIES.get(gencat, [])):\n-            general_categories[cat].add(code)\n-            category_assigned_codepoints.add(code)\n-\n-        # Record combining class, if any.\n-        if combine != \"0\":\n-            combines[combine].add(code)\n-\n-    # Generate Not_Assigned from Assigned.\n-    general_categories[\"Cn\"] = get_unassigned_codepoints(category_assigned_codepoints)\n-\n-    # Other contains Not_Assigned\n-    general_categories[\"C\"].update(general_categories[\"Cn\"])\n-\n-    grouped_categories = group_categories(general_categories)\n-\n-    # FIXME: combines are not used\n-    return UnicodeData(\n-        to_lower=to_lower, to_upper=to_upper, to_title=to_title,\n-        compat_decomp=compat_decomp, canon_decomp=canon_decomp,\n-        general_categories=grouped_categories, combines=combines,\n-    )\n-\n-\n-def load_special_casing(file_path, unicode_data):\n-    # type: (str, UnicodeData) -> None\n-    \"\"\"\n-    Load special casing data and enrich given Unicode data.\n-    \"\"\"\n-    for line in fileinput.input(file_path):\n-        data = line.split(\"#\")[0].split(\";\")\n-        if len(data) == 5:\n-            code, lower, title, upper, _comment = data\n-        elif len(data) == 6:\n-            code, lower, title, upper, condition, _comment = data\n-            if condition.strip():  # Only keep unconditional mappins\n-                continue\n-        else:\n-            continue\n-        code = code.strip()\n-        lower = lower.strip()\n-        title = title.strip()\n-        upper = upper.strip()\n-        key = int(code, 16)\n-        for (map_, values) in ((unicode_data.to_lower, lower),\n-                               (unicode_data.to_upper, upper),\n-                               (unicode_data.to_title, title)):\n-            if values != code:\n-                split = values.split()\n-\n-                codepoints = list(itertools.chain(\n-                    (int(i, 16) for i in split),\n-                    (0 for _ in range(len(split), 3))\n-                ))\n-\n-                assert len(codepoints) == 3\n-                map_[key] = codepoints\n-\n-\n-def group_categories(mapping):\n-    # type: (Dict[Any, Iterable[int]]) -> Dict[str, List[Tuple[int, int]]]\n-    \"\"\"\n-    Group codepoints mapped in \"categories\".\n-    \"\"\"\n-    return {category: group_codepoints(codepoints)\n-            for category, codepoints in mapping.items()}\n-\n-\n-def group_codepoints(codepoints):\n-    # type: (Iterable[int]) -> List[Tuple[int, int]]\n-    \"\"\"\n-    Group integral values into continuous, disjoint value ranges.\n-\n-    Performs value deduplication.\n-\n-    :return: sorted list of pairs denoting start and end of codepoint\n-        group values, both ends inclusive.\n-\n-    >>> group_codepoints([1, 2, 10, 11, 12, 3, 4])\n-    [(1, 4), (10, 12)]\n-    >>> group_codepoints([1])\n-    [(1, 1)]\n-    >>> group_codepoints([1, 5, 6])\n-    [(1, 1), (5, 6)]\n-    >>> group_codepoints([])\n-    []\n-    \"\"\"\n-    sorted_codes = sorted(set(codepoints))\n-    result = []     # type: List[Tuple[int, int]]\n-\n-    if not sorted_codes:\n-        return result\n-\n-    next_codes = sorted_codes[1:]\n-    start_code = sorted_codes[0]\n-\n-    for code, next_code in zip_longest(sorted_codes, next_codes, fillvalue=None):\n-        if next_code is None or next_code - code != 1:\n-            result.append((start_code, code))\n-            start_code = next_code\n-\n-    return result\n-\n-\n-def ungroup_codepoints(codepoint_pairs):\n-    # type: (Iterable[Tuple[int, int]]) -> List[int]\n-    \"\"\"\n-    The inverse of group_codepoints -- produce a flat list of values\n-    from value range pairs.\n-\n-    >>> ungroup_codepoints([(1, 4), (10, 12)])\n-    [1, 2, 3, 4, 10, 11, 12]\n-    >>> ungroup_codepoints([(1, 1), (5, 6)])\n-    [1, 5, 6]\n-    >>> ungroup_codepoints(group_codepoints([1, 2, 7, 8]))\n-    [1, 2, 7, 8]\n-    >>> ungroup_codepoints([])\n-    []\n-    \"\"\"\n-    return list(itertools.chain.from_iterable(\n-        range(lo, hi + 1) for lo, hi in codepoint_pairs\n-    ))\n-\n-\n-def get_unassigned_codepoints(assigned_codepoints):\n-    # type: (Set[int]) -> Set[int]\n-    \"\"\"\n-    Given a set of \"assigned\" codepoints, return a set\n-    of these that are not in assigned and not surrogate.\n-    \"\"\"\n-    return {i for i in range(0, 0x110000)\n-            if i not in assigned_codepoints and not is_surrogate(i)}\n-\n-\n-def generate_table_lines(items, indent, wrap=98):\n-    # type: (Iterable[str], int, int) -> Iterator[str]\n-    \"\"\"\n-    Given table items, generate wrapped lines of text with comma-separated items.\n-\n-    This is a generator function.\n-\n-    :param wrap: soft wrap limit (characters per line), integer.\n-    \"\"\"\n-    line = \" \" * indent\n-    first = True\n-    for item in items:\n-        if len(line) + len(item) < wrap:\n-            if first:\n-                line += item\n-            else:\n-                line += \", \" + item\n-            first = False\n-        else:\n-            yield line + \",\\n\"\n-            line = \" \" * indent + item\n-\n-    yield line\n-\n-\n-def load_properties(file_path, interesting_props):\n-    # type: (str, Iterable[str]) -> Dict[str, List[Tuple[int, int]]]\n-    \"\"\"\n-    Load properties data and return in grouped form.\n-    \"\"\"\n-    props = defaultdict(list)   # type: Dict[str, List[Tuple[int, int]]]\n-    # \"Raw string\" is necessary for `\\.` and `\\w` not to be treated as escape chars\n-    # (for the sake of compat with future Python versions).\n-    # See: https://docs.python.org/3.6/whatsnew/3.6.html#deprecated-python-behavior\n-    re1 = re.compile(r\"^ *([0-9A-F]+) *; *(\\w+)\")\n-    re2 = re.compile(r\"^ *([0-9A-F]+)\\.\\.([0-9A-F]+) *; *(\\w+)\")\n-\n-    for line in fileinput.input(file_path):\n-        match = re1.match(line) or re2.match(line)\n-        if match:\n-            groups = match.groups()\n-\n-            if len(groups) == 2:\n-                # `re1` matched (2 groups).\n-                d_lo, prop = groups\n-                d_hi = d_lo\n-            else:\n-                d_lo, d_hi, prop = groups\n-        else:\n-            continue\n-\n-        if interesting_props and prop not in interesting_props:\n-            continue\n-\n-        lo_value = int(d_lo, 16)\n-        hi_value = int(d_hi, 16)\n-\n-        props[prop].append((lo_value, hi_value))\n-\n-    # Optimize if possible.\n-    for prop in props:\n-        props[prop] = group_codepoints(ungroup_codepoints(props[prop]))\n-\n-    return props\n-\n-\n-def escape_char(c):\n-    # type: (int) -> str\n-    r\"\"\"\n-    Escape a codepoint for use as Rust char literal.\n-\n-    Outputs are OK to use as Rust source code as char literals\n-    and they also include necessary quotes.\n-\n-    >>> escape_char(97)\n-    \"'\\\\u{61}'\"\n-    >>> escape_char(0)\n-    \"'\\\\0'\"\n-    \"\"\"\n-    return r\"'\\u{%x}'\" % c if c != 0 else r\"'\\0'\"\n-\n-\n-def format_char_pair(pair):\n-    # type: (Tuple[int, int]) -> str\n-    \"\"\"\n-    Format a pair of two Rust chars.\n-    \"\"\"\n-    return \"(%s,%s)\" % (escape_char(pair[0]), escape_char(pair[1]))\n-\n-\n-def generate_table(\n-    name,   # type: str\n-    items,  # type: List[Tuple[int, int]]\n-    decl_type=\"&[(char, char)]\",    # type: str\n-    is_pub=True,                    # type: bool\n-    format_item=format_char_pair,   # type: Callable[[Tuple[int, int]], str]\n-):\n-    # type: (...) -> Iterator[str]\n-    \"\"\"\n-    Generate a nicely formatted Rust constant \"table\" array.\n-\n-    This generates actual Rust code.\n-    \"\"\"\n-    pub_string = \"\"\n-    if is_pub:\n-        pub_string = \"pub \"\n-\n-    yield \"\\n\"\n-    yield \"    #[rustfmt::skip]\\n\"\n-    yield \"    %sconst %s: %s = &[\\n\" % (pub_string, name, decl_type)\n-\n-    data = []\n-    first = True\n-    for item in items:\n-        if not first:\n-            data.append(\",\")\n-        first = False\n-        data.extend(format_item(item))\n-\n-    for table_line in generate_table_lines(\"\".join(data).split(\",\"), 8):\n-        yield table_line\n-\n-    yield \"\\n    ];\\n\"\n-\n-\n-def compute_trie(raw_data, chunk_size):\n-    # type: (List[int], int) -> Tuple[List[int], List[int]]\n-    \"\"\"\n-    Compute postfix-compressed trie.\n-\n-    See: bool_trie.rs for more details.\n-\n-    >>> compute_trie([1, 2, 3, 1, 2, 3, 4, 5, 6], 3)\n-    ([0, 0, 1], [1, 2, 3, 4, 5, 6])\n-    >>> compute_trie([1, 2, 3, 1, 2, 4, 4, 5, 6], 3)\n-    ([0, 1, 2], [1, 2, 3, 1, 2, 4, 4, 5, 6])\n-    \"\"\"\n-    root = []\n-    childmap = {}       # type: Dict[Tuple[int, ...], int]\n-    child_data = []\n-\n-    assert len(raw_data) % chunk_size == 0, \"Chunks must be equally sized\"\n-\n-    for i in range(len(raw_data) // chunk_size):\n-        data = raw_data[i * chunk_size : (i + 1) * chunk_size]\n-\n-        # Postfix compression of child nodes (data chunks)\n-        # (identical child nodes are shared).\n-\n-        # Make a tuple out of the list so it's hashable.\n-        child = tuple(data)\n-        if child not in childmap:\n-            childmap[child] = len(childmap)\n-            child_data.extend(data)\n-\n-        root.append(childmap[child])\n-\n-    return root, child_data\n-\n-\n-def generate_bool_trie(name, codepoint_ranges, is_pub=False):\n-    # type: (str, List[Tuple[int, int]], bool) -> Iterator[str]\n-    \"\"\"\n-    Generate Rust code for BoolTrie struct.\n-\n-    This yields string fragments that should be joined to produce\n-    the final string.\n-\n-    See: `bool_trie.rs`.\n-    \"\"\"\n-    chunk_size = 64\n-    rawdata = [False] * 0x110000\n-    for (lo, hi) in codepoint_ranges:\n-        for cp in range(lo, hi + 1):\n-            rawdata[cp] = True\n-\n-    # Convert to bitmap chunks of `chunk_size` bits each.\n-    chunks = []\n-    for i in range(0x110000 // chunk_size):\n-        chunk = 0\n-        for j in range(chunk_size):\n-            if rawdata[i * chunk_size + j]:\n-                chunk |= 1 << j\n-        chunks.append(chunk)\n-\n-    pub_string = \"\"\n-    if is_pub:\n-        pub_string = \"pub \"\n-\n-    yield \"\\n\"\n-    yield \"    #[rustfmt::skip]\\n\"\n-    yield \"    %sconst %s: &super::BoolTrie = &super::BoolTrie {\\n\" % (pub_string, name)\n-    yield \"        r1: [\\n\"\n-    data = (\"0x%016x\" % chunk for chunk in chunks[:0x800 // chunk_size])\n-    for fragment in generate_table_lines(data, 12):\n-        yield fragment\n-    yield \"\\n        ],\\n\"\n-\n-    # 0x800..0x10000 trie\n-    (r2, r3) = compute_trie(chunks[0x800 // chunk_size : 0x10000 // chunk_size], 64 // chunk_size)\n-    yield \"        r2: [\\n\"\n-    data = map(str, r2)\n-    for fragment in generate_table_lines(data, 12):\n-        yield fragment\n-    yield \"\\n        ],\\n\"\n-\n-    yield \"        r3: &[\\n\"\n-    data = (\"0x%016x\" % node for node in r3)\n-    for fragment in generate_table_lines(data, 12):\n-        yield fragment\n-    yield \"\\n        ],\\n\"\n-\n-    # 0x10000..0x110000 trie\n-    (mid, r6) = compute_trie(chunks[0x10000 // chunk_size : 0x110000 // chunk_size],\n-                             64 // chunk_size)\n-    (r4, r5) = compute_trie(mid, 64)\n-\n-    yield \"        r4: [\\n\"\n-    data = map(str, r4)\n-    for fragment in generate_table_lines(data, 12):\n-        yield fragment\n-    yield \"\\n        ],\\n\"\n-\n-    yield \"        r5: &[\\n\"\n-    data = map(str, r5)\n-    for fragment in generate_table_lines(data, 12):\n-        yield fragment\n-    yield \"\\n        ],\\n\"\n-\n-    yield \"        r6: &[\\n\"\n-    data = (\"0x%016x\" % node for node in r6)\n-    for fragment in generate_table_lines(data, 12):\n-        yield fragment\n-    yield \"\\n        ],\\n\"\n-\n-    yield \"    };\\n\"\n-\n-\n-def generate_small_bool_trie(name, codepoint_ranges, is_pub=False):\n-    # type: (str, List[Tuple[int, int]], bool) -> Iterator[str]\n-    \"\"\"\n-    Generate Rust code for `SmallBoolTrie` struct.\n-\n-    See: `bool_trie.rs`.\n-    \"\"\"\n-    last_chunk = max(hi // 64 for (lo, hi) in codepoint_ranges)\n-    n_chunks = last_chunk + 1\n-    chunks = [0] * n_chunks\n-    for (lo, hi) in codepoint_ranges:\n-        for cp in range(lo, hi + 1):\n-            assert cp // 64 < len(chunks)\n-            chunks[cp // 64] |= 1 << (cp & 63)\n-\n-    pub_string = \"\"\n-    if is_pub:\n-        pub_string = \"pub \"\n-\n-    yield \"\\n\"\n-    yield \"    #[rustfmt::skip]\\n\"\n-    yield (\"    %sconst %s: &super::SmallBoolTrie = &super::SmallBoolTrie {\\n\"\n-           % (pub_string, name))\n-\n-    (r1, r2) = compute_trie(chunks, 1)\n-\n-    yield \"        r1: &[\\n\"\n-    data = (str(node) for node in r1)\n-    for fragment in generate_table_lines(data, 12):\n-        yield fragment\n-    yield \"\\n        ],\\n\"\n-\n-    yield \"        r2: &[\\n\"\n-    data = (\"0x%016x\" % node for node in r2)\n-    for fragment in generate_table_lines(data, 12):\n-        yield fragment\n-    yield \"\\n        ],\\n\"\n-\n-    yield \"    };\\n\"\n-\n-\n-def generate_property_module(mod, grouped_categories, category_subset):\n-    # type: (str, Dict[str, List[Tuple[int, int]]], Iterable[str]) -> Iterator[str]\n-    \"\"\"\n-    Generate Rust code for module defining properties.\n-    \"\"\"\n-\n-    yield \"pub(crate) mod %s {\" % mod\n-    for cat in sorted(category_subset):\n-        if cat in (\"Cc\", \"White_Space\"):\n-            generator = generate_small_bool_trie(\"%s_table\" % cat, grouped_categories[cat])\n-        else:\n-            generator = generate_bool_trie(\"%s_table\" % cat, grouped_categories[cat])\n-\n-        for fragment in generator:\n-            yield fragment\n-\n-        yield \"\\n\"\n-        yield \"    pub fn %s(c: char) -> bool {\\n\" % cat\n-        yield \"        %s_table.lookup(c)\\n\" % cat\n-        yield \"    }\\n\"\n-\n-    yield \"}\\n\\n\"\n-\n-\n-def generate_conversions_module(unicode_data):\n-    # type: (UnicodeData) -> Iterator[str]\n-    \"\"\"\n-    Generate Rust code for module defining conversions.\n-    \"\"\"\n-\n-    yield \"pub(crate) mod conversions {\"\n-    yield \"\"\"\n-    pub fn to_lower(c: char) -> [char; 3] {\n-        match bsearch_case_table(c, to_lowercase_table) {\n-            None => [c, '\\\\0', '\\\\0'],\n-            Some(index) => to_lowercase_table[index].1,\n-        }\n-    }\n-\n-    pub fn to_upper(c: char) -> [char; 3] {\n-        match bsearch_case_table(c, to_uppercase_table) {\n-            None => [c, '\\\\0', '\\\\0'],\n-            Some(index) => to_uppercase_table[index].1,\n-        }\n-    }\n-\n-    fn bsearch_case_table(c: char, table: &[(char, [char; 3])]) -> Option<usize> {\n-        table.binary_search_by(|&(key, _)| key.cmp(&c)).ok()\n-    }\\n\"\"\"\n-\n-    decl_type = \"&[(char, [char; 3])]\"\n-    format_conversion = lambda x: \"({},[{},{},{}])\".format(*(\n-        escape_char(c) for c in (x[0], x[1][0], x[1][1], x[1][2])\n-    ))\n-\n-    for fragment in generate_table(\n-        name=\"to_lowercase_table\",\n-        items=sorted(unicode_data.to_lower.items(), key=lambda x: x[0]),\n-        decl_type=decl_type,\n-        is_pub=False,\n-        format_item=format_conversion\n-    ):\n-        yield fragment\n-\n-    for fragment in generate_table(\n-        name=\"to_uppercase_table\",\n-        items=sorted(unicode_data.to_upper.items(), key=lambda x: x[0]),\n-        decl_type=decl_type,\n-        is_pub=False,\n-        format_item=format_conversion\n-    ):\n-        yield fragment\n-\n-    yield \"}\\n\"\n-\n-\n-def parse_args():\n-    # type: () -> argparse.Namespace\n-    \"\"\"\n-    Parse command line arguments.\n-    \"\"\"\n-    parser = argparse.ArgumentParser(description=__doc__)\n-    parser.add_argument(\"-v\", \"--version\", default=None, type=str,\n-                        help=\"Unicode version to use (if not specified,\"\n-                             \" defaults to latest release).\")\n-\n-    return parser.parse_args()\n-\n-\n-def main():\n-    # type: () -> None\n-    \"\"\"\n-    Script entry point.\n-    \"\"\"\n-    args = parse_args()\n-\n-    unicode_version = fetch_files(args.version)\n-    print(\"Using Unicode version: {}\".format(unicode_version.as_str))\n-\n-    # All the writing happens entirely in memory, we only write to file\n-    # once we have generated the file content (it's not very large, <1 MB).\n-    buf = StringIO()\n-    buf.write(PREAMBLE)\n-\n-    unicode_version_notice = textwrap.dedent(\"\"\"\n-    /// The version of [Unicode](http://www.unicode.org/) that the Unicode parts of\n-    /// `char` and `str` methods are based on.\n-    #[unstable(feature = \"unicode_version\", issue = \"49726\")]\n-    pub const UNICODE_VERSION: UnicodeVersion =\n-        UnicodeVersion {{ major: {v.major}, minor: {v.minor}, micro: {v.micro}, _priv: () }};\n-    \"\"\").format(v=unicode_version)\n-    buf.write(unicode_version_notice)\n-\n-    get_path = lambda f: get_unicode_file_path(unicode_version, f)\n-\n-    unicode_data = load_unicode_data(get_path(UnicodeFiles.UNICODE_DATA))\n-    load_special_casing(get_path(UnicodeFiles.SPECIAL_CASING), unicode_data)\n-\n-    want_derived = {\"Alphabetic\", \"Lowercase\", \"Uppercase\",\n-                    \"Cased\", \"Case_Ignorable\", \"Grapheme_Extend\"}\n-    derived = load_properties(get_path(UnicodeFiles.DERIVED_CORE_PROPERTIES), want_derived)\n-\n-    props = load_properties(get_path(UnicodeFiles.PROPS),\n-                            {\"White_Space\", \"Join_Control\", \"Noncharacter_Code_Point\"})\n-\n-    # Category tables\n-    for (name, categories, category_subset) in (\n-            (\"general_category\", unicode_data.general_categories, [\"N\", \"Cc\"]),\n-            (\"derived_property\", derived, want_derived),\n-            (\"property\", props, [\"White_Space\"])\n-    ):\n-        for fragment in generate_property_module(name, categories, category_subset):\n-            buf.write(fragment)\n-\n-    for fragment in generate_conversions_module(unicode_data):\n-        buf.write(fragment)\n-\n-    tables_rs_path = os.path.join(THIS_DIR, \"tables.rs\")\n-\n-    # Actually write out the file content.\n-    # Will overwrite the file if it exists.\n-    with open(tables_rs_path, \"w\") as fd:\n-        fd.write(buf.getvalue())\n-\n-    print(\"Regenerated tables.rs.\")\n-\n-\n-if __name__ == \"__main__\":\n-    main()"}, {"sha": "da4cd4e9b1da1900e5703b5a2cc7f3ad65a77d90", "filename": "src/libcore/unicode/unicode_data.rs", "status": "added", "additions": 2343, "deletions": 0, "changes": 2343, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibcore%2Funicode%2Funicode_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibcore%2Funicode%2Funicode_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Funicode_data.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d"}, {"sha": "15e92d8d8421930d60c32929051b805f72c4d7b2", "filename": "src/librustc/arena.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -123,6 +123,9 @@ macro_rules! arena_types {\n             [few] inferred_outlives_crate: rustc::ty::CratePredicatesMap<'tcx>,\n             [] upvars: rustc_data_structures::fx::FxIndexMap<rustc_hir::HirId, rustc_hir::Upvar>,\n \n+            // Interned types\n+            [] tys: rustc::ty::TyS<$tcx>,\n+\n             // HIR types\n             [few] hir_forest: rustc::hir::map::Forest<$tcx>,\n             [] arm: rustc_hir::Arm<$tcx>,\n@@ -176,7 +179,7 @@ macro_rules! declare_arena {\n     ([], [$($a:tt $name:ident: $ty:ty,)*], $tcx:lifetime) => {\n         #[derive(Default)]\n         pub struct Arena<$tcx> {\n-            dropless: DroplessArena,\n+            pub dropless: DroplessArena,\n             drop: DropArena,\n             $($name: arena_for_type!($a[$ty]),)*\n         }"}, {"sha": "de82b262e4956137c8dd50aa4e55a3562b3e2d9b", "filename": "src/librustc/benches/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fbenches%2Flib.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,4 +1,4 @@\n-#![feature(slice_patterns)]\n+#![cfg_attr(bootstrap, feature(slice_patterns))]\n #![feature(test)]\n \n extern crate test;"}, {"sha": "5a4d7ceea2734125cd8f4ec2b9e907e8b18562d5", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -112,7 +112,7 @@ impl Target {\n             ItemKind::Union(..) => Target::Union,\n             ItemKind::Trait(..) => Target::Trait,\n             ItemKind::TraitAlias(..) => Target::TraitAlias,\n-            ItemKind::Impl(..) => Target::Impl,\n+            ItemKind::Impl { .. } => Target::Impl,\n         }\n     }\n \n@@ -144,7 +144,7 @@ impl Target {\n                 let parent_hir_id = tcx.hir().get_parent_item(impl_item.hir_id);\n                 let containing_item = tcx.hir().expect_item(parent_hir_id);\n                 let containing_impl_is_for_trait = match &containing_item.kind {\n-                    hir::ItemKind::Impl(_, _, _, _, tr, _, _) => tr.is_some(),\n+                    hir::ItemKind::Impl { ref of_trait, .. } => of_trait.is_some(),\n                     _ => bug!(\"parent of an ImplItem must be an Impl\"),\n                 };\n                 if containing_impl_is_for_trait {"}, {"sha": "6d7f53133a66644717a88dff7490abe35d5b9fb8", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -341,7 +341,7 @@ impl<'hir> Map<'hir> {\n                 | ItemKind::Use(..)\n                 | ItemKind::ForeignMod(..)\n                 | ItemKind::GlobalAsm(..)\n-                | ItemKind::Impl(..) => return None,\n+                | ItemKind::Impl { .. } => return None,\n             },\n             Node::ForeignItem(item) => match item.kind {\n                 ForeignItemKind::Fn(..) => DefKind::Fn,\n@@ -604,7 +604,7 @@ impl<'hir> Map<'hir> {\n                 | ItemKind::Union(_, ref generics)\n                 | ItemKind::Trait(_, _, ref generics, ..)\n                 | ItemKind::TraitAlias(ref generics, _)\n-                | ItemKind::Impl(_, _, _, ref generics, ..) => Some(generics),\n+                | ItemKind::Impl { ref generics, .. } => Some(generics),\n                 _ => None,\n             },\n             _ => None,\n@@ -821,7 +821,7 @@ impl<'hir> Map<'hir> {\n                     | ItemKind::Struct(..)\n                     | ItemKind::Union(..)\n                     | ItemKind::Trait(..)\n-                    | ItemKind::Impl(..) => true,\n+                    | ItemKind::Impl { .. } => true,\n                     _ => false,\n                 },\n                 Node::ForeignItem(fi) => match fi.kind {\n@@ -1332,7 +1332,7 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId, include_id: bool) -> String {\n                 ItemKind::Union(..) => \"union\",\n                 ItemKind::Trait(..) => \"trait\",\n                 ItemKind::TraitAlias(..) => \"trait alias\",\n-                ItemKind::Impl(..) => \"impl\",\n+                ItemKind::Impl { .. } => \"impl\",\n             };\n             format!(\"{} {}{}\", item_str, path_str(), id_str)\n         }"}, {"sha": "a2009461fa568e22d24c822d05da7380aafdd19c", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -254,7 +254,7 @@ fn emit_msg_span(\n \n fn item_scope_tag(item: &hir::Item<'_>) -> &'static str {\n     match item.kind {\n-        hir::ItemKind::Impl(..) => \"impl\",\n+        hir::ItemKind::Impl { .. } => \"impl\",\n         hir::ItemKind::Struct(..) => \"struct\",\n         hir::ItemKind::Union(..) => \"union\",\n         hir::ItemKind::Enum(..) => \"enum\",\n@@ -2008,7 +2008,7 @@ impl<'tcx> ObligationCause<'tcx> {\n                 TypeError::IntrinsicCast => {\n                     Error0308(\"cannot coerce intrinsics to function pointers\")\n                 }\n-                TypeError::ObjectUnsafeCoercion(did) => Error0038(did.clone()),\n+                TypeError::ObjectUnsafeCoercion(did) => Error0038(*did),\n                 _ => Error0308(\"mismatched types\"),\n             },\n         }"}, {"sha": "18c25ef0dd9e1365b555f3259d64bf04a0a8195b", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 36, "deletions": 40, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -19,7 +19,6 @@ use rustc_data_structures::graph::implementation::{\n     Direction, Graph, NodeIndex, INCOMING, OUTGOING,\n };\n use rustc_hir::def_id::DefId;\n-use rustc_index::bit_set::BitSet;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_span::Span;\n use std::fmt;\n@@ -295,62 +294,59 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n     }\n \n     fn expansion(&self, var_values: &mut LexicalRegionResolutions<'tcx>) {\n-        let mut process_constraint = |constraint: &Constraint<'tcx>| {\n-            let (a_region, b_vid, b_data, retain) = match *constraint {\n+        let mut constraints = IndexVec::from_elem_n(Vec::new(), var_values.values.len());\n+        let mut changes = Vec::new();\n+        for constraint in self.data.constraints.keys() {\n+            let (a_vid, a_region, b_vid, b_data) = match *constraint {\n                 Constraint::RegSubVar(a_region, b_vid) => {\n                     let b_data = var_values.value_mut(b_vid);\n-                    (a_region, b_vid, b_data, false)\n+                    (None, a_region, b_vid, b_data)\n                 }\n                 Constraint::VarSubVar(a_vid, b_vid) => match *var_values.value(a_vid) {\n-                    VarValue::ErrorValue => return (false, false),\n+                    VarValue::ErrorValue => continue,\n                     VarValue::Value(a_region) => {\n                         let b_data = var_values.value_mut(b_vid);\n-                        let retain = match *b_data {\n-                            VarValue::Value(ReStatic) | VarValue::ErrorValue => false,\n-                            _ => true,\n-                        };\n-                        (a_region, b_vid, b_data, retain)\n+                        (Some(a_vid), a_region, b_vid, b_data)\n                     }\n                 },\n                 Constraint::RegSubReg(..) | Constraint::VarSubReg(..) => {\n                     // These constraints are checked after expansion\n                     // is done, in `collect_errors`.\n-                    return (false, false);\n+                    continue;\n                 }\n             };\n-\n-            let changed = self.expand_node(a_region, b_vid, b_data);\n-            (changed, retain)\n-        };\n-\n-        // Using bitsets to track the remaining elements is faster than using a\n-        // `Vec` by itself (which requires removing elements, which requires\n-        // element shuffling, which is slow).\n-        let constraints: Vec<_> = self.data.constraints.keys().collect();\n-        let mut live_indices: BitSet<usize> = BitSet::new_filled(constraints.len());\n-        let mut killed_indices: BitSet<usize> = BitSet::new_empty(constraints.len());\n-        let mut changed = true;\n-        while changed {\n-            changed = false;\n-            for index in live_indices.iter() {\n-                let constraint = constraints[index];\n-                let (edge_changed, retain) = process_constraint(constraint);\n-                changed |= edge_changed;\n-                if !retain {\n-                    let changed = killed_indices.insert(index);\n-                    debug_assert!(changed);\n+            if self.expand_node(a_region, b_vid, b_data) {\n+                changes.push(b_vid);\n+            }\n+            if let Some(a_vid) = a_vid {\n+                match *b_data {\n+                    VarValue::Value(ReStatic) | VarValue::ErrorValue => (),\n+                    _ => {\n+                        constraints[a_vid].push((a_vid, b_vid));\n+                        constraints[b_vid].push((a_vid, b_vid));\n+                    }\n                 }\n             }\n-            live_indices.subtract(&killed_indices);\n+        }\n \n-            // We could clear `killed_indices` here, but we don't need to and\n-            // it's cheaper not to.\n+        while let Some(vid) = changes.pop() {\n+            constraints[vid].retain(|&(a_vid, b_vid)| {\n+                let a_region = match *var_values.value(a_vid) {\n+                    VarValue::ErrorValue => return false,\n+                    VarValue::Value(a_region) => a_region,\n+                };\n+                let b_data = var_values.value_mut(b_vid);\n+                if self.expand_node(a_region, b_vid, b_data) {\n+                    changes.push(b_vid);\n+                }\n+                match *b_data {\n+                    VarValue::Value(ReStatic) | VarValue::ErrorValue => false,\n+                    _ => true,\n+                }\n+            });\n         }\n     }\n \n-    // This function is very hot in some workloads. There's a single callsite\n-    // so always inlining is ok even though it's large.\n-    #[inline(always)]\n     fn expand_node(\n         &self,\n         a_region: Region<'tcx>,\n@@ -790,8 +786,8 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             self.var_infos[node_idx].origin.span(),\n             &format!(\n                 \"collect_error_for_expanding_node() could not find \\\n-                      error for var {:?} in universe {:?}, lower_bounds={:#?}, \\\n-                      upper_bounds={:#?}\",\n+                 error for var {:?} in universe {:?}, lower_bounds={:#?}, \\\n+                 upper_bounds={:#?}\",\n                 node_idx, node_universe, lower_bounds, upper_bounds\n             ),\n         );"}, {"sha": "ee214bea7b8fc39f45968fb28f4bfec728b3405f", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1219,7 +1219,7 @@ pub fn may_define_opaque_type(tcx: TyCtxt<'_>, def_id: DefId, opaque_hir_id: hir\n     let res = hir_id == scope;\n     trace!(\n         \"may_define_opaque_type(def={:?}, opaque_node={:?}) = {}\",\n-        tcx.hir().get(hir_id),\n+        tcx.hir().find(hir_id),\n         tcx.hir().get(opaque_hir_id),\n         res\n     );"}, {"sha": "69ca40636948f72e92a5dc5cf65e1be7fc7dbc59", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -34,7 +34,6 @@\n #![feature(const_transmute)]\n #![feature(core_intrinsics)]\n #![feature(drain_filter)]\n-#![cfg_attr(windows, feature(libc))]\n #![feature(never_type)]\n #![feature(exhaustive_patterns)]\n #![feature(overlapping_marker_traits)]\n@@ -43,7 +42,7 @@\n #![feature(optin_builtin_traits)]\n #![feature(option_expect_none)]\n #![feature(range_is_empty)]\n-#![feature(slice_patterns)]\n+#![cfg_attr(bootstrap, feature(slice_patterns))]\n #![feature(specialization)]\n #![feature(unboxed_closures)]\n #![feature(thread_local)]"}, {"sha": "643359f098b4d3c5424a615f457c5a126db0f564", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -184,7 +184,7 @@ impl LanguageItemCollector<'tcx> {\n                         self.tcx.sess,\n                         span,\n                         E0152,\n-                        \"duplicate lang item found: `{}`.\",\n+                        \"found duplicate lang item `{}`\",\n                         name\n                     ),\n                     None => {\n@@ -206,12 +206,12 @@ impl LanguageItemCollector<'tcx> {\n                     },\n                 };\n                 if let Some(span) = self.tcx.hir().span_if_local(original_def_id) {\n-                    err.span_note(span, \"first defined here.\");\n+                    err.span_note(span, \"first defined here\");\n                 } else {\n                     match self.tcx.extern_crate(original_def_id) {\n                         Some(ExternCrate {dependency_of, ..}) => {\n                             err.note(&format!(\n-                            \"first defined in crate `{}` (which `{}` depends on).\",\n+                            \"first defined in crate `{}` (which `{}` depends on)\",\n                                       self.tcx.crate_name(original_def_id.krate),\n                                       self.tcx.crate_name(*dependency_of)));\n                         },"}, {"sha": "42d896af8014d0720387540838d9791cdfaaa5a0", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -33,7 +33,7 @@ impl ErrorHandled {\n             ErrorHandled::Reported => {}\n             ErrorHandled::TooGeneric => bug!(\n                 \"MIR interpretation failed without reporting an error \\\n-                                              even though it was fully monomorphized\"\n+                 even though it was fully monomorphized\"\n             ),\n         }\n     }"}, {"sha": "e554b280ef78cbc8723d559869c455a66a847fb4", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -403,8 +403,8 @@ impl<'tcx> AllocMap<'tcx> {\n         let next = self.next_id;\n         self.next_id.0 = self.next_id.0.checked_add(1).expect(\n             \"You overflowed a u64 by incrementing by 1... \\\n-                     You've just earned yourself a free drink if we ever meet. \\\n-                     Seriously, how did you do that?!\",\n+             You've just earned yourself a free drink if we ever meet. \\\n+             Seriously, how did you do that?!\",\n         );\n         next\n     }"}, {"sha": "e7a4c5b5921052aa9ba41d3c713e3db873d63b05", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,6 +1,7 @@\n use crate::dep_graph::{DepConstructor, DepNode, WorkProduct, WorkProductId};\n use crate::ich::{Fingerprint, NodeIdHashingMode, StableHashingContext};\n use crate::session::config::OptLevel;\n+use crate::traits::TraitQueryMode;\n use crate::ty::print::obsolete::DefPathBasedNames;\n use crate::ty::{subst::InternalSubsts, Instance, InstanceDef, SymbolName, TyCtxt};\n use rustc_data_structures::base_n;\n@@ -167,7 +168,9 @@ impl<'tcx> MonoItem<'tcx> {\n             MonoItem::GlobalAsm(..) => return true,\n         };\n \n-        tcx.substitute_normalize_and_test_predicates((def_id, &substs))\n+        // We shouldn't encounter any overflow here, so we use TraitQueryMode::Standard\\\n+        // to report an error if overflow somehow occurs.\n+        tcx.substitute_normalize_and_test_predicates((def_id, &substs, TraitQueryMode::Standard))\n     }\n \n     pub fn to_string(&self, tcx: TyCtxt<'tcx>, debug: bool) -> String {"}, {"sha": "a20e011b91a7543697bdb006784a82e205397ace", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1148,11 +1148,11 @@ rustc_queries! {\n             desc { \"normalizing `{:?}`\", goal }\n         }\n \n-        query substitute_normalize_and_test_predicates(key: (DefId, SubstsRef<'tcx>)) -> bool {\n+        query substitute_normalize_and_test_predicates(key: (DefId, SubstsRef<'tcx>, traits::TraitQueryMode)) -> bool {\n             no_force\n             desc { |tcx|\n-                \"testing substituted normalized predicates:`{}`\",\n-                tcx.def_path_str(key.0)\n+                \"testing substituted normalized predicates in mode {:?}:`{}`\",\n+                key.2, tcx.def_path_str(key.0)\n             }\n         }\n "}, {"sha": "0c9a73d78a5ebe184290243e052fa6acb2f87b95", "filename": "src/librustc/traits/error_reporting.rs", "status": "removed", "additions": 0, "deletions": 2971, "changes": 2971, "blob_url": "https://github.com/rust-lang/rust/blob/470cdf54ac9acee20ab8da46ef7899bae9f58f29/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470cdf54ac9acee20ab8da46ef7899bae9f58f29/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=470cdf54ac9acee20ab8da46ef7899bae9f58f29"}, {"sha": "db3173989ac605e114159989fa5665110fc972c2", "filename": "src/librustc/traits/error_reporting/mod.rs", "status": "added", "additions": 1412, "deletions": 0, "changes": 1412, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -0,0 +1,1412 @@\n+pub mod on_unimplemented;\n+pub mod suggestions;\n+\n+use super::{\n+    ConstEvalFailure, EvaluationResult, FulfillmentError, FulfillmentErrorCode,\n+    MismatchedProjectionTypes, ObjectSafetyViolation, Obligation, ObligationCause,\n+    ObligationCauseCode, OnUnimplementedDirective, OnUnimplementedNote,\n+    OutputTypeParameterMismatch, Overflow, PredicateObligation, SelectionContext, SelectionError,\n+    TraitNotObjectSafe,\n+};\n+\n+use crate::infer::error_reporting::{TyCategory, TypeAnnotationNeeded as ErrorCode};\n+use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use crate::infer::{self, InferCtxt};\n+use crate::mir::interpret::ErrorHandled;\n+use crate::session::DiagnosticMessageId;\n+use crate::traits::object_safety_violations;\n+use crate::ty::error::ExpectedFound;\n+use crate::ty::fast_reject;\n+use crate::ty::fold::TypeFolder;\n+use crate::ty::SubtypePredicate;\n+use crate::ty::{self, AdtKind, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable};\n+\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n+use rustc_hir as hir;\n+use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_span::source_map::SourceMap;\n+use rustc_span::{ExpnKind, Span, DUMMY_SP};\n+use std::fmt;\n+use syntax::ast;\n+\n+use rustc_error_codes::*;\n+\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+    pub fn report_fulfillment_errors(\n+        &self,\n+        errors: &[FulfillmentError<'tcx>],\n+        body_id: Option<hir::BodyId>,\n+        fallback_has_occurred: bool,\n+    ) {\n+        #[derive(Debug)]\n+        struct ErrorDescriptor<'tcx> {\n+            predicate: ty::Predicate<'tcx>,\n+            index: Option<usize>, // None if this is an old error\n+        }\n+\n+        let mut error_map: FxHashMap<_, Vec<_>> = self\n+            .reported_trait_errors\n+            .borrow()\n+            .iter()\n+            .map(|(&span, predicates)| {\n+                (\n+                    span,\n+                    predicates\n+                        .iter()\n+                        .map(|predicate| ErrorDescriptor {\n+                            predicate: predicate.clone(),\n+                            index: None,\n+                        })\n+                        .collect(),\n+                )\n+            })\n+            .collect();\n+\n+        for (index, error) in errors.iter().enumerate() {\n+            // We want to ignore desugarings here: spans are equivalent even\n+            // if one is the result of a desugaring and the other is not.\n+            let mut span = error.obligation.cause.span;\n+            let expn_data = span.ctxt().outer_expn_data();\n+            if let ExpnKind::Desugaring(_) = expn_data.kind {\n+                span = expn_data.call_site;\n+            }\n+\n+            error_map.entry(span).or_default().push(ErrorDescriptor {\n+                predicate: error.obligation.predicate.clone(),\n+                index: Some(index),\n+            });\n+\n+            self.reported_trait_errors\n+                .borrow_mut()\n+                .entry(span)\n+                .or_default()\n+                .push(error.obligation.predicate.clone());\n+        }\n+\n+        // We do this in 2 passes because we want to display errors in order, though\n+        // maybe it *is* better to sort errors by span or something.\n+        let mut is_suppressed = vec![false; errors.len()];\n+        for (_, error_set) in error_map.iter() {\n+            // We want to suppress \"duplicate\" errors with the same span.\n+            for error in error_set {\n+                if let Some(index) = error.index {\n+                    // Suppress errors that are either:\n+                    // 1) strictly implied by another error.\n+                    // 2) implied by an error with a smaller index.\n+                    for error2 in error_set {\n+                        if error2.index.map_or(false, |index2| is_suppressed[index2]) {\n+                            // Avoid errors being suppressed by already-suppressed\n+                            // errors, to prevent all errors from being suppressed\n+                            // at once.\n+                            continue;\n+                        }\n+\n+                        if self.error_implies(&error2.predicate, &error.predicate)\n+                            && !(error2.index >= error.index\n+                                && self.error_implies(&error.predicate, &error2.predicate))\n+                        {\n+                            info!(\"skipping {:?} (implied by {:?})\", error, error2);\n+                            is_suppressed[index] = true;\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        for (error, suppressed) in errors.iter().zip(is_suppressed) {\n+            if !suppressed {\n+                self.report_fulfillment_error(error, body_id, fallback_has_occurred);\n+            }\n+        }\n+    }\n+\n+    // returns if `cond` not occurring implies that `error` does not occur - i.e., that\n+    // `error` occurring implies that `cond` occurs.\n+    fn error_implies(&self, cond: &ty::Predicate<'tcx>, error: &ty::Predicate<'tcx>) -> bool {\n+        if cond == error {\n+            return true;\n+        }\n+\n+        let (cond, error) = match (cond, error) {\n+            (&ty::Predicate::Trait(..), &ty::Predicate::Trait(ref error)) => (cond, error),\n+            _ => {\n+                // FIXME: make this work in other cases too.\n+                return false;\n+            }\n+        };\n+\n+        for implication in super::elaborate_predicates(self.tcx, vec![cond.clone()]) {\n+            if let ty::Predicate::Trait(implication) = implication {\n+                let error = error.to_poly_trait_ref();\n+                let implication = implication.to_poly_trait_ref();\n+                // FIXME: I'm just not taking associated types at all here.\n+                // Eventually I'll need to implement param-env-aware\n+                // `\u0393\u2081 \u22a6 \u03c6\u2081 => \u0393\u2082 \u22a6 \u03c6\u2082` logic.\n+                let param_env = ty::ParamEnv::empty();\n+                if self.can_sub(param_env, error, implication).is_ok() {\n+                    debug!(\"error_implies: {:?} -> {:?} -> {:?}\", cond, error, implication);\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        false\n+    }\n+\n+    fn report_fulfillment_error(\n+        &self,\n+        error: &FulfillmentError<'tcx>,\n+        body_id: Option<hir::BodyId>,\n+        fallback_has_occurred: bool,\n+    ) {\n+        debug!(\"report_fulfillment_error({:?})\", error);\n+        match error.code {\n+            FulfillmentErrorCode::CodeSelectionError(ref selection_error) => {\n+                self.report_selection_error(\n+                    &error.obligation,\n+                    selection_error,\n+                    fallback_has_occurred,\n+                    error.points_at_arg_span,\n+                );\n+            }\n+            FulfillmentErrorCode::CodeProjectionError(ref e) => {\n+                self.report_projection_error(&error.obligation, e);\n+            }\n+            FulfillmentErrorCode::CodeAmbiguity => {\n+                self.maybe_report_ambiguity(&error.obligation, body_id);\n+            }\n+            FulfillmentErrorCode::CodeSubtypeError(ref expected_found, ref err) => {\n+                self.report_mismatched_types(\n+                    &error.obligation.cause,\n+                    expected_found.expected,\n+                    expected_found.found,\n+                    err.clone(),\n+                )\n+                .emit();\n+            }\n+        }\n+    }\n+\n+    fn report_projection_error(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        error: &MismatchedProjectionTypes<'tcx>,\n+    ) {\n+        let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n+\n+        if predicate.references_error() {\n+            return;\n+        }\n+\n+        self.probe(|_| {\n+            let err_buf;\n+            let mut err = &error.err;\n+            let mut values = None;\n+\n+            // try to find the mismatched types to report the error with.\n+            //\n+            // this can fail if the problem was higher-ranked, in which\n+            // cause I have no idea for a good error message.\n+            if let ty::Predicate::Projection(ref data) = predicate {\n+                let mut selcx = SelectionContext::new(self);\n+                let (data, _) = self.replace_bound_vars_with_fresh_vars(\n+                    obligation.cause.span,\n+                    infer::LateBoundRegionConversionTime::HigherRankedType,\n+                    data,\n+                );\n+                let mut obligations = vec![];\n+                let normalized_ty = super::normalize_projection_type(\n+                    &mut selcx,\n+                    obligation.param_env,\n+                    data.projection_ty,\n+                    obligation.cause.clone(),\n+                    0,\n+                    &mut obligations,\n+                );\n+\n+                debug!(\n+                    \"report_projection_error obligation.cause={:?} obligation.param_env={:?}\",\n+                    obligation.cause, obligation.param_env\n+                );\n+\n+                debug!(\n+                    \"report_projection_error normalized_ty={:?} data.ty={:?}\",\n+                    normalized_ty, data.ty\n+                );\n+\n+                let is_normalized_ty_expected = match &obligation.cause.code {\n+                    ObligationCauseCode::ItemObligation(_)\n+                    | ObligationCauseCode::BindingObligation(_, _)\n+                    | ObligationCauseCode::ObjectCastObligation(_) => false,\n+                    _ => true,\n+                };\n+\n+                if let Err(error) = self.at(&obligation.cause, obligation.param_env).eq_exp(\n+                    is_normalized_ty_expected,\n+                    normalized_ty,\n+                    data.ty,\n+                ) {\n+                    values = Some(infer::ValuePairs::Types(ExpectedFound::new(\n+                        is_normalized_ty_expected,\n+                        normalized_ty,\n+                        data.ty,\n+                    )));\n+\n+                    err_buf = error;\n+                    err = &err_buf;\n+                }\n+            }\n+\n+            let msg = format!(\"type mismatch resolving `{}`\", predicate);\n+            let error_id = (DiagnosticMessageId::ErrorId(271), Some(obligation.cause.span), msg);\n+            let fresh = self.tcx.sess.one_time_diagnostics.borrow_mut().insert(error_id);\n+            if fresh {\n+                let mut diag = struct_span_err!(\n+                    self.tcx.sess,\n+                    obligation.cause.span,\n+                    E0271,\n+                    \"type mismatch resolving `{}`\",\n+                    predicate\n+                );\n+                self.note_type_err(&mut diag, &obligation.cause, None, values, err);\n+                self.note_obligation_cause(&mut diag, obligation);\n+                diag.emit();\n+            }\n+        });\n+    }\n+\n+    fn fuzzy_match_tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n+        /// returns the fuzzy category of a given type, or None\n+        /// if the type can be equated to any type.\n+        fn type_category(t: Ty<'_>) -> Option<u32> {\n+            match t.kind {\n+                ty::Bool => Some(0),\n+                ty::Char => Some(1),\n+                ty::Str => Some(2),\n+                ty::Int(..) | ty::Uint(..) | ty::Infer(ty::IntVar(..)) => Some(3),\n+                ty::Float(..) | ty::Infer(ty::FloatVar(..)) => Some(4),\n+                ty::Ref(..) | ty::RawPtr(..) => Some(5),\n+                ty::Array(..) | ty::Slice(..) => Some(6),\n+                ty::FnDef(..) | ty::FnPtr(..) => Some(7),\n+                ty::Dynamic(..) => Some(8),\n+                ty::Closure(..) => Some(9),\n+                ty::Tuple(..) => Some(10),\n+                ty::Projection(..) => Some(11),\n+                ty::Param(..) => Some(12),\n+                ty::Opaque(..) => Some(13),\n+                ty::Never => Some(14),\n+                ty::Adt(adt, ..) => match adt.adt_kind() {\n+                    AdtKind::Struct => Some(15),\n+                    AdtKind::Union => Some(16),\n+                    AdtKind::Enum => Some(17),\n+                },\n+                ty::Generator(..) => Some(18),\n+                ty::Foreign(..) => Some(19),\n+                ty::GeneratorWitness(..) => Some(20),\n+                ty::Placeholder(..) | ty::Bound(..) | ty::Infer(..) | ty::Error => None,\n+                ty::UnnormalizedProjection(..) => bug!(\"only used with chalk-engine\"),\n+            }\n+        }\n+\n+        match (type_category(a), type_category(b)) {\n+            (Some(cat_a), Some(cat_b)) => match (&a.kind, &b.kind) {\n+                (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => def_a == def_b,\n+                _ => cat_a == cat_b,\n+            },\n+            // infer and error can be equated to all types\n+            _ => true,\n+        }\n+    }\n+\n+    fn describe_generator(&self, body_id: hir::BodyId) -> Option<&'static str> {\n+        self.tcx.hir().body(body_id).generator_kind.map(|gen_kind| match gen_kind {\n+            hir::GeneratorKind::Gen => \"a generator\",\n+            hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Block) => \"an async block\",\n+            hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Fn) => \"an async function\",\n+            hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Closure) => \"an async closure\",\n+        })\n+    }\n+\n+    fn find_similar_impl_candidates(\n+        &self,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+    ) -> Vec<ty::TraitRef<'tcx>> {\n+        let simp = fast_reject::simplify_type(self.tcx, trait_ref.skip_binder().self_ty(), true);\n+        let all_impls = self.tcx.all_impls(trait_ref.def_id());\n+\n+        match simp {\n+            Some(simp) => all_impls\n+                .iter()\n+                .filter_map(|&def_id| {\n+                    let imp = self.tcx.impl_trait_ref(def_id).unwrap();\n+                    let imp_simp = fast_reject::simplify_type(self.tcx, imp.self_ty(), true);\n+                    if let Some(imp_simp) = imp_simp {\n+                        if simp != imp_simp {\n+                            return None;\n+                        }\n+                    }\n+\n+                    Some(imp)\n+                })\n+                .collect(),\n+            None => {\n+                all_impls.iter().map(|&def_id| self.tcx.impl_trait_ref(def_id).unwrap()).collect()\n+            }\n+        }\n+    }\n+\n+    fn report_similar_impl_candidates(\n+        &self,\n+        impl_candidates: Vec<ty::TraitRef<'tcx>>,\n+        err: &mut DiagnosticBuilder<'_>,\n+    ) {\n+        if impl_candidates.is_empty() {\n+            return;\n+        }\n+\n+        let len = impl_candidates.len();\n+        let end = if impl_candidates.len() <= 5 { impl_candidates.len() } else { 4 };\n+\n+        let normalize = |candidate| {\n+            self.tcx.infer_ctxt().enter(|ref infcx| {\n+                let normalized = infcx\n+                    .at(&ObligationCause::dummy(), ty::ParamEnv::empty())\n+                    .normalize(candidate)\n+                    .ok();\n+                match normalized {\n+                    Some(normalized) => format!(\"\\n  {:?}\", normalized.value),\n+                    None => format!(\"\\n  {:?}\", candidate),\n+                }\n+            })\n+        };\n+\n+        // Sort impl candidates so that ordering is consistent for UI tests.\n+        let mut normalized_impl_candidates =\n+            impl_candidates.iter().map(normalize).collect::<Vec<String>>();\n+\n+        // Sort before taking the `..end` range,\n+        // because the ordering of `impl_candidates` may not be deterministic:\n+        // https://github.com/rust-lang/rust/pull/57475#issuecomment-455519507\n+        normalized_impl_candidates.sort();\n+\n+        err.help(&format!(\n+            \"the following implementations were found:{}{}\",\n+            normalized_impl_candidates[..end].join(\"\"),\n+            if len > 5 { format!(\"\\nand {} others\", len - 4) } else { String::new() }\n+        ));\n+    }\n+\n+    /// Reports that an overflow has occurred and halts compilation. We\n+    /// halt compilation unconditionally because it is important that\n+    /// overflows never be masked -- they basically represent computations\n+    /// whose result could not be truly determined and thus we can't say\n+    /// if the program type checks or not -- and they are unusual\n+    /// occurrences in any case.\n+    pub fn report_overflow_error<T>(\n+        &self,\n+        obligation: &Obligation<'tcx, T>,\n+        suggest_increasing_limit: bool,\n+    ) -> !\n+    where\n+        T: fmt::Display + TypeFoldable<'tcx>,\n+    {\n+        let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n+        let mut err = struct_span_err!(\n+            self.tcx.sess,\n+            obligation.cause.span,\n+            E0275,\n+            \"overflow evaluating the requirement `{}`\",\n+            predicate\n+        );\n+\n+        if suggest_increasing_limit {\n+            self.suggest_new_overflow_limit(&mut err);\n+        }\n+\n+        self.note_obligation_cause_code(\n+            &mut err,\n+            &obligation.predicate,\n+            &obligation.cause.code,\n+            &mut vec![],\n+        );\n+\n+        err.emit();\n+        self.tcx.sess.abort_if_errors();\n+        bug!();\n+    }\n+\n+    /// Reports that a cycle was detected which led to overflow and halts\n+    /// compilation. This is equivalent to `report_overflow_error` except\n+    /// that we can give a more helpful error message (and, in particular,\n+    /// we do not suggest increasing the overflow limit, which is not\n+    /// going to help).\n+    pub fn report_overflow_error_cycle(&self, cycle: &[PredicateObligation<'tcx>]) -> ! {\n+        let cycle = self.resolve_vars_if_possible(&cycle.to_owned());\n+        assert!(cycle.len() > 0);\n+\n+        debug!(\"report_overflow_error_cycle: cycle={:?}\", cycle);\n+\n+        self.report_overflow_error(&cycle[0], false);\n+    }\n+\n+    pub fn report_extra_impl_obligation(\n+        &self,\n+        error_span: Span,\n+        item_name: ast::Name,\n+        _impl_item_def_id: DefId,\n+        trait_item_def_id: DefId,\n+        requirement: &dyn fmt::Display,\n+    ) -> DiagnosticBuilder<'tcx> {\n+        let msg = \"impl has stricter requirements than trait\";\n+        let sp = self.tcx.sess.source_map().def_span(error_span);\n+\n+        let mut err = struct_span_err!(self.tcx.sess, sp, E0276, \"{}\", msg);\n+\n+        if let Some(trait_item_span) = self.tcx.hir().span_if_local(trait_item_def_id) {\n+            let span = self.tcx.sess.source_map().def_span(trait_item_span);\n+            err.span_label(span, format!(\"definition of `{}` from trait\", item_name));\n+        }\n+\n+        err.span_label(sp, format!(\"impl has extra requirement {}\", requirement));\n+\n+        err\n+    }\n+\n+    /// Gets the parent trait chain start\n+    fn get_parent_trait_ref(\n+        &self,\n+        code: &ObligationCauseCode<'tcx>,\n+    ) -> Option<(String, Option<Span>)> {\n+        match code {\n+            &ObligationCauseCode::BuiltinDerivedObligation(ref data) => {\n+                let parent_trait_ref = self.resolve_vars_if_possible(&data.parent_trait_ref);\n+                match self.get_parent_trait_ref(&data.parent_code) {\n+                    Some(t) => Some(t),\n+                    None => {\n+                        let ty = parent_trait_ref.skip_binder().self_ty();\n+                        let span =\n+                            TyCategory::from_ty(ty).map(|(_, def_id)| self.tcx.def_span(def_id));\n+                        Some((ty.to_string(), span))\n+                    }\n+                }\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn report_selection_error(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        error: &SelectionError<'tcx>,\n+        fallback_has_occurred: bool,\n+        points_at_arg: bool,\n+    ) {\n+        let tcx = self.tcx;\n+        let span = obligation.cause.span;\n+\n+        let mut err = match *error {\n+            SelectionError::Unimplemented => {\n+                if let ObligationCauseCode::CompareImplMethodObligation {\n+                    item_name,\n+                    impl_item_def_id,\n+                    trait_item_def_id,\n+                }\n+                | ObligationCauseCode::CompareImplTypeObligation {\n+                    item_name,\n+                    impl_item_def_id,\n+                    trait_item_def_id,\n+                } = obligation.cause.code\n+                {\n+                    self.report_extra_impl_obligation(\n+                        span,\n+                        item_name,\n+                        impl_item_def_id,\n+                        trait_item_def_id,\n+                        &format!(\"`{}`\", obligation.predicate),\n+                    )\n+                    .emit();\n+                    return;\n+                }\n+                match obligation.predicate {\n+                    ty::Predicate::Trait(ref trait_predicate) => {\n+                        let trait_predicate = self.resolve_vars_if_possible(trait_predicate);\n+\n+                        if self.tcx.sess.has_errors() && trait_predicate.references_error() {\n+                            return;\n+                        }\n+                        let trait_ref = trait_predicate.to_poly_trait_ref();\n+                        let (post_message, pre_message, type_def) = self\n+                            .get_parent_trait_ref(&obligation.cause.code)\n+                            .map(|(t, s)| {\n+                                (\n+                                    format!(\" in `{}`\", t),\n+                                    format!(\"within `{}`, \", t),\n+                                    s.map(|s| (format!(\"within this `{}`\", t), s)),\n+                                )\n+                            })\n+                            .unwrap_or_default();\n+\n+                        let OnUnimplementedNote { message, label, note, enclosing_scope } =\n+                            self.on_unimplemented_note(trait_ref, obligation);\n+                        let have_alt_message = message.is_some() || label.is_some();\n+                        let is_try = self\n+                            .tcx\n+                            .sess\n+                            .source_map()\n+                            .span_to_snippet(span)\n+                            .map(|s| &s == \"?\")\n+                            .unwrap_or(false);\n+                        let is_from = format!(\"{}\", trait_ref.print_only_trait_path())\n+                            .starts_with(\"std::convert::From<\");\n+                        let (message, note) = if is_try && is_from {\n+                            (\n+                                Some(format!(\n+                                    \"`?` couldn't convert the error to `{}`\",\n+                                    trait_ref.self_ty(),\n+                                )),\n+                                Some(\n+                                    \"the question mark operation (`?`) implicitly performs a \\\n+                                     conversion on the error value using the `From` trait\"\n+                                        .to_owned(),\n+                                ),\n+                            )\n+                        } else {\n+                            (message, note)\n+                        };\n+\n+                        let mut err = struct_span_err!(\n+                            self.tcx.sess,\n+                            span,\n+                            E0277,\n+                            \"{}\",\n+                            message.unwrap_or_else(|| format!(\n+                                \"the trait bound `{}` is not satisfied{}\",\n+                                trait_ref.to_predicate(),\n+                                post_message,\n+                            ))\n+                        );\n+\n+                        let explanation =\n+                            if obligation.cause.code == ObligationCauseCode::MainFunctionType {\n+                                \"consider using `()`, or a `Result`\".to_owned()\n+                            } else {\n+                                format!(\n+                                    \"{}the trait `{}` is not implemented for `{}`\",\n+                                    pre_message,\n+                                    trait_ref.print_only_trait_path(),\n+                                    trait_ref.self_ty(),\n+                                )\n+                            };\n+\n+                        if self.suggest_add_reference_to_arg(\n+                            &obligation,\n+                            &mut err,\n+                            &trait_ref,\n+                            points_at_arg,\n+                            have_alt_message,\n+                        ) {\n+                            self.note_obligation_cause(&mut err, obligation);\n+                            err.emit();\n+                            return;\n+                        }\n+                        if let Some(ref s) = label {\n+                            // If it has a custom `#[rustc_on_unimplemented]`\n+                            // error message, let's display it as the label!\n+                            err.span_label(span, s.as_str());\n+                            err.help(&explanation);\n+                        } else {\n+                            err.span_label(span, explanation);\n+                        }\n+                        if let Some((msg, span)) = type_def {\n+                            err.span_label(span, &msg);\n+                        }\n+                        if let Some(ref s) = note {\n+                            // If it has a custom `#[rustc_on_unimplemented]` note, let's display it\n+                            err.note(s.as_str());\n+                        }\n+                        if let Some(ref s) = enclosing_scope {\n+                            let enclosing_scope_span = tcx.def_span(\n+                                tcx.hir()\n+                                    .opt_local_def_id(obligation.cause.body_id)\n+                                    .unwrap_or_else(|| {\n+                                        tcx.hir().body_owner_def_id(hir::BodyId {\n+                                            hir_id: obligation.cause.body_id,\n+                                        })\n+                                    }),\n+                            );\n+\n+                            err.span_label(enclosing_scope_span, s.as_str());\n+                        }\n+\n+                        self.suggest_borrow_on_unsized_slice(&obligation.cause.code, &mut err);\n+                        self.suggest_fn_call(&obligation, &mut err, &trait_ref, points_at_arg);\n+                        self.suggest_remove_reference(&obligation, &mut err, &trait_ref);\n+                        self.suggest_semicolon_removal(&obligation, &mut err, span, &trait_ref);\n+                        self.note_version_mismatch(&mut err, &trait_ref);\n+                        if self.suggest_impl_trait(&mut err, span, &obligation, &trait_ref) {\n+                            err.emit();\n+                            return;\n+                        }\n+\n+                        // Try to report a help message\n+                        if !trait_ref.has_infer_types()\n+                            && self.predicate_can_apply(obligation.param_env, trait_ref)\n+                        {\n+                            // If a where-clause may be useful, remind the\n+                            // user that they can add it.\n+                            //\n+                            // don't display an on-unimplemented note, as\n+                            // these notes will often be of the form\n+                            //     \"the type `T` can't be frobnicated\"\n+                            // which is somewhat confusing.\n+                            self.suggest_restricting_param_bound(\n+                                &mut err,\n+                                &trait_ref,\n+                                obligation.cause.body_id,\n+                            );\n+                        } else {\n+                            if !have_alt_message {\n+                                // Can't show anything else useful, try to find similar impls.\n+                                let impl_candidates = self.find_similar_impl_candidates(trait_ref);\n+                                self.report_similar_impl_candidates(impl_candidates, &mut err);\n+                            }\n+                            self.suggest_change_mut(\n+                                &obligation,\n+                                &mut err,\n+                                &trait_ref,\n+                                points_at_arg,\n+                            );\n+                        }\n+\n+                        // If this error is due to `!: Trait` not implemented but `(): Trait` is\n+                        // implemented, and fallback has occurred, then it could be due to a\n+                        // variable that used to fallback to `()` now falling back to `!`. Issue a\n+                        // note informing about the change in behaviour.\n+                        if trait_predicate.skip_binder().self_ty().is_never()\n+                            && fallback_has_occurred\n+                        {\n+                            let predicate = trait_predicate.map_bound(|mut trait_pred| {\n+                                trait_pred.trait_ref.substs = self.tcx.mk_substs_trait(\n+                                    self.tcx.mk_unit(),\n+                                    &trait_pred.trait_ref.substs[1..],\n+                                );\n+                                trait_pred\n+                            });\n+                            let unit_obligation = Obligation {\n+                                predicate: ty::Predicate::Trait(predicate),\n+                                ..obligation.clone()\n+                            };\n+                            if self.predicate_may_hold(&unit_obligation) {\n+                                err.note(\n+                                    \"the trait is implemented for `()`. \\\n+                                         Possibly this error has been caused by changes to \\\n+                                         Rust's type-inference algorithm \\\n+                                         (see: https://github.com/rust-lang/rust/issues/48950 \\\n+                                         for more info). Consider whether you meant to use the \\\n+                                         type `()` here instead.\",\n+                                );\n+                            }\n+                        }\n+\n+                        err\n+                    }\n+\n+                    ty::Predicate::Subtype(ref predicate) => {\n+                        // Errors for Subtype predicates show up as\n+                        // `FulfillmentErrorCode::CodeSubtypeError`,\n+                        // not selection error.\n+                        span_bug!(span, \"subtype requirement gave wrong error: `{:?}`\", predicate)\n+                    }\n+\n+                    ty::Predicate::RegionOutlives(ref predicate) => {\n+                        let predicate = self.resolve_vars_if_possible(predicate);\n+                        let err = self\n+                            .region_outlives_predicate(&obligation.cause, &predicate)\n+                            .err()\n+                            .unwrap();\n+                        struct_span_err!(\n+                            self.tcx.sess,\n+                            span,\n+                            E0279,\n+                            \"the requirement `{}` is not satisfied (`{}`)\",\n+                            predicate,\n+                            err,\n+                        )\n+                    }\n+\n+                    ty::Predicate::Projection(..) | ty::Predicate::TypeOutlives(..) => {\n+                        let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n+                        struct_span_err!(\n+                            self.tcx.sess,\n+                            span,\n+                            E0280,\n+                            \"the requirement `{}` is not satisfied\",\n+                            predicate\n+                        )\n+                    }\n+\n+                    ty::Predicate::ObjectSafe(trait_def_id) => {\n+                        let violations = object_safety_violations(self.tcx, trait_def_id);\n+                        report_object_safety_error(self.tcx, span, trait_def_id, violations)\n+                    }\n+\n+                    ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n+                        let found_kind = self.closure_kind(closure_def_id, closure_substs).unwrap();\n+                        let closure_span = self\n+                            .tcx\n+                            .sess\n+                            .source_map()\n+                            .def_span(self.tcx.hir().span_if_local(closure_def_id).unwrap());\n+                        let hir_id = self.tcx.hir().as_local_hir_id(closure_def_id).unwrap();\n+                        let mut err = struct_span_err!(\n+                            self.tcx.sess,\n+                            closure_span,\n+                            E0525,\n+                            \"expected a closure that implements the `{}` trait, \\\n+                             but this closure only implements `{}`\",\n+                            kind,\n+                            found_kind\n+                        );\n+\n+                        err.span_label(\n+                            closure_span,\n+                            format!(\"this closure implements `{}`, not `{}`\", found_kind, kind),\n+                        );\n+                        err.span_label(\n+                            obligation.cause.span,\n+                            format!(\"the requirement to implement `{}` derives from here\", kind),\n+                        );\n+\n+                        // Additional context information explaining why the closure only implements\n+                        // a particular trait.\n+                        if let Some(tables) = self.in_progress_tables {\n+                            let tables = tables.borrow();\n+                            match (found_kind, tables.closure_kind_origins().get(hir_id)) {\n+                                (ty::ClosureKind::FnOnce, Some((span, name))) => {\n+                                    err.span_label(\n+                                        *span,\n+                                        format!(\n+                                            \"closure is `FnOnce` because it moves the \\\n+                                         variable `{}` out of its environment\",\n+                                            name\n+                                        ),\n+                                    );\n+                                }\n+                                (ty::ClosureKind::FnMut, Some((span, name))) => {\n+                                    err.span_label(\n+                                        *span,\n+                                        format!(\n+                                            \"closure is `FnMut` because it mutates the \\\n+                                         variable `{}` here\",\n+                                            name\n+                                        ),\n+                                    );\n+                                }\n+                                _ => {}\n+                            }\n+                        }\n+\n+                        err.emit();\n+                        return;\n+                    }\n+\n+                    ty::Predicate::WellFormed(ty) => {\n+                        if !self.tcx.sess.opts.debugging_opts.chalk {\n+                            // WF predicates cannot themselves make\n+                            // errors. They can only block due to\n+                            // ambiguity; otherwise, they always\n+                            // degenerate into other obligations\n+                            // (which may fail).\n+                            span_bug!(span, \"WF predicate not satisfied for {:?}\", ty);\n+                        } else {\n+                            // FIXME: we'll need a better message which takes into account\n+                            // which bounds actually failed to hold.\n+                            self.tcx.sess.struct_span_err(\n+                                span,\n+                                &format!(\"the type `{}` is not well-formed (chalk)\", ty),\n+                            )\n+                        }\n+                    }\n+\n+                    ty::Predicate::ConstEvaluatable(..) => {\n+                        // Errors for `ConstEvaluatable` predicates show up as\n+                        // `SelectionError::ConstEvalFailure`,\n+                        // not `Unimplemented`.\n+                        span_bug!(\n+                            span,\n+                            \"const-evaluatable requirement gave wrong error: `{:?}`\",\n+                            obligation\n+                        )\n+                    }\n+                }\n+            }\n+\n+            OutputTypeParameterMismatch(ref found_trait_ref, ref expected_trait_ref, _) => {\n+                let found_trait_ref = self.resolve_vars_if_possible(&*found_trait_ref);\n+                let expected_trait_ref = self.resolve_vars_if_possible(&*expected_trait_ref);\n+\n+                if expected_trait_ref.self_ty().references_error() {\n+                    return;\n+                }\n+\n+                let found_trait_ty = found_trait_ref.self_ty();\n+\n+                let found_did = match found_trait_ty.kind {\n+                    ty::Closure(did, _) | ty::Foreign(did) | ty::FnDef(did, _) => Some(did),\n+                    ty::Adt(def, _) => Some(def.did),\n+                    _ => None,\n+                };\n+\n+                let found_span = found_did\n+                    .and_then(|did| self.tcx.hir().span_if_local(did))\n+                    .map(|sp| self.tcx.sess.source_map().def_span(sp)); // the sp could be an fn def\n+\n+                if self.reported_closure_mismatch.borrow().contains(&(span, found_span)) {\n+                    // We check closures twice, with obligations flowing in different directions,\n+                    // but we want to complain about them only once.\n+                    return;\n+                }\n+\n+                self.reported_closure_mismatch.borrow_mut().insert((span, found_span));\n+\n+                let found = match found_trait_ref.skip_binder().substs.type_at(1).kind {\n+                    ty::Tuple(ref tys) => vec![ArgKind::empty(); tys.len()],\n+                    _ => vec![ArgKind::empty()],\n+                };\n+\n+                let expected_ty = expected_trait_ref.skip_binder().substs.type_at(1);\n+                let expected = match expected_ty.kind {\n+                    ty::Tuple(ref tys) => tys\n+                        .iter()\n+                        .map(|t| ArgKind::from_expected_ty(t.expect_ty(), Some(span)))\n+                        .collect(),\n+                    _ => vec![ArgKind::Arg(\"_\".to_owned(), expected_ty.to_string())],\n+                };\n+\n+                if found.len() == expected.len() {\n+                    self.report_closure_arg_mismatch(\n+                        span,\n+                        found_span,\n+                        found_trait_ref,\n+                        expected_trait_ref,\n+                    )\n+                } else {\n+                    let (closure_span, found) = found_did\n+                        .and_then(|did| self.tcx.hir().get_if_local(did))\n+                        .map(|node| {\n+                            let (found_span, found) = self.get_fn_like_arguments(node);\n+                            (Some(found_span), found)\n+                        })\n+                        .unwrap_or((found_span, found));\n+\n+                    self.report_arg_count_mismatch(\n+                        span,\n+                        closure_span,\n+                        expected,\n+                        found,\n+                        found_trait_ty.is_closure(),\n+                    )\n+                }\n+            }\n+\n+            TraitNotObjectSafe(did) => {\n+                let violations = object_safety_violations(self.tcx, did);\n+                report_object_safety_error(self.tcx, span, did, violations)\n+            }\n+\n+            // already reported in the query\n+            ConstEvalFailure(err) => {\n+                if let ErrorHandled::TooGeneric = err {\n+                    // Silence this error, as it can be produced during intermediate steps\n+                    // when a constant is not yet able to be evaluated (but will be later).\n+                    return;\n+                }\n+                self.tcx.sess.delay_span_bug(\n+                    span,\n+                    &format!(\"constant in type had an ignored error: {:?}\", err),\n+                );\n+                return;\n+            }\n+\n+            Overflow => {\n+                bug!(\"overflow should be handled before the `report_selection_error` path\");\n+            }\n+        };\n+\n+        self.note_obligation_cause(&mut err, obligation);\n+        self.point_at_returns_when_relevant(&mut err, &obligation);\n+\n+        err.emit();\n+    }\n+\n+    /// If the `Self` type of the unsatisfied trait `trait_ref` implements a trait\n+    /// with the same path as `trait_ref`, a help message about\n+    /// a probable version mismatch is added to `err`\n+    fn note_version_mismatch(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        trait_ref: &ty::PolyTraitRef<'tcx>,\n+    ) {\n+        let get_trait_impl = |trait_def_id| {\n+            let mut trait_impl = None;\n+            self.tcx.for_each_relevant_impl(trait_def_id, trait_ref.self_ty(), |impl_def_id| {\n+                if trait_impl.is_none() {\n+                    trait_impl = Some(impl_def_id);\n+                }\n+            });\n+            trait_impl\n+        };\n+        let required_trait_path = self.tcx.def_path_str(trait_ref.def_id());\n+        let all_traits = self.tcx.all_traits(LOCAL_CRATE);\n+        let traits_with_same_path: std::collections::BTreeSet<_> = all_traits\n+            .iter()\n+            .filter(|trait_def_id| **trait_def_id != trait_ref.def_id())\n+            .filter(|trait_def_id| self.tcx.def_path_str(**trait_def_id) == required_trait_path)\n+            .collect();\n+        for trait_with_same_path in traits_with_same_path {\n+            if let Some(impl_def_id) = get_trait_impl(*trait_with_same_path) {\n+                let impl_span = self.tcx.def_span(impl_def_id);\n+                err.span_help(impl_span, \"trait impl with same name found\");\n+                let trait_crate = self.tcx.crate_name(trait_with_same_path.krate);\n+                let crate_msg = format!(\n+                    \"perhaps two different versions of crate `{}` are being used?\",\n+                    trait_crate\n+                );\n+                err.note(&crate_msg);\n+            }\n+        }\n+    }\n+\n+    fn mk_obligation_for_def_id(\n+        &self,\n+        def_id: DefId,\n+        output_ty: Ty<'tcx>,\n+        cause: ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> PredicateObligation<'tcx> {\n+        let new_trait_ref =\n+            ty::TraitRef { def_id, substs: self.tcx.mk_substs_trait(output_ty, &[]) };\n+        Obligation::new(cause, param_env, new_trait_ref.to_predicate())\n+    }\n+}\n+\n+pub fn recursive_type_with_infinite_size_error(\n+    tcx: TyCtxt<'tcx>,\n+    type_def_id: DefId,\n+) -> DiagnosticBuilder<'tcx> {\n+    assert!(type_def_id.is_local());\n+    let span = tcx.hir().span_if_local(type_def_id).unwrap();\n+    let span = tcx.sess.source_map().def_span(span);\n+    let mut err = struct_span_err!(\n+        tcx.sess,\n+        span,\n+        E0072,\n+        \"recursive type `{}` has infinite size\",\n+        tcx.def_path_str(type_def_id)\n+    );\n+    err.span_label(span, \"recursive type has infinite size\");\n+    err.help(&format!(\n+        \"insert indirection (e.g., a `Box`, `Rc`, or `&`) \\\n+                           at some point to make `{}` representable\",\n+        tcx.def_path_str(type_def_id)\n+    ));\n+    err\n+}\n+\n+pub fn report_object_safety_error(\n+    tcx: TyCtxt<'tcx>,\n+    span: Span,\n+    trait_def_id: DefId,\n+    violations: Vec<ObjectSafetyViolation>,\n+) -> DiagnosticBuilder<'tcx> {\n+    let trait_str = tcx.def_path_str(trait_def_id);\n+    let span = tcx.sess.source_map().def_span(span);\n+    let mut err = struct_span_err!(\n+        tcx.sess,\n+        span,\n+        E0038,\n+        \"the trait `{}` cannot be made into an object\",\n+        trait_str\n+    );\n+    err.span_label(span, format!(\"the trait `{}` cannot be made into an object\", trait_str));\n+\n+    let mut reported_violations = FxHashSet::default();\n+    for violation in violations {\n+        if reported_violations.insert(violation.clone()) {\n+            match violation.span() {\n+                Some(span) => err.span_label(span, violation.error_msg()),\n+                None => err.note(&violation.error_msg()),\n+            };\n+        }\n+    }\n+\n+    if tcx.sess.trait_methods_not_found.borrow().contains(&span) {\n+        // Avoid emitting error caused by non-existing method (#58734)\n+        err.cancel();\n+    }\n+\n+    err\n+}\n+\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+    fn maybe_report_ambiguity(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        body_id: Option<hir::BodyId>,\n+    ) {\n+        // Unable to successfully determine, probably means\n+        // insufficient type information, but could mean\n+        // ambiguous impls. The latter *ought* to be a\n+        // coherence violation, so we don't report it here.\n+\n+        let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n+        let span = obligation.cause.span;\n+\n+        debug!(\n+            \"maybe_report_ambiguity(predicate={:?}, obligation={:?} body_id={:?}, code={:?})\",\n+            predicate, obligation, body_id, obligation.cause.code,\n+        );\n+\n+        // Ambiguity errors are often caused as fallout from earlier\n+        // errors. So just ignore them if this infcx is tainted.\n+        if self.is_tainted_by_errors() {\n+            return;\n+        }\n+\n+        let mut err = match predicate {\n+            ty::Predicate::Trait(ref data) => {\n+                let trait_ref = data.to_poly_trait_ref();\n+                let self_ty = trait_ref.self_ty();\n+                debug!(\"self_ty {:?} {:?} trait_ref {:?}\", self_ty, self_ty.kind, trait_ref);\n+\n+                if predicate.references_error() {\n+                    return;\n+                }\n+                // Typically, this ambiguity should only happen if\n+                // there are unresolved type inference variables\n+                // (otherwise it would suggest a coherence\n+                // failure). But given #21974 that is not necessarily\n+                // the case -- we can have multiple where clauses that\n+                // are only distinguished by a region, which results\n+                // in an ambiguity even when all types are fully\n+                // known, since we don't dispatch based on region\n+                // relationships.\n+\n+                // This is kind of a hack: it frequently happens that some earlier\n+                // error prevents types from being fully inferred, and then we get\n+                // a bunch of uninteresting errors saying something like \"<generic\n+                // #0> doesn't implement Sized\".  It may even be true that we\n+                // could just skip over all checks where the self-ty is an\n+                // inference variable, but I was afraid that there might be an\n+                // inference variable created, registered as an obligation, and\n+                // then never forced by writeback, and hence by skipping here we'd\n+                // be ignoring the fact that we don't KNOW the type works\n+                // out. Though even that would probably be harmless, given that\n+                // we're only talking about builtin traits, which are known to be\n+                // inhabited. We used to check for `self.tcx.sess.has_errors()` to\n+                // avoid inundating the user with unnecessary errors, but we now\n+                // check upstream for type errors and dont add the obligations to\n+                // begin with in those cases.\n+                if self\n+                    .tcx\n+                    .lang_items()\n+                    .sized_trait()\n+                    .map_or(false, |sized_id| sized_id == trait_ref.def_id())\n+                {\n+                    self.need_type_info_err(body_id, span, self_ty, ErrorCode::E0282).emit();\n+                    return;\n+                }\n+                let mut err = self.need_type_info_err(body_id, span, self_ty, ErrorCode::E0283);\n+                err.note(&format!(\"cannot resolve `{}`\", predicate));\n+                if let ObligationCauseCode::ItemObligation(def_id) = obligation.cause.code {\n+                    self.suggest_fully_qualified_path(&mut err, def_id, span, trait_ref.def_id());\n+                } else if let (\n+                    Ok(ref snippet),\n+                    ObligationCauseCode::BindingObligation(ref def_id, _),\n+                ) =\n+                    (self.tcx.sess.source_map().span_to_snippet(span), &obligation.cause.code)\n+                {\n+                    let generics = self.tcx.generics_of(*def_id);\n+                    if !generics.params.is_empty() && !snippet.ends_with('>') {\n+                        // FIXME: To avoid spurious suggestions in functions where type arguments\n+                        // where already supplied, we check the snippet to make sure it doesn't\n+                        // end with a turbofish. Ideally we would have access to a `PathSegment`\n+                        // instead. Otherwise we would produce the following output:\n+                        //\n+                        // error[E0283]: type annotations needed\n+                        //   --> $DIR/issue-54954.rs:3:24\n+                        //    |\n+                        // LL | const ARR_LEN: usize = Tt::const_val::<[i8; 123]>();\n+                        //    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+                        //    |                        |\n+                        //    |                        cannot infer type\n+                        //    |                        help: consider specifying the type argument\n+                        //    |                        in the function call:\n+                        //    |                        `Tt::const_val::<[i8; 123]>::<T>`\n+                        // ...\n+                        // LL |     const fn const_val<T: Sized>() -> usize {\n+                        //    |              --------- - required by this bound in `Tt::const_val`\n+                        //    |\n+                        //    = note: cannot resolve `_: Tt`\n+\n+                        err.span_suggestion(\n+                            span,\n+                            &format!(\n+                                \"consider specifying the type argument{} in the function call\",\n+                                if generics.params.len() > 1 { \"s\" } else { \"\" },\n+                            ),\n+                            format!(\n+                                \"{}::<{}>\",\n+                                snippet,\n+                                generics\n+                                    .params\n+                                    .iter()\n+                                    .map(|p| p.name.to_string())\n+                                    .collect::<Vec<String>>()\n+                                    .join(\", \")\n+                            ),\n+                            Applicability::HasPlaceholders,\n+                        );\n+                    }\n+                }\n+                err\n+            }\n+\n+            ty::Predicate::WellFormed(ty) => {\n+                // Same hacky approach as above to avoid deluging user\n+                // with error messages.\n+                if ty.references_error() || self.tcx.sess.has_errors() {\n+                    return;\n+                }\n+                self.need_type_info_err(body_id, span, ty, ErrorCode::E0282)\n+            }\n+\n+            ty::Predicate::Subtype(ref data) => {\n+                if data.references_error() || self.tcx.sess.has_errors() {\n+                    // no need to overload user in such cases\n+                    return;\n+                }\n+                let &SubtypePredicate { a_is_expected: _, a, b } = data.skip_binder();\n+                // both must be type variables, or the other would've been instantiated\n+                assert!(a.is_ty_var() && b.is_ty_var());\n+                self.need_type_info_err(body_id, span, a, ErrorCode::E0282)\n+            }\n+            ty::Predicate::Projection(ref data) => {\n+                let trait_ref = data.to_poly_trait_ref(self.tcx);\n+                let self_ty = trait_ref.self_ty();\n+                if predicate.references_error() {\n+                    return;\n+                }\n+                let mut err = self.need_type_info_err(body_id, span, self_ty, ErrorCode::E0284);\n+                err.note(&format!(\"cannot resolve `{}`\", predicate));\n+                err\n+            }\n+\n+            _ => {\n+                if self.tcx.sess.has_errors() {\n+                    return;\n+                }\n+                let mut err = struct_span_err!(\n+                    self.tcx.sess,\n+                    span,\n+                    E0284,\n+                    \"type annotations needed: cannot resolve `{}`\",\n+                    predicate,\n+                );\n+                err.span_label(span, &format!(\"cannot resolve `{}`\", predicate));\n+                err\n+            }\n+        };\n+        self.note_obligation_cause(&mut err, obligation);\n+        err.emit();\n+    }\n+\n+    /// Returns `true` if the trait predicate may apply for *some* assignment\n+    /// to the type parameters.\n+    fn predicate_can_apply(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        pred: ty::PolyTraitRef<'tcx>,\n+    ) -> bool {\n+        struct ParamToVarFolder<'a, 'tcx> {\n+            infcx: &'a InferCtxt<'a, 'tcx>,\n+            var_map: FxHashMap<Ty<'tcx>, Ty<'tcx>>,\n+        }\n+\n+        impl<'a, 'tcx> TypeFolder<'tcx> for ParamToVarFolder<'a, 'tcx> {\n+            fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n+                self.infcx.tcx\n+            }\n+\n+            fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+                if let ty::Param(ty::ParamTy { name, .. }) = ty.kind {\n+                    let infcx = self.infcx;\n+                    self.var_map.entry(ty).or_insert_with(|| {\n+                        infcx.next_ty_var(TypeVariableOrigin {\n+                            kind: TypeVariableOriginKind::TypeParameterDefinition(name, None),\n+                            span: DUMMY_SP,\n+                        })\n+                    })\n+                } else {\n+                    ty.super_fold_with(self)\n+                }\n+            }\n+        }\n+\n+        self.probe(|_| {\n+            let mut selcx = SelectionContext::new(self);\n+\n+            let cleaned_pred =\n+                pred.fold_with(&mut ParamToVarFolder { infcx: self, var_map: Default::default() });\n+\n+            let cleaned_pred = super::project::normalize(\n+                &mut selcx,\n+                param_env,\n+                ObligationCause::dummy(),\n+                &cleaned_pred,\n+            )\n+            .value;\n+\n+            let obligation =\n+                Obligation::new(ObligationCause::dummy(), param_env, cleaned_pred.to_predicate());\n+\n+            self.predicate_may_hold(&obligation)\n+        })\n+    }\n+\n+    fn note_obligation_cause(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) {\n+        // First, attempt to add note to this error with an async-await-specific\n+        // message, and fall back to regular note otherwise.\n+        if !self.maybe_note_obligation_cause_for_async_await(err, obligation) {\n+            self.note_obligation_cause_code(\n+                err,\n+                &obligation.predicate,\n+                &obligation.cause.code,\n+                &mut vec![],\n+            );\n+        }\n+    }\n+\n+    fn is_recursive_obligation(\n+        &self,\n+        obligated_types: &mut Vec<&ty::TyS<'tcx>>,\n+        cause_code: &ObligationCauseCode<'tcx>,\n+    ) -> bool {\n+        if let ObligationCauseCode::BuiltinDerivedObligation(ref data) = cause_code {\n+            let parent_trait_ref = self.resolve_vars_if_possible(&data.parent_trait_ref);\n+\n+            if obligated_types.iter().any(|ot| ot == &parent_trait_ref.skip_binder().self_ty()) {\n+                return true;\n+            }\n+        }\n+        false\n+    }\n+}\n+\n+/// Summarizes information\n+#[derive(Clone)]\n+pub enum ArgKind {\n+    /// An argument of non-tuple type. Parameters are (name, ty)\n+    Arg(String, String),\n+\n+    /// An argument of tuple type. For a \"found\" argument, the span is\n+    /// the locationo in the source of the pattern. For a \"expected\"\n+    /// argument, it will be None. The vector is a list of (name, ty)\n+    /// strings for the components of the tuple.\n+    Tuple(Option<Span>, Vec<(String, String)>),\n+}\n+\n+impl ArgKind {\n+    fn empty() -> ArgKind {\n+        ArgKind::Arg(\"_\".to_owned(), \"_\".to_owned())\n+    }\n+\n+    /// Creates an `ArgKind` from the expected type of an\n+    /// argument. It has no name (`_`) and an optional source span.\n+    pub fn from_expected_ty(t: Ty<'_>, span: Option<Span>) -> ArgKind {\n+        match t.kind {\n+            ty::Tuple(ref tys) => ArgKind::Tuple(\n+                span,\n+                tys.iter().map(|ty| (\"_\".to_owned(), ty.to_string())).collect::<Vec<_>>(),\n+            ),\n+            _ => ArgKind::Arg(\"_\".to_owned(), t.to_string()),\n+        }\n+    }\n+}\n+\n+/// Suggest restricting a type param with a new bound.\n+pub fn suggest_constraining_type_param(\n+    generics: &hir::Generics<'_>,\n+    err: &mut DiagnosticBuilder<'_>,\n+    param_name: &str,\n+    constraint: &str,\n+    source_map: &SourceMap,\n+    span: Span,\n+) -> bool {\n+    let restrict_msg = \"consider further restricting this bound\";\n+    if let Some(param) =\n+        generics.params.iter().filter(|p| p.name.ident().as_str() == param_name).next()\n+    {\n+        if param_name.starts_with(\"impl \") {\n+            // `impl Trait` in argument:\n+            // `fn foo(x: impl Trait) {}` \u2192 `fn foo(t: impl Trait + Trait2) {}`\n+            err.span_suggestion(\n+                param.span,\n+                restrict_msg,\n+                // `impl CurrentTrait + MissingTrait`\n+                format!(\"{} + {}\", param_name, constraint),\n+                Applicability::MachineApplicable,\n+            );\n+        } else if generics.where_clause.predicates.is_empty() && param.bounds.is_empty() {\n+            // If there are no bounds whatsoever, suggest adding a constraint\n+            // to the type parameter:\n+            // `fn foo<T>(t: T) {}` \u2192 `fn foo<T: Trait>(t: T) {}`\n+            err.span_suggestion(\n+                param.span,\n+                \"consider restricting this bound\",\n+                format!(\"{}: {}\", param_name, constraint),\n+                Applicability::MachineApplicable,\n+            );\n+        } else if !generics.where_clause.predicates.is_empty() {\n+            // There is a `where` clause, so suggest expanding it:\n+            // `fn foo<T>(t: T) where T: Debug {}` \u2192\n+            // `fn foo<T>(t: T) where T: Debug, T: Trait {}`\n+            err.span_suggestion(\n+                generics.where_clause.span().unwrap().shrink_to_hi(),\n+                &format!(\"consider further restricting type parameter `{}`\", param_name),\n+                format!(\", {}: {}\", param_name, constraint),\n+                Applicability::MachineApplicable,\n+            );\n+        } else {\n+            // If there is no `where` clause lean towards constraining to the\n+            // type parameter:\n+            // `fn foo<X: Bar, T>(t: T, x: X) {}` \u2192 `fn foo<T: Trait>(t: T) {}`\n+            // `fn foo<T: Bar>(t: T) {}` \u2192 `fn foo<T: Bar + Trait>(t: T) {}`\n+            let sp = param.span.with_hi(span.hi());\n+            let span = source_map.span_through_char(sp, ':');\n+            if sp != param.span && sp != span {\n+                // Only suggest if we have high certainty that the span\n+                // covers the colon in `foo<T: Trait>`.\n+                err.span_suggestion(\n+                    span,\n+                    restrict_msg,\n+                    format!(\"{}: {} + \", param_name, constraint),\n+                    Applicability::MachineApplicable,\n+                );\n+            } else {\n+                err.span_label(\n+                    param.span,\n+                    &format!(\"consider adding a `where {}: {}` bound\", param_name, constraint),\n+                );\n+            }\n+        }\n+        return true;\n+    }\n+    false\n+}"}, {"sha": "9f3fc91548b218e4c5378f0a31ec8fe559396172", "filename": "src/librustc/traits/error_reporting/on_unimplemented.rs", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -0,0 +1,199 @@\n+use super::{\n+    ObligationCauseCode, OnUnimplementedDirective, OnUnimplementedNote, PredicateObligation,\n+};\n+use crate::infer::InferCtxt;\n+use crate::ty::subst::Subst;\n+use crate::ty::{self, GenericParamDefKind};\n+use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n+use rustc_span::symbol::sym;\n+\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+    fn impl_similar_to(\n+        &self,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) -> Option<DefId> {\n+        let tcx = self.tcx;\n+        let param_env = obligation.param_env;\n+        let trait_ref = tcx.erase_late_bound_regions(&trait_ref);\n+        let trait_self_ty = trait_ref.self_ty();\n+\n+        let mut self_match_impls = vec![];\n+        let mut fuzzy_match_impls = vec![];\n+\n+        self.tcx.for_each_relevant_impl(trait_ref.def_id, trait_self_ty, |def_id| {\n+            let impl_substs = self.fresh_substs_for_item(obligation.cause.span, def_id);\n+            let impl_trait_ref = tcx.impl_trait_ref(def_id).unwrap().subst(tcx, impl_substs);\n+\n+            let impl_self_ty = impl_trait_ref.self_ty();\n+\n+            if let Ok(..) = self.can_eq(param_env, trait_self_ty, impl_self_ty) {\n+                self_match_impls.push(def_id);\n+\n+                if trait_ref\n+                    .substs\n+                    .types()\n+                    .skip(1)\n+                    .zip(impl_trait_ref.substs.types().skip(1))\n+                    .all(|(u, v)| self.fuzzy_match_tys(u, v))\n+                {\n+                    fuzzy_match_impls.push(def_id);\n+                }\n+            }\n+        });\n+\n+        let impl_def_id = if self_match_impls.len() == 1 {\n+            self_match_impls[0]\n+        } else if fuzzy_match_impls.len() == 1 {\n+            fuzzy_match_impls[0]\n+        } else {\n+            return None;\n+        };\n+\n+        tcx.has_attr(impl_def_id, sym::rustc_on_unimplemented).then_some(impl_def_id)\n+    }\n+\n+    /// Used to set on_unimplemented's `ItemContext`\n+    /// to be the enclosing (async) block/function/closure\n+    fn describe_enclosure(&self, hir_id: hir::HirId) -> Option<&'static str> {\n+        let hir = &self.tcx.hir();\n+        let node = hir.find(hir_id)?;\n+        if let hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(sig, _, body_id), .. }) = &node {\n+            self.describe_generator(*body_id).or_else(|| {\n+                Some(if let hir::FnHeader { asyncness: hir::IsAsync::Async, .. } = sig.header {\n+                    \"an async function\"\n+                } else {\n+                    \"a function\"\n+                })\n+            })\n+        } else if let hir::Node::Expr(hir::Expr {\n+            kind: hir::ExprKind::Closure(_is_move, _, body_id, _, gen_movability),\n+            ..\n+        }) = &node\n+        {\n+            self.describe_generator(*body_id).or_else(|| {\n+                Some(if gen_movability.is_some() { \"an async closure\" } else { \"a closure\" })\n+            })\n+        } else if let hir::Node::Expr(hir::Expr { .. }) = &node {\n+            let parent_hid = hir.get_parent_node(hir_id);\n+            if parent_hid != hir_id {\n+                return self.describe_enclosure(parent_hid);\n+            } else {\n+                None\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    crate fn on_unimplemented_note(\n+        &self,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) -> OnUnimplementedNote {\n+        let def_id =\n+            self.impl_similar_to(trait_ref, obligation).unwrap_or_else(|| trait_ref.def_id());\n+        let trait_ref = *trait_ref.skip_binder();\n+\n+        let mut flags = vec![];\n+        flags.push((\n+            sym::item_context,\n+            self.describe_enclosure(obligation.cause.body_id).map(|s| s.to_owned()),\n+        ));\n+\n+        match obligation.cause.code {\n+            ObligationCauseCode::BuiltinDerivedObligation(..)\n+            | ObligationCauseCode::ImplDerivedObligation(..) => {}\n+            _ => {\n+                // this is a \"direct\", user-specified, rather than derived,\n+                // obligation.\n+                flags.push((sym::direct, None));\n+            }\n+        }\n+\n+        if let ObligationCauseCode::ItemObligation(item) = obligation.cause.code {\n+            // FIXME: maybe also have some way of handling methods\n+            // from other traits? That would require name resolution,\n+            // which we might want to be some sort of hygienic.\n+            //\n+            // Currently I'm leaving it for what I need for `try`.\n+            if self.tcx.trait_of_item(item) == Some(trait_ref.def_id) {\n+                let method = self.tcx.item_name(item);\n+                flags.push((sym::from_method, None));\n+                flags.push((sym::from_method, Some(method.to_string())));\n+            }\n+        }\n+        if let Some((t, _)) = self.get_parent_trait_ref(&obligation.cause.code) {\n+            flags.push((sym::parent_trait, Some(t)));\n+        }\n+\n+        if let Some(k) = obligation.cause.span.desugaring_kind() {\n+            flags.push((sym::from_desugaring, None));\n+            flags.push((sym::from_desugaring, Some(format!(\"{:?}\", k))));\n+        }\n+        let generics = self.tcx.generics_of(def_id);\n+        let self_ty = trait_ref.self_ty();\n+        // This is also included through the generics list as `Self`,\n+        // but the parser won't allow you to use it\n+        flags.push((sym::_Self, Some(self_ty.to_string())));\n+        if let Some(def) = self_ty.ty_adt_def() {\n+            // We also want to be able to select self's original\n+            // signature with no type arguments resolved\n+            flags.push((sym::_Self, Some(self.tcx.type_of(def.did).to_string())));\n+        }\n+\n+        for param in generics.params.iter() {\n+            let value = match param.kind {\n+                GenericParamDefKind::Type { .. } | GenericParamDefKind::Const => {\n+                    trait_ref.substs[param.index as usize].to_string()\n+                }\n+                GenericParamDefKind::Lifetime => continue,\n+            };\n+            let name = param.name;\n+            flags.push((name, Some(value)));\n+        }\n+\n+        if let Some(true) = self_ty.ty_adt_def().map(|def| def.did.is_local()) {\n+            flags.push((sym::crate_local, None));\n+        }\n+\n+        // Allow targeting all integers using `{integral}`, even if the exact type was resolved\n+        if self_ty.is_integral() {\n+            flags.push((sym::_Self, Some(\"{integral}\".to_owned())));\n+        }\n+\n+        if let ty::Array(aty, len) = self_ty.kind {\n+            flags.push((sym::_Self, Some(\"[]\".to_owned())));\n+            flags.push((sym::_Self, Some(format!(\"[{}]\", aty))));\n+            if let Some(def) = aty.ty_adt_def() {\n+                // We also want to be able to select the array's type's original\n+                // signature with no type arguments resolved\n+                flags.push((\n+                    sym::_Self,\n+                    Some(format!(\"[{}]\", self.tcx.type_of(def.did).to_string())),\n+                ));\n+                let tcx = self.tcx;\n+                if let Some(len) = len.try_eval_usize(tcx, ty::ParamEnv::empty()) {\n+                    flags.push((\n+                        sym::_Self,\n+                        Some(format!(\"[{}; {}]\", self.tcx.type_of(def.did).to_string(), len)),\n+                    ));\n+                } else {\n+                    flags.push((\n+                        sym::_Self,\n+                        Some(format!(\"[{}; _]\", self.tcx.type_of(def.did).to_string())),\n+                    ));\n+                }\n+            }\n+        }\n+\n+        if let Ok(Some(command)) =\n+            OnUnimplementedDirective::of_item(self.tcx, trait_ref.def_id, def_id)\n+        {\n+            command.evaluate(self.tcx, trait_ref, &flags[..])\n+        } else {\n+            OnUnimplementedNote::default()\n+        }\n+    }\n+}"}, {"sha": "c09fd3079731c33af533e5c963f27cbcbeab37c1", "filename": "src/librustc/traits/error_reporting/suggestions.rs", "status": "added", "additions": 1717, "deletions": 0, "changes": 1717, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -0,0 +1,1717 @@\n+use super::{\n+    ArgKind, EvaluationResult, Obligation, ObligationCause, ObligationCauseCode,\n+    PredicateObligation,\n+};\n+\n+use crate::infer::InferCtxt;\n+use crate::traits::object_safety::object_safety_violations;\n+use crate::ty::TypeckTables;\n+use crate::ty::{self, AdtKind, DefIdTree, ToPredicate, Ty, TyCtxt, TypeFoldable};\n+\n+use rustc_errors::{\n+    error_code, pluralize, struct_span_err, Applicability, DiagnosticBuilder, Style,\n+};\n+use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::intravisit::Visitor;\n+use rustc_hir::Node;\n+use rustc_span::source_map::SourceMap;\n+use rustc_span::symbol::{kw, sym};\n+use rustc_span::{MultiSpan, Span, DUMMY_SP};\n+use std::fmt;\n+\n+use rustc_error_codes::*;\n+\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+    crate fn suggest_restricting_param_bound(\n+        &self,\n+        mut err: &mut DiagnosticBuilder<'_>,\n+        trait_ref: &ty::PolyTraitRef<'_>,\n+        body_id: hir::HirId,\n+    ) {\n+        let self_ty = trait_ref.self_ty();\n+        let (param_ty, projection) = match &self_ty.kind {\n+            ty::Param(_) => (true, None),\n+            ty::Projection(projection) => (false, Some(projection)),\n+            _ => return,\n+        };\n+\n+        let suggest_restriction =\n+            |generics: &hir::Generics<'_>, msg, err: &mut DiagnosticBuilder<'_>| {\n+                let span = generics.where_clause.span_for_predicates_or_empty_place();\n+                if !span.from_expansion() && span.desugaring_kind().is_none() {\n+                    err.span_suggestion(\n+                        generics.where_clause.span_for_predicates_or_empty_place().shrink_to_hi(),\n+                        &format!(\"consider further restricting {}\", msg),\n+                        format!(\n+                            \"{} {} \",\n+                            if !generics.where_clause.predicates.is_empty() {\n+                                \",\"\n+                            } else {\n+                                \" where\"\n+                            },\n+                            trait_ref.to_predicate(),\n+                        ),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            };\n+\n+        // FIXME: Add check for trait bound that is already present, particularly `?Sized` so we\n+        //        don't suggest `T: Sized + ?Sized`.\n+        let mut hir_id = body_id;\n+        while let Some(node) = self.tcx.hir().find(hir_id) {\n+            match node {\n+                hir::Node::TraitItem(hir::TraitItem {\n+                    generics,\n+                    kind: hir::TraitItemKind::Method(..),\n+                    ..\n+                }) if param_ty && self_ty == self.tcx.types.self_param => {\n+                    // Restricting `Self` for a single method.\n+                    suggest_restriction(&generics, \"`Self`\", err);\n+                    return;\n+                }\n+\n+                hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(_, generics, _), .. })\n+                | hir::Node::TraitItem(hir::TraitItem {\n+                    generics,\n+                    kind: hir::TraitItemKind::Method(..),\n+                    ..\n+                })\n+                | hir::Node::ImplItem(hir::ImplItem {\n+                    generics,\n+                    kind: hir::ImplItemKind::Method(..),\n+                    ..\n+                })\n+                | hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Trait(_, _, generics, _, _),\n+                    ..\n+                })\n+                | hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Impl { generics, .. }, ..\n+                }) if projection.is_some() => {\n+                    // Missing associated type bound.\n+                    suggest_restriction(&generics, \"the associated type\", err);\n+                    return;\n+                }\n+\n+                hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Struct(_, generics),\n+                    span,\n+                    ..\n+                })\n+                | hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Enum(_, generics), span, ..\n+                })\n+                | hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Union(_, generics),\n+                    span,\n+                    ..\n+                })\n+                | hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Trait(_, _, generics, ..),\n+                    span,\n+                    ..\n+                })\n+                | hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Impl { generics, .. },\n+                    span,\n+                    ..\n+                })\n+                | hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Fn(_, generics, _),\n+                    span,\n+                    ..\n+                })\n+                | hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::TyAlias(_, generics),\n+                    span,\n+                    ..\n+                })\n+                | hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::TraitAlias(generics, _),\n+                    span,\n+                    ..\n+                })\n+                | hir::Node::Item(hir::Item {\n+                    kind: hir::ItemKind::OpaqueTy(hir::OpaqueTy { generics, .. }),\n+                    span,\n+                    ..\n+                })\n+                | hir::Node::TraitItem(hir::TraitItem { generics, span, .. })\n+                | hir::Node::ImplItem(hir::ImplItem { generics, span, .. })\n+                    if param_ty =>\n+                {\n+                    // Missing generic type parameter bound.\n+                    let param_name = self_ty.to_string();\n+                    let constraint = trait_ref.print_only_trait_path().to_string();\n+                    if suggest_constraining_type_param(\n+                        generics,\n+                        &mut err,\n+                        &param_name,\n+                        &constraint,\n+                        self.tcx.sess.source_map(),\n+                        *span,\n+                    ) {\n+                        return;\n+                    }\n+                }\n+\n+                hir::Node::Crate => return,\n+\n+                _ => {}\n+            }\n+\n+            hir_id = self.tcx.hir().get_parent_item(hir_id);\n+        }\n+    }\n+\n+    /// When encountering an assignment of an unsized trait, like `let x = \"\"[..];`, provide a\n+    /// suggestion to borrow the initializer in order to use have a slice instead.\n+    crate fn suggest_borrow_on_unsized_slice(\n+        &self,\n+        code: &ObligationCauseCode<'tcx>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+    ) {\n+        if let &ObligationCauseCode::VariableType(hir_id) = code {\n+            let parent_node = self.tcx.hir().get_parent_node(hir_id);\n+            if let Some(Node::Local(ref local)) = self.tcx.hir().find(parent_node) {\n+                if let Some(ref expr) = local.init {\n+                    if let hir::ExprKind::Index(_, _) = expr.kind {\n+                        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(expr.span) {\n+                            err.span_suggestion(\n+                                expr.span,\n+                                \"consider borrowing here\",\n+                                format!(\"&{}\", snippet),\n+                                Applicability::MachineApplicable,\n+                            );\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Given a closure's `DefId`, return the given name of the closure.\n+    ///\n+    /// This doesn't account for reassignments, but it's only used for suggestions.\n+    crate fn get_closure_name(\n+        &self,\n+        def_id: DefId,\n+        err: &mut DiagnosticBuilder<'_>,\n+        msg: &str,\n+    ) -> Option<String> {\n+        let get_name =\n+            |err: &mut DiagnosticBuilder<'_>, kind: &hir::PatKind<'_>| -> Option<String> {\n+                // Get the local name of this closure. This can be inaccurate because\n+                // of the possibility of reassignment, but this should be good enough.\n+                match &kind {\n+                    hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, _, name, None) => {\n+                        Some(format!(\"{}\", name))\n+                    }\n+                    _ => {\n+                        err.note(&msg);\n+                        None\n+                    }\n+                }\n+            };\n+\n+        let hir = self.tcx.hir();\n+        let hir_id = hir.as_local_hir_id(def_id)?;\n+        let parent_node = hir.get_parent_node(hir_id);\n+        match hir.find(parent_node) {\n+            Some(hir::Node::Stmt(hir::Stmt { kind: hir::StmtKind::Local(local), .. })) => {\n+                get_name(err, &local.pat.kind)\n+            }\n+            // Different to previous arm because one is `&hir::Local` and the other\n+            // is `P<hir::Local>`.\n+            Some(hir::Node::Local(local)) => get_name(err, &local.pat.kind),\n+            _ => return None,\n+        }\n+    }\n+\n+    /// We tried to apply the bound to an `fn` or closure. Check whether calling it would\n+    /// evaluate to a type that *would* satisfy the trait binding. If it would, suggest calling\n+    /// it: `bar(foo)` \u2192 `bar(foo())`. This case is *very* likely to be hit if `foo` is `async`.\n+    crate fn suggest_fn_call(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut DiagnosticBuilder<'_>,\n+        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+        points_at_arg: bool,\n+    ) {\n+        let self_ty = trait_ref.self_ty();\n+        let (def_id, output_ty, callable) = match self_ty.kind {\n+            ty::Closure(def_id, substs) => {\n+                (def_id, self.closure_sig(def_id, substs).output(), \"closure\")\n+            }\n+            ty::FnDef(def_id, _) => (def_id, self_ty.fn_sig(self.tcx).output(), \"function\"),\n+            _ => return,\n+        };\n+        let msg = format!(\"use parentheses to call the {}\", callable);\n+\n+        let obligation = self.mk_obligation_for_def_id(\n+            trait_ref.def_id(),\n+            output_ty.skip_binder(),\n+            obligation.cause.clone(),\n+            obligation.param_env,\n+        );\n+\n+        match self.evaluate_obligation(&obligation) {\n+            Ok(EvaluationResult::EvaluatedToOk)\n+            | Ok(EvaluationResult::EvaluatedToOkModuloRegions)\n+            | Ok(EvaluationResult::EvaluatedToAmbig) => {}\n+            _ => return,\n+        }\n+        let hir = self.tcx.hir();\n+        // Get the name of the callable and the arguments to be used in the suggestion.\n+        let snippet = match hir.get_if_local(def_id) {\n+            Some(hir::Node::Expr(hir::Expr {\n+                kind: hir::ExprKind::Closure(_, decl, _, span, ..),\n+                ..\n+            })) => {\n+                err.span_label(*span, \"consider calling this closure\");\n+                let name = match self.get_closure_name(def_id, err, &msg) {\n+                    Some(name) => name,\n+                    None => return,\n+                };\n+                let args = decl.inputs.iter().map(|_| \"_\").collect::<Vec<_>>().join(\", \");\n+                format!(\"{}({})\", name, args)\n+            }\n+            Some(hir::Node::Item(hir::Item {\n+                ident,\n+                kind: hir::ItemKind::Fn(.., body_id),\n+                ..\n+            })) => {\n+                err.span_label(ident.span, \"consider calling this function\");\n+                let body = hir.body(*body_id);\n+                let args = body\n+                    .params\n+                    .iter()\n+                    .map(|arg| match &arg.pat.kind {\n+                        hir::PatKind::Binding(_, _, ident, None)\n+                        // FIXME: provide a better suggestion when encountering `SelfLower`, it\n+                        // should suggest a method call.\n+                        if ident.name != kw::SelfLower => ident.to_string(),\n+                        _ => \"_\".to_string(),\n+                    })\n+                    .collect::<Vec<_>>()\n+                    .join(\", \");\n+                format!(\"{}({})\", ident, args)\n+            }\n+            _ => return,\n+        };\n+        if points_at_arg {\n+            // When the obligation error has been ensured to have been caused by\n+            // an argument, the `obligation.cause.span` points at the expression\n+            // of the argument, so we can provide a suggestion. This is signaled\n+            // by `points_at_arg`. Otherwise, we give a more general note.\n+            err.span_suggestion(\n+                obligation.cause.span,\n+                &msg,\n+                snippet,\n+                Applicability::HasPlaceholders,\n+            );\n+        } else {\n+            err.help(&format!(\"{}: `{}`\", msg, snippet));\n+        }\n+    }\n+\n+    crate fn suggest_add_reference_to_arg(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+        points_at_arg: bool,\n+        has_custom_message: bool,\n+    ) -> bool {\n+        if !points_at_arg {\n+            return false;\n+        }\n+\n+        let span = obligation.cause.span;\n+        let param_env = obligation.param_env;\n+        let trait_ref = trait_ref.skip_binder();\n+\n+        if let ObligationCauseCode::ImplDerivedObligation(obligation) = &obligation.cause.code {\n+            // Try to apply the original trait binding obligation by borrowing.\n+            let self_ty = trait_ref.self_ty();\n+            let found = self_ty.to_string();\n+            let new_self_ty = self.tcx.mk_imm_ref(self.tcx.lifetimes.re_static, self_ty);\n+            let substs = self.tcx.mk_substs_trait(new_self_ty, &[]);\n+            let new_trait_ref = ty::TraitRef::new(obligation.parent_trait_ref.def_id(), substs);\n+            let new_obligation =\n+                Obligation::new(ObligationCause::dummy(), param_env, new_trait_ref.to_predicate());\n+            if self.predicate_must_hold_modulo_regions(&new_obligation) {\n+                if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n+                    // We have a very specific type of error, where just borrowing this argument\n+                    // might solve the problem. In cases like this, the important part is the\n+                    // original type obligation, not the last one that failed, which is arbitrary.\n+                    // Because of this, we modify the error to refer to the original obligation and\n+                    // return early in the caller.\n+                    let msg = format!(\n+                        \"the trait bound `{}: {}` is not satisfied\",\n+                        found,\n+                        obligation.parent_trait_ref.skip_binder().print_only_trait_path(),\n+                    );\n+                    if has_custom_message {\n+                        err.note(&msg);\n+                    } else {\n+                        err.message = vec![(msg, Style::NoStyle)];\n+                    }\n+                    if snippet.starts_with('&') {\n+                        // This is already a literal borrow and the obligation is failing\n+                        // somewhere else in the obligation chain. Do not suggest non-sense.\n+                        return false;\n+                    }\n+                    err.span_label(\n+                        span,\n+                        &format!(\n+                            \"expected an implementor of trait `{}`\",\n+                            obligation.parent_trait_ref.skip_binder().print_only_trait_path(),\n+                        ),\n+                    );\n+                    err.span_suggestion(\n+                        span,\n+                        \"consider borrowing here\",\n+                        format!(\"&{}\", snippet),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                    return true;\n+                }\n+            }\n+        }\n+        false\n+    }\n+\n+    /// Whenever references are used by mistake, like `for (i, e) in &vec.iter().enumerate()`,\n+    /// suggest removing these references until we reach a type that implements the trait.\n+    crate fn suggest_remove_reference(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+    ) {\n+        let trait_ref = trait_ref.skip_binder();\n+        let span = obligation.cause.span;\n+\n+        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n+            let refs_number =\n+                snippet.chars().filter(|c| !c.is_whitespace()).take_while(|c| *c == '&').count();\n+            if let Some('\\'') =\n+                snippet.chars().filter(|c| !c.is_whitespace()).skip(refs_number).next()\n+            {\n+                // Do not suggest removal of borrow from type arguments.\n+                return;\n+            }\n+\n+            let mut trait_type = trait_ref.self_ty();\n+\n+            for refs_remaining in 0..refs_number {\n+                if let ty::Ref(_, t_type, _) = trait_type.kind {\n+                    trait_type = t_type;\n+\n+                    let new_obligation = self.mk_obligation_for_def_id(\n+                        trait_ref.def_id,\n+                        trait_type,\n+                        ObligationCause::dummy(),\n+                        obligation.param_env,\n+                    );\n+\n+                    if self.predicate_may_hold(&new_obligation) {\n+                        let sp = self\n+                            .tcx\n+                            .sess\n+                            .source_map()\n+                            .span_take_while(span, |c| c.is_whitespace() || *c == '&');\n+\n+                        let remove_refs = refs_remaining + 1;\n+                        let format_str =\n+                            format!(\"consider removing {} leading `&`-references\", remove_refs);\n+\n+                        err.span_suggestion_short(\n+                            sp,\n+                            &format_str,\n+                            String::new(),\n+                            Applicability::MachineApplicable,\n+                        );\n+                        break;\n+                    }\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Check if the trait bound is implemented for a different mutability and note it in the\n+    /// final error.\n+    crate fn suggest_change_mut(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+        points_at_arg: bool,\n+    ) {\n+        let span = obligation.cause.span;\n+        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n+            let refs_number =\n+                snippet.chars().filter(|c| !c.is_whitespace()).take_while(|c| *c == '&').count();\n+            if let Some('\\'') =\n+                snippet.chars().filter(|c| !c.is_whitespace()).skip(refs_number).next()\n+            {\n+                // Do not suggest removal of borrow from type arguments.\n+                return;\n+            }\n+            let trait_ref = self.resolve_vars_if_possible(trait_ref);\n+            if trait_ref.has_infer_types() {\n+                // Do not ICE while trying to find if a reborrow would succeed on a trait with\n+                // unresolved bindings.\n+                return;\n+            }\n+\n+            if let ty::Ref(region, t_type, mutability) = trait_ref.skip_binder().self_ty().kind {\n+                let trait_type = match mutability {\n+                    hir::Mutability::Mut => self.tcx.mk_imm_ref(region, t_type),\n+                    hir::Mutability::Not => self.tcx.mk_mut_ref(region, t_type),\n+                };\n+\n+                let new_obligation = self.mk_obligation_for_def_id(\n+                    trait_ref.skip_binder().def_id,\n+                    trait_type,\n+                    ObligationCause::dummy(),\n+                    obligation.param_env,\n+                );\n+\n+                if self.evaluate_obligation_no_overflow(&new_obligation).must_apply_modulo_regions()\n+                {\n+                    let sp = self\n+                        .tcx\n+                        .sess\n+                        .source_map()\n+                        .span_take_while(span, |c| c.is_whitespace() || *c == '&');\n+                    if points_at_arg && mutability == hir::Mutability::Not && refs_number > 0 {\n+                        err.span_suggestion(\n+                            sp,\n+                            \"consider changing this borrow's mutability\",\n+                            \"&mut \".to_string(),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    } else {\n+                        err.note(&format!(\n+                            \"`{}` is implemented for `{:?}`, but not for `{:?}`\",\n+                            trait_ref.print_only_trait_path(),\n+                            trait_type,\n+                            trait_ref.skip_binder().self_ty(),\n+                        ));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    crate fn suggest_semicolon_removal(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        span: Span,\n+        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+    ) {\n+        let hir = self.tcx.hir();\n+        let parent_node = hir.get_parent_node(obligation.cause.body_id);\n+        let node = hir.find(parent_node);\n+        if let Some(hir::Node::Item(hir::Item {\n+            kind: hir::ItemKind::Fn(sig, _, body_id), ..\n+        })) = node\n+        {\n+            let body = hir.body(*body_id);\n+            if let hir::ExprKind::Block(blk, _) = &body.value.kind {\n+                if sig.decl.output.span().overlaps(span)\n+                    && blk.expr.is_none()\n+                    && \"()\" == &trait_ref.self_ty().to_string()\n+                {\n+                    // FIXME(estebank): When encountering a method with a trait\n+                    // bound not satisfied in the return type with a body that has\n+                    // no return, suggest removal of semicolon on last statement.\n+                    // Once that is added, close #54771.\n+                    if let Some(ref stmt) = blk.stmts.last() {\n+                        let sp = self.tcx.sess.source_map().end_point(stmt.span);\n+                        err.span_label(sp, \"consider removing this semicolon\");\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /// If all conditions are met to identify a returned `dyn Trait`, suggest using `impl Trait` if\n+    /// applicable and signal that the error has been expanded appropriately and needs to be\n+    /// emitted.\n+    crate fn suggest_impl_trait(\n+        &self,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        span: Span,\n+        obligation: &PredicateObligation<'tcx>,\n+        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+    ) -> bool {\n+        match obligation.cause.code.peel_derives() {\n+            // Only suggest `impl Trait` if the return type is unsized because it is `dyn Trait`.\n+            ObligationCauseCode::SizedReturnType => {}\n+            _ => return false,\n+        }\n+\n+        let hir = self.tcx.hir();\n+        let parent_node = hir.get_parent_node(obligation.cause.body_id);\n+        let node = hir.find(parent_node);\n+        let (sig, body_id) = if let Some(hir::Node::Item(hir::Item {\n+            kind: hir::ItemKind::Fn(sig, _, body_id),\n+            ..\n+        })) = node\n+        {\n+            (sig, body_id)\n+        } else {\n+            return false;\n+        };\n+        let body = hir.body(*body_id);\n+        let trait_ref = self.resolve_vars_if_possible(trait_ref);\n+        let ty = trait_ref.skip_binder().self_ty();\n+        let is_object_safe = match ty.kind {\n+            ty::Dynamic(predicates, _) => {\n+                // If the `dyn Trait` is not object safe, do not suggest `Box<dyn Trait>`.\n+                predicates\n+                    .principal_def_id()\n+                    .map_or(true, |def_id| object_safety_violations(self.tcx, def_id).is_empty())\n+            }\n+            // We only want to suggest `impl Trait` to `dyn Trait`s.\n+            // For example, `fn foo() -> str` needs to be filtered out.\n+            _ => return false,\n+        };\n+\n+        let ret_ty = if let hir::FunctionRetTy::Return(ret_ty) = sig.decl.output {\n+            ret_ty\n+        } else {\n+            return false;\n+        };\n+\n+        // Use `TypeVisitor` instead of the output type directly to find the span of `ty` for\n+        // cases like `fn foo() -> (dyn Trait, i32) {}`.\n+        // Recursively look for `TraitObject` types and if there's only one, use that span to\n+        // suggest `impl Trait`.\n+\n+        // Visit to make sure there's a single `return` type to suggest `impl Trait`,\n+        // otherwise suggest using `Box<dyn Trait>` or an enum.\n+        let mut visitor = ReturnsVisitor(vec![]);\n+        visitor.visit_body(&body);\n+\n+        let tables = self.in_progress_tables.map(|t| t.borrow()).unwrap();\n+\n+        let mut ret_types = visitor.0.iter().filter_map(|expr| tables.node_type_opt(expr.hir_id));\n+        let (last_ty, all_returns_have_same_type) =\n+            ret_types.clone().fold((None, true), |(last_ty, mut same), returned_ty| {\n+                same &= last_ty.map_or(true, |ty| ty == returned_ty);\n+                (Some(returned_ty), same)\n+            });\n+        let all_returns_conform_to_trait =\n+            if let Some(ty_ret_ty) = tables.node_type_opt(ret_ty.hir_id) {\n+                match ty_ret_ty.kind {\n+                    ty::Dynamic(predicates, _) => {\n+                        let cause = ObligationCause::misc(ret_ty.span, ret_ty.hir_id);\n+                        let param_env = ty::ParamEnv::empty();\n+                        ret_types.all(|returned_ty| {\n+                            predicates.iter().all(|predicate| {\n+                                let pred = predicate.with_self_ty(self.tcx, returned_ty);\n+                                let obl = Obligation::new(cause.clone(), param_env, pred);\n+                                self.predicate_may_hold(&obl)\n+                            })\n+                        })\n+                    }\n+                    _ => true,\n+                }\n+            } else {\n+                true\n+            };\n+\n+        let (snippet, last_ty) =\n+            if let (true, hir::TyKind::TraitObject(..), Ok(snippet), true, Some(last_ty)) = (\n+                // Verify that we're dealing with a return `dyn Trait`\n+                ret_ty.span.overlaps(span),\n+                &ret_ty.kind,\n+                self.tcx.sess.source_map().span_to_snippet(ret_ty.span),\n+                // If any of the return types does not conform to the trait, then we can't\n+                // suggest `impl Trait` nor trait objects, it is a type mismatch error.\n+                all_returns_conform_to_trait,\n+                last_ty,\n+            ) {\n+                (snippet, last_ty)\n+            } else {\n+                return false;\n+            };\n+        err.code(error_code!(E0746));\n+        err.set_primary_message(\"return type cannot have an unboxed trait object\");\n+        err.children.clear();\n+        let impl_trait_msg = \"for information on `impl Trait`, see \\\n+            <https://doc.rust-lang.org/book/ch10-02-traits.html\\\n+            #returning-types-that-implement-traits>\";\n+        let trait_obj_msg = \"for information on trait objects, see \\\n+            <https://doc.rust-lang.org/book/ch17-02-trait-objects.html\\\n+            #using-trait-objects-that-allow-for-values-of-different-types>\";\n+        let has_dyn = snippet.split_whitespace().next().map_or(false, |s| s == \"dyn\");\n+        let trait_obj = if has_dyn { &snippet[4..] } else { &snippet[..] };\n+        if all_returns_have_same_type {\n+            // Suggest `-> impl Trait`.\n+            err.span_suggestion(\n+                ret_ty.span,\n+                &format!(\n+                    \"return `impl {1}` instead, as all return paths are of type `{}`, \\\n+                        which implements `{1}`\",\n+                    last_ty, trait_obj,\n+                ),\n+                format!(\"impl {}\", trait_obj),\n+                Applicability::MachineApplicable,\n+            );\n+            err.note(impl_trait_msg);\n+        } else {\n+            if is_object_safe {\n+                // Suggest `-> Box<dyn Trait>` and `Box::new(returned_value)`.\n+                // Get all the return values and collect their span and suggestion.\n+                let mut suggestions = visitor\n+                    .0\n+                    .iter()\n+                    .map(|expr| {\n+                        (\n+                            expr.span,\n+                            format!(\n+                                \"Box::new({})\",\n+                                self.tcx.sess.source_map().span_to_snippet(expr.span).unwrap()\n+                            ),\n+                        )\n+                    })\n+                    .collect::<Vec<_>>();\n+                // Add the suggestion for the return type.\n+                suggestions.push((\n+                    ret_ty.span,\n+                    format!(\"Box<{}{}>\", if has_dyn { \"\" } else { \"dyn \" }, snippet),\n+                ));\n+                err.multipart_suggestion(\n+                    \"return a boxed trait object instead\",\n+                    suggestions,\n+                    Applicability::MaybeIncorrect,\n+                );\n+            } else {\n+                // This is currently not possible to trigger because E0038 takes precedence, but\n+                // leave it in for completeness in case anything changes in an earlier stage.\n+                err.note(&format!(\n+                    \"if trait `{}` was object safe, you could return a trait object\",\n+                    trait_obj,\n+                ));\n+            }\n+            err.note(trait_obj_msg);\n+            err.note(&format!(\n+                \"if all the returned values were of the same type you could use \\\n+                    `impl {}` as the return type\",\n+                trait_obj,\n+            ));\n+            err.note(impl_trait_msg);\n+            err.note(\"you can create a new `enum` with a variant for each returned type\");\n+        }\n+        true\n+    }\n+\n+    crate fn point_at_returns_when_relevant(\n+        &self,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) {\n+        match obligation.cause.code.peel_derives() {\n+            ObligationCauseCode::SizedReturnType => {}\n+            _ => return,\n+        }\n+\n+        let hir = self.tcx.hir();\n+        let parent_node = hir.get_parent_node(obligation.cause.body_id);\n+        let node = hir.find(parent_node);\n+        if let Some(hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(_, _, body_id), .. })) =\n+            node\n+        {\n+            let body = hir.body(*body_id);\n+            // Point at all the `return`s in the function as they have failed trait bounds.\n+            let mut visitor = ReturnsVisitor(vec![]);\n+            visitor.visit_body(&body);\n+            let tables = self.in_progress_tables.map(|t| t.borrow()).unwrap();\n+            for expr in &visitor.0 {\n+                if let Some(returned_ty) = tables.node_type_opt(expr.hir_id) {\n+                    let ty = self.resolve_vars_if_possible(&returned_ty);\n+                    err.span_label(expr.span, &format!(\"this returned value is of type `{}`\", ty));\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Given some node representing a fn-like thing in the HIR map,\n+    /// returns a span and `ArgKind` information that describes the\n+    /// arguments it expects. This can be supplied to\n+    /// `report_arg_count_mismatch`.\n+    pub fn get_fn_like_arguments(&self, node: Node<'_>) -> (Span, Vec<ArgKind>) {\n+        match node {\n+            Node::Expr(&hir::Expr {\n+                kind: hir::ExprKind::Closure(_, ref _decl, id, span, _),\n+                ..\n+            }) => (\n+                self.tcx.sess.source_map().def_span(span),\n+                self.tcx\n+                    .hir()\n+                    .body(id)\n+                    .params\n+                    .iter()\n+                    .map(|arg| {\n+                        if let hir::Pat { kind: hir::PatKind::Tuple(ref args, _), span, .. } =\n+                            *arg.pat\n+                        {\n+                            ArgKind::Tuple(\n+                                Some(span),\n+                                args.iter()\n+                                    .map(|pat| {\n+                                        let snippet = self\n+                                            .tcx\n+                                            .sess\n+                                            .source_map()\n+                                            .span_to_snippet(pat.span)\n+                                            .unwrap();\n+                                        (snippet, \"_\".to_owned())\n+                                    })\n+                                    .collect::<Vec<_>>(),\n+                            )\n+                        } else {\n+                            let name =\n+                                self.tcx.sess.source_map().span_to_snippet(arg.pat.span).unwrap();\n+                            ArgKind::Arg(name, \"_\".to_owned())\n+                        }\n+                    })\n+                    .collect::<Vec<ArgKind>>(),\n+            ),\n+            Node::Item(&hir::Item { span, kind: hir::ItemKind::Fn(ref sig, ..), .. })\n+            | Node::ImplItem(&hir::ImplItem {\n+                span,\n+                kind: hir::ImplItemKind::Method(ref sig, _),\n+                ..\n+            })\n+            | Node::TraitItem(&hir::TraitItem {\n+                span,\n+                kind: hir::TraitItemKind::Method(ref sig, _),\n+                ..\n+            }) => (\n+                self.tcx.sess.source_map().def_span(span),\n+                sig.decl\n+                    .inputs\n+                    .iter()\n+                    .map(|arg| match arg.clone().kind {\n+                        hir::TyKind::Tup(ref tys) => ArgKind::Tuple(\n+                            Some(arg.span),\n+                            vec![(\"_\".to_owned(), \"_\".to_owned()); tys.len()],\n+                        ),\n+                        _ => ArgKind::empty(),\n+                    })\n+                    .collect::<Vec<ArgKind>>(),\n+            ),\n+            Node::Ctor(ref variant_data) => {\n+                let span = variant_data\n+                    .ctor_hir_id()\n+                    .map(|hir_id| self.tcx.hir().span(hir_id))\n+                    .unwrap_or(DUMMY_SP);\n+                let span = self.tcx.sess.source_map().def_span(span);\n+\n+                (span, vec![ArgKind::empty(); variant_data.fields().len()])\n+            }\n+            _ => panic!(\"non-FnLike node found: {:?}\", node),\n+        }\n+    }\n+\n+    /// Reports an error when the number of arguments needed by a\n+    /// trait match doesn't match the number that the expression\n+    /// provides.\n+    pub fn report_arg_count_mismatch(\n+        &self,\n+        span: Span,\n+        found_span: Option<Span>,\n+        expected_args: Vec<ArgKind>,\n+        found_args: Vec<ArgKind>,\n+        is_closure: bool,\n+    ) -> DiagnosticBuilder<'tcx> {\n+        let kind = if is_closure { \"closure\" } else { \"function\" };\n+\n+        let args_str = |arguments: &[ArgKind], other: &[ArgKind]| {\n+            let arg_length = arguments.len();\n+            let distinct = match &other[..] {\n+                &[ArgKind::Tuple(..)] => true,\n+                _ => false,\n+            };\n+            match (arg_length, arguments.get(0)) {\n+                (1, Some(&ArgKind::Tuple(_, ref fields))) => {\n+                    format!(\"a single {}-tuple as argument\", fields.len())\n+                }\n+                _ => format!(\n+                    \"{} {}argument{}\",\n+                    arg_length,\n+                    if distinct && arg_length > 1 { \"distinct \" } else { \"\" },\n+                    pluralize!(arg_length)\n+                ),\n+            }\n+        };\n+\n+        let expected_str = args_str(&expected_args, &found_args);\n+        let found_str = args_str(&found_args, &expected_args);\n+\n+        let mut err = struct_span_err!(\n+            self.tcx.sess,\n+            span,\n+            E0593,\n+            \"{} is expected to take {}, but it takes {}\",\n+            kind,\n+            expected_str,\n+            found_str,\n+        );\n+\n+        err.span_label(span, format!(\"expected {} that takes {}\", kind, expected_str));\n+\n+        if let Some(found_span) = found_span {\n+            err.span_label(found_span, format!(\"takes {}\", found_str));\n+\n+            // move |_| { ... }\n+            // ^^^^^^^^-- def_span\n+            //\n+            // move |_| { ... }\n+            // ^^^^^-- prefix\n+            let prefix_span = self.tcx.sess.source_map().span_until_non_whitespace(found_span);\n+            // move |_| { ... }\n+            //      ^^^-- pipe_span\n+            let pipe_span =\n+                if let Some(span) = found_span.trim_start(prefix_span) { span } else { found_span };\n+\n+            // Suggest to take and ignore the arguments with expected_args_length `_`s if\n+            // found arguments is empty (assume the user just wants to ignore args in this case).\n+            // For example, if `expected_args_length` is 2, suggest `|_, _|`.\n+            if found_args.is_empty() && is_closure {\n+                let underscores = vec![\"_\"; expected_args.len()].join(\", \");\n+                err.span_suggestion(\n+                    pipe_span,\n+                    &format!(\n+                        \"consider changing the closure to take and ignore the expected argument{}\",\n+                        if expected_args.len() < 2 { \"\" } else { \"s\" }\n+                    ),\n+                    format!(\"|{}|\", underscores),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+\n+            if let &[ArgKind::Tuple(_, ref fields)] = &found_args[..] {\n+                if fields.len() == expected_args.len() {\n+                    let sugg = fields\n+                        .iter()\n+                        .map(|(name, _)| name.to_owned())\n+                        .collect::<Vec<String>>()\n+                        .join(\", \");\n+                    err.span_suggestion(\n+                        found_span,\n+                        \"change the closure to take multiple arguments instead of a single tuple\",\n+                        format!(\"|{}|\", sugg),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }\n+            if let &[ArgKind::Tuple(_, ref fields)] = &expected_args[..] {\n+                if fields.len() == found_args.len() && is_closure {\n+                    let sugg = format!(\n+                        \"|({}){}|\",\n+                        found_args\n+                            .iter()\n+                            .map(|arg| match arg {\n+                                ArgKind::Arg(name, _) => name.to_owned(),\n+                                _ => \"_\".to_owned(),\n+                            })\n+                            .collect::<Vec<String>>()\n+                            .join(\", \"),\n+                        // add type annotations if available\n+                        if found_args.iter().any(|arg| match arg {\n+                            ArgKind::Arg(_, ty) => ty != \"_\",\n+                            _ => false,\n+                        }) {\n+                            format!(\n+                                \": ({})\",\n+                                fields\n+                                    .iter()\n+                                    .map(|(_, ty)| ty.to_owned())\n+                                    .collect::<Vec<String>>()\n+                                    .join(\", \")\n+                            )\n+                        } else {\n+                            String::new()\n+                        },\n+                    );\n+                    err.span_suggestion(\n+                        found_span,\n+                        \"change the closure to accept a tuple instead of individual arguments\",\n+                        sugg,\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }\n+        }\n+\n+        err\n+    }\n+\n+    crate fn report_closure_arg_mismatch(\n+        &self,\n+        span: Span,\n+        found_span: Option<Span>,\n+        expected_ref: ty::PolyTraitRef<'tcx>,\n+        found: ty::PolyTraitRef<'tcx>,\n+    ) -> DiagnosticBuilder<'tcx> {\n+        crate fn build_fn_sig_string<'tcx>(\n+            tcx: TyCtxt<'tcx>,\n+            trait_ref: &ty::TraitRef<'tcx>,\n+        ) -> String {\n+            let inputs = trait_ref.substs.type_at(1);\n+            let sig = if let ty::Tuple(inputs) = inputs.kind {\n+                tcx.mk_fn_sig(\n+                    inputs.iter().map(|k| k.expect_ty()),\n+                    tcx.mk_ty_infer(ty::TyVar(ty::TyVid { index: 0 })),\n+                    false,\n+                    hir::Unsafety::Normal,\n+                    ::rustc_target::spec::abi::Abi::Rust,\n+                )\n+            } else {\n+                tcx.mk_fn_sig(\n+                    ::std::iter::once(inputs),\n+                    tcx.mk_ty_infer(ty::TyVar(ty::TyVid { index: 0 })),\n+                    false,\n+                    hir::Unsafety::Normal,\n+                    ::rustc_target::spec::abi::Abi::Rust,\n+                )\n+            };\n+            ty::Binder::bind(sig).to_string()\n+        }\n+\n+        let argument_is_closure = expected_ref.skip_binder().substs.type_at(0).is_closure();\n+        let mut err = struct_span_err!(\n+            self.tcx.sess,\n+            span,\n+            E0631,\n+            \"type mismatch in {} arguments\",\n+            if argument_is_closure { \"closure\" } else { \"function\" }\n+        );\n+\n+        let found_str = format!(\n+            \"expected signature of `{}`\",\n+            build_fn_sig_string(self.tcx, found.skip_binder())\n+        );\n+        err.span_label(span, found_str);\n+\n+        let found_span = found_span.unwrap_or(span);\n+        let expected_str = format!(\n+            \"found signature of `{}`\",\n+            build_fn_sig_string(self.tcx, expected_ref.skip_binder())\n+        );\n+        err.span_label(found_span, expected_str);\n+\n+        err\n+    }\n+}\n+\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+    crate fn suggest_fully_qualified_path(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        def_id: DefId,\n+        span: Span,\n+        trait_ref: DefId,\n+    ) {\n+        if let Some(assoc_item) = self.tcx.opt_associated_item(def_id) {\n+            if let ty::AssocKind::Const | ty::AssocKind::Type = assoc_item.kind {\n+                err.note(&format!(\n+                    \"{}s cannot be accessed directly on a `trait`, they can only be \\\n+                        accessed through a specific `impl`\",\n+                    assoc_item.kind.suggestion_descr(),\n+                ));\n+                err.span_suggestion(\n+                    span,\n+                    \"use the fully qualified path to an implementation\",\n+                    format!(\"<Type as {}>::{}\", self.tcx.def_path_str(trait_ref), assoc_item.ident),\n+                    Applicability::HasPlaceholders,\n+                );\n+            }\n+        }\n+    }\n+\n+    /// Adds an async-await specific note to the diagnostic when the future does not implement\n+    /// an auto trait because of a captured type.\n+    ///\n+    /// ```ignore (diagnostic)\n+    /// note: future does not implement `Qux` as this value is used across an await\n+    ///   --> $DIR/issue-64130-3-other.rs:17:5\n+    ///    |\n+    /// LL |     let x = Foo;\n+    ///    |         - has type `Foo`\n+    /// LL |     baz().await;\n+    ///    |     ^^^^^^^^^^^ await occurs here, with `x` maybe used later\n+    /// LL | }\n+    ///    | - `x` is later dropped here\n+    /// ```\n+    ///\n+    /// When the diagnostic does not implement `Send` or `Sync` specifically, then the diagnostic\n+    /// is \"replaced\" with a different message and a more specific error.\n+    ///\n+    /// ```ignore (diagnostic)\n+    /// error: future cannot be sent between threads safely\n+    ///   --> $DIR/issue-64130-2-send.rs:21:5\n+    ///    |\n+    /// LL | fn is_send<T: Send>(t: T) { }\n+    ///    |    -------    ---- required by this bound in `is_send`\n+    /// ...\n+    /// LL |     is_send(bar());\n+    ///    |     ^^^^^^^ future returned by `bar` is not send\n+    ///    |\n+    ///    = help: within `impl std::future::Future`, the trait `std::marker::Send` is not\n+    ///            implemented for `Foo`\n+    /// note: future is not send as this value is used across an await\n+    ///   --> $DIR/issue-64130-2-send.rs:15:5\n+    ///    |\n+    /// LL |     let x = Foo;\n+    ///    |         - has type `Foo`\n+    /// LL |     baz().await;\n+    ///    |     ^^^^^^^^^^^ await occurs here, with `x` maybe used later\n+    /// LL | }\n+    ///    | - `x` is later dropped here\n+    /// ```\n+    ///\n+    /// Returns `true` if an async-await specific note was added to the diagnostic.\n+    crate fn maybe_note_obligation_cause_for_async_await(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) -> bool {\n+        debug!(\n+            \"maybe_note_obligation_cause_for_async_await: obligation.predicate={:?} \\\n+                obligation.cause.span={:?}\",\n+            obligation.predicate, obligation.cause.span\n+        );\n+        let source_map = self.tcx.sess.source_map();\n+\n+        // Attempt to detect an async-await error by looking at the obligation causes, looking\n+        // for a generator to be present.\n+        //\n+        // When a future does not implement a trait because of a captured type in one of the\n+        // generators somewhere in the call stack, then the result is a chain of obligations.\n+        //\n+        // Given a `async fn` A that calls a `async fn` B which captures a non-send type and that\n+        // future is passed as an argument to a function C which requires a `Send` type, then the\n+        // chain looks something like this:\n+        //\n+        // - `BuiltinDerivedObligation` with a generator witness (B)\n+        // - `BuiltinDerivedObligation` with a generator (B)\n+        // - `BuiltinDerivedObligation` with `std::future::GenFuture` (B)\n+        // - `BuiltinDerivedObligation` with `impl std::future::Future` (B)\n+        // - `BuiltinDerivedObligation` with `impl std::future::Future` (B)\n+        // - `BuiltinDerivedObligation` with a generator witness (A)\n+        // - `BuiltinDerivedObligation` with a generator (A)\n+        // - `BuiltinDerivedObligation` with `std::future::GenFuture` (A)\n+        // - `BuiltinDerivedObligation` with `impl std::future::Future` (A)\n+        // - `BuiltinDerivedObligation` with `impl std::future::Future` (A)\n+        // - `BindingObligation` with `impl_send (Send requirement)\n+        //\n+        // The first obligation in the chain is the most useful and has the generator that captured\n+        // the type. The last generator has information about where the bound was introduced. At\n+        // least one generator should be present for this diagnostic to be modified.\n+        let (mut trait_ref, mut target_ty) = match obligation.predicate {\n+            ty::Predicate::Trait(p) => {\n+                (Some(p.skip_binder().trait_ref), Some(p.skip_binder().self_ty()))\n+            }\n+            _ => (None, None),\n+        };\n+        let mut generator = None;\n+        let mut last_generator = None;\n+        let mut next_code = Some(&obligation.cause.code);\n+        while let Some(code) = next_code {\n+            debug!(\"maybe_note_obligation_cause_for_async_await: code={:?}\", code);\n+            match code {\n+                ObligationCauseCode::BuiltinDerivedObligation(derived_obligation)\n+                | ObligationCauseCode::ImplDerivedObligation(derived_obligation) => {\n+                    let ty = derived_obligation.parent_trait_ref.self_ty();\n+                    debug!(\n+                        \"maybe_note_obligation_cause_for_async_await: \\\n+                            parent_trait_ref={:?} self_ty.kind={:?}\",\n+                        derived_obligation.parent_trait_ref, ty.kind\n+                    );\n+\n+                    match ty.kind {\n+                        ty::Generator(did, ..) => {\n+                            generator = generator.or(Some(did));\n+                            last_generator = Some(did);\n+                        }\n+                        ty::GeneratorWitness(..) => {}\n+                        _ if generator.is_none() => {\n+                            trait_ref = Some(*derived_obligation.parent_trait_ref.skip_binder());\n+                            target_ty = Some(ty);\n+                        }\n+                        _ => {}\n+                    }\n+\n+                    next_code = Some(derived_obligation.parent_code.as_ref());\n+                }\n+                _ => break,\n+            }\n+        }\n+\n+        // Only continue if a generator was found.\n+        debug!(\n+            \"maybe_note_obligation_cause_for_async_await: generator={:?} trait_ref={:?} \\\n+                target_ty={:?}\",\n+            generator, trait_ref, target_ty\n+        );\n+        let (generator_did, trait_ref, target_ty) = match (generator, trait_ref, target_ty) {\n+            (Some(generator_did), Some(trait_ref), Some(target_ty)) => {\n+                (generator_did, trait_ref, target_ty)\n+            }\n+            _ => return false,\n+        };\n+\n+        let span = self.tcx.def_span(generator_did);\n+\n+        // Do not ICE on closure typeck (#66868).\n+        if self.tcx.hir().as_local_hir_id(generator_did).is_none() {\n+            return false;\n+        }\n+\n+        // Get the tables from the infcx if the generator is the function we are\n+        // currently type-checking; otherwise, get them by performing a query.\n+        // This is needed to avoid cycles.\n+        let in_progress_tables = self.in_progress_tables.map(|t| t.borrow());\n+        let generator_did_root = self.tcx.closure_base_def_id(generator_did);\n+        debug!(\n+            \"maybe_note_obligation_cause_for_async_await: generator_did={:?} \\\n+             generator_did_root={:?} in_progress_tables.local_id_root={:?} span={:?}\",\n+            generator_did,\n+            generator_did_root,\n+            in_progress_tables.as_ref().map(|t| t.local_id_root),\n+            span\n+        );\n+        let query_tables;\n+        let tables: &TypeckTables<'tcx> = match &in_progress_tables {\n+            Some(t) if t.local_id_root == Some(generator_did_root) => t,\n+            _ => {\n+                query_tables = self.tcx.typeck_tables_of(generator_did);\n+                &query_tables\n+            }\n+        };\n+\n+        // Look for a type inside the generator interior that matches the target type to get\n+        // a span.\n+        let target_ty_erased = self.tcx.erase_regions(&target_ty);\n+        let target_span = tables\n+            .generator_interior_types\n+            .iter()\n+            .find(|ty::GeneratorInteriorTypeCause { ty, .. }| {\n+                // Careful: the regions for types that appear in the\n+                // generator interior are not generally known, so we\n+                // want to erase them when comparing (and anyway,\n+                // `Send` and other bounds are generally unaffected by\n+                // the choice of region).  When erasing regions, we\n+                // also have to erase late-bound regions. This is\n+                // because the types that appear in the generator\n+                // interior generally contain \"bound regions\" to\n+                // represent regions that are part of the suspended\n+                // generator frame. Bound regions are preserved by\n+                // `erase_regions` and so we must also call\n+                // `erase_late_bound_regions`.\n+                let ty_erased = self.tcx.erase_late_bound_regions(&ty::Binder::bind(*ty));\n+                let ty_erased = self.tcx.erase_regions(&ty_erased);\n+                let eq = ty::TyS::same_type(ty_erased, target_ty_erased);\n+                debug!(\n+                    \"maybe_note_obligation_cause_for_async_await: ty_erased={:?} \\\n+                        target_ty_erased={:?} eq={:?}\",\n+                    ty_erased, target_ty_erased, eq\n+                );\n+                eq\n+            })\n+            .map(|ty::GeneratorInteriorTypeCause { span, scope_span, expr, .. }| {\n+                (span, source_map.span_to_snippet(*span), scope_span, expr)\n+            });\n+\n+        debug!(\n+            \"maybe_note_obligation_cause_for_async_await: target_ty={:?} \\\n+                generator_interior_types={:?} target_span={:?}\",\n+            target_ty, tables.generator_interior_types, target_span\n+        );\n+        if let Some((target_span, Ok(snippet), scope_span, expr)) = target_span {\n+            self.note_obligation_cause_for_async_await(\n+                err,\n+                *target_span,\n+                scope_span,\n+                *expr,\n+                snippet,\n+                generator_did,\n+                last_generator,\n+                trait_ref,\n+                target_ty,\n+                tables,\n+                obligation,\n+                next_code,\n+            );\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    /// Unconditionally adds the diagnostic note described in\n+    /// `maybe_note_obligation_cause_for_async_await`'s documentation comment.\n+    crate fn note_obligation_cause_for_async_await(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        target_span: Span,\n+        scope_span: &Option<Span>,\n+        expr: Option<hir::HirId>,\n+        snippet: String,\n+        first_generator: DefId,\n+        last_generator: Option<DefId>,\n+        trait_ref: ty::TraitRef<'_>,\n+        target_ty: Ty<'tcx>,\n+        tables: &ty::TypeckTables<'_>,\n+        obligation: &PredicateObligation<'tcx>,\n+        next_code: Option<&ObligationCauseCode<'tcx>>,\n+    ) {\n+        let source_map = self.tcx.sess.source_map();\n+\n+        let is_async_fn = self\n+            .tcx\n+            .parent(first_generator)\n+            .map(|parent_did| self.tcx.asyncness(parent_did))\n+            .map(|parent_asyncness| parent_asyncness == hir::IsAsync::Async)\n+            .unwrap_or(false);\n+        let is_async_move = self\n+            .tcx\n+            .hir()\n+            .as_local_hir_id(first_generator)\n+            .and_then(|hir_id| self.tcx.hir().maybe_body_owned_by(hir_id))\n+            .map(|body_id| self.tcx.hir().body(body_id))\n+            .and_then(|body| body.generator_kind())\n+            .map(|generator_kind| match generator_kind {\n+                hir::GeneratorKind::Async(..) => true,\n+                _ => false,\n+            })\n+            .unwrap_or(false);\n+        let await_or_yield = if is_async_fn || is_async_move { \"await\" } else { \"yield\" };\n+\n+        // Special case the primary error message when send or sync is the trait that was\n+        // not implemented.\n+        let is_send = self.tcx.is_diagnostic_item(sym::send_trait, trait_ref.def_id);\n+        let is_sync = self.tcx.is_diagnostic_item(sym::sync_trait, trait_ref.def_id);\n+        let hir = self.tcx.hir();\n+        let trait_explanation = if is_send || is_sync {\n+            let (trait_name, trait_verb) =\n+                if is_send { (\"`Send`\", \"sent\") } else { (\"`Sync`\", \"shared\") };\n+\n+            err.clear_code();\n+            err.set_primary_message(format!(\n+                \"future cannot be {} between threads safely\",\n+                trait_verb\n+            ));\n+\n+            let original_span = err.span.primary_span().unwrap();\n+            let mut span = MultiSpan::from_span(original_span);\n+\n+            let message = if let Some(name) = last_generator\n+                .and_then(|generator_did| self.tcx.parent(generator_did))\n+                .and_then(|parent_did| hir.as_local_hir_id(parent_did))\n+                .and_then(|parent_hir_id| hir.opt_name(parent_hir_id))\n+            {\n+                format!(\"future returned by `{}` is not {}\", name, trait_name)\n+            } else {\n+                format!(\"future is not {}\", trait_name)\n+            };\n+\n+            span.push_span_label(original_span, message);\n+            err.set_span(span);\n+\n+            format!(\"is not {}\", trait_name)\n+        } else {\n+            format!(\"does not implement `{}`\", trait_ref.print_only_trait_path())\n+        };\n+\n+        // Look at the last interior type to get a span for the `.await`.\n+        let await_span = tables.generator_interior_types.iter().map(|t| t.span).last().unwrap();\n+        let mut span = MultiSpan::from_span(await_span);\n+        span.push_span_label(\n+            await_span,\n+            format!(\"{} occurs here, with `{}` maybe used later\", await_or_yield, snippet),\n+        );\n+\n+        span.push_span_label(target_span, format!(\"has type `{}`\", target_ty));\n+\n+        // If available, use the scope span to annotate the drop location.\n+        if let Some(scope_span) = scope_span {\n+            span.push_span_label(\n+                source_map.end_point(*scope_span),\n+                format!(\"`{}` is later dropped here\", snippet),\n+            );\n+        }\n+\n+        err.span_note(\n+            span,\n+            &format!(\n+                \"future {} as this value is used across an {}\",\n+                trait_explanation, await_or_yield,\n+            ),\n+        );\n+\n+        if let Some(expr_id) = expr {\n+            let expr = hir.expect_expr(expr_id);\n+            let is_ref = tables.expr_adjustments(expr).iter().any(|adj| adj.is_region_borrow());\n+            let parent = hir.get_parent_node(expr_id);\n+            if let Some(hir::Node::Expr(e)) = hir.find(parent) {\n+                let method_span = hir.span(parent);\n+                if tables.is_method_call(e) && is_ref {\n+                    err.span_help(\n+                        method_span,\n+                        \"consider moving this method call into a `let` \\\n+                        binding to create a shorter lived borrow\",\n+                    );\n+                }\n+            }\n+        }\n+\n+        // Add a note for the item obligation that remains - normally a note pointing to the\n+        // bound that introduced the obligation (e.g. `T: Send`).\n+        debug!(\"note_obligation_cause_for_async_await: next_code={:?}\", next_code);\n+        self.note_obligation_cause_code(\n+            err,\n+            &obligation.predicate,\n+            next_code.unwrap(),\n+            &mut Vec::new(),\n+        );\n+    }\n+\n+    crate fn note_obligation_cause_code<T>(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        predicate: &T,\n+        cause_code: &ObligationCauseCode<'tcx>,\n+        obligated_types: &mut Vec<&ty::TyS<'tcx>>,\n+    ) where\n+        T: fmt::Display,\n+    {\n+        let tcx = self.tcx;\n+        match *cause_code {\n+            ObligationCauseCode::ExprAssignable\n+            | ObligationCauseCode::MatchExpressionArm { .. }\n+            | ObligationCauseCode::Pattern { .. }\n+            | ObligationCauseCode::IfExpression { .. }\n+            | ObligationCauseCode::IfExpressionWithNoElse\n+            | ObligationCauseCode::MainFunctionType\n+            | ObligationCauseCode::StartFunctionType\n+            | ObligationCauseCode::IntrinsicType\n+            | ObligationCauseCode::MethodReceiver\n+            | ObligationCauseCode::ReturnNoExpression\n+            | ObligationCauseCode::MiscObligation => {}\n+            ObligationCauseCode::SliceOrArrayElem => {\n+                err.note(\"slice and array elements must have `Sized` type\");\n+            }\n+            ObligationCauseCode::TupleElem => {\n+                err.note(\"only the last element of a tuple may have a dynamically sized type\");\n+            }\n+            ObligationCauseCode::ProjectionWf(data) => {\n+                err.note(&format!(\"required so that the projection `{}` is well-formed\", data,));\n+            }\n+            ObligationCauseCode::ReferenceOutlivesReferent(ref_ty) => {\n+                err.note(&format!(\n+                    \"required so that reference `{}` does not outlive its referent\",\n+                    ref_ty,\n+                ));\n+            }\n+            ObligationCauseCode::ObjectTypeBound(object_ty, region) => {\n+                err.note(&format!(\n+                    \"required so that the lifetime bound of `{}` for `{}` is satisfied\",\n+                    region, object_ty,\n+                ));\n+            }\n+            ObligationCauseCode::ItemObligation(item_def_id) => {\n+                let item_name = tcx.def_path_str(item_def_id);\n+                let msg = format!(\"required by `{}`\", item_name);\n+\n+                if let Some(sp) = tcx.hir().span_if_local(item_def_id) {\n+                    let sp = tcx.sess.source_map().def_span(sp);\n+                    err.span_label(sp, &msg);\n+                } else {\n+                    err.note(&msg);\n+                }\n+            }\n+            ObligationCauseCode::BindingObligation(item_def_id, span) => {\n+                let item_name = tcx.def_path_str(item_def_id);\n+                let msg = format!(\"required by this bound in `{}`\", item_name);\n+                if let Some(ident) = tcx.opt_item_name(item_def_id) {\n+                    err.span_label(ident.span, \"\");\n+                }\n+                if span != DUMMY_SP {\n+                    err.span_label(span, &msg);\n+                } else {\n+                    err.note(&msg);\n+                }\n+            }\n+            ObligationCauseCode::ObjectCastObligation(object_ty) => {\n+                err.note(&format!(\n+                    \"required for the cast to the object type `{}`\",\n+                    self.ty_to_string(object_ty)\n+                ));\n+            }\n+            ObligationCauseCode::Coercion { source: _, target } => {\n+                err.note(&format!(\"required by cast to type `{}`\", self.ty_to_string(target)));\n+            }\n+            ObligationCauseCode::RepeatVec(suggest_const_in_array_repeat_expressions) => {\n+                err.note(\n+                    \"the `Copy` trait is required because the repeated element will be copied\",\n+                );\n+                if suggest_const_in_array_repeat_expressions {\n+                    err.note(\n+                        \"this array initializer can be evaluated at compile-time, for more \\\n+                         information, see issue \\\n+                         https://github.com/rust-lang/rust/issues/49147\",\n+                    );\n+                    if tcx.sess.opts.unstable_features.is_nightly_build() {\n+                        err.help(\n+                            \"add `#![feature(const_in_array_repeat_expressions)]` to the \\\n+                             crate attributes to enable\",\n+                        );\n+                    }\n+                }\n+            }\n+            ObligationCauseCode::VariableType(_) => {\n+                err.note(\"all local variables must have a statically known size\");\n+                if !self.tcx.features().unsized_locals {\n+                    err.help(\"unsized locals are gated as an unstable feature\");\n+                }\n+            }\n+            ObligationCauseCode::SizedArgumentType => {\n+                err.note(\"all function arguments must have a statically known size\");\n+                if !self.tcx.features().unsized_locals {\n+                    err.help(\"unsized locals are gated as an unstable feature\");\n+                }\n+            }\n+            ObligationCauseCode::SizedReturnType => {\n+                err.note(\"the return type of a function must have a statically known size\");\n+            }\n+            ObligationCauseCode::SizedYieldType => {\n+                err.note(\"the yield type of a generator must have a statically known size\");\n+            }\n+            ObligationCauseCode::AssignmentLhsSized => {\n+                err.note(\"the left-hand-side of an assignment must have a statically known size\");\n+            }\n+            ObligationCauseCode::TupleInitializerSized => {\n+                err.note(\"tuples must have a statically known size to be initialized\");\n+            }\n+            ObligationCauseCode::StructInitializerSized => {\n+                err.note(\"structs must have a statically known size to be initialized\");\n+            }\n+            ObligationCauseCode::FieldSized { adt_kind: ref item, last } => match *item {\n+                AdtKind::Struct => {\n+                    if last {\n+                        err.note(\n+                            \"the last field of a packed struct may only have a \\\n+                             dynamically sized type if it does not need drop to be run\",\n+                        );\n+                    } else {\n+                        err.note(\n+                            \"only the last field of a struct may have a dynamically sized type\",\n+                        );\n+                    }\n+                }\n+                AdtKind::Union => {\n+                    err.note(\"no field of a union may have a dynamically sized type\");\n+                }\n+                AdtKind::Enum => {\n+                    err.note(\"no field of an enum variant may have a dynamically sized type\");\n+                }\n+            },\n+            ObligationCauseCode::ConstSized => {\n+                err.note(\"constant expressions must have a statically known size\");\n+            }\n+            ObligationCauseCode::ConstPatternStructural => {\n+                err.note(\"constants used for pattern-matching must derive `PartialEq` and `Eq`\");\n+            }\n+            ObligationCauseCode::SharedStatic => {\n+                err.note(\"shared static variables must have a type that implements `Sync`\");\n+            }\n+            ObligationCauseCode::BuiltinDerivedObligation(ref data) => {\n+                let parent_trait_ref = self.resolve_vars_if_possible(&data.parent_trait_ref);\n+                let ty = parent_trait_ref.skip_binder().self_ty();\n+                err.note(&format!(\"required because it appears within the type `{}`\", ty));\n+                obligated_types.push(ty);\n+\n+                let parent_predicate = parent_trait_ref.to_predicate();\n+                if !self.is_recursive_obligation(obligated_types, &data.parent_code) {\n+                    self.note_obligation_cause_code(\n+                        err,\n+                        &parent_predicate,\n+                        &data.parent_code,\n+                        obligated_types,\n+                    );\n+                }\n+            }\n+            ObligationCauseCode::ImplDerivedObligation(ref data) => {\n+                let parent_trait_ref = self.resolve_vars_if_possible(&data.parent_trait_ref);\n+                err.note(&format!(\n+                    \"required because of the requirements on the impl of `{}` for `{}`\",\n+                    parent_trait_ref.print_only_trait_path(),\n+                    parent_trait_ref.skip_binder().self_ty()\n+                ));\n+                let parent_predicate = parent_trait_ref.to_predicate();\n+                self.note_obligation_cause_code(\n+                    err,\n+                    &parent_predicate,\n+                    &data.parent_code,\n+                    obligated_types,\n+                );\n+            }\n+            ObligationCauseCode::CompareImplMethodObligation { .. } => {\n+                err.note(&format!(\n+                    \"the requirement `{}` appears on the impl method \\\n+                     but not on the corresponding trait method\",\n+                    predicate\n+                ));\n+            }\n+            ObligationCauseCode::CompareImplTypeObligation { .. } => {\n+                err.note(&format!(\n+                    \"the requirement `{}` appears on the associated impl type \\\n+                     but not on the corresponding associated trait type\",\n+                    predicate\n+                ));\n+            }\n+            ObligationCauseCode::ReturnType\n+            | ObligationCauseCode::ReturnValue(_)\n+            | ObligationCauseCode::BlockTailExpression(_) => (),\n+            ObligationCauseCode::TrivialBound => {\n+                err.help(\"see issue #48214\");\n+                if tcx.sess.opts.unstable_features.is_nightly_build() {\n+                    err.help(\"add `#![feature(trivial_bounds)]` to the crate attributes to enable\");\n+                }\n+            }\n+            ObligationCauseCode::AssocTypeBound(ref data) => {\n+                err.span_label(data.original, \"associated type defined here\");\n+                if let Some(sp) = data.impl_span {\n+                    err.span_label(sp, \"in this `impl` item\");\n+                }\n+                for sp in &data.bounds {\n+                    err.span_label(*sp, \"restricted in this bound\");\n+                }\n+            }\n+        }\n+    }\n+\n+    crate fn suggest_new_overflow_limit(&self, err: &mut DiagnosticBuilder<'_>) {\n+        let current_limit = self.tcx.sess.recursion_limit.get();\n+        let suggested_limit = current_limit * 2;\n+        err.help(&format!(\n+            \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n+            suggested_limit\n+        ));\n+    }\n+}\n+\n+/// Suggest restricting a type param with a new bound.\n+pub fn suggest_constraining_type_param(\n+    generics: &hir::Generics<'_>,\n+    err: &mut DiagnosticBuilder<'_>,\n+    param_name: &str,\n+    constraint: &str,\n+    source_map: &SourceMap,\n+    span: Span,\n+) -> bool {\n+    let restrict_msg = \"consider further restricting this bound\";\n+    if let Some(param) =\n+        generics.params.iter().filter(|p| p.name.ident().as_str() == param_name).next()\n+    {\n+        if param_name.starts_with(\"impl \") {\n+            // `impl Trait` in argument:\n+            // `fn foo(x: impl Trait) {}` \u2192 `fn foo(t: impl Trait + Trait2) {}`\n+            err.span_suggestion(\n+                param.span,\n+                restrict_msg,\n+                // `impl CurrentTrait + MissingTrait`\n+                format!(\"{} + {}\", param_name, constraint),\n+                Applicability::MachineApplicable,\n+            );\n+        } else if generics.where_clause.predicates.is_empty() && param.bounds.is_empty() {\n+            // If there are no bounds whatsoever, suggest adding a constraint\n+            // to the type parameter:\n+            // `fn foo<T>(t: T) {}` \u2192 `fn foo<T: Trait>(t: T) {}`\n+            err.span_suggestion(\n+                param.span,\n+                \"consider restricting this bound\",\n+                format!(\"{}: {}\", param_name, constraint),\n+                Applicability::MachineApplicable,\n+            );\n+        } else if !generics.where_clause.predicates.is_empty() {\n+            // There is a `where` clause, so suggest expanding it:\n+            // `fn foo<T>(t: T) where T: Debug {}` \u2192\n+            // `fn foo<T>(t: T) where T: Debug, T: Trait {}`\n+            err.span_suggestion(\n+                generics.where_clause.span().unwrap().shrink_to_hi(),\n+                &format!(\"consider further restricting type parameter `{}`\", param_name),\n+                format!(\", {}: {}\", param_name, constraint),\n+                Applicability::MachineApplicable,\n+            );\n+        } else {\n+            // If there is no `where` clause lean towards constraining to the\n+            // type parameter:\n+            // `fn foo<X: Bar, T>(t: T, x: X) {}` \u2192 `fn foo<T: Trait>(t: T) {}`\n+            // `fn foo<T: Bar>(t: T) {}` \u2192 `fn foo<T: Bar + Trait>(t: T) {}`\n+            let sp = param.span.with_hi(span.hi());\n+            let span = source_map.span_through_char(sp, ':');\n+            if sp != param.span && sp != span {\n+                // Only suggest if we have high certainty that the span\n+                // covers the colon in `foo<T: Trait>`.\n+                err.span_suggestion(\n+                    span,\n+                    restrict_msg,\n+                    format!(\"{}: {} + \", param_name, constraint),\n+                    Applicability::MachineApplicable,\n+                );\n+            } else {\n+                err.span_label(\n+                    param.span,\n+                    &format!(\"consider adding a `where {}: {}` bound\", param_name, constraint),\n+                );\n+            }\n+        }\n+        return true;\n+    }\n+    false\n+}\n+\n+/// Collect all the returned expressions within the input expression.\n+/// Used to point at the return spans when we want to suggest some change to them.\n+struct ReturnsVisitor<'v>(Vec<&'v hir::Expr<'v>>);\n+\n+impl<'v> Visitor<'v> for ReturnsVisitor<'v> {\n+    type Map = rustc::hir::map::Map<'v>;\n+\n+    fn nested_visit_map(&mut self) -> hir::intravisit::NestedVisitorMap<'_, Self::Map> {\n+        hir::intravisit::NestedVisitorMap::None\n+    }\n+\n+    fn visit_expr(&mut self, ex: &'v hir::Expr<'v>) {\n+        if let hir::ExprKind::Ret(Some(ex)) = ex.kind {\n+            self.0.push(ex);\n+        }\n+        hir::intravisit::walk_expr(self, ex);\n+    }\n+\n+    fn visit_body(&mut self, body: &'v hir::Body<'v>) {\n+        if body.generator_kind().is_none() {\n+            if let hir::ExprKind::Block(block, None) = body.value.kind {\n+                if let Some(expr) = block.expr {\n+                    self.0.push(expr);\n+                }\n+            }\n+        }\n+        hir::intravisit::walk_body(self, body);\n+    }\n+}"}, {"sha": "9e5abc80822c7cf5d5653355bfc25acc4e7b289f", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -16,6 +16,7 @@ use super::CodeSelectionError;\n use super::{ConstEvalFailure, Unimplemented};\n use super::{FulfillmentError, FulfillmentErrorCode};\n use super::{ObligationCause, PredicateObligation};\n+use crate::traits::TraitQueryMode;\n \n impl<'tcx> ForestObligation for PendingPredicateObligation<'tcx> {\n     type Predicate = ty::Predicate<'tcx>;\n@@ -62,6 +63,9 @@ pub struct FulfillmentContext<'tcx> {\n     // a snapshot (they don't *straddle* a snapshot, so there\n     // is no trouble there).\n     usable_in_snapshot: bool,\n+\n+    // The `TraitQueryMode` used when constructing a `SelectionContext`\n+    query_mode: TraitQueryMode,\n }\n \n #[derive(Clone, Debug)]\n@@ -75,12 +79,26 @@ pub struct PendingPredicateObligation<'tcx> {\n static_assert_size!(PendingPredicateObligation<'_>, 136);\n \n impl<'a, 'tcx> FulfillmentContext<'tcx> {\n-    /// Creates a new fulfillment context.\n+    /// Creates a new fulfillment context with `TraitQueryMode::Standard`\n+    /// You almost always want to use this instead of `with_query_mode`\n     pub fn new() -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n             predicates: ObligationForest::new(),\n             register_region_obligations: true,\n             usable_in_snapshot: false,\n+            query_mode: TraitQueryMode::Standard,\n+        }\n+    }\n+\n+    /// Creates a new fulfillment context with the specified query mode.\n+    /// This should only be used when you want to ignore overflow,\n+    /// rather than reporting it as an error.\n+    pub fn with_query_mode(query_mode: TraitQueryMode) -> FulfillmentContext<'tcx> {\n+        FulfillmentContext {\n+            predicates: ObligationForest::new(),\n+            register_region_obligations: true,\n+            usable_in_snapshot: false,\n+            query_mode,\n         }\n     }\n \n@@ -89,6 +107,7 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n             predicates: ObligationForest::new(),\n             register_region_obligations: true,\n             usable_in_snapshot: true,\n+            query_mode: TraitQueryMode::Standard,\n         }\n     }\n \n@@ -97,6 +116,7 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n             predicates: ObligationForest::new(),\n             register_region_obligations: false,\n             usable_in_snapshot: false,\n+            query_mode: TraitQueryMode::Standard,\n         }\n     }\n \n@@ -217,7 +237,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n         &mut self,\n         infcx: &InferCtxt<'_, 'tcx>,\n     ) -> Result<(), Vec<FulfillmentError<'tcx>>> {\n-        let mut selcx = SelectionContext::new(infcx);\n+        let mut selcx = SelectionContext::with_query_mode(infcx, self.query_mode);\n         self.select(&mut selcx)\n     }\n "}, {"sha": "2e5da2b038254f7ab45131821d959b34b13d29c0", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -95,7 +95,7 @@ pub enum IntercrateMode {\n }\n \n /// The mode that trait queries run in.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, HashStable)]\n pub enum TraitQueryMode {\n     // Standard/un-canonicalized queries get accurate\n     // spans etc. passed in and hence can do reasonable\n@@ -155,8 +155,8 @@ pub struct ObligationCause<'tcx> {\n     pub code: ObligationCauseCode<'tcx>,\n }\n \n-impl<'tcx> ObligationCause<'tcx> {\n-    pub fn span(&self, tcx: TyCtxt<'tcx>) -> Span {\n+impl ObligationCause<'_> {\n+    pub fn span(&self, tcx: TyCtxt<'_>) -> Span {\n         match self.code {\n             ObligationCauseCode::CompareImplMethodObligation { .. }\n             | ObligationCauseCode::MainFunctionType\n@@ -1017,13 +1017,14 @@ where\n fn normalize_and_test_predicates<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     predicates: Vec<ty::Predicate<'tcx>>,\n+    mode: TraitQueryMode,\n ) -> bool {\n-    debug!(\"normalize_and_test_predicates(predicates={:?})\", predicates);\n+    debug!(\"normalize_and_test_predicates(predicates={:?}, mode={:?})\", predicates, mode);\n \n     let result = tcx.infer_ctxt().enter(|infcx| {\n         let param_env = ty::ParamEnv::reveal_all();\n-        let mut selcx = SelectionContext::new(&infcx);\n-        let mut fulfill_cx = FulfillmentContext::new();\n+        let mut selcx = SelectionContext::with_query_mode(&infcx, mode);\n+        let mut fulfill_cx = FulfillmentContext::with_query_mode(mode);\n         let cause = ObligationCause::dummy();\n         let Normalized { value: predicates, obligations } =\n             normalize(&mut selcx, param_env, cause.clone(), &predicates);\n@@ -1043,12 +1044,12 @@ fn normalize_and_test_predicates<'tcx>(\n \n fn substitute_normalize_and_test_predicates<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    key: (DefId, SubstsRef<'tcx>),\n+    key: (DefId, SubstsRef<'tcx>, TraitQueryMode),\n ) -> bool {\n     debug!(\"substitute_normalize_and_test_predicates(key={:?})\", key);\n \n     let predicates = tcx.predicates_of(key.0).instantiate(tcx, key.1).predicates;\n-    let result = normalize_and_test_predicates(tcx, predicates);\n+    let result = normalize_and_test_predicates(tcx, predicates, key.2);\n \n     debug!(\"substitute_normalize_and_test_predicates(key={:?}) = {:?}\", key, result);\n     result\n@@ -1101,7 +1102,10 @@ fn vtable_methods<'tcx>(\n             // Note that this method could then never be called, so we\n             // do not want to try and codegen it, in that case (see #23435).\n             let predicates = tcx.predicates_of(def_id).instantiate_own(tcx, substs);\n-            if !normalize_and_test_predicates(tcx, predicates.predicates) {\n+            // We don't expect overflow here, so report an error if it somehow ends\n+            // up happening.\n+            if !normalize_and_test_predicates(tcx, predicates.predicates, TraitQueryMode::Standard)\n+            {\n                 debug!(\"vtable_methods: predicates do not hold\");\n                 return None;\n             }\n@@ -1167,6 +1171,17 @@ impl<'tcx> ObligationCause<'tcx> {\n     }\n }\n \n+impl ObligationCauseCode<'_> {\n+    // Return the base obligation, ignoring derived obligations.\n+    pub fn peel_derives(&self) -> &Self {\n+        let mut base_cause = self;\n+        while let BuiltinDerivedObligation(cause) | ImplDerivedObligation(cause) = base_cause {\n+            base_cause = &cause.parent_code;\n+        }\n+        base_cause\n+    }\n+}\n+\n impl<'tcx, N> Vtable<'tcx, N> {\n     pub fn nested_obligations(self) -> Vec<N> {\n         match self {"}, {"sha": "3bfe542baabbf82a8e4245f545620d6d15cfab26", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 63, "deletions": 15, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1417,14 +1417,20 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         debug!(\"winnowed to {} candidates for {:?}: {:?}\", candidates.len(), stack, candidates);\n \n+        let needs_infer = stack.obligation.predicate.needs_infer();\n+\n         // If there are STILL multiple candidates, we can further\n         // reduce the list by dropping duplicates -- including\n         // resolving specializations.\n         if candidates.len() > 1 {\n             let mut i = 0;\n             while i < candidates.len() {\n                 let is_dup = (0..candidates.len()).filter(|&j| i != j).any(|j| {\n-                    self.candidate_should_be_dropped_in_favor_of(&candidates[i], &candidates[j])\n+                    self.candidate_should_be_dropped_in_favor_of(\n+                        &candidates[i],\n+                        &candidates[j],\n+                        needs_infer,\n+                    )\n                 });\n                 if is_dup {\n                     debug!(\"Dropping candidate #{}/{}: {:?}\", i, candidates.len(), candidates[i]);\n@@ -2258,6 +2264,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         &mut self,\n         victim: &EvaluatedCandidate<'tcx>,\n         other: &EvaluatedCandidate<'tcx>,\n+        needs_infer: bool,\n     ) -> bool {\n         if victim.candidate == other.candidate {\n             return true;\n@@ -2339,10 +2346,55 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     match victim.candidate {\n                         ImplCandidate(victim_def) => {\n                             let tcx = self.tcx();\n-                            return tcx.specializes((other_def, victim_def))\n-                                || tcx\n-                                    .impls_are_allowed_to_overlap(other_def, victim_def)\n-                                    .is_some();\n+                            if tcx.specializes((other_def, victim_def)) {\n+                                return true;\n+                            }\n+                            return match tcx.impls_are_allowed_to_overlap(other_def, victim_def) {\n+                                Some(ty::ImplOverlapKind::Permitted { marker: true }) => {\n+                                    // Subtle: If the predicate we are evaluating has inference\n+                                    // variables, do *not* allow discarding candidates due to\n+                                    // marker trait impls.\n+                                    //\n+                                    // Without this restriction, we could end up accidentally\n+                                    // constrainting inference variables based on an arbitrarily\n+                                    // chosen trait impl.\n+                                    //\n+                                    // Imagine we have the following code:\n+                                    //\n+                                    // ```rust\n+                                    // #[marker] trait MyTrait {}\n+                                    // impl MyTrait for u8 {}\n+                                    // impl MyTrait for bool {}\n+                                    // ```\n+                                    //\n+                                    // And we are evaluating the predicate `<_#0t as MyTrait>`.\n+                                    //\n+                                    // During selection, we will end up with one candidate for each\n+                                    // impl of `MyTrait`. If we were to discard one impl in favor\n+                                    // of the other, we would be left with one candidate, causing\n+                                    // us to \"successfully\" select the predicate, unifying\n+                                    // _#0t with (for example) `u8`.\n+                                    //\n+                                    // However, we have no reason to believe that this unification\n+                                    // is correct - we've essentially just picked an arbitrary\n+                                    // *possibility* for _#0t, and required that this be the *only*\n+                                    // possibility.\n+                                    //\n+                                    // Eventually, we will either:\n+                                    // 1) Unify all inference variables in the predicate through\n+                                    // some other means (e.g. type-checking of a function). We will\n+                                    // then be in a position to drop marker trait candidates\n+                                    // without constraining inference variables (since there are\n+                                    // none left to constrin)\n+                                    // 2) Be left with some unconstrained inference variables. We\n+                                    // will then correctly report an inference error, since the\n+                                    // existence of multiple marker trait impls tells us nothing\n+                                    // about which one should actually apply.\n+                                    !needs_infer\n+                                }\n+                                Some(_) => true,\n+                                None => false,\n+                            };\n                         }\n                         ParamCandidate(ref cand) => {\n                             // Prefer the impl to a global where clause candidate.\n@@ -3767,16 +3819,12 @@ impl<'tcx> TraitObligation<'tcx> {\n         // NOTE(flaper87): As of now, it keeps track of the whole error\n         // chain. Ideally, we should have a way to configure this either\n         // by using -Z verbose or just a CLI argument.\n-        if obligation.recursion_depth >= 0 {\n-            let derived_cause = DerivedObligationCause {\n-                parent_trait_ref: obligation.predicate.to_poly_trait_ref(),\n-                parent_code: Rc::new(obligation.cause.code.clone()),\n-            };\n-            let derived_code = variant(derived_cause);\n-            ObligationCause::new(obligation.cause.span, obligation.cause.body_id, derived_code)\n-        } else {\n-            obligation.cause.clone()\n-        }\n+        let derived_cause = DerivedObligationCause {\n+            parent_trait_ref: obligation.predicate.to_poly_trait_ref(),\n+            parent_code: Rc::new(obligation.cause.code.clone()),\n+        };\n+        let derived_code = variant(derived_cause);\n+        ObligationCause::new(obligation.cause.span, obligation.cause.body_id, derived_code)\n     }\n }\n "}, {"sha": "9509b6220eb0ed15d6d49db5445686b7225545fe", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -163,7 +163,7 @@ impl<'tcx> Children {\n                         tcx.impls_are_allowed_to_overlap(impl_def_id, possible_sibling)\n                     {\n                         match overlap_kind {\n-                            ty::ImplOverlapKind::Permitted => {}\n+                            ty::ImplOverlapKind::Permitted { marker: _ } => {}\n                             ty::ImplOverlapKind::Issue33140 => {\n                                 last_lint = Some(FutureCompatOverlapError {\n                                     error: overlap_error(overlap),"}, {"sha": "f058a4d2df24a60ed4626126e74092c8dc0a92ee", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -651,7 +651,7 @@ pub fn impl_is_default(tcx: TyCtxt<'_>, node_item_def_id: DefId) -> bool {\n     match tcx.hir().as_local_hir_id(node_item_def_id) {\n         Some(hir_id) => {\n             let item = tcx.hir().expect_item(hir_id);\n-            if let hir::ItemKind::Impl(_, _, defaultness, ..) = item.kind {\n+            if let hir::ItemKind::Impl { defaultness, .. } = item.kind {\n                 defaultness.is_default()\n             } else {\n                 false"}, {"sha": "869ba5315c1aee3c5fab435e6e723be9b05bdfad", "filename": "src/librustc/traits/wf.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fwf.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -229,9 +229,9 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                         //      |\n                         //      = note: expected type `u32`\n                         //                 found type `()`\n-                        if let Some(hir::ItemKind::Impl(.., impl_items)) = item.map(|i| &i.kind) {\n+                        if let Some(hir::ItemKind::Impl { items, .. }) = item.map(|i| &i.kind) {\n                             let trait_assoc_item = tcx.associated_item(proj.projection_def_id());\n-                            if let Some(impl_item) = impl_items\n+                            if let Some(impl_item) = items\n                                 .iter()\n                                 .filter(|item| item.ident == trait_assoc_item.ident)\n                                 .next()\n@@ -279,14 +279,14 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                         //      |     ^^^^^^^^^^^^^^^^^^ the trait `Bar` is not implemented for `bool`\n                         if let (\n                             ty::Projection(ty::ProjectionTy { item_def_id, .. }),\n-                            Some(hir::ItemKind::Impl(.., impl_items)),\n+                            Some(hir::ItemKind::Impl { items, .. }),\n                         ) = (&proj.skip_binder().self_ty().kind, item.map(|i| &i.kind))\n                         {\n                             if let Some((impl_item, trait_assoc_item)) = trait_assoc_items\n                                 .filter(|i| i.def_id == *item_def_id)\n                                 .next()\n                                 .and_then(|trait_assoc_item| {\n-                                    impl_items\n+                                    items\n                                         .iter()\n                                         .filter(|i| i.ident == trait_assoc_item.ident)\n                                         .next()"}, {"sha": "db034d1618cea6cb35659e1792760e3418c47e5a", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -81,6 +81,15 @@ pub struct Adjustment<'tcx> {\n     pub target: Ty<'tcx>,\n }\n \n+impl Adjustment<'tcx> {\n+    pub fn is_region_borrow(&self) -> bool {\n+        match self.kind {\n+            Adjust::Borrow(AutoBorrow::Ref(..)) => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n pub enum Adjust<'tcx> {\n     /// Go from ! to any type."}, {"sha": "a51f0f7f24c368e6f8aebcc45fb6a023c745c0c0", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 30, "deletions": 36, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -51,10 +51,9 @@ use rustc_session::config::CrateType;\n use rustc_session::config::{BorrowckMode, OutputFilenames};\n use rustc_session::Session;\n \n-use arena::SyncDroplessArena;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::profiling::SelfProfilerRef;\n-use rustc_data_structures::sharded::ShardedHashMap;\n+use rustc_data_structures::sharded::{IntoPointer, ShardedHashMap};\n use rustc_data_structures::stable_hasher::{\n     hash_stable_hashmap, HashStable, StableHasher, StableVec,\n };\n@@ -83,21 +82,11 @@ use syntax::ast;\n use syntax::attr;\n use syntax::expand::allocator::AllocatorKind;\n \n-pub struct AllArenas {\n-    pub interner: SyncDroplessArena,\n-}\n-\n-impl AllArenas {\n-    pub fn new() -> Self {\n-        AllArenas { interner: SyncDroplessArena::default() }\n-    }\n-}\n-\n type InternedSet<'tcx, T> = ShardedHashMap<Interned<'tcx, T>, ()>;\n \n pub struct CtxtInterners<'tcx> {\n     /// The arena that types, regions, etc. are allocated from.\n-    arena: &'tcx SyncDroplessArena,\n+    arena: &'tcx WorkerLocal<Arena<'tcx>>,\n \n     /// Specifically use a speedy hash algorithm for these hash sets, since\n     /// they're accessed quite often.\n@@ -117,7 +106,7 @@ pub struct CtxtInterners<'tcx> {\n }\n \n impl<'tcx> CtxtInterners<'tcx> {\n-    fn new(arena: &'tcx SyncDroplessArena) -> CtxtInterners<'tcx> {\n+    fn new(arena: &'tcx WorkerLocal<Arena<'tcx>>) -> CtxtInterners<'tcx> {\n         CtxtInterners {\n             arena,\n             type_: Default::default(),\n@@ -315,15 +304,16 @@ pub struct ResolvedOpaqueTy<'tcx> {\n ///\n /// Here, we would store the type `T`, the span of the value `x`, and the \"scope-span\" for\n /// the scope that contains `x`.\n-#[derive(RustcEncodable, RustcDecodable, Clone, Debug, Eq, Hash, PartialEq)]\n-#[derive(HashStable, TypeFoldable)]\n+#[derive(RustcEncodable, RustcDecodable, Clone, Debug, Eq, Hash, PartialEq, HashStable)]\n pub struct GeneratorInteriorTypeCause<'tcx> {\n     /// Type of the captured binding.\n     pub ty: Ty<'tcx>,\n     /// Span of the binding that was captured.\n     pub span: Span,\n     /// Span of the scope of the captured binding.\n     pub scope_span: Option<Span>,\n+    /// Expr which the type evaluated from.\n+    pub expr: Option<hir::HirId>,\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug)]\n@@ -436,7 +426,7 @@ pub struct TypeckTables<'tcx> {\n     /// entire variable.\n     pub upvar_list: ty::UpvarListMap,\n \n-    /// Stores the type, span and optional scope span of all types\n+    /// Stores the type, expression, span and optional scope span of all types\n     /// that are live across the yield of this generator (if a generator).\n     pub generator_interior_types: Vec<GeneratorInteriorTypeCause<'tcx>>,\n }\n@@ -1124,7 +1114,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         lint_store: Lrc<dyn Any + sync::Send + sync::Sync>,\n         local_providers: ty::query::Providers<'tcx>,\n         extern_providers: ty::query::Providers<'tcx>,\n-        arenas: &'tcx AllArenas,\n         arena: &'tcx WorkerLocal<Arena<'tcx>>,\n         resolutions: ty::ResolverOutputs,\n         hir: hir_map::Map<'tcx>,\n@@ -1135,7 +1124,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let data_layout = TargetDataLayout::parse(&s.target.target).unwrap_or_else(|err| {\n             s.fatal(&err);\n         });\n-        let interners = CtxtInterners::new(&arenas.interner);\n+        let interners = CtxtInterners::new(arena);\n         let common_types = CommonTypes::new(&interners);\n         let common_lifetimes = CommonLifetimes::new(&interners);\n         let common_consts = CommonConsts::new(&interners, &common_types);\n@@ -1566,11 +1555,11 @@ pub trait Lift<'tcx>: fmt::Debug {\n }\n \n macro_rules! nop_lift {\n-    ($ty:ty => $lifted:ty) => {\n+    ($set:ident; $ty:ty => $lifted:ty) => {\n         impl<'a, 'tcx> Lift<'tcx> for $ty {\n             type Lifted = $lifted;\n             fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-                if tcx.interners.arena.in_arena(*self as *const _) {\n+                if tcx.interners.$set.contains_pointer_to(&Interned(*self)) {\n                     Some(unsafe { mem::transmute(*self) })\n                 } else {\n                     None\n@@ -1581,14 +1570,14 @@ macro_rules! nop_lift {\n }\n \n macro_rules! nop_list_lift {\n-    ($ty:ty => $lifted:ty) => {\n+    ($set:ident; $ty:ty => $lifted:ty) => {\n         impl<'a, 'tcx> Lift<'tcx> for &'a List<$ty> {\n             type Lifted = &'tcx List<$lifted>;\n             fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n                 if self.is_empty() {\n                     return Some(List::empty());\n                 }\n-                if tcx.interners.arena.in_arena(*self as *const _) {\n+                if tcx.interners.$set.contains_pointer_to(&Interned(*self)) {\n                     Some(unsafe { mem::transmute(*self) })\n                 } else {\n                     None\n@@ -1598,21 +1587,21 @@ macro_rules! nop_list_lift {\n     };\n }\n \n-nop_lift! {Ty<'a> => Ty<'tcx>}\n-nop_lift! {Region<'a> => Region<'tcx>}\n-nop_lift! {Goal<'a> => Goal<'tcx>}\n-nop_lift! {&'a Const<'a> => &'tcx Const<'tcx>}\n+nop_lift! {type_; Ty<'a> => Ty<'tcx>}\n+nop_lift! {region; Region<'a> => Region<'tcx>}\n+nop_lift! {goal; Goal<'a> => Goal<'tcx>}\n+nop_lift! {const_; &'a Const<'a> => &'tcx Const<'tcx>}\n \n-nop_list_lift! {Goal<'a> => Goal<'tcx>}\n-nop_list_lift! {Clause<'a> => Clause<'tcx>}\n-nop_list_lift! {Ty<'a> => Ty<'tcx>}\n-nop_list_lift! {ExistentialPredicate<'a> => ExistentialPredicate<'tcx>}\n-nop_list_lift! {Predicate<'a> => Predicate<'tcx>}\n-nop_list_lift! {CanonicalVarInfo => CanonicalVarInfo}\n-nop_list_lift! {ProjectionKind => ProjectionKind}\n+nop_list_lift! {goal_list; Goal<'a> => Goal<'tcx>}\n+nop_list_lift! {clauses; Clause<'a> => Clause<'tcx>}\n+nop_list_lift! {type_list; Ty<'a> => Ty<'tcx>}\n+nop_list_lift! {existential_predicates; ExistentialPredicate<'a> => ExistentialPredicate<'tcx>}\n+nop_list_lift! {predicates; Predicate<'a> => Predicate<'tcx>}\n+nop_list_lift! {canonical_var_infos; CanonicalVarInfo => CanonicalVarInfo}\n+nop_list_lift! {projs; ProjectionKind => ProjectionKind}\n \n // This is the impl for `&'a InternalSubsts<'a>`.\n-nop_list_lift! {GenericArg<'a> => GenericArg<'tcx>}\n+nop_list_lift! {substs; GenericArg<'a> => GenericArg<'tcx>}\n \n pub mod tls {\n     use super::{ptr_eq, GlobalCtxt, TyCtxt};\n@@ -1936,6 +1925,11 @@ impl<'tcx, T: 'tcx + ?Sized> Clone for Interned<'tcx, T> {\n }\n impl<'tcx, T: 'tcx + ?Sized> Copy for Interned<'tcx, T> {}\n \n+impl<'tcx, T: 'tcx + ?Sized> IntoPointer for Interned<'tcx, T> {\n+    fn into_pointer(&self) -> *const () {\n+        self.0 as *const _ as *const ()\n+    }\n+}\n // N.B., an `Interned<Ty>` compares and hashes as a `TyKind`.\n impl<'tcx> PartialEq for Interned<'tcx, TyS<'tcx>> {\n     fn eq(&self, other: &Interned<'tcx, TyS<'tcx>>) -> bool {\n@@ -2088,7 +2082,7 @@ macro_rules! slice_interners {\n         $(impl<'tcx> TyCtxt<'tcx> {\n             pub fn $method(self, v: &[$ty]) -> &'tcx List<$ty> {\n                 self.interners.$field.intern_ref(v, || {\n-                    Interned(List::from_arena(&self.interners.arena, v))\n+                    Interned(List::from_arena(&*self.arena, v))\n                 }).0\n             }\n         })+"}, {"sha": "217ca0ca3f6f51d38e464b578ddadaaf16593370", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -244,9 +244,9 @@ impl<'tcx> ty::TyS<'tcx> {\n             ty::FnPtr(_) => \"fn pointer\".into(),\n             ty::Dynamic(ref inner, ..) => {\n                 if let Some(principal) = inner.principal() {\n-                    format!(\"trait `{}`\", tcx.def_path_str(principal.def_id())).into()\n+                    format!(\"trait object `dyn {}`\", tcx.def_path_str(principal.def_id())).into()\n                 } else {\n-                    \"trait\".into()\n+                    \"trait object\".into()\n                 }\n             }\n             ty::Closure(..) => \"closure\".into(),"}, {"sha": "3040ecf90ed53b95925f8ed254c0c204067b80e4", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 17, "deletions": 362, "changes": 379, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -6,6 +6,7 @@ pub use self::BorrowKind::*;\n pub use self::IntVarValue::*;\n pub use self::Variance::*;\n \n+use crate::arena::Arena;\n use crate::hir::exports::ExportMap;\n use crate::hir::map as hir_map;\n \n@@ -18,20 +19,17 @@ use crate::middle::resolve_lifetime::ObjectLifetimeDefault;\n use crate::mir::interpret::ErrorHandled;\n use crate::mir::GeneratorLayout;\n use crate::mir::ReadOnlyBodyAndCache;\n-use crate::session::CrateDisambiguator;\n use crate::session::DataTypeKind;\n use crate::traits::{self, Reveal};\n use crate::ty;\n use crate::ty::layout::VariantIdx;\n use crate::ty::subst::{InternalSubsts, Subst, SubstsRef};\n use crate::ty::util::{Discr, IntTypeExt};\n use crate::ty::walk::TypeWalker;\n-use arena::SyncDroplessArena;\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::fx::FxIndexMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::{self, par_iter, Lrc, ParallelIterator};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n@@ -76,7 +74,7 @@ pub use crate::ty::diagnostics::*;\n pub use self::binding::BindingMode;\n pub use self::binding::BindingMode::*;\n \n-pub use self::context::{keep_local, tls, AllArenas, FreeRegionInfo, TyCtxt};\n+pub use self::context::{keep_local, tls, FreeRegionInfo, TyCtxt};\n pub use self::context::{\n     CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations, ResolvedOpaqueTy,\n     UserType, UserTypeAnnotationIndex,\n@@ -606,7 +604,7 @@ unsafe impl<T: Sync> Sync for List<T> {}\n \n impl<T: Copy> List<T> {\n     #[inline]\n-    fn from_arena<'tcx>(arena: &'tcx SyncDroplessArena, slice: &[T]) -> &'tcx List<T> {\n+    fn from_arena<'tcx>(arena: &'tcx Arena<'tcx>, slice: &[T]) -> &'tcx List<T> {\n         assert!(!mem::needs_drop::<T>());\n         assert!(mem::size_of::<T>() != 0);\n         assert!(slice.len() != 0);\n@@ -619,7 +617,9 @@ impl<T: Copy> List<T> {\n \n         let size = offset + slice.len() * mem::size_of::<T>();\n \n-        let mem = arena.alloc_raw(size, cmp::max(mem::align_of::<T>(), mem::align_of::<usize>()));\n+        let mem = arena\n+            .dropless\n+            .alloc_raw(size, cmp::max(mem::align_of::<T>(), mem::align_of::<usize>()));\n         unsafe {\n             let result = &mut *(mem.as_mut_ptr() as *mut List<T>);\n             // Write the length\n@@ -2423,70 +2423,6 @@ impl<'tcx> AdtDef {\n     pub fn sized_constraint(&self, tcx: TyCtxt<'tcx>) -> &'tcx [Ty<'tcx>] {\n         tcx.adt_sized_constraint(self.did).0\n     }\n-\n-    fn sized_constraint_for_ty(&self, tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Vec<Ty<'tcx>> {\n-        let result = match ty.kind {\n-            Bool | Char | Int(..) | Uint(..) | Float(..) | RawPtr(..) | Ref(..) | FnDef(..)\n-            | FnPtr(_) | Array(..) | Closure(..) | Generator(..) | Never => vec![],\n-\n-            Str | Dynamic(..) | Slice(_) | Foreign(..) | Error | GeneratorWitness(..) => {\n-                // these are never sized - return the target type\n-                vec![ty]\n-            }\n-\n-            Tuple(ref tys) => match tys.last() {\n-                None => vec![],\n-                Some(ty) => self.sized_constraint_for_ty(tcx, ty.expect_ty()),\n-            },\n-\n-            Adt(adt, substs) => {\n-                // recursive case\n-                let adt_tys = adt.sized_constraint(tcx);\n-                debug!(\"sized_constraint_for_ty({:?}) intermediate = {:?}\", ty, adt_tys);\n-                adt_tys\n-                    .iter()\n-                    .map(|ty| ty.subst(tcx, substs))\n-                    .flat_map(|ty| self.sized_constraint_for_ty(tcx, ty))\n-                    .collect()\n-            }\n-\n-            Projection(..) | Opaque(..) => {\n-                // must calculate explicitly.\n-                // FIXME: consider special-casing always-Sized projections\n-                vec![ty]\n-            }\n-\n-            UnnormalizedProjection(..) => bug!(\"only used with chalk-engine\"),\n-\n-            Param(..) => {\n-                // perf hack: if there is a `T: Sized` bound, then\n-                // we know that `T` is Sized and do not need to check\n-                // it on the impl.\n-\n-                let sized_trait = match tcx.lang_items().sized_trait() {\n-                    Some(x) => x,\n-                    _ => return vec![ty],\n-                };\n-                let sized_predicate = Binder::dummy(TraitRef {\n-                    def_id: sized_trait,\n-                    substs: tcx.mk_substs_trait(ty, &[]),\n-                })\n-                .to_predicate();\n-                let predicates = tcx.predicates_of(self.did).predicates;\n-                if predicates.iter().any(|(p, _)| *p == sized_predicate) {\n-                    vec![]\n-                } else {\n-                    vec![ty]\n-                }\n-            }\n-\n-            Placeholder(..) | Bound(..) | Infer(..) => {\n-                bug!(\"unexpected type `{:?}` in sized_constraint_for_ty\", ty)\n-            }\n-        };\n-        debug!(\"sized_constraint_for_ty({:?}) = {:?}\", ty, result);\n-        result\n-    }\n }\n \n impl<'tcx> FieldDef {\n@@ -2655,7 +2591,12 @@ impl<'tcx> ::std::ops::Deref for Attributes<'tcx> {\n #[derive(Debug, PartialEq, Eq)]\n pub enum ImplOverlapKind {\n     /// These impls are always allowed to overlap.\n-    Permitted,\n+    Permitted {\n+        /// Whether or not the impl is permitted due to the trait being\n+        /// a marker trait (a trait with #[marker], or a trait with\n+        /// no associated items and #![feature(overlapping_marker_traits)] enabled)\n+        marker: bool,\n+    },\n     /// These impls are allowed to overlap, but that raises\n     /// an issue #33140 future-compatibility warning.\n     ///\n@@ -2742,57 +2683,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         is_associated_item.then(|| self.associated_item(def_id))\n     }\n \n-    fn associated_item_from_trait_item_ref(\n-        self,\n-        parent_def_id: DefId,\n-        parent_vis: &hir::Visibility<'_>,\n-        trait_item_ref: &hir::TraitItemRef,\n-    ) -> AssocItem {\n-        let def_id = self.hir().local_def_id(trait_item_ref.id.hir_id);\n-        let (kind, has_self) = match trait_item_ref.kind {\n-            hir::AssocItemKind::Const => (ty::AssocKind::Const, false),\n-            hir::AssocItemKind::Method { has_self } => (ty::AssocKind::Method, has_self),\n-            hir::AssocItemKind::Type => (ty::AssocKind::Type, false),\n-            hir::AssocItemKind::OpaqueTy => bug!(\"only impls can have opaque types\"),\n-        };\n-\n-        AssocItem {\n-            ident: trait_item_ref.ident,\n-            kind,\n-            // Visibility of trait items is inherited from their traits.\n-            vis: Visibility::from_hir(parent_vis, trait_item_ref.id.hir_id, self),\n-            defaultness: trait_item_ref.defaultness,\n-            def_id,\n-            container: TraitContainer(parent_def_id),\n-            method_has_self_argument: has_self,\n-        }\n-    }\n-\n-    fn associated_item_from_impl_item_ref(\n-        self,\n-        parent_def_id: DefId,\n-        impl_item_ref: &hir::ImplItemRef<'_>,\n-    ) -> AssocItem {\n-        let def_id = self.hir().local_def_id(impl_item_ref.id.hir_id);\n-        let (kind, has_self) = match impl_item_ref.kind {\n-            hir::AssocItemKind::Const => (ty::AssocKind::Const, false),\n-            hir::AssocItemKind::Method { has_self } => (ty::AssocKind::Method, has_self),\n-            hir::AssocItemKind::Type => (ty::AssocKind::Type, false),\n-            hir::AssocItemKind::OpaqueTy => (ty::AssocKind::OpaqueTy, false),\n-        };\n-\n-        AssocItem {\n-            ident: impl_item_ref.ident,\n-            kind,\n-            // Visibility of trait impl items doesn't matter.\n-            vis: ty::Visibility::from_hir(&impl_item_ref.vis, impl_item_ref.id.hir_id, self),\n-            defaultness: impl_item_ref.defaultness,\n-            def_id,\n-            container: ImplContainer(parent_def_id),\n-            method_has_self_argument: has_self,\n-        }\n-    }\n-\n     pub fn field_index(self, hir_id: hir::HirId, tables: &TypeckTables<'_>) -> usize {\n         tables.field_indices().get(hir_id).cloned().expect(\"no index for a field\")\n     }\n@@ -2826,7 +2716,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if self.impl_trait_ref(def_id1).map_or(false, |tr| tr.references_error())\n             || self.impl_trait_ref(def_id2).map_or(false, |tr| tr.references_error())\n         {\n-            return Some(ImplOverlapKind::Permitted);\n+            return Some(ImplOverlapKind::Permitted { marker: false });\n         }\n \n         match (self.impl_polarity(def_id1), self.impl_polarity(def_id2)) {\n@@ -2836,7 +2726,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                     \"impls_are_allowed_to_overlap({:?}, {:?}) = Some(Permitted) (reservations)\",\n                     def_id1, def_id2\n                 );\n-                return Some(ImplOverlapKind::Permitted);\n+                return Some(ImplOverlapKind::Permitted { marker: false });\n             }\n             (ImplPolarity::Positive, ImplPolarity::Negative)\n             | (ImplPolarity::Negative, ImplPolarity::Positive) => {\n@@ -2872,7 +2762,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 \"impls_are_allowed_to_overlap({:?}, {:?}) = Some(Permitted) (marker overlap)\",\n                 def_id1, def_id2\n             );\n-            Some(ImplOverlapKind::Permitted)\n+            Some(ImplOverlapKind::Permitted { marker: true })\n         } else {\n             if let Some(self_ty1) = self.issue33140_self_ty(def_id1) {\n                 if let Some(self_ty2) = self.issue33140_self_ty(def_id2) {\n@@ -3070,105 +2960,9 @@ impl Iterator for AssocItemsIterator<'_> {\n     }\n }\n \n-fn associated_item(tcx: TyCtxt<'_>, def_id: DefId) -> AssocItem {\n-    let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    let parent_id = tcx.hir().get_parent_item(id);\n-    let parent_def_id = tcx.hir().local_def_id(parent_id);\n-    let parent_item = tcx.hir().expect_item(parent_id);\n-    match parent_item.kind {\n-        hir::ItemKind::Impl(.., ref impl_item_refs) => {\n-            if let Some(impl_item_ref) = impl_item_refs.iter().find(|i| i.id.hir_id == id) {\n-                let assoc_item =\n-                    tcx.associated_item_from_impl_item_ref(parent_def_id, impl_item_ref);\n-                debug_assert_eq!(assoc_item.def_id, def_id);\n-                return assoc_item;\n-            }\n-        }\n-\n-        hir::ItemKind::Trait(.., ref trait_item_refs) => {\n-            if let Some(trait_item_ref) = trait_item_refs.iter().find(|i| i.id.hir_id == id) {\n-                let assoc_item = tcx.associated_item_from_trait_item_ref(\n-                    parent_def_id,\n-                    &parent_item.vis,\n-                    trait_item_ref,\n-                );\n-                debug_assert_eq!(assoc_item.def_id, def_id);\n-                return assoc_item;\n-            }\n-        }\n-\n-        _ => {}\n-    }\n-\n-    span_bug!(\n-        parent_item.span,\n-        \"unexpected parent of trait or impl item or item not found: {:?}\",\n-        parent_item.kind\n-    )\n-}\n-\n #[derive(Clone, HashStable)]\n pub struct AdtSizedConstraint<'tcx>(pub &'tcx [Ty<'tcx>]);\n \n-/// Calculates the `Sized` constraint.\n-///\n-/// In fact, there are only a few options for the types in the constraint:\n-///     - an obviously-unsized type\n-///     - a type parameter or projection whose Sizedness can't be known\n-///     - a tuple of type parameters or projections, if there are multiple\n-///       such.\n-///     - a Error, if a type contained itself. The representability\n-///       check should catch this case.\n-fn adt_sized_constraint(tcx: TyCtxt<'_>, def_id: DefId) -> AdtSizedConstraint<'_> {\n-    let def = tcx.adt_def(def_id);\n-\n-    let result = tcx.mk_type_list(\n-        def.variants\n-            .iter()\n-            .flat_map(|v| v.fields.last())\n-            .flat_map(|f| def.sized_constraint_for_ty(tcx, tcx.type_of(f.did))),\n-    );\n-\n-    debug!(\"adt_sized_constraint: {:?} => {:?}\", def, result);\n-\n-    AdtSizedConstraint(result)\n-}\n-\n-fn associated_item_def_ids(tcx: TyCtxt<'_>, def_id: DefId) -> &[DefId] {\n-    let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    let item = tcx.hir().expect_item(id);\n-    match item.kind {\n-        hir::ItemKind::Trait(.., ref trait_item_refs) => tcx.arena.alloc_from_iter(\n-            trait_item_refs\n-                .iter()\n-                .map(|trait_item_ref| trait_item_ref.id)\n-                .map(|id| tcx.hir().local_def_id(id.hir_id)),\n-        ),\n-        hir::ItemKind::Impl(.., ref impl_item_refs) => tcx.arena.alloc_from_iter(\n-            impl_item_refs\n-                .iter()\n-                .map(|impl_item_ref| impl_item_ref.id)\n-                .map(|id| tcx.hir().local_def_id(id.hir_id)),\n-        ),\n-        hir::ItemKind::TraitAlias(..) => &[],\n-        _ => span_bug!(item.span, \"associated_item_def_ids: not impl or trait\"),\n-    }\n-}\n-\n-fn def_span(tcx: TyCtxt<'_>, def_id: DefId) -> Span {\n-    tcx.hir().span_if_local(def_id).unwrap()\n-}\n-\n-/// If the given `DefId` describes an item belonging to a trait,\n-/// returns the `DefId` of the trait that the trait item belongs to;\n-/// otherwise, returns `None`.\n-fn trait_of_item(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n-    tcx.opt_associated_item(def_id).and_then(|associated_item| match associated_item.container {\n-        TraitContainer(def_id) => Some(def_id),\n-        ImplContainer(_) => None,\n-    })\n-}\n-\n /// Yields the parent function's `DefId` if `def_id` is an `impl Trait` definition.\n pub fn is_impl_trait_defn(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n     if let Some(hir_id) = tcx.hir().as_local_hir_id(def_id) {\n@@ -3181,151 +2975,12 @@ pub fn is_impl_trait_defn(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n     None\n }\n \n-/// See `ParamEnv` struct definition for details.\n-fn param_env(tcx: TyCtxt<'_>, def_id: DefId) -> ParamEnv<'_> {\n-    // The param_env of an impl Trait type is its defining function's param_env\n-    if let Some(parent) = is_impl_trait_defn(tcx, def_id) {\n-        return param_env(tcx, parent);\n-    }\n-    // Compute the bounds on Self and the type parameters.\n-\n-    let InstantiatedPredicates { predicates } = tcx.predicates_of(def_id).instantiate_identity(tcx);\n-\n-    // Finally, we have to normalize the bounds in the environment, in\n-    // case they contain any associated type projections. This process\n-    // can yield errors if the put in illegal associated types, like\n-    // `<i32 as Foo>::Bar` where `i32` does not implement `Foo`. We\n-    // report these errors right here; this doesn't actually feel\n-    // right to me, because constructing the environment feels like a\n-    // kind of a \"idempotent\" action, but I'm not sure where would be\n-    // a better place. In practice, we construct environments for\n-    // every fn once during type checking, and we'll abort if there\n-    // are any errors at that point, so after type checking you can be\n-    // sure that this will succeed without errors anyway.\n-\n-    let unnormalized_env = ty::ParamEnv::new(\n-        tcx.intern_predicates(&predicates),\n-        traits::Reveal::UserFacing,\n-        tcx.sess.opts.debugging_opts.chalk.then_some(def_id),\n-    );\n-\n-    let body_id = tcx.hir().as_local_hir_id(def_id).map_or(hir::DUMMY_HIR_ID, |id| {\n-        tcx.hir().maybe_body_owned_by(id).map_or(id, |body| body.hir_id)\n-    });\n-    let cause = traits::ObligationCause::misc(tcx.def_span(def_id), body_id);\n-    traits::normalize_param_env_or_error(tcx, def_id, unnormalized_env, cause)\n-}\n-\n-fn crate_disambiguator(tcx: TyCtxt<'_>, crate_num: CrateNum) -> CrateDisambiguator {\n-    assert_eq!(crate_num, LOCAL_CRATE);\n-    tcx.sess.local_crate_disambiguator()\n-}\n-\n-fn original_crate_name(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Symbol {\n-    assert_eq!(crate_num, LOCAL_CRATE);\n-    tcx.crate_name.clone()\n-}\n-\n-fn crate_hash(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Svh {\n-    assert_eq!(crate_num, LOCAL_CRATE);\n-    tcx.hir().crate_hash\n-}\n-\n-fn instance_def_size_estimate<'tcx>(tcx: TyCtxt<'tcx>, instance_def: InstanceDef<'tcx>) -> usize {\n-    match instance_def {\n-        InstanceDef::Item(..) | InstanceDef::DropGlue(..) => {\n-            let mir = tcx.instance_mir(instance_def);\n-            mir.basic_blocks().iter().map(|bb| bb.statements.len()).sum()\n-        }\n-        // Estimate the size of other compiler-generated shims to be 1.\n-        _ => 1,\n-    }\n-}\n-\n-/// If `def_id` is an issue 33140 hack impl, returns its self type; otherwise, returns `None`.\n-///\n-/// See [`ImplOverlapKind::Issue33140`] for more details.\n-fn issue33140_self_ty(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Ty<'_>> {\n-    debug!(\"issue33140_self_ty({:?})\", def_id);\n-\n-    let trait_ref = tcx\n-        .impl_trait_ref(def_id)\n-        .unwrap_or_else(|| bug!(\"issue33140_self_ty called on inherent impl {:?}\", def_id));\n-\n-    debug!(\"issue33140_self_ty({:?}), trait-ref={:?}\", def_id, trait_ref);\n-\n-    let is_marker_like = tcx.impl_polarity(def_id) == ty::ImplPolarity::Positive\n-        && tcx.associated_item_def_ids(trait_ref.def_id).is_empty();\n-\n-    // Check whether these impls would be ok for a marker trait.\n-    if !is_marker_like {\n-        debug!(\"issue33140_self_ty - not marker-like!\");\n-        return None;\n-    }\n-\n-    // impl must be `impl Trait for dyn Marker1 + Marker2 + ...`\n-    if trait_ref.substs.len() != 1 {\n-        debug!(\"issue33140_self_ty - impl has substs!\");\n-        return None;\n-    }\n-\n-    let predicates = tcx.predicates_of(def_id);\n-    if predicates.parent.is_some() || !predicates.predicates.is_empty() {\n-        debug!(\"issue33140_self_ty - impl has predicates {:?}!\", predicates);\n-        return None;\n-    }\n-\n-    let self_ty = trait_ref.self_ty();\n-    let self_ty_matches = match self_ty.kind {\n-        ty::Dynamic(ref data, ty::ReStatic) => data.principal().is_none(),\n-        _ => false,\n-    };\n-\n-    if self_ty_matches {\n-        debug!(\"issue33140_self_ty - MATCHES!\");\n-        Some(self_ty)\n-    } else {\n-        debug!(\"issue33140_self_ty - non-matching self type\");\n-        None\n-    }\n-}\n-\n-/// Check if a function is async.\n-fn asyncness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::IsAsync {\n-    let hir_id = tcx\n-        .hir()\n-        .as_local_hir_id(def_id)\n-        .unwrap_or_else(|| bug!(\"asyncness: expected local `DefId`, got `{:?}`\", def_id));\n-\n-    let node = tcx.hir().get(hir_id);\n-\n-    let fn_like = hir_map::blocks::FnLikeNode::from_node(node).unwrap_or_else(|| {\n-        bug!(\"asyncness: expected fn-like node but got `{:?}`\", def_id);\n-    });\n-\n-    fn_like.asyncness()\n-}\n-\n pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     context::provide(providers);\n     erase_regions::provide(providers);\n     layout::provide(providers);\n-    *providers = ty::query::Providers {\n-        asyncness,\n-        associated_item,\n-        associated_item_def_ids,\n-        adt_sized_constraint,\n-        def_span,\n-        param_env,\n-        trait_of_item,\n-        crate_disambiguator,\n-        original_crate_name,\n-        crate_hash,\n-        trait_impls_of: trait_def::trait_impls_of_provider,\n-        instance_def_size_estimate,\n-        issue33140_self_ty,\n-        ..*providers\n-    };\n+    *providers =\n+        ty::query::Providers { trait_impls_of: trait_def::trait_impls_of_provider, ..*providers };\n }\n \n /// A map for the local crate mapping each type to a vector of its"}, {"sha": "3fb3720a5638a1dc7d253425b4f57b13e357dd85", "filename": "src/librustc/ty/query/keys.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -125,6 +125,15 @@ impl<'tcx> Key for (DefId, SubstsRef<'tcx>) {\n     }\n }\n \n+impl<'tcx> Key for (DefId, SubstsRef<'tcx>, traits::TraitQueryMode) {\n+    fn query_crate(&self) -> CrateNum {\n+        self.0.krate\n+    }\n+    fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n+        self.0.default_span(tcx)\n+    }\n+}\n+\n impl<'tcx> Key for (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>) {\n     fn query_crate(&self) -> CrateNum {\n         self.1.def_id().krate"}, {"sha": "2866a1624de5b8686d3d326b1157f1285c34987a", "filename": "src/librustc_ast_lowering/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_ast_lowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_ast_lowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fexpr.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -909,18 +909,18 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     fn lower_expr_asm(&mut self, asm: &InlineAsm) -> hir::ExprKind<'hir> {\n         let inner = hir::InlineAsmInner {\n-            inputs: asm.inputs.iter().map(|&(ref c, _)| c.clone()).collect(),\n+            inputs: asm.inputs.iter().map(|&(c, _)| c).collect(),\n             outputs: asm\n                 .outputs\n                 .iter()\n                 .map(|out| hir::InlineAsmOutput {\n-                    constraint: out.constraint.clone(),\n+                    constraint: out.constraint,\n                     is_rw: out.is_rw,\n                     is_indirect: out.is_indirect,\n                     span: out.expr.span,\n                 })\n                 .collect(),\n-            asm: asm.asm.clone(),\n+            asm: asm.asm,\n             asm_str_style: asm.asm_str_style,\n             clobbers: asm.clobbers.clone().into(),\n             volatile: asm.volatile,"}, {"sha": "6da2d457f3c3b5692d103736cd74d7cb4d9a66b3", "filename": "src/librustc_ast_lowering/item.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_ast_lowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_ast_lowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fitem.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -67,14 +67,15 @@ impl<'a> Visitor<'a> for ItemLowerer<'a, '_, '_> {\n         if let Some(hir_id) = item_hir_id {\n             self.lctx.with_parent_item_lifetime_defs(hir_id, |this| {\n                 let this = &mut ItemLowerer { lctx: this };\n-                if let ItemKind::Impl(.., ref opt_trait_ref, _, _) = item.kind {\n-                    if opt_trait_ref.as_ref().map(|tr| tr.constness.is_some()).unwrap_or(false) {\n+                if let ItemKind::Impl { ref of_trait, .. } = item.kind {\n+                    if of_trait.as_ref().map(|tr| tr.constness.is_some()).unwrap_or(false) {\n+                        this.with_trait_impl_ref(of_trait, |this| visit::walk_item(this, item));\n                         this.lctx\n                             .diagnostic()\n                             .span_err(item.span, \"const trait impls are not yet implemented\");\n                     }\n \n-                    this.with_trait_impl_ref(opt_trait_ref, |this| visit::walk_item(this, item));\n+                    this.with_trait_impl_ref(of_trait, |this| visit::walk_item(this, item));\n                 } else {\n                     visit::walk_item(this, item);\n                 }\n@@ -118,7 +119,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let old_len = self.in_scope_lifetimes.len();\n \n         let parent_generics = match self.items.get(&parent_hir_id).unwrap().kind {\n-            hir::ItemKind::Impl(_, _, _, ref generics, ..)\n+            hir::ItemKind::Impl { ref generics, .. }\n             | hir::ItemKind::Trait(_, _, ref generics, ..) => &generics.params[..],\n             _ => &[],\n         };\n@@ -173,7 +174,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 vec\n             }\n             ItemKind::MacroDef(..) => SmallVec::new(),\n-            ItemKind::Fn(..) | ItemKind::Impl(.., None, _, _) => smallvec![i.id],\n+            ItemKind::Fn(..) | ItemKind::Impl { of_trait: None, .. } => smallvec![i.id],\n             ItemKind::Static(ref ty, ..) => {\n                 let mut ids = smallvec![i.id];\n                 if self.sess.features_untracked().impl_trait_in_bindings {\n@@ -361,15 +362,15 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     self.lower_generics(generics, ImplTraitContext::disallowed()),\n                 )\n             }\n-            ItemKind::Impl(\n+            ItemKind::Impl {\n                 unsafety,\n                 polarity,\n                 defaultness,\n-                ref ast_generics,\n-                ref trait_ref,\n-                ref ty,\n-                ref impl_items,\n-            ) => {\n+                generics: ref ast_generics,\n+                of_trait: ref trait_ref,\n+                self_ty: ref ty,\n+                items: ref impl_items,\n+            } => {\n                 let def_id = self.resolver.definitions().local_def_id(id);\n \n                 // Lower the \"impl header\" first. This ordering is important\n@@ -417,15 +418,15 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         )\n                     });\n \n-                hir::ItemKind::Impl(\n+                hir::ItemKind::Impl {\n                     unsafety,\n                     polarity,\n-                    self.lower_defaultness(defaultness, true /* [1] */),\n+                    defaultness: self.lower_defaultness(defaultness, true /* [1] */),\n                     generics,\n-                    trait_ref,\n-                    lowered_ty,\n-                    new_impl_items,\n-                )\n+                    of_trait: trait_ref,\n+                    self_ty: lowered_ty,\n+                    items: new_impl_items,\n+                }\n             }\n             ItemKind::Trait(is_auto, unsafety, ref generics, ref bounds, ref items) => {\n                 let bounds = self.lower_param_bounds(bounds, ImplTraitContext::disallowed());"}, {"sha": "23701459025ae3dd8b12fcb967135ed613f3f6db", "filename": "src/librustc_ast_passes/ast_validation.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_ast_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_ast_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Fast_validation.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -612,9 +612,17 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         }\n \n         match item.kind {\n-            ItemKind::Impl(unsafety, polarity, _, _, Some(..), ref ty, ref impl_items) => {\n+            ItemKind::Impl {\n+                unsafety,\n+                polarity,\n+                defaultness: _,\n+                generics: _,\n+                of_trait: Some(_),\n+                ref self_ty,\n+                ref items,\n+            } => {\n                 self.invalid_visibility(&item.vis, None);\n-                if let TyKind::Err = ty.kind {\n+                if let TyKind::Err = self_ty.kind {\n                     self.err_handler()\n                         .struct_span_err(item.span, \"`impl Trait for .. {}` is an obsolete syntax\")\n                         .help(\"use `auto trait Trait {}` instead\")\n@@ -629,15 +637,23 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     )\n                     .emit();\n                 }\n-                for impl_item in impl_items {\n+                for impl_item in items {\n                     self.invalid_visibility(&impl_item.vis, None);\n                     if let AssocItemKind::Fn(ref sig, _) = impl_item.kind {\n                         self.check_trait_fn_not_const(sig.header.constness);\n                         self.check_trait_fn_not_async(impl_item.span, sig.header.asyncness.node);\n                     }\n                 }\n             }\n-            ItemKind::Impl(unsafety, polarity, defaultness, _, None, _, _) => {\n+            ItemKind::Impl {\n+                unsafety,\n+                polarity,\n+                defaultness,\n+                generics: _,\n+                of_trait: None,\n+                self_ty: _,\n+                items: _,\n+            } => {\n                 self.invalid_visibility(\n                     &item.vis,\n                     Some(\"place qualifiers on individual impl items instead\"),"}, {"sha": "461072873bb529a08885100c25810393d0df0357", "filename": "src/librustc_ast_passes/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 23, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Ffeature_gate.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -339,7 +339,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 }\n             }\n \n-            ast::ItemKind::Impl(_, polarity, defaultness, ..) => {\n+            ast::ItemKind::Impl { polarity, defaultness, .. } => {\n                 if polarity == ast::ImplPolarity::Negative {\n                     gate_feature_post!(\n                         &self,\n@@ -413,7 +413,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 self.check_extern(bare_fn_ty.ext);\n             }\n             ast::TyKind::Never => {\n-                gate_feature_post!(&self, never_type, ty.span, \"The `!` type is experimental\");\n+                gate_feature_post!(&self, never_type, ty.span, \"the `!` type is experimental\");\n             }\n             _ => {}\n         }\n@@ -470,29 +470,8 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         visit::walk_expr(self, e)\n     }\n \n-    fn visit_arm(&mut self, arm: &'a ast::Arm) {\n-        visit::walk_arm(self, arm)\n-    }\n-\n     fn visit_pat(&mut self, pattern: &'a ast::Pat) {\n         match &pattern.kind {\n-            PatKind::Slice(pats) => {\n-                for pat in &*pats {\n-                    let span = pat.span;\n-                    let inner_pat = match &pat.kind {\n-                        PatKind::Ident(.., Some(pat)) => pat,\n-                        _ => pat,\n-                    };\n-                    if inner_pat.is_rest() {\n-                        gate_feature_post!(\n-                            &self,\n-                            slice_patterns,\n-                            span,\n-                            \"subslice patterns are unstable\"\n-                        );\n-                    }\n-                }\n-            }\n             PatKind::Box(..) => {\n                 gate_feature_post!(\n                     &self,"}, {"sha": "5de45f4e1f36571e597f6e8cfddb58f2688c4c4c", "filename": "src/librustc_ast_passes/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_ast_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_ast_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Flib.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -2,7 +2,7 @@\n //! parsed by `rustc_parse` and then lowered, after the passes in this crate,\n //! by `rustc_ast_lowering`.\n \n-#![feature(slice_patterns)]\n+#![cfg_attr(bootstrap, feature(slice_patterns))]\n \n pub mod ast_validation;\n pub mod feature_gate;"}, {"sha": "d346dbc8b4ee71a91aa6908c83b7338b09c54bef", "filename": "src/librustc_builtin_macros/deriving/generic/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -705,15 +705,15 @@ impl<'a> TraitDef<'a> {\n             self.span,\n             Ident::invalid(),\n             a,\n-            ast::ItemKind::Impl(\n+            ast::ItemKind::Impl {\n                 unsafety,\n-                ast::ImplPolarity::Positive,\n-                ast::Defaultness::Final,\n-                trait_generics,\n-                opt_trait_ref,\n-                self_type,\n-                methods.into_iter().chain(associated_types).collect(),\n-            ),\n+                polarity: ast::ImplPolarity::Positive,\n+                defaultness: ast::Defaultness::Final,\n+                generics: trait_generics,\n+                of_trait: opt_trait_ref,\n+                self_ty: self_type,\n+                items: methods.into_iter().chain(associated_types).collect(),\n+            },\n         )\n     }\n \n@@ -1608,7 +1608,7 @@ impl<'a> TraitDef<'a> {\n                 } else {\n                     ast::BindingMode::ByRef(mutbl)\n                 };\n-                cx.pat(path.span, PatKind::Ident(binding_mode, (*path).clone(), None))\n+                cx.pat(path.span, PatKind::Ident(binding_mode, *path, None))\n             })\n             .collect()\n     }"}, {"sha": "9aa7623dc9f77cd1e3f856869b7b5aeee471792f", "filename": "src/librustc_builtin_macros/deriving/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_builtin_macros%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_builtin_macros%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fmod.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -156,15 +156,15 @@ fn inject_impl_of_structural_trait(\n         span,\n         ast::Ident::invalid(),\n         attrs,\n-        ItemKind::Impl(\n-            ast::Unsafety::Normal,\n-            ast::ImplPolarity::Positive,\n-            ast::Defaultness::Final,\n+        ItemKind::Impl {\n+            unsafety: ast::Unsafety::Normal,\n+            polarity: ast::ImplPolarity::Positive,\n+            defaultness: ast::Defaultness::Final,\n             generics,\n-            Some(trait_ref),\n-            self_type,\n-            Vec::new(),\n-        ),\n+            of_trait: Some(trait_ref),\n+            self_ty: self_type,\n+            items: Vec::new(),\n+        },\n     );\n \n     push(Annotatable::Item(newitem));"}, {"sha": "07715cdbcb5e92e2dede68640c07d8209184cdfc", "filename": "src/librustc_builtin_macros/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_builtin_macros%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_builtin_macros%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Ftest.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -325,7 +325,7 @@ fn should_panic(cx: &ExtCtxt<'_>, i: &ast::Item) -> ShouldPanic {\n                              `expected = \\\"error message\\\"`\",\n                         )\n                         .note(\n-                            \"Errors in this attribute were erroneously \\\n+                            \"errors in this attribute were erroneously \\\n                                 allowed and will become a hard error in a \\\n                                 future release.\",\n                         )"}, {"sha": "aba77231268e7e0226098c1bf65fede240edeeec", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -4,7 +4,7 @@\n #![feature(box_syntax)]\n #![feature(core_intrinsics)]\n #![feature(libc)]\n-#![feature(slice_patterns)]\n+#![cfg_attr(bootstrap, feature(slice_patterns))]\n #![feature(stmt_expr_attributes)]\n #![feature(try_blocks)]\n #![feature(in_band_lifetimes)]"}, {"sha": "fb4f818c4b2492b003fc0811b96c3dcc86a35fc0", "filename": "src/librustc_data_structures/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2FCargo.toml?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -31,3 +31,6 @@ measureme = \"0.7.1\"\n [dependencies.parking_lot]\n version = \"0.9\"\n features = [\"nightly\"]\n+\n+[target.'cfg(windows)'.dependencies]\n+winapi = { version = \"0.3\", features = [\"fileapi\", \"psapi\"] }"}, {"sha": "2a0139fa90d5a2b742cf9c0c11fd3372b3834066", "filename": "src/librustc_data_structures/flock.rs", "status": "modified", "additions": 3, "deletions": 31, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_data_structures%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_data_structures%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fflock.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -87,39 +87,11 @@ cfg_if! {\n     } else if #[cfg(windows)] {\n         use std::mem;\n         use std::os::windows::prelude::*;\n-        use std::os::windows::raw::HANDLE;\n         use std::fs::{File, OpenOptions};\n-        use std::os::raw::{c_ulong, c_int};\n-\n-        type DWORD = c_ulong;\n-        type BOOL = c_int;\n-        type ULONG_PTR = usize;\n-\n-        type LPOVERLAPPED = *mut OVERLAPPED;\n-        const LOCKFILE_EXCLUSIVE_LOCK: DWORD = 0x0000_0002;\n-        const LOCKFILE_FAIL_IMMEDIATELY: DWORD = 0x0000_0001;\n-\n-        const FILE_SHARE_DELETE: DWORD = 0x4;\n-        const FILE_SHARE_READ: DWORD = 0x1;\n-        const FILE_SHARE_WRITE: DWORD = 0x2;\n-\n-        #[repr(C)]\n-        struct OVERLAPPED {\n-            Internal: ULONG_PTR,\n-            InternalHigh: ULONG_PTR,\n-            Offset: DWORD,\n-            OffsetHigh: DWORD,\n-            hEvent: HANDLE,\n-        }\n \n-        extern \"system\" {\n-            fn LockFileEx(hFile: HANDLE,\n-                          dwFlags: DWORD,\n-                          dwReserved: DWORD,\n-                          nNumberOfBytesToLockLow: DWORD,\n-                          nNumberOfBytesToLockHigh: DWORD,\n-                          lpOverlapped: LPOVERLAPPED) -> BOOL;\n-        }\n+        use winapi::um::minwinbase::{OVERLAPPED, LOCKFILE_FAIL_IMMEDIATELY, LOCKFILE_EXCLUSIVE_LOCK};\n+        use winapi::um::fileapi::LockFileEx;\n+        use winapi::um::winnt::{FILE_SHARE_DELETE, FILE_SHARE_READ, FILE_SHARE_WRITE};\n \n         #[derive(Debug)]\n         pub struct Lock {"}, {"sha": "6db2910bca4967cc82befdaf20898737d3ce42bd", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -33,9 +33,6 @@ extern crate libc;\n #[macro_use]\n extern crate cfg_if;\n \n-#[cfg(windows)]\n-extern crate libc;\n-\n pub use rustc_serialize::hex::ToHex;\n \n #[inline(never)]"}, {"sha": "44cef727f034be23d7884972cbda659bd5a8bcec", "filename": "src/librustc_data_structures/profiling.rs", "status": "modified", "additions": 15, "deletions": 33, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_data_structures%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_data_structures%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fprofiling.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -136,9 +136,11 @@ bitflags::bitflags! {\n     }\n }\n \n+// keep this in sync with the `-Z self-profile-events` help message in librustc_session/options.rs\n const EVENT_FILTERS_BY_NAME: &[(&str, EventFilter)] = &[\n     (\"none\", EventFilter::NONE),\n     (\"all\", EventFilter::ALL),\n+    (\"default\", EventFilter::DEFAULT),\n     (\"generic-activity\", EventFilter::GENERIC_ACTIVITIES),\n     (\"query-provider\", EventFilter::QUERY_PROVIDERS),\n     (\"query-cache-hit\", EventFilter::QUERY_CACHE_HITS),\n@@ -569,39 +571,19 @@ fn get_resident() -> Option<usize> {\n \n #[cfg(windows)]\n fn get_resident() -> Option<usize> {\n-    type BOOL = i32;\n-    type DWORD = u32;\n-    type HANDLE = *mut u8;\n-    use libc::size_t;\n-    #[repr(C)]\n-    #[allow(non_snake_case)]\n-    struct PROCESS_MEMORY_COUNTERS {\n-        cb: DWORD,\n-        PageFaultCount: DWORD,\n-        PeakWorkingSetSize: size_t,\n-        WorkingSetSize: size_t,\n-        QuotaPeakPagedPoolUsage: size_t,\n-        QuotaPagedPoolUsage: size_t,\n-        QuotaPeakNonPagedPoolUsage: size_t,\n-        QuotaNonPagedPoolUsage: size_t,\n-        PagefileUsage: size_t,\n-        PeakPagefileUsage: size_t,\n-    }\n-    #[allow(non_camel_case_types)]\n-    type PPROCESS_MEMORY_COUNTERS = *mut PROCESS_MEMORY_COUNTERS;\n-    #[link(name = \"psapi\")]\n-    extern \"system\" {\n-        fn GetCurrentProcess() -> HANDLE;\n-        fn GetProcessMemoryInfo(\n-            Process: HANDLE,\n-            ppsmemCounters: PPROCESS_MEMORY_COUNTERS,\n-            cb: DWORD,\n-        ) -> BOOL;\n-    }\n-    let mut pmc: PROCESS_MEMORY_COUNTERS = unsafe { std::mem::zeroed() };\n-    pmc.cb = std::mem::size_of_val(&pmc) as DWORD;\n-    match unsafe { GetProcessMemoryInfo(GetCurrentProcess(), &mut pmc, pmc.cb) } {\n+    use std::mem::{self, MaybeUninit};\n+    use winapi::shared::minwindef::DWORD;\n+    use winapi::um::processthreadsapi::GetCurrentProcess;\n+    use winapi::um::psapi::{GetProcessMemoryInfo, PROCESS_MEMORY_COUNTERS};\n+\n+    let mut pmc = MaybeUninit::<PROCESS_MEMORY_COUNTERS>::uninit();\n+    match unsafe {\n+        GetProcessMemoryInfo(GetCurrentProcess(), pmc.as_mut_ptr(), mem::size_of_val(&pmc) as DWORD)\n+    } {\n         0 => None,\n-        _ => Some(pmc.WorkingSetSize as usize),\n+        _ => {\n+            let pmc = unsafe { pmc.assume_init() };\n+            Some(pmc.WorkingSetSize as usize)\n+        }\n     }\n }"}, {"sha": "ee3f88ff1675fa6039077b6ad8c5e258a38ec10a", "filename": "src/librustc_data_structures/sharded.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_data_structures%2Fsharded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_data_structures%2Fsharded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsharded.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -137,6 +137,20 @@ impl<K: Eq + Hash + Copy> ShardedHashMap<K, ()> {\n     }\n }\n \n+pub trait IntoPointer {\n+    /// Returns a pointer which outlives `self`.\n+    fn into_pointer(&self) -> *const ();\n+}\n+\n+impl<K: Eq + Hash + Copy + IntoPointer> ShardedHashMap<K, ()> {\n+    pub fn contains_pointer_to<T: Hash + IntoPointer>(&self, value: &T) -> bool {\n+        let hash = make_hash(&value);\n+        let shard = self.get_shard_by_hash(hash).lock();\n+        let value = value.into_pointer();\n+        shard.raw_entry().from_hash(hash, |entry| entry.into_pointer() == value).is_some()\n+    }\n+}\n+\n #[inline]\n fn make_hash<K: Hash + ?Sized>(val: &K) -> u64 {\n     let mut state = FxHasher::default();"}, {"sha": "b856e5da5a093262125cd339be50409ab79f436c", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -32,5 +32,8 @@ rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n syntax = { path = \"../libsyntax\" }\n rustc_span = { path = \"../librustc_span\" }\n \n+[target.'cfg(windows)'.dependencies]\n+winapi = { version = \"0.3\", features = [\"consoleapi\", \"debugapi\", \"processenv\"] }\n+\n [features]\n llvm = ['rustc_interface/llvm']"}, {"sha": "019ff431bcb97d2f56ecfc05a6abba63aff89134", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -514,15 +514,10 @@ fn stdout_isatty() -> bool {\n \n #[cfg(windows)]\n fn stdout_isatty() -> bool {\n-    type DWORD = u32;\n-    type BOOL = i32;\n-    type HANDLE = *mut u8;\n-    type LPDWORD = *mut u32;\n-    const STD_OUTPUT_HANDLE: DWORD = -11i32 as DWORD;\n-    extern \"system\" {\n-        fn GetStdHandle(which: DWORD) -> HANDLE;\n-        fn GetConsoleMode(hConsoleHandle: HANDLE, lpMode: LPDWORD) -> BOOL;\n-    }\n+    use winapi::um::consoleapi::GetConsoleMode;\n+    use winapi::um::processenv::GetStdHandle;\n+    use winapi::um::winbase::STD_OUTPUT_HANDLE;\n+\n     unsafe {\n         let handle = GetStdHandle(STD_OUTPUT_HANDLE);\n         let mut out = 0;\n@@ -1214,11 +1209,8 @@ pub fn report_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n     #[cfg(windows)]\n     unsafe {\n         if env::var(\"RUSTC_BREAK_ON_ICE\").is_ok() {\n-            extern \"system\" {\n-                fn DebugBreak();\n-            }\n             // Trigger a debugger if we crashed during bootstrap\n-            DebugBreak();\n+            winapi::um::debugapi::DebugBreak();\n         }\n     }\n }"}, {"sha": "6ef6dcf87eddb6b552f0d2cc64ca32158f128458", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -429,7 +429,6 @@ pub fn print_after_hir_lowering<'tcx>(\n         PpmSource(s) => {\n             // Silently ignores an identified node.\n             let out = &mut out;\n-            let src = src.clone();\n             call_with_pp_support(&s, tcx.sess, Some(tcx), move |annotation| {\n                 debug!(\"pretty printing source code {:?}\", s);\n                 let sess = annotation.sess();\n@@ -447,7 +446,6 @@ pub fn print_after_hir_lowering<'tcx>(\n \n         PpmHir(s) => {\n             let out = &mut out;\n-            let src = src.clone();\n             call_with_pp_support_hir(&s, tcx, move |annotation, krate| {\n                 debug!(\"pretty printing source code {:?}\", s);\n                 let sess = annotation.sess();"}, {"sha": "180ccb15977dd5126b2b9617f75efbedb166fe1f", "filename": "src/librustc_error_codes/error_codes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_error_codes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_error_codes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -414,6 +414,7 @@ E0742: include_str!(\"./error_codes/E0742.md\"),\n E0743: include_str!(\"./error_codes/E0743.md\"),\n E0744: include_str!(\"./error_codes/E0744.md\"),\n E0745: include_str!(\"./error_codes/E0745.md\"),\n+E0746: include_str!(\"./error_codes/E0746.md\"),\n ;\n //  E0006, // merged with E0005\n //  E0008, // cannot bind by-move into a pattern guard"}, {"sha": "9678cd173b7cac28f51164f0317689a46cccc356", "filename": "src/librustc_error_codes/error_codes/E0170.md", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_error_codes%2Ferror_codes%2FE0170.md", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_error_codes%2Ferror_codes%2FE0170.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0170.md?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,3 +1,24 @@\n+A pattern binding is using the same name as one of the variants of a type.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0170\n+# #![deny(warnings)]\n+enum Method {\n+    GET,\n+    POST,\n+}\n+\n+fn is_empty(s: Method) -> bool {\n+    match s {\n+        GET => true,\n+        _ => false\n+    }\n+}\n+\n+fn main() {}\n+```\n+\n Enum variants are qualified by default. For example, given this type:\n \n ```"}, {"sha": "b8c313d412eba9ee91b67eee02994082187ba006", "filename": "src/librustc_error_codes/error_codes/E0195.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_error_codes%2Ferror_codes%2FE0195.md", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_error_codes%2Ferror_codes%2FE0195.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0195.md?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,4 +1,5 @@\n-Your method's lifetime parameters do not match the trait declaration.\n+The lifetime parameters of the method do not match the trait declaration.\n+\n Erroneous code example:\n \n ```compile_fail,E0195\n@@ -16,7 +17,7 @@ impl Trait for Foo {\n }\n ```\n \n-The lifetime constraint `'b` for bar() implementation does not match the\n+The lifetime constraint `'b` for `bar()` implementation does not match the\n trait declaration. Ensure lifetime declarations match exactly in both trait\n declaration and implementation. Example:\n "}, {"sha": "c142b8f3664c5e83a46c396d7191681c1298f79f", "filename": "src/librustc_error_codes/error_codes/E0197.md", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_error_codes%2Ferror_codes%2FE0197.md", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_error_codes%2Ferror_codes%2FE0197.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0197.md?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,13 +1,20 @@\n+An inherent implementation was marked unsafe.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0197\n+struct Foo;\n+\n+unsafe impl Foo { } // error!\n+```\n+\n Inherent implementations (one that do not implement a trait but provide\n methods associated with a type) are always safe because they are not\n implementing an unsafe trait. Removing the `unsafe` keyword from the inherent\n implementation will resolve this error.\n \n-```compile_fail,E0197\n+```\n struct Foo;\n \n-// this will cause this error\n-unsafe impl Foo { }\n-// converting it to this will fix it\n-impl Foo { }\n+impl Foo { } // ok!\n ```"}, {"sha": "687214a205096ff62c0c5454062938714c309ea7", "filename": "src/librustc_error_codes/error_codes/E0198.md", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_error_codes%2Ferror_codes%2FE0198.md", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_error_codes%2Ferror_codes%2FE0198.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0198.md?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,17 +1,18 @@\n-A negative implementation is one that excludes a type from implementing a\n-particular trait. Not being able to use a trait is always a safe operation,\n-so negative implementations are always safe and never need to be marked as\n-unsafe.\n+A negative implementation was marked as unsafe.\n \n-```compile_fail\n-#![feature(optin_builtin_traits)]\n+Erroneous code example:\n \n+```compile_fail\n struct Foo;\n \n-// unsafe is unnecessary\n-unsafe impl !Clone for Foo { }\n+unsafe impl !Clone for Foo { } // error!\n ```\n \n+A negative implementation is one that excludes a type from implementing a\n+particular trait. Not being able to use a trait is always a safe operation,\n+so negative implementations are always safe and never need to be marked as\n+unsafe.\n+\n This will compile:\n \n ```ignore (ignore auto_trait future compatibility warning)"}, {"sha": "88130e8e5e596540c2c10b02bb8ff41baca5cf27", "filename": "src/librustc_error_codes/error_codes/E0199.md", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_error_codes%2Ferror_codes%2FE0199.md", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_error_codes%2Ferror_codes%2FE0199.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0199.md?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,14 +1,23 @@\n+A trait implementation was marked as unsafe while the trait is safe.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0199\n+struct Foo;\n+\n+trait Bar { }\n+\n+unsafe impl Bar for Foo { } // error!\n+```\n+\n Safe traits should not have unsafe implementations, therefore marking an\n implementation for a safe trait unsafe will cause a compiler error. Removing\n-the unsafe marker on the trait noted in the error will resolve this problem.\n+the unsafe marker on the trait noted in the error will resolve this problem:\n \n-```compile_fail,E0199\n+```\n struct Foo;\n \n trait Bar { }\n \n-// this won't compile because Bar is safe\n-unsafe impl Bar for Foo { }\n-// this will compile\n-impl Bar for Foo { }\n+impl Bar for Foo { } // ok!\n ```"}, {"sha": "7245bb59ce5ffa5406f42f82e752ff0b89303643", "filename": "src/librustc_error_codes/error_codes/E0200.md", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_error_codes%2Ferror_codes%2FE0200.md", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_error_codes%2Ferror_codes%2FE0200.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0200.md?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,14 +1,23 @@\n+An unsafe trait was implemented without an unsafe implementation.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0200\n+struct Foo;\n+\n+unsafe trait Bar { }\n+\n+impl Bar for Foo { } // error!\n+```\n+\n Unsafe traits must have unsafe implementations. This error occurs when an\n implementation for an unsafe trait isn't marked as unsafe. This may be resolved\n by marking the unsafe implementation as unsafe.\n \n-```compile_fail,E0200\n+```\n struct Foo;\n \n unsafe trait Bar { }\n \n-// this won't compile because Bar is unsafe and impl isn't unsafe\n-impl Bar for Foo { }\n-// this will compile\n-unsafe impl Bar for Foo { }\n+unsafe impl Bar for Foo { } // ok!\n ```"}, {"sha": "97ea31269388142df9853a62c3aa8b756aa86e1c", "filename": "src/librustc_error_codes/error_codes/E0527.md", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_error_codes%2Ferror_codes%2FE0527.md", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_error_codes%2Ferror_codes%2FE0527.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0527.md?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -17,8 +17,6 @@ Ensure that the pattern is consistent with the size of the matched\n array. Additional elements can be matched with `..`:\n \n ```\n-#![feature(slice_patterns)]\n-\n let r = &[1, 2, 3, 4];\n match r {\n     &[a, b, ..] => { // ok!"}, {"sha": "54c2c4d4e9d0f765eb1d1450e1f7cc381ed9a569", "filename": "src/librustc_error_codes/error_codes/E0528.md", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_error_codes%2Ferror_codes%2FE0528.md", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_error_codes%2Ferror_codes%2FE0528.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0528.md?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -4,8 +4,6 @@ matched array.\n Example of erroneous code:\n \n ```compile_fail,E0528\n-#![feature(slice_patterns)]\n-\n let r = &[1, 2];\n match r {\n     &[a, b, c, rest @ ..] => { // error: pattern requires at least 3\n@@ -19,8 +17,6 @@ Ensure that the matched array has at least as many elements as the pattern\n requires. You can match an arbitrary number of remaining elements with `..`:\n \n ```\n-#![feature(slice_patterns)]\n-\n let r = &[1, 2, 3, 4, 5];\n match r {\n     &[a, b, c, rest @ ..] => { // ok!"}, {"sha": "bf1f72be3258926bd7f107935517027cbda26f8a", "filename": "src/librustc_error_codes/error_codes/E0730.md", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_error_codes%2Ferror_codes%2FE0730.md", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_error_codes%2Ferror_codes%2FE0730.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0730.md?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -18,8 +18,6 @@ Ensure that the pattern is consistent with the size of the matched\n array. Additional elements can be matched with `..`:\n \n ```\n-#![feature(slice_patterns)]\n-\n let r = &[1, 2, 3, 4];\n match r {\n     &[a, b, ..] => { // ok!"}, {"sha": "16b2722f0eac2b47519db7523443dc15c2eb87f0", "filename": "src/librustc_error_codes/error_codes/E0746.md", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_error_codes%2Ferror_codes%2FE0746.md", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_error_codes%2Ferror_codes%2FE0746.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0746.md?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -0,0 +1,138 @@\n+Return types cannot be `dyn Trait`s as they must be `Sized`.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0277\n+# // FIXME: after E0746 is in beta, change the above\n+trait T {\n+    fn bar(&self);\n+}\n+struct S(usize);\n+impl T for S {\n+    fn bar(&self) {}\n+}\n+\n+// Having the trait `T` as return type is invalid because\n+// unboxed trait objects do not have a statically known size:\n+fn foo() -> dyn T {\n+    S(42)\n+}\n+```\n+\n+To avoid the error there are a couple of options.\n+\n+If there is a single type involved, you can use [`impl Trait`]:\n+\n+```\n+# trait T {\n+#     fn bar(&self);\n+# }\n+# struct S(usize);\n+# impl T for S {\n+#     fn bar(&self) {}\n+# }\n+// The compiler will select `S(usize)` as the materialized return type of this\n+// function, but callers will only know that the return type implements `T`.\n+fn foo() -> impl T {\n+    S(42)\n+}\n+```\n+\n+If there are multiple types involved, the only way you care to interact with\n+them is through the trait's interface, and having to rely on dynamic dispatch\n+is acceptable, then you can use [trait objects] with `Box`, or other container\n+types like `Rc` or `Arc`:\n+\n+```\n+# trait T {\n+#     fn bar(&self);\n+# }\n+# struct S(usize);\n+# impl T for S {\n+#     fn bar(&self) {}\n+# }\n+struct O(&'static str);\n+impl T for O {\n+    fn bar(&self) {}\n+}\n+\n+// This now returns a \"trait object\" and callers are only be able to access\n+// associated items from `T`.\n+fn foo(x: bool) -> Box<dyn T> {\n+    if x {\n+        Box::new(S(42))\n+    } else {\n+        Box::new(O(\"val\"))\n+    }\n+}\n+```\n+\n+Finally, if you wish to still be able to access the original type, you can\n+create a new `enum` with a variant for each type:\n+\n+```\n+# trait T {\n+#     fn bar(&self);\n+# }\n+# struct S(usize);\n+# impl T for S {\n+#     fn bar(&self) {}\n+# }\n+# struct O(&'static str);\n+# impl T for O {\n+#     fn bar(&self) {}\n+# }\n+enum E {\n+    S(S),\n+    O(O),\n+}\n+\n+// The caller can access the original types directly, but it needs to match on\n+// the returned `enum E`.\n+fn foo(x: bool) -> E {\n+    if x {\n+        E::S(S(42))\n+    } else {\n+        E::O(O(\"val\"))\n+    }\n+}\n+```\n+\n+You can even implement the `trait` on the returned `enum` so the callers\n+*don't* have to match on the returned value to invoke the associated items:\n+\n+```\n+# trait T {\n+#     fn bar(&self);\n+# }\n+# struct S(usize);\n+# impl T for S {\n+#     fn bar(&self) {}\n+# }\n+# struct O(&'static str);\n+# impl T for O {\n+#     fn bar(&self) {}\n+# }\n+# enum E {\n+#     S(S),\n+#     O(O),\n+# }\n+impl T for E {\n+    fn bar(&self) {\n+        match self {\n+            E::S(s) => s.bar(),\n+            E::O(o) => o.bar(),\n+        }\n+    }\n+}\n+```\n+\n+If you decide to use trait objects, be aware that these rely on\n+[dynamic dispatch], which has performance implications, as the compiler needs\n+to emit code that will figure out which method to call *at runtime* instead of\n+during compilation. Using trait objects we are trading flexibility for\n+performance.\n+\n+[`impl Trait`]: https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits\n+[trait objects]: https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types\n+[dynamic dispatch]: https://doc.rust-lang.org/book/ch17-02-trait-objects.html#trait-objects-perform-dynamic-dispatch"}, {"sha": "01ea80659d6b9d021095e82faa5b6de594bb2fff", "filename": "src/librustc_errors/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_errors%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_errors%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2FCargo.toml?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -19,3 +19,6 @@ atty = \"0.2\"\n termcolor = \"1.0\"\n annotate-snippets = \"0.6.1\"\n term_size = \"0.3.1\"\n+\n+[target.'cfg(windows)'.dependencies]\n+winapi = { version = \"0.3\", features = [\"handleapi\", \"synchapi\", \"winbase\"] }"}, {"sha": "009ab6ac5b12f90ea37822a2ac6d7e05a546799b", "filename": "src/librustc_errors/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -196,7 +196,7 @@ impl AnnotateSnippetEmitterWriter {\n     ) {\n         let converter = DiagnosticConverter {\n             source_map: self.source_map.clone(),\n-            level: level.clone(),\n+            level: *level,\n             message,\n             code: code.clone(),\n             msp: msp.clone(),"}, {"sha": "b0e0cb611afaffb60711b97e46c21e669ff2d4dc", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1476,6 +1476,15 @@ impl EmitterWriter {\n             None => return Ok(()),\n         };\n \n+        // Render the replacements for each suggestion\n+        let suggestions = suggestion.splice_lines(&**sm);\n+\n+        if suggestions.is_empty() {\n+            // Suggestions coming from macros can have malformed spans. This is a heavy handed\n+            // approach to avoid ICEs by ignoring the suggestion outright.\n+            return Ok(());\n+        }\n+\n         let mut buffer = StyledBuffer::new();\n \n         // Render the suggestion message\n@@ -1492,9 +1501,6 @@ impl EmitterWriter {\n             Some(Style::HeaderMsg),\n         );\n \n-        // Render the replacements for each suggestion\n-        let suggestions = suggestion.splice_lines(&**sm);\n-\n         let mut row_num = 2;\n         let mut notice_capitalization = false;\n         for (complete, parts, only_capitalization) in suggestions.iter().take(MAX_SUGGESTIONS) {\n@@ -1505,7 +1511,9 @@ impl EmitterWriter {\n             let show_underline = !(parts.len() == 1 && parts[0].snippet.trim() == complete.trim())\n                 && complete.lines().count() == 1;\n \n-            let lines = sm.span_to_lines(parts[0].span).unwrap();\n+            let lines = sm\n+                .span_to_lines(parts[0].span)\n+                .expect(\"span_to_lines failed when emitting suggestion\");\n \n             assert!(!lines.lines.is_empty());\n "}, {"sha": "827e9b831f32d711978c1b0c960fc90aabc4ab49", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -10,6 +10,7 @@\n \n pub use emitter::ColorConfig;\n \n+use log::debug;\n use Level::*;\n \n use emitter::{is_case_difference, Emitter, EmitterWriter};\n@@ -174,6 +175,15 @@ impl CodeSuggestion {\n \n         self.substitutions\n             .iter()\n+            .filter(|subst| {\n+                // Suggestions coming from macros can have malformed spans. This is a heavy\n+                // handed approach to avoid ICEs by ignoring the suggestion outright.\n+                let invalid = subst.parts.iter().any(|item| cm.is_valid_span(item.span).is_err());\n+                if invalid {\n+                    debug!(\"splice_lines: suggestion contains an invalid span: {:?}\", subst);\n+                }\n+                !invalid\n+            })\n             .cloned()\n             .map(|mut substitution| {\n                 // Assumption: all spans are in the same file, and all spans"}, {"sha": "a73472021d4127bd246b1543c8d1d9d22eba1dcb", "filename": "src/librustc_errors/lock.rs", "status": "modified", "additions": 5, "deletions": 22, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_errors%2Flock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_errors%2Flock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flock.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -12,31 +12,14 @@\n use std::any::Any;\n \n #[cfg(windows)]\n-#[allow(nonstandard_style)]\n pub fn acquire_global_lock(name: &str) -> Box<dyn Any> {\n     use std::ffi::CString;\n     use std::io;\n \n-    type LPSECURITY_ATTRIBUTES = *mut u8;\n-    type BOOL = i32;\n-    type LPCSTR = *const u8;\n-    type HANDLE = *mut u8;\n-    type DWORD = u32;\n-\n-    const INFINITE: DWORD = !0;\n-    const WAIT_OBJECT_0: DWORD = 0;\n-    const WAIT_ABANDONED: DWORD = 0x00000080;\n-\n-    extern \"system\" {\n-        fn CreateMutexA(\n-            lpMutexAttributes: LPSECURITY_ATTRIBUTES,\n-            bInitialOwner: BOOL,\n-            lpName: LPCSTR,\n-        ) -> HANDLE;\n-        fn WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) -> DWORD;\n-        fn ReleaseMutex(hMutex: HANDLE) -> BOOL;\n-        fn CloseHandle(hObject: HANDLE) -> BOOL;\n-    }\n+    use winapi::shared::ntdef::HANDLE;\n+    use winapi::um::handleapi::CloseHandle;\n+    use winapi::um::synchapi::{CreateMutexA, ReleaseMutex, WaitForSingleObject};\n+    use winapi::um::winbase::{INFINITE, WAIT_ABANDONED, WAIT_OBJECT_0};\n \n     struct Handle(HANDLE);\n \n@@ -65,7 +48,7 @@ pub fn acquire_global_lock(name: &str) -> Box<dyn Any> {\n         //\n         // This will silently create one if it doesn't already exist, or it'll\n         // open up a handle to one if it already exists.\n-        let mutex = CreateMutexA(std::ptr::null_mut(), 0, cname.as_ptr() as *const u8);\n+        let mutex = CreateMutexA(std::ptr::null_mut(), 0, cname.as_ptr());\n         if mutex.is_null() {\n             panic!(\n                 \"failed to create global mutex named `{}`: {}\","}, {"sha": "007cee4c7642443c1e74220c0fb784479e825698", "filename": "src/librustc_feature/accepted.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_feature%2Faccepted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_feature%2Faccepted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Faccepted.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -257,6 +257,8 @@ declare_features! (\n     /// Allows relaxing the coherence rules such that\n     /// `impl<T> ForeignTrait<LocalType> for ForeignType<T>` is permitted.\n     (accepted, re_rebalance_coherence, \"1.41.0\", Some(55437), None),\n+    /// Allows using subslice patterns, `[a, .., b]` and `[a, xs @ .., b]`.\n+    (accepted, slice_patterns, \"1.42.0\", Some(62254), None),\n \n     // -------------------------------------------------------------------------\n     // feature-group-end: accepted features"}, {"sha": "6af9b6c0872780160e71c63332982c9344a433ed", "filename": "src/librustc_feature/active.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_feature%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_feature%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Factive.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -262,9 +262,6 @@ declare_features! (\n     /// Allows using non lexical lifetimes (RFC 2094).\n     (active, nll, \"1.0.0\", Some(43234), None),\n \n-    /// Allows using slice patterns.\n-    (active, slice_patterns, \"1.0.0\", Some(62254), None),\n-\n     /// Allows the definition of `const` functions with some advanced features.\n     (active, const_fn, \"1.2.0\", Some(57563), None),\n \n@@ -333,7 +330,7 @@ declare_features! (\n     (active, abi_ptx, \"1.15.0\", Some(38788), None),\n \n     /// Allows the `#[repr(i128)]` attribute for enums.\n-    (active, repr128, \"1.16.0\", Some(35118), None),\n+    (active, repr128, \"1.16.0\", Some(56071), None),\n \n     /// Allows `#[link(kind=\"static-nobundle\"...)]`.\n     (active, static_nobundle, \"1.16.0\", Some(37403), None),\n@@ -481,7 +478,7 @@ declare_features! (\n     (active, arbitrary_enum_discriminant, \"1.37.0\", Some(60553), None),\n \n     /// Allows `impl Trait` with multiple unrelated lifetimes.\n-    (active, member_constraints, \"1.37.0\", Some(61977), None),\n+    (active, member_constraints, \"1.37.0\", Some(61997), None),\n \n     /// Allows `async || body` closures.\n     (active, async_closure, \"1.37.0\", Some(62290), None),"}, {"sha": "1fef871b5140e41ad2b24b94b3cec134c0ef493c", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -377,6 +377,13 @@ pub enum GenericBound<'hir> {\n }\n \n impl GenericBound<'_> {\n+    pub fn trait_def_id(&self) -> Option<DefId> {\n+        match self {\n+            GenericBound::Trait(data, _) => Some(data.trait_ref.trait_def_id()),\n+            _ => None,\n+        }\n+    }\n+\n     pub fn span(&self) -> Span {\n         match self {\n             &GenericBound::Trait(ref t, ..) => t.span,\n@@ -2429,15 +2436,18 @@ pub enum ItemKind<'hir> {\n     TraitAlias(Generics<'hir>, GenericBounds<'hir>),\n \n     /// An implementation, e.g., `impl<A> Trait for Foo { .. }`.\n-    Impl(\n-        Unsafety,\n-        ImplPolarity,\n-        Defaultness,\n-        Generics<'hir>,\n-        Option<TraitRef<'hir>>, // (optional) trait this impl implements\n-        &'hir Ty<'hir>,         // self\n-        &'hir [ImplItemRef<'hir>],\n-    ),\n+    Impl {\n+        unsafety: Unsafety,\n+        polarity: ImplPolarity,\n+        defaultness: Defaultness,\n+        generics: Generics<'hir>,\n+\n+        /// The trait being implemented, if any.\n+        of_trait: Option<TraitRef<'hir>>,\n+\n+        self_ty: &'hir Ty<'hir>,\n+        items: &'hir [ImplItemRef<'hir>],\n+    },\n }\n \n impl ItemKind<'_> {\n@@ -2458,7 +2468,7 @@ impl ItemKind<'_> {\n             ItemKind::Union(..) => \"union\",\n             ItemKind::Trait(..) => \"trait\",\n             ItemKind::TraitAlias(..) => \"trait alias\",\n-            ItemKind::Impl(..) => \"impl\",\n+            ItemKind::Impl { .. } => \"impl\",\n         }\n     }\n \n@@ -2471,7 +2481,7 @@ impl ItemKind<'_> {\n             | ItemKind::Struct(_, ref generics)\n             | ItemKind::Union(_, ref generics)\n             | ItemKind::Trait(_, _, ref generics, _, _)\n-            | ItemKind::Impl(_, _, _, ref generics, _, _, _) => generics,\n+            | ItemKind::Impl { ref generics, .. } => generics,\n             _ => return None,\n         })\n     }"}, {"sha": "1a73e41db9da54c71d92d2a72d22239ac9c562bb", "filename": "src/librustc_hir/intravisit.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_hir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_hir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fintravisit.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -566,12 +566,20 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item<'v>) {\n             // `visit_enum_def()` takes care of visiting the `Item`'s `HirId`.\n             visitor.visit_enum_def(enum_definition, generics, item.hir_id, item.span)\n         }\n-        ItemKind::Impl(.., ref generics, ref opt_trait_reference, ref typ, impl_item_refs) => {\n+        ItemKind::Impl {\n+            unsafety: _,\n+            defaultness: _,\n+            polarity: _,\n+            ref generics,\n+            ref of_trait,\n+            ref self_ty,\n+            items,\n+        } => {\n             visitor.visit_id(item.hir_id);\n             visitor.visit_generics(generics);\n-            walk_list!(visitor, visit_trait_ref, opt_trait_reference);\n-            visitor.visit_ty(typ);\n-            walk_list!(visitor, visit_impl_item_ref, impl_item_refs);\n+            walk_list!(visitor, visit_trait_ref, of_trait);\n+            visitor.visit_ty(self_ty);\n+            walk_list!(visitor, visit_impl_item_ref, items);\n         }\n         ItemKind::Struct(ref struct_definition, ref generics)\n         | ItemKind::Union(ref struct_definition, ref generics) => {"}, {"sha": "6c7d419395317b950a713df4949ed62c17aa3d2f", "filename": "src/librustc_hir/print.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_hir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_hir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fprint.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -627,15 +627,15 @@ impl<'a> State<'a> {\n                 self.head(visibility_qualified(&item.vis, \"union\"));\n                 self.print_struct(struct_def, generics, item.ident.name, item.span, true);\n             }\n-            hir::ItemKind::Impl(\n+            hir::ItemKind::Impl {\n                 unsafety,\n                 polarity,\n                 defaultness,\n                 ref generics,\n-                ref opt_trait,\n-                ref ty,\n-                impl_items,\n-            ) => {\n+                ref of_trait,\n+                ref self_ty,\n+                items,\n+            } => {\n                 self.head(\"\");\n                 self.print_visibility(&item.vis);\n                 self.print_defaultness(defaultness);\n@@ -651,19 +651,19 @@ impl<'a> State<'a> {\n                     self.s.word(\"!\");\n                 }\n \n-                if let Some(ref t) = opt_trait {\n+                if let Some(ref t) = of_trait {\n                     self.print_trait_ref(t);\n                     self.s.space();\n                     self.word_space(\"for\");\n                 }\n \n-                self.print_type(&ty);\n+                self.print_type(&self_ty);\n                 self.print_where_clause(&generics.where_clause);\n \n                 self.s.space();\n                 self.bopen();\n                 self.print_inner_attributes(&item.attrs);\n-                for impl_item in impl_items {\n+                for impl_item in items {\n                     self.ann.nested(self, Nested::ImplItem(impl_item.id));\n                 }\n                 self.bclose(item.span);"}, {"sha": "c5e74868bda4a705352197c4a08eb0da0674ca27", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -315,7 +315,7 @@ impl DirtyCleanVisitor<'tcx> {\n                     //HirItem::Trait(..) => (\"ItemTrait\", LABELS_TRAIT),\n \n                     // An implementation, eg `impl<A> Trait for Foo { .. }`\n-                    HirItem::Impl(..) => (\"ItemKind::Impl\", LABELS_IMPL),\n+                    HirItem::Impl { .. } => (\"ItemKind::Impl\", LABELS_IMPL),\n \n                     _ => self.tcx.sess.span_fatal(\n                         attr.span,"}, {"sha": "87f39dedd02734331310758d29aab7753f81d091", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -236,7 +236,7 @@ fn encode_work_product_index(\n     let serialized_products: Vec<_> = work_products\n         .iter()\n         .map(|(id, work_product)| SerializedWorkProduct {\n-            id: id.clone(),\n+            id: *id,\n             work_product: work_product.clone(),\n         })\n         .collect();"}, {"sha": "1fe5248dbf4ceac9b33712b6cbacc2af81081689", "filename": "src/librustc_interface/Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2FCargo.toml?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -40,9 +40,13 @@ rustc_errors = { path = \"../librustc_errors\" }\n rustc_plugin_impl = { path = \"../librustc_plugin_impl\" }\n rustc_privacy = { path = \"../librustc_privacy\" }\n rustc_resolve = { path = \"../librustc_resolve\" }\n+rustc_ty = { path = \"../librustc_ty\" }\n tempfile = \"3.0.5\"\n once_cell = \"1\"\n \n+[target.'cfg(windows)'.dependencies]\n+winapi = { version = \"0.3\", features = [\"libloaderapi\"] }\n+\n [dev-dependencies]\n rustc_target = { path = \"../librustc_target\" }\n "}, {"sha": "d62c7539d5f2189ac7c0663c7dc4e4231219bc29", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -15,7 +15,7 @@ use rustc::session::search_paths::PathKind;\n use rustc::session::Session;\n use rustc::traits;\n use rustc::ty::steal::Steal;\n-use rustc::ty::{self, AllArenas, GlobalCtxt, ResolverOutputs, TyCtxt};\n+use rustc::ty::{self, GlobalCtxt, ResolverOutputs, TyCtxt};\n use rustc::util::common::ErrorReported;\n use rustc_builtin_macros;\n use rustc_codegen_ssa::back::link::emit_metadata;\n@@ -680,6 +680,7 @@ pub fn default_provide(providers: &mut ty::query::Providers<'_>) {\n     rustc_passes::provide(providers);\n     rustc_resolve::provide(providers);\n     rustc_traits::provide(providers);\n+    rustc_ty::provide(providers);\n     rustc_metadata::provide(providers);\n     rustc_lint::provide(providers);\n     rustc_codegen_utils::provide(providers);\n@@ -714,7 +715,6 @@ pub fn create_global_ctxt<'tcx>(\n     outputs: OutputFilenames,\n     crate_name: &str,\n     global_ctxt: &'tcx Once<GlobalCtxt<'tcx>>,\n-    all_arenas: &'tcx AllArenas,\n     arena: &'tcx WorkerLocal<Arena<'tcx>>,\n ) -> QueryContext<'tcx> {\n     let sess = &compiler.session();\n@@ -745,7 +745,6 @@ pub fn create_global_ctxt<'tcx>(\n                 lint_store,\n                 local_providers,\n                 extern_providers,\n-                &all_arenas,\n                 arena,\n                 resolver_outputs,\n                 hir_map,"}, {"sha": "0af9b17a2995b2f5026b2d1cefc2759ddb93d316", "filename": "src/librustc_interface/queries.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_interface%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_interface%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fqueries.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -7,7 +7,7 @@ use rustc::hir::map;\n use rustc::session::config::{OutputFilenames, OutputType};\n use rustc::session::Session;\n use rustc::ty::steal::Steal;\n-use rustc::ty::{AllArenas, GlobalCtxt, ResolverOutputs};\n+use rustc::ty::{GlobalCtxt, ResolverOutputs};\n use rustc::util::common::ErrorReported;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use rustc_data_structures::sync::{Lrc, Once, WorkerLocal};\n@@ -66,7 +66,6 @@ pub struct Queries<'tcx> {\n     compiler: &'tcx Compiler,\n     gcx: Once<GlobalCtxt<'tcx>>,\n \n-    all_arenas: AllArenas,\n     arena: WorkerLocal<Arena<'tcx>>,\n \n     dep_graph_future: Query<Option<DepGraphFuture>>,\n@@ -86,7 +85,6 @@ impl<'tcx> Queries<'tcx> {\n         Queries {\n             compiler,\n             gcx: Once::new(),\n-            all_arenas: AllArenas::new(),\n             arena: WorkerLocal::new(|_| Arena::default()),\n             dep_graph_future: Default::default(),\n             parse: Default::default(),\n@@ -265,7 +263,6 @@ impl<'tcx> Queries<'tcx> {\n                 outputs,\n                 &crate_name,\n                 &self.gcx,\n-                &self.all_arenas,\n                 &self.arena,\n             ))\n         })"}, {"sha": "21f9fa48165918f254e716ce59519bda17e4fa01", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -340,19 +340,17 @@ fn sysroot_candidates() -> Vec<PathBuf> {\n     fn current_dll_path() -> Option<PathBuf> {\n         use std::ffi::OsString;\n         use std::os::windows::prelude::*;\n+        use std::ptr;\n \n-        extern \"system\" {\n-            fn GetModuleHandleExW(dwFlags: u32, lpModuleName: usize, phModule: *mut usize) -> i32;\n-            fn GetModuleFileNameW(hModule: usize, lpFilename: *mut u16, nSize: u32) -> u32;\n-        }\n-\n-        const GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS: u32 = 0x00000004;\n+        use winapi::um::libloaderapi::{\n+            GetModuleFileNameW, GetModuleHandleExW, GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,\n+        };\n \n         unsafe {\n-            let mut module = 0;\n+            let mut module = ptr::null_mut();\n             let r = GetModuleHandleExW(\n                 GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,\n-                current_dll_path as usize,\n+                current_dll_path as usize as *mut _,\n                 &mut module,\n             );\n             if r == 0 {"}, {"sha": "c8d3d5f9c83d8d18ac7f44fcbef9c9c29c57318e", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -251,7 +251,7 @@ impl EarlyLintPass for UnsafeCode {\n                 self.report_unsafe(cx, it.span, \"declaration of an `unsafe` trait\")\n             }\n \n-            ast::ItemKind::Impl(ast::Unsafety::Unsafe, ..) => {\n+            ast::ItemKind::Impl { unsafety: ast::Unsafety::Unsafe, .. } => {\n                 self.report_unsafe(cx, it.span, \"implementation of an `unsafe` trait\")\n             }\n \n@@ -431,15 +431,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n                 \"a trait\"\n             }\n             hir::ItemKind::TyAlias(..) => \"a type alias\",\n-            hir::ItemKind::Impl(.., Some(ref trait_ref), _, impl_item_refs) => {\n+            hir::ItemKind::Impl { of_trait: Some(ref trait_ref), items, .. } => {\n                 // If the trait is private, add the impl items to `private_traits` so they don't get\n                 // reported for missing docs.\n                 let real_trait = trait_ref.path.res.def_id();\n                 if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(real_trait) {\n                     match cx.tcx.hir().find(hir_id) {\n                         Some(Node::Item(item)) => {\n                             if let hir::VisibilityKind::Inherited = item.vis.node {\n-                                for impl_item_ref in impl_item_refs {\n+                                for impl_item_ref in items {\n                                     self.private_traits.insert(impl_item_ref.id.hir_id);\n                                 }\n                             }\n@@ -657,7 +657,7 @@ impl EarlyLintPass for AnonymousParameters {\n                                 )\n                                 .span_suggestion(\n                                     arg.pat.span,\n-                                    \"Try naming the parameter or explicitly \\\n+                                    \"try naming the parameter or explicitly \\\n                                     ignoring it\",\n                                     format!(\"_: {}\", ty_snip),\n                                     appl,\n@@ -1934,21 +1934,21 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n             use rustc::ty::TyKind::*;\n             match ty.kind {\n                 // Primitive types that don't like 0 as a value.\n-                Ref(..) => Some((format!(\"References must be non-null\"), None)),\n+                Ref(..) => Some((format!(\"references must be non-null\"), None)),\n                 Adt(..) if ty.is_box() => Some((format!(\"`Box` must be non-null\"), None)),\n-                FnPtr(..) => Some((format!(\"Function pointers must be non-null\"), None)),\n-                Never => Some((format!(\"The never type (`!`) has no valid value\"), None)),\n+                FnPtr(..) => Some((format!(\"function pointers must be non-null\"), None)),\n+                Never => Some((format!(\"the `!` type has no valid value\"), None)),\n                 RawPtr(tm) if matches!(tm.ty.kind, Dynamic(..)) =>\n                 // raw ptr to dyn Trait\n                 {\n-                    Some((format!(\"The vtable of a wide raw pointer must be non-null\"), None))\n+                    Some((format!(\"the vtable of a wide raw pointer must be non-null\"), None))\n                 }\n                 // Primitive types with other constraints.\n                 Bool if init == InitKind::Uninit => {\n-                    Some((format!(\"Booleans must be `true` or `false`\"), None))\n+                    Some((format!(\"booleans must be either `true` or `false`\"), None))\n                 }\n                 Char if init == InitKind::Uninit => {\n-                    Some((format!(\"Characters must be a valid unicode codepoint\"), None))\n+                    Some((format!(\"characters must be a valid Unicode codepoint\"), None))\n                 }\n                 // Recurse and checks for some compound types.\n                 Adt(adt_def, substs) if !adt_def.is_union() => {\n@@ -1959,21 +1959,24 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n                         // return `Bound::Excluded`.  (And we have tests checking that we\n                         // handle the attribute correctly.)\n                         (Bound::Included(lo), _) if lo > 0 => {\n-                            return Some((format!(\"{} must be non-null\", ty), None));\n+                            return Some((format!(\"`{}` must be non-null\", ty), None));\n                         }\n                         (Bound::Included(_), _) | (_, Bound::Included(_))\n                             if init == InitKind::Uninit =>\n                         {\n                             return Some((\n-                                format!(\"{} must be initialized inside its custom valid range\", ty),\n+                                format!(\n+                                    \"`{}` must be initialized inside its custom valid range\",\n+                                    ty,\n+                                ),\n                                 None,\n                             ));\n                         }\n                         _ => {}\n                     }\n                     // Now, recurse.\n                     match adt_def.variants.len() {\n-                        0 => Some((format!(\"0-variant enums have no valid value\"), None)),\n+                        0 => Some((format!(\"enums with no variants have no valid value\"), None)),\n                         1 => {\n                             // Struct, or enum with exactly one variant.\n                             // Proceed recursively, check all fields."}, {"sha": "42ec8787cb2878a51391110e70f0ef02b1600972", "filename": "src/librustc_lint/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_lint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_lint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fcontext.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -245,7 +245,7 @@ impl LintStore {\n \n     pub fn register_renamed(&mut self, old_name: &str, new_name: &str) {\n         let target = match self.by_name.get(new_name) {\n-            Some(&Id(lint_id)) => lint_id.clone(),\n+            Some(&Id(lint_id)) => lint_id,\n             _ => bug!(\"invalid lint renaming of {} to {}\", old_name, new_name),\n         };\n         self.by_name.insert(old_name.to_string(), Renamed(new_name.to_string(), target));"}, {"sha": "91aeccbb5e334457e44b6ce9e0ed4cfabdc79e52", "filename": "src/librustc_lint/internal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_lint%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_lint%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Finternal.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -221,7 +221,7 @@ declare_lint_pass!(LintPassImpl => [LINT_PASS_IMPL_WITHOUT_MACRO]);\n \n impl EarlyLintPass for LintPassImpl {\n     fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n-        if let ItemKind::Impl(_, _, _, _, Some(lint_pass), _, _) = &item.kind {\n+        if let ItemKind::Impl { of_trait: Some(lint_pass), .. } = &item.kind {\n             if let Some(last) = lint_pass.path.segments.last() {\n                 if last.ident.name == sym::LintPass {\n                     let expn_data = lint_pass.path.span.ctxt().outer_expn_data();"}, {"sha": "394da4a5bb0c151942a897913b39d92468a8c77d", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -350,7 +350,20 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n     }\n \n     fn check_pat(&mut self, cx: &LateContext<'_, '_>, p: &hir::Pat<'_>) {\n-        if let &PatKind::Binding(_, _, ident, _) = &p.kind {\n+        if let &PatKind::Binding(_, hid, ident, _) = &p.kind {\n+            if let hir::Node::Pat(parent_pat) = cx.tcx.hir().get(cx.tcx.hir().get_parent_node(hid))\n+            {\n+                if let PatKind::Struct(_, field_pats, _) = &parent_pat.kind {\n+                    for field in field_pats.iter() {\n+                        if field.ident != ident {\n+                            // Only check if a new name has been introduced, to avoid warning\n+                            // on both the struct definition and this pattern.\n+                            self.check_snake_case(cx, \"variable\", &ident);\n+                        }\n+                    }\n+                    return;\n+                }\n+            }\n             self.check_snake_case(cx, \"variable\", &ident);\n         }\n     }"}, {"sha": "405ce0307cd822f7fff95ddab38f192f12c8eff2", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -215,12 +215,14 @@ fn main() {\n     let mut cmd = Command::new(&llvm_config);\n     cmd.arg(llvm_link_arg).arg(\"--ldflags\");\n     for lib in output(&mut cmd).split_whitespace() {\n-        if lib.starts_with(\"-LIBPATH:\") {\n-            println!(\"cargo:rustc-link-search=native={}\", &lib[9..]);\n-        } else if is_crossed {\n-            if lib.starts_with(\"-L\") {\n+        if is_crossed {\n+            if lib.starts_with(\"-LIBPATH:\") {\n+                println!(\"cargo:rustc-link-search=native={}\", lib[9..].replace(&host, &target));\n+            } else if lib.starts_with(\"-L\") {\n                 println!(\"cargo:rustc-link-search=native={}\", lib[2..].replace(&host, &target));\n             }\n+        } else if lib.starts_with(\"-LIBPATH:\") {\n+            println!(\"cargo:rustc-link-search=native={}\", &lib[9..]);\n         } else if lib.starts_with(\"-l\") {\n             println!(\"cargo:rustc-link-lib={}\", &lib[2..]);\n         } else if lib.starts_with(\"-L\") {"}, {"sha": "0a0bcb190bea720b1b90c7746d371915ce3f4967", "filename": "src/librustc_metadata/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2FCargo.toml?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -27,3 +27,6 @@ rustc_expand = { path = \"../librustc_expand\" }\n rustc_parse = { path = \"../librustc_parse\" }\n rustc_span = { path = \"../librustc_span\" }\n rustc_error_codes = { path = \"../librustc_error_codes\" }\n+\n+[target.'cfg(windows)'.dependencies]\n+winapi = { version = \"0.3\", features = [\"errhandlingapi\", \"libloaderapi\"] }"}, {"sha": "f04d0239d49237f04810d567b5c262cc405e6a10", "filename": "src/librustc_metadata/dynamic_lib.rs", "status": "modified", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_metadata%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_metadata%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdynamic_lib.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -111,9 +111,9 @@ mod dl {\n     ) -> Result<*mut u8, String> {\n         check_for_errors_in(|| libc::dlsym(handle as *mut libc::c_void, symbol) as *mut u8)\n     }\n+\n     pub(super) unsafe fn close(handle: *mut u8) {\n         libc::dlclose(handle as *mut libc::c_void);\n-        ()\n     }\n }\n \n@@ -124,27 +124,15 @@ mod dl {\n     use std::os::windows::prelude::*;\n     use std::ptr;\n \n-    use libc::{c_char, c_uint, c_void};\n-\n-    type DWORD = u32;\n-    type HMODULE = *mut u8;\n-    type BOOL = i32;\n-    type LPCWSTR = *const u16;\n-    type LPCSTR = *const i8;\n-\n-    extern \"system\" {\n-        fn SetThreadErrorMode(dwNewMode: DWORD, lpOldMode: *mut DWORD) -> c_uint;\n-        fn LoadLibraryW(name: LPCWSTR) -> HMODULE;\n-        fn GetModuleHandleExW(dwFlags: DWORD, name: LPCWSTR, handle: *mut HMODULE) -> BOOL;\n-        fn GetProcAddress(handle: HMODULE, name: LPCSTR) -> *mut c_void;\n-        fn FreeLibrary(handle: HMODULE) -> BOOL;\n-    }\n+    use winapi::shared::minwindef::HMODULE;\n+    use winapi::um::errhandlingapi::SetThreadErrorMode;\n+    use winapi::um::libloaderapi::{FreeLibrary, GetModuleHandleExW, GetProcAddress, LoadLibraryW};\n+    use winapi::um::winbase::SEM_FAILCRITICALERRORS;\n \n     pub(super) fn open(filename: Option<&OsStr>) -> Result<*mut u8, String> {\n         // disable \"dll load failed\" error dialog.\n         let prev_error_mode = unsafe {\n-            // SEM_FAILCRITICALERRORS 0x01\n-            let new_error_mode = 1;\n+            let new_error_mode = SEM_FAILCRITICALERRORS;\n             let mut prev_error_mode = 0;\n             let result = SetThreadErrorMode(new_error_mode, &mut prev_error_mode);\n             if result == 0 {\n@@ -156,12 +144,12 @@ mod dl {\n         let result = match filename {\n             Some(filename) => {\n                 let filename_str: Vec<_> = filename.encode_wide().chain(Some(0)).collect();\n-                let result = unsafe { LoadLibraryW(filename_str.as_ptr()) };\n+                let result = unsafe { LoadLibraryW(filename_str.as_ptr()) } as *mut u8;\n                 ptr_result(result)\n             }\n             None => {\n                 let mut handle = ptr::null_mut();\n-                let succeeded = unsafe { GetModuleHandleExW(0 as DWORD, ptr::null(), &mut handle) };\n+                let succeeded = unsafe { GetModuleHandleExW(0, ptr::null(), &mut handle) };\n                 if succeeded == 0 {\n                     Err(io::Error::last_os_error().to_string())\n                 } else {\n@@ -177,7 +165,10 @@ mod dl {\n         result\n     }\n \n-    pub(super) unsafe fn symbol(handle: *mut u8, symbol: *const c_char) -> Result<*mut u8, String> {\n+    pub(super) unsafe fn symbol(\n+        handle: *mut u8,\n+        symbol: *const libc::c_char,\n+    ) -> Result<*mut u8, String> {\n         let ptr = GetProcAddress(handle as HMODULE, symbol) as *mut u8;\n         ptr_result(ptr)\n     }"}, {"sha": "cf925ab91875f0fcf0e572ecbd22599d742f24aa", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -10,7 +10,7 @@\n #![feature(proc_macro_internals)]\n #![feature(proc_macro_quote)]\n #![feature(rustc_private)]\n-#![feature(slice_patterns)]\n+#![cfg_attr(bootstrap, feature(slice_patterns))]\n #![feature(specialization)]\n #![feature(stmt_expr_attributes)]\n #![recursion_limit = \"256\"]"}, {"sha": "6280121f655660fab155a744edb8a5b1a6144446", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -840,7 +840,7 @@ impl<'a, 'tcx> CrateMetadata {\n \n     fn get_stability(&self, id: DefIndex) -> Option<attr::Stability> {\n         match self.is_proc_macro(id) {\n-            true => self.root.proc_macro_stability.clone(),\n+            true => self.root.proc_macro_stability,\n             false => self.root.per_def.stability.get(self, id).map(|stab| stab.decode(self)),\n         }\n     }"}, {"sha": "9d2bea28c8c2ebf88da381576bb93becd9c8ad9c", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -504,7 +504,7 @@ impl<'tcx> EncodeContext<'tcx> {\n             },\n             proc_macro_data,\n             proc_macro_stability: if is_proc_macro {\n-                tcx.lookup_stability(DefId::local(CRATE_DEF_INDEX)).map(|stab| stab.clone())\n+                tcx.lookup_stability(DefId::local(CRATE_DEF_INDEX)).map(|stab| *stab)\n             } else {\n                 None\n             },\n@@ -1073,7 +1073,7 @@ impl EncodeContext<'tcx> {\n                     ctor: None,\n                 }), adt_def.repr)\n             }\n-            hir::ItemKind::Impl(_, _, defaultness, ..) => {\n+            hir::ItemKind::Impl { defaultness, .. } => {\n                 let trait_ref = self.tcx.impl_trait_ref(def_id);\n                 let polarity = self.tcx.impl_polarity(def_id);\n                 let parent = if let Some(trait_ref) = trait_ref {\n@@ -1149,7 +1149,7 @@ impl EncodeContext<'tcx> {\n                     })\n                 )\n             }\n-            hir::ItemKind::Impl(..) | hir::ItemKind::Trait(..) => {\n+            hir::ItemKind::Impl { .. } | hir::ItemKind::Trait(..) => {\n                 let associated_item_def_ids = self.tcx.associated_item_def_ids(def_id);\n                 record!(self.per_def.children[def_id] <-\n                     associated_item_def_ids.iter().map(|&def_id| {\n@@ -1172,13 +1172,13 @@ impl EncodeContext<'tcx> {\n             | hir::ItemKind::Enum(..)\n             | hir::ItemKind::Struct(..)\n             | hir::ItemKind::Union(..)\n-            | hir::ItemKind::Impl(..) => self.encode_item_type(def_id),\n+            | hir::ItemKind::Impl { .. } => self.encode_item_type(def_id),\n             _ => {}\n         }\n         if let hir::ItemKind::Fn(..) = item.kind {\n             record!(self.per_def.fn_sig[def_id] <- tcx.fn_sig(def_id));\n         }\n-        if let hir::ItemKind::Impl(..) = item.kind {\n+        if let hir::ItemKind::Impl { .. } = item.kind {\n             if let Some(trait_ref) = self.tcx.impl_trait_ref(def_id) {\n                 record!(self.per_def.impl_trait_ref[def_id] <- trait_ref);\n             }\n@@ -1199,7 +1199,7 @@ impl EncodeContext<'tcx> {\n             | hir::ItemKind::Enum(..)\n             | hir::ItemKind::Struct(..)\n             | hir::ItemKind::Union(..)\n-            | hir::ItemKind::Impl(..)\n+            | hir::ItemKind::Impl { .. }\n             | hir::ItemKind::OpaqueTy(..)\n             | hir::ItemKind::Trait(..)\n             | hir::ItemKind::TraitAlias(..) => {\n@@ -1645,7 +1645,7 @@ impl EncodeContext<'tcx> {\n             hir::ItemKind::Union(..) => {\n                 self.encode_fields(def_id);\n             }\n-            hir::ItemKind::Impl(..) => {\n+            hir::ItemKind::Impl { .. } => {\n                 for &trait_item_def_id in self.tcx.associated_item_def_ids(def_id).iter() {\n                     self.encode_info_for_impl_item(trait_item_def_id);\n                 }\n@@ -1666,7 +1666,7 @@ struct ImplVisitor<'tcx> {\n \n impl<'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'tcx> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        if let hir::ItemKind::Impl(..) = item.kind {\n+        if let hir::ItemKind::Impl { .. } = item.kind {\n             let impl_id = self.tcx.hir().local_def_id(item.hir_id);\n             if let Some(trait_ref) = self.tcx.impl_trait_ref(impl_id) {\n                 self.impls.entry(trait_ref.def_id).or_default().push(impl_id.index);"}, {"sha": "9d5cf3ec4bec0e8c2f962d85123fc020f6654dd8", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -200,8 +200,8 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'tcx> {\n                 region,\n                 reserve_location: location,\n                 activation_location: TwoPhaseActivation::NotTwoPhase,\n-                borrowed_place: borrowed_place.clone(),\n-                assigned_place: assigned_place.clone(),\n+                borrowed_place: *borrowed_place,\n+                assigned_place: *assigned_place,\n             };\n             let idx = self.idx_vec.push(borrow);\n             self.location_map.insert(location, idx);"}, {"sha": "01b7c5645fe8b2a1c0aaff5baed72ceede5ddb87", "filename": "src/librustc_mir/borrow_check/diagnostics/explain_borrow.rs", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -2,12 +2,13 @@\n \n use std::collections::VecDeque;\n \n+use rustc::infer::NLLRegionVariableOrigin;\n use rustc::mir::{\n     Body, CastKind, ConstraintCategory, FakeReadCause, Local, Location, Operand, Place, Rvalue,\n     Statement, StatementKind, TerminatorKind,\n };\n use rustc::ty::adjustment::PointerCast;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, RegionVid, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_index::vec::IndexVec;\n@@ -254,6 +255,23 @@ impl BorrowExplanation {\n }\n \n impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n+    fn free_region_constraint_info(\n+        &self,\n+        borrow_region: RegionVid,\n+        outlived_region: RegionVid,\n+    ) -> (ConstraintCategory, bool, Span, Option<RegionName>) {\n+        let (category, from_closure, span) = self.regioncx.best_blame_constraint(\n+            &self.body,\n+            borrow_region,\n+            NLLRegionVariableOrigin::FreeRegion,\n+            |r| self.regioncx.provides_universal_region(r, borrow_region, outlived_region),\n+        );\n+\n+        let outlived_fr_name = self.give_region_a_name(outlived_region);\n+\n+        (category, from_closure, span, outlived_fr_name)\n+    }\n+\n     /// Returns structured explanation for *why* the borrow contains the\n     /// point from `location`. This is key for the \"3-point errors\"\n     /// [described in the NLL RFC][d].\n@@ -278,14 +296,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             location, borrow, kind_place\n         );\n \n-        let regioncx = &self.nonlexical_regioncx;\n+        let regioncx = &self.regioncx;\n         let body: &Body<'_> = &self.body;\n         let tcx = self.infcx.tcx;\n \n         let borrow_region_vid = borrow.region;\n         debug!(\"explain_why_borrow_contains_point: borrow_region_vid={:?}\", borrow_region_vid);\n \n-        let region_sub = regioncx.find_sub_region_live_at(borrow_region_vid, location);\n+        let region_sub = self.regioncx.find_sub_region_live_at(borrow_region_vid, location);\n         debug!(\"explain_why_borrow_contains_point: region_sub={:?}\", region_sub);\n \n         match find_use::find(body, regioncx, tcx, region_sub, location) {\n@@ -329,10 +347,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n \n             None => {\n-                if let Some(region) = regioncx.to_error_region_vid(borrow_region_vid) {\n-                    let (category, from_closure, span, region_name) = self\n-                        .nonlexical_regioncx\n-                        .free_region_constraint_info(self, borrow_region_vid, region);\n+                if let Some(region) = self.to_error_region_vid(borrow_region_vid) {\n+                    let (category, from_closure, span, region_name) =\n+                        self.free_region_constraint_info(borrow_region_vid, region);\n                     if let Some(region_name) = region_name {\n                         let opt_place_desc = self.describe_place(borrow.borrowed_place.as_ref());\n                         BorrowExplanation::MustBeValidFor {\n@@ -345,14 +362,14 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     } else {\n                         debug!(\n                             \"explain_why_borrow_contains_point: \\\n-                                Could not generate a region name\"\n+                             Could not generate a region name\"\n                         );\n                         BorrowExplanation::Unexplained\n                     }\n                 } else {\n                     debug!(\n                         \"explain_why_borrow_contains_point: \\\n-                            Could not generate an error region vid\"\n+                         Could not generate an error region vid\"\n                     );\n                     BorrowExplanation::Unexplained\n                 }"}, {"sha": "0fc73d33f90013475e059f7d9f8003343cdfe071", "filename": "src/librustc_mir/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -32,7 +32,7 @@ mod region_errors;\n crate use mutability_errors::AccessKind;\n crate use outlives_suggestion::OutlivesSuggestionBuilder;\n crate use region_errors::{ErrorConstraintInfo, RegionErrorKind, RegionErrors};\n-crate use region_name::{RegionErrorNamingCtx, RegionName, RegionNameSource};\n+crate use region_name::{RegionName, RegionNameSource};\n \n pub(super) struct IncludingDowncast(pub(super) bool);\n "}, {"sha": "ee9489078bdb9ba61d73168d6a419363235f637b", "filename": "src/librustc_mir/borrow_check/diagnostics/outlives_suggestion.rs", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Foutlives_suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Foutlives_suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Foutlives_suggestion.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -12,7 +12,7 @@ use smallvec::SmallVec;\n \n use crate::borrow_check::MirBorrowckCtxt;\n \n-use super::{ErrorConstraintInfo, RegionErrorNamingCtx, RegionName, RegionNameSource};\n+use super::{ErrorConstraintInfo, RegionName, RegionNameSource};\n \n /// The different things we could suggest.\n enum SuggestedConstraint {\n@@ -77,19 +77,15 @@ impl OutlivesSuggestionBuilder {\n     fn region_vid_to_name(\n         &self,\n         mbcx: &MirBorrowckCtxt<'_, '_>,\n-        renctx: &mut RegionErrorNamingCtx,\n         region: RegionVid,\n     ) -> Option<RegionName> {\n-        mbcx.nonlexical_regioncx\n-            .give_region_a_name(mbcx, renctx, region)\n-            .filter(Self::region_name_is_suggestable)\n+        mbcx.give_region_a_name(region).filter(Self::region_name_is_suggestable)\n     }\n \n     /// Compiles a list of all suggestions to be printed in the final big suggestion.\n     fn compile_all_suggestions(\n         &self,\n         mbcx: &MirBorrowckCtxt<'_, '_>,\n-        renctx: &mut RegionErrorNamingCtx,\n     ) -> SmallVec<[SuggestedConstraint; 2]> {\n         let mut suggested = SmallVec::new();\n \n@@ -98,7 +94,7 @@ impl OutlivesSuggestionBuilder {\n         let mut unified_already = FxHashSet::default();\n \n         for (fr, outlived) in &self.constraints_to_add {\n-            let fr_name = if let Some(fr_name) = self.region_vid_to_name(mbcx, renctx, *fr) {\n+            let fr_name = if let Some(fr_name) = self.region_vid_to_name(mbcx, *fr) {\n                 fr_name\n             } else {\n                 continue;\n@@ -107,9 +103,7 @@ impl OutlivesSuggestionBuilder {\n             let outlived = outlived\n                 .iter()\n                 // if there is a `None`, we will just omit that constraint\n-                .filter_map(|fr| {\n-                    self.region_vid_to_name(mbcx, renctx, *fr).map(|rname| (fr, rname))\n-                })\n+                .filter_map(|fr| self.region_vid_to_name(mbcx, *fr).map(|rname| (fr, rname)))\n                 .collect::<Vec<_>>();\n \n             // No suggestable outlived lifetimes.\n@@ -173,12 +167,11 @@ impl OutlivesSuggestionBuilder {\n         &mut self,\n         mbcx: &MirBorrowckCtxt<'_, '_>,\n         errci: &ErrorConstraintInfo,\n-        renctx: &mut RegionErrorNamingCtx,\n         diag: &mut DiagnosticBuilder<'_>,\n     ) {\n         // Emit an intermediate note.\n-        let fr_name = self.region_vid_to_name(mbcx, renctx, errci.fr);\n-        let outlived_fr_name = self.region_vid_to_name(mbcx, renctx, errci.outlived_fr);\n+        let fr_name = self.region_vid_to_name(mbcx, errci.fr);\n+        let outlived_fr_name = self.region_vid_to_name(mbcx, errci.outlived_fr);\n \n         if let (Some(fr_name), Some(outlived_fr_name)) = (fr_name, outlived_fr_name) {\n             if let RegionNameSource::Static = outlived_fr_name.source {\n@@ -194,11 +187,7 @@ impl OutlivesSuggestionBuilder {\n \n     /// If there is a suggestion to emit, add a diagnostic to the buffer. This is the final\n     /// suggestion including all collected constraints.\n-    crate fn add_suggestion(\n-        &self,\n-        mbcx: &mut MirBorrowckCtxt<'_, '_>,\n-        renctx: &mut RegionErrorNamingCtx,\n-    ) {\n+    crate fn add_suggestion(&self, mbcx: &mut MirBorrowckCtxt<'_, '_>) {\n         // No constraints to add? Done.\n         if self.constraints_to_add.is_empty() {\n             debug!(\"No constraints to suggest.\");\n@@ -215,7 +204,7 @@ impl OutlivesSuggestionBuilder {\n         }\n \n         // Get all suggestable constraints.\n-        let suggested = self.compile_all_suggestions(mbcx, renctx);\n+        let suggested = self.compile_all_suggestions(mbcx);\n \n         // If there are no suggestable constraints...\n         if suggested.is_empty() {"}, {"sha": "b999dfa3031035f83157f12b37fd2e0a1ea4c2f3", "filename": "src/librustc_mir/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 193, "deletions": 515, "changes": 708, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,27 +1,25 @@\n //! Error reporting machinery for lifetime errors.\n \n use rustc::infer::{\n-    error_reporting::nice_region_error::NiceRegionError, region_constraints::GenericKind,\n-    InferCtxt, NLLRegionVariableOrigin,\n+    error_reporting::nice_region_error::NiceRegionError, opaque_types, NLLRegionVariableOrigin,\n };\n-use rustc::mir::{Body, ConstraintCategory, Location};\n+use rustc::mir::ConstraintCategory;\n use rustc::ty::{self, RegionVid, Ty};\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir::def_id::DefId;\n-use rustc_index::vec::IndexVec;\n use rustc_span::symbol::kw;\n use rustc_span::Span;\n-use std::collections::VecDeque;\n \n use crate::util::borrowck_errors;\n \n use crate::borrow_check::{\n-    constraints::OutlivesConstraint, nll::ConstraintDescription,\n-    region_infer::RegionInferenceContext, type_check::Locations, universal_regions::DefiningTy,\n+    nll::ConstraintDescription,\n+    region_infer::{values::RegionElement, TypeTest},\n+    universal_regions::DefiningTy,\n     MirBorrowckCtxt,\n };\n \n-use super::{OutlivesSuggestionBuilder, RegionErrorNamingCtx, RegionName, RegionNameSource};\n+use super::{OutlivesSuggestionBuilder, RegionName, RegionNameSource};\n \n impl ConstraintDescription for ConstraintCategory {\n     fn description(&self) -> &'static str {\n@@ -46,13 +44,6 @@ impl ConstraintDescription for ConstraintCategory {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-enum Trace {\n-    StartRegion,\n-    FromOutlivesConstraint(OutlivesConstraint),\n-    NotVisited,\n-}\n-\n /// A collection of errors encountered during region inference. This is needed to efficiently\n /// report errors after borrow checking.\n ///\n@@ -62,23 +53,8 @@ crate type RegionErrors<'tcx> = Vec<RegionErrorKind<'tcx>>;\n \n #[derive(Clone, Debug)]\n crate enum RegionErrorKind<'tcx> {\n-    /// An error for a type test: `T: 'a` does not live long enough.\n-    TypeTestDoesNotLiveLongEnough {\n-        /// The span of the type test.\n-        span: Span,\n-        /// The generic type of the type test.\n-        generic: GenericKind<'tcx>,\n-    },\n-\n-    /// A generic bound failure for a type test.\n-    TypeTestGenericBoundError {\n-        /// The span of the type test.\n-        span: Span,\n-        /// The generic type of the type test.\n-        generic: GenericKind<'tcx>,\n-        /// The lower bound region.\n-        lower_bound_region: ty::Region<'tcx>,\n-    },\n+    /// A generic bound failure for a type test (`T: 'a`).\n+    TypeTestError { type_test: TypeTest<'tcx> },\n \n     /// An unexpected hidden region for an opaque type.\n     UnexpectedHiddenRegion {\n@@ -94,8 +70,8 @@ crate enum RegionErrorKind<'tcx> {\n     BoundUniversalRegionError {\n         /// The placeholder free region.\n         longer_fr: RegionVid,\n-        /// The region that erroneously must be outlived by `longer_fr`.\n-        error_region: RegionVid,\n+        /// The region element that erroneously must be outlived by `longer_fr`.\n+        error_element: RegionElement,\n         /// The origin of the placeholder region.\n         fr_origin: NLLRegionVariableOrigin,\n     },\n@@ -128,297 +104,161 @@ pub struct ErrorConstraintInfo {\n     pub(super) span: Span,\n }\n \n-impl<'tcx> RegionInferenceContext<'tcx> {\n+impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     /// Converts a region inference variable into a `ty::Region` that\n     /// we can use for error reporting. If `r` is universally bound,\n     /// then we use the name that we have on record for it. If `r` is\n     /// existentially bound, then we check its inferred value and try\n     /// to find a good name from that. Returns `None` if we can't find\n     /// one (e.g., this is just some random part of the CFG).\n-    pub fn to_error_region(&self, r: RegionVid) -> Option<ty::Region<'tcx>> {\n-        self.to_error_region_vid(r).and_then(|r| self.definitions[r].external_name)\n+    pub(super) fn to_error_region(&self, r: RegionVid) -> Option<ty::Region<'tcx>> {\n+        self.to_error_region_vid(r).and_then(|r| self.regioncx.region_definition(r).external_name)\n     }\n \n-    /// Returns the [RegionVid] corresponding to the region returned by\n+    /// Returns the `RegionVid` corresponding to the region returned by\n     /// `to_error_region`.\n-    pub fn to_error_region_vid(&self, r: RegionVid) -> Option<RegionVid> {\n-        if self.universal_regions.is_universal_region(r) {\n+    pub(super) fn to_error_region_vid(&self, r: RegionVid) -> Option<RegionVid> {\n+        if self.regioncx.universal_regions().is_universal_region(r) {\n             Some(r)\n         } else {\n-            let r_scc = self.constraint_sccs.scc(r);\n-            let upper_bound = self.universal_upper_bound(r);\n-            if self.scc_values.contains(r_scc, upper_bound) {\n+            let upper_bound = self.regioncx.universal_upper_bound(r);\n+\n+            if self.regioncx.upper_bound_in_region_scc(r, upper_bound) {\n                 self.to_error_region_vid(upper_bound)\n             } else {\n                 None\n             }\n         }\n     }\n \n-    /// Tries to find the best constraint to blame for the fact that\n-    /// `R: from_region`, where `R` is some region that meets\n-    /// `target_test`. This works by following the constraint graph,\n-    /// creating a constraint path that forces `R` to outlive\n-    /// `from_region`, and then finding the best choices within that\n-    /// path to blame.\n-    fn best_blame_constraint(\n-        &self,\n-        body: &Body<'tcx>,\n-        from_region: RegionVid,\n-        from_region_origin: NLLRegionVariableOrigin,\n-        target_test: impl Fn(RegionVid) -> bool,\n-    ) -> (ConstraintCategory, bool, Span) {\n-        debug!(\n-            \"best_blame_constraint(from_region={:?}, from_region_origin={:?})\",\n-            from_region, from_region_origin\n-        );\n-\n-        // Find all paths\n-        let (path, target_region) =\n-            self.find_constraint_paths_between_regions(from_region, target_test).unwrap();\n-        debug!(\n-            \"best_blame_constraint: path={:#?}\",\n-            path.iter()\n-                .map(|&c| format!(\n-                    \"{:?} ({:?}: {:?})\",\n-                    c,\n-                    self.constraint_sccs.scc(c.sup),\n-                    self.constraint_sccs.scc(c.sub),\n-                ))\n-                .collect::<Vec<_>>()\n-        );\n-\n-        // Classify each of the constraints along the path.\n-        let mut categorized_path: Vec<(ConstraintCategory, bool, Span)> = path\n-            .iter()\n-            .map(|constraint| {\n-                if constraint.category == ConstraintCategory::ClosureBounds {\n-                    self.retrieve_closure_constraint_info(body, &constraint)\n-                } else {\n-                    (constraint.category, false, constraint.locations.span(body))\n-                }\n-            })\n-            .collect();\n-        debug!(\"best_blame_constraint: categorized_path={:#?}\", categorized_path);\n-\n-        // To find the best span to cite, we first try to look for the\n-        // final constraint that is interesting and where the `sup` is\n-        // not unified with the ultimate target region. The reason\n-        // for this is that we have a chain of constraints that lead\n-        // from the source to the target region, something like:\n-        //\n-        //    '0: '1 ('0 is the source)\n-        //    '1: '2\n-        //    '2: '3\n-        //    '3: '4\n-        //    '4: '5\n-        //    '5: '6 ('6 is the target)\n-        //\n-        // Some of those regions are unified with `'6` (in the same\n-        // SCC).  We want to screen those out. After that point, the\n-        // \"closest\" constraint we have to the end is going to be the\n-        // most likely to be the point where the value escapes -- but\n-        // we still want to screen for an \"interesting\" point to\n-        // highlight (e.g., a call site or something).\n-        let target_scc = self.constraint_sccs.scc(target_region);\n-        let mut range = 0..path.len();\n-\n-        // As noted above, when reporting an error, there is typically a chain of constraints\n-        // leading from some \"source\" region which must outlive some \"target\" region.\n-        // In most cases, we prefer to \"blame\" the constraints closer to the target --\n-        // but there is one exception. When constraints arise from higher-ranked subtyping,\n-        // we generally prefer to blame the source value,\n-        // as the \"target\" in this case tends to be some type annotation that the user gave.\n-        // Therefore, if we find that the region origin is some instantiation\n-        // of a higher-ranked region, we start our search from the \"source\" point\n-        // rather than the \"target\", and we also tweak a few other things.\n-        //\n-        // An example might be this bit of Rust code:\n-        //\n-        // ```rust\n-        // let x: fn(&'static ()) = |_| {};\n-        // let y: for<'a> fn(&'a ()) = x;\n-        // ```\n-        //\n-        // In MIR, this will be converted into a combination of assignments and type ascriptions.\n-        // In particular, the 'static is imposed through a type ascription:\n-        //\n-        // ```rust\n-        // x = ...;\n-        // AscribeUserType(x, fn(&'static ())\n-        // y = x;\n-        // ```\n-        //\n-        // We wind up ultimately with constraints like\n-        //\n-        // ```rust\n-        // !a: 'temp1 // from the `y = x` statement\n-        // 'temp1: 'temp2\n-        // 'temp2: 'static // from the AscribeUserType\n-        // ```\n-        //\n-        // and here we prefer to blame the source (the y = x statement).\n-        let blame_source = match from_region_origin {\n-            NLLRegionVariableOrigin::FreeRegion\n-            | NLLRegionVariableOrigin::Existential { from_forall: false } => true,\n-            NLLRegionVariableOrigin::Placeholder(_)\n-            | NLLRegionVariableOrigin::Existential { from_forall: true } => false,\n-        };\n-\n-        let find_region = |i: &usize| {\n-            let constraint = path[*i];\n-\n-            let constraint_sup_scc = self.constraint_sccs.scc(constraint.sup);\n-\n-            if blame_source {\n-                match categorized_path[*i].0 {\n-                    ConstraintCategory::OpaqueType\n-                    | ConstraintCategory::Boring\n-                    | ConstraintCategory::BoringNoLocation\n-                    | ConstraintCategory::Internal => false,\n-                    ConstraintCategory::TypeAnnotation\n-                    | ConstraintCategory::Return\n-                    | ConstraintCategory::Yield => true,\n-                    _ => constraint_sup_scc != target_scc,\n-                }\n-            } else {\n-                match categorized_path[*i].0 {\n-                    ConstraintCategory::OpaqueType\n-                    | ConstraintCategory::Boring\n-                    | ConstraintCategory::BoringNoLocation\n-                    | ConstraintCategory::Internal => false,\n-                    _ => true,\n-                }\n-            }\n-        };\n-\n-        let best_choice =\n-            if blame_source { range.rev().find(find_region) } else { range.find(find_region) };\n-\n-        debug!(\n-            \"best_blame_constraint: best_choice={:?} blame_source={}\",\n-            best_choice, blame_source\n-        );\n-\n-        if let Some(i) = best_choice {\n-            if let Some(next) = categorized_path.get(i + 1) {\n-                if categorized_path[i].0 == ConstraintCategory::Return\n-                    && next.0 == ConstraintCategory::OpaqueType\n+    /// Returns `true` if a closure is inferred to be an `FnMut` closure.\n+    fn is_closure_fn_mut(&self, fr: RegionVid) -> bool {\n+        if let Some(ty::ReFree(free_region)) = self.to_error_region(fr) {\n+            if let ty::BoundRegion::BrEnv = free_region.bound_region {\n+                if let DefiningTy::Closure(def_id, substs) =\n+                    self.regioncx.universal_regions().defining_ty\n                 {\n-                    // The return expression is being influenced by the return type being\n-                    // impl Trait, point at the return type and not the return expr.\n-                    return *next;\n+                    return substs.as_closure().kind(def_id, self.infcx.tcx)\n+                        == ty::ClosureKind::FnMut;\n                 }\n             }\n-            return categorized_path[i];\n         }\n \n-        // If that search fails, that is.. unusual. Maybe everything\n-        // is in the same SCC or something. In that case, find what\n-        // appears to be the most interesting point to report to the\n-        // user via an even more ad-hoc guess.\n-        categorized_path.sort_by(|p0, p1| p0.0.cmp(&p1.0));\n-        debug!(\"`: sorted_path={:#?}\", categorized_path);\n-\n-        *categorized_path.first().unwrap()\n+        false\n     }\n \n-    /// Walks the graph of constraints (where `'a: 'b` is considered\n-    /// an edge `'a -> 'b`) to find all paths from `from_region` to\n-    /// `to_region`. The paths are accumulated into the vector\n-    /// `results`. The paths are stored as a series of\n-    /// `ConstraintIndex` values -- in other words, a list of *edges*.\n-    ///\n-    /// Returns: a series of constraints as well as the region `R`\n-    /// that passed the target test.\n-    fn find_constraint_paths_between_regions(\n-        &self,\n-        from_region: RegionVid,\n-        target_test: impl Fn(RegionVid) -> bool,\n-    ) -> Option<(Vec<OutlivesConstraint>, RegionVid)> {\n-        let mut context = IndexVec::from_elem(Trace::NotVisited, &self.definitions);\n-        context[from_region] = Trace::StartRegion;\n-\n-        // Use a deque so that we do a breadth-first search. We will\n-        // stop at the first match, which ought to be the shortest\n-        // path (fewest constraints).\n-        let mut deque = VecDeque::new();\n-        deque.push_back(from_region);\n-\n-        while let Some(r) = deque.pop_front() {\n-            debug!(\n-                \"find_constraint_paths_between_regions: from_region={:?} r={:?} value={}\",\n-                from_region,\n-                r,\n-                self.region_value_str(r),\n-            );\n-\n-            // Check if we reached the region we were looking for. If so,\n-            // we can reconstruct the path that led to it and return it.\n-            if target_test(r) {\n-                let mut result = vec![];\n-                let mut p = r;\n-                loop {\n-                    match context[p] {\n-                        Trace::NotVisited => {\n-                            bug!(\"found unvisited region {:?} on path to {:?}\", p, r)\n-                        }\n-\n-                        Trace::FromOutlivesConstraint(c) => {\n-                            result.push(c);\n-                            p = c.sup;\n-                        }\n-\n-                        Trace::StartRegion => {\n-                            result.reverse();\n-                            return Some((result, r));\n-                        }\n+    /// Produces nice borrowck error diagnostics for all the errors collected in `nll_errors`.\n+    pub(in crate::borrow_check) fn report_region_errors(&mut self, nll_errors: RegionErrors<'tcx>) {\n+        // Iterate through all the errors, producing a diagnostic for each one. The diagnostics are\n+        // buffered in the `MirBorrowckCtxt`.\n+\n+        let mut outlives_suggestion = OutlivesSuggestionBuilder::default();\n+\n+        for nll_error in nll_errors.into_iter() {\n+            match nll_error {\n+                RegionErrorKind::TypeTestError { type_test } => {\n+                    // Try to convert the lower-bound region into something named we can print for the user.\n+                    let lower_bound_region = self.to_error_region(type_test.lower_bound);\n+\n+                    let type_test_span = type_test.locations.span(&self.body);\n+\n+                    if let Some(lower_bound_region) = lower_bound_region {\n+                        let region_scope_tree = &self.infcx.tcx.region_scope_tree(self.mir_def_id);\n+                        self.infcx\n+                            .construct_generic_bound_failure(\n+                                region_scope_tree,\n+                                type_test_span,\n+                                None,\n+                                type_test.generic_kind,\n+                                lower_bound_region,\n+                            )\n+                            .buffer(&mut self.errors_buffer);\n+                    } else {\n+                        // FIXME. We should handle this case better. It\n+                        // indicates that we have e.g., some region variable\n+                        // whose value is like `'a+'b` where `'a` and `'b` are\n+                        // distinct unrelated univesal regions that are not\n+                        // known to outlive one another. It'd be nice to have\n+                        // some examples where this arises to decide how best\n+                        // to report it; we could probably handle it by\n+                        // iterating over the universal regions and reporting\n+                        // an error that multiple bounds are required.\n+                        self.infcx\n+                            .tcx\n+                            .sess\n+                            .struct_span_err(\n+                                type_test_span,\n+                                &format!(\"`{}` does not live long enough\", type_test.generic_kind),\n+                            )\n+                            .buffer(&mut self.errors_buffer);\n                     }\n                 }\n-            }\n \n-            // Otherwise, walk over the outgoing constraints and\n-            // enqueue any regions we find, keeping track of how we\n-            // reached them.\n-\n-            // A constraint like `'r: 'x` can come from our constraint\n-            // graph.\n-            let fr_static = self.universal_regions.fr_static;\n-            let outgoing_edges_from_graph =\n-                self.constraint_graph.outgoing_edges(r, &self.constraints, fr_static);\n-\n-            // Always inline this closure because it can be hot.\n-            let mut handle_constraint = #[inline(always)]\n-            |constraint: OutlivesConstraint| {\n-                debug_assert_eq!(constraint.sup, r);\n-                let sub_region = constraint.sub;\n-                if let Trace::NotVisited = context[sub_region] {\n-                    context[sub_region] = Trace::FromOutlivesConstraint(constraint);\n-                    deque.push_back(sub_region);\n+                RegionErrorKind::UnexpectedHiddenRegion {\n+                    opaque_type_def_id,\n+                    hidden_ty,\n+                    member_region,\n+                } => {\n+                    let region_scope_tree = &self.infcx.tcx.region_scope_tree(self.mir_def_id);\n+                    opaque_types::unexpected_hidden_region_diagnostic(\n+                        self.infcx.tcx,\n+                        Some(region_scope_tree),\n+                        opaque_type_def_id,\n+                        hidden_ty,\n+                        member_region,\n+                    )\n+                    .buffer(&mut self.errors_buffer);\n                 }\n-            };\n \n-            // This loop can be hot.\n-            for constraint in outgoing_edges_from_graph {\n-                handle_constraint(constraint);\n-            }\n+                RegionErrorKind::BoundUniversalRegionError {\n+                    longer_fr,\n+                    fr_origin,\n+                    error_element,\n+                } => {\n+                    let error_region = self.regioncx.region_from_element(longer_fr, error_element);\n+\n+                    // Find the code to blame for the fact that `longer_fr` outlives `error_fr`.\n+                    let (_, span) = self.regioncx.find_outlives_blame_span(\n+                        &self.body,\n+                        longer_fr,\n+                        fr_origin,\n+                        error_region,\n+                    );\n+\n+                    // FIXME: improve this error message\n+                    self.infcx\n+                        .tcx\n+                        .sess\n+                        .struct_span_err(span, \"higher-ranked subtype error\")\n+                        .buffer(&mut self.errors_buffer);\n+                }\n \n-            // Member constraints can also give rise to `'r: 'x` edges that\n-            // were not part of the graph initially, so watch out for those.\n-            // (But they are extremely rare; this loop is very cold.)\n-            for constraint in self.applied_member_constraints(r) {\n-                let p_c = &self.member_constraints[constraint.member_constraint_index];\n-                let constraint = OutlivesConstraint {\n-                    sup: r,\n-                    sub: constraint.min_choice,\n-                    locations: Locations::All(p_c.definition_span),\n-                    category: ConstraintCategory::OpaqueType,\n-                };\n-                handle_constraint(constraint);\n+                RegionErrorKind::RegionError { fr_origin, longer_fr, shorter_fr, is_reported } => {\n+                    if is_reported {\n+                        self.report_region_error(\n+                            longer_fr,\n+                            fr_origin,\n+                            shorter_fr,\n+                            &mut outlives_suggestion,\n+                        );\n+                    } else {\n+                        // We only report the first error, so as not to overwhelm the user. See\n+                        // `RegRegionErrorKind` docs.\n+                        //\n+                        // FIXME: currently we do nothing with these, but perhaps we can do better?\n+                        // FIXME: try collecting these constraints on the outlives suggestion\n+                        // builder. Does it make the suggestions any better?\n+                        debug!(\n+                            \"Unreported region error: can't prove that {:?}: {:?}\",\n+                            longer_fr, shorter_fr\n+                        );\n+                    }\n+                }\n             }\n         }\n \n-        None\n+        // Emit one outlives suggestions for each MIR def we borrowck\n+        outlives_suggestion.add_suggestion(self);\n     }\n \n     /// Report an error because the universal region `fr` was required to outlive\n@@ -429,38 +269,38 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     ///\n     /// Here we would be invoked with `fr = 'a` and `outlived_fr = `'b`.\n-    pub(in crate::borrow_check) fn report_error<'a>(\n-        &'a self,\n-        mbcx: &MirBorrowckCtxt<'a, 'tcx>,\n+    pub(in crate::borrow_check) fn report_region_error(\n+        &mut self,\n         fr: RegionVid,\n         fr_origin: NLLRegionVariableOrigin,\n         outlived_fr: RegionVid,\n         outlives_suggestion: &mut OutlivesSuggestionBuilder,\n-        renctx: &mut RegionErrorNamingCtx,\n-    ) -> DiagnosticBuilder<'a> {\n-        debug!(\"report_error(fr={:?}, outlived_fr={:?})\", fr, outlived_fr);\n+    ) {\n+        debug!(\"report_region_error(fr={:?}, outlived_fr={:?})\", fr, outlived_fr);\n \n-        let (category, _, span) = self.best_blame_constraint(&mbcx.body, fr, fr_origin, |r| {\n-            self.provides_universal_region(r, fr, outlived_fr)\n-        });\n+        let (category, _, span) =\n+            self.regioncx.best_blame_constraint(&self.body, fr, fr_origin, |r| {\n+                self.regioncx.provides_universal_region(r, fr, outlived_fr)\n+            });\n \n-        debug!(\"report_error: category={:?} {:?}\", category, span);\n+        debug!(\"report_region_error: category={:?} {:?}\", category, span);\n         // Check if we can use one of the \"nice region errors\".\n         if let (Some(f), Some(o)) = (self.to_error_region(fr), self.to_error_region(outlived_fr)) {\n-            let tables = mbcx.infcx.tcx.typeck_tables_of(mbcx.mir_def_id);\n-            let nice = NiceRegionError::new_from_span(mbcx.infcx, span, o, f, Some(tables));\n+            let tables = self.infcx.tcx.typeck_tables_of(self.mir_def_id);\n+            let nice = NiceRegionError::new_from_span(self.infcx, span, o, f, Some(tables));\n             if let Some(diag) = nice.try_report_from_nll() {\n-                return diag;\n+                diag.buffer(&mut self.errors_buffer);\n+                return;\n             }\n         }\n \n         let (fr_is_local, outlived_fr_is_local): (bool, bool) = (\n-            self.universal_regions.is_local_free_region(fr),\n-            self.universal_regions.is_local_free_region(outlived_fr),\n+            self.regioncx.universal_regions().is_local_free_region(fr),\n+            self.regioncx.universal_regions().is_local_free_region(outlived_fr),\n         );\n \n         debug!(\n-            \"report_error: fr_is_local={:?} outlived_fr_is_local={:?} category={:?}\",\n+            \"report_region_error: fr_is_local={:?} outlived_fr_is_local={:?} category={:?}\",\n             fr_is_local, outlived_fr_is_local, category\n         );\n \n@@ -473,52 +313,30 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             span,\n         };\n \n-        match (category, fr_is_local, outlived_fr_is_local) {\n-            (ConstraintCategory::Return, true, false) if self.is_closure_fn_mut(mbcx.infcx, fr) => {\n-                self.report_fnmut_error(mbcx, &errci, renctx)\n+        let diag = match (category, fr_is_local, outlived_fr_is_local) {\n+            (ConstraintCategory::Return, true, false) if self.is_closure_fn_mut(fr) => {\n+                self.report_fnmut_error(&errci)\n             }\n             (ConstraintCategory::Assignment, true, false)\n             | (ConstraintCategory::CallArgument, true, false) => {\n-                let mut db = self.report_escaping_data_error(mbcx, &errci, renctx);\n+                let mut db = self.report_escaping_data_error(&errci);\n \n-                outlives_suggestion.intermediate_suggestion(mbcx, &errci, renctx, &mut db);\n+                outlives_suggestion.intermediate_suggestion(self, &errci, &mut db);\n                 outlives_suggestion.collect_constraint(fr, outlived_fr);\n \n                 db\n             }\n             _ => {\n-                let mut db = self.report_general_error(mbcx, &errci, renctx);\n+                let mut db = self.report_general_error(&errci);\n \n-                outlives_suggestion.intermediate_suggestion(mbcx, &errci, renctx, &mut db);\n+                outlives_suggestion.intermediate_suggestion(self, &errci, &mut db);\n                 outlives_suggestion.collect_constraint(fr, outlived_fr);\n \n                 db\n             }\n-        }\n-    }\n-\n-    /// We have a constraint `fr1: fr2` that is not satisfied, where\n-    /// `fr2` represents some universal region. Here, `r` is some\n-    /// region where we know that `fr1: r` and this function has the\n-    /// job of determining whether `r` is \"to blame\" for the fact that\n-    /// `fr1: fr2` is required.\n-    ///\n-    /// This is true under two conditions:\n-    ///\n-    /// - `r == fr2`\n-    /// - `fr2` is `'static` and `r` is some placeholder in a universe\n-    ///   that cannot be named by `fr1`; in that case, we will require\n-    ///   that `fr1: 'static` because it is the only way to `fr1: r` to\n-    ///   be satisfied. (See `add_incompatible_universe`.)\n-    fn provides_universal_region(&self, r: RegionVid, fr1: RegionVid, fr2: RegionVid) -> bool {\n-        debug!(\"provides_universal_region(r={:?}, fr1={:?}, fr2={:?})\", r, fr1, fr2);\n-        let result = {\n-            r == fr2 || {\n-                fr2 == self.universal_regions.fr_static && self.cannot_name_placeholder(fr1, r)\n-            }\n         };\n-        debug!(\"provides_universal_region: result = {:?}\", result);\n-        result\n+\n+        diag.buffer(&mut self.errors_buffer);\n     }\n \n     /// Report a specialized error when `FnMut` closures return a reference to a captured variable.\n@@ -537,23 +355,19 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ///            executing...\n     ///    = note: ...therefore, returned references to captured variables will escape the closure\n     /// ```\n-    fn report_fnmut_error(\n-        &self,\n-        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n-        errci: &ErrorConstraintInfo,\n-        renctx: &mut RegionErrorNamingCtx,\n-    ) -> DiagnosticBuilder<'_> {\n+    fn report_fnmut_error(&self, errci: &ErrorConstraintInfo) -> DiagnosticBuilder<'tcx> {\n         let ErrorConstraintInfo { outlived_fr, span, .. } = errci;\n \n-        let mut diag = mbcx\n+        let mut diag = self\n             .infcx\n             .tcx\n             .sess\n             .struct_span_err(*span, \"captured variable cannot escape `FnMut` closure body\");\n \n         // We should check if the return type of this closure is in fact a closure - in that\n         // case, we can special case the error further.\n-        let return_type_is_closure = self.universal_regions.unnormalized_output_ty.is_closure();\n+        let return_type_is_closure =\n+            self.regioncx.universal_regions().unnormalized_output_ty.is_closure();\n         let message = if return_type_is_closure {\n             \"returns a closure that contains a reference to a captured variable, which then \\\n              escapes the closure body\"\n@@ -563,7 +377,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         diag.span_label(*span, message);\n \n-        match self.give_region_a_name(mbcx, renctx, *outlived_fr).unwrap().source {\n+        match self.give_region_a_name(*outlived_fr).unwrap().source {\n             RegionNameSource::NamedEarlyBoundRegion(fr_span)\n             | RegionNameSource::NamedFreeRegion(fr_span)\n             | RegionNameSource::SynthesizedFreeEnvRegion(fr_span, _)\n@@ -598,30 +412,25 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// LL |     ref_obj(x)\n     ///    |     ^^^^^^^^^^ `x` escapes the function body here\n     /// ```\n-    fn report_escaping_data_error(\n-        &self,\n-        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n-        errci: &ErrorConstraintInfo,\n-        renctx: &mut RegionErrorNamingCtx,\n-    ) -> DiagnosticBuilder<'_> {\n+    fn report_escaping_data_error(&self, errci: &ErrorConstraintInfo) -> DiagnosticBuilder<'tcx> {\n         let ErrorConstraintInfo { span, category, .. } = errci;\n \n-        let fr_name_and_span = self.get_var_name_and_span_for_region(\n-            mbcx.infcx.tcx,\n-            &mbcx.body,\n-            &mbcx.local_names,\n-            &mbcx.upvars,\n+        let fr_name_and_span = self.regioncx.get_var_name_and_span_for_region(\n+            self.infcx.tcx,\n+            &self.body,\n+            &self.local_names,\n+            &self.upvars,\n             errci.fr,\n         );\n-        let outlived_fr_name_and_span = self.get_var_name_and_span_for_region(\n-            mbcx.infcx.tcx,\n-            &mbcx.body,\n-            &mbcx.local_names,\n-            &mbcx.upvars,\n+        let outlived_fr_name_and_span = self.regioncx.get_var_name_and_span_for_region(\n+            self.infcx.tcx,\n+            &self.body,\n+            &self.local_names,\n+            &self.upvars,\n             errci.outlived_fr,\n         );\n \n-        let escapes_from = match self.universal_regions.defining_ty {\n+        let escapes_from = match self.regioncx.universal_regions().defining_ty {\n             DefiningTy::Closure(..) => \"closure\",\n             DefiningTy::Generator(..) => \"generator\",\n             DefiningTy::FnDef(..) => \"function\",\n@@ -634,15 +443,15 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             || (*category == ConstraintCategory::Assignment && escapes_from == \"function\")\n             || escapes_from == \"const\"\n         {\n-            return self.report_general_error(\n-                mbcx,\n-                &ErrorConstraintInfo { fr_is_local: true, outlived_fr_is_local: false, ..*errci },\n-                renctx,\n-            );\n+            return self.report_general_error(&ErrorConstraintInfo {\n+                fr_is_local: true,\n+                outlived_fr_is_local: false,\n+                ..*errci\n+            });\n         }\n \n         let mut diag =\n-            borrowck_errors::borrowed_data_escapes_closure(mbcx.infcx.tcx, *span, escapes_from);\n+            borrowck_errors::borrowed_data_escapes_closure(self.infcx.tcx, *span, escapes_from);\n \n         if let Some((Some(outlived_fr_name), outlived_fr_span)) = outlived_fr_name_and_span {\n             diag.span_label(\n@@ -684,12 +493,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ///    |     ^^^^^^^^^^^^^^ function was supposed to return data with lifetime `'a` but it\n     ///    |                    is returning data with lifetime `'b`\n     /// ```\n-    fn report_general_error(\n-        &self,\n-        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n-        errci: &ErrorConstraintInfo,\n-        renctx: &mut RegionErrorNamingCtx,\n-    ) -> DiagnosticBuilder<'_> {\n+    fn report_general_error(&self, errci: &ErrorConstraintInfo) -> DiagnosticBuilder<'tcx> {\n         let ErrorConstraintInfo {\n             fr,\n             fr_is_local,\n@@ -701,14 +505,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         } = errci;\n \n         let mut diag =\n-            mbcx.infcx.tcx.sess.struct_span_err(*span, \"lifetime may not live long enough\");\n+            self.infcx.tcx.sess.struct_span_err(*span, \"lifetime may not live long enough\");\n \n         let mir_def_name =\n-            if mbcx.infcx.tcx.is_closure(mbcx.mir_def_id) { \"closure\" } else { \"function\" };\n+            if self.infcx.tcx.is_closure(self.mir_def_id) { \"closure\" } else { \"function\" };\n \n-        let fr_name = self.give_region_a_name(mbcx, renctx, *fr).unwrap();\n+        let fr_name = self.give_region_a_name(*fr).unwrap();\n         fr_name.highlight_region_name(&mut diag);\n-        let outlived_fr_name = self.give_region_a_name(mbcx, renctx, *outlived_fr).unwrap();\n+        let outlived_fr_name = self.give_region_a_name(*outlived_fr).unwrap();\n         outlived_fr_name.highlight_region_name(&mut diag);\n \n         match (category, outlived_fr_is_local, fr_is_local) {\n@@ -735,7 +539,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n         }\n \n-        self.add_static_impl_trait_suggestion(mbcx.infcx, &mut diag, *fr, fr_name, *outlived_fr);\n+        self.add_static_impl_trait_suggestion(&mut diag, *fr, fr_name, *outlived_fr);\n \n         diag\n     }\n@@ -751,8 +555,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     fn add_static_impl_trait_suggestion(\n         &self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n-        diag: &mut DiagnosticBuilder<'_>,\n+        diag: &mut DiagnosticBuilder<'tcx>,\n         fr: RegionVid,\n         // We need to pass `fr_name` - computing it again will label it twice.\n         fr_name: RegionName,\n@@ -761,20 +564,21 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         if let (Some(f), Some(ty::RegionKind::ReStatic)) =\n             (self.to_error_region(fr), self.to_error_region(outlived_fr))\n         {\n-            if let Some((ty::TyS { kind: ty::Opaque(did, substs), .. }, _)) = infcx\n+            if let Some((ty::TyS { kind: ty::Opaque(did, substs), .. }, _)) = self\n+                .infcx\n                 .tcx\n                 .is_suitable_region(f)\n                 .map(|r| r.def_id)\n-                .map(|id| infcx.tcx.return_type_impl_trait(id))\n+                .map(|id| self.infcx.tcx.return_type_impl_trait(id))\n                 .unwrap_or(None)\n             {\n                 // Check whether or not the impl trait return type is intended to capture\n                 // data with the static lifetime.\n                 //\n                 // eg. check for `impl Trait + 'static` instead of `impl Trait`.\n                 let has_static_predicate = {\n-                    let predicates_of = infcx.tcx.predicates_of(*did);\n-                    let bounds = predicates_of.instantiate(infcx.tcx, substs);\n+                    let predicates_of = self.infcx.tcx.predicates_of(*did);\n+                    let bounds = predicates_of.instantiate(self.infcx.tcx, substs);\n \n                     let mut found = false;\n                     for predicate in bounds.predicates {\n@@ -802,8 +606,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     diag.help(&format!(\"consider replacing `{}` with `{}`\", fr_name, static_str));\n                 } else {\n                     // Otherwise, we should suggest adding a constraint on the return type.\n-                    let span = infcx.tcx.def_span(*did);\n-                    if let Ok(snippet) = infcx.tcx.sess.source_map().span_to_snippet(span) {\n+                    let span = self.infcx.tcx.def_span(*did);\n+                    if let Ok(snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(span) {\n                         let suggestable_fr_name = if fr_name.was_named() {\n                             fr_name.to_string()\n                         } else {\n@@ -830,130 +634,4 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n         }\n     }\n-\n-    crate fn free_region_constraint_info(\n-        &self,\n-        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n-        borrow_region: RegionVid,\n-        outlived_region: RegionVid,\n-    ) -> (ConstraintCategory, bool, Span, Option<RegionName>) {\n-        let (category, from_closure, span) = self.best_blame_constraint(\n-            &mbcx.body,\n-            borrow_region,\n-            NLLRegionVariableOrigin::FreeRegion,\n-            |r| self.provides_universal_region(r, borrow_region, outlived_region),\n-        );\n-\n-        let mut renctx = RegionErrorNamingCtx::new();\n-        let outlived_fr_name = self.give_region_a_name(mbcx, &mut renctx, outlived_region);\n-\n-        (category, from_closure, span, outlived_fr_name)\n-    }\n-\n-    // Finds some region R such that `fr1: R` and `R` is live at\n-    // `elem`.\n-    crate fn find_sub_region_live_at(&self, fr1: RegionVid, elem: Location) -> RegionVid {\n-        debug!(\"find_sub_region_live_at(fr1={:?}, elem={:?})\", fr1, elem);\n-        self.find_constraint_paths_between_regions(fr1, |r| {\n-            // First look for some `r` such that `fr1: r` and `r` is live at `elem`\n-            debug!(\n-                \"find_sub_region_live_at: liveness_constraints for {:?} are {:?}\",\n-                r,\n-                self.liveness_constraints.region_value_str(r),\n-            );\n-            self.liveness_constraints.contains(r, elem)\n-        })\n-        .or_else(|| {\n-            // If we fail to find that, we may find some `r` such that\n-            // `fr1: r` and `r` is a placeholder from some universe\n-            // `fr1` cannot name. This would force `fr1` to be\n-            // `'static`.\n-            self.find_constraint_paths_between_regions(fr1, |r| {\n-                self.cannot_name_placeholder(fr1, r)\n-            })\n-        })\n-        .or_else(|| {\n-            // If we fail to find THAT, it may be that `fr1` is a\n-            // placeholder that cannot \"fit\" into its SCC. In that\n-            // case, there should be some `r` where `fr1: r`, both\n-            // `fr1` and `r` are in the same SCC, and `fr1` is a\n-            // placeholder that `r` cannot name. We can blame that\n-            // edge.\n-            self.find_constraint_paths_between_regions(fr1, |r| {\n-                self.constraint_sccs.scc(fr1) == self.constraint_sccs.scc(r)\n-                    && self.cannot_name_placeholder(r, fr1)\n-            })\n-        })\n-        .map(|(_path, r)| r)\n-        .unwrap()\n-    }\n-\n-    // Finds a good span to blame for the fact that `fr1` outlives `fr2`.\n-    crate fn find_outlives_blame_span(\n-        &self,\n-        body: &Body<'tcx>,\n-        fr1: RegionVid,\n-        fr1_origin: NLLRegionVariableOrigin,\n-        fr2: RegionVid,\n-    ) -> (ConstraintCategory, Span) {\n-        let (category, _, span) = self.best_blame_constraint(body, fr1, fr1_origin, |r| {\n-            self.provides_universal_region(r, fr1, fr2)\n-        });\n-        (category, span)\n-    }\n-\n-    fn retrieve_closure_constraint_info(\n-        &self,\n-        body: &Body<'tcx>,\n-        constraint: &OutlivesConstraint,\n-    ) -> (ConstraintCategory, bool, Span) {\n-        let loc = match constraint.locations {\n-            Locations::All(span) => return (constraint.category, false, span),\n-            Locations::Single(loc) => loc,\n-        };\n-\n-        let opt_span_category =\n-            self.closure_bounds_mapping[&loc].get(&(constraint.sup, constraint.sub));\n-        opt_span_category.map(|&(category, span)| (category, true, span)).unwrap_or((\n-            constraint.category,\n-            false,\n-            body.source_info(loc).span,\n-        ))\n-    }\n-\n-    /// Returns `true` if a closure is inferred to be an `FnMut` closure.\n-    crate fn is_closure_fn_mut(&self, infcx: &InferCtxt<'_, 'tcx>, fr: RegionVid) -> bool {\n-        if let Some(ty::ReFree(free_region)) = self.to_error_region(fr) {\n-            if let ty::BoundRegion::BrEnv = free_region.bound_region {\n-                if let DefiningTy::Closure(def_id, substs) = self.universal_regions.defining_ty {\n-                    let closure_kind_ty = substs.as_closure().kind_ty(def_id, infcx.tcx);\n-                    return Some(ty::ClosureKind::FnMut) == closure_kind_ty.to_opt_closure_kind();\n-                }\n-            }\n-        }\n-\n-        false\n-    }\n-\n-    /// If `r2` represents a placeholder region, then this returns\n-    /// `true` if `r1` cannot name that placeholder in its\n-    /// value; otherwise, returns `false`.\n-    fn cannot_name_placeholder(&self, r1: RegionVid, r2: RegionVid) -> bool {\n-        debug!(\"cannot_name_value_of(r1={:?}, r2={:?})\", r1, r2);\n-\n-        match self.definitions[r2].origin {\n-            NLLRegionVariableOrigin::Placeholder(placeholder) => {\n-                let universe1 = self.definitions[r1].universe;\n-                debug!(\n-                    \"cannot_name_value_of: universe1={:?} placeholder={:?}\",\n-                    universe1, placeholder\n-                );\n-                universe1.cannot_name(placeholder.universe)\n-            }\n-\n-            NLLRegionVariableOrigin::FreeRegion | NLLRegionVariableOrigin::Existential { .. } => {\n-                false\n-            }\n-        }\n-    }\n }"}, {"sha": "47eb2d8940af402c9c0959fffb678e70d902167a", "filename": "src/librustc_mir/borrow_check/diagnostics/region_name.rs", "status": "modified", "additions": 81, "deletions": 148, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -2,18 +2,14 @@ use std::fmt::{self, Display};\n \n use rustc::ty::print::RegionHighlightMode;\n use rustc::ty::subst::{GenericArgKind, SubstsRef};\n-use rustc::ty::{self, RegionVid, Ty, TyCtxt};\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc::ty::{self, RegionVid, Ty};\n use rustc_errors::DiagnosticBuilder;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_span::symbol::kw;\n use rustc_span::{symbol::Symbol, Span, DUMMY_SP};\n \n-use crate::borrow_check::{\n-    nll::ToRegionVid, region_infer::RegionInferenceContext, universal_regions::DefiningTy,\n-    MirBorrowckCtxt,\n-};\n+use crate::borrow_check::{nll::ToRegionVid, universal_regions::DefiningTy, MirBorrowckCtxt};\n \n /// A name for a particular region used in emitting diagnostics. This name could be a generated\n /// name like `'1`, a name used by the user like `'a`, or a name like `'static`.\n@@ -55,46 +51,6 @@ crate enum RegionNameSource {\n     AnonRegionFromAsyncFn(Span),\n }\n \n-/// Records region names that have been assigned before so that we can use the same ones in later\n-/// diagnostics.\n-#[derive(Debug, Clone)]\n-crate struct RegionErrorNamingCtx {\n-    /// Record the region names generated for each region in the given\n-    /// MIR def so that we can reuse them later in help/error messages.\n-    renctx: FxHashMap<RegionVid, RegionName>,\n-\n-    /// The counter for generating new region names.\n-    counter: usize,\n-}\n-\n-impl RegionErrorNamingCtx {\n-    crate fn new() -> Self {\n-        Self { counter: 1, renctx: FxHashMap::default() }\n-    }\n-\n-    /// Get the name of `region` if it has previously been named.\n-    crate fn get(&self, region: &RegionVid) -> Option<&RegionName> {\n-        self.renctx.get(region)\n-    }\n-\n-    /// Give `region` the name `name`.\n-    crate fn insert(&mut self, region: RegionVid, name: RegionName) {\n-        self.renctx.insert(region, name);\n-    }\n-\n-    /// Creates a synthetic region named `'N`, where `N` is the next value of the counter. Then,\n-    /// increment the counter.\n-    ///\n-    /// The name is not memoized. A separate call to `insert` should be made later. (Currently,\n-    /// this happens at the end of `give_region_a_name`).\n-    crate fn synthesize_region_name(&mut self) -> Symbol {\n-        let c = self.counter;\n-        self.counter += 1;\n-\n-        Symbol::intern(&format!(\"'{:?}\", c))\n-    }\n-}\n-\n impl RegionName {\n     crate fn was_named(&self) -> bool {\n         match self.source {\n@@ -161,7 +117,16 @@ impl Display for RegionName {\n     }\n }\n \n-impl<'tcx> RegionInferenceContext<'tcx> {\n+impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n+    /// Generate a synthetic region named `'N`, where `N` is the next value of the counter. Then,\n+    /// increment the counter.\n+    ///\n+    /// This is _not_ idempotent. Call `give_region_a_name` when possible.\n+    fn synthesize_region_name(&self) -> Symbol {\n+        let c = self.next_region_name.replace_with(|counter| *counter + 1);\n+        Symbol::intern(&format!(\"'{:?}\", c))\n+    }\n+\n     /// Maps from an internal MIR region vid to something that we can\n     /// report to the user. In some cases, the region vids will map\n     /// directly to lifetimes that the user has a name for (e.g.,\n@@ -170,6 +135,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// that end, this function takes a \"diagnostic\" so that it can\n     /// create auxiliary notes as needed.\n     ///\n+    /// The names are memoized, so this is both cheap to recompute and idempotent.\n+    ///\n     /// Example (function arguments):\n     ///\n     /// Suppose we are trying to give a name to the lifetime of the\n@@ -187,29 +154,28 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     ///\n     /// and then return the name `'1` for us to use.\n-    crate fn give_region_a_name(\n-        &self,\n-        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n-        renctx: &mut RegionErrorNamingCtx,\n-        fr: RegionVid,\n-    ) -> Option<RegionName> {\n-        debug!(\"give_region_a_name(fr={:?}, counter={:?})\", fr, renctx.counter);\n+    crate fn give_region_a_name(&self, fr: RegionVid) -> Option<RegionName> {\n+        debug!(\n+            \"give_region_a_name(fr={:?}, counter={:?})\",\n+            fr,\n+            self.next_region_name.try_borrow().unwrap()\n+        );\n \n-        assert!(self.universal_regions.is_universal_region(fr));\n+        assert!(self.regioncx.universal_regions().is_universal_region(fr));\n \n-        if let Some(value) = renctx.get(&fr) {\n+        if let Some(value) = self.region_names.try_borrow_mut().unwrap().get(&fr) {\n             return Some(value.clone());\n         }\n \n         let value = self\n-            .give_name_from_error_region(mbcx, fr, renctx)\n-            .or_else(|| self.give_name_if_anonymous_region_appears_in_arguments(mbcx, fr, renctx))\n-            .or_else(|| self.give_name_if_anonymous_region_appears_in_upvars(mbcx, fr, renctx))\n-            .or_else(|| self.give_name_if_anonymous_region_appears_in_output(mbcx, fr, renctx))\n-            .or_else(|| self.give_name_if_anonymous_region_appears_in_yield_ty(mbcx, fr, renctx));\n+            .give_name_from_error_region(fr)\n+            .or_else(|| self.give_name_if_anonymous_region_appears_in_arguments(fr))\n+            .or_else(|| self.give_name_if_anonymous_region_appears_in_upvars(fr))\n+            .or_else(|| self.give_name_if_anonymous_region_appears_in_output(fr))\n+            .or_else(|| self.give_name_if_anonymous_region_appears_in_yield_ty(fr));\n \n         if let Some(ref value) = value {\n-            renctx.insert(fr, value.clone());\n+            self.region_names.try_borrow_mut().unwrap().insert(fr, value.clone());\n         }\n \n         debug!(\"give_region_a_name: gave name {:?}\", value);\n@@ -220,15 +186,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// *user* has a name for. In that case, we'll be able to map\n     /// `fr` to a `Region<'tcx>`, and that region will be one of\n     /// named variants.\n-    fn give_name_from_error_region(\n-        &self,\n-        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n-        fr: RegionVid,\n-        renctx: &mut RegionErrorNamingCtx,\n-    ) -> Option<RegionName> {\n+    fn give_name_from_error_region(&self, fr: RegionVid) -> Option<RegionName> {\n         let error_region = self.to_error_region(fr)?;\n \n-        let tcx = mbcx.infcx.tcx;\n+        let tcx = self.infcx.tcx;\n \n         debug!(\"give_region_a_name: error_region = {:?}\", error_region);\n         match error_region {\n@@ -267,7 +228,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         // happen if we have an elided name in an async fn for example: the\n                         // compiler will generate a region named `'_`, but reporting such a name is\n                         // not actually useful, so we synthesize a name for it instead.\n-                        let name = renctx.synthesize_region_name();\n+                        let name = self.synthesize_region_name();\n                         Some(RegionName {\n                             name,\n                             source: RegionNameSource::AnonRegionFromAsyncFn(span),\n@@ -276,13 +237,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 }\n \n                 ty::BoundRegion::BrEnv => {\n-                    let mir_hir_id = mbcx\n+                    let mir_hir_id = self\n                         .infcx\n                         .tcx\n                         .hir()\n-                        .as_local_hir_id(mbcx.mir_def_id)\n+                        .as_local_hir_id(self.mir_def_id)\n                         .expect(\"non-local mir\");\n-                    let def_ty = self.universal_regions.defining_ty;\n+                    let def_ty = self.regioncx.universal_regions().defining_ty;\n \n                     if let DefiningTy::Closure(def_id, substs) = def_ty {\n                         let args_span = if let hir::ExprKind::Closure(_, _, _, span, _) =\n@@ -292,7 +253,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         } else {\n                             bug!(\"Closure is not defined by a closure expr\");\n                         };\n-                        let region_name = renctx.synthesize_region_name();\n+                        let region_name = self.synthesize_region_name();\n \n                         let closure_kind_ty = substs.as_closure().kind_ty(def_id, tcx);\n                         let note = match closure_kind_ty.to_opt_closure_kind() {\n@@ -346,38 +307,30 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     fn give_name_if_anonymous_region_appears_in_arguments(\n         &self,\n-        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n         fr: RegionVid,\n-        renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n-        let implicit_inputs = self.universal_regions.defining_ty.implicit_inputs();\n-        let argument_index = self.get_argument_index_for_region(mbcx.infcx.tcx, fr)?;\n-\n-        let arg_ty =\n-            self.universal_regions.unnormalized_input_tys[implicit_inputs + argument_index];\n-        if let Some(region_name) = self.give_name_if_we_can_match_hir_ty_from_argument(\n-            mbcx,\n-            fr,\n-            arg_ty,\n-            argument_index,\n-            renctx,\n-        ) {\n+        let implicit_inputs = self.regioncx.universal_regions().defining_ty.implicit_inputs();\n+        let argument_index = self.regioncx.get_argument_index_for_region(self.infcx.tcx, fr)?;\n+\n+        let arg_ty = self.regioncx.universal_regions().unnormalized_input_tys\n+            [implicit_inputs + argument_index];\n+        if let Some(region_name) =\n+            self.give_name_if_we_can_match_hir_ty_from_argument(fr, arg_ty, argument_index)\n+        {\n             return Some(region_name);\n         }\n \n-        self.give_name_if_we_cannot_match_hir_ty(mbcx, fr, arg_ty, renctx)\n+        self.give_name_if_we_cannot_match_hir_ty(fr, arg_ty)\n     }\n \n     fn give_name_if_we_can_match_hir_ty_from_argument(\n         &self,\n-        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n         needle_fr: RegionVid,\n         argument_ty: Ty<'tcx>,\n         argument_index: usize,\n-        renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n-        let mir_hir_id = mbcx.infcx.tcx.hir().as_local_hir_id(mbcx.mir_def_id)?;\n-        let fn_decl = mbcx.infcx.tcx.hir().fn_decl_by_hir_id(mir_hir_id)?;\n+        let mir_hir_id = self.infcx.tcx.hir().as_local_hir_id(self.mir_def_id)?;\n+        let fn_decl = self.infcx.tcx.hir().fn_decl_by_hir_id(mir_hir_id)?;\n         let argument_hir_ty: &hir::Ty<'_> = fn_decl.inputs.get(argument_index)?;\n         match argument_hir_ty.kind {\n             // This indicates a variable with no type annotation, like\n@@ -387,13 +340,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // (`give_name_if_anonymous_region_appears_in_arguments`).\n             hir::TyKind::Infer => None,\n \n-            _ => self.give_name_if_we_can_match_hir_ty(\n-                mbcx.infcx.tcx,\n-                needle_fr,\n-                argument_ty,\n-                argument_hir_ty,\n-                renctx,\n-            ),\n+            _ => self.give_name_if_we_can_match_hir_ty(needle_fr, argument_ty, argument_hir_ty),\n         }\n     }\n \n@@ -410,34 +357,33 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// ```\n     fn give_name_if_we_cannot_match_hir_ty(\n         &self,\n-        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n         needle_fr: RegionVid,\n         argument_ty: Ty<'tcx>,\n-        renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n-        let counter = renctx.counter;\n+        let counter = *self.next_region_name.try_borrow().unwrap();\n         let mut highlight = RegionHighlightMode::default();\n         highlight.highlighting_region_vid(needle_fr, counter);\n-        let type_name = mbcx.infcx.extract_type_name(&argument_ty, Some(highlight)).0;\n+        let type_name = self.infcx.extract_type_name(&argument_ty, Some(highlight)).0;\n \n         debug!(\n             \"give_name_if_we_cannot_match_hir_ty: type_name={:?} needle_fr={:?}\",\n             type_name, needle_fr\n         );\n         let assigned_region_name = if type_name.find(&format!(\"'{}\", counter)).is_some() {\n             // Only add a label if we can confirm that a region was labelled.\n-            let argument_index = self.get_argument_index_for_region(mbcx.infcx.tcx, needle_fr)?;\n-            let (_, span) = self.get_argument_name_and_span_for_region(\n-                &mbcx.body,\n-                &mbcx.local_names,\n+            let argument_index =\n+                self.regioncx.get_argument_index_for_region(self.infcx.tcx, needle_fr)?;\n+            let (_, span) = self.regioncx.get_argument_name_and_span_for_region(\n+                &self.body,\n+                &self.local_names,\n                 argument_index,\n             );\n \n             Some(RegionName {\n                 // This counter value will already have been used, so this function will increment\n                 // it so the next value will be used next and return the region name that would\n                 // have been used.\n-                name: renctx.synthesize_region_name(),\n+                name: self.synthesize_region_name(),\n                 source: RegionNameSource::CannotMatchHirTy(span, type_name),\n             })\n         } else {\n@@ -470,11 +416,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// to highlighting that closest type instead.\n     fn give_name_if_we_can_match_hir_ty(\n         &self,\n-        tcx: TyCtxt<'tcx>,\n         needle_fr: RegionVid,\n         argument_ty: Ty<'tcx>,\n         argument_hir_ty: &hir::Ty<'_>,\n-        renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n         let search_stack: &mut Vec<(Ty<'tcx>, &hir::Ty<'_>)> =\n             &mut vec![(argument_ty, argument_hir_ty)];\n@@ -492,10 +436,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     hir::TyKind::Rptr(_lifetime, referent_hir_ty),\n                 ) => {\n                     if region.to_region_vid() == needle_fr {\n-                        let region_name = renctx.synthesize_region_name();\n+                        let region_name = self.synthesize_region_name();\n \n                         // Just grab the first character, the `&`.\n-                        let source_map = tcx.sess.source_map();\n+                        let source_map = self.infcx.tcx.sess.source_map();\n                         let ampersand_span = source_map.start_point(hir_ty.span);\n \n                         return Some(RegionName {\n@@ -525,7 +469,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                                     substs,\n                                     needle_fr,\n                                     last_segment,\n-                                    renctx,\n                                     search_stack,\n                                 ) {\n                                     return Some(name);\n@@ -570,7 +513,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         substs: SubstsRef<'tcx>,\n         needle_fr: RegionVid,\n         last_segment: &'hir hir::PathSegment<'hir>,\n-        renctx: &mut RegionErrorNamingCtx,\n         search_stack: &mut Vec<(Ty<'tcx>, &'hir hir::Ty<'hir>)>,\n     ) -> Option<RegionName> {\n         // Did the user give explicit arguments? (e.g., `Foo<..>`)\n@@ -582,7 +524,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             | hir::LifetimeName::Error\n             | hir::LifetimeName::Static\n             | hir::LifetimeName::Underscore => {\n-                let region_name = renctx.synthesize_region_name();\n+                let region_name = self.synthesize_region_name();\n                 let ampersand_span = lifetime.span;\n                 Some(RegionName {\n                     name: region_name,\n@@ -663,16 +605,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ///  | let x = Some(&22);\n     ///        - fully elaborated type of `x` is `Option<&'1 u32>`\n     /// ```\n-    fn give_name_if_anonymous_region_appears_in_upvars(\n-        &self,\n-        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n-        fr: RegionVid,\n-        renctx: &mut RegionErrorNamingCtx,\n-    ) -> Option<RegionName> {\n-        let upvar_index = self.get_upvar_index_for_region(mbcx.infcx.tcx, fr)?;\n-        let (upvar_name, upvar_span) =\n-            self.get_upvar_name_and_span_for_region(mbcx.infcx.tcx, &mbcx.upvars, upvar_index);\n-        let region_name = renctx.synthesize_region_name();\n+    fn give_name_if_anonymous_region_appears_in_upvars(&self, fr: RegionVid) -> Option<RegionName> {\n+        let upvar_index = self.regioncx.get_upvar_index_for_region(self.infcx.tcx, fr)?;\n+        let (upvar_name, upvar_span) = self.regioncx.get_upvar_name_and_span_for_region(\n+            self.infcx.tcx,\n+            &self.upvars,\n+            upvar_index,\n+        );\n+        let region_name = self.synthesize_region_name();\n \n         Some(RegionName {\n             name: region_name,\n@@ -684,25 +624,20 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// must be a closure since, in a free fn, such an argument would\n     /// have to either also appear in an argument (if using elision)\n     /// or be early bound (named, not in argument).\n-    fn give_name_if_anonymous_region_appears_in_output(\n-        &self,\n-        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n-        fr: RegionVid,\n-        renctx: &mut RegionErrorNamingCtx,\n-    ) -> Option<RegionName> {\n-        let tcx = mbcx.infcx.tcx;\n+    fn give_name_if_anonymous_region_appears_in_output(&self, fr: RegionVid) -> Option<RegionName> {\n+        let tcx = self.infcx.tcx;\n \n-        let return_ty = self.universal_regions.unnormalized_output_ty;\n+        let return_ty = self.regioncx.universal_regions().unnormalized_output_ty;\n         debug!(\"give_name_if_anonymous_region_appears_in_output: return_ty = {:?}\", return_ty);\n         if !tcx.any_free_region_meets(&return_ty, |r| r.to_region_vid() == fr) {\n             return None;\n         }\n \n         let mut highlight = RegionHighlightMode::default();\n-        highlight.highlighting_region_vid(fr, renctx.counter);\n-        let type_name = mbcx.infcx.extract_type_name(&return_ty, Some(highlight)).0;\n+        highlight.highlighting_region_vid(fr, *self.next_region_name.try_borrow().unwrap());\n+        let type_name = self.infcx.extract_type_name(&return_ty, Some(highlight)).0;\n \n-        let mir_hir_id = tcx.hir().as_local_hir_id(mbcx.mir_def_id).expect(\"non-local mir\");\n+        let mir_hir_id = tcx.hir().as_local_hir_id(self.mir_def_id).expect(\"non-local mir\");\n \n         let (return_span, mir_description) = match tcx.hir().get(mir_hir_id) {\n             hir::Node::Expr(hir::Expr {\n@@ -719,14 +654,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 kind: hir::ImplItemKind::Method(method_sig, _),\n                 ..\n             }) => (method_sig.decl.output.span(), \"\"),\n-            _ => (mbcx.body.span, \"\"),\n+            _ => (self.body.span, \"\"),\n         };\n \n         Some(RegionName {\n             // This counter value will already have been used, so this function will increment it\n             // so the next value will be used next and return the region name that would have been\n             // used.\n-            name: renctx.synthesize_region_name(),\n+            name: self.synthesize_region_name(),\n             source: RegionNameSource::AnonRegionFromOutput(\n                 return_span,\n                 mir_description.to_string(),\n@@ -737,32 +672,30 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n     fn give_name_if_anonymous_region_appears_in_yield_ty(\n         &self,\n-        mbcx: &MirBorrowckCtxt<'_, 'tcx>,\n         fr: RegionVid,\n-        renctx: &mut RegionErrorNamingCtx,\n     ) -> Option<RegionName> {\n         // Note: generators from `async fn` yield `()`, so we don't have to\n         // worry about them here.\n-        let yield_ty = self.universal_regions.yield_ty?;\n+        let yield_ty = self.regioncx.universal_regions().yield_ty?;\n         debug!(\"give_name_if_anonymous_region_appears_in_yield_ty: yield_ty = {:?}\", yield_ty,);\n \n-        let tcx = mbcx.infcx.tcx;\n+        let tcx = self.infcx.tcx;\n \n         if !tcx.any_free_region_meets(&yield_ty, |r| r.to_region_vid() == fr) {\n             return None;\n         }\n \n         let mut highlight = RegionHighlightMode::default();\n-        highlight.highlighting_region_vid(fr, renctx.counter);\n-        let type_name = mbcx.infcx.extract_type_name(&yield_ty, Some(highlight)).0;\n+        highlight.highlighting_region_vid(fr, *self.next_region_name.try_borrow().unwrap());\n+        let type_name = self.infcx.extract_type_name(&yield_ty, Some(highlight)).0;\n \n-        let mir_hir_id = tcx.hir().as_local_hir_id(mbcx.mir_def_id).expect(\"non-local mir\");\n+        let mir_hir_id = tcx.hir().as_local_hir_id(self.mir_def_id).expect(\"non-local mir\");\n \n         let yield_span = match tcx.hir().get(mir_hir_id) {\n             hir::Node::Expr(hir::Expr {\n                 kind: hir::ExprKind::Closure(_, _, _, span, _), ..\n             }) => (tcx.sess.source_map().end_point(*span)),\n-            _ => mbcx.body.span,\n+            _ => self.body.span,\n         };\n \n         debug!(\n@@ -772,7 +705,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         );\n \n         Some(RegionName {\n-            name: renctx.synthesize_region_name(),\n+            name: self.synthesize_region_name(),\n             source: RegionNameSource::AnonRegionFromYieldTy(yield_span, type_name),\n         })\n     }"}, {"sha": "5f3585ce8b119927ce127559f86994da3963d049", "filename": "src/librustc_mir/borrow_check/diagnostics/var_name.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fvar_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fvar_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fvar_name.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -16,7 +16,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         fr: RegionVid,\n     ) -> Option<(Option<Symbol>, Span)> {\n         debug!(\"get_var_name_and_span_for_region(fr={:?})\", fr);\n-        assert!(self.universal_regions.is_universal_region(fr));\n+        assert!(self.universal_regions().is_universal_region(fr));\n \n         debug!(\"get_var_name_and_span_for_region: attempting upvar\");\n         self.get_upvar_index_for_region(tcx, fr)\n@@ -35,7 +35,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Search the upvars (if any) to find one that references fr. Return its index.\n     crate fn get_upvar_index_for_region(&self, tcx: TyCtxt<'tcx>, fr: RegionVid) -> Option<usize> {\n         let upvar_index =\n-            self.universal_regions.defining_ty.upvar_tys(tcx).position(|upvar_ty| {\n+            self.universal_regions().defining_ty.upvar_tys(tcx).position(|upvar_ty| {\n                 debug!(\"get_upvar_index_for_region: upvar_ty={:?}\", upvar_ty);\n                 tcx.any_free_region_meets(&upvar_ty, |r| {\n                     let r = r.to_region_vid();\n@@ -44,7 +44,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 })\n             })?;\n \n-        let upvar_ty = self.universal_regions.defining_ty.upvar_tys(tcx).nth(upvar_index);\n+        let upvar_ty = self.universal_regions().defining_ty.upvar_tys(tcx).nth(upvar_index);\n \n         debug!(\n             \"get_upvar_index_for_region: found {:?} in upvar {} which has type {:?}\",\n@@ -85,9 +85,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         fr: RegionVid,\n     ) -> Option<usize> {\n-        let implicit_inputs = self.universal_regions.defining_ty.implicit_inputs();\n+        let implicit_inputs = self.universal_regions().defining_ty.implicit_inputs();\n         let argument_index =\n-            self.universal_regions.unnormalized_input_tys.iter().skip(implicit_inputs).position(\n+            self.universal_regions().unnormalized_input_tys.iter().skip(implicit_inputs).position(\n                 |arg_ty| {\n                     debug!(\"get_argument_index_for_region: arg_ty = {:?}\", arg_ty);\n                     tcx.any_free_region_meets(arg_ty, |r| r.to_region_vid() == fr)\n@@ -96,7 +96,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         debug!(\n             \"get_argument_index_for_region: found {:?} in argument {} which has type {:?}\",\n-            fr, argument_index, self.universal_regions.unnormalized_input_tys[argument_index],\n+            fr,\n+            argument_index,\n+            self.universal_regions().unnormalized_input_tys[argument_index],\n         );\n \n         Some(argument_index)\n@@ -110,7 +112,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         local_names: &IndexVec<Local, Option<Symbol>>,\n         argument_index: usize,\n     ) -> (Option<Symbol>, Span) {\n-        let implicit_inputs = self.universal_regions.defining_ty.implicit_inputs();\n+        let implicit_inputs = self.universal_regions().defining_ty.implicit_inputs();\n         let argument_local = Local::new(implicit_inputs + argument_index + 1);\n         debug!(\"get_argument_name_and_span_for_region: argument_local={:?}\", argument_local);\n "}, {"sha": "90927069242b19e2cf032b2891558178fc642d28", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 19, "deletions": 125, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,6 +1,6 @@\n //! This query borrow-checks the MIR to (further) ensure it is not broken.\n \n-use rustc::infer::{opaque_types, InferCtxt};\n+use rustc::infer::InferCtxt;\n use rustc::lint::builtin::MUTABLE_BORROW_RESERVATION_CONFLICT;\n use rustc::lint::builtin::UNUSED_MUT;\n use rustc::mir::{\n@@ -11,7 +11,8 @@ use rustc::mir::{AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind};\n use rustc::mir::{Field, ProjectionElem, Promoted, Rvalue, Statement, StatementKind};\n use rustc::mir::{Terminator, TerminatorKind};\n use rustc::ty::query::Providers;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, RegionVid, TyCtxt};\n+\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder};\n@@ -21,6 +22,7 @@ use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n \n use smallvec::SmallVec;\n+use std::cell::RefCell;\n use std::collections::BTreeMap;\n use std::mem;\n use std::rc::Rc;\n@@ -39,9 +41,7 @@ use crate::dataflow::{do_dataflow, DebugFormatted};\n use crate::dataflow::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n use crate::transform::MirSource;\n \n-use self::diagnostics::{\n-    AccessKind, OutlivesSuggestionBuilder, RegionErrorKind, RegionErrorNamingCtx, RegionErrors,\n-};\n+use self::diagnostics::{AccessKind, RegionName};\n use self::flows::Flows;\n use self::location::LocationTable;\n use self::prefixes::PrefixSet;\n@@ -285,13 +285,15 @@ fn do_mir_borrowck<'a, 'tcx>(\n         move_error_reported: BTreeMap::new(),\n         uninitialized_error_reported: Default::default(),\n         errors_buffer,\n-        nonlexical_regioncx: regioncx,\n+        regioncx,\n         used_mut: Default::default(),\n         used_mut_upvars: SmallVec::new(),\n         borrow_set,\n         dominators,\n         upvars,\n         local_names,\n+        region_names: RefCell::default(),\n+        next_region_name: RefCell::new(1),\n     };\n \n     // Compute and report region errors, if any.\n@@ -476,10 +478,9 @@ crate struct MirBorrowckCtxt<'cx, 'tcx> {\n     /// If the function we're checking is a closure, then we'll need to report back the list of\n     /// mutable upvars that have been used. This field keeps track of them.\n     used_mut_upvars: SmallVec<[Field; 8]>,\n-    /// Non-lexical region inference context, if NLL is enabled. This\n-    /// contains the results from region inference and lets us e.g.\n+    /// Region inference context. This contains the results from region inference and lets us e.g.\n     /// find out which CFG points are contained in each borrow region.\n-    nonlexical_regioncx: Rc<RegionInferenceContext<'tcx>>,\n+    regioncx: Rc<RegionInferenceContext<'tcx>>,\n \n     /// The set of borrows extracted from the MIR\n     borrow_set: Rc<BorrowSet<'tcx>>,\n@@ -492,6 +493,13 @@ crate struct MirBorrowckCtxt<'cx, 'tcx> {\n \n     /// Names of local (user) variables (extracted from `var_debug_info`).\n     local_names: IndexVec<Local, Option<Name>>,\n+\n+    /// Record the region names generated for each region in the given\n+    /// MIR def so that we can reuse them later in help/error messages.\n+    region_names: RefCell<FxHashMap<RegionVid, RegionName>>,\n+\n+    /// The counter for generating new region names.\n+    next_region_name: RefCell<usize>,\n }\n \n // Check that:\n@@ -631,7 +639,7 @@ impl<'cx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx\n \n                 debug!(\n                     \"visit_terminator_drop \\\n-                        loc: {:?} term: {:?} drop_place: {:?} drop_place_ty: {:?} span: {:?}\",\n+                     loc: {:?} term: {:?} drop_place: {:?} drop_place_ty: {:?} span: {:?}\",\n                     loc, term, drop_place, drop_place_ty, span\n                 );\n \n@@ -1465,120 +1473,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             // initial reservation.\n         }\n     }\n-\n-    /// Produces nice borrowck error diagnostics for all the errors collected in `nll_errors`.\n-    fn report_region_errors(&mut self, nll_errors: RegionErrors<'tcx>) {\n-        // Iterate through all the errors, producing a diagnostic for each one. The diagnostics are\n-        // buffered in the `MirBorrowckCtxt`.\n-\n-        // FIXME(mark-i-m): Would be great to get rid of the naming context.\n-        let mut region_naming = RegionErrorNamingCtx::new();\n-        let mut outlives_suggestion = OutlivesSuggestionBuilder::default();\n-\n-        for nll_error in nll_errors.into_iter() {\n-            match nll_error {\n-                RegionErrorKind::TypeTestDoesNotLiveLongEnough { span, generic } => {\n-                    // FIXME. We should handle this case better. It\n-                    // indicates that we have e.g., some region variable\n-                    // whose value is like `'a+'b` where `'a` and `'b` are\n-                    // distinct unrelated univesal regions that are not\n-                    // known to outlive one another. It'd be nice to have\n-                    // some examples where this arises to decide how best\n-                    // to report it; we could probably handle it by\n-                    // iterating over the universal regions and reporting\n-                    // an error that multiple bounds are required.\n-                    self.infcx\n-                        .tcx\n-                        .sess\n-                        .struct_span_err(span, &format!(\"`{}` does not live long enough\", generic))\n-                        .buffer(&mut self.errors_buffer);\n-                }\n-\n-                RegionErrorKind::TypeTestGenericBoundError {\n-                    span,\n-                    generic,\n-                    lower_bound_region,\n-                } => {\n-                    let region_scope_tree = &self.infcx.tcx.region_scope_tree(self.mir_def_id);\n-                    self.infcx\n-                        .construct_generic_bound_failure(\n-                            region_scope_tree,\n-                            span,\n-                            None,\n-                            generic,\n-                            lower_bound_region,\n-                        )\n-                        .buffer(&mut self.errors_buffer);\n-                }\n-\n-                RegionErrorKind::UnexpectedHiddenRegion {\n-                    opaque_type_def_id,\n-                    hidden_ty,\n-                    member_region,\n-                } => {\n-                    let region_scope_tree = &self.infcx.tcx.region_scope_tree(self.mir_def_id);\n-                    opaque_types::unexpected_hidden_region_diagnostic(\n-                        self.infcx.tcx,\n-                        Some(region_scope_tree),\n-                        opaque_type_def_id,\n-                        hidden_ty,\n-                        member_region,\n-                    )\n-                    .buffer(&mut self.errors_buffer);\n-                }\n-\n-                RegionErrorKind::BoundUniversalRegionError {\n-                    longer_fr,\n-                    fr_origin,\n-                    error_region,\n-                } => {\n-                    // Find the code to blame for the fact that `longer_fr` outlives `error_fr`.\n-                    let (_, span) = self.nonlexical_regioncx.find_outlives_blame_span(\n-                        &self.body,\n-                        longer_fr,\n-                        fr_origin,\n-                        error_region,\n-                    );\n-\n-                    // FIXME: improve this error message\n-                    self.infcx\n-                        .tcx\n-                        .sess\n-                        .struct_span_err(span, \"higher-ranked subtype error\")\n-                        .buffer(&mut self.errors_buffer);\n-                }\n-\n-                RegionErrorKind::RegionError { fr_origin, longer_fr, shorter_fr, is_reported } => {\n-                    if is_reported {\n-                        let db = self.nonlexical_regioncx.report_error(\n-                            self,\n-                            longer_fr,\n-                            fr_origin,\n-                            shorter_fr,\n-                            &mut outlives_suggestion,\n-                            &mut region_naming,\n-                        );\n-\n-                        db.buffer(&mut self.errors_buffer);\n-                    } else {\n-                        // We only report the first error, so as not to overwhelm the user. See\n-                        // `RegRegionErrorKind` docs.\n-                        //\n-                        // FIXME: currently we do nothing with these, but perhaps we can do better?\n-                        // FIXME: try collecting these constraints on the outlives suggestion\n-                        // builder. Does it make the suggestions any better?\n-                        debug!(\n-                            \"Unreported region error: can't prove that {:?}: {:?}\",\n-                            longer_fr, shorter_fr\n-                        );\n-                    }\n-                }\n-            }\n-        }\n-\n-        // Emit one outlives suggestions for each MIR def we borrowck\n-        outlives_suggestion.add_suggestion(self, &mut region_naming);\n-    }\n }\n \n impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n@@ -2225,7 +2119,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             let upvar = &self.upvars[field.index()];\n                             debug!(\n                                 \"upvar.mutability={:?} local_mutation_is_allowed={:?} \\\n-                                place={:?}\",\n+                                 place={:?}\",\n                                 upvar, is_local_mutation_allowed, place\n                             );\n                             match (upvar.mutability, is_local_mutation_allowed) {"}, {"sha": "73718d58346f10a6a85f7faf6db59a298bbead85", "filename": "src/librustc_mir/borrow_check/nll.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -360,7 +360,7 @@ pub(super) fn dump_annotation<'a, 'tcx>(\n     // better.\n \n     if let Some(closure_region_requirements) = closure_region_requirements {\n-        let mut err = tcx.sess.diagnostic().span_note_diag(body.span, \"External requirements\");\n+        let mut err = tcx.sess.diagnostic().span_note_diag(body.span, \"external requirements\");\n \n         regioncx.annotate(tcx, &mut err);\n \n@@ -379,7 +379,7 @@ pub(super) fn dump_annotation<'a, 'tcx>(\n \n         err.buffer(errors_buffer);\n     } else {\n-        let mut err = tcx.sess.diagnostic().span_note_diag(body.span, \"No external requirements\");\n+        let mut err = tcx.sess.diagnostic().span_note_diag(body.span, \"no external requirements\");\n         regioncx.annotate(tcx, &mut err);\n \n         err.buffer(errors_buffer);"}, {"sha": "26d9cf2e0450fe02d82d69d73b6154434b672834", "filename": "src/librustc_mir/borrow_check/region_infer/mod.rs", "status": "modified", "additions": 449, "deletions": 54, "changes": 503, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,3 +1,4 @@\n+use std::collections::VecDeque;\n use std::rc::Rc;\n \n use rustc::infer::canonical::QueryOutlivesConstraint;\n@@ -43,49 +44,48 @@ pub struct RegionInferenceContext<'tcx> {\n     /// variables are identified by their index (`RegionVid`). The\n     /// definition contains information about where the region came\n     /// from as well as its final inferred value.\n-    pub(in crate::borrow_check) definitions: IndexVec<RegionVid, RegionDefinition<'tcx>>,\n+    definitions: IndexVec<RegionVid, RegionDefinition<'tcx>>,\n \n     /// The liveness constraints added to each region. For most\n     /// regions, these start out empty and steadily grow, though for\n     /// each universally quantified region R they start out containing\n     /// the entire CFG and `end(R)`.\n-    pub(in crate::borrow_check) liveness_constraints: LivenessValues<RegionVid>,\n+    liveness_constraints: LivenessValues<RegionVid>,\n \n     /// The outlives constraints computed by the type-check.\n-    pub(in crate::borrow_check) constraints: Rc<OutlivesConstraintSet>,\n+    constraints: Rc<OutlivesConstraintSet>,\n \n     /// The constraint-set, but in graph form, making it easy to traverse\n     /// the constraints adjacent to a particular region. Used to construct\n     /// the SCC (see `constraint_sccs`) and for error reporting.\n-    pub(in crate::borrow_check) constraint_graph: Rc<NormalConstraintGraph>,\n+    constraint_graph: Rc<NormalConstraintGraph>,\n \n     /// The SCC computed from `constraints` and the constraint\n     /// graph. We have an edge from SCC A to SCC B if `A: B`. Used to\n     /// compute the values of each region.\n-    pub(in crate::borrow_check) constraint_sccs: Rc<Sccs<RegionVid, ConstraintSccIndex>>,\n+    constraint_sccs: Rc<Sccs<RegionVid, ConstraintSccIndex>>,\n \n     /// Reverse of the SCC constraint graph -- i.e., an edge `A -> B`\n     /// exists if `B: A`. Computed lazilly.\n-    pub(in crate::borrow_check) rev_constraint_graph: Option<Rc<VecGraph<ConstraintSccIndex>>>,\n+    rev_constraint_graph: Option<Rc<VecGraph<ConstraintSccIndex>>>,\n \n     /// The \"R0 member of [R1..Rn]\" constraints, indexed by SCC.\n-    pub(in crate::borrow_check) member_constraints:\n-        Rc<MemberConstraintSet<'tcx, ConstraintSccIndex>>,\n+    member_constraints: Rc<MemberConstraintSet<'tcx, ConstraintSccIndex>>,\n \n     /// Records the member constraints that we applied to each scc.\n     /// This is useful for error reporting. Once constraint\n     /// propagation is done, this vector is sorted according to\n     /// `member_region_scc`.\n-    pub(in crate::borrow_check) member_constraints_applied: Vec<AppliedMemberConstraint>,\n+    member_constraints_applied: Vec<AppliedMemberConstraint>,\n \n     /// Map closure bounds to a `Span` that should be used for error reporting.\n-    pub(in crate::borrow_check) closure_bounds_mapping:\n+    closure_bounds_mapping:\n         FxHashMap<Location, FxHashMap<(RegionVid, RegionVid), (ConstraintCategory, Span)>>,\n \n     /// Contains the minimum universe of any variable within the same\n     /// SCC. We will ensure that no SCC contains values that are not\n     /// visible from this index.\n-    pub(in crate::borrow_check) scc_universes: IndexVec<ConstraintSccIndex, ty::UniverseIndex>,\n+    scc_universes: IndexVec<ConstraintSccIndex, ty::UniverseIndex>,\n \n     /// Contains a \"representative\" from each SCC. This will be the\n     /// minimal RegionVid belonging to that universe. It is used as a\n@@ -94,23 +94,23 @@ pub struct RegionInferenceContext<'tcx> {\n     /// of its SCC and be sure that -- if they have the same repr --\n     /// they *must* be equal (though not having the same repr does not\n     /// mean they are unequal).\n-    pub(in crate::borrow_check) scc_representatives: IndexVec<ConstraintSccIndex, ty::RegionVid>,\n+    scc_representatives: IndexVec<ConstraintSccIndex, ty::RegionVid>,\n \n     /// The final inferred values of the region variables; we compute\n     /// one value per SCC. To get the value for any given *region*,\n     /// you first find which scc it is a part of.\n-    pub(in crate::borrow_check) scc_values: RegionValues<ConstraintSccIndex>,\n+    scc_values: RegionValues<ConstraintSccIndex>,\n \n     /// Type constraints that we check after solving.\n-    pub(in crate::borrow_check) type_tests: Vec<TypeTest<'tcx>>,\n+    type_tests: Vec<TypeTest<'tcx>>,\n \n     /// Information about the universally quantified regions in scope\n     /// on this function.\n-    pub(in crate::borrow_check) universal_regions: Rc<UniversalRegions<'tcx>>,\n+    universal_regions: Rc<UniversalRegions<'tcx>>,\n \n     /// Information about how the universally quantified regions in\n     /// scope on this function relate to one another.\n-    pub(in crate::borrow_check) universal_region_relations: Rc<UniversalRegionRelations<'tcx>>,\n+    universal_region_relations: Rc<UniversalRegionRelations<'tcx>>,\n }\n \n /// Each time that `apply_member_constraint` is successful, it appends\n@@ -225,6 +225,13 @@ enum RegionRelationCheckResult {\n     Error,\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum Trace {\n+    StartRegion,\n+    FromOutlivesConstraint(OutlivesConstraint),\n+    NotVisited,\n+}\n+\n impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Creates a new region inference context with a total of\n     /// `num_region_variables` valid inference variables; the first N\n@@ -838,39 +845,22 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n \n             // Type-test failed. Report the error.\n-\n-            // Try to convert the lower-bound region into something named we can print for the user.\n-            let lower_bound_region = self.to_error_region(type_test.lower_bound);\n+            let erased_generic_kind = infcx.tcx.erase_regions(&type_test.generic_kind);\n \n             // Skip duplicate-ish errors.\n-            let type_test_span = type_test.locations.span(body);\n-            let erased_generic_kind = tcx.erase_regions(&type_test.generic_kind);\n-            if !deduplicate_errors.insert((\n+            if deduplicate_errors.insert((\n                 erased_generic_kind,\n-                lower_bound_region,\n+                type_test.lower_bound,\n                 type_test.locations,\n             )) {\n-                continue;\n-            } else {\n                 debug!(\n                     \"check_type_test: reporting error for erased_generic_kind={:?}, \\\n                      lower_bound_region={:?}, \\\n                      type_test.locations={:?}\",\n-                    erased_generic_kind, lower_bound_region, type_test.locations,\n+                    erased_generic_kind, type_test.lower_bound, type_test.locations,\n                 );\n-            }\n \n-            if let Some(lower_bound_region) = lower_bound_region {\n-                errors_buffer.push(RegionErrorKind::TypeTestGenericBoundError {\n-                    span: type_test_span,\n-                    generic: type_test.generic_kind,\n-                    lower_bound_region,\n-                });\n-            } else {\n-                errors_buffer.push(RegionErrorKind::TypeTestDoesNotLiveLongEnough {\n-                    span: type_test_span,\n-                    generic: type_test.generic_kind,\n-                });\n+                errors_buffer.push(RegionErrorKind::TypeTestError { type_test: type_test.clone() });\n             }\n         }\n     }\n@@ -1355,7 +1345,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         for (longer_fr, shorter_fr) in subset_errors.into_iter() {\n             debug!(\n                 \"check_polonius_subset_errors: subset_error longer_fr={:?},\\\n-                shorter_fr={:?}\",\n+                 shorter_fr={:?}\",\n                 longer_fr, shorter_fr\n             );\n \n@@ -1572,23 +1562,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         debug!(\"check_bound_universal_region: error_element = {:?}\", error_element);\n \n         // Find the region that introduced this `error_element`.\n-        let error_region = match error_element {\n-            RegionElement::Location(l) => self.find_sub_region_live_at(longer_fr, l),\n-            RegionElement::RootUniversalRegion(r) => r,\n-            RegionElement::PlaceholderRegion(error_placeholder) => self\n-                .definitions\n-                .iter_enumerated()\n-                .filter_map(|(r, definition)| match definition.origin {\n-                    NLLRegionVariableOrigin::Placeholder(p) if p == error_placeholder => Some(r),\n-                    _ => None,\n-                })\n-                .next()\n-                .unwrap(),\n-        };\n-\n         errors_buffer.push(RegionErrorKind::BoundUniversalRegionError {\n             longer_fr,\n-            error_region,\n+            error_element,\n             fr_origin: NLLRegionVariableOrigin::Placeholder(placeholder),\n         });\n     }\n@@ -1628,6 +1604,425 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             });\n         }\n     }\n+\n+    /// We have a constraint `fr1: fr2` that is not satisfied, where\n+    /// `fr2` represents some universal region. Here, `r` is some\n+    /// region where we know that `fr1: r` and this function has the\n+    /// job of determining whether `r` is \"to blame\" for the fact that\n+    /// `fr1: fr2` is required.\n+    ///\n+    /// This is true under two conditions:\n+    ///\n+    /// - `r == fr2`\n+    /// - `fr2` is `'static` and `r` is some placeholder in a universe\n+    ///   that cannot be named by `fr1`; in that case, we will require\n+    ///   that `fr1: 'static` because it is the only way to `fr1: r` to\n+    ///   be satisfied. (See `add_incompatible_universe`.)\n+    crate fn provides_universal_region(\n+        &self,\n+        r: RegionVid,\n+        fr1: RegionVid,\n+        fr2: RegionVid,\n+    ) -> bool {\n+        debug!(\"provides_universal_region(r={:?}, fr1={:?}, fr2={:?})\", r, fr1, fr2);\n+        let result = {\n+            r == fr2 || {\n+                fr2 == self.universal_regions.fr_static && self.cannot_name_placeholder(fr1, r)\n+            }\n+        };\n+        debug!(\"provides_universal_region: result = {:?}\", result);\n+        result\n+    }\n+\n+    /// If `r2` represents a placeholder region, then this returns\n+    /// `true` if `r1` cannot name that placeholder in its\n+    /// value; otherwise, returns `false`.\n+    crate fn cannot_name_placeholder(&self, r1: RegionVid, r2: RegionVid) -> bool {\n+        debug!(\"cannot_name_value_of(r1={:?}, r2={:?})\", r1, r2);\n+\n+        match self.definitions[r2].origin {\n+            NLLRegionVariableOrigin::Placeholder(placeholder) => {\n+                let universe1 = self.definitions[r1].universe;\n+                debug!(\n+                    \"cannot_name_value_of: universe1={:?} placeholder={:?}\",\n+                    universe1, placeholder\n+                );\n+                universe1.cannot_name(placeholder.universe)\n+            }\n+\n+            NLLRegionVariableOrigin::FreeRegion | NLLRegionVariableOrigin::Existential { .. } => {\n+                false\n+            }\n+        }\n+    }\n+\n+    crate fn retrieve_closure_constraint_info(\n+        &self,\n+        body: &Body<'tcx>,\n+        constraint: &OutlivesConstraint,\n+    ) -> (ConstraintCategory, bool, Span) {\n+        let loc = match constraint.locations {\n+            Locations::All(span) => return (constraint.category, false, span),\n+            Locations::Single(loc) => loc,\n+        };\n+\n+        let opt_span_category =\n+            self.closure_bounds_mapping[&loc].get(&(constraint.sup, constraint.sub));\n+        opt_span_category.map(|&(category, span)| (category, true, span)).unwrap_or((\n+            constraint.category,\n+            false,\n+            body.source_info(loc).span,\n+        ))\n+    }\n+\n+    /// Finds a good span to blame for the fact that `fr1` outlives `fr2`.\n+    crate fn find_outlives_blame_span(\n+        &self,\n+        body: &Body<'tcx>,\n+        fr1: RegionVid,\n+        fr1_origin: NLLRegionVariableOrigin,\n+        fr2: RegionVid,\n+    ) -> (ConstraintCategory, Span) {\n+        let (category, _, span) = self.best_blame_constraint(body, fr1, fr1_origin, |r| {\n+            self.provides_universal_region(r, fr1, fr2)\n+        });\n+        (category, span)\n+    }\n+\n+    /// Walks the graph of constraints (where `'a: 'b` is considered\n+    /// an edge `'a -> 'b`) to find all paths from `from_region` to\n+    /// `to_region`. The paths are accumulated into the vector\n+    /// `results`. The paths are stored as a series of\n+    /// `ConstraintIndex` values -- in other words, a list of *edges*.\n+    ///\n+    /// Returns: a series of constraints as well as the region `R`\n+    /// that passed the target test.\n+    crate fn find_constraint_paths_between_regions(\n+        &self,\n+        from_region: RegionVid,\n+        target_test: impl Fn(RegionVid) -> bool,\n+    ) -> Option<(Vec<OutlivesConstraint>, RegionVid)> {\n+        let mut context = IndexVec::from_elem(Trace::NotVisited, &self.definitions);\n+        context[from_region] = Trace::StartRegion;\n+\n+        // Use a deque so that we do a breadth-first search. We will\n+        // stop at the first match, which ought to be the shortest\n+        // path (fewest constraints).\n+        let mut deque = VecDeque::new();\n+        deque.push_back(from_region);\n+\n+        while let Some(r) = deque.pop_front() {\n+            debug!(\n+                \"find_constraint_paths_between_regions: from_region={:?} r={:?} value={}\",\n+                from_region,\n+                r,\n+                self.region_value_str(r),\n+            );\n+\n+            // Check if we reached the region we were looking for. If so,\n+            // we can reconstruct the path that led to it and return it.\n+            if target_test(r) {\n+                let mut result = vec![];\n+                let mut p = r;\n+                loop {\n+                    match context[p] {\n+                        Trace::NotVisited => {\n+                            bug!(\"found unvisited region {:?} on path to {:?}\", p, r)\n+                        }\n+\n+                        Trace::FromOutlivesConstraint(c) => {\n+                            result.push(c);\n+                            p = c.sup;\n+                        }\n+\n+                        Trace::StartRegion => {\n+                            result.reverse();\n+                            return Some((result, r));\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Otherwise, walk over the outgoing constraints and\n+            // enqueue any regions we find, keeping track of how we\n+            // reached them.\n+\n+            // A constraint like `'r: 'x` can come from our constraint\n+            // graph.\n+            let fr_static = self.universal_regions.fr_static;\n+            let outgoing_edges_from_graph =\n+                self.constraint_graph.outgoing_edges(r, &self.constraints, fr_static);\n+\n+            // Always inline this closure because it can be hot.\n+            let mut handle_constraint = #[inline(always)]\n+            |constraint: OutlivesConstraint| {\n+                debug_assert_eq!(constraint.sup, r);\n+                let sub_region = constraint.sub;\n+                if let Trace::NotVisited = context[sub_region] {\n+                    context[sub_region] = Trace::FromOutlivesConstraint(constraint);\n+                    deque.push_back(sub_region);\n+                }\n+            };\n+\n+            // This loop can be hot.\n+            for constraint in outgoing_edges_from_graph {\n+                handle_constraint(constraint);\n+            }\n+\n+            // Member constraints can also give rise to `'r: 'x` edges that\n+            // were not part of the graph initially, so watch out for those.\n+            // (But they are extremely rare; this loop is very cold.)\n+            for constraint in self.applied_member_constraints(r) {\n+                let p_c = &self.member_constraints[constraint.member_constraint_index];\n+                let constraint = OutlivesConstraint {\n+                    sup: r,\n+                    sub: constraint.min_choice,\n+                    locations: Locations::All(p_c.definition_span),\n+                    category: ConstraintCategory::OpaqueType,\n+                };\n+                handle_constraint(constraint);\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    /// Finds some region R such that `fr1: R` and `R` is live at `elem`.\n+    crate fn find_sub_region_live_at(&self, fr1: RegionVid, elem: Location) -> RegionVid {\n+        debug!(\"find_sub_region_live_at(fr1={:?}, elem={:?})\", fr1, elem);\n+        self.find_constraint_paths_between_regions(fr1, |r| {\n+            // First look for some `r` such that `fr1: r` and `r` is live at `elem`\n+            debug!(\n+                \"find_sub_region_live_at: liveness_constraints for {:?} are {:?}\",\n+                r,\n+                self.liveness_constraints.region_value_str(r),\n+            );\n+            self.liveness_constraints.contains(r, elem)\n+        })\n+        .or_else(|| {\n+            // If we fail to find that, we may find some `r` such that\n+            // `fr1: r` and `r` is a placeholder from some universe\n+            // `fr1` cannot name. This would force `fr1` to be\n+            // `'static`.\n+            self.find_constraint_paths_between_regions(fr1, |r| {\n+                self.cannot_name_placeholder(fr1, r)\n+            })\n+        })\n+        .or_else(|| {\n+            // If we fail to find THAT, it may be that `fr1` is a\n+            // placeholder that cannot \"fit\" into its SCC. In that\n+            // case, there should be some `r` where `fr1: r`, both\n+            // `fr1` and `r` are in the same SCC, and `fr1` is a\n+            // placeholder that `r` cannot name. We can blame that\n+            // edge.\n+            self.find_constraint_paths_between_regions(fr1, |r| {\n+                self.constraint_sccs.scc(fr1) == self.constraint_sccs.scc(r)\n+                    && self.cannot_name_placeholder(r, fr1)\n+            })\n+        })\n+        .map(|(_path, r)| r)\n+        .unwrap()\n+    }\n+\n+    /// Get the region outlived by `longer_fr` and live at `element`.\n+    crate fn region_from_element(&self, longer_fr: RegionVid, element: RegionElement) -> RegionVid {\n+        match element {\n+            RegionElement::Location(l) => self.find_sub_region_live_at(longer_fr, l),\n+            RegionElement::RootUniversalRegion(r) => r,\n+            RegionElement::PlaceholderRegion(error_placeholder) => self\n+                .definitions\n+                .iter_enumerated()\n+                .filter_map(|(r, definition)| match definition.origin {\n+                    NLLRegionVariableOrigin::Placeholder(p) if p == error_placeholder => Some(r),\n+                    _ => None,\n+                })\n+                .next()\n+                .unwrap(),\n+        }\n+    }\n+\n+    /// Get the region definition of `r`.\n+    crate fn region_definition(&self, r: RegionVid) -> &RegionDefinition<'tcx> {\n+        &self.definitions[r]\n+    }\n+\n+    /// Check if the SCC of `r` contains `upper`.\n+    crate fn upper_bound_in_region_scc(&self, r: RegionVid, upper: RegionVid) -> bool {\n+        let r_scc = self.constraint_sccs.scc(r);\n+        self.scc_values.contains(r_scc, upper)\n+    }\n+\n+    crate fn universal_regions(&self) -> &UniversalRegions<'tcx> {\n+        self.universal_regions.as_ref()\n+    }\n+\n+    /// Tries to find the best constraint to blame for the fact that\n+    /// `R: from_region`, where `R` is some region that meets\n+    /// `target_test`. This works by following the constraint graph,\n+    /// creating a constraint path that forces `R` to outlive\n+    /// `from_region`, and then finding the best choices within that\n+    /// path to blame.\n+    crate fn best_blame_constraint(\n+        &self,\n+        body: &Body<'tcx>,\n+        from_region: RegionVid,\n+        from_region_origin: NLLRegionVariableOrigin,\n+        target_test: impl Fn(RegionVid) -> bool,\n+    ) -> (ConstraintCategory, bool, Span) {\n+        debug!(\n+            \"best_blame_constraint(from_region={:?}, from_region_origin={:?})\",\n+            from_region, from_region_origin\n+        );\n+\n+        // Find all paths\n+        let (path, target_region) =\n+            self.find_constraint_paths_between_regions(from_region, target_test).unwrap();\n+        debug!(\n+            \"best_blame_constraint: path={:#?}\",\n+            path.iter()\n+                .map(|&c| format!(\n+                    \"{:?} ({:?}: {:?})\",\n+                    c,\n+                    self.constraint_sccs.scc(c.sup),\n+                    self.constraint_sccs.scc(c.sub),\n+                ))\n+                .collect::<Vec<_>>()\n+        );\n+\n+        // Classify each of the constraints along the path.\n+        let mut categorized_path: Vec<(ConstraintCategory, bool, Span)> = path\n+            .iter()\n+            .map(|constraint| {\n+                if constraint.category == ConstraintCategory::ClosureBounds {\n+                    self.retrieve_closure_constraint_info(body, &constraint)\n+                } else {\n+                    (constraint.category, false, constraint.locations.span(body))\n+                }\n+            })\n+            .collect();\n+        debug!(\"best_blame_constraint: categorized_path={:#?}\", categorized_path);\n+\n+        // To find the best span to cite, we first try to look for the\n+        // final constraint that is interesting and where the `sup` is\n+        // not unified with the ultimate target region. The reason\n+        // for this is that we have a chain of constraints that lead\n+        // from the source to the target region, something like:\n+        //\n+        //    '0: '1 ('0 is the source)\n+        //    '1: '2\n+        //    '2: '3\n+        //    '3: '4\n+        //    '4: '5\n+        //    '5: '6 ('6 is the target)\n+        //\n+        // Some of those regions are unified with `'6` (in the same\n+        // SCC).  We want to screen those out. After that point, the\n+        // \"closest\" constraint we have to the end is going to be the\n+        // most likely to be the point where the value escapes -- but\n+        // we still want to screen for an \"interesting\" point to\n+        // highlight (e.g., a call site or something).\n+        let target_scc = self.constraint_sccs.scc(target_region);\n+        let mut range = 0..path.len();\n+\n+        // As noted above, when reporting an error, there is typically a chain of constraints\n+        // leading from some \"source\" region which must outlive some \"target\" region.\n+        // In most cases, we prefer to \"blame\" the constraints closer to the target --\n+        // but there is one exception. When constraints arise from higher-ranked subtyping,\n+        // we generally prefer to blame the source value,\n+        // as the \"target\" in this case tends to be some type annotation that the user gave.\n+        // Therefore, if we find that the region origin is some instantiation\n+        // of a higher-ranked region, we start our search from the \"source\" point\n+        // rather than the \"target\", and we also tweak a few other things.\n+        //\n+        // An example might be this bit of Rust code:\n+        //\n+        // ```rust\n+        // let x: fn(&'static ()) = |_| {};\n+        // let y: for<'a> fn(&'a ()) = x;\n+        // ```\n+        //\n+        // In MIR, this will be converted into a combination of assignments and type ascriptions.\n+        // In particular, the 'static is imposed through a type ascription:\n+        //\n+        // ```rust\n+        // x = ...;\n+        // AscribeUserType(x, fn(&'static ())\n+        // y = x;\n+        // ```\n+        //\n+        // We wind up ultimately with constraints like\n+        //\n+        // ```rust\n+        // !a: 'temp1 // from the `y = x` statement\n+        // 'temp1: 'temp2\n+        // 'temp2: 'static // from the AscribeUserType\n+        // ```\n+        //\n+        // and here we prefer to blame the source (the y = x statement).\n+        let blame_source = match from_region_origin {\n+            NLLRegionVariableOrigin::FreeRegion\n+            | NLLRegionVariableOrigin::Existential { from_forall: false } => true,\n+            NLLRegionVariableOrigin::Placeholder(_)\n+            | NLLRegionVariableOrigin::Existential { from_forall: true } => false,\n+        };\n+\n+        let find_region = |i: &usize| {\n+            let constraint = path[*i];\n+\n+            let constraint_sup_scc = self.constraint_sccs.scc(constraint.sup);\n+\n+            if blame_source {\n+                match categorized_path[*i].0 {\n+                    ConstraintCategory::OpaqueType\n+                    | ConstraintCategory::Boring\n+                    | ConstraintCategory::BoringNoLocation\n+                    | ConstraintCategory::Internal => false,\n+                    ConstraintCategory::TypeAnnotation\n+                    | ConstraintCategory::Return\n+                    | ConstraintCategory::Yield => true,\n+                    _ => constraint_sup_scc != target_scc,\n+                }\n+            } else {\n+                match categorized_path[*i].0 {\n+                    ConstraintCategory::OpaqueType\n+                    | ConstraintCategory::Boring\n+                    | ConstraintCategory::BoringNoLocation\n+                    | ConstraintCategory::Internal => false,\n+                    _ => true,\n+                }\n+            }\n+        };\n+\n+        let best_choice =\n+            if blame_source { range.rev().find(find_region) } else { range.find(find_region) };\n+\n+        debug!(\n+            \"best_blame_constraint: best_choice={:?} blame_source={}\",\n+            best_choice, blame_source\n+        );\n+\n+        if let Some(i) = best_choice {\n+            if let Some(next) = categorized_path.get(i + 1) {\n+                if categorized_path[i].0 == ConstraintCategory::Return\n+                    && next.0 == ConstraintCategory::OpaqueType\n+                {\n+                    // The return expression is being influenced by the return type being\n+                    // impl Trait, point at the return type and not the return expr.\n+                    return *next;\n+                }\n+            }\n+            return categorized_path[i];\n+        }\n+\n+        // If that search fails, that is.. unusual. Maybe everything\n+        // is in the same SCC or something. In that case, find what\n+        // appears to be the most interesting point to report to the\n+        // user via an even more ad-hoc guess.\n+        categorized_path.sort_by(|p0, p1| p0.0.cmp(&p1.0));\n+        debug!(\"`: sorted_path={:#?}\", categorized_path);\n+\n+        *categorized_path.first().unwrap()\n+    }\n }\n \n impl<'tcx> RegionDefinition<'tcx> {"}, {"sha": "3126d44014b4ea3d0943c3497794c6a38e7dec9b", "filename": "src/librustc_mir/borrow_check/region_infer/values.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fvalues.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -114,7 +114,7 @@ rustc_index::newtype_index! {\n \n /// An individual element in a region value -- the value of a\n /// particular region variable consists of a set of these elements.\n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n crate enum RegionElement {\n     /// A point in the control-flow graph.\n     Location(Location),"}, {"sha": "aad0e1629359a8523895b2e7f2e9a67c9df8d674", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -5,7 +5,7 @@ use rustc::ty::layout::VariantIdx;\n use rustc::ty::{self, TyCtxt};\n use rustc_span::{source_map::DUMMY_SP, symbol::Symbol};\n \n-use crate::interpret::{intern_const_alloc_recursive, ConstValue, InterpCx};\n+use crate::interpret::{intern_const_alloc_recursive, ConstValue, InternKind, InterpCx};\n \n mod error;\n mod eval_queries;\n@@ -52,7 +52,7 @@ pub(crate) fn const_caller_location<'tcx>(\n \n     let loc_ty = tcx.caller_location_ty();\n     let loc_place = ecx.alloc_caller_location(file, line, col);\n-    intern_const_alloc_recursive(&mut ecx, None, loc_place, false).unwrap();\n+    intern_const_alloc_recursive(&mut ecx, InternKind::Constant, loc_place, false).unwrap();\n     let loc_const = ty::Const {\n         ty: loc_ty,\n         val: ty::ConstKind::Value(ConstValue::Scalar(loc_place.ptr.into())),"}, {"sha": "442baf85f2bafea116b28a1f05b6207722f21b04", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,9 +1,9 @@\n use super::{error_to_const_error, CompileTimeEvalContext, CompileTimeInterpreter, MemoryExtra};\n use crate::interpret::eval_nullary_intrinsic;\n use crate::interpret::{\n-    intern_const_alloc_recursive, Allocation, ConstValue, GlobalId, ImmTy, Immediate, InterpCx,\n-    InterpResult, MPlaceTy, MemoryKind, OpTy, RawConst, RefTracking, Scalar, ScalarMaybeUndef,\n-    StackPopCleanup,\n+    intern_const_alloc_recursive, Allocation, ConstValue, GlobalId, ImmTy, Immediate, InternKind,\n+    InterpCx, InterpResult, MPlaceTy, MemoryKind, OpTy, RawConst, RefTracking, Scalar,\n+    ScalarMaybeUndef, StackPopCleanup,\n };\n use rustc::mir;\n use rustc::mir::interpret::{ConstEvalErr, ErrorHandled};\n@@ -56,9 +56,14 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n     ecx.run()?;\n \n     // Intern the result\n+    let intern_kind = match tcx.static_mutability(cid.instance.def_id()) {\n+        Some(m) => InternKind::Static(m),\n+        None if cid.promoted.is_some() => InternKind::Promoted,\n+        _ => InternKind::Constant,\n+    };\n     intern_const_alloc_recursive(\n         ecx,\n-        tcx.static_mutability(cid.instance.def_id()),\n+        intern_kind,\n         ret,\n         body.ignore_interior_mut_in_const_validation,\n     )?;"}, {"sha": "0c65b77a38240af17f80298d32103b3ba226d327", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 34, "deletions": 10, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -268,19 +268,27 @@ impl<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx\n     }\n }\n \n+pub enum InternKind {\n+    /// The `mutability` of the static, ignoring the type which may have interior mutability.\n+    Static(hir::Mutability),\n+    Constant,\n+    Promoted,\n+    ConstProp,\n+}\n+\n pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n     ecx: &mut InterpCx<'mir, 'tcx, M>,\n-    // The `mutability` of the place, ignoring the type.\n-    place_mut: Option<hir::Mutability>,\n+    intern_kind: InternKind,\n     ret: MPlaceTy<'tcx>,\n     ignore_interior_mut_in_const_validation: bool,\n ) -> InterpResult<'tcx> {\n     let tcx = ecx.tcx;\n-    let (base_mutability, base_intern_mode) = match place_mut {\n+    let (base_mutability, base_intern_mode) = match intern_kind {\n         // `static mut` doesn't care about interior mutability, it's mutable anyway\n-        Some(mutbl) => (mutbl, InternMode::Static),\n-        // consts, promoteds. FIXME: what about array lengths, array initializers?\n-        None => (Mutability::Not, InternMode::ConstBase),\n+        InternKind::Static(mutbl) => (mutbl, InternMode::Static),\n+        // FIXME: what about array lengths, array initializers?\n+        InternKind::Constant | InternKind::ConstProp => (Mutability::Not, InternMode::ConstBase),\n+        InternKind::Promoted => (Mutability::Not, InternMode::ConstBase),\n     };\n \n     // Type based interning.\n@@ -338,10 +346,24 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n             // We can't call the `intern_shallow` method here, as its logic is tailored to safe\n             // references and a `leftover_allocations` set (where we only have a todo-list here).\n             // So we hand-roll the interning logic here again.\n-            match base_intern_mode {\n-                InternMode::Static => {}\n-                InternMode::Const | InternMode::ConstBase => {\n-                    // If it's not a static, it *must* be immutable.\n+            match intern_kind {\n+                // Statics may contain mutable allocations even behind relocations.\n+                // Even for immutable statics it would be ok to have mutable allocations behind\n+                // raw pointers, e.g. for `static FOO: *const AtomicUsize = &AtomicUsize::new(42)`.\n+                InternKind::Static(_) => {}\n+                // Raw pointers in promoteds may only point to immutable things so we mark\n+                // everything as immutable.\n+                // It is UB to mutate through a raw pointer obtained via an immutable reference.\n+                // Since all references and pointers inside a promoted must by their very definition\n+                // be created from an immutable reference (and promotion also excludes interior\n+                // mutability), mutating through them would be UB.\n+                // There's no way we can check whether the user is using raw pointers correctly,\n+                // so all we can do is mark this as immutable here.\n+                InternKind::Promoted => {\n+                    alloc.mutability = Mutability::Not;\n+                }\n+                InternKind::Constant | InternKind::ConstProp => {\n+                    // If it's a constant, it *must* be immutable.\n                     // We cannot have mutable memory inside a constant.\n                     // We use `delay_span_bug` here, because this can be reached in the presence\n                     // of fancy transmutes.\n@@ -364,6 +386,8 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n             // dangling pointer\n             throw_unsup!(ValidationFailure(\"encountered dangling pointer in final constant\".into()))\n         } else if ecx.tcx.alloc_map.lock().get(alloc_id).is_none() {\n+            // We have hit an `AllocId` that is neither in local or global memory and isn't marked\n+            // as dangling by local memory.\n             span_bug!(ecx.tcx.span, \"encountered unknown alloc id {:?}\", alloc_id);\n         }\n     }"}, {"sha": "0bcdf9ae3c1f20866644e42a44dbfb534a32c90a", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -580,10 +580,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 let layout = self.tcx.layout_of(ParamEnv::empty().and(ty)).unwrap();\n                 Ok((layout.size, layout.align.abi))\n             }\n-            Some(GlobalAlloc::Memory(alloc)) =>\n-            // Need to duplicate the logic here, because the global allocations have\n-            // different associated types than the interpreter-local ones.\n-            {\n+            Some(GlobalAlloc::Memory(alloc)) => {\n+                // Need to duplicate the logic here, because the global allocations have\n+                // different associated types than the interpreter-local ones.\n                 Ok((alloc.size, alloc.align))\n             }\n             Some(GlobalAlloc::Function(_)) => bug!(\"We already checked function pointers above\"),"}, {"sha": "a519f38e712087dc9215a0aa79a71a77c9dc09f6", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -32,6 +32,6 @@ pub use self::visitor::{MutValueVisitor, ValueVisitor};\n \n pub use self::validity::RefTracking;\n \n-pub use self::intern::intern_const_alloc_recursive;\n+pub use self::intern::{intern_const_alloc_recursive, InternKind};\n \n crate use self::intrinsics::eval_nullary_intrinsic;"}, {"sha": "d1c08da6cbee55da6b4c287974897bdcb9ad121b", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -684,16 +684,14 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             let variant_index = variants_start\n                                 .checked_add(variant_index_relative)\n                                 .expect(\"oveflow computing absolute variant idx\");\n-                            assert!(\n-                                (variant_index as usize)\n-                                    < rval\n-                                        .layout\n-                                        .ty\n-                                        .ty_adt_def()\n-                                        .expect(\"tagged layout for non adt\")\n-                                        .variants\n-                                        .len()\n-                            );\n+                            let variants_len = rval\n+                                .layout\n+                                .ty\n+                                .ty_adt_def()\n+                                .expect(\"tagged layout for non adt\")\n+                                .variants\n+                                .len();\n+                            assert!((variant_index as usize) < variants_len);\n                             (u128::from(variant_index), VariantIdx::from_u32(variant_index))\n                         } else {\n                             (u128::from(dataful_variant.as_u32()), dataful_variant)"}, {"sha": "4f96cb698915d25146c45e2bff6d9528bf49e772", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -432,12 +432,11 @@ where\n             // happens at run-time so that's okay.\n             let align = match self.size_and_align_of(base.meta, field_layout)? {\n                 Some((_, align)) => align,\n-                None if offset == Size::ZERO =>\n-                // An extern type at offset 0, we fall back to its static alignment.\n-                // FIXME: Once we have made decisions for how to handle size and alignment\n-                // of `extern type`, this should be adapted.  It is just a temporary hack\n-                // to get some code to work that probably ought to work.\n-                {\n+                None if offset == Size::ZERO => {\n+                    // An extern type at offset 0, we fall back to its static alignment.\n+                    // FIXME: Once we have made decisions for how to handle size and alignment\n+                    // of `extern type`, this should be adapted.  It is just a temporary hack\n+                    // to get some code to work that probably ought to work.\n                     field_layout.align.abi\n                 }\n                 None => bug!(\"Cannot compute offset for extern type field at non-0 offset\"),"}, {"sha": "aa2b3040a716f49a757207d8c33b88d1bd3386e5", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -114,14 +114,11 @@ fn write_path(out: &mut String, path: &Vec<PathElem>) {\n             ClosureVar(name) => write!(out, \".<closure-var({})>\", name),\n             TupleElem(idx) => write!(out, \".{}\", idx),\n             ArrayElem(idx) => write!(out, \"[{}]\", idx),\n-            Deref =>\n-            // This does not match Rust syntax, but it is more readable for long paths -- and\n+            // `.<deref>` does not match Rust syntax, but it is more readable for long paths -- and\n             // some of the other items here also are not Rust syntax.  Actually we can't\n             // even use the usual syntax because we are just showing the projections,\n             // not the root.\n-            {\n-                write!(out, \".<deref>\")\n-            }\n+            Deref => write!(out, \".<deref>\"),\n             Tag => write!(out, \".<enum-tag>\"),\n             DynDowncast => write!(out, \".<dyn-downcast>\"),\n         }\n@@ -206,9 +203,8 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n             ty::Adt(def, ..) if def.is_enum() => {\n                 // we might be projecting *to* a variant, or to a field *in*a variant.\n                 match layout.variants {\n-                    layout::Variants::Single { index } =>\n-                    // Inside a variant\n-                    {\n+                    layout::Variants::Single { index } => {\n+                        // Inside a variant\n                         PathElem::Field(def.variants[index].fields[field].ident.name)\n                     }\n                     _ => bug!(),\n@@ -587,12 +583,6 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     // padding.\n                     match tys.kind {\n                         ty::Int(..) | ty::Uint(..) | ty::Float(..) => true,\n-                        ty::Tuple(tys) if tys.len() == 0 => true,\n-                        ty::Adt(adt_def, _)\n-                            if adt_def.is_struct() && adt_def.all_fields().next().is_none() =>\n-                        {\n-                            true\n-                        }\n                         _ => false,\n                     }\n                 } =>\n@@ -609,11 +599,6 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 }\n                 // This is the element type size.\n                 let layout = self.ecx.layout_of(tys)?;\n-                // Empty tuples and fieldless structs (the only ZSTs that allow reaching this code)\n-                // have no data to be checked.\n-                if layout.is_zst() {\n-                    return Ok(());\n-                }\n                 // This is the size in bytes of the whole array.\n                 let size = layout.size * len;\n                 // Size is not 0, get a pointer.\n@@ -656,6 +641,13 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     }\n                 }\n             }\n+            // Fast path for arrays and slices of ZSTs. We only need to check a single ZST element\n+            // of an array and not all of them, because there's only a single value of a specific\n+            // ZST type, so either validation fails for all elements or none.\n+            ty::Array(tys, ..) | ty::Slice(tys) if self.ecx.layout_of(tys)?.is_zst() => {\n+                // Validate just the first element\n+                self.walk_aggregate(op, fields.take(1))?\n+            }\n             _ => {\n                 self.walk_aggregate(op, fields)? // default handler\n             }"}, {"sha": "5e42ba3279027953cefa1c0b7aa889d5804c7be7", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -7,7 +7,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(nll)]\n #![feature(in_band_lifetimes)]\n #![feature(inner_deref)]\n-#![feature(slice_patterns)]\n+#![cfg_attr(bootstrap, feature(slice_patterns))]\n #![feature(bool_to_option)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]"}, {"sha": "f4611c32e0a32a21bcb40794d66e3d0442d84ed4", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -418,7 +418,7 @@ fn check_recursion_limit<'tcx>(\n     let recursion_depth = recursion_depths.get(&def_id).cloned().unwrap_or(0);\n     debug!(\" => recursion depth={}\", recursion_depth);\n \n-    let recursion_depth = if Some(def_id) == tcx.lang_items().drop_in_place_fn() {\n+    let adjusted_recursion_depth = if Some(def_id) == tcx.lang_items().drop_in_place_fn() {\n         // HACK: drop_in_place creates tight monomorphization loops. Give\n         // it more margin.\n         recursion_depth / 4\n@@ -429,7 +429,7 @@ fn check_recursion_limit<'tcx>(\n     // Code that needs to instantiate the same function recursively\n     // more than the recursion limit is assumed to be causing an\n     // infinite expansion.\n-    if recursion_depth > *tcx.sess.recursion_limit.get() {\n+    if adjusted_recursion_depth > *tcx.sess.recursion_limit.get() {\n         let error = format!(\"reached the recursion limit while instantiating `{}`\", instance);\n         if let Some(hir_id) = tcx.hir().as_local_hir_id(def_id) {\n             tcx.sess.span_fatal(tcx.hir().span(hir_id), &error);\n@@ -954,7 +954,7 @@ impl ItemLikeVisitor<'v> for RootCollector<'_, 'v> {\n                 // Nothing to do, just keep recursing.\n             }\n \n-            hir::ItemKind::Impl(..) => {\n+            hir::ItemKind::Impl { .. } => {\n                 if self.mode == MonoItemCollectionMode::Eager {\n                     create_mono_items_for_default_impls(self.tcx, item, self.output);\n                 }\n@@ -1098,7 +1098,7 @@ fn create_mono_items_for_default_impls<'tcx>(\n     output: &mut Vec<MonoItem<'tcx>>,\n ) {\n     match item.kind {\n-        hir::ItemKind::Impl(_, _, _, ref generics, .., ref impl_item_refs) => {\n+        hir::ItemKind::Impl { ref generics, ref items, .. } => {\n             for param in generics.params {\n                 match param.kind {\n                     hir::GenericParamKind::Lifetime { .. } => {}\n@@ -1119,7 +1119,7 @@ fn create_mono_items_for_default_impls<'tcx>(\n                 let param_env = ty::ParamEnv::reveal_all();\n                 let trait_ref = tcx.normalize_erasing_regions(param_env, trait_ref);\n                 let overridden_methods: FxHashSet<_> =\n-                    impl_item_refs.iter().map(|iiref| iiref.ident.modern()).collect();\n+                    items.iter().map(|iiref| iiref.ident.modern()).collect();\n                 for method in tcx.provided_trait_methods(trait_ref.def_id) {\n                     if overridden_methods.contains(&method.ident.modern()) {\n                         continue;"}, {"sha": "bd398c6e5b449e0a4ebbd3dcbcd5dc15cf820a60", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 53, "deletions": 35, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -14,6 +14,7 @@ use rustc::mir::{\n     SourceInfo, SourceScope, SourceScopeData, Statement, StatementKind, Terminator, TerminatorKind,\n     UnOp, RETURN_PLACE,\n };\n+use rustc::traits::TraitQueryMode;\n use rustc::ty::layout::{\n     HasDataLayout, HasTyCtxt, LayoutError, LayoutOf, Size, TargetDataLayout, TyLayout,\n };\n@@ -29,9 +30,9 @@ use syntax::ast::Mutability;\n \n use crate::const_eval::error_to_const_error;\n use crate::interpret::{\n-    self, intern_const_alloc_recursive, AllocId, Allocation, Frame, ImmTy, Immediate, InterpCx,\n-    LocalState, LocalValue, Memory, MemoryKind, OpTy, Operand as InterpOperand, PlaceTy, Pointer,\n-    ScalarMaybeUndef, StackPopCleanup,\n+    self, intern_const_alloc_recursive, AllocId, Allocation, Frame, ImmTy, Immediate, InternKind,\n+    InterpCx, LocalState, LocalValue, Memory, MemoryKind, OpTy, Operand as InterpOperand, PlaceTy,\n+    Pointer, ScalarMaybeUndef, StackPopCleanup,\n };\n use crate::transform::{MirPass, MirSource};\n \n@@ -74,6 +75,46 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n             return;\n         }\n \n+        // Check if it's even possible to satisfy the 'where' clauses\n+        // for this item.\n+        // This branch will never be taken for any normal function.\n+        // However, it's possible to `#!feature(trivial_bounds)]` to write\n+        // a function with impossible to satisfy clauses, e.g.:\n+        // `fn foo() where String: Copy {}`\n+        //\n+        // We don't usually need to worry about this kind of case,\n+        // since we would get a compilation error if the user tried\n+        // to call it. However, since we can do const propagation\n+        // even without any calls to the function, we need to make\n+        // sure that it even makes sense to try to evaluate the body.\n+        // If there are unsatisfiable where clauses, then all bets are\n+        // off, and we just give up.\n+        //\n+        // Note that we use TraitQueryMode::Canonical here, which causes\n+        // us to treat overflow like any other error. This is because we\n+        // are \"speculatively\" evaluating this item with the default substs.\n+        // While this usually succeeds, it may fail with tricky impls\n+        // (e.g. the typenum crate). Const-propagation is fundamentally\n+        // \"best-effort\", and does not affect correctness in any way.\n+        // Therefore, it's perfectly fine to just \"give up\" if we're\n+        // unable to check the bounds with the default substs.\n+        //\n+        // False negatives (failing to run const-prop on something when we actually\n+        // could) are fine. However, false positives (running const-prop on\n+        // an item with unsatisfiable bounds) can lead to us generating invalid\n+        // MIR.\n+        if !tcx.substitute_normalize_and_test_predicates((\n+            source.def_id(),\n+            InternalSubsts::identity_for_item(tcx, source.def_id()),\n+            TraitQueryMode::Canonical,\n+        )) {\n+            trace!(\n+                \"ConstProp skipped for item with unsatisfiable predicates: {:?}\",\n+                source.def_id()\n+            );\n+            return;\n+        }\n+\n         trace!(\"ConstProp starting for {:?}\", source.def_id());\n \n         let dummy_body = &Body::new(\n@@ -247,8 +288,6 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n     }\n }\n \n-type Const<'tcx> = OpTy<'tcx>;\n-\n /// Finds optimization opportunities on the MIR.\n struct ConstPropagator<'mir, 'tcx> {\n     ecx: InterpCx<'mir, 'tcx, ConstPropMachine>,\n@@ -346,7 +385,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n     }\n \n-    fn get_const(&self, local: Local) -> Option<Const<'tcx>> {\n+    fn get_const(&self, local: Local) -> Option<OpTy<'tcx>> {\n         if local == RETURN_PLACE {\n             // Try to read the return place as an immediate so that if it is representable as a\n             // scalar, we can handle it as such, but otherwise, just return the value as is.\n@@ -425,11 +464,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         r\n     }\n \n-    fn eval_constant(\n-        &mut self,\n-        c: &Constant<'tcx>,\n-        source_info: SourceInfo,\n-    ) -> Option<Const<'tcx>> {\n+    fn eval_constant(&mut self, c: &Constant<'tcx>, source_info: SourceInfo) -> Option<OpTy<'tcx>> {\n         self.ecx.tcx.span = c.span;\n \n         // FIXME we need to revisit this for #67176\n@@ -469,12 +504,12 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n     }\n \n-    fn eval_place(&mut self, place: &Place<'tcx>, source_info: SourceInfo) -> Option<Const<'tcx>> {\n+    fn eval_place(&mut self, place: &Place<'tcx>, source_info: SourceInfo) -> Option<OpTy<'tcx>> {\n         trace!(\"eval_place(place={:?})\", place);\n         self.use_ecx(source_info, |this| this.ecx.eval_place_to_op(place, None))\n     }\n \n-    fn eval_operand(&mut self, op: &Operand<'tcx>, source_info: SourceInfo) -> Option<Const<'tcx>> {\n+    fn eval_operand(&mut self, op: &Operand<'tcx>, source_info: SourceInfo) -> Option<OpTy<'tcx>> {\n         match *op {\n             Operand::Constant(ref c) => self.eval_constant(c, source_info),\n             Operand::Move(ref place) | Operand::Copy(ref place) => {\n@@ -595,28 +630,11 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                 self.check_binary_op(*op, left, right, source_info, place_layout, overflow_check)?;\n             }\n \n-            // Work around: avoid ICE in miri. FIXME(wesleywiser)\n-            // The Miri engine ICEs when taking a reference to an uninitialized unsized\n-            // local. There's nothing it can do here: taking a reference needs an allocation\n-            // which needs to know the size. Normally that's okay as during execution\n-            // (e.g. for CTFE) it can never happen. But here in const_prop\n-            // unknown data is uninitialized, so if e.g. a function argument is unsized\n-            // and has a reference taken, we get an ICE.\n+            // Do not try creating references (#67862)\n             Rvalue::Ref(_, _, place_ref) => {\n-                trace!(\"checking Ref({:?})\", place_ref);\n+                trace!(\"skipping Ref({:?})\", place_ref);\n \n-                if let Some(local) = place_ref.as_local() {\n-                    let alive = if let LocalValue::Live(_) = self.ecx.frame().locals[local].value {\n-                        true\n-                    } else {\n-                        false\n-                    };\n-\n-                    if !alive {\n-                        trace!(\"skipping Ref({:?}) to uninitialized local\", place);\n-                        return None;\n-                    }\n-                }\n+                return None;\n             }\n \n             _ => {}\n@@ -640,7 +658,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     fn replace_with_const(\n         &mut self,\n         rval: &mut Rvalue<'tcx>,\n-        value: Const<'tcx>,\n+        value: OpTy<'tcx>,\n         source_info: SourceInfo,\n     ) {\n         trace!(\"attepting to replace {:?} with {:?}\", rval, value);\n@@ -726,7 +744,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             )) => l.is_bits() && r.is_bits(),\n             interpret::Operand::Indirect(_) if mir_opt_level >= 2 => {\n                 let mplace = op.assert_mem_place(&self.ecx);\n-                intern_const_alloc_recursive(&mut self.ecx, None, mplace, false)\n+                intern_const_alloc_recursive(&mut self.ecx, InternKind::ConstProp, mplace, false)\n                     .expect(\"failed to intern alloc\");\n                 true\n             }"}, {"sha": "d927553c72e8b4afdc1bd9eb2b31ba70688d9555", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -309,21 +309,22 @@ fn check_terminator(\n ) -> McfResult {\n     let span = terminator.source_info.span;\n     match &terminator.kind {\n-        TerminatorKind::Goto { .. } | TerminatorKind::Return | TerminatorKind::Resume => Ok(()),\n+        TerminatorKind::FalseEdges { .. }\n+        | TerminatorKind::FalseUnwind { .. }\n+        | TerminatorKind::Goto { .. }\n+        | TerminatorKind::Return\n+        | TerminatorKind::Resume => Ok(()),\n \n         TerminatorKind::Drop { location, .. } => check_place(tcx, location, span, def_id, body),\n         TerminatorKind::DropAndReplace { location, value, .. } => {\n             check_place(tcx, location, span, def_id, body)?;\n             check_operand(tcx, value, span, def_id, body)\n         }\n \n-        TerminatorKind::FalseEdges { .. } | TerminatorKind::SwitchInt { .. }\n-            if !feature_allowed(tcx, def_id, sym::const_if_match) =>\n-        {\n+        TerminatorKind::SwitchInt { .. } if !feature_allowed(tcx, def_id, sym::const_if_match) => {\n             Err((span, \"loops and conditional expressions are not stable in const fn\".into()))\n         }\n \n-        TerminatorKind::FalseEdges { .. } => Ok(()),\n         TerminatorKind::SwitchInt { discr, switch_ty: _, values: _, targets: _ } => {\n             check_operand(tcx, discr, span, def_id, body)\n         }\n@@ -367,13 +368,5 @@ fn check_terminator(\n         TerminatorKind::Assert { cond, expected: _, msg: _, target: _, cleanup: _ } => {\n             check_operand(tcx, cond, span, def_id, body)\n         }\n-\n-        TerminatorKind::FalseUnwind { .. } if feature_allowed(tcx, def_id, sym::const_loop) => {\n-            Ok(())\n-        }\n-\n-        TerminatorKind::FalseUnwind { .. } => {\n-            Err((span, \"loops are not allowed in const fn\".into()))\n-        }\n     }\n }"}, {"sha": "44ff493b5b4f0370f99bc1047e2af32b8521f2ea", "filename": "src/librustc_mir_build/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -65,7 +65,7 @@ fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> BodyAndCache<'_> {\n         } else if cx.body_owner_kind.is_fn_or_closure() {\n             // fetch the fully liberated fn signature (that is, all bound\n             // types/lifetimes replaced)\n-            let fn_sig = cx.tables().liberated_fn_sigs()[id].clone();\n+            let fn_sig = cx.tables().liberated_fn_sigs()[id];\n             let fn_def_id = tcx.hir().local_def_id(id);\n \n             let ty = tcx.type_of(fn_def_id);"}, {"sha": "d6786ea24797340d6ffcdc7416910b834a65c9a9", "filename": "src/librustc_mir_build/hair/cx/expr.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -411,18 +411,21 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n             let def_id = cx.tcx.hir().local_def_id(count.hir_id);\n             let substs = InternalSubsts::identity_for_item(cx.tcx, def_id);\n             let span = cx.tcx.def_span(def_id);\n-            let count =\n-                match cx.tcx.const_eval_resolve(cx.param_env, def_id, substs, None, Some(span)) {\n-                    Ok(cv) => cv.eval_usize(cx.tcx, cx.param_env),\n-                    Err(ErrorHandled::Reported) => 0,\n-                    Err(ErrorHandled::TooGeneric) => {\n-                        let span = cx.tcx.def_span(def_id);\n-                        cx.tcx\n-                            .sess\n-                            .span_err(span, \"array lengths can't depend on generic parameters\");\n-                        0\n-                    }\n-                };\n+            let count = match cx.tcx.const_eval_resolve(\n+                ty::ParamEnv::reveal_all(),\n+                def_id,\n+                substs,\n+                None,\n+                Some(span),\n+            ) {\n+                Ok(cv) => cv.eval_usize(cx.tcx, ty::ParamEnv::reveal_all()),\n+                Err(ErrorHandled::Reported) => 0,\n+                Err(ErrorHandled::TooGeneric) => {\n+                    let span = cx.tcx.def_span(def_id);\n+                    cx.tcx.sess.span_err(span, \"array lengths can't depend on generic parameters\");\n+                    0\n+                }\n+            };\n \n             ExprKind::Repeat { value: v.to_ref(), count }\n         }"}, {"sha": "42292d635bc75f65e83f9c7ee7d4d4cf899488f9", "filename": "src/librustc_mir_build/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir_build%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_mir_build%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Flib.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -5,7 +5,7 @@\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(crate_visibility_modifier)]\n-#![feature(slice_patterns)]\n+#![cfg_attr(bootstrap, feature(slice_patterns))]\n #![feature(bool_to_option)]\n #![recursion_limit = \"256\"]\n "}, {"sha": "08f4f210152dd5825b98abe38a7902896b0e0381", "filename": "src/librustc_parse/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_parse%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_parse%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flib.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -2,7 +2,7 @@\n \n #![feature(bool_to_option)]\n #![feature(crate_visibility_modifier)]\n-#![feature(slice_patterns)]\n+#![cfg_attr(bootstrap, feature(slice_patterns))]\n \n use syntax::ast;\n use syntax::print::pprust;"}, {"sha": "3d40b91a7bdc8e664f1d2bfe00f1c6a57a3123c7", "filename": "src/librustc_parse/parser/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fattr.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -236,8 +236,8 @@ impl<'a> Parser<'a> {\n             self.struct_span_err(lit.span, msg)\n                 .help(\n                     \"instead of using a suffixed literal \\\n-                                    (1u8, 1.0f32, etc.), use an unsuffixed version \\\n-                                    (1, 1.0, etc.).\",\n+                                    (`1u8`, `1.0f32`, etc.), use an unsuffixed version \\\n+                                    (`1`, `1.0`, etc.)\",\n                 )\n                 .emit()\n         }"}, {"sha": "1921a6c8506891d7da017a1abad514b0b6709522", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -634,15 +634,15 @@ impl<'a> Parser<'a> {\n                 let constness = constness.map(|c| c.node);\n                 let trait_ref = TraitRef { path, constness, ref_id: ty_first.id };\n \n-                ItemKind::Impl(\n+                ItemKind::Impl {\n                     unsafety,\n                     polarity,\n                     defaultness,\n                     generics,\n-                    Some(trait_ref),\n-                    ty_second,\n-                    impl_items,\n-                )\n+                    of_trait: Some(trait_ref),\n+                    self_ty: ty_second,\n+                    items: impl_items,\n+                }\n             }\n             None => {\n                 // Reject `impl const Type {}` here\n@@ -653,15 +653,15 @@ impl<'a> Parser<'a> {\n                 }\n \n                 // impl Type\n-                ItemKind::Impl(\n+                ItemKind::Impl {\n                     unsafety,\n                     polarity,\n                     defaultness,\n                     generics,\n-                    None,\n-                    ty_first,\n-                    impl_items,\n-                )\n+                    of_trait: None,\n+                    self_ty: ty_first,\n+                    items: impl_items,\n+                }\n             }\n         };\n "}, {"sha": "549acf67d38245038dad6c5d196a664f00e44d82", "filename": "src/librustc_parse/parser/pat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpat.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -209,13 +209,13 @@ impl<'a> Parser<'a> {\n         if let Ok(seq_snippet) = self.span_to_snippet(seq_span) {\n             err.span_suggestion(\n                 seq_span,\n-                \"try adding parentheses to match on a tuple..\",\n+                \"try adding parentheses to match on a tuple...\",\n                 format!(\"({})\", seq_snippet),\n                 Applicability::MachineApplicable,\n             )\n             .span_suggestion(\n                 seq_span,\n-                \"..or a vertical bar to match on multiple alternatives\",\n+                \"...or a vertical bar to match on multiple alternatives\",\n                 format!(\"{}\", seq_snippet.replace(\",\", \" |\")),\n                 Applicability::MachineApplicable,\n             );"}, {"sha": "065a3b14428c700f4691f6ba6721bf4f911cdd73", "filename": "src/librustc_parse/parser/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_parse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_parse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fty.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -500,7 +500,7 @@ impl<'a> Parser<'a> {\n             err.span_suggestion_short(\n                 lo.to(self.prev_span),\n                 \"remove the parentheses\",\n-                snippet.to_owned(),\n+                snippet,\n                 Applicability::MachineApplicable,\n             );\n         }"}, {"sha": "2ff9d744f2c4d771c782d03bd5854905d64e3dad", "filename": "src/librustc_passes/dead.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_passes%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_passes%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdead.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -405,10 +405,10 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n                     }\n                 }\n             }\n-            hir::ItemKind::Impl(.., ref opt_trait, _, impl_item_refs) => {\n-                for impl_item_ref in impl_item_refs {\n+            hir::ItemKind::Impl { ref of_trait, items, .. } => {\n+                for impl_item_ref in items {\n                     let impl_item = self.krate.impl_item(impl_item_ref.id);\n-                    if opt_trait.is_some()\n+                    if of_trait.is_some()\n                         || has_allow_dead_code_or_lang_attr(\n                             self.tcx,\n                             impl_item.hir_id,\n@@ -586,7 +586,7 @@ impl Visitor<'tcx> for DeadVisitor<'tcx> {\n                 | hir::ItemKind::Struct(..)\n                 | hir::ItemKind::Union(..)\n                 | hir::ItemKind::Trait(..)\n-                | hir::ItemKind::Impl(..) => {\n+                | hir::ItemKind::Impl { .. } => {\n                     // FIXME(66095): Because item.span is annotated with things\n                     // like expansion data, and ident.span isn't, we use the\n                     // def_span method if it's part of a macro invocation"}, {"sha": "8d220a3f695f28df454b1730c77d39958de80dda", "filename": "src/librustc_passes/diagnostic_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_passes%2Fdiagnostic_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_passes%2Fdiagnostic_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdiagnostic_items.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -73,7 +73,7 @@ fn collect_item(\n                 )),\n             };\n             if let Some(span) = tcx.hir().span_if_local(original_def_id) {\n-                err.span_note(span, \"first defined here.\");\n+                err.span_note(span, \"first defined here\");\n             } else {\n                 err.note(&format!(\n                     \"first defined in crate `{}`.\","}, {"sha": "d746f097928eaaccfe5ae29ab717f3e04ec3a7c5", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -7,7 +7,7 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n-#![feature(slice_patterns)]\n+#![cfg_attr(bootstrap, feature(slice_patterns))]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "667898046ac3623dfedcf05b7a331e5ecc5d8b76", "filename": "src/librustc_passes/reachable.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_passes%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_passes%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Freachable.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -35,7 +35,7 @@ fn item_might_be_inlined(tcx: TyCtxt<'tcx>, item: &hir::Item<'_>, attrs: Codegen\n         hir::ItemKind::Fn(ref sig, ..) if sig.header.is_const() => {\n             return true;\n         }\n-        hir::ItemKind::Impl(..) | hir::ItemKind::Fn(..) => {\n+        hir::ItemKind::Impl { .. } | hir::ItemKind::Fn(..) => {\n             let generics = tcx.generics_of(tcx.hir().local_def_id(item.hir_id));\n             generics.requires_monomorphization(tcx)\n         }\n@@ -181,7 +181,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                             // does too.\n                             let impl_hir_id = self.tcx.hir().as_local_hir_id(impl_did).unwrap();\n                             match self.tcx.hir().expect_item(impl_hir_id).kind {\n-                                hir::ItemKind::Impl(..) => {\n+                                hir::ItemKind::Impl { .. } => {\n                                     let generics = self.tcx.generics_of(impl_did);\n                                     generics.requires_monomorphization(self.tcx)\n                                 }\n@@ -266,7 +266,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     | hir::ItemKind::Static(..)\n                     | hir::ItemKind::Mod(..)\n                     | hir::ItemKind::ForeignMod(..)\n-                    | hir::ItemKind::Impl(..)\n+                    | hir::ItemKind::Impl { .. }\n                     | hir::ItemKind::Trait(..)\n                     | hir::ItemKind::TraitAlias(..)\n                     | hir::ItemKind::Struct(..)\n@@ -349,9 +349,9 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a, 'tcx\n         }\n \n         // We need only trait impls here, not inherent impls, and only non-exported ones\n-        if let hir::ItemKind::Impl(.., Some(ref trait_ref), _, ref impl_item_refs) = item.kind {\n+        if let hir::ItemKind::Impl { of_trait: Some(ref trait_ref), ref items, .. } = item.kind {\n             if !self.access_levels.is_reachable(item.hir_id) {\n-                self.worklist.extend(impl_item_refs.iter().map(|ii_ref| ii_ref.id.hir_id));\n+                self.worklist.extend(items.iter().map(|ii_ref| ii_ref.id.hir_id));\n \n                 let trait_def_id = match trait_ref.path.res {\n                     Res::Def(DefKind::Trait, def_id) => def_id,"}, {"sha": "b649f36f2fc589671854ed51b238d475b733f5ed", "filename": "src/librustc_passes/stability.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_passes%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_passes%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstability.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -91,7 +91,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n                 // deprecated_since and its reason.\n                 if let Some(parent_stab) = self.parent_stab {\n                     if parent_stab.rustc_depr.is_some() && stab.rustc_depr.is_none() {\n-                        stab.rustc_depr = parent_stab.rustc_depr.clone()\n+                        stab.rustc_depr = parent_stab.rustc_depr\n                     }\n                 }\n \n@@ -219,11 +219,11 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n             // they don't have their own stability. They still can be annotated as unstable\n             // and propagate this unstability to children, but this annotation is completely\n             // optional. They inherit stability from their parents when unannotated.\n-            hir::ItemKind::Impl(.., None, _, _) | hir::ItemKind::ForeignMod(..) => {\n+            hir::ItemKind::Impl { of_trait: None, .. } | hir::ItemKind::ForeignMod(..) => {\n                 self.in_trait_impl = false;\n                 kind = AnnotationKind::Container;\n             }\n-            hir::ItemKind::Impl(.., Some(_), _, _) => {\n+            hir::ItemKind::Impl { of_trait: Some(_), .. } => {\n                 self.in_trait_impl = true;\n             }\n             hir::ItemKind::Struct(ref sd, _) => {\n@@ -308,7 +308,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n             // they don't have their own stability. They still can be annotated as unstable\n             // and propagate this unstability to children, but this annotation is completely\n             // optional. They inherit stability from their parents when unannotated.\n-            hir::ItemKind::Impl(.., None, _, _) | hir::ItemKind::ForeignMod(..) => {}\n+            hir::ItemKind::Impl { of_trait: None, .. } | hir::ItemKind::ForeignMod(..) => {}\n \n             _ => self.check_missing_stability(i.hir_id, i.span, i.kind.descriptive_variant()),\n         }\n@@ -463,9 +463,9 @@ impl Visitor<'tcx> for Checker<'tcx> {\n             // For implementations of traits, check the stability of each item\n             // individually as it's possible to have a stable trait with unstable\n             // items.\n-            hir::ItemKind::Impl(.., Some(ref t), _, impl_item_refs) => {\n+            hir::ItemKind::Impl { of_trait: Some(ref t), items, .. } => {\n                 if let Res::Def(DefKind::Trait, trait_did) = t.path.res {\n-                    for impl_item_ref in impl_item_refs {\n+                    for impl_item_ref in items {\n                         let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n                         let trait_item_def_id = self\n                             .tcx"}, {"sha": "90a422a4dcf6cba48b0e96d031c9c006032f279a", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -255,8 +255,8 @@ fn def_id_visibility<'tcx>(\n                 Node::ImplItem(impl_item) => {\n                     match tcx.hir().get(tcx.hir().get_parent_item(hir_id)) {\n                         Node::Item(item) => match &item.kind {\n-                            hir::ItemKind::Impl(.., None, _, _) => &impl_item.vis,\n-                            hir::ItemKind::Impl(.., Some(trait_ref), _, _) => {\n+                            hir::ItemKind::Impl { of_trait: None, .. } => &impl_item.vis,\n+                            hir::ItemKind::Impl { of_trait: Some(trait_ref), .. } => {\n                                 return def_id_visibility(tcx, trait_ref.path.res.def_id());\n                             }\n                             kind => bug!(\"unexpected item kind: {:?}\", kind),\n@@ -686,7 +686,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n \n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         let inherited_item_level = match item.kind {\n-            hir::ItemKind::Impl(..) => {\n+            hir::ItemKind::Impl { .. } => {\n                 Option::<AccessLevel>::of_impl(item.hir_id, self.tcx, &self.access_levels)\n             }\n             // Foreign modules inherit level from parents.\n@@ -730,9 +730,9 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                     }\n                 }\n             }\n-            hir::ItemKind::Impl(.., ref trait_ref, _, impl_item_refs) => {\n-                for impl_item_ref in impl_item_refs {\n-                    if trait_ref.is_some() || impl_item_ref.vis.node.is_pub() {\n+            hir::ItemKind::Impl { ref of_trait, items, .. } => {\n+                for impl_item_ref in items {\n+                    if of_trait.is_some() || impl_item_ref.vis.node.is_pub() {\n                         self.update(impl_item_ref.id.hir_id, item_level);\n                     }\n                 }\n@@ -827,11 +827,11 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                 }\n             }\n             // Visit everything except for private impl items.\n-            hir::ItemKind::Impl(.., impl_item_refs) => {\n+            hir::ItemKind::Impl { items, .. } => {\n                 if item_level.is_some() {\n                     self.reach(item.hir_id, item_level).generics().predicates().ty().trait_ref();\n \n-                    for impl_item_ref in impl_item_refs {\n+                    for impl_item_ref in items {\n                         let impl_item_level = self.get(impl_item_ref.id.hir_id);\n                         if impl_item_level.is_some() {\n                             self.reach(impl_item_ref.id.hir_id, impl_item_level)\n@@ -1510,7 +1510,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n             // (i.e., we could just return here to not check them at\n             // all, or some worse estimation of whether an impl is\n             // publicly visible).\n-            hir::ItemKind::Impl(.., ref g, ref trait_ref, ref self_, impl_item_refs) => {\n+            hir::ItemKind::Impl { generics: ref g, ref of_trait, ref self_ty, items, .. } => {\n                 // `impl [... for] Private` is never visible.\n                 let self_contains_private;\n                 // `impl [... for] Public<...>`, but not `impl [... for]\n@@ -1525,15 +1525,15 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                         at_outer_type: true,\n                         outer_type_is_public_path: false,\n                     };\n-                    visitor.visit_ty(&self_);\n+                    visitor.visit_ty(&self_ty);\n                     self_contains_private = visitor.contains_private;\n                     self_is_public_path = visitor.outer_type_is_public_path;\n                 }\n \n                 // Miscellaneous info about the impl:\n \n                 // `true` iff this is `impl Private for ...`.\n-                let not_private_trait = trait_ref.as_ref().map_or(\n+                let not_private_trait = of_trait.as_ref().map_or(\n                     true, // no trait counts as public trait\n                     |tr| {\n                         let did = tr.path.res.def_id();\n@@ -1554,8 +1554,8 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                 // directly because we might have `impl<T: Foo<Private>> ...`,\n                 // and we shouldn't warn about the generics if all the methods\n                 // are private (because `T` won't be visible externally).\n-                let trait_or_some_public_method = trait_ref.is_some()\n-                    || impl_item_refs.iter().any(|impl_item_ref| {\n+                let trait_or_some_public_method = of_trait.is_some()\n+                    || items.iter().any(|impl_item_ref| {\n                         let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n                         match impl_item.kind {\n                             hir::ImplItemKind::Const(..) | hir::ImplItemKind::Method(..) => {\n@@ -1570,9 +1570,9 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                 if !self_contains_private && not_private_trait && trait_or_some_public_method {\n                     intravisit::walk_generics(self, g);\n \n-                    match *trait_ref {\n+                    match of_trait {\n                         None => {\n-                            for impl_item_ref in impl_item_refs {\n+                            for impl_item_ref in items {\n                                 // This is where we choose whether to walk down\n                                 // further into the impl to check its items. We\n                                 // should only walk into public items so that we\n@@ -1594,7 +1594,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                                 }\n                             }\n                         }\n-                        Some(ref tr) => {\n+                        Some(tr) => {\n                             // Any private types in a trait impl fall into three\n                             // categories.\n                             // 1. mentioned in the trait definition\n@@ -1611,19 +1611,19 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                             intravisit::walk_path(self, &tr.path);\n \n                             // Those in 3. are warned with this call.\n-                            for impl_item_ref in impl_item_refs {\n+                            for impl_item_ref in items {\n                                 let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n                                 if let hir::ImplItemKind::TyAlias(ref ty) = impl_item.kind {\n                                     self.visit_ty(ty);\n                                 }\n                             }\n                         }\n                     }\n-                } else if trait_ref.is_none() && self_is_public_path {\n+                } else if of_trait.is_none() && self_is_public_path {\n                     // `impl Public<Private> { ... }`. Any public static\n                     // methods will be visible as `Public::foo`.\n                     let mut found_pub_static = false;\n-                    for impl_item_ref in impl_item_refs {\n+                    for impl_item_ref in items {\n                         if self.item_is_public(&impl_item_ref.id.hir_id, &impl_item_ref.vis) {\n                             let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n                             match impl_item_ref.kind {\n@@ -1997,12 +1997,12 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n             // Subitems of inherent impls have their own publicity.\n             // A trait impl is public when both its type and its trait are public\n             // Subitems of trait impls have inherited publicity.\n-            hir::ItemKind::Impl(.., ref trait_ref, _, impl_item_refs) => {\n+            hir::ItemKind::Impl { ref of_trait, items, .. } => {\n                 let impl_vis = ty::Visibility::of_impl(item.hir_id, tcx, &Default::default());\n                 self.check(item.hir_id, impl_vis).generics().predicates();\n-                for impl_item_ref in impl_item_refs {\n+                for impl_item_ref in items {\n                     let impl_item = tcx.hir().impl_item(impl_item_ref.id);\n-                    let impl_item_vis = if trait_ref.is_none() {\n+                    let impl_item_vis = if of_trait.is_none() {\n                         min(\n                             ty::Visibility::from_hir(&impl_item.vis, item.hir_id, tcx),\n                             impl_vis,"}, {"sha": "40a89ef06745874dd99f89b16278d92355f9763f", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -815,7 +815,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             }\n \n             // These items do not add names to modules.\n-            ItemKind::Impl(..) | ItemKind::ForeignMod(..) | ItemKind::GlobalAsm(..) => {}\n+            ItemKind::Impl { .. } | ItemKind::ForeignMod(..) | ItemKind::GlobalAsm(..) => {}\n \n             ItemKind::MacroDef(..) | ItemKind::Mac(_) => unreachable!(),\n         }\n@@ -963,7 +963,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                             .session\n                             .struct_span_err(\n                                 attr.span,\n-                                \"`macro_use` is not supported on `extern crate self`\",\n+                                \"`#[macro_use]` is not supported on `extern crate self`\",\n                             )\n                             .emit();\n                     }\n@@ -1054,10 +1054,10 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     fn contains_macro_use(&mut self, attrs: &[ast::Attribute]) -> bool {\n         for attr in attrs {\n             if attr.check_name(sym::macro_escape) {\n-                let msg = \"macro_escape is a deprecated synonym for macro_use\";\n+                let msg = \"`#[macro_escape]` is a deprecated synonym for `#[macro_use]`\";\n                 let mut err = self.r.session.struct_span_warn(attr.span, msg);\n                 if let ast::AttrStyle::Inner = attr.style {\n-                    err.help(\"consider an outer attribute, `#[macro_use]` mod ...\").emit();\n+                    err.help(\"try an outer attribute: `#[macro_use]`\").emit();\n                 } else {\n                     err.emit();\n                 }\n@@ -1066,7 +1066,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             }\n \n             if !attr.is_word() {\n-                self.r.session.span_err(attr.span, \"arguments to macro_use are not allowed here\");\n+                self.r.session.span_err(attr.span, \"arguments to `macro_use` are not allowed here\");\n             }\n             return true;\n         }"}, {"sha": "696ba0e994c7dbd095481e2c47cdd8c60befc9a1", "filename": "src/librustc_resolve/def_collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_resolve%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_resolve%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdef_collector.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -104,7 +104,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n         // Pick the def data. This need not be unique, but the more\n         // information we encapsulate into, the better\n         let def_data = match &i.kind {\n-            ItemKind::Impl(..) => DefPathData::Impl,\n+            ItemKind::Impl { .. } => DefPathData::Impl,\n             ItemKind::Mod(..) if i.ident.name == kw::Invalid => {\n                 return visit::walk_item(self, i);\n             }"}, {"sha": "a433ae8ed676a5f26aee53da29efed1482b7ec1c", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 160, "deletions": 2, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -8,7 +8,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_feature::BUILTIN_ATTRIBUTES;\n use rustc_hir::def::Namespace::{self, *};\n-use rustc_hir::def::{self, DefKind, NonMacroAttrKind};\n+use rustc_hir::def::{self, CtorKind, CtorOf, DefKind, NonMacroAttrKind};\n use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::SourceMap;\n@@ -20,8 +20,9 @@ use syntax::util::lev_distance::find_best_match_for_name;\n \n use crate::imports::{ImportDirective, ImportDirectiveSubclass, ImportResolver};\n use crate::path_names_to_string;\n-use crate::VisResolutionError;\n+use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind};\n use crate::{BindingError, CrateLint, HasGenericParams, LegacyScope, Module, ModuleOrUniformRoot};\n+use crate::{NameBinding, NameBindingKind, PrivacyError, VisResolutionError};\n use crate::{ParentScope, PathResult, ResolutionError, Resolver, Scope, ScopeSet, Segment};\n \n use rustc_error_codes::*;\n@@ -802,6 +803,163 @@ impl<'a> Resolver<'a> {\n         }\n         false\n     }\n+\n+    fn binding_description(&self, b: &NameBinding<'_>, ident: Ident, from_prelude: bool) -> String {\n+        let res = b.res();\n+        if b.span.is_dummy() {\n+            let add_built_in = match b.res() {\n+                // These already contain the \"built-in\" prefix or look bad with it.\n+                Res::NonMacroAttr(..) | Res::PrimTy(..) | Res::ToolMod => false,\n+                _ => true,\n+            };\n+            let (built_in, from) = if from_prelude {\n+                (\"\", \" from prelude\")\n+            } else if b.is_extern_crate()\n+                && !b.is_import()\n+                && self.session.opts.externs.get(&ident.as_str()).is_some()\n+            {\n+                (\"\", \" passed with `--extern`\")\n+            } else if add_built_in {\n+                (\" built-in\", \"\")\n+            } else {\n+                (\"\", \"\")\n+            };\n+\n+            let article = if built_in.is_empty() { res.article() } else { \"a\" };\n+            format!(\n+                \"{a}{built_in} {thing}{from}\",\n+                a = article,\n+                thing = res.descr(),\n+                built_in = built_in,\n+                from = from\n+            )\n+        } else {\n+            let introduced = if b.is_import() { \"imported\" } else { \"defined\" };\n+            format!(\"the {thing} {introduced} here\", thing = res.descr(), introduced = introduced)\n+        }\n+    }\n+\n+    crate fn report_ambiguity_error(&self, ambiguity_error: &AmbiguityError<'_>) {\n+        let AmbiguityError { kind, ident, b1, b2, misc1, misc2 } = *ambiguity_error;\n+        let (b1, b2, misc1, misc2, swapped) = if b2.span.is_dummy() && !b1.span.is_dummy() {\n+            // We have to print the span-less alternative first, otherwise formatting looks bad.\n+            (b2, b1, misc2, misc1, true)\n+        } else {\n+            (b1, b2, misc1, misc2, false)\n+        };\n+\n+        let mut err = struct_span_err!(\n+            self.session,\n+            ident.span,\n+            E0659,\n+            \"`{ident}` is ambiguous ({why})\",\n+            ident = ident,\n+            why = kind.descr()\n+        );\n+        err.span_label(ident.span, \"ambiguous name\");\n+\n+        let mut could_refer_to = |b: &NameBinding<'_>, misc: AmbiguityErrorMisc, also: &str| {\n+            let what = self.binding_description(b, ident, misc == AmbiguityErrorMisc::FromPrelude);\n+            let note_msg = format!(\n+                \"`{ident}` could{also} refer to {what}\",\n+                ident = ident,\n+                also = also,\n+                what = what\n+            );\n+\n+            let thing = b.res().descr();\n+            let mut help_msgs = Vec::new();\n+            if b.is_glob_import()\n+                && (kind == AmbiguityKind::GlobVsGlob\n+                    || kind == AmbiguityKind::GlobVsExpanded\n+                    || kind == AmbiguityKind::GlobVsOuter && swapped != also.is_empty())\n+            {\n+                help_msgs.push(format!(\n+                    \"consider adding an explicit import of \\\n+                     `{ident}` to disambiguate\",\n+                    ident = ident\n+                ))\n+            }\n+            if b.is_extern_crate() && ident.span.rust_2018() {\n+                help_msgs.push(format!(\n+                    \"use `::{ident}` to refer to this {thing} unambiguously\",\n+                    ident = ident,\n+                    thing = thing,\n+                ))\n+            }\n+            if misc == AmbiguityErrorMisc::SuggestCrate {\n+                help_msgs.push(format!(\n+                    \"use `crate::{ident}` to refer to this {thing} unambiguously\",\n+                    ident = ident,\n+                    thing = thing,\n+                ))\n+            } else if misc == AmbiguityErrorMisc::SuggestSelf {\n+                help_msgs.push(format!(\n+                    \"use `self::{ident}` to refer to this {thing} unambiguously\",\n+                    ident = ident,\n+                    thing = thing,\n+                ))\n+            }\n+\n+            err.span_note(b.span, &note_msg);\n+            for (i, help_msg) in help_msgs.iter().enumerate() {\n+                let or = if i == 0 { \"\" } else { \"or \" };\n+                err.help(&format!(\"{}{}\", or, help_msg));\n+            }\n+        };\n+\n+        could_refer_to(b1, misc1, \"\");\n+        could_refer_to(b2, misc2, \" also\");\n+        err.emit();\n+    }\n+\n+    crate fn report_privacy_error(&self, privacy_error: &PrivacyError<'_>) {\n+        let PrivacyError { ident, binding, .. } = *privacy_error;\n+        let session = &self.session;\n+        let mk_struct_span_error = |is_constructor| {\n+            let mut descr = binding.res().descr().to_string();\n+            if is_constructor {\n+                descr += \" constructor\";\n+            }\n+            if binding.is_import() {\n+                descr += \" import\";\n+            }\n+\n+            let mut err =\n+                struct_span_err!(session, ident.span, E0603, \"{} `{}` is private\", descr, ident);\n+\n+            err.span_label(ident.span, &format!(\"this {} is private\", descr));\n+            err.span_note(\n+                session.source_map().def_span(binding.span),\n+                &format!(\"the {} `{}` is defined here\", descr, ident),\n+            );\n+\n+            err\n+        };\n+\n+        let mut err = if let NameBindingKind::Res(\n+            Res::Def(DefKind::Ctor(CtorOf::Struct, CtorKind::Fn), ctor_def_id),\n+            _,\n+        ) = binding.kind\n+        {\n+            let def_id = (&*self).parent(ctor_def_id).expect(\"no parent for a constructor\");\n+            if let Some(fields) = self.field_names.get(&def_id) {\n+                let mut err = mk_struct_span_error(true);\n+                let first_field = fields.first().expect(\"empty field list in the map\");\n+                err.span_label(\n+                    fields.iter().fold(first_field.span, |acc, field| acc.to(field.span)),\n+                    \"a constructor is private if any of the fields is private\",\n+                );\n+                err\n+            } else {\n+                mk_struct_span_error(false)\n+            }\n+        } else {\n+            mk_struct_span_error(false)\n+        };\n+\n+        err.emit();\n+    }\n }\n \n impl<'a, 'b> ImportResolver<'a, 'b> {"}, {"sha": "9f459834175c126a2584b81db962baefae7de960", "filename": "src/librustc_resolve/imports.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_resolve%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_resolve%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fimports.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -319,7 +319,11 @@ impl<'a> Resolver<'a> {\n                        // Remove this together with `PUB_USE_OF_PRIVATE_EXTERN_CRATE`\n                        !(self.last_import_segment && binding.is_extern_crate())\n                         {\n-                            self.privacy_errors.push(PrivacyError(path_span, ident, binding));\n+                            self.privacy_errors.push(PrivacyError {\n+                                ident,\n+                                binding,\n+                                dedup_span: path_span,\n+                            });\n                         }\n \n                         Ok(binding)\n@@ -718,7 +722,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         }\n \n         if !errors.is_empty() {\n-            self.throw_unresolved_import_error(errors.clone(), None);\n+            self.throw_unresolved_import_error(errors, None);\n         }\n     }\n "}, {"sha": "08cd9c4d1d53a54e424a7b46dd8c448b552fbf93", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -797,14 +797,14 @@ impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n                 self.resolve_adt(item, generics);\n             }\n \n-            ItemKind::Impl(.., ref generics, ref opt_trait_ref, ref self_type, ref impl_items) => {\n-                self.resolve_implementation(\n-                    generics,\n-                    opt_trait_ref,\n-                    &self_type,\n-                    item.id,\n-                    impl_items,\n-                )\n+            ItemKind::Impl {\n+                ref generics,\n+                ref of_trait,\n+                ref self_ty,\n+                items: ref impl_items,\n+                ..\n+            } => {\n+                self.resolve_implementation(generics, of_trait, &self_ty, item.id, impl_items);\n             }\n \n             ItemKind::Trait(.., ref generics, ref bounds, ref trait_items) => {"}, {"sha": "60a0049f5da379c29d990ca6913dc4fcb4e20c11", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 11, "deletions": 153, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -2,12 +2,9 @@\n //!\n //! Module structure of the crate is built here.\n //! Paths in macros, imports, expressions, types, patterns are resolved here.\n-//! Label names are resolved here as well.\n+//! Label and lifetime names are resolved here as well.\n //!\n //! Type-relative name resolution (methods, fields, associated items) happens in `librustc_typeck`.\n-//! Lifetime names are resolved in `librustc/middle/resolve_lifetime.rs`.\n-\n-// ignore-tidy-filelength\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![feature(bool_to_option)]\n@@ -33,7 +30,7 @@ use rustc_data_structures::sync::Lrc;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_expand::base::SyntaxExtension;\n use rustc_hir::def::Namespace::*;\n-use rustc_hir::def::{self, CtorKind, CtorOf, DefKind, NonMacroAttrKind, PartialRes};\n+use rustc_hir::def::{self, CtorOf, DefKind, NonMacroAttrKind, PartialRes};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::PrimTy::{self, Bool, Char, Float, Int, Str, Uint};\n use rustc_hir::{GlobMap, TraitMap};\n@@ -604,7 +601,11 @@ impl<'a> NameBindingKind<'a> {\n     }\n }\n \n-struct PrivacyError<'a>(Span, Ident, &'a NameBinding<'a>);\n+struct PrivacyError<'a> {\n+    ident: Ident,\n+    binding: &'a NameBinding<'a>,\n+    dedup_span: Span,\n+}\n \n struct UseError<'a> {\n     err: DiagnosticBuilder<'a>,\n@@ -2006,7 +2007,7 @@ impl<'a> Resolver<'a> {\n                             continue;\n                         }\n                     }\n-                    let msg = \"there are too many initial `super`s.\".to_string();\n+                    let msg = \"there are too many leading `super` keywords\".to_string();\n                     return PathResult::Failed {\n                         span: ident.span,\n                         label: msg,\n@@ -2446,115 +2447,6 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn binding_description(&self, b: &NameBinding<'_>, ident: Ident, from_prelude: bool) -> String {\n-        let res = b.res();\n-        if b.span.is_dummy() {\n-            let add_built_in = match b.res() {\n-                // These already contain the \"built-in\" prefix or look bad with it.\n-                Res::NonMacroAttr(..) | Res::PrimTy(..) | Res::ToolMod => false,\n-                _ => true,\n-            };\n-            let (built_in, from) = if from_prelude {\n-                (\"\", \" from prelude\")\n-            } else if b.is_extern_crate()\n-                && !b.is_import()\n-                && self.session.opts.externs.get(&ident.as_str()).is_some()\n-            {\n-                (\"\", \" passed with `--extern`\")\n-            } else if add_built_in {\n-                (\" built-in\", \"\")\n-            } else {\n-                (\"\", \"\")\n-            };\n-\n-            let article = if built_in.is_empty() { res.article() } else { \"a\" };\n-            format!(\n-                \"{a}{built_in} {thing}{from}\",\n-                a = article,\n-                thing = res.descr(),\n-                built_in = built_in,\n-                from = from\n-            )\n-        } else {\n-            let introduced = if b.is_import() { \"imported\" } else { \"defined\" };\n-            format!(\"the {thing} {introduced} here\", thing = res.descr(), introduced = introduced)\n-        }\n-    }\n-\n-    fn report_ambiguity_error(&self, ambiguity_error: &AmbiguityError<'_>) {\n-        let AmbiguityError { kind, ident, b1, b2, misc1, misc2 } = *ambiguity_error;\n-        let (b1, b2, misc1, misc2, swapped) = if b2.span.is_dummy() && !b1.span.is_dummy() {\n-            // We have to print the span-less alternative first, otherwise formatting looks bad.\n-            (b2, b1, misc2, misc1, true)\n-        } else {\n-            (b1, b2, misc1, misc2, false)\n-        };\n-\n-        let mut err = struct_span_err!(\n-            self.session,\n-            ident.span,\n-            E0659,\n-            \"`{ident}` is ambiguous ({why})\",\n-            ident = ident,\n-            why = kind.descr()\n-        );\n-        err.span_label(ident.span, \"ambiguous name\");\n-\n-        let mut could_refer_to = |b: &NameBinding<'_>, misc: AmbiguityErrorMisc, also: &str| {\n-            let what = self.binding_description(b, ident, misc == AmbiguityErrorMisc::FromPrelude);\n-            let note_msg = format!(\n-                \"`{ident}` could{also} refer to {what}\",\n-                ident = ident,\n-                also = also,\n-                what = what\n-            );\n-\n-            let thing = b.res().descr();\n-            let mut help_msgs = Vec::new();\n-            if b.is_glob_import()\n-                && (kind == AmbiguityKind::GlobVsGlob\n-                    || kind == AmbiguityKind::GlobVsExpanded\n-                    || kind == AmbiguityKind::GlobVsOuter && swapped != also.is_empty())\n-            {\n-                help_msgs.push(format!(\n-                    \"consider adding an explicit import of \\\n-                     `{ident}` to disambiguate\",\n-                    ident = ident\n-                ))\n-            }\n-            if b.is_extern_crate() && ident.span.rust_2018() {\n-                help_msgs.push(format!(\n-                    \"use `::{ident}` to refer to this {thing} unambiguously\",\n-                    ident = ident,\n-                    thing = thing,\n-                ))\n-            }\n-            if misc == AmbiguityErrorMisc::SuggestCrate {\n-                help_msgs.push(format!(\n-                    \"use `crate::{ident}` to refer to this {thing} unambiguously\",\n-                    ident = ident,\n-                    thing = thing,\n-                ))\n-            } else if misc == AmbiguityErrorMisc::SuggestSelf {\n-                help_msgs.push(format!(\n-                    \"use `self::{ident}` to refer to this {thing} unambiguously\",\n-                    ident = ident,\n-                    thing = thing,\n-                ))\n-            }\n-\n-            err.span_note(b.span, &note_msg);\n-            for (i, help_msg) in help_msgs.iter().enumerate() {\n-                let or = if i == 0 { \"\" } else { \"or \" };\n-                err.help(&format!(\"{}{}\", or, help_msg));\n-            }\n-        };\n-\n-        could_refer_to(b1, misc1, \"\");\n-        could_refer_to(b2, misc2, \" also\");\n-        err.emit();\n-    }\n-\n     fn report_errors(&mut self, krate: &Crate) {\n         self.report_with_use_injections(krate);\n \n@@ -2575,43 +2467,9 @@ impl<'a> Resolver<'a> {\n         }\n \n         let mut reported_spans = FxHashSet::default();\n-        for &PrivacyError(dedup_span, ident, binding) in &self.privacy_errors {\n-            if reported_spans.insert(dedup_span) {\n-                let session = &self.session;\n-                let mk_struct_span_error = |is_constructor| {\n-                    struct_span_err!(\n-                        session,\n-                        ident.span,\n-                        E0603,\n-                        \"{}{} `{}` is private\",\n-                        binding.res().descr(),\n-                        if is_constructor { \" constructor\" } else { \"\" },\n-                        ident.name,\n-                    )\n-                };\n-\n-                let mut err = if let NameBindingKind::Res(\n-                    Res::Def(DefKind::Ctor(CtorOf::Struct, CtorKind::Fn), ctor_def_id),\n-                    _,\n-                ) = binding.kind\n-                {\n-                    let def_id = (&*self).parent(ctor_def_id).expect(\"no parent for a constructor\");\n-                    if let Some(fields) = self.field_names.get(&def_id) {\n-                        let mut err = mk_struct_span_error(true);\n-                        let first_field = fields.first().expect(\"empty field list in the map\");\n-                        err.span_label(\n-                            fields.iter().fold(first_field.span, |acc, field| acc.to(field.span)),\n-                            \"a constructor is private if any of the fields is private\",\n-                        );\n-                        err\n-                    } else {\n-                        mk_struct_span_error(false)\n-                    }\n-                } else {\n-                    mk_struct_span_error(false)\n-                };\n-\n-                err.emit();\n+        for error in &self.privacy_errors {\n+            if reported_spans.insert(error.dedup_span) {\n+                self.report_privacy_error(error);\n             }\n         }\n     }"}, {"sha": "5fae8f33187435d06d4edda9d3db4ba12f9026a9", "filename": "src/librustc_resolve/lifetimes.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_resolve%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_resolve%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flifetimes.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -416,11 +416,11 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             | hir::ItemKind::Union(_, ref generics)\n             | hir::ItemKind::Trait(_, _, ref generics, ..)\n             | hir::ItemKind::TraitAlias(ref generics, ..)\n-            | hir::ItemKind::Impl(_, _, _, ref generics, ..) => {\n+            | hir::ItemKind::Impl { ref generics, .. } => {\n                 // Impls permit `'_` to be used and it is equivalent to \"some fresh lifetime name\".\n                 // This is not true for other kinds of items.x\n                 let track_lifetime_uses = match item.kind {\n-                    hir::ItemKind::Impl(..) => true,\n+                    hir::ItemKind::Impl { .. } => true,\n                     _ => false,\n                 };\n                 // These kinds of items have only early-bound lifetime parameters.\n@@ -1638,7 +1638,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n             match parent.kind {\n                 hir::ItemKind::Trait(_, _, ref generics, ..)\n-                | hir::ItemKind::Impl(_, _, _, ref generics, ..) => {\n+                | hir::ItemKind::Impl { ref generics, .. } => {\n                     index += generics.params.len() as u32;\n                 }\n                 _ => {}\n@@ -2067,12 +2067,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n \n             Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Method(_, body), .. }) => {\n-                if let hir::ItemKind::Impl(.., ref self_ty, ref impl_items) =\n+                if let hir::ItemKind::Impl { ref self_ty, ref items, .. } =\n                     self.tcx.hir().expect_item(self.tcx.hir().get_parent_item(parent)).kind\n                 {\n                     impl_self = Some(self_ty);\n                     assoc_item_kind =\n-                        impl_items.iter().find(|ii| ii.id.hir_id == parent).map(|ii| ii.kind);\n+                        items.iter().find(|ii| ii.id.hir_id == parent).map(|ii| ii.kind);\n                 }\n                 Some(body)\n             }"}, {"sha": "d252fc542c325ca4bc1553a5695cf48b85617e51", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1300,8 +1300,8 @@ impl<'l, 'tcx> Visitor<'l> for DumpVisitor<'l, 'tcx> {\n                 self.process_struct(item, def, ty_params)\n             }\n             Enum(ref def, ref ty_params) => self.process_enum(item, def, ty_params),\n-            Impl(.., ref ty_params, ref trait_ref, ref typ, ref impl_items) => {\n-                self.process_impl(item, ty_params, trait_ref, &typ, impl_items)\n+            Impl { ref generics, ref of_trait, ref self_ty, ref items, .. } => {\n+                self.process_impl(item, generics, of_trait, &self_ty, items)\n             }\n             Trait(_, _, ref generics, ref trait_refs, ref methods) => {\n                 self.process_trait(item, generics, trait_refs, methods)"}, {"sha": "537fe198a0c39f944cbd17924e644bf8c455d14d", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -305,8 +305,8 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                     attributes: lower_attributes(item.attrs.clone(), self),\n                 }))\n             }\n-            ast::ItemKind::Impl(.., ref trait_ref, ref typ, ref impls) => {\n-                if let ast::TyKind::Path(None, ref path) = typ.kind {\n+            ast::ItemKind::Impl { ref of_trait, ref self_ty, ref items, .. } => {\n+                if let ast::TyKind::Path(None, ref path) = self_ty.kind {\n                     // Common case impl for a struct or something basic.\n                     if generated_code(path.span) {\n                         return None;\n@@ -317,29 +317,29 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                     let impl_id = self.next_impl_id();\n                     let span = self.span_from_span(sub_span);\n \n-                    let type_data = self.lookup_def_id(typ.id);\n+                    let type_data = self.lookup_def_id(self_ty.id);\n                     type_data.map(|type_data| {\n                         Data::RelationData(\n                             Relation {\n                                 kind: RelationKind::Impl { id: impl_id },\n                                 span: span.clone(),\n                                 from: id_from_def_id(type_data),\n-                                to: trait_ref\n+                                to: of_trait\n                                     .as_ref()\n                                     .and_then(|t| self.lookup_def_id(t.ref_id))\n                                     .map(id_from_def_id)\n                                     .unwrap_or_else(|| null_id()),\n                             },\n                             Impl {\n                                 id: impl_id,\n-                                kind: match *trait_ref {\n+                                kind: match *of_trait {\n                                     Some(_) => ImplKind::Direct,\n                                     None => ImplKind::Inherent,\n                                 },\n                                 span: span,\n                                 value: String::new(),\n                                 parent: None,\n-                                children: impls\n+                                children: items\n                                     .iter()\n                                     .map(|i| id_from_node_id(i.id, self))\n                                     .collect(),\n@@ -405,9 +405,9 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n         {\n             Some(impl_id) => match self.tcx.hir().get_if_local(impl_id) {\n                 Some(Node::Item(item)) => match item.kind {\n-                    hir::ItemKind::Impl(.., ref ty, _) => {\n+                    hir::ItemKind::Impl { ref self_ty, .. } => {\n                         let mut qualname = String::from(\"<\");\n-                        qualname.push_str(&self.tcx.hir().hir_to_pretty_string(ty.hir_id));\n+                        qualname.push_str(&self.tcx.hir().hir_to_pretty_string(self_ty.hir_id));\n \n                         let trait_id = self.tcx.trait_id_of_impl(impl_id);\n                         let mut decl_id = None;"}, {"sha": "779d3f55018d56f88980ead8dac6f8cbe25fa11f", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -482,15 +482,15 @@ impl Sig for ast::Item {\n \n                 Ok(sig)\n             }\n-            ast::ItemKind::Impl(\n+            ast::ItemKind::Impl {\n                 unsafety,\n                 polarity,\n                 defaultness,\n                 ref generics,\n-                ref opt_trait,\n-                ref ty,\n-                _,\n-            ) => {\n+                ref of_trait,\n+                ref self_ty,\n+                items: _,\n+            } => {\n                 let mut text = String::new();\n                 if let ast::Defaultness::Default = defaultness {\n                     text.push_str(\"default \");\n@@ -505,7 +505,7 @@ impl Sig for ast::Item {\n \n                 text.push(' ');\n \n-                let trait_sig = if let Some(ref t) = *opt_trait {\n+                let trait_sig = if let Some(ref t) = *of_trait {\n                     if polarity == ast::ImplPolarity::Negative {\n                         text.push('!');\n                     }\n@@ -517,7 +517,7 @@ impl Sig for ast::Item {\n                     text_sig(String::new())\n                 };\n \n-                let ty_sig = ty.make(offset + text.len(), id, scx)?;\n+                let ty_sig = self_ty.make(offset + text.len(), id, scx)?;\n                 text.push_str(&ty_sig.text);\n \n                 text.push_str(\" {}\");"}, {"sha": "2a0ed27b63b08f7c23f56ab2069a2265b0652fb7", "filename": "src/librustc_session/options.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_session%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_session%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Foptions.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -923,8 +923,12 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n     self_profile: SwitchWithOptPath = (SwitchWithOptPath::Disabled,\n         parse_switch_with_opt_path, [UNTRACKED],\n         \"run the self profiler and output the raw event data\"),\n+    // keep this in sync with the event filter names in librustc_data_structures/profiling.rs\n     self_profile_events: Option<Vec<String>> = (None, parse_opt_comma_list, [UNTRACKED],\n-        \"specifies which kinds of events get recorded by the self profiler\"),\n+        \"specifies which kinds of events get recorded by the self profiler;\n+        for example: `-Z self-profile-events=default,query-keys`\n+        all options: none, all, default, generic-activity, query-provider, query-cache-hit\n+                     query-blocked, incr-cache-load, query-keys\"),\n     emit_stack_sizes: bool = (false, parse_bool, [UNTRACKED],\n         \"emits a section containing stack size metadata\"),\n     plt: Option<bool> = (None, parse_opt_bool, [TRACKED],"}, {"sha": "9c7c0f0c8b0eca79346dd05357cf2fede430baa2", "filename": "src/librustc_span/source_map.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_span%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_span%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsource_map.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -473,20 +473,23 @@ impl SourceMap {\n         lo.line != hi.line\n     }\n \n-    pub fn span_to_lines(&self, sp: Span) -> FileLinesResult {\n-        debug!(\"span_to_lines(sp={:?})\", sp);\n-\n+    pub fn is_valid_span(&self, sp: Span) -> Result<(Loc, Loc), SpanLinesError> {\n         let lo = self.lookup_char_pos(sp.lo());\n         debug!(\"span_to_lines: lo={:?}\", lo);\n         let hi = self.lookup_char_pos(sp.hi());\n         debug!(\"span_to_lines: hi={:?}\", hi);\n-\n         if lo.file.start_pos != hi.file.start_pos {\n             return Err(SpanLinesError::DistinctSources(DistinctSources {\n                 begin: (lo.file.name.clone(), lo.file.start_pos),\n                 end: (hi.file.name.clone(), hi.file.start_pos),\n             }));\n         }\n+        Ok((lo, hi))\n+    }\n+\n+    pub fn span_to_lines(&self, sp: Span) -> FileLinesResult {\n+        debug!(\"span_to_lines(sp={:?})\", sp);\n+        let (lo, hi) = self.is_valid_span(sp)?;\n         assert!(hi.line >= lo.line);\n \n         let mut lines = Vec::with_capacity(hi.line - lo.line + 1);"}, {"sha": "84c6d720b8e00c5e58d36075fb671f16cf7a251a", "filename": "src/librustc_target/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_target%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_target%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Flib.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -11,7 +11,7 @@\n #![feature(box_syntax)]\n #![feature(bool_to_option)]\n #![feature(nll)]\n-#![feature(slice_patterns)]\n+#![cfg_attr(bootstrap, feature(slice_patterns))]\n \n #[macro_use]\n extern crate log;"}, {"sha": "0b18352df330764c0d37dd468494b300e8e3c1df", "filename": "src/librustc_traits/chalk_context/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -400,7 +400,7 @@ impl context::UnificationOps<ChalkArenas<'tcx>, ChalkArenas<'tcx>>\n         &mut self,\n         value: &Canonical<'tcx, InEnvironment<'tcx, Goal<'tcx>>>,\n     ) -> (Canonical<'tcx, InEnvironment<'tcx, Goal<'tcx>>>, UniverseMap) {\n-        (value.clone(), UniverseMap)\n+        (*value, UniverseMap)\n     }\n \n     fn invert_goal("}, {"sha": "7df27e67d5b1c2a64adcc75942be2295cf512d99", "filename": "src/librustc_traits/lowering/environment.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -195,8 +195,8 @@ crate fn environment(tcx: TyCtxt<'_>, def_id: DefId) -> Environment<'_> {\n         },\n \n         Node::Item(item) => match item.kind {\n-            ItemKind::Impl(.., Some(..), _, _) => NodeKind::TraitImpl,\n-            ItemKind::Impl(.., None, _, _) => NodeKind::InherentImpl,\n+            ItemKind::Impl { of_trait: Some(_), .. } => NodeKind::TraitImpl,\n+            ItemKind::Impl { of_trait: None, .. } => NodeKind::InherentImpl,\n             ItemKind::Fn(..) => NodeKind::Fn,\n             _ => NodeKind::Other,\n         },"}, {"sha": "fb0d93fe5ebb6a8ee899bbd941e8b5a47c71a5b2", "filename": "src/librustc_ty/Cargo.toml", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2FCargo.toml?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -0,0 +1,16 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_ty\"\n+version = \"0.0.0\"\n+edition = \"2018\"\n+\n+[lib]\n+name = \"rustc_ty\"\n+path = \"lib.rs\"\n+\n+[dependencies]\n+log = \"0.4\"\n+rustc = { path = \"../librustc\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_hir = { path = \"../librustc_hir\" }\n+rustc_span = { path = \"../librustc_span\" }"}, {"sha": "e5ec98743e0aeeaf989f23974f7376065031f461", "filename": "src/librustc_ty/lib.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_ty%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_ty%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Flib.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -0,0 +1,25 @@\n+//! Various checks\n+//!\n+//! # Note\n+//!\n+//! This API is completely unstable and subject to change.\n+\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![feature(bool_to_option)]\n+#![feature(in_band_lifetimes)]\n+#![feature(nll)]\n+#![cfg_attr(bootstrap, feature(slice_patterns))]\n+#![recursion_limit = \"256\"]\n+\n+#[macro_use]\n+extern crate rustc;\n+#[macro_use]\n+extern crate log;\n+\n+use rustc::ty::query::Providers;\n+\n+mod ty;\n+\n+pub fn provide(providers: &mut Providers<'_>) {\n+    ty::provide(providers);\n+}"}, {"sha": "d47e54366b55018b386d3324d7c66f7ca3af73b1", "filename": "src/librustc_ty/ty.rs", "status": "added", "additions": 369, "deletions": 0, "changes": 369, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_ty%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_ty%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fty.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -0,0 +1,369 @@\n+use rustc::hir::map as hir_map;\n+use rustc::session::CrateDisambiguator;\n+use rustc::traits::{self};\n+use rustc::ty::subst::Subst;\n+use rustc::ty::{self, ToPredicate, Ty, TyCtxt};\n+use rustc_data_structures::svh::Svh;\n+use rustc_hir as hir;\n+use rustc_hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use rustc_span::symbol::Symbol;\n+use rustc_span::Span;\n+\n+fn sized_constraint_for_ty(tcx: TyCtxt<'tcx>, adtdef: &ty::AdtDef, ty: Ty<'tcx>) -> Vec<Ty<'tcx>> {\n+    use ty::TyKind::*;\n+\n+    let result = match ty.kind {\n+        Bool | Char | Int(..) | Uint(..) | Float(..) | RawPtr(..) | Ref(..) | FnDef(..)\n+        | FnPtr(_) | Array(..) | Closure(..) | Generator(..) | Never => vec![],\n+\n+        Str | Dynamic(..) | Slice(_) | Foreign(..) | Error | GeneratorWitness(..) => {\n+            // these are never sized - return the target type\n+            vec![ty]\n+        }\n+\n+        Tuple(ref tys) => match tys.last() {\n+            None => vec![],\n+            Some(ty) => sized_constraint_for_ty(tcx, adtdef, ty.expect_ty()),\n+        },\n+\n+        Adt(adt, substs) => {\n+            // recursive case\n+            let adt_tys = adt.sized_constraint(tcx);\n+            debug!(\"sized_constraint_for_ty({:?}) intermediate = {:?}\", ty, adt_tys);\n+            adt_tys\n+                .iter()\n+                .map(|ty| ty.subst(tcx, substs))\n+                .flat_map(|ty| sized_constraint_for_ty(tcx, adtdef, ty))\n+                .collect()\n+        }\n+\n+        Projection(..) | Opaque(..) => {\n+            // must calculate explicitly.\n+            // FIXME: consider special-casing always-Sized projections\n+            vec![ty]\n+        }\n+\n+        UnnormalizedProjection(..) => bug!(\"only used with chalk-engine\"),\n+\n+        Param(..) => {\n+            // perf hack: if there is a `T: Sized` bound, then\n+            // we know that `T` is Sized and do not need to check\n+            // it on the impl.\n+\n+            let sized_trait = match tcx.lang_items().sized_trait() {\n+                Some(x) => x,\n+                _ => return vec![ty],\n+            };\n+            let sized_predicate = ty::Binder::dummy(ty::TraitRef {\n+                def_id: sized_trait,\n+                substs: tcx.mk_substs_trait(ty, &[]),\n+            })\n+            .to_predicate();\n+            let predicates = tcx.predicates_of(adtdef.did).predicates;\n+            if predicates.iter().any(|(p, _)| *p == sized_predicate) { vec![] } else { vec![ty] }\n+        }\n+\n+        Placeholder(..) | Bound(..) | Infer(..) => {\n+            bug!(\"unexpected type `{:?}` in sized_constraint_for_ty\", ty)\n+        }\n+    };\n+    debug!(\"sized_constraint_for_ty({:?}) = {:?}\", ty, result);\n+    result\n+}\n+\n+fn associated_item_from_trait_item_ref(\n+    tcx: TyCtxt<'_>,\n+    parent_def_id: DefId,\n+    parent_vis: &hir::Visibility<'_>,\n+    trait_item_ref: &hir::TraitItemRef,\n+) -> ty::AssocItem {\n+    let def_id = tcx.hir().local_def_id(trait_item_ref.id.hir_id);\n+    let (kind, has_self) = match trait_item_ref.kind {\n+        hir::AssocItemKind::Const => (ty::AssocKind::Const, false),\n+        hir::AssocItemKind::Method { has_self } => (ty::AssocKind::Method, has_self),\n+        hir::AssocItemKind::Type => (ty::AssocKind::Type, false),\n+        hir::AssocItemKind::OpaqueTy => bug!(\"only impls can have opaque types\"),\n+    };\n+\n+    ty::AssocItem {\n+        ident: trait_item_ref.ident,\n+        kind,\n+        // Visibility of trait items is inherited from their traits.\n+        vis: ty::Visibility::from_hir(parent_vis, trait_item_ref.id.hir_id, tcx),\n+        defaultness: trait_item_ref.defaultness,\n+        def_id,\n+        container: ty::TraitContainer(parent_def_id),\n+        method_has_self_argument: has_self,\n+    }\n+}\n+\n+fn associated_item_from_impl_item_ref(\n+    tcx: TyCtxt<'_>,\n+    parent_def_id: DefId,\n+    impl_item_ref: &hir::ImplItemRef<'_>,\n+) -> ty::AssocItem {\n+    let def_id = tcx.hir().local_def_id(impl_item_ref.id.hir_id);\n+    let (kind, has_self) = match impl_item_ref.kind {\n+        hir::AssocItemKind::Const => (ty::AssocKind::Const, false),\n+        hir::AssocItemKind::Method { has_self } => (ty::AssocKind::Method, has_self),\n+        hir::AssocItemKind::Type => (ty::AssocKind::Type, false),\n+        hir::AssocItemKind::OpaqueTy => (ty::AssocKind::OpaqueTy, false),\n+    };\n+\n+    ty::AssocItem {\n+        ident: impl_item_ref.ident,\n+        kind,\n+        // Visibility of trait impl items doesn't matter.\n+        vis: ty::Visibility::from_hir(&impl_item_ref.vis, impl_item_ref.id.hir_id, tcx),\n+        defaultness: impl_item_ref.defaultness,\n+        def_id,\n+        container: ty::ImplContainer(parent_def_id),\n+        method_has_self_argument: has_self,\n+    }\n+}\n+\n+fn associated_item(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssocItem {\n+    let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let parent_id = tcx.hir().get_parent_item(id);\n+    let parent_def_id = tcx.hir().local_def_id(parent_id);\n+    let parent_item = tcx.hir().expect_item(parent_id);\n+    match parent_item.kind {\n+        hir::ItemKind::Impl { ref items, .. } => {\n+            if let Some(impl_item_ref) = items.iter().find(|i| i.id.hir_id == id) {\n+                let assoc_item =\n+                    associated_item_from_impl_item_ref(tcx, parent_def_id, impl_item_ref);\n+                debug_assert_eq!(assoc_item.def_id, def_id);\n+                return assoc_item;\n+            }\n+        }\n+\n+        hir::ItemKind::Trait(.., ref trait_item_refs) => {\n+            if let Some(trait_item_ref) = trait_item_refs.iter().find(|i| i.id.hir_id == id) {\n+                let assoc_item = associated_item_from_trait_item_ref(\n+                    tcx,\n+                    parent_def_id,\n+                    &parent_item.vis,\n+                    trait_item_ref,\n+                );\n+                debug_assert_eq!(assoc_item.def_id, def_id);\n+                return assoc_item;\n+            }\n+        }\n+\n+        _ => {}\n+    }\n+\n+    span_bug!(\n+        parent_item.span,\n+        \"unexpected parent of trait or impl item or item not found: {:?}\",\n+        parent_item.kind\n+    )\n+}\n+\n+/// Calculates the `Sized` constraint.\n+///\n+/// In fact, there are only a few options for the types in the constraint:\n+///     - an obviously-unsized type\n+///     - a type parameter or projection whose Sizedness can't be known\n+///     - a tuple of type parameters or projections, if there are multiple\n+///       such.\n+///     - a Error, if a type contained itself. The representability\n+///       check should catch this case.\n+fn adt_sized_constraint(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AdtSizedConstraint<'_> {\n+    let def = tcx.adt_def(def_id);\n+\n+    let result = tcx.mk_type_list(\n+        def.variants\n+            .iter()\n+            .flat_map(|v| v.fields.last())\n+            .flat_map(|f| sized_constraint_for_ty(tcx, def, tcx.type_of(f.did))),\n+    );\n+\n+    debug!(\"adt_sized_constraint: {:?} => {:?}\", def, result);\n+\n+    ty::AdtSizedConstraint(result)\n+}\n+\n+fn associated_item_def_ids(tcx: TyCtxt<'_>, def_id: DefId) -> &[DefId] {\n+    let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let item = tcx.hir().expect_item(id);\n+    match item.kind {\n+        hir::ItemKind::Trait(.., ref trait_item_refs) => tcx.arena.alloc_from_iter(\n+            trait_item_refs\n+                .iter()\n+                .map(|trait_item_ref| trait_item_ref.id)\n+                .map(|id| tcx.hir().local_def_id(id.hir_id)),\n+        ),\n+        hir::ItemKind::Impl { ref items, .. } => tcx.arena.alloc_from_iter(\n+            items\n+                .iter()\n+                .map(|impl_item_ref| impl_item_ref.id)\n+                .map(|id| tcx.hir().local_def_id(id.hir_id)),\n+        ),\n+        hir::ItemKind::TraitAlias(..) => &[],\n+        _ => span_bug!(item.span, \"associated_item_def_ids: not impl or trait\"),\n+    }\n+}\n+\n+fn def_span(tcx: TyCtxt<'_>, def_id: DefId) -> Span {\n+    tcx.hir().span_if_local(def_id).unwrap()\n+}\n+\n+/// If the given `DefId` describes an item belonging to a trait,\n+/// returns the `DefId` of the trait that the trait item belongs to;\n+/// otherwise, returns `None`.\n+fn trait_of_item(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n+    tcx.opt_associated_item(def_id).and_then(|associated_item| match associated_item.container {\n+        ty::TraitContainer(def_id) => Some(def_id),\n+        ty::ImplContainer(_) => None,\n+    })\n+}\n+\n+/// See `ParamEnv` struct definition for details.\n+fn param_env(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ParamEnv<'_> {\n+    // The param_env of an impl Trait type is its defining function's param_env\n+    if let Some(parent) = ty::is_impl_trait_defn(tcx, def_id) {\n+        return param_env(tcx, parent);\n+    }\n+    // Compute the bounds on Self and the type parameters.\n+\n+    let ty::InstantiatedPredicates { predicates } =\n+        tcx.predicates_of(def_id).instantiate_identity(tcx);\n+\n+    // Finally, we have to normalize the bounds in the environment, in\n+    // case they contain any associated type projections. This process\n+    // can yield errors if the put in illegal associated types, like\n+    // `<i32 as Foo>::Bar` where `i32` does not implement `Foo`. We\n+    // report these errors right here; this doesn't actually feel\n+    // right to me, because constructing the environment feels like a\n+    // kind of a \"idempotent\" action, but I'm not sure where would be\n+    // a better place. In practice, we construct environments for\n+    // every fn once during type checking, and we'll abort if there\n+    // are any errors at that point, so after type checking you can be\n+    // sure that this will succeed without errors anyway.\n+\n+    let unnormalized_env = ty::ParamEnv::new(\n+        tcx.intern_predicates(&predicates),\n+        traits::Reveal::UserFacing,\n+        tcx.sess.opts.debugging_opts.chalk.then_some(def_id),\n+    );\n+\n+    let body_id = tcx.hir().as_local_hir_id(def_id).map_or(hir::DUMMY_HIR_ID, |id| {\n+        tcx.hir().maybe_body_owned_by(id).map_or(id, |body| body.hir_id)\n+    });\n+    let cause = traits::ObligationCause::misc(tcx.def_span(def_id), body_id);\n+    traits::normalize_param_env_or_error(tcx, def_id, unnormalized_env, cause)\n+}\n+\n+fn crate_disambiguator(tcx: TyCtxt<'_>, crate_num: CrateNum) -> CrateDisambiguator {\n+    assert_eq!(crate_num, LOCAL_CRATE);\n+    tcx.sess.local_crate_disambiguator()\n+}\n+\n+fn original_crate_name(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Symbol {\n+    assert_eq!(crate_num, LOCAL_CRATE);\n+    tcx.crate_name.clone()\n+}\n+\n+fn crate_hash(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Svh {\n+    assert_eq!(crate_num, LOCAL_CRATE);\n+    tcx.hir().crate_hash\n+}\n+\n+fn instance_def_size_estimate<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    instance_def: ty::InstanceDef<'tcx>,\n+) -> usize {\n+    use ty::InstanceDef;\n+\n+    match instance_def {\n+        InstanceDef::Item(..) | InstanceDef::DropGlue(..) => {\n+            let mir = tcx.instance_mir(instance_def);\n+            mir.basic_blocks().iter().map(|bb| bb.statements.len()).sum()\n+        }\n+        // Estimate the size of other compiler-generated shims to be 1.\n+        _ => 1,\n+    }\n+}\n+\n+/// If `def_id` is an issue 33140 hack impl, returns its self type; otherwise, returns `None`.\n+///\n+/// See [`ImplOverlapKind::Issue33140`] for more details.\n+fn issue33140_self_ty(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Ty<'_>> {\n+    debug!(\"issue33140_self_ty({:?})\", def_id);\n+\n+    let trait_ref = tcx\n+        .impl_trait_ref(def_id)\n+        .unwrap_or_else(|| bug!(\"issue33140_self_ty called on inherent impl {:?}\", def_id));\n+\n+    debug!(\"issue33140_self_ty({:?}), trait-ref={:?}\", def_id, trait_ref);\n+\n+    let is_marker_like = tcx.impl_polarity(def_id) == ty::ImplPolarity::Positive\n+        && tcx.associated_item_def_ids(trait_ref.def_id).is_empty();\n+\n+    // Check whether these impls would be ok for a marker trait.\n+    if !is_marker_like {\n+        debug!(\"issue33140_self_ty - not marker-like!\");\n+        return None;\n+    }\n+\n+    // impl must be `impl Trait for dyn Marker1 + Marker2 + ...`\n+    if trait_ref.substs.len() != 1 {\n+        debug!(\"issue33140_self_ty - impl has substs!\");\n+        return None;\n+    }\n+\n+    let predicates = tcx.predicates_of(def_id);\n+    if predicates.parent.is_some() || !predicates.predicates.is_empty() {\n+        debug!(\"issue33140_self_ty - impl has predicates {:?}!\", predicates);\n+        return None;\n+    }\n+\n+    let self_ty = trait_ref.self_ty();\n+    let self_ty_matches = match self_ty.kind {\n+        ty::Dynamic(ref data, ty::ReStatic) => data.principal().is_none(),\n+        _ => false,\n+    };\n+\n+    if self_ty_matches {\n+        debug!(\"issue33140_self_ty - MATCHES!\");\n+        Some(self_ty)\n+    } else {\n+        debug!(\"issue33140_self_ty - non-matching self type\");\n+        None\n+    }\n+}\n+\n+/// Check if a function is async.\n+fn asyncness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::IsAsync {\n+    let hir_id = tcx\n+        .hir()\n+        .as_local_hir_id(def_id)\n+        .unwrap_or_else(|| bug!(\"asyncness: expected local `DefId`, got `{:?}`\", def_id));\n+\n+    let node = tcx.hir().get(hir_id);\n+\n+    let fn_like = hir_map::blocks::FnLikeNode::from_node(node).unwrap_or_else(|| {\n+        bug!(\"asyncness: expected fn-like node but got `{:?}`\", def_id);\n+    });\n+\n+    fn_like.asyncness()\n+}\n+\n+pub fn provide(providers: &mut ty::query::Providers<'_>) {\n+    *providers = ty::query::Providers {\n+        asyncness,\n+        associated_item,\n+        associated_item_def_ids,\n+        adt_sized_constraint,\n+        def_span,\n+        param_env,\n+        trait_of_item,\n+        crate_disambiguator,\n+        original_crate_name,\n+        crate_hash,\n+        instance_def_size_estimate,\n+        issue33140_self_ty,\n+        ..*providers\n+    };\n+}"}, {"sha": "173bb29e964d160c278b01ac66fecaff9f5785ce", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1320,10 +1320,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // those that do.\n                 self.one_bound_for_assoc_type(\n                     || traits::supertraits(tcx, trait_ref),\n-                    &trait_ref.print_only_trait_path().to_string(),\n+                    || trait_ref.print_only_trait_path().to_string(),\n                     binding.item_name,\n                     path_span,\n-                    match binding.kind {\n+                    || match binding.kind {\n                         ConvertedBindingKind::Equality(ty) => Some(ty.to_string()),\n                         _ => None,\n                     },\n@@ -1880,10 +1880,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     predicates.iter().filter_map(|(p, _)| p.to_opt_poly_trait_ref()),\n                 )\n             },\n-            &param_name.as_str(),\n+            || param_name.to_string(),\n             assoc_name,\n             span,\n-            None,\n+            || None,\n         )\n     }\n \n@@ -1892,10 +1892,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     fn one_bound_for_assoc_type<I>(\n         &self,\n         all_candidates: impl Fn() -> I,\n-        ty_param_name: &str,\n+        ty_param_name: impl Fn() -> String,\n         assoc_name: ast::Ident,\n         span: Span,\n-        is_equality: Option<String>,\n+        is_equality: impl Fn() -> Option<String>,\n     ) -> Result<ty::PolyTraitRef<'tcx>, ErrorReported>\n     where\n         I: Iterator<Item = ty::PolyTraitRef<'tcx>>,\n@@ -1908,7 +1908,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             None => {\n                 self.complain_about_assoc_type_not_found(\n                     all_candidates,\n-                    ty_param_name,\n+                    &ty_param_name(),\n                     assoc_name,\n                     span,\n                 );\n@@ -1921,6 +1921,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         if let Some(bound2) = matching_candidates.next() {\n             debug!(\"one_bound_for_assoc_type: bound2 = {:?}\", bound2);\n \n+            let is_equality = is_equality();\n             let bounds = iter::once(bound).chain(iter::once(bound2)).chain(matching_candidates);\n             let mut err = if is_equality.is_some() {\n                 // More specific Error Index entry.\n@@ -1930,7 +1931,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     E0222,\n                     \"ambiguous associated type `{}` in bounds of `{}`\",\n                     assoc_name,\n-                    ty_param_name\n+                    ty_param_name()\n                 )\n             } else {\n                 struct_span_err!(\n@@ -1939,7 +1940,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     E0221,\n                     \"ambiguous associated type `{}` in bounds of `{}`\",\n                     assoc_name,\n-                    ty_param_name\n+                    ty_param_name()\n                 )\n             };\n             err.span_label(span, format!(\"ambiguous associated type `{}`\", assoc_name));\n@@ -1977,7 +1978,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             \"use fully qualified syntax to disambiguate\",\n                             format!(\n                                 \"<{} as {}>::{}\",\n-                                ty_param_name,\n+                                ty_param_name(),\n                                 bound.print_only_trait_path(),\n                                 assoc_name,\n                             ),\n@@ -1987,7 +1988,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 } else {\n                     err.note(&format!(\n                         \"associated type `{}` could derive from `{}`\",\n-                        ty_param_name,\n+                        ty_param_name(),\n                         bound.print_only_trait_path(),\n                     ));\n                 }\n@@ -1996,7 +1997,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 err.help(&format!(\n                     \"consider introducing a new type parameter `T` and adding `where` constraints:\\\n                      \\n    where\\n        T: {},\\n{}\",\n-                    ty_param_name,\n+                    ty_param_name(),\n                     where_bounds.join(\",\\n\"),\n                 ));\n             }\n@@ -2110,10 +2111,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n                 self.one_bound_for_assoc_type(\n                     || traits::supertraits(tcx, ty::Binder::bind(trait_ref)),\n-                    \"Self\",\n+                    || \"Self\".to_string(),\n                     assoc_ident,\n                     span,\n-                    None,\n+                    || None,\n                 )?\n             }\n             (&ty::Param(_), Res::SelfTy(Some(param_did), None))"}, {"sha": "cbbfe2d6278957a13d6ce25c1d76a4adeaa3835b", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -381,7 +381,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                     if unknown_cast_to { \"to\" } else { \"from\" }\n                 );\n                 err.note(\n-                    \"The type information given here is insufficient to check whether \\\n+                    \"the type information given here is insufficient to check whether \\\n                           the pointer cast is valid\",\n                 );\n                 if unknown_cast_to {"}, {"sha": "084e6c8d083c5be9999ec2f02e17d1dfc1ab238b", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -175,7 +175,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             ty::Infer(ty::TyVar(vid)) => self.deduce_expectations_from_obligations(vid),\n             ty::FnPtr(sig) => {\n-                let expected_sig = ExpectedSig { cause_span: None, sig: sig.skip_binder().clone() };\n+                let expected_sig = ExpectedSig { cause_span: None, sig: *sig.skip_binder() };\n                 (Some(expected_sig), Some(ty::ClosureKind::Fn))\n             }\n             _ => (None, None),"}, {"sha": "a32fbff7bfe2df233b19dffc9c691a88395687ac", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 99, "deletions": 10, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -50,10 +50,12 @@\n //! sort of a minor point so I've opted to leave it for later -- after all,\n //! we may want to adjust precisely when coercions occur.\n \n+use crate::astconv::AstConv;\n use crate::check::{FnCtxt, Needs};\n use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc::infer::{Coercion, InferOk, InferResult};\n use rustc::session::parse::feature_err;\n+use rustc::traits::object_safety_violations;\n use rustc::traits::{self, ObligationCause, ObligationCauseCode};\n use rustc::ty::adjustment::{\n     Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability, PointerCast,\n@@ -67,8 +69,8 @@ use rustc_error_codes::*;\n use rustc_errors::{struct_span_err, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_span;\n use rustc_span::symbol::sym;\n+use rustc_span::{self, Span};\n use rustc_target::spec::abi::Abi;\n use smallvec::{smallvec, SmallVec};\n use std::ops::Deref;\n@@ -1222,6 +1224,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                 };\n \n                 let mut err;\n+                let mut unsized_return = false;\n                 match cause.code {\n                     ObligationCauseCode::ReturnNoExpression => {\n                         err = struct_span_err!(\n@@ -1243,6 +1246,9 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                             parent_id,\n                             expression.map(|expr| (expr, blk_id)),\n                         );\n+                        if !fcx.tcx.features().unsized_locals {\n+                            unsized_return = self.is_return_ty_unsized(fcx, blk_id);\n+                        }\n                     }\n                     ObligationCauseCode::ReturnValue(id) => {\n                         err = self.report_return_mismatched_types(\n@@ -1254,6 +1260,10 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                             id,\n                             None,\n                         );\n+                        if !fcx.tcx.features().unsized_locals {\n+                            let id = fcx.tcx.hir().get_parent_node(id);\n+                            unsized_return = self.is_return_ty_unsized(fcx, id);\n+                        }\n                     }\n                     _ => {\n                         err = fcx.report_mismatched_types(cause, expected, found, coercion_error);\n@@ -1282,7 +1292,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                     .filter(|e| fcx.is_assign_to_bool(e, self.expected_ty()))\n                     .is_some();\n \n-                err.emit_unless(assign_to_bool);\n+                err.emit_unless(assign_to_bool || unsized_return);\n \n                 self.final_ty = Some(fcx.tcx.types.err);\n             }\n@@ -1302,7 +1312,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n         let mut err = fcx.report_mismatched_types(cause, expected, found, ty_err);\n \n         let mut pointing_at_return_type = false;\n-        let mut return_sp = None;\n+        let mut fn_output = None;\n \n         // Verify that this is a tail expression of a function, otherwise the\n         // label pointing out the cause for the type coercion will be wrong\n@@ -1339,19 +1349,98 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                 );\n             }\n             if !pointing_at_return_type {\n-                return_sp = Some(fn_decl.output.span()); // `impl Trait` return type\n+                fn_output = Some(&fn_decl.output); // `impl Trait` return type\n             }\n         }\n-        if let (Some(sp), Some(return_sp)) = (fcx.ret_coercion_span.borrow().as_ref(), return_sp) {\n-            err.span_label(return_sp, \"expected because this return type...\");\n-            err.span_label( *sp, format!(\n-                \"...is found to be `{}` here\",\n-                fcx.resolve_vars_with_obligations(expected),\n-            ));\n+        if let (Some(sp), Some(fn_output)) = (fcx.ret_coercion_span.borrow().as_ref(), fn_output) {\n+            self.add_impl_trait_explanation(&mut err, fcx, expected, *sp, fn_output);\n         }\n         err\n     }\n \n+    fn add_impl_trait_explanation<'a>(\n+        &self,\n+        err: &mut DiagnosticBuilder<'a>,\n+        fcx: &FnCtxt<'a, 'tcx>,\n+        expected: Ty<'tcx>,\n+        sp: Span,\n+        fn_output: &hir::FunctionRetTy<'_>,\n+    ) {\n+        let return_sp = fn_output.span();\n+        err.span_label(return_sp, \"expected because this return type...\");\n+        err.span_label(\n+            sp,\n+            format!(\"...is found to be `{}` here\", fcx.resolve_vars_with_obligations(expected)),\n+        );\n+        let impl_trait_msg = \"for information on `impl Trait`, see \\\n+                <https://doc.rust-lang.org/book/ch10-02-traits.html\\\n+                #returning-types-that-implement-traits>\";\n+        let trait_obj_msg = \"for information on trait objects, see \\\n+                <https://doc.rust-lang.org/book/ch17-02-trait-objects.html\\\n+                #using-trait-objects-that-allow-for-values-of-different-types>\";\n+        err.note(\"to return `impl Trait`, all returned values must be of the same type\");\n+        err.note(impl_trait_msg);\n+        let snippet = fcx\n+            .tcx\n+            .sess\n+            .source_map()\n+            .span_to_snippet(return_sp)\n+            .unwrap_or_else(|_| \"dyn Trait\".to_string());\n+        let mut snippet_iter = snippet.split_whitespace();\n+        let has_impl = snippet_iter.next().map_or(false, |s| s == \"impl\");\n+        // Only suggest `Box<dyn Trait>` if `Trait` in `impl Trait` is object safe.\n+        let mut is_object_safe = false;\n+        if let hir::FunctionRetTy::Return(ty) = fn_output {\n+            // Get the return type.\n+            if let hir::TyKind::Def(..) = ty.kind {\n+                let ty = AstConv::ast_ty_to_ty(fcx, ty);\n+                // Get the `impl Trait`'s `DefId`.\n+                if let ty::Opaque(def_id, _) = ty.kind {\n+                    let hir_id = fcx.tcx.hir().as_local_hir_id(def_id).unwrap();\n+                    // Get the `impl Trait`'s `Item` so that we can get its trait bounds and\n+                    // get the `Trait`'s `DefId`.\n+                    if let hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds, .. }) =\n+                        fcx.tcx.hir().expect_item(hir_id).kind\n+                    {\n+                        // Are of this `impl Trait`'s traits object safe?\n+                        is_object_safe = bounds.iter().all(|bound| {\n+                            bound.trait_def_id().map_or(false, |def_id| {\n+                                object_safety_violations(fcx.tcx, def_id).is_empty()\n+                            })\n+                        })\n+                    }\n+                }\n+            }\n+        };\n+        if has_impl {\n+            if is_object_safe {\n+                err.help(&format!(\n+                    \"you can instead return a boxed trait object using `Box<dyn {}>`\",\n+                    &snippet[5..]\n+                ));\n+            } else {\n+                err.help(&format!(\n+                    \"if the trait `{}` were object safe, you could return a boxed trait object\",\n+                    &snippet[5..]\n+                ));\n+            }\n+            err.note(trait_obj_msg);\n+        }\n+        err.help(\"alternatively, create a new `enum` with a variant for each returned type\");\n+    }\n+\n+    fn is_return_ty_unsized(&self, fcx: &FnCtxt<'a, 'tcx>, blk_id: hir::HirId) -> bool {\n+        if let Some((fn_decl, _)) = fcx.get_fn_decl(blk_id) {\n+            if let hir::FunctionRetTy::Return(ty) = fn_decl.output {\n+                let ty = AstConv::ast_ty_to_ty(fcx, ty);\n+                if let ty::Dynamic(..) = ty.kind {\n+                    return true;\n+                }\n+            }\n+        }\n+        false\n+    }\n+\n     pub fn complete<'a>(self, fcx: &FnCtxt<'a, 'tcx>) -> Ty<'tcx> {\n         if let Some(final_ty) = self.final_ty {\n             final_ty"}, {"sha": "fc02d17a50f373d9752e07d95014bfa6fcb7e954", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -97,6 +97,7 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n                         span: source_span,\n                         ty: &ty,\n                         scope_span,\n+                        expr: expr.map(|e| e.hir_id),\n                     })\n                     .or_insert(entries);\n             }\n@@ -164,17 +165,25 @@ pub fn resolve_interior<'a, 'tcx>(\n     // which means that none of the regions inside relate to any other, even if\n     // typeck had previously found constraints that would cause them to be related.\n     let mut counter = 0;\n-    let types = fcx.tcx.fold_regions(&types, &mut false, |_, current_depth| {\n+    let fold_types: Vec<_> = types.iter().map(|(t, _)| t.ty).collect();\n+    let folded_types = fcx.tcx.fold_regions(&fold_types, &mut false, |_, current_depth| {\n         counter += 1;\n         fcx.tcx.mk_region(ty::ReLateBound(current_depth, ty::BrAnon(counter)))\n     });\n \n     // Store the generator types and spans into the tables for this generator.\n-    let interior_types = types.iter().map(|t| t.0.clone()).collect::<Vec<_>>();\n-    visitor.fcx.inh.tables.borrow_mut().generator_interior_types = interior_types;\n+    let types = types\n+        .into_iter()\n+        .zip(&folded_types)\n+        .map(|((mut interior_cause, _), ty)| {\n+            interior_cause.ty = ty;\n+            interior_cause\n+        })\n+        .collect();\n+    visitor.fcx.inh.tables.borrow_mut().generator_interior_types = types;\n \n     // Extract type components\n-    let type_list = fcx.tcx.mk_type_list(types.into_iter().map(|t| (t.0).ty));\n+    let type_list = fcx.tcx.mk_type_list(folded_types.iter());\n \n     let witness = fcx.tcx.mk_generator_witness(ty::Binder::bind(type_list));\n "}, {"sha": "d6c0d9c77b4950a2963361724abc64a261c45ad3", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -479,7 +479,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     macro_rules! report_function {\n                         ($span:expr, $name:expr) => {\n                             err.note(&format!(\n-                                \"{} is a function, perhaps you wish to call it\",\n+                                \"`{}` is a function, perhaps you wish to call it\",\n                                 $name\n                             ));\n                         };"}, {"sha": "4affdc4a9d64e7d8eca6a8ccf948f07d523a924c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 65, "deletions": 34, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -122,7 +122,7 @@ use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefIdSet, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n-use rustc_hir::{ExprKind, GenericArg, HirIdMap, ItemKind, Node, PatKind, QPath};\n+use rustc_hir::{ExprKind, GenericArg, HirIdMap, Item, ItemKind, Node, PatKind, QPath};\n use rustc_index::vec::Idx;\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::source_map::{original_sp, DUMMY_SP};\n@@ -1664,7 +1664,7 @@ fn check_opaque_for_cycles<'tcx>(\n         if let hir::OpaqueTyOrigin::AsyncFn = origin {\n             struct_span_err!(tcx.sess, span, E0733, \"recursion in an `async fn` requires boxing\",)\n                 .span_label(span, \"recursive `async fn`\")\n-                .note(\"a recursive `async fn` must be rewritten to return a boxed `dyn Future`.\")\n+                .note(\"a recursive `async fn` must be rewritten to return a boxed `dyn Future`\")\n                 .emit();\n         } else {\n             let mut err =\n@@ -1709,17 +1709,11 @@ pub fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, it: &'tcx hir::Item<'tcx>) {\n             check_enum(tcx, it.span, &enum_definition.variants, it.hir_id);\n         }\n         hir::ItemKind::Fn(..) => {} // entirely within check_item_body\n-        hir::ItemKind::Impl(.., ref impl_item_refs) => {\n+        hir::ItemKind::Impl { ref items, .. } => {\n             debug!(\"ItemKind::Impl {} with id {}\", it.ident, it.hir_id);\n             let impl_def_id = tcx.hir().local_def_id(it.hir_id);\n             if let Some(impl_trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n-                check_impl_items_against_trait(\n-                    tcx,\n-                    it.span,\n-                    impl_def_id,\n-                    impl_trait_ref,\n-                    impl_item_refs,\n-                );\n+                check_impl_items_against_trait(tcx, it.span, impl_def_id, impl_trait_ref, items);\n                 let trait_def_id = impl_trait_ref.def_id;\n                 check_on_unimplemented(tcx, trait_def_id, it);\n             }\n@@ -2312,44 +2306,81 @@ fn check_packed(tcx: TyCtxt<'_>, sp: Span, def_id: DefId) {\n                 \"type has conflicting packed and align representation hints\"\n             )\n             .emit();\n-        } else if check_packed_inner(tcx, def_id, &mut Vec::new()) {\n-            struct_span_err!(\n-                tcx.sess,\n-                sp,\n-                E0588,\n-                \"packed type cannot transitively contain a `[repr(align)]` type\"\n-            )\n-            .emit();\n+        } else {\n+            if let Some(def_spans) = check_packed_inner(tcx, def_id, &mut vec![]) {\n+                let mut err = struct_span_err!(\n+                    tcx.sess,\n+                    sp,\n+                    E0588,\n+                    \"packed type cannot transitively contain a `#[repr(align)]` type\"\n+                );\n+\n+                let hir = tcx.hir();\n+                if let Some(hir_id) = hir.as_local_hir_id(def_spans[0].0) {\n+                    if let Node::Item(Item { ident, .. }) = hir.get(hir_id) {\n+                        err.span_note(\n+                            tcx.def_span(def_spans[0].0),\n+                            &format!(\"`{}` has a `#[repr(align)]` attribute\", ident),\n+                        );\n+                    }\n+                }\n+\n+                if def_spans.len() > 2 {\n+                    let mut first = true;\n+                    for (adt_def, span) in def_spans.iter().skip(1).rev() {\n+                        if let Some(hir_id) = hir.as_local_hir_id(*adt_def) {\n+                            if let Node::Item(Item { ident, .. }) = hir.get(hir_id) {\n+                                err.span_note(\n+                                    *span,\n+                                    &if first {\n+                                        format!(\n+                                            \"`{}` contains a field of type `{}`\",\n+                                            tcx.type_of(def_id),\n+                                            ident\n+                                        )\n+                                    } else {\n+                                        format!(\"...which contains a field of type `{}`\", ident)\n+                                    },\n+                                );\n+                                first = false;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                err.emit();\n+            }\n         }\n     }\n }\n \n-fn check_packed_inner(tcx: TyCtxt<'_>, def_id: DefId, stack: &mut Vec<DefId>) -> bool {\n-    let t = tcx.type_of(def_id);\n-    if stack.contains(&def_id) {\n-        debug!(\"check_packed_inner: {:?} is recursive\", t);\n-        return false;\n-    }\n-    if let ty::Adt(def, substs) = t.kind {\n+fn check_packed_inner(\n+    tcx: TyCtxt<'_>,\n+    def_id: DefId,\n+    stack: &mut Vec<DefId>,\n+) -> Option<Vec<(DefId, Span)>> {\n+    if let ty::Adt(def, substs) = tcx.type_of(def_id).kind {\n         if def.is_struct() || def.is_union() {\n-            if tcx.adt_def(def.did).repr.align.is_some() {\n-                return true;\n+            if def.repr.align.is_some() {\n+                return Some(vec![(def.did, DUMMY_SP)]);\n             }\n-            // push struct def_id before checking fields\n+\n             stack.push(def_id);\n             for field in &def.non_enum_variant().fields {\n-                let f = field.ty(tcx, substs);\n-                if let ty::Adt(def, _) = f.kind {\n-                    if check_packed_inner(tcx, def.did, stack) {\n-                        return true;\n+                if let ty::Adt(def, _) = field.ty(tcx, substs).kind {\n+                    if !stack.contains(&def.did) {\n+                        if let Some(mut defs) = check_packed_inner(tcx, def.did, stack) {\n+                            defs.push((def.did, field.ident.span));\n+                            return Some(defs);\n+                        }\n                     }\n                 }\n             }\n-            // only need to pop if not early out\n             stack.pop();\n         }\n     }\n-    false\n+\n+    None\n }\n \n /// Emit an error when encountering more or less than one variant in a transparent enum."}, {"sha": "5e91e98a7dfa500063533ef9322f81950e07c51a", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -97,7 +97,7 @@ pub fn check_item_well_formed(tcx: TyCtxt<'_>, def_id: DefId) {\n         //\n         // won't be allowed unless there's an *explicit* implementation of `Send`\n         // for `T`\n-        hir::ItemKind::Impl(_, _, defaultness, _, ref trait_ref, ref self_ty, _) => {\n+        hir::ItemKind::Impl { defaultness, ref of_trait, ref self_ty, .. } => {\n             let is_auto = tcx\n                 .impl_trait_ref(tcx.hir().local_def_id(item.hir_id))\n                 .map_or(false, |trait_ref| tcx.trait_is_auto(trait_ref.def_id));\n@@ -107,11 +107,11 @@ pub fn check_item_well_formed(tcx: TyCtxt<'_>, def_id: DefId) {\n             }\n             match polarity {\n                 ty::ImplPolarity::Positive => {\n-                    check_impl(tcx, item, self_ty, trait_ref);\n+                    check_impl(tcx, item, self_ty, of_trait);\n                 }\n                 ty::ImplPolarity::Negative => {\n                     // FIXME(#27579): what amount of WF checking do we need for neg impls?\n-                    if trait_ref.is_some() && !is_auto {\n+                    if of_trait.is_some() && !is_auto {\n                         struct_span_err!(\n                             tcx.sess,\n                             item.span,"}, {"sha": "516dc16d46bd8f122febc4a96672efd8a7250f55", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -57,7 +57,7 @@ fn visit_implementation_of_drop(tcx: TyCtxt<'_>, impl_did: DefId) {\n \n     let impl_hir_id = tcx.hir().as_local_hir_id(impl_did).expect(\"foreign Drop impl on non-ADT\");\n     let sp = match tcx.hir().expect_item(impl_hir_id).kind {\n-        ItemKind::Impl(.., ty, _) => ty.span,\n+        ItemKind::Impl { self_ty, .. } => self_ty.span,\n         _ => bug!(\"expected Drop impl item\"),\n     };\n \n@@ -94,7 +94,7 @@ fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: DefId) {\n         Ok(()) => {}\n         Err(CopyImplementationError::InfrigingFields(fields)) => {\n             let item = tcx.hir().expect_item(impl_hir_id);\n-            let span = if let ItemKind::Impl(.., Some(ref tr), _, _) = item.kind {\n+            let span = if let ItemKind::Impl { of_trait: Some(ref tr), .. } = item.kind {\n                 tr.path.span\n             } else {\n                 span\n@@ -113,7 +113,8 @@ fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: DefId) {\n         }\n         Err(CopyImplementationError::NotAnAdt) => {\n             let item = tcx.hir().expect_item(impl_hir_id);\n-            let span = if let ItemKind::Impl(.., ref ty, _) = item.kind { ty.span } else { span };\n+            let span =\n+                if let ItemKind::Impl { self_ty, .. } = item.kind { self_ty.span } else { span };\n \n             struct_span_err!(\n                 tcx.sess,\n@@ -490,7 +491,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n                     return err_info;\n                 } else if diff_fields.len() > 1 {\n                     let item = tcx.hir().expect_item(impl_hir_id);\n-                    let span = if let ItemKind::Impl(.., Some(ref t), _, _) = item.kind {\n+                    let span = if let ItemKind::Impl { of_trait: Some(ref t), .. } = item.kind {\n                         t.path.span\n                     } else {\n                         tcx.hir().span(impl_hir_id)"}, {"sha": "d313e32fc20e0fb6333af31ea4f62d9602ff436d", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -47,7 +47,7 @@ struct InherentCollect<'tcx> {\n impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n         let ty = match item.kind {\n-            hir::ItemKind::Impl(.., None, ref ty, _) => ty,\n+            hir::ItemKind::Impl { of_trait: None, ref self_ty, .. } => self_ty,\n             _ => return,\n         };\n "}, {"sha": "9ba8fa4247f269f5e3dc6554071d499e88fc851a", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -27,7 +27,7 @@ impl ItemLikeVisitor<'v> for OrphanChecker<'tcx> {\n     fn visit_item(&mut self, item: &hir::Item<'_>) {\n         let def_id = self.tcx.hir().local_def_id(item.hir_id);\n         // \"Trait\" impl\n-        if let hir::ItemKind::Impl(.., generics, Some(tr), impl_ty, _) = &item.kind {\n+        if let hir::ItemKind::Impl { generics, of_trait: Some(ref tr), self_ty, .. } = &item.kind {\n             debug!(\n                 \"coherence2::orphan check: trait impl {}\",\n                 self.tcx.hir().node_to_string(item.hir_id)\n@@ -72,7 +72,7 @@ impl ItemLikeVisitor<'v> for OrphanChecker<'tcx> {\n                         let msg = format!(\"{} is not defined in the current crate{}\", ty, postfix);\n                         if *is_target_ty {\n                             // Point at `D<A>` in `impl<A, B> for C<B> in D<A>`\n-                            err.span_label(impl_ty.span, &msg);\n+                            err.span_label(self_ty.span, &msg);\n                         } else {\n                             // Point at `C<B>` in `impl<A, B> for C<B> in D<A>`\n                             err.span_label(tr.path.span, &msg);"}, {"sha": "48b96886d3a7184dcd95c4041f8049938ec6b0fa", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -88,7 +88,7 @@ impl UnsafetyChecker<'tcx> {\n \n impl ItemLikeVisitor<'v> for UnsafetyChecker<'tcx> {\n     fn visit_item(&mut self, item: &'v hir::Item<'v>) {\n-        if let hir::ItemKind::Impl(unsafety, polarity, _, ref generics, ..) = item.kind {\n+        if let hir::ItemKind::Impl { unsafety, polarity, ref generics, .. } = item.kind {\n             self.check_unsafety_coherence(item, Some(generics), unsafety, polarity);\n         }\n     }"}, {"sha": "a03b9f747372e49939164edb22690a6fc7ea3508", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 38, "deletions": 25, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -184,7 +184,7 @@ fn reject_placeholder_type_signatures_in_item(tcx: TyCtxt<'tcx>, item: &'tcx hir\n         | hir::ItemKind::Enum(_, generics)\n         | hir::ItemKind::TraitAlias(generics, _)\n         | hir::ItemKind::Trait(_, _, generics, ..)\n-        | hir::ItemKind::Impl(_, _, _, generics, ..)\n+        | hir::ItemKind::Impl { generics, .. }\n         | hir::ItemKind::Struct(_, generics) => (generics, true),\n         hir::ItemKind::OpaqueTy(hir::OpaqueTy { generics, .. })\n         | hir::ItemKind::TyAlias(_, generics) => (generics, false),\n@@ -401,7 +401,7 @@ fn type_param_predicates(\n         Node::Item(item) => {\n             match item.kind {\n                 ItemKind::Fn(.., ref generics, _)\n-                | ItemKind::Impl(_, _, _, ref generics, ..)\n+                | ItemKind::Impl { ref generics, .. }\n                 | ItemKind::TyAlias(_, ref generics)\n                 | ItemKind::OpaqueTy(OpaqueTy { ref generics, impl_trait_fn: None, .. })\n                 | ItemKind::Enum(_, ref generics)\n@@ -531,7 +531,7 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::HirId) {\n             tcx.predicates_of(def_id);\n             convert_enum_variant_types(tcx, def_id, &enum_definition.variants);\n         }\n-        hir::ItemKind::Impl(..) => {\n+        hir::ItemKind::Impl { .. } => {\n             tcx.generics_of(def_id);\n             tcx.type_of(def_id);\n             tcx.impl_trait_ref(def_id);\n@@ -1052,9 +1052,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n \n         Node::Item(item) => {\n             match item.kind {\n-                ItemKind::Fn(.., ref generics, _) | ItemKind::Impl(_, _, _, ref generics, ..) => {\n-                    generics\n-                }\n+                ItemKind::Fn(.., ref generics, _) | ItemKind::Impl { ref generics, .. } => generics,\n \n                 ItemKind::TyAlias(_, ref generics)\n                 | ItemKind::Enum(_, ref generics)\n@@ -1338,7 +1336,9 @@ fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                         icx.to_ty(ty)\n                     }\n                 }\n-                ItemKind::TyAlias(ref ty, _) | ItemKind::Impl(.., ref ty, _) => icx.to_ty(ty),\n+                ItemKind::TyAlias(ref self_ty, _) | ItemKind::Impl { ref self_ty, .. } => {\n+                    icx.to_ty(self_ty)\n+                }\n                 ItemKind::Fn(..) => {\n                     let substs = InternalSubsts::identity_for_item(tcx, def_id);\n                     tcx.mk_fn_def(def_id, substs)\n@@ -1806,6 +1806,16 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n     }\n }\n \n+fn are_suggestable_generic_args(generic_args: &[hir::GenericArg<'_>]) -> bool {\n+    generic_args\n+        .iter()\n+        .filter_map(|arg| match arg {\n+            hir::GenericArg::Type(ty) => Some(ty),\n+            _ => None,\n+        })\n+        .any(is_suggestable_infer_ty)\n+}\n+\n /// Whether `ty` is a type with `_` placeholders that can be infered. Used in diagnostics only to\n /// use inference to provide suggestions for the appropriate type if possible.\n fn is_suggestable_infer_ty(ty: &hir::Ty<'_>) -> bool {\n@@ -1815,13 +1825,16 @@ fn is_suggestable_infer_ty(ty: &hir::Ty<'_>) -> bool {\n         Slice(ty) | Array(ty, _) => is_suggestable_infer_ty(ty),\n         Tup(tys) => tys.iter().any(is_suggestable_infer_ty),\n         Ptr(mut_ty) | Rptr(_, mut_ty) => is_suggestable_infer_ty(mut_ty.ty),\n-        Def(_, generic_args) => generic_args\n-            .iter()\n-            .filter_map(|arg| match arg {\n-                hir::GenericArg::Type(ty) => Some(ty),\n-                _ => None,\n-            })\n-            .any(is_suggestable_infer_ty),\n+        Def(_, generic_args) => are_suggestable_generic_args(generic_args),\n+        Path(hir::QPath::TypeRelative(ty, segment)) => {\n+            is_suggestable_infer_ty(ty) || are_suggestable_generic_args(segment.generic_args().args)\n+        }\n+        Path(hir::QPath::Resolved(ty_opt, hir::Path { segments, .. })) => {\n+            ty_opt.map_or(false, is_suggestable_infer_ty)\n+                || segments\n+                    .iter()\n+                    .any(|segment| are_suggestable_generic_args(segment.generic_args().args))\n+        }\n         _ => false,\n     }\n }\n@@ -1943,12 +1956,10 @@ fn impl_trait_ref(tcx: TyCtxt<'_>, def_id: DefId) -> Option<ty::TraitRef<'_>> {\n \n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     match tcx.hir().expect_item(hir_id).kind {\n-        hir::ItemKind::Impl(.., ref opt_trait_ref, _, _) => {\n-            opt_trait_ref.as_ref().map(|ast_trait_ref| {\n-                let selfty = tcx.type_of(def_id);\n-                AstConv::instantiate_mono_trait_ref(&icx, ast_trait_ref, selfty)\n-            })\n-        }\n+        hir::ItemKind::Impl { ref of_trait, .. } => of_trait.as_ref().map(|ast_trait_ref| {\n+            let selfty = tcx.type_of(def_id);\n+            AstConv::instantiate_mono_trait_ref(&icx, ast_trait_ref, selfty)\n+        }),\n         _ => bug!(),\n     }\n }\n@@ -1958,19 +1969,21 @@ fn impl_polarity(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ImplPolarity {\n     let is_rustc_reservation = tcx.has_attr(def_id, sym::rustc_reservation_impl);\n     let item = tcx.hir().expect_item(hir_id);\n     match &item.kind {\n-        hir::ItemKind::Impl(_, hir::ImplPolarity::Negative, ..) => {\n+        hir::ItemKind::Impl { polarity: hir::ImplPolarity::Negative, .. } => {\n             if is_rustc_reservation {\n                 tcx.sess.span_err(item.span, \"reservation impls can't be negative\");\n             }\n             ty::ImplPolarity::Negative\n         }\n-        hir::ItemKind::Impl(_, hir::ImplPolarity::Positive, _, _, None, _, _) => {\n+        hir::ItemKind::Impl { polarity: hir::ImplPolarity::Positive, of_trait: None, .. } => {\n             if is_rustc_reservation {\n                 tcx.sess.span_err(item.span, \"reservation impls can't be inherent\");\n             }\n             ty::ImplPolarity::Positive\n         }\n-        hir::ItemKind::Impl(_, hir::ImplPolarity::Positive, _, _, Some(_tr), _, _) => {\n+        hir::ItemKind::Impl {\n+            polarity: hir::ImplPolarity::Positive, of_trait: Some(_), ..\n+        } => {\n             if is_rustc_reservation {\n                 ty::ImplPolarity::Reservation\n             } else {\n@@ -2129,7 +2142,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n \n         Node::Item(item) => {\n             match item.kind {\n-                ItemKind::Impl(_, _, defaultness, ref generics, ..) => {\n+                ItemKind::Impl { defaultness, ref generics, .. } => {\n                     if defaultness.is_default() {\n                         is_default_impl_trait = tcx.impl_trait_ref(def_id);\n                     }\n@@ -2346,7 +2359,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n     // before uses of `U`.  This avoids false ambiguity errors\n     // in trait checking. See `setup_constraining_predicates`\n     // for details.\n-    if let Node::Item(&Item { kind: ItemKind::Impl(..), .. }) = node {\n+    if let Node::Item(&Item { kind: ItemKind::Impl { .. }, .. }) = node {\n         let self_ty = tcx.type_of(def_id);\n         let trait_ref = tcx.impl_trait_ref(def_id);\n         cgp::setup_constraining_predicates("}, {"sha": "9ee4e7c48190d57af455d5e5f46666f9fc0a1dbc", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -75,10 +75,10 @@ struct ImplWfCheck<'tcx> {\n \n impl ItemLikeVisitor<'tcx> for ImplWfCheck<'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        if let hir::ItemKind::Impl(.., ref impl_item_refs) = item.kind {\n+        if let hir::ItemKind::Impl { ref items, .. } = item.kind {\n             let impl_def_id = self.tcx.hir().local_def_id(item.hir_id);\n-            enforce_impl_params_are_constrained(self.tcx, impl_def_id, impl_item_refs);\n-            enforce_impl_items_are_distinct(self.tcx, impl_item_refs);\n+            enforce_impl_params_are_constrained(self.tcx, impl_def_id, items);\n+            enforce_impl_items_are_distinct(self.tcx, items);\n         }\n     }\n "}, {"sha": "95cd3c631ed22dc22d6d5811b1be0a83b5877e85", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -64,7 +64,7 @@ This API is completely unstable and subject to change.\n #![feature(exhaustive_patterns)]\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n-#![feature(slice_patterns)]\n+#![cfg_attr(bootstrap, feature(slice_patterns))]\n #![feature(try_blocks)]\n #![feature(never_type)]\n #![recursion_limit = \"256\"]"}, {"sha": "f37f6921cebaf4f5c3a1360237be99c8a0cf4136", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -239,7 +239,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         //  constraint, and add it to our list. Since we make sure to never re-add\n         //  deleted items, this process will always finish.\n         while !vid_map.is_empty() {\n-            let target = vid_map.keys().next().expect(\"Keys somehow empty\").clone();\n+            let target = *vid_map.keys().next().expect(\"Keys somehow empty\");\n             let deps = vid_map.remove(&target).expect(\"Entry somehow missing\");\n \n             for smaller in deps.smaller.iter() {"}, {"sha": "8a6abe036dc14b9305901af1892cd7c573401317", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -273,6 +273,22 @@ fn build_type_alias(cx: &DocContext<'_>, did: DefId) -> clean::Typedef {\n     clean::Typedef {\n         type_: cx.tcx.type_of(did).clean(cx),\n         generics: (cx.tcx.generics_of(did), predicates).clean(cx),\n+        item_type: build_type_alias_type(cx, did),\n+    }\n+}\n+\n+fn build_type_alias_type(cx: &DocContext<'_>, did: DefId) -> Option<clean::Type> {\n+    let type_ = cx.tcx.type_of(did).clean(cx);\n+    type_.def_id().and_then(|did| build_ty(cx, did))\n+}\n+\n+pub fn build_ty(cx: &DocContext, did: DefId) -> Option<clean::Type> {\n+    match cx.tcx.def_kind(did)? {\n+        DefKind::Struct | DefKind::Union | DefKind::Enum | DefKind::Const | DefKind::Static => {\n+            Some(cx.tcx.type_of(did).clean(cx))\n+        }\n+        DefKind::TyAlias => build_type_alias_type(cx, did),\n+        _ => None,\n     }\n }\n \n@@ -331,7 +347,7 @@ pub fn build_impl(\n \n     let for_ = if let Some(hir_id) = tcx.hir().as_local_hir_id(did) {\n         match tcx.hir().expect_item(hir_id).kind {\n-            hir::ItemKind::Impl(.., ref t, _) => t.clean(cx),\n+            hir::ItemKind::Impl { self_ty, .. } => self_ty.clean(cx),\n             _ => panic!(\"did given to build_impl was not an impl\"),\n         }\n     } else {\n@@ -351,9 +367,9 @@ pub fn build_impl(\n     let predicates = tcx.explicit_predicates_of(did);\n     let (trait_items, generics) = if let Some(hir_id) = tcx.hir().as_local_hir_id(did) {\n         match tcx.hir().expect_item(hir_id).kind {\n-            hir::ItemKind::Impl(.., ref gen, _, _, ref item_ids) => (\n-                item_ids.iter().map(|ii| tcx.hir().impl_item(ii.id).clean(cx)).collect::<Vec<_>>(),\n-                gen.clean(cx),\n+            hir::ItemKind::Impl { ref generics, ref items, .. } => (\n+                items.iter().map(|item| tcx.hir().impl_item(item.id).clean(cx)).collect::<Vec<_>>(),\n+                generics.clean(cx),\n             ),\n             _ => panic!(\"did given to build_impl was not an impl\"),\n         }"}, {"sha": "20a5a6c54984d0bed6dd310df67780dbdd35cc8e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1122,7 +1122,9 @@ impl Clean<Item> for hir::ImplItem<'_> {\n                 MethodItem((sig, &self.generics, body, Some(self.defaultness)).clean(cx))\n             }\n             hir::ImplItemKind::TyAlias(ref ty) => {\n-                TypedefItem(Typedef { type_: ty.clean(cx), generics: Generics::default() }, true)\n+                let type_ = ty.clean(cx);\n+                let item_type = type_.def_id().and_then(|did| inline::build_ty(cx, did));\n+                TypedefItem(Typedef { type_, generics: Generics::default(), item_type }, true)\n             }\n             hir::ImplItemKind::OpaqueTy(ref bounds) => OpaqueTyItem(\n                 OpaqueTy { bounds: bounds.clean(cx), generics: Generics::default() },\n@@ -1282,10 +1284,13 @@ impl Clean<Item> for ty::AssocItem {\n \n                     AssocTypeItem(bounds, ty.clean(cx))\n                 } else {\n+                    let type_ = cx.tcx.type_of(self.def_id).clean(cx);\n+                    let item_type = type_.def_id().and_then(|did| inline::build_ty(cx, did));\n                     TypedefItem(\n                         Typedef {\n-                            type_: cx.tcx.type_of(self.def_id).clean(cx),\n+                            type_,\n                             generics: Generics { params: Vec::new(), where_predicates: Vec::new() },\n+                            item_type,\n                         },\n                         true,\n                     )\n@@ -1989,6 +1994,8 @@ impl Clean<String> for ast::Name {\n \n impl Clean<Item> for doctree::Typedef<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n+        let type_ = self.ty.clean(cx);\n+        let item_type = type_.def_id().and_then(|did| inline::build_ty(cx, did));\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -1997,10 +2004,7 @@ impl Clean<Item> for doctree::Typedef<'_> {\n             visibility: self.vis.clean(cx),\n             stability: cx.stability(self.id).clean(cx),\n             deprecation: cx.deprecation(self.id).clean(cx),\n-            inner: TypedefItem(\n-                Typedef { type_: self.ty.clean(cx), generics: self.gen.clean(cx) },\n-                false,\n-            ),\n+            inner: TypedefItem(Typedef { type_, generics: self.gen.clean(cx), item_type }, false),\n         }\n     }\n }\n@@ -2101,7 +2105,7 @@ impl Clean<Vec<Item>> for doctree::Impl<'_> {\n             build_deref_target_impls(cx, &items, &mut ret);\n         }\n \n-        let provided = trait_\n+        let provided: FxHashSet<String> = trait_\n             .def_id()\n             .map(|did| {\n                 cx.tcx\n@@ -2112,7 +2116,12 @@ impl Clean<Vec<Item>> for doctree::Impl<'_> {\n             })\n             .unwrap_or_default();\n \n-        ret.push(Item {\n+        let for_ = self.for_.clean(cx);\n+        let type_alias = for_.def_id().and_then(|did| match cx.tcx.def_kind(did) {\n+            Some(DefKind::TyAlias) => Some(cx.tcx.type_of(did).clean(cx)),\n+            _ => None,\n+        });\n+        let make_item = |trait_: Option<Type>, for_: Type, items: Vec<Item>| Item {\n             name: None,\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n@@ -2123,15 +2132,19 @@ impl Clean<Vec<Item>> for doctree::Impl<'_> {\n             inner: ImplItem(Impl {\n                 unsafety: self.unsafety,\n                 generics: self.generics.clean(cx),\n-                provided_trait_methods: provided,\n+                provided_trait_methods: provided.clone(),\n                 trait_,\n-                for_: self.for_.clean(cx),\n+                for_,\n                 items,\n                 polarity: Some(cx.tcx.impl_polarity(def_id).clean(cx)),\n                 synthetic: false,\n                 blanket_impl: None,\n             }),\n-        });\n+        };\n+        if let Some(type_alias) = type_alias {\n+            ret.push(make_item(trait_.clone(), type_alias, items.clone()));\n+        }\n+        ret.push(make_item(trait_, for_, items));\n         ret\n     }\n }"}, {"sha": "79a078ca7a991abdaf58ccdf8728d6e22b466fbf", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1406,6 +1406,14 @@ pub struct PathSegment {\n pub struct Typedef {\n     pub type_: Type,\n     pub generics: Generics,\n+    // Type of target item.\n+    pub item_type: Option<Type>,\n+}\n+\n+impl GetDefId for Typedef {\n+    fn def_id(&self) -> Option<DefId> {\n+        self.type_.def_id()\n+    }\n }\n \n #[derive(Clone, Debug)]"}, {"sha": "aa52b769c38ed3af420ccd1085260b5bb6acbb7e", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -65,7 +65,7 @@ pub fn render_with_highlighting(\n         Err(()) => {\n             // If errors are encountered while trying to highlight, just emit\n             // the unhighlighted source.\n-            write!(out, \"<pre><code>{}</code></pre>\", src).unwrap();\n+            write!(out, \"<pre><code>{}</code></pre>\", Escape(src)).unwrap();\n         }\n     }\n "}, {"sha": "c87964af0200cf8c7ca8c1da2e87c04c58f0b8d8", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -380,7 +380,10 @@ impl<'a, 'b, 'ids, I: Iterator<Item = Event<'a>>> Iterator for HeadingLinks<'a,\n                     }\n                     _ => {}\n                 }\n-                self.buf.push_back(event);\n+                match event {\n+                    Event::Start(Tag::Link(_, _, _)) | Event::End(Tag::Link(..)) => {}\n+                    event => self.buf.push_back(event),\n+                }\n             }\n             let id = self.id_map.derive(id);\n \n@@ -395,7 +398,7 @@ impl<'a, 'b, 'ids, I: Iterator<Item = Event<'a>>> Iterator for HeadingLinks<'a,\n \n             let start_tags = format!(\n                 \"<h{level} id=\\\"{id}\\\" class=\\\"section-header\\\">\\\n-                                      <a href=\\\"#{id}\\\">\",\n+                    <a href=\\\"#{id}\\\">\",\n                 id = id,\n                 level = level\n             );"}, {"sha": "9406803825350e82abb50b9987f47f73dfc8dbc2", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -3469,20 +3469,23 @@ fn render_deref_methods(\n     deref_mut: bool,\n ) {\n     let deref_type = impl_.inner_impl().trait_.as_ref().unwrap();\n-    let target = impl_\n+    let (target, real_target) = impl_\n         .inner_impl()\n         .items\n         .iter()\n         .filter_map(|item| match item.inner {\n-            clean::TypedefItem(ref t, true) => Some(&t.type_),\n+            clean::TypedefItem(ref t, true) => Some(match *t {\n+                clean::Typedef { item_type: Some(ref type_), .. } => (type_, &t.type_),\n+                _ => (&t.type_, &t.type_),\n+            }),\n             _ => None,\n         })\n         .next()\n         .expect(\"Expected associated type binding\");\n     let what =\n-        AssocItemRender::DerefFor { trait_: deref_type, type_: target, deref_mut_: deref_mut };\n+        AssocItemRender::DerefFor { trait_: deref_type, type_: real_target, deref_mut_: deref_mut };\n     if let Some(did) = target.def_id() {\n-        render_assoc_items(w, cx, container_item, did, what)\n+        render_assoc_items(w, cx, container_item, did, what);\n     } else {\n         if let Some(prim) = target.primitive_type() {\n             if let Some(&did) = cx.cache.primitive_locations.get(&prim) {\n@@ -4123,12 +4126,15 @@ fn sidebar_assoc_items(it: &clean::Item) -> String {\n                 .filter(|i| i.inner_impl().trait_.is_some())\n                 .find(|i| i.inner_impl().trait_.def_id() == c.deref_trait_did)\n             {\n-                if let Some(target) = impl_\n+                if let Some((target, real_target)) = impl_\n                     .inner_impl()\n                     .items\n                     .iter()\n                     .filter_map(|item| match item.inner {\n-                        clean::TypedefItem(ref t, true) => Some(&t.type_),\n+                        clean::TypedefItem(ref t, true) => Some(match *t {\n+                            clean::Typedef { item_type: Some(ref type_), .. } => (type_, &t.type_),\n+                            _ => (&t.type_, &t.type_),\n+                        }),\n                         _ => None,\n                     })\n                     .next()\n@@ -4147,7 +4153,7 @@ fn sidebar_assoc_items(it: &clean::Item) -> String {\n                                 \"{:#}\",\n                                 impl_.inner_impl().trait_.as_ref().unwrap().print()\n                             )),\n-                            Escape(&format!(\"{:#}\", target.print()))\n+                            Escape(&format!(\"{:#}\", real_target.print()))\n                         ));\n                         out.push_str(\"</a>\");\n                         let mut ret = impls"}, {"sha": "f1f83acdda59e81cb16f0593ae59ea5b5970a684", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -277,7 +277,7 @@ impl DocFolder for Cache {\n                 | clean::StructFieldItem(..)\n                 | clean::VariantItem(..) => (\n                     (\n-                        Some(*self.parent_stack.last().unwrap()),\n+                        Some(*self.parent_stack.last().expect(\"parent_stack is empty\")),\n                         Some(&self.stack[..self.stack.len() - 1]),\n                     ),\n                     false,\n@@ -286,7 +286,7 @@ impl DocFolder for Cache {\n                     if self.parent_stack.is_empty() {\n                         ((None, None), false)\n                     } else {\n-                        let last = self.parent_stack.last().unwrap();\n+                        let last = self.parent_stack.last().expect(\"parent_stack is empty 2\");\n                         let did = *last;\n                         let path = match self.paths.get(&did) {\n                             // The current stack not necessarily has correlation\n@@ -468,7 +468,7 @@ impl DocFolder for Cache {\n                         self.impls.entry(did).or_insert(vec![]).push(impl_item.clone());\n                     }\n                 } else {\n-                    let trait_did = impl_item.trait_did().unwrap();\n+                    let trait_did = impl_item.trait_did().expect(\"no trait did\");\n                     self.orphan_trait_impls.push((trait_did, dids, impl_item));\n                 }\n                 None\n@@ -478,10 +478,10 @@ impl DocFolder for Cache {\n         });\n \n         if pushed {\n-            self.stack.pop().unwrap();\n+            self.stack.pop().expect(\"stack already empty\");\n         }\n         if parent_pushed {\n-            self.parent_stack.pop().unwrap();\n+            self.parent_stack.pop().expect(\"parent stack already empty\");\n         }\n         self.stripped_mod = orig_stripped_mod;\n         self.parent_is_trait_impl = orig_parent_is_trait_impl;\n@@ -594,7 +594,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n     for item in search_index {\n         item.parent_idx = item.parent.map(|nodeid| {\n             if nodeid_to_pathid.contains_key(&nodeid) {\n-                *nodeid_to_pathid.get(&nodeid).unwrap()\n+                *nodeid_to_pathid.get(&nodeid).expect(\"no pathid\")\n             } else {\n                 let pathid = lastpathid;\n                 nodeid_to_pathid.insert(nodeid, pathid);\n@@ -639,7 +639,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n             items: crate_items,\n             paths: crate_paths,\n         })\n-        .unwrap()\n+        .expect(\"failed serde conversion\")\n     )\n }\n "}, {"sha": "05d41415689813e42a00df41028d3a020a953042", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -704,7 +704,7 @@ impl Tester for Collector {\n         debug!(\"creating test {}: {}\", name, test);\n         self.tests.push(testing::TestDescAndFn {\n             desc: testing::TestDesc {\n-                name: testing::DynTestName(name.clone()),\n+                name: testing::DynTestName(name),\n                 ignore: match config.ignore {\n                     Ignore::All => true,\n                     Ignore::None => false,\n@@ -905,8 +905,8 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for HirCollector<'a, 'hir> {\n     }\n \n     fn visit_item(&mut self, item: &'hir hir::Item) {\n-        let name = if let hir::ItemKind::Impl(.., ref ty, _) = item.kind {\n-            self.map.hir_to_pretty_string(ty.hir_id)\n+        let name = if let hir::ItemKind::Impl { ref self_ty, .. } = item.kind {\n+            self.map.hir_to_pretty_string(self_ty.hir_id)\n         } else {\n             item.ident.to_string()\n         };"}, {"sha": "fdff18779e7954364834429ac03cec4a16d267da", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -558,27 +558,27 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 om.trait_aliases.push(t);\n             }\n \n-            hir::ItemKind::Impl(\n+            hir::ItemKind::Impl {\n                 unsafety,\n                 polarity,\n                 defaultness,\n                 ref generics,\n-                ref trait_,\n-                for_,\n-                ref item_ids,\n-            ) => {\n+                ref of_trait,\n+                self_ty,\n+                ref items,\n+            } => {\n                 // Don't duplicate impls when inlining or if it's implementing a trait, we'll pick\n                 // them up regardless of where they're located.\n-                if !self.inlining && trait_.is_none() {\n+                if !self.inlining && of_trait.is_none() {\n                     let items =\n-                        item_ids.iter().map(|ii| self.cx.tcx.hir().impl_item(ii.id)).collect();\n+                        items.iter().map(|item| self.cx.tcx.hir().impl_item(item.id)).collect();\n                     let i = Impl {\n                         unsafety,\n                         polarity,\n                         defaultness,\n                         generics,\n-                        trait_,\n-                        for_,\n+                        trait_: of_trait,\n+                        for_: self_ty,\n                         items,\n                         attrs: &item.attrs,\n                         id: item.hir_id,"}, {"sha": "941ea6a767c57d4a7d9621324774fcdbe8e62bb9", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 14, "deletions": 58, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -44,23 +44,7 @@ impl f32 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn floor(self) -> f32 {\n-        // On MSVC LLVM will lower many math intrinsics to a call to the\n-        // corresponding function. On MSVC, however, many of these functions\n-        // aren't actually available as symbols to call, but rather they are all\n-        // `static inline` functions in header files. This means that from a C\n-        // perspective it's \"compatible\", but not so much from an ABI\n-        // perspective (which we're worried about).\n-        //\n-        // The inline header functions always just cast to a f64 and do their\n-        // operation, so we do that here as well, but only for MSVC targets.\n-        //\n-        // Note that there are many MSVC-specific float operations which\n-        // redirect to this comment, so `floorf` is just one case of a missing\n-        // function on MSVC, but there are many others elsewhere.\n-        #[cfg(target_env = \"msvc\")]\n-        return (self as f64).floor() as f32;\n-        #[cfg(not(target_env = \"msvc\"))]\n-        return unsafe { intrinsics::floorf32(self) };\n+        unsafe { intrinsics::floorf32(self) }\n     }\n \n     /// Returns the smallest integer greater than or equal to a number.\n@@ -78,11 +62,7 @@ impl f32 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn ceil(self) -> f32 {\n-        // see notes above in `floor`\n-        #[cfg(target_env = \"msvc\")]\n-        return (self as f64).ceil() as f32;\n-        #[cfg(not(target_env = \"msvc\"))]\n-        return unsafe { intrinsics::ceilf32(self) };\n+        unsafe { intrinsics::ceilf32(self) }\n     }\n \n     /// Returns the nearest integer to a number. Round half-way cases away from\n@@ -131,10 +111,10 @@ impl f32 {\n     /// ```\n     /// use std::f32;\n     ///\n-    /// let x = 3.5_f32;\n-    /// let y = -3.5_f32;\n-    /// let abs_difference_x = (x.fract() - 0.5).abs();\n-    /// let abs_difference_y = (y.fract() - (-0.5)).abs();\n+    /// let x = 3.6_f32;\n+    /// let y = -3.6_f32;\n+    /// let abs_difference_x = (x.fract() - 0.6).abs();\n+    /// let abs_difference_y = (y.fract() - (-0.6)).abs();\n     ///\n     /// assert!(abs_difference_x <= f32::EPSILON);\n     /// assert!(abs_difference_y <= f32::EPSILON);\n@@ -348,14 +328,10 @@ impl f32 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn powf(self, n: f32) -> f32 {\n-        // see notes above in `floor`\n-        #[cfg(target_env = \"msvc\")]\n-        return (self as f64).powf(n as f64) as f32;\n-        #[cfg(not(target_env = \"msvc\"))]\n-        return unsafe { intrinsics::powf32(self, n) };\n+        unsafe { intrinsics::powf32(self, n) }\n     }\n \n-    /// Takes the square root of a number.\n+    /// Returns the square root of a number.\n     ///\n     /// Returns NaN if `self` is a negative number.\n     ///\n@@ -399,11 +375,7 @@ impl f32 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn exp(self) -> f32 {\n-        // see notes above in `floor`\n-        #[cfg(target_env = \"msvc\")]\n-        return (self as f64).exp() as f32;\n-        #[cfg(not(target_env = \"msvc\"))]\n-        return unsafe { intrinsics::expf32(self) };\n+        unsafe { intrinsics::expf32(self) }\n     }\n \n     /// Returns `2^(self)`.\n@@ -447,11 +419,7 @@ impl f32 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn ln(self) -> f32 {\n-        // see notes above in `floor`\n-        #[cfg(target_env = \"msvc\")]\n-        return (self as f64).ln() as f32;\n-        #[cfg(not(target_env = \"msvc\"))]\n-        return unsafe { intrinsics::logf32(self) };\n+        unsafe { intrinsics::logf32(self) }\n     }\n \n     /// Returns the logarithm of the number with respect to an arbitrary base.\n@@ -521,11 +489,7 @@ impl f32 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn log10(self) -> f32 {\n-        // see notes above in `floor`\n-        #[cfg(target_env = \"msvc\")]\n-        return (self as f64).log10() as f32;\n-        #[cfg(not(target_env = \"msvc\"))]\n-        return unsafe { intrinsics::log10f32(self) };\n+        unsafe { intrinsics::log10f32(self) }\n     }\n \n     /// The positive difference of two numbers.\n@@ -564,7 +528,7 @@ impl f32 {\n         unsafe { cmath::fdimf(self, other) }\n     }\n \n-    /// Takes the cubic root of a number.\n+    /// Returns the cubic root of a number.\n     ///\n     /// # Examples\n     ///\n@@ -625,11 +589,7 @@ impl f32 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn sin(self) -> f32 {\n-        // see notes in `core::f32::Float::floor`\n-        #[cfg(target_env = \"msvc\")]\n-        return (self as f64).sin() as f32;\n-        #[cfg(not(target_env = \"msvc\"))]\n-        return unsafe { intrinsics::sinf32(self) };\n+        unsafe { intrinsics::sinf32(self) }\n     }\n \n     /// Computes the cosine of a number (in radians).\n@@ -649,11 +609,7 @@ impl f32 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn cos(self) -> f32 {\n-        // see notes in `core::f32::Float::floor`\n-        #[cfg(target_env = \"msvc\")]\n-        return (self as f64).cos() as f32;\n-        #[cfg(not(target_env = \"msvc\"))]\n-        return unsafe { intrinsics::cosf32(self) };\n+        unsafe { intrinsics::cosf32(self) }\n     }\n \n     /// Computes the tangent of a number (in radians)."}, {"sha": "d89b38e1a003501c1002639537b890d1bbee9163", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -109,10 +109,10 @@ impl f64 {\n     /// # Examples\n     ///\n     /// ```\n-    /// let x = 3.5_f64;\n-    /// let y = -3.5_f64;\n-    /// let abs_difference_x = (x.fract() - 0.5).abs();\n-    /// let abs_difference_y = (y.fract() - (-0.5)).abs();\n+    /// let x = 3.6_f64;\n+    /// let y = -3.6_f64;\n+    /// let abs_difference_x = (x.fract() - 0.6).abs();\n+    /// let abs_difference_y = (y.fract() - (-0.6)).abs();\n     ///\n     /// assert!(abs_difference_x < 1e-10);\n     /// assert!(abs_difference_y < 1e-10);\n@@ -323,7 +323,7 @@ impl f64 {\n         unsafe { intrinsics::powf64(self, n) }\n     }\n \n-    /// Takes the square root of a number.\n+    /// Returns the square root of a number.\n     ///\n     /// Returns NaN if `self` is a negative number.\n     ///\n@@ -506,7 +506,7 @@ impl f64 {\n         unsafe { cmath::fdim(self, other) }\n     }\n \n-    /// Takes the cubic root of a number.\n+    /// Returns the cubic root of a number.\n     ///\n     /// # Examples\n     ///"}, {"sha": "c8fae91fcf3a5c5e236a5bb8c3af9ddba1e9bb78", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -294,7 +294,7 @@\n #![feature(shrink_to)]\n #![feature(slice_concat_ext)]\n #![feature(slice_internals)]\n-#![feature(slice_patterns)]\n+#![cfg_attr(bootstrap, feature(slice_patterns))]\n #![feature(specialization)]\n #![feature(staged_api)]\n #![feature(std_internals)]"}, {"sha": "fee7ace92eaa3a965d393761cf02a5c8379d1fef", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -208,7 +208,7 @@ fn default_hook(info: &PanicInfo<'_>) {\n                     let _ = writeln!(\n                         err,\n                         \"note: run with `RUST_BACKTRACE=1` \\\n-                                           environment variable to display a backtrace.\"\n+                                           environment variable to display a backtrace\"\n                     );\n                 }\n             }"}, {"sha": "1a5421facd0c1aba216ebd195b0e72f4800e7560", "filename": "src/libstd/sys/windows/cmath.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibstd%2Fsys%2Fwindows%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibstd%2Fsys%2Fwindows%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fcmath.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -27,7 +27,7 @@ extern \"C\" {\n \n pub use self::shims::*;\n \n-#[cfg(not(target_env = \"msvc\"))]\n+#[cfg(not(all(target_env = \"msvc\", target_arch = \"x86\")))]\n mod shims {\n     use libc::c_float;\n \n@@ -43,10 +43,10 @@ mod shims {\n     }\n }\n \n-// On MSVC these functions aren't defined, so we just define shims which promote\n-// everything fo f64, perform the calculation, and then demote back to f32.\n-// While not precisely correct should be \"correct enough\" for now.\n-#[cfg(target_env = \"msvc\")]\n+// On 32-bit x86 MSVC these functions aren't defined, so we just define shims\n+// which promote everything fo f64, perform the calculation, and then demote\n+// back to f32. While not precisely correct should be \"correct enough\" for now.\n+#[cfg(all(target_env = \"msvc\", target_arch = \"x86\"))]\n mod shims {\n     use libc::c_float;\n "}, {"sha": "5bc8fe5ae6d791bd59edee9cbe418d11ca9a4af0", "filename": "src/libstd/time.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -65,7 +65,7 @@ pub use core::time::Duration;\n ///\n /// |  Platform |               System call                                            |\n /// |:---------:|:--------------------------------------------------------------------:|\n-/// | Cloud ABI | [clock_time_get (Monotonic Clock)]                                   |\n+/// | CloudABI  | [clock_time_get (Monotonic Clock)]                                   |\n /// | SGX       | [`insecure_time` usercall]. More information on [timekeeping in SGX] |\n /// | UNIX      | [clock_gettime (Monotonic Clock)]                                    |\n /// | Darwin    | [mach_absolute_time]                                                 |\n@@ -79,7 +79,7 @@ pub use core::time::Duration;\n /// [__wasi_clock_time_get (Monotonic Clock)]: https://github.com/CraneStation/wasmtime/blob/master/docs/WASI-api.md#clock_time_get\n /// [clock_gettime (Monotonic Clock)]: https://linux.die.net/man/3/clock_gettime\n /// [mach_absolute_time]: https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/KernelProgramming/services/services.html\n-/// [clock_time_get (Monotonic Clock)]: https://github.com/NuxiNL/cloudabi/blob/master/cloudabi.txt\n+/// [clock_time_get (Monotonic Clock)]: https://nuxi.nl/cloudabi/#clock_time_get\n ///\n /// **Disclaimer:** These system calls might change over time.\n ///\n@@ -144,15 +144,15 @@ pub struct Instant(time::Instant);\n ///\n /// |  Platform |               System call                                            |\n /// |:---------:|:--------------------------------------------------------------------:|\n-/// | Cloud ABI | [clock_time_get (Realtime Clock)]                                    |\n+/// | CloudABI  | [clock_time_get (Realtime Clock)]                                    |\n /// | SGX       | [`insecure_time` usercall]. More information on [timekeeping in SGX] |\n /// | UNIX      | [clock_gettime (Realtime Clock)]                                     |\n /// | DARWIN    | [gettimeofday]                                                       |\n /// | VXWorks   | [clock_gettime (Realtime Clock)]                                     |\n /// | WASI      | [__wasi_clock_time_get (Realtime Clock)]                             |\n /// | Windows   | [GetSystemTimeAsFileTime]                                            |\n ///\n-/// [clock_time_get (Realtime Clock)]: https://github.com/NuxiNL/cloudabi/blob/master/cloudabi.txt\n+/// [clock_time_get (Realtime Clock)]: https://nuxi.nl/cloudabi/#clock_time_get\n /// [`insecure_time` usercall]: https://edp.fortanix.com/docs/api/fortanix_sgx_abi/struct.Usercalls.html#method.insecure_time\n /// [timekeeping in SGX]: https://edp.fortanix.com/docs/concepts/rust-std/#codestdtimecode\n /// [gettimeofday]: http://man7.org/linux/man-pages/man2/gettimeofday.2.html"}, {"sha": "a5a4eb1583bedc10cb14aff332471431e2930b49", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -2614,15 +2614,18 @@ pub enum ItemKind {\n     /// An implementation.\n     ///\n     /// E.g., `impl<A> Foo<A> { .. }` or `impl<A> Trait for Foo<A> { .. }`.\n-    Impl(\n-        Unsafety,\n-        ImplPolarity,\n-        Defaultness,\n-        Generics,\n-        Option<TraitRef>, // (optional) trait this impl implements\n-        P<Ty>,            // self\n-        Vec<AssocItem>,\n-    ),\n+    Impl {\n+        unsafety: Unsafety,\n+        polarity: ImplPolarity,\n+        defaultness: Defaultness,\n+        generics: Generics,\n+\n+        /// The trait being implemented, if any.\n+        of_trait: Option<TraitRef>,\n+\n+        self_ty: P<Ty>,\n+        items: Vec<AssocItem>,\n+    },\n     /// A macro invocation.\n     ///\n     /// E.g., `foo!(..)`.\n@@ -2649,7 +2652,7 @@ impl ItemKind {\n             ItemKind::Union(..) => \"union\",\n             ItemKind::Trait(..) => \"trait\",\n             ItemKind::TraitAlias(..) => \"trait alias\",\n-            ItemKind::Mac(..) | ItemKind::MacroDef(..) | ItemKind::Impl(..) => \"item\",\n+            ItemKind::Mac(..) | ItemKind::MacroDef(..) | ItemKind::Impl { .. } => \"item\",\n         }\n     }\n }"}, {"sha": "b0c2aa3dbb28ead5ef9079041b1e7228b6d2866a", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -13,7 +13,7 @@\n #![feature(label_break_value)]\n #![feature(nll)]\n #![feature(try_trait)]\n-#![feature(slice_patterns)]\n+#![cfg_attr(bootstrap, feature(slice_patterns))]\n #![feature(unicode_internals)]\n #![recursion_limit = \"256\"]\n "}, {"sha": "750d054e8a0f2d4891709681bb960be492545b91", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -918,10 +918,18 @@ pub fn noop_visit_item_kind<T: MutVisitor>(kind: &mut ItemKind, vis: &mut T) {\n             vis.visit_variant_data(variant_data);\n             vis.visit_generics(generics);\n         }\n-        ItemKind::Impl(_unsafety, _polarity, _defaultness, generics, trait_ref, ty, items) => {\n+        ItemKind::Impl {\n+            unsafety: _,\n+            polarity: _,\n+            defaultness: _,\n+            generics,\n+            of_trait,\n+            self_ty,\n+            items,\n+        } => {\n             vis.visit_generics(generics);\n-            visit_opt(trait_ref, |trait_ref| vis.visit_trait_ref(trait_ref));\n-            vis.visit_ty(ty);\n+            visit_opt(of_trait, |trait_ref| vis.visit_trait_ref(trait_ref));\n+            vis.visit_ty(self_ty);\n             items.flat_map_in_place(|item| vis.flat_map_impl_item(item));\n         }\n         ItemKind::Trait(_is_auto, _unsafety, generics, bounds, items) => {"}, {"sha": "bc67980c454c0c4093e868a882d8c9d1ba345bc3", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1226,15 +1226,15 @@ impl<'a> State<'a> {\n                 self.head(visibility_qualified(&item.vis, \"union\"));\n                 self.print_struct(struct_def, generics, item.ident, item.span, true);\n             }\n-            ast::ItemKind::Impl(\n+            ast::ItemKind::Impl {\n                 unsafety,\n                 polarity,\n                 defaultness,\n                 ref generics,\n-                ref opt_trait,\n-                ref ty,\n-                ref impl_items,\n-            ) => {\n+                ref of_trait,\n+                ref self_ty,\n+                ref items,\n+            } => {\n                 self.head(\"\");\n                 self.print_visibility(&item.vis);\n                 self.print_defaultness(defaultness);\n@@ -1250,19 +1250,19 @@ impl<'a> State<'a> {\n                     self.s.word(\"!\");\n                 }\n \n-                if let Some(ref t) = *opt_trait {\n+                if let Some(ref t) = *of_trait {\n                     self.print_trait_ref(t);\n                     self.s.space();\n                     self.word_space(\"for\");\n                 }\n \n-                self.print_type(ty);\n+                self.print_type(self_ty);\n                 self.print_where_clause(&generics.where_clause);\n \n                 self.s.space();\n                 self.bopen();\n                 self.print_inner_attributes(&item.attrs);\n-                for impl_item in impl_items {\n+                for impl_item in items {\n                     self.print_assoc_item(impl_item);\n                 }\n                 self.bclose(item.span);"}, {"sha": "d03a9dfc167588b0f83930e2a0c108e0fff781d1", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -308,11 +308,19 @@ pub fn walk_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a Item) {\n             visitor.visit_generics(generics);\n             visitor.visit_enum_def(enum_definition, generics, item.id, item.span)\n         }\n-        ItemKind::Impl(_, _, _, ref generics, ref opt_trait_reference, ref typ, ref impl_items) => {\n+        ItemKind::Impl {\n+            unsafety: _,\n+            polarity: _,\n+            defaultness: _,\n+            ref generics,\n+            ref of_trait,\n+            ref self_ty,\n+            ref items,\n+        } => {\n             visitor.visit_generics(generics);\n-            walk_list!(visitor, visit_trait_ref, opt_trait_reference);\n-            visitor.visit_ty(typ);\n-            walk_list!(visitor, visit_impl_item, impl_items);\n+            walk_list!(visitor, visit_trait_ref, of_trait);\n+            visitor.visit_ty(self_ty);\n+            walk_list!(visitor, visit_impl_item, items);\n         }\n         ItemKind::Struct(ref struct_definition, ref generics)\n         | ItemKind::Union(ref struct_definition, ref generics) => {"}, {"sha": "e99473177e8384ce3603c32138358fd29db661da", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -153,12 +153,13 @@ pub fn test_main_static_abort(tests: &[&TestDescAndFn]) {\n     // If we're being run in SpawnedSecondary mode, run the test here. run_test\n     // will then exit the process.\n     if let Ok(name) = env::var(SECONDARY_TEST_INVOKER_VAR) {\n+        env::remove_var(SECONDARY_TEST_INVOKER_VAR);\n         let test = tests\n             .iter()\n             .filter(|test| test.desc.name.as_slice() == name)\n             .map(make_owned_test)\n             .next()\n-            .expect(\"couldn't find a test with the provided name\");\n+            .expect(&format!(\"couldn't find a test with the provided name '{}'\", name));\n         let TestDescAndFn { desc, testfn } = test;\n         let testfn = match testfn {\n             StaticTestFn(f) => f,\n@@ -485,9 +486,7 @@ pub fn run_test(\n         }\n         StaticBenchFn(benchfn) => {\n             // Benchmarks aren't expected to panic, so we run them all in-process.\n-            crate::bench::benchmark(desc, monitor_ch, opts.nocapture, |harness| {\n-                (benchfn.clone())(harness)\n-            });\n+            crate::bench::benchmark(desc, monitor_ch, opts.nocapture, benchfn);\n         }\n         DynTestFn(f) => {\n             match strategy {\n@@ -553,7 +552,7 @@ fn run_test_in_process(\n         Err(e) => calc_result(&desc, Err(e.as_ref()), &time_opts, &exec_time),\n     };\n     let stdout = data.lock().unwrap().to_vec();\n-    let message = CompletedTest::new(desc.clone(), test_result, exec_time, stdout);\n+    let message = CompletedTest::new(desc, test_result, exec_time, stdout);\n     monitor_ch.send(message).unwrap();\n }\n \n@@ -602,7 +601,7 @@ fn spawn_test_subprocess(\n         (result, test_output, exec_time)\n     })();\n \n-    let message = CompletedTest::new(desc.clone(), result, exec_time, test_output);\n+    let message = CompletedTest::new(desc, result, exec_time, test_output);\n     monitor_ch.send(message).unwrap();\n }\n "}, {"sha": "cd87134ab77e6bacb2128137065b328b9c35e0e5", "filename": "src/llvm-project", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm-project?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1 +1 @@\n-Subproject commit 9330ec5a4c1df5fc1fa62f993ed6a04da68cb040\n+Subproject commit cd87134ab77e6bacb2128137065b328b9c35e0e5"}, {"sha": "0c5359b9bd8c6ef05b749852be31ad8311710c04", "filename": "src/test/compile-fail/panic-handler-twice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fcompile-fail%2Fpanic-handler-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fcompile-fail%2Fpanic-handler-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpanic-handler-twice.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -10,7 +10,7 @@ use core::panic::PanicInfo;\n \n #[panic_handler]\n fn panic(info: &PanicInfo) -> ! {\n-    //~^ error duplicate lang item found: `panic_impl`\n+    //~^ ERROR found duplicate lang item `panic_impl`\n     loop {}\n }\n "}, {"sha": "ca539fb7462a5eb176eabc7eef5686632748c428", "filename": "src/test/mir-opt/const_prop/ref_deref_project.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fref_deref_project.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fref_deref_project.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fref_deref_project.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n-    *(&(4, 5).1);\n+    *(&(4, 5).1); // This does not currently propagate (#67862)\n }\n \n // END RUST SOURCE\n@@ -35,7 +35,7 @@ fn main() {\n //     ...\n //     _4 = const main::promoted[0];\n //     _2 = &((*_4).1: i32);\n-//     _1 = const 5i32;\n+//     _1 = (*_2);\n //     ...\n // }\n // END rustc.main.ConstProp.after.mir"}, {"sha": "f368bdef6f8e2d85d0fb28b6e1db639a4de3b834", "filename": "src/test/mir-opt/inline/inline-into-box-place.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fmir-opt%2Finline%2Finline-into-box-place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fmir-opt%2Finline%2Finline-into-box-place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline-into-box-place.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,5 +1,6 @@\n // ignore-tidy-linelength\n // ignore-wasm32-bare compiled with panic=abort by default\n+// compile-flags: -Z mir-opt-level=3\n #![feature(box_syntax)]\n \n fn main() {"}, {"sha": "d587d237227ad0b632ff5b64ea4f541ce2182eb3", "filename": "src/test/mir-opt/uniform_array_move_out.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fmir-opt%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fmir-opt%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Funiform_array_move_out.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,5 +1,4 @@\n #![feature(box_syntax)]\n-#![feature(slice_patterns)]\n \n fn move_out_from_end() {\n     let a = [box 1, box 2];"}, {"sha": "0cd9ab79e32f354da7361b2fb1afae9e9c1da4ec", "filename": "src/test/run-make-fulldeps/libtest-json/output-default.json", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Frun-make-fulldeps%2Flibtest-json%2Foutput-default.json", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Frun-make-fulldeps%2Flibtest-json%2Foutput-default.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Flibtest-json%2Foutput-default.json?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -2,7 +2,7 @@\n { \"type\": \"test\", \"event\": \"started\", \"name\": \"a\" }\n { \"type\": \"test\", \"name\": \"a\", \"event\": \"ok\" }\n { \"type\": \"test\", \"event\": \"started\", \"name\": \"b\" }\n-{ \"type\": \"test\", \"name\": \"b\", \"event\": \"failed\", \"stdout\": \"thread 'main' panicked at 'assertion failed: false', f.rs:9:5\\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\\n\" }\n+{ \"type\": \"test\", \"name\": \"b\", \"event\": \"failed\", \"stdout\": \"thread 'main' panicked at 'assertion failed: false', f.rs:9:5\\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\\n\" }\n { \"type\": \"test\", \"event\": \"started\", \"name\": \"c\" }\n { \"type\": \"test\", \"name\": \"c\", \"event\": \"ok\" }\n { \"type\": \"test\", \"event\": \"started\", \"name\": \"d\" }"}, {"sha": "dfaf005052e5536715377a74a725bd93dc72d890", "filename": "src/test/run-make-fulldeps/libtest-json/output-stdout-success.json", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Frun-make-fulldeps%2Flibtest-json%2Foutput-stdout-success.json", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Frun-make-fulldeps%2Flibtest-json%2Foutput-stdout-success.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Flibtest-json%2Foutput-stdout-success.json?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -2,7 +2,7 @@\n { \"type\": \"test\", \"event\": \"started\", \"name\": \"a\" }\n { \"type\": \"test\", \"name\": \"a\", \"event\": \"ok\", \"stdout\": \"print from successful test\\n\" }\n { \"type\": \"test\", \"event\": \"started\", \"name\": \"b\" }\n-{ \"type\": \"test\", \"name\": \"b\", \"event\": \"failed\", \"stdout\": \"thread 'main' panicked at 'assertion failed: false', f.rs:9:5\\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\\n\" }\n+{ \"type\": \"test\", \"name\": \"b\", \"event\": \"failed\", \"stdout\": \"thread 'main' panicked at 'assertion failed: false', f.rs:9:5\\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\\n\" }\n { \"type\": \"test\", \"event\": \"started\", \"name\": \"c\" }\n { \"type\": \"test\", \"name\": \"c\", \"event\": \"ok\", \"stdout\": \"thread 'main' panicked at 'assertion failed: false', f.rs:15:5\\n\" }\n { \"type\": \"test\", \"event\": \"started\", \"name\": \"d\" }"}, {"sha": "7f5e9049b2f77e3acd72cb1bef34b33ef39e377e", "filename": "src/test/run-make-fulldeps/sanitizer-address/Makefile", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/470cdf54ac9acee20ab8da46ef7899bae9f58f29/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-address%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/470cdf54ac9acee20ab8da46ef7899bae9f58f29/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-address%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-address%2FMakefile?ref=470cdf54ac9acee20ab8da46ef7899bae9f58f29", "patch": "@@ -1,30 +0,0 @@\n-# needs-sanitizer-support\n-\n--include ../tools.mk\n-\n-LOG := $(TMPDIR)/log.txt\n-\n-# NOTE the address sanitizer only supports x86_64 linux and macOS\n-\n-ifeq ($(TARGET),x86_64-apple-darwin)\n-EXTRA_RUSTFLAG=-C rpath\n-else\n-ifeq ($(TARGET),x86_64-unknown-linux-gnu)\n-\n-# Apparently there are very specific Linux kernels, notably the one that's\n-# currently on Travis CI, which contain a buggy commit that triggers failures in\n-# the ASan implementation, detailed at google/sanitizers#837. As noted in\n-# google/sanitizers#856 the \"fix\" is to avoid using PIE binaries, so we pass a\n-# different relocation model to avoid generating a PIE binary. Once Travis is no\n-# longer running kernel 4.4.0-93 we can remove this and pass an empty set of\n-# flags again.\n-EXTRA_RUSTFLAG=-C relocation-model=dynamic-no-pic\n-endif\n-endif\n-\n-all:\n-\t$(RUSTC) -g -Z sanitizer=address -Z print-link-args $(EXTRA_RUSTFLAG) overflow.rs | $(CGREP) rustc_rt.asan\n-\t# Verify that stack buffer overflow is detected:\n-\t$(TMPDIR)/overflow 2>&1 | $(CGREP) stack-buffer-overflow\n-\t# Verify that variable name is included in address sanitizer report:\n-\t$(TMPDIR)/overflow 2>&1 | $(CGREP) \"'xs'\""}, {"sha": "b997a74cc3eb4ac0d810076e9a298ff51f8131b7", "filename": "src/test/run-make-fulldeps/sanitizer-address/overflow.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/470cdf54ac9acee20ab8da46ef7899bae9f58f29/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-address%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470cdf54ac9acee20ab8da46ef7899bae9f58f29/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-address%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-address%2Foverflow.rs?ref=470cdf54ac9acee20ab8da46ef7899bae9f58f29", "patch": "@@ -1,4 +0,0 @@\n-fn main() {\n-    let xs = [0, 1, 2, 3];\n-    let _y = unsafe { *xs.as_ptr().offset(4) };\n-}"}, {"sha": "2a23f0fe3d4ef1d5465db9e0b7ecf59ac0c44b9c", "filename": "src/test/run-make-fulldeps/sanitizer-invalid-target/Makefile", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/470cdf54ac9acee20ab8da46ef7899bae9f58f29/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-invalid-target%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/470cdf54ac9acee20ab8da46ef7899bae9f58f29/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-invalid-target%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-invalid-target%2FMakefile?ref=470cdf54ac9acee20ab8da46ef7899bae9f58f29", "patch": "@@ -1,5 +0,0 @@\n--include ../tools.mk\n-\n-all:\n-\t$(RUSTC) -Z sanitizer=leak --target i686-unknown-linux-gnu hello.rs 2>&1 | \\\n-\t\t$(CGREP) 'LeakSanitizer only works with the `x86_64-unknown-linux-gnu` or `x86_64-apple-darwin` target'"}, {"sha": "d3dd5ed03d9548e1015db5a13d339fc7971be813", "filename": "src/test/run-make-fulldeps/sanitizer-invalid-target/hello.rs", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/470cdf54ac9acee20ab8da46ef7899bae9f58f29/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-invalid-target%2Fhello.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470cdf54ac9acee20ab8da46ef7899bae9f58f29/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-invalid-target%2Fhello.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-invalid-target%2Fhello.rs?ref=470cdf54ac9acee20ab8da46ef7899bae9f58f29", "patch": "@@ -1,3 +0,0 @@\n-#![feature(no_core)]\n-#![no_core]\n-#![no_main]"}, {"sha": "d8598b8ac93f90815226bf832d06c647d8bc6dac", "filename": "src/test/run-make-fulldeps/sanitizer-leak/Makefile", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/470cdf54ac9acee20ab8da46ef7899bae9f58f29/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-leak%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/470cdf54ac9acee20ab8da46ef7899bae9f58f29/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-leak%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-leak%2FMakefile?ref=470cdf54ac9acee20ab8da46ef7899bae9f58f29", "patch": "@@ -1,11 +0,0 @@\n--include ../tools.mk\n-\n-# needs-sanitizer-support\n-# only-linux\n-# only-x86_64\n-# ignore-test\n-# FIXME(#46126) ThinLTO for libstd broke this test\n-\n-all:\n-\t$(RUSTC) -C opt-level=1 -g -Z sanitizer=leak -Z print-link-args leak.rs | $(CGREP) rustc_rt.lsan\n-\t$(TMPDIR)/leak 2>&1 | $(CGREP) 'detected memory leaks'"}, {"sha": "ab8df5c7bfd450df1a493667b43e2b4f4f0750d4", "filename": "src/test/run-make-fulldeps/sanitizer-leak/leak.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/470cdf54ac9acee20ab8da46ef7899bae9f58f29/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-leak%2Fleak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470cdf54ac9acee20ab8da46ef7899bae9f58f29/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-leak%2Fleak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-leak%2Fleak.rs?ref=470cdf54ac9acee20ab8da46ef7899bae9f58f29", "patch": "@@ -1,6 +0,0 @@\n-use std::mem;\n-\n-fn main() {\n-    let xs = vec![1, 2, 3, 4];\n-    mem::forget(xs);\n-}"}, {"sha": "8bc9df1b4baebbaa5d23d2521e1891439df19d97", "filename": "src/test/run-make-fulldeps/sanitizer-memory/Makefile", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/470cdf54ac9acee20ab8da46ef7899bae9f58f29/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-memory%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/470cdf54ac9acee20ab8da46ef7899bae9f58f29/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-memory%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-memory%2FMakefile?ref=470cdf54ac9acee20ab8da46ef7899bae9f58f29", "patch": "@@ -1,11 +0,0 @@\n--include ../tools.mk\n-\n-# needs-sanitizer-support\n-# only-linux\n-# only-x86_64\n-\n-all:\n-\t$(RUSTC) -g -Z sanitizer=memory -Z print-link-args uninit.rs | $(CGREP) rustc_rt.msan\n-\t$(TMPDIR)/uninit 2>&1 | $(CGREP) use-of-uninitialized-value\n-\t$(RUSTC) -g -Z sanitizer=memory -Z print-link-args maybeuninit.rs | $(CGREP) rustc_rt.msan\n-\t$(TMPDIR)/maybeuninit 2>&1 | $(CGREP) use-of-uninitialized-value"}, {"sha": "a9ae85f57639e8d8e78f38d19cc83fc2ef829c04", "filename": "src/test/run-make-fulldeps/sanitizer-memory/maybeuninit.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/470cdf54ac9acee20ab8da46ef7899bae9f58f29/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-memory%2Fmaybeuninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470cdf54ac9acee20ab8da46ef7899bae9f58f29/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-memory%2Fmaybeuninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-memory%2Fmaybeuninit.rs?ref=470cdf54ac9acee20ab8da46ef7899bae9f58f29", "patch": "@@ -1,8 +0,0 @@\n-use std::mem::MaybeUninit;\n-\n-fn main() {\n-    // This is technically not sound -- but we're literally trying to test\n-    // that the sanitizer catches this, so I guess \"intentionally unsound\"?\n-    let xs: [u8; 4] = unsafe { MaybeUninit::uninit().assume_init() };\n-    let y = xs[0] + xs[1];\n-}"}, {"sha": "eae52508f658543ee92825830af6aebe13176880", "filename": "src/test/run-make-fulldeps/sanitizer-memory/uninit.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/470cdf54ac9acee20ab8da46ef7899bae9f58f29/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-memory%2Funinit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/470cdf54ac9acee20ab8da46ef7899bae9f58f29/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-memory%2Funinit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsanitizer-memory%2Funinit.rs?ref=470cdf54ac9acee20ab8da46ef7899bae9f58f29", "patch": "@@ -1,7 +0,0 @@\n-fn main() {\n-    // This is technically not sound -- but we're literally trying to test\n-    // that the sanitizer catches this, so I guess \"intentionally unsound\"?\n-    #[allow(deprecated)]\n-    let xs: [u8; 4] = unsafe { std::mem::uninitialized() };\n-    let y = xs[0] + xs[1];\n-}"}, {"sha": "ee79ae1a690ecb251b9c5d60519dc4333289bac9", "filename": "src/test/rustdoc-ui/failed-doctest-output.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -27,7 +27,7 @@ stderr:\n stderr 1\n stderr 2\n thread 'main' panicked at 'oh no', $DIR/failed-doctest-output.rs:7:1\n-note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\n+note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n \n \n "}, {"sha": "ae8fbe4a2a800d2d7440558bffde05fb184ee297", "filename": "src/test/rustdoc/bad-codeblock-syntax.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Frustdoc%2Fbad-codeblock-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Frustdoc%2Fbad-codeblock-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fbad-codeblock-syntax.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -25,3 +25,11 @@ pub fn quux() {}\n /// \\_\n /// ```\n pub fn ok() {}\n+\n+// @has bad_codeblock_syntax/fn.escape.html\n+// @has - '//*[@class=\"docblock\"]/pre/code' '\\_ <script>alert(\"not valid Rust\");</script>'\n+/// ```\n+/// \\_\n+/// <script>alert(\"not valid Rust\");</script>\n+/// ```\n+pub fn escape() {}"}, {"sha": "770f8d7289c3bb2ce26a7c3698f6999a9afc7cc3", "filename": "src/test/rustdoc/deref-typedef.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Frustdoc%2Fderef-typedef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Frustdoc%2Fderef-typedef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fderef-typedef.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -0,0 +1,33 @@\n+#![crate_name = \"foo\"]\n+\n+// @has 'foo/struct.Bar.html'\n+// @has '-' '//*[@id=\"deref-methods\"]' 'Methods from Deref<Target = FooC>'\n+// @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.foo_a\"]' 'pub fn foo_a(&self)'\n+// @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.foo_b\"]' 'pub fn foo_b(&self)'\n+// @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.foo_c\"]' 'pub fn foo_c(&self)'\n+// @has '-' '//*[@class=\"sidebar-title\"]' 'Methods from Deref<Target=FooC>'\n+// @has '-' '//*[@class=\"sidebar-links\"]/a[@href=\"#method.foo_a\"]' 'foo_a'\n+// @has '-' '//*[@class=\"sidebar-links\"]/a[@href=\"#method.foo_b\"]' 'foo_b'\n+// @has '-' '//*[@class=\"sidebar-links\"]/a[@href=\"#method.foo_c\"]' 'foo_c'\n+\n+pub struct FooA;\n+pub type FooB = FooA;\n+pub type FooC = FooB;\n+\n+impl FooA {\n+    pub fn foo_a(&self) {}\n+}\n+\n+impl FooB {\n+    pub fn foo_b(&self) {}\n+}\n+\n+impl FooC {\n+    pub fn foo_c(&self) {}\n+}\n+\n+pub struct Bar;\n+impl std::ops::Deref for Bar {\n+    type Target = FooC;\n+    fn deref(&self) -> &Self::Target { unimplemented!() }\n+}"}, {"sha": "9761c1ddbe23f2e417ee4769105e61b12463a8c8", "filename": "src/test/rustdoc/remove-url-from-headings.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Frustdoc%2Fremove-url-from-headings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Frustdoc%2Fremove-url-from-headings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fremove-url-from-headings.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -0,0 +1,17 @@\n+#![crate_name = \"foo\"]\n+\n+// @has foo/fn.foo.html\n+// !@has - '//a[@href=\"http://a.a\"]'\n+// @has - '//a[@href=\"#implementing-stuff-somewhere\"]' 'Implementing stuff somewhere'\n+// @has - '//a[@href=\"#another-one-urg\"]' 'Another one urg'\n+\n+/// fooo\n+///\n+/// # Implementing [stuff](http://a.a \"title\") somewhere\n+///\n+/// hello\n+///\n+/// # Another [one][two] urg\n+///\n+/// [two]: http://a.a\n+pub fn foo() {}"}, {"sha": "8e4fa70d342f2e0ff91db8c82ca39c0898f42ebb", "filename": "src/test/ui/anon-params-deprecated.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fanon-params-deprecated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fanon-params-deprecated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fanon-params-deprecated.stderr?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -2,7 +2,7 @@ warning: anonymous parameters are deprecated and will be removed in the next edi\n   --> $DIR/anon-params-deprecated.rs:9:12\n    |\n LL |     fn foo(i32);\n-   |            ^^^ help: Try naming the parameter or explicitly ignoring it: `_: i32`\n+   |            ^^^ help: try naming the parameter or explicitly ignoring it: `_: i32`\n    |\n note: lint level defined here\n   --> $DIR/anon-params-deprecated.rs:1:9\n@@ -16,7 +16,7 @@ warning: anonymous parameters are deprecated and will be removed in the next edi\n   --> $DIR/anon-params-deprecated.rs:12:30\n    |\n LL |     fn bar_with_default_impl(String, String) {}\n-   |                              ^^^^^^ help: Try naming the parameter or explicitly ignoring it: `_: String`\n+   |                              ^^^^^^ help: try naming the parameter or explicitly ignoring it: `_: String`\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2018 edition!\n    = note: for more information, see issue #41686 <https://github.com/rust-lang/rust/issues/41686>\n@@ -25,7 +25,7 @@ warning: anonymous parameters are deprecated and will be removed in the next edi\n   --> $DIR/anon-params-deprecated.rs:12:38\n    |\n LL |     fn bar_with_default_impl(String, String) {}\n-   |                                      ^^^^^^ help: Try naming the parameter or explicitly ignoring it: `_: String`\n+   |                                      ^^^^^^ help: try naming the parameter or explicitly ignoring it: `_: String`\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2018 edition!\n    = note: for more information, see issue #41686 <https://github.com/rust-lang/rust/issues/41686>"}, {"sha": "34adb42a32f961d23f7f51719d657277c8706a76", "filename": "src/test/ui/array-slice-vec/slice-pat-type-mismatches.rs", "status": "renamed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Farray-slice-vec%2Fslice-pat-type-mismatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Farray-slice-vec%2Fslice-pat-type-mismatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fslice-pat-type-mismatches.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,5 +1,3 @@\n-#![feature(slice_patterns)]\n-\n fn main() {\n     match \"foo\".to_string() {\n         ['f', 'o', ..] => {}", "previous_filename": "src/test/ui/match/match-vec-mismatch.rs"}, {"sha": "c4548142c13ef99f3a1898a5ab5e036d8080e356", "filename": "src/test/ui/array-slice-vec/slice-pat-type-mismatches.stderr", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Farray-slice-vec%2Fslice-pat-type-mismatches.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Farray-slice-vec%2Fslice-pat-type-mismatches.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fslice-pat-type-mismatches.stderr?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,29 +1,29 @@\n error[E0425]: cannot find value `does_not_exist` in this scope\n-  --> $DIR/match-vec-mismatch.rs:28:11\n+  --> $DIR/slice-pat-type-mismatches.rs:26:11\n    |\n LL |     match does_not_exist {\n    |           ^^^^^^^^^^^^^^ not found in this scope\n \n error[E0529]: expected an array or slice, found `std::string::String`\n-  --> $DIR/match-vec-mismatch.rs:5:9\n+  --> $DIR/slice-pat-type-mismatches.rs:3:9\n    |\n LL |         ['f', 'o', ..] => {}\n    |         ^^^^^^^^^^^^^^ pattern cannot match with input type `std::string::String`\n \n error[E0527]: pattern requires 1 element but array has 3\n-  --> $DIR/match-vec-mismatch.rs:20:9\n+  --> $DIR/slice-pat-type-mismatches.rs:18:9\n    |\n LL |         [0] => {},\n    |         ^^^ expected 3 elements\n \n error[E0528]: pattern requires at least 4 elements but array has 3\n-  --> $DIR/match-vec-mismatch.rs:25:9\n+  --> $DIR/slice-pat-type-mismatches.rs:23:9\n    |\n LL |         [0, 1, 2, 3, x @ ..] => {}\n    |         ^^^^^^^^^^^^^^^^^^^^ pattern cannot match array of 3 elements\n \n error[E0282]: type annotations needed\n-  --> $DIR/match-vec-mismatch.rs:36:9\n+  --> $DIR/slice-pat-type-mismatches.rs:34:9\n    |\n LL |         [] => {}\n    |         ^^ cannot infer type", "previous_filename": "src/test/ui/match/match-vec-mismatch.stderr"}, {"sha": "97e33624bf6deb4c8a3eab08b0b5e1122764eb01", "filename": "src/test/ui/array-slice-vec/subslice-only-once-semantic-restriction.rs", "status": "renamed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-only-once-semantic-restriction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-only-once-semantic-restriction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-only-once-semantic-restriction.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -3,8 +3,6 @@ fn main() {\n     match a {\n         [1, tail @ .., tail @ ..] => {},\n         //~^ ERROR identifier `tail` is bound more than once in the same pattern\n-        //~| ERROR subslice patterns are unstable\n-        //~| ERROR subslice patterns are unstable\n         //~| ERROR `..` can only be used once per slice pattern\n         _ => ()\n     }", "previous_filename": "src/test/ui/parser/match-vec-invalid.rs"}, {"sha": "4d6078788b2283420d065fb942bb702f5d325c43", "filename": "src/test/ui/array-slice-vec/subslice-only-once-semantic-restriction.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-only-once-semantic-restriction.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-only-once-semantic-restriction.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-only-once-semantic-restriction.stderr?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -0,0 +1,24 @@\n+error[E0416]: identifier `tail` is bound more than once in the same pattern\n+  --> $DIR/subslice-only-once-semantic-restriction.rs:4:24\n+   |\n+LL |         [1, tail @ .., tail @ ..] => {},\n+   |                        ^^^^ used in a pattern more than once\n+\n+error: `..` can only be used once per slice pattern\n+  --> $DIR/subslice-only-once-semantic-restriction.rs:4:31\n+   |\n+LL |         [1, tail @ .., tail @ ..] => {},\n+   |                    --         ^^ can only be used once per slice pattern\n+   |                    |\n+   |                    previously used here\n+\n+error[E0308]: mismatched types\n+  --> $DIR/subslice-only-once-semantic-restriction.rs:11:30\n+   |\n+LL | const RECOVERY_WITNESS: () = 0;\n+   |                              ^ expected `()`, found integer\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors have detailed explanations: E0308, E0416.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "69c33921868cfd0a62c2b909a021f14f8b5ebacd", "filename": "src/test/ui/array-slice-vec/subslice-patterns-const-eval-match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-patterns-const-eval-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-patterns-const-eval-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-patterns-const-eval-match.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -2,7 +2,7 @@\n \n // run-pass\n \n-#![feature(slice_patterns, const_fn, const_if_match)]\n+#![feature(const_fn, const_if_match)]\n #[derive(PartialEq, Debug, Clone)]\n struct N(u8);\n "}, {"sha": "0b793fa0120e99f1f1988b409a4e444ad4d3e2ff", "filename": "src/test/ui/array-slice-vec/subslice-patterns-const-eval.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-patterns-const-eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-patterns-const-eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-patterns-const-eval.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -2,8 +2,6 @@\n \n // run-pass\n \n-#![feature(slice_patterns)]\n-\n #[derive(PartialEq, Debug, Clone)]\n struct N(u8);\n "}, {"sha": "e05790911f52d9b3e0ca2eb9fcb233ba7607edbf", "filename": "src/test/ui/array-slice-vec/subslice-patterns-pass.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-patterns-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-patterns-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fsubslice-patterns-pass.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -4,8 +4,6 @@\n \n // run-pass\n \n-#![feature(slice_patterns)]\n-\n #![allow(unreachable_patterns)]\n \n use std::convert::identity;"}, {"sha": "fdeb7e4fda640a5c118ab5eed6d1cae4a1d4e5c8", "filename": "src/test/ui/array-slice-vec/vec-matching-fixed.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec-matching-fixed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec-matching-fixed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec-matching-fixed.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,7 +1,5 @@\n // run-pass\n \n-#![feature(slice_patterns)]\n-\n fn a() {\n     let x = [1, 2, 3];\n     match x {"}, {"sha": "998899271e4114a05c461eae5c6345ae9b7a4f7c", "filename": "src/test/ui/array-slice-vec/vec-matching-fold.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec-matching-fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec-matching-fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec-matching-fold.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,7 +1,5 @@\n // run-pass\n \n-#![feature(slice_patterns)]\n-\n use std::fmt::Debug;\n \n fn foldl<T, U, F>(values: &[T],"}, {"sha": "ed34f074a929aa53fb1617434f54846da5aa041a", "filename": "src/test/ui/array-slice-vec/vec-matching-legal-tail-element-borrow.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec-matching-legal-tail-element-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec-matching-legal-tail-element-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec-matching-legal-tail-element-borrow.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,7 +1,6 @@\n // run-pass\n-#![allow(unused_variables)]\n \n-#![feature(slice_patterns)]\n+#![allow(unused_variables)]\n \n pub fn main() {\n     let x = &[1, 2, 3, 4, 5];"}, {"sha": "7009244aa189a9e79b54b9494dc4ec840ef85e0b", "filename": "src/test/ui/array-slice-vec/vec-matching.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec-matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec-matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec-matching.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,7 +1,5 @@\n // run-pass\n \n-#![feature(slice_patterns)]\n-\n fn a() {\n     let x = [1];\n     match x {"}, {"sha": "5f1699227d8e601634a2b2ff0e91e28b3226ae9b", "filename": "src/test/ui/array-slice-vec/vec-tail-matching.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec-tail-matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec-tail-matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec-tail-matching.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,7 +1,5 @@\n // run-pass\n \n-#![feature(slice_patterns)]\n-\n struct Foo {\n     string: &'static str\n }"}, {"sha": "77712168a0fd912125877ee64d983167817bf908", "filename": "src/test/ui/associated-types/issue-64848.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fassociated-types%2Fissue-64848.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fassociated-types%2Fissue-64848.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-64848.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -0,0 +1,29 @@\n+// build-pass\n+\n+trait AssociatedConstant {\n+    const DATA: ();\n+}\n+\n+impl<F, T> AssociatedConstant for F\n+where\n+    F: FnOnce() -> T,\n+    T: AssociatedConstant,\n+{\n+    const DATA: () = T::DATA;\n+}\n+\n+impl AssociatedConstant for () {\n+    const DATA: () = ();\n+}\n+\n+fn foo() -> impl AssociatedConstant {\n+    ()\n+}\n+\n+fn get_data<T: AssociatedConstant>(_: T) -> &'static () {\n+    &T::DATA\n+}\n+\n+fn main() {\n+    get_data(foo);\n+}"}, {"sha": "f59dbc263840077dbb02bb71b9717ec71494230f", "filename": "src/test/ui/async-await/issue-64130-4-async-move.stderr", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-64130-4-async-move.stderr?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,8 +1,17 @@\n error: future cannot be sent between threads safely\n   --> $DIR/issue-64130-4-async-move.rs:15:17\n    |\n-LL | pub fn foo() -> impl Future + Send {\n-   |                 ^^^^^^^^^^^^^^^^^^ future returned by `foo` is not `Send`\n+LL |   pub fn foo() -> impl Future + Send {\n+   |                   ^^^^^^^^^^^^^^^^^^ future returned by `foo` is not `Send`\n+...\n+LL | /     async move {\n+LL | |         match client.status() {\n+LL | |             200 => {\n+LL | |                 let _x = get().await;\n+...  |\n+LL | |         }\n+LL | |     }\n+   | |_____- this returned value is of type `impl std::future::Future`\n    |\n    = help: the trait `std::marker::Sync` is not implemented for `(dyn std::any::Any + std::marker::Send + 'static)`\n note: future is not `Send` as this value is used across an await\n@@ -16,6 +25,11 @@ LL |                 let _x = get().await;\n ...\n LL |     }\n    |     - `client` is later dropped here\n+help: consider moving this method call into a `let` binding to create a shorter lived borrow\n+  --> $DIR/issue-64130-4-async-move.rs:19:15\n+   |\n+LL |         match client.status() {\n+   |               ^^^^^^^^^^^^^^^\n    = note: the return type of a function must have a statically known size\n \n error: aborting due to previous error"}, {"sha": "f6e4c8be29260a5f769c3290ca68bbbf25926e79", "filename": "src/test/ui/async-await/mutually-recursive-async-impl-trait-type.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fasync-await%2Fmutually-recursive-async-impl-trait-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fasync-await%2Fmutually-recursive-async-impl-trait-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmutually-recursive-async-impl-trait-type.stderr?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -4,15 +4,15 @@ error[E0733]: recursion in an `async fn` requires boxing\n LL | async fn rec_1() {\n    |                  ^ recursive `async fn`\n    |\n-   = note: a recursive `async fn` must be rewritten to return a boxed `dyn Future`.\n+   = note: a recursive `async fn` must be rewritten to return a boxed `dyn Future`\n \n error[E0733]: recursion in an `async fn` requires boxing\n   --> $DIR/mutually-recursive-async-impl-trait-type.rs:9:18\n    |\n LL | async fn rec_2() {\n    |                  ^ recursive `async fn`\n    |\n-   = note: a recursive `async fn` must be rewritten to return a boxed `dyn Future`.\n+   = note: a recursive `async fn` must be rewritten to return a boxed `dyn Future`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "892d91e3a4992706fdb93558374f7d5048829e4d", "filename": "src/test/ui/async-await/recursive-async-impl-trait-type.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fasync-await%2Frecursive-async-impl-trait-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fasync-await%2Frecursive-async-impl-trait-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Frecursive-async-impl-trait-type.stderr?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -4,7 +4,7 @@ error[E0733]: recursion in an `async fn` requires boxing\n LL | async fn recursive_async_function() -> () {\n    |                                        ^^ recursive `async fn`\n    |\n-   = note: a recursive `async fn` must be rewritten to return a boxed `dyn Future`.\n+   = note: a recursive `async fn` must be rewritten to return a boxed `dyn Future`\n \n error: aborting due to previous error\n "}, {"sha": "0d0dbcaf40f4349de9c61afe800c7842080d79dc", "filename": "src/test/ui/binding/empty-types-in-patterns.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fbinding%2Fempty-types-in-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fbinding%2Fempty-types-in-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinding%2Fempty-types-in-patterns.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,7 +1,8 @@\n // run-pass\n+\n #![feature(never_type, never_type_fallback)]\n #![feature(exhaustive_patterns)]\n-#![feature(slice_patterns)]\n+\n #![allow(unreachable_patterns)]\n #![allow(unreachable_code)]\n #![allow(unused_variables)]"}, {"sha": "048e1e5e9b4b6b81297e637a6abb2423ddf49369", "filename": "src/test/ui/binding/irrefutable-slice-patterns.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fbinding%2Firrefutable-slice-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fbinding%2Firrefutable-slice-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinding%2Firrefutable-slice-patterns.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,7 +1,6 @@\n // run-pass\n-// #47096\n \n-#![feature(slice_patterns)]\n+// Regression test for #47096.\n \n fn foo(s: &[i32]) -> &[i32] {\n     let &[ref xs @ ..] = s;"}, {"sha": "f0c988c01c2b843291ac193cf42fc1a68337f7d8", "filename": "src/test/ui/binding/match-byte-array-patterns.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fbinding%2Fmatch-byte-array-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fbinding%2Fmatch-byte-array-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinding%2Fmatch-byte-array-patterns.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,5 +1,4 @@\n // run-pass\n-#![feature(slice_patterns)]\n \n fn main() {\n     let buf = &[0u8; 4];"}, {"sha": "af95eb95df04cab1cc6f854423e9963442372448", "filename": "src/test/ui/binding/match-vec-alternatives.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fbinding%2Fmatch-vec-alternatives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fbinding%2Fmatch-vec-alternatives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinding%2Fmatch-vec-alternatives.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,5 +1,4 @@\n // run-pass\n-#![feature(slice_patterns)]\n \n fn match_vecs<'a, T>(l1: &'a [T], l2: &'a [T]) -> &'static str {\n     match (l1, l2) {"}, {"sha": "187c2983633e7dcb3a18e34bfa56102393ccfd0f", "filename": "src/test/ui/binding/zero_sized_subslice_match.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fbinding%2Fzero_sized_subslice_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fbinding%2Fzero_sized_subslice_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinding%2Fzero_sized_subslice_match.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,5 +1,4 @@\n // run-pass\n-#![feature(slice_patterns)]\n \n fn main() {\n     let x = [(), ()];"}, {"sha": "0229ca37a692aa3d2a8ff5001e62b4eec0a92656", "filename": "src/test/ui/borrowck/borrowck-closures-slice-patterns-ok.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-slice-patterns-ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-slice-patterns-ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-slice-patterns-ok.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,6 +1,5 @@\n // Check that closure captures for slice patterns are inferred correctly\n \n-#![feature(slice_patterns)]\n #![allow(unused_variables)]\n \n // run-pass"}, {"sha": "32057d5c126ed4782b78bd0575d724c05388984f", "filename": "src/test/ui/borrowck/borrowck-closures-slice-patterns.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-slice-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-slice-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-slice-patterns.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,7 +1,5 @@\n // Check that closure captures for slice patterns are inferred correctly\n \n-#![feature(slice_patterns)]\n-\n fn arr_by_ref(mut x: [String; 3]) {\n     let f = || {\n         let [ref y, ref z @ ..] = x;"}, {"sha": "483975e5778a893c5cd5ef750c11c9f51753f2dc", "filename": "src/test/ui/borrowck/borrowck-closures-slice-patterns.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-slice-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-slice-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-slice-patterns.stderr?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,5 +1,5 @@\n error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-closures-slice-patterns.rs:9:13\n+  --> $DIR/borrowck-closures-slice-patterns.rs:7:13\n    |\n LL |     let f = || {\n    |             -- immutable borrow occurs here\n@@ -13,7 +13,7 @@ LL |     f();\n    |     - immutable borrow later used here\n \n error[E0502]: cannot borrow `x` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-closures-slice-patterns.rs:18:13\n+  --> $DIR/borrowck-closures-slice-patterns.rs:16:13\n    |\n LL |     let mut f = || {\n    |                 -- mutable borrow occurs here\n@@ -27,7 +27,7 @@ LL |     f();\n    |     - mutable borrow later used here\n \n error[E0382]: borrow of moved value: `x`\n-  --> $DIR/borrowck-closures-slice-patterns.rs:27:5\n+  --> $DIR/borrowck-closures-slice-patterns.rs:25:5\n    |\n LL | fn arr_by_move(x: [String; 3]) {\n    |                - move occurs because `x` has type `[std::string::String; 3]`, which does not implement the `Copy` trait\n@@ -40,7 +40,7 @@ LL |     &x;\n    |     ^^ value borrowed here after move\n \n error[E0502]: cannot borrow `*x` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-closures-slice-patterns.rs:35:13\n+  --> $DIR/borrowck-closures-slice-patterns.rs:33:13\n    |\n LL |     let f = || {\n    |             -- immutable borrow occurs here\n@@ -54,7 +54,7 @@ LL |     f();\n    |     - immutable borrow later used here\n \n error[E0501]: cannot borrow `x` as immutable because previous closure requires unique access\n-  --> $DIR/borrowck-closures-slice-patterns.rs:44:13\n+  --> $DIR/borrowck-closures-slice-patterns.rs:42:13\n    |\n LL |     let mut f = || {\n    |                 -- closure construction occurs here\n@@ -68,7 +68,7 @@ LL |     f();\n    |     - first borrow later used here\n \n error[E0382]: borrow of moved value: `x`\n-  --> $DIR/borrowck-closures-slice-patterns.rs:53:5\n+  --> $DIR/borrowck-closures-slice-patterns.rs:51:5\n    |\n LL | fn arr_box_by_move(x: Box<[String; 3]>) {\n    |                    - move occurs because `x` has type `std::boxed::Box<[std::string::String; 3]>`, which does not implement the `Copy` trait\n@@ -81,7 +81,7 @@ LL |     &x;\n    |     ^^ value borrowed here after move\n \n error[E0502]: cannot borrow `*x` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-closures-slice-patterns.rs:61:13\n+  --> $DIR/borrowck-closures-slice-patterns.rs:59:13\n    |\n LL |     let f = || {\n    |             -- immutable borrow occurs here\n@@ -95,7 +95,7 @@ LL |     f();\n    |     - immutable borrow later used here\n \n error[E0501]: cannot borrow `x` as immutable because previous closure requires unique access\n-  --> $DIR/borrowck-closures-slice-patterns.rs:70:13\n+  --> $DIR/borrowck-closures-slice-patterns.rs:68:13\n    |\n LL |     let mut f = || {\n    |                 -- closure construction occurs here"}, {"sha": "c8bfbe0729c59032e489b84c9f51445cded345f7", "filename": "src/test/ui/borrowck/borrowck-describe-lvalue.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-describe-lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-describe-lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-describe-lvalue.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,7 +1,5 @@\n // ignore-tidy-linelength\n \n-#![feature(slice_patterns)]\n-\n pub struct Foo {\n   x: u32\n }"}, {"sha": "075e0e2e4515e69a99a5f472ec9473cc0c33d6fe", "filename": "src/test/ui/borrowck/borrowck-describe-lvalue.stderr", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-describe-lvalue.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-describe-lvalue.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-describe-lvalue.stderr?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,5 +1,5 @@\n error[E0499]: cannot borrow `x` as mutable more than once at a time\n-  --> $DIR/borrowck-describe-lvalue.rs:258:13\n+  --> $DIR/borrowck-describe-lvalue.rs:256:13\n    |\n LL |             let y = &mut x;\n    |                     ------ first mutable borrow occurs here\n@@ -9,7 +9,7 @@ LL |             *y = 1;\n    |             ------ first borrow later used here\n \n error[E0499]: cannot borrow `x` as mutable more than once at a time\n-  --> $DIR/borrowck-describe-lvalue.rs:268:20\n+  --> $DIR/borrowck-describe-lvalue.rs:266:20\n    |\n LL |                    let y = &mut x;\n    |                            ------ first mutable borrow occurs here\n@@ -19,7 +19,7 @@ LL |                    *y = 1;\n    |                    ------ first borrow later used here\n \n error: captured variable cannot escape `FnMut` closure body\n-  --> $DIR/borrowck-describe-lvalue.rs:266:16\n+  --> $DIR/borrowck-describe-lvalue.rs:264:16\n    |\n LL |              || {\n    |               - inferred to be a `FnMut` closure\n@@ -35,7 +35,7 @@ LL | |                 }\n    = note: ...therefore, they cannot allow references to captured variables to escape\n \n error[E0503]: cannot use `f.x` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:41:9\n+  --> $DIR/borrowck-describe-lvalue.rs:39:9\n    |\n LL |         let x = f.x();\n    |                 - borrow of `f` occurs here\n@@ -45,7 +45,7 @@ LL |         drop(x);\n    |              - borrow later used here\n \n error[E0503]: cannot use `g.0` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:48:9\n+  --> $DIR/borrowck-describe-lvalue.rs:46:9\n    |\n LL |         let x = g.x();\n    |                 - borrow of `g` occurs here\n@@ -55,7 +55,7 @@ LL |         drop(x);\n    |              - borrow later used here\n \n error[E0503]: cannot use `h.0` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:55:9\n+  --> $DIR/borrowck-describe-lvalue.rs:53:9\n    |\n LL |         let x = &mut h.0;\n    |                 -------- borrow of `h.0` occurs here\n@@ -65,7 +65,7 @@ LL |         drop(x);\n    |              - borrow later used here\n \n error[E0503]: cannot use `e.0` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:63:20\n+  --> $DIR/borrowck-describe-lvalue.rs:61:20\n    |\n LL |         let x = e.x();\n    |                 - borrow of `e` occurs here\n@@ -77,7 +77,7 @@ LL |         drop(x);\n    |              - borrow later used here\n \n error[E0503]: cannot use `u.a` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:71:9\n+  --> $DIR/borrowck-describe-lvalue.rs:69:9\n    |\n LL |         let x = &mut u.a;\n    |                 -------- borrow of `u.a` occurs here\n@@ -87,7 +87,7 @@ LL |         drop(x);\n    |              - borrow later used here\n \n error[E0503]: cannot use `f.x` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:78:9\n+  --> $DIR/borrowck-describe-lvalue.rs:76:9\n    |\n LL |         let x = f.x();\n    |                 - borrow of `*f` occurs here\n@@ -97,7 +97,7 @@ LL |         drop(x);\n    |              - borrow later used here\n \n error[E0503]: cannot use `g.0` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:85:9\n+  --> $DIR/borrowck-describe-lvalue.rs:83:9\n    |\n LL |         let x = g.x();\n    |                 - borrow of `*g` occurs here\n@@ -107,7 +107,7 @@ LL |         drop(x);\n    |              - borrow later used here\n \n error[E0503]: cannot use `h.0` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:92:9\n+  --> $DIR/borrowck-describe-lvalue.rs:90:9\n    |\n LL |         let x = &mut h.0;\n    |                 -------- borrow of `h.0` occurs here\n@@ -117,7 +117,7 @@ LL |         drop(x);\n    |              - borrow later used here\n \n error[E0503]: cannot use `e.0` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:100:20\n+  --> $DIR/borrowck-describe-lvalue.rs:98:20\n    |\n LL |         let x = e.x();\n    |                 - borrow of `*e` occurs here\n@@ -129,7 +129,7 @@ LL |         drop(x);\n    |              - borrow later used here\n \n error[E0503]: cannot use `u.a` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:109:9\n+  --> $DIR/borrowck-describe-lvalue.rs:107:9\n    |\n LL |         let x = &mut u.a;\n    |                 -------- borrow of `u.a` occurs here\n@@ -139,7 +139,7 @@ LL |         drop(x);\n    |              - borrow later used here\n \n error[E0503]: cannot use `v[..]` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:117:15\n+  --> $DIR/borrowck-describe-lvalue.rs:115:15\n    |\n LL |         let x = &mut v;\n    |                 ------ borrow of `v` occurs here\n@@ -151,7 +151,7 @@ LL |         drop(x);\n    |              - borrow later used here\n \n error[E0503]: cannot use `v[..]` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:122:18\n+  --> $DIR/borrowck-describe-lvalue.rs:120:18\n    |\n LL |         let x = &mut v;\n    |                 ------ borrow of `v` occurs here\n@@ -163,7 +163,7 @@ LL |         drop(x);\n    |              - borrow later used here\n \n error[E0503]: cannot use `v[..]` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:127:25\n+  --> $DIR/borrowck-describe-lvalue.rs:125:25\n    |\n LL |         let x = &mut v;\n    |                 ------ borrow of `v` occurs here\n@@ -175,7 +175,7 @@ LL |         drop(x);\n    |              - borrow later used here\n \n error[E0503]: cannot use `v[..]` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:132:28\n+  --> $DIR/borrowck-describe-lvalue.rs:130:28\n    |\n LL |         let x = &mut v;\n    |                 ------ borrow of `v` occurs here\n@@ -187,7 +187,7 @@ LL |         drop(x);\n    |              - borrow later used here\n \n error[E0503]: cannot use `v[..]` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:143:15\n+  --> $DIR/borrowck-describe-lvalue.rs:141:15\n    |\n LL |         let x = &mut v;\n    |                 ------ borrow of `v` occurs here\n@@ -199,7 +199,7 @@ LL |         drop(x);\n    |              - borrow later used here\n \n error[E0503]: cannot use `v[..]` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:148:18\n+  --> $DIR/borrowck-describe-lvalue.rs:146:18\n    |\n LL |         let x = &mut v;\n    |                 ------ borrow of `v` occurs here\n@@ -211,7 +211,7 @@ LL |         drop(x);\n    |              - borrow later used here\n \n error[E0503]: cannot use `v[..]` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:153:15\n+  --> $DIR/borrowck-describe-lvalue.rs:151:15\n    |\n LL |         let x = &mut v;\n    |                 ------ borrow of `v` occurs here\n@@ -223,7 +223,7 @@ LL |         drop(x);\n    |              - borrow later used here\n \n error[E0503]: cannot use `v[..]` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:158:18\n+  --> $DIR/borrowck-describe-lvalue.rs:156:18\n    |\n LL |         let x = &mut v;\n    |                 ------ borrow of `v` occurs here\n@@ -235,7 +235,7 @@ LL |         drop(x);\n    |              - borrow later used here\n \n error[E0503]: cannot use `e` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:171:13\n+  --> $DIR/borrowck-describe-lvalue.rs:169:13\n    |\n LL |         let x = &mut e;\n    |                 ------ borrow of `e` occurs here\n@@ -247,7 +247,7 @@ LL |         drop(x);\n    |              - borrow later used here\n \n error[E0502]: cannot borrow `e.0` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-describe-lvalue.rs:171:18\n+  --> $DIR/borrowck-describe-lvalue.rs:169:18\n    |\n LL |         let x = &mut e;\n    |                 ------ mutable borrow occurs here\n@@ -259,7 +259,7 @@ LL |         drop(x);\n    |              - mutable borrow later used here\n \n error[E0502]: cannot borrow `e.x` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-describe-lvalue.rs:175:23\n+  --> $DIR/borrowck-describe-lvalue.rs:173:23\n    |\n LL |         let x = &mut e;\n    |                 ------ mutable borrow occurs here\n@@ -271,7 +271,7 @@ LL |         drop(x);\n    |              - mutable borrow later used here\n \n error[E0502]: cannot borrow `s.y.0` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-describe-lvalue.rs:188:22\n+  --> $DIR/borrowck-describe-lvalue.rs:186:22\n    |\n LL |         let x = &mut s;\n    |                 ------ mutable borrow occurs here\n@@ -283,7 +283,7 @@ LL |         drop(x);\n    |              - mutable borrow later used here\n \n error[E0502]: cannot borrow `s.x.y` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-describe-lvalue.rs:194:28\n+  --> $DIR/borrowck-describe-lvalue.rs:192:28\n    |\n LL |         let x = &mut s;\n    |                 ------ mutable borrow occurs here\n@@ -295,7 +295,7 @@ LL |         drop(x);\n    |              - mutable borrow later used here\n \n error[E0503]: cannot use `*v` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:236:9\n+  --> $DIR/borrowck-describe-lvalue.rs:234:9\n    |\n LL |         let x = &mut v;\n    |                 ------ borrow of `v` occurs here\n@@ -306,7 +306,7 @@ LL |         drop(x);\n    |              - borrow later used here\n \n error[E0503]: cannot use `v[_].y` because it was mutably borrowed\n-  --> $DIR/borrowck-describe-lvalue.rs:236:9\n+  --> $DIR/borrowck-describe-lvalue.rs:234:9\n    |\n LL |         let x = &mut v;\n    |                 ------ borrow of `v` occurs here\n@@ -317,7 +317,7 @@ LL |         drop(x);\n    |              - borrow later used here\n \n error[E0502]: cannot borrow `v[..].x` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-describe-lvalue.rs:247:24\n+  --> $DIR/borrowck-describe-lvalue.rs:245:24\n    |\n LL |         let x = &mut v;\n    |                 ------ mutable borrow occurs here\n@@ -329,7 +329,7 @@ LL |         drop(x);\n    |              - mutable borrow later used here\n \n error[E0502]: cannot borrow `*block.current` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-describe-lvalue.rs:210:29\n+  --> $DIR/borrowck-describe-lvalue.rs:208:29\n    |\n LL |             let x = &mut block;\n    |                     ---------- mutable borrow occurs here\n@@ -340,7 +340,7 @@ LL |             drop(x);\n    |                  - mutable borrow later used here\n \n error[E0502]: cannot borrow `*block.current` as immutable because it is also borrowed as mutable\n-  --> $DIR/borrowck-describe-lvalue.rs:225:33\n+  --> $DIR/borrowck-describe-lvalue.rs:223:33\n    |\n LL |             let x = &mut block;\n    |                     ---------- mutable borrow occurs here\n@@ -351,7 +351,7 @@ LL |             drop(x);\n    |                  - mutable borrow later used here\n \n error[E0382]: use of moved value: `x`\n-  --> $DIR/borrowck-describe-lvalue.rs:278:22\n+  --> $DIR/borrowck-describe-lvalue.rs:276:22\n    |\n LL |                 drop(x);\n    |                      - value moved here"}, {"sha": "c1513fcba8a66819626769f73a6d17796d043bef", "filename": "src/test/ui/borrowck/borrowck-move-out-from-array-match.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-match.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,5 +1,3 @@\n-#![feature(slice_patterns)]\n-\n fn array() -> [(String, String); 3] {\n     Default::default()\n }"}, {"sha": "84930b000ccb3a5a122c1fa25b438d2a39b727d4", "filename": "src/test/ui/borrowck/borrowck-move-out-from-array-match.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-match.stderr?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,5 +1,5 @@\n error[E0382]: use of moved value: `a[..]`\n-  --> $DIR/borrowck-move-out-from-array-match.rs:15:14\n+  --> $DIR/borrowck-move-out-from-array-match.rs:13:14\n    |\n LL |         [_, _, _x] => {}\n    |                -- value moved here\n@@ -10,7 +10,7 @@ LL |         [.., _y] => {}\n    = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a[..]`\n-  --> $DIR/borrowck-move-out-from-array-match.rs:25:14\n+  --> $DIR/borrowck-move-out-from-array-match.rs:23:14\n    |\n LL |         [_, _, (_x, _)] => {}\n    |                 -- value moved here\n@@ -21,7 +21,7 @@ LL |         [.., _y] => {}\n    = note: move occurs because `a[..].0` has type `std::string::String`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a[..].0`\n-  --> $DIR/borrowck-move-out-from-array-match.rs:35:15\n+  --> $DIR/borrowck-move-out-from-array-match.rs:33:15\n    |\n LL |         [_, _, (_x, _)] => {}\n    |                 -- value moved here\n@@ -32,7 +32,7 @@ LL |         [.., (_y, _)] => {}\n    = note: move occurs because `a[..].0` has type `std::string::String`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array-match.rs:46:11\n+  --> $DIR/borrowck-move-out-from-array-match.rs:44:11\n    |\n LL |         [_x, _, _] => {}\n    |          -- value moved here\n@@ -43,7 +43,7 @@ LL |     match a {\n    = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array-match.rs:57:11\n+  --> $DIR/borrowck-move-out-from-array-match.rs:55:11\n    |\n LL |         [.., _x] => {}\n    |              -- value moved here\n@@ -54,7 +54,7 @@ LL |     match a {\n    = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array-match.rs:68:11\n+  --> $DIR/borrowck-move-out-from-array-match.rs:66:11\n    |\n LL |         [(_x, _), _, _] => {}\n    |           -- value moved here\n@@ -65,7 +65,7 @@ LL |     match a {\n    = note: move occurs because `a[..].0` has type `std::string::String`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array-match.rs:79:11\n+  --> $DIR/borrowck-move-out-from-array-match.rs:77:11\n    |\n LL |         [.., (_x, _)] => {}\n    |               -- value moved here\n@@ -76,7 +76,7 @@ LL |     match a {\n    = note: move occurs because `a[..].0` has type `std::string::String`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a[..].0`\n-  --> $DIR/borrowck-move-out-from-array-match.rs:91:11\n+  --> $DIR/borrowck-move-out-from-array-match.rs:89:11\n    |\n LL |         [_y @ .., _, _] => {}\n    |          ------- value moved here\n@@ -87,7 +87,7 @@ LL |         [(_x, _), _, _] => {}\n    = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a[..].0`\n-  --> $DIR/borrowck-move-out-from-array-match.rs:101:15\n+  --> $DIR/borrowck-move-out-from-array-match.rs:99:15\n    |\n LL |         [_, _, _y @ ..] => {}\n    |                ------- value moved here\n@@ -98,7 +98,7 @@ LL |         [.., (_x, _)] => {}\n    = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array-match.rs:112:11\n+  --> $DIR/borrowck-move-out-from-array-match.rs:110:11\n    |\n LL |         [x @ .., _] => {}\n    |          ------ value moved here"}, {"sha": "056b8e672bd93a5cab6658e05ce651added16f80", "filename": "src/test/ui/borrowck/borrowck-move-out-from-array-no-overlap-match.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-no-overlap-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-no-overlap-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-no-overlap-match.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -3,8 +3,6 @@\n // Once the bug is fixed, the test, which is derived from a\n // passing test for `let` statements, should become check-pass.\n \n-#![feature(slice_patterns)]\n-\n fn array() -> [(String, String); 3] {\n     Default::default()\n }"}, {"sha": "ff5eab2442c83312dd43695f0b9e89cf68191efe", "filename": "src/test/ui/borrowck/borrowck-move-out-from-array-no-overlap-match.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-no-overlap-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-no-overlap-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-no-overlap-match.stderr?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,5 +1,5 @@\n error[E0382]: use of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array-no-overlap-match.rs:19:11\n+  --> $DIR/borrowck-move-out-from-array-no-overlap-match.rs:17:11\n    |\n LL |         [_, _, _x] => {}\n    |                -- value moved here\n@@ -10,7 +10,7 @@ LL |     match a {\n    = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array-no-overlap-match.rs:30:11\n+  --> $DIR/borrowck-move-out-from-array-no-overlap-match.rs:28:11\n    |\n LL |         [_, _, (_x, _)] => {}\n    |                 -- value moved here\n@@ -21,7 +21,7 @@ LL |     match a {\n    = note: move occurs because `a[..].0` has type `std::string::String`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array-no-overlap-match.rs:43:11\n+  --> $DIR/borrowck-move-out-from-array-no-overlap-match.rs:41:11\n    |\n LL |         [_x, _, _] => {}\n    |          -- value moved here\n@@ -32,7 +32,7 @@ LL |     match a {\n    = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array-no-overlap-match.rs:54:11\n+  --> $DIR/borrowck-move-out-from-array-no-overlap-match.rs:52:11\n    |\n LL |         [.., _x] => {}\n    |              -- value moved here\n@@ -43,7 +43,7 @@ LL |     match a {\n    = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array-no-overlap-match.rs:65:11\n+  --> $DIR/borrowck-move-out-from-array-no-overlap-match.rs:63:11\n    |\n LL |         [(_x, _), _, _] => {}\n    |           -- value moved here\n@@ -54,7 +54,7 @@ LL |     match a {\n    = note: move occurs because `a[..].0` has type `std::string::String`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array-no-overlap-match.rs:76:11\n+  --> $DIR/borrowck-move-out-from-array-no-overlap-match.rs:74:11\n    |\n LL |         [.., (_x, _)] => {}\n    |               -- value moved here\n@@ -65,7 +65,7 @@ LL |     match a {\n    = note: move occurs because `a[..].0` has type `std::string::String`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array-no-overlap-match.rs:87:11\n+  --> $DIR/borrowck-move-out-from-array-no-overlap-match.rs:85:11\n    |\n LL |         [_, _y @ ..] => {}\n    |             ------- value moved here\n@@ -76,7 +76,7 @@ LL |     match a {\n    = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array-no-overlap-match.rs:98:11\n+  --> $DIR/borrowck-move-out-from-array-no-overlap-match.rs:96:11\n    |\n LL |         [_y @ .., _] => {}\n    |          ------- value moved here\n@@ -87,7 +87,7 @@ LL |     match a {\n    = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array-no-overlap-match.rs:111:11\n+  --> $DIR/borrowck-move-out-from-array-no-overlap-match.rs:109:11\n    |\n LL |         [x @ .., _, _] => {}\n    |          ------ value moved here"}, {"sha": "c91b4286b6478038a46840d2b924f22c3dc6d66d", "filename": "src/test/ui/borrowck/borrowck-move-out-from-array-no-overlap.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-no-overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-no-overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-no-overlap.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,7 +1,5 @@\n // check-pass\n \n-#![feature(slice_patterns)]\n-\n fn array() -> [(String, String); 3] {\n     Default::default()\n }"}, {"sha": "604a25cdcc1d689ecebacc42584aacd06ca4a69d", "filename": "src/test/ui/borrowck/borrowck-move-out-from-array-use-match.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use-match.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,5 +1,3 @@\n-#![feature(slice_patterns)]\n-\n fn array() -> [(String, String); 3] {\n     Default::default()\n }"}, {"sha": "0ef63105cfbd3212953a94c654a134be6c6c1906", "filename": "src/test/ui/borrowck/borrowck-move-out-from-array-use-match.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use-match.stderr?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,5 +1,5 @@\n error[E0382]: borrow of moved value: `a[..]`\n-  --> $DIR/borrowck-move-out-from-array-use-match.rs:15:14\n+  --> $DIR/borrowck-move-out-from-array-use-match.rs:13:14\n    |\n LL |         [_, _, _x] => {}\n    |                -- value moved here\n@@ -10,7 +10,7 @@ LL |         [.., ref _y] => {}\n    = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n \n error[E0382]: borrow of moved value: `a[..]`\n-  --> $DIR/borrowck-move-out-from-array-use-match.rs:25:14\n+  --> $DIR/borrowck-move-out-from-array-use-match.rs:23:14\n    |\n LL |         [_, _, (_x, _)] => {}\n    |                 -- value moved here\n@@ -21,7 +21,7 @@ LL |         [.., ref _y] => {}\n    = note: move occurs because `a[..].0` has type `std::string::String`, which does not implement the `Copy` trait\n \n error[E0382]: borrow of moved value: `a[..].0`\n-  --> $DIR/borrowck-move-out-from-array-use-match.rs:35:15\n+  --> $DIR/borrowck-move-out-from-array-use-match.rs:33:15\n    |\n LL |         [_, _, (_x, _)] => {}\n    |                 -- value moved here\n@@ -32,7 +32,7 @@ LL |         [.., (ref _y, _)] => {}\n    = note: move occurs because `a[..].0` has type `std::string::String`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array-use-match.rs:46:11\n+  --> $DIR/borrowck-move-out-from-array-use-match.rs:44:11\n    |\n LL |         [_x, _, _] => {}\n    |          -- value moved here\n@@ -43,7 +43,7 @@ LL |     match a {\n    = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array-use-match.rs:57:11\n+  --> $DIR/borrowck-move-out-from-array-use-match.rs:55:11\n    |\n LL |         [.., _x] => {}\n    |              -- value moved here\n@@ -54,7 +54,7 @@ LL |     match a {\n    = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array-use-match.rs:68:11\n+  --> $DIR/borrowck-move-out-from-array-use-match.rs:66:11\n    |\n LL |         [(_x, _), _, _] => {}\n    |           -- value moved here\n@@ -65,7 +65,7 @@ LL |     match a {\n    = note: move occurs because `a[..].0` has type `std::string::String`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array-use-match.rs:79:11\n+  --> $DIR/borrowck-move-out-from-array-use-match.rs:77:11\n    |\n LL |         [.., (_x, _)] => {}\n    |               -- value moved here\n@@ -76,7 +76,7 @@ LL |     match a {\n    = note: move occurs because `a[..].0` has type `std::string::String`, which does not implement the `Copy` trait\n \n error[E0382]: borrow of moved value: `a[..]`\n-  --> $DIR/borrowck-move-out-from-array-use-match.rs:91:11\n+  --> $DIR/borrowck-move-out-from-array-use-match.rs:89:11\n    |\n LL |         [_y @ .., _, _] => {}\n    |          ------- value moved here\n@@ -87,7 +87,7 @@ LL |         [(ref _x, _), _, _] => {}\n    = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n \n error[E0382]: borrow of moved value: `a[..]`\n-  --> $DIR/borrowck-move-out-from-array-use-match.rs:101:15\n+  --> $DIR/borrowck-move-out-from-array-use-match.rs:99:15\n    |\n LL |         [_, _, _y @ ..] => {}\n    |                ------- value moved here\n@@ -98,7 +98,7 @@ LL |         [.., (ref _x, _)] => {}\n    = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array-use-match.rs:112:11\n+  --> $DIR/borrowck-move-out-from-array-use-match.rs:110:11\n    |\n LL |         [x @ .., _] => {}\n    |          ------ value moved here\n@@ -109,7 +109,7 @@ LL |     match a {\n    = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array-use-match.rs:125:5\n+  --> $DIR/borrowck-move-out-from-array-use-match.rs:123:5\n    |\n LL |         [_, _, _x] => {}\n    |                -- value moved here\n@@ -120,7 +120,7 @@ LL |     a[2] = Default::default();\n    = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array-use-match.rs:133:5\n+  --> $DIR/borrowck-move-out-from-array-use-match.rs:131:5\n    |\n LL |         [_, _, (_x, _)] => {}\n    |                 -- value moved here\n@@ -131,7 +131,7 @@ LL |     a[2].1 = Default::default();\n    = note: move occurs because `a[..].0` has type `std::string::String`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array-use-match.rs:141:5\n+  --> $DIR/borrowck-move-out-from-array-use-match.rs:139:5\n    |\n LL |         [_, _, _x @ ..] => {}\n    |                ------- value moved here\n@@ -142,7 +142,7 @@ LL |     a[0] = Default::default();\n    = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array-use-match.rs:149:5\n+  --> $DIR/borrowck-move-out-from-array-use-match.rs:147:5\n    |\n LL |         [_, _, _x @ ..] => {}\n    |                ------- value moved here"}, {"sha": "5afd6835dcfb60b0c98bd8b4bccf4887eb631174", "filename": "src/test/ui/borrowck/borrowck-move-out-from-array-use-no-overlap-match.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use-no-overlap-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use-no-overlap-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use-no-overlap-match.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -3,8 +3,6 @@\n // Once the bug is fixed, the test, which is derived from a\n // passing test for `let` statements, should become check-pass.\n \n-#![feature(slice_patterns)]\n-\n fn array() -> [(String, String); 3] {\n     Default::default()\n }"}, {"sha": "a4042ce7db336192c64086777a9a6105cc62be34", "filename": "src/test/ui/borrowck/borrowck-move-out-from-array-use-no-overlap-match.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use-no-overlap-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use-no-overlap-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use-no-overlap-match.stderr?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,5 +1,5 @@\n error[E0382]: use of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array-use-no-overlap-match.rs:19:11\n+  --> $DIR/borrowck-move-out-from-array-use-no-overlap-match.rs:17:11\n    |\n LL |         [_, _, _x] => {}\n    |                -- value moved here\n@@ -10,7 +10,7 @@ LL |     match a {\n    = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array-use-no-overlap-match.rs:30:11\n+  --> $DIR/borrowck-move-out-from-array-use-no-overlap-match.rs:28:11\n    |\n LL |         [_, _, (_x, _)] => {}\n    |                 -- value moved here\n@@ -21,7 +21,7 @@ LL |     match a {\n    = note: move occurs because `a[..].0` has type `std::string::String`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array-use-no-overlap-match.rs:43:11\n+  --> $DIR/borrowck-move-out-from-array-use-no-overlap-match.rs:41:11\n    |\n LL |         [_x, _, _] => {}\n    |          -- value moved here\n@@ -32,7 +32,7 @@ LL |     match a {\n    = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array-use-no-overlap-match.rs:54:11\n+  --> $DIR/borrowck-move-out-from-array-use-no-overlap-match.rs:52:11\n    |\n LL |         [.., _x] => {}\n    |              -- value moved here\n@@ -43,7 +43,7 @@ LL |     match a {\n    = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array-use-no-overlap-match.rs:65:11\n+  --> $DIR/borrowck-move-out-from-array-use-no-overlap-match.rs:63:11\n    |\n LL |         [(_x, _), _, _] => {}\n    |           -- value moved here\n@@ -54,7 +54,7 @@ LL |     match a {\n    = note: move occurs because `a[..].0` has type `std::string::String`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array-use-no-overlap-match.rs:76:11\n+  --> $DIR/borrowck-move-out-from-array-use-no-overlap-match.rs:74:11\n    |\n LL |         [.., (_x, _)] => {}\n    |               -- value moved here\n@@ -65,7 +65,7 @@ LL |     match a {\n    = note: move occurs because `a[..].0` has type `std::string::String`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array-use-no-overlap-match.rs:87:11\n+  --> $DIR/borrowck-move-out-from-array-use-no-overlap-match.rs:85:11\n    |\n LL |         [_, _y @ ..] => {}\n    |             ------- value moved here\n@@ -76,7 +76,7 @@ LL |     match a {\n    = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array-use-no-overlap-match.rs:98:11\n+  --> $DIR/borrowck-move-out-from-array-use-no-overlap-match.rs:96:11\n    |\n LL |         [_y @ .., _] => {}\n    |          ------- value moved here\n@@ -87,7 +87,7 @@ LL |     match a {\n    = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array-use-no-overlap-match.rs:111:11\n+  --> $DIR/borrowck-move-out-from-array-use-no-overlap-match.rs:109:11\n    |\n LL |         [x @ .., _, _] => {}\n    |          ------ value moved here"}, {"sha": "e3498cef37719005a50df2f946b65fbed90c273f", "filename": "src/test/ui/borrowck/borrowck-move-out-from-array-use-no-overlap.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use-no-overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use-no-overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use-no-overlap.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,7 +1,5 @@\n // check-pass\n \n-#![feature(slice_patterns)]\n-\n fn array() -> [(String, String); 3] {\n     Default::default()\n }"}, {"sha": "ad08367a3b5b31ecf3866abd0fd1098aecefd695", "filename": "src/test/ui/borrowck/borrowck-move-out-from-array-use.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,5 +1,3 @@\n-#![feature(slice_patterns)]\n-\n fn array() -> [(String, String); 3] {\n     Default::default()\n }"}, {"sha": "7ad4116645e9351d87f1eef6d814f3cd85c9ca15", "filename": "src/test/ui/borrowck/borrowck-move-out-from-array-use.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array-use.stderr?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,5 +1,5 @@\n error[E0382]: borrow of moved value: `a[..]`\n-  --> $DIR/borrowck-move-out-from-array-use.rs:12:14\n+  --> $DIR/borrowck-move-out-from-array-use.rs:10:14\n    |\n LL |     let [_, _, _x] = a;\n    |                -- value moved here\n@@ -9,7 +9,7 @@ LL |     let [.., ref _y] = a;\n    = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n \n error[E0382]: borrow of moved value: `a[..]`\n-  --> $DIR/borrowck-move-out-from-array-use.rs:18:14\n+  --> $DIR/borrowck-move-out-from-array-use.rs:16:14\n    |\n LL |     let [_, _, (_x, _)] = a;\n    |                 -- value moved here\n@@ -19,7 +19,7 @@ LL |     let [.., ref _y] = a;\n    = note: move occurs because `a[..].0` has type `std::string::String`, which does not implement the `Copy` trait\n \n error[E0382]: borrow of moved value: `a[..].0`\n-  --> $DIR/borrowck-move-out-from-array-use.rs:24:15\n+  --> $DIR/borrowck-move-out-from-array-use.rs:22:15\n    |\n LL |     let [_, _, (_x, _)] = a;\n    |                 -- value moved here\n@@ -29,7 +29,7 @@ LL |     let [.., (ref _y, _)] = a;\n    = note: move occurs because `a[..].0` has type `std::string::String`, which does not implement the `Copy` trait\n \n error[E0382]: borrow of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array-use.rs:32:10\n+  --> $DIR/borrowck-move-out-from-array-use.rs:30:10\n    |\n LL |     let [_x, _, _] = a;\n    |          -- value moved here\n@@ -39,7 +39,7 @@ LL |     let [ref _y @ .., _, _] = a;\n    = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n \n error[E0382]: borrow of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array-use.rs:38:16\n+  --> $DIR/borrowck-move-out-from-array-use.rs:36:16\n    |\n LL |     let [.., _x] = a;\n    |              -- value moved here\n@@ -49,7 +49,7 @@ LL |     let [_, _, ref _y @ ..] = a;\n    = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n \n error[E0382]: borrow of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array-use.rs:44:10\n+  --> $DIR/borrowck-move-out-from-array-use.rs:42:10\n    |\n LL |     let [(_x, _), _, _] = a;\n    |           -- value moved here\n@@ -59,7 +59,7 @@ LL |     let [ref _y @ .., _, _] = a;\n    = note: move occurs because `a[..].0` has type `std::string::String`, which does not implement the `Copy` trait\n \n error[E0382]: borrow of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array-use.rs:50:16\n+  --> $DIR/borrowck-move-out-from-array-use.rs:48:16\n    |\n LL |     let [.., (_x, _)] = a;\n    |               -- value moved here\n@@ -69,7 +69,7 @@ LL |     let [_, _, ref _y @ ..] = a;\n    = note: move occurs because `a[..].0` has type `std::string::String`, which does not implement the `Copy` trait\n \n error[E0382]: borrow of moved value: `a[..]`\n-  --> $DIR/borrowck-move-out-from-array-use.rs:56:11\n+  --> $DIR/borrowck-move-out-from-array-use.rs:54:11\n    |\n LL |     let [_y @ .., _, _] = a;\n    |          ------- value moved here\n@@ -79,7 +79,7 @@ LL |     let [(ref _x, _), _, _] = a;\n    = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n \n error[E0382]: borrow of moved value: `a[..]`\n-  --> $DIR/borrowck-move-out-from-array-use.rs:62:15\n+  --> $DIR/borrowck-move-out-from-array-use.rs:60:15\n    |\n LL |     let [_, _, _y @ ..] = a;\n    |                ------- value moved here\n@@ -89,7 +89,7 @@ LL |     let [.., (ref _x, _)] = a;\n    = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n \n error[E0382]: borrow of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array-use.rs:70:13\n+  --> $DIR/borrowck-move-out-from-array-use.rs:68:13\n    |\n LL |     let [x @ .., _] = a;\n    |          ------ value moved here\n@@ -99,7 +99,7 @@ LL |     let [_, ref _y @ ..] = a;\n    = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array-use.rs:78:5\n+  --> $DIR/borrowck-move-out-from-array-use.rs:76:5\n    |\n LL |     let [_, _, _x] = a;\n    |                -- value moved here\n@@ -109,7 +109,7 @@ LL |     a[2] = Default::default();\n    = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array-use.rs:84:5\n+  --> $DIR/borrowck-move-out-from-array-use.rs:82:5\n    |\n LL |     let [_, _, (_x, _)] = a;\n    |                 -- value moved here\n@@ -119,7 +119,7 @@ LL |     a[2].1 = Default::default();\n    = note: move occurs because `a[..].0` has type `std::string::String`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array-use.rs:90:5\n+  --> $DIR/borrowck-move-out-from-array-use.rs:88:5\n    |\n LL |     let [_, _, _x @ ..] = a;\n    |                ------- value moved here\n@@ -129,7 +129,7 @@ LL |     a[0] = Default::default();\n    = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array-use.rs:96:5\n+  --> $DIR/borrowck-move-out-from-array-use.rs:94:5\n    |\n LL |     let [_, _, _x @ ..] = a;\n    |                ------- value moved here"}, {"sha": "83755812f4b32315da27118643ef8cd79471ed58", "filename": "src/test/ui/borrowck/borrowck-move-out-from-array.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,5 +1,3 @@\n-#![feature(slice_patterns)]\n-\n fn array() -> [(String, String); 3] {\n     Default::default()\n }"}, {"sha": "b7babd93ed7a638244a594ff060fc62fad8a86cb", "filename": "src/test/ui/borrowck/borrowck-move-out-from-array.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-from-array.stderr?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,5 +1,5 @@\n error[E0382]: use of moved value: `a[..]`\n-  --> $DIR/borrowck-move-out-from-array.rs:12:14\n+  --> $DIR/borrowck-move-out-from-array.rs:10:14\n    |\n LL |     let [_, _, _x] = a;\n    |                -- value moved here\n@@ -9,7 +9,7 @@ LL |     let [.., _y] = a;\n    = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a[..]`\n-  --> $DIR/borrowck-move-out-from-array.rs:18:14\n+  --> $DIR/borrowck-move-out-from-array.rs:16:14\n    |\n LL |     let [_, _, (_x, _)] = a;\n    |                 -- value moved here\n@@ -19,7 +19,7 @@ LL |     let [.., _y] = a;\n    = note: move occurs because `a[..].0` has type `std::string::String`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a[..].0`\n-  --> $DIR/borrowck-move-out-from-array.rs:24:15\n+  --> $DIR/borrowck-move-out-from-array.rs:22:15\n    |\n LL |     let [_, _, (_x, _)] = a;\n    |                 -- value moved here\n@@ -29,7 +29,7 @@ LL |     let [.., (_y, _)] = a;\n    = note: move occurs because `a[..].0` has type `std::string::String`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array.rs:32:10\n+  --> $DIR/borrowck-move-out-from-array.rs:30:10\n    |\n LL |     let [_x, _, _] = a;\n    |          -- value moved here\n@@ -39,7 +39,7 @@ LL |     let [_y @ .., _, _] = a;\n    = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array.rs:38:16\n+  --> $DIR/borrowck-move-out-from-array.rs:36:16\n    |\n LL |     let [.., _x] = a;\n    |              -- value moved here\n@@ -49,7 +49,7 @@ LL |     let [_, _, _y @ ..] = a;\n    = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array.rs:44:10\n+  --> $DIR/borrowck-move-out-from-array.rs:42:10\n    |\n LL |     let [(_x, _), _, _] = a;\n    |           -- value moved here\n@@ -59,7 +59,7 @@ LL |     let [_y @ .., _, _] = a;\n    = note: move occurs because `a[..].0` has type `std::string::String`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array.rs:50:16\n+  --> $DIR/borrowck-move-out-from-array.rs:48:16\n    |\n LL |     let [.., (_x, _)] = a;\n    |               -- value moved here\n@@ -69,7 +69,7 @@ LL |     let [_, _, _y @ ..] = a;\n    = note: move occurs because `a[..].0` has type `std::string::String`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a[..].0`\n-  --> $DIR/borrowck-move-out-from-array.rs:56:11\n+  --> $DIR/borrowck-move-out-from-array.rs:54:11\n    |\n LL |     let [_y @ .., _, _] = a;\n    |          ------- value moved here\n@@ -79,7 +79,7 @@ LL |     let [(_x, _), _, _] = a;\n    = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a[..].0`\n-  --> $DIR/borrowck-move-out-from-array.rs:62:15\n+  --> $DIR/borrowck-move-out-from-array.rs:60:15\n    |\n LL |     let [_, _, _y @ ..] = a;\n    |                ------- value moved here\n@@ -89,7 +89,7 @@ LL |     let [.., (_x, _)] = a;\n    = note: move occurs because `a[..]` has type `(std::string::String, std::string::String)`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `a`\n-  --> $DIR/borrowck-move-out-from-array.rs:70:13\n+  --> $DIR/borrowck-move-out-from-array.rs:68:13\n    |\n LL |     let [x @ .., _] = a;\n    |          ------ value moved here"}, {"sha": "8ece81a3c845e9209a20699ff9664cfc854cbcde", "filename": "src/test/ui/borrowck/borrowck-move-out-of-vec-tail.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-vec-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-vec-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-vec-tail.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,7 +1,5 @@\n // Test that we do not permit moves from &[] matched by a vec pattern.\n \n-#![feature(slice_patterns)]\n-\n #[derive(Clone, Debug)]\n struct Foo {\n     string: String"}, {"sha": "a345c1238f02c3bdb2322c33b72d7fc83dea2fd3", "filename": "src/test/ui/borrowck/borrowck-move-out-of-vec-tail.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-vec-tail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-vec-tail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-vec-tail.stderr?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,5 +1,5 @@\n error[E0508]: cannot move out of type `[Foo]`, a non-copy slice\n-  --> $DIR/borrowck-move-out-of-vec-tail.rs:19:19\n+  --> $DIR/borrowck-move-out-of-vec-tail.rs:17:19\n    |\n LL |             match tail {\n    |                   ^^^^ cannot move out of here"}, {"sha": "a8e56f648e2e538c4bbe34d4b94563ccbdac5fce", "filename": "src/test/ui/borrowck/borrowck-slice-pattern-element-loan-array-no-overlap.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-array-no-overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-array-no-overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-array-no-overlap.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,7 +1,5 @@\n // check-pass\n \n-#![feature(slice_patterns)]\n-\n fn nop(_s: &[& i32]) {}\n fn nop_subslice(_s: &[i32]) {}\n "}, {"sha": "6b210d73228f864ddb77ecf02e8ee31397f50d49", "filename": "src/test/ui/borrowck/borrowck-slice-pattern-element-loan-array.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-array.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,5 +1,3 @@\n-#![feature(slice_patterns)]\n-\n fn nop(_s: &[& i32]) {}\n fn nop_subslice(_s: &[i32]) {}\n "}, {"sha": "0432aaf51d29f50a6c22be7fa34e08ad0f1560ae", "filename": "src/test/ui/borrowck/borrowck-slice-pattern-element-loan-array.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-array.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-array.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-array.stderr?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,5 +1,5 @@\n error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-slice-pattern-element-loan-array.rs:8:13\n+  --> $DIR/borrowck-slice-pattern-element-loan-array.rs:6:13\n    |\n LL |     let [ref first, ref second, ..] = *s;\n    |                     ---------- immutable borrow occurs here\n@@ -9,7 +9,7 @@ LL |     nop(&[first, second, second2, third]);\n    |                  ------ immutable borrow later used here\n \n error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-slice-pattern-element-loan-array.rs:14:14\n+  --> $DIR/borrowck-slice-pattern-element-loan-array.rs:12:14\n    |\n LL |     let [.., ref fourth, ref third, _, ref first] = *s;\n    |                          --------- immutable borrow occurs here\n@@ -19,7 +19,7 @@ LL |     nop(&[first, third, third2, fourth]);\n    |                  ----- immutable borrow later used here\n \n error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-slice-pattern-element-loan-array.rs:21:16\n+  --> $DIR/borrowck-slice-pattern-element-loan-array.rs:19:16\n    |\n LL |     let [.., _, ref from_end4, ref from_end3, _, ref from_end1] = *s;\n    |                 ------------- immutable borrow occurs here\n@@ -30,7 +30,7 @@ LL |     nop(&[from_begin2, from_end1, from_end3, from_end4]);\n    |                                              --------- immutable borrow later used here\n \n error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-slice-pattern-element-loan-array.rs:23:19\n+  --> $DIR/borrowck-slice-pattern-element-loan-array.rs:21:19\n    |\n LL |     let [.., _, ref from_end4, ref from_end3, _, ref from_end1] = *s;\n    |                                ------------- immutable borrow occurs here\n@@ -41,7 +41,7 @@ LL |     nop(&[from_begin3, from_end1, from_end3, from_end4]);\n    |                                   --------- immutable borrow later used here\n \n error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-slice-pattern-element-loan-array.rs:28:14\n+  --> $DIR/borrowck-slice-pattern-element-loan-array.rs:26:14\n    |\n LL |     let [ref from_begin0, ref from_begin1, _, ref from_begin3, _, ..] = *s;\n    |                                               --------------- immutable borrow occurs here\n@@ -52,7 +52,7 @@ LL |     nop(&[from_begin0, from_begin1, from_begin3, from_end3]);\n    |                                     ----------- immutable borrow later used here\n \n error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-slice-pattern-element-loan-array.rs:34:13\n+  --> $DIR/borrowck-slice-pattern-element-loan-array.rs:32:13\n    |\n LL |     let [ref first, ref second, ..] = *s;\n    |                     ---------- immutable borrow occurs here\n@@ -62,7 +62,7 @@ LL |     nop(&[first, second]);\n    |                  ------ immutable borrow later used here\n \n error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-slice-pattern-element-loan-array.rs:41:10\n+  --> $DIR/borrowck-slice-pattern-element-loan-array.rs:39:10\n    |\n LL |     let [.., ref second, ref first] = *s;\n    |              ---------- immutable borrow occurs here\n@@ -72,7 +72,7 @@ LL |     nop(&[first, second]);\n    |                  ------ immutable borrow later used here\n \n error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-slice-pattern-element-loan-array.rs:48:10\n+  --> $DIR/borrowck-slice-pattern-element-loan-array.rs:46:10\n    |\n LL |     let [_,  ref s1 @ ..] = *s;\n    |              ----------- immutable borrow occurs here"}, {"sha": "4367596c6ea88066acf6dbc32f341b57b83c14a0", "filename": "src/test/ui/borrowck/borrowck-slice-pattern-element-loan-rpass.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-rpass.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,7 +1,4 @@\n // run-pass\n-//compile-flags: -Z borrowck=mir\n-\n-#![feature(slice_patterns)]\n \n fn mut_head_tail<'a, A>(v: &'a mut [A]) -> Option<(&'a mut A, &'a mut [A])> {\n     match *v {"}, {"sha": "6390dc3a91a0d922f81b9fd4a3025ed103da0fbd", "filename": "src/test/ui/borrowck/borrowck-slice-pattern-element-loan-slice-no-overlap.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-slice-no-overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-slice-no-overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-slice-no-overlap.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,7 +1,5 @@\n // check-pass\n \n-#![feature(slice_patterns)]\n-\n fn nop(_s: &[& i32]) {}\n fn nop_subslice(_s: &[i32]) {}\n "}, {"sha": "0e1c90a1cd83d5e9727baa27b091571777c49985", "filename": "src/test/ui/borrowck/borrowck-slice-pattern-element-loan-slice.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-slice.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,5 +1,3 @@\n-#![feature(slice_patterns)]\n-\n fn nop(_s: &[& i32]) {}\n fn nop_subslice(_s: &[i32]) {}\n "}, {"sha": "d3388e071aa5349820cf42dc7e010d031f96f152", "filename": "src/test/ui/borrowck/borrowck-slice-pattern-element-loan-slice.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-slice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-slice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-slice-pattern-element-loan-slice.stderr?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,5 +1,5 @@\n error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-slice-pattern-element-loan-slice.rs:8:20\n+  --> $DIR/borrowck-slice-pattern-element-loan-slice.rs:6:20\n    |\n LL |     if let [ref first, ref second, ..] = *s {\n    |                        ---------- immutable borrow occurs here\n@@ -9,7 +9,7 @@ LL |             nop(&[first, second, second2, third]);\n    |                          ------ immutable borrow later used here\n \n error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-slice-pattern-element-loan-slice.rs:16:21\n+  --> $DIR/borrowck-slice-pattern-element-loan-slice.rs:14:21\n    |\n LL |     if let [.., ref fourth, ref third, _, ref first] = *s {\n    |                             --------- immutable borrow occurs here\n@@ -19,7 +19,7 @@ LL |             nop(&[first, third, third2, fourth]);\n    |                          ----- immutable borrow later used here\n \n error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-slice-pattern-element-loan-slice.rs:24:20\n+  --> $DIR/borrowck-slice-pattern-element-loan-slice.rs:22:20\n    |\n LL |     if let [.., _, ref from_end4, ref from_end3, _, ref from_end1] = *s {\n    |                    ------------- immutable borrow occurs here\n@@ -29,7 +29,7 @@ LL |             nop(&[from_begin1, from_end1, from_end3, from_end4]);\n    |                                                      --------- immutable borrow later used here\n \n error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-slice-pattern-element-loan-slice.rs:27:23\n+  --> $DIR/borrowck-slice-pattern-element-loan-slice.rs:25:23\n    |\n LL |     if let [.., _, ref from_end4, ref from_end3, _, ref from_end1] = *s {\n    |                                   ------------- immutable borrow occurs here\n@@ -40,7 +40,7 @@ LL |             nop(&[from_begin2, from_end1, from_end3, from_end4]);\n    |                                           --------- immutable borrow later used here\n \n error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-slice-pattern-element-loan-slice.rs:30:26\n+  --> $DIR/borrowck-slice-pattern-element-loan-slice.rs:28:26\n    |\n LL |     if let [.., _, ref from_end4, ref from_end3, _, ref from_end1] = *s {\n    |                                   ------------- immutable borrow occurs here\n@@ -51,7 +51,7 @@ LL |             nop(&[from_begin3, from_end1, from_end3, from_end4]);\n    |                                           --------- immutable borrow later used here\n \n error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-slice-pattern-element-loan-slice.rs:35:21\n+  --> $DIR/borrowck-slice-pattern-element-loan-slice.rs:33:21\n    |\n LL |     if let [ref from_begin0, ref from_begin1, _, ref from_begin3, _, ..] = *s {\n    |                                                  --------------- immutable borrow occurs here\n@@ -61,7 +61,7 @@ LL |             nop(&[from_begin0, from_begin1, from_begin3, from_end2]);\n    |                                             ----------- immutable borrow later used here\n \n error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-slice-pattern-element-loan-slice.rs:38:21\n+  --> $DIR/borrowck-slice-pattern-element-loan-slice.rs:36:21\n    |\n LL |     if let [ref from_begin0, ref from_begin1, _, ref from_begin3, _, ..] = *s {\n    |                                                  --------------- immutable borrow occurs here\n@@ -72,7 +72,7 @@ LL |             nop(&[from_begin0, from_begin1, from_begin3, from_end3]);\n    |                                             ----------- immutable borrow later used here\n \n error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-slice-pattern-element-loan-slice.rs:41:21\n+  --> $DIR/borrowck-slice-pattern-element-loan-slice.rs:39:21\n    |\n LL |     if let [ref from_begin0, ref from_begin1, _, ref from_begin3, _, ..] = *s {\n    |                              --------------- immutable borrow occurs here\n@@ -83,7 +83,7 @@ LL |             nop(&[from_begin0, from_begin1, from_begin3, from_end4]);\n    |                                ----------- immutable borrow later used here\n \n error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-slice-pattern-element-loan-slice.rs:49:20\n+  --> $DIR/borrowck-slice-pattern-element-loan-slice.rs:47:20\n    |\n LL |     if let [ref first, ref second, ..] = *s {\n    |                        ---------- immutable borrow occurs here\n@@ -93,7 +93,7 @@ LL |             nop(&[first, second]);\n    |                          ------ immutable borrow later used here\n \n error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-slice-pattern-element-loan-slice.rs:58:17\n+  --> $DIR/borrowck-slice-pattern-element-loan-slice.rs:56:17\n    |\n LL |     if let [.., ref second, ref first] = *s {\n    |                 ---------- immutable borrow occurs here\n@@ -103,7 +103,7 @@ LL |             nop(&[first, second]);\n    |                          ------ immutable borrow later used here\n \n error[E0502]: cannot borrow `s[..]` as mutable because it is also borrowed as immutable\n-  --> $DIR/borrowck-slice-pattern-element-loan-slice.rs:67:17\n+  --> $DIR/borrowck-slice-pattern-element-loan-slice.rs:65:17\n    |\n LL |     if let [_, _, _, ref s1 @ ..] = *s {\n    |                      ----------- immutable borrow occurs here"}, {"sha": "cd853b83363ab622c36c32d092bae2def7122e3b", "filename": "src/test/ui/borrowck/borrowck-vec-pattern-element-loan.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-element-loan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-element-loan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-element-loan.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,5 +1,3 @@\n-#![feature(slice_patterns)]\n-\n fn a<'a>() -> &'a [isize] {\n     let vec = vec![1, 2, 3, 4];\n     let vec: &[isize] = &vec;"}, {"sha": "170982b1693fb1ee69e208fda4e7068418582576", "filename": "src/test/ui/borrowck/borrowck-vec-pattern-element-loan.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-element-loan.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-element-loan.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-element-loan.stderr?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,5 +1,5 @@\n error[E0515]: cannot return value referencing local variable `vec`\n-  --> $DIR/borrowck-vec-pattern-element-loan.rs:10:5\n+  --> $DIR/borrowck-vec-pattern-element-loan.rs:8:5\n    |\n LL |     let vec: &[isize] = &vec;\n    |                         ---- `vec` is borrowed here\n@@ -8,7 +8,7 @@ LL |     tail\n    |     ^^^^ returns a value referencing data owned by the current function\n \n error[E0515]: cannot return value referencing local variable `vec`\n-  --> $DIR/borrowck-vec-pattern-element-loan.rs:20:5\n+  --> $DIR/borrowck-vec-pattern-element-loan.rs:18:5\n    |\n LL |     let vec: &[isize] = &vec;\n    |                         ---- `vec` is borrowed here\n@@ -17,7 +17,7 @@ LL |     init\n    |     ^^^^ returns a value referencing data owned by the current function\n \n error[E0515]: cannot return value referencing local variable `vec`\n-  --> $DIR/borrowck-vec-pattern-element-loan.rs:30:5\n+  --> $DIR/borrowck-vec-pattern-element-loan.rs:28:5\n    |\n LL |     let vec: &[isize] = &vec;\n    |                         ---- `vec` is borrowed here"}, {"sha": "05859c95d174d9dedc1c5b7dc1d84c80a7fe84f6", "filename": "src/test/ui/borrowck/borrowck-vec-pattern-loan-from-mut.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-loan-from-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-loan-from-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-loan-from-mut.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,5 +1,3 @@\n-#![feature(slice_patterns)]\n-\n fn a() {\n     let mut v = vec![1, 2, 3];\n     let vb: &mut [isize] = &mut v;"}, {"sha": "5141fcc1bb261f4a454a406506c2f117c571adaf", "filename": "src/test/ui/borrowck/borrowck-vec-pattern-loan-from-mut.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-loan-from-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-loan-from-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-loan-from-mut.stderr?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,5 +1,5 @@\n error[E0499]: cannot borrow `v` as mutable more than once at a time\n-  --> $DIR/borrowck-vec-pattern-loan-from-mut.rs:8:13\n+  --> $DIR/borrowck-vec-pattern-loan-from-mut.rs:6:13\n    |\n LL |     let vb: &mut [isize] = &mut v;\n    |                            ------ first mutable borrow occurs here"}, {"sha": "9b8ba2ea8adc5df61562a5d2c785169d3e1ca82b", "filename": "src/test/ui/borrowck/borrowck-vec-pattern-move-tail.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-move-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-move-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-move-tail.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,7 +1,3 @@\n-// http://rust-lang.org/COPYRIGHT.\n-\n-#![feature(slice_patterns)]\n-\n fn main() {\n     let mut a = [1, 2, 3, 4];\n     let t = match a {"}, {"sha": "ff70ba9fcca8b5145983d135fe1cb7d6630dc868", "filename": "src/test/ui/borrowck/borrowck-vec-pattern-move-tail.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-move-tail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-move-tail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-move-tail.stderr?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,5 +1,5 @@\n error[E0506]: cannot assign to `a[_]` because it is borrowed\n-  --> $DIR/borrowck-vec-pattern-move-tail.rs:12:5\n+  --> $DIR/borrowck-vec-pattern-move-tail.rs:8:5\n    |\n LL |         [1, 2, ref tail @ ..] => tail,\n    |                ------------- borrow of `a[_]` occurs here"}, {"sha": "67b6c12ba803a230a09266750e53ec004f8b2698", "filename": "src/test/ui/borrowck/borrowck-vec-pattern-nesting.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-nesting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-nesting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-nesting.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,6 +1,5 @@\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n-#![feature(slice_patterns)]\n \n fn a() {\n     let mut vec = [box 1, box 2, box 3];"}, {"sha": "e2c0852dd83c696113d89c46b5fcac54a6bc92be", "filename": "src/test/ui/borrowck/borrowck-vec-pattern-nesting.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-nesting.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-nesting.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-nesting.stderr?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,5 +1,5 @@\n error[E0506]: cannot assign to `vec[_]` because it is borrowed\n-  --> $DIR/borrowck-vec-pattern-nesting.rs:10:13\n+  --> $DIR/borrowck-vec-pattern-nesting.rs:9:13\n    |\n LL |         [box ref _a, _, _] => {\n    |              ------ borrow of `vec[_]` occurs here\n@@ -11,7 +11,7 @@ LL |             _a.use_ref();\n    |             -- borrow later used here\n \n error[E0506]: cannot assign to `vec[_]` because it is borrowed\n-  --> $DIR/borrowck-vec-pattern-nesting.rs:24:13\n+  --> $DIR/borrowck-vec-pattern-nesting.rs:23:13\n    |\n LL |         &mut [ref _b @ ..] => {\n    |               ----------- borrow of `vec[_]` occurs here\n@@ -23,7 +23,7 @@ LL |             _b.use_ref();\n    |             -- borrow later used here\n \n error[E0508]: cannot move out of type `[std::boxed::Box<isize>]`, a non-copy slice\n-  --> $DIR/borrowck-vec-pattern-nesting.rs:35:11\n+  --> $DIR/borrowck-vec-pattern-nesting.rs:34:11\n    |\n LL |     match vec {\n    |           ^^^ cannot move out of here\n@@ -45,7 +45,7 @@ LL |         ] => {\n    |\n \n error[E0508]: cannot move out of type `[std::boxed::Box<isize>]`, a non-copy slice\n-  --> $DIR/borrowck-vec-pattern-nesting.rs:47:13\n+  --> $DIR/borrowck-vec-pattern-nesting.rs:46:13\n    |\n LL |     let a = vec[0];\n    |             ^^^^^^\n@@ -55,7 +55,7 @@ LL |     let a = vec[0];\n    |             help: consider borrowing here: `&vec[0]`\n \n error[E0508]: cannot move out of type `[std::boxed::Box<isize>]`, a non-copy slice\n-  --> $DIR/borrowck-vec-pattern-nesting.rs:56:11\n+  --> $DIR/borrowck-vec-pattern-nesting.rs:55:11\n    |\n LL |     match vec {\n    |           ^^^ cannot move out of here\n@@ -74,7 +74,7 @@ LL |          _b] => {}\n    |\n \n error[E0508]: cannot move out of type `[std::boxed::Box<isize>]`, a non-copy slice\n-  --> $DIR/borrowck-vec-pattern-nesting.rs:66:13\n+  --> $DIR/borrowck-vec-pattern-nesting.rs:65:13\n    |\n LL |     let a = vec[0];\n    |             ^^^^^^\n@@ -84,7 +84,7 @@ LL |     let a = vec[0];\n    |             help: consider borrowing here: `&vec[0]`\n \n error[E0508]: cannot move out of type `[std::boxed::Box<isize>]`, a non-copy slice\n-  --> $DIR/borrowck-vec-pattern-nesting.rs:75:11\n+  --> $DIR/borrowck-vec-pattern-nesting.rs:74:11\n    |\n LL |     match vec {\n    |           ^^^ cannot move out of here\n@@ -100,7 +100,7 @@ LL |         &mut [_a, _b, _c] => {}\n    = note: move occurs because these variables have types that don't implement the `Copy` trait\n \n error[E0508]: cannot move out of type `[std::boxed::Box<isize>]`, a non-copy slice\n-  --> $DIR/borrowck-vec-pattern-nesting.rs:86:13\n+  --> $DIR/borrowck-vec-pattern-nesting.rs:85:13\n    |\n LL |     let a = vec[0];\n    |             ^^^^^^"}, {"sha": "39872825cd2a461d832bc074782f9b12c41d921f", "filename": "src/test/ui/borrowck/borrowck-vec-pattern-tail-element-loan.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-tail-element-loan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-tail-element-loan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-tail-element-loan.rs?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,5 +1,3 @@\n-#![feature(slice_patterns)]\n-\n fn a<'a>() -> &'a isize {\n     let vec = vec![1, 2, 3, 4];\n     let vec: &[isize] = &vec;"}, {"sha": "7e21c55f21b5fa7e901eba7b7136f3892ab2fb5d", "filename": "src/test/ui/borrowck/borrowck-vec-pattern-tail-element-loan.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-tail-element-loan.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-tail-element-loan.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-tail-element-loan.stderr?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -1,5 +1,5 @@\n error[E0515]: cannot return value referencing local variable `vec`\n-  --> $DIR/borrowck-vec-pattern-tail-element-loan.rs:10:5\n+  --> $DIR/borrowck-vec-pattern-tail-element-loan.rs:8:5\n    |\n LL |     let vec: &[isize] = &vec;\n    |                         ---- `vec` is borrowed here"}, {"sha": "89107e799bd2207c4f26a4f62e38ceb0cf27c35a", "filename": "src/test/ui/c-variadic/variadic-ffi-4.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a3a077610028c773bffc7a74e6a15faa10d2360d/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fc-variadic%2Fvariadic-ffi-4.nll.stderr?ref=a3a077610028c773bffc7a74e6a15faa10d2360d", "patch": "@@ -87,12 +87,12 @@ error[E0597]: `ap1` does not live long enough\n   --> $DIR/variadic-ffi-4.rs:24:11\n    |\n LL | pub unsafe extern \"C\" fn no_escape4(_: usize, ap0: &mut VaListImpl, mut ap1: ...) {\n-   |                                                    - let's call the lifetime of this reference `'1`\n+   |                                                    - let's call the lifetime of this reference `'3`\n LL |     ap0 = &mut ap1;\n    |     ------^^^^^^^^\n    |     |     |\n    |     |     borrowed value does not live long enough\n-   |     assignment requires that `ap1` is borrowed for `'1`\n+   |     assignment requires that `ap1` is borrowed for `'3`\n ...\n LL | }\n    | - `ap1` dropped here while still borrowed"}]}