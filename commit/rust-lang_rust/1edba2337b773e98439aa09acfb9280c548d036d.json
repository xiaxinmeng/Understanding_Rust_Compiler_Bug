{"sha": "1edba2337b773e98439aa09acfb9280c548d036d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlZGJhMjMzN2I3NzNlOTg0MzlhYTA5YWNmYjkyODBjNTQ4ZDAzNmQ=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-26T08:47:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-11-26T08:47:22Z"}, "message": "Merge branch 'master' into self-referential-generator", "tree": {"sha": "8a912e680187710f33959cebef3dc87068615547", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a912e680187710f33959cebef3dc87068615547"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1edba2337b773e98439aa09acfb9280c548d036d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJb+7MaCRBK7hj4Ov3rIwAAdHIIADLeVkl10QOeb4u6kTAABcF1\n+8UCwOLkcPT66/O2HIbsfPEXG949e8EYV8ixas+wQiJAO9B84sPbT/o4HWJ3vh6P\n0pjNNq1VeaZY/VmhpNUTnWkwCEvLdgSkV26PqlOI1XUfNXk/CpRBa5R/M/Zm5ltU\nMCOzU9euGhSehms2XqYAAZK3TIqKnWh7M0Om9ZhcjhQ1S9CRjoXUD8NfQabxlInp\nDo/divaifpMP2TiccUOIXUniQorxInDgU5DBJRKeAjcLs7PVAGXI2rIe6N5Sy+gN\nigyWI+BAp8gL70eUEA/1GleifUkevlD/sjMPUR9IXBQQ+FgscDsyogkgztN4Q0M=\n=bnLk\n-----END PGP SIGNATURE-----\n", "payload": "tree 8a912e680187710f33959cebef3dc87068615547\nparent 7fe24a2b86bd355b20bc772e4613554ea5105ec0\nparent e6948fa6eafbe0cd1a4f48531f8626fc1d312c79\nauthor Ralf Jung <post@ralfj.de> 1543222042 +0100\ncommitter GitHub <noreply@github.com> 1543222042 +0100\n\nMerge branch 'master' into self-referential-generator"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1edba2337b773e98439aa09acfb9280c548d036d", "html_url": "https://github.com/rust-lang/rust/commit/1edba2337b773e98439aa09acfb9280c548d036d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1edba2337b773e98439aa09acfb9280c548d036d/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7fe24a2b86bd355b20bc772e4613554ea5105ec0", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fe24a2b86bd355b20bc772e4613554ea5105ec0", "html_url": "https://github.com/rust-lang/rust/commit/7fe24a2b86bd355b20bc772e4613554ea5105ec0"}, {"sha": "e6948fa6eafbe0cd1a4f48531f8626fc1d312c79", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6948fa6eafbe0cd1a4f48531f8626fc1d312c79", "html_url": "https://github.com/rust-lang/rust/commit/e6948fa6eafbe0cd1a4f48531f8626fc1d312c79"}], "stats": {"total": 207, "additions": 109, "deletions": 98}, "files": [{"sha": "0268b07ac411aa32361b2d914978708f3d54c127", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1edba2337b773e98439aa09acfb9280c548d036d/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/1edba2337b773e98439aa09acfb9280c548d036d/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=1edba2337b773e98439aa09acfb9280c548d036d", "patch": "@@ -1 +1 @@\n-nightly-2018-11-20\n+nightly-2018-11-26"}, {"sha": "6fa9b817ffee73df16a46f4a456f56235f981e83", "filename": "src/bin/miri-rustc-tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1edba2337b773e98439aa09acfb9280c548d036d/src%2Fbin%2Fmiri-rustc-tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1edba2337b773e98439aa09acfb9280c548d036d/src%2Fbin%2Fmiri-rustc-tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri-rustc-tests.rs?ref=1edba2337b773e98439aa09acfb9280c548d036d", "patch": "@@ -1,4 +1,4 @@\n-#![feature(rustc_private, extern_crate_item_prelude)]\n+#![feature(rustc_private)]\n extern crate miri;\n extern crate getopts;\n extern crate rustc;"}, {"sha": "1bbf3c8c4a4a8e136242ee7730b273b81fe4d8ef", "filename": "src/bin/miri.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1edba2337b773e98439aa09acfb9280c548d036d/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1edba2337b773e98439aa09acfb9280c548d036d/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=1edba2337b773e98439aa09acfb9280c548d036d", "patch": "@@ -1,4 +1,4 @@\n-#![feature(rustc_private, extern_crate_item_prelude)]\n+#![feature(rustc_private)]\n \n extern crate getopts;\n extern crate miri;"}, {"sha": "e9d3255a5b32590519470be37804ad373e240654", "filename": "src/fn_call.rs", "status": "modified", "additions": 35, "deletions": 26, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/1edba2337b773e98439aa09acfb9280c548d036d/src%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1edba2337b773e98439aa09acfb9280c548d036d/src%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffn_call.rs?ref=1edba2337b773e98439aa09acfb9280c548d036d", "patch": "@@ -114,6 +114,8 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n             None => self.tcx.item_name(def_id).as_str(),\n         };\n \n+        let tcx = &{self.tcx.tcx};\n+\n         // All these functions take raw pointers, so if we access memory directly\n         // (as opposed to through a place), we have to remember to erase any tag\n         // that might still hang around!\n@@ -124,7 +126,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 if size == 0 {\n                     self.write_null(dest)?;\n                 } else {\n-                    let align = self.tcx.data_layout.pointer_align;\n+                    let align = self.tcx.data_layout.pointer_align.abi;\n                     let ptr = self.memory_mut().allocate(Size::from_bytes(size), align, MiriMemoryKind::C.into())?;\n                     self.write_scalar(Scalar::Ptr(ptr.with_default_tag()), dest)?;\n                 }\n@@ -153,7 +155,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 let ptr = self.memory_mut()\n                     .allocate(\n                         Size::from_bytes(size),\n-                        Align::from_bytes(align, align).unwrap(),\n+                        Align::from_bytes(align).unwrap(),\n                         MiriMemoryKind::Rust.into()\n                     )?\n                     .with_default_tag();\n@@ -171,11 +173,13 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 let ptr = self.memory_mut()\n                     .allocate(\n                         Size::from_bytes(size),\n-                        Align::from_bytes(align, align).unwrap(),\n+                        Align::from_bytes(align).unwrap(),\n                         MiriMemoryKind::Rust.into()\n                     )?\n                     .with_default_tag();\n-                self.memory_mut().write_repeat(ptr.into(), 0, Size::from_bytes(size))?;\n+                self.memory_mut()\n+                    .get_mut(ptr.alloc_id)?\n+                    .write_repeat(tcx, ptr, 0, Size::from_bytes(size))?;\n                 self.write_scalar(Scalar::Ptr(ptr), dest)?;\n             }\n             \"__rust_dealloc\" => {\n@@ -190,7 +194,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 }\n                 self.memory_mut().deallocate(\n                     ptr,\n-                    Some((Size::from_bytes(old_size), Align::from_bytes(align, align).unwrap())),\n+                    Some((Size::from_bytes(old_size), Align::from_bytes(align).unwrap())),\n                     MiriMemoryKind::Rust.into(),\n                 )?;\n             }\n@@ -208,9 +212,9 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 let new_ptr = self.memory_mut().reallocate(\n                     ptr,\n                     Size::from_bytes(old_size),\n-                    Align::from_bytes(align, align).unwrap(),\n+                    Align::from_bytes(align).unwrap(),\n                     Size::from_bytes(new_size),\n-                    Align::from_bytes(align, align).unwrap(),\n+                    Align::from_bytes(align).unwrap(),\n                     MiriMemoryKind::Rust.into(),\n                 )?;\n                 self.write_scalar(Scalar::Ptr(new_ptr.with_default_tag()), dest)?;\n@@ -239,7 +243,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n             \"dlsym\" => {\n                 let _handle = self.read_scalar(args[0])?;\n                 let symbol = self.read_scalar(args[1])?.to_ptr()?;\n-                let symbol_name = self.memory().read_c_str(symbol)?;\n+                let symbol_name = self.memory().get(symbol.alloc_id)?.read_c_str(tcx, symbol)?;\n                 let err = format!(\"bad c unicode symbol: {:?}\", symbol_name);\n                 let symbol_name = ::std::str::from_utf8(symbol_name).unwrap_or(&err);\n                 return err!(Unimplemented(format!(\n@@ -346,7 +350,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n             \"getenv\" => {\n                 let result = {\n                     let name_ptr = self.read_scalar(args[0])?.to_ptr()?;\n-                    let name = self.memory().read_c_str(name_ptr)?;\n+                    let name = self.memory().get(name_ptr.alloc_id)?.read_c_str(tcx, name_ptr)?;\n                     match self.machine.env_vars.get(name) {\n                         Some(&var) => Scalar::Ptr(var),\n                         None => Scalar::ptr_null(&*self.tcx),\n@@ -360,8 +364,8 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 {\n                     let name_ptr = self.read_scalar(args[0])?.not_undef()?;\n                     if !name_ptr.is_null_ptr(self) {\n-                        let name = self.memory().read_c_str(name_ptr.to_ptr()?\n-                            )?.to_owned();\n+                        let name_ptr = name_ptr.to_ptr()?;\n+                        let name = self.memory().get(name_ptr.alloc_id)?.read_c_str(tcx, name_ptr)?.to_owned();\n                         if !name.is_empty() && !name.contains(&b'=') {\n                             success = Some(self.machine.env_vars.remove(&name));\n                         }\n@@ -382,9 +386,10 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 {\n                     let name_ptr = self.read_scalar(args[0])?.not_undef()?;\n                     let value_ptr = self.read_scalar(args[1])?.to_ptr()?;\n-                    let value = self.memory().read_c_str(value_ptr)?;\n+                    let value = self.memory().get(value_ptr.alloc_id)?.read_c_str(tcx, value_ptr)?;\n                     if !name_ptr.is_null_ptr(self) {\n-                        let name = self.memory().read_c_str(name_ptr.to_ptr()?)?;\n+                        let name_ptr = name_ptr.to_ptr()?;\n+                        let name = self.memory().get(name_ptr.alloc_id)?.read_c_str(tcx, name_ptr)?;\n                         if !name.is_empty() && !name.contains(&b'=') {\n                             new = Some((name.to_owned(), value.to_owned()));\n                         }\n@@ -394,12 +399,15 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                     // +1 for the null terminator\n                     let value_copy = self.memory_mut().allocate(\n                         Size::from_bytes((value.len() + 1) as u64),\n-                        Align::from_bytes(1, 1).unwrap(),\n+                        Align::from_bytes(1).unwrap(),\n                         MiriMemoryKind::Env.into(),\n                     )?.with_default_tag();\n-                    self.memory_mut().write_bytes(value_copy.into(), &value)?;\n-                    let trailing_zero_ptr = value_copy.offset(Size::from_bytes(value.len() as u64), self)?.into();\n-                    self.memory_mut().write_bytes(trailing_zero_ptr, &[0])?;\n+                    {\n+                        let alloc = self.memory_mut().get_mut(value_copy.alloc_id)?;\n+                        alloc.write_bytes(tcx, value_copy, &value)?;\n+                        let trailing_zero_ptr = value_copy.offset(Size::from_bytes(value.len() as u64), tcx)?;\n+                        alloc.write_bytes(tcx, trailing_zero_ptr, &[0])?;\n+                    }\n                     if let Some(var) = self.machine.env_vars.insert(\n                         name.to_owned(),\n                         value_copy,\n@@ -444,7 +452,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n \n             \"strlen\" => {\n                 let ptr = self.read_scalar(args[0])?.to_ptr()?;\n-                let n = self.memory().read_c_str(ptr)?.len();\n+                let n = self.memory().get(ptr.alloc_id)?.read_c_str(tcx, ptr)?.len();\n                 self.write_scalar(Scalar::from_uint(n as u64, dest.layout.size), dest)?;\n             }\n \n@@ -469,10 +477,9 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                             instance,\n                             promoted: None,\n                         };\n-                        let const_val = self.const_eval(cid)?;\n-                        let value = const_val.unwrap_bits(\n-                            self.tcx.tcx,\n-                            ty::ParamEnv::empty().and(self.tcx.types.i32)) as i32;\n+                        let const_val = self.const_eval_raw(cid)?;\n+                        let const_val = self.read_scalar(const_val.into())?;\n+                        let value = const_val.to_i32()?;\n                         if value == name {\n                             result = Some(path_value);\n                             break;\n@@ -508,13 +515,15 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 let key_layout = self.layout_of(key_type)?;\n \n                 // Create key and write it into the memory where key_ptr wants it\n-                let key = self.machine.tls.create_tls_key(dtor, &*self.tcx) as u128;\n+                let key = self.machine.tls.create_tls_key(dtor, tcx) as u128;\n                 if key_layout.size.bits() < 128 && key >= (1u128 << key_layout.size.bits() as u128) {\n                     return err!(OutOfTls);\n                 }\n-                self.memory_mut().write_scalar(\n+\n+                self.memory().check_align(key_ptr.into(), key_layout.align.abi)?;\n+                self.memory_mut().get_mut(key_ptr.alloc_id)?.write_scalar(\n+                    tcx,\n                     key_ptr,\n-                    key_layout.align,\n                     Scalar::from_uint(key, key_layout.size).into(),\n                     key_layout.size,\n                 )?;\n@@ -611,7 +620,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 // This just creates a key; Windows does not natively support TLS dtors.\n \n                 // Create key and return it\n-                let key = self.machine.tls.create_tls_key(None, &*self.tcx) as u128;\n+                let key = self.machine.tls.create_tls_key(None, tcx) as u128;\n \n                 // Figure out how large a TLS key actually is. This is c::DWORD.\n                 if dest.layout.size.bits() < 128 && key >= (1u128 << dest.layout.size.bits() as u128) {"}, {"sha": "2b1a28fe9e0d0f27a1cc864b27807a4a65cb2926", "filename": "src/helpers.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1edba2337b773e98439aa09acfb9280c548d036d/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1edba2337b773e98439aa09acfb9280c548d036d/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=1edba2337b773e98439aa09acfb9280c548d036d", "patch": "@@ -130,9 +130,10 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n                 unsafe_cell_action: |place| {\n                     trace!(\"unsafe_cell_action on {:?}\", place.ptr);\n                     // We need a size to go on.\n-                    let (unsafe_cell_size, _) = self.size_and_align_of_mplace(place)?\n+                    let unsafe_cell_size = self.size_and_align_of_mplace(place)?\n+                        .map(|(size, _)| size)\n                         // for extern types, just cover what we can\n-                        .unwrap_or_else(|| place.layout.size_and_align());\n+                        .unwrap_or_else(|| place.layout.size);\n                     // Now handle this `UnsafeCell`, unless it is empty.\n                     if unsafe_cell_size != Size::ZERO {\n                         unsafe_cell_action(place.ptr, unsafe_cell_size)"}, {"sha": "c9b16525e566268d5474fbdfe4e4ce0a9bd4550a", "filename": "src/intrinsic.rs", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1edba2337b773e98439aa09acfb9280c548d036d/src%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1edba2337b773e98439aa09acfb9280c548d036d/src%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic.rs?ref=1edba2337b773e98439aa09acfb9280c548d036d", "patch": "@@ -28,7 +28,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n         if self.emulate_intrinsic(instance, args, dest)? {\n             return Ok(());\n         }\n-\n+        let tcx = &{self.tcx.tcx};\n         let substs = instance.substs;\n \n         // All these intrinsics take raw pointers, so if we access memory directly\n@@ -152,7 +152,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                 let elem_layout = self.layout_of(elem_ty)?;\n                 let elem_size = elem_layout.size.bytes();\n                 let count = self.read_scalar(args[2])?.to_usize(self)?;\n-                let elem_align = elem_layout.align;\n+                let elem_align = elem_layout.align.abi;\n                 // erase tags: this is a raw ptr operation\n                 let src = self.read_scalar(args[0])?.not_undef()?;\n                 let dest = self.read_scalar(args[1])?.not_undef()?;\n@@ -248,6 +248,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                 // FIXME: We do not properly validate in case of ZSTs and when doing it in memory!\n                 // However, this only affects direct calls of the intrinsic; calls to the stable\n                 // functions wrapping them do get their validation.\n+                // FIXME: should we check that the destination pointer is aligned even for ZSTs?\n                 if !dest.layout.is_zst() { // nothing to do for ZST\n                     match dest.layout.abi {\n                         layout::Abi::Scalar(ref s) => {\n@@ -263,7 +264,9 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                             // Do it in memory\n                             let mplace = self.force_allocation(dest)?;\n                             assert!(mplace.meta.is_none());\n-                            self.memory_mut().write_repeat(mplace.ptr, 0, dest.layout.size)?;\n+                            // not a zst, must be valid pointer\n+                            let ptr = mplace.ptr.to_ptr()?;\n+                            self.memory_mut().get_mut(ptr.alloc_id)?.write_repeat(tcx, ptr, 0, dest.layout.size)?;\n                         }\n                     }\n                 }\n@@ -272,7 +275,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n             \"pref_align_of\" => {\n                 let ty = substs.type_at(0);\n                 let layout = self.layout_of(ty)?;\n-                let align = layout.align.pref();\n+                let align = layout.align.pref.bytes();\n                 let ptr_size = self.pointer_size();\n                 let align_val = Scalar::from_uint(align as u128, ptr_size);\n                 self.write_scalar(align_val, dest)?;\n@@ -364,7 +367,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                     .expect(\"size_of_val called on extern type\");\n                 let ptr_size = self.pointer_size();\n                 self.write_scalar(\n-                    Scalar::from_uint(align.abi(), ptr_size),\n+                    Scalar::from_uint(align.bytes(), ptr_size),\n                     dest,\n                 )?;\n             }\n@@ -412,6 +415,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                 // FIXME: We do not properly validate in case of ZSTs and when doing it in memory!\n                 // However, this only affects direct calls of the intrinsic; calls to the stable\n                 // functions wrapping them do get their validation.\n+                // FIXME: should we check alignment for ZSTs?\n                 if !dest.layout.is_zst() { // nothing to do for ZST\n                     match dest.layout.abi {\n                         layout::Abi::Scalar(..) => {\n@@ -426,7 +430,10 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                             // Do it in memory\n                             let mplace = self.force_allocation(dest)?;\n                             assert!(mplace.meta.is_none());\n-                            self.memory_mut().mark_definedness(mplace.ptr.to_ptr()?, dest.layout.size, false)?;\n+                            let ptr = mplace.ptr.to_ptr()?;\n+                            self.memory_mut()\n+                                .get_mut(ptr.alloc_id)?\n+                                .mark_definedness(ptr, dest.layout.size, false)?;\n                         }\n                     }\n                 }\n@@ -438,8 +445,14 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                 let val_byte = self.read_scalar(args[1])?.to_u8()?;\n                 let ptr = self.read_scalar(args[0])?.not_undef()?;\n                 let count = self.read_scalar(args[2])?.to_usize(self)?;\n-                self.memory().check_align(ptr, ty_layout.align)?;\n-                self.memory_mut().write_repeat(ptr, val_byte, ty_layout.size * count)?;\n+                self.memory().check_align(ptr, ty_layout.align.abi)?;\n+                let byte_count = ty_layout.size * count;\n+                if byte_count.bytes() != 0 {\n+                    let ptr = ptr.to_ptr()?;\n+                    self.memory_mut()\n+                        .get_mut(ptr.alloc_id)?\n+                        .write_repeat(tcx, ptr, val_byte, byte_count)?;\n+                }\n             }\n \n             name => return err!(Unimplemented(format!(\"unimplemented intrinsic: {}\", name))),"}, {"sha": "10a1405b2a628e752253dc5995bc7eb0b40020fa", "filename": "src/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1edba2337b773e98439aa09acfb9280c548d036d/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1edba2337b773e98439aa09acfb9280c548d036d/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=1edba2337b773e98439aa09acfb9280c548d036d", "patch": "@@ -1,4 +1,4 @@\n-#![feature(rustc_private, extern_crate_item_prelude)]\n+#![feature(rustc_private)]\n \n #![cfg_attr(feature = \"cargo-clippy\", allow(cast_lossless))]\n \n@@ -397,7 +397,7 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n \n         // Second argument: align\n         let arg = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n-        let align = layout.align.abi();\n+        let align = layout.align.abi.bytes();\n         ecx.write_scalar(Scalar::from_uint(align, arg.layout.size), arg)?;\n \n         // No more arguments\n@@ -419,7 +419,7 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n             \"__cxa_thread_atexit_impl\" => {\n                 // This should be all-zero, pointer-sized\n                 let data = vec![0; tcx.data_layout.pointer_size.bytes() as usize];\n-                Allocation::from_bytes(&data[..], tcx.data_layout.pointer_align)\n+                Allocation::from_bytes(&data[..], tcx.data_layout.pointer_align.abi)\n             }\n             _ => return err!(Unimplemented(\n                     format!(\"can't access foreign static: {}\", link_name),\n@@ -458,9 +458,9 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n         place: MPlaceTy<'tcx, Borrow>,\n         mutability: Option<hir::Mutability>,\n     ) -> EvalResult<'tcx, Scalar<Borrow>> {\n-        let (size, _) = ecx.size_and_align_of_mplace(place)?\n+        let size = ecx.size_and_align_of_mplace(place)?.map(|(size, _)| size)\n             // for extern types, just cover what we can\n-            .unwrap_or_else(|| place.layout.size_and_align());\n+            .unwrap_or_else(|| place.layout.size);\n         if !ecx.tcx.sess.opts.debugging_opts.mir_emit_retag ||\n             !Self::enforce_validity(ecx) || size == Size::ZERO\n         {\n@@ -498,9 +498,9 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n         // This is deliberately NOT `deref_operand` as we do not want `tag_dereference`\n         // to be called!  That would kill the original tag if we got a raw ptr.\n         let place = ecx.ref_to_mplace(ecx.read_immediate(ptr)?)?;\n-        let (size, _) = ecx.size_and_align_of_mplace(place)?\n+        let size = ecx.size_and_align_of_mplace(place)?.map(|(size, _)| size)\n             // for extern types, just cover what we can\n-            .unwrap_or_else(|| place.layout.size_and_align());\n+            .unwrap_or_else(|| place.layout.size);\n         if !ecx.tcx.sess.opts.debugging_opts.mir_emit_retag ||\n             !ecx.machine.validate || size == Size::ZERO\n         {"}, {"sha": "e1ccdf91995efaab70fbda980b1ca4c1cd0fda18", "filename": "src/operator.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1edba2337b773e98439aa09acfb9280c548d036d/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1edba2337b773e98439aa09acfb9280c548d036d/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=1edba2337b773e98439aa09acfb9280c548d036d", "patch": "@@ -142,10 +142,12 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                     // allocations sit right next to each other.  The C/C++ standards are\n                     // somewhat fuzzy about this case, so I think for now this check is\n                     // \"good enough\".\n-                    // We require liveness, as dead allocations can of course overlap.\n-                    self.memory().check_bounds_ptr(left, InboundsCheck::Live)?;\n-                    self.memory().check_bounds_ptr(right, InboundsCheck::Live)?;\n-                    // Two live in-bounds pointers, we can compare across allocations\n+                    // Dead allocations in miri cannot overlap with live allocations, but\n+                    // on read hardware this can easily happen. Thus for comparisons we require\n+                    // both pointers to be live.\n+                    self.memory().get(left.alloc_id)?.check_bounds_ptr(left)?;\n+                    self.memory().get(right.alloc_id)?.check_bounds_ptr(right)?;\n+                    // Two in-bounds pointers, we can compare across allocations\n                     left == right\n                 }\n             }\n@@ -158,20 +160,21 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                 // Case I: Comparing with NULL\n                 if bits == 0 {\n                     // Test if the ptr is in-bounds. Then it cannot be NULL.\n-                    if self.memory().check_bounds_ptr(ptr, InboundsCheck::MaybeDead).is_ok() {\n+                    // Even dangling pointers cannot be NULL.\n+                    if self.memory().check_bounds_ptr_maybe_dead(ptr).is_ok() {\n                         return Ok(false);\n                     }\n                 }\n \n                 let (alloc_size, alloc_align) = self.memory().get_size_and_align(ptr.alloc_id);\n \n                 // Case II: Alignment gives it away\n-                if ptr.offset.bytes() % alloc_align.abi() == 0 {\n+                if ptr.offset.bytes() % alloc_align.bytes() == 0 {\n                     // The offset maintains the allocation alignment, so we know `base+offset`\n                     // is aligned by `alloc_align`.\n                     // FIXME: We could be even more general, e.g. offset 2 into a 4-aligned\n                     // allocation cannot equal 3.\n-                    if bits % alloc_align.abi() != 0 {\n+                    if bits % alloc_align.bytes() != 0 {\n                         // The integer is *not* aligned. So they cannot be equal.\n                         return Ok(false);\n                     }\n@@ -226,7 +229,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                 map_to_primval(left.overflowing_offset(Size::from_bytes(right as u64), self)),\n \n             BitAnd if !signed => {\n-                let ptr_base_align = self.memory().get(left.alloc_id)?.align.abi();\n+                let ptr_base_align = self.memory().get(left.alloc_id)?.align.bytes();\n                 let base_mask = {\n                     // FIXME: Use interpret::truncate, once that takes a Size instead of a Layout\n                     let shift = 128 - self.memory().pointer_size().bits();\n@@ -259,7 +262,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n             Rem if !signed => {\n                 // Doing modulo a divisor of the alignment is allowed.\n                 // (Intuition: Modulo a divisor leaks less information.)\n-                let ptr_base_align = self.memory().get(left.alloc_id)?.align.abi();\n+                let ptr_base_align = self.memory().get(left.alloc_id)?.align.bytes();\n                 let right = right as u64;\n                 let ptr_size = self.memory().pointer_size().bytes() as u8;\n                 if right == 1 {\n@@ -298,9 +301,10 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n         if let Scalar::Ptr(ptr) = ptr {\n             // Both old and new pointer must be in-bounds of a *live* allocation.\n             // (Of the same allocation, but that part is trivial with our representation.)\n-            self.memory().check_bounds_ptr(ptr, InboundsCheck::Live)?;\n+            let alloc = self.memory().get(ptr.alloc_id)?;\n+            alloc.check_bounds_ptr(ptr)?;\n             let ptr = ptr.signed_offset(offset, self)?;\n-            self.memory().check_bounds_ptr(ptr, InboundsCheck::Live)?;\n+            alloc.check_bounds_ptr(ptr)?;\n             Ok(Scalar::Ptr(ptr))\n         } else {\n             // An integer pointer. They can only be offset by 0, and we pretend there"}, {"sha": "f292d083637ac6647b885dc2822d051e7e667fa1", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 12, "deletions": 35, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/1edba2337b773e98439aa09acfb9280c548d036d/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1edba2337b773e98439aa09acfb9280c548d036d/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=1edba2337b773e98439aa09acfb9280c548d036d", "patch": "@@ -5,7 +5,7 @@ use rustc::hir::{Mutability, MutMutable, MutImmutable};\n \n use crate::{\n     EvalResult, EvalErrorKind, MiriEvalContext, HelpersEvalContextExt, Evaluator, MutValueVisitor,\n-    MemoryKind, MiriMemoryKind, RangeMap, AllocId, Allocation, AllocationExtra, InboundsCheck,\n+    MemoryKind, MiriMemoryKind, RangeMap, AllocId, Allocation, AllocationExtra,\n     Pointer, MemPlace, Scalar, Immediate, ImmTy, PlaceTy, MPlaceTy,\n };\n \n@@ -151,6 +151,10 @@ impl<'tcx> Stack {\n     /// Returns the index of the item we matched, `None` if it was the frozen one.\n     /// `kind` indicates which kind of reference is being dereferenced.\n     fn deref(&self, bor: Borrow, kind: RefKind) -> Result<Option<usize>, String> {\n+        // Exclude unique ref with frozen tag.\n+        if let (RefKind::Unique, Borrow::Shr(Some(_))) = (kind, bor) {\n+            return Err(format!(\"Encountered mutable reference with frozen tag ({:?})\", bor));\n+        }\n         // Checks related to freezing\n         match bor {\n             Borrow::Shr(Some(bor_t)) if kind == RefKind::Frozen => {\n@@ -490,41 +494,14 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for MiriEvalContext<'a, 'mir, 'tcx> {\n             if let Some(mutability) = mutability { format!(\"{:?}\", mutability) } else { format!(\"raw\") },\n             place.ptr, place.layout.ty);\n         let ptr = place.ptr.to_ptr()?;\n-        // In principle we should not have to do anything here.  However, with transmutes involved,\n-        // it can happen that the tag of `ptr` does not actually match `mutability`, and we\n-        // should adjust for that.\n-        // Notably, the compiler can introduce such transmutes by optimizing away `&[mut]*`.\n-        // That can transmute a raw ptr to a (shared/mut) ref, and a mut ref to a shared one.\n-        match (mutability, ptr.tag) {\n-            (None, _) => {\n-                // No further validation on raw accesses.\n-                return Ok(());\n-            }\n-            (Some(MutMutable), Borrow::Uniq(_)) |\n-            (Some(MutImmutable), Borrow::Shr(_)) => {\n-                // Expected combinations.  Nothing to do.\n-            }\n-            (Some(MutMutable), Borrow::Shr(None)) => {\n-                // Raw transmuted to mut ref.  This is something real unsafe code does.\n-                // We cannot reborrow here because we do not want to mutate state on a deref.\n-            }\n-            (Some(MutImmutable), Borrow::Uniq(_)) => {\n-                // A mut got transmuted to shr.  Can happen even from compiler transformations:\n-                // `&*x` gets optimized to `x` even when `x` is a `&mut`.\n-            }\n-            (Some(MutMutable), Borrow::Shr(Some(_))) => {\n-                // This is just invalid: A shr got transmuted to a mut.\n-                // If we ever allow this, we have to consider what we do when a turn a\n-                // `Raw`-tagged `&mut` into a raw pointer pointing to a frozen location.\n-                // We probably do not want to allow that, but we have to allow\n-                // turning a `Raw`-tagged `&` into a raw ptr to a frozen location.\n-                return err!(MachineError(format!(\"Encountered mutable reference with frozen tag {:?}\", ptr.tag)))\n-            }\n+        if mutability.is_none() {\n+            // No further checks on raw derefs -- only the access itself will be checked.\n+            return Ok(());\n         }\n \n         // Get the allocation\n-        self.memory().check_bounds(ptr, size, InboundsCheck::Live)?;\n-        let alloc = self.memory().get(ptr.alloc_id).expect(\"We checked that the ptr is fine!\");\n+        let alloc = self.memory().get(ptr.alloc_id)?;\n+        alloc.check_bounds(self, ptr, size)?;\n         // If we got here, we do some checking, *but* we leave the tag unchanged.\n         if let Borrow::Shr(Some(_)) = ptr.tag {\n             assert_eq!(mutability, Some(MutImmutable));\n@@ -566,8 +543,8 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for MiriEvalContext<'a, 'mir, 'tcx> {\n             ptr, place.layout.ty, new_bor);\n \n         // Get the allocation.  It might not be mutable, so we cannot use `get_mut`.\n-        self.memory().check_bounds(ptr, size, InboundsCheck::Live)?;\n-        let alloc = self.memory().get(ptr.alloc_id).expect(\"We checked that the ptr is fine!\");\n+        let alloc = self.memory().get(ptr.alloc_id)?;\n+        alloc.check_bounds(self, ptr, size)?;\n         // Update the stacks.\n         if let Borrow::Shr(Some(_)) = new_bor {\n             // Reference that cares about freezing. We need a frozen-sensitive reborrow."}, {"sha": "bd0fec859d8f7c424a677f8f1120fd635b8a97bf", "filename": "tests/compile-fail-fullmir/stacked_borrows/box_exclusive_violation1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1edba2337b773e98439aa09acfb9280c548d036d/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fbox_exclusive_violation1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1edba2337b773e98439aa09acfb9280c548d036d/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fbox_exclusive_violation1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fbox_exclusive_violation1.rs?ref=1edba2337b773e98439aa09acfb9280c548d036d", "patch": "@@ -25,5 +25,5 @@ fn unknown_code_2() { unsafe {\n } }\n \n fn main() {\n-    assert_eq!(demo_mut_advanced_unique(Box::new(0)), 5);\n+    demo_mut_advanced_unique(Box::new(0));\n }"}, {"sha": "fec699e35bcfbab58772d077404d697c0f1ce5a2", "filename": "tests/compile-fail-fullmir/stacked_borrows/mut_exclusive_violation1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1edba2337b773e98439aa09acfb9280c548d036d/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fmut_exclusive_violation1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1edba2337b773e98439aa09acfb9280c548d036d/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fmut_exclusive_violation1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fmut_exclusive_violation1.rs?ref=1edba2337b773e98439aa09acfb9280c548d036d", "patch": "@@ -25,5 +25,5 @@ fn unknown_code_2() { unsafe {\n } }\n \n fn main() {\n-    assert_eq!(demo_mut_advanced_unique(&mut 0), 5);\n+    demo_mut_advanced_unique(&mut 0);\n }"}, {"sha": "c092cbfe5098594ea79af8b5da8019842b270410", "filename": "tests/compile-fail-fullmir/stacked_borrows/static_memory_modification.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1edba2337b773e98439aa09acfb9280c548d036d/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fstatic_memory_modification.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1edba2337b773e98439aa09acfb9280c548d036d/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fstatic_memory_modification.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fstatic_memory_modification.rs?ref=1edba2337b773e98439aa09acfb9280c548d036d", "patch": "@@ -1,6 +1,3 @@\n-// FIXME still considering whether we are okay with this not being an error\n-// ignore-test\n-\n static X: usize = 5;\n \n #[allow(mutable_transmutes)]"}, {"sha": "3dd30fd676fd1011aa3c0834d8b4f3cf1bd0272a", "filename": "tests/run-pass-fullmir/foreign-fn-linkname.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1edba2337b773e98439aa09acfb9280c548d036d/tests%2Frun-pass-fullmir%2Fforeign-fn-linkname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1edba2337b773e98439aa09acfb9280c548d036d/tests%2Frun-pass-fullmir%2Fforeign-fn-linkname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fforeign-fn-linkname.rs?ref=1edba2337b773e98439aa09acfb9280c548d036d", "patch": "@@ -10,7 +10,7 @@\n \n //ignore-windows: Uses POSIX APIs\n \n-#![feature(libc, extern_crate_item_prelude)]\n+#![feature(libc)]\n #![allow(unused_extern_crates)] // rustc bug https://github.com/rust-lang/rust/issues/56098\n \n extern crate libc;"}, {"sha": "93bdf5ffbf326bef3bf65f38a1e72aa169771da9", "filename": "tests/run-pass/stacked-borrows.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1edba2337b773e98439aa09acfb9280c548d036d/tests%2Frun-pass%2Fstacked-borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1edba2337b773e98439aa09acfb9280c548d036d/tests%2Frun-pass%2Fstacked-borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fstacked-borrows.rs?ref=1edba2337b773e98439aa09acfb9280c548d036d", "patch": "@@ -7,6 +7,7 @@ fn main() {\n     mut_shr_raw();\n     mut_raw_then_mut_shr();\n     mut_raw_mut();\n+    partially_invalidate_mut();\n }\n \n // Deref a raw ptr to access a field of a large struct, where the field\n@@ -97,3 +98,12 @@ fn mut_raw_mut() {\n     }\n     assert_eq!(x, 4);\n }\n+\n+fn partially_invalidate_mut() {\n+    let data = &mut (0u8, 0u8);\n+    let reborrow = &mut *data as *mut (u8, u8);\n+    let shard = unsafe { &mut (*reborrow).0 };\n+    data.1 += 1; // the deref overlaps with `shard`, but that is okay; the access does not overlap.\n+    *shard += 1; // so we can still use `shard`.\n+    assert_eq!(*data, (1, 1));\n+}"}]}