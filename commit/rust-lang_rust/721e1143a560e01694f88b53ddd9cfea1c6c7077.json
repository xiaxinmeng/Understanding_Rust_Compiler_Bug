{"sha": "721e1143a560e01694f88b53ddd9cfea1c6c7077", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyMWUxMTQzYTU2MGUwMTY5NGY4OGI1M2RkZDljZmVhMWM2YzcwNzc=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-04-26T01:36:02Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-04-26T18:07:47Z"}, "message": "tutorial: rework the section on destructors\n\nThis removes the comparison to manual memory management examples,\nbecause it requires too much existing knowledge. Implementing custom\ndestructors can be covered in the FFI tutorial, where `unsafe` is\nalready well explained.", "tree": {"sha": "3f7d8a16b982a7993e62d3d0c1d4d9fc3a13c392", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f7d8a16b982a7993e62d3d0c1d4d9fc3a13c392"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/721e1143a560e01694f88b53ddd9cfea1c6c7077", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/721e1143a560e01694f88b53ddd9cfea1c6c7077", "html_url": "https://github.com/rust-lang/rust/commit/721e1143a560e01694f88b53ddd9cfea1c6c7077", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/721e1143a560e01694f88b53ddd9cfea1c6c7077/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0604468fd540b4356ba28bf9a6d26b56b73d5b3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/0604468fd540b4356ba28bf9a6d26b56b73d5b3b", "html_url": "https://github.com/rust-lang/rust/commit/0604468fd540b4356ba28bf9a6d26b56b73d5b3b"}], "stats": {"total": 132, "additions": 33, "deletions": 99}, "files": [{"sha": "c757329a45f0609ec80a6cd544aac41e24b45775", "filename": "doc/tutorial.md", "status": "modified", "additions": 33, "deletions": 99, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/721e1143a560e01694f88b53ddd9cfea1c6c7077/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/721e1143a560e01694f88b53ddd9cfea1c6c7077/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=721e1143a560e01694f88b53ddd9cfea1c6c7077", "patch": "@@ -868,108 +868,27 @@ fn first((value, _): (int, float)) -> int { value }\n \n # Destructors\n \n-C-style resource management requires the programmer to match every allocation\n-with a free, which means manually tracking the responsibility for cleaning up\n-(the owner). Correctness is left to the programmer, and it's easy to get wrong.\n+A *destructor* is a function responsible for cleaning up the resources used by\n+an object when it is no longer accessible. Destructors can be defined to handle\n+the release of resources like files, sockets and heap memory.\n \n-The following code demonstrates manual memory management, in order to contrast\n-it with Rust's resource management. Rust enforces safety, so the `unsafe`\n-keyword is used to explicitly wrap the unsafe code. The keyword is a promise to\n-the compiler that unsafety does not leak outside of the unsafe block, and is\n-used to create safe concepts on top of low-level code.\n+Objects are never accessible after their destructor has been called, so there\n+are no dynamic failures from accessing freed resources. When a task fails, the\n+destructors of all objects in the task are called.\n \n-~~~~\n-use core::libc::{calloc, free, size_t};\n-\n-fn main() {\n-    unsafe {\n-        let a = calloc(1, int::bytes as size_t);\n-\n-        let d;\n+The `~` sigil represents a unique handle for a memory allocation on the heap:\n \n-        {\n-            let b = calloc(1, int::bytes as size_t);\n-\n-            let c = calloc(1, int::bytes as size_t);\n-            d = c; // move ownership to d\n-\n-            free(b);\n-        }\n-\n-        free(d);\n-        free(a);\n-    }\n-}\n ~~~~\n-\n-Rust uses destructors to handle the release of resources like memory\n-allocations, files and sockets. An object will only be destroyed when there is\n-no longer any way to access it, which prevents dynamic failures from an attempt\n-to use a freed resource. When a task fails, the stack unwinds and the\n-destructors of all objects owned by that task are called.\n-\n-The unsafe code from above can be contained behind a safe API that prevents\n-memory leaks or use-after-free:\n-\n-~~~~\n-use core::libc::{calloc, free, c_void, size_t};\n-\n-struct Blob { priv ptr: *c_void }\n-\n-impl Blob {\n-    fn new() -> Blob {\n-        unsafe { Blob{ptr: calloc(1, int::bytes as size_t)} }\n-    }\n-}\n-\n-impl Drop for Blob {\n-    fn finalize(&self) {\n-        unsafe { free(self.ptr); }\n-    }\n-}\n-\n-fn main() {\n-    let a = Blob::new();\n-\n-    let d;\n-\n-    {\n-        let b = Blob::new();\n-\n-        let c = Blob::new();\n-        d = c; // move ownership to d\n-\n-        // b is destroyed here\n-    }\n-\n-    // d is destroyed here\n-    // a is destroyed here\n+{\n+    // an integer allocated on the heap\n+    let y = ~10;\n }\n+// the destructor frees the heap memory as soon as `y` goes out of scope\n ~~~~\n \n-This pattern is common enough that Rust includes dynamically allocated memory\n-as first-class types (`~` and `@`). Non-memory resources like files are cleaned\n-up with custom destructors.\n-\n-~~~~\n-fn main() {\n-    let a = ~0;\n-\n-    let d;\n-\n-    {\n-        let b = ~0;\n-\n-        let c = ~0;\n-        d = c; // move ownership to d\n-\n-        // b is destroyed here\n-    }\n-\n-    // d is destroyed here\n-    // a is destroyed here\n-}\n-~~~~\n+Rust includes syntax for heap memory allocation in the language since it's\n+commonly used, but the same semantics can be implemented by a type with a\n+custom destructor.\n \n # Ownership\n \n@@ -984,6 +903,22 @@ and destroy the contained object when they go out of scope. A box managed by\n the garbage collector starts a new ownership tree, and the destructor is called\n when it is collected.\n \n+~~~~\n+// the struct owns the objects contained in the `x` and `y` fields\n+struct Foo { x: int, y: ~int }\n+\n+{\n+    // `a` is the owner of the struct, and thus the owner of the struct's fields\n+    let a = Foo { x: 5, y: ~10 };\n+}\n+// when `a` goes out of scope, the destructor for the `~int` in the struct's\n+// field is called\n+\n+// `b` is mutable, and the mutability is inherited by the objects it owns\n+let mut b = Foo { x: 5, y: ~10 };\n+b.x = 10;\n+~~~~\n+\n If an object doesn't contain garbage-collected boxes, it consists of a single\n ownership tree and is given the `Owned` trait which allows it to be sent\n between tasks. Custom destructors can only be implemented directly on types\n@@ -1007,7 +942,7 @@ refer to that through a pointer.\n ## Owned boxes\n \n An owned box (`~`) is a uniquely owned allocation on the heap. It inherits the\n-mutability and lifetime of the owner as it would if there was no box.\n+mutability and lifetime of the owner as it would if there was no box:\n \n ~~~~\n let x = 5; // immutable\n@@ -1021,8 +956,8 @@ let mut y = ~5; // mutable\n \n The purpose of an owned box is to add a layer of indirection in order to create\n recursive data structures or cheaply pass around an object larger than a\n-pointer. Since an owned box has a unique owner, it can be used to represent any\n-tree data structure.\n+pointer. Since an owned box has a unique owner, it can only be used to\n+represent a tree data structure.\n \n The following struct won't compile, because the lack of indirection would mean\n it has an infinite size:\n@@ -1092,7 +1027,6 @@ d = b;          // box type is the same, okay\n c = b;          // error\n ~~~~\n \n-\n # Move semantics\n \n Rust uses a shallow copy for parameter passing, assignment and returning values"}]}