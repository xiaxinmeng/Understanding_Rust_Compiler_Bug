{"sha": "c9a1c376fcf4d469742665a4be59cca68fc63ed7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5YTFjMzc2ZmNmNGQ0Njk3NDI2NjVhNGJlNTljY2E2OGZjNjNlZDc=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-09-18T13:33:36Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-11-25T14:26:16Z"}, "message": "Added fragments.rs: compute drop obligations remaining post moves.\n\nIncludes differentiation between assigned_fragments and\nmoved_fragments, support for all-but-one array fragments, and\ninstrumentation to print out the moved/assigned/unmmoved/parents for\neach function, factored out into separate submodule.", "tree": {"sha": "30c26e7cfa0680c88f9956a03feae51fa99d8fda", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30c26e7cfa0680c88f9956a03feae51fa99d8fda"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9a1c376fcf4d469742665a4be59cca68fc63ed7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9a1c376fcf4d469742665a4be59cca68fc63ed7", "html_url": "https://github.com/rust-lang/rust/commit/c9a1c376fcf4d469742665a4be59cca68fc63ed7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9a1c376fcf4d469742665a4be59cca68fc63ed7/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21fe017ab0114160c27ead73cb8515074aae0e1d", "url": "https://api.github.com/repos/rust-lang/rust/commits/21fe017ab0114160c27ead73cb8515074aae0e1d", "html_url": "https://github.com/rust-lang/rust/commit/21fe017ab0114160c27ead73cb8515074aae0e1d"}], "stats": {"total": 932, "additions": 924, "deletions": 8}, "files": [{"sha": "5b70d97b40276dd7c06e9b1835ba92520250a337", "filename": "src/librustc/middle/borrowck/doc.rs", "status": "modified", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/c9a1c376fcf4d469742665a4be59cca68fc63ed7/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9a1c376fcf4d469742665a4be59cca68fc63ed7/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs?ref=c9a1c376fcf4d469742665a4be59cca68fc63ed7", "patch": "@@ -27,6 +27,7 @@ These docs are long. Search for the section you are interested in.\n - Formal model\n - Borrowing and loans\n - Moves and initialization\n+- Drop flags and structural fragments\n - Future work\n \n # Overview\n@@ -1019,6 +1020,175 @@ walk back over, identify all uses, assignments, and captures, and\n check that they are legal given the set of dataflow bits we have\n computed for that program point.\n \n+# Drop flags and structural fragments\n+\n+In addition to the job of enforcing memory safety, the borrow checker\n+code is also responsible for identifying the *structural fragments* of\n+data in the function, to support out-of-band dynamic drop flags\n+allocated on the stack. (For background, see [RFC PR #320].)\n+\n+[RFC PR #320]: https://github.com/rust-lang/rfcs/pull/320\n+\n+Semantically, each piece of data that has a destructor may need a\n+boolean flag to indicate whether or not its destructor has been run\n+yet. However, in many cases there is no need to actually maintain such\n+a flag: It can be apparent from the code itself that a given path is\n+always initialized (or always deinitialized) when control reaches the\n+end of its owner's scope, and thus we can unconditionally emit (or\n+not) the destructor invocation for that path.\n+\n+A simple example of this is the following:\n+\n+```rust\n+struct D { p: int }\n+impl D { fn new(x: int) -> D { ... }\n+impl Drop for D { ... }\n+\n+fn foo(a: D, b: D, t: || -> bool) {\n+    let c: D;\n+    let d: D;\n+    if t() { c = b; }\n+}\n+```\n+\n+At the end of the body of `foo`, the compiler knows that `a` is\n+initialized, introducing a drop obligation (deallocating the boxed\n+integer) for the end of `a`'s scope that is run unconditionally.\n+Likewise the compiler knows that `d` is not initialized, and thus it\n+leave out the drop code for `d`.\n+\n+The compiler cannot statically know the drop-state of `b` nor `c` at\n+the end of their scope, since that depends on the value of\n+`t`. Therefore, we need to insert boolean flags to track whether we\n+need to drop `b` and `c`.\n+\n+However, the matter is not as simple as just mapping local variables\n+to their corresponding drop flags when necessary. In particular, in\n+addition to being able to move data out of local variables, Rust\n+allows one to move values in and out of structured data.\n+\n+Consider the following:\n+\n+```rust\n+struct S { x: D, y: D, z: D }\n+\n+fn foo(a: S, mut b: S, t: || -> bool) {\n+    let mut c: S;\n+    let d: S;\n+    let e: S = a.clone();\n+    if t() {\n+        c = b;\n+        b.x = e.y;\n+    }\n+    if t() { c.y = D::new(4); }\n+}\n+```\n+\n+As before, the drop obligations of `a` and `d` can be statically\n+determined, and again the state of `b` and `c` depend on dynamic\n+state. But additionally, the dynamic drop obligations introduced by\n+`b` and `c` are not just per-local boolean flags. For example, if the\n+first call to `t` returns `false` and the second call `true`, then at\n+the end of their scope, `b` will be completely initialized, but only\n+`c.y` in `c` will be initialized.  If both calls to `t` return `true`,\n+then at the end of their scope, `c` will be completely initialized,\n+but only `b.x` will be initialized in `b`, and only `e.x` and `e.z`\n+will be initialized in `e`.\n+\n+Note that we need to cover the `z` field in each case in some way,\n+since it may (or may not) need to be dropped, even though `z` is never\n+directly mentioned in the body of the `foo` function. We call a path\n+like `b.z` a *fragment sibling* of `b.x`, since the field `z` comes\n+from the same structure `S` that declared the field `x` in `b.x`.\n+\n+In general we need to maintain boolean flags that match the\n+`S`-structure of both `b` and `c`.  In addition, we need to consult\n+such a flag when doing an assignment (such as `c.y = D::new(4);`\n+above), in order to know whether or not there is a previous value that\n+needs to be dropped before we do the assignment.\n+\n+So for any given function, we need to determine what flags are needed\n+to track its drop obligations. Our strategy for determining the set of\n+flags is to represent the fragmentation of the structure explicitly:\n+by starting initially from the paths that are explicitly mentioned in\n+moves and assignments (such as `b.x` and `c.y` above), and then\n+traversing the structure of the path's type to identify leftover\n+*unmoved fragments*: assigning into `c.y` means that `c.x` and `c.z`\n+are leftover unmoved fragments. Each fragment represents a drop\n+obligation that may need to be tracked. Paths that are only moved or\n+assigned in their entirety (like `a` and `d`) are treated as a single\n+drop obligation.\n+\n+The fragment construction process works by piggy-backing on the\n+existing `move_data` module. We already have callbacks that visit each\n+direct move and assignment; these form the basis for the sets of\n+moved_leaf_paths and assigned_leaf_paths. From these leaves, we can\n+walk up their parent chain to identify all of their parent paths.\n+We need to identify the parents because of cases like the following:\n+\n+```rust\n+struct Pair<X,Y>{ x: X, y: Y }\n+fn foo(dd_d_d: Pair<Pair<Pair<D, D>, D>, D>) {\n+    other_function(dd_d_d.x.y);\n+}\n+```\n+\n+In this code, the move of the path `dd_d.x.y` leaves behind not only\n+the fragment drop-obligation `dd_d.x.x` but also `dd_d.y` as well.\n+\n+Once we have identified the directly-referenced leaves and their\n+parents, we compute the left-over fragments, in the function\n+`fragments::add_fragment_siblings`. As of this writing this works by\n+looking at each directly-moved or assigned path P, and blindly\n+gathering all sibling fields of P (as well as siblings for the parents\n+of P, etc). After accumulating all such siblings, we filter out the\n+entries added as siblings of P that turned out to be\n+directly-referenced paths (or parents of directly referenced paths)\n+themselves, thus leaving the never-referenced \"left-overs\" as the only\n+thing left from the gathering step.\n+\n+## Array structural fragments\n+\n+A special case of the structural fragments discussed above are\n+the elements of an array that has been passed by value, such as\n+the following:\n+\n+```rust\n+fn foo(a: [D, ..10], i: uint) -> D {\n+    a[i]\n+}\n+```\n+\n+The above code moves a single element out of the input array `a`.\n+The remainder of the array still needs to be dropped; i.e., it\n+is a structural fragment. Note that after performing such a move,\n+it is not legal to read from the array `a`. There are a number of\n+ways to deal with this, but the important thing to note is that\n+the semantics needs to distinguish in some manner between a\n+fragment that is the *entire* array versus a fragment that represents\n+all-but-one element of the array.  A place where that distinction\n+would arise is the following:\n+\n+```rust\n+fn foo(a: [D, ..10], b: [D, ..10], i: uint, t: bool) -> D {\n+    if t {\n+        a[i]\n+    } else {\n+        b[i]\n+    }\n+\n+    // When control exits, we will need either to drop all of `a`\n+    // and all-but-one of `b`, or to drop all of `b` and all-but-one\n+    // of `a`.\n+}\n+```\n+\n+There are a number of ways that the trans backend could choose to\n+compile this (e.g. a `[bool, ..10]` array for each such moved array;\n+or an `Option<uint>` for each moved array).  From the viewpoint of the\n+borrow-checker, the important thing is to record what kind of fragment\n+is implied by the relevant moves.\n+\n # Future work\n \n While writing up these docs, I encountered some rules I believe to be"}, {"sha": "7e766e9138e35f6e49a6cac4adedae312af08d58", "filename": "src/librustc/middle/borrowck/fragments.rs", "status": "added", "additions": 491, "deletions": 0, "changes": 491, "blob_url": "https://github.com/rust-lang/rust/blob/c9a1c376fcf4d469742665a4be59cca68fc63ed7/src%2Flibrustc%2Fmiddle%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9a1c376fcf4d469742665a4be59cca68fc63ed7/src%2Flibrustc%2Fmiddle%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Ffragments.rs?ref=c9a1c376fcf4d469742665a4be59cca68fc63ed7", "patch": "@@ -0,0 +1,491 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+\n+Helper routines used for fragmenting structural paths due to moves for\n+tracking drop obligations. Please see the extensive comments in the\n+section \"Structural fragments\" in `doc.rs`.\n+\n+*/\n+use self::Fragment::*;\n+\n+use session::config;\n+use middle::borrowck::{LoanPath};\n+use middle::borrowck::LoanPathKind::{LpVar, LpUpvar, LpDowncast, LpExtend};\n+use middle::borrowck::LoanPathElem::{LpDeref, LpInterior};\n+use middle::borrowck::move_data::{InvalidMovePathIndex};\n+use middle::borrowck::move_data::{MoveData, MovePathIndex};\n+use middle::ty;\n+use middle::mem_categorization as mc;\n+use util::ppaux::{Repr, UserString};\n+\n+use std::mem;\n+use std::rc::Rc;\n+use std::slice;\n+use syntax::ast;\n+use syntax::ast_map;\n+use syntax::attr::AttrMetaMethods;\n+use syntax::codemap::Span;\n+\n+#[deriving(PartialEq, Eq, PartialOrd, Ord)]\n+enum Fragment {\n+    // This represents the path described by the move path index\n+    Just(MovePathIndex),\n+\n+    // This represents the collection of all but one of the elements\n+    // from an array at the path described by the move path index.\n+    // Note that attached MovePathIndex should have mem_categorization\n+    // of InteriorElement (i.e. array dereference `[]`).\n+    AllButOneFrom(MovePathIndex),\n+}\n+\n+impl Fragment {\n+    fn loan_path_repr<'tcx>(&self, move_data: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) -> String {\n+        let repr = |mpi| move_data.path_loan_path(mpi).repr(tcx);\n+        match *self {\n+            Just(mpi) => repr(mpi),\n+            AllButOneFrom(mpi) => format!(\"$(allbutone {})\", repr(mpi)),\n+        }\n+    }\n+\n+    fn loan_path_user_string<'tcx>(&self,\n+                                   move_data: &MoveData<'tcx>,\n+                                   tcx: &ty::ctxt<'tcx>) -> String {\n+        let user_string = |mpi| move_data.path_loan_path(mpi).user_string(tcx);\n+        match *self {\n+            Just(mpi) => user_string(mpi),\n+            AllButOneFrom(mpi) => format!(\"$(allbutone {})\", user_string(mpi)),\n+        }\n+    }\n+}\n+\n+pub struct FragmentSets {\n+    /// During move_data construction, `moved_leaf_paths` tracks paths\n+    /// that have been used directly by being moved out of.  When\n+    /// move_data construction has been completed, `moved_leaf_paths`\n+    /// tracks such paths that are *leaf fragments* (e.g. `a.j` if we\n+    /// never move out any child like `a.j.x`); any parent paths\n+    /// (e.g. `a` for the `a.j` example) are moved over to\n+    /// `parents_of_fragments`.\n+    moved_leaf_paths: Vec<MovePathIndex>,\n+\n+    /// `assigned_leaf_paths` tracks paths that have been used\n+    /// directly by being overwritten, but is otherwise much like\n+    /// `moved_leaf_paths`.\n+    assigned_leaf_paths: Vec<MovePathIndex>,\n+\n+    /// `parents_of_fragments` tracks paths that are definitely\n+    /// parents of paths that have been moved.\n+    ///\n+    /// FIXME(pnkfelix) probably do not want/need\n+    /// `parents_of_fragments` at all, if we can avoid it.\n+    ///\n+    /// Update: I do not see a way to to avoid it.  Maybe just remove\n+    /// above fixme, or at least document why doing this may be hard.\n+    parents_of_fragments: Vec<MovePathIndex>,\n+\n+    /// During move_data construction (specifically the\n+    /// fixup_fragment_sets call), `unmoved_fragments` tracks paths\n+    /// that have been \"left behind\" after a sibling has been moved or\n+    /// assigned.  When move_data construction has been completed,\n+    /// `unmoved_fragments` tracks paths that were *only* results of\n+    /// being left-behind, and never directly moved themselves.\n+    unmoved_fragments: Vec<Fragment>,\n+}\n+\n+impl FragmentSets {\n+    pub fn new() -> FragmentSets {\n+        FragmentSets {\n+            unmoved_fragments: Vec::new(),\n+            moved_leaf_paths: Vec::new(),\n+            assigned_leaf_paths: Vec::new(),\n+            parents_of_fragments: Vec::new(),\n+        }\n+    }\n+\n+    pub fn add_move(&mut self, path_index: MovePathIndex) {\n+        self.moved_leaf_paths.push(path_index);\n+    }\n+\n+    pub fn add_assignment(&mut self, path_index: MovePathIndex) {\n+        self.assigned_leaf_paths.push(path_index);\n+    }\n+}\n+\n+pub fn instrument_move_fragments<'tcx>(this: &MoveData<'tcx>,\n+                                       tcx: &ty::ctxt<'tcx>,\n+                                       sp: Span,\n+                                       id: ast::NodeId) {\n+    let (span_err, print) = {\n+        let attrs : &[ast::Attribute];\n+        attrs = match tcx.map.find(id) {\n+            Some(ast_map::NodeItem(ref item)) =>\n+                item.attrs.as_slice(),\n+            Some(ast_map::NodeImplItem(&ast::MethodImplItem(ref m))) =>\n+                m.attrs.as_slice(),\n+            Some(ast_map::NodeTraitItem(&ast::ProvidedMethod(ref m))) =>\n+                m.attrs.as_slice(),\n+            _ => [].as_slice(),\n+        };\n+\n+        let span_err =\n+            attrs.iter().any(|a| a.check_name(\"rustc_move_fragments\"));\n+        let print = tcx.sess.debugging_opt(config::PRINT_MOVE_FRAGMENTS);\n+\n+        (span_err, print)\n+    };\n+\n+    if !span_err && !print { return; }\n+\n+    let instrument_all_paths = |kind, vec_rc: &Vec<MovePathIndex>| {\n+        for (i, mpi) in vec_rc.iter().enumerate() {\n+            let render = || this.path_loan_path(*mpi).user_string(tcx);\n+            if span_err {\n+                tcx.sess.span_err(sp, format!(\"{}: `{}`\", kind, render()).as_slice());\n+            }\n+            if print {\n+                println!(\"id:{} {}[{}] `{}`\", id, kind, i, render());\n+            }\n+        }\n+    };\n+\n+    let instrument_all_fragments = |kind, vec_rc: &Vec<Fragment>| {\n+        for (i, f) in vec_rc.iter().enumerate() {\n+            let render = || f.loan_path_user_string(this, tcx);\n+            if span_err {\n+                tcx.sess.span_err(sp, format!(\"{}: `{}`\", kind, render()).as_slice());\n+            }\n+            if print {\n+                println!(\"id:{} {}[{}] `{}`\", id, kind, i, render());\n+            }\n+        }\n+    };\n+\n+    let fragments = this.fragments.borrow();\n+    instrument_all_paths(\"moved_leaf_path\", &fragments.moved_leaf_paths);\n+    instrument_all_fragments(\"unmoved_fragment\", &fragments.unmoved_fragments);\n+    instrument_all_paths(\"parent_of_fragments\", &fragments.parents_of_fragments);\n+    instrument_all_paths(\"assigned_leaf_path\", &fragments.assigned_leaf_paths);\n+}\n+\n+pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) {\n+    /*!\n+     * Normalizes the fragment sets in `this`; i.e., removes\n+     * duplicate entries, constructs the set of parents, and\n+     * constructs the left-over fragments.\n+     *\n+     * Note: \"left-over fragments\" means paths that were not\n+     * directly referenced in moves nor assignments, but must\n+     * nonetheless be tracked as potential drop obligations.\n+     */\n+\n+    let mut fragments = this.fragments.borrow_mut();\n+\n+    // Swap out contents of fragments so that we can modify the fields\n+    // without borrowing the common fragments.\n+    let mut unmoved = mem::replace(&mut fragments.unmoved_fragments, vec![]);\n+    let mut parents = mem::replace(&mut fragments.parents_of_fragments, vec![]);\n+    let mut moved = mem::replace(&mut fragments.moved_leaf_paths, vec![]);\n+    let mut assigned = mem::replace(&mut fragments.assigned_leaf_paths, vec![]);\n+\n+    let path_lps = |mpis: &[MovePathIndex]| -> Vec<String> {\n+        mpis.iter().map(|mpi| this.path_loan_path(*mpi).repr(tcx)).collect()\n+    };\n+\n+    let frag_lps = |fs: &[Fragment]| -> Vec<String> {\n+        fs.iter().map(|f| f.loan_path_repr(this, tcx)).collect()\n+    };\n+\n+    // First, filter out duplicates\n+    moved.sort();\n+    moved.dedup();\n+    debug!(\"fragments 1 moved: {}\", path_lps(moved.as_slice()));\n+\n+    assigned.sort();\n+    assigned.dedup();\n+    debug!(\"fragments 1 assigned: {}\", path_lps(assigned.as_slice()));\n+\n+    // Second, build parents from the moved and assigned.\n+    for m in moved.iter() {\n+        let mut p = this.path_parent(*m);\n+        while p != InvalidMovePathIndex {\n+            parents.push(p);\n+            p = this.path_parent(p);\n+        }\n+    }\n+    for a in assigned.iter() {\n+        let mut p = this.path_parent(*a);\n+        while p != InvalidMovePathIndex {\n+            parents.push(p);\n+            p = this.path_parent(p);\n+        }\n+    }\n+\n+    parents.sort();\n+    parents.dedup();\n+    debug!(\"fragments 2 parents: {}\", path_lps(parents.as_slice()));\n+\n+    // Third, filter the moved and assigned fragments down to just the non-parents\n+    moved.retain(|f| non_member(*f, parents.as_slice()));\n+    debug!(\"fragments 3 moved: {}\", path_lps(moved.as_slice()));\n+\n+    assigned.retain(|f| non_member(*f, parents.as_slice()));\n+    debug!(\"fragments 3 assigned: {}\", path_lps(assigned.as_slice()));\n+\n+    // Fourth, build the leftover from the moved, assigned, and parents.\n+    for m in moved.as_slice().iter() {\n+        let lp = this.path_loan_path(*m);\n+        add_fragment_siblings(this, tcx, &mut unmoved, lp, None);\n+    }\n+    for a in assigned.as_slice().iter() {\n+        let lp = this.path_loan_path(*a);\n+        add_fragment_siblings(this, tcx, &mut unmoved, lp, None);\n+    }\n+    for p in parents.as_slice().iter() {\n+        let lp = this.path_loan_path(*p);\n+        add_fragment_siblings(this, tcx, &mut unmoved, lp, None);\n+    }\n+\n+    unmoved.sort();\n+    unmoved.dedup();\n+    debug!(\"fragments 4 unmoved: {}\", frag_lps(unmoved.as_slice()));\n+\n+    // Fifth, filter the leftover fragments down to its core.\n+    unmoved.retain(|f| match *f {\n+        AllButOneFrom(_) => true,\n+        Just(mpi) => non_member(mpi, parents.as_slice()) &&\n+            non_member(mpi, moved.as_slice()) &&\n+            non_member(mpi, assigned.as_slice())\n+    });\n+    debug!(\"fragments 5 unmoved: {}\", frag_lps(unmoved.as_slice()));\n+\n+    // Swap contents back in.\n+    fragments.unmoved_fragments = unmoved;\n+    fragments.parents_of_fragments = parents;\n+    fragments.moved_leaf_paths = moved;\n+    fragments.assigned_leaf_paths = assigned;\n+\n+    return;\n+\n+    fn non_member(elem: MovePathIndex, set: &[MovePathIndex]) -> bool {\n+        match set.binary_search_elem(&elem) {\n+            slice::Found(_) => false,\n+            slice::NotFound(_) => true,\n+        }\n+    }\n+}\n+\n+fn add_fragment_siblings<'tcx>(this: &MoveData<'tcx>,\n+                               tcx: &ty::ctxt<'tcx>,\n+                               gathered_fragments: &mut Vec<Fragment>,\n+                               lp: Rc<LoanPath<'tcx>>,\n+                               origin_id: Option<ast::NodeId>) {\n+    /*!\n+     * Adds all of the precisely-tracked siblings of `lp` as\n+     * potential move paths of interest. For example, if `lp`\n+     * represents `s.x.j`, then adds moves paths for `s.x.i` and\n+     * `s.x.k`, the siblings of `s.x.j`.\n+     */\n+\n+    match lp.kind {\n+        LpVar(_) | LpUpvar(..) => {} // Local variables have no siblings.\n+\n+        // Consuming a downcast is like consuming the original value, so propage inward.\n+        LpDowncast(ref loan_parent, _) => {\n+            add_fragment_siblings(this, tcx, gathered_fragments, loan_parent.clone(), origin_id);\n+        }\n+\n+        // *LV for OwnedPtr consumes the contents of the box (at\n+        // least when it is non-copy...), so propagate inward.\n+        LpExtend(ref loan_parent, _, LpDeref(mc::OwnedPtr)) => {\n+            add_fragment_siblings(this, tcx, gathered_fragments, loan_parent.clone(), origin_id);\n+        }\n+\n+        // *LV for unsafe and borrowed pointers do not consume their loan path, so stop here.\n+        LpExtend(_, _, LpDeref(mc::UnsafePtr(..)))   |\n+        LpExtend(_, _, LpDeref(mc::Implicit(..)))    |\n+        LpExtend(_, _, LpDeref(mc::BorrowedPtr(..))) => {}\n+\n+        // FIXME(pnkfelix): LV[j] should be tracked, at least in the\n+        // sense of we will track the remaining drop obligation of the\n+        // rest of the array.\n+        //\n+        // LV[j] is not tracked precisely\n+        LpExtend(_, _, LpInterior(mc::InteriorElement(_))) => {\n+            let mp = this.move_path(tcx, lp.clone());\n+            gathered_fragments.push(AllButOneFrom(mp));\n+        }\n+\n+        // field access LV.x and tuple access LV#k are the cases\n+        // we are interested in\n+        LpExtend(ref loan_parent, mc,\n+                 LpInterior(mc::InteriorField(ref field_name))) => {\n+            let enum_variant_info = match loan_parent.kind {\n+                LpDowncast(ref loan_parent_2, variant_def_id) =>\n+                    Some((variant_def_id, loan_parent_2.clone())),\n+                LpExtend(..) | LpVar(..) | LpUpvar(..) =>\n+                    None,\n+            };\n+            add_fragment_siblings_for_extension(\n+                this,\n+                tcx,\n+                gathered_fragments,\n+                loan_parent, mc, field_name, &lp, origin_id, enum_variant_info);\n+        }\n+    }\n+}\n+\n+fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n+                                             tcx: &ty::ctxt<'tcx>,\n+                                             gathered_fragments: &mut Vec<Fragment>,\n+                                             parent_lp: &Rc<LoanPath<'tcx>>,\n+                                             mc: mc::MutabilityCategory,\n+                                             origin_field_name: &mc::FieldName,\n+                                             origin_lp: &Rc<LoanPath<'tcx>>,\n+                                             origin_id: Option<ast::NodeId>,\n+                                             enum_variant_info: Option<(ast::DefId,\n+                                                                        Rc<LoanPath<'tcx>>)>) {\n+    /*!\n+     * We have determined that `origin_lp` destructures to\n+     * LpExtend(parent, original_field_name). Based on this,\n+     * add move paths for all of the siblings of `origin_lp`.\n+     */\n+\n+    let parent_ty = parent_lp.to_type();\n+\n+    let add_fragment_sibling_local = |field_name| {\n+        add_fragment_sibling_core(\n+            this, tcx, gathered_fragments, parent_lp.clone(), mc, field_name, origin_lp);\n+    };\n+\n+    match (&parent_ty.sty, enum_variant_info) {\n+        (&ty::ty_tup(ref v), None) => {\n+            let tuple_idx = match *origin_field_name {\n+                mc::PositionalField(tuple_idx) => tuple_idx,\n+                mc::NamedField(_) =>\n+                    panic!(\"tuple type {} should not have named fields.\",\n+                           parent_ty.repr(tcx)),\n+            };\n+            let tuple_len = v.len();\n+            for i in range(0, tuple_len) {\n+                if i == tuple_idx { continue }\n+                let field_name = mc::PositionalField(i);\n+                add_fragment_sibling_local(field_name);\n+            }\n+        }\n+\n+        (&ty::ty_struct(def_id, ref _substs), None) => {\n+            let fields = ty::lookup_struct_fields(tcx, def_id);\n+            match *origin_field_name {\n+                mc::NamedField(ast_name) => {\n+                    for f in fields.iter() {\n+                        if f.name == ast_name {\n+                            continue;\n+                        }\n+                        let field_name = mc::NamedField(f.name);\n+                        add_fragment_sibling_local(field_name);\n+                    }\n+                }\n+                mc::PositionalField(tuple_idx) => {\n+                    for (i, _f) in fields.iter().enumerate() {\n+                        if i == tuple_idx {\n+                            continue\n+                        }\n+                        let field_name = mc::PositionalField(i);\n+                        add_fragment_sibling_local(field_name);\n+                    }\n+                }\n+            }\n+        }\n+\n+        (&ty::ty_enum(enum_def_id, ref substs), ref enum_variant_info) => {\n+            let variant_info = {\n+                let mut variants = ty::substd_enum_variants(tcx, enum_def_id, substs);\n+                match *enum_variant_info {\n+                    Some((variant_def_id, ref _lp2)) =>\n+                        variants.iter()\n+                        .find(|variant| variant.id == variant_def_id)\n+                        .expect(\"enum_variant_with_id(): no variant exists with that ID\")\n+                        .clone(),\n+                    None => {\n+                        assert_eq!(variants.len(), 1);\n+                        variants.pop().unwrap()\n+                    }\n+                }\n+            };\n+            match *origin_field_name {\n+                mc::NamedField(ast_name) => {\n+                    let variant_arg_names = variant_info.arg_names.as_ref().unwrap();\n+                    for variant_arg_ident in variant_arg_names.iter() {\n+                        if variant_arg_ident.name == ast_name {\n+                            continue;\n+                        }\n+                        let field_name = mc::NamedField(variant_arg_ident.name);\n+                        add_fragment_sibling_local(field_name);\n+                    }\n+                }\n+                mc::PositionalField(tuple_idx) => {\n+                    let variant_arg_types = &variant_info.args;\n+                    for (i, _variant_arg_ty) in variant_arg_types.iter().enumerate() {\n+                        if tuple_idx == i {\n+                            continue;\n+                        }\n+                        let field_name = mc::PositionalField(i);\n+                        add_fragment_sibling_local(field_name);\n+                    }\n+                }\n+            }\n+        }\n+\n+        ref sty_and_variant_info => {\n+            let msg = format!(\"type {} ({}) is not fragmentable\",\n+                              parent_ty.repr(tcx), sty_and_variant_info);\n+            let opt_span = origin_id.and_then(|id|tcx.map.opt_span(id));\n+            tcx.sess.opt_span_bug(opt_span, msg.as_slice())\n+        }\n+    }\n+}\n+\n+fn add_fragment_sibling_core<'tcx>(this: &MoveData<'tcx>,\n+                                   tcx: &ty::ctxt<'tcx>,\n+                                   gathered_fragments: &mut Vec<Fragment>,\n+                                   parent: Rc<LoanPath<'tcx>>,\n+                                   mc: mc::MutabilityCategory,\n+                                   new_field_name: mc::FieldName,\n+                                   origin_lp: &Rc<LoanPath<'tcx>>) -> MovePathIndex {\n+    /*!\n+     * Adds the single sibling `LpExtend(parent, new_field_name)`\n+     * of `origin_lp` (the original loan-path).\n+     */\n+    let opt_variant_did = match parent.kind {\n+        LpDowncast(_, variant_did) => Some(variant_did),\n+        LpVar(..) | LpUpvar(..) | LpExtend(..) => None,\n+    };\n+\n+    let loan_path_elem = LpInterior(mc::InteriorField(new_field_name));\n+    let new_lp_type = match new_field_name {\n+        mc::NamedField(ast_name) =>\n+            ty::named_element_ty(tcx, parent.to_type(), ast_name, opt_variant_did),\n+        mc::PositionalField(idx) =>\n+            ty::positional_element_ty(tcx, parent.to_type(), idx, opt_variant_did),\n+    };\n+    let new_lp_variant = LpExtend(parent, mc, loan_path_elem);\n+    let new_lp = LoanPath::new(new_lp_variant, new_lp_type.unwrap());\n+    debug!(\"add_fragment_sibling_core(new_lp={}, origin_lp={})\",\n+           new_lp.repr(tcx), origin_lp.repr(tcx));\n+    let mp = this.move_path(tcx, Rc::new(new_lp));\n+\n+    // Do not worry about checking for duplicates here; we will sort\n+    // and dedup after all are added.\n+    gathered_fragments.push(Just(mp));\n+\n+    mp\n+}"}, {"sha": "1d0b0558bb16c2ae94482dcd3938217734ebe06c", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c9a1c376fcf4d469742665a4be59cca68fc63ed7/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9a1c376fcf4d469742665a4be59cca68fc63ed7/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=c9a1c376fcf4d469742665a4be59cca68fc63ed7", "patch": "@@ -62,6 +62,37 @@ pub fn gather_move_from_expr<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     gather_move(bccx, move_data, move_error_collector, move_info);\n }\n \n+pub fn gather_match_variant<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n+                                      move_data: &MoveData<'tcx>,\n+                                      _move_error_collector: &MoveErrorCollector<'tcx>,\n+                                      move_pat: &ast::Pat,\n+                                      cmt: mc::cmt<'tcx>,\n+                                      mode: euv::MatchMode) {\n+    let tcx = bccx.tcx;\n+    debug!(\"gather_match_variant(move_pat={}, cmt={}, mode={})\",\n+           move_pat.id, cmt.repr(tcx), mode);\n+\n+    let opt_lp = opt_loan_path(&cmt);\n+    match opt_lp {\n+        Some(lp) => {\n+            match lp.kind {\n+                LpDowncast(ref base_lp, _) =>\n+                    move_data.add_variant_match(\n+                        tcx, lp.clone(), move_pat.id, base_lp.clone(), mode),\n+                _ => panic!(\"should only call gather_match_variant \\\n+                             for cat_downcast cmt\"),\n+            }\n+        }\n+        None => {\n+            // We get None when input to match is non-path (e.g.\n+            // temporary result like a function call). Since no\n+            // loan-path is being matched, no need to record a\n+            // downcast.\n+            return;\n+        }\n+    }\n+}\n+\n pub fn gather_move_from_pat<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                       move_data: &MoveData<'tcx>,\n                                       move_error_collector: &MoveErrorCollector<'tcx>,"}, {"sha": "088b62a12cf98ddad27e608d40dc4ecdba39176d", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c9a1c376fcf4d469742665a4be59cca68fc63ed7/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9a1c376fcf4d469742665a4be59cca68fc63ed7/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=c9a1c376fcf4d469742665a4be59cca68fc63ed7", "patch": "@@ -96,6 +96,14 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n                matched_pat.repr(self.tcx()),\n                cmt.repr(self.tcx()),\n                mode);\n+\n+        match cmt.cat {\n+            mc::cat_downcast(..) =>\n+                gather_moves::gather_match_variant(\n+                    self.bccx, &self.move_data, &self.move_error_collector,\n+                    matched_pat, cmt, mode),\n+            _ => {}\n+        }\n     }\n \n     fn consume_pat(&mut self,"}, {"sha": "45040cd7b102e93d18a7fda4c24805e40dd76d72", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 43, "deletions": 2, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/c9a1c376fcf4d469742665a4be59cca68fc63ed7/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9a1c376fcf4d469742665a4be59cca68fc63ed7/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=c9a1c376fcf4d469742665a4be59cca68fc63ed7", "patch": "@@ -143,6 +143,9 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n                        move_data:flowed_moves } =\n         build_borrowck_dataflow_data(this, fk, decl, &cfg, body, sp, id);\n \n+    move_data::fragments::instrument_move_fragments(&flowed_moves.move_data,\n+                                                    this.tcx, sp, id);\n+\n     check_loans::check_loans(this, &loan_dfcx, flowed_moves,\n                              all_loans.as_slice(), decl, body);\n \n@@ -322,8 +325,14 @@ impl<'tcx> LoanPath<'tcx> {\n         LoanPath { kind: kind, ty: ty }\n     }\n \n+    fn to_type(&self) -> ty::Ty<'tcx> { self.ty }\n }\n \n+// FIXME (pnkfelix): See discussion here\n+// https://github.com/pnkfelix/rust/commit/\n+//     b2b39e8700e37ad32b486b9a8409b50a8a53aa51#commitcomment-7892003\n+static DOWNCAST_PRINTED_OPERATOR : &'static str = \" as \";\n+\n #[deriving(PartialEq, Eq, Hash, Show)]\n pub enum LoanPathElem {\n     LpDeref(mc::PointerKind),    // `*LV` in doc.rs\n@@ -927,7 +936,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             LpDowncast(ref lp_base, variant_def_id) => {\n                 out.push('(');\n                 self.append_loan_path_to_string(&**lp_base, out);\n-                out.push_str(\"->\");\n+                out.push_str(DOWNCAST_PRINTED_OPERATOR);\n                 out.push_str(ty::item_path_str(self.tcx, variant_def_id).as_slice());\n                 out.push(')');\n             }\n@@ -1051,7 +1060,7 @@ impl<'tcx> Repr<'tcx> for LoanPath<'tcx> {\n                 } else {\n                     variant_def_id.repr(tcx)\n                 };\n-                format!(\"({}->{})\", lp.repr(tcx), variant_str)\n+                format!(\"({}{}{})\", lp.repr(tcx), DOWNCAST_PRINTED_OPERATOR, variant_str)\n             }\n \n             LpExtend(ref lp, _, LpDeref(_)) => {\n@@ -1064,3 +1073,35 @@ impl<'tcx> Repr<'tcx> for LoanPath<'tcx> {\n         }\n     }\n }\n+\n+impl<'tcx> UserString<'tcx> for LoanPath<'tcx> {\n+    fn user_string(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+        match self.kind {\n+            LpVar(id) => {\n+                format!(\"$({})\", tcx.map.node_to_user_string(id))\n+            }\n+\n+            LpUpvar(ty::UpvarId{ var_id, closure_expr_id: _ }) => {\n+                let s = tcx.map.node_to_user_string(var_id);\n+                format!(\"$({} captured by closure)\", s)\n+            }\n+\n+            LpDowncast(ref lp, variant_def_id) => {\n+                let variant_str = if variant_def_id.krate == ast::LOCAL_CRATE {\n+                    ty::item_path_str(tcx, variant_def_id)\n+                } else {\n+                    variant_def_id.repr(tcx)\n+                };\n+                format!(\"({}{}{})\", lp.user_string(tcx), DOWNCAST_PRINTED_OPERATOR, variant_str)\n+            }\n+\n+            LpExtend(ref lp, _, LpDeref(_)) => {\n+                format!(\"{}.*\", lp.user_string(tcx))\n+            }\n+\n+            LpExtend(ref lp, _, LpInterior(ref interior)) => {\n+                format!(\"{}.{}\", lp.user_string(tcx), interior.repr(tcx))\n+            }\n+        }\n+    }\n+}"}, {"sha": "dc9516ccc5da2d352c9b3938b9782ae5dd29122e", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 110, "deletions": 6, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/c9a1c376fcf4d469742665a4be59cca68fc63ed7/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9a1c376fcf4d469742665a4be59cca68fc63ed7/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=c9a1c376fcf4d469742665a4be59cca68fc63ed7", "patch": "@@ -11,7 +11,7 @@\n /*!\n \n Data structures used for tracking moves. Please see the extensive\n-comments in the section \"Moves and initialization\" and in `doc.rs`.\n+comments in the section \"Moves and initialization\" in `doc.rs`.\n \n */\n \n@@ -36,6 +36,9 @@ use syntax::codemap::Span;\n use util::nodemap::{FnvHashMap, NodeSet};\n use util::ppaux::Repr;\n \n+#[path=\"fragments.rs\"]\n+pub mod fragments;\n+\n pub struct MoveData<'tcx> {\n     /// Move paths. See section \"Move paths\" in `doc.rs`.\n     pub paths: RefCell<Vec<MovePath<'tcx>>>,\n@@ -56,8 +59,15 @@ pub struct MoveData<'tcx> {\n     /// kill move bits.\n     pub path_assignments: RefCell<Vec<Assignment>>,\n \n+    /// Enum variant matched within a pattern on some match arm, like\n+    /// `SomeStruct{ f: Variant1(x, y) } => ...`\n+    pub variant_matches: RefCell<Vec<VariantMatch>>,\n+\n     /// Assignments to a variable or path, like `x = foo`, but not `x += foo`.\n     pub assignee_ids: RefCell<NodeSet>,\n+\n+    /// Path-fragments from moves in to or out of parts of structured data.\n+    pub fragments: RefCell<fragments::FragmentSets>,\n }\n \n pub struct FlowedMoveData<'a, 'tcx: 'a> {\n@@ -72,7 +82,7 @@ pub struct FlowedMoveData<'a, 'tcx: 'a> {\n }\n \n /// Index into `MoveData.paths`, used like a pointer\n-#[deriving(PartialEq, Show)]\n+#[deriving(PartialEq, Eq, PartialOrd, Ord, Show)]\n pub struct MovePathIndex(uint);\n \n impl MovePathIndex {\n@@ -157,6 +167,20 @@ pub struct Assignment {\n     pub span: Span,\n }\n \n+pub struct VariantMatch {\n+    /// downcast to the variant.\n+    pub path: MovePathIndex,\n+\n+    /// path being downcast to the variant.\n+    pub base_path: MovePathIndex,\n+\n+    /// id where variant's pattern occurs\n+    pub id: ast::NodeId,\n+\n+    /// says if variant established by move (and why), by copy, or by borrow.\n+    pub mode: euv::MatchMode\n+}\n+\n #[deriving(Clone)]\n pub struct MoveDataFlowOperator;\n \n@@ -184,6 +208,37 @@ fn loan_path_is_precise(loan_path: &LoanPath) -> bool {\n     }\n }\n \n+impl Move {\n+    pub fn to_string<'tcx>(&self, move_data: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) -> String {\n+        format!(\"Move{} path: {}, id: {}, kind: {} {}\",\n+                \"{\",\n+                move_data.path_loan_path(self.path).repr(tcx),\n+                self.id,\n+                self.kind,\n+                \"}\")\n+    }\n+}\n+\n+impl Assignment {\n+    pub fn to_string<'tcx>(&self, move_data: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) -> String {\n+        format!(\"Assignment{} path: {}, id: {} {}\",\n+                \"{\",\n+                move_data.path_loan_path(self.path).repr(tcx),\n+                self.id,\n+                \"}\")\n+    }\n+}\n+\n+impl VariantMatch {\n+    pub fn to_string<'tcx>(&self, move_data: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) -> String {\n+        format!(\"VariantMatch{} path: {}, id: {} {}\",\n+                \"{\",\n+                move_data.path_loan_path(self.path).repr(tcx),\n+                self.id,\n+                \"}\")\n+    }\n+}\n+\n impl<'tcx> MoveData<'tcx> {\n     pub fn new() -> MoveData<'tcx> {\n         MoveData {\n@@ -192,7 +247,9 @@ impl<'tcx> MoveData<'tcx> {\n             moves: RefCell::new(Vec::new()),\n             path_assignments: RefCell::new(Vec::new()),\n             var_assignments: RefCell::new(Vec::new()),\n+            variant_matches: RefCell::new(Vec::new()),\n             assignee_ids: RefCell::new(NodeSet::new()),\n+            fragments: RefCell::new(fragments::FragmentSets::new()),\n         }\n     }\n \n@@ -208,6 +265,8 @@ impl<'tcx> MoveData<'tcx> {\n         (*self.paths.borrow())[index.get()].first_move\n     }\n \n+    /// Returns the index of first child, or `InvalidMovePathIndex` if\n+    /// `index` is leaf.\n     fn path_first_child(&self, index: MovePathIndex) -> MovePathIndex {\n         (*self.paths.borrow())[index.get()].first_child\n     }\n@@ -353,9 +412,11 @@ impl<'tcx> MoveData<'tcx> {\n                id,\n                kind);\n \n-        let path_index = self.move_path(tcx, lp);\n+        let path_index = self.move_path(tcx, lp.clone());\n         let move_index = MoveIndex(self.moves.borrow().len());\n \n+        self.fragments.borrow_mut().add_move(path_index);\n+\n         let next_move = self.path_first_move(path_index);\n         self.set_path_first_move(path_index, move_index);\n \n@@ -384,6 +445,8 @@ impl<'tcx> MoveData<'tcx> {\n \n         let path_index = self.move_path(tcx, lp.clone());\n \n+        self.fragments.borrow_mut().add_assignment(path_index);\n+\n         match mode {\n             euv::Init | euv::JustWrite => {\n                 self.assignee_ids.borrow_mut().insert(assignee_id);\n@@ -410,6 +473,40 @@ impl<'tcx> MoveData<'tcx> {\n         }\n     }\n \n+    pub fn add_variant_match(&self,\n+                             tcx: &ty::ctxt<'tcx>,\n+                             lp: Rc<LoanPath<'tcx>>,\n+                             pattern_id: ast::NodeId,\n+                             base_lp: Rc<LoanPath<'tcx>>,\n+                             mode: euv::MatchMode) {\n+        /*!\n+         * Adds a new record for a match of `base_lp`, downcast to\n+         * variant `lp`, that occurs at location `pattern_id`.  (One\n+         * should be able to recover the span info from the\n+         * `pattern_id` and the ast_map, I think.)\n+         */\n+        debug!(\"add_variant_match(lp={}, pattern_id={})\",\n+               lp.repr(tcx), pattern_id);\n+\n+        let path_index = self.move_path(tcx, lp.clone());\n+        let base_path_index = self.move_path(tcx, base_lp.clone());\n+\n+        self.fragments.borrow_mut().add_assignment(path_index);\n+\n+        let variant_match = VariantMatch {\n+            path: path_index,\n+            base_path: base_path_index,\n+            id: pattern_id,\n+            mode: mode,\n+        };\n+\n+        self.variant_matches.borrow_mut().push(variant_match);\n+    }\n+\n+    fn fixup_fragment_sets(&self, tcx: &ty::ctxt<'tcx>) {\n+        fragments::fixup_fragment_sets(self, tcx)\n+    }\n+\n     fn add_gen_kills(&self,\n                      tcx: &ty::ctxt<'tcx>,\n                      dfcx_moves: &mut MoveDataFlow,\n@@ -435,8 +532,8 @@ impl<'tcx> MoveData<'tcx> {\n             self.kill_moves(assignment.path, assignment.id, dfcx_moves);\n         }\n \n-        // Kill all moves related to a variable `x` when it goes out\n-        // of scope:\n+        // Kill all moves related to a variable `x` when\n+        // it goes out of scope:\n         for path in self.paths.borrow().iter() {\n             match path.loan_path.kind {\n                 LpVar(..) | LpUpvar(..) | LpDowncast(..) => {\n@@ -556,9 +653,16 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n                                  AssignDataFlowOperator,\n                                  id_range,\n                                  move_data.var_assignments.borrow().len());\n-        move_data.add_gen_kills(tcx, &mut dfcx_moves, &mut dfcx_assign);\n+\n+        move_data.fixup_fragment_sets(tcx);\n+\n+        move_data.add_gen_kills(tcx,\n+                                &mut dfcx_moves,\n+                                &mut dfcx_assign);\n+\n         dfcx_moves.add_kills_from_flow_exits(cfg);\n         dfcx_assign.add_kills_from_flow_exits(cfg);\n+\n         dfcx_moves.propagate(cfg, body);\n         dfcx_assign.propagate(cfg, body);\n "}, {"sha": "98b958749d55e64a44a066221cb84a1b33c03771", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/c9a1c376fcf4d469742665a4be59cca68fc63ed7/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9a1c376fcf4d469742665a4be59cca68fc63ed7/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=c9a1c376fcf4d469742665a4be59cca68fc63ed7", "patch": "@@ -3442,6 +3442,62 @@ pub fn array_element_ty<'tcx>(ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n     }\n }\n \n+/// Returns the type of element at index `i` in tuple or tuple-like type `t`.\n+/// For an enum `t`, `variant` is None only if `t` is a univariant enum.\n+pub fn positional_element_ty<'tcx>(cx: &ctxt<'tcx>,\n+                                   ty: Ty<'tcx>,\n+                                   i: uint,\n+                                   variant: Option<ast::DefId>) -> Option<Ty<'tcx>> {\n+\n+    match (&ty.sty, variant) {\n+        (&ty_tup(ref v), None) => v.as_slice().get(i).map(|&t| t),\n+\n+\n+        (&ty_struct(def_id, ref substs), None) => lookup_struct_fields(cx, def_id)\n+            .as_slice().get(i)\n+            .map(|&t|lookup_item_type(cx, t.id).ty.subst(cx, substs)),\n+\n+        (&ty_enum(def_id, ref substs), Some(variant_def_id)) => {\n+            let variant_info = enum_variant_with_id(cx, def_id, variant_def_id);\n+            variant_info.args.as_slice().get(i).map(|t|t.subst(cx, substs))\n+        }\n+\n+        (&ty_enum(def_id, ref substs), None) => {\n+            assert!(enum_is_univariant(cx, def_id));\n+            let enum_variants = enum_variants(cx, def_id);\n+            let variant_info = &(*enum_variants)[0];\n+            variant_info.args.as_slice().get(i).map(|t|t.subst(cx, substs))\n+        }\n+\n+        _ => None\n+    }\n+}\n+\n+/// Returns the type of element at field `n` in struct or struct-like type `t`.\n+/// For an enum `t`, `variant` must be some def id.\n+pub fn named_element_ty<'tcx>(cx: &ctxt<'tcx>,\n+                              ty: Ty<'tcx>,\n+                              n: ast::Name,\n+                              variant: Option<ast::DefId>) -> Option<Ty<'tcx>> {\n+\n+    match (&ty.sty, variant) {\n+        (&ty_struct(def_id, ref substs), None) => {\n+            let r = lookup_struct_fields(cx, def_id);\n+            r.iter().find(|f| f.name == n)\n+                .map(|&f| lookup_field_type(cx, def_id, f.id, substs))\n+        }\n+        (&ty_enum(def_id, ref substs), Some(variant_def_id)) => {\n+            let variant_info = enum_variant_with_id(cx, def_id, variant_def_id);\n+            variant_info.arg_names.as_ref()\n+                .expect(\"must have struct enum variant if accessing a named fields\")\n+                .iter().zip(variant_info.args.iter())\n+                .find(|&(ident, _)| ident.name == n)\n+                .map(|(_ident, arg_t)| arg_t.subst(cx, substs))\n+        }\n+        _ => None\n+    }\n+}\n+\n pub fn node_id_to_trait_ref<'tcx>(cx: &ctxt<'tcx>, id: ast::NodeId)\n                                   -> Rc<ty::TraitRef<'tcx>> {\n     match cx.trait_refs.borrow().get(&id) {"}, {"sha": "82cf8f28e3dfe8753c08dee1c92492c9c9aa07bd", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c9a1c376fcf4d469742665a4be59cca68fc63ed7/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9a1c376fcf4d469742665a4be59cca68fc63ed7/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=c9a1c376fcf4d469742665a4be59cca68fc63ed7", "patch": "@@ -208,6 +208,7 @@ debugging_opts!(\n         AST_JSON_NOEXPAND,\n         LS,\n         SAVE_ANALYSIS,\n+        PRINT_MOVE_FRAGMENTS,\n         FLOWGRAPH_PRINT_LOANS,\n         FLOWGRAPH_PRINT_MOVES,\n         FLOWGRAPH_PRINT_ASSIGNS,\n@@ -246,6 +247,8 @@ pub fn debugging_opts_map() -> Vec<(&'static str, &'static str, u64)> {\n      (\"ls\", \"List the symbols defined by a library crate\", LS),\n      (\"save-analysis\", \"Write syntax and type analysis information \\\n                         in addition to normal output\", SAVE_ANALYSIS),\n+     (\"print-move-fragments\", \"Print out move-fragment data for every fn\",\n+      PRINT_MOVE_FRAGMENTS),\n      (\"flowgraph-print-loans\", \"Include loan analysis data in \\\n                        --pretty flowgraph output\", FLOWGRAPH_PRINT_LOANS),\n      (\"flowgraph-print-moves\", \"Include move analysis data in \\"}, {"sha": "89f6cda64d9d3f482e7e3370b0e04fdfcb0a8281", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c9a1c376fcf4d469742665a4be59cca68fc63ed7/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9a1c376fcf4d469742665a4be59cca68fc63ed7/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=c9a1c376fcf4d469742665a4be59cca68fc63ed7", "patch": "@@ -90,6 +90,12 @@ impl Session {\n     pub fn warn(&self, msg: &str) {\n         self.diagnostic().handler().warn(msg)\n     }\n+    pub fn opt_span_warn(&self, opt_sp: Option<Span>, msg: &str) {\n+        match opt_sp {\n+            Some(sp) => self.span_warn(sp, msg),\n+            None => self.warn(msg),\n+        }\n+    }\n     pub fn span_note(&self, sp: Span, msg: &str) {\n         self.diagnostic().span_note(sp, msg)\n     }\n@@ -108,6 +114,12 @@ impl Session {\n     pub fn help(&self, msg: &str) {\n         self.diagnostic().handler().note(msg)\n     }\n+    pub fn opt_span_bug(&self, opt_sp: Option<Span>, msg: &str) -> ! {\n+        match opt_sp {\n+            Some(sp) => self.span_bug(sp, msg),\n+            None => self.bug(msg),\n+        }\n+    }\n     pub fn span_bug(&self, sp: Span, msg: &str) -> ! {\n         self.diagnostic().span_bug(sp, msg)\n     }"}]}