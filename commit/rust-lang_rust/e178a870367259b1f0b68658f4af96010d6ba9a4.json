{"sha": "e178a870367259b1f0b68658f4af96010d6ba9a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxNzhhODcwMzY3MjU5YjFmMGI2ODY1OGY0YWY5NjAxMGQ2YmE5YTQ=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-08-30T20:27:07Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-08-30T20:27:07Z"}, "message": "Expand documentation for the `lattice` module", "tree": {"sha": "dd03be2055d4dfd7ccae8c5092aaef0cb1b3c3fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd03be2055d4dfd7ccae8c5092aaef0cb1b3c3fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e178a870367259b1f0b68658f4af96010d6ba9a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e178a870367259b1f0b68658f4af96010d6ba9a4", "html_url": "https://github.com/rust-lang/rust/commit/e178a870367259b1f0b68658f4af96010d6ba9a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e178a870367259b1f0b68658f4af96010d6ba9a4/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c03eba2d0833a21205b00e4b71e920df709a2658", "url": "https://api.github.com/repos/rust-lang/rust/commits/c03eba2d0833a21205b00e4b71e920df709a2658", "html_url": "https://github.com/rust-lang/rust/commit/c03eba2d0833a21205b00e4b71e920df709a2658"}], "stats": {"total": 68, "additions": 51, "deletions": 17}, "files": [{"sha": "e7ef9267db5e5ed9e74a12f5ad849f86ae239a76", "filename": "compiler/rustc_mir/src/dataflow/framework/lattice.rs", "status": "modified", "additions": 51, "deletions": 17, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/e178a870367259b1f0b68658f4af96010d6ba9a4/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e178a870367259b1f0b68658f4af96010d6ba9a4/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fframework%2Flattice.rs?ref=e178a870367259b1f0b68658f4af96010d6ba9a4", "patch": "@@ -1,18 +1,42 @@\n //! Traits used to represent [lattices] for use as the domain of a dataflow analysis.\n //!\n-//! ## Implementation Notes\n+//! # Overview\n //!\n-//! Given that they represent partially ordered sets, you may be surprised that [`MeetSemiLattice`]\n-//! and [`JoinSemiLattice`] do not have [`PartialOrd`][std::cmp::PartialOrd] as a supertrait. This\n-//! is because most standard library types use lexicographic ordering instead of [set inclusion]\n-//! for their `PartialOrd` impl. Since we do not actually need to compare lattice elements to run a\n-//! dataflow analysis, there's no need for a hypothetical `SetInclusion` newtype with a custom\n-//! `PartialOrd` impl.  The only benefit would be the ability to check (in debug mode) that the\n-//! least upper (or greatest lower) bound returned by the lattice join (or meet) operator was in\n-//! fact greater (or lower) than the inputs.\n+//! The most common lattice is a powerset of some set `S`, ordered by [set inclusion]. The [Hasse\n+//! diagram] for the powerset of a set with two elements (`X` and `Y`) is shown below. Note that\n+//! distinct elements at the same height in a Hasse diagram (e.g. `{X}` and `{Y}`) are\n+//! *incomparable*, not equal.\n+//!\n+//! ```text\n+//!      {X, Y}    <- top\n+//!       /  \\\n+//!    {X}    {Y}\n+//!       \\  /\n+//!        {}      <- bottom\n+//!\n+//! ```\n+//!\n+//! The defining characteristic of a lattice\u2014the one that differentiates it from a [partially\n+//! ordered set][poset]\u2014is the existence of a *unique* least upper and greatest lower bound for\n+//! every pair of elements. The lattice join operator (`\u2228`) returns the least upper bound, and the\n+//! lattice meet operator (`\u2227`) returns the greatest lower bound. Types that implement one operator\n+//! but not the other are known as semilattices. Dataflow analysis only uses the join operator and\n+//! will work with any join-semilattice, but both should be specified when possible.\n+//!\n+//! ## `PartialOrd`\n+//!\n+//! Given that they represent partially ordered sets, you may be surprised that [`JoinSemiLattice`]\n+//! and [`MeetSemiLattice`] do not have [`PartialOrd`][std::cmp::PartialOrd] as a supertrait. This\n+//! is because most standard library types use lexicographic ordering instead of set inclusion for\n+//! their `PartialOrd` impl. Since we do not actually need to compare lattice elements to run a\n+//! dataflow analysis, there's no need for a newtype wrapper with a custom `PartialOrd` impl. The\n+//! only benefit would be the ability to check that the least upper (or greatest lower) bound\n+//! returned by the lattice join (or meet) operator was in fact greater (or lower) than the inputs.\n //!\n //! [lattices]: https://en.wikipedia.org/wiki/Lattice_(order)\n //! [set inclusion]: https://en.wikipedia.org/wiki/Subset\n+//! [Hasse diagram]: https://en.wikipedia.org/wiki/Hasse_diagram\n+//! [poset]: https://en.wikipedia.org/wiki/Partially_ordered_set\n \n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::{Idx, IndexVec};\n@@ -47,7 +71,13 @@ pub trait MeetSemiLattice: Eq {\n     fn meet(&mut self, other: &Self) -> bool;\n }\n \n-/// A `bool` is a \"two-point\" lattice with `true` as the top element and `false` as the bottom.\n+/// A `bool` is a \"two-point\" lattice with `true` as the top element and `false` as the bottom:\n+///\n+/// ```text\n+///      true\n+///        |\n+///      false\n+/// ```\n impl JoinSemiLattice for bool {\n     fn join(&mut self, other: &Self) -> bool {\n         if let (false, true) = (*self, *other) {\n@@ -70,8 +100,11 @@ impl MeetSemiLattice for bool {\n     }\n }\n \n-/// A tuple or list of lattices is itself a lattice whose least upper bound is the concatenation of\n-/// the least upper bounds of each element of the tuple or list.\n+/// A tuple (or list) of lattices is itself a lattice whose least upper bound is the concatenation\n+/// of the least upper bounds of each element of the tuple (or list).\n+///\n+/// In other words:\n+///     (A\u2080, A\u2081, ..., A\u2099) \u2228 (B\u2080, B\u2081, ..., B\u2099) = (A\u2080\u2228B\u2080, A\u2081\u2228B\u2081, ..., A\u2099\u2228B\u2099)\n impl<I: Idx, T: JoinSemiLattice> JoinSemiLattice for IndexVec<I, T> {\n     fn join(&mut self, other: &Self) -> bool {\n         assert_eq!(self.len(), other.len());\n@@ -96,9 +129,9 @@ impl<I: Idx, T: MeetSemiLattice> MeetSemiLattice for IndexVec<I, T> {\n     }\n }\n \n-/// A `BitSet` is an efficent way to store a tuple of \"two-point\" lattices. Equivalently, it is the\n-/// lattice corresponding to the powerset of the set of all possibe values of the index type `T`\n-/// ordered by inclusion.\n+/// A `BitSet` represents the lattice formed by the powerset of all possible values of\n+/// the index type `T` ordered by inclusion. Equivalently, it is a tuple of \"two-point\" lattices,\n+/// one for each possible value of `T`.\n impl<T: Idx> JoinSemiLattice for BitSet<T> {\n     fn join(&mut self, other: &Self) -> bool {\n         self.union(other)\n@@ -146,8 +179,7 @@ impl<T: JoinSemiLattice> MeetSemiLattice for Dual<T> {\n }\n \n /// Extends a type `T` with top and bottom elements to make it a partially ordered set in which no\n-/// value of `T` is comparable with any other. A flat set has the following [Hasse\n-/// diagram](https://en.wikipedia.org/wiki/Hasse_diagram):\n+/// value of `T` is comparable with any other. A flat set has the following [Hasse diagram]:\n ///\n /// ```text\n ///         top\n@@ -156,6 +188,8 @@ impl<T: JoinSemiLattice> MeetSemiLattice for Dual<T> {\n ///       \\ \\  / /\n ///        bottom\n /// ```\n+///\n+/// [Hasse diagram]: https://en.wikipedia.org/wiki/Hasse_diagram\n #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n pub enum FlatSet<T> {\n     Bottom,"}]}