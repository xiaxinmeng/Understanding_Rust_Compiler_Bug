{"sha": "4a3acfd9371f59368108ad5e7be28f4268ed862b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhM2FjZmQ5MzcxZjU5MzY4MTA4YWQ1ZTdiZTI4ZjQyNjhlZDg2MmI=", "commit": {"author": {"name": "ggomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-05-11T12:33:14Z"}, "committer": {"name": "ggomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-05-11T15:01:15Z"}, "message": "Update to eddyb's PR", "tree": {"sha": "d801942c4c6a41fefb68fef2ab46a16f658fd36c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d801942c4c6a41fefb68fef2ab46a16f658fd36c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a3acfd9371f59368108ad5e7be28f4268ed862b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a3acfd9371f59368108ad5e7be28f4268ed862b", "html_url": "https://github.com/rust-lang/rust/commit/4a3acfd9371f59368108ad5e7be28f4268ed862b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a3acfd9371f59368108ad5e7be28f4268ed862b/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e6c0ff65edef9d31593bda378693542906376021", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6c0ff65edef9d31593bda378693542906376021", "html_url": "https://github.com/rust-lang/rust/commit/e6c0ff65edef9d31593bda378693542906376021"}], "stats": {"total": 328, "additions": 129, "deletions": 199}, "files": [{"sha": "508261ddfdd6c6d85105719e4cc14a34388843b5", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 129, "deletions": 199, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/4a3acfd9371f59368108ad5e7be28f4268ed862b/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a3acfd9371f59368108ad5e7be28f4268ed862b/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=4a3acfd9371f59368108ad5e7be28f4268ed862b", "patch": "@@ -26,7 +26,7 @@ use super::{\n \n use fmt_macros::{Parser, Piece, Position};\n use hir::def_id::DefId;\n-use infer::{self, InferCtxt, TypeOrigin};\n+use infer::{InferCtxt, TypeOrigin};\n use ty::{self, ToPredicate, ToPolyTraitRef, TraitRef, Ty, TyCtxt, TypeFoldable, TypeVariants};\n use ty::fast_reject;\n use ty::fold::TypeFolder;\n@@ -37,7 +37,6 @@ use std::cmp;\n use std::fmt;\n use syntax::ast;\n use syntax::attr::{AttributeMethods, AttrMetaMethods};\n-use syntax::ast;\n use syntax::codemap::Span;\n use syntax::errors::DiagnosticBuilder;\n \n@@ -62,26 +61,6 @@ impl<'a, 'gcx, 'tcx> TraitErrorKey<'tcx> {\n     }\n }\n \n-fn impl_substs<'a, 'tcx>(fcx: &InferCtxt<'a, 'tcx>,\n-                         did: DefId,\n-                         obligation: PredicateObligation<'tcx>)\n-                         -> subst::Substs<'tcx> {\n-    let tcx = fcx.tcx;\n-\n-    let ity = tcx.lookup_item_type(did);\n-    let (tps, rps, _) =\n-        (ity.generics.types.get_slice(subst::TypeSpace),\n-         ity.generics.regions.get_slice(subst::TypeSpace),\n-         ity.ty);\n-\n-    let rps = fcx.region_vars_for_defs(obligation.cause.span, rps);\n-    let mut substs = subst::Substs::new(\n-        subst::VecPerParamSpace::empty(),\n-        subst::VecPerParamSpace::new(rps, Vec::new(), Vec::new()));\n-    fcx.type_vars_for_defs(obligation.cause.span, subst::ParamSpace::TypeSpace, &mut substs, tps);\n-    substs\n-}\n-\n // Enum used to differentiate the \"big\" and \"little\" weights.\n enum Weight {\n     Coarse,\n@@ -204,141 +183,6 @@ fn get_best_matching_type<'tcx>(imps: &[(DefId, subst::Substs<'tcx>)],\n     }\n }\n \n-fn get_current_failing_impl<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                      trait_ref: &TraitRef<'tcx>,\n-                                      obligation: &PredicateObligation<'tcx>)\n-                                     -> Option<(DefId, subst::Substs<'tcx>)> {\n-    let simp = fast_reject::simplify_type(infcx.tcx,\n-                                          trait_ref.self_ty(),\n-                                          true);\n-    let trait_def = infcx.tcx.lookup_trait_def(trait_ref.def_id);\n-\n-    match simp {\n-        Some(_) => {\n-            let mut matching_impls = Vec::new();\n-            trait_def.for_each_impl(infcx.tcx, |def_id| {\n-                let imp = infcx.tcx.impl_trait_ref(def_id).unwrap();\n-                let substs = impl_substs(infcx, def_id, obligation.clone());\n-                let imp = imp.subst(infcx.tcx, &substs);\n-\n-                if infer::mk_eqty(infcx, true,\n-                                  TypeOrigin::Misc(obligation.cause.span),\n-                                  trait_ref.self_ty(),\n-                                  imp.self_ty()).is_ok() {\n-                    matching_impls.push((def_id, imp.substs.clone()));\n-                }\n-            });\n-            if matching_impls.len() == 0 {\n-                None\n-            } else if matching_impls.len() == 1 {\n-                Some(matching_impls[0].clone())\n-            } else {\n-                let end = trait_ref.input_types().len() - 1;\n-                // we need to determine which type is the good one!\n-                Some(matching_impls[get_best_matching_type(&matching_impls,\n-                                                           &trait_ref.input_types()[0..end])]\n-                                                          .clone())\n-            }\n-        },\n-        None => None,\n-    }\n-}\n-\n-fn find_attr<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                       def_id: DefId,\n-                       attr_name: &str)\n-                      -> Option<ast::Attribute> {\n-    for item in infcx.tcx.get_attrs(def_id).iter() {\n-        if item.check_name(attr_name) {\n-            return Some(item.clone());\n-        }\n-    }\n-    None\n-}\n-\n-fn on_unimplemented_note<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                   trait_ref: ty::PolyTraitRef<'tcx>,\n-                                   obligation: &PredicateObligation<'tcx>) -> Option<String> {\n-    let trait_ref = trait_ref.skip_binder();\n-    let mut report = None;\n-    let def_id = match get_current_failing_impl(infcx, trait_ref, obligation) {\n-        Some((def_id, _)) => {\n-            if let Some(_) = find_attr(infcx, def_id, \"rustc_on_unimplemented\") {\n-                def_id\n-            } else {\n-                trait_ref.def_id\n-            }\n-        },\n-        None => trait_ref.def_id,\n-    };\n-    let span = obligation.cause.span;\n-    let mut report = None;\n-\n-    for item in infcx.tcx.get_attrs(def_id).iter() {\n-        if item.check_name(\"rustc_on_unimplemented\") {\n-            let err_sp = item.meta().span.substitute_dummy(span);\n-            let def = infcx.tcx.lookup_trait_def(trait_ref.def_id);\n-            let trait_str = def.trait_ref.to_string();\n-            if let Some(ref istring) = item.value_str() {\n-                let mut generic_map = def.generics.types.iter_enumerated()\n-                                         .map(|(param, i, gen)| {\n-                                               (gen.name.as_str().to_string(),\n-                                                trait_ref.substs.types.get(param, i)\n-                                                         .to_string())\n-                                              }).collect::<FnvHashMap<String, String>>();\n-                generic_map.insert(\"Self\".to_string(),\n-                                   trait_ref.self_ty().to_string());\n-                let parser = Parser::new(&istring);\n-                let mut errored = false;\n-                let err: String = parser.filter_map(|p| {\n-                    match p {\n-                        Piece::String(s) => Some(s),\n-                        Piece::NextArgument(a) => match a.position {\n-                            Position::ArgumentNamed(s) => match generic_map.get(s) {\n-                                Some(val) => Some(val),\n-                                None => {\n-                                    span_err!(infcx.tcx.sess, err_sp, E0272,\n-                                              \"the #[rustc_on_unimplemented] \\\n-                                               attribute on \\\n-                                               trait definition for {} refers to \\\n-                                               non-existent type parameter {}\",\n-                                              trait_str, s);\n-                                    errored = true;\n-                                    None\n-                                }\n-                            },\n-                            _ => {\n-                                span_err!(infcx.tcx.sess, err_sp, E0273,\n-                                          \"the #[rustc_on_unimplemented] \\\n-                                           attribute on \\\n-                                           trait definition for {} must have named \\\n-                                           format arguments, \\\n-                                           eg `#[rustc_on_unimplemented = \\\n-                                           \\\"foo {{T}}\\\"]`\",\n-                                          trait_str);\n-                                errored = true;\n-                                None\n-                            }\n-                        }\n-                    }\n-                }).collect();\n-                // Report only if the format string checks out\n-                if !errored {\n-                    report = Some(err);\n-                }\n-            } else {\n-                span_err!(infcx.tcx.sess, err_sp, E0274,\n-                          \"the #[rustc_on_unimplemented] attribute on \\\n-                           trait definition for {} must have a value, \\\n-                           eg `#[rustc_on_unimplemented = \\\"foo\\\"]`\",\n-                          trait_str);\n-            }\n-            break;\n-        }\n-    }\n-    report\n-}\n-\n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn report_fulfillment_errors(&self, errors: &Vec<FulfillmentError<'tcx>>) {\n         for error in errors {\n@@ -405,16 +249,101 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn impl_substs(&self,\n+                   did: DefId,\n+                   obligation: PredicateObligation<'tcx>)\n+                   -> subst::Substs<'tcx> {\n+        let tcx = self.tcx;\n+\n+        let ity = tcx.lookup_item_type(did);\n+        let (tps, rps, _) =\n+            (ity.generics.types.get_slice(subst::TypeSpace),\n+             ity.generics.regions.get_slice(subst::TypeSpace),\n+             ity.ty);\n+\n+        let rps = self.region_vars_for_defs(obligation.cause.span, rps);\n+        let mut substs = subst::Substs::new(\n+            subst::VecPerParamSpace::empty(),\n+            subst::VecPerParamSpace::new(rps, Vec::new(), Vec::new()));\n+        self.type_vars_for_defs(obligation.cause.span,\n+                                subst::ParamSpace::TypeSpace,\n+                                &mut substs,\n+                                tps);\n+        substs\n+    }\n+\n+    fn get_current_failing_impl(&self,\n+                                trait_ref: &TraitRef<'tcx>,\n+                                obligation: &PredicateObligation<'tcx>)\n+                                -> Option<(DefId, subst::Substs<'tcx>)> {\n+        let simp = fast_reject::simplify_type(self.tcx,\n+                                              trait_ref.self_ty(),\n+                                              true);\n+        let trait_def = self.tcx.lookup_trait_def(trait_ref.def_id);\n+\n+        match simp {\n+            Some(_) => {\n+                let mut matching_impls = Vec::new();\n+                trait_def.for_each_impl(self.tcx, |def_id| {\n+                    let imp = self.tcx.impl_trait_ref(def_id).unwrap();\n+                    let substs = self.impl_substs(def_id, obligation.clone());\n+                    let imp = imp.subst(self.tcx, &substs);\n+\n+                    if self.eq_types(true,\n+                                      TypeOrigin::Misc(obligation.cause.span),\n+                                      trait_ref.self_ty(),\n+                                      imp.self_ty()).is_ok() {\n+                        matching_impls.push((def_id, imp.substs.clone()));\n+                    }\n+                });\n+                if matching_impls.len() == 0 {\n+                    None\n+                } else if matching_impls.len() == 1 {\n+                    Some(matching_impls[0].clone())\n+                } else {\n+                    let end = trait_ref.input_types().len() - 1;\n+                    // we need to determine which type is the good one!\n+                    Some(matching_impls[get_best_matching_type(&matching_impls,\n+                                                               &trait_ref.input_types()[0..end])]\n+                                                              .clone())\n+                }\n+            },\n+            None => None,\n+        }\n+    }\n+\n+    fn find_attr(&self,\n+                 def_id: DefId,\n+                 attr_name: &str)\n+                 -> Option<ast::Attribute> {\n+        for item in self.tcx.get_attrs(def_id).iter() {\n+            if item.check_name(attr_name) {\n+                return Some(item.clone());\n+            }\n+        }\n+        None\n+    }\n+\n     fn on_unimplemented_note(&self,\n                              trait_ref: ty::PolyTraitRef<'tcx>,\n-                             span: Span) -> Option<String> {\n+                             obligation: &PredicateObligation<'tcx>) -> Option<String> {\n         let trait_ref = trait_ref.skip_binder();\n-        let def_id = trait_ref.def_id;\n+        let def_id = match self.get_current_failing_impl(trait_ref, obligation) {\n+            Some((def_id, _)) => {\n+                if let Some(_) = self.find_attr(def_id, \"rustc_on_unimplemented\") {\n+                    def_id\n+                } else {\n+                    trait_ref.def_id\n+                }\n+            },\n+            None => trait_ref.def_id,\n+        };\n+        let span = obligation.cause.span;\n         let mut report = None;\n         for item in self.tcx.get_attrs(def_id).iter() {\n             if item.check_name(\"rustc_on_unimplemented\") {\n                 let err_sp = item.meta().span.substitute_dummy(span);\n-                let def = self.tcx.lookup_trait_def(def_id);\n+                let def = self.tcx.lookup_trait_def(trait_ref.def_id);\n                 let trait_str = def.trait_ref.to_string();\n                 if let Some(ref istring) = item.value_str() {\n                     let mut generic_map = def.generics.types.iter_enumerated()\n@@ -474,6 +403,37 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         report\n     }\n \n+    fn find_similar_impl_candidates(&self,\n+                                    trait_ref: ty::PolyTraitRef<'tcx>)\n+                                    -> Vec<ty::TraitRef<'tcx>>\n+    {\n+        let simp = fast_reject::simplify_type(self.tcx,\n+                                              trait_ref.skip_binder().self_ty(),\n+                                              true);\n+        let mut impl_candidates = Vec::new();\n+        let trait_def = self.tcx.lookup_trait_def(trait_ref.def_id());\n+\n+        match simp {\n+            Some(simp) => trait_def.for_each_impl(self.tcx, |def_id| {\n+                let imp = self.tcx.impl_trait_ref(def_id).unwrap();\n+                let imp_simp = fast_reject::simplify_type(self.tcx,\n+                                                          imp.self_ty(),\n+                                                          true);\n+                if let Some(imp_simp) = imp_simp {\n+                    if simp != imp_simp {\n+                        return;\n+                    }\n+                }\n+                impl_candidates.push(imp);\n+            }),\n+            None => trait_def.for_each_impl(self.tcx, |def_id| {\n+                impl_candidates.push(\n+                    self.tcx.impl_trait_ref(def_id).unwrap());\n+            })\n+        };\n+        impl_candidates\n+    }\n+\n     fn report_similar_impl_candidates(&self,\n                                       trait_ref: ty::PolyTraitRef<'tcx>,\n                                       err: &mut DiagnosticBuilder)\n@@ -682,30 +642,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                 self.resolve_type_vars_if_possible(trait_predicate);\n \n                             if self.tcx.sess.has_errors() && trait_predicate.references_error() {\n-                                let trait_ref = trait_predicate.to_poly_trait_ref();\n-                                let mut err = struct_span_err!(\n-                                    infcx.tcx.sess, obligation.cause.span, E0277,\n-                                    \"the trait bound `{}` is not satisfied\",\n-                                    trait_ref.to_predicate());\n-\n-                            // Try to report a help message\n-\n-                            if !trait_ref.has_infer_types() &&\n-                                predicate_can_apply(infcx, trait_ref) {\n-                                // If a where-clause may be useful, remind the\n-                                // user that they can add it.\n-                                //\n-                                // don't display an on-unimplemented note, as\n-                                // these notes will often be of the form\n-                                //     \"the type `T` can't be frobnicated\"\n-                                // which is somewhat confusing.\n-                                err.help(&format!(\"consider adding a `where {}` bound\",\n-                                                  trait_ref.to_predicate()));\n-                            } else if let Some(s) = on_unimplemented_note(infcx, trait_ref,\n-                                                                          obligation) {\n-                                // If it has a custom \"#[rustc_on_unimplemented]\"\n-                                // error message, let's display it!\n-                                err.note(&s);\n+                                return;\n                             } else {\n                                 let trait_ref = trait_predicate.to_poly_trait_ref();\n \n@@ -727,8 +664,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                 // Try to report a help message\n \n                                 if !trait_ref.has_infer_types() &&\n-                                    self.predicate_can_apply(trait_ref)\n-                                {\n+                                    self.predicate_can_apply(trait_ref) {\n                                     // If a where-clause may be useful, remind the\n                                     // user that they can add it.\n                                     //\n@@ -737,29 +673,23 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                     //     \"the type `T` can't be frobnicated\"\n                                     // which is somewhat confusing.\n                                     err.help(&format!(\"consider adding a `where {}` bound\",\n-                                        trait_ref.to_predicate()\n-                                        ));\n-                                } else if let Some(s) =\n-                                        self.on_unimplemented_note(trait_ref, span) {\n-                                    // Otherwise, if there is an on-unimplemented note,\n-                                    // display it.\n+                                                      trait_ref.to_predicate()));\n+                                } else if let Some(s) = self.on_unimplemented_note(trait_ref,\n+                                                                                   obligation) {\n+                                    // If it has a custom \"#[rustc_on_unimplemented]\"\n+                                    // error message, let's display it!\n                                     err.note(&s);\n                                 } else {\n                                     // If we can't show anything useful, try to find\n                                     // similar impls.\n-\n-                                    self.report_similar_impl_candidates(trait_ref, &mut err);\n-                                    // If we can't show anything useful, try to find\n-                                    // similar impls.\n                                     let impl_candidates =\n-                                        find_similar_impl_candidates(infcx, trait_ref);\n+                                        self.find_similar_impl_candidates(trait_ref);\n                                     if impl_candidates.len() > 0 {\n                                         self.report_similar_impl_candidates(trait_ref, &mut err);\n+                                    }\n                                 }\n                                 err\n                             }\n-                            note_obligation_cause(infcx, &mut err, obligation);\n-                            err.emit();\n                         }\n \n                         ty::Predicate::Equate(ref predicate) => {"}]}