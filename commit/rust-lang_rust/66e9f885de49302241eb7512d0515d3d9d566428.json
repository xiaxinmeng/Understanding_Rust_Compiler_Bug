{"sha": "66e9f885de49302241eb7512d0515d3d9d566428", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2ZTlmODg1ZGU0OTMwMjI0MWViNzUxMmQwNTE1ZDNkOWQ1NjY0Mjg=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-11-22T23:52:59Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-11-27T21:07:19Z"}, "message": "Handle `Rvalue::Ref` in one place", "tree": {"sha": "95e603d385e1be70977b393c3c60d6259f56c801", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95e603d385e1be70977b393c3c60d6259f56c801"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66e9f885de49302241eb7512d0515d3d9d566428", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66e9f885de49302241eb7512d0515d3d9d566428", "html_url": "https://github.com/rust-lang/rust/commit/66e9f885de49302241eb7512d0515d3d9d566428", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66e9f885de49302241eb7512d0515d3d9d566428/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "659616585a9c813564c7c276b296dc5983a10008", "url": "https://api.github.com/repos/rust-lang/rust/commits/659616585a9c813564c7c276b296dc5983a10008", "html_url": "https://github.com/rust-lang/rust/commit/659616585a9c813564c7c276b296dc5983a10008"}], "stats": {"total": 177, "additions": 106, "deletions": 71}, "files": [{"sha": "824ec36e275e46e32da50ac1a2a4afe96f6f5d57", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 106, "deletions": 71, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/66e9f885de49302241eb7512d0515d3d9d566428/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66e9f885de49302241eb7512d0515d3d9d566428/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=66e9f885de49302241eb7512d0515d3d9d566428", "patch": "@@ -322,20 +322,9 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n         trace!(\"visit_rvalue: rvalue={:?} location={:?}\", rvalue, location);\n \n-        // Check nested operands and places.\n+        // Special-case reborrows to be more like a copy of a reference.\n         if let Rvalue::Ref(_, kind, ref place) = *rvalue {\n-            // Special-case reborrows to be more like a copy of a reference.\n-            let mut reborrow_place = None;\n-            if let &[ref proj_base @ .., elem] = place.projection.as_ref() {\n-                if elem == ProjectionElem::Deref {\n-                    let base_ty = Place::ty_from(&place.base, proj_base, self.body, self.tcx).ty;\n-                    if let ty::Ref(..) = base_ty.kind {\n-                        reborrow_place = Some(proj_base);\n-                    }\n-                }\n-            }\n-\n-            if let Some(proj) = reborrow_place {\n+            if let Some(reborrowed_proj) = place_as_reborrow(self.tcx, self.body, place) {\n                 let ctx = match kind {\n                     BorrowKind::Shared => PlaceContext::NonMutatingUse(\n                         NonMutatingUseContext::SharedBorrow,\n@@ -351,14 +340,13 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n                     ),\n                 };\n                 self.visit_place_base(&place.base, ctx, location);\n-                self.visit_projection(&place.base, proj, ctx, location);\n-            } else {\n-                self.super_rvalue(rvalue, location);\n+                self.visit_projection(&place.base, reborrowed_proj, ctx, location);\n+                return;\n             }\n-        } else {\n-            self.super_rvalue(rvalue, location);\n         }\n \n+        self.super_rvalue(rvalue, location);\n+\n         match *rvalue {\n             Rvalue::Use(_) |\n             Rvalue::Repeat(..) |\n@@ -369,9 +357,87 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n             Rvalue::Cast(CastKind::Pointer(_), ..) |\n             Rvalue::Discriminant(..) |\n             Rvalue::Len(_) |\n-            Rvalue::Ref(..) |\n             Rvalue::Aggregate(..) => {}\n \n+            | Rvalue::Ref(_, kind @ BorrowKind::Mut { .. }, ref place)\n+            | Rvalue::Ref(_, kind @ BorrowKind::Unique, ref place)\n+            => {\n+                let ty = place.ty(self.body, self.tcx).ty;\n+                let is_allowed = match ty.kind {\n+                    // Inside a `static mut`, `&mut [...]` is allowed.\n+                    ty::Array(..) | ty::Slice(_) if self.const_kind() == ConstKind::StaticMut\n+                        => true,\n+\n+                    // FIXME(ecstaticmorse): We could allow `&mut []` inside a const context given\n+                    // that this is merely a ZST and it is already eligible for promotion.\n+                    // This may require an RFC?\n+                    /*\n+                    ty::Array(_, len) if len.try_eval_usize(cx.tcx, cx.param_env) == Some(0)\n+                        => true,\n+                    */\n+\n+                    _ => false,\n+                };\n+\n+                if !is_allowed {\n+                    self.check_op(ops::MutBorrow(kind));\n+                }\n+            }\n+\n+            // Taking a shared borrow of a `static` is always legal, even if that `static` has\n+            // interior mutability.\n+            | Rvalue::Ref(_, BorrowKind::Shared, ref place)\n+            | Rvalue::Ref(_, BorrowKind::Shallow, ref place)\n+            if matches!(place.base, PlaceBase::Static(_))\n+            => {}\n+\n+            | Rvalue::Ref(_, kind @ BorrowKind::Shared, ref place)\n+            | Rvalue::Ref(_, kind @ BorrowKind::Shallow, ref place)\n+            => {\n+                // FIXME: Change the `in_*` methods to take a `FnMut` so we don't have to manually\n+                // seek the cursors beforehand.\n+                self.qualifs.has_mut_interior.cursor.seek_before(location);\n+                self.qualifs.indirectly_mutable.seek(location);\n+\n+                let borrowed_place_has_mut_interior = HasMutInterior::in_place(\n+                    &self.item,\n+                    &|local| self.qualifs.has_mut_interior_eager_seek(local),\n+                    place.as_ref(),\n+                );\n+\n+                if borrowed_place_has_mut_interior {\n+                    let src_derived_from_illegal_borrow = borrowed_place\n+                        .as_local()\n+                        .map_or(false, |local| self.derived_from_illegal_borrow.contains(local));\n+\n+                    // Don't emit errors for borrows of values that are *themselves* the result of\n+                    // an illegal borrow (e.g., the outermost `&` in `&&Cell::new(42)`). We want to\n+                    // point the user to the place where the original illegal borrow occurred, not\n+                    // to subsequent borrows of the resulting value.\n+                    let dest_derived_from_illegal_borrow = if !src_derived_from_illegal_borrow {\n+                        self.check_op(ops::MutBorrow(kind)) == CheckOpResult::Forbidden\n+                    } else {\n+                        true\n+                    };\n+\n+                    // When the target of the assignment is a local with no projections, it will be\n+                    // marked as derived from an illegal borrow if necessary.\n+                    //\n+                    // FIXME: should we also clear `derived_from_illegal_borrow` when a local is\n+                    // assigned a new value?\n+\n+                    if dest_derived_from_illegal_borrow {\n+                        let block = &self.body[location.block];\n+                        let statement = &block.statements[location.statement_index];\n+                        if let StatementKind::Assign(box (dest, _)) = &statement.kind {\n+                            if let Some(dest) = dest.as_local() {\n+                                self.derived_from_illegal_borrow.insert(dest);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+\n             Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) => {\n                 let operand_ty = operand.ty(self.body, self.tcx);\n                 let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n@@ -436,58 +502,6 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n         }\n     }\n \n-    fn visit_assign(&mut self, dest: &Place<'tcx>, rvalue: &Rvalue<'tcx>, location: Location) {\n-        trace!(\"visit_assign: dest={:?} rvalue={:?} location={:?}\", dest, rvalue, location);\n-\n-        // Error on mutable borrows or shared borrows of values with interior mutability.\n-        //\n-        // This replicates the logic at the start of `assign` in the old const checker.  Note that\n-        // it depends on `HasMutInterior` being set for mutable borrows as well as values with\n-        // interior mutability.\n-        if let Rvalue::Ref(_, kind, ref borrowed_place) = *rvalue {\n-            // FIXME: Change the `in_*` methods to take a `FnMut` so we don't have to manually seek\n-            // the cursors beforehand.\n-            self.qualifs.has_mut_interior.cursor.seek_before(location);\n-            self.qualifs.indirectly_mutable.seek(location);\n-\n-            let rvalue_has_mut_interior = HasMutInterior::in_rvalue(\n-                &self.item,\n-                &|local| self.qualifs.has_mut_interior_eager_seek(local),\n-                rvalue,\n-            );\n-\n-            if rvalue_has_mut_interior {\n-                let is_derived_from_illegal_borrow = match borrowed_place.as_local() {\n-                    // If an unprojected local was borrowed and its value was the result of an\n-                    // illegal borrow, suppress this error and mark the result of this borrow as\n-                    // illegal as well.\n-                    Some(borrowed_local)\n-                        if self.derived_from_illegal_borrow.contains(borrowed_local) =>\n-                    {\n-                        true\n-                    }\n-\n-                    // Otherwise proceed normally: check the legality of a mutable borrow in this\n-                    // context.\n-                    _ => self.check_op(ops::MutBorrow(kind)) == CheckOpResult::Forbidden,\n-                };\n-\n-                // When the target of the assignment is a local with no projections, mark it as\n-                // derived from an illegal borrow if necessary.\n-                //\n-                // FIXME: should we also clear `derived_from_illegal_borrow` when a local is\n-                // assigned a new value?\n-                if is_derived_from_illegal_borrow {\n-                    if let Some(dest) = dest.as_local() {\n-                        self.derived_from_illegal_borrow.insert(dest);\n-                    }\n-                }\n-            }\n-        }\n-\n-        self.super_assign(dest, rvalue, location);\n-    }\n-\n     fn visit_projection_elem(\n         &mut self,\n         place_base: &PlaceBase<'tcx>,\n@@ -725,3 +739,24 @@ fn check_return_ty_is_sync(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, hir_id: HirId)\n         }\n     });\n }\n+\n+fn place_as_reborrow(\n+    tcx: TyCtxt<'tcx>,\n+    body: &Body<'tcx>,\n+    place: &'a Place<'tcx>,\n+) -> Option<&'a [PlaceElem<'tcx>]> {\n+    place\n+        .projection\n+        .split_last()\n+        .and_then(|(outermost, inner)| {\n+            if outermost != &ProjectionElem::Deref {\n+                return None;\n+            }\n+\n+            let inner_ty = Place::ty_from(&place.base, inner, body, tcx).ty;\n+            match inner_ty.kind {\n+                ty::Ref(..) => Some(inner),\n+                _ => None,\n+            }\n+        })\n+}"}]}