{"sha": "e2a28165a336aacd3f6227fa5bddcddb8cd7bf94", "node_id": "C_kwDOAAsO6NoAKGUyYTI4MTY1YTMzNmFhY2QzZjYyMjdmYTViZGRjZGRiOGNkN2JmOTQ", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-11-14T16:36:29Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-11-16T13:42:30Z"}, "message": "Fix perf regression by correctly matching keywords", "tree": {"sha": "da8d37958852f3b5ced5bf9e93bed3c2960d695a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da8d37958852f3b5ced5bf9e93bed3c2960d695a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2a28165a336aacd3f6227fa5bddcddb8cd7bf94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2a28165a336aacd3f6227fa5bddcddb8cd7bf94", "html_url": "https://github.com/rust-lang/rust/commit/e2a28165a336aacd3f6227fa5bddcddb8cd7bf94", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2a28165a336aacd3f6227fa5bddcddb8cd7bf94/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e702534763599db252f2ca308739ec340d0933de", "url": "https://api.github.com/repos/rust-lang/rust/commits/e702534763599db252f2ca308739ec340d0933de", "html_url": "https://github.com/rust-lang/rust/commit/e702534763599db252f2ca308739ec340d0933de"}], "stats": {"total": 32, "additions": 22, "deletions": 10}, "files": [{"sha": "aaa3d6239cadf83720db65edcd05ca600fab185b", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e2a28165a336aacd3f6227fa5bddcddb8cd7bf94/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a28165a336aacd3f6227fa5bddcddb8cd7bf94/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=e2a28165a336aacd3f6227fa5bddcddb8cd7bf94", "patch": "@@ -222,7 +222,8 @@ impl<'a> Parser<'a> {\n             self.parse_use_item()?\n         } else if self.check_fn_front_matter(def_final, case) {\n             // FUNCTION ITEM\n-            let (ident, sig, generics, body) = self.parse_fn(attrs, fn_parse_mode, lo, vis)?;\n+            let (ident, sig, generics, body) =\n+                self.parse_fn(attrs, fn_parse_mode, lo, vis, case)?;\n             (ident, ItemKind::Fn(Box::new(Fn { defaultness: def_(), sig, generics, body })))\n         } else if self.eat_keyword(kw::Extern) {\n             if self.eat_keyword(kw::Crate) {\n@@ -1792,7 +1793,13 @@ impl<'a> Parser<'a> {\n                 };\n                 // We use `parse_fn` to get a span for the function\n                 let fn_parse_mode = FnParseMode { req_name: |_| true, req_body: true };\n-                match self.parse_fn(&mut AttrVec::new(), fn_parse_mode, lo, &inherited_vis) {\n+                match self.parse_fn(\n+                    &mut AttrVec::new(),\n+                    fn_parse_mode,\n+                    lo,\n+                    &inherited_vis,\n+                    Case::Insensitive,\n+                ) {\n                     Ok(_) => {\n                         let mut err = self.struct_span_err(\n                             lo.to(self.prev_token.span),\n@@ -2116,8 +2123,9 @@ impl<'a> Parser<'a> {\n         fn_parse_mode: FnParseMode,\n         sig_lo: Span,\n         vis: &Visibility,\n+        case: Case,\n     ) -> PResult<'a, (Ident, FnSig, Generics, Option<P<Block>>)> {\n-        let header = self.parse_fn_front_matter(vis)?; // `const ... fn`\n+        let header = self.parse_fn_front_matter(vis, case)?; // `const ... fn`\n         let ident = self.parse_ident()?; // `foo`\n         let mut generics = self.parse_generics()?; // `<'a, T, ...>`\n         let decl =\n@@ -2241,24 +2249,28 @@ impl<'a> Parser<'a> {\n     ///\n     /// `vis` represents the visibility that was already parsed, if any. Use\n     /// `Visibility::Inherited` when no visibility is known.\n-    pub(super) fn parse_fn_front_matter(&mut self, orig_vis: &Visibility) -> PResult<'a, FnHeader> {\n+    pub(super) fn parse_fn_front_matter(\n+        &mut self,\n+        orig_vis: &Visibility,\n+        case: Case,\n+    ) -> PResult<'a, FnHeader> {\n         let sp_start = self.token.span;\n-        let constness = self.parse_constness(Case::Insensitive);\n+        let constness = self.parse_constness(case);\n \n         let async_start_sp = self.token.span;\n-        let asyncness = self.parse_asyncness(Case::Insensitive);\n+        let asyncness = self.parse_asyncness(case);\n \n         let unsafe_start_sp = self.token.span;\n-        let unsafety = self.parse_unsafety(Case::Insensitive);\n+        let unsafety = self.parse_unsafety(case);\n \n         let ext_start_sp = self.token.span;\n-        let ext = self.parse_extern(Case::Insensitive);\n+        let ext = self.parse_extern(case);\n \n         if let Async::Yes { span, .. } = asyncness {\n             self.ban_async_in_2015(span);\n         }\n \n-        if !self.eat_keyword_case(kw::Fn, Case::Insensitive) {\n+        if !self.eat_keyword_case(kw::Fn, case) {\n             // It is possible for `expect_one_of` to recover given the contents of\n             // `self.expected_tokens`, therefore, do not use `self.unexpected()` which doesn't\n             // account for this."}, {"sha": "552fd6ddc867e9c4a076e45a7003c42e440690b9", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2a28165a336aacd3f6227fa5bddcddb8cd7bf94/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2a28165a336aacd3f6227fa5bddcddb8cd7bf94/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=e2a28165a336aacd3f6227fa5bddcddb8cd7bf94", "patch": "@@ -536,7 +536,7 @@ impl<'a> Parser<'a> {\n         };\n         let span_start = self.token.span;\n         let ast::FnHeader { ext, unsafety, constness, asyncness } =\n-            self.parse_fn_front_matter(&inherited_vis)?;\n+            self.parse_fn_front_matter(&inherited_vis, Case::Sensitive)?;\n         if self.may_recover() && self.token.kind == TokenKind::Lt {\n             self.recover_fn_ptr_with_generics(lo, &mut params, param_insertion_point)?;\n         }"}]}