{"sha": "29d0430c56276da7371a845008bef3d1361b842e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5ZDA0MzBjNTYyNzZkYTczNzFhODQ1MDA4YmVmM2QxMzYxYjg0MmU=", "commit": {"author": {"name": "Jed Davis", "email": "jld@panix.com", "date": "2013-02-25T02:41:39Z"}, "committer": {"name": "Jed Davis", "email": "jld@panix.com", "date": "2013-03-07T04:41:57Z"}, "message": "Convert iter_structural_ty to trans::adt", "tree": {"sha": "4301cfa4d5d4aab4519f163b0058b48d0a922d01", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4301cfa4d5d4aab4519f163b0058b48d0a922d01"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29d0430c56276da7371a845008bef3d1361b842e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29d0430c56276da7371a845008bef3d1361b842e", "html_url": "https://github.com/rust-lang/rust/commit/29d0430c56276da7371a845008bef3d1361b842e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29d0430c56276da7371a845008bef3d1361b842e/comments", "author": {"login": "jld", "id": 254973, "node_id": "MDQ6VXNlcjI1NDk3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/254973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jld", "html_url": "https://github.com/jld", "followers_url": "https://api.github.com/users/jld/followers", "following_url": "https://api.github.com/users/jld/following{/other_user}", "gists_url": "https://api.github.com/users/jld/gists{/gist_id}", "starred_url": "https://api.github.com/users/jld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jld/subscriptions", "organizations_url": "https://api.github.com/users/jld/orgs", "repos_url": "https://api.github.com/users/jld/repos", "events_url": "https://api.github.com/users/jld/events{/privacy}", "received_events_url": "https://api.github.com/users/jld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jld", "id": 254973, "node_id": "MDQ6VXNlcjI1NDk3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/254973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jld", "html_url": "https://github.com/jld", "followers_url": "https://api.github.com/users/jld/followers", "following_url": "https://api.github.com/users/jld/following{/other_user}", "gists_url": "https://api.github.com/users/jld/gists{/gist_id}", "starred_url": "https://api.github.com/users/jld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jld/subscriptions", "organizations_url": "https://api.github.com/users/jld/orgs", "repos_url": "https://api.github.com/users/jld/repos", "events_url": "https://api.github.com/users/jld/events{/privacy}", "received_events_url": "https://api.github.com/users/jld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0f6909f7ecee906ea21c9bbba903e105bb7e711", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0f6909f7ecee906ea21c9bbba903e105bb7e711", "html_url": "https://github.com/rust-lang/rust/commit/c0f6909f7ecee906ea21c9bbba903e105bb7e711"}], "stats": {"total": 113, "additions": 49, "deletions": 64}, "files": [{"sha": "342da3fadf709bfc73c173e0af37e95b8a7b37c1", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 49, "deletions": 64, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/29d0430c56276da7371a845008bef3d1361b842e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29d0430c56276da7371a845008bef3d1361b842e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=29d0430c56276da7371a845008bef3d1361b842e", "patch": "@@ -640,35 +640,16 @@ pub fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n                           f: val_and_ty_fn) -> block {\n     let _icx = cx.insn_ctxt(\"iter_structural_ty\");\n \n-    fn iter_variant(cx: block, a_tup: ValueRef,\n+    fn iter_variant(cx: block, repr: &adt::Repr, av: ValueRef,\n                     variant: ty::VariantInfo,\n-                    tps: &[ty::t], tid: ast::def_id,\n-                    f: val_and_ty_fn) -> block {\n+                    tps: &[ty::t], f: val_and_ty_fn) -> block {\n         let _icx = cx.insn_ctxt(\"iter_variant\");\n-        if variant.args.len() == 0u { return cx; }\n-        let fn_ty = variant.ctor_ty;\n-        let ccx = cx.ccx();\n+        let tcx = cx.tcx();\n         let mut cx = cx;\n-        match ty::get(fn_ty).sty {\n-          ty::ty_bare_fn(ref fn_ty) => {\n-            let mut j = 0u;\n-            let v_id = variant.id;\n-            for vec::each(fn_ty.sig.inputs) |a| {\n-                let llfldp_a = GEP_enum(cx, a_tup, tid, v_id,\n-                                        /*bad*/copy tps, j);\n-                // This assumes the self type is absent (it passes\n-                // None for the self_ty_opt arg of substs_tps).\n-                // I think that's ok since you can't have an enum\n-                // inside a trait.\n-                let ty_subst = ty::subst_tps(ccx.tcx, tps, None, a.ty);\n-                cx = f(cx, llfldp_a, ty_subst);\n-                j += 1u;\n-            }\n-          }\n-          _ => cx.tcx().sess.bug(fmt!(\"iter_variant: not a function type: \\\n-                                       %s (variant name = %s)\",\n-                                      cx.ty_to_str(fn_ty),\n-                                      *cx.sess().str_of(variant.name)))\n+\n+        for variant.args.eachi |i, &arg| {\n+            cx = f(cx, adt::trans_GEP(cx, repr, av, variant.disr_val, i),\n+                   ty::subst_tps(tcx, tps, None, arg));\n         }\n         return cx;\n     }\n@@ -697,45 +678,49 @@ pub fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n           }\n       }\n       ty::ty_enum(tid, ref substs) => {\n-        let variants = ty::enum_variants(cx.tcx(), tid);\n-        let n_variants = (*variants).len();\n-\n-        // Cast the enums to types we can GEP into.\n-        if n_variants == 1u {\n-            return iter_variant(cx,\n-                                av,\n-                                variants[0],\n-                                /*bad*/copy substs.tps,\n-                                tid,\n-                                f);\n-        }\n+          let ccx = cx.ccx();\n \n-        let ccx = cx.ccx();\n-        let llenumty = T_opaque_enum_ptr(ccx);\n-        let av_enum = PointerCast(cx, av, llenumty);\n-        let lldiscrim_a_ptr = GEPi(cx, av_enum, [0u, 0u]);\n-        let llunion_a_ptr = GEPi(cx, av_enum, [0u, 1u]);\n-        let lldiscrim_a = Load(cx, lldiscrim_a_ptr);\n-\n-        // NB: we must hit the discriminant first so that structural\n-        // comparison know not to proceed when the discriminants differ.\n-        cx = f(cx, lldiscrim_a_ptr, ty::mk_int(cx.tcx()));\n-        let unr_cx = sub_block(cx, ~\"enum-iter-unr\");\n-        Unreachable(unr_cx);\n-        let llswitch = Switch(cx, lldiscrim_a, unr_cx.llbb, n_variants);\n-        let next_cx = sub_block(cx, ~\"enum-iter-next\");\n-        for vec::each(*variants) |variant| {\n-            let variant_cx =\n-                sub_block(cx,\n-                                   ~\"enum-iter-variant-\" +\n-                                       int::to_str(variant.disr_val));\n-            AddCase(llswitch, C_int(ccx, variant.disr_val), variant_cx.llbb);\n-            let variant_cx =\n-                iter_variant(variant_cx, llunion_a_ptr, *variant,\n-                             /*bad*/copy (*substs).tps, tid, f);\n-            Br(variant_cx, next_cx.llbb);\n-        }\n-        return next_cx;\n+          let repr = adt::represent_type(ccx, t);\n+          let variants = ty::enum_variants(ccx.tcx, tid);\n+          let n_variants = (*variants).len();\n+\n+          // NB: we must hit the discriminant first so that structural\n+          // comparison know not to proceed when the discriminants differ.\n+\n+          match adt::trans_switch(cx, &repr, av) {\n+              (_match::single, None) => {\n+                  cx = iter_variant(cx, &repr, av, variants[0],\n+                                    substs.tps, f);\n+              }\n+              (_match::switch, Some(lldiscrim_a)) => {\n+                  cx = f(cx, lldiscrim_a, ty::mk_int(cx.tcx()));\n+                  let unr_cx = sub_block(cx, ~\"enum-iter-unr\");\n+                  Unreachable(unr_cx);\n+                  let llswitch = Switch(cx, lldiscrim_a, unr_cx.llbb,\n+                                        n_variants);\n+                  let next_cx = sub_block(cx, ~\"enum-iter-next\");\n+\n+                  for vec::each(*variants) |variant| {\n+                      let variant_cx =\n+                          sub_block(cx, ~\"enum-iter-variant-\" +\n+                                    int::to_str(variant.disr_val));\n+                      let variant_cx =\n+                          iter_variant(variant_cx, &repr, av, *variant,\n+                                       substs.tps, f);\n+                      match adt::trans_case(cx, &repr, variant.disr_val) {\n+                          _match::single_result(r) => {\n+                              AddCase(llswitch, r.val, variant_cx.llbb)\n+                          }\n+                          _ => ccx.sess.unimpl(~\"value from adt::trans_case \\\n+                                                 in iter_structural_ty\")\n+                      }\n+                      Br(variant_cx, next_cx.llbb);\n+                  }\n+                  cx = next_cx;\n+              }\n+              _ => ccx.sess.unimpl(~\"value from adt::trans_switch \\\n+                                     in iter_structural_ty\")\n+          }\n       }\n       _ => cx.sess().unimpl(~\"type in iter_structural_ty\")\n     }"}]}