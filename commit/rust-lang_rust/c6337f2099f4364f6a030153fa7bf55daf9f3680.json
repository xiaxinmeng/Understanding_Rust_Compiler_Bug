{"sha": "c6337f2099f4364f6a030153fa7bf55daf9f3680", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2MzM3ZjIwOTlmNDM2NGY2YTAzMDE1M2ZhN2JmNTVkYWY5ZjM2ODA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-22T08:31:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-22T08:31:24Z"}, "message": "auto merge of #10003 : alexcrichton/rust/issue-fixes, r=brson\n\nCommits have all the fun details.", "tree": {"sha": "384d75e3e07b277471a85b740ef0d544db3db29e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/384d75e3e07b277471a85b740ef0d544db3db29e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6337f2099f4364f6a030153fa7bf55daf9f3680", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6337f2099f4364f6a030153fa7bf55daf9f3680", "html_url": "https://github.com/rust-lang/rust/commit/c6337f2099f4364f6a030153fa7bf55daf9f3680", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6337f2099f4364f6a030153fa7bf55daf9f3680/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "886a4ddcec08a4fea68f31c6387c90f745a7df0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/886a4ddcec08a4fea68f31c6387c90f745a7df0f", "html_url": "https://github.com/rust-lang/rust/commit/886a4ddcec08a4fea68f31c6387c90f745a7df0f"}, {"sha": "41f6e97a445f736ab437b2f64756b967cf69d763", "url": "https://api.github.com/repos/rust-lang/rust/commits/41f6e97a445f736ab437b2f64756b967cf69d763", "html_url": "https://github.com/rust-lang/rust/commit/41f6e97a445f736ab437b2f64756b967cf69d763"}], "stats": {"total": 299, "additions": 235, "deletions": 64}, "files": [{"sha": "f65eeee49d510bf9a3c360f0c46d9ec2fefb82c4", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 72, "deletions": 35, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/c6337f2099f4364f6a030153fa7bf55daf9f3680/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6337f2099f4364f6a030153fa7bf55daf9f3680/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=c6337f2099f4364f6a030153fa7bf55daf9f3680", "patch": "@@ -21,36 +21,36 @@ use middle::privacy;\n use middle::resolve;\n \n use std::hashmap::HashSet;\n-use syntax::ast::*;\n+use syntax::ast;\n use syntax::ast_map;\n-use syntax::ast_util::{def_id_of_def, is_local};\n+use syntax::ast_util::{def_id_of_def, is_local, local_def};\n use syntax::attr;\n use syntax::parse::token;\n use syntax::visit::Visitor;\n use syntax::visit;\n \n // Returns true if the given set of attributes contains the `#[inline]`\n // attribute.\n-fn attributes_specify_inlining(attrs: &[Attribute]) -> bool {\n+fn attributes_specify_inlining(attrs: &[ast::Attribute]) -> bool {\n     attr::contains_name(attrs, \"inline\")\n }\n \n // Returns true if the given set of generics implies that the item it's\n // associated with must be inlined.\n-fn generics_require_inlining(generics: &Generics) -> bool {\n+fn generics_require_inlining(generics: &ast::Generics) -> bool {\n     !generics.ty_params.is_empty()\n }\n \n // Returns true if the given item must be inlined because it may be\n // monomorphized or it was marked with `#[inline]`. This will only return\n // true for functions.\n-fn item_might_be_inlined(item: @item) -> bool {\n+fn item_might_be_inlined(item: @ast::item) -> bool {\n     if attributes_specify_inlining(item.attrs) {\n         return true\n     }\n \n     match item.node {\n-        item_fn(_, _, _, ref generics, _) => {\n+        ast::item_fn(_, _, _, ref generics, _) => {\n             generics_require_inlining(generics)\n         }\n         _ => false,\n@@ -59,17 +59,17 @@ fn item_might_be_inlined(item: @item) -> bool {\n \n // Returns true if the given type method must be inlined because it may be\n // monomorphized or it was marked with `#[inline]`.\n-fn ty_method_might_be_inlined(ty_method: &TypeMethod) -> bool {\n+fn ty_method_might_be_inlined(ty_method: &ast::TypeMethod) -> bool {\n     attributes_specify_inlining(ty_method.attrs) ||\n         generics_require_inlining(&ty_method.generics)\n }\n \n // Returns true if the given trait method must be inlined because it may be\n // monomorphized or it was marked with `#[inline]`.\n-fn trait_method_might_be_inlined(trait_method: &trait_method) -> bool {\n+fn trait_method_might_be_inlined(trait_method: &ast::trait_method) -> bool {\n     match *trait_method {\n-        required(ref ty_method) => ty_method_might_be_inlined(ty_method),\n-        provided(_) => true\n+        ast::required(ref ty_method) => ty_method_might_be_inlined(ty_method),\n+        ast::provided(_) => true\n     }\n }\n \n@@ -81,27 +81,27 @@ struct ReachableContext {\n     // methods they've been resolved to.\n     method_map: typeck::method_map,\n     // The set of items which must be exported in the linkage sense.\n-    reachable_symbols: @mut HashSet<NodeId>,\n+    reachable_symbols: @mut HashSet<ast::NodeId>,\n     // A worklist of item IDs. Each item ID in this worklist will be inlined\n     // and will be scanned for further references.\n-    worklist: @mut ~[NodeId],\n+    worklist: @mut ~[ast::NodeId],\n     // Known reexports of modules\n     exp_map2: resolve::ExportMap2,\n }\n \n struct MarkSymbolVisitor {\n-    worklist: @mut ~[NodeId],\n+    worklist: @mut ~[ast::NodeId],\n     method_map: typeck::method_map,\n     tcx: ty::ctxt,\n-    reachable_symbols: @mut HashSet<NodeId>,\n+    reachable_symbols: @mut HashSet<ast::NodeId>,\n }\n \n impl Visitor<()> for MarkSymbolVisitor {\n \n-    fn visit_expr(&mut self, expr:@Expr, _:()) {\n+    fn visit_expr(&mut self, expr:@ast::Expr, _:()) {\n \n                 match expr.node {\n-                    ExprPath(_) => {\n+                    ast::ExprPath(_) => {\n                         let def = match self.tcx.def_map.find(&expr.id) {\n                             Some(&def) => def,\n                             None => {\n@@ -118,7 +118,7 @@ impl Visitor<()> for MarkSymbolVisitor {\n                         }\n                         self.reachable_symbols.insert(def_id.node);\n                     }\n-                    ExprMethodCall(*) => {\n+                    ast::ExprMethodCall(*) => {\n                         match self.method_map.find(&expr.id) {\n                             Some(&typeck::method_map_entry {\n                                 origin: typeck::method_static(def_id),\n@@ -162,24 +162,24 @@ impl ReachableContext {\n \n     // Returns true if the given def ID represents a local item that is\n     // eligible for inlining and false otherwise.\n-    fn def_id_represents_local_inlined_item(tcx: ty::ctxt, def_id: DefId)\n+    fn def_id_represents_local_inlined_item(tcx: ty::ctxt, def_id: ast::DefId)\n                                             -> bool {\n-        if def_id.crate != LOCAL_CRATE {\n+        if def_id.crate != ast::LOCAL_CRATE {\n             return false\n         }\n \n         let node_id = def_id.node;\n         match tcx.items.find(&node_id) {\n             Some(&ast_map::node_item(item, _)) => {\n                 match item.node {\n-                    item_fn(*) => item_might_be_inlined(item),\n+                    ast::item_fn(*) => item_might_be_inlined(item),\n                     _ => false,\n                 }\n             }\n             Some(&ast_map::node_trait_method(trait_method, _, _)) => {\n                 match *trait_method {\n-                    required(_) => false,\n-                    provided(_) => true,\n+                    ast::required(_) => false,\n+                    ast::provided(_) => true,\n                 }\n             }\n             Some(&ast_map::node_method(method, impl_did, _)) => {\n@@ -189,11 +189,11 @@ impl ReachableContext {\n                 } else {\n                     // Check the impl. If the generics on the self type of the\n                     // impl require inlining, this method does too.\n-                    assert!(impl_did.crate == LOCAL_CRATE);\n+                    assert!(impl_did.crate == ast::LOCAL_CRATE);\n                     match tcx.items.find(&impl_did.node) {\n                         Some(&ast_map::node_item(item, _)) => {\n                             match item.node {\n-                                item_impl(ref generics, _, _, _) => {\n+                                ast::item_impl(ref generics, _, _, _) => {\n                                     generics_require_inlining(generics)\n                                 }\n                                 _ => false\n@@ -231,7 +231,7 @@ impl ReachableContext {\n         }\n     }\n \n-    fn propagate_mod(&self, id: NodeId) {\n+    fn propagate_mod(&self, id: ast::NodeId) {\n         match self.exp_map2.find(&id) {\n             Some(l) => {\n                 for reexport in l.iter() {\n@@ -262,21 +262,58 @@ impl ReachableContext {\n             match self.tcx.items.find(&search_item) {\n                 Some(&ast_map::node_item(item, _)) => {\n                     match item.node {\n-                        item_fn(_, _, _, _, ref search_block) => {\n+                        ast::item_fn(_, _, _, _, ref search_block) => {\n                             visit::walk_block(&mut visitor, search_block, ())\n                         }\n                         // Our recursion into modules involves looking up their\n                         // public reexports and the destinations of those\n                         // exports. Privacy will put them in the worklist, but\n                         // we won't find them in the ast_map, so this is where\n                         // we deal with publicly re-exported items instead.\n-                        item_mod(*) => { self.propagate_mod(item.id); }\n+                        ast::item_mod(*) => self.propagate_mod(item.id),\n+\n+                        // Implementations of exported structs/enums need to get\n+                        // added to the worklist (as all their methods should be\n+                        // accessible)\n+                        ast::item_struct(*) | ast::item_enum(*) => {\n+                            let def = local_def(item.id);\n+                            let impls = match self.tcx.inherent_impls.find(&def) {\n+                                Some(&impls) => impls,\n+                                None => continue\n+                            };\n+                            for imp in impls.iter() {\n+                                if is_local(imp.did) {\n+                                    self.worklist.push(imp.did.node);\n+                                }\n+                            }\n+                        }\n+\n+                        // Propagate through this impl\n+                        ast::item_impl(_, _, _, ref methods) => {\n+                            for method in methods.iter() {\n+                                self.worklist.push(method.id);\n+                            }\n+                        }\n+\n+                        // Default methods of exported traits need to all be\n+                        // accessible.\n+                        ast::item_trait(_, _, ref methods) => {\n+                            for method in methods.iter() {\n+                                match *method {\n+                                    ast::required(*) => {}\n+                                    ast::provided(ref method) => {\n+                                        self.worklist.push(method.id);\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n                         // These are normal, nothing reachable about these\n                         // inherently and their children are already in the\n                         // worklist\n-                        item_struct(*) | item_impl(*) | item_static(*) |\n-                        item_enum(*) | item_ty(*) | item_trait(*) |\n-                        item_foreign_mod(*) => {}\n+                        ast::item_static(*) | ast::item_ty(*) |\n+                            ast::item_foreign_mod(*) => {}\n+\n                         _ => {\n                             self.tcx.sess.span_bug(item.span,\n                                                    \"found non-function item \\\n@@ -286,10 +323,10 @@ impl ReachableContext {\n                 }\n                 Some(&ast_map::node_trait_method(trait_method, _, _)) => {\n                     match *trait_method {\n-                        required(*) => {\n+                        ast::required(*) => {\n                             // Keep going, nothing to get exported\n                         }\n-                        provided(ref method) => {\n+                        ast::provided(ref method) => {\n                             visit::walk_block(&mut visitor, &method.body, ())\n                         }\n                     }\n@@ -310,7 +347,7 @@ impl ReachableContext {\n                                                worklist: {}\",\n                                                desc))\n                 }\n-                None if search_item == CRATE_NODE_ID => {\n+                None if search_item == ast::CRATE_NODE_ID => {\n                     self.propagate_mod(search_item);\n                 }\n                 None => {\n@@ -329,7 +366,7 @@ impl ReachableContext {\n     // reachability, which might result in a compile time loss.\n     fn mark_destructors_reachable(&self) {\n         for (_, destructor_def_id) in self.tcx.destructor_for_type.iter() {\n-            if destructor_def_id.crate == LOCAL_CRATE {\n+            if destructor_def_id.crate == ast::LOCAL_CRATE {\n                 self.reachable_symbols.insert(destructor_def_id.node);\n             }\n         }\n@@ -340,7 +377,7 @@ pub fn find_reachable(tcx: ty::ctxt,\n                       method_map: typeck::method_map,\n                       exp_map2: resolve::ExportMap2,\n                       exported_items: &privacy::ExportedItems)\n-                      -> @mut HashSet<NodeId> {\n+                      -> @mut HashSet<ast::NodeId> {\n     // XXX(pcwalton): We only need to mark symbols that are exported. But this\n     // is more complicated than just looking at whether the symbol is `pub`,\n     // because it might be the target of a `pub use` somewhere. For now, I"}, {"sha": "8b089e76f3a0ba68efb7c622796a2c31b854d61d", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 56, "deletions": 29, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/c6337f2099f4364f6a030153fa7bf55daf9f3680/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6337f2099f4364f6a030153fa7bf55daf9f3680/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=c6337f2099f4364f6a030153fa7bf55daf9f3680", "patch": "@@ -149,10 +149,9 @@ pub struct Cache {\n \n     /// This map contains information about all known traits of this crate.\n     /// Implementations of a crate should inherit the documentation of the\n-    /// parent trait if no extra documentation is specified, and this map is\n-    /// keyed on trait id with a value of a 'method name => documentation'\n-    /// mapping.\n-    traits: HashMap<ast::NodeId, HashMap<~str, ~str>>,\n+    /// parent trait if no extra documentation is specified, and default methods\n+    /// should show up in documentation about trait implementations.\n+    traits: HashMap<ast::NodeId, clean::Trait>,\n \n     /// When rendering traits, it's often useful to be able to list all\n     /// implementors of the trait, and this mapping is exactly, that: a mapping\n@@ -488,18 +487,7 @@ impl DocFolder for Cache {\n         // trait\n         match item.inner {\n             clean::TraitItem(ref t) => {\n-                let mut dox = HashMap::new();\n-                for meth in t.methods.iter() {\n-                    let it = meth.item();\n-                    match it.doc_value() {\n-                        None => {}\n-                        Some(s) => {\n-                            dox.insert(it.name.get_ref().to_owned(),\n-                                       s.to_owned());\n-                        }\n-                    }\n-                }\n-                self.traits.insert(item.id, dox);\n+                self.traits.insert(item.id, t.clone());\n             }\n             _ => {}\n         }\n@@ -1480,18 +1468,25 @@ fn render_impl(w: &mut io::Writer, i: &clean::Impl, dox: &Option<~str>) {\n         }\n         None => {}\n     }\n-    write!(w, \"<div class='methods'>\");\n-    for meth in i.methods.iter() {\n+\n+    fn docmeth(w: &mut io::Writer, item: &clean::Item) -> bool {\n         write!(w, \"<h4 id='method.{}' class='method'><code>\",\n-               *meth.name.get_ref());\n-        render_method(w, meth, false);\n+               *item.name.get_ref());\n+        render_method(w, item, false);\n         write!(w, \"</code></h4>\\n\");\n-        match meth.doc_value() {\n+        match item.doc_value() {\n             Some(s) => {\n                 write!(w, \"<div class='docblock'>{}</div>\", Markdown(s));\n-                continue\n+                true\n             }\n-            None => {}\n+            None => false\n+        }\n+    }\n+\n+    write!(w, \"<div class='methods'>\");\n+    for meth in i.methods.iter() {\n+        if docmeth(w, meth) {\n+            continue\n         }\n \n         // No documentation? Attempt to slurp in the trait's documentation\n@@ -1501,13 +1496,19 @@ fn render_impl(w: &mut io::Writer, i: &clean::Impl, dox: &Option<~str>) {\n         };\n         do local_data::get(cache_key) |cache| {\n             do cache.unwrap().read |cache| {\n-                let name = meth.name.get_ref().as_slice();\n                 match cache.traits.find(&trait_id) {\n-                    Some(m) => {\n-                        match m.find_equiv(&name) {\n-                            Some(s) => {\n-                                write!(w, \"<div class='docblock'>{}</div>\",\n-                                       Markdown(s.as_slice()));\n+                    Some(t) => {\n+                        let name = meth.name.clone();\n+                        match t.methods.iter().find(|t| t.item().name == name) {\n+                            Some(method) => {\n+                                match method.item().doc_value() {\n+                                    Some(s) => {\n+                                        write!(w,\n+                                               \"<div class='docblock'>{}</div>\",\n+                                               Markdown(s));\n+                                    }\n+                                    None => {}\n+                                }\n                             }\n                             None => {}\n                         }\n@@ -1517,6 +1518,32 @@ fn render_impl(w: &mut io::Writer, i: &clean::Impl, dox: &Option<~str>) {\n             }\n         }\n     }\n+\n+    // If we've implemented a trait, then also emit documentation for all\n+    // default methods which weren't overridden in the implementation block.\n+    match trait_id {\n+        None => {}\n+        Some(id) => {\n+            do local_data::get(cache_key) |cache| {\n+                do cache.unwrap().read |cache| {\n+                    match cache.traits.find(&id) {\n+                        Some(t) => {\n+                            for method in t.methods.iter() {\n+                                let n = method.item().name.clone();\n+                                match i.methods.iter().find(|m| m.name == n) {\n+                                    Some(*) => continue,\n+                                    None => {}\n+                                }\n+\n+                                docmeth(w, method.item());\n+                            }\n+                        }\n+                        None => {}\n+                    }\n+                }\n+            }\n+        }\n+    }\n     write!(w, \"</div>\");\n }\n "}, {"sha": "b1ef4dc829acc6552c2fa60e97801d4d2024f603", "filename": "src/librustdoc/html/static/main.css", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c6337f2099f4364f6a030153fa7bf55daf9f3680/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/c6337f2099f4364f6a030153fa7bf55daf9f3680/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css?ref=c6337f2099f4364f6a030153fa7bf55daf9f3680", "patch": "@@ -97,6 +97,13 @@ nav.sub {\n     margin-bottom: 10px;\n }\n .block h2 { margin-top: 0; }\n+.block a {\n+    display: inline-block;\n+    width: 100%;\n+    text-overflow: ellipsis;\n+    overflow: hidden;\n+    line-height: 15px;\n+}\n \n .content {\n     background: #f3f3f3;"}, {"sha": "09ce8f0097ea663003f26715f80b6d30b5c70f05", "filename": "src/test/auxiliary/issue-9906.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c6337f2099f4364f6a030153fa7bf55daf9f3680/src%2Ftest%2Fauxiliary%2Fissue-9906.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6337f2099f4364f6a030153fa7bf55daf9f3680/src%2Ftest%2Fauxiliary%2Fissue-9906.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-9906.rs?ref=c6337f2099f4364f6a030153fa7bf55daf9f3680", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-fast windows doesn't like extern mod\n+// aux-build:issue-9906.rs\n+\n+pub use other::FooBar;\n+pub use other::foo;\n+\n+mod other {\n+    pub struct FooBar{value: int}\n+    impl FooBar{\n+        pub fn new(val: int) -> FooBar {\n+            FooBar{value: val}\n+        }\n+    }\n+\n+    pub fn foo(){\n+        1+1;\n+    }\n+}"}, {"sha": "d04d761e112560250daea6293025e02eb8863201", "filename": "src/test/auxiliary/issue-9968.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c6337f2099f4364f6a030153fa7bf55daf9f3680/src%2Ftest%2Fauxiliary%2Fissue-9968.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6337f2099f4364f6a030153fa7bf55daf9f3680/src%2Ftest%2Fauxiliary%2Fissue-9968.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-9968.rs?ref=c6337f2099f4364f6a030153fa7bf55daf9f3680", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use internal::core::{Trait, Struct};\n+\n+mod internal {\n+    pub mod core {\n+        pub struct Struct;\n+        impl Struct {\n+            pub fn init() -> Struct {\n+                Struct\n+            }\n+        }\n+\n+        pub trait Trait {\n+            fn test(&self) {\n+                private();\n+            }\n+        }\n+\n+        impl Trait for Struct {}\n+\n+        fn private() { }\n+    }\n+}"}, {"sha": "287000d2fb1d42d1f42a215281a6eb1db1dd063c", "filename": "src/test/run-pass/issue-9906.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c6337f2099f4364f6a030153fa7bf55daf9f3680/src%2Ftest%2Frun-pass%2Fissue-9906.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6337f2099f4364f6a030153fa7bf55daf9f3680/src%2Ftest%2Frun-pass%2Fissue-9906.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9906.rs?ref=c6337f2099f4364f6a030153fa7bf55daf9f3680", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-fast windows doesn't like extern mod\n+// aux-build:issue-9906.rs\n+\n+extern mod testmod(name = \"issue-9906\");\n+\n+fn main() {\n+    testmod::foo();\n+    testmod::FooBar::new(1);\n+}"}, {"sha": "70338bd0f32b4d80e760b70291fc7e16f5c0504c", "filename": "src/test/run-pass/issue-9968.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c6337f2099f4364f6a030153fa7bf55daf9f3680/src%2Ftest%2Frun-pass%2Fissue-9968.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6337f2099f4364f6a030153fa7bf55daf9f3680/src%2Ftest%2Frun-pass%2Fissue-9968.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9968.rs?ref=c6337f2099f4364f6a030153fa7bf55daf9f3680", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-fast windows doesn't like extern mod\n+// aux-build:issue-9968.rs\n+\n+extern mod lib(name = \"issue-9968\");\n+\n+use lib::{Trait, Struct};\n+\n+fn main()\n+{\n+    Struct::init().test();\n+}"}]}