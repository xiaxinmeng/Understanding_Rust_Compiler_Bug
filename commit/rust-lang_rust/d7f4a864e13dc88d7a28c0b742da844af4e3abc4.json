{"sha": "d7f4a864e13dc88d7a28c0b742da844af4e3abc4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3ZjRhODY0ZTEzZGM4OGQ3YTI4YzBiNzQyZGE4NDRhZjRlM2FiYzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-08T12:29:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-08T12:29:57Z"}, "message": "Auto merge of #60246 - Zoxc:hir-map-vec, r=eddyb\n\nOptimize HIR map\n\nBuilds on https://github.com/rust-lang/rust/pull/59042\n\ncc @ljedrz\nr? @eddyb", "tree": {"sha": "a2554850fb607965f3d628c584f623a761a22b24", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a2554850fb607965f3d628c584f623a761a22b24"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7f4a864e13dc88d7a28c0b742da844af4e3abc4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7f4a864e13dc88d7a28c0b742da844af4e3abc4", "html_url": "https://github.com/rust-lang/rust/commit/d7f4a864e13dc88d7a28c0b742da844af4e3abc4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7f4a864e13dc88d7a28c0b742da844af4e3abc4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b92d360c6cf029bd98c154cb510ec9e11b39bad6", "url": "https://api.github.com/repos/rust-lang/rust/commits/b92d360c6cf029bd98c154cb510ec9e11b39bad6", "html_url": "https://github.com/rust-lang/rust/commit/b92d360c6cf029bd98c154cb510ec9e11b39bad6"}, {"sha": "d33db6ed570a38fa52d8fdf29dbad9a5cdf4c44d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d33db6ed570a38fa52d8fdf29dbad9a5cdf4c44d", "html_url": "https://github.com/rust-lang/rust/commit/d33db6ed570a38fa52d8fdf29dbad9a5cdf4c44d"}], "stats": {"total": 162, "additions": 102, "deletions": 60}, "files": [{"sha": "136d683e76b483abc2af87c4d7a7fa02d957ebb9", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d7f4a864e13dc88d7a28c0b742da844af4e3abc4/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f4a864e13dc88d7a28c0b742da844af4e3abc4/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=d7f4a864e13dc88d7a28c0b742da844af4e3abc4", "patch": "@@ -1,9 +1,11 @@\n use super::*;\n use crate::dep_graph::{DepGraph, DepKind, DepNodeIndex};\n use crate::hir;\n+use crate::hir::map::HirEntryMap;\n use crate::hir::def_id::{LOCAL_CRATE, CrateNum};\n use crate::hir::intravisit::{Visitor, NestedVisitorMap};\n use rustc_data_structures::svh::Svh;\n+use rustc_data_structures::indexed_vec::IndexVec;\n use crate::ich::Fingerprint;\n use crate::middle::cstore::CrateStore;\n use crate::session::CrateDisambiguator;\n@@ -12,6 +14,7 @@ use crate::util::nodemap::FxHashMap;\n use syntax::ast::NodeId;\n use syntax::source_map::SourceMap;\n use syntax_pos::Span;\n+use std::iter::repeat;\n \n use crate::ich::StableHashingContext;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n@@ -25,7 +28,7 @@ pub(super) struct NodeCollector<'a, 'hir> {\n     source_map: &'a SourceMap,\n \n     /// The node map\n-    map: FxHashMap<HirId, Entry<'hir>>,\n+    map: HirEntryMap<'hir>,\n     /// The parent of this node\n     parent_node: hir::HirId,\n \n@@ -142,11 +145,15 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             );\n         }\n \n+        let (lo, hi) = definitions.def_index_counts_lo_hi();\n+\n         let mut collector = NodeCollector {\n             krate,\n             source_map: sess.source_map(),\n-            map: FxHashMap::with_capacity_and_hasher(sess.current_node_id_count(),\n-                Default::default()),\n+            map: [\n+                repeat(None).take(lo).collect(),\n+                repeat(None).take(hi).collect(),\n+            ],\n             parent_node: hir::CRATE_HIR_ID,\n             current_signature_dep_index: root_mod_sig_dep_index,\n             current_full_dep_index: root_mod_full_dep_index,\n@@ -171,7 +178,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n                                                   crate_disambiguator: CrateDisambiguator,\n                                                   cstore: &dyn CrateStore,\n                                                   commandline_args_hash: u64)\n-                                                  -> (FxHashMap<HirId, Entry<'hir>>, Svh)\n+                                                  -> (HirEntryMap<'hir>, Svh)\n     {\n         self.hir_body_nodes.sort_unstable_by_key(|bn| bn.0);\n \n@@ -224,7 +231,17 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n \n     fn insert_entry(&mut self, id: HirId, entry: Entry<'hir>) {\n         debug!(\"hir_map: {:?} => {:?}\", id, entry);\n-        self.map.insert(id, entry);\n+        let local_map = &mut self.map[id.owner.address_space().index()][id.owner.as_array_index()];\n+        let i = id.local_id.as_u32() as usize;\n+        if local_map.is_none() {\n+            *local_map = Some(IndexVec::with_capacity(i + 1));\n+        }\n+        let local_map = local_map.as_mut().unwrap();\n+        let len = local_map.len();\n+        if i >= len {\n+            local_map.extend(repeat(None).take(i - len + 1));\n+        }\n+        local_map[id.local_id] = Some(entry);\n     }\n \n     fn insert(&mut self, span: Span, hir_id: HirId, node: Node<'hir>) {"}, {"sha": "c2b513a39a8b7b520bc0f8e325dcde04eca3f6e6", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 73, "deletions": 47, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/d7f4a864e13dc88d7a28c0b742da844af4e3abc4/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f4a864e13dc88d7a28c0b742da844af4e3abc4/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=d7f4a864e13dc88d7a28c0b742da844af4e3abc4", "patch": "@@ -11,6 +11,7 @@ use crate::middle::cstore::CrateStoreDyn;\n \n use rustc_target::spec::abi::Abi;\n use rustc_data_structures::svh::Svh;\n+use rustc_data_structures::indexed_vec::IndexVec;\n use syntax::ast::{self, Name, NodeId};\n use syntax::source_map::Spanned;\n use syntax::ext::base::MacroKind;\n@@ -161,6 +162,13 @@ impl Forest {\n     }\n }\n \n+/// This type is effectively a `HashMap<HirId, Entry<'hir>>`,\n+/// but is implemented by 3 layers of arrays.\n+/// - the outer layer is `[A; 2]` and correspond to the 2 address spaces `DefIndex`es can be in\n+/// - then we have `A = Vec<Option<B>>` mapping a `DefIndex`'s index to a inner value\n+/// - which is `B = IndexVec<ItemLocalId, Option<Entry<'hir>>` which finally gives you the `Entry`.\n+pub(super) type HirEntryMap<'hir> = [Vec<Option<IndexVec<ItemLocalId, Option<Entry<'hir>>>>>; 2];\n+\n /// Represents a mapping from `NodeId`s to AST elements and their parent `NodeId`s.\n #[derive(Clone)]\n pub struct Map<'hir> {\n@@ -174,7 +182,7 @@ pub struct Map<'hir> {\n     /// The SVH of the local crate.\n     pub crate_hash: Svh,\n \n-    map: FxHashMap<HirId, Entry<'hir>>,\n+    map: HirEntryMap<'hir>,\n \n     definitions: &'hir Definitions,\n \n@@ -183,6 +191,12 @@ pub struct Map<'hir> {\n }\n \n impl<'hir> Map<'hir> {\n+    #[inline]\n+    fn lookup(&self, id: HirId) -> Option<&Entry<'hir>> {\n+        let local_map = self.map[id.owner.address_space().index()].get(id.owner.as_array_index())?;\n+        local_map.as_ref()?.get(id.local_id)?.as_ref()\n+    }\n+\n     /// Registers a read in the dependency graph of the AST node with\n     /// the given `id`. This needs to be called each time a public\n     /// function returns the HIR for a node -- in other words, when it\n@@ -191,7 +205,7 @@ impl<'hir> Map<'hir> {\n     /// read recorded). If the function just returns a DefId or\n     /// NodeId, no actual content was returned, so no read is needed.\n     pub fn read(&self, hir_id: HirId) {\n-        if let Some(entry) = self.map.get(&hir_id) {\n+        if let Some(entry) = self.lookup(hir_id) {\n             self.dep_graph.read_index(entry.dep_node);\n         } else {\n             bug!(\"called `HirMap::read()` with invalid `HirId`: {:?}\", hir_id)\n@@ -378,12 +392,8 @@ impl<'hir> Map<'hir> {\n         })\n     }\n \n-    fn entry_count(&self) -> usize {\n-        self.map.len()\n-    }\n-\n     fn find_entry(&self, id: HirId) -> Option<Entry<'hir>> {\n-        self.map.get(&id).cloned()\n+        self.lookup(id).cloned()\n     }\n \n     pub fn krate(&self) -> &'hir Crate {\n@@ -433,7 +443,7 @@ impl<'hir> Map<'hir> {\n     /// item (possibly associated), a closure, or a `hir::AnonConst`.\n     pub fn body_owner(&self, BodyId { hir_id }: BodyId) -> NodeId {\n         let parent = self.get_parent_node_by_hir_id(hir_id);\n-        assert!(self.map.get(&parent).map_or(false, |e| e.is_body_owner(hir_id)));\n+        assert!(self.lookup(parent).map_or(false, |e| e.is_body_owner(hir_id)));\n         self.hir_to_node_id(parent)\n     }\n \n@@ -1004,6 +1014,34 @@ impl<'hir> Map<'hir> {\n         attrs.unwrap_or(&[])\n     }\n \n+    /// Returns an iterator that yields all the hir ids in the map.\n+    fn all_ids<'a>(&'a self) -> impl Iterator<Item = HirId> + 'a {\n+        // This code is a bit awkward because the map is implemented as 3 levels of arrays,\n+        // see the comment on `HirEntryMap`.\n+        let map = &self.map;\n+\n+        // Look at both the def index address spaces\n+        let spaces = [DefIndexAddressSpace::Low, DefIndexAddressSpace::High].iter().cloned();\n+        spaces.flat_map(move |space| {\n+            // Iterate over all the indices in the address space and return a reference to\n+            // local maps and their index given that they exist.\n+            let local_maps = map[space.index()].iter().enumerate().filter_map(|(i, local_map)| {\n+                local_map.as_ref().map(|m| (i, m))\n+            });\n+\n+            local_maps.flat_map(move |(array_index, local_map)| {\n+                // Iterate over each valid entry in the local map\n+                local_map.iter_enumerated().filter_map(move |(i, entry)| entry.map(move |_| {\n+                    // Reconstruct the HirId based on the 3 indices we used to find it\n+                    HirId {\n+                        owner: DefIndex::from_array_index(array_index, space),\n+                        local_id: i,\n+                    }\n+                }))\n+            })\n+        })\n+    }\n+\n     /// Returns an iterator that yields the node id's with paths that\n     /// match `parts`.  (Requires `parts` is non-empty.)\n     ///\n@@ -1012,13 +1050,16 @@ impl<'hir> Map<'hir> {\n     /// such as `foo::bar::quux`, `bar::quux`, `other::bar::quux`, and\n     /// any other such items it can find in the map.\n     pub fn nodes_matching_suffix<'a>(&'a self, parts: &'a [String])\n-                                 -> NodesMatchingSuffix<'a, 'hir> {\n-        NodesMatchingSuffix {\n+                                 -> impl Iterator<Item = NodeId> + 'a {\n+        let nodes = NodesMatchingSuffix {\n             map: self,\n             item_name: parts.last().unwrap(),\n             in_which: &parts[..parts.len() - 1],\n-            idx: ast::CRATE_NODE_ID,\n-        }\n+        };\n+\n+        self.all_ids().filter(move |hir| nodes.matces_suffix(*hir)).map(move |hir| {\n+            self.hir_to_node_id(hir)\n+        })\n     }\n \n     pub fn span(&self, id: NodeId) -> Span {\n@@ -1097,21 +1138,20 @@ impl<'hir> Map<'hir> {\n     }\n }\n \n-pub struct NodesMatchingSuffix<'a, 'hir:'a> {\n-    map: &'a Map<'hir>,\n+pub struct NodesMatchingSuffix<'a> {\n+    map: &'a Map<'a>,\n     item_name: &'a String,\n     in_which: &'a [String],\n-    idx: NodeId,\n }\n \n-impl<'a, 'hir> NodesMatchingSuffix<'a, 'hir> {\n+impl<'a> NodesMatchingSuffix<'a> {\n     /// Returns `true` only if some suffix of the module path for parent\n     /// matches `self.in_which`.\n     ///\n     /// In other words: let `[x_0,x_1,...,x_k]` be `self.in_which`;\n     /// returns true if parent's path ends with the suffix\n     /// `x_0::x_1::...::x_k`.\n-    fn suffix_matches(&self, parent: NodeId) -> bool {\n+    fn suffix_matches(&self, parent: HirId) -> bool {\n         let mut cursor = parent;\n         for part in self.in_which.iter().rev() {\n             let (mod_id, mod_name) = match find_first_mod_parent(self.map, cursor) {\n@@ -1121,7 +1161,7 @@ impl<'a, 'hir> NodesMatchingSuffix<'a, 'hir> {\n             if mod_name != &**part {\n                 return false;\n             }\n-            cursor = self.map.get_parent(mod_id);\n+            cursor = self.map.get_parent_item(mod_id);\n         }\n         return true;\n \n@@ -1131,14 +1171,14 @@ impl<'a, 'hir> NodesMatchingSuffix<'a, 'hir> {\n         // If `id` itself is a mod named `m` with parent `p`, then\n         // returns `Some(id, m, p)`.  If `id` has no mod in its parent\n         // chain, then returns `None`.\n-        fn find_first_mod_parent<'a>(map: &'a Map<'_>, mut id: NodeId) -> Option<(NodeId, Name)> {\n+        fn find_first_mod_parent<'a>(map: &'a Map<'_>, mut id: HirId) -> Option<(HirId, Name)> {\n             loop {\n-                if let Node::Item(item) = map.find(id)? {\n+                if let Node::Item(item) = map.find_by_hir_id(id)? {\n                     if item_is_mod(&item) {\n                         return Some((id, item.ident.name))\n                     }\n                 }\n-                let parent = map.get_parent(id);\n+                let parent = map.get_parent_item(id);\n                 if parent == id { return None }\n                 id = parent;\n             }\n@@ -1154,35 +1194,21 @@ impl<'a, 'hir> NodesMatchingSuffix<'a, 'hir> {\n \n     // We are looking at some node `n` with a given name and parent\n     // id; do their names match what I am seeking?\n-    fn matches_names(&self, parent_of_n: NodeId, name: Name) -> bool {\n+    fn matches_names(&self, parent_of_n: HirId, name: Name) -> bool {\n         name == &**self.item_name && self.suffix_matches(parent_of_n)\n     }\n-}\n \n-impl<'a, 'hir> Iterator for NodesMatchingSuffix<'a, 'hir> {\n-    type Item = NodeId;\n-\n-    fn next(&mut self) -> Option<NodeId> {\n-        loop {\n-            let idx = self.idx;\n-            if idx.as_usize() >= self.map.entry_count() {\n-                return None;\n-            }\n-            self.idx = NodeId::from_u32(self.idx.as_u32() + 1);\n-            let hir_idx = self.map.node_to_hir_id(idx);\n-            let name = match self.map.find_entry(hir_idx).map(|entry| entry.node) {\n-                Some(Node::Item(n)) => n.name(),\n-                Some(Node::ForeignItem(n)) => n.name(),\n-                Some(Node::TraitItem(n)) => n.name(),\n-                Some(Node::ImplItem(n)) => n.name(),\n-                Some(Node::Variant(n)) => n.name(),\n-                Some(Node::Field(n)) => n.name(),\n-                _ => continue,\n-            };\n-            if self.matches_names(self.map.get_parent(idx), name) {\n-                return Some(idx)\n-            }\n-        }\n+    fn matces_suffix(&self, hir: HirId) -> bool {\n+        let name = match self.map.find_entry(hir).map(|entry| entry.node) {\n+            Some(Node::Item(n)) => n.name(),\n+            Some(Node::ForeignItem(n)) => n.name(),\n+            Some(Node::TraitItem(n)) => n.name(),\n+            Some(Node::ImplItem(n)) => n.name(),\n+            Some(Node::Variant(n)) => n.name(),\n+            Some(Node::Field(n)) => n.name(),\n+            _ => return false,\n+        };\n+        self.matches_names(self.map.get_parent_item(hir), name)\n     }\n }\n "}, {"sha": "e8c7965ab4f45835c196bdff7909b22b7d3ee480", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d7f4a864e13dc88d7a28c0b742da844af4e3abc4/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f4a864e13dc88d7a28c0b742da844af4e3abc4/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=d7f4a864e13dc88d7a28c0b742da844af4e3abc4", "patch": "@@ -408,9 +408,6 @@ impl Session {\n     pub fn next_node_id(&self) -> NodeId {\n         self.reserve_node_ids(1)\n     }\n-    pub(crate) fn current_node_id_count(&self) -> usize {\n-        self.next_node_id.get().as_u32() as usize\n-    }\n     pub fn diagnostic<'a>(&'a self) -> &'a errors::Handler {\n         &self.parse_sess.span_diagnostic\n     }"}, {"sha": "a339ec30a74f8b262a1ca9b402bfa060967937ad", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d7f4a864e13dc88d7a28c0b742da844af4e3abc4/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7f4a864e13dc88d7a28c0b742da844af4e3abc4/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=d7f4a864e13dc88d7a28c0b742da844af4e3abc4", "patch": "@@ -543,12 +543,12 @@ impl FromStr for UserIdentifiedItem {\n     }\n }\n \n-enum NodesMatchingUII<'a, 'hir: 'a> {\n+enum NodesMatchingUII<'a> {\n     NodesMatchingDirect(option::IntoIter<ast::NodeId>),\n-    NodesMatchingSuffix(hir_map::NodesMatchingSuffix<'a, 'hir>),\n+    NodesMatchingSuffix(Box<dyn Iterator<Item = ast::NodeId> + 'a>),\n }\n \n-impl<'a, 'hir> Iterator for NodesMatchingUII<'a, 'hir> {\n+impl<'a> Iterator for NodesMatchingUII<'a> {\n     type Item = ast::NodeId;\n \n     fn next(&mut self) -> Option<ast::NodeId> {\n@@ -576,10 +576,12 @@ impl UserIdentifiedItem {\n \n     fn all_matching_node_ids<'a, 'hir>(&'a self,\n                                        map: &'a hir_map::Map<'hir>)\n-                                       -> NodesMatchingUII<'a, 'hir> {\n+                                       -> NodesMatchingUII<'a> {\n         match *self {\n             ItemViaNode(node_id) => NodesMatchingDirect(Some(node_id).into_iter()),\n-            ItemViaPath(ref parts) => NodesMatchingSuffix(map.nodes_matching_suffix(&parts)),\n+            ItemViaPath(ref parts) => {\n+                NodesMatchingSuffix(Box::new(map.nodes_matching_suffix(&parts)))\n+            }\n         }\n     }\n "}]}