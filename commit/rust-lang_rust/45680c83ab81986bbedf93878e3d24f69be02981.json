{"sha": "45680c83ab81986bbedf93878e3d24f69be02981", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1NjgwYzgzYWI4MTk4NmJiZWRmOTM4NzhlM2QyNGY2OWJlMDI5ODE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-06-03T14:36:40Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-06-07T01:37:04Z"}, "message": "borrowck changes: some copies, some removed mut annotations, some dvec", "tree": {"sha": "0d8c148de99248e4f385e2cb6e552c8a8ebbeecc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d8c148de99248e4f385e2cb6e552c8a8ebbeecc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45680c83ab81986bbedf93878e3d24f69be02981", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45680c83ab81986bbedf93878e3d24f69be02981", "html_url": "https://github.com/rust-lang/rust/commit/45680c83ab81986bbedf93878e3d24f69be02981", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45680c83ab81986bbedf93878e3d24f69be02981/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3b266f50f5f7a05761a06fbe30c14451e86ca31", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3b266f50f5f7a05761a06fbe30c14451e86ca31", "html_url": "https://github.com/rust-lang/rust/commit/c3b266f50f5f7a05761a06fbe30c14451e86ca31"}], "stats": {"total": 82, "additions": 42, "deletions": 40}, "files": [{"sha": "764c484c8e39bd243978999e55deef2d8b4cf4eb", "filename": "src/libsyntax/ext/simplext.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/45680c83ab81986bbedf93878e3d24f69be02981/src%2Flibsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45680c83ab81986bbedf93878e3d24f69be02981/src%2Flibsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsimplext.rs?ref=45680c83ab81986bbedf93878e3d24f69be02981", "patch": "@@ -1,5 +1,6 @@\n import codemap::span;\n import std::map::{hashmap, str_hash};\n+import dvec::{dvec, extensions};\n \n import base::*;\n \n@@ -134,7 +135,7 @@ fn compose_sels(s1: selector, s2: selector) -> selector {\n \n type binders =\n     {real_binders: hashmap<ident, selector>,\n-     mut literal_ast_matchers: [selector]};\n+     literal_ast_matchers: dvec<selector>};\n type bindings = hashmap<ident, arb_depth<matchable>>;\n \n fn acumm_bindings(_cx: ext_ctxt, _b_dest: bindings, _b_src: bindings) { }\n@@ -146,7 +147,7 @@ fn acumm_bindings(_cx: ext_ctxt, _b_dest: bindings, _b_src: bindings) { }\n fn pattern_to_selectors(cx: ext_ctxt, e: @expr) -> binders {\n     let res: binders =\n         {real_binders: str_hash::<selector>(),\n-         mut literal_ast_matchers: []};\n+         literal_ast_matchers: dvec()};\n     //this oughta return binders instead, but macro args are a sequence of\n     //expressions, rather than a single expression\n     fn trivial_selector(m: matchable) -> match_result { ret some(leaf(m)); }\n@@ -474,7 +475,7 @@ fn p_t_s_rec(cx: ext_ctxt, m: matchable, s: selector, b: binders) {\n                       _ { cx.bug(\"broken traversal in p_t_s_r\") }\n                     }\n             }\n-            b.literal_ast_matchers += [bind select(cx, _, e)];\n+            b.literal_ast_matchers.push(bind select(cx, _, e));\n           }\n         }\n       }\n@@ -640,8 +641,8 @@ fn p_t_s_r_length(cx: ext_ctxt, len: uint, at_least: bool, s: selector,\n               _ { none }\n             }\n     }\n-    b.literal_ast_matchers +=\n-        [compose_sels(s, bind len_select(cx, _, at_least, len))];\n+    b.literal_ast_matchers.push(\n+        compose_sels(s, bind len_select(cx, _, at_least, len)));\n }\n \n fn p_t_s_r_actual_vector(cx: ext_ctxt, elts: [@expr], _repeat_after: bool,"}, {"sha": "05e14c4654df02720532be531b756d58f7c94721", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/45680c83ab81986bbedf93878e3d24f69be02981/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45680c83ab81986bbedf93878e3d24f69be02981/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=45680c83ab81986bbedf93878e3d24f69be02981", "patch": "@@ -18,7 +18,7 @@ fn seq_sep_none() -> seq_sep {\n }\n \n \n-fn token_to_str(reader: reader, token: token::token) -> str {\n+fn token_to_str(reader: reader, ++token: token::token) -> str {\n     token::to_str(*reader.interner, token)\n }\n \n@@ -27,8 +27,9 @@ fn token_to_str(reader: reader, token: token::token) -> str {\n impl parser_common for parser {\n \n     fn unexpected_last(t: token::token) -> ! {\n-        self.span_fatal(self.last_span, \"unexpected token: '\"\n-                        + token_to_str(self.reader, t) + \"'\");\n+        self.span_fatal(\n+            copy self.last_span,\n+            \"unexpected token: '\" + token_to_str(self.reader, t) + \"'\");\n     }\n \n     fn unexpected() -> ! {\n@@ -49,7 +50,7 @@ impl parser_common for parser {\n     }\n \n     fn parse_ident() -> ast::ident {\n-        alt self.token {\n+        alt copy self.token {\n           token::IDENT(i, _) { self.bump(); ret self.get_str(i); }\n           _ { self.fatal(\"expecting ident, found \"\n                       + token_to_str(self.reader, self.token)); }\n@@ -79,7 +80,7 @@ impl parser_common for parser {\n         }\n     }\n \n-    fn token_is_keyword(word: str, tok: token::token) -> bool {\n+    fn token_is_keyword(word: str, ++tok: token::token) -> bool {\n         self.require_keyword(word);\n         alt tok {\n           token::IDENT(sid, false) { str::eq(word, self.get_str(sid)) }\n@@ -93,7 +94,7 @@ impl parser_common for parser {\n \n     fn eat_keyword(word: str) -> bool {\n         self.require_keyword(word);\n-        alt self.token {\n+        alt copy self.token {\n           token::IDENT(sid, false) {\n             if str::eq(word, self.get_str(sid)) {\n                 self.bump();"}, {"sha": "33e7d082bfb0b4f66dbec338e5342b73b7759dfd", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/45680c83ab81986bbedf93878e3d24f69be02981/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45680c83ab81986bbedf93878e3d24f69be02981/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=45680c83ab81986bbedf93878e3d24f69be02981", "patch": "@@ -121,16 +121,16 @@ class parser {\n         ret self.buffer[distance - 1u].tok;\n     }\n     fn fatal(m: str) -> ! {\n-        self.sess.span_diagnostic.span_fatal(self.span, m)\n+        self.sess.span_diagnostic.span_fatal(copy self.span, m)\n     }\n     fn span_fatal(sp: span, m: str) -> ! {\n         self.sess.span_diagnostic.span_fatal(sp, m)\n     }\n     fn bug(m: str) -> ! {\n-        self.sess.span_diagnostic.span_bug(self.span, m)\n+        self.sess.span_diagnostic.span_bug(copy self.span, m)\n     }\n     fn warn(m: str) {\n-        self.sess.span_diagnostic.span_warn(self.span, m)\n+        self.sess.span_diagnostic.span_warn(copy self.span, m)\n     }\n     fn get_str(i: token::str_num) -> str {\n         interner::get(*self.reader.interner, i)\n@@ -307,7 +307,7 @@ class parser {\n     // Parses something like \"&x\"\n     fn parse_region() -> @region {\n         self.expect(token::BINOP(token::AND));\n-        alt self.token {\n+        alt copy self.token {\n           token::IDENT(sid, _) {\n             self.bump();\n             let n = self.get_str(sid);\n@@ -322,7 +322,7 @@ class parser {\n     // Parses something like \"&x.\" (note the trailing dot)\n     fn parse_region_dot() -> @region {\n         let name =\n-            alt self.token {\n+            alt copy self.token {\n               token::IDENT(sid, _) if self.look_ahead(1u) == token::DOT {\n                 self.bump(); self.bump();\n                 some(self.get_str(sid))\n@@ -483,11 +483,11 @@ class parser {\n     }\n \n     fn maybe_parse_dollar_mac() -> option<mac_> {\n-        alt self.token {\n+        alt copy self.token {\n           token::DOLLAR {\n             let lo = self.span.lo;\n             self.bump();\n-            alt self.token {\n+            alt copy self.token {\n               token::LIT_INT(num, ty_i) {\n                 self.bump();\n                 some(mac_var(num as uint))\n@@ -511,7 +511,7 @@ class parser {\n     fn maybe_parse_vstore() -> option<vstore> {\n         if self.token == token::BINOP(token::SLASH) {\n             self.bump();\n-            alt self.token {\n+            alt copy self.token {\n               token::AT {\n                 self.bump(); some(vstore_box)\n               }\n@@ -968,7 +968,7 @@ class parser {\n         loop {\n             // expr.f\n             if self.eat(token::DOT) {\n-                alt self.token {\n+                alt copy self.token {\n                   token::IDENT(i, _) {\n                     hi = self.span.hi;\n                     self.bump();\n@@ -986,7 +986,7 @@ class parser {\n                 cont;\n             }\n             if self.expr_is_complete(e) { break; }\n-            alt self.token {\n+            alt copy self.token {\n               // expr(...)\n               token::LPAREN if self.permits_call() {\n                 let es_opt = self.parse_seq(token::LPAREN, token::RPAREN,\n@@ -1042,7 +1042,7 @@ class parser {\n         let mut hi;\n \n         let mut ex;\n-        alt self.token {\n+        alt copy self.token {\n           token::NOT {\n             self.bump();\n             let e = self.to_expr(self.parse_prefix_expr());\n@@ -1134,7 +1134,7 @@ class parser {\n     fn parse_assign_expr() -> @expr {\n         let lo = self.span.lo;\n         let lhs = self.parse_binops();\n-        alt self.token {\n+        alt copy self.token {\n           token::EQ {\n             self.bump();\n             let rhs = self.parse_expr();\n@@ -1831,7 +1831,7 @@ class parser {\n     }\n \n     fn parse_method_name() -> ident {\n-        alt self.token {\n+        alt copy self.token {\n           token::BINOP(op) { self.bump(); token::binop_to_str(op) }\n           token::NOT { self.bump(); \"!\" }\n           token::LBRACKET { self.bump(); self.expect(token::RBRACKET); \"[]\" }\n@@ -2375,7 +2375,7 @@ class parser {\n             while self.token == token::MOD_SEP {\n                 self.bump();\n \n-                alt self.token {\n+                alt copy self.token {\n \n                   token::IDENT(i, _) {\n                     self.bump();\n@@ -2477,7 +2477,7 @@ class parser {\n     }\n \n     fn parse_str() -> str {\n-        alt self.token {\n+        alt copy self.token {\n           token::LIT_STR(s) { self.bump(); self.get_str(s) }\n           _ {\n             self.fatal(\"expected string literal\")"}, {"sha": "329dff0c4c1b14fe99e601c9ff4dc266265b9275", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/45680c83ab81986bbedf93878e3d24f69be02981/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45680c83ab81986bbedf93878e3d24f69be02981/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=45680c83ab81986bbedf93878e3d24f69be02981", "patch": "@@ -59,11 +59,11 @@ type break_t = {offset: int, blank_space: int};\n \n type begin_t = {offset: int, breaks: breaks};\n \n-enum token { STRING(str, int), BREAK(break_t), BEGIN(begin_t), END, EOF, }\n+enum token { STRING(@str, int), BREAK(break_t), BEGIN(begin_t), END, EOF, }\n \n-fn tok_str(t: token) -> str {\n+fn tok_str(++t: token) -> str {\n     alt t {\n-      STRING(s, len) { ret #fmt[\"STR(%s,%d)\", s, len]; }\n+      STRING(s, len) { ret #fmt[\"STR(%s,%d)\", *s, len]; }\n       BREAK(_) { ret \"BREAK\"; }\n       BEGIN(_) { ret \"BEGIN\"; }\n       END { ret \"END\"; }\n@@ -109,8 +109,8 @@ fn mk_printer(out: io::writer, linewidth: uint) -> printer {\n       mut space: linewidth as int,\n       mut left: 0u,\n       mut right: 0u,\n-      mut token: token,\n-      mut size: size,\n+      token: token,\n+      size: size,\n       mut left_total: 0,\n       mut right_total: 0,\n       mut scan_stack: scan_stack,\n@@ -206,8 +206,8 @@ type printer = @{\n     mut space: int, // number of spaces left on line\n     mut left: uint, // index of left side of input stream\n     mut right: uint, // index of right side of input stream\n-    mut token: [mut token], // ring-buffr stream goes through\n-    mut size: [mut int], // ring-buffer of calculated sizes\n+    token: [mut token], // ring-buffr stream goes through\n+    size: [mut int], // ring-buffer of calculated sizes\n     mut left_total: int, // running size of stream \"...left\"\n     mut right_total: int, // running size of stream \"...right\"\n     // pseudo-stack, really a ring too. Holds the\n@@ -346,7 +346,7 @@ impl printer for printer {\n         self.right %= self.buf_len;\n         assert (self.right != self.left);\n     }\n-    fn advance_left(x: token, L: int) {\n+    fn advance_left(++x: token, L: int) {\n         #debug(\"advnce_left [%u,%u], sizeof(%u)=%d\", self.left, self.right,\n                self.left, L);\n         if L >= 0 {\n@@ -367,7 +367,7 @@ impl printer for printer {\n     fn check_stack(k: int) {\n         if !self.scan_stack_empty {\n             let x = self.scan_top();\n-            alt self.token[x] {\n+            alt copy self.token[x] {\n               BEGIN(b) {\n                 if k > 0 {\n                     self.size[self.scan_pop()] = self.size[x] +\n@@ -465,7 +465,7 @@ impl printer for printer {\n             assert (L == len);\n             // assert L <= space;\n             self.space -= len;\n-            self.write_str(s);\n+            self.write_str(*s);\n           }\n           EOF {\n             // EOF should never get here.\n@@ -493,14 +493,14 @@ fn end(p: printer) { p.pretty_print(END); }\n fn eof(p: printer) { p.pretty_print(EOF); }\n \n fn word(p: printer, wrd: str) {\n-    p.pretty_print(STRING(wrd, str::len(wrd) as int));\n+    p.pretty_print(STRING(@wrd, str::len(wrd) as int));\n }\n \n fn huge_word(p: printer, wrd: str) {\n-    p.pretty_print(STRING(wrd, size_infinity));\n+    p.pretty_print(STRING(@wrd, size_infinity));\n }\n \n-fn zero_word(p: printer, wrd: str) { p.pretty_print(STRING(wrd, 0)); }\n+fn zero_word(p: printer, wrd: str) { p.pretty_print(STRING(@wrd, 0)); }\n \n fn spaces(p: printer, n: uint) { break_offset(p, n, 0); }\n "}, {"sha": "a8df8d85092b82fe8c9def425535f7da06be73ac", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45680c83ab81986bbedf93878e3d24f69be02981/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45680c83ab81986bbedf93878e3d24f69be02981/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=45680c83ab81986bbedf93878e3d24f69be02981", "patch": "@@ -1703,7 +1703,7 @@ fn print_comment(s: ps, cmnt: comments::cmnt) {\n         // We need to do at least one, possibly two hardbreaks.\n         let is_semi =\n             alt s.s.last_token() {\n-              pp::STRING(s, _) { s == \";\" }\n+              pp::STRING(s, _) { *s == \";\" }\n               _ { false }\n             };\n         if is_semi || is_begin(s) || is_end(s) { hardbreak(s.s); }"}]}