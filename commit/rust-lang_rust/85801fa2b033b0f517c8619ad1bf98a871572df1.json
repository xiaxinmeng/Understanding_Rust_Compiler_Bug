{"sha": "85801fa2b033b0f517c8619ad1bf98a871572df1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1ODAxZmEyYjAzM2IwZjUxN2M4NjE5YWQxYmY5OGE4NzE1NzJkZjE=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-11-19T08:10:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-19T08:10:02Z"}, "message": "Merge pull request #87 from oli-obk/no_u_size_is_wong\n\nreplace most uses of `usize` with `u64`", "tree": {"sha": "2d251f4bddaf53f41f03ab960b5e0d9dcdb39323", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d251f4bddaf53f41f03ab960b5e0d9dcdb39323"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85801fa2b033b0f517c8619ad1bf98a871572df1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85801fa2b033b0f517c8619ad1bf98a871572df1", "html_url": "https://github.com/rust-lang/rust/commit/85801fa2b033b0f517c8619ad1bf98a871572df1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85801fa2b033b0f517c8619ad1bf98a871572df1/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b632d553e8c4590ea349a54254d9aacaea0f543", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b632d553e8c4590ea349a54254d9aacaea0f543", "html_url": "https://github.com/rust-lang/rust/commit/0b632d553e8c4590ea349a54254d9aacaea0f543"}, {"sha": "0039ebc9400af7575a1e11693e0e74007800062c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0039ebc9400af7575a1e11693e0e74007800062c", "html_url": "https://github.com/rust-lang/rust/commit/0039ebc9400af7575a1e11693e0e74007800062c"}], "stats": {"total": 381, "additions": 207, "deletions": 174}, "files": [{"sha": "96caa54468bd906d6e82e66b6f6e58d934ee535f", "filename": "src/bin/miri.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85801fa2b033b0f517c8619ad1bf98a871572df1/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85801fa2b033b0f517c8619ad1bf98a871572df1/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=85801fa2b033b0f517c8619ad1bf98a871572df1", "patch": "@@ -53,7 +53,7 @@ impl<'a> CompilerCalls<'a> for MiriCompilerCalls {\n                             NestedMetaItemKind::MetaItem(ref inner) => match inner.node {\n                                 MetaItemKind::NameValue(ref name, ref value) => {\n                                     match &**name {\n-                                        \"memory_size\" => memory_size = extract_int(value) as usize,\n+                                        \"memory_size\" => memory_size = extract_int(value),\n                                         \"step_limit\" => step_limit = extract_int(value),\n                                         \"stack_limit\" => stack_limit = extract_int(value) as usize,\n                                         _ => state.session.span_err(item.span, \"unknown miri attribute\"),"}, {"sha": "afc1855e8e75523f59245c47f38cdc2523dd63d5", "filename": "src/error.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/85801fa2b033b0f517c8619ad1bf98a871572df1/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85801fa2b033b0f517c8619ad1bf98a871572df1/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=85801fa2b033b0f517c8619ad1bf98a871572df1", "patch": "@@ -18,8 +18,8 @@ pub enum EvalError<'tcx> {\n     InvalidDiscriminant,\n     PointerOutOfBounds {\n         ptr: Pointer,\n-        size: usize,\n-        allocation_size: usize,\n+        size: u64,\n+        allocation_size: u64,\n     },\n     ReadPointerAsBytes,\n     InvalidPointerMath,\n@@ -32,15 +32,15 @@ pub enum EvalError<'tcx> {\n     Math(Span, ConstMathErr),\n     InvalidChar(u64),\n     OutOfMemory {\n-        allocation_size: usize,\n-        memory_size: usize,\n-        memory_usage: usize,\n+        allocation_size: u64,\n+        memory_size: u64,\n+        memory_usage: u64,\n     },\n     ExecutionTimeLimitReached,\n     StackFrameLimitReached,\n     AlignmentCheckFailed {\n-        required: usize,\n-        has: usize,\n+        required: u64,\n+        has: u64,\n     },\n     CalledClosureAsFunction,\n     VtableForArgumentlessMethod,"}, {"sha": "5bf5d26c228e9ed88c5a2bf7ff9013705962d790", "filename": "src/interpreter/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85801fa2b033b0f517c8619ad1bf98a871572df1/src%2Finterpreter%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85801fa2b033b0f517c8619ad1bf98a871572df1/src%2Finterpreter%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fcast.rs?ref=85801fa2b033b0f517c8619ad1bf98a871572df1", "patch": "@@ -67,7 +67,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             TyChar if v as u8 as u64 == v => Ok(PrimVal::new(v, Char)),\n             TyChar => Err(EvalError::InvalidChar(v)),\n \n-            TyRawPtr(_) => Ok(PrimVal::from_ptr(Pointer::from_int(v as usize))),\n+            TyRawPtr(_) => Ok(PrimVal::from_ptr(Pointer::from_int(v))),\n \n             _ => Err(EvalError::Unimplemented(format!(\"int to {:?} cast\", ty))),\n         }"}, {"sha": "abeea0790b84a698fb078271bea697cb0d4ef482", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/85801fa2b033b0f517c8619ad1bf98a871572df1/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85801fa2b033b0f517c8619ad1bf98a871572df1/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=85801fa2b033b0f517c8619ad1bf98a871572df1", "patch": "@@ -167,7 +167,7 @@ pub enum StackPopCleanup {\n }\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, memory_size: usize, stack_limit: usize, step_limit: u64) -> Self {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, memory_size: u64, stack_limit: usize, step_limit: u64) -> Self {\n         EvalContext {\n             tcx: tcx,\n             memory: Memory::new(&tcx.data_layout, memory_size),\n@@ -211,7 +211,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     fn str_to_value(&mut self, s: &str) -> EvalResult<'tcx, Value> {\n         // FIXME: cache these allocs\n-        let ptr = self.memory.allocate(s.len(), 1)?;\n+        let ptr = self.memory.allocate(s.len() as u64, 1)?;\n         self.memory.write_bytes(ptr, s.as_bytes())?;\n         self.memory.freeze(ptr.alloc_id)?;\n         Ok(Value::ByValPair(PrimVal::from_ptr(ptr), self.usize_primval(s.len() as u64)))\n@@ -255,7 +255,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Str(ref s) => return self.str_to_value(s),\n \n             ByteStr(ref bs) => {\n-                let ptr = self.memory.allocate(bs.len(), 1)?;\n+                let ptr = self.memory.allocate(bs.len() as u64, 1)?;\n                 self.memory.write_bytes(ptr, bs)?;\n                 self.memory.freeze(ptr.alloc_id)?;\n                 PrimVal::from_ptr(ptr)\n@@ -292,25 +292,25 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.tcx.normalize_associated_type(&substituted)\n     }\n \n-    fn type_size(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<usize>> {\n+    fn type_size(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<u64>> {\n         self.type_size_with_substs(ty, self.substs())\n     }\n \n-    fn type_align(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, usize> {\n+    fn type_align(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, u64> {\n         self.type_align_with_substs(ty, self.substs())\n     }\n \n-    fn type_size_with_substs(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> EvalResult<'tcx, Option<usize>> {\n+    fn type_size_with_substs(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> EvalResult<'tcx, Option<u64>> {\n         let layout = self.type_layout_with_substs(ty, substs)?;\n         if layout.is_unsized() {\n             Ok(None)\n         } else {\n-            Ok(Some(layout.size(&self.tcx.data_layout).bytes() as usize))\n+            Ok(Some(layout.size(&self.tcx.data_layout).bytes()))\n         }\n     }\n \n-    fn type_align_with_substs(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> EvalResult<'tcx, usize> {\n-        self.type_layout_with_substs(ty, substs).map(|layout| layout.align(&self.tcx.data_layout).abi() as usize)\n+    fn type_align_with_substs(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> EvalResult<'tcx, u64> {\n+        self.type_layout_with_substs(ty, substs).map(|layout| layout.align(&self.tcx.data_layout).abi())\n     }\n \n     fn type_layout(&self, ty: Ty<'tcx>) -> EvalResult<'tcx, &'tcx Layout> {\n@@ -464,7 +464,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         for (offset, operand) in offsets.into_iter().zip(operands) {\n             let value = self.eval_operand(operand)?;\n             let value_ty = self.operand_ty(operand);\n-            let field_dest = dest.offset(offset as isize);\n+            let field_dest = dest.offset(offset);\n             self.write_value_to_ptr(value, field_dest, value_ty)?;\n         }\n         Ok(())\n@@ -525,8 +525,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     General { discr, ref variants, .. } => {\n                         if let mir::AggregateKind::Adt(adt_def, variant, _, _) = *kind {\n                             let discr_val = adt_def.variants[variant].disr_val.to_u64_unchecked();\n-                            let discr_size = discr.size().bytes() as usize;\n-                            let discr_offset = variants[variant].offsets[0].bytes() as isize;\n+                            let discr_size = discr.size().bytes();\n+                            let discr_offset = variants[variant].offsets[0].bytes();\n \n                             // FIXME(solson)\n                             let dest = self.force_allocation(dest)?;\n@@ -581,7 +581,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                                 // FIXME(solson)\n                                 let dest = self.force_allocation(dest)?.to_ptr();\n \n-                                let dest = dest.offset(offset.bytes() as isize);\n+                                let dest = dest.offset(offset.bytes());\n                                 let dest_size = self.type_size(ty)?.expect(\"bad StructWrappedNullablePointer discrfield\");\n                                 try!(self.memory.write_int(dest, 0, dest_size));\n                             }\n@@ -594,7 +594,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         assert_eq!(operands.len(), 0);\n                         if let mir::AggregateKind::Adt(adt_def, variant, _, _) = *kind {\n                             let n = adt_def.variants[variant].disr_val.to_u64_unchecked();\n-                            let size = discr.size().bytes() as usize;\n+                            let size = discr.size().bytes();\n \n                             let val = if signed {\n                                 PrimVal::from_int_with_size(n as i64, size)\n@@ -621,18 +621,18 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             Repeat(ref operand, _) => {\n                 let (elem_ty, length) = match dest_ty.sty {\n-                    ty::TyArray(elem_ty, n) => (elem_ty, n),\n+                    ty::TyArray(elem_ty, n) => (elem_ty, n as u64),\n                     _ => bug!(\"tried to assign array-repeat to non-array type {:?}\", dest_ty),\n                 };\n-                self.inc_step_counter_and_check_limit(length as u64)?;\n+                self.inc_step_counter_and_check_limit(length)?;\n                 let elem_size = self.type_size(elem_ty)?.expect(\"repeat element type must be sized\");\n                 let value = self.eval_operand(operand)?;\n \n                 // FIXME(solson)\n                 let dest = self.force_allocation(dest)?.to_ptr();\n \n                 for i in 0..length {\n-                    let elem_dest = dest.offset((i * elem_size) as isize);\n+                    let elem_dest = dest.offset(i * elem_size);\n                     self.write_value_to_ptr(value, elem_dest, elem_ty)?;\n                 }\n             }\n@@ -741,15 +741,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     fn nonnull_offset_and_ty(&self, ty: Ty<'tcx>, nndiscr: u64, discrfield: &[u32]) -> EvalResult<'tcx, (Size, Ty<'tcx>)> {\n-        // Skip the constant 0 at the start meant for LLVM GEP.\n-        let mut path = discrfield.iter().skip(1).map(|&i| i as usize);\n+        // Skip the constant 0 at the start meant for LLVM GEP and the outer non-null variant\n+        let path = discrfield.iter().skip(2).map(|&i| i as usize);\n \n         // Handle the field index for the outer non-null variant.\n         let inner_ty = match ty.sty {\n             ty::TyAdt(adt_def, substs) => {\n                 let variant = &adt_def.variants[nndiscr as usize];\n-                let index = path.next().unwrap();\n-                let field = &variant.fields[index];\n+                let index = discrfield[1];\n+                let field = &variant.fields[index as usize];\n                 field.ty(self.tcx, substs)\n             }\n             _ => bug!(\"non-enum for StructWrappedNullablePointer: {}\", ty),\n@@ -804,8 +804,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 Ok(variant.offsets[field_index])\n             }\n             FatPointer { .. } => {\n-                let bytes = field_index * self.memory.pointer_size();\n-                Ok(Size::from_bytes(bytes as u64))\n+                let bytes = field_index as u64 * self.memory.pointer_size();\n+                Ok(Size::from_bytes(bytes))\n             }\n             _ => {\n                 let msg = format!(\"can't handle type: {:?}, with layout: {:?}\", ty, layout);\n@@ -980,7 +980,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     _ => bug!(\"field access on non-product type: {:?}\", base_layout),\n                 };\n \n-                let ptr = base_ptr.offset(offset.bytes() as isize);\n+                let ptr = base_ptr.offset(offset.bytes());\n                 let extra = if self.type_is_sized(field_ty) {\n                     LvalueExtra::None\n                 } else {\n@@ -1048,7 +1048,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let n = self.value_to_primval(n_ptr, usize)?\n                     .expect_uint(\"Projection::Index expected usize\");\n                 assert!(n < len);\n-                let ptr = base_ptr.offset(n as isize * elem_size as isize);\n+                let ptr = base_ptr.offset(n * elem_size);\n                 (ptr, LvalueExtra::None)\n             }\n \n@@ -1062,12 +1062,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 assert!(n >= min_length as u64);\n \n                 let index = if from_end {\n-                    n as isize - offset as isize\n+                    n - u64::from(offset)\n                 } else {\n-                    offset as isize\n+                    u64::from(offset)\n                 };\n \n-                let ptr = base_ptr.offset(index * elem_size as isize);\n+                let ptr = base_ptr.offset(index * elem_size);\n                 (ptr, LvalueExtra::None)\n             }\n \n@@ -1078,9 +1078,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                 let (elem_ty, n) = base.elem_ty_and_len(base_ty);\n                 let elem_size = self.type_size(elem_ty)?.expect(\"slice element must be sized\");\n-                assert!((from as u64) <= n - (to as u64));\n-                let ptr = base_ptr.offset(from as isize * elem_size as isize);\n-                let extra = LvalueExtra::Length(n - to as u64 - from as u64);\n+                assert!(u64::from(from) <= n - u64::from(to));\n+                let ptr = base_ptr.offset(u64::from(from) * elem_size);\n+                let extra = LvalueExtra::Length(n - u64::from(to) - u64::from(from));\n                 (ptr, extra)\n             }\n         };\n@@ -1318,8 +1318,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         ty: Ty<'tcx>\n     ) -> EvalResult<'tcx, ()> {\n         assert_eq!(self.get_field_count(ty)?, 2);\n-        let field_0 = self.get_field_offset(ty, 0)?.bytes() as isize;\n-        let field_1 = self.get_field_offset(ty, 1)?.bytes() as isize;\n+        let field_0 = self.get_field_offset(ty, 0)?.bytes();\n+        let field_1 = self.get_field_offset(ty, 1)?.bytes();\n         self.memory.write_primval(ptr.offset(field_0), a)?;\n         self.memory.write_primval(ptr.offset(field_1), b)?;\n         Ok(())\n@@ -1368,7 +1368,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             ty::TyAdt(..) => {\n                 use rustc::ty::layout::Layout::*;\n                 if let CEnum { discr, signed, .. } = *self.type_layout(ty)? {\n-                    let size = discr.size().bytes() as usize;\n+                    let size = discr.size().bytes();\n                     if signed {\n                         PrimValKind::from_int_size(size)\n                     } else {\n@@ -1450,7 +1450,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     PrimVal::from_ptr(p)\n                 } else {\n                     trace!(\"reading fat pointer extra of type {}\", ty);\n-                    let extra = ptr.offset(self.memory.pointer_size() as isize);\n+                    let extra = ptr.offset(self.memory.pointer_size());\n                     let extra = match self.tcx.struct_tail(ty).sty {\n                         ty::TyTrait(..) => PrimVal::from_ptr(self.memory.read_ptr(extra)?),\n                         ty::TySlice(..) |\n@@ -1464,7 +1464,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             ty::TyAdt(..) => {\n                 use rustc::ty::layout::Layout::*;\n                 if let CEnum { discr, signed, .. } = *self.type_layout(ty)? {\n-                    let size = discr.size().bytes() as usize;\n+                    let size = discr.size().bytes();\n                     if signed {\n                         let n = self.memory.read_int(ptr, size)?;\n                         PrimVal::from_int_with_size(n, size)\n@@ -1566,8 +1566,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     if self.type_size(dst_fty)? == Some(0) {\n                         continue;\n                     }\n-                    let src_field_offset = self.get_field_offset(src_ty, i)?.bytes() as isize;\n-                    let dst_field_offset = self.get_field_offset(dest_ty, i)?.bytes() as isize;\n+                    let src_field_offset = self.get_field_offset(src_ty, i)?.bytes();\n+                    let dst_field_offset = self.get_field_offset(dest_ty, i)?.bytes();\n                     let src_f_ptr = src_ptr.offset(src_field_offset);\n                     let dst_f_ptr = dest.offset(dst_field_offset);\n                     if src_fty == dst_fty {\n@@ -1699,7 +1699,7 @@ impl<'tcx> Lvalue<'tcx> {\n pub fn eval_main<'a, 'tcx: 'a>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     def_id: DefId,\n-    memory_size: usize,\n+    memory_size: u64,\n     step_limit: u64,\n     stack_limit: usize,\n ) {"}, {"sha": "87a9229aba0c4fd407f03536f6da8bab9ac6b9ce", "filename": "src/interpreter/terminator/intrinsics.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/85801fa2b033b0f517c8619ad1bf98a871572df1/src%2Finterpreter%2Fterminator%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85801fa2b033b0f517c8619ad1bf98a871572df1/src%2Finterpreter%2Fterminator%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fintrinsics.rs?ref=85801fa2b033b0f517c8619ad1bf98a871572df1", "patch": "@@ -46,7 +46,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let ptr = arg_vals[0].read_ptr(&self.memory)?;\n                 let offset = self.value_to_primval(arg_vals[1], isize)?\n                     .expect_int(\"arith_offset second arg not isize\");\n-                let new_ptr = ptr.offset(offset as isize);\n+                let new_ptr = ptr.signed_offset(offset);\n                 self.write_primval(dest, PrimVal::from_ptr(new_ptr))?;\n             }\n \n@@ -150,7 +150,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let dest = arg_vals[1].read_ptr(&self.memory)?;\n                 let count = self.value_to_primval(arg_vals[2], usize)?\n                     .expect_uint(\"arith_offset second arg not isize\");\n-                self.memory.copy(src, dest, count as usize * elem_size, elem_align)?;\n+                self.memory.copy(src, dest, count * elem_size, elem_align)?;\n             }\n \n             \"ctpop\" |\n@@ -220,7 +220,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"forget\" => {}\n \n             \"init\" => {\n-                let size = dest_layout.size(&self.tcx.data_layout).bytes() as usize;\n+                let size = dest_layout.size(&self.tcx.data_layout).bytes();\n                 let init = |this: &mut Self, val: Option<Value>| {\n                     match val {\n                         Some(Value::ByRef(ptr)) => {\n@@ -280,12 +280,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             \"offset\" => {\n                 let pointee_ty = substs.type_at(0);\n-                let pointee_size = self.type_size(pointee_ty)?.expect(\"cannot offset a pointer to an unsized type\") as isize;\n+                // FIXME: assuming here that type size is < i64::max_value()\n+                let pointee_size = self.type_size(pointee_ty)?.expect(\"cannot offset a pointer to an unsized type\") as i64;\n                 let offset = self.value_to_primval(arg_vals[1], isize)?\n                     .expect_int(\"offset second arg not isize\");\n \n                 let ptr = arg_vals[0].read_ptr(&self.memory)?;\n-                let result_ptr = ptr.offset(offset as isize * pointee_size);\n+                let result_ptr = ptr.signed_offset(offset * pointee_size);\n                 self.write_primval(dest, PrimVal::from_ptr(result_ptr))?;\n             }\n \n@@ -378,7 +379,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"uninit\" => {\n-                let size = dest_layout.size(&self.tcx.data_layout).bytes() as usize;\n+                let size = dest_layout.size(&self.tcx.data_layout).bytes();\n                 let uninit = |this: &mut Self, val: Option<Value>| {\n                     match val {\n                         Some(Value::ByRef(ptr)) => {\n@@ -482,8 +483,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 ty::TyTrait(..) => {\n                     let (_, vtable) = value.expect_ptr_vtable_pair(&self.memory)?;\n                     // the second entry in the vtable is the dynamic size of the object.\n-                    let size = self.memory.read_usize(vtable.offset(pointer_size as isize))?;\n-                    let align = self.memory.read_usize(vtable.offset(pointer_size as isize * 2))?;\n+                    let size = self.memory.read_usize(vtable.offset(pointer_size))?;\n+                    let align = self.memory.read_usize(vtable.offset(pointer_size * 2))?;\n                     Ok((size, align))\n                 }\n "}, {"sha": "ab5b695ff1dde7ba95c3f1e18e6d13f79bd9c880", "filename": "src/interpreter/terminator/mod.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/85801fa2b033b0f517c8619ad1bf98a871572df1/src%2Finterpreter%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85801fa2b033b0f517c8619ad1bf98a871572df1/src%2Finterpreter%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fmod.rs?ref=85801fa2b033b0f517c8619ad1bf98a871572df1", "patch": "@@ -254,23 +254,23 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         let discr_val = match *adt_layout {\n             General { discr, .. } | CEnum { discr, signed: false, .. } => {\n                 let discr_size = discr.size().bytes();\n-                self.memory.read_uint(adt_ptr, discr_size as usize)?\n+                self.memory.read_uint(adt_ptr, discr_size)?\n             }\n \n             CEnum { discr, signed: true, .. } => {\n                 let discr_size = discr.size().bytes();\n-                self.memory.read_int(adt_ptr, discr_size as usize)? as u64\n+                self.memory.read_int(adt_ptr, discr_size)? as u64\n             }\n \n             RawNullablePointer { nndiscr, value } => {\n-                let discr_size = value.size(&self.tcx.data_layout).bytes() as usize;\n+                let discr_size = value.size(&self.tcx.data_layout).bytes();\n                 trace!(\"rawnullablepointer with size {}\", discr_size);\n                 self.read_nonnull_discriminant_value(adt_ptr, nndiscr, discr_size)?\n             }\n \n             StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n                 let (offset, ty) = self.nonnull_offset_and_ty(adt_ty, nndiscr, discrfield)?;\n-                let nonnull = adt_ptr.offset(offset.bytes() as isize);\n+                let nonnull = adt_ptr.offset(offset.bytes());\n                 trace!(\"struct wrapped nullable pointer type: {}\", ty);\n                 // only the pointer part of a fat pointer is used for this space optimization\n                 let discr_size = self.type_size(ty)?.expect(\"bad StructWrappedNullablePointer discrfield\");\n@@ -285,7 +285,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(discr_val)\n     }\n \n-    fn read_nonnull_discriminant_value(&self, ptr: Pointer, nndiscr: u64, discr_size: usize) -> EvalResult<'tcx, u64> {\n+    fn read_nonnull_discriminant_value(&self, ptr: Pointer, nndiscr: u64, discr_size: u64) -> EvalResult<'tcx, u64> {\n         let not_null = match self.memory.read_uint(ptr, discr_size) {\n             Ok(0) => false,\n             Ok(_) | Err(EvalError::ReadPointerAsBytes) => true,\n@@ -300,7 +300,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         def_id: DefId,\n         args: &[mir::Operand<'tcx>],\n         dest: Lvalue<'tcx>,\n-        dest_size: usize,\n+        dest_size: u64,\n     ) -> EvalResult<'tcx, ()> {\n         let name = self.tcx.item_name(def_id);\n         let attrs = self.tcx.get_attrs(def_id);\n@@ -327,7 +327,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     .expect_uint(\"__rust_allocate first arg not usize\");\n                 let align = self.value_to_primval(args[1], usize)?\n                     .expect_uint(\"__rust_allocate second arg not usize\");\n-                let ptr = self.memory.allocate(size as usize, align as usize)?;\n+                let ptr = self.memory.allocate(size, align)?;\n                 self.write_primval(dest, PrimVal::from_ptr(ptr))?;\n             }\n \n@@ -345,14 +345,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let ptr = args[0].read_ptr(&self.memory)?;\n                 let size = self.value_to_primval(args[2], usize)?.expect_uint(\"__rust_reallocate third arg not usize\");\n                 let align = self.value_to_primval(args[3], usize)?.expect_uint(\"__rust_reallocate fourth arg not usize\");\n-                let new_ptr = self.memory.reallocate(ptr, size as usize, align as usize)?;\n+                let new_ptr = self.memory.reallocate(ptr, size, align)?;\n                 self.write_primval(dest, PrimVal::from_ptr(new_ptr))?;\n             }\n \n             \"memcmp\" => {\n                 let left = args[0].read_ptr(&self.memory)?;\n                 let right = args[1].read_ptr(&self.memory)?;\n-                let n = self.value_to_primval(args[2], usize)?.expect_uint(\"__rust_reallocate first arg not usize\") as usize;\n+                let n = self.value_to_primval(args[2], usize)?.expect_uint(\"__rust_reallocate first arg not usize\");\n \n                 let result = {\n                     let left_bytes = self.memory.read_bytes(left, n)?;\n@@ -414,7 +414,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         _ => bug!(\"rust-call ABI tuple argument wasn't Value::ByRef\"),\n                     };\n                     for (offset, ty) in offsets.zip(fields) {\n-                        let arg = Value::ByRef(last_ptr.offset(offset as isize));\n+                        let arg = Value::ByRef(last_ptr.offset(offset));\n                         args.push((arg, ty));\n                     }\n                 }\n@@ -496,13 +496,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             traits::VtableObject(ref data) => {\n-                let idx = self.tcx.get_vtable_index_of_object_method(data, def_id);\n+                let idx = self.tcx.get_vtable_index_of_object_method(data, def_id) as u64;\n                 if let Some(&mut(ref mut first_arg, ref mut first_ty)) = args.get_mut(0) {\n                     let (self_ptr, vtable) = first_arg.expect_ptr_vtable_pair(&self.memory)?;\n                     *first_arg = Value::ByVal(PrimVal::from_ptr(self_ptr));\n                     let idx = idx + 3;\n                     let offset = idx * self.memory.pointer_size();\n-                    let fn_ptr = self.memory.read_ptr(vtable.offset(offset as isize))?;\n+                    let fn_ptr = self.memory.read_ptr(vtable.offset(offset))?;\n                     let (def_id, substs, _abi, sig) = self.memory.get_fn(fn_ptr.alloc_id)?;\n                     *first_ty = sig.inputs[0];\n                     Ok((def_id, substs))\n@@ -600,6 +600,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Layout::StructWrappedNullablePointer { nndiscr, ref nonnull, .. } => {\n                         let discr = self.read_discriminant_value(adt_ptr, ty)?;\n                         if discr == nndiscr {\n+                            assert_eq!(discr as usize as u64, discr);\n                             adt_def.variants[discr as usize].fields.iter().zip(&nonnull.offsets)\n                         } else {\n                             // FIXME: the zst variant might contain zst types that impl Drop\n@@ -609,6 +610,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Layout::RawNullablePointer { nndiscr, .. } => {\n                         let discr = self.read_discriminant_value(adt_ptr, ty)?;\n                         if discr == nndiscr {\n+                            assert_eq!(discr as usize as u64, discr);\n                             assert_eq!(adt_def.variants[discr as usize].fields.len(), 1);\n                             let field_ty = &adt_def.variants[discr as usize].fields[0];\n                             let field_ty = monomorphize_field_ty(self.tcx, field_ty, substs);\n@@ -656,10 +658,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             },\n             ty::TySlice(elem_ty) => {\n                 let (ptr, len) = match lval {\n-                    Lvalue::Ptr { ptr, extra: LvalueExtra::Length(len) } => (ptr, len as isize),\n+                    Lvalue::Ptr { ptr, extra: LvalueExtra::Length(len) } => (ptr, len),\n                     _ => bug!(\"expected an lvalue with a length\"),\n                 };\n-                let size = self.type_size(elem_ty)?.expect(\"slice element must be sized\") as isize;\n+                let size = self.type_size(elem_ty)?.expect(\"slice element must be sized\");\n                 // FIXME: this creates a lot of stack frames if the element type has\n                 // a drop impl\n                 for i in 0..len {\n@@ -672,11 +674,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Lvalue::Ptr { ptr, extra } => (ptr, extra),\n                     _ => bug!(\"expected an lvalue with optional extra data\"),\n                 };\n-                let size = self.type_size(elem_ty)?.expect(\"array element cannot be unsized\") as isize;\n+                let size = self.type_size(elem_ty)?.expect(\"array element cannot be unsized\");\n                 // FIXME: this creates a lot of stack frames if the element type has\n                 // a drop impl\n-                for i in 0..len {\n-                    self.drop(Lvalue::Ptr { ptr: ptr.offset(i as isize * size), extra: extra }, elem_ty, drop)?;\n+                for i in 0..(len as u64) {\n+                    self.drop(Lvalue::Ptr { ptr: ptr.offset(i * size), extra: extra }, elem_ty, drop)?;\n                 }\n             },\n             // FIXME: what about TyClosure and TyAnon?\n@@ -699,7 +701,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         let (adt_ptr, extra) = self.force_allocation(lval)?.to_ptr_and_extra();\n         // manual iteration, because we need to be careful about the last field if it is unsized\n         while let Some((field_ty, offset)) = fields.next() {\n-            let ptr = adt_ptr.offset(offset.bytes() as isize);\n+            let ptr = adt_ptr.offset(offset.bytes());\n             if self.type_is_sized(field_ty) {\n                 self.drop(Lvalue::from_ptr(ptr), field_ty, drop)?;\n             } else {"}, {"sha": "f31f1ca24bc3c67b3ea26af78a7f372946306913", "filename": "src/interpreter/value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/85801fa2b033b0f517c8619ad1bf98a871572df1/src%2Finterpreter%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85801fa2b033b0f517c8619ad1bf98a871572df1/src%2Finterpreter%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fvalue.rs?ref=85801fa2b033b0f517c8619ad1bf98a871572df1", "patch": "@@ -34,7 +34,7 @@ impl<'a, 'tcx: 'a> Value {\n         match *self {\n             ByRef(ref_ptr) => {\n                 let ptr = mem.read_ptr(ref_ptr)?;\n-                let vtable = mem.read_ptr(ref_ptr.offset(mem.pointer_size() as isize))?;\n+                let vtable = mem.read_ptr(ref_ptr.offset(mem.pointer_size()))?;\n                 Ok((ptr, vtable))\n             }\n \n@@ -49,7 +49,7 @@ impl<'a, 'tcx: 'a> Value {\n         match *self {\n             ByRef(ref_ptr) => {\n                 let ptr = mem.read_ptr(ref_ptr)?;\n-                let len = mem.read_usize(ref_ptr.offset(mem.pointer_size() as isize))?;\n+                let len = mem.read_usize(ref_ptr.offset(mem.pointer_size()))?;\n                 Ok((ptr, len))\n             },\n             ByValPair(ptr, val) => {"}, {"sha": "89db8e111e40ce2dace357dfc4f8c88ee874e059", "filename": "src/interpreter/vtable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/85801fa2b033b0f517c8619ad1bf98a871572df1/src%2Finterpreter%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85801fa2b033b0f517c8619ad1bf98a871572df1/src%2Finterpreter%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fvtable.rs?ref=85801fa2b033b0f517c8619ad1bf98a871572df1", "patch": "@@ -84,7 +84,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         let align = self.type_align(trait_ref.self_ty())?;\n \n         let ptr_size = self.memory.pointer_size();\n-        let vtable = self.memory.allocate(ptr_size * (3 + methods.len()), ptr_size)?;\n+        let vtable = self.memory.allocate(ptr_size * (3 + methods.len() as u64), ptr_size)?;\n \n         // in case there is no drop function to be called, this still needs to be initialized\n         self.memory.write_usize(vtable, 0)?;\n@@ -99,12 +99,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n         }\n \n-        self.memory.write_usize(vtable.offset(ptr_size as isize), size as u64)?;\n-        self.memory.write_usize(vtable.offset((ptr_size * 2) as isize), align as u64)?;\n+        self.memory.write_usize(vtable.offset(ptr_size), size)?;\n+        self.memory.write_usize(vtable.offset((ptr_size * 2)), align)?;\n \n         for (i, method) in methods.into_iter().enumerate() {\n             if let Some(method) = method {\n-                self.memory.write_ptr(vtable.offset(ptr_size as isize * (3 + i as isize)), method)?;\n+                self.memory.write_ptr(vtable.offset(ptr_size * (3 + i as u64)), method)?;\n             }\n         }\n "}, {"sha": "c4c045c121b1035125f32371c0b6816ac1c9d301", "filename": "src/memory.rs", "status": "modified", "additions": 118, "deletions": 88, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/85801fa2b033b0f517c8619ad1bf98a871572df1/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85801fa2b033b0f517c8619ad1bf98a871572df1/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=85801fa2b033b0f517c8619ad1bf98a871572df1", "patch": "@@ -33,11 +33,11 @@ pub struct Allocation {\n     pub bytes: Vec<u8>,\n     /// Maps from byte addresses to allocations.\n     /// Only the first byte of a pointer is inserted into the map.\n-    pub relocations: BTreeMap<usize, AllocId>,\n+    pub relocations: BTreeMap<u64, AllocId>,\n     /// Denotes undefined memory. Reading from undefined memory is forbidden in miri\n     pub undef_mask: UndefMask,\n     /// The alignment of the allocation to detect unaligned reads.\n-    pub align: usize,\n+    pub align: u64,\n     /// Whether the allocation may be modified.\n     /// Use the `freeze` method of `Memory` to ensure that an error occurs, if the memory of this\n     /// allocation is modified in the future.\n@@ -47,34 +47,43 @@ pub struct Allocation {\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub struct Pointer {\n     pub alloc_id: AllocId,\n-    pub offset: usize,\n+    pub offset: u64,\n }\n \n impl Pointer {\n-    pub fn new(alloc_id: AllocId, offset: usize) -> Self {\n+    pub fn new(alloc_id: AllocId, offset: u64) -> Self {\n         Pointer { alloc_id: alloc_id, offset: offset }\n     }\n \n-    pub fn offset(self, i: isize) -> Self {\n-        let new_offset = (self.offset as isize + i) as usize;\n-        Pointer::new(self.alloc_id, new_offset)\n+    pub fn signed_offset(self, i: i64) -> Self {\n+        // FIXME: is it possible to over/underflow here?\n+        if i < 0 {\n+            // trickery to ensure that i64::min_value() works fine\n+            // this formula only works for true negative values, it panics for zero!\n+            let n = u64::max_value() - (i as u64) + 1;\n+            Pointer::new(self.alloc_id, self.offset - n)\n+        } else {\n+            self.offset(i as u64)\n+        }\n+    }\n+\n+    pub fn offset(self, i: u64) -> Self {\n+        Pointer::new(self.alloc_id, self.offset + i)\n     }\n \n     pub fn points_to_zst(&self) -> bool {\n         self.alloc_id == ZST_ALLOC_ID\n     }\n \n-    pub fn to_int<'tcx>(&self) -> EvalResult<'tcx, usize> {\n+    pub fn to_int<'tcx>(&self) -> EvalResult<'tcx, u64> {\n         match self.alloc_id {\n             NEVER_ALLOC_ID |\n             ZST_ALLOC_ID => Ok(self.offset),\n             _ => Err(EvalError::ReadPointerAsBytes),\n         }\n     }\n \n-    // FIXME(solson): Integer pointers should use u64, not usize. Target pointers can be larger\n-    // than host usize.\n-    pub fn from_int(i: usize) -> Self {\n+    pub fn from_int(i: u64) -> Self {\n         Pointer::new(NEVER_ALLOC_ID, i)\n     }\n \n@@ -103,9 +112,9 @@ pub struct Memory<'a, 'tcx> {\n     /// Actual memory allocations (arbitrary bytes, may contain pointers into other allocations)\n     alloc_map: HashMap<AllocId, Allocation>,\n     /// Number of virtual bytes allocated\n-    memory_usage: usize,\n+    memory_usage: u64,\n     /// Maximum number of virtual bytes that may be allocated\n-    memory_size: usize,\n+    memory_size: u64,\n     /// Function \"allocations\". They exist solely so pointers have something to point to, and\n     /// we can figure out what they point to.\n     functions: HashMap<AllocId, FunctionDefinition<'tcx>>,\n@@ -119,7 +128,7 @@ const ZST_ALLOC_ID: AllocId = AllocId(0);\n const NEVER_ALLOC_ID: AllocId = AllocId(1);\n \n impl<'a, 'tcx> Memory<'a, 'tcx> {\n-    pub fn new(layout: &'a TargetDataLayout, max_memory: usize) -> Self {\n+    pub fn new(layout: &'a TargetDataLayout, max_memory: u64) -> Self {\n         Memory {\n             alloc_map: HashMap::new(),\n             functions: HashMap::new(),\n@@ -175,7 +184,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Pointer::new(id, 0)\n     }\n \n-    pub fn allocate(&mut self, size: usize, align: usize) -> EvalResult<'tcx, Pointer> {\n+    pub fn allocate(&mut self, size: u64, align: u64) -> EvalResult<'tcx, Pointer> {\n         if size == 0 {\n             return Ok(Pointer::zst_ptr());\n         }\n@@ -189,8 +198,9 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             });\n         }\n         self.memory_usage += size;\n+        assert_eq!(size as usize as u64, size);\n         let alloc = Allocation {\n-            bytes: vec![0; size],\n+            bytes: vec![0; size as usize],\n             relocations: BTreeMap::new(),\n             undef_mask: UndefMask::new(size),\n             align: align,\n@@ -204,7 +214,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n     // TODO(solson): Track which allocations were returned from __rust_allocate and report an error\n     // when reallocating/deallocating any others.\n-    pub fn reallocate(&mut self, ptr: Pointer, new_size: usize, align: usize) -> EvalResult<'tcx, Pointer> {\n+    pub fn reallocate(&mut self, ptr: Pointer, new_size: u64, align: u64) -> EvalResult<'tcx, Pointer> {\n         // TODO(solson): Report error about non-__rust_allocate'd pointer.\n         if ptr.offset != 0 {\n             return Err(EvalError::Unimplemented(format!(\"bad pointer offset: {}\", ptr.offset)));\n@@ -216,19 +226,21 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             return Err(EvalError::ReallocatedFrozenMemory);\n         }\n \n-        let size = self.get(ptr.alloc_id)?.bytes.len();\n+        let size = self.get(ptr.alloc_id)?.bytes.len() as u64;\n \n         if new_size > size {\n             let amount = new_size - size;\n             self.memory_usage += amount;\n             let alloc = self.get_mut(ptr.alloc_id)?;\n-            alloc.bytes.extend(iter::repeat(0).take(amount));\n+            assert_eq!(amount as usize as u64, amount);\n+            alloc.bytes.extend(iter::repeat(0).take(amount as usize));\n             alloc.undef_mask.grow(amount, false);\n         } else if size > new_size {\n             self.memory_usage -= size - new_size;\n-            self.clear_relocations(ptr.offset(new_size as isize), size - new_size)?;\n+            self.clear_relocations(ptr.offset(new_size), size - new_size)?;\n             let alloc = self.get_mut(ptr.alloc_id)?;\n-            alloc.bytes.truncate(new_size);\n+            // `as usize` is fine here, since it is smaller than `size`, which came from a usize\n+            alloc.bytes.truncate(new_size as usize);\n             alloc.bytes.shrink_to_fit();\n             alloc.undef_mask.truncate(new_size);\n         }\n@@ -250,7 +262,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n \n         if let Some(alloc) = self.alloc_map.remove(&ptr.alloc_id) {\n-            self.memory_usage -= alloc.bytes.len();\n+            self.memory_usage -= alloc.bytes.len() as u64;\n         } else {\n             debug!(\"deallocated a pointer twice: {}\", ptr.alloc_id);\n             // TODO(solson): Report error about erroneous free. This is blocked on properly tracking\n@@ -262,15 +274,15 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(())\n     }\n \n-    pub fn pointer_size(&self) -> usize {\n-        self.layout.pointer_size.bytes() as usize\n+    pub fn pointer_size(&self) -> u64 {\n+        self.layout.pointer_size.bytes()\n     }\n \n     pub fn endianess(&self) -> layout::Endian {\n         self.layout.endian\n     }\n \n-    pub fn check_align(&self, ptr: Pointer, align: usize) -> EvalResult<'tcx, ()> {\n+    pub fn check_align(&self, ptr: Pointer, align: u64) -> EvalResult<'tcx, ()> {\n         let alloc = self.get(ptr.alloc_id)?;\n         if alloc.align < align {\n             return Err(EvalError::AlignmentCheckFailed {\n@@ -358,15 +370,16 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n                 (Some(_), Some(_)) => bug!(\"miri invariant broken: an allocation id exists that points to both a function and a memory location\"),\n             };\n \n-            for i in 0..alloc.bytes.len() {\n+            for i in 0..(alloc.bytes.len() as u64) {\n                 if let Some(&target_id) = alloc.relocations.get(&i) {\n                     if !allocs_seen.contains(&target_id) {\n                         allocs_to_print.push_back(target_id);\n                     }\n                     relocations.push((i, target_id));\n                 }\n                 if alloc.undef_mask.is_range_defined(i, i + 1) {\n-                    write!(msg, \"{:02x} \", alloc.bytes[i]).unwrap();\n+                    // this `as usize` is fine, since `i` came from a `usize`\n+                    write!(msg, \"{:02x} \", alloc.bytes[i as usize]).unwrap();\n                 } else {\n                     msg.push_str(\"__ \");\n                 }\n@@ -381,13 +394,15 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n                 let mut pos = 0;\n                 let relocation_width = (self.pointer_size() - 1) * 3;\n                 for (i, target_id) in relocations {\n-                    write!(msg, \"{:1$}\", \"\", (i - pos) * 3).unwrap();\n+                    // this `as usize` is fine, since we can't print more chars than `usize::MAX`\n+                    write!(msg, \"{:1$}\", \"\", ((i - pos) * 3) as usize).unwrap();\n                     let target = match target_id {\n                         ZST_ALLOC_ID => String::from(\"zst\"),\n                         NEVER_ALLOC_ID => String::from(\"int ptr\"),\n                         _ => format!(\"({})\", target_id),\n                     };\n-                    write!(msg, \"\u2514{0:\u2500^1$}\u2518 \", target, relocation_width).unwrap();\n+                    // this `as usize` is fine, since we can't print more chars than `usize::MAX`\n+                    write!(msg, \"\u2514{0:\u2500^1$}\u2518 \", target, relocation_width as usize).unwrap();\n                     pos = i + self.pointer_size();\n                 }\n                 trace!(\"{}\", msg);\n@@ -398,37 +413,43 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n /// Byte accessors\n impl<'a, 'tcx> Memory<'a, 'tcx> {\n-    fn get_bytes_unchecked(&self, ptr: Pointer, size: usize) -> EvalResult<'tcx, &[u8]> {\n+    fn get_bytes_unchecked(&self, ptr: Pointer, size: u64) -> EvalResult<'tcx, &[u8]> {\n         if size == 0 {\n             return Ok(&[]);\n         }\n         let alloc = self.get(ptr.alloc_id)?;\n-        if ptr.offset + size > alloc.bytes.len() {\n+        if ptr.offset + size > alloc.bytes.len() as u64 {\n             return Err(EvalError::PointerOutOfBounds {\n                 ptr: ptr,\n                 size: size,\n-                allocation_size: alloc.bytes.len(),\n+                allocation_size: alloc.bytes.len() as u64,\n             });\n         }\n-        Ok(&alloc.bytes[ptr.offset..ptr.offset + size])\n+        assert_eq!(ptr.offset as usize as u64, ptr.offset);\n+        assert_eq!(size as usize as u64, size);\n+        let offset = ptr.offset as usize;\n+        Ok(&alloc.bytes[offset..offset + size as usize])\n     }\n \n-    fn get_bytes_unchecked_mut(&mut self, ptr: Pointer, size: usize) -> EvalResult<'tcx, &mut [u8]> {\n+    fn get_bytes_unchecked_mut(&mut self, ptr: Pointer, size: u64) -> EvalResult<'tcx, &mut [u8]> {\n         if size == 0 {\n             return Ok(&mut []);\n         }\n         let alloc = self.get_mut(ptr.alloc_id)?;\n-        if ptr.offset + size > alloc.bytes.len() {\n+        if ptr.offset + size > alloc.bytes.len() as u64 {\n             return Err(EvalError::PointerOutOfBounds {\n                 ptr: ptr,\n                 size: size,\n-                allocation_size: alloc.bytes.len(),\n+                allocation_size: alloc.bytes.len() as u64,\n             });\n         }\n-        Ok(&mut alloc.bytes[ptr.offset..ptr.offset + size])\n+        assert_eq!(ptr.offset as usize as u64, ptr.offset);\n+        assert_eq!(size as usize as u64, size);\n+        let offset = ptr.offset as usize;\n+        Ok(&mut alloc.bytes[offset..offset + size as usize])\n     }\n \n-    fn get_bytes(&self, ptr: Pointer, size: usize, align: usize) -> EvalResult<'tcx, &[u8]> {\n+    fn get_bytes(&self, ptr: Pointer, size: u64, align: u64) -> EvalResult<'tcx, &[u8]> {\n         if size == 0 {\n             return Ok(&[]);\n         }\n@@ -440,7 +461,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         self.get_bytes_unchecked(ptr, size)\n     }\n \n-    fn get_bytes_mut(&mut self, ptr: Pointer, size: usize, align: usize) -> EvalResult<'tcx, &mut [u8]> {\n+    fn get_bytes_mut(&mut self, ptr: Pointer, size: u64, align: u64) -> EvalResult<'tcx, &mut [u8]> {\n         if size == 0 {\n             return Ok(&mut []);\n         }\n@@ -476,7 +497,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(())\n     }\n \n-    pub fn copy(&mut self, src: Pointer, dest: Pointer, size: usize, align: usize) -> EvalResult<'tcx, ()> {\n+    pub fn copy(&mut self, src: Pointer, dest: Pointer, size: u64, align: u64) -> EvalResult<'tcx, ()> {\n         if size == 0 {\n             return Ok(());\n         }\n@@ -489,10 +510,11 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         // behind `src` and `dest`. Also, we use the overlapping-safe `ptr::copy` if `src` and\n         // `dest` could possibly overlap.\n         unsafe {\n+            assert_eq!(size as usize as u64, size);\n             if src.alloc_id == dest.alloc_id {\n-                ptr::copy(src_bytes, dest_bytes, size);\n+                ptr::copy(src_bytes, dest_bytes, size as usize);\n             } else {\n-                ptr::copy_nonoverlapping(src_bytes, dest_bytes, size);\n+                ptr::copy_nonoverlapping(src_bytes, dest_bytes, size as usize);\n             }\n         }\n \n@@ -502,17 +524,17 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(())\n     }\n \n-    pub fn read_bytes(&self, ptr: Pointer, size: usize) -> EvalResult<'tcx, &[u8]> {\n+    pub fn read_bytes(&self, ptr: Pointer, size: u64) -> EvalResult<'tcx, &[u8]> {\n         self.get_bytes(ptr, size, 1)\n     }\n \n     pub fn write_bytes(&mut self, ptr: Pointer, src: &[u8]) -> EvalResult<'tcx, ()> {\n-        let bytes = self.get_bytes_mut(ptr, src.len(), 1)?;\n+        let bytes = self.get_bytes_mut(ptr, src.len() as u64, 1)?;\n         bytes.clone_from_slice(src);\n         Ok(())\n     }\n \n-    pub fn write_repeat(&mut self, ptr: Pointer, val: u8, count: usize) -> EvalResult<'tcx, ()> {\n+    pub fn write_repeat(&mut self, ptr: Pointer, val: u8, count: u64) -> EvalResult<'tcx, ()> {\n         let bytes = self.get_bytes_mut(ptr, count, 1)?;\n         for b in bytes { *b = val; }\n         Ok(())\n@@ -523,7 +545,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         self.check_defined(ptr, size)?;\n         let endianess = self.endianess();\n         let bytes = self.get_bytes_unchecked(ptr, size)?;\n-        let offset = read_target_uint(endianess, bytes).unwrap() as usize;\n+        let offset = read_target_uint(endianess, bytes).unwrap();\n         let alloc = self.get(ptr.alloc_id)?;\n         match alloc.relocations.get(&ptr.offset) {\n             Some(&alloc_id) => Ok(Pointer::new(alloc_id, offset)),\n@@ -539,7 +561,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n     pub fn write_primval(&mut self, dest: Pointer, val: PrimVal) -> EvalResult<'tcx, ()> {\n         if let Some(alloc_id) = val.relocation {\n-            return self.write_ptr(dest, Pointer::new(alloc_id, val.bits as usize));\n+            return self.write_ptr(dest, Pointer::new(alloc_id, val.bits));\n         }\n \n         use primval::PrimValKind::*;\n@@ -556,7 +578,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     }\n \n     pub fn read_bool(&self, ptr: Pointer) -> EvalResult<'tcx, bool> {\n-        let bytes = self.get_bytes(ptr, 1, self.layout.i1_align.abi() as usize)?;\n+        let bytes = self.get_bytes(ptr, 1, self.layout.i1_align.abi())?;\n         match bytes[0] {\n             0 => Ok(false),\n             1 => Ok(true),\n@@ -565,40 +587,40 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     }\n \n     pub fn write_bool(&mut self, ptr: Pointer, b: bool) -> EvalResult<'tcx, ()> {\n-        let align = self.layout.i1_align.abi() as usize;\n+        let align = self.layout.i1_align.abi();\n         self.get_bytes_mut(ptr, 1, align)\n             .map(|bytes| bytes[0] = b as u8)\n     }\n \n-    fn int_align(&self, size: usize) -> EvalResult<'tcx, usize> {\n+    fn int_align(&self, size: u64) -> EvalResult<'tcx, u64> {\n         match size {\n-            1 => Ok(self.layout.i8_align.abi() as usize),\n-            2 => Ok(self.layout.i16_align.abi() as usize),\n-            4 => Ok(self.layout.i32_align.abi() as usize),\n-            8 => Ok(self.layout.i64_align.abi() as usize),\n+            1 => Ok(self.layout.i8_align.abi()),\n+            2 => Ok(self.layout.i16_align.abi()),\n+            4 => Ok(self.layout.i32_align.abi()),\n+            8 => Ok(self.layout.i64_align.abi()),\n             _ => bug!(\"bad integer size: {}\", size),\n         }\n     }\n \n-    pub fn read_int(&self, ptr: Pointer, size: usize) -> EvalResult<'tcx, i64> {\n+    pub fn read_int(&self, ptr: Pointer, size: u64) -> EvalResult<'tcx, i64> {\n         let align = self.int_align(size)?;\n         self.get_bytes(ptr, size, align).map(|b| read_target_int(self.endianess(), b).unwrap())\n     }\n \n-    pub fn write_int(&mut self, ptr: Pointer, n: i64, size: usize) -> EvalResult<'tcx, ()> {\n+    pub fn write_int(&mut self, ptr: Pointer, n: i64, size: u64) -> EvalResult<'tcx, ()> {\n         let align = self.int_align(size)?;\n         let endianess = self.endianess();\n         let b = self.get_bytes_mut(ptr, size, align)?;\n         write_target_int(endianess, b, n).unwrap();\n         Ok(())\n     }\n \n-    pub fn read_uint(&self, ptr: Pointer, size: usize) -> EvalResult<'tcx, u64> {\n+    pub fn read_uint(&self, ptr: Pointer, size: u64) -> EvalResult<'tcx, u64> {\n         let align = self.int_align(size)?;\n         self.get_bytes(ptr, size, align).map(|b| read_target_uint(self.endianess(), b).unwrap())\n     }\n \n-    pub fn write_uint(&mut self, ptr: Pointer, n: u64, size: usize) -> EvalResult<'tcx, ()> {\n+    pub fn write_uint(&mut self, ptr: Pointer, n: u64, size: u64) -> EvalResult<'tcx, ()> {\n         let align = self.int_align(size)?;\n         let endianess = self.endianess();\n         let b = self.get_bytes_mut(ptr, size, align)?;\n@@ -626,42 +648,42 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n     pub fn write_f32(&mut self, ptr: Pointer, f: f32) -> EvalResult<'tcx, ()> {\n         let endianess = self.endianess();\n-        let align = self.layout.f32_align.abi() as usize;\n+        let align = self.layout.f32_align.abi();\n         let b = self.get_bytes_mut(ptr, 4, align)?;\n         write_target_f32(endianess, b, f).unwrap();\n         Ok(())\n     }\n \n     pub fn write_f64(&mut self, ptr: Pointer, f: f64) -> EvalResult<'tcx, ()> {\n         let endianess = self.endianess();\n-        let align = self.layout.f64_align.abi() as usize;\n+        let align = self.layout.f64_align.abi();\n         let b = self.get_bytes_mut(ptr, 8, align)?;\n         write_target_f64(endianess, b, f).unwrap();\n         Ok(())\n     }\n \n     pub fn read_f32(&self, ptr: Pointer) -> EvalResult<'tcx, f32> {\n-        self.get_bytes(ptr, 4, self.layout.f32_align.abi() as usize)\n+        self.get_bytes(ptr, 4, self.layout.f32_align.abi())\n             .map(|b| read_target_f32(self.endianess(), b).unwrap())\n     }\n \n     pub fn read_f64(&self, ptr: Pointer) -> EvalResult<'tcx, f64> {\n-        self.get_bytes(ptr, 8, self.layout.f64_align.abi() as usize)\n+        self.get_bytes(ptr, 8, self.layout.f64_align.abi())\n             .map(|b| read_target_f64(self.endianess(), b).unwrap())\n     }\n }\n \n /// Relocations\n impl<'a, 'tcx> Memory<'a, 'tcx> {\n-    fn relocations(&self, ptr: Pointer, size: usize)\n-        -> EvalResult<'tcx, btree_map::Range<usize, AllocId>>\n+    fn relocations(&self, ptr: Pointer, size: u64)\n+        -> EvalResult<'tcx, btree_map::Range<u64, AllocId>>\n     {\n         let start = ptr.offset.saturating_sub(self.pointer_size() - 1);\n         let end = ptr.offset + size;\n         Ok(self.get(ptr.alloc_id)?.relocations.range(Included(&start), Excluded(&end)))\n     }\n \n-    fn clear_relocations(&mut self, ptr: Pointer, size: usize) -> EvalResult<'tcx, ()> {\n+    fn clear_relocations(&mut self, ptr: Pointer, size: u64) -> EvalResult<'tcx, ()> {\n         // Find all relocations overlapping the given range.\n         let keys: Vec<_> = self.relocations(ptr, size)?.map(|(&k, _)| k).collect();\n         if keys.is_empty() { return Ok(()); }\n@@ -685,16 +707,16 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(())\n     }\n \n-    fn check_relocation_edges(&self, ptr: Pointer, size: usize) -> EvalResult<'tcx, ()> {\n+    fn check_relocation_edges(&self, ptr: Pointer, size: u64) -> EvalResult<'tcx, ()> {\n         let overlapping_start = self.relocations(ptr, 0)?.count();\n-        let overlapping_end = self.relocations(ptr.offset(size as isize), 0)?.count();\n+        let overlapping_end = self.relocations(ptr.offset(size), 0)?.count();\n         if overlapping_start + overlapping_end != 0 {\n             return Err(EvalError::ReadPointerAsBytes);\n         }\n         Ok(())\n     }\n \n-    fn copy_relocations(&mut self, src: Pointer, dest: Pointer, size: usize) -> EvalResult<'tcx, ()> {\n+    fn copy_relocations(&mut self, src: Pointer, dest: Pointer, size: u64) -> EvalResult<'tcx, ()> {\n         let relocations: Vec<_> = self.relocations(src, size)?\n             .map(|(&offset, &alloc_id)| {\n                 // Update relocation offsets for the new positions in the destination allocation.\n@@ -709,28 +731,29 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n /// Undefined bytes\n impl<'a, 'tcx> Memory<'a, 'tcx> {\n     // FIXME(solson): This is a very naive, slow version.\n-    fn copy_undef_mask(&mut self, src: Pointer, dest: Pointer, size: usize) -> EvalResult<'tcx, ()> {\n+    fn copy_undef_mask(&mut self, src: Pointer, dest: Pointer, size: u64) -> EvalResult<'tcx, ()> {\n         // The bits have to be saved locally before writing to dest in case src and dest overlap.\n-        let mut v = Vec::with_capacity(size);\n+        assert_eq!(size as usize as u64, size);\n+        let mut v = Vec::with_capacity(size as usize);\n         for i in 0..size {\n             let defined = self.get(src.alloc_id)?.undef_mask.get(src.offset + i);\n             v.push(defined);\n         }\n         for (i, defined) in v.into_iter().enumerate() {\n-            self.get_mut(dest.alloc_id)?.undef_mask.set(dest.offset + i, defined);\n+            self.get_mut(dest.alloc_id)?.undef_mask.set(dest.offset + i as u64, defined);\n         }\n         Ok(())\n     }\n \n-    fn check_defined(&self, ptr: Pointer, size: usize) -> EvalResult<'tcx, ()> {\n+    fn check_defined(&self, ptr: Pointer, size: u64) -> EvalResult<'tcx, ()> {\n         let alloc = self.get(ptr.alloc_id)?;\n         if !alloc.undef_mask.is_range_defined(ptr.offset, ptr.offset + size) {\n             return Err(EvalError::ReadUndefBytes);\n         }\n         Ok(())\n     }\n \n-    pub fn mark_definedness(&mut self, ptr: Pointer, size: usize, new_state: bool)\n+    pub fn mark_definedness(&mut self, ptr: Pointer, size: u64, new_state: bool)\n         -> EvalResult<'tcx, ()>\n     {\n         if size == 0 {\n@@ -809,16 +832,16 @@ fn read_target_f64(endianess: layout::Endian, mut source: &[u8]) -> Result<f64,\n ////////////////////////////////////////////////////////////////////////////////\n \n type Block = u64;\n-const BLOCK_SIZE: usize = 64;\n+const BLOCK_SIZE: u64 = 64;\n \n #[derive(Clone, Debug)]\n pub struct UndefMask {\n     blocks: Vec<Block>,\n-    len: usize,\n+    len: u64,\n }\n \n impl UndefMask {\n-    fn new(size: usize) -> Self {\n+    fn new(size: u64) -> Self {\n         let mut m = UndefMask {\n             blocks: vec![],\n             len: 0,\n@@ -828,30 +851,30 @@ impl UndefMask {\n     }\n \n     /// Check whether the range `start..end` (end-exclusive) is entirely defined.\n-    pub fn is_range_defined(&self, start: usize, end: usize) -> bool {\n+    pub fn is_range_defined(&self, start: u64, end: u64) -> bool {\n         if end > self.len { return false; }\n         for i in start..end {\n             if !self.get(i) { return false; }\n         }\n         true\n     }\n \n-    fn set_range(&mut self, start: usize, end: usize, new_state: bool) {\n+    fn set_range(&mut self, start: u64, end: u64, new_state: bool) {\n         let len = self.len;\n         if end > len { self.grow(end - len, new_state); }\n         self.set_range_inbounds(start, end, new_state);\n     }\n \n-    fn set_range_inbounds(&mut self, start: usize, end: usize, new_state: bool) {\n+    fn set_range_inbounds(&mut self, start: u64, end: u64, new_state: bool) {\n         for i in start..end { self.set(i, new_state); }\n     }\n \n-    fn get(&self, i: usize) -> bool {\n+    fn get(&self, i: u64) -> bool {\n         let (block, bit) = bit_index(i);\n         (self.blocks[block] & 1 << bit) != 0\n     }\n \n-    fn set(&mut self, i: usize, new_state: bool) {\n+    fn set(&mut self, i: u64, new_state: bool) {\n         let (block, bit) = bit_index(i);\n         if new_state {\n             self.blocks[block] |= 1 << bit;\n@@ -860,24 +883,31 @@ impl UndefMask {\n         }\n     }\n \n-    fn grow(&mut self, amount: usize, new_state: bool) {\n-        let unused_trailing_bits = self.blocks.len() * BLOCK_SIZE - self.len;\n+    fn grow(&mut self, amount: u64, new_state: bool) {\n+        let unused_trailing_bits = self.blocks.len() as u64 * BLOCK_SIZE - self.len;\n         if amount > unused_trailing_bits {\n             let additional_blocks = amount / BLOCK_SIZE + 1;\n-            self.blocks.extend(iter::repeat(0).take(additional_blocks));\n+            assert_eq!(additional_blocks as usize as u64, additional_blocks);\n+            self.blocks.extend(iter::repeat(0).take(additional_blocks as usize));\n         }\n         let start = self.len;\n         self.len += amount;\n         self.set_range_inbounds(start, start + amount, new_state);\n     }\n \n-    fn truncate(&mut self, length: usize) {\n+    fn truncate(&mut self, length: u64) {\n         self.len = length;\n-        self.blocks.truncate(self.len / BLOCK_SIZE + 1);\n+        let truncate = self.len / BLOCK_SIZE + 1;\n+        assert_eq!(truncate as usize as u64, truncate);\n+        self.blocks.truncate(truncate as usize);\n         self.blocks.shrink_to_fit();\n     }\n }\n \n-fn bit_index(bits: usize) -> (usize, usize) {\n-    (bits / BLOCK_SIZE, bits % BLOCK_SIZE)\n+fn bit_index(bits: u64) -> (usize, usize) {\n+    let a = bits / BLOCK_SIZE;\n+    let b = bits % BLOCK_SIZE;\n+    assert_eq!(a as usize as u64, a);\n+    assert_eq!(b as usize as u64, b);\n+    (a as usize, b as usize)\n }"}, {"sha": "20b08b5a0a1b6026f4c19525281aa8030552d0bd", "filename": "src/primval.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/85801fa2b033b0f517c8619ad1bf98a871572df1/src%2Fprimval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85801fa2b033b0f517c8619ad1bf98a871572df1/src%2Fprimval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fprimval.rs?ref=85801fa2b033b0f517c8619ad1bf98a871572df1", "patch": "@@ -65,7 +65,7 @@ impl PrimValKind {\n         }\n     }\n \n-    pub fn from_uint_size(size: usize) -> Self {\n+    pub fn from_uint_size(size: u64) -> Self {\n         match size {\n             1 => PrimValKind::U8,\n             2 => PrimValKind::U16,\n@@ -75,7 +75,7 @@ impl PrimValKind {\n         }\n     }\n \n-    pub fn from_int_size(size: usize) -> Self {\n+    pub fn from_int_size(size: u64) -> Self {\n         match size {\n             1 => PrimValKind::I8,\n             2 => PrimValKind::I16,\n@@ -119,11 +119,11 @@ impl PrimVal {\n         PrimVal::new(f64_to_bits(f), PrimValKind::F64)\n     }\n \n-    pub fn from_uint_with_size(n: u64, size: usize) -> Self {\n+    pub fn from_uint_with_size(n: u64, size: u64) -> Self {\n         PrimVal::new(n, PrimValKind::from_uint_size(size))\n     }\n \n-    pub fn from_int_with_size(n: i64, size: usize) -> Self {\n+    pub fn from_int_with_size(n: i64, size: u64) -> Self {\n         PrimVal::new(n as u64, PrimValKind::from_int_size(size))\n     }\n \n@@ -139,8 +139,8 @@ impl PrimVal {\n \n     pub fn to_ptr(self) -> Pointer {\n         self.relocation.map(|alloc_id| {\n-            Pointer::new(alloc_id, self.bits as usize)\n-        }).unwrap_or_else(|| Pointer::from_int(self.bits as usize))\n+            Pointer::new(alloc_id, self.bits)\n+        }).unwrap_or_else(|| Pointer::from_int(self.bits))\n     }\n \n     pub fn try_as_uint<'tcx>(self) -> EvalResult<'tcx, u64> {"}]}