{"sha": "0bff861d3268de14426b1a8b4912aebf8330a009", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiZmY4NjFkMzI2OGRlMTQ0MjZiMWE4YjQ5MTJhZWJmODMzMGEwMDk=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2018-08-03T20:13:05Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2018-08-04T09:02:25Z"}, "message": "Remove FinderTrait and move its functions into DocContext", "tree": {"sha": "5f2d84baa516659cbcf5b217ab27274bac50709d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f2d84baa516659cbcf5b217ab27274bac50709d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0bff861d3268de14426b1a8b4912aebf8330a009", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0bff861d3268de14426b1a8b4912aebf8330a009", "html_url": "https://github.com/rust-lang/rust/commit/0bff861d3268de14426b1a8b4912aebf8330a009", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0bff861d3268de14426b1a8b4912aebf8330a009/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc81adb3c221c4d5687685742f6235c37128e8e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc81adb3c221c4d5687685742f6235c37128e8e0", "html_url": "https://github.com/rust-lang/rust/commit/fc81adb3c221c4d5687685742f6235c37128e8e0"}], "stats": {"total": 330, "additions": 150, "deletions": 180}, "files": [{"sha": "61cd34ae7fd00ecc8bf74160bb481fcebfc35cfd", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0bff861d3268de14426b1a8b4912aebf8330a009/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bff861d3268de14426b1a8b4912aebf8330a009/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=0bff861d3268de14426b1a8b4912aebf8330a009", "patch": "@@ -17,7 +17,6 @@ use rustc::middle::cstore::CrateStore;\n use std::fmt::Debug;\n \n use self::def_ctor::{get_def_from_def_id, get_def_from_node_id};\n-use self::finder_trait::Finder;\n \n use super::*;\n \n@@ -168,14 +167,14 @@ impl<'a, 'tcx, 'rcx, 'cstore> AutoTraitFinder<'a, 'tcx, 'rcx, 'cstore> {\n                 _ => unreachable!(),\n             };\n             let real_name = name.map(|name| Ident::from_str(&name));\n-            let ty = self.get_real_ty(def_id, def_ctor, &real_name, &generics);\n+            let ty = self.cx.get_real_ty(def_id, def_ctor, &real_name, &generics);\n \n             return Some(Item {\n                 source: Span::empty(),\n                 name: None,\n                 attrs: Default::default(),\n                 visibility: None,\n-                def_id: self.next_def_id(def_id.krate),\n+                def_id: self.cx.next_def_id(def_id.krate),\n                 stability: None,\n                 deprecation: None,\n                 inner: ImplItem(Impl {\n@@ -862,12 +861,6 @@ impl<'a, 'tcx, 'rcx, 'cstore> AutoTraitFinder<'a, 'tcx, 'rcx, 'cstore> {\n     }\n }\n \n-impl<'a, 'tcx: 'a, 'rcx: 'a> Finder<'a, 'tcx, 'rcx> for AutoTraitFinder<'a, 'tcx, 'rcx> {\n-    fn get_cx(&self) -> &DocContext<'a, 'tcx, 'rcx> {\n-        &self.cx\n-    }\n-}\n-\n // Replaces all ReVars in a type with ty::Region's, using the provided map\n struct RegionReplacer<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     vid_to_region: &'a FxHashMap<ty::RegionVid, ty::Region<'tcx>>,"}, {"sha": "386f46dbfedc29bcc43f9e2a74e3c0a74f457a7a", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0bff861d3268de14426b1a8b4912aebf8330a009/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bff861d3268de14426b1a8b4912aebf8330a009/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=0bff861d3268de14426b1a8b4912aebf8330a009", "patch": "@@ -20,7 +20,6 @@ use core::DocAccessLevels;\n use super::*;\n \n use self::def_ctor::{get_def_from_def_id, get_def_from_node_id};\n-use self::finder_trait::Finder;\n \n pub struct BlanketImplFinder<'a, 'tcx: 'a, 'rcx: 'a> {\n     pub cx: &'a core::DocContext<'a, 'tcx, 'rcx>,\n@@ -127,15 +126,15 @@ impl<'a, 'tcx, 'rcx> BlanketImplFinder <'a, 'tcx, 'rcx> {\n                                          .map(|meth| meth.ident.to_string())\n                                          .collect();\n \n-                            let ty = self.get_real_ty(def_id, def_ctor, &real_name, generics);\n+                            let ty = self.cx.get_real_ty(def_id, def_ctor, &real_name, generics);\n                             let predicates = infcx.tcx.predicates_of(impl_def_id);\n \n                             impls.push(Item {\n                                 source: infcx.tcx.def_span(impl_def_id).clean(self.cx),\n                                 name: None,\n                                 attrs: Default::default(),\n                                 visibility: None,\n-                                def_id: self.next_def_id(impl_def_id.krate),\n+                                def_id: self.cx.next_def_id(impl_def_id.krate),\n                                 stability: None,\n                                 deprecation: None,\n                                 inner: ImplItem(Impl {\n@@ -161,9 +160,3 @@ impl<'a, 'tcx, 'rcx> BlanketImplFinder <'a, 'tcx, 'rcx> {\n         impls\n     }\n }\n-\n-impl<'a, 'tcx: 'a, 'rcx: 'a> Finder<'a, 'tcx, 'rcx> for BlanketImplFinder<'a, 'tcx, 'rcx> {\n-    fn get_cx(&self) -> &DocContext<'a, 'tcx, 'rcx> {\n-        &self.cx\n-    }\n-}"}, {"sha": "cc0f3c49d16fb20cda2ef729099d7fd17e891866", "filename": "src/librustdoc/clean/finder_trait.rs", "status": "removed", "additions": 0, "deletions": 154, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/fc81adb3c221c4d5687685742f6235c37128e8e0/src%2Flibrustdoc%2Fclean%2Ffinder_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc81adb3c221c4d5687685742f6235c37128e8e0/src%2Flibrustdoc%2Fclean%2Ffinder_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ffinder_trait.rs?ref=fc81adb3c221c4d5687685742f6235c37128e8e0", "patch": "@@ -1,154 +0,0 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use rustc::hir;\n-use syntax_pos::DUMMY_SP;\n-\n-use super::*;\n-\n-pub trait Finder<'a, 'tcx: 'a, 'rcx: 'a> {\n-    fn get_cx(&self) -> &DocContext<'a, 'tcx, 'rcx>;\n-\n-    // This is an ugly hack, but it's the simplest way to handle synthetic impls without greatly\n-    // refactoring either librustdoc or librustc. In particular, allowing new DefIds to be\n-    // registered after the AST is constructed would require storing the defid mapping in a\n-    // RefCell, decreasing the performance for normal compilation for very little gain.\n-    //\n-    // Instead, we construct 'fake' def ids, which start immediately after the last DefId in\n-    // DefIndexAddressSpace::Low. In the Debug impl for clean::Item, we explicitly check for fake\n-    // def ids, as we'll end up with a panic if we use the DefId Debug impl for fake DefIds\n-    fn next_def_id(&self, crate_num: CrateNum) -> DefId {\n-        let start_def_id = {\n-            let next_id = if crate_num == LOCAL_CRATE {\n-                self.get_cx()\n-                    .tcx\n-                    .hir\n-                    .definitions()\n-                    .def_path_table()\n-                    .next_id(DefIndexAddressSpace::Low)\n-            } else {\n-                self.get_cx()\n-                    .cstore\n-                    .def_path_table(crate_num)\n-                    .next_id(DefIndexAddressSpace::Low)\n-            };\n-\n-            DefId {\n-                krate: crate_num,\n-                index: next_id,\n-            }\n-        };\n-\n-        let mut fake_ids = self.get_cx().fake_def_ids.borrow_mut();\n-\n-        let def_id = fake_ids.entry(crate_num).or_insert(start_def_id).clone();\n-        fake_ids.insert(\n-            crate_num,\n-            DefId {\n-                krate: crate_num,\n-                index: DefIndex::from_array_index(\n-                    def_id.index.as_array_index() + 1,\n-                    def_id.index.address_space(),\n-                ),\n-            },\n-        );\n-\n-        MAX_DEF_ID.with(|m| {\n-            m.borrow_mut()\n-                .entry(def_id.krate.clone())\n-                .or_insert(start_def_id);\n-        });\n-\n-        self.get_cx().all_fake_def_ids.borrow_mut().insert(def_id);\n-\n-        def_id.clone()\n-    }\n-\n-    fn get_real_ty<F>(&self,\n-                      def_id: DefId,\n-                      def_ctor: &F,\n-                      real_name: &Option<Ident>,\n-                      generics: &ty::Generics,\n-    ) -> hir::Ty\n-    where F: Fn(DefId) -> Def {\n-        let path = get_path_for_type(self.get_cx().tcx, def_id, def_ctor);\n-        let mut segments = path.segments.into_vec();\n-        let last = segments.pop().expect(\"segments were empty\");\n-\n-        segments.push(hir::PathSegment::new(\n-            real_name.unwrap_or(last.ident),\n-            self.generics_to_path_params(generics.clone()),\n-            false,\n-        ));\n-\n-        let new_path = hir::Path {\n-            span: path.span,\n-            def: path.def,\n-            segments: HirVec::from_vec(segments),\n-        };\n-\n-        hir::Ty {\n-            id: ast::DUMMY_NODE_ID,\n-            node: hir::TyKind::Path(hir::QPath::Resolved(None, P(new_path))),\n-            span: DUMMY_SP,\n-            hir_id: hir::DUMMY_HIR_ID,\n-        }\n-    }\n-\n-    fn generics_to_path_params(&self, generics: ty::Generics) -> hir::GenericArgs {\n-        let mut args = vec![];\n-\n-        for param in generics.params.iter() {\n-            match param.kind {\n-                ty::GenericParamDefKind::Lifetime => {\n-                    let name = if param.name == \"\" {\n-                        hir::ParamName::Plain(keywords::StaticLifetime.ident())\n-                    } else {\n-                        hir::ParamName::Plain(ast::Ident::from_interned_str(param.name))\n-                    };\n-\n-                    args.push(hir::GenericArg::Lifetime(hir::Lifetime {\n-                        id: ast::DUMMY_NODE_ID,\n-                        span: DUMMY_SP,\n-                        name: hir::LifetimeName::Param(name),\n-                    }));\n-                }\n-                ty::GenericParamDefKind::Type {..} => {\n-                    args.push(hir::GenericArg::Type(self.ty_param_to_ty(param.clone())));\n-                }\n-            }\n-        }\n-\n-        hir::GenericArgs {\n-            args: HirVec::from_vec(args),\n-            bindings: HirVec::new(),\n-            parenthesized: false,\n-        }\n-    }\n-\n-    fn ty_param_to_ty(&self, param: ty::GenericParamDef) -> hir::Ty {\n-        debug!(\"ty_param_to_ty({:?}) {:?}\", param, param.def_id);\n-        hir::Ty {\n-            id: ast::DUMMY_NODE_ID,\n-            node: hir::TyKind::Path(hir::QPath::Resolved(\n-                None,\n-                P(hir::Path {\n-                    span: DUMMY_SP,\n-                    def: Def::TyParam(param.def_id),\n-                    segments: HirVec::from_vec(vec![\n-                        hir::PathSegment::from_ident(Ident::from_interned_str(param.name))\n-                    ]),\n-                }),\n-            )),\n-            span: DUMMY_SP,\n-            hir_id: hir::DUMMY_HIR_ID,\n-        }\n-    }\n-}"}, {"sha": "9dbd7d7b2607d45f010cbb1758bf07027a58d9c1", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0bff861d3268de14426b1a8b4912aebf8330a009/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bff861d3268de14426b1a8b4912aebf8330a009/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=0bff861d3268de14426b1a8b4912aebf8330a009", "patch": "@@ -37,8 +37,7 @@ use rustc::middle::lang_items;\n use rustc::mir::interpret::GlobalId;\n use rustc::hir::{self, GenericArg, HirVec};\n use rustc::hir::def::{self, Def, CtorKind};\n-use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n-use rustc::hir::def_id::DefIndexAddressSpace;\n+use rustc::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc::hir::map::Node;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, TyCtxt, Region, RegionVid, Ty, AdtKind};\n@@ -75,13 +74,13 @@ mod simplify;\n mod auto_trait;\n mod blanket_impl;\n pub mod def_ctor;\n-mod finder_trait;\n \n use self::cfg::Cfg;\n use self::auto_trait::AutoTraitFinder;\n use self::blanket_impl::BlanketImplFinder;\n \n-thread_local!(static MAX_DEF_ID: RefCell<FxHashMap<CrateNum, DefId>> = RefCell::new(FxHashMap()));\n+thread_local!(pub static MAX_DEF_ID: RefCell<FxHashMap<CrateNum, DefId>> =\n+    RefCell::new(FxHashMap()));\n \n const FN_OUTPUT_NAME: &'static str = \"Output\";\n \n@@ -4505,7 +4504,7 @@ pub fn path_to_def(tcx: &TyCtxt, path: &[&str]) -> Option<DefId> {\n     }\n }\n \n-fn get_path_for_type<F>(tcx: TyCtxt, def_id: DefId, def_ctor: F) -> hir::Path\n+pub fn get_path_for_type<F>(tcx: TyCtxt, def_id: DefId, def_ctor: F) -> hir::Path\n where F: Fn(DefId) -> Def {\n     struct AbsolutePathBuffer {\n         names: Vec<String>,"}, {"sha": "3b7ae929ca14617fac03561769198c062b5b0a08", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 142, "deletions": 3, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/0bff861d3268de14426b1a8b4912aebf8330a009/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bff861d3268de14426b1a8b4912aebf8330a009/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=0bff861d3268de14426b1a8b4912aebf8330a009", "patch": "@@ -11,8 +11,10 @@\n use rustc_lint;\n use rustc_driver::{self, driver, target_features, abort_on_err};\n use rustc::session::{self, config};\n-use rustc::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n+use rustc::hir::def_id::{DefId, DefIndex, DefIndexAddressSpace, CrateNum, LOCAL_CRATE};\n use rustc::hir::def::Def;\n+use rustc::hir::{self, HirVec};\n+use rustc::middle::cstore::CrateStore;\n use rustc::middle::privacy::AccessLevels;\n use rustc::ty::{self, TyCtxt, AllArenas};\n use rustc::hir::map as hir_map;\n@@ -24,11 +26,14 @@ use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::CStore;\n use rustc_target::spec::TargetTriple;\n \n-use syntax::ast::{Name, NodeId};\n+use syntax::ast::{self, Ident, Name, NodeId};\n use syntax::codemap;\n use syntax::edition::Edition;\n use syntax::feature_gate::UnstableFeatures;\n use syntax::json::JsonEmitter;\n+use syntax::ptr::P;\n+use syntax::symbol::keywords;\n+use syntax_pos::DUMMY_SP;\n use errors;\n use errors::emitter::{Emitter, EmitterWriter};\n \n@@ -40,7 +45,7 @@ use std::path::PathBuf;\n \n use visit_ast::RustdocVisitor;\n use clean;\n-use clean::Clean;\n+use clean::{get_path_for_type, Clean, MAX_DEF_ID};\n use html::render::RenderInfo;\n \n pub use rustc::session::config::{Input, CodegenOptions};\n@@ -106,6 +111,140 @@ impl<'a, 'tcx, 'rcx, 'cstore> DocContext<'a, 'tcx, 'rcx, 'cstore> {\n         *self.lt_substs.borrow_mut() = old_lts;\n         r\n     }\n+\n+    // This is an ugly hack, but it's the simplest way to handle synthetic impls without greatly\n+    // refactoring either librustdoc or librustc. In particular, allowing new DefIds to be\n+    // registered after the AST is constructed would require storing the defid mapping in a\n+    // RefCell, decreasing the performance for normal compilation for very little gain.\n+    //\n+    // Instead, we construct 'fake' def ids, which start immediately after the last DefId in\n+    // DefIndexAddressSpace::Low. In the Debug impl for clean::Item, we explicitly check for fake\n+    // def ids, as we'll end up with a panic if we use the DefId Debug impl for fake DefIds\n+    pub fn next_def_id(&self, crate_num: CrateNum) -> DefId {\n+        let start_def_id = {\n+            let next_id = if crate_num == LOCAL_CRATE {\n+                self.tcx\n+                    .hir\n+                    .definitions()\n+                    .def_path_table()\n+                    .next_id(DefIndexAddressSpace::Low)\n+            } else {\n+                self.cstore\n+                    .def_path_table(crate_num)\n+                    .next_id(DefIndexAddressSpace::Low)\n+            };\n+\n+            DefId {\n+                krate: crate_num,\n+                index: next_id,\n+            }\n+        };\n+\n+        let mut fake_ids = self.fake_def_ids.borrow_mut();\n+\n+        let def_id = fake_ids.entry(crate_num).or_insert(start_def_id).clone();\n+        fake_ids.insert(\n+            crate_num,\n+            DefId {\n+                krate: crate_num,\n+                index: DefIndex::from_array_index(\n+                    def_id.index.as_array_index() + 1,\n+                    def_id.index.address_space(),\n+                ),\n+            },\n+        );\n+\n+        MAX_DEF_ID.with(|m| {\n+            m.borrow_mut()\n+                .entry(def_id.krate.clone())\n+                .or_insert(start_def_id);\n+        });\n+\n+        self.all_fake_def_ids.borrow_mut().insert(def_id);\n+\n+        def_id.clone()\n+    }\n+\n+    pub fn get_real_ty<F>(&self,\n+                          def_id: DefId,\n+                          def_ctor: &F,\n+                          real_name: &Option<Ident>,\n+                          generics: &ty::Generics,\n+    ) -> hir::Ty\n+    where F: Fn(DefId) -> Def {\n+        let path = get_path_for_type(self.tcx, def_id, def_ctor);\n+        let mut segments = path.segments.into_vec();\n+        let last = segments.pop().expect(\"segments were empty\");\n+\n+        segments.push(hir::PathSegment::new(\n+            real_name.unwrap_or(last.ident),\n+            self.generics_to_path_params(generics.clone()),\n+            false,\n+        ));\n+\n+        let new_path = hir::Path {\n+            span: path.span,\n+            def: path.def,\n+            segments: HirVec::from_vec(segments),\n+        };\n+\n+        hir::Ty {\n+            id: ast::DUMMY_NODE_ID,\n+            node: hir::TyKind::Path(hir::QPath::Resolved(None, P(new_path))),\n+            span: DUMMY_SP,\n+            hir_id: hir::DUMMY_HIR_ID,\n+        }\n+    }\n+\n+    pub fn generics_to_path_params(&self, generics: ty::Generics) -> hir::GenericArgs {\n+        let mut args = vec![];\n+\n+        for param in generics.params.iter() {\n+            match param.kind {\n+                ty::GenericParamDefKind::Lifetime => {\n+                    let name = if param.name == \"\" {\n+                        hir::ParamName::Plain(keywords::StaticLifetime.ident())\n+                    } else {\n+                        hir::ParamName::Plain(ast::Ident::from_interned_str(param.name))\n+                    };\n+\n+                    args.push(hir::GenericArg::Lifetime(hir::Lifetime {\n+                        id: ast::DUMMY_NODE_ID,\n+                        span: DUMMY_SP,\n+                        name: hir::LifetimeName::Param(name),\n+                    }));\n+                }\n+                ty::GenericParamDefKind::Type {..} => {\n+                    args.push(hir::GenericArg::Type(self.ty_param_to_ty(param.clone())));\n+                }\n+            }\n+        }\n+\n+        hir::GenericArgs {\n+            args: HirVec::from_vec(args),\n+            bindings: HirVec::new(),\n+            parenthesized: false,\n+        }\n+    }\n+\n+    pub fn ty_param_to_ty(&self, param: ty::GenericParamDef) -> hir::Ty {\n+        debug!(\"ty_param_to_ty({:?}) {:?}\", param, param.def_id);\n+        hir::Ty {\n+            id: ast::DUMMY_NODE_ID,\n+            node: hir::TyKind::Path(hir::QPath::Resolved(\n+                None,\n+                P(hir::Path {\n+                    span: DUMMY_SP,\n+                    def: Def::TyParam(param.def_id),\n+                    segments: HirVec::from_vec(vec![\n+                        hir::PathSegment::from_ident(Ident::from_interned_str(param.name))\n+                    ]),\n+                }),\n+            )),\n+            span: DUMMY_SP,\n+            hir_id: hir::DUMMY_HIR_ID,\n+        }\n+    }\n }\n \n pub trait DocAccessLevels {"}]}