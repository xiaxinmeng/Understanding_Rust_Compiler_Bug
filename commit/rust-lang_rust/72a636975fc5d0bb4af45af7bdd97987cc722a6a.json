{"sha": "72a636975fc5d0bb4af45af7bdd97987cc722a6a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyYTYzNjk3NWZjNWQwYmI0YWY0NWFmN2JkZDk3OTg3Y2M3MjJhNmE=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-07T23:21:59Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-13T09:40:26Z"}, "message": "Move macro resolution into `librustc_resolve`.", "tree": {"sha": "71b6b7ff658d8d95bf56ba5b4923ebd4821bd589", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71b6b7ff658d8d95bf56ba5b4923ebd4821bd589"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/72a636975fc5d0bb4af45af7bdd97987cc722a6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/72a636975fc5d0bb4af45af7bdd97987cc722a6a", "html_url": "https://github.com/rust-lang/rust/commit/72a636975fc5d0bb4af45af7bdd97987cc722a6a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/72a636975fc5d0bb4af45af7bdd97987cc722a6a/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "20b43b23230ce063ccf99a4841d85790ad311bdf", "url": "https://api.github.com/repos/rust-lang/rust/commits/20b43b23230ce063ccf99a4841d85790ad311bdf", "html_url": "https://github.com/rust-lang/rust/commit/20b43b23230ce063ccf99a4841d85790ad311bdf"}], "stats": {"total": 845, "additions": 439, "deletions": 406}, "files": [{"sha": "49686d63ee43b8d288275d48770cae3429d50467", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/72a636975fc5d0bb4af45af7bdd97987cc722a6a/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72a636975fc5d0bb4af45af7bdd97987cc722a6a/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=72a636975fc5d0bb4af45af7bdd97987cc722a6a", "patch": "@@ -21,7 +21,7 @@ use util::nodemap::{NodeMap, FnvHashMap};\n use util::common::duration_to_secs_str;\n use mir::transform as mir_pass;\n \n-use syntax::ast::{NodeId, Name};\n+use syntax::ast::NodeId;\n use errors::{self, DiagnosticBuilder};\n use errors::emitter::{Emitter, EmitterWriter};\n use syntax::json::JsonEmitter;\n@@ -39,7 +39,7 @@ use llvm;\n \n use std::path::{Path, PathBuf};\n use std::cell::{self, Cell, RefCell};\n-use std::collections::{HashMap, HashSet};\n+use std::collections::HashMap;\n use std::env;\n use std::ffi::CString;\n use std::rc::Rc;\n@@ -96,10 +96,6 @@ pub struct Session {\n     pub injected_allocator: Cell<Option<ast::CrateNum>>,\n     pub injected_panic_runtime: Cell<Option<ast::CrateNum>>,\n \n-    /// Names of all bang-style macros and syntax extensions\n-    /// available in this crate\n-    pub available_macros: RefCell<HashSet<Name>>,\n-\n     /// Map from imported macro spans (which consist of\n     /// the localized span for the macro body) to the\n     /// macro name and defintion span in the source crate.\n@@ -552,7 +548,6 @@ pub fn build_session_(sopts: config::Options,\n         next_node_id: Cell::new(1),\n         injected_allocator: Cell::new(None),\n         injected_panic_runtime: Cell::new(None),\n-        available_macros: RefCell::new(HashSet::new()),\n         imported_macro_spans: RefCell::new(HashMap::new()),\n         incr_comp_session: RefCell::new(IncrCompSession::NotInitialized),\n         perf_stats: PerfStats {"}, {"sha": "bf50c96034dd016d7300e900f1119f341265a038", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/72a636975fc5d0bb4af45af7bdd97987cc722a6a/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72a636975fc5d0bb4af45af7bdd97987cc722a6a/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=72a636975fc5d0bb4af45af7bdd97987cc722a6a", "patch": "@@ -50,6 +50,7 @@ use std::io::{self, Write};\n use std::path::{Path, PathBuf};\n use syntax::{ast, diagnostics, visit};\n use syntax::attr;\n+use syntax::ext::base::ExtCtxt;\n use syntax::parse::{self, PResult, token};\n use syntax::util::node_count::NodeCounter;\n use syntax;\n@@ -643,6 +644,7 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n \n     let resolver_arenas = Resolver::arenas();\n     let mut resolver = Resolver::new(sess, make_glob_map, &mut macro_loader, &resolver_arenas);\n+    syntax_ext::register_builtins(&mut resolver, sess.features.borrow().quote);\n \n     krate = time(time_passes, \"expansion\", || {\n         // Windows dlls do not have rpaths, so they don't know how to find their\n@@ -678,16 +680,11 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n             trace_mac: sess.opts.debugging_opts.trace_macros,\n             should_test: sess.opts.test,\n         };\n-        let mut ecx = syntax::ext::base::ExtCtxt::new(&sess.parse_sess,\n-                                                      krate.config.clone(),\n-                                                      cfg,\n-                                                      &mut resolver);\n-        syntax_ext::register_builtins(&mut ecx.syntax_env);\n+        let mut ecx = ExtCtxt::new(&sess.parse_sess, krate.config.clone(), cfg, &mut resolver);\n         let ret = syntax::ext::expand::expand_crate(&mut ecx, syntax_exts, krate);\n         if cfg!(windows) {\n             env::set_var(\"PATH\", &old_path);\n         }\n-        *sess.available_macros.borrow_mut() = ecx.syntax_env.names;\n         ret\n     });\n "}, {"sha": "6bf45ab8f6fa0a30e1bf348f16b1c6e1eb6b7bc5", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/72a636975fc5d0bb4af45af7bdd97987cc722a6a/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72a636975fc5d0bb4af45af7bdd97987cc722a6a/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=72a636975fc5d0bb4af45af7bdd97987cc722a6a", "patch": "@@ -54,8 +54,6 @@ use rustc::ty;\n use rustc::hir::{Freevar, FreevarMap, TraitCandidate, TraitMap, GlobMap};\n use rustc::util::nodemap::{NodeMap, NodeSet, FnvHashMap, FnvHashSet};\n \n-use syntax::ext;\n-use syntax::ext::base::LoadedMacro;\n use syntax::ext::hygiene::Mark;\n use syntax::ast::{self, FloatTy};\n use syntax::ast::{CRATE_NODE_ID, Name, NodeId, CrateNum, IntTy, UintTy};\n@@ -82,6 +80,7 @@ use resolve_imports::{ImportDirective, NameResolution};\n // registered before they are used.\n mod diagnostics;\n \n+mod macros;\n mod check_unused;\n mod build_reduced_graph;\n mod resolve_imports;\n@@ -1073,6 +1072,10 @@ pub struct Resolver<'a> {\n     new_import_semantics: bool, // true if `#![feature(item_like_imports)]`\n \n     macro_loader: &'a mut MacroLoader,\n+    macro_names: FnvHashSet<Name>,\n+\n+    // Maps the `Mark` of an expansion to its containing module or block.\n+    expansion_data: Vec<macros::ExpansionData>,\n }\n \n pub struct ResolverArenas<'a> {\n@@ -1154,12 +1157,6 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n     }\n }\n \n-impl<'a> ext::base::Resolver for Resolver<'a> {\n-    fn load_crate(&mut self, extern_crate: &ast::Item, allows_macros: bool) -> Vec<LoadedMacro> {\n-        self.macro_loader.load_crate(extern_crate, allows_macros)\n-    }\n-}\n-\n trait Named {\n     fn name(&self) -> Name;\n }\n@@ -1243,6 +1240,8 @@ impl<'a> Resolver<'a> {\n             new_import_semantics: session.features.borrow().item_like_imports,\n \n             macro_loader: macro_loader,\n+            macro_names: FnvHashSet(),\n+            expansion_data: vec![macros::ExpansionData::default()],\n         }\n     }\n \n@@ -2784,8 +2783,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn find_best_match(&mut self, name: &str) -> SuggestionType {\n-        if let Some(macro_name) = self.session.available_macros\n-                                  .borrow().iter().find(|n| n.as_str() == name) {\n+        if let Some(macro_name) = self.macro_names.iter().find(|n| n.as_str() == name) {\n             return SuggestionType::Macro(format!(\"{}!\", macro_name));\n         }\n "}, {"sha": "36f501a54d26134f2d5090e0806695250377f4d5", "filename": "src/librustc_resolve/macros.rs", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/72a636975fc5d0bb4af45af7bdd97987cc722a6a/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72a636975fc5d0bb4af45af7bdd97987cc722a6a/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=72a636975fc5d0bb4af45af7bdd97987cc722a6a", "patch": "@@ -0,0 +1,213 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use Resolver;\n+use rustc::util::nodemap::FnvHashMap;\n+use std::cell::RefCell;\n+use std::mem;\n+use std::rc::Rc;\n+use syntax::ast::{self, Name};\n+use syntax::errors::DiagnosticBuilder;\n+use syntax::ext::base::{self, LoadedMacro, MultiModifier, MultiDecorator};\n+use syntax::ext::base::{NormalTT, SyntaxExtension};\n+use syntax::ext::expand::{Expansion, Invocation, InvocationKind};\n+use syntax::ext::hygiene::Mark;\n+use syntax::parse::token::intern;\n+use syntax::util::lev_distance::find_best_match_for_name;\n+use syntax::visit::{self, Visitor};\n+\n+#[derive(Clone, Default)]\n+pub struct ExpansionData {\n+    module: Rc<ModuleData>,\n+}\n+\n+// FIXME(jseyfried): merge with `::ModuleS`.\n+#[derive(Default)]\n+struct ModuleData {\n+    parent: Option<Rc<ModuleData>>,\n+    macros: RefCell<FnvHashMap<Name, Rc<SyntaxExtension>>>,\n+    macros_escape: bool,\n+}\n+\n+impl<'a> base::Resolver for Resolver<'a> {\n+    fn load_crate(&mut self, extern_crate: &ast::Item, allows_macros: bool) -> Vec<LoadedMacro> {\n+        self.macro_loader.load_crate(extern_crate, allows_macros)\n+    }\n+\n+    fn visit_expansion(&mut self, mark: Mark, expansion: &Expansion) {\n+        expansion.visit_with(&mut ExpansionVisitor {\n+            current_module: self.expansion_data[mark.as_u32() as usize].module.clone(),\n+            resolver: self,\n+        });\n+    }\n+\n+    fn add_macro(&mut self, scope: Mark, ident: ast::Ident, ext: Rc<SyntaxExtension>) {\n+        if let NormalTT(..) = *ext {\n+            self.macro_names.insert(ident.name);\n+        }\n+\n+        let mut module = self.expansion_data[scope.as_u32() as usize].module.clone();\n+        while module.macros_escape {\n+            module = module.parent.clone().unwrap();\n+        }\n+        module.macros.borrow_mut().insert(ident.name, ext);\n+    }\n+\n+    fn add_expansions_at_stmt(&mut self, id: ast::NodeId, macros: Vec<Mark>) {\n+        self.macros_at_scope.insert(id, macros);\n+    }\n+\n+    fn find_attr_invoc(&mut self, attrs: &mut Vec<ast::Attribute>) -> Option<ast::Attribute> {\n+        for i in 0..attrs.len() {\n+            let name = intern(&attrs[i].name());\n+            match self.expansion_data[0].module.macros.borrow().get(&name) {\n+                Some(ext) => match **ext {\n+                    MultiModifier(..) | MultiDecorator(..) => return Some(attrs.remove(i)),\n+                    _ => {}\n+                },\n+                None => {}\n+            }\n+        }\n+        None\n+    }\n+\n+    fn resolve_invoc(&mut self, invoc: &Invocation) -> Option<Rc<SyntaxExtension>> {\n+        let (name, span) = match invoc.kind {\n+            InvocationKind::Bang { ref mac, .. } => {\n+                let path = &mac.node.path;\n+                if path.segments.len() > 1 || path.global ||\n+                   !path.segments[0].parameters.is_empty() {\n+                    self.session.span_err(path.span,\n+                                          \"expected macro name without module separators\");\n+                    return None;\n+                }\n+                (path.segments[0].identifier.name, path.span)\n+            }\n+            InvocationKind::Attr { ref attr, .. } => (intern(&*attr.name()), attr.span),\n+        };\n+\n+        let mut module = self.expansion_data[invoc.mark().as_u32() as usize].module.clone();\n+        loop {\n+            if let Some(ext) = module.macros.borrow().get(&name) {\n+                return Some(ext.clone());\n+            }\n+            match module.parent.clone() {\n+                Some(parent) => module = parent,\n+                None => break,\n+            }\n+        }\n+\n+        let mut err =\n+            self.session.struct_span_err(span, &format!(\"macro undefined: '{}!'\", name));\n+        self.suggest_macro_name(&name.as_str(), &mut err);\n+        err.emit();\n+        None\n+    }\n+}\n+\n+impl<'a> Resolver<'a> {\n+    fn suggest_macro_name(&mut self, name: &str, err: &mut DiagnosticBuilder<'a>) {\n+        if let Some(suggestion) = find_best_match_for_name(self.macro_names.iter(), name, None) {\n+            if suggestion != name {\n+                err.help(&format!(\"did you mean `{}!`?\", suggestion));\n+            } else {\n+                err.help(&format!(\"have you added the `#[macro_use]` on the module/import?\"));\n+            }\n+        }\n+    }\n+}\n+\n+struct ExpansionVisitor<'b, 'a: 'b> {\n+    resolver: &'b mut Resolver<'a>,\n+    current_module: Rc<ModuleData>,\n+}\n+\n+impl<'a, 'b> ExpansionVisitor<'a, 'b> {\n+    fn visit_invoc(&mut self, id: ast::NodeId) {\n+        assert_eq!(id, self.resolver.expansion_data.len() as u32);\n+        self.resolver.expansion_data.push(ExpansionData {\n+            module: self.current_module.clone(),\n+        });\n+    }\n+\n+    // does this attribute list contain \"macro_use\"?\n+    fn contains_macro_use(&mut self, attrs: &[ast::Attribute]) -> bool {\n+        for attr in attrs {\n+            if attr.check_name(\"macro_escape\") {\n+                let msg = \"macro_escape is a deprecated synonym for macro_use\";\n+                let mut err = self.resolver.session.struct_span_warn(attr.span, msg);\n+                if let ast::AttrStyle::Inner = attr.node.style {\n+                    err.help(\"consider an outer attribute, #[macro_use] mod ...\").emit();\n+                } else {\n+                    err.emit();\n+                }\n+            } else if !attr.check_name(\"macro_use\") {\n+                continue;\n+            }\n+\n+            if !attr.is_word() {\n+                self.resolver.session.span_err(attr.span,\n+                                               \"arguments to macro_use are not allowed here\");\n+            }\n+            return true;\n+        }\n+\n+        false\n+    }\n+}\n+\n+macro_rules! method {\n+    ($visit:ident: $ty:ty, $invoc:path, $walk:ident) => {\n+        fn $visit(&mut self, node: &$ty) {\n+            match node.node {\n+                $invoc(..) => self.visit_invoc(node.id),\n+                _ => visit::$walk(self, node),\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'b> Visitor for ExpansionVisitor<'a, 'b>  {\n+    method!(visit_trait_item: ast::TraitItem, ast::TraitItemKind::Macro, walk_trait_item);\n+    method!(visit_impl_item:  ast::ImplItem,  ast::ImplItemKind::Macro,  walk_impl_item);\n+    method!(visit_stmt:       ast::Stmt,      ast::StmtKind::Mac,        walk_stmt);\n+    method!(visit_expr:       ast::Expr,      ast::ExprKind::Mac,        walk_expr);\n+    method!(visit_pat:        ast::Pat,       ast::PatKind::Mac,         walk_pat);\n+    method!(visit_ty:         ast::Ty,        ast::TyKind::Mac,          walk_ty);\n+\n+    fn visit_item(&mut self, item: &ast::Item) {\n+        match item.node {\n+            ast::ItemKind::Mac(..) if item.id == ast::DUMMY_NODE_ID => {} // Scope placeholder\n+            ast::ItemKind::Mac(..) => self.visit_invoc(item.id),\n+            ast::ItemKind::Mod(..) => {\n+                let module_data = ModuleData {\n+                    parent: Some(self.current_module.clone()),\n+                    macros: RefCell::new(FnvHashMap()),\n+                    macros_escape: self.contains_macro_use(&item.attrs),\n+                };\n+                let orig_module = mem::replace(&mut self.current_module, Rc::new(module_data));\n+                visit::walk_item(self, item);\n+                self.current_module = orig_module;\n+            }\n+            _ => visit::walk_item(self, item),\n+        }\n+    }\n+\n+    fn visit_block(&mut self, block: &ast::Block) {\n+        let module_data = ModuleData {\n+            parent: Some(self.current_module.clone()),\n+            macros: RefCell::new(FnvHashMap()),\n+            macros_escape: false,\n+        };\n+        let orig_module = mem::replace(&mut self.current_module, Rc::new(module_data));\n+        visit::walk_block(self, block);\n+        self.current_module = orig_module;\n+    }\n+}"}, {"sha": "d46e2a9872e8d6ccd71904717c3bb817bf561a57", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 61, "deletions": 237, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/72a636975fc5d0bb4af45af7bdd97987cc722a6a/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72a636975fc5d0bb4af45af7bdd97987cc722a6a/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=72a636975fc5d0bb4af45af7bdd97987cc722a6a", "patch": "@@ -10,27 +10,25 @@\n \n pub use self::SyntaxExtension::*;\n \n-use ast;\n-use ast::{Name, PatKind};\n+use ast::{self, Attribute, Name, PatKind};\n use attr::HasAttrs;\n use codemap::{self, CodeMap, ExpnInfo, Spanned, respan};\n use syntax_pos::{Span, ExpnId, NO_EXPANSION};\n use errors::DiagnosticBuilder;\n-use ext;\n-use ext::expand;\n+use ext::expand::{self, Invocation, Expansion};\n+use ext::hygiene::Mark;\n use ext::tt::macro_rules;\n use parse;\n use parse::parser;\n use parse::token;\n-use parse::token::{InternedString, intern, str_to_ident};\n+use parse::token::{InternedString, str_to_ident};\n use ptr::P;\n use std_inject;\n use util::small_vector::SmallVector;\n-use util::lev_distance::find_best_match_for_name;\n use fold::Folder;\n use feature_gate;\n \n-use std::collections::{HashMap, HashSet};\n+use std::collections::HashMap;\n use std::path::PathBuf;\n use std::rc::Rc;\n use tokenstream;\n@@ -44,15 +42,15 @@ pub enum Annotatable {\n }\n \n impl HasAttrs for Annotatable {\n-    fn attrs(&self) -> &[ast::Attribute] {\n+    fn attrs(&self) -> &[Attribute] {\n         match *self {\n             Annotatable::Item(ref item) => &item.attrs,\n             Annotatable::TraitItem(ref trait_item) => &trait_item.attrs,\n             Annotatable::ImplItem(ref impl_item) => &impl_item.attrs,\n         }\n     }\n \n-    fn map_attrs<F: FnOnce(Vec<ast::Attribute>) -> Vec<ast::Attribute>>(self, f: F) -> Self {\n+    fn map_attrs<F: FnOnce(Vec<Attribute>) -> Vec<Attribute>>(self, f: F) -> Self {\n         match self {\n             Annotatable::Item(item) => Annotatable::Item(item.map_attrs(f)),\n             Annotatable::TraitItem(trait_item) => Annotatable::TraitItem(trait_item.map_attrs(f)),\n@@ -464,91 +462,15 @@ pub enum SyntaxExtension {\n \n pub type NamedSyntaxExtension = (Name, SyntaxExtension);\n \n-/// The base map of methods for expanding syntax extension\n-/// AST nodes into full ASTs\n-fn initial_syntax_expander_table<'feat>(ecfg: &expand::ExpansionConfig<'feat>)\n-                                        -> SyntaxEnv {\n-    // utility function to simplify creating NormalTT syntax extensions\n-    fn builtin_normal_expander(f: MacroExpanderFn) -> SyntaxExtension {\n-        NormalTT(Box::new(f), None, false)\n-    }\n-\n-    let mut syntax_expanders = SyntaxEnv::new();\n-    syntax_expanders.insert(intern(\"macro_rules\"), MacroRulesTT);\n-\n-    if ecfg.enable_quotes() {\n-        // Quasi-quoting expanders\n-        syntax_expanders.insert(intern(\"quote_tokens\"),\n-                           builtin_normal_expander(\n-                                ext::quote::expand_quote_tokens));\n-        syntax_expanders.insert(intern(\"quote_expr\"),\n-                           builtin_normal_expander(\n-                                ext::quote::expand_quote_expr));\n-        syntax_expanders.insert(intern(\"quote_ty\"),\n-                           builtin_normal_expander(\n-                                ext::quote::expand_quote_ty));\n-        syntax_expanders.insert(intern(\"quote_item\"),\n-                           builtin_normal_expander(\n-                                ext::quote::expand_quote_item));\n-        syntax_expanders.insert(intern(\"quote_pat\"),\n-                           builtin_normal_expander(\n-                                ext::quote::expand_quote_pat));\n-        syntax_expanders.insert(intern(\"quote_arm\"),\n-                           builtin_normal_expander(\n-                                ext::quote::expand_quote_arm));\n-        syntax_expanders.insert(intern(\"quote_stmt\"),\n-                           builtin_normal_expander(\n-                                ext::quote::expand_quote_stmt));\n-        syntax_expanders.insert(intern(\"quote_matcher\"),\n-                           builtin_normal_expander(\n-                                ext::quote::expand_quote_matcher));\n-        syntax_expanders.insert(intern(\"quote_attr\"),\n-                           builtin_normal_expander(\n-                                ext::quote::expand_quote_attr));\n-        syntax_expanders.insert(intern(\"quote_arg\"),\n-                           builtin_normal_expander(\n-                                ext::quote::expand_quote_arg));\n-        syntax_expanders.insert(intern(\"quote_block\"),\n-                           builtin_normal_expander(\n-                                ext::quote::expand_quote_block));\n-        syntax_expanders.insert(intern(\"quote_meta_item\"),\n-                           builtin_normal_expander(\n-                                ext::quote::expand_quote_meta_item));\n-        syntax_expanders.insert(intern(\"quote_path\"),\n-                           builtin_normal_expander(\n-                                ext::quote::expand_quote_path));\n-    }\n-\n-    syntax_expanders.insert(intern(\"line\"),\n-                            builtin_normal_expander(\n-                                    ext::source_util::expand_line));\n-    syntax_expanders.insert(intern(\"column\"),\n-                            builtin_normal_expander(\n-                                    ext::source_util::expand_column));\n-    syntax_expanders.insert(intern(\"file\"),\n-                            builtin_normal_expander(\n-                                    ext::source_util::expand_file));\n-    syntax_expanders.insert(intern(\"stringify\"),\n-                            builtin_normal_expander(\n-                                    ext::source_util::expand_stringify));\n-    syntax_expanders.insert(intern(\"include\"),\n-                            builtin_normal_expander(\n-                                    ext::source_util::expand_include));\n-    syntax_expanders.insert(intern(\"include_str\"),\n-                            builtin_normal_expander(\n-                                    ext::source_util::expand_include_str));\n-    syntax_expanders.insert(intern(\"include_bytes\"),\n-                            builtin_normal_expander(\n-                                    ext::source_util::expand_include_bytes));\n-    syntax_expanders.insert(intern(\"module_path\"),\n-                            builtin_normal_expander(\n-                                    ext::source_util::expand_mod));\n-    syntax_expanders\n-}\n-\n pub trait Resolver {\n-    fn load_crate(&mut self, extern_crate: &ast::Item, allows_macros: bool)\n-                  -> Vec<LoadedMacro>;\n+    fn load_crate(&mut self, extern_crate: &ast::Item, allows_macros: bool) -> Vec<LoadedMacro>;\n+\n+    fn visit_expansion(&mut self, mark: Mark, expansion: &Expansion);\n+    fn add_macro(&mut self, scope: Mark, ident: ast::Ident, ext: Rc<SyntaxExtension>);\n+    fn add_expansions_at_stmt(&mut self, id: ast::NodeId, macros: Vec<Mark>);\n+\n+    fn find_attr_invoc(&mut self, attrs: &mut Vec<Attribute>) -> Option<Attribute>;\n+    fn resolve_invoc(&mut self, invoc: &Invocation) -> Option<Rc<SyntaxExtension>>;\n }\n \n pub enum LoadedMacro {\n@@ -558,9 +480,31 @@ pub enum LoadedMacro {\n \n pub struct DummyResolver;\n impl Resolver for DummyResolver {\n-    fn load_crate(&mut self, _: &ast::Item, _: bool) -> Vec<LoadedMacro> {\n+    fn load_crate(&mut self, _extern_crate: &ast::Item, _allows_macros: bool) -> Vec<LoadedMacro> {\n         Vec::new()\n     }\n+\n+    fn visit_expansion(&mut self, _invoc: Mark, _expansion: &Expansion) {}\n+    fn add_macro(&mut self, _scope: Mark, _ident: ast::Ident, _ext: Rc<SyntaxExtension>) {}\n+    fn add_expansions_at_stmt(&mut self, _id: ast::NodeId, _macros: Vec<Mark>) {}\n+\n+    fn find_attr_invoc(&mut self, _attrs: &mut Vec<Attribute>) -> Option<Attribute> { None }\n+    fn resolve_invoc(&mut self, _invoc: &Invocation) -> Option<Rc<SyntaxExtension>> { None }\n+}\n+\n+#[derive(Clone)]\n+pub struct ModuleData {\n+    pub mod_path: Vec<ast::Ident>,\n+    pub directory: PathBuf,\n+}\n+\n+#[derive(Clone)]\n+pub struct ExpansionData {\n+    pub mark: Mark,\n+    pub depth: usize,\n+    pub backtrace: ExpnId,\n+    pub module: Rc<ModuleData>,\n+    pub in_block: bool,\n }\n \n /// One of these is made during expansion and incrementally updated as we go;\n@@ -569,16 +513,12 @@ impl Resolver for DummyResolver {\n pub struct ExtCtxt<'a> {\n     pub parse_sess: &'a parse::ParseSess,\n     pub cfg: ast::CrateConfig,\n-    pub backtrace: ExpnId,\n     pub ecfg: expand::ExpansionConfig<'a>,\n     pub crate_root: Option<&'static str>,\n     pub resolver: &'a mut Resolver,\n-\n     pub exported_macros: Vec<ast::MacroDef>,\n-\n-    pub syntax_env: SyntaxEnv,\n     pub derive_modes: HashMap<InternedString, Box<MultiItemModifier>>,\n-    pub recursion_count: usize,\n+    pub current_expansion: ExpansionData,\n }\n \n impl<'a> ExtCtxt<'a> {\n@@ -587,16 +527,20 @@ impl<'a> ExtCtxt<'a> {\n                resolver: &'a mut Resolver)\n                -> ExtCtxt<'a> {\n         ExtCtxt {\n-            syntax_env: initial_syntax_expander_table(&ecfg),\n             parse_sess: parse_sess,\n             cfg: cfg,\n-            backtrace: NO_EXPANSION,\n             ecfg: ecfg,\n             crate_root: None,\n             exported_macros: Vec::new(),\n             resolver: resolver,\n             derive_modes: HashMap::new(),\n-            recursion_count: 0,\n+            current_expansion: ExpansionData {\n+                mark: Mark::root(),\n+                depth: 0,\n+                backtrace: NO_EXPANSION,\n+                module: Rc::new(ModuleData { mod_path: Vec::new(), directory: PathBuf::new() }),\n+                in_block: false,\n+            },\n         }\n     }\n \n@@ -609,23 +553,22 @@ impl<'a> ExtCtxt<'a> {\n         -> parser::Parser<'a> {\n         parse::tts_to_parser(self.parse_sess, tts.to_vec(), self.cfg())\n     }\n-\n     pub fn codemap(&self) -> &'a CodeMap { self.parse_sess.codemap() }\n     pub fn parse_sess(&self) -> &'a parse::ParseSess { self.parse_sess }\n     pub fn cfg(&self) -> ast::CrateConfig { self.cfg.clone() }\n     pub fn call_site(&self) -> Span {\n-        self.codemap().with_expn_info(self.backtrace, |ei| match ei {\n+        self.codemap().with_expn_info(self.backtrace(), |ei| match ei {\n             Some(expn_info) => expn_info.call_site,\n             None => self.bug(\"missing top span\")\n         })\n     }\n-    pub fn backtrace(&self) -> ExpnId { self.backtrace }\n+    pub fn backtrace(&self) -> ExpnId { self.current_expansion.backtrace }\n \n     /// Returns span for the macro which originally caused the current expansion to happen.\n     ///\n     /// Stops backtracing at include! boundary.\n     pub fn expansion_cause(&self) -> Span {\n-        let mut expn_id = self.backtrace;\n+        let mut expn_id = self.backtrace();\n         let mut last_macro = None;\n         loop {\n             if self.codemap().with_expn_info(expn_id, |info| {\n@@ -646,15 +589,15 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n     pub fn bt_push(&mut self, ei: ExpnInfo) {\n-        if self.recursion_count > self.ecfg.recursion_limit {\n+        if self.current_expansion.depth > self.ecfg.recursion_limit {\n             self.span_fatal(ei.call_site,\n                             &format!(\"recursion limit reached while expanding the macro `{}`\",\n                                     ei.callee.name()));\n         }\n \n         let mut call_site = ei.call_site;\n-        call_site.expn_id = self.backtrace;\n-        self.backtrace = self.codemap().record_expansion(ExpnInfo {\n+        call_site.expn_id = self.backtrace();\n+        self.current_expansion.backtrace = self.codemap().record_expansion(ExpnInfo {\n             call_site: call_site,\n             callee: ei.callee\n         });\n@@ -667,14 +610,11 @@ impl<'a> ExtCtxt<'a> {\n         }\n         if def.use_locally {\n             let ext = macro_rules::compile(self, &def);\n-            self.syntax_env.insert(def.ident.name, ext);\n+            self.resolver.add_macro(self.current_expansion.mark, def.ident, Rc::new(ext));\n         }\n     }\n \n-    pub fn insert_custom_derive(&mut self,\n-                                name: &str,\n-                                ext: Box<MultiItemModifier>,\n-                                sp: Span) {\n+    pub fn insert_custom_derive(&mut self, name: &str, ext: Box<MultiItemModifier>, sp: Span) {\n         if !self.ecfg.enable_rustc_macro() {\n             feature_gate::emit_feature_err(&self.parse_sess.span_diagnostic,\n                                            \"rustc_macro\",\n@@ -685,8 +625,7 @@ impl<'a> ExtCtxt<'a> {\n         }\n         let name = token::intern_and_get_ident(name);\n         if self.derive_modes.insert(name.clone(), ext).is_some() {\n-            self.span_err(sp, &format!(\"cannot shadow existing derive mode `{}`\",\n-                                       name));\n+            self.span_err(sp, &format!(\"cannot shadow existing derive mode `{}`\", name));\n         }\n     }\n \n@@ -765,20 +704,6 @@ impl<'a> ExtCtxt<'a> {\n         token::intern(st)\n     }\n \n-    pub fn suggest_macro_name(&mut self,\n-                              name: &str,\n-                              err: &mut DiagnosticBuilder<'a>) {\n-        let names = &self.syntax_env.names;\n-        if let Some(suggestion) = find_best_match_for_name(names.iter(), name, None) {\n-            if suggestion != name {\n-                err.help(&format!(\"did you mean `{}!`?\", suggestion));\n-            } else {\n-                err.help(&format!(\"have you added the `#[macro_use]` on the \\\n-                                   module/import?\"));\n-            }\n-        }\n-    }\n-\n     pub fn initialize(&mut self, user_exts: Vec<NamedSyntaxExtension>, krate: &ast::Crate) {\n         if std_inject::no_core(&krate) {\n             self.crate_root = None;\n@@ -789,16 +714,16 @@ impl<'a> ExtCtxt<'a> {\n         }\n \n         for (name, extension) in user_exts {\n-            self.syntax_env.insert(name, extension);\n+            let ident = ast::Ident::with_empty_ctxt(name);\n+            self.resolver.add_macro(Mark::root(), ident, Rc::new(extension));\n         }\n \n-        self.syntax_env.current_module = Module(0);\n-        let mut paths = ModulePaths {\n+        let mut module = ModuleData {\n             mod_path: vec![token::str_to_ident(&self.ecfg.crate_name)],\n             directory: PathBuf::from(self.parse_sess.codemap().span_to_filename(krate.span)),\n         };\n-        paths.directory.pop();\n-        self.syntax_env.module_data[0].paths = Rc::new(paths);\n+        module.directory.pop();\n+        self.current_expansion.module = Rc::new(module);\n     }\n }\n \n@@ -809,7 +734,7 @@ pub fn expr_to_spanned_string(cx: &mut ExtCtxt, expr: P<ast::Expr>, err_msg: &st\n                               -> Option<Spanned<(InternedString, ast::StrStyle)>> {\n     // Update `expr.span`'s expn_id now in case expr is an `include!` macro invocation.\n     let expr = expr.map(|mut expr| {\n-        expr.span.expn_id = cx.backtrace;\n+        expr.span.expn_id = cx.backtrace();\n         expr\n     });\n \n@@ -884,104 +809,3 @@ pub fn get_exprs_from_tts(cx: &mut ExtCtxt,\n     }\n     Some(es)\n }\n-\n-/// In order to have some notion of scoping for macros,\n-/// we want to implement the notion of a transformation\n-/// environment.\n-///\n-/// This environment maps Names to SyntaxExtensions.\n-pub struct SyntaxEnv {\n-    module_data: Vec<ModuleData>,\n-    pub current_module: Module,\n-\n-    /// All bang-style macro/extension names\n-    /// encountered so far; to be used for diagnostics in resolve\n-    pub names: HashSet<Name>,\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq)]\n-pub struct Module(u32);\n-\n-struct ModuleData {\n-    parent: Module,\n-    paths: Rc<ModulePaths>,\n-    macros: HashMap<Name, Rc<SyntaxExtension>>,\n-    macros_escape: bool,\n-    in_block: bool,\n-}\n-\n-#[derive(Clone)]\n-pub struct ModulePaths {\n-    pub mod_path: Vec<ast::Ident>,\n-    pub directory: PathBuf,\n-}\n-\n-impl SyntaxEnv {\n-    fn new() -> SyntaxEnv {\n-        let mut env = SyntaxEnv {\n-            current_module: Module(0),\n-            module_data: Vec::new(),\n-            names: HashSet::new(),\n-        };\n-        let paths = Rc::new(ModulePaths { mod_path: Vec::new(), directory: PathBuf::new() });\n-        env.add_module(false, false, paths);\n-        env\n-    }\n-\n-    fn data(&self, module: Module) -> &ModuleData {\n-        &self.module_data[module.0 as usize]\n-    }\n-\n-    pub fn paths(&self) -> Rc<ModulePaths> {\n-        self.data(self.current_module).paths.clone()\n-    }\n-\n-    pub fn in_block(&self) -> bool {\n-        self.data(self.current_module).in_block\n-    }\n-\n-    pub fn add_module(&mut self, macros_escape: bool, in_block: bool, paths: Rc<ModulePaths>)\n-                      -> Module {\n-        let data = ModuleData {\n-            parent: self.current_module,\n-            paths: paths,\n-            macros: HashMap::new(),\n-            macros_escape: macros_escape,\n-            in_block: in_block,\n-        };\n-\n-        self.module_data.push(data);\n-        Module(self.module_data.len() as u32 - 1)\n-    }\n-\n-    pub fn find(&self, name: Name) -> Option<Rc<SyntaxExtension>> {\n-        let mut module = self.current_module;\n-        let mut module_data;\n-        loop {\n-            module_data = self.data(module);\n-            if let Some(ext) = module_data.macros.get(&name) {\n-                return Some(ext.clone());\n-            }\n-            if module == module_data.parent {\n-                return None;\n-            }\n-            module = module_data.parent;\n-        }\n-    }\n-\n-    pub fn insert(&mut self, name: Name, ext: SyntaxExtension) {\n-        if let NormalTT(..) = ext {\n-            self.names.insert(name);\n-        }\n-\n-        let mut module = self.current_module;\n-        while self.data(module).macros_escape {\n-            module = self.data(module).parent;\n-        }\n-        self.module_data[module.0 as usize].macros.insert(name, Rc::new(ext));\n-    }\n-\n-    pub fn is_crate_root(&mut self) -> bool {\n-        self.current_module == Module(0)\n-    }\n-}"}, {"sha": "beb1687dfdc72578173cb23711ea52d05db27486", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 77, "deletions": 105, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/72a636975fc5d0bb4af45af7bdd97987cc722a6a/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72a636975fc5d0bb4af45af7bdd97987cc722a6a/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=72a636975fc5d0bb4af45af7bdd97987cc722a6a", "patch": "@@ -25,14 +25,16 @@ use parse::token::{intern, keywords};\n use ptr::P;\n use tokenstream::TokenTree;\n use util::small_vector::SmallVector;\n+use visit::Visitor;\n \n use std::mem;\n use std::path::PathBuf;\n use std::rc::Rc;\n \n macro_rules! expansions {\n     ($($kind:ident: $ty:ty [$($vec:ident, $ty_elt:ty)*], $kind_name:expr, .$make:ident,\n-            $(.$fold:ident)*  $(lift .$fold_elt:ident)*;)*) => {\n+            $(.$fold:ident)*  $(lift .$fold_elt:ident)*,\n+            $(.$visit:ident)*  $(lift .$visit_elt:ident)*;)*) => {\n         #[derive(Copy, Clone)]\n         pub enum ExpansionKind { OptExpr, $( $kind, )*  }\n         pub enum Expansion { OptExpr(Option<P<ast::Expr>>), $( $kind($ty), )* }\n@@ -77,6 +79,17 @@ macro_rules! expansions {\n                     }, )*)*\n                 }\n             }\n+\n+            pub fn visit_with<V: Visitor>(&self, visitor: &mut V) {\n+                match *self {\n+                    Expansion::OptExpr(Some(ref expr)) => visitor.visit_expr(expr),\n+                    Expansion::OptExpr(None) => {}\n+                    $($( Expansion::$kind(ref ast) => visitor.$visit(ast), )*)*\n+                    $($( Expansion::$kind(ref ast) => for ast in ast.as_slice() {\n+                        visitor.$visit_elt(ast);\n+                    }, )*)*\n+                }\n+            }\n         }\n \n         impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n@@ -94,17 +107,17 @@ macro_rules! expansions {\n }\n \n expansions! {\n-    Expr: P<ast::Expr> [], \"expression\", .make_expr, .fold_expr;\n-    Pat: P<ast::Pat>   [], \"pattern\",    .make_pat,  .fold_pat;\n-    Ty: P<ast::Ty>     [], \"type\",       .make_ty,   .fold_ty;\n+    Expr: P<ast::Expr> [], \"expression\", .make_expr, .fold_expr, .visit_expr;\n+    Pat: P<ast::Pat>   [], \"pattern\",    .make_pat,  .fold_pat,  .visit_pat;\n+    Ty: P<ast::Ty>     [], \"type\",       .make_ty,   .fold_ty,   .visit_ty;\n     Stmts: SmallVector<ast::Stmt> [SmallVector, ast::Stmt],\n-        \"statement\",  .make_stmts,       lift .fold_stmt;\n+        \"statement\",  .make_stmts,       lift .fold_stmt, lift .visit_stmt;\n     Items: SmallVector<P<ast::Item>> [SmallVector, P<ast::Item>],\n-        \"item\",       .make_items,       lift .fold_item;\n+        \"item\",       .make_items,       lift .fold_item, lift .visit_item;\n     TraitItems: SmallVector<ast::TraitItem> [SmallVector, ast::TraitItem],\n-        \"trait item\", .make_trait_items, lift .fold_trait_item;\n+        \"trait item\", .make_trait_items, lift .fold_trait_item, lift .visit_trait_item;\n     ImplItems: SmallVector<ast::ImplItem> [SmallVector, ast::ImplItem],\n-        \"impl item\",  .make_impl_items,  lift .fold_impl_item;\n+        \"impl item\",  .make_impl_items,  lift .fold_impl_item,  lift .visit_impl_item;\n }\n \n impl ExpansionKind {\n@@ -127,15 +140,12 @@ impl ExpansionKind {\n }\n \n pub struct Invocation {\n-    kind: InvocationKind,\n+    pub kind: InvocationKind,\n     expansion_kind: ExpansionKind,\n-    mark: Mark,\n-    module: Module,\n-    backtrace: ExpnId,\n-    depth: usize,\n+    expansion_data: ExpansionData,\n }\n \n-enum InvocationKind {\n+pub enum InvocationKind {\n     Bang {\n         attrs: Vec<ast::Attribute>,\n         mac: ast::Mac,\n@@ -148,6 +158,19 @@ enum InvocationKind {\n     },\n }\n \n+impl Invocation {\n+    fn span(&self) -> Span {\n+        match self.kind {\n+            InvocationKind::Bang { span, .. } => span,\n+            InvocationKind::Attr { ref attr, .. } => attr.span,\n+        }\n+    }\n+\n+    pub fn mark(&self) -> Mark {\n+        self.expansion_data.mark\n+    }\n+}\n+\n pub struct MacroExpander<'a, 'b:'a> {\n     pub cx: &'a mut ExtCtxt<'b>,\n     pub single_step: bool,\n@@ -170,7 +193,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n         let items = Expansion::Items(SmallVector::many(krate.module.items));\n         krate.module.items = self.expand(items).make_items().into();\n-        krate.exported_macros = self.cx.exported_macros.clone();\n+        krate.exported_macros = mem::replace(&mut self.cx.exported_macros, Vec::new());\n \n         if self.cx.parse_sess.span_diagnostic.err_count() > err_count {\n             self.cx.parse_sess.span_diagnostic.abort_if_errors();\n@@ -181,21 +204,23 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n     // Fully expand all the invocations in `expansion`.\n     fn expand(&mut self, expansion: Expansion) -> Expansion {\n-        self.cx.recursion_count = 0;\n+        let orig_expansion_data = self.cx.current_expansion.clone();\n+        self.cx.current_expansion.depth = 0;\n+\n         let (expansion, mut invocations) = self.collect_invocations(expansion);\n         invocations.reverse();\n \n         let mut expansions = vec![vec![(0, expansion)]];\n         while let Some(invoc) = invocations.pop() {\n-            let Invocation { mark, module, depth, backtrace, .. } = invoc;\n-            self.cx.syntax_env.current_module = module;\n-            self.cx.recursion_count = depth;\n-            self.cx.backtrace = backtrace;\n+            let ExpansionData { depth, mark, .. } = invoc.expansion_data;\n+            self.cx.current_expansion = invoc.expansion_data.clone();\n \n-            let expansion = self.expand_invoc(invoc);\n+            let expansion = match self.cx.resolver.resolve_invoc(&invoc) {\n+                Some(ext) => self.expand_invoc(invoc, ext),\n+                None => invoc.expansion_kind.dummy(invoc.span()),\n+            };\n \n-            self.cx.syntax_env.current_module = module;\n-            self.cx.recursion_count = depth + 1;\n+            self.cx.current_expansion.depth = depth + 1;\n             let (expansion, new_invocations) = self.collect_invocations(expansion);\n \n             if expansions.len() == depth {\n@@ -207,6 +232,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             }\n         }\n \n+        self.cx.current_expansion = orig_expansion_data;\n+\n         let mut placeholder_expander = PlaceholderExpander::new();\n         while let Some(expansions) = expansions.pop() {\n             for (mark, expansion) in expansions.into_iter().rev() {\n@@ -233,30 +260,27 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             };\n             (expansion.fold_with(&mut collector), collector.invocations)\n         };\n-\n         self.cx.cfg = crate_config;\n+\n+        let mark = self.cx.current_expansion.mark;\n+        self.cx.resolver.visit_expansion(mark, &result.0);\n         result\n     }\n \n-    fn expand_invoc(&mut self, invoc: Invocation) -> Expansion {\n+    fn expand_invoc(&mut self, invoc: Invocation, ext: Rc<SyntaxExtension>) -> Expansion {\n         match invoc.kind {\n-            InvocationKind::Bang { .. } => self.expand_bang_invoc(invoc),\n-            InvocationKind::Attr { .. } => self.expand_attr_invoc(invoc),\n+            InvocationKind::Bang { .. } => self.expand_bang_invoc(invoc, ext),\n+            InvocationKind::Attr { .. } => self.expand_attr_invoc(invoc, ext),\n         }\n     }\n \n-    fn expand_attr_invoc(&mut self, invoc: Invocation) -> Expansion {\n+    fn expand_attr_invoc(&mut self, invoc: Invocation, ext: Rc<SyntaxExtension>) -> Expansion {\n         let Invocation { expansion_kind: kind, .. } = invoc;\n         let (attr, item) = match invoc.kind {\n             InvocationKind::Attr { attr, item } => (attr, item),\n             _ => unreachable!(),\n         };\n \n-        let extension = match self.cx.syntax_env.find(intern(&attr.name())) {\n-            Some(extension) => extension,\n-            None => unreachable!(),\n-        };\n-\n         attr::mark_used(&attr);\n         self.cx.bt_push(ExpnInfo {\n             call_site: attr.span,\n@@ -267,7 +291,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             }\n         });\n \n-        match *extension {\n+        match *ext {\n             MultiModifier(ref mac) => {\n                 let item = mac.expand(self.cx, attr.span, &attr.node.value, item);\n                 kind.expect_from_annotatables(item)\n@@ -284,8 +308,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     }\n \n     /// Expand a macro invocation. Returns the result of expansion.\n-    fn expand_bang_invoc(&mut self, invoc: Invocation) -> Expansion {\n-        let Invocation { mark, expansion_kind: kind, .. } = invoc;\n+    fn expand_bang_invoc(&mut self, invoc: Invocation, ext: Rc<SyntaxExtension>) -> Expansion {\n+        let (mark, kind) = (invoc.mark(), invoc.expansion_kind);\n         let (attrs, mac, ident, span) = match invoc.kind {\n             InvocationKind::Bang { attrs, mac, ident, span } => (attrs, mac, ident, span),\n             _ => unreachable!(),\n@@ -306,19 +330,9 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n \n         let extname = path.segments[0].identifier.name;\n-        let extension = if let Some(extension) = self.cx.syntax_env.find(extname) {\n-            extension\n-        } else {\n-            let mut err =\n-                self.cx.struct_span_err(path.span, &format!(\"macro undefined: '{}!'\", &extname));\n-            self.cx.suggest_macro_name(&extname.as_str(), &mut err);\n-            err.emit();\n-            return kind.dummy(span);\n-        };\n-\n         let ident = ident.unwrap_or(keywords::Invalid.ident());\n         let marked_tts = mark_tts(&tts, mark);\n-        let opt_expanded = match *extension {\n+        let opt_expanded = match *ext {\n             NormalTT(ref expandfun, exp_span, allow_internal_unstable) => {\n                 if ident.name != keywords::Invalid.name() {\n                     let msg =\n@@ -442,10 +456,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n         self.invocations.push(Invocation {\n             kind: kind,\n             expansion_kind: expansion_kind,\n-            mark: mark,\n-            module: self.cx.syntax_env.current_module,\n-            backtrace: self.cx.backtrace,\n-            depth: self.cx.recursion_count,\n+            expansion_data: ExpansionData { mark: mark, ..self.cx.current_expansion.clone() },\n         });\n         placeholder(expansion_kind, mark.as_u32())\n     }\n@@ -462,50 +473,15 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n     }\n \n     // If `item` is an attr invocation, remove and return the macro attribute.\n-    fn classify_item<T: HasAttrs>(&self, mut item: T) -> (T, Option<ast::Attribute>) {\n+    fn classify_item<T: HasAttrs>(&mut self, mut item: T) -> (T, Option<ast::Attribute>) {\n         let mut attr = None;\n         item = item.map_attrs(|mut attrs| {\n-            for i in 0..attrs.len() {\n-                if let Some(extension) = self.cx.syntax_env.find(intern(&attrs[i].name())) {\n-                    match *extension {\n-                        MultiModifier(..) | MultiDecorator(..) => {\n-                            attr = Some(attrs.remove(i));\n-                            break;\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-            }\n+            attr = self.cx.resolver.find_attr_invoc(&mut attrs);\n             attrs\n         });\n         (item, attr)\n     }\n \n-    // does this attribute list contain \"macro_use\" ?\n-    fn contains_macro_use(&mut self, attrs: &[ast::Attribute]) -> bool {\n-        for attr in attrs {\n-            let mut is_use = attr.check_name(\"macro_use\");\n-            if attr.check_name(\"macro_escape\") {\n-                let msg = \"macro_escape is a deprecated synonym for macro_use\";\n-                let mut err = self.cx.struct_span_warn(attr.span, msg);\n-                is_use = true;\n-                if let ast::AttrStyle::Inner = attr.node.style {\n-                    err.help(\"consider an outer attribute, #[macro_use] mod ...\").emit();\n-                } else {\n-                    err.emit();\n-                }\n-            };\n-\n-            if is_use {\n-                if !attr.is_word() {\n-                    self.cx.span_err(attr.span, \"arguments to macro_use are not allowed here\");\n-                }\n-                return true;\n-            }\n-        }\n-        false\n-    }\n-\n     fn configure<T: HasAttrs>(&mut self, node: T) -> Option<T> {\n         self.cfg.configure(node)\n     }\n@@ -574,11 +550,9 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n     }\n \n     fn fold_block(&mut self, block: P<Block>) -> P<Block> {\n-        let paths = self.cx.syntax_env.paths();\n-        let module = self.cx.syntax_env.add_module(false, true, paths);\n-        let orig_module = mem::replace(&mut self.cx.syntax_env.current_module, module);\n+        let orig_in_block = mem::replace(&mut self.cx.current_expansion.in_block, true);\n         let result = noop_fold_block(block, self);\n-        self.cx.syntax_env.current_module = orig_module;\n+        self.cx.current_expansion.in_block = orig_in_block;\n         result\n     }\n \n@@ -613,37 +587,35 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n                 })\n             }\n             ast::ItemKind::Mod(ast::Mod { inner, .. }) => {\n-                let mut paths = (*self.cx.syntax_env.paths()).clone();\n-                paths.mod_path.push(item.ident);\n+                let mut module = (*self.cx.current_expansion.module).clone();\n+                module.mod_path.push(item.ident);\n \n                 // Detect if this is an inline module (`mod m { ... }` as opposed to `mod m;`).\n                 // In the non-inline case, `inner` is never the dummy span (c.f. `parse_item_mod`).\n                 // Thus, if `inner` is the dummy span, we know the module is inline.\n                 let inline_module = item.span.contains(inner) || inner == syntax_pos::DUMMY_SP;\n \n                 if inline_module {\n-                    paths.directory.push(&*{\n+                    module.directory.push(&*{\n                         ::attr::first_attr_value_str_by_name(&item.attrs, \"path\")\n                             .unwrap_or(item.ident.name.as_str())\n                     });\n                 } else {\n-                    paths.directory =\n+                    module.directory =\n                         PathBuf::from(self.cx.parse_sess.codemap().span_to_filename(inner));\n-                    paths.directory.pop();\n+                    module.directory.pop();\n                 }\n \n-                let macro_use = self.contains_macro_use(&item.attrs);\n-                let in_block = self.cx.syntax_env.in_block();\n-                let module = self.cx.syntax_env.add_module(macro_use, in_block, Rc::new(paths));\n-                let module = mem::replace(&mut self.cx.syntax_env.current_module, module);\n+                let orig_module =\n+                    mem::replace(&mut self.cx.current_expansion.module, Rc::new(module));\n                 let result = noop_fold_item(item, self);\n-                self.cx.syntax_env.current_module = module;\n-                result\n-            },\n+                self.cx.current_expansion.module = orig_module;\n+                return result;\n+            }\n             ast::ItemKind::ExternCrate(..) => {\n                 // We need to error on `#[macro_use] extern crate` when it isn't at the\n                 // crate root, because `$crate` won't work properly.\n-                let is_crate_root = self.cx.syntax_env.is_crate_root();\n+                let is_crate_root = self.cx.current_expansion.module.mod_path.len() == 1;\n                 for def in self.cx.resolver.load_crate(&*item, is_crate_root) {\n                     match def {\n                         LoadedMacro::Def(def) => self.cx.insert_macro(def),"}, {"sha": "34126fac4ac784c888a282a0e947ba8685998400", "filename": "src/libsyntax/ext/hygiene.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/72a636975fc5d0bb4af45af7bdd97987cc722a6a/src%2Flibsyntax%2Fext%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72a636975fc5d0bb4af45af7bdd97987cc722a6a/src%2Flibsyntax%2Fext%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fhygiene.rs?ref=72a636975fc5d0bb4af45af7bdd97987cc722a6a", "patch": "@@ -29,7 +29,7 @@ pub struct SyntaxContextData {\n     pub prev_ctxt: SyntaxContext,\n }\n \n-/// A mark represents a unique id associated with a macro expansion.\n+/// A mark is a unique id associated with a macro expansion.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, Default)]\n pub struct Mark(u32);\n \n@@ -41,6 +41,11 @@ impl Mark {\n         })\n     }\n \n+    /// The mark of the theoretical expansion that generates freshly parsed, unexpanded AST.\n+    pub fn root() -> Self {\n+        Mark(0)\n+    }\n+\n     pub fn as_u32(&self) -> u32 {\n         self.0\n     }\n@@ -56,8 +61,8 @@ impl HygieneData {\n     fn new() -> Self {\n         HygieneData {\n             syntax_contexts: vec![SyntaxContextData {\n-                outer_mark: Mark(0), // the null mark\n-                prev_ctxt: SyntaxContext(0), // the empty context\n+                outer_mark: Mark::root(),\n+                prev_ctxt: SyntaxContext::empty(),\n             }],\n             markings: HashMap::new(),\n             next_mark: Mark(1),"}, {"sha": "e75e41d0c2d4bf61238d35b61ebe895d824fac8a", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/72a636975fc5d0bb4af45af7bdd97987cc722a6a/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72a636975fc5d0bb4af45af7bdd97987cc722a6a/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=72a636975fc5d0bb4af45af7bdd97987cc722a6a", "patch": "@@ -74,8 +74,8 @@ pub fn expand_stringify(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTre\n pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n                   -> Box<base::MacResult+'static> {\n     base::check_zero_tts(cx, sp, tts, \"module_path!\");\n-    let paths = cx.syntax_env.paths();\n-    let string = paths.mod_path.iter().map(|x| x.to_string()).collect::<Vec<String>>().join(\"::\");\n+    let mod_path = &cx.current_expansion.module.mod_path;\n+    let string = mod_path.iter().map(|x| x.to_string()).collect::<Vec<String>>().join(\"::\");\n \n     base::MacEager::expr(cx.expr_str(\n             sp,"}, {"sha": "51ef45b97be6f336aef5e6e510b15d57b62f6887", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/72a636975fc5d0bb4af45af7bdd97987cc722a6a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72a636975fc5d0bb4af45af7bdd97987cc722a6a/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=72a636975fc5d0bb4af45af7bdd97987cc722a6a", "patch": "@@ -211,8 +211,8 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                                            imported_from,\n                                            rhs);\n                 let mut p = Parser::new(cx.parse_sess(), cx.cfg(), Box::new(trncbr));\n-                p.directory = cx.syntax_env.paths().directory.clone();\n-                p.restrictions = match cx.syntax_env.in_block() {\n+                p.directory = cx.current_expansion.module.directory.clone();\n+                p.restrictions = match cx.current_expansion.in_block {\n                     true => Restrictions::NO_NONINLINE_MOD,\n                     false => Restrictions::empty(),\n                 };"}, {"sha": "6162beb80eccc7d9eb53c92cabd9c8e7b5f9e251", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/72a636975fc5d0bb4af45af7bdd97987cc722a6a/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72a636975fc5d0bb4af45af7bdd97987cc722a6a/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=72a636975fc5d0bb4af45af7bdd97987cc722a6a", "patch": "@@ -11,8 +11,7 @@\n //! The compiler code necessary to implement the `#[derive]` extensions.\n \n use syntax::ast::{self, MetaItem};\n-use syntax::ext::base::{Annotatable, ExtCtxt, SyntaxEnv};\n-use syntax::ext::base::MultiModifier;\n+use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::feature_gate;\n use syntax::codemap;\n@@ -89,7 +88,7 @@ fn allow_unstable(cx: &mut ExtCtxt, span: Span, attr_name: &str) -> Span {\n     }\n }\n \n-fn expand_derive(cx: &mut ExtCtxt,\n+pub fn expand_derive(cx: &mut ExtCtxt,\n                  span: Span,\n                  mitem: &MetaItem,\n                  annotatable: Annotatable)\n@@ -243,10 +242,6 @@ fn expand_derive(cx: &mut ExtCtxt,\n \n macro_rules! derive_traits {\n     ($( $name:expr => $func:path, )+) => {\n-        pub fn register_all(env: &mut SyntaxEnv) {\n-            env.insert(intern(\"derive\"), MultiModifier(Box::new(expand_derive)));\n-        }\n-\n         pub fn is_builtin_trait(name: &str) -> bool {\n             match name {\n                 $( $name )|+ => true,"}, {"sha": "3a6212e5445ce6d687940e3e36a1ea37369d0be6", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 61, "deletions": 27, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/72a636975fc5d0bb4af45af7bdd97987cc722a6a/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72a636975fc5d0bb4af45af7bdd97987cc722a6a/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=72a636975fc5d0bb4af45af7bdd97987cc722a6a", "patch": "@@ -34,11 +34,6 @@ extern crate syntax_pos;\n extern crate rustc_macro;\n extern crate rustc_errors as errors;\n \n-use syntax::ext::base::{MacroExpanderFn, NormalTT};\n-use syntax::ext::base::{SyntaxEnv, SyntaxExtension};\n-use syntax::parse::token::intern;\n-\n-\n mod asm;\n mod cfg;\n mod concat;\n@@ -53,28 +48,67 @@ pub mod rustc_macro_registrar;\n // for custom_derive\n pub mod deriving;\n \n-pub fn register_builtins(env: &mut SyntaxEnv) {\n-    // utility function to simplify creating NormalTT syntax extensions\n-    fn builtin_normal_expander(f: MacroExpanderFn) -> SyntaxExtension {\n-        NormalTT(Box::new(f), None, false)\n+use std::rc::Rc;\n+use syntax::ast;\n+use syntax::ext::base::{MacroExpanderFn, MacroRulesTT, NormalTT, MultiModifier};\n+use syntax::ext::hygiene::Mark;\n+use syntax::parse::token::intern;\n+\n+pub fn register_builtins(resolver: &mut syntax::ext::base::Resolver, enable_quotes: bool) {\n+    let mut register = |name, ext| {\n+        resolver.add_macro(Mark::root(), ast::Ident::with_empty_ctxt(intern(name)), Rc::new(ext));\n+    };\n+\n+    register(\"macro_rules\", MacroRulesTT);\n+\n+    macro_rules! register {\n+        ($( $name:ident: $f:expr, )*) => { $(\n+            register(stringify!($name), NormalTT(Box::new($f as MacroExpanderFn), None, false));\n+        )* }\n     }\n \n-    env.insert(intern(\"asm\"), builtin_normal_expander(asm::expand_asm));\n-    env.insert(intern(\"cfg\"), builtin_normal_expander(cfg::expand_cfg));\n-    env.insert(intern(\"concat\"),\n-               builtin_normal_expander(concat::expand_syntax_ext));\n-    env.insert(intern(\"concat_idents\"),\n-               builtin_normal_expander(concat_idents::expand_syntax_ext));\n-    env.insert(intern(\"env\"), builtin_normal_expander(env::expand_env));\n-    env.insert(intern(\"option_env\"),\n-               builtin_normal_expander(env::expand_option_env));\n-    env.insert(intern(\"format_args\"),\n-               // format_args uses `unstable` things internally.\n-               NormalTT(Box::new(format::expand_format_args), None, true));\n-    env.insert(intern(\"log_syntax\"),\n-               builtin_normal_expander(log_syntax::expand_syntax_ext));\n-    env.insert(intern(\"trace_macros\"),\n-               builtin_normal_expander(trace_macros::expand_trace_macros));\n-\n-    deriving::register_all(env);\n+    if enable_quotes {\n+        use syntax::ext::quote::*;\n+        register! {\n+            quote_tokens: expand_quote_tokens,\n+            quote_expr: expand_quote_expr,\n+            quote_ty: expand_quote_ty,\n+            quote_item: expand_quote_item,\n+            quote_pat: expand_quote_pat,\n+            quote_arm: expand_quote_arm,\n+            quote_stmt: expand_quote_stmt,\n+            quote_matcher: expand_quote_matcher,\n+            quote_attr: expand_quote_attr,\n+            quote_arg: expand_quote_arg,\n+            quote_block: expand_quote_block,\n+            quote_meta_item: expand_quote_meta_item,\n+            quote_path: expand_quote_path,\n+        }\n+    }\n+\n+    use syntax::ext::source_util::*;\n+    register! {\n+        line: expand_line,\n+        column: expand_column,\n+        file: expand_file,\n+        stringify: expand_stringify,\n+        include: expand_include,\n+        include_str: expand_include_str,\n+        include_bytes: expand_include_bytes,\n+        module_path: expand_mod,\n+\n+        asm: asm::expand_asm,\n+        cfg: cfg::expand_cfg,\n+        concat: concat::expand_syntax_ext,\n+        concat_idents: concat_idents::expand_syntax_ext,\n+        env: env::expand_env,\n+        option_env: env::expand_option_env,\n+        log_syntax: log_syntax::expand_syntax_ext,\n+        trace_macros: trace_macros::expand_trace_macros,\n+    }\n+\n+    // format_args uses `unstable` things internally.\n+    register(\"format_args\", NormalTT(Box::new(format::expand_format_args), None, true));\n+\n+    register(\"derive\", MultiModifier(Box::new(deriving::expand_derive)));\n }"}]}