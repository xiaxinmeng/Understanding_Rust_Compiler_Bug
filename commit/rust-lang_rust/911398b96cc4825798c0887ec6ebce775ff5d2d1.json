{"sha": "911398b96cc4825798c0887ec6ebce775ff5d2d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxMTM5OGI5NmNjNDgyNTc5OGMwODg3ZWM2ZWJjZTc3NWZmNWQyZDE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-08-14T13:38:40Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-08-14T13:38:40Z"}, "message": "remove special handling of \\r\\n from the lexer", "tree": {"sha": "24dea0cc5e5b81b8d7b943517ce493581bb5786f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24dea0cc5e5b81b8d7b943517ce493581bb5786f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/911398b96cc4825798c0887ec6ebce775ff5d2d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/911398b96cc4825798c0887ec6ebce775ff5d2d1", "html_url": "https://github.com/rust-lang/rust/commit/911398b96cc4825798c0887ec6ebce775ff5d2d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/911398b96cc4825798c0887ec6ebce775ff5d2d1/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "004f3acec11fa599d1afe71d85121f1c345d8769", "url": "https://api.github.com/repos/rust-lang/rust/commits/004f3acec11fa599d1afe71d85121f1c345d8769", "html_url": "https://github.com/rust-lang/rust/commit/004f3acec11fa599d1afe71d85121f1c345d8769"}], "stats": {"total": 130, "additions": 26, "deletions": 104}, "files": [{"sha": "afef307a0ed3702b1355a14cffa16a23c57d4f60", "filename": "src/librustc_lexer/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/911398b96cc4825798c0887ec6ebce775ff5d2d1/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911398b96cc4825798c0887ec6ebce775ff5d2d1/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Flib.rs?ref=911398b96cc4825798c0887ec6ebce775ff5d2d1", "patch": "@@ -352,7 +352,6 @@ impl Cursor<'_> {\n         loop {\n             match self.nth_char(0) {\n                 '\\n' => break,\n-                '\\r' if self.nth_char(1) == '\\n' => break,\n                 EOF_CHAR if self.is_eof() => break,\n                 _ => {\n                     self.bump();\n@@ -525,7 +524,6 @@ impl Cursor<'_> {\n             match self.nth_char(0) {\n                 '/' if !first => break,\n                 '\\n' if self.nth_char(1) != '\\'' => break,\n-                '\\r' if self.nth_char(1) == '\\n' => break,\n                 EOF_CHAR if self.is_eof() => break,\n                 '\\'' => {\n                     self.bump();"}, {"sha": "c709b7526082f6a3c18ba057cbed48a0bb4a0e11", "filename": "src/librustc_lexer/src/unescape.rs", "status": "modified", "additions": 8, "deletions": 28, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/911398b96cc4825798c0887ec6ebce775ff5d2d1/src%2Flibrustc_lexer%2Fsrc%2Funescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911398b96cc4825798c0887ec6ebce775ff5d2d1/src%2Flibrustc_lexer%2Fsrc%2Funescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Funescape.rs?ref=911398b96cc4825798c0887ec6ebce775ff5d2d1", "patch": "@@ -128,11 +128,7 @@ fn scan_escape(first_char: char, chars: &mut Chars<'_>, mode: Mode) -> Result<ch\n     if first_char != '\\\\' {\n         return match first_char {\n             '\\t' | '\\n' => Err(EscapeError::EscapeOnlyChar),\n-            '\\r' => Err(if chars.clone().next() == Some('\\n') {\n-                EscapeError::EscapeOnlyChar\n-            } else {\n-                EscapeError::BareCarriageReturn\n-            }),\n+            '\\r' => Err(EscapeError::BareCarriageReturn),\n             '\\'' if mode.in_single_quotes() => Err(EscapeError::EscapeOnlyChar),\n             '\"' if mode.in_double_quotes() => Err(EscapeError::EscapeOnlyChar),\n             _ => {\n@@ -244,27 +240,15 @@ where\n \n         let unescaped_char = match first_char {\n             '\\\\' => {\n-                let (second_char, third_char) = {\n-                    let mut chars = chars.clone();\n-                    (chars.next(), chars.next())\n-                };\n-                match (second_char, third_char) {\n-                    (Some('\\n'), _) | (Some('\\r'), Some('\\n')) => {\n+                let second_char = chars.clone().next();\n+                match second_char {\n+                    Some('\\n') => {\n                         skip_ascii_whitespace(&mut chars);\n                         continue;\n                     }\n                     _ => scan_escape(first_char, &mut chars, mode),\n                 }\n             }\n-            '\\r' => {\n-                let second_char = chars.clone().next();\n-                if second_char == Some('\\n') {\n-                    chars.next();\n-                    Ok('\\n')\n-                } else {\n-                    scan_escape(first_char, &mut chars, mode)\n-                }\n-            }\n             '\\n' => Ok('\\n'),\n             '\\t' => Ok('\\t'),\n             _ => scan_escape(first_char, &mut chars, mode),\n@@ -298,15 +282,11 @@ where\n     while let Some(curr) = chars.next() {\n         let start = initial_len - chars.as_str().len() - curr.len_utf8();\n \n-        let result = match (curr, chars.clone().next()) {\n-            ('\\r', Some('\\n')) => {\n-                chars.next();\n-                Ok('\\n')\n-            },\n-            ('\\r', _) => Err(EscapeError::BareCarriageReturnInRawString),\n-            (c, _) if mode.is_bytes() && !c.is_ascii() =>\n+        let result = match curr {\n+            '\\r' => Err(EscapeError::BareCarriageReturnInRawString),\n+            c if mode.is_bytes() && !c.is_ascii() =>\n                 Err(EscapeError::NonAsciiCharInByteString),\n-            (c, _) => Ok(c),\n+            c => Ok(c),\n         };\n         let end = initial_len - chars.as_str().len();\n "}, {"sha": "e7b1ff6479d88dc4f60888bbd8ccf62fe5e9ff94", "filename": "src/librustc_lexer/src/unescape/tests.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/911398b96cc4825798c0887ec6ebce775ff5d2d1/src%2Flibrustc_lexer%2Fsrc%2Funescape%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911398b96cc4825798c0887ec6ebce775ff5d2d1/src%2Flibrustc_lexer%2Fsrc%2Funescape%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Funescape%2Ftests.rs?ref=911398b96cc4825798c0887ec6ebce775ff5d2d1", "patch": "@@ -11,7 +11,6 @@ fn test_unescape_char_bad() {\n     check(r\"\\\", EscapeError::LoneSlash);\n \n     check(\"\\n\", EscapeError::EscapeOnlyChar);\n-    check(\"\\r\\n\", EscapeError::EscapeOnlyChar);\n     check(\"\\t\", EscapeError::EscapeOnlyChar);\n     check(\"'\", EscapeError::EscapeOnlyChar);\n     check(\"\\r\", EscapeError::BareCarriageReturn);\n@@ -31,6 +30,7 @@ fn test_unescape_char_bad() {\n     check(r\"\\v\", EscapeError::InvalidEscape);\n     check(r\"\\\ud83d\udca9\", EscapeError::InvalidEscape);\n     check(r\"\\\u25cf\", EscapeError::InvalidEscape);\n+    check(\"\\\\\\r\", EscapeError::InvalidEscape);\n \n     check(r\"\\x\", EscapeError::TooShortHexEscape);\n     check(r\"\\x0\", EscapeError::TooShortHexEscape);\n@@ -116,10 +116,9 @@ fn test_unescape_str_good() {\n \n     check(\"foo\", \"foo\");\n     check(\"\", \"\");\n-    check(\" \\t\\n\\r\\n\", \" \\t\\n\\n\");\n+    check(\" \\t\\n\", \" \\t\\n\");\n \n     check(\"hello \\\\\\n     world\", \"hello world\");\n-    check(\"hello \\\\\\r\\n     world\", \"hello world\");\n     check(\"thread's\", \"thread's\")\n }\n \n@@ -134,7 +133,6 @@ fn test_unescape_byte_bad() {\n     check(r\"\\\", EscapeError::LoneSlash);\n \n     check(\"\\n\", EscapeError::EscapeOnlyChar);\n-    check(\"\\r\\n\", EscapeError::EscapeOnlyChar);\n     check(\"\\t\", EscapeError::EscapeOnlyChar);\n     check(\"'\", EscapeError::EscapeOnlyChar);\n     check(\"\\r\", EscapeError::BareCarriageReturn);\n@@ -238,10 +236,9 @@ fn test_unescape_byte_str_good() {\n \n     check(\"foo\", b\"foo\");\n     check(\"\", b\"\");\n-    check(\" \\t\\n\\r\\n\", b\" \\t\\n\\n\");\n+    check(\" \\t\\n\", b\" \\t\\n\");\n \n     check(\"hello \\\\\\n     world\", b\"hello world\");\n-    check(\"hello \\\\\\r\\n     world\", b\"hello world\");\n     check(\"thread's\", b\"thread's\")\n }\n \n@@ -253,7 +250,6 @@ fn test_unescape_raw_str() {\n         assert_eq!(unescaped, expected);\n     }\n \n-    check(\"\\r\\n\", &[(0..2, Ok('\\n'))]);\n     check(\"\\r\", &[(0..1, Err(EscapeError::BareCarriageReturnInRawString))]);\n     check(\"\\rx\", &[(0..1, Err(EscapeError::BareCarriageReturnInRawString)), (1..2, Ok('x'))]);\n }\n@@ -266,7 +262,6 @@ fn test_unescape_raw_byte_str() {\n         assert_eq!(unescaped, expected);\n     }\n \n-    check(\"\\r\\n\", &[(0..2, Ok(byte_from_char('\\n')))]);\n     check(\"\\r\", &[(0..1, Err(EscapeError::BareCarriageReturnInRawString))]);\n     check(\"\ud83e\udd80\", &[(0..4, Err(EscapeError::NonAsciiCharInByteString))]);\n     check("}, {"sha": "e811bf7a5817ddfcfe1aab938ce928cdc2446f43", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 15, "deletions": 66, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/911398b96cc4825798c0887ec6ebce775ff5d2d1/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/911398b96cc4825798c0887ec6ebce775ff5d2d1/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=911398b96cc4825798c0887ec6ebce775ff5d2d1", "patch": "@@ -8,9 +8,7 @@ use syntax_pos::{BytePos, Pos, Span, NO_EXPANSION};\n use rustc_lexer::Base;\n use rustc_lexer::unescape;\n \n-use std::borrow::Cow;\n use std::char;\n-use std::iter;\n use std::convert::TryInto;\n use rustc_data_structures::sync::Lrc;\n use log::debug;\n@@ -181,18 +179,7 @@ impl<'a> StringReader<'a> {\n                 let string = self.str_from(start);\n                 // comments with only more \"/\"s are not doc comments\n                 let tok = if is_doc_comment(string) {\n-                    let mut idx = 0;\n-                    loop {\n-                        idx = match string[idx..].find('\\r') {\n-                            None => break,\n-                            Some(it) => idx + it + 1\n-                        };\n-                        if string[idx..].chars().next() != Some('\\n') {\n-                            self.err_span_(start + BytePos(idx as u32 - 1),\n-                                            start + BytePos(idx as u32),\n-                                            \"bare CR not allowed in doc-comment\");\n-                        }\n-                    }\n+                    self.forbid_bare_cr(start, string, \"bare CR not allowed in doc-comment\");\n                     token::DocComment(Symbol::intern(string))\n                 } else {\n                     token::Comment\n@@ -217,15 +204,10 @@ impl<'a> StringReader<'a> {\n                 }\n \n                 let tok = if is_doc_comment {\n-                    let has_cr = string.contains('\\r');\n-                    let string = if has_cr {\n-                        self.translate_crlf(start,\n-                                            string,\n-                                            \"bare CR not allowed in block doc-comment\")\n-                    } else {\n-                        string.into()\n-                    };\n-                    token::DocComment(Symbol::intern(&string[..]))\n+                    self.forbid_bare_cr(start,\n+                                        string,\n+                                        \"bare CR not allowed in block doc-comment\");\n+                    token::DocComment(Symbol::intern(string))\n                 } else {\n                     token::Comment\n                 };\n@@ -516,49 +498,16 @@ impl<'a> StringReader<'a> {\n         &self.src[self.src_index(start)..self.src_index(end)]\n     }\n \n-    /// Converts CRLF to LF in the given string, raising an error on bare CR.\n-    fn translate_crlf<'b>(&self, start: BytePos, s: &'b str, errmsg: &'b str) -> Cow<'b, str> {\n-        let mut chars = s.char_indices().peekable();\n-        while let Some((i, ch)) = chars.next() {\n-            if ch == '\\r' {\n-                if let Some((lf_idx, '\\n')) = chars.peek() {\n-                    return translate_crlf_(self, start, s, *lf_idx, chars, errmsg).into();\n-                }\n-                let pos = start + BytePos(i as u32);\n-                let end_pos = start + BytePos((i + ch.len_utf8()) as u32);\n-                self.err_span_(pos, end_pos, errmsg);\n-            }\n-        }\n-        return s.into();\n-\n-        fn translate_crlf_(rdr: &StringReader<'_>,\n-                           start: BytePos,\n-                           s: &str,\n-                           mut j: usize,\n-                           mut chars: iter::Peekable<impl Iterator<Item = (usize, char)>>,\n-                           errmsg: &str)\n-                           -> String {\n-            let mut buf = String::with_capacity(s.len());\n-            // Skip first CR\n-            buf.push_str(&s[.. j - 1]);\n-            while let Some((i, ch)) = chars.next() {\n-                if ch == '\\r' {\n-                    if j < i {\n-                        buf.push_str(&s[j..i]);\n-                    }\n-                    let next = i + ch.len_utf8();\n-                    j = next;\n-                    if chars.peek().map(|(_, ch)| *ch) != Some('\\n') {\n-                        let pos = start + BytePos(i as u32);\n-                        let end_pos = start + BytePos(next as u32);\n-                        rdr.err_span_(pos, end_pos, errmsg);\n-                    }\n-                }\n-            }\n-            if j < s.len() {\n-                buf.push_str(&s[j..]);\n-            }\n-            buf\n+    fn forbid_bare_cr(&self, start: BytePos, s: &str, errmsg: &str) {\n+        let mut idx = 0;\n+        loop {\n+            idx = match s[idx..].find('\\r') {\n+                None => break,\n+                Some(it) => idx + it + 1\n+            };\n+            self.err_span_(start + BytePos(idx as u32 - 1),\n+                           start + BytePos(idx as u32),\n+                           errmsg);\n         }\n     }\n "}]}