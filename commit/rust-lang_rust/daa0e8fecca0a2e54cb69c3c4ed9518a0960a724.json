{"sha": "daa0e8fecca0a2e54cb69c3c4ed9518a0960a724", "node_id": "C_kwDOAAsO6NoAKGRhYTBlOGZlY2NhMGEyZTU0Y2I2OWMzYzRlZDk1MThhMDk2MGE3MjQ", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2022-08-08T15:48:17Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2022-08-08T15:48:17Z"}, "message": "remove Clean trait implementation for hir::Generics", "tree": {"sha": "2c5e894837dafd51944f373a9d30718387c2cf78", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c5e894837dafd51944f373a9d30718387c2cf78"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/daa0e8fecca0a2e54cb69c3c4ed9518a0960a724", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/daa0e8fecca0a2e54cb69c3c4ed9518a0960a724", "html_url": "https://github.com/rust-lang/rust/commit/daa0e8fecca0a2e54cb69c3c4ed9518a0960a724", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/daa0e8fecca0a2e54cb69c3c4ed9518a0960a724/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bed8e93f40ab77f1dcb2009ff651ec623090769e", "url": "https://api.github.com/repos/rust-lang/rust/commits/bed8e93f40ab77f1dcb2009ff651ec623090769e", "html_url": "https://github.com/rust-lang/rust/commit/bed8e93f40ab77f1dcb2009ff651ec623090769e"}], "stats": {"total": 135, "additions": 67, "deletions": 68}, "files": [{"sha": "58f92eeeb3358b97f5740f11efa428102e96e784", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/daa0e8fecca0a2e54cb69c3c4ed9518a0960a724/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa0e8fecca0a2e54cb69c3c4ed9518a0960a724/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=daa0e8fecca0a2e54cb69c3c4ed9518a0960a724", "patch": "@@ -16,8 +16,8 @@ use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Symbol};\n \n use crate::clean::{\n-    self, clean_fn_decl_from_did_and_sig, clean_impl_item, clean_middle_field, clean_middle_ty,\n-    clean_trait_ref_with_bindings, clean_ty, clean_ty_generics, clean_variant_def,\n+    self, clean_fn_decl_from_did_and_sig, clean_generics, clean_impl_item, clean_middle_field,\n+    clean_middle_ty, clean_trait_ref_with_bindings, clean_ty, clean_ty_generics, clean_variant_def,\n     clean_visibility, utils, Attributes, AttributesExt, Clean, ImplKind, ItemId, Type, Visibility,\n };\n use crate::core::DocContext;\n@@ -418,7 +418,7 @@ pub(crate) fn build_impl(\n                 })\n                 .map(|item| clean_impl_item(item, cx))\n                 .collect::<Vec<_>>(),\n-            impl_.generics.clean(cx),\n+            clean_generics(impl_.generics, cx),\n         ),\n         None => (\n             tcx.associated_items(did)"}, {"sha": "f4f0d3154e1dca19351f9b53a2f968812c8fd612", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 64, "deletions": 65, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/daa0e8fecca0a2e54cb69c3c4ed9518a0960a724/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daa0e8fecca0a2e54cb69c3c4ed9518a0960a724/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=daa0e8fecca0a2e54cb69c3c4ed9518a0960a724", "patch": "@@ -575,69 +575,68 @@ fn is_elided_lifetime(param: &hir::GenericParam<'_>) -> bool {\n     matches!(param.kind, hir::GenericParamKind::Lifetime { kind: hir::LifetimeParamKind::Elided })\n }\n \n-impl<'tcx> Clean<'tcx, Generics> for hir::Generics<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Generics {\n-        let impl_trait_params = self\n-            .params\n-            .iter()\n-            .filter(|param| is_impl_trait(param))\n-            .map(|param| {\n-                let param = clean_generic_param(cx, Some(self), param);\n-                match param.kind {\n-                    GenericParamDefKind::Lifetime { .. } => unreachable!(),\n-                    GenericParamDefKind::Type { did, ref bounds, .. } => {\n-                        cx.impl_trait_bounds.insert(did.into(), bounds.clone());\n-                    }\n-                    GenericParamDefKind::Const { .. } => unreachable!(),\n+pub(crate) fn clean_generics<'tcx>(\n+    gens: &hir::Generics<'tcx>,\n+    cx: &mut DocContext<'tcx>,\n+) -> Generics {\n+    let impl_trait_params = gens\n+        .params\n+        .iter()\n+        .filter(|param| is_impl_trait(param))\n+        .map(|param| {\n+            let param = clean_generic_param(cx, Some(gens), param);\n+            match param.kind {\n+                GenericParamDefKind::Lifetime { .. } => unreachable!(),\n+                GenericParamDefKind::Type { did, ref bounds, .. } => {\n+                    cx.impl_trait_bounds.insert(did.into(), bounds.clone());\n                 }\n-                param\n-            })\n-            .collect::<Vec<_>>();\n+                GenericParamDefKind::Const { .. } => unreachable!(),\n+            }\n+            param\n+        })\n+        .collect::<Vec<_>>();\n \n-        let mut params = Vec::with_capacity(self.params.len());\n-        for p in self.params.iter().filter(|p| !is_impl_trait(p) && !is_elided_lifetime(p)) {\n-            let p = clean_generic_param(cx, Some(self), p);\n-            params.push(p);\n-        }\n-        params.extend(impl_trait_params);\n+    let mut params = Vec::with_capacity(gens.params.len());\n+    for p in gens.params.iter().filter(|p| !is_impl_trait(p) && !is_elided_lifetime(p)) {\n+        let p = clean_generic_param(cx, Some(gens), p);\n+        params.push(p);\n+    }\n+    params.extend(impl_trait_params);\n \n-        let mut generics = Generics {\n-            params,\n-            where_predicates: self\n-                .predicates\n-                .iter()\n-                .filter_map(|x| clean_where_predicate(x, cx))\n-                .collect(),\n-        };\n+    let mut generics = Generics {\n+        params,\n+        where_predicates: gens\n+            .predicates\n+            .iter()\n+            .filter_map(|x| clean_where_predicate(x, cx))\n+            .collect(),\n+    };\n \n-        // Some duplicates are generated for ?Sized bounds between type params and where\n-        // predicates. The point in here is to move the bounds definitions from type params\n-        // to where predicates when such cases occur.\n-        for where_pred in &mut generics.where_predicates {\n-            match *where_pred {\n-                WherePredicate::BoundPredicate {\n-                    ty: Generic(ref name), ref mut bounds, ..\n-                } => {\n-                    if bounds.is_empty() {\n-                        for param in &mut generics.params {\n-                            match param.kind {\n-                                GenericParamDefKind::Lifetime { .. } => {}\n-                                GenericParamDefKind::Type { bounds: ref mut ty_bounds, .. } => {\n-                                    if &param.name == name {\n-                                        mem::swap(bounds, ty_bounds);\n-                                        break;\n-                                    }\n+    // Some duplicates are generated for ?Sized bounds between type params and where\n+    // predicates. The point in here is to move the bounds definitions from type params\n+    // to where predicates when such cases occur.\n+    for where_pred in &mut generics.where_predicates {\n+        match *where_pred {\n+            WherePredicate::BoundPredicate { ty: Generic(ref name), ref mut bounds, .. } => {\n+                if bounds.is_empty() {\n+                    for param in &mut generics.params {\n+                        match param.kind {\n+                            GenericParamDefKind::Lifetime { .. } => {}\n+                            GenericParamDefKind::Type { bounds: ref mut ty_bounds, .. } => {\n+                                if &param.name == name {\n+                                    mem::swap(bounds, ty_bounds);\n+                                    break;\n                                 }\n-                                GenericParamDefKind::Const { .. } => {}\n                             }\n+                            GenericParamDefKind::Const { .. } => {}\n                         }\n                     }\n                 }\n-                _ => continue,\n             }\n+            _ => continue,\n         }\n-        generics\n     }\n+    generics\n }\n \n fn clean_ty_generics<'tcx>(\n@@ -903,7 +902,7 @@ fn clean_function<'tcx>(\n ) -> Box<Function> {\n     let (generics, decl) = enter_impl_trait(cx, |cx| {\n         // NOTE: generics must be cleaned before args\n-        let generics = generics.clean(cx);\n+        let generics = clean_generics(generics, cx);\n         let args = clean_args_from_types_and_body_id(cx, sig.decl.inputs, body_id);\n         let decl = clean_fn_decl_with_args(cx, sig.decl, args);\n         (generics, decl)\n@@ -1032,15 +1031,15 @@ fn clean_trait_item<'tcx>(trait_item: &hir::TraitItem<'tcx>, cx: &mut DocContext\n             hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Required(names)) => {\n                 let (generics, decl) = enter_impl_trait(cx, |cx| {\n                     // NOTE: generics must be cleaned before args\n-                    let generics = trait_item.generics.clean(cx);\n+                    let generics = clean_generics(trait_item.generics, cx);\n                     let args = clean_args_from_types_and_names(cx, sig.decl.inputs, names);\n                     let decl = clean_fn_decl_with_args(cx, sig.decl, args);\n                     (generics, decl)\n                 });\n                 TyMethodItem(Box::new(Function { decl, generics }))\n             }\n             hir::TraitItemKind::Type(bounds, Some(default)) => {\n-                let generics = enter_impl_trait(cx, |cx| trait_item.generics.clean(cx));\n+                let generics = enter_impl_trait(cx, |cx| clean_generics(trait_item.generics, cx));\n                 let bounds = bounds.iter().filter_map(|x| clean_generic_bound(x, cx)).collect();\n                 let item_type = clean_middle_ty(hir_ty_to_ty(cx.tcx, default), cx, None);\n                 AssocTypeItem(\n@@ -1053,7 +1052,7 @@ fn clean_trait_item<'tcx>(trait_item: &hir::TraitItem<'tcx>, cx: &mut DocContext\n                 )\n             }\n             hir::TraitItemKind::Type(bounds, None) => {\n-                let generics = enter_impl_trait(cx, |cx| trait_item.generics.clean(cx));\n+                let generics = enter_impl_trait(cx, |cx| clean_generics(trait_item.generics, cx));\n                 let bounds = bounds.iter().filter_map(|x| clean_generic_bound(x, cx)).collect();\n                 TyAssocTypeItem(Box::new(generics), bounds)\n             }\n@@ -1083,7 +1082,7 @@ pub(crate) fn clean_impl_item<'tcx>(\n             }\n             hir::ImplItemKind::TyAlias(hir_ty) => {\n                 let type_ = clean_ty(hir_ty, cx);\n-                let generics = impl_.generics.clean(cx);\n+                let generics = clean_generics(impl_.generics, cx);\n                 let item_type = clean_middle_ty(hir_ty_to_ty(cx.tcx, hir_ty), cx, None);\n                 AssocTypeItem(\n                     Box::new(Typedef { type_, generics, item_type: Some(item_type) }),\n@@ -1913,32 +1912,32 @@ fn clean_maybe_renamed_item<'tcx>(\n             }),\n             ItemKind::OpaqueTy(ref ty) => OpaqueTyItem(OpaqueTy {\n                 bounds: ty.bounds.iter().filter_map(|x| clean_generic_bound(x, cx)).collect(),\n-                generics: ty.generics.clean(cx),\n+                generics: clean_generics(ty.generics, cx),\n             }),\n             ItemKind::TyAlias(hir_ty, generics) => {\n                 let rustdoc_ty = clean_ty(hir_ty, cx);\n                 let ty = clean_middle_ty(hir_ty_to_ty(cx.tcx, hir_ty), cx, None);\n                 TypedefItem(Box::new(Typedef {\n                     type_: rustdoc_ty,\n-                    generics: generics.clean(cx),\n+                    generics: clean_generics(generics, cx),\n                     item_type: Some(ty),\n                 }))\n             }\n             ItemKind::Enum(ref def, generics) => EnumItem(Enum {\n                 variants: def.variants.iter().map(|v| v.clean(cx)).collect(),\n-                generics: generics.clean(cx),\n+                generics: clean_generics(generics, cx),\n             }),\n             ItemKind::TraitAlias(generics, bounds) => TraitAliasItem(TraitAlias {\n-                generics: generics.clean(cx),\n+                generics: clean_generics(generics, cx),\n                 bounds: bounds.iter().filter_map(|x| clean_generic_bound(x, cx)).collect(),\n             }),\n             ItemKind::Union(ref variant_data, generics) => UnionItem(Union {\n-                generics: generics.clean(cx),\n+                generics: clean_generics(generics, cx),\n                 fields: variant_data.fields().iter().map(|x| clean_field(x, cx)).collect(),\n             }),\n             ItemKind::Struct(ref variant_data, generics) => StructItem(Struct {\n                 struct_type: CtorKind::from_hir(variant_data),\n-                generics: generics.clean(cx),\n+                generics: clean_generics(generics, cx),\n                 fields: variant_data.fields().iter().map(|x| clean_field(x, cx)).collect(),\n             }),\n             ItemKind::Impl(impl_) => return clean_impl(impl_, item.hir_id(), cx),\n@@ -1961,7 +1960,7 @@ fn clean_maybe_renamed_item<'tcx>(\n                 TraitItem(Trait {\n                     def_id,\n                     items,\n-                    generics: generics.clean(cx),\n+                    generics: clean_generics(generics, cx),\n                     bounds: bounds.iter().filter_map(|x| clean_generic_bound(x, cx)).collect(),\n                 })\n             }\n@@ -2017,7 +2016,7 @@ fn clean_impl<'tcx>(\n     let mut make_item = |trait_: Option<Path>, for_: Type, items: Vec<Item>| {\n         let kind = ImplItem(Box::new(Impl {\n             unsafety: impl_.unsafety,\n-            generics: impl_.generics.clean(cx),\n+            generics: clean_generics(impl_.generics, cx),\n             trait_,\n             for_,\n             items,\n@@ -2212,7 +2211,7 @@ fn clean_maybe_renamed_foreign_item<'tcx>(\n             hir::ForeignItemKind::Fn(decl, names, generics) => {\n                 let (generics, decl) = enter_impl_trait(cx, |cx| {\n                     // NOTE: generics must be cleaned before args\n-                    let generics = generics.clean(cx);\n+                    let generics = clean_generics(generics, cx);\n                     let args = clean_args_from_types_and_names(cx, decl.inputs, names);\n                     let decl = clean_fn_decl_with_args(cx, decl, args);\n                     (generics, decl)"}]}