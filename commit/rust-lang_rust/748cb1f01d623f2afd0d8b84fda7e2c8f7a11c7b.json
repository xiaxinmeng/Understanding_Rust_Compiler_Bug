{"sha": "748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b", "node_id": "C_kwDOAAsO6NoAKDc0OGNiMWYwMWQ2MjNmMmFmZDBkOGI4NGZkYTdlMmM4ZjdhMTFjN2I", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-20T07:03:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-20T07:03:54Z"}, "message": "Auto merge of #99493 - Dylan-DPC:rollup-lli4gcx, r=Dylan-DPC\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #98784 (Suggest returning local on \"expected `ty`, found `()`\" due to expr-less block)\n - #98916 (Windows: Use `FindFirstFileW` for getting the metadata of locked system files)\n - #99433 (Erase regions before comparing signatures of foreign fns.)\n - #99452 (int_macros was only using to_xe_bytes_doc and not from_xe_bytes_doc)\n - #99481 (Add regression test for #71547)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "9acf078061e8970bf2cf81193a29f9e09ce1b400", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9acf078061e8970bf2cf81193a29f9e09ce1b400"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b", "html_url": "https://github.com/rust-lang/rust/commit/748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03d488b48af9f66b91e9400387f781b82411fa82", "url": "https://api.github.com/repos/rust-lang/rust/commits/03d488b48af9f66b91e9400387f781b82411fa82", "html_url": "https://github.com/rust-lang/rust/commit/03d488b48af9f66b91e9400387f781b82411fa82"}, {"sha": "d7a65a55584368500314384e526378d50c60bdd1", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7a65a55584368500314384e526378d50c60bdd1", "html_url": "https://github.com/rust-lang/rust/commit/d7a65a55584368500314384e526378d50c60bdd1"}], "stats": {"total": 546, "additions": 462, "deletions": 84}, "files": [{"sha": "9e4dc702f0737bec6c37c2ead5936972c20f6a7a", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b", "patch": "@@ -2858,9 +2858,10 @@ impl ClashingExternDeclarations {\n                             let a_poly_sig = a.fn_sig(tcx);\n                             let b_poly_sig = b.fn_sig(tcx);\n \n-                            // As we don't compare regions, skip_binder is fine.\n-                            let a_sig = a_poly_sig.skip_binder();\n-                            let b_sig = b_poly_sig.skip_binder();\n+                            // We don't compare regions, but leaving bound regions around ICEs, so\n+                            // we erase them.\n+                            let a_sig = tcx.erase_late_bound_regions(a_poly_sig);\n+                            let b_sig = tcx.erase_late_bound_regions(b_poly_sig);\n \n                             (a_sig.abi, a_sig.unsafety, a_sig.c_variadic)\n                                 == (b_sig.abi, b_sig.unsafety, b_sig.c_variadic)"}, {"sha": "e6fa95b91e9b3840eb849c608f79d1d75c49e618", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 4, "deletions": 40, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b", "patch": "@@ -31,9 +31,7 @@ use rustc_middle::ty::{self, DefIdTree, IsSuggestable, Ty};\n use rustc_session::Session;\n use rustc_span::symbol::Ident;\n use rustc_span::{self, Span};\n-use rustc_trait_selection::traits::{\n-    self, ObligationCauseCode, SelectionContext, StatementAsExpression,\n-};\n+use rustc_trait_selection::traits::{self, ObligationCauseCode, SelectionContext};\n \n use std::iter;\n use std::slice;\n@@ -1410,7 +1408,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         &self.misc(sp),\n                         &mut |err| {\n                             if let Some(expected_ty) = expected.only_has_type(self) {\n-                                self.consider_hint_about_removing_semicolon(blk, expected_ty, err);\n+                                if !self.consider_removing_semicolon(blk, expected_ty, err) {\n+                                    self.consider_returning_binding(blk, expected_ty, err);\n+                                }\n                                 if expected_ty == self.tcx.types.bool {\n                                     // If this is caused by a missing `let` in a `while let`,\n                                     // silence this redundant error, as we already emit E0070.\n@@ -1478,42 +1478,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ty\n     }\n \n-    /// A common error is to add an extra semicolon:\n-    ///\n-    /// ```compile_fail,E0308\n-    /// fn foo() -> usize {\n-    ///     22;\n-    /// }\n-    /// ```\n-    ///\n-    /// This routine checks if the final statement in a block is an\n-    /// expression with an explicit semicolon whose type is compatible\n-    /// with `expected_ty`. If so, it suggests removing the semicolon.\n-    fn consider_hint_about_removing_semicolon(\n-        &self,\n-        blk: &'tcx hir::Block<'tcx>,\n-        expected_ty: Ty<'tcx>,\n-        err: &mut Diagnostic,\n-    ) {\n-        if let Some((span_semi, boxed)) = self.could_remove_semicolon(blk, expected_ty) {\n-            if let StatementAsExpression::NeedsBoxing = boxed {\n-                err.span_suggestion_verbose(\n-                    span_semi,\n-                    \"consider removing this semicolon and boxing the expression\",\n-                    \"\",\n-                    Applicability::HasPlaceholders,\n-                );\n-            } else {\n-                err.span_suggestion_short(\n-                    span_semi,\n-                    \"remove this semicolon\",\n-                    \"\",\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-        }\n-    }\n-\n     fn parent_item_span(&self, id: hir::HirId) -> Option<Span> {\n         let node = self.tcx.hir().get_by_def_id(self.tcx.hir().get_parent_item(id));\n         match node {"}, {"sha": "d5ee299c0f98d1f55b70d9721244539ab64edbc4", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 156, "deletions": 3, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b", "patch": "@@ -3,6 +3,7 @@ use crate::astconv::AstConv;\n use crate::errors::{AddReturnTypeSuggestion, ExpectedReturnTypeLabel};\n \n use rustc_ast::util::parser::ExprPrecedence;\n+use rustc_data_structures::stable_set::FxHashSet;\n use rustc_errors::{Applicability, Diagnostic, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind};\n@@ -11,12 +12,12 @@ use rustc_hir::{\n     Expr, ExprKind, GenericBound, Node, Path, QPath, Stmt, StmtKind, TyKind, WherePredicate,\n };\n use rustc_infer::infer::{self, TyCtxtInferExt};\n-use rustc_infer::traits;\n+use rustc_infer::traits::{self, StatementAsExpression};\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::{self, Binder, IsSuggestable, Subst, ToPredicate, Ty};\n+use rustc_middle::ty::{self, Binder, IsSuggestable, Subst, ToPredicate, Ty, TypeVisitable};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n-use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n+use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub(in super::super) fn suggest_semicolon_at_end(&self, span: Span, err: &mut Diagnostic) {\n@@ -864,4 +865,156 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             );\n         }\n     }\n+\n+    /// A common error is to add an extra semicolon:\n+    ///\n+    /// ```compile_fail,E0308\n+    /// fn foo() -> usize {\n+    ///     22;\n+    /// }\n+    /// ```\n+    ///\n+    /// This routine checks if the final statement in a block is an\n+    /// expression with an explicit semicolon whose type is compatible\n+    /// with `expected_ty`. If so, it suggests removing the semicolon.\n+    pub(crate) fn consider_removing_semicolon(\n+        &self,\n+        blk: &'tcx hir::Block<'tcx>,\n+        expected_ty: Ty<'tcx>,\n+        err: &mut Diagnostic,\n+    ) -> bool {\n+        if let Some((span_semi, boxed)) = self.could_remove_semicolon(blk, expected_ty) {\n+            if let StatementAsExpression::NeedsBoxing = boxed {\n+                err.span_suggestion_verbose(\n+                    span_semi,\n+                    \"consider removing this semicolon and boxing the expression\",\n+                    \"\",\n+                    Applicability::HasPlaceholders,\n+                );\n+            } else {\n+                err.span_suggestion_short(\n+                    span_semi,\n+                    \"remove this semicolon\",\n+                    \"\",\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    pub(crate) fn consider_returning_binding(\n+        &self,\n+        blk: &'tcx hir::Block<'tcx>,\n+        expected_ty: Ty<'tcx>,\n+        err: &mut Diagnostic,\n+    ) {\n+        let mut shadowed = FxHashSet::default();\n+        let mut candidate_idents = vec![];\n+        let mut find_compatible_candidates = |pat: &hir::Pat<'_>| {\n+            if let hir::PatKind::Binding(_, hir_id, ident, _) = &pat.kind\n+                && let Some(pat_ty) = self.typeck_results.borrow().node_type_opt(*hir_id)\n+            {\n+                let pat_ty = self.resolve_vars_if_possible(pat_ty);\n+                if self.can_coerce(pat_ty, expected_ty)\n+                    && !(pat_ty, expected_ty).references_error()\n+                    && shadowed.insert(ident.name)\n+                {\n+                    candidate_idents.push((*ident, pat_ty));\n+                }\n+            }\n+            true\n+        };\n+\n+        let hir = self.tcx.hir();\n+        for stmt in blk.stmts.iter().rev() {\n+            let StmtKind::Local(local) = &stmt.kind else { continue; };\n+            local.pat.walk(&mut find_compatible_candidates);\n+        }\n+        match hir.find(hir.get_parent_node(blk.hir_id)) {\n+            Some(hir::Node::Expr(hir::Expr { hir_id, .. })) => {\n+                match hir.find(hir.get_parent_node(*hir_id)) {\n+                    Some(hir::Node::Arm(hir::Arm { pat, .. })) => {\n+                        pat.walk(&mut find_compatible_candidates);\n+                    }\n+                    Some(\n+                        hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(_, _, body), .. })\n+                        | hir::Node::ImplItem(hir::ImplItem {\n+                            kind: hir::ImplItemKind::Fn(_, body),\n+                            ..\n+                        })\n+                        | hir::Node::TraitItem(hir::TraitItem {\n+                            kind: hir::TraitItemKind::Fn(_, hir::TraitFn::Provided(body)),\n+                            ..\n+                        })\n+                        | hir::Node::Expr(hir::Expr {\n+                            kind: hir::ExprKind::Closure(hir::Closure { body, .. }),\n+                            ..\n+                        }),\n+                    ) => {\n+                        for param in hir.body(*body).params {\n+                            param.pat.walk(&mut find_compatible_candidates);\n+                        }\n+                    }\n+                    Some(hir::Node::Expr(hir::Expr {\n+                        kind:\n+                            hir::ExprKind::If(\n+                                hir::Expr { kind: hir::ExprKind::Let(let_), .. },\n+                                then_block,\n+                                _,\n+                            ),\n+                        ..\n+                    })) if then_block.hir_id == *hir_id => {\n+                        let_.pat.walk(&mut find_compatible_candidates);\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        match &candidate_idents[..] {\n+            [(ident, _ty)] => {\n+                let sm = self.tcx.sess.source_map();\n+                if let Some(stmt) = blk.stmts.last() {\n+                    let stmt_span = sm.stmt_span(stmt.span, blk.span);\n+                    let sugg = if sm.is_multiline(blk.span)\n+                        && let Some(spacing) = sm.indentation_before(stmt_span)\n+                    {\n+                        format!(\"\\n{spacing}{ident}\")\n+                    } else {\n+                        format!(\" {ident}\")\n+                    };\n+                    err.span_suggestion_verbose(\n+                        stmt_span.shrink_to_hi(),\n+                        format!(\"consider returning the local binding `{ident}`\"),\n+                        sugg,\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else {\n+                    let sugg = if sm.is_multiline(blk.span)\n+                        && let Some(spacing) = sm.indentation_before(blk.span.shrink_to_lo())\n+                    {\n+                        format!(\"\\n{spacing}    {ident}\\n{spacing}\")\n+                    } else {\n+                        format!(\" {ident} \")\n+                    };\n+                    let left_span = sm.span_through_char(blk.span, '{').shrink_to_hi();\n+                    err.span_suggestion_verbose(\n+                        sm.span_extend_while(left_span, |c| c.is_whitespace()).unwrap_or(left_span),\n+                        format!(\"consider returning the local binding `{ident}`\"),\n+                        sugg,\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }\n+            values if (1..3).contains(&values.len()) => {\n+                let spans = values.iter().map(|(ident, _)| ident.span).collect::<Vec<_>>();\n+                err.span_note(spans, \"consider returning one of these bindings\");\n+            }\n+            _ => {}\n+        }\n+    }\n }"}, {"sha": "eb458f3866e63181394b48b5444f3a794ce67180", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b", "patch": "@@ -2612,7 +2612,7 @@ macro_rules! int_impl {\n         /// Create an integer value from its representation as a byte array in\n         /// big endian.\n         ///\n-        #[doc = $to_xe_bytes_doc]\n+        #[doc = $from_xe_bytes_doc]\n         ///\n         /// # Examples\n         ///\n@@ -2641,7 +2641,7 @@ macro_rules! int_impl {\n         /// Create an integer value from its representation as a byte array in\n         /// little endian.\n         ///\n-        #[doc = $to_xe_bytes_doc]\n+        #[doc = $from_xe_bytes_doc]\n         ///\n         /// # Examples\n         ///\n@@ -2677,7 +2677,7 @@ macro_rules! int_impl {\n         /// [`from_be_bytes`]: Self::from_be_bytes\n         /// [`from_le_bytes`]: Self::from_le_bytes\n         ///\n-        #[doc = $to_xe_bytes_doc]\n+        #[doc = $from_xe_bytes_doc]\n         ///\n         /// # Examples\n         ///"}, {"sha": "b8959316de170e568de3fc7a366ed478158855dc", "filename": "library/std/src/fs/tests.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs?ref=748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b", "patch": "@@ -1534,3 +1534,20 @@ fn read_large_dir() {\n         entry.unwrap();\n     }\n }\n+\n+/// Test the fallback for getting the metadata of files like hiberfil.sys that\n+/// Windows holds a special lock on, preventing normal means of querying\n+/// metadata. See #96980.\n+///\n+/// Note this fails in CI because `hiberfil.sys` does not actually exist there.\n+/// Therefore it's marked as ignored.\n+#[test]\n+#[ignore]\n+#[cfg(windows)]\n+fn hiberfil_sys() {\n+    let hiberfil = Path::new(r\"C:\\hiberfil.sys\");\n+    assert_eq!(true, hiberfil.try_exists().unwrap());\n+    fs::symlink_metadata(hiberfil).unwrap();\n+    fs::metadata(hiberfil).unwrap();\n+    assert_eq!(true, hiberfil.exists());\n+}"}, {"sha": "4d3162f1254628e6560265c95c387dcb263ea395", "filename": "library/std/src/sys/windows/fs.rs", "status": "modified", "additions": 82, "deletions": 26, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs?ref=748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b", "patch": "@@ -155,22 +155,7 @@ impl DirEntry {\n     }\n \n     pub fn metadata(&self) -> io::Result<FileAttr> {\n-        Ok(FileAttr {\n-            attributes: self.data.dwFileAttributes,\n-            creation_time: self.data.ftCreationTime,\n-            last_access_time: self.data.ftLastAccessTime,\n-            last_write_time: self.data.ftLastWriteTime,\n-            file_size: ((self.data.nFileSizeHigh as u64) << 32) | (self.data.nFileSizeLow as u64),\n-            reparse_tag: if self.data.dwFileAttributes & c::FILE_ATTRIBUTE_REPARSE_POINT != 0 {\n-                // reserved unless this is a reparse point\n-                self.data.dwReserved0\n-            } else {\n-                0\n-            },\n-            volume_serial_number: None,\n-            number_of_links: None,\n-            file_index: None,\n-        })\n+        Ok(self.data.into())\n     }\n }\n \n@@ -879,6 +864,26 @@ impl FileAttr {\n         self.file_index\n     }\n }\n+impl From<c::WIN32_FIND_DATAW> for FileAttr {\n+    fn from(wfd: c::WIN32_FIND_DATAW) -> Self {\n+        FileAttr {\n+            attributes: wfd.dwFileAttributes,\n+            creation_time: wfd.ftCreationTime,\n+            last_access_time: wfd.ftLastAccessTime,\n+            last_write_time: wfd.ftLastWriteTime,\n+            file_size: ((wfd.nFileSizeHigh as u64) << 32) | (wfd.nFileSizeLow as u64),\n+            reparse_tag: if wfd.dwFileAttributes & c::FILE_ATTRIBUTE_REPARSE_POINT != 0 {\n+                // reserved unless this is a reparse point\n+                wfd.dwReserved0\n+            } else {\n+                0\n+            },\n+            volume_serial_number: None,\n+            number_of_links: None,\n+            file_index: None,\n+        }\n+    }\n+}\n \n fn to_u64(ft: &c::FILETIME) -> u64 {\n     (ft.dwLowDateTime as u64) | ((ft.dwHighDateTime as u64) << 32)\n@@ -1145,22 +1150,73 @@ pub fn link(_original: &Path, _link: &Path) -> io::Result<()> {\n }\n \n pub fn stat(path: &Path) -> io::Result<FileAttr> {\n-    let mut opts = OpenOptions::new();\n-    // No read or write permissions are necessary\n-    opts.access_mode(0);\n-    // This flag is so we can open directories too\n-    opts.custom_flags(c::FILE_FLAG_BACKUP_SEMANTICS);\n-    let file = File::open(path, &opts)?;\n-    file.file_attr()\n+    metadata(path, ReparsePoint::Follow)\n }\n \n pub fn lstat(path: &Path) -> io::Result<FileAttr> {\n+    metadata(path, ReparsePoint::Open)\n+}\n+\n+#[repr(u32)]\n+#[derive(Clone, Copy, PartialEq, Eq)]\n+enum ReparsePoint {\n+    Follow = 0,\n+    Open = c::FILE_FLAG_OPEN_REPARSE_POINT,\n+}\n+impl ReparsePoint {\n+    fn as_flag(self) -> u32 {\n+        self as u32\n+    }\n+}\n+\n+fn metadata(path: &Path, reparse: ReparsePoint) -> io::Result<FileAttr> {\n     let mut opts = OpenOptions::new();\n     // No read or write permissions are necessary\n     opts.access_mode(0);\n-    opts.custom_flags(c::FILE_FLAG_BACKUP_SEMANTICS | c::FILE_FLAG_OPEN_REPARSE_POINT);\n-    let file = File::open(path, &opts)?;\n-    file.file_attr()\n+    opts.custom_flags(c::FILE_FLAG_BACKUP_SEMANTICS | reparse.as_flag());\n+\n+    // Attempt to open the file normally.\n+    // If that fails with `ERROR_SHARING_VIOLATION` then retry using `FindFirstFileW`.\n+    // If the fallback fails for any reason we return the original error.\n+    match File::open(path, &opts) {\n+        Ok(file) => file.file_attr(),\n+        Err(e) if e.raw_os_error() == Some(c::ERROR_SHARING_VIOLATION as _) => {\n+            // `ERROR_SHARING_VIOLATION` will almost never be returned.\n+            // Usually if a file is locked you can still read some metadata.\n+            // However, there are special system files, such as\n+            // `C:\\hiberfil.sys`, that are locked in a way that denies even that.\n+            unsafe {\n+                let path = maybe_verbatim(path)?;\n+\n+                // `FindFirstFileW` accepts wildcard file names.\n+                // Fortunately wildcards are not valid file names and\n+                // `ERROR_SHARING_VIOLATION` means the file exists (but is locked)\n+                // therefore it's safe to assume the file name given does not\n+                // include wildcards.\n+                let mut wfd = mem::zeroed();\n+                let handle = c::FindFirstFileW(path.as_ptr(), &mut wfd);\n+\n+                if handle == c::INVALID_HANDLE_VALUE {\n+                    // This can fail if the user does not have read access to the\n+                    // directory.\n+                    Err(e)\n+                } else {\n+                    // We no longer need the find handle.\n+                    c::FindClose(handle);\n+\n+                    // `FindFirstFileW` reads the cached file information from the\n+                    // directory. The downside is that this metadata may be outdated.\n+                    let attrs = FileAttr::from(wfd);\n+                    if reparse == ReparsePoint::Follow && attrs.file_type().is_symlink() {\n+                        Err(e)\n+                    } else {\n+                        Ok(attrs)\n+                    }\n+                }\n+            }\n+        }\n+        Err(e) => Err(e),\n+    }\n }\n \n pub fn set_perm(p: &Path, perm: FilePermissions) -> io::Result<()> {"}, {"sha": "ada6e357aea5ee7f17633dc7a2b3bf4b2999b9ae", "filename": "src/test/ui/async-await/async-block-control-flow-static-semantics.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.stderr?ref=748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b", "patch": "@@ -18,6 +18,14 @@ LL | |             break 0u8;\n LL | |         };\n    | |_________- enclosing `async` block\n \n+error[E0271]: type mismatch resolving `<impl Future<Output = u8> as Future>::Output == ()`\n+  --> $DIR/async-block-control-flow-static-semantics.rs:26:39\n+   |\n+LL |     let _: &dyn Future<Output = ()> = &block;\n+   |                                       ^^^^^^ expected `()`, found `u8`\n+   |\n+   = note: required for the cast from `impl Future<Output = u8>` to the object type `dyn Future<Output = ()>`\n+\n error[E0308]: mismatched types\n   --> $DIR/async-block-control-flow-static-semantics.rs:21:58\n    |\n@@ -32,7 +40,7 @@ LL | | }\n    | |_^ expected `u8`, found `()`\n \n error[E0271]: type mismatch resolving `<impl Future<Output = u8> as Future>::Output == ()`\n-  --> $DIR/async-block-control-flow-static-semantics.rs:26:39\n+  --> $DIR/async-block-control-flow-static-semantics.rs:17:39\n    |\n LL |     let _: &dyn Future<Output = ()> = &block;\n    |                                       ^^^^^^ expected `()`, found `u8`\n@@ -47,14 +55,6 @@ LL | fn return_targets_async_block_not_fn() -> u8 {\n    |    |\n    |    implicitly returns `()` as its body has no tail or `return` expression\n \n-error[E0271]: type mismatch resolving `<impl Future<Output = u8> as Future>::Output == ()`\n-  --> $DIR/async-block-control-flow-static-semantics.rs:17:39\n-   |\n-LL |     let _: &dyn Future<Output = ()> = &block;\n-   |                                       ^^^^^^ expected `()`, found `u8`\n-   |\n-   = note: required for the cast from `impl Future<Output = u8>` to the object type `dyn Future<Output = ()>`\n-\n error[E0308]: mismatched types\n   --> $DIR/async-block-control-flow-static-semantics.rs:47:44\n    |"}, {"sha": "60776a1a985cfd1309ed44754f19d6b2a662f2c2", "filename": "src/test/ui/const-generics/issues/issue-71547.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-71547.rs", "raw_url": "https://github.com/rust-lang/rust/raw/748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-71547.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-71547.rs?ref=748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b", "patch": "@@ -0,0 +1,18 @@\n+// check-pass\n+\n+#![feature(adt_const_params)]\n+#![allow(incomplete_features)]\n+\n+pub trait GetType<const N: &'static str> {\n+    type Ty;\n+    fn get(&self) -> &Self::Ty;\n+}\n+\n+pub fn get_val<T>(value: &T) -> &T::Ty\n+where\n+    T: GetType<\"hello\">,\n+{\n+    value.get()\n+}\n+\n+fn main() {}"}, {"sha": "fce603c801f2488ccac02ed12b0c50616b9f22f4", "filename": "src/test/ui/foreign/issue-99276-same-type-lifetimes.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b/src%2Ftest%2Fui%2Fforeign%2Fissue-99276-same-type-lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b/src%2Ftest%2Fui%2Fforeign%2Fissue-99276-same-type-lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fforeign%2Fissue-99276-same-type-lifetimes.rs?ref=748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b", "patch": "@@ -0,0 +1,24 @@\n+// Check that we do not ICE when structurally comparing types with lifetimes present.\n+// check-pass\n+\n+pub struct Record<'a> {\n+    pub args: &'a [(usize, &'a str)],\n+}\n+\n+mod a {\n+    extern \"Rust\" {\n+        fn foo<'a, 'b>(record: &'a super::Record<'b>);\n+\n+        fn bar<'a, 'b>(record: &'a super::Record<'b>);\n+    }\n+}\n+\n+mod b {\n+    extern \"Rust\" {\n+        fn foo<'a, 'b>(record: &'a super::Record<'b>);\n+\n+        fn bar<'a, 'b>(record: &'a super::Record<'b>);\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "ddbdbdb0fd043eb0f5655c7545eaac7a94a03621", "filename": "src/test/ui/liveness/liveness-forgot-ret.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b/src%2Ftest%2Fui%2Fliveness%2Fliveness-forgot-ret.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b/src%2Ftest%2Fui%2Fliveness%2Fliveness-forgot-ret.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fliveness%2Fliveness-forgot-ret.stderr?ref=748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b", "patch": "@@ -5,6 +5,11 @@ LL | fn f(a: isize) -> isize { if god_exists(a) { return 5; }; }\n    |    -              ^^^^^ expected `isize`, found `()`\n    |    |\n    |    implicitly returns `()` as its body has no tail or `return` expression\n+   |\n+help: consider returning the local binding `a`\n+   |\n+LL | fn f(a: isize) -> isize { if god_exists(a) { return 5; }; a }\n+   |                                                           +\n \n error: aborting due to previous error\n "}, {"sha": "b7250f3b0b539b5be0139162726c26271917c7ea", "filename": "src/test/ui/parser/issues/issue-33413.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-33413.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-33413.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissues%2Fissue-33413.stderr?ref=748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b", "patch": "@@ -11,6 +11,11 @@ LL |     fn f(*, a: u8) -> u8 {}\n    |        -              ^^ expected `u8`, found `()`\n    |        |\n    |        implicitly returns `()` as its body has no tail or `return` expression\n+   |\n+help: consider returning the local binding `a`\n+   |\n+LL |     fn f(*, a: u8) -> u8 { a }\n+   |                            +\n \n error: aborting due to 2 previous errors\n "}, {"sha": "8c3bd641e97846b137759280a76cf9990fdf2b7b", "filename": "src/test/ui/suggestions/return-bindings-multi.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings-multi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings-multi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings-multi.rs?ref=748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b", "patch": "@@ -0,0 +1,9 @@\n+fn a(i: i32) -> i32 {\n+    //~^ ERROR mismatched types\n+    let j = 2i32;\n+}\n+\n+fn b(i: i32, j: i32) -> i32 {}\n+//~^ ERROR mismatched types\n+\n+fn main() {}"}, {"sha": "738e3f2f4beb828831aa3331ec18beadbb21180b", "filename": "src/test/ui/suggestions/return-bindings-multi.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings-multi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings-multi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings-multi.stderr?ref=748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b", "patch": "@@ -0,0 +1,34 @@\n+error[E0308]: mismatched types\n+  --> $DIR/return-bindings-multi.rs:1:17\n+   |\n+LL | fn a(i: i32) -> i32 {\n+   |    -            ^^^ expected `i32`, found `()`\n+   |    |\n+   |    implicitly returns `()` as its body has no tail or `return` expression\n+   |\n+note: consider returning one of these bindings\n+  --> $DIR/return-bindings-multi.rs:1:6\n+   |\n+LL | fn a(i: i32) -> i32 {\n+   |      ^\n+LL |\n+LL |     let j = 2i32;\n+   |         ^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/return-bindings-multi.rs:6:25\n+   |\n+LL | fn b(i: i32, j: i32) -> i32 {}\n+   |    -                    ^^^ expected `i32`, found `()`\n+   |    |\n+   |    implicitly returns `()` as its body has no tail or `return` expression\n+   |\n+note: consider returning one of these bindings\n+  --> $DIR/return-bindings-multi.rs:6:6\n+   |\n+LL | fn b(i: i32, j: i32) -> i32 {}\n+   |      ^       ^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "4fabc411abcbe8c8b4e16935d4853079194a6018", "filename": "src/test/ui/suggestions/return-bindings.fixed", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings.fixed?ref=748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b", "patch": "@@ -0,0 +1,23 @@\n+// run-rustfix\n+\n+#![allow(unused)]\n+\n+fn a(i: i32) -> i32 { i }\n+//~^ ERROR mismatched types\n+\n+fn b(opt_str: Option<String>) {\n+    let s: String = if let Some(s) = opt_str {\n+        s\n+    //~^ ERROR mismatched types\n+    } else {\n+        String::new()\n+    };\n+}\n+\n+fn c() -> Option<i32> {\n+    //~^ ERROR mismatched types\n+    let x = Some(1);\n+    x\n+}\n+\n+fn main() {}"}, {"sha": "d05b4ba27d6e8a5f2adb60ba961f8a4a11aec116", "filename": "src/test/ui/suggestions/return-bindings.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings.rs?ref=748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b", "patch": "@@ -0,0 +1,21 @@\n+// run-rustfix\n+\n+#![allow(unused)]\n+\n+fn a(i: i32) -> i32 {}\n+//~^ ERROR mismatched types\n+\n+fn b(opt_str: Option<String>) {\n+    let s: String = if let Some(s) = opt_str {\n+        //~^ ERROR mismatched types\n+    } else {\n+        String::new()\n+    };\n+}\n+\n+fn c() -> Option<i32> {\n+    //~^ ERROR mismatched types\n+    let x = Some(1);\n+}\n+\n+fn main() {}"}, {"sha": "e5d49255005567effa1ba305fcd471edba4f5dbd", "filename": "src/test/ui/suggestions/return-bindings.stderr", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings.stderr?ref=748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b", "patch": "@@ -0,0 +1,48 @@\n+error[E0308]: mismatched types\n+  --> $DIR/return-bindings.rs:5:17\n+   |\n+LL | fn a(i: i32) -> i32 {}\n+   |    -            ^^^ expected `i32`, found `()`\n+   |    |\n+   |    implicitly returns `()` as its body has no tail or `return` expression\n+   |\n+help: consider returning the local binding `i`\n+   |\n+LL | fn a(i: i32) -> i32 { i }\n+   |                       +\n+\n+error[E0308]: mismatched types\n+  --> $DIR/return-bindings.rs:9:46\n+   |\n+LL |       let s: String = if let Some(s) = opt_str {\n+   |  ______________________________________________^\n+LL | |\n+LL | |     } else {\n+   | |_____^ expected struct `String`, found `()`\n+   |\n+help: consider returning the local binding `s`\n+   |\n+LL ~     let s: String = if let Some(s) = opt_str {\n+LL +         s\n+LL ~\n+   |\n+\n+error[E0308]: mismatched types\n+  --> $DIR/return-bindings.rs:16:11\n+   |\n+LL | fn c() -> Option<i32> {\n+   |    -      ^^^^^^^^^^^ expected enum `Option`, found `()`\n+   |    |\n+   |    implicitly returns `()` as its body has no tail or `return` expression\n+   |\n+   = note:   expected enum `Option<i32>`\n+           found unit type `()`\n+help: consider returning the local binding `x`\n+   |\n+LL ~     let x = Some(1);\n+LL +     x\n+   |\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}]}