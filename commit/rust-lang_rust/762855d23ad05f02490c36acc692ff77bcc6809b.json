{"sha": "762855d23ad05f02490c36acc692ff77bcc6809b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2Mjg1NWQyM2FkMDVmMDI0OTBjMzZhY2M2OTJmZjc3YmNjNjgwOWI=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-08-09T17:03:45Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-08-09T17:03:45Z"}, "message": "Rollup merge of #53215 - ljedrz:refactor_format, r=estebank\n\nSlightly refactor syntax_ext/format\n\nexpand_preparsed_format_args:\n- move a potential error `return` earlier in the processing\n- pre-allocate some of the required space for `cx.pieces` and `cx.str_pieces`\n- create `cx`-independent objects before `cx`\n- build `pieces` and `errs` using `collect` instead of a `push` loop\n\ndescribe_num_args:\n- return `Cow<str>` instead of `String`", "tree": {"sha": "2a994e4e5727fda6f7bfb212abe0cfc10a847165", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a994e4e5727fda6f7bfb212abe0cfc10a847165"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/762855d23ad05f02490c36acc692ff77bcc6809b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZ1R8CLMp8f2GxWoQ/vbIBR0OATwFAltsc/EACgkQ/vbIBR0O\nATx1rw//YWksnv7eKB6QzRX3t9TGcZPwkB2QTEMOoRGcVgxoAxy3/Q48d6ePMqYD\nQ7twcrBvxQdw3hWiZs1ymuN/tQaxo0irCicRbDxDom8v2M+aKCEOxjVwZofsQny1\njO/IVdqvXL2t1T5Pn/Ys723ejQrytVhkzsV2qZs7ODxf9hmIqUx74C/xw43YCFND\n+NEV7dXUeI2nMcr9OeavmykWaWCeeWxqtqU/FEt/g4Vlv9gk5sgpJ0kymRSHVd/a\ny7S4jVw2olDRt0M/+oq/iYWY2NrzEaWosOkKHaD1mnTAF9z1p1PXcMRxOA5Fmm+P\nFCmmLj/nz2h3V/uQx586DopmKSIP+UrejCqhDBN9CbfmSf08uErZWiWC6OJ5p/F3\nv6x/VkZI9Zc6sXQXOH7ZDlY/0OHc4slKT/kh58vujO+I9XRxKsuzb0nZbqbNZozf\nXrF94IrsvXsxNGub2aIK1O6rZaGwxzeGXa26ZYNxqgQtgabCFiyoqbbd6ZhhINep\nu4mkJUKX81s0dZLOh5xMJclGvnQxx2EhPavx7y/J/f4N7D17zgyRzMjoFi+M8AlY\nK+RpZDDrV2Kwj7QidsdEZHoYNDc5m93S+dTuioWuuaig16AwWFZr1odYztJFVxwA\na5vkaMvl6qo4JF82KY5urXA5m+rZytO+4cPd6cecDNjreyd9AWk=\n=fUKv\n-----END PGP SIGNATURE-----", "payload": "tree 2a994e4e5727fda6f7bfb212abe0cfc10a847165\nparent e2d0e3f6ace4aeec1b66e42fa41d168809b1f224\nparent aab063a40e46357ef803c0f369afa1a1dcafb4bd\nauthor kennytm <kennytm@gmail.com> 1533834225 +0800\ncommitter kennytm <kennytm@gmail.com> 1533834225 +0800\n\nRollup merge of #53215 - ljedrz:refactor_format, r=estebank\n\nSlightly refactor syntax_ext/format\n\nexpand_preparsed_format_args:\n- move a potential error `return` earlier in the processing\n- pre-allocate some of the required space for `cx.pieces` and `cx.str_pieces`\n- create `cx`-independent objects before `cx`\n- build `pieces` and `errs` using `collect` instead of a `push` loop\n\ndescribe_num_args:\n- return `Cow<str>` instead of `String`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/762855d23ad05f02490c36acc692ff77bcc6809b", "html_url": "https://github.com/rust-lang/rust/commit/762855d23ad05f02490c36acc692ff77bcc6809b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/762855d23ad05f02490c36acc692ff77bcc6809b/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2d0e3f6ace4aeec1b66e42fa41d168809b1f224", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2d0e3f6ace4aeec1b66e42fa41d168809b1f224", "html_url": "https://github.com/rust-lang/rust/commit/e2d0e3f6ace4aeec1b66e42fa41d168809b1f224"}, {"sha": "aab063a40e46357ef803c0f369afa1a1dcafb4bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/aab063a40e46357ef803c0f369afa1a1dcafb4bd", "html_url": "https://github.com/rust-lang/rust/commit/aab063a40e46357ef803c0f369afa1a1dcafb4bd"}], "stats": {"total": 131, "additions": 70, "deletions": 61}, "files": [{"sha": "61f52194aad3e4a4e239362e37d6eae16322d540", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 70, "deletions": 61, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/762855d23ad05f02490c36acc692ff77bcc6809b/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/762855d23ad05f02490c36acc692ff77bcc6809b/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=762855d23ad05f02490c36acc692ff77bcc6809b", "patch": "@@ -14,8 +14,7 @@ use self::Position::*;\n use fmt_macros as parse;\n \n use syntax::ast;\n-use syntax::ext::base;\n-use syntax::ext::base::*;\n+use syntax::ext::base::{self, *};\n use syntax::ext::build::AstBuilder;\n use syntax::feature_gate;\n use syntax::parse::token;\n@@ -24,6 +23,7 @@ use syntax::symbol::Symbol;\n use syntax::tokenstream;\n use syntax_pos::{MultiSpan, Span, DUMMY_SP};\n \n+use std::borrow::Cow;\n use std::collections::hash_map::Entry;\n use std::collections::{HashMap, HashSet};\n \n@@ -143,8 +143,10 @@ fn parse_args(ecx: &mut ExtCtxt,\n         ecx.span_err(sp, \"requires at least a format string argument\");\n         return None;\n     }\n+\n     let fmtstr = panictry!(p.parse_expr());\n     let mut named = false;\n+\n     while p.token != token::Eof {\n         if !p.eat(&token::Comma) {\n             ecx.span_err(p.span, \"expected token: `,`\");\n@@ -264,11 +266,11 @@ impl<'a, 'b> Context<'a, 'b> {\n         }\n     }\n \n-    fn describe_num_args(&self) -> String {\n+    fn describe_num_args(&self) -> Cow<str> {\n         match self.args.len() {\n-            0 => \"no arguments were given\".to_string(),\n-            1 => \"there is 1 argument\".to_string(),\n-            x => format!(\"there are {} arguments\", x),\n+            0 => \"no arguments were given\".into(),\n+            1 => \"there is 1 argument\".into(),\n+            x => format!(\"there are {} arguments\", x).into(),\n         }\n     }\n \n@@ -772,8 +774,10 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n     // `ArgumentType` does not derive `Clone`.\n     let arg_types: Vec<_> = (0..args.len()).map(|_| Vec::new()).collect();\n     let arg_unique_types: Vec<_> = (0..args.len()).map(|_| Vec::new()).collect();\n+\n     let mut macsp = ecx.call_site();\n     macsp = macsp.apply_mark(ecx.current_expansion.mark);\n+\n     let msg = \"format argument must be a string literal\";\n     let fmt_sp = efmt.span;\n     let fmt = match expr_to_spanned_string(ecx, efmt, msg) {\n@@ -796,11 +800,46 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n             return DummyResult::raw_expr(sp);\n         }\n     };\n+\n     let is_literal = match ecx.codemap().span_to_snippet(fmt_sp) {\n         Ok(ref s) if s.starts_with(\"\\\"\") || s.starts_with(\"r#\") => true,\n         _ => false,\n     };\n \n+    let fmt_str = &*fmt.node.0.as_str();\n+    let str_style = match fmt.node.1 {\n+        ast::StrStyle::Cooked => None,\n+        ast::StrStyle::Raw(raw) => Some(raw as usize),\n+    };\n+\n+    let mut parser = parse::Parser::new(fmt_str, str_style);\n+\n+    let mut unverified_pieces = Vec::new();\n+    while let Some(piece) = parser.next() {\n+        if !parser.errors.is_empty() {\n+            break;\n+        } else {\n+            unverified_pieces.push(piece);\n+        }\n+    }\n+\n+    if !parser.errors.is_empty() {\n+        let err = parser.errors.remove(0);\n+        let sp = fmt.span.from_inner_byte_pos(err.start, err.end);\n+        let mut e = ecx.struct_span_err(sp, &format!(\"invalid format string: {}\",\n+                                                        err.description));\n+        e.span_label(sp, err.label + \" in format string\");\n+        if let Some(note) = err.note {\n+            e.note(&note);\n+        }\n+        e.emit();\n+        return DummyResult::raw_expr(sp);\n+    }\n+\n+    let arg_spans = parser.arg_places.iter()\n+        .map(|&(start, end)| fmt.span.from_inner_byte_pos(start, end))\n+        .collect();\n+\n     let mut cx = Context {\n         ecx,\n         args,\n@@ -815,42 +854,22 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n         count_positions_count: 0,\n         count_args_index_offset: 0,\n         literal: String::new(),\n-        pieces: Vec::new(),\n-        str_pieces: Vec::new(),\n+        pieces: Vec::with_capacity(unverified_pieces.len()),\n+        str_pieces: Vec::with_capacity(unverified_pieces.len()),\n         all_pieces_simple: true,\n         macsp,\n         fmtsp: fmt.span,\n         invalid_refs: Vec::new(),\n-        arg_spans: Vec::new(),\n+        arg_spans,\n         is_literal,\n     };\n \n-    let fmt_str = &*fmt.node.0.as_str();\n-    let str_style = match fmt.node.1 {\n-        ast::StrStyle::Cooked => None,\n-        ast::StrStyle::Raw(raw) => Some(raw as usize),\n-    };\n-    let mut parser = parse::Parser::new(fmt_str, str_style);\n-    let mut unverified_pieces = vec![];\n-    let mut pieces = vec![];\n-\n-    while let Some(piece) = parser.next() {\n-        if !parser.errors.is_empty() {\n-            break;\n-        }\n-        unverified_pieces.push(piece);\n-    }\n-\n-    cx.arg_spans = parser.arg_places.iter()\n-        .map(|&(start, end)| fmt.span.from_inner_byte_pos(start, end))\n-        .collect();\n-\n     // This needs to happen *after* the Parser has consumed all pieces to create all the spans\n-    for mut piece in unverified_pieces {\n+    let pieces = unverified_pieces.into_iter().map(|mut piece| {\n         cx.verify_piece(&piece);\n         cx.resolve_name_inplace(&mut piece);\n-        pieces.push(piece);\n-    }\n+        piece\n+    }).collect::<Vec<_>>();\n \n     let numbered_position_args = pieces.iter().any(|arg: &parse::Piece| {\n         match *arg {\n@@ -867,6 +886,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n     cx.build_index_map();\n \n     let mut arg_index_consumed = vec![0usize; cx.arg_index_map.len()];\n+\n     for piece in pieces {\n         if let Some(piece) = cx.build_piece(&piece, &mut arg_index_consumed) {\n             let s = cx.build_literal_string();\n@@ -875,18 +895,6 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n         }\n     }\n \n-    if !parser.errors.is_empty() {\n-        let err = parser.errors.remove(0);\n-        let sp = cx.fmtsp.from_inner_byte_pos(err.start, err.end);\n-        let mut e = cx.ecx.struct_span_err(sp, &format!(\"invalid format string: {}\",\n-                                                        err.description));\n-        e.span_label(sp, err.label + \" in format string\");\n-        if let Some(note) = err.note {\n-            e.note(&note);\n-        }\n-        e.emit();\n-        return DummyResult::raw_expr(sp);\n-    }\n     if !cx.literal.is_empty() {\n         let s = cx.build_literal_string();\n         cx.str_pieces.push(s);\n@@ -898,24 +906,25 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n \n     // Make sure that all arguments were used and all arguments have types.\n     let num_pos_args = cx.args.len() - cx.names.len();\n-    let mut errs = vec![];\n-    for (i, ty) in cx.arg_types.iter().enumerate() {\n-        if ty.len() == 0 {\n-            if cx.count_positions.contains_key(&i) {\n-                continue;\n-            }\n-            let msg = if i >= num_pos_args {\n-                // named argument\n-                \"named argument never used\"\n-            } else {\n-                // positional argument\n-                \"argument never used\"\n-            };\n-            errs.push((cx.args[i].span, msg));\n-        }\n-    }\n+\n+    let errs = cx.arg_types\n+                 .iter()\n+                 .enumerate()\n+                 .filter(|(i, ty)| ty.is_empty() && !cx.count_positions.contains_key(&i))\n+                 .map(|(i, _)| {\n+                    let msg = if i >= num_pos_args {\n+                        // named argument\n+                        \"named argument never used\"\n+                    } else {\n+                        // positional argument\n+                        \"argument never used\"\n+                    };\n+                    (cx.args[i].span, msg)\n+                 })\n+                 .collect::<Vec<_>>();\n+\n     let errs_len = errs.len();\n-    if errs_len > 0 {\n+    if !errs.is_empty() {\n         let args_used = cx.arg_types.len() - errs_len;\n         let args_unused = errs_len;\n "}]}