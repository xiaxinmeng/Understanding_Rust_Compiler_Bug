{"sha": "48ddf9068229cf29a9680913db506d358e446d8e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4ZGRmOTA2ODIyOWNmMjlhOTY4MDkxM2RiNTA2ZDM1OGU0NDZkOGU=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-07-16T21:54:44Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-07-16T21:54:44Z"}, "message": "Merge branch 'doc_io_traits_enums' of https://github.com/steveklabnik/rust into rollup_central", "tree": {"sha": "ad812f660e17644adde3af450e330b07b0353ece", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad812f660e17644adde3af450e330b07b0353ece"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48ddf9068229cf29a9680913db506d358e446d8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48ddf9068229cf29a9680913db506d358e446d8e", "html_url": "https://github.com/rust-lang/rust/commit/48ddf9068229cf29a9680913db506d358e446d8e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48ddf9068229cf29a9680913db506d358e446d8e/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c451bb81ee1915fd19ac30cccc8fff2f784fdb58", "url": "https://api.github.com/repos/rust-lang/rust/commits/c451bb81ee1915fd19ac30cccc8fff2f784fdb58", "html_url": "https://github.com/rust-lang/rust/commit/c451bb81ee1915fd19ac30cccc8fff2f784fdb58"}, {"sha": "4fb02a391d7e1ef3e94d00f10af18304e5c1b53f", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fb02a391d7e1ef3e94d00f10af18304e5c1b53f", "html_url": "https://github.com/rust-lang/rust/commit/4fb02a391d7e1ef3e94d00f10af18304e5c1b53f"}], "stats": {"total": 659, "additions": 601, "deletions": 58}, "files": [{"sha": "244747310310170ea1c1b749faf4fa9f7dc360eb", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 601, "deletions": 58, "changes": 659, "blob_url": "https://github.com/rust-lang/rust/blob/48ddf9068229cf29a9680913db506d358e446d8e/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48ddf9068229cf29a9680913db506d358e446d8e/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=48ddf9068229cf29a9680913db506d358e446d8e", "patch": "@@ -127,14 +127,50 @@ fn read_to_end<R: Read + ?Sized>(r: &mut R, buf: &mut Vec<u8>) -> Result<usize>\n     ret\n }\n \n-/// A trait for objects which are byte-oriented sources.\n+/// The `Read` trait allows for reading bytes from a source.\n ///\n-/// Readers are defined by one method, `read`. Each call to `read` will attempt\n-/// to pull bytes from this source into a provided buffer.\n+/// Implementors of the `Read` trait are sometimes called 'readers'.\n ///\n-/// Readers are intended to be composable with one another. Many objects\n-/// throughout the I/O and related libraries take and provide types which\n-/// implement the `Read` trait.\n+/// Readers are defined by one required method, `read()`. Each call to `read`\n+/// will attempt to pull bytes from this source into a provided buffer. A\n+/// number of other methods are implemented in terms of `read()`, giving\n+/// implementors a number of ways to read bytes while only needing to implement\n+/// a single method.\n+///\n+/// Readers are intended to be composable with one another. Many implementors\n+/// throughout `std::io` take and provide types which implement the `Read`\n+/// trait.\n+///\n+/// # Examples\n+///\n+/// [`File`][file]s implement `Read`:\n+///\n+/// [file]: ../std/fs/struct.File.html\n+///\n+/// ```\n+/// use std::io;\n+/// use std::io::prelude::*;\n+/// use std::fs::File;\n+///\n+/// # fn foo() -> io::Result<()> {\n+/// let mut f = try!(File::open(\"foo.txt\"));\n+/// let mut buffer = [0; 10];\n+///\n+/// // read up to 10 bytes\n+/// try!(f.read(&mut buffer));\n+///\n+/// let mut buffer = vec![0; 10];\n+/// // read the whole file\n+/// try!(f.read_to_end(&mut buffer));\n+///\n+/// // read into a String, so that you don't need to do the conversion.\n+/// let mut buffer = String::new();\n+/// try!(f.read_to_string(&mut buffer));\n+///\n+/// // and more! See the other methods for more details.\n+/// # Ok(())\n+/// # }\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Read {\n     /// Pull some bytes from this source into the specified buffer, returning\n@@ -164,6 +200,27 @@ pub trait Read {\n     /// If this function encounters any form of I/O or other error, an error\n     /// variant will be returned. If an error is returned then it must be\n     /// guaranteed that no bytes were read.\n+    ///\n+    /// # Examples\n+    ///\n+    /// [`File`][file]s implement `Read`:\n+    ///\n+    /// [file]: ../std/fs/struct.File.html\n+    ///\n+    /// ```\n+    /// use std::io;\n+    /// use std::io::prelude::*;\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> io::Result<()> {\n+    /// let mut f = try!(File::open(\"foo.txt\"));\n+    /// let mut buffer = [0; 10];\n+    ///\n+    /// // read 10 bytes\n+    /// try!(f.read(&mut buffer[..]));\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn read(&mut self, buf: &mut [u8]) -> Result<usize>;\n \n@@ -185,6 +242,27 @@ pub trait Read {\n     /// If any other read error is encountered then this function immediately\n     /// returns. Any bytes which have already been read will be appended to\n     /// `buf`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// [`File`][file]s implement `Read`:\n+    ///\n+    /// [file]: ../std/fs/struct.File.html\n+    ///\n+    /// ```\n+    /// use std::io;\n+    /// use std::io::prelude::*;\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> io::Result<()> {\n+    /// let mut f = try!(File::open(\"foo.txt\"));\n+    /// let mut buffer = Vec::new();\n+    ///\n+    /// // read the whole file\n+    /// try!(f.read_to_end(&mut buffer));\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn read_to_end(&mut self, buf: &mut Vec<u8>) -> Result<usize> {\n         read_to_end(self, buf)\n@@ -200,7 +278,29 @@ pub trait Read {\n     /// If the data in this stream is *not* valid UTF-8 then an error is\n     /// returned and `buf` is unchanged.\n     ///\n-    /// See `read_to_end` for other error semantics.\n+    /// See [`read_to_end()`][readtoend] for other error semantics.\n+    ///\n+    /// [readtoend]: #method.read_to_end\n+    ///\n+    /// # Examples\n+    ///\n+    /// [`File`][file]s implement `Read`:\n+    ///\n+    /// [file]: ../std/fs/struct.File.html\n+    ///\n+    /// ```\n+    /// use std::io;\n+    /// use std::io::prelude::*;\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> io::Result<()> {\n+    /// let mut f = try!(File::open(\"foo.txt\"));\n+    /// let mut buffer = String::new();\n+    ///\n+    /// try!(f.read_to_string(&mut buffer));\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn read_to_string(&mut self, buf: &mut String) -> Result<usize> {\n         // Note that we do *not* call `.read_to_end()` here. We are passing\n@@ -219,6 +319,36 @@ pub trait Read {\n     ///\n     /// The returned adaptor also implements `Read` and will simply borrow this\n     /// current reader.\n+    ///\n+    /// # Examples\n+    ///\n+    /// [`File`][file]s implement `Read`:\n+    ///\n+    /// [file]: ../std/fs/struct.File.html\n+    ///\n+    /// ```\n+    /// use std::io;\n+    /// use std::io::Read;\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> io::Result<()> {\n+    /// let mut f = try!(File::open(\"foo.txt\"));\n+    /// let mut buffer = Vec::new();\n+    /// let mut other_buffer = Vec::new();\n+    ///\n+    /// {\n+    ///     let reference = f.by_ref();\n+    ///\n+    ///     // read at most 5 bytes\n+    ///     try!(reference.take(5).read_to_end(&mut buffer));\n+    ///\n+    /// } // drop our &mut reference so we can use f again\n+    ///\n+    /// // original file still usable, read the rest\n+    /// try!(f.read_to_end(&mut other_buffer));\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn by_ref(&mut self) -> &mut Self where Self: Sized { self }\n \n@@ -228,6 +358,27 @@ pub trait Read {\n     /// R::Err>`.  The yielded item is `Ok` if a byte was successfully read and\n     /// `Err` otherwise for I/O errors. EOF is mapped to returning `None` from\n     /// this iterator.\n+    ///\n+    /// # Examples\n+    ///\n+    /// [`File`][file]s implement `Read`:\n+    ///\n+    /// [file]: ../std/fs/struct.File.html\n+    ///\n+    /// ```\n+    /// use std::io;\n+    /// use std::io::prelude::*;\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> io::Result<()> {\n+    /// let mut f = try!(File::open(\"foo.txt\"));\n+    ///\n+    /// for byte in f.bytes() {\n+    ///     println!(\"{}\", byte.unwrap());\n+    /// }\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn bytes(self) -> Bytes<Self> where Self: Sized {\n         Bytes { inner: self }\n@@ -243,6 +394,28 @@ pub trait Read {\n     ///\n     /// Currently this adaptor will discard intermediate data read, and should\n     /// be avoided if this is not desired.\n+    ///\n+    /// # Examples\n+    ///\n+    /// [`File`][file]s implement `Read`:\n+    ///\n+    /// [file]: ../std/fs/struct.File.html\n+    ///\n+    /// ```\n+    /// #![feature(io)]\n+    /// use std::io;\n+    /// use std::io::prelude::*;\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> io::Result<()> {\n+    /// let mut f = try!(File::open(\"foo.txt\"));\n+    ///\n+    /// for c in f.chars() {\n+    ///     println!(\"{}\", c.unwrap());\n+    /// }\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[unstable(feature = \"io\", reason = \"the semantics of a partial read/write \\\n                                          of where errors happen is currently \\\n                                          unclear and may change\")]\n@@ -255,6 +428,31 @@ pub trait Read {\n     /// The returned `Read` instance will first read all bytes from this object\n     /// until EOF is encountered. Afterwards the output is equivalent to the\n     /// output of `next`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// [`File`][file]s implement `Read`:\n+    ///\n+    /// [file]: ../std/fs/struct.File.html\n+    ///\n+    /// ```\n+    /// use std::io;\n+    /// use std::io::prelude::*;\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> io::Result<()> {\n+    /// let mut f1 = try!(File::open(\"foo.txt\"));\n+    /// let mut f2 = try!(File::open(\"bar.txt\"));\n+    ///\n+    /// let mut handle = f1.chain(f2);\n+    /// let mut buffer = String::new();\n+    ///\n+    /// // read the value into a String. We could use any Read method here,\n+    /// // this is just one example.\n+    /// try!(handle.read_to_string(&mut buffer));\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn chain<R: Read>(self, next: R) -> Chain<Self, R> where Self: Sized {\n         Chain { first: self, second: next, done_first: false }\n@@ -266,6 +464,29 @@ pub trait Read {\n     /// `limit` bytes, after which it will always return EOF (`Ok(0)`). Any\n     /// read errors will not count towards the number of bytes read and future\n     /// calls to `read` may succeed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// [`File`][file]s implement `Read`:\n+    ///\n+    /// [file]: ../std/fs/struct.File.html\n+    ///\n+    /// ```\n+    /// use std::io;\n+    /// use std::io::prelude::*;\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> io::Result<()> {\n+    /// let mut f = try!(File::open(\"foo.txt\"));\n+    /// let mut buffer = [0; 10];\n+    ///\n+    /// // read at most five bytes\n+    /// let mut handle = f.take(5);\n+    ///\n+    /// try!(handle.read(&mut buffer));\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn take(self, limit: u64) -> Take<Self> where Self: Sized {\n         Take { inner: self, limit: limit }\n@@ -277,6 +498,31 @@ pub trait Read {\n     /// Whenever the returned `Read` instance is read it will write the read\n     /// data to `out`. The current semantics of this implementation imply that\n     /// a `write` error will not report how much data was initially read.\n+    ///\n+    /// # Examples\n+    ///\n+    /// [`File`][file]s implement `Read`:\n+    ///\n+    /// [file]: ../std/fs/struct.File.html\n+    ///\n+    /// ```\n+    /// #![feature(io)]\n+    /// use std::io;\n+    /// use std::io::prelude::*;\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> io::Result<()> {\n+    /// let mut f = try!(File::open(\"foo.txt\"));\n+    /// let mut buffer1 = Vec::with_capacity(10);\n+    /// let mut buffer2 = Vec::with_capacity(10);\n+    ///\n+    /// // write the output to buffer1 as we read\n+    /// let mut handle = f.tee(&mut buffer1);\n+    ///\n+    /// try!(handle.read(&mut buffer2));\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[unstable(feature = \"io\", reason = \"the semantics of a partial read/write \\\n                                          of where errors happen is currently \\\n                                          unclear and may change\")]\n@@ -287,15 +533,34 @@ pub trait Read {\n \n /// A trait for objects which are byte-oriented sinks.\n ///\n-/// The `write` method will attempt to write some data into the object,\n-/// returning how many bytes were successfully written.\n+/// Implementors of the `Write` trait are sometimes called 'writers'.\n ///\n-/// The `flush` method is useful for adaptors and explicit buffers themselves\n-/// for ensuring that all buffered data has been pushed out to the \"true sink\".\n+/// Writers are defined by two required methods, `write()` and `flush()`:\n ///\n-/// Writers are intended to be composable with one another. Many objects\n-/// throughout the I/O and related libraries take and provide types which\n-/// implement the `Write` trait.\n+/// * The `write()` method will attempt to write some data into the object,\n+///   returning how many bytes were successfully written.\n+///\n+/// * The `flush()` method is useful for adaptors and explicit buffers\n+///   themselves for ensuring that all buffered data has been pushed out to the\n+///   'true sink'.\n+///\n+/// Writers are intended to be composable with one another. Many implementors\n+/// throughout `std::io` take and provide types which implement the `Write`\n+/// trait.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::io::prelude::*;\n+/// use std::fs::File;\n+///\n+/// # fn foo() -> std::io::Result<()> {\n+/// let mut buffer = try!(File::create(\"foo.txt\"));\n+///\n+/// try!(buffer.write(b\"some bytes\"));\n+/// # Ok(())\n+/// # }\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Write {\n     /// Write a buffer into this object, returning how many bytes were written.\n@@ -322,6 +587,20 @@ pub trait Write {\n     ///\n     /// It is **not** considered an error if the entire buffer could not be\n     /// written to this writer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::io::prelude::*;\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// let mut buffer = try!(File::create(\"foo.txt\"));\n+    ///\n+    /// try!(buffer.write(b\"some bytes\"));\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn write(&mut self, buf: &[u8]) -> Result<usize>;\n \n@@ -332,6 +611,22 @@ pub trait Write {\n     ///\n     /// It is considered an error if not all bytes could be written due to\n     /// I/O errors or EOF being reached.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::io::prelude::*;\n+    /// use std::io::BufWriter;\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// let mut buffer = BufWriter::new(try!(File::create(\"foo.txt\")));\n+    ///\n+    /// try!(buffer.write(b\"some bytes\"));\n+    /// try!(buffer.flush());\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn flush(&mut self) -> Result<()>;\n \n@@ -345,6 +640,20 @@ pub trait Write {\n     /// # Errors\n     ///\n     /// This function will return the first error that `write` returns.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::io::prelude::*;\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// let mut buffer = try!(File::create(\"foo.txt\"));\n+    ///\n+    /// try!(buffer.write_all(b\"some bytes\"));\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn write_all(&mut self, mut buf: &[u8]) -> Result<()> {\n         while !buf.is_empty() {\n@@ -362,17 +671,41 @@ pub trait Write {\n     /// Writes a formatted string into this writer, returning any error\n     /// encountered.\n     ///\n-    /// This method is primarily used to interface with the `format_args!`\n-    /// macro, but it is rare that this should explicitly be called. The\n-    /// `write!` macro should be favored to invoke this method instead.\n+    /// This method is primarily used to interface with the\n+    /// [`format_args!`][formatargs] macro, but it is rare that this should\n+    /// explicitly be called. The [`write!`][write] macro should be favored to\n+    /// invoke this method instead.\n+    ///\n+    /// [formatargs]: ../std/macro.format_args!.html\n+    /// [write]: ../std/macro.write!.html\n     ///\n-    /// This function internally uses the `write_all` method on this trait and\n-    /// hence will continuously write data so long as no errors are received.\n-    /// This also means that partial writes are not indicated in this signature.\n+    /// This function internally uses the [`write_all`][writeall] method on\n+    /// this trait and hence will continuously write data so long as no errors\n+    /// are received. This also means that partial writes are not indicated in\n+    /// this signature.\n+    ///\n+    /// [writeall]: #method.write_all\n     ///\n     /// # Errors\n     ///\n     /// This function will return any I/O error reported while formatting.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::io::prelude::*;\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// let mut buffer = try!(File::create(\"foo.txt\"));\n+    ///\n+    /// // this call\n+    /// try!(write!(buffer, \"{:.*}\", 2, 1.234567));\n+    /// // turns into this:\n+    /// try!(buffer.write_fmt(format_args!(\"{:.*}\", 2, 1.234567)));\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<()> {\n         // Create a shim which translates a Write to a fmt::Write and saves\n@@ -405,6 +738,23 @@ pub trait Write {\n     ///\n     /// The returned adaptor also implements `Write` and will simply borrow this\n     /// current writer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::io::Write;\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// let mut buffer = try!(File::create(\"foo.txt\"));\n+    ///\n+    /// let reference = buffer.by_ref();\n+    ///\n+    /// // we can use reference just like our original buffer\n+    /// try!(reference.write_all(b\"some bytes\"));\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn by_ref(&mut self) -> &mut Self where Self: Sized { self }\n \n@@ -416,6 +766,25 @@ pub trait Write {\n     /// implementation do not precisely track where errors happen. For example\n     /// an error on the second call to `write` will not report that the first\n     /// call to `write` succeeded.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(io)]\n+    /// use std::io::prelude::*;\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// let mut buffer1 = try!(File::create(\"foo.txt\"));\n+    /// let mut buffer2 = Vec::new();\n+    ///\n+    /// // write the output to buffer1 as we read\n+    /// let mut handle = buffer1.broadcast(&mut buffer2);\n+    ///\n+    /// try!(handle.write(b\"some bytes\"));\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[unstable(feature = \"io\", reason = \"the semantics of a partial read/write \\\n                                          of where errors happen is currently \\\n                                          unclear and may change\")]\n@@ -426,17 +795,38 @@ pub trait Write {\n     }\n }\n \n-/// An object implementing `Seek` internally has some form of cursor which can\n-/// be moved within a stream of bytes.\n+/// The `Seek` trait provides a cursor which can be moved within a stream of\n+/// bytes.\n ///\n /// The stream typically has a fixed size, allowing seeking relative to either\n /// end or the current offset.\n+///\n+/// # Examples\n+///\n+/// [`File`][file]s implement `Seek`:\n+///\n+/// [file]: ../std/fs/struct.File.html\n+///\n+/// ```\n+/// use std::io;\n+/// use std::io::prelude::*;\n+/// use std::fs::File;\n+/// use std::io::SeekFrom;\n+///\n+/// # fn foo() -> io::Result<()> {\n+/// let mut f = try!(File::open(\"foo.txt\"));\n+///\n+/// // move the cursor 42 bytes from the start of the file\n+/// try!(f.seek(SeekFrom::Start(42)));\n+/// # Ok(())\n+/// # }\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Seek {\n-    /// Seek to an offset, in bytes, in a stream\n+    /// Seek to an offset, in bytes, in a stream.\n     ///\n-    /// A seek beyond the end of a stream is allowed, but seeking before offset\n-    /// 0 is an error.\n+    /// A seek beyond the end of a stream is allowed, but implementation\n+    /// defined.\n     ///\n     /// The behavior when seeking past the end of the stream is implementation\n     /// defined.\n@@ -446,7 +836,7 @@ pub trait Seek {\n     ///\n     /// # Errors\n     ///\n-    /// Seeking to a negative offset is considered an error\n+    /// Seeking to a negative offset is considered an error.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn seek(&mut self, pos: SeekFrom) -> Result<u64>;\n }\n@@ -505,59 +895,135 @@ fn read_until<R: BufRead + ?Sized>(r: &mut R, delim: u8, buf: &mut Vec<u8>)\n     }\n }\n \n-/// A `BufRead` is a type of reader which has some form of internal buffering to\n-/// allow certain kinds of reading operations to be more optimized than others.\n+/// A `BufRead` is a type of `Read`er which has an internal buffer, allowing it\n+/// to perform extra ways of reading.\n+///\n+/// For example, reading line-by-line is inefficient without using a buffer, so\n+/// if you want to read by line, you'll need `BufRead`, which includes a\n+/// [`read_line()`][readline] method as well as a [`lines()`][lines] iterator.\n+///\n+/// [readline]: #method.read_line\n+/// [lines]: #method.lines\n+///\n+/// # Examples\n+///\n+/// A locked standard input implements `BufRead`:\n+///\n+/// ```\n+/// use std::io;\n+/// use std::io::prelude::*;\n+///\n+/// let stdin = io::stdin();\n+/// for line in stdin.lock().lines() {\n+///     println!(\"{}\", line.unwrap());\n+/// }\n+/// ```\n+///\n+/// If you have something that implements `Read`, you can use the [`BufReader`\n+/// type][bufreader] to turn it into a `BufRead`.\n+///\n+/// For example, [`File`][file] implements `Read`, but not `BufRead`.\n+/// `BufReader` to the rescue!\n+///\n+/// [bufreader]: struct.BufReader.html\n+/// [file]: ../fs/struct.File.html\n+///\n+/// ```\n+/// use std::io::{self, BufReader};\n+/// use std::io::prelude::*;\n+/// use std::fs::File;\n ///\n-/// This type extends the `Read` trait with a few methods that are not\n-/// possible to reasonably implement with purely a read interface.\n+/// # fn foo() -> io::Result<()> {\n+/// let f = try!(File::open(\"foo.txt\"));\n+/// let f = BufReader::new(f);\n+///\n+/// for line in f.lines() {\n+///     println!(\"{}\", line.unwrap());\n+/// }\n+///\n+/// # Ok(())\n+/// # }\n+/// ```\n ///\n-/// You can use the [`BufReader` wrapper type](struct.BufReader.html) to turn any\n-/// reader into a buffered reader.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait BufRead: Read {\n     /// Fills the internal buffer of this object, returning the buffer contents.\n     ///\n-    /// None of the contents will be \"read\" in the sense that later calling\n-    /// `read` may return the same contents.\n+    /// This function is a lower-level call. It needs to be paired with the\n+    /// [`consume`][consume] method to function properly. When calling this\n+    /// method, none of the contents will be \"read\" in the sense that later\n+    /// calling `read` may return the same contents. As such, `consume` must be\n+    /// called with the number of bytes that are consumed from this buffer to\n+    /// ensure that the bytes are never returned twice.\n     ///\n-    /// The `consume` function must be called with the number of bytes that are\n-    /// consumed from this buffer returned to ensure that the bytes are never\n-    /// returned twice.\n+    /// [consume]: #tymethod.consume\n     ///\n     /// An empty buffer returned indicates that the stream has reached EOF.\n     ///\n     /// # Errors\n     ///\n     /// This function will return an I/O error if the underlying reader was\n     /// read, but returned an error.\n+    ///\n+    /// # Examples\n+    ///\n+    /// A locked standard input implements `BufRead`:\n+    ///\n+    /// ```\n+    /// use std::io;\n+    /// use std::io::prelude::*;\n+    ///\n+    /// let stdin = io::stdin();\n+    /// let mut stdin = stdin.lock();\n+    ///\n+    /// // we can't have two `&mut` references to `stdin`, so use a block\n+    /// // to end the borrow early.\n+    /// let length = {\n+    ///     let buffer = stdin.fill_buf().unwrap();\n+    ///\n+    ///     // work with buffer\n+    ///     println!(\"{:?}\", buffer);\n+    ///\n+    ///     buffer.len()\n+    /// };\n+    ///\n+    /// // ensure the bytes we worked with aren't returned again later\n+    /// stdin.consume(length);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn fill_buf(&mut self) -> Result<&[u8]>;\n \n     /// Tells this buffer that `amt` bytes have been consumed from the buffer,\n     /// so they should no longer be returned in calls to `read`.\n     ///\n-    /// This function does not perform any I/O, it simply informs this object\n-    /// that some amount of its buffer, returned from `fill_buf`, has been\n-    /// consumed and should no longer be returned.\n+    /// This function is a lower-level call. It needs to be paired with the\n+    /// [`fill_buf`][fillbuf] method to function properly. This function does\n+    /// not perform any I/O, it simply informs this object that some amount of\n+    /// its buffer, returned from `fill_buf`, has been consumed and should no\n+    /// longer be returned. As such, this function may do odd things if\n+    /// `fill_buf` isn't called before calling it.\n     ///\n-    /// This function is used to tell the buffer how many bytes you've consumed\n-    /// from the return value of `fill_buf`, and so may do odd things if\n-    /// `fill_buf` isn't called before calling this.\n+    /// [fillbuf]: #tymethod.fill_buff\n     ///\n-    /// The `amt` must be `<=` the number of bytes in the buffer returned by `fill_buf`.\n+    /// The `amt` must be `<=` the number of bytes in the buffer returned by\n+    /// `fill_buf`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Since `consume()` is meant to be used with [`fill_buf()`][fillbuf],\n+    /// that method's example includes an example of `consume()`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn consume(&mut self, amt: usize);\n \n-    /// Read all bytes until the delimiter `byte` is reached.\n+    /// Read all bytes into `buf` until the delimiter `byte` is reached.\n     ///\n-    /// This function will continue to read (and buffer) bytes from the\n-    /// underlying stream until the delimiter or EOF is found. Once found, all\n-    /// bytes up to, and including, the delimiter (if found) will be appended to\n-    /// `buf`.\n+    /// This function will read bytes from the underlying stream until the\n+    /// delimiter or EOF is found. Once found, all bytes up to, and including,\n+    /// the delimiter (if found) will be appended to `buf`.\n     ///\n-    /// If this buffered reader is currently at EOF, then this function will not\n-    /// place any more bytes into `buf` and will return `Ok(n)` where `n` is the\n-    /// number of bytes which were read.\n+    /// If this reader is currently at EOF then this function will not modify\n+    /// `buf` and will return `Ok(n)` where `n` is the number of bytes which\n+    /// were read.\n     ///\n     /// # Errors\n     ///\n@@ -566,18 +1032,39 @@ pub trait BufRead: Read {\n     ///\n     /// If an I/O error is encountered then all bytes read so far will be\n     /// present in `buf` and its length will have been adjusted appropriately.\n+    ///\n+    /// # Examples\n+    ///\n+    /// A locked standard input implements `BufRead`. In this example, we'll\n+    /// read from standard input until we see an `a` byte.\n+    ///\n+    /// ```\n+    /// use std::io;\n+    /// use std::io::prelude::*;\n+    ///\n+    /// fn foo() -> io::Result<()> {\n+    /// let stdin = io::stdin();\n+    /// let mut stdin = stdin.lock();\n+    /// let mut buffer = Vec::new();\n+    ///\n+    /// try!(stdin.read_until(b'a', &mut buffer));\n+    ///\n+    /// println!(\"{:?}\", buffer);\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> Result<usize> {\n         read_until(self, byte, buf)\n     }\n \n-    /// Read all bytes until a newline (the 0xA byte) is reached, and\n-    /// append them to the provided buffer.\n+    /// Read all bytes until a newline (the 0xA byte) is reached, and append\n+    /// them to the provided buffer.\n     ///\n-    /// This function will continue to read (and buffer) bytes from the\n-    /// underlying stream until the newline delimiter (the 0xA byte) or EOF is\n-    /// found. Once found, all bytes up to, and including, the delimiter (if\n-    /// found) will be appended to `buf`.\n+    /// This function will read bytes from the underlying stream until the\n+    /// newline delimiter (the 0xA byte) or EOF is found. Once found, all bytes\n+    /// up to, and including, the delimiter (if found) will be appended to\n+    /// `buf`.\n     ///\n     /// If this reader is currently at EOF then this function will not modify\n     /// `buf` and will return `Ok(n)` where `n` is the number of bytes which\n@@ -589,6 +1076,31 @@ pub trait BufRead: Read {\n     /// return an error if the read bytes are not valid UTF-8. If an I/O error\n     /// is encountered then `buf` may contain some bytes already read in the\n     /// event that all data read so far was valid UTF-8.\n+    ///\n+    /// # Examples\n+    ///\n+    /// A locked standard input implements `BufRead`. In this example, we'll\n+    /// read all of the lines from standard input. If we were to do this in\n+    /// an actual project, the [`lines()`][lines] method would be easier, of\n+    /// course.\n+    ///\n+    /// [lines]: #method.lines\n+    ///\n+    /// ```\n+    /// use std::io;\n+    /// use std::io::prelude::*;\n+    ///\n+    /// let stdin = io::stdin();\n+    /// let mut stdin = stdin.lock();\n+    /// let mut buffer = String::new();\n+    ///\n+    /// while stdin.read_line(&mut buffer).unwrap() > 0 {\n+    ///     // work with buffer\n+    ///     println!(\"{:?}\", buffer);\n+    ///\n+    ///     buffer.clear();\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn read_line(&mut self, buf: &mut String) -> Result<usize> {\n         // Note that we are not calling the `.read_until` method here, but\n@@ -606,6 +1118,22 @@ pub trait BufRead: Read {\n     ///\n     /// This function will yield errors whenever `read_until` would have also\n     /// yielded an error.\n+    ///\n+    /// # Examples\n+    ///\n+    /// A locked standard input implements `BufRead`. In this example, we'll\n+    /// read some input from standard input, splitting on commas.\n+    ///\n+    /// ```\n+    /// use std::io;\n+    /// use std::io::prelude::*;\n+    ///\n+    /// let stdin = io::stdin();\n+    ///\n+    /// for content in stdin.lock().split(b',') {\n+    ///     println!(\"{:?}\", content.unwrap());\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn split(self, byte: u8) -> Split<Self> where Self: Sized {\n         Split { buf: self, delim: byte }\n@@ -616,6 +1144,21 @@ pub trait BufRead: Read {\n     /// The iterator returned from this function will yield instances of\n     /// `io::Result<String>`. Each string returned will *not* have a newline\n     /// byte (the 0xA byte) at the end.\n+    ///\n+    /// # Examples\n+    ///\n+    /// A locked standard input implements `BufRead`:\n+    ///\n+    /// ```\n+    /// use std::io;\n+    /// use std::io::prelude::*;\n+    ///\n+    /// let stdin = io::stdin();\n+    ///\n+    /// for line in stdin.lock().lines() {\n+    ///     println!(\"{}\", line.unwrap());\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn lines(self) -> Lines<Self> where Self: Sized {\n         Lines { buf: self }"}]}