{"sha": "6992280f0003e825ad05daf6b5aed94c63e77773", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5OTIyODBmMDAwM2U4MjVhZDA1ZGFmNmI1YWVkOTRjNjNlNzc3NzM=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-03-03T13:48:08Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-03-10T11:50:13Z"}, "message": "simplify const path lookup for constants and associated constants", "tree": {"sha": "f4b1f70c9f638803813fe840c8b6afbb51f578c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4b1f70c9f638803813fe840c8b6afbb51f578c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6992280f0003e825ad05daf6b5aed94c63e77773", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6992280f0003e825ad05daf6b5aed94c63e77773", "html_url": "https://github.com/rust-lang/rust/commit/6992280f0003e825ad05daf6b5aed94c63e77773", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6992280f0003e825ad05daf6b5aed94c63e77773/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a48bd1718356cdcc4204b57ed282ff8111df5427", "url": "https://api.github.com/repos/rust-lang/rust/commits/a48bd1718356cdcc4204b57ed282ff8111df5427", "html_url": "https://github.com/rust-lang/rust/commit/a48bd1718356cdcc4204b57ed282ff8111df5427"}], "stats": {"total": 180, "additions": 65, "deletions": 115}, "files": [{"sha": "51985be96db53991242b92376d84703522cfe720", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6992280f0003e825ad05daf6b5aed94c63e77773/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6992280f0003e825ad05daf6b5aed94c63e77773/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=6992280f0003e825ad05daf6b5aed94c63e77773", "patch": "@@ -476,7 +476,7 @@ impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n                     Some(Def::AssociatedConst(did)) |\n                     Some(Def::Const(did)) => match lookup_const_by_id(self.tcx, did,\n                                                                     Some(pat.id), None) {\n-                        Some(const_expr) => {\n+                        Some((const_expr, _const_ty)) => {\n                             const_expr_to_pat(self.tcx, const_expr, pat.span).map(|new_pat| {\n \n                                 if let Some(ref mut renaming_map) = self.renaming_map {"}, {"sha": "3690f0c1d664b95138bef58fc1388e35dced8b6f", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 55, "deletions": 109, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/6992280f0003e825ad05daf6b5aed94c63e77773/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6992280f0003e825ad05daf6b5aed94c63e77773/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=6992280f0003e825ad05daf6b5aed94c63e77773", "patch": "@@ -98,13 +98,13 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n                                         def_id: DefId,\n                                         maybe_ref_id: Option<ast::NodeId>,\n                                         param_substs: Option<&'tcx subst::Substs<'tcx>>)\n-                                        -> Option<&'tcx Expr> {\n+                                        -> Option<(&'tcx Expr, Option<ty::Ty<'tcx>>)> {\n     if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n         match tcx.map.find(node_id) {\n             None => None,\n             Some(ast_map::NodeItem(it)) => match it.node {\n-                hir::ItemConst(_, ref const_expr) => {\n-                    Some(&const_expr)\n+                hir::ItemConst(ref ty, ref const_expr) => {\n+                    Some((&const_expr, ast_ty_to_prim_ty(tcx, ty)))\n                 }\n                 _ => None\n             },\n@@ -123,8 +123,7 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n                             if let Some(param_substs) = param_substs {\n                                 substs = substs.subst(tcx, param_substs);\n                             }\n-                            resolve_trait_associated_const(tcx, ti, trait_id,\n-                                                           substs)\n+                            resolve_trait_associated_const(tcx, ti, trait_id, substs)\n                         }\n                         // Technically, without knowing anything about the\n                         // expression that generates the obligation, we could\n@@ -138,25 +137,27 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n                 _ => None\n             },\n             Some(ast_map::NodeImplItem(ii)) => match ii.node {\n-                hir::ImplItemKind::Const(_, ref expr) => {\n-                    Some(&expr)\n+                hir::ImplItemKind::Const(ref ty, ref expr) => {\n+                    Some((&expr, ast_ty_to_prim_ty(tcx, ty)))\n                 }\n                 _ => None\n             },\n             Some(_) => None\n         }\n     } else {\n         match tcx.extern_const_statics.borrow().get(&def_id) {\n-            Some(&ast::DUMMY_NODE_ID) => return None,\n-            Some(&expr_id) => {\n-                return Some(tcx.map.expect_expr(expr_id));\n+            Some(&None) => return None,\n+            Some(&Some((expr_id, ty))) => {\n+                return Some((tcx.map.expect_expr(expr_id), ty));\n             }\n             None => {}\n         }\n         let mut used_ref_id = false;\n-        let expr_id = match tcx.sess.cstore.maybe_get_item_ast(tcx, def_id) {\n+        let expr_ty = match tcx.sess.cstore.maybe_get_item_ast(tcx, def_id) {\n             cstore::FoundAst::Found(&InlinedItem::Item(ref item)) => match item.node {\n-                hir::ItemConst(_, ref const_expr) => Some(const_expr.id),\n+                hir::ItemConst(ref ty, ref const_expr) => {\n+                    Some((&**const_expr, ast_ty_to_prim_ty(tcx, ty)))\n+                },\n                 _ => None\n             },\n             cstore::FoundAst::Found(&InlinedItem::TraitItem(trait_id, ref ti)) => match ti.node {\n@@ -173,16 +174,17 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n                             if let Some(param_substs) = param_substs {\n                                 substs = substs.subst(tcx, param_substs);\n                             }\n-                            resolve_trait_associated_const(tcx, ti, trait_id,\n-                                                           substs).map(|e| e.id)\n+                            resolve_trait_associated_const(tcx, ti, trait_id, substs)\n                         }\n                         None => None\n                     }\n                 }\n                 _ => None\n             },\n             cstore::FoundAst::Found(&InlinedItem::ImplItem(_, ref ii)) => match ii.node {\n-                hir::ImplItemKind::Const(_, ref expr) => Some(expr.id),\n+                hir::ImplItemKind::Const(ref ty, ref expr) => {\n+                    Some((&**expr, ast_ty_to_prim_ty(tcx, ty)))\n+                },\n                 _ => None\n             },\n             _ => None\n@@ -192,10 +194,10 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n         // lookup with the same def_id may yield a different result.\n         if !used_ref_id {\n             tcx.extern_const_statics\n-               .borrow_mut().insert(def_id,\n-                                    expr_id.unwrap_or(ast::DUMMY_NODE_ID));\n+               .borrow_mut()\n+               .insert(def_id, expr_ty.map(|(e, t)| (e.id, t)));\n         }\n-        expr_id.map(|id| tcx.map.expect_expr(id))\n+        expr_ty\n     }\n }\n \n@@ -386,7 +388,7 @@ pub fn const_expr_to_pat(tcx: &TyCtxt, expr: &Expr, span: Span) -> P<hir::Pat> {\n                     PatKind::Path(path.clone()),\n                 Some(Def::Const(def_id)) |\n                 Some(Def::AssociatedConst(def_id)) => {\n-                    let expr = lookup_const_by_id(tcx, def_id, Some(expr.id), None).unwrap();\n+                    let (expr, _ty) = lookup_const_by_id(tcx, def_id, Some(expr.id), None).unwrap();\n                     return const_expr_to_pat(tcx, expr, span);\n                 },\n                 _ => unreachable!(),\n@@ -778,90 +780,49 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n               if def.depth != 0 {\n                   signal!(e, UnresolvedPath);\n               }\n-              Some(def.full_def())\n+              def.full_def()\n           } else {\n-              None\n+              signal!(e, NonConstPath);\n           };\n-          let (const_expr, const_ty) = match opt_def {\n-              Some(Def::Const(def_id)) => {\n-                  if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n-                      match tcx.map.find(node_id) {\n-                          Some(ast_map::NodeItem(it)) => match it.node {\n-                              hir::ItemConst(ref ty, ref expr) => {\n-                                  (Some(&**expr), Some(&**ty))\n-                              }\n-                              _ => (None, None)\n-                          },\n-                          _ => (None, None)\n-                      }\n+          match opt_def {\n+              Def::Const(def_id) |\n+              Def::AssociatedConst(def_id) => {\n+                  let maybe_ref_id = if let ExprTypeChecked = ty_hint {\n+                      Some(e.id)\n+                  } else {\n+                      None\n+                  };\n+                  if let Some((e, ty)) = lookup_const_by_id(tcx, def_id, maybe_ref_id, None) {\n+                      let item_hint = match ty {\n+                          Some(ty) => ty_hint.checked_or(ty),\n+                          None => ty_hint,\n+                      };\n+                      try!(eval_const_expr_partial(tcx, e, item_hint, None))\n                   } else {\n-                      (lookup_const_by_id(tcx, def_id, Some(e.id), None), None)\n+                      signal!(e, NonConstPath);\n                   }\n-              }\n-              Some(Def::AssociatedConst(def_id)) => {\n-                  if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n-                      match impl_or_trait_container(tcx, def_id) {\n-                          ty::TraitContainer(trait_id) => match tcx.map.find(node_id) {\n-                              Some(ast_map::NodeTraitItem(ti)) => match ti.node {\n-                                  hir::ConstTraitItem(ref ty, _) => {\n-                                      if let ExprTypeChecked = ty_hint {\n-                                          let substs = tcx.node_id_item_substs(e.id).substs;\n-                                          (resolve_trait_associated_const(tcx,\n-                                                                          ti,\n-                                                                          trait_id,\n-                                                                          substs),\n-                                           Some(&**ty))\n-                                       } else {\n-                                           (None, None)\n-                                       }\n-                                  }\n-                                  _ => (None, None)\n-                              },\n-                              _ => (None, None)\n-                          },\n-                          ty::ImplContainer(_) => match tcx.map.find(node_id) {\n-                              Some(ast_map::NodeImplItem(ii)) => match ii.node {\n-                                  hir::ImplItemKind::Const(ref ty, ref expr) => {\n-                                      (Some(&**expr), Some(&**ty))\n-                                  }\n-                                  _ => (None, None)\n-                              },\n-                              _ => (None, None)\n-                          },\n-                      }\n+              },\n+              Def::Variant(enum_def, variant_def) => {\n+                  if let Some(const_expr) = lookup_variant_by_id(tcx, enum_def, variant_def) {\n+                      try!(eval_const_expr_partial(tcx, const_expr, ty_hint, None))\n                   } else {\n-                      (lookup_const_by_id(tcx, def_id, Some(e.id), None), None)\n+                      signal!(e, NonConstPath);\n                   }\n               }\n-              Some(Def::Variant(enum_def, variant_def)) => {\n-                  (lookup_variant_by_id(tcx, enum_def, variant_def), None)\n+              Def::Struct(..) => {\n+                  ConstVal::Struct(e.id)\n               }\n-              Some(Def::Struct(..)) => {\n-                  return Ok(ConstVal::Struct(e.id))\n-              }\n-              Some(Def::Local(_, id)) => {\n+              Def::Local(_, id) => {\n                   debug!(\"Def::Local({:?}): {:?}\", id, fn_args);\n                   if let Some(val) = fn_args.and_then(|args| args.get(&id)) {\n-                      return Ok(val.clone());\n+                      val.clone()\n                   } else {\n-                      (None, None)\n+                      signal!(e, NonConstPath);\n                   }\n               },\n-              Some(Def::Method(id)) | Some(Def::Fn(id)) => return Ok(Function(id)),\n-              _ => (None, None)\n-          };\n-          let const_expr = match const_expr {\n-              Some(actual_e) => actual_e,\n-              None => signal!(e, NonConstPath)\n-          };\n-          let item_hint = match const_ty {\n-              Some(ty) => match ast_ty_to_prim_ty(tcx, ty) {\n-                  Some(ty) => ty_hint.checked_or(ty),\n-                  None => ty_hint.erase_hint(),\n-              },\n-              None => ty_hint.erase_hint(),\n-          };\n-          try!(eval_const_expr_partial(tcx, const_expr, item_hint, fn_args))\n+              Def::Method(id) | Def::Fn(id) => Function(id),\n+              _ => signal!(e, NonConstPath),\n+          }\n       }\n       hir::ExprCall(ref callee, ref args) => {\n           let sub_ty_hint = ty_hint.erase_hint();\n@@ -1097,28 +1058,11 @@ fn infer<'tcx>(\n     }\n }\n \n-fn impl_or_trait_container(tcx: &TyCtxt, def_id: DefId) -> ty::ImplOrTraitItemContainer {\n-    // This is intended to be equivalent to tcx.impl_or_trait_item(def_id).container()\n-    // for local def_id, but it can be called before tcx.impl_or_trait_items is complete.\n-    if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n-        if let Some(ast_map::NodeItem(item)) = tcx.map.find(tcx.map.get_parent_node(node_id)) {\n-            let container_id = tcx.map.local_def_id(item.id);\n-            match item.node {\n-                hir::ItemImpl(..) => return ty::ImplContainer(container_id),\n-                hir::ItemTrait(..) => return ty::TraitContainer(container_id),\n-                _ => ()\n-            }\n-        }\n-        panic!(\"No impl or trait container for {:?}\", def_id);\n-    }\n-    panic!(\"{:?} is not local\", def_id);\n-}\n-\n fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n                                                 ti: &'tcx hir::TraitItem,\n                                                 trait_id: DefId,\n                                                 rcvr_substs: subst::Substs<'tcx>)\n-                                                -> Option<&'tcx Expr>\n+                                                -> Option<(&'tcx Expr, Option<ty::Ty<'tcx>>)>\n {\n     let trait_ref = ty::Binder(\n         rcvr_substs.erase_regions().to_trait_ref(tcx, trait_id)\n@@ -1151,7 +1095,9 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: &'a TyCtxt<'tcx>,\n                      .iter().find(|ic| ic.name == ti.name) {\n                 Some(ic) => lookup_const_by_id(tcx, ic.def_id, None, None),\n                 None => match ti.node {\n-                    hir::ConstTraitItem(_, Some(ref expr)) => Some(&*expr),\n+                    hir::ConstTraitItem(ref ty, Some(ref expr)) => {\n+                        Some((&*expr, ast_ty_to_prim_ty(tcx, ty)))\n+                    },\n                     _ => None,\n                 },\n             }"}, {"sha": "03c13115aea626fc91fc16747cbe1326594619f0", "filename": "src/librustc/middle/ty/context.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6992280f0003e825ad05daf6b5aed94c63e77773/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6992280f0003e825ad05daf6b5aed94c63e77773/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs?ref=6992280f0003e825ad05daf6b5aed94c63e77773", "patch": "@@ -342,8 +342,12 @@ pub struct TyCtxt<'tcx> {\n     /// FIXME(arielb1): why is this separate from populated_external_types?\n     pub populated_external_primitive_impls: RefCell<DefIdSet>,\n \n-    /// These caches are used by const_eval when decoding external constants.\n-    pub extern_const_statics: RefCell<DefIdMap<NodeId>>,\n+    /// Cache used by const_eval when decoding external constants.\n+    /// Contains `None` when the constant has been fetched but doesn't exist.\n+    /// Constains `Some(expr_id, type)` otherwise.\n+    /// `type` is `None` in case it's not a primitive type\n+    pub extern_const_statics: RefCell<DefIdMap<Option<(NodeId, Option<Ty<'tcx>>)>>>,\n+    /// Cache used by const_eval when decoding extern const fns\n     pub extern_const_fns: RefCell<DefIdMap<NodeId>>,\n \n     pub node_lint_levels: RefCell<FnvHashMap<(NodeId, lint::LintId),"}, {"sha": "d1e3f08aff894d01ea538f23b4e943bfba94bace", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6992280f0003e825ad05daf6b5aed94c63e77773/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6992280f0003e825ad05daf6b5aed94c63e77773/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=6992280f0003e825ad05daf6b5aed94c63e77773", "patch": "@@ -87,7 +87,7 @@ impl<'patcx, 'cx, 'tcx> PatCx<'patcx, 'cx, 'tcx> {\n                     Def::Const(def_id) | Def::AssociatedConst(def_id) =>\n                         match const_eval::lookup_const_by_id(self.cx.tcx, def_id,\n                                                              Some(pat.id), None) {\n-                            Some(const_expr) => {\n+                            Some((const_expr, _const_ty)) => {\n                                 let pat = const_eval::const_expr_to_pat(self.cx.tcx, const_expr,\n                                                                         pat.span);\n                                 return self.to_pattern(&pat);"}, {"sha": "a9e03bba7db8e0351967c18771fb545067864696", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6992280f0003e825ad05daf6b5aed94c63e77773/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6992280f0003e825ad05daf6b5aed94c63e77773/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=6992280f0003e825ad05daf6b5aed94c63e77773", "patch": "@@ -604,7 +604,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                 }\n                 Some(Def::Const(did)) |\n                 Some(Def::AssociatedConst(did)) => {\n-                    if let Some(expr) = const_eval::lookup_const_by_id(v.tcx, did,\n+                    if let Some((expr, _ty)) = const_eval::lookup_const_by_id(v.tcx, did,\n                                                                        Some(e.id),\n                                                                        None) {\n                         let inner = v.global_expr(Mode::Const, expr);"}, {"sha": "7d37627ad0eea53a7145e286857c7c80f8d2a77a", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6992280f0003e825ad05daf6b5aed94c63e77773/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6992280f0003e825ad05daf6b5aed94c63e77773/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=6992280f0003e825ad05daf6b5aed94c63e77773", "patch": "@@ -227,7 +227,7 @@ pub fn get_const_expr<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n \n     match const_eval::lookup_const_by_id(ccx.tcx(), def_id, Some(ref_expr.id), Some(param_substs)) {\n-        Some(ref expr) => expr,\n+        Some((ref expr, _ty)) => expr,\n         None => {\n             ccx.sess().span_bug(ref_expr.span, \"constant item not found\")\n         }"}]}