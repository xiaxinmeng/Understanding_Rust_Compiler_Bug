{"sha": "f6a79936da30702b1c717769a2d12dffbad6d30a", "node_id": "C_kwDOAAsO6NoAKGY2YTc5OTM2ZGEzMDcwMmIxYzcxNzc2OWEyZDEyZGZmYmFkNmQzMGE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-25T03:16:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-25T03:16:22Z"}, "message": "Auto merge of #93878 - Aaron1011:newtype-macro, r=cjgillot\n\nConvert `newtype_index` to a proc macro\n\nThe `macro_rules!` implementation was becomng excessively complicated,\nand difficult to modify. The new proc macro implementation should make\nit much easier to add new features (e.g. skipping certain `#[derive]`s)", "tree": {"sha": "2277126f6649883810888dc0073072ca60491fb2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2277126f6649883810888dc0073072ca60491fb2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6a79936da30702b1c717769a2d12dffbad6d30a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6a79936da30702b1c717769a2d12dffbad6d30a", "html_url": "https://github.com/rust-lang/rust/commit/f6a79936da30702b1c717769a2d12dffbad6d30a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6a79936da30702b1c717769a2d12dffbad6d30a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9", "html_url": "https://github.com/rust-lang/rust/commit/d4de1f230ca30b7ce08fbf453daebf8b2e7ffcc9"}, {"sha": "7b7b0f148c0e76136beb3c24d392f25bb4044612", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b7b0f148c0e76136beb3c24d392f25bb4044612", "html_url": "https://github.com/rust-lang/rust/commit/7b7b0f148c0e76136beb3c24d392f25bb4044612"}], "stats": {"total": 799, "additions": 342, "deletions": 457}, "files": [{"sha": "33c3c536f119b4bf3cf4b388e66ba00fa29cfa81", "filename": "compiler/rustc_index/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6a79936da30702b1c717769a2d12dffbad6d30a/compiler%2Frustc_index%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6a79936da30702b1c717769a2d12dffbad6d30a/compiler%2Frustc_index%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Flib.rs?ref=f6a79936da30702b1c717769a2d12dffbad6d30a", "patch": "@@ -12,6 +12,8 @@ pub mod bit_set;\n pub mod interval;\n pub mod vec;\n \n+pub use rustc_macros::newtype_index;\n+\n /// Type size assertion. The first argument is a type and the second argument is its expected size.\n #[macro_export]\n macro_rules! static_assert_size {"}, {"sha": "4656994ac0869621eb4588493acc21d00b320dc9", "filename": "compiler/rustc_index/src/vec.rs", "status": "modified", "additions": 0, "deletions": 455, "changes": 455, "blob_url": "https://github.com/rust-lang/rust/blob/f6a79936da30702b1c717769a2d12dffbad6d30a/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6a79936da30702b1c717769a2d12dffbad6d30a/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fvec.rs?ref=f6a79936da30702b1c717769a2d12dffbad6d30a", "patch": "@@ -49,461 +49,6 @@ impl Idx for u32 {\n     }\n }\n \n-/// Creates a struct type `S` that can be used as an index with\n-/// `IndexVec` and so on.\n-///\n-/// There are two ways of interacting with these indices:\n-///\n-/// - The `From` impls are the preferred way. So you can do\n-///   `S::from(v)` with a `usize` or `u32`. And you can convert back\n-///   to an integer with `u32::from(s)`.\n-///\n-/// - Alternatively, you can use the methods `S::new(v)` and `s.index()`\n-///   to create/return a value.\n-///\n-/// Internally, the index uses a u32, so the index must not exceed\n-/// `u32::MAX`. You can also customize things like the `Debug` impl,\n-/// what traits are derived, and so forth via the macro.\n-#[macro_export]\n-#[allow_internal_unstable(step_trait, rustc_attrs, trusted_step)]\n-macro_rules! newtype_index {\n-    // ---- public rules ----\n-\n-    // Use default constants\n-    ($(#[$attrs:meta])* $v:vis struct $name:ident { .. }) => (\n-        $crate::newtype_index!(\n-            // Leave out derives marker so we can use its absence to ensure it comes first\n-            @attrs        [$(#[$attrs])*]\n-            @type         [$name]\n-            // shave off 256 indices at the end to allow space for packing these indices into enums\n-            @max          [0xFFFF_FF00]\n-            @vis          [$v]\n-            @debug_format [\"{}\"]);\n-    );\n-\n-    // Define any constants\n-    ($(#[$attrs:meta])* $v:vis struct $name:ident { $($tokens:tt)+ }) => (\n-        $crate::newtype_index!(\n-            // Leave out derives marker so we can use its absence to ensure it comes first\n-            @attrs        [$(#[$attrs])*]\n-            @type         [$name]\n-            // shave off 256 indices at the end to allow space for packing these indices into enums\n-            @max          [0xFFFF_FF00]\n-            @vis          [$v]\n-            @debug_format [\"{}\"]\n-                          $($tokens)+);\n-    );\n-\n-    // ---- private rules ----\n-\n-    // Base case, user-defined constants (if any) have already been defined\n-    (@derives      [$($derives:ident,)*]\n-     @attrs        [$(#[$attrs:meta])*]\n-     @type         [$type:ident]\n-     @max          [$max:expr]\n-     @vis          [$v:vis]\n-     @debug_format [$debug_format:tt]) => (\n-        $(#[$attrs])*\n-        #[derive(Copy, PartialEq, Eq, Hash, PartialOrd, Ord, $($derives),*)]\n-        #[rustc_layout_scalar_valid_range_end($max)]\n-        $v struct $type {\n-            private: u32\n-        }\n-\n-        impl Clone for $type {\n-            #[inline]\n-            fn clone(&self) -> Self {\n-                *self\n-            }\n-        }\n-\n-        impl $type {\n-            /// Maximum value the index can take, as a `u32`.\n-            $v const MAX_AS_U32: u32 = $max;\n-\n-            /// Maximum value the index can take.\n-            $v const MAX: Self = Self::from_u32($max);\n-\n-            /// Creates a new index from a given `usize`.\n-            ///\n-            /// # Panics\n-            ///\n-            /// Will panic if `value` exceeds `MAX`.\n-            #[inline]\n-            $v const fn from_usize(value: usize) -> Self {\n-                assert!(value <= ($max as usize));\n-                // SAFETY: We just checked that `value <= max`.\n-                unsafe {\n-                    Self::from_u32_unchecked(value as u32)\n-                }\n-            }\n-\n-            /// Creates a new index from a given `u32`.\n-            ///\n-            /// # Panics\n-            ///\n-            /// Will panic if `value` exceeds `MAX`.\n-            #[inline]\n-            $v const fn from_u32(value: u32) -> Self {\n-                assert!(value <= $max);\n-                // SAFETY: We just checked that `value <= max`.\n-                unsafe {\n-                    Self::from_u32_unchecked(value)\n-                }\n-            }\n-\n-            /// Creates a new index from a given `u32`.\n-            ///\n-            /// # Safety\n-            ///\n-            /// The provided value must be less than or equal to the maximum value for the newtype.\n-            /// Providing a value outside this range is undefined due to layout restrictions.\n-            ///\n-            /// Prefer using `from_u32`.\n-            #[inline]\n-            $v const unsafe fn from_u32_unchecked(value: u32) -> Self {\n-                Self { private: value }\n-            }\n-\n-            /// Extracts the value of this index as a `usize`.\n-            #[inline]\n-            $v const fn index(self) -> usize {\n-                self.as_usize()\n-            }\n-\n-            /// Extracts the value of this index as a `u32`.\n-            #[inline]\n-            $v const fn as_u32(self) -> u32 {\n-                self.private\n-            }\n-\n-            /// Extracts the value of this index as a `usize`.\n-            #[inline]\n-            $v const fn as_usize(self) -> usize {\n-                self.as_u32() as usize\n-            }\n-        }\n-\n-        impl std::ops::Add<usize> for $type {\n-            type Output = Self;\n-\n-            fn add(self, other: usize) -> Self {\n-                Self::from_usize(self.index() + other)\n-            }\n-        }\n-\n-        impl $crate::vec::Idx for $type {\n-            #[inline]\n-            fn new(value: usize) -> Self {\n-                Self::from_usize(value)\n-            }\n-\n-            #[inline]\n-            fn index(self) -> usize {\n-                self.as_usize()\n-            }\n-        }\n-\n-        impl ::std::iter::Step for $type {\n-            #[inline]\n-            fn steps_between(start: &Self, end: &Self) -> Option<usize> {\n-                <usize as ::std::iter::Step>::steps_between(\n-                    &Self::index(*start),\n-                    &Self::index(*end),\n-                )\n-            }\n-\n-            #[inline]\n-            fn forward_checked(start: Self, u: usize) -> Option<Self> {\n-                Self::index(start).checked_add(u).map(Self::from_usize)\n-            }\n-\n-            #[inline]\n-            fn backward_checked(start: Self, u: usize) -> Option<Self> {\n-                Self::index(start).checked_sub(u).map(Self::from_usize)\n-            }\n-        }\n-\n-        // Safety: The implementation of `Step` upholds all invariants.\n-        unsafe impl ::std::iter::TrustedStep for $type {}\n-\n-        impl From<$type> for u32 {\n-            #[inline]\n-            fn from(v: $type) -> u32 {\n-                v.as_u32()\n-            }\n-        }\n-\n-        impl From<$type> for usize {\n-            #[inline]\n-            fn from(v: $type) -> usize {\n-                v.as_usize()\n-            }\n-        }\n-\n-        impl From<usize> for $type {\n-            #[inline]\n-            fn from(value: usize) -> Self {\n-                Self::from_usize(value)\n-            }\n-        }\n-\n-        impl From<u32> for $type {\n-            #[inline]\n-            fn from(value: u32) -> Self {\n-                Self::from_u32(value)\n-            }\n-        }\n-\n-        $crate::newtype_index!(\n-            @handle_debug\n-            @derives      [$($derives,)*]\n-            @type         [$type]\n-            @debug_format [$debug_format]);\n-    );\n-\n-    // base case for handle_debug where format is custom. No Debug implementation is emitted.\n-    (@handle_debug\n-     @derives      [$($_derives:ident,)*]\n-     @type         [$type:ident]\n-     @debug_format [custom]) => ();\n-\n-    // base case for handle_debug, no debug overrides found, so use default\n-    (@handle_debug\n-     @derives      []\n-     @type         [$type:ident]\n-     @debug_format [$debug_format:tt]) => (\n-        impl ::std::fmt::Debug for $type {\n-            fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {\n-                write!(fmt, $debug_format, self.as_u32())\n-            }\n-        }\n-    );\n-\n-    // Debug is requested for derive, don't generate any Debug implementation.\n-    (@handle_debug\n-     @derives      [Debug, $($derives:ident,)*]\n-     @type         [$type:ident]\n-     @debug_format [$debug_format:tt]) => ();\n-\n-    // It's not Debug, so just pop it off the front of the derives stack and check the rest.\n-    (@handle_debug\n-     @derives      [$_derive:ident, $($derives:ident,)*]\n-     @type         [$type:ident]\n-     @debug_format [$debug_format:tt]) => (\n-        $crate::newtype_index!(\n-            @handle_debug\n-            @derives      [$($derives,)*]\n-            @type         [$type]\n-            @debug_format [$debug_format]);\n-    );\n-\n-    // Append comma to end of derives list if it's missing\n-    (@attrs        [$(#[$attrs:meta])*]\n-     @type         [$type:ident]\n-     @max          [$max:expr]\n-     @vis          [$v:vis]\n-     @debug_format [$debug_format:tt]\n-                   derive [$($derives:ident),*]\n-                   $($tokens:tt)*) => (\n-        $crate::newtype_index!(\n-            @attrs        [$(#[$attrs])*]\n-            @type         [$type]\n-            @max          [$max]\n-            @vis          [$v]\n-            @debug_format [$debug_format]\n-                          derive [$($derives,)*]\n-                          $($tokens)*);\n-    );\n-\n-    // By not including the @derives marker in this list nor in the default args, we can force it\n-    // to come first if it exists. When encodable is custom, just use the derives list as-is.\n-    (@attrs        [$(#[$attrs:meta])*]\n-     @type         [$type:ident]\n-     @max          [$max:expr]\n-     @vis          [$v:vis]\n-     @debug_format [$debug_format:tt]\n-                   derive [$($derives:ident,)+]\n-                   ENCODABLE = custom\n-                   $($tokens:tt)*) => (\n-        $crate::newtype_index!(\n-            @attrs        [$(#[$attrs])*]\n-            @derives      [$($derives,)+]\n-            @type         [$type]\n-            @max          [$max]\n-            @vis          [$v]\n-            @debug_format [$debug_format]\n-                          $($tokens)*);\n-    );\n-\n-    // By not including the @derives marker in this list nor in the default args, we can force it\n-    // to come first if it exists. When encodable isn't custom, add serialization traits by default.\n-    (@attrs        [$(#[$attrs:meta])*]\n-     @type         [$type:ident]\n-     @max          [$max:expr]\n-     @vis          [$v:vis]\n-     @debug_format [$debug_format:tt]\n-                   derive [$($derives:ident,)+]\n-                   $($tokens:tt)*) => (\n-        $crate::newtype_index!(\n-            @derives      [$($derives,)+]\n-            @attrs        [$(#[$attrs])*]\n-            @type         [$type]\n-            @max          [$max]\n-            @vis          [$v]\n-            @debug_format [$debug_format]\n-                          $($tokens)*);\n-        $crate::newtype_index!(@serializable $type);\n-    );\n-\n-    // The case where no derives are added, but encodable is overridden. Don't\n-    // derive serialization traits\n-    (@attrs        [$(#[$attrs:meta])*]\n-     @type         [$type:ident]\n-     @max          [$max:expr]\n-     @vis          [$v:vis]\n-     @debug_format [$debug_format:tt]\n-                   ENCODABLE = custom\n-                   $($tokens:tt)*) => (\n-        $crate::newtype_index!(\n-            @derives      []\n-            @attrs        [$(#[$attrs])*]\n-            @type         [$type]\n-            @max          [$max]\n-            @vis          [$v]\n-            @debug_format [$debug_format]\n-                          $($tokens)*);\n-    );\n-\n-    // The case where no derives are added, add serialization derives by default\n-    (@attrs        [$(#[$attrs:meta])*]\n-     @type         [$type:ident]\n-     @max          [$max:expr]\n-     @vis          [$v:vis]\n-     @debug_format [$debug_format:tt]\n-                   $($tokens:tt)*) => (\n-        $crate::newtype_index!(\n-            @derives      []\n-            @attrs        [$(#[$attrs])*]\n-            @type         [$type]\n-            @max          [$max]\n-            @vis          [$v]\n-            @debug_format [$debug_format]\n-                          $($tokens)*);\n-        $crate::newtype_index!(@serializable $type);\n-    );\n-\n-    (@serializable $type:ident) => (\n-        impl<D: ::rustc_serialize::Decoder> ::rustc_serialize::Decodable<D> for $type {\n-            fn decode(d: &mut D) -> Self {\n-                Self::from_u32(d.read_u32())\n-            }\n-        }\n-        impl<E: ::rustc_serialize::Encoder> ::rustc_serialize::Encodable<E> for $type {\n-            fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n-                e.emit_u32(self.private)\n-            }\n-        }\n-    );\n-\n-    // Rewrite final without comma to one that includes comma\n-    (@derives      [$($derives:ident,)*]\n-     @attrs        [$(#[$attrs:meta])*]\n-     @type         [$type:ident]\n-     @max          [$max:expr]\n-     @vis          [$v:vis]\n-     @debug_format [$debug_format:tt]\n-                   $name:ident = $constant:expr) => (\n-        $crate::newtype_index!(\n-            @derives      [$($derives,)*]\n-            @attrs        [$(#[$attrs])*]\n-            @type         [$type]\n-            @max          [$max]\n-            @vis          [$v]\n-            @debug_format [$debug_format]\n-                          $name = $constant,);\n-    );\n-\n-    // Rewrite final const without comma to one that includes comma\n-    (@derives      [$($derives:ident,)*]\n-     @attrs        [$(#[$attrs:meta])*]\n-     @type         [$type:ident]\n-     @max          [$max:expr]\n-     @vis          [$v:vis]\n-     @debug_format [$debug_format:tt]\n-                   $(#[doc = $doc:expr])*\n-                   const $name:ident = $constant:expr) => (\n-        $crate::newtype_index!(\n-            @derives      [$($derives,)*]\n-            @attrs        [$(#[$attrs])*]\n-            @type         [$type]\n-            @max          [$max]\n-            @vis          [$v]\n-            @debug_format [$debug_format]\n-                          $(#[doc = $doc])* const $name = $constant,);\n-    );\n-\n-    // Replace existing default for max\n-    (@derives      [$($derives:ident,)*]\n-     @attrs        [$(#[$attrs:meta])*]\n-     @type         [$type:ident]\n-     @max          [$_max:expr]\n-     @vis          [$v:vis]\n-     @debug_format [$debug_format:tt]\n-                   MAX = $max:expr,\n-                   $($tokens:tt)*) => (\n-        $crate::newtype_index!(\n-            @derives      [$($derives,)*]\n-            @attrs        [$(#[$attrs])*]\n-            @type         [$type]\n-            @max          [$max]\n-            @vis          [$v]\n-            @debug_format [$debug_format]\n-                          $($tokens)*);\n-    );\n-\n-    // Replace existing default for debug_format\n-    (@derives      [$($derives:ident,)*]\n-     @attrs        [$(#[$attrs:meta])*]\n-     @type         [$type:ident]\n-     @max          [$max:expr]\n-     @vis          [$v:vis]\n-     @debug_format [$_debug_format:tt]\n-                   DEBUG_FORMAT = $debug_format:tt,\n-                   $($tokens:tt)*) => (\n-        $crate::newtype_index!(\n-            @derives      [$($derives,)*]\n-            @attrs        [$(#[$attrs])*]\n-            @type         [$type]\n-            @max          [$max]\n-            @vis          [$v]\n-            @debug_format [$debug_format]\n-                          $($tokens)*);\n-    );\n-\n-    // Assign a user-defined constant\n-    (@derives      [$($derives:ident,)*]\n-     @attrs        [$(#[$attrs:meta])*]\n-     @type         [$type:ident]\n-     @max          [$max:expr]\n-     @vis          [$v:vis]\n-     @debug_format [$debug_format:tt]\n-                   $(#[doc = $doc:expr])*\n-                   const $name:ident = $constant:expr,\n-                   $($tokens:tt)*) => (\n-        $(#[doc = $doc])*\n-        $v const $name: $type = $type::from_u32($constant);\n-        $crate::newtype_index!(\n-            @derives      [$($derives,)*]\n-            @attrs        [$(#[$attrs])*]\n-            @type         [$type]\n-            @max          [$max]\n-            @vis          [$v]\n-            @debug_format [$debug_format]\n-                          $($tokens)*);\n-    );\n-}\n-\n #[derive(Clone, PartialEq, Eq, Hash)]\n pub struct IndexVec<I: Idx, T> {\n     pub raw: Vec<T>,"}, {"sha": "915d2e8bcb3ff74b1e031aa3aa13ba239f8fa105", "filename": "compiler/rustc_index/src/vec/tests.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6a79936da30702b1c717769a2d12dffbad6d30a/compiler%2Frustc_index%2Fsrc%2Fvec%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6a79936da30702b1c717769a2d12dffbad6d30a/compiler%2Frustc_index%2Fsrc%2Fvec%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fvec%2Ftests.rs?ref=f6a79936da30702b1c717769a2d12dffbad6d30a", "patch": "@@ -1,5 +1,9 @@\n #![allow(dead_code)]\n-newtype_index!(struct MyIdx { MAX = 0xFFFF_FFFA });\n+\n+// Allows the macro invocation below to work\n+use crate as rustc_index;\n+\n+rustc_macros::newtype_index!(struct MyIdx { MAX = 0xFFFF_FFFA });\n \n #[test]\n fn index_size_is_optimized() {"}, {"sha": "03e139755ba292266bf0a73d9a531560f09e82d5", "filename": "compiler/rustc_macros/src/lib.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f6a79936da30702b1c717769a2d12dffbad6d30a/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6a79936da30702b1c717769a2d12dffbad6d30a/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Flib.rs?ref=f6a79936da30702b1c717769a2d12dffbad6d30a", "patch": "@@ -1,4 +1,5 @@\n #![feature(proc_macro_diagnostic)]\n+#![feature(allow_internal_unstable)]\n #![allow(rustc::default_hash_types)]\n #![recursion_limit = \"128\"]\n \n@@ -8,6 +9,7 @@ use proc_macro::TokenStream;\n \n mod hash_stable;\n mod lift;\n+mod newtype;\n mod query;\n mod serialize;\n mod session_diagnostic;\n@@ -24,6 +26,27 @@ pub fn symbols(input: TokenStream) -> TokenStream {\n     symbols::symbols(input.into()).into()\n }\n \n+/// Creates a struct type `S` that can be used as an index with\n+/// `IndexVec` and so on.\n+///\n+/// There are two ways of interacting with these indices:\n+///\n+/// - The `From` impls are the preferred way. So you can do\n+///   `S::from(v)` with a `usize` or `u32`. And you can convert back\n+///   to an integer with `u32::from(s)`.\n+///\n+/// - Alternatively, you can use the methods `S::new(v)` and `s.index()`\n+///   to create/return a value.\n+///\n+/// Internally, the index uses a u32, so the index must not exceed\n+/// `u32::MAX`. You can also customize things like the `Debug` impl,\n+/// what traits are derived, and so forth via the macro.\n+#[proc_macro]\n+#[allow_internal_unstable(step_trait, rustc_attrs, trusted_step)]\n+pub fn newtype_index(input: TokenStream) -> TokenStream {\n+    newtype::newtype(input).into()\n+}\n+\n decl_derive!([HashStable, attributes(stable_hasher)] => hash_stable::hash_stable_derive);\n decl_derive!(\n     [HashStable_Generic, attributes(stable_hasher)] =>"}, {"sha": "f284e5cdd5c1e1be7e773f4adbd288e5a3c5428b", "filename": "compiler/rustc_macros/src/newtype.rs", "status": "added", "additions": 310, "deletions": 0, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/f6a79936da30702b1c717769a2d12dffbad6d30a/compiler%2Frustc_macros%2Fsrc%2Fnewtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6a79936da30702b1c717769a2d12dffbad6d30a/compiler%2Frustc_macros%2Fsrc%2Fnewtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fnewtype.rs?ref=f6a79936da30702b1c717769a2d12dffbad6d30a", "patch": "@@ -0,0 +1,310 @@\n+use proc_macro2::{Span, TokenStream};\n+use quote::quote;\n+use syn::parse::*;\n+use syn::punctuated::Punctuated;\n+use syn::*;\n+\n+mod kw {\n+    syn::custom_keyword!(derive);\n+    syn::custom_keyword!(DEBUG_FORMAT);\n+    syn::custom_keyword!(MAX);\n+    syn::custom_keyword!(ENCODABLE);\n+    syn::custom_keyword!(custom);\n+}\n+\n+#[derive(Debug)]\n+enum DebugFormat {\n+    // The user will provide a custom `Debug` impl, so we shouldn't generate\n+    // one\n+    Custom,\n+    // Use the specified format string in the generated `Debug` impl\n+    // By default, this is \"{}\"\n+    Format(String),\n+}\n+\n+// We parse the input and emit the output in a single step.\n+// This field stores the final macro output\n+struct Newtype(TokenStream);\n+\n+impl Parse for Newtype {\n+    fn parse(input: ParseStream<'_>) -> Result<Self> {\n+        let attrs = input.call(Attribute::parse_outer)?;\n+        let vis: Visibility = input.parse()?;\n+        input.parse::<Token![struct]>()?;\n+        let name: Ident = input.parse()?;\n+\n+        let body;\n+        braced!(body in input);\n+\n+        // Any additional `#[derive]` macro paths to apply\n+        let mut derive_paths: Vec<Path> = Vec::new();\n+        let mut debug_format: Option<DebugFormat> = None;\n+        let mut max = None;\n+        let mut consts = Vec::new();\n+        let mut encodable = true;\n+\n+        // Parse an optional trailing comma\n+        let try_comma = || -> Result<()> {\n+            if body.lookahead1().peek(Token![,]) {\n+                body.parse::<Token![,]>()?;\n+            }\n+            Ok(())\n+        };\n+\n+        if body.lookahead1().peek(Token![..]) {\n+            body.parse::<Token![..]>()?;\n+        } else {\n+            loop {\n+                if body.lookahead1().peek(kw::derive) {\n+                    body.parse::<kw::derive>()?;\n+                    let derives;\n+                    bracketed!(derives in body);\n+                    let derives: Punctuated<Path, Token![,]> =\n+                        derives.parse_terminated(Path::parse)?;\n+                    try_comma()?;\n+                    derive_paths.extend(derives);\n+                    continue;\n+                }\n+                if body.lookahead1().peek(kw::DEBUG_FORMAT) {\n+                    body.parse::<kw::DEBUG_FORMAT>()?;\n+                    body.parse::<Token![=]>()?;\n+                    let new_debug_format = if body.lookahead1().peek(kw::custom) {\n+                        body.parse::<kw::custom>()?;\n+                        DebugFormat::Custom\n+                    } else {\n+                        let format_str: LitStr = body.parse()?;\n+                        DebugFormat::Format(format_str.value())\n+                    };\n+                    try_comma()?;\n+                    if let Some(old) = debug_format.replace(new_debug_format) {\n+                        panic!(\"Specified multiple debug format options: {:?}\", old);\n+                    }\n+                    continue;\n+                }\n+                if body.lookahead1().peek(kw::MAX) {\n+                    body.parse::<kw::MAX>()?;\n+                    body.parse::<Token![=]>()?;\n+                    let val: Lit = body.parse()?;\n+                    try_comma()?;\n+                    if let Some(old) = max.replace(val) {\n+                        panic!(\"Specified multiple MAX: {:?}\", old);\n+                    }\n+                    continue;\n+                }\n+                if body.lookahead1().peek(kw::ENCODABLE) {\n+                    body.parse::<kw::ENCODABLE>()?;\n+                    body.parse::<Token![=]>()?;\n+                    body.parse::<kw::custom>()?;\n+                    try_comma()?;\n+                    encodable = false;\n+                    continue;\n+                }\n+\n+                // We've parsed everything that the user provided, so we're done\n+                if body.is_empty() {\n+                    break;\n+                }\n+\n+                // Otherwise, we are parsng a user-defined constant\n+                let const_attrs = body.call(Attribute::parse_outer)?;\n+                body.parse::<Token![const]>()?;\n+                let const_name: Ident = body.parse()?;\n+                body.parse::<Token![=]>()?;\n+                let const_val: Expr = body.parse()?;\n+                try_comma()?;\n+                consts.push(quote! { #(#const_attrs)* #vis const #const_name: #name = #name::from_u32(#const_val); });\n+            }\n+        }\n+\n+        let debug_format = debug_format.unwrap_or(DebugFormat::Format(\"{}\".to_string()));\n+        // shave off 256 indices at the end to allow space for packing these indices into enums\n+        let max = max.unwrap_or_else(|| Lit::Int(LitInt::new(\"0xFFFF_FF00\", Span::call_site())));\n+\n+        let encodable_impls = if encodable {\n+            quote! {\n+                impl<D: ::rustc_serialize::Decoder> ::rustc_serialize::Decodable<D> for #name {\n+                    fn decode(d: &mut D) -> Self {\n+                        Self::from_u32(d.read_u32())\n+                    }\n+                }\n+                impl<E: ::rustc_serialize::Encoder> ::rustc_serialize::Encodable<E> for #name {\n+                    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n+                        e.emit_u32(self.private)\n+                    }\n+                }\n+            }\n+        } else {\n+            quote! {}\n+        };\n+\n+        let debug_impl = match debug_format {\n+            DebugFormat::Custom => quote! {},\n+            DebugFormat::Format(format) => {\n+                quote! {\n+                    impl ::std::fmt::Debug for #name {\n+                        fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {\n+                            write!(fmt, #format, self.as_u32())\n+                        }\n+                    }\n+                }\n+            }\n+        };\n+\n+        Ok(Self(quote! {\n+            #(#attrs)*\n+            #[derive(Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord, #(#derive_paths),*)]\n+            #[rustc_layout_scalar_valid_range_end(#max)]\n+            #vis struct #name {\n+                private: u32,\n+            }\n+\n+            #(#consts)*\n+\n+            impl #name {\n+                /// Maximum value the index can take, as a `u32`.\n+                #vis const MAX_AS_U32: u32  = #max;\n+\n+                /// Maximum value the index can take.\n+                #vis const MAX: Self = Self::from_u32(#max);\n+\n+                /// Creates a new index from a given `usize`.\n+                ///\n+                /// # Panics\n+                ///\n+                /// Will panic if `value` exceeds `MAX`.\n+                #[inline]\n+                #vis const fn from_usize(value: usize) -> Self {\n+                    assert!(value <= (#max as usize));\n+                    // SAFETY: We just checked that `value <= max`.\n+                    unsafe {\n+                        Self::from_u32_unchecked(value as u32)\n+                    }\n+                }\n+\n+                /// Creates a new index from a given `u32`.\n+                ///\n+                /// # Panics\n+                ///\n+                /// Will panic if `value` exceeds `MAX`.\n+                #[inline]\n+                #vis const fn from_u32(value: u32) -> Self {\n+                    assert!(value <= #max);\n+                    // SAFETY: We just checked that `value <= max`.\n+                    unsafe {\n+                        Self::from_u32_unchecked(value)\n+                    }\n+                }\n+\n+                /// Creates a new index from a given `u32`.\n+                ///\n+                /// # Safety\n+                ///\n+                /// The provided value must be less than or equal to the maximum value for the newtype.\n+                /// Providing a value outside this range is undefined due to layout restrictions.\n+                ///\n+                /// Prefer using `from_u32`.\n+                #[inline]\n+                #vis const unsafe fn from_u32_unchecked(value: u32) -> Self {\n+                    Self { private: value }\n+                }\n+\n+                /// Extracts the value of this index as a `usize`.\n+                #[inline]\n+                #vis const fn index(self) -> usize {\n+                    self.as_usize()\n+                }\n+\n+                /// Extracts the value of this index as a `u32`.\n+                #[inline]\n+                #vis const fn as_u32(self) -> u32 {\n+                    self.private\n+                }\n+\n+                /// Extracts the value of this index as a `usize`.\n+                #[inline]\n+                #vis const fn as_usize(self) -> usize {\n+                    self.as_u32() as usize\n+                }\n+            }\n+\n+            impl std::ops::Add<usize> for #name {\n+                type Output = Self;\n+\n+                fn add(self, other: usize) -> Self {\n+                    Self::from_usize(self.index() + other)\n+                }\n+            }\n+\n+            impl rustc_index::vec::Idx for #name {\n+                #[inline]\n+                fn new(value: usize) -> Self {\n+                    Self::from_usize(value)\n+                }\n+\n+                #[inline]\n+                fn index(self) -> usize {\n+                    self.as_usize()\n+                }\n+            }\n+\n+            impl ::std::iter::Step for #name {\n+                #[inline]\n+                fn steps_between(start: &Self, end: &Self) -> Option<usize> {\n+                    <usize as ::std::iter::Step>::steps_between(\n+                        &Self::index(*start),\n+                        &Self::index(*end),\n+                    )\n+                }\n+\n+                #[inline]\n+                fn forward_checked(start: Self, u: usize) -> Option<Self> {\n+                    Self::index(start).checked_add(u).map(Self::from_usize)\n+                }\n+\n+                #[inline]\n+                fn backward_checked(start: Self, u: usize) -> Option<Self> {\n+                    Self::index(start).checked_sub(u).map(Self::from_usize)\n+                }\n+            }\n+\n+            // Safety: The implementation of `Step` upholds all invariants.\n+            unsafe impl ::std::iter::TrustedStep for #name {}\n+\n+            impl From<#name> for u32 {\n+                #[inline]\n+                fn from(v: #name) -> u32 {\n+                    v.as_u32()\n+                }\n+            }\n+\n+            impl From<#name> for usize {\n+                #[inline]\n+                fn from(v: #name) -> usize {\n+                    v.as_usize()\n+                }\n+            }\n+\n+            impl From<usize> for #name {\n+                #[inline]\n+                fn from(value: usize) -> Self {\n+                    Self::from_usize(value)\n+                }\n+            }\n+\n+            impl From<u32> for #name {\n+                #[inline]\n+                fn from(value: u32) -> Self {\n+                    Self::from_u32(value)\n+                }\n+            }\n+\n+            #encodable_impls\n+            #debug_impl\n+        }))\n+    }\n+}\n+\n+pub fn newtype(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n+    let input = parse_macro_input!(input as Newtype);\n+    input.0.into()\n+}"}, {"sha": "9a36230516c17acff3562c2e3ac60f9086ee5d36", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6a79936da30702b1c717769a2d12dffbad6d30a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6a79936da30702b1c717769a2d12dffbad6d30a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=f6a79936da30702b1c717769a2d12dffbad6d30a", "patch": "@@ -1847,6 +1847,7 @@ rustc_index::newtype_index! {\n     /// rustc can identify that a field projection refers to either two different regions of memory\n     /// or the same one between the base and the 'projection element'.\n     /// Read more about projections in the [rustc-dev-guide][mir-datatypes]\n+    ///\n     /// [wrapper]: https://rustc-dev-guide.rust-lang.org/appendix/glossary.html#newtype\n     /// [CFG]: https://rustc-dev-guide.rust-lang.org/appendix/background.html#cfg\n     /// [mir-datatypes]: https://rustc-dev-guide.rust-lang.org/mir/index.html#mir-data-types"}, {"sha": "55f7e70db8fd30f8a2dca6382950cfb88c3225a2", "filename": "compiler/rustc_mir_transform/src/coverage/graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6a79936da30702b1c717769a2d12dffbad6d30a/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6a79936da30702b1c717769a2d12dffbad6d30a/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs?ref=f6a79936da30702b1c717769a2d12dffbad6d30a", "patch": "@@ -281,7 +281,7 @@ impl graph::WithPredecessors for CoverageGraph {\n }\n \n rustc_index::newtype_index! {\n-    /// A node in the [control-flow graph][CFG] of CoverageGraph.\n+    /// A node in the control-flow graph of CoverageGraph.\n     pub(super) struct BasicCoverageBlock {\n         DEBUG_FORMAT = \"bcb{}\",\n         const START_BCB = 0,"}]}