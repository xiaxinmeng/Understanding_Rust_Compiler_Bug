{"sha": "78c3a49044d2f93a008f5e8040a27445c8d2f58c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4YzNhNDkwNDRkMmY5M2EwMDhmNWU4MDQwYTI3NDQ1YzhkMmY1OGM=", "commit": {"author": {"name": "Vadim Chugunov", "email": "vadimcn@gmail.com", "date": "2017-03-24T01:03:39Z"}, "committer": {"name": "Vadim Chugunov", "email": "vadimcn@gmail.com", "date": "2017-03-30T23:31:45Z"}, "message": "Emit linker hints for all library kinds.", "tree": {"sha": "211ee5ebb3ca2541a0847a0fdfb80c39bc2d7ec5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/211ee5ebb3ca2541a0847a0fdfb80c39bc2d7ec5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78c3a49044d2f93a008f5e8040a27445c8d2f58c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78c3a49044d2f93a008f5e8040a27445c8d2f58c", "html_url": "https://github.com/rust-lang/rust/commit/78c3a49044d2f93a008f5e8040a27445c8d2f58c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78c3a49044d2f93a008f5e8040a27445c8d2f58c/comments", "author": {"login": "vadimcn", "id": 3203809, "node_id": "MDQ6VXNlcjMyMDM4MDk=", "avatar_url": "https://avatars.githubusercontent.com/u/3203809?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vadimcn", "html_url": "https://github.com/vadimcn", "followers_url": "https://api.github.com/users/vadimcn/followers", "following_url": "https://api.github.com/users/vadimcn/following{/other_user}", "gists_url": "https://api.github.com/users/vadimcn/gists{/gist_id}", "starred_url": "https://api.github.com/users/vadimcn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vadimcn/subscriptions", "organizations_url": "https://api.github.com/users/vadimcn/orgs", "repos_url": "https://api.github.com/users/vadimcn/repos", "events_url": "https://api.github.com/users/vadimcn/events{/privacy}", "received_events_url": "https://api.github.com/users/vadimcn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vadimcn", "id": 3203809, "node_id": "MDQ6VXNlcjMyMDM4MDk=", "avatar_url": "https://avatars.githubusercontent.com/u/3203809?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vadimcn", "html_url": "https://github.com/vadimcn", "followers_url": "https://api.github.com/users/vadimcn/followers", "following_url": "https://api.github.com/users/vadimcn/following{/other_user}", "gists_url": "https://api.github.com/users/vadimcn/gists{/gist_id}", "starred_url": "https://api.github.com/users/vadimcn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vadimcn/subscriptions", "organizations_url": "https://api.github.com/users/vadimcn/orgs", "repos_url": "https://api.github.com/users/vadimcn/repos", "events_url": "https://api.github.com/users/vadimcn/events{/privacy}", "received_events_url": "https://api.github.com/users/vadimcn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c94997b6b1cca3e65ecfc5ba40c033d6838019b", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c94997b6b1cca3e65ecfc5ba40c033d6838019b", "html_url": "https://github.com/rust-lang/rust/commit/5c94997b6b1cca3e65ecfc5ba40c033d6838019b"}], "stats": {"total": 158, "additions": 68, "deletions": 90}, "files": [{"sha": "12a1ffa2767255aa325b6f3eff380d6fad49ca44", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 6, "deletions": 25, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/78c3a49044d2f93a008f5e8040a27445c8d2f58c/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78c3a49044d2f93a008f5e8040a27445c8d2f58c/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=78c3a49044d2f93a008f5e8040a27445c8d2f58c", "patch": "@@ -734,9 +734,10 @@ fn link_natively(sess: &Session,\n     }\n \n     {\n-        let mut linker = trans.linker_info.to_linker(&mut cmd, &sess);\n+        let mut linker = trans.linker_info.to_linker(cmd, &sess);\n         link_args(&mut *linker, sess, crate_type, tmpdir,\n                   objects, out_filename, outputs, trans);\n+        cmd = linker.finalize();\n     }\n     cmd.args(&sess.target.target.options.late_link_args);\n     for obj in &sess.target.target.options.post_link_objects {\n@@ -1021,38 +1022,18 @@ fn add_local_native_libraries(cmd: &mut Linker, sess: &Session) {\n         }\n     });\n \n-    let pair = sess.cstore.used_libraries().into_iter().filter(|l| {\n+    let relevant_libs = sess.cstore.used_libraries().into_iter().filter(|l| {\n         relevant_lib(sess, l)\n-    }).partition(|lib| {\n-        lib.kind == NativeLibraryKind::NativeStatic\n     });\n-    let (staticlibs, others): (Vec<_>, Vec<_>) = pair;\n-\n-    // Some platforms take hints about whether a library is static or dynamic.\n-    // For those that support this, we ensure we pass the option if the library\n-    // was flagged \"static\" (most defaults are dynamic) to ensure that if\n-    // libfoo.a and libfoo.so both exist that the right one is chosen.\n-    cmd.hint_static();\n \n     let search_path = archive_search_paths(sess);\n-    for l in staticlibs {\n-        // Here we explicitly ask that the entire archive is included into the\n-        // result artifact. For more details see #15460, but the gist is that\n-        // the linker will strip away any unused objects in the archive if we\n-        // don't otherwise explicitly reference them. This can occur for\n-        // libraries which are just providing bindings, libraries with generic\n-        // functions, etc.\n-        cmd.link_whole_staticlib(&l.name.as_str(), &search_path);\n-    }\n-\n-    cmd.hint_dynamic();\n-\n-    for lib in others {\n+    for lib in relevant_libs {\n         match lib.kind {\n             NativeLibraryKind::NativeUnknown => cmd.link_dylib(&lib.name.as_str()),\n             NativeLibraryKind::NativeFramework => cmd.link_framework(&lib.name.as_str()),\n             NativeLibraryKind::NativeStaticNobundle => cmd.link_staticlib(&lib.name.as_str()),\n-            NativeLibraryKind::NativeStatic => bug!(),\n+            NativeLibraryKind::NativeStatic => cmd.link_whole_staticlib(&lib.name.as_str(),\n+                                                                        &search_path)\n         }\n     }\n }"}, {"sha": "a178d17a7c2d371f01e17ce87fc7cd22a41efab7", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 62, "deletions": 65, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/78c3a49044d2f93a008f5e8040a27445c8d2f58c/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78c3a49044d2f93a008f5e8040a27445c8d2f58c/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=78c3a49044d2f93a008f5e8040a27445c8d2f58c", "patch": "@@ -43,7 +43,7 @@ impl<'a, 'tcx> LinkerInfo {\n     }\n \n     pub fn to_linker(&'a self,\n-                     cmd: &'a mut Command,\n+                     cmd: Command,\n                      sess: &'a Session) -> Box<Linker+'a> {\n         if sess.target.target.options.is_like_msvc {\n             Box::new(MsvcLinker {\n@@ -61,7 +61,8 @@ impl<'a, 'tcx> LinkerInfo {\n             Box::new(GnuLinker {\n                 cmd: cmd,\n                 sess: sess,\n-                info: self\n+                info: self,\n+                hinted_static: false,\n             }) as Box<Linker>\n         }\n     }\n@@ -93,30 +94,49 @@ pub trait Linker {\n     fn no_default_libraries(&mut self);\n     fn build_dylib(&mut self, out_filename: &Path);\n     fn args(&mut self, args: &[String]);\n-    fn hint_static(&mut self);\n-    fn hint_dynamic(&mut self);\n-    fn whole_archives(&mut self);\n-    fn no_whole_archives(&mut self);\n     fn export_symbols(&mut self, tmpdir: &Path, crate_type: CrateType);\n     fn subsystem(&mut self, subsystem: &str);\n+    // Should have been finalize(self), but we don't support self-by-value on trait objects (yet?).\n+    fn finalize(&mut self) -> Command;\n }\n \n pub struct GnuLinker<'a> {\n-    cmd: &'a mut Command,\n+    cmd: Command,\n     sess: &'a Session,\n-    info: &'a LinkerInfo\n+    info: &'a LinkerInfo,\n+    hinted_static: bool, // Keeps track of the current hinting mode.\n }\n \n impl<'a> GnuLinker<'a> {\n     fn takes_hints(&self) -> bool {\n         !self.sess.target.target.options.is_like_osx\n     }\n+\n+    // Some platforms take hints about whether a library is static or dynamic.\n+    // For those that support this, we ensure we pass the option if the library\n+    // was flagged \"static\" (most defaults are dynamic) to ensure that if\n+    // libfoo.a and libfoo.so both exist that the right one is chosen.\n+    fn hint_static(&mut self) {\n+        if !self.takes_hints() { return }\n+        if !self.hinted_static {\n+            self.cmd.arg(\"-Wl,-Bstatic\");\n+            self.hinted_static = true;\n+        }\n+    }\n+\n+    fn hint_dynamic(&mut self) {\n+        if !self.takes_hints() { return }\n+        if self.hinted_static {\n+            self.cmd.arg(\"-Wl,-Bdynamic\");\n+            self.hinted_static = false;\n+        }\n+    }\n }\n \n impl<'a> Linker for GnuLinker<'a> {\n-    fn link_dylib(&mut self, lib: &str) { self.cmd.arg(\"-l\").arg(lib); }\n-    fn link_staticlib(&mut self, lib: &str) { self.cmd.arg(\"-l\").arg(lib); }\n-    fn link_rlib(&mut self, lib: &Path) { self.cmd.arg(lib); }\n+    fn link_dylib(&mut self, lib: &str) { self.hint_dynamic(); self.cmd.arg(\"-l\").arg(lib); }\n+    fn link_staticlib(&mut self, lib: &str) { self.hint_static(); self.cmd.arg(\"-l\").arg(lib); }\n+    fn link_rlib(&mut self, lib: &Path) { self.hint_static(); self.cmd.arg(lib); }\n     fn include_path(&mut self, path: &Path) { self.cmd.arg(\"-L\").arg(path); }\n     fn framework_path(&mut self, path: &Path) { self.cmd.arg(\"-F\").arg(path); }\n     fn output_filename(&mut self, path: &Path) { self.cmd.arg(\"-o\").arg(path); }\n@@ -125,14 +145,23 @@ impl<'a> Linker for GnuLinker<'a> {\n     fn args(&mut self, args: &[String]) { self.cmd.args(args); }\n \n     fn link_rust_dylib(&mut self, lib: &str, _path: &Path) {\n+        self.hint_dynamic();\n         self.cmd.arg(\"-l\").arg(lib);\n     }\n \n     fn link_framework(&mut self, framework: &str) {\n+        self.hint_dynamic();\n         self.cmd.arg(\"-framework\").arg(framework);\n     }\n \n+    // Here we explicitly ask that the entire archive is included into the\n+    // result artifact. For more details see #15460, but the gist is that\n+    // the linker will strip away any unused objects in the archive if we\n+    // don't otherwise explicitly reference them. This can occur for\n+    // libraries which are just providing bindings, libraries with generic\n+    // functions, etc.\n     fn link_whole_staticlib(&mut self, lib: &str, search_path: &[PathBuf]) {\n+        self.hint_static();\n         let target = &self.sess.target.target;\n         if !target.options.is_like_osx {\n             self.cmd.arg(\"-Wl,--whole-archive\")\n@@ -148,6 +177,7 @@ impl<'a> Linker for GnuLinker<'a> {\n     }\n \n     fn link_whole_rlib(&mut self, lib: &Path) {\n+        self.hint_static();\n         if self.sess.target.target.options.is_like_osx {\n             let mut v = OsString::from(\"-Wl,-force_load,\");\n             v.push(lib);\n@@ -228,26 +258,6 @@ impl<'a> Linker for GnuLinker<'a> {\n         }\n     }\n \n-    fn whole_archives(&mut self) {\n-        if !self.takes_hints() { return }\n-        self.cmd.arg(\"-Wl,--whole-archive\");\n-    }\n-\n-    fn no_whole_archives(&mut self) {\n-        if !self.takes_hints() { return }\n-        self.cmd.arg(\"-Wl,--no-whole-archive\");\n-    }\n-\n-    fn hint_static(&mut self) {\n-        if !self.takes_hints() { return }\n-        self.cmd.arg(\"-Wl,-Bstatic\");\n-    }\n-\n-    fn hint_dynamic(&mut self) {\n-        if !self.takes_hints() { return }\n-        self.cmd.arg(\"-Wl,-Bdynamic\");\n-    }\n-\n     fn export_symbols(&mut self, tmpdir: &Path, crate_type: CrateType) {\n         // If we're compiling a dylib, then we let symbol visibility in object\n         // files to take care of whether they're exported or not.\n@@ -311,10 +321,17 @@ impl<'a> Linker for GnuLinker<'a> {\n     fn subsystem(&mut self, subsystem: &str) {\n         self.cmd.arg(&format!(\"-Wl,--subsystem,{}\", subsystem));\n     }\n+\n+    fn finalize(&mut self) -> Command {\n+        self.hint_dynamic(); // Reset to default before returning the composed command line.\n+        let mut cmd = Command::new(\"\");\n+        ::std::mem::swap(&mut cmd, &mut self.cmd);\n+        cmd\n+    }\n }\n \n pub struct MsvcLinker<'a> {\n-    cmd: &'a mut Command,\n+    cmd: Command,\n     sess: &'a Session,\n     info: &'a LinkerInfo\n }\n@@ -416,22 +433,6 @@ impl<'a> Linker for MsvcLinker<'a> {\n         self.cmd.arg(\"/DEBUG\");\n     }\n \n-    fn whole_archives(&mut self) {\n-        // hints not supported?\n-    }\n-    fn no_whole_archives(&mut self) {\n-        // hints not supported?\n-    }\n-\n-    // On windows static libraries are of the form `foo.lib` and dynamic\n-    // libraries are not linked against directly, but rather through their\n-    // import libraries also called `foo.lib`. As a result there's no\n-    // possibility for a native library to appear both dynamically and\n-    // statically in the same folder so we don't have to worry about hints like\n-    // we do on Unix platforms.\n-    fn hint_static(&mut self) {}\n-    fn hint_dynamic(&mut self) {}\n-\n     // Currently the compiler doesn't use `dllexport` (an LLVM attribute) to\n     // export symbols from a dynamic library. When building a dynamic library,\n     // however, we're going to want some symbols exported, so this function\n@@ -492,10 +493,16 @@ impl<'a> Linker for MsvcLinker<'a> {\n             self.cmd.arg(\"/ENTRY:mainCRTStartup\");\n         }\n     }\n+\n+    fn finalize(&mut self) -> Command {\n+        let mut cmd = Command::new(\"\");\n+        ::std::mem::swap(&mut cmd, &mut self.cmd);\n+        cmd\n+    }\n }\n \n pub struct EmLinker<'a> {\n-    cmd: &'a mut Command,\n+    cmd: Command,\n     sess: &'a Session,\n     info: &'a LinkerInfo\n }\n@@ -591,22 +598,6 @@ impl<'a> Linker for EmLinker<'a> {\n         bug!(\"building dynamic library is unsupported on Emscripten\")\n     }\n \n-    fn whole_archives(&mut self) {\n-        // noop\n-    }\n-\n-    fn no_whole_archives(&mut self) {\n-        // noop\n-    }\n-\n-    fn hint_static(&mut self) {\n-        // noop\n-    }\n-\n-    fn hint_dynamic(&mut self) {\n-        // noop\n-    }\n-\n     fn export_symbols(&mut self, _tmpdir: &Path, crate_type: CrateType) {\n         let symbols = &self.info.exports[&crate_type];\n \n@@ -640,6 +631,12 @@ impl<'a> Linker for EmLinker<'a> {\n     fn subsystem(&mut self, _subsystem: &str) {\n         // noop\n     }\n+\n+    fn finalize(&mut self) -> Command {\n+        let mut cmd = Command::new(\"\");\n+        ::std::mem::swap(&mut cmd, &mut self.cmd);\n+        cmd\n+    }\n }\n \n fn exported_symbols(scx: &SharedCrateContext,"}]}