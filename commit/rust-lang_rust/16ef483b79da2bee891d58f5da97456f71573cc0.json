{"sha": "16ef483b79da2bee891d58f5da97456f71573cc0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2ZWY0ODNiNzlkYTJiZWU4OTFkNThmNWRhOTc0NTZmNzE1NzNjYzA=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-05-28T16:15:39Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-05-28T16:15:39Z"}, "message": "Rollup merge of #61164 - RalfJung:scalar, r=oli-obk\n\nrename Scalar::Bits to Scalar::Raw and bits field to data\n\nAlso use this opportunity to seal some abstraction leaks (other modules constructing `Scalar::Bits` directly instead of using a constructor).\n\nr? @oli-obk", "tree": {"sha": "31d2399f817e9906721c8bbed0a03cf40af2b65f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31d2399f817e9906721c8bbed0a03cf40af2b65f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16ef483b79da2bee891d58f5da97456f71573cc0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJc7V6sCRBK7hj4Ov3rIwAAdHIIAALKvWEJJ65UiWARNfALJEyt\nHvyHCBgWjb6vZBRH3iZ8Iyj1rLGvlH9bOQ2KUZTH9DEnNOiOclGuph7zuisXwKtJ\nvLdkrjyuxRFq0tQlIwRJcTmoXnVYQ/syxknMuDvjbmU1maLovHzIwVMHLYJDIHOm\nvEQFAxgUg3XI7sa5InXcTMClU03MwshE4ppwFkHNiCsObU5sijRgqRvkCmazLE8K\nH871qmDES2+MvrtMmZ/3eOiYzaxljfxGYxGZkwzMimbP1iGGDp7cpEcoXcELgM7i\n/iDcVXh4lZyEKaWyKeYFZL7b9FnmX/8h/63vZXpqeRoAF//EJXKBGEGdOicgB0Y=\n=UdkM\n-----END PGP SIGNATURE-----\n", "payload": "tree 31d2399f817e9906721c8bbed0a03cf40af2b65f\nparent f91a3abade0764714af1ad7cb49e8b1d298cd0b3\nparent fe19ed8737fb0270b88adab77787940cc37ac6c9\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1559060139 +0200\ncommitter GitHub <noreply@github.com> 1559060139 +0200\n\nRollup merge of #61164 - RalfJung:scalar, r=oli-obk\n\nrename Scalar::Bits to Scalar::Raw and bits field to data\n\nAlso use this opportunity to seal some abstraction leaks (other modules constructing `Scalar::Bits` directly instead of using a constructor).\n\nr? @oli-obk\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16ef483b79da2bee891d58f5da97456f71573cc0", "html_url": "https://github.com/rust-lang/rust/commit/16ef483b79da2bee891d58f5da97456f71573cc0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16ef483b79da2bee891d58f5da97456f71573cc0/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f91a3abade0764714af1ad7cb49e8b1d298cd0b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/f91a3abade0764714af1ad7cb49e8b1d298cd0b3", "html_url": "https://github.com/rust-lang/rust/commit/f91a3abade0764714af1ad7cb49e8b1d298cd0b3"}, {"sha": "fe19ed8737fb0270b88adab77787940cc37ac6c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe19ed8737fb0270b88adab77787940cc37ac6c9", "html_url": "https://github.com/rust-lang/rust/commit/fe19ed8737fb0270b88adab77787940cc37ac6c9"}], "stats": {"total": 376, "additions": 181, "deletions": 195}, "files": [{"sha": "9549a5af5af5c7c64c62e0ab45852abf24e28e29", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/16ef483b79da2bee891d58f5da97456f71573cc0/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16ef483b79da2bee891d58f5da97456f71573cc0/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=16ef483b79da2bee891d58f5da97456f71573cc0", "patch": "@@ -2,7 +2,6 @@\n \n use super::{\n     Pointer, EvalResult, AllocId, ScalarMaybeUndef, write_target_uint, read_target_uint, Scalar,\n-    truncate,\n };\n \n use crate::ty::layout::{Size, Align};\n@@ -407,18 +406,9 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n             ScalarMaybeUndef::Undef => return self.mark_definedness(ptr, type_size, false),\n         };\n \n-        let bytes = match val {\n-            Scalar::Ptr(val) => {\n-                assert_eq!(type_size, cx.data_layout().pointer_size);\n-                val.offset.bytes() as u128\n-            }\n-\n-            Scalar::Bits { bits, size } => {\n-                assert_eq!(size as u64, type_size.bytes());\n-                debug_assert_eq!(truncate(bits, Size::from_bytes(size.into())), bits,\n-                    \"Unexpected value of size {} when writing to memory\", size);\n-                bits\n-            },\n+        let bytes = match val.to_bits_or_ptr(type_size, cx) {\n+            Err(val) => val.offset.bytes() as u128,\n+            Ok(data) => data,\n         };\n \n         let endian = cx.data_layout().endian;"}, {"sha": "07d22cf991c6bab23b857be57b942b55b0d4fd62", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/16ef483b79da2bee891d58f5da97456f71573cc0/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16ef483b79da2bee891d58f5da97456f71573cc0/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=16ef483b79da2bee891d58f5da97456f71573cc0", "patch": "@@ -349,6 +349,7 @@ impl<'tcx> AllocMap<'tcx> {\n     /// illegal and will likely ICE.\n     /// This function exists to allow const eval to detect the difference between evaluation-\n     /// local dangling pointers and allocations in constants/statics.\n+    #[inline]\n     pub fn get(&self, id: AllocId) -> Option<AllocKind<'tcx>> {\n         self.id_to_kind.get(&id).cloned()\n     }\n@@ -397,6 +398,7 @@ impl<'tcx> AllocMap<'tcx> {\n // Methods to access integers in the target endianness\n ////////////////////////////////////////////////////////////////////////////////\n \n+#[inline]\n pub fn write_target_uint(\n     endianness: layout::Endian,\n     mut target: &mut [u8],\n@@ -409,6 +411,7 @@ pub fn write_target_uint(\n     }\n }\n \n+#[inline]\n pub fn read_target_uint(endianness: layout::Endian, mut source: &[u8]) -> Result<u128, io::Error> {\n     match endianness {\n         layout::Endian::Little => source.read_uint128::<LittleEndian>(source.len()),\n@@ -420,17 +423,30 @@ pub fn read_target_uint(endianness: layout::Endian, mut source: &[u8]) -> Result\n // Methods to facilitate working with signed integers stored in a u128\n ////////////////////////////////////////////////////////////////////////////////\n \n+/// Truncate `value` to `size` bits and then sign-extend it to 128 bits\n+/// (i.e., if it is negative, fill with 1's on the left).\n+#[inline]\n pub fn sign_extend(value: u128, size: Size) -> u128 {\n     let size = size.bits();\n+    if size == 0 {\n+        // Truncated until nothing is left.\n+        return 0;\n+    }\n     // sign extend\n     let shift = 128 - size;\n     // shift the unsigned value to the left\n     // and back to the right as signed (essentially fills with FF on the left)\n     (((value << shift) as i128) >> shift) as u128\n }\n \n+/// Truncate `value` to `size` bits.\n+#[inline]\n pub fn truncate(value: u128, size: Size) -> u128 {\n     let size = size.bits();\n+    if size == 0 {\n+        // Truncated until nothing is left.\n+        return 0;\n+    }\n     let shift = 128 - size;\n     // truncate (shift left to drop out leftover values, shift right to fill with zeroes)\n     (value << shift) >> shift"}, {"sha": "9e71399d4fdf7eacd9d02e4e12d1932e35b7ae74", "filename": "src/librustc/mir/interpret/pointer.rs", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/16ef483b79da2bee891d58f5da97456f71573cc0/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16ef483b79da2bee891d58f5da97456f71573cc0/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs?ref=16ef483b79da2bee891d58f5da97456f71573cc0", "patch": "@@ -20,45 +20,48 @@ pub trait PointerArithmetic: layout::HasDataLayout {\n         self.data_layout().pointer_size\n     }\n \n-    //// Trunace the given value to the pointer size; also return whether there was an overflow\n+    /// Helper function: truncate given value-\"overflowed flag\" pair to pointer size and\n+    /// update \"overflowed flag\" if there was an overflow.\n+    /// This should be called by all the other methods before returning!\n     #[inline]\n-    fn truncate_to_ptr(&self, val: u128) -> (u64, bool) {\n+    fn truncate_to_ptr(&self, (val, over): (u64, bool)) -> (u64, bool) {\n+        let val = val as u128;\n         let max_ptr_plus_1 = 1u128 << self.pointer_size().bits();\n-        ((val % max_ptr_plus_1) as u64, val >= max_ptr_plus_1)\n-    }\n-\n-    #[inline]\n-    fn offset<'tcx>(&self, val: u64, i: u64) -> EvalResult<'tcx, u64> {\n-        let (res, over) = self.overflowing_offset(val, i);\n-        if over { err!(Overflow(mir::BinOp::Add)) } else { Ok(res) }\n+        ((val % max_ptr_plus_1) as u64, over || val >= max_ptr_plus_1)\n     }\n \n     #[inline]\n     fn overflowing_offset(&self, val: u64, i: u64) -> (u64, bool) {\n-        let (res, over1) = val.overflowing_add(i);\n-        let (res, over2) = self.truncate_to_ptr(u128::from(res));\n-        (res, over1 || over2)\n-    }\n-\n-    #[inline]\n-    fn signed_offset<'tcx>(&self, val: u64, i: i64) -> EvalResult<'tcx, u64> {\n-        let (res, over) = self.overflowing_signed_offset(val, i128::from(i));\n-        if over { err!(Overflow(mir::BinOp::Add)) } else { Ok(res) }\n+        let res = val.overflowing_add(i);\n+        self.truncate_to_ptr(res)\n     }\n \n     // Overflow checking only works properly on the range from -u64 to +u64.\n     #[inline]\n     fn overflowing_signed_offset(&self, val: u64, i: i128) -> (u64, bool) {\n         // FIXME: is it possible to over/underflow here?\n         if i < 0 {\n-            // trickery to ensure that i64::min_value() works fine\n-            // this formula only works for true negative values, it panics for zero!\n+            // Trickery to ensure that i64::min_value() works fine: compute n = -i.\n+            // This formula only works for true negative values, it overflows for zero!\n             let n = u64::max_value() - (i as u64) + 1;\n-            val.overflowing_sub(n)\n+            let res = val.overflowing_sub(n);\n+            self.truncate_to_ptr(res)\n         } else {\n             self.overflowing_offset(val, i as u64)\n         }\n     }\n+\n+    #[inline]\n+    fn offset<'tcx>(&self, val: u64, i: u64) -> EvalResult<'tcx, u64> {\n+        let (res, over) = self.overflowing_offset(val, i);\n+        if over { err!(Overflow(mir::BinOp::Add)) } else { Ok(res) }\n+    }\n+\n+    #[inline]\n+    fn signed_offset<'tcx>(&self, val: u64, i: i64) -> EvalResult<'tcx, u64> {\n+        let (res, over) = self.overflowing_signed_offset(val, i128::from(i));\n+        if over { err!(Overflow(mir::BinOp::Add)) } else { Ok(res) }\n+    }\n }\n \n impl<T: layout::HasDataLayout> PointerArithmetic for T {}"}, {"sha": "21792b847db77e2e6fb0319436a0f61868a09d5f", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 82, "deletions": 60, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/16ef483b79da2bee891d58f5da97456f71573cc0/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16ef483b79da2bee891d58f5da97456f71573cc0/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=16ef483b79da2bee891d58f5da97456f71573cc0", "patch": "@@ -87,11 +87,11 @@ impl<'tcx> ConstValue<'tcx> {\n          RustcEncodable, RustcDecodable, Hash, HashStable)]\n pub enum Scalar<Tag=(), Id=AllocId> {\n     /// The raw bytes of a simple value.\n-    Bits {\n-        /// The first `size` bytes are the value.\n+    Raw {\n+        /// The first `size` bytes of `data` are the value.\n         /// Do not try to read less or more bytes than that. The remaining bytes must be 0.\n+        data: u128,\n         size: u8,\n-        bits: u128,\n     },\n \n     /// A pointer into an `Allocation`. An `Allocation` in the `memory` module has a list of\n@@ -108,16 +108,14 @@ impl<Tag: fmt::Debug, Id: fmt::Debug> fmt::Debug for Scalar<Tag, Id> {\n         match self {\n             Scalar::Ptr(ptr) =>\n                 write!(f, \"{:?}\", ptr),\n-            &Scalar::Bits { bits, size } => {\n+            &Scalar::Raw { data, size } => {\n+                Scalar::check_data(data, size);\n                 if size == 0 {\n-                    assert_eq!(bits, 0, \"ZST value must be 0\");\n                     write!(f, \"<ZST>\")\n                 } else {\n-                    assert_eq!(truncate(bits, Size::from_bytes(size as u64)), bits,\n-                            \"Scalar value {:#x} exceeds size of {} bytes\", bits, size);\n                     // Format as hex number wide enough to fit any value of the given `size`.\n-                    // So bits=20, size=1 will be \"0x14\", but with size=4 it'll be \"0x00000014\".\n-                    write!(f, \"0x{:>0width$x}\", bits, width=(size*2) as usize)\n+                    // So data=20, size=1 will be \"0x14\", but with size=4 it'll be \"0x00000014\".\n+                    write!(f, \"0x{:>0width$x}\", data, width=(size*2) as usize)\n                 }\n             }\n         }\n@@ -128,17 +126,23 @@ impl<Tag> fmt::Display for Scalar<Tag> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             Scalar::Ptr(_) => write!(f, \"a pointer\"),\n-            Scalar::Bits { bits, .. } => write!(f, \"{}\", bits),\n+            Scalar::Raw { data, .. } => write!(f, \"{}\", data),\n         }\n     }\n }\n \n impl<'tcx> Scalar<()> {\n+    #[inline(always)]\n+    fn check_data(data: u128, size: u8) {\n+        debug_assert_eq!(truncate(data, Size::from_bytes(size as u64)), data,\n+                         \"Scalar value {:#x} exceeds size of {} bytes\", data, size);\n+    }\n+\n     #[inline]\n     pub fn with_tag<Tag>(self, new_tag: Tag) -> Scalar<Tag> {\n         match self {\n             Scalar::Ptr(ptr) => Scalar::Ptr(ptr.with_tag(new_tag)),\n-            Scalar::Bits { bits, size } => Scalar::Bits { bits, size },\n+            Scalar::Raw { data, size } => Scalar::Raw { data, size },\n         }\n     }\n \n@@ -155,31 +159,31 @@ impl<'tcx, Tag> Scalar<Tag> {\n     pub fn erase_tag(self) -> Scalar {\n         match self {\n             Scalar::Ptr(ptr) => Scalar::Ptr(ptr.erase_tag()),\n-            Scalar::Bits { bits, size } => Scalar::Bits { bits, size },\n+            Scalar::Raw { data, size } => Scalar::Raw { data, size },\n         }\n     }\n \n     #[inline]\n     pub fn ptr_null(cx: &impl HasDataLayout) -> Self {\n-        Scalar::Bits {\n-            bits: 0,\n+        Scalar::Raw {\n+            data: 0,\n             size: cx.data_layout().pointer_size.bytes() as u8,\n         }\n     }\n \n     #[inline]\n     pub fn zst() -> Self {\n-        Scalar::Bits { bits: 0, size: 0 }\n+        Scalar::Raw { data: 0, size: 0 }\n     }\n \n     #[inline]\n     pub fn ptr_offset(self, i: Size, cx: &impl HasDataLayout) -> EvalResult<'tcx, Self> {\n         let dl = cx.data_layout();\n         match self {\n-            Scalar::Bits { bits, size } => {\n+            Scalar::Raw { data, size } => {\n                 assert_eq!(size as u64, dl.pointer_size.bytes());\n-                Ok(Scalar::Bits {\n-                    bits: dl.offset(bits as u64, i.bytes())? as u128,\n+                Ok(Scalar::Raw {\n+                    data: dl.offset(data as u64, i.bytes())? as u128,\n                     size,\n                 })\n             }\n@@ -191,10 +195,10 @@ impl<'tcx, Tag> Scalar<Tag> {\n     pub fn ptr_wrapping_offset(self, i: Size, cx: &impl HasDataLayout) -> Self {\n         let dl = cx.data_layout();\n         match self {\n-            Scalar::Bits { bits, size } => {\n+            Scalar::Raw { data, size } => {\n                 assert_eq!(size as u64, dl.pointer_size.bytes());\n-                Scalar::Bits {\n-                    bits: dl.overflowing_offset(bits as u64, i.bytes()).0 as u128,\n+                Scalar::Raw {\n+                    data: dl.overflowing_offset(data as u64, i.bytes()).0 as u128,\n                     size,\n                 }\n             }\n@@ -206,10 +210,10 @@ impl<'tcx, Tag> Scalar<Tag> {\n     pub fn ptr_signed_offset(self, i: i64, cx: &impl HasDataLayout) -> EvalResult<'tcx, Self> {\n         let dl = cx.data_layout();\n         match self {\n-            Scalar::Bits { bits, size } => {\n+            Scalar::Raw { data, size } => {\n                 assert_eq!(size as u64, dl.pointer_size().bytes());\n-                Ok(Scalar::Bits {\n-                    bits: dl.signed_offset(bits as u64, i)? as u128,\n+                Ok(Scalar::Raw {\n+                    data: dl.signed_offset(data as u64, i)? as u128,\n                     size,\n                 })\n             }\n@@ -221,25 +225,25 @@ impl<'tcx, Tag> Scalar<Tag> {\n     pub fn ptr_wrapping_signed_offset(self, i: i64, cx: &impl HasDataLayout) -> Self {\n         let dl = cx.data_layout();\n         match self {\n-            Scalar::Bits { bits, size } => {\n+            Scalar::Raw { data, size } => {\n                 assert_eq!(size as u64, dl.pointer_size.bytes());\n-                Scalar::Bits {\n-                    bits: dl.overflowing_signed_offset(bits as u64, i128::from(i)).0 as u128,\n+                Scalar::Raw {\n+                    data: dl.overflowing_signed_offset(data as u64, i128::from(i)).0 as u128,\n                     size,\n                 }\n             }\n             Scalar::Ptr(ptr) => Scalar::Ptr(ptr.wrapping_signed_offset(i, dl)),\n         }\n     }\n \n-    /// Returns this pointers offset from the allocation base, or from NULL (for\n+    /// Returns this pointer's offset from the allocation base, or from NULL (for\n     /// integer pointers).\n     #[inline]\n     pub fn get_ptr_offset(self, cx: &impl HasDataLayout) -> Size {\n         match self {\n-            Scalar::Bits { bits, size } => {\n+            Scalar::Raw { data, size } => {\n                 assert_eq!(size as u64, cx.pointer_size().bytes());\n-                Size::from_bytes(bits as u64)\n+                Size::from_bytes(data as u64)\n             }\n             Scalar::Ptr(ptr) => ptr.offset,\n         }\n@@ -248,59 +252,84 @@ impl<'tcx, Tag> Scalar<Tag> {\n     #[inline]\n     pub fn is_null_ptr(self, cx: &impl HasDataLayout) -> bool {\n         match self {\n-            Scalar::Bits { bits, size } => {\n+            Scalar::Raw { data, size } => {\n                 assert_eq!(size as u64, cx.data_layout().pointer_size.bytes());\n-                bits == 0\n+                data == 0\n             },\n             Scalar::Ptr(_) => false,\n         }\n     }\n \n     #[inline]\n     pub fn from_bool(b: bool) -> Self {\n-        Scalar::Bits { bits: b as u128, size: 1 }\n+        Scalar::Raw { data: b as u128, size: 1 }\n     }\n \n     #[inline]\n     pub fn from_char(c: char) -> Self {\n-        Scalar::Bits { bits: c as u128, size: 4 }\n+        Scalar::Raw { data: c as u128, size: 4 }\n     }\n \n     #[inline]\n     pub fn from_uint(i: impl Into<u128>, size: Size) -> Self {\n         let i = i.into();\n-        debug_assert_eq!(truncate(i, size), i,\n-                         \"Unsigned value {} does not fit in {} bits\", i, size.bits());\n-        Scalar::Bits { bits: i, size: size.bytes() as u8 }\n+        assert_eq!(\n+            truncate(i, size), i,\n+            \"Unsigned value {:#x} does not fit in {} bits\", i, size.bits()\n+        );\n+        Scalar::Raw { data: i, size: size.bytes() as u8 }\n     }\n \n     #[inline]\n     pub fn from_int(i: impl Into<i128>, size: Size) -> Self {\n         let i = i.into();\n         // `into` performed sign extension, we have to truncate\n         let truncated = truncate(i as u128, size);\n-        debug_assert_eq!(sign_extend(truncated, size) as i128, i,\n-                         \"Signed value {} does not fit in {} bits\", i, size.bits());\n-        Scalar::Bits { bits: truncated, size: size.bytes() as u8 }\n+        assert_eq!(\n+            sign_extend(truncated, size) as i128, i,\n+            \"Signed value {:#x} does not fit in {} bits\", i, size.bits()\n+        );\n+        Scalar::Raw { data: truncated, size: size.bytes() as u8 }\n     }\n \n     #[inline]\n     pub fn from_f32(f: f32) -> Self {\n-        Scalar::Bits { bits: f.to_bits() as u128, size: 4 }\n+        Scalar::Raw { data: f.to_bits() as u128, size: 4 }\n     }\n \n     #[inline]\n     pub fn from_f64(f: f64) -> Self {\n-        Scalar::Bits { bits: f.to_bits() as u128, size: 8 }\n+        Scalar::Raw { data: f.to_bits() as u128, size: 8 }\n+    }\n+\n+    #[inline]\n+    pub fn to_bits_or_ptr(\n+        self,\n+        target_size: Size,\n+        cx: &impl HasDataLayout,\n+    ) -> Result<u128, Pointer<Tag>> {\n+        match self {\n+            Scalar::Raw { data, size } => {\n+                assert_eq!(target_size.bytes(), size as u64);\n+                assert_ne!(size, 0, \"you should never look at the bits of a ZST\");\n+                Scalar::check_data(data, size);\n+                Ok(data)\n+            }\n+            Scalar::Ptr(ptr) => {\n+                assert_eq!(target_size, cx.data_layout().pointer_size);\n+                Err(ptr)\n+            }\n+        }\n     }\n \n     #[inline]\n     pub fn to_bits(self, target_size: Size) -> EvalResult<'tcx, u128> {\n         match self {\n-            Scalar::Bits { bits, size } => {\n+            Scalar::Raw { data, size } => {\n                 assert_eq!(target_size.bytes(), size as u64);\n-                assert_ne!(size, 0, \"to_bits cannot be used with zsts\");\n-                Ok(bits)\n+                assert_ne!(size, 0, \"you should never look at the bits of a ZST\");\n+                Scalar::check_data(data, size);\n+                Ok(data)\n             }\n             Scalar::Ptr(_) => err!(ReadPointerAsBytes),\n         }\n@@ -309,16 +338,16 @@ impl<'tcx, Tag> Scalar<Tag> {\n     #[inline]\n     pub fn to_ptr(self) -> EvalResult<'tcx, Pointer<Tag>> {\n         match self {\n-            Scalar::Bits { bits: 0, .. } => err!(InvalidNullPointerUsage),\n-            Scalar::Bits { .. } => err!(ReadBytesAsPointer),\n+            Scalar::Raw { data: 0, .. } => err!(InvalidNullPointerUsage),\n+            Scalar::Raw { .. } => err!(ReadBytesAsPointer),\n             Scalar::Ptr(p) => Ok(p),\n         }\n     }\n \n     #[inline]\n     pub fn is_bits(self) -> bool {\n         match self {\n-            Scalar::Bits { .. } => true,\n+            Scalar::Raw { .. } => true,\n             _ => false,\n         }\n     }\n@@ -333,8 +362,8 @@ impl<'tcx, Tag> Scalar<Tag> {\n \n     pub fn to_bool(self) -> EvalResult<'tcx, bool> {\n         match self {\n-            Scalar::Bits { bits: 0, size: 1 } => Ok(false),\n-            Scalar::Bits { bits: 1, size: 1 } => Ok(true),\n+            Scalar::Raw { data: 0, size: 1 } => Ok(false),\n+            Scalar::Raw { data: 1, size: 1 } => Ok(true),\n             _ => err!(InvalidBool),\n         }\n     }\n@@ -350,58 +379,51 @@ impl<'tcx, Tag> Scalar<Tag> {\n     pub fn to_u8(self) -> EvalResult<'static, u8> {\n         let sz = Size::from_bits(8);\n         let b = self.to_bits(sz)?;\n-        assert_eq!(b as u8 as u128, b);\n         Ok(b as u8)\n     }\n \n     pub fn to_u32(self) -> EvalResult<'static, u32> {\n         let sz = Size::from_bits(32);\n         let b = self.to_bits(sz)?;\n-        assert_eq!(b as u32 as u128, b);\n         Ok(b as u32)\n     }\n \n     pub fn to_u64(self) -> EvalResult<'static, u64> {\n         let sz = Size::from_bits(64);\n         let b = self.to_bits(sz)?;\n-        assert_eq!(b as u64 as u128, b);\n         Ok(b as u64)\n     }\n \n     pub fn to_usize(self, cx: &impl HasDataLayout) -> EvalResult<'static, u64> {\n         let b = self.to_bits(cx.data_layout().pointer_size)?;\n-        assert_eq!(b as u64 as u128, b);\n         Ok(b as u64)\n     }\n \n     pub fn to_i8(self) -> EvalResult<'static, i8> {\n         let sz = Size::from_bits(8);\n         let b = self.to_bits(sz)?;\n         let b = sign_extend(b, sz) as i128;\n-        assert_eq!(b as i8 as i128, b);\n         Ok(b as i8)\n     }\n \n     pub fn to_i32(self) -> EvalResult<'static, i32> {\n         let sz = Size::from_bits(32);\n         let b = self.to_bits(sz)?;\n         let b = sign_extend(b, sz) as i128;\n-        assert_eq!(b as i32 as i128, b);\n         Ok(b as i32)\n     }\n \n     pub fn to_i64(self) -> EvalResult<'static, i64> {\n         let sz = Size::from_bits(64);\n         let b = self.to_bits(sz)?;\n         let b = sign_extend(b, sz) as i128;\n-        assert_eq!(b as i64 as i128, b);\n         Ok(b as i64)\n     }\n \n     pub fn to_isize(self, cx: &impl HasDataLayout) -> EvalResult<'static, i64> {\n-        let b = self.to_bits(cx.data_layout().pointer_size)?;\n-        let b = sign_extend(b, cx.data_layout().pointer_size) as i128;\n-        assert_eq!(b as i64 as i128, b);\n+        let sz = cx.data_layout().pointer_size;\n+        let b = self.to_bits(sz)?;\n+        let b = sign_extend(b, sz) as i128;\n         Ok(b as i64)\n     }\n "}, {"sha": "e2a8cd6b17df62c0ba3b38295f3adf5d5a2a0beb", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/16ef483b79da2bee891d58f5da97456f71573cc0/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16ef483b79da2bee891d58f5da97456f71573cc0/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=16ef483b79da2bee891d58f5da97456f71573cc0", "patch": "@@ -1669,10 +1669,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n                         .map(|&u| {\n                             tcx.mk_const(ty::Const {\n                                 val: ConstValue::Scalar(\n-                                    Scalar::Bits {\n-                                        bits: u,\n-                                        size: size.bytes() as u8,\n-                                    }.into(),\n+                                    Scalar::from_uint(u, size).into(),\n                                 ),\n                                 ty: switch_ty,\n                             }).to_string().into()"}, {"sha": "92de3e28d19035467e858af53fbba8d1837dd3ae", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16ef483b79da2bee891d58f5da97456f71573cc0/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16ef483b79da2bee891d58f5da97456f71573cc0/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=16ef483b79da2bee891d58f5da97456f71573cc0", "patch": "@@ -1001,7 +1001,7 @@ impl<'tcx> CommonConsts<'tcx> {\n \n         CommonConsts {\n             err: mk_const(ty::Const {\n-                val: ConstValue::Scalar(Scalar::Bits { bits: 0, size: 0 }),\n+                val: ConstValue::Scalar(Scalar::zst()),\n                 ty: types.err,\n             }),\n         }"}, {"sha": "a246d9652f2f045ef3b1c9667b736c191e0d2d62", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/16ef483b79da2bee891d58f5da97456f71573cc0/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16ef483b79da2bee891d58f5da97456f71573cc0/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=16ef483b79da2bee891d58f5da97456f71573cc0", "patch": "@@ -845,34 +845,34 @@ pub trait PrettyPrinter<'gcx: 'tcx, 'tcx>:\n             p!(write(\"{}\", name));\n             return Ok(self);\n         }\n-        if let ConstValue::Scalar(Scalar::Bits { bits, .. }) = ct.val {\n+        if let ConstValue::Scalar(Scalar::Raw { data, .. }) = ct.val {\n             match ct.ty.sty {\n                 ty::Bool => {\n-                    p!(write(\"{}\", if bits == 0 { \"false\" } else { \"true\" }));\n+                    p!(write(\"{}\", if data == 0 { \"false\" } else { \"true\" }));\n                     return Ok(self);\n                 },\n                 ty::Float(ast::FloatTy::F32) => {\n-                    p!(write(\"{}f32\", Single::from_bits(bits)));\n+                    p!(write(\"{}f32\", Single::from_bits(data)));\n                     return Ok(self);\n                 },\n                 ty::Float(ast::FloatTy::F64) => {\n-                    p!(write(\"{}f64\", Double::from_bits(bits)));\n+                    p!(write(\"{}f64\", Double::from_bits(data)));\n                     return Ok(self);\n                 },\n                 ty::Uint(ui) => {\n-                    p!(write(\"{}{}\", bits, ui));\n+                    p!(write(\"{}{}\", data, ui));\n                     return Ok(self);\n                 },\n                 ty::Int(i) =>{\n                     let ty = self.tcx().lift_to_global(&ct.ty).unwrap();\n                     let size = self.tcx().layout_of(ty::ParamEnv::empty().and(ty))\n                         .unwrap()\n                         .size;\n-                    p!(write(\"{}{}\", sign_extend(bits, size) as i128, i));\n+                    p!(write(\"{}{}\", sign_extend(data, size) as i128, i));\n                     return Ok(self);\n                 },\n                 ty::Char => {\n-                    p!(write(\"{:?}\", ::std::char::from_u32(bits as u32).unwrap()));\n+                    p!(write(\"{:?}\", ::std::char::from_u32(data as u32).unwrap()));\n                     return Ok(self);\n                 }\n                 _ => {},"}, {"sha": "75d227d8067c3c088348f5a54ea98702b9a9bdce", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16ef483b79da2bee891d58f5da97456f71573cc0/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16ef483b79da2bee891d58f5da97456f71573cc0/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=16ef483b79da2bee891d58f5da97456f71573cc0", "patch": "@@ -613,7 +613,7 @@ where\n         (ConstValue::Placeholder(p1), ConstValue::Placeholder(p2)) if p1 == p2 => {\n             Ok(a)\n         }\n-        (ConstValue::Scalar(Scalar::Bits { .. }), _) if a == b => {\n+        (ConstValue::Scalar(Scalar::Raw { .. }), _) if a == b => {\n             Ok(a)\n         }\n         (ConstValue::ByRef(..), _) => {"}, {"sha": "0a673dd380b5254416da4ea452c86d6f1e7dbc60", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16ef483b79da2bee891d58f5da97456f71573cc0/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16ef483b79da2bee891d58f5da97456f71573cc0/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=16ef483b79da2bee891d58f5da97456f71573cc0", "patch": "@@ -3,7 +3,7 @@\n use crate::hir;\n use crate::hir::def_id::DefId;\n use crate::infer::canonical::Canonical;\n-use crate::mir::interpret::{ConstValue, truncate};\n+use crate::mir::interpret::ConstValue;\n use crate::middle::region;\n use polonius_engine::Atom;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -2232,14 +2232,12 @@ impl<'tcx> Const<'tcx> {\n         let size = tcx.layout_of(ty).unwrap_or_else(|e| {\n             panic!(\"could not compute layout for {:?}: {:?}\", ty, e)\n         }).size;\n-        let truncated = truncate(bits, size);\n-        assert_eq!(truncated, bits, \"from_bits called with untruncated value\");\n-        Self::from_scalar(tcx, Scalar::Bits { bits, size: size.bytes() as u8 }, ty.value)\n+        Self::from_scalar(tcx, Scalar::from_uint(bits, size), ty.value)\n     }\n \n     #[inline]\n     pub fn zero_sized(tcx: TyCtxt<'_, '_, 'tcx>, ty: Ty<'tcx>) -> &'tcx Self {\n-        Self::from_scalar(tcx, Scalar::Bits { bits: 0, size: 0 }, ty)\n+        Self::from_scalar(tcx, Scalar::zst(), ty)\n     }\n \n     #[inline]"}, {"sha": "c713362440d97140b8d185fe00c76049d2942ed4", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/16ef483b79da2bee891d58f5da97456f71573cc0/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16ef483b79da2bee891d58f5da97456f71573cc0/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=16ef483b79da2bee891d58f5da97456f71573cc0", "patch": "@@ -294,13 +294,13 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     ) -> &'ll Value {\n         let bitsize = if layout.is_bool() { 1 } else { layout.value.size(self).bits() };\n         match cv {\n-            Scalar::Bits { size: 0, .. } => {\n+            Scalar::Raw { size: 0, .. } => {\n                 assert_eq!(0, layout.value.size(self).bytes());\n                 self.const_undef(self.type_ix(0))\n             },\n-            Scalar::Bits { bits, size } => {\n+            Scalar::Raw { data, size } => {\n                 assert_eq!(size as u64, layout.value.size(self).bytes());\n-                let llval = self.const_uint_big(self.type_ix(bitsize), bits);\n+                let llval = self.const_uint_big(self.type_ix(bitsize), data);\n                 if layout.value == layout::Pointer {\n                     unsafe { llvm::LLVMConstIntToPtr(llval, llty) }\n                 } else {"}, {"sha": "bf81b7f0da5258fee7c8bff4374072bb0ce4ff63", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16ef483b79da2bee891d58f5da97456f71573cc0/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16ef483b79da2bee891d58f5da97456f71573cc0/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=16ef483b79da2bee891d58f5da97456f71573cc0", "patch": "@@ -443,7 +443,7 @@ impl Printer<'tcx, 'tcx> for SymbolPrinter<'_, 'tcx> {\n         ct: &'tcx ty::Const<'tcx>,\n     ) -> Result<Self::Const, Self::Error> {\n         // only print integers\n-        if let ConstValue::Scalar(Scalar::Bits { .. }) = ct.val {\n+        if let ConstValue::Scalar(Scalar::Raw { .. }) = ct.val {\n             if ct.ty.is_integral() {\n                 return self.pretty_print_const(ct);\n             }"}, {"sha": "7b3d0bceb6896c475f979ff91b91d2887a5c925d", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16ef483b79da2bee891d58f5da97456f71573cc0/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16ef483b79da2bee891d58f5da97456f71573cc0/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=16ef483b79da2bee891d58f5da97456f71573cc0", "patch": "@@ -115,7 +115,7 @@ fn op_to_const<'tcx>(\n                     ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id),\n                     ptr.offset.bytes(),\n                 ),\n-                Scalar::Bits { .. } => (\n+                Scalar::Raw { .. } => (\n                     ecx.tcx.intern_const_alloc(Allocation::from_byte_aligned_bytes(b\"\", ())),\n                     0,\n                 ),"}, {"sha": "69df36348a69e6ffbe47801b1d71cabda1f14a0f", "filename": "src/librustc_mir/hair/constant.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/16ef483b79da2bee891d58f5da97456f71573cc0/src%2Flibrustc_mir%2Fhair%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16ef483b79da2bee891d58f5da97456f71573cc0/src%2Flibrustc_mir%2Fhair%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fconstant.rs?ref=16ef483b79da2bee891d58f5da97456f71573cc0", "patch": "@@ -1,5 +1,5 @@\n use syntax::ast;\n-use rustc::ty::{self, Ty, TyCtxt, ParamEnv};\n+use rustc::ty::{self, Ty, TyCtxt, ParamEnv, layout::Size};\n use syntax_pos::symbol::Symbol;\n use rustc::mir::interpret::{ConstValue, Scalar};\n \n@@ -23,10 +23,7 @@ crate fn lit_to_const<'a, 'gcx, 'tcx>(\n         trace!(\"trunc {} with size {} and shift {}\", n, width.bits(), 128 - width.bits());\n         let result = truncate(n, width);\n         trace!(\"trunc result: {}\", result);\n-        Ok(ConstValue::Scalar(Scalar::Bits {\n-            bits: result,\n-            size: width.bytes() as u8,\n-        }))\n+        Ok(ConstValue::Scalar(Scalar::from_uint(result, width)))\n     };\n \n     use rustc::mir::interpret::*;\n@@ -50,10 +47,7 @@ crate fn lit_to_const<'a, 'gcx, 'tcx>(\n             let id = tcx.allocate_bytes(data);\n             ConstValue::Scalar(Scalar::Ptr(id.into()))\n         },\n-        LitKind::Byte(n) => ConstValue::Scalar(Scalar::Bits {\n-            bits: n as u128,\n-            size: 1,\n-        }),\n+        LitKind::Byte(n) => ConstValue::Scalar(Scalar::from_uint(n, Size::from_bytes(1))),\n         LitKind::Int(n, _) if neg => {\n             let n = n as i128;\n             let n = n.overflowing_neg().0;\n@@ -84,7 +78,7 @@ fn parse_float<'tcx>(\n     let num = num.as_str();\n     use rustc_apfloat::ieee::{Single, Double};\n     use rustc_apfloat::Float;\n-    let (bits, size) = match fty {\n+    let (data, size) = match fty {\n         ast::FloatTy::F32 => {\n             num.parse::<f32>().map_err(|_| ())?;\n             let mut f = num.parse::<Single>().unwrap_or_else(|e| {\n@@ -107,5 +101,5 @@ fn parse_float<'tcx>(\n         }\n     };\n \n-    Ok(ConstValue::Scalar(Scalar::Bits { bits, size }))\n+    Ok(ConstValue::Scalar(Scalar::from_uint(data, Size::from_bytes(size))))\n }"}, {"sha": "76b11ac2fe6463a4515782d743e1a2b30dc018ee", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 8, "deletions": 33, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/16ef483b79da2bee891d58f5da97456f71573cc0/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16ef483b79da2bee891d58f5da97456f71573cc0/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=16ef483b79da2bee891d58f5da97456f71573cc0", "patch": "@@ -6,7 +6,7 @@ use syntax::symbol::sym;\n \n use rustc_apfloat::ieee::{Single, Double};\n use rustc::mir::interpret::{\n-    Scalar, EvalResult, Pointer, PointerArithmetic, InterpError, truncate\n+    Scalar, EvalResult, Pointer, PointerArithmetic, InterpError,\n };\n use rustc::mir::CastKind;\n use rustc_apfloat::Float;\n@@ -135,29 +135,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         use rustc::ty::TyKind::*;\n         trace!(\"Casting {:?}: {:?} to {:?}\", val, src_layout.ty, dest_layout.ty);\n \n-        match val {\n-            Scalar::Ptr(ptr) => self.cast_from_ptr(ptr, dest_layout.ty),\n-            Scalar::Bits { bits, size } => {\n-                debug_assert_eq!(size as u64, src_layout.size.bytes());\n-                debug_assert_eq!(truncate(bits, Size::from_bytes(size.into())), bits,\n-                    \"Unexpected value of size {} before casting\", size);\n-\n-                let res = match src_layout.ty.sty {\n-                    Float(fty) => self.cast_from_float(bits, fty, dest_layout.ty)?,\n-                    _ => self.cast_from_int(bits, src_layout, dest_layout)?,\n-                };\n-\n-                // Sanity check\n-                match res {\n-                    Scalar::Ptr(_) => bug!(\"Fabricated a ptr value from an int...?\"),\n-                    Scalar::Bits { bits, size } => {\n-                        debug_assert_eq!(size as u64, dest_layout.size.bytes());\n-                        debug_assert_eq!(truncate(bits, Size::from_bytes(size.into())), bits,\n-                            \"Unexpected value of size {} after casting\", size);\n-                    }\n+        match val.to_bits_or_ptr(src_layout.size, self) {\n+            Err(ptr) => self.cast_from_ptr(ptr, dest_layout.ty),\n+            Ok(data) => {\n+                match src_layout.ty.sty {\n+                    Float(fty) => self.cast_from_float(data, fty, dest_layout.ty),\n+                    _ => self.cast_from_int(data, src_layout, dest_layout),\n                 }\n-                // Done\n-                Ok(res)\n             }\n         }\n     }\n@@ -177,7 +161,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         trace!(\"cast_from_int: {}, {}, {}\", v, src_layout.ty, dest_layout.ty);\n         use rustc::ty::TyKind::*;\n         match dest_layout.ty.sty {\n-            Int(_) | Uint(_) => {\n+            Int(_) | Uint(_) | RawPtr(_) => {\n                 let v = self.truncate(v, dest_layout);\n                 Ok(Scalar::from_uint(v, dest_layout.size))\n             }\n@@ -205,15 +189,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n                 Ok(Scalar::from_uint(v, Size::from_bytes(4)))\n             },\n \n-            // No alignment check needed for raw pointers.\n-            // But we have to truncate to target ptr size.\n-            RawPtr(_) => {\n-                Ok(Scalar::from_uint(\n-                    self.truncate_to_ptr(v).0,\n-                    self.pointer_size(),\n-                ))\n-            },\n-\n             // Casts to bool are not permitted by rustc, no need to handle them here.\n             _ => err!(Unimplemented(format!(\"int to {:?} cast\", dest_layout.ty))),\n         }"}, {"sha": "65a3b04c8b152f1c26eb0762e92eb7dd58a61152", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/16ef483b79da2bee891d58f5da97456f71573cc0/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16ef483b79da2bee891d58f5da97456f71573cc0/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=16ef483b79da2bee891d58f5da97456f71573cc0", "patch": "@@ -12,7 +12,6 @@ use std::borrow::Cow;\n \n use rustc::ty::{self, Instance, ParamEnv, query::TyCtxtAt};\n use rustc::ty::layout::{Align, TargetDataLayout, Size, HasDataLayout};\n-pub use rustc::mir::interpret::{truncate, write_target_uint, read_target_uint};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n \n use syntax::ast::Mutability;\n@@ -248,23 +247,21 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         required_align: Align\n     ) -> EvalResult<'tcx> {\n         // Check non-NULL/Undef, extract offset\n-        let (offset, alloc_align) = match ptr {\n-            Scalar::Ptr(ptr) => {\n+        let (offset, alloc_align) = match ptr.to_bits_or_ptr(self.pointer_size(), self) {\n+            Err(ptr) => {\n                 // check this is not NULL -- which we can ensure only if this is in-bounds\n                 // of some (potentially dead) allocation.\n                 let align = self.check_bounds_ptr(ptr, InboundsCheck::MaybeDead,\n                                                   CheckInAllocMsg::NullPointerTest)?;\n                 (ptr.offset.bytes(), align)\n             }\n-            Scalar::Bits { bits, size } => {\n-                assert_eq!(size as u64, self.pointer_size().bytes());\n-                assert!(bits < (1u128 << self.pointer_size().bits()));\n+            Ok(data) => {\n                 // check this is not NULL\n-                if bits == 0 {\n+                if data == 0 {\n                     return err!(InvalidNullPointerUsage);\n                 }\n                 // the \"base address\" is 0 and hence always aligned\n-                (bits as u64, required_align)\n+                (data as u64, required_align)\n             }\n         };\n         // Check alignment"}, {"sha": "289379f34a9a3bb8771d4dfe0253f7e97689fde4", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/16ef483b79da2bee891d58f5da97456f71573cc0/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16ef483b79da2bee891d58f5da97456f71573cc0/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=16ef483b79da2bee891d58f5da97456f71573cc0", "patch": "@@ -641,19 +641,20 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n             } => {\n                 let variants_start = niche_variants.start().as_u32() as u128;\n                 let variants_end = niche_variants.end().as_u32() as u128;\n-                match raw_discr {\n-                    ScalarMaybeUndef::Scalar(Scalar::Ptr(ptr)) => {\n+                let raw_discr = raw_discr.not_undef()\n+                    .map_err(|_| InterpError::InvalidDiscriminant(ScalarMaybeUndef::Undef))?;\n+                match raw_discr.to_bits_or_ptr(discr_val.layout.size, self) {\n+                    Err(ptr) => {\n                         // The niche must be just 0 (which an inbounds pointer value never is)\n                         let ptr_valid = niche_start == 0 && variants_start == variants_end &&\n                             self.memory.check_bounds_ptr(ptr, InboundsCheck::MaybeDead,\n                                                          CheckInAllocMsg::NullPointerTest).is_ok();\n                         if !ptr_valid {\n-                            return err!(InvalidDiscriminant(raw_discr.erase_tag()));\n+                            return err!(InvalidDiscriminant(raw_discr.erase_tag().into()));\n                         }\n                         (dataful_variant.as_u32() as u128, dataful_variant)\n                     },\n-                    ScalarMaybeUndef::Scalar(Scalar::Bits { bits: raw_discr, size }) => {\n-                        assert_eq!(size as u64, discr_val.layout.size.bytes());\n+                    Ok(raw_discr) => {\n                         let adjusted_discr = raw_discr.wrapping_sub(niche_start)\n                             .wrapping_add(variants_start);\n                         if variants_start <= adjusted_discr && adjusted_discr <= variants_end {\n@@ -668,8 +669,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n                             (dataful_variant.as_u32() as u128, dataful_variant)\n                         }\n                     },\n-                    ScalarMaybeUndef::Undef =>\n-                        return err!(InvalidDiscriminant(ScalarMaybeUndef::Undef)),\n                 }\n             }\n         })"}, {"sha": "0ae4e90b7c24d57afb72319874960c5893f79c6e", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16ef483b79da2bee891d58f5da97456f71573cc0/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16ef483b79da2bee891d58f5da97456f71573cc0/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=16ef483b79da2bee891d58f5da97456f71573cc0", "patch": "@@ -686,7 +686,7 @@ where\n                 Immediate::Scalar(ScalarMaybeUndef::Scalar(Scalar::Ptr(_))) =>\n                     assert_eq!(self.pointer_size(), dest.layout.size,\n                         \"Size mismatch when writing pointer\"),\n-                Immediate::Scalar(ScalarMaybeUndef::Scalar(Scalar::Bits { size, .. })) =>\n+                Immediate::Scalar(ScalarMaybeUndef::Scalar(Scalar::Raw { size, .. })) =>\n                     assert_eq!(Size::from_bytes(size.into()), dest.layout.size,\n                         \"Size mismatch when writing bits\"),\n                 Immediate::Scalar(ScalarMaybeUndef::Undef) => {}, // undef can have any size"}, {"sha": "c0bc7ce6b39ad09af7c5d7e790fef386c4f68a78", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16ef483b79da2bee891d58f5da97456f71573cc0/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16ef483b79da2bee891d58f5da97456f71573cc0/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=16ef483b79da2bee891d58f5da97456f71573cc0", "patch": "@@ -186,9 +186,9 @@ impl<'a, Ctx> Snapshot<'a, Ctx> for Scalar\n     fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n         match self {\n             Scalar::Ptr(p) => Scalar::Ptr(p.snapshot(ctx)),\n-            Scalar::Bits{ size, bits } => Scalar::Bits {\n+            Scalar::Raw{ size, data } => Scalar::Raw {\n+                data: *data,\n                 size: *size,\n-                bits: *bits,\n             },\n         }\n     }"}, {"sha": "072c6f4fd90e8e9641bcf2264246bc025050f2ab", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/16ef483b79da2bee891d58f5da97456f71573cc0/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16ef483b79da2bee891d58f5da97456f71573cc0/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=16ef483b79da2bee891d58f5da97456f71573cc0", "patch": "@@ -480,8 +480,8 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                 wrapping_range_format(&layout.valid_range, max_hi),\n             )\n         );\n-        let bits = match value {\n-            Scalar::Ptr(ptr) => {\n+        let bits = match value.to_bits_or_ptr(op.layout.size, self.ecx) {\n+            Err(ptr) => {\n                 if lo == 1 && hi == max_hi {\n                     // only NULL is not allowed.\n                     // We can call `check_align` to check non-NULL-ness, but have to also look\n@@ -509,10 +509,8 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                     );\n                 }\n             }\n-            Scalar::Bits { bits, size } => {\n-                assert_eq!(size as u64, op.layout.size.bytes());\n-                bits\n-            }\n+            Ok(data) =>\n+                data\n         };\n         // Now compare. This is slightly subtle because this is a special \"wrap-around\" range.\n         if wrapping_range_contains(&layout.valid_range, bits) {"}, {"sha": "c46b439f4d34e1105ebe9834ed118e9e5cebebb3", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/16ef483b79da2bee891d58f5da97456f71573cc0/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16ef483b79da2bee891d58f5da97456f71573cc0/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=16ef483b79da2bee891d58f5da97456f71573cc0", "patch": "@@ -382,10 +382,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                 type_size_of(self.tcx, self.param_env, ty).and_then(|n| Some(\n                     ImmTy {\n                         imm: Immediate::Scalar(\n-                            Scalar::Bits {\n-                                bits: n as u128,\n-                                size: self.tcx.data_layout.pointer_size.bytes() as u8,\n-                            }.into()\n+                            Scalar::from_uint(n, self.tcx.data_layout.pointer_size).into()\n                         ),\n                         layout: self.tcx.layout_of(self.param_env.and(self.tcx.types.usize)).ok()?,\n                     }.into()\n@@ -713,18 +710,18 @@ impl<'b, 'a, 'tcx> MutVisitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n                                     .eval_operand(len, source_info)\n                                     .expect(\"len must be const\");\n                                 let len = match self.ecx.read_scalar(len) {\n-                                    Ok(ScalarMaybeUndef::Scalar(Scalar::Bits {\n-                                        bits, ..\n-                                    })) => bits,\n+                                    Ok(ScalarMaybeUndef::Scalar(Scalar::Raw {\n+                                        data, ..\n+                                    })) => data,\n                                     other => bug!(\"const len not primitive: {:?}\", other),\n                                 };\n                                 let index = self\n                                     .eval_operand(index, source_info)\n                                     .expect(\"index must be const\");\n                                 let index = match self.ecx.read_scalar(index) {\n-                                    Ok(ScalarMaybeUndef::Scalar(Scalar::Bits {\n-                                        bits, ..\n-                                    })) => bits,\n+                                    Ok(ScalarMaybeUndef::Scalar(Scalar::Raw {\n+                                        data, ..\n+                                    })) => data,\n                                     other => bug!(\"const index not primitive: {:?}\", other),\n                                 };\n                                 format!("}]}