{"sha": "0fe876925e59aad4765b415d9caaf262a6d43c4c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmZTg3NjkyNWU1OWFhZDQ3NjViNDE1ZDljYWFmMjYyYTZkNDNjNGM=", "commit": {"author": {"name": "Roland Ruckerbauer", "email": "roland.rucky@gmail.com", "date": "2020-05-18T21:39:10Z"}, "committer": {"name": "Roland Ruckerbauer", "email": "roland.rucky@gmail.com", "date": "2020-05-18T21:39:10Z"}, "message": "Infer return type of loops with value breaks.", "tree": {"sha": "2196f6884fe99a580b03f8891ef91c7065ff92cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2196f6884fe99a580b03f8891ef91c7065ff92cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0fe876925e59aad4765b415d9caaf262a6d43c4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0fe876925e59aad4765b415d9caaf262a6d43c4c", "html_url": "https://github.com/rust-lang/rust/commit/0fe876925e59aad4765b415d9caaf262a6d43c4c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0fe876925e59aad4765b415d9caaf262a6d43c4c/comments", "author": null, "committer": null, "parents": [{"sha": "38e8f35855efac144373c1b5aab3af050e47e594", "url": "https://api.github.com/repos/rust-lang/rust/commits/38e8f35855efac144373c1b5aab3af050e47e594", "html_url": "https://github.com/rust-lang/rust/commit/38e8f35855efac144373c1b5aab3af050e47e594"}], "stats": {"total": 22, "additions": 16, "deletions": 6}, "files": [{"sha": "957d6e0b5792d5f6d84a609e76ab5c2a57cd7382", "filename": "crates/ra_hir_ty/src/infer.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0fe876925e59aad4765b415d9caaf262a6d43c4c/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fe876925e59aad4765b415d9caaf262a6d43c4c/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer.rs?ref=0fe876925e59aad4765b415d9caaf262a6d43c4c", "patch": "@@ -218,6 +218,7 @@ struct InferenceContext<'a> {\n #[derive(Clone, Debug)]\n struct BreakableContext {\n     pub may_break: bool,\n+    pub break_ty: Ty,\n }\n \n impl<'a> InferenceContext<'a> {"}, {"sha": "c7aa67fbe1ed5dec6421f18c878212cd24d44f19", "filename": "crates/ra_hir_ty/src/infer/expr.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0fe876925e59aad4765b415d9caaf262a6d43c4c/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fe876925e59aad4765b415d9caaf262a6d43c4c/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=0fe876925e59aad4765b415d9caaf262a6d43c4c", "patch": "@@ -93,7 +93,7 @@ impl<'a> InferenceContext<'a> {\n                 Ty::Unknown\n             }\n             Expr::Loop { body } => {\n-                self.breakables.push(BreakableContext { may_break: false });\n+                self.breakables.push(BreakableContext { may_break: false, break_ty: Ty::Unknown });\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n \n                 let ctxt = self.breakables.pop().expect(\"breakable stack broken\");\n@@ -102,13 +102,13 @@ impl<'a> InferenceContext<'a> {\n                 }\n                 // FIXME handle break with value\n                 if ctxt.may_break {\n-                    Ty::unit()\n+                    ctxt.break_ty\n                 } else {\n                     Ty::simple(TypeCtor::Never)\n                 }\n             }\n             Expr::While { condition, body } => {\n-                self.breakables.push(BreakableContext { may_break: false });\n+                self.breakables.push(BreakableContext { may_break: false, break_ty: Ty::Unknown });\n                 // while let is desugared to a match loop, so this is always simple while\n                 self.infer_expr(*condition, &Expectation::has_type(Ty::simple(TypeCtor::Bool)));\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n@@ -120,7 +120,7 @@ impl<'a> InferenceContext<'a> {\n             Expr::For { iterable, body, pat } => {\n                 let iterable_ty = self.infer_expr(*iterable, &Expectation::none());\n \n-                self.breakables.push(BreakableContext { may_break: false });\n+                self.breakables.push(BreakableContext { may_break: false, break_ty: Ty::Unknown });\n                 let pat_ty =\n                     self.resolve_associated_type(iterable_ty, self.resolve_into_iter_item());\n \n@@ -229,12 +229,21 @@ impl<'a> InferenceContext<'a> {\n             }\n             Expr::Continue => Ty::simple(TypeCtor::Never),\n             Expr::Break { expr } => {\n+                let mut has_val_ty = None;\n+\n                 if let Some(expr) = expr {\n-                    // FIXME handle break with value\n-                    self.infer_expr(*expr, &Expectation::none());\n+                    has_val_ty = Some(self.infer_expr(*expr, &Expectation::none()));\n                 }\n+\n                 if let Some(ctxt) = self.breakables.last_mut() {\n                     ctxt.may_break = true;\n+                    if let Some(val_ty) = has_val_ty {\n+                        if ctxt.break_ty == Ty::Unknown {\n+                            ctxt.break_ty = val_ty;\n+                        } else if ctxt.break_ty != val_ty {\n+                            // TODO: Unify partially matching type information (Option<{unknown}> + Option<i32> => Option<i32>)\n+                        }\n+                    }\n                 } else {\n                     self.push_diagnostic(InferenceDiagnostic::BreakOutsideOfLoop {\n                         expr: tgt_expr,"}]}