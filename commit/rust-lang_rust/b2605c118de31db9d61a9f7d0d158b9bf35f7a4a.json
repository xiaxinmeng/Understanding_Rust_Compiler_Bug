{"sha": "b2605c118de31db9d61a9f7d0d158b9bf35f7a4a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyNjA1YzExOGRlMzFkYjlkNjFhOWY3ZDBkMTU4YjliZjM1ZjdhNGE=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-02-24T10:04:13Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-02-24T10:04:13Z"}, "message": "parser: `token` -> `normalized_token`, `nonnormalized_token` -> `token`", "tree": {"sha": "3e5a25d1132cbece626fb35ccf2d4a63bdddecbe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e5a25d1132cbece626fb35ccf2d4a63bdddecbe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2605c118de31db9d61a9f7d0d158b9bf35f7a4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2605c118de31db9d61a9f7d0d158b9bf35f7a4a", "html_url": "https://github.com/rust-lang/rust/commit/b2605c118de31db9d61a9f7d0d158b9bf35f7a4a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2605c118de31db9d61a9f7d0d158b9bf35f7a4a/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59261f0a7cf264f16e2b6a4e87d4249b212e920e", "url": "https://api.github.com/repos/rust-lang/rust/commits/59261f0a7cf264f16e2b6a4e87d4249b212e920e", "html_url": "https://github.com/rust-lang/rust/commit/59261f0a7cf264f16e2b6a4e87d4249b212e920e"}], "stats": {"total": 177, "additions": 88, "deletions": 89}, "files": [{"sha": "072c987a5230e7474012a1162f1bd87ec4e0e967", "filename": "src/librustc_builtin_macros/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b2605c118de31db9d61a9f7d0d158b9bf35f7a4a/src%2Flibrustc_builtin_macros%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2605c118de31db9d61a9f7d0d158b9bf35f7a4a/src%2Flibrustc_builtin_macros%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fformat.rs?ref=b2605c118de31db9d61a9f7d0d158b9bf35f7a4a", "patch": "@@ -158,7 +158,7 @@ fn parse_args<'a>(\n         } // accept trailing commas\n         if p.token.is_ident() && p.look_ahead(1, |t| *t == token::Eq) {\n             named = true;\n-            let name = if let token::Ident(name, _) = p.token.kind {\n+            let name = if let token::Ident(name, _) = p.normalized_token.kind {\n                 p.bump();\n                 name\n             } else {"}, {"sha": "2a53d600c5bcf729355af25f3066e4b702f37f3d", "filename": "src/librustc_expand/mbe/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2605c118de31db9d61a9f7d0d158b9bf35f7a4a/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2605c118de31db9d61a9f7d0d158b9bf35f7a4a/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs?ref=b2605c118de31db9d61a9f7d0d158b9bf35f7a4a", "patch": "@@ -889,9 +889,8 @@ fn parse_nt_inner<'a>(p: &mut Parser<'a>, sp: Span, name: Symbol) -> PResult<'a,\n         // this could be handled like a token, since it is one\n         sym::ident => {\n             if let Some((name, is_raw)) = get_macro_name(&p.token) {\n-                let span = p.token.span;\n                 p.bump();\n-                token::NtIdent(Ident::new(name, span), is_raw)\n+                token::NtIdent(Ident::new(name, p.normalized_prev_token.span), is_raw)\n             } else {\n                 let token_str = pprust::token_to_string(&p.token);\n                 let msg = &format!(\"expected ident, found {}\", &token_str);"}, {"sha": "00f5fb9705286e2a9641bac0d136a681b381c2d7", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b2605c118de31db9d61a9f7d0d158b9bf35f7a4a/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2605c118de31db9d61a9f7d0d158b9bf35f7a4a/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=b2605c118de31db9d61a9f7d0d158b9bf35f7a4a", "patch": "@@ -192,12 +192,12 @@ impl<'a> Parser<'a> {\n             TokenKind::CloseDelim(token::DelimToken::Brace),\n             TokenKind::CloseDelim(token::DelimToken::Paren),\n         ];\n-        if let token::Ident(name, false) = self.token.kind {\n-            if Ident::new(name, self.token.span).is_raw_guess()\n+        if let token::Ident(name, false) = self.normalized_token.kind {\n+            if Ident::new(name, self.normalized_token.span).is_raw_guess()\n                 && self.look_ahead(1, |t| valid_follow.contains(&t.kind))\n             {\n                 err.span_suggestion(\n-                    self.token.span,\n+                    self.normalized_token.span,\n                     \"you can escape reserved keywords to use them as identifiers\",\n                     format!(\"r#{}\", name),\n                     Applicability::MaybeIncorrect,"}, {"sha": "859e53127b7b05b1ce0b16aeb1385d91286134ef", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b2605c118de31db9d61a9f7d0d158b9bf35f7a4a/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2605c118de31db9d61a9f7d0d158b9bf35f7a4a/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=b2605c118de31db9d61a9f7d0d158b9bf35f7a4a", "patch": "@@ -97,15 +97,14 @@ impl<'a> Parser<'a> {\n     fn parse_expr_catch_underscore(&mut self) -> PResult<'a, P<Expr>> {\n         match self.parse_expr() {\n             Ok(expr) => Ok(expr),\n-            Err(mut err) => match self.token.kind {\n+            Err(mut err) => match self.normalized_token.kind {\n                 token::Ident(name, false)\n                     if name == kw::Underscore && self.look_ahead(1, |t| t == &token::Comma) =>\n                 {\n                     // Special-case handling of `foo(_, _, _)`\n                     err.emit();\n-                    let sp = self.token.span;\n                     self.bump();\n-                    Ok(self.mk_expr(sp, ExprKind::Err, AttrVec::new()))\n+                    Ok(self.mk_expr(self.prev_token.span, ExprKind::Err, AttrVec::new()))\n                 }\n                 _ => Err(err),\n             },\n@@ -166,7 +165,7 @@ impl<'a> Parser<'a> {\n         while let Some(op) = self.check_assoc_op() {\n             // Adjust the span for interpolated LHS to point to the `$lhs` token\n             // and not to what it refers to.\n-            let lhs_span = match self.unnormalized_prev_token.kind {\n+            let lhs_span = match self.prev_token.kind {\n                 TokenKind::Interpolated(..) => self.prev_span,\n                 _ => lhs.span,\n             };\n@@ -337,7 +336,7 @@ impl<'a> Parser<'a> {\n     /// Also performs recovery for `and` / `or` which are mistaken for `&&` and `||` respectively.\n     fn check_assoc_op(&self) -> Option<Spanned<AssocOp>> {\n         Some(Spanned {\n-            node: match (AssocOp::from_token(&self.token), &self.token.kind) {\n+            node: match (AssocOp::from_token(&self.token), &self.normalized_token.kind) {\n                 (Some(op), _) => op,\n                 (None, token::Ident(sym::and, false)) => {\n                     self.error_bad_logical_op(\"and\", \"&&\", \"conjunction\");\n@@ -349,7 +348,7 @@ impl<'a> Parser<'a> {\n                 }\n                 _ => return None,\n             },\n-            span: self.token.span,\n+            span: self.normalized_token.span,\n         })\n     }\n \n@@ -441,7 +440,7 @@ impl<'a> Parser<'a> {\n         let attrs = self.parse_or_use_outer_attributes(attrs)?;\n         let lo = self.token.span;\n         // Note: when adding new unary operators, don't forget to adjust TokenKind::can_begin_expr()\n-        let (hi, ex) = match self.token.kind {\n+        let (hi, ex) = match self.normalized_token.kind {\n             token::Not => self.parse_unary_expr(lo, UnOp::Not), // `!expr`\n             token::Tilde => self.recover_tilde_expr(lo),        // `~expr`\n             token::BinOp(token::Minus) => self.parse_unary_expr(lo, UnOp::Neg), // `-expr`\n@@ -527,7 +526,7 @@ impl<'a> Parser<'a> {\n     ) -> PResult<'a, (Span, P<Expr>)> {\n         expr.map(|e| {\n             (\n-                match self.unnormalized_prev_token.kind {\n+                match self.prev_token.kind {\n                     TokenKind::Interpolated(..) => self.prev_span,\n                     _ => e.span,\n                 },\n@@ -708,7 +707,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn parse_dot_suffix_expr(&mut self, lo: Span, base: P<Expr>) -> PResult<'a, P<Expr>> {\n-        match self.token.kind {\n+        match self.normalized_token.kind {\n             token::Ident(..) => self.parse_dot_suffix(base, lo),\n             token::Literal(token::Lit { kind: token::Integer, symbol, suffix }) => {\n                 Ok(self.parse_tuple_field_access_expr(lo, base, symbol, suffix))\n@@ -777,8 +776,8 @@ impl<'a> Parser<'a> {\n         field: Symbol,\n         suffix: Option<Symbol>,\n     ) -> P<Expr> {\n-        let span = self.token.span;\n         self.bump();\n+        let span = self.prev_token.span;\n         let field = ExprKind::Field(base, Ident::new(field, span));\n         self.expect_no_suffix(span, \"a tuple index\", suffix);\n         self.mk_expr(lo.to(span), field, AttrVec::new())\n@@ -802,7 +801,7 @@ impl<'a> Parser<'a> {\n \n     /// Assuming we have just parsed `.`, continue parsing into an expression.\n     fn parse_dot_suffix(&mut self, self_arg: P<Expr>, lo: Span) -> PResult<'a, P<Expr>> {\n-        if self.token.span.rust_2018() && self.eat_keyword(kw::Await) {\n+        if self.normalized_token.span.rust_2018() && self.eat_keyword(kw::Await) {\n             return self.mk_await_expr(self_arg, lo);\n         }\n \n@@ -916,7 +915,7 @@ impl<'a> Parser<'a> {\n             //       |             ^ expected expression\n             self.bump();\n             Ok(self.mk_expr_err(self.token.span))\n-        } else if self.token.span.rust_2018() {\n+        } else if self.normalized_token.span.rust_2018() {\n             // `Span::rust_2018()` is somewhat expensive; don't get it repeatedly.\n             if self.check_keyword(kw::Async) {\n                 if self.is_async_block() {\n@@ -1346,7 +1345,7 @@ impl<'a> Parser<'a> {\n             if self.eat_keyword(kw::Static) { Movability::Static } else { Movability::Movable };\n \n         let asyncness =\n-            if self.token.span.rust_2018() { self.parse_asyncness() } else { Async::No };\n+            if self.normalized_token.span.rust_2018() { self.parse_asyncness() } else { Async::No };\n         if asyncness.is_async() {\n             // Feature-gate `async ||` closures.\n             self.sess.gated_spans.gate(sym::async_closure, self.prev_span);\n@@ -1560,9 +1559,8 @@ impl<'a> Parser<'a> {\n \n     fn eat_label(&mut self) -> Option<Label> {\n         self.token.lifetime().map(|ident| {\n-            let span = self.token.span;\n             self.bump();\n-            Label { ident: Ident::new(ident.name, span) }\n+            Label { ident }\n         })\n     }\n \n@@ -1704,7 +1702,7 @@ impl<'a> Parser<'a> {\n     fn is_try_block(&self) -> bool {\n         self.token.is_keyword(kw::Try) &&\n         self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace)) &&\n-        self.token.span.rust_2018() &&\n+        self.normalized_token.span.rust_2018() &&\n         // Prevent `while try {} {}`, `if try {} {} else {}`, etc.\n         !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL)\n     }\n@@ -1854,13 +1852,12 @@ impl<'a> Parser<'a> {\n \n     /// Use in case of error after field-looking code: `S { foo: () with a }`.\n     fn find_struct_error_after_field_looking_code(&self) -> Option<Field> {\n-        if let token::Ident(name, _) = self.token.kind {\n+        if let token::Ident(name, _) = self.normalized_token.kind {\n             if !self.token.is_reserved_ident() && self.look_ahead(1, |t| *t == token::Colon) {\n-                let span = self.token.span;\n                 return Some(ast::Field {\n-                    ident: Ident::new(name, span),\n-                    span,\n-                    expr: self.mk_expr_err(span),\n+                    ident: Ident::new(name, self.normalized_token.span),\n+                    span: self.token.span,\n+                    expr: self.mk_expr_err(self.token.span),\n                     is_shorthand: false,\n                     attrs: AttrVec::new(),\n                     id: DUMMY_NODE_ID,"}, {"sha": "d62687f8945df58bbe7f7cf1c21a27ef7425bce3", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b2605c118de31db9d61a9f7d0d158b9bf35f7a4a/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2605c118de31db9d61a9f7d0d158b9bf35f7a4a/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=b2605c118de31db9d61a9f7d0d158b9bf35f7a4a", "patch": "@@ -747,11 +747,10 @@ impl<'a> Parser<'a> {\n     }\n \n     fn parse_ident_or_underscore(&mut self) -> PResult<'a, ast::Ident> {\n-        match self.token.kind {\n+        match self.normalized_token.kind {\n             token::Ident(name @ kw::Underscore, false) => {\n-                let span = self.token.span;\n                 self.bump();\n-                Ok(Ident::new(name, span))\n+                Ok(Ident::new(name, self.normalized_prev_token.span))\n             }\n             _ => self.parse_ident(),\n         }\n@@ -1545,7 +1544,7 @@ impl<'a> Parser<'a> {\n \n         let is_name_required = match self.token.kind {\n             token::DotDotDot => false,\n-            _ => req_name(&self.token),\n+            _ => req_name(&self.normalized_token),\n         };\n         let (pat, ty) = if is_name_required || self.is_named_param() {\n             debug!(\"parse_param_general parse_pat (is_name_required:{})\", is_name_required);\n@@ -1611,12 +1610,11 @@ impl<'a> Parser<'a> {\n     fn parse_self_param(&mut self) -> PResult<'a, Option<Param>> {\n         // Extract an identifier *after* having confirmed that the token is one.\n         let expect_self_ident = |this: &mut Self| {\n-            match this.token.kind {\n+            match this.normalized_token.kind {\n                 // Preserve hygienic context.\n                 token::Ident(name, _) => {\n-                    let span = this.token.span;\n                     this.bump();\n-                    Ident::new(name, span)\n+                    Ident::new(name, this.normalized_prev_token.span)\n                 }\n                 _ => unreachable!(),\n             }\n@@ -1653,7 +1651,7 @@ impl<'a> Parser<'a> {\n         // Only a limited set of initial token sequences is considered `self` parameters; anything\n         // else is parsed as a normal function parameter list, so some lookahead is required.\n         let eself_lo = self.token.span;\n-        let (eself, eself_ident, eself_hi) = match self.token.kind {\n+        let (eself, eself_ident, eself_hi) = match self.normalized_token.kind {\n             token::BinOp(token::And) => {\n                 let eself = if is_isolated_self(self, 1) {\n                     // `&self`"}, {"sha": "cf940233b59f8e7564954fc73d5d3ddac2696cc1", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b2605c118de31db9d61a9f7d0d158b9bf35f7a4a/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2605c118de31db9d61a9f7d0d158b9bf35f7a4a/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=b2605c118de31db9d61a9f7d0d158b9bf35f7a4a", "patch": "@@ -86,23 +86,22 @@ macro_rules! maybe_recover_from_interpolated_ty_qpath {\n #[derive(Clone)]\n pub struct Parser<'a> {\n     pub sess: &'a ParseSess,\n+    /// The current non-normalized token.\n+    pub token: Token,\n     /// The current normalized token.\n     /// \"Normalized\" means that some interpolated tokens\n     /// (`$i: ident` and `$l: lifetime` meta-variables) are replaced\n     /// with non-interpolated identifier and lifetime tokens they refer to.\n-    /// Use span from this token if you need an isolated span.\n-    pub token: Token,\n-    /// The current non-normalized token if it's different from `token`.\n-    /// Use span from this token if you need to concatenate it with some neighbouring spans.\n-    unnormalized_token: Token,\n+    /// Use this if you need to check for `token::Ident` or `token::Lifetime` specifically,\n+    /// this also includes edition checks for edition-specific keyword identifiers.\n+    pub normalized_token: Token,\n+    /// The previous non-normalized token.\n+    pub prev_token: Token,\n     /// The previous normalized token.\n-    /// Use span from this token if you need an isolated span.\n-    prev_token: Token,\n-    /// The previous non-normalized token if it's different from `prev_token`.\n-    /// Use span from this token if you need to concatenate it with some neighbouring spans.\n-    unnormalized_prev_token: Token,\n-    /// Equivalent to `unnormalized_prev_token.span`.\n-    /// FIXME: Remove in favor of `(unnormalized_)prev_token.span`.\n+    /// Use this if you need to check for `token::Ident` or `token::Lifetime` specifically,\n+    /// this also includes edition checks for edition-specific keyword identifiers.\n+    pub normalized_prev_token: Token,\n+    /// FIXME: Remove in favor of the equivalent `prev_token.span`.\n     pub prev_span: Span,\n     restrictions: Restrictions,\n     /// Used to determine the path to externally loaded source files.\n@@ -376,9 +375,9 @@ impl<'a> Parser<'a> {\n         let mut parser = Parser {\n             sess,\n             token: Token::dummy(),\n-            unnormalized_token: Token::dummy(),\n+            normalized_token: Token::dummy(),\n             prev_token: Token::dummy(),\n-            unnormalized_prev_token: Token::dummy(),\n+            normalized_prev_token: Token::dummy(),\n             prev_span: DUMMY_SP,\n             restrictions: Restrictions::empty(),\n             recurse_into_file_modules,\n@@ -483,7 +482,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn parse_ident_common(&mut self, recover: bool) -> PResult<'a, ast::Ident> {\n-        match self.token.kind {\n+        match self.normalized_token.kind {\n             token::Ident(name, _) => {\n                 if self.token.is_reserved_ident() {\n                     let mut err = self.expected_ident_found();\n@@ -493,9 +492,8 @@ impl<'a> Parser<'a> {\n                         return Err(err);\n                     }\n                 }\n-                let span = self.token.span;\n                 self.bump();\n-                Ok(Ident::new(name, span))\n+                Ok(Ident::new(name, self.normalized_prev_token.span))\n             }\n             _ => Err(match self.prev_token.kind {\n                 TokenKind::DocComment(..) => {\n@@ -825,16 +823,16 @@ impl<'a> Parser<'a> {\n     // tokens are replaced with usual identifier and lifetime tokens,\n     // so the former are never encountered during normal parsing.\n     crate fn set_token(&mut self, token: Token) {\n-        self.unnormalized_token = token;\n-        self.token = match &self.unnormalized_token.kind {\n+        self.token = token;\n+        self.normalized_token = match &self.token.kind {\n             token::Interpolated(nt) => match **nt {\n                 token::NtIdent(ident, is_raw) => {\n                     Token::new(token::Ident(ident.name, is_raw), ident.span)\n                 }\n                 token::NtLifetime(ident) => Token::new(token::Lifetime(ident.name), ident.span),\n-                _ => self.unnormalized_token.clone(),\n+                _ => self.token.clone(),\n             },\n-            _ => self.unnormalized_token.clone(),\n+            _ => self.token.clone(),\n         }\n     }\n \n@@ -848,19 +846,19 @@ impl<'a> Parser<'a> {\n \n         // Update the current and previous tokens.\n         self.prev_token = self.token.take();\n-        self.unnormalized_prev_token = self.unnormalized_token.take();\n+        self.normalized_prev_token = self.normalized_token.take();\n         self.set_token(next_token);\n \n         // Update fields derived from the previous token.\n-        self.prev_span = self.unnormalized_prev_token.span;\n+        self.prev_span = self.prev_token.span;\n \n         // Diagnostics.\n         self.expected_tokens.clear();\n     }\n \n     /// Advance the parser by one token.\n     pub fn bump(&mut self) {\n-        let next_token = self.next_tok(self.unnormalized_token.span);\n+        let next_token = self.next_tok(self.token.span);\n         self.bump_with(next_token);\n     }\n \n@@ -891,7 +889,7 @@ impl<'a> Parser<'a> {\n     /// Parses asyncness: `async` or nothing.\n     fn parse_asyncness(&mut self) -> Async {\n         if self.eat_keyword(kw::Async) {\n-            let span = self.prev_span;\n+            let span = self.normalized_prev_token.span;\n             Async::Yes { span, closure_id: DUMMY_NODE_ID, return_impl_trait_id: DUMMY_NODE_ID }\n         } else {\n             Async::No"}, {"sha": "f3a61ad4419785e18d41f3569230a3f95a63cf41", "filename": "src/librustc_parse/parser/path.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b2605c118de31db9d61a9f7d0d158b9bf35f7a4a/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2605c118de31db9d61a9f7d0d158b9bf35f7a4a/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpath.rs?ref=b2605c118de31db9d61a9f7d0d158b9bf35f7a4a", "patch": "@@ -134,7 +134,7 @@ impl<'a> Parser<'a> {\n             path\n         });\n \n-        let lo = self.unnormalized_token.span;\n+        let lo = self.token.span;\n         let mut segments = Vec::new();\n         let mod_sep_ctxt = self.token.span.ctxt();\n         if self.eat(&token::ModSep) {\n@@ -238,11 +238,10 @@ impl<'a> Parser<'a> {\n     }\n \n     pub(super) fn parse_path_segment_ident(&mut self) -> PResult<'a, Ident> {\n-        match self.token.kind {\n+        match self.normalized_token.kind {\n             token::Ident(name, _) if name.is_path_segment_keyword() => {\n-                let span = self.token.span;\n                 self.bump();\n-                Ok(Ident::new(name, span))\n+                Ok(Ident::new(name, self.normalized_prev_token.span))\n             }\n             _ => self.parse_ident(),\n         }"}, {"sha": "7b2fdebcfb91051f58995418a0817c366fe6a302", "filename": "src/librustc_parse/parser/ty.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b2605c118de31db9d61a9f7d0d158b9bf35f7a4a/src%2Flibrustc_parse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2605c118de31db9d61a9f7d0d158b9bf35f7a4a/src%2Flibrustc_parse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fty.rs?ref=b2605c118de31db9d61a9f7d0d158b9bf35f7a4a", "patch": "@@ -5,7 +5,7 @@ use crate::{maybe_recover_from_interpolated_ty_qpath, maybe_whole};\n use rustc_errors::{pluralize, struct_span_err, Applicability, PResult};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::{kw, sym};\n-use syntax::ast::{self, BareFnTy, FnRetTy, GenericParam, Ident, Lifetime, MutTy, Ty, TyKind};\n+use syntax::ast::{self, BareFnTy, FnRetTy, GenericParam, Lifetime, MutTy, Ty, TyKind};\n use syntax::ast::{\n     GenericBound, GenericBounds, PolyTraitRef, TraitBoundModifier, TraitObjectSyntax,\n };\n@@ -323,7 +323,7 @@ impl<'a> Parser<'a> {\n     /// Is a `dyn B0 + ... + Bn` type allowed here?\n     fn is_explicit_dyn_type(&mut self) -> bool {\n         self.check_keyword(kw::Dyn)\n-            && (self.token.span.rust_2018()\n+            && (self.normalized_token.span.rust_2018()\n                 || self.look_ahead(1, |t| {\n                     t.can_begin_bound() && !can_continue_type_after_non_fn_ident(t)\n                 }))\n@@ -604,9 +604,8 @@ impl<'a> Parser<'a> {\n     /// Parses a single lifetime `'a` or panics.\n     pub fn expect_lifetime(&mut self) -> Lifetime {\n         if let Some(ident) = self.token.lifetime() {\n-            let span = self.token.span;\n             self.bump();\n-            Lifetime { ident: Ident::new(ident.name, span), id: ast::DUMMY_NODE_ID }\n+            Lifetime { ident, id: ast::DUMMY_NODE_ID }\n         } else {\n             self.span_bug(self.token.span, \"not a lifetime\")\n         }"}, {"sha": "58a90b2fca2ca9b4b94044c0c56d32b7d1e2db72", "filename": "src/test/ui/borrowck/move-error-snippets.stderr", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b2605c118de31db9d61a9f7d0d158b9bf35f7a4a/src%2Ftest%2Fui%2Fborrowck%2Fmove-error-snippets.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b2605c118de31db9d61a9f7d0d158b9bf35f7a4a/src%2Ftest%2Fui%2Fborrowck%2Fmove-error-snippets.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fmove-error-snippets.stderr?ref=b2605c118de31db9d61a9f7d0d158b9bf35f7a4a", "patch": "@@ -1,14 +1,16 @@\n error[E0507]: cannot move out of static item `D`\n-  --> $DIR/move-error-snippets.rs:16:18\n+  --> $DIR/move-error-snippets-ext.rs:5:17\n    |\n-LL | | #[macro_use]\n-   | |__________________^ move occurs because `D` has type `A`, which does not implement the `Copy` trait\n-...\n-LL |               aaa!(D);\n-   |  __________________^\n-...\n-LL |   sss!();\n-   |   ------- in this macro invocation\n+LL |         let a = $c;\n+   |                 ^^\n+   |                 |\n+   |                 move occurs because `D` has type `A`, which does not implement the `Copy` trait\n+   |                 help: consider borrowing here: `&$c`\n+   | \n+  ::: $DIR/move-error-snippets.rs:21:1\n+   |\n+LL | sss!();\n+   | ------- in this macro invocation\n    |\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n "}, {"sha": "376c1a9cd66277f94a5936af6559aac8bc0a305e", "filename": "src/test/ui/directory_ownership/macro-expanded-mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2605c118de31db9d61a9f7d0d158b9bf35f7a4a/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmacro-expanded-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2605c118de31db9d61a9f7d0d158b9bf35f7a4a/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmacro-expanded-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmacro-expanded-mod.rs?ref=b2605c118de31db9d61a9f7d0d158b9bf35f7a4a", "patch": "@@ -1,7 +1,7 @@\n // Test that macro-expanded non-inline modules behave correctly\n \n macro_rules! mod_decl {\n-    ($i:ident) => { mod $i; }\n+    ($i:ident) => { mod $i; } //~ ERROR Cannot declare a non-inline module inside a block\n }\n \n mod macro_expanded_mod_helper {\n@@ -10,5 +10,4 @@ mod macro_expanded_mod_helper {\n \n fn main() {\n     mod_decl!(foo);\n-    //~^ ERROR Cannot declare a non-inline module inside a block\n }"}, {"sha": "c7780c869d635c55c9800240145e52c2502b2cf9", "filename": "src/test/ui/directory_ownership/macro-expanded-mod.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b2605c118de31db9d61a9f7d0d158b9bf35f7a4a/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmacro-expanded-mod.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b2605c118de31db9d61a9f7d0d158b9bf35f7a4a/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmacro-expanded-mod.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmacro-expanded-mod.stderr?ref=b2605c118de31db9d61a9f7d0d158b9bf35f7a4a", "patch": "@@ -1,8 +1,13 @@\n error: Cannot declare a non-inline module inside a block unless it has a path attribute\n-  --> $DIR/macro-expanded-mod.rs:12:15\n+  --> $DIR/macro-expanded-mod.rs:4:25\n    |\n+LL |     ($i:ident) => { mod $i; }\n+   |                         ^^\n+...\n LL |     mod_decl!(foo);\n-   |               ^^^\n+   |     --------------- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}, {"sha": "fd8846bb13c88de3193341b760e7645e9f12a021", "filename": "src/test/ui/hygiene/fields-definition.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b2605c118de31db9d61a9f7d0d158b9bf35f7a4a/src%2Ftest%2Fui%2Fhygiene%2Ffields-definition.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b2605c118de31db9d61a9f7d0d158b9bf35f7a4a/src%2Ftest%2Fui%2Fhygiene%2Ffields-definition.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Ffields-definition.stderr?ref=b2605c118de31db9d61a9f7d0d158b9bf35f7a4a", "patch": "@@ -1,10 +1,10 @@\n error[E0124]: field `a` is already declared\n-  --> $DIR/fields-definition.rs:14:17\n+  --> $DIR/fields-definition.rs:14:13\n    |\n LL |             a: u8,\n    |             ----- `a` first declared here\n LL |             $a: u8,\n-   |                 ^^ field already declared\n+   |             ^^^^^^ field already declared\n ...\n LL | legacy!(a);\n    | ----------- in this macro invocation"}, {"sha": "1964d739989ebafa57eb8094b8d341813a005eb1", "filename": "src/test/ui/issues/issue-39848.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b2605c118de31db9d61a9f7d0d158b9bf35f7a4a/src%2Ftest%2Fui%2Fissues%2Fissue-39848.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2605c118de31db9d61a9f7d0d158b9bf35f7a4a/src%2Ftest%2Fui%2Fissues%2Fissue-39848.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-39848.rs?ref=b2605c118de31db9d61a9f7d0d158b9bf35f7a4a", "patch": "@@ -1,10 +1,9 @@\n macro_rules! get_opt {\n     ($tgt:expr, $field:ident) => {\n-        if $tgt.has_$field() {}\n+        if $tgt.has_$field() {} //~ ERROR expected `{`, found `foo`\n     }\n }\n \n fn main() {\n     get_opt!(bar, foo);\n-    //~^ ERROR expected `{`, found `foo`\n }"}, {"sha": "0250c6b1fdd0f16aa040e8b6972c5a752d46c03f", "filename": "src/test/ui/issues/issue-39848.stderr", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b2605c118de31db9d61a9f7d0d158b9bf35f7a4a/src%2Ftest%2Fui%2Fissues%2Fissue-39848.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b2605c118de31db9d61a9f7d0d158b9bf35f7a4a/src%2Ftest%2Fui%2Fissues%2Fissue-39848.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-39848.stderr?ref=b2605c118de31db9d61a9f7d0d158b9bf35f7a4a", "patch": "@@ -1,13 +1,17 @@\n error: expected `{`, found `foo`\n-  --> $DIR/issue-39848.rs:8:19\n+  --> $DIR/issue-39848.rs:3:21\n    |\n LL |         if $tgt.has_$field() {}\n-   |         --                -- help: try placing this code inside a block: `{ () }`\n-   |         |\n+   |         --          ^^^^^^--\n+   |         |           |\n+   |         |           expected `{`\n+   |         |           help: try placing this code inside a block: `{ $field() }`\n    |         this `if` expression has a condition, but no block\n ...\n LL |     get_opt!(bar, foo);\n-   |                   ^^^ expected `{`\n+   |     ------------------- in this macro invocation\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error\n "}]}