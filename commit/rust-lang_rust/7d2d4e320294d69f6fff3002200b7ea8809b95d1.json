{"sha": "7d2d4e320294d69f6fff3002200b7ea8809b95d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkMmQ0ZTMyMDI5NGQ2OWY2ZmZmMzAwMjIwMGI3ZWE4ODA5Yjk1ZDE=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2018-01-16T09:16:38Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2018-03-08T07:34:08Z"}, "message": "Add InterpretInterner to StableHashingContext for AllocId serialization", "tree": {"sha": "9fb7eb37c4977c528d2b38d0bb5cc6dc27f4c81b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9fb7eb37c4977c528d2b38d0bb5cc6dc27f4c81b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d2d4e320294d69f6fff3002200b7ea8809b95d1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAlqg53AACgkQpp+NIls6\n19l2KRAAoLOUqNCrT0DeUOZa7c5rwHqcIaI4vfuT6rvi62elAP8W58+sdKfx06R5\nZw+JabNHN33eN66wzI0wDZoo2m1MmwBoHi0U8wLDAVldKarKGrG+Mw9mJWw/Psu9\nSr4Kc/CGjhMqI4sf02N7d3N8x6tCeQ8B4+Nfrp7q21wISWNpHFXZSh2bkzJhkAiu\nzexgpXGPwgt+s1JV/oOPm84ktUfoCRS4Wf0D/Jn4gw27Rpa+5lbosJf7eLY2cix4\n4D1l/Zdr3Vw8zEq+oojdXXsiSvHW8rSV2q+9WBF/mcJbc8YCMERx+ZnBh+W6ufKA\nn4VeKIfbNHs4yDK/InzmYk1Btm57hXYAzTeyjt1wusILOkQktF5TBhgKxli7ESgK\n6SV/aF1bAd0JeaVLqrOYpSRg9AhaZwyzsIsLwulpe2tLtlNKnd7bTdoiq+N5WC2e\nkudR+BxjZ+MN9OqtpmBR6yF/f7++Su3+3chfR4esZLZERGYliXDWy0YEkehi4MvC\nhXi9dNKnREzLP6gtI1yU5nhYjmyk/nSpeLa0aMt7i4UTeaEHDk/HYk5X7tgTYPNp\nYqKK8/SZMzZNt2nxJGjBcLuKtV82z4b4NvkMVI/M9j/E0RLUu36gwgVFPhxoUmQq\nFh+4UyMxlofrRM7pnsMAB6dFywk3uMGR4n9LL3a3ZN5A9m3LjyI=\n=5LG3\n-----END PGP SIGNATURE-----", "payload": "tree 9fb7eb37c4977c528d2b38d0bb5cc6dc27f4c81b\nparent e0045ab8915c85e35dd04e9f9d00d6d011237bfa\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1516094198 +0100\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1520494448 +0100\n\nAdd InterpretInterner to StableHashingContext for AllocId serialization\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d2d4e320294d69f6fff3002200b7ea8809b95d1", "html_url": "https://github.com/rust-lang/rust/commit/7d2d4e320294d69f6fff3002200b7ea8809b95d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d2d4e320294d69f6fff3002200b7ea8809b95d1/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0045ab8915c85e35dd04e9f9d00d6d011237bfa", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0045ab8915c85e35dd04e9f9d00d6d011237bfa", "html_url": "https://github.com/rust-lang/rust/commit/e0045ab8915c85e35dd04e9f9d00d6d011237bfa"}], "stats": {"total": 1146, "additions": 618, "deletions": 528}, "files": [{"sha": "7d8709a82f4d386af6256aa0710663a869111185", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=7d2d4e320294d69f6fff3002200b7ea8809b95d1", "patch": "@@ -661,7 +661,7 @@ trait DepNodeParams<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> : fmt::Debug {\n }\n \n impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a, T> DepNodeParams<'a, 'gcx, 'tcx> for T\n-    where T: HashStable<StableHashingContext<'gcx>> + fmt::Debug\n+    where T: HashStable<StableHashingContext<'a>> + fmt::Debug\n {\n     default const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n "}, {"sha": "3c523f5633e114fd9d405bff4f4ea10a07f71fa7", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=7d2d4e320294d69f6fff3002200b7ea8809b95d1", "patch": "@@ -529,7 +529,7 @@ struct HirItemLike<T> {\n     hash_bodies: bool,\n }\n \n-impl<'hir, T> HashStable<StableHashingContext<'hir>> for HirItemLike<T>\n+impl<'a, 'hir, T> HashStable<StableHashingContext<'hir>> for HirItemLike<T>\n     where T: HashStable<StableHashingContext<'hir>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,"}, {"sha": "6ae588b2a07b657229b3c1310e0cf3ce22954b40", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=7d2d4e320294d69f6fff3002200b7ea8809b95d1", "patch": "@@ -46,19 +46,19 @@ pub fn compute_ignored_attr_names() -> FxHashSet<Symbol> {\n /// a reference to the TyCtxt) and it holds a few caches for speeding up various\n /// things (e.g. each DefId/DefPath is only hashed once).\n #[derive(Clone)]\n-pub struct StableHashingContext<'gcx> {\n-    sess: &'gcx Session,\n-    definitions: &'gcx Definitions,\n-    cstore: &'gcx dyn CrateStore,\n-    body_resolver: BodyResolver<'gcx>,\n+pub struct StableHashingContext<'a> {\n+    sess: &'a Session,\n+    definitions: &'a Definitions,\n+    cstore: &'a dyn CrateStore,\n+    body_resolver: BodyResolver<'a>,\n     hash_spans: bool,\n     hash_bodies: bool,\n     node_id_hashing_mode: NodeIdHashingMode,\n \n     // Very often, we are hashing something that does not need the\n     // CachingCodemapView, so we initialize it lazily.\n-    raw_codemap: &'gcx CodeMap,\n-    caching_codemap: Option<CachingCodemapView<'gcx>>,\n+    raw_codemap: &'a CodeMap,\n+    caching_codemap: Option<CachingCodemapView<'a>>,\n }\n \n #[derive(PartialEq, Eq, Clone, Copy)]\n@@ -81,14 +81,14 @@ impl<'gcx> BodyResolver<'gcx> {\n     }\n }\n \n-impl<'gcx> StableHashingContext<'gcx> {\n+impl<'a> StableHashingContext<'a> {\n     // The `krate` here is only used for mapping BodyIds to Bodies.\n     // Don't use it for anything else or you'll run the risk of\n     // leaking data out of the tracking system.\n-    pub fn new(sess: &'gcx Session,\n-               krate: &'gcx hir::Crate,\n-               definitions: &'gcx Definitions,\n-               cstore: &'gcx dyn CrateStore)\n+    pub fn new(sess: &'a Session,\n+               krate: &'a hir::Crate,\n+               definitions: &'a Definitions,\n+               cstore: &'a dyn CrateStore)\n                -> Self {\n         let hash_spans_initial = !sess.opts.debugging_opts.incremental_ignore_spans;\n \n@@ -106,7 +106,7 @@ impl<'gcx> StableHashingContext<'gcx> {\n     }\n \n     #[inline]\n-    pub fn sess(&self) -> &'gcx Session {\n+    pub fn sess(&self) -> &'a Session {\n         self.sess\n     }\n \n@@ -165,7 +165,7 @@ impl<'gcx> StableHashingContext<'gcx> {\n     }\n \n     #[inline]\n-    pub fn codemap(&mut self) -> &mut CachingCodemapView<'gcx> {\n+    pub fn codemap(&mut self) -> &mut CachingCodemapView<'a> {\n         match self.caching_codemap {\n             Some(ref mut cm) => {\n                 cm\n@@ -193,38 +193,38 @@ impl<'gcx> StableHashingContext<'gcx> {\n }\n \n impl<'a, 'gcx, 'lcx> StableHashingContextProvider for TyCtxt<'a, 'gcx, 'lcx> {\n-    type ContextType = StableHashingContext<'gcx>;\n+    type ContextType = StableHashingContext<'a>;\n     fn create_stable_hashing_context(&self) -> Self::ContextType {\n         (*self).create_stable_hashing_context()\n     }\n }\n \n \n-impl<'gcx> StableHashingContextProvider for StableHashingContext<'gcx> {\n-    type ContextType = StableHashingContext<'gcx>;\n+impl<'a> StableHashingContextProvider for StableHashingContext<'a> {\n+    type ContextType = StableHashingContext<'a>;\n     fn create_stable_hashing_context(&self) -> Self::ContextType {\n         self.clone()\n     }\n }\n \n-impl<'gcx> ::dep_graph::DepGraphSafe for StableHashingContext<'gcx> {\n+impl<'a> ::dep_graph::DepGraphSafe for StableHashingContext<'a> {\n }\n \n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::BodyId {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::BodyId {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         if hcx.hash_bodies() {\n             hcx.body_resolver.body(*self).hash_stable(hcx, hasher);\n         }\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::HirId {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::HirId {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         match hcx.node_id_hashing_mode {\n             NodeIdHashingMode::Ignore => {\n@@ -243,21 +243,21 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::HirId {\n     }\n }\n \n-impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for hir::HirId {\n+impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::HirId {\n     type KeyType = (DefPathHash, hir::ItemLocalId);\n \n     #[inline]\n     fn to_stable_hash_key(&self,\n-                          hcx: &StableHashingContext<'gcx>)\n+                          hcx: &StableHashingContext<'a>)\n                           -> (DefPathHash, hir::ItemLocalId) {\n         let def_path_hash = hcx.local_def_path_hash(self.owner);\n         (def_path_hash, self.local_id)\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for ast::NodeId {\n+impl<'a> HashStable<StableHashingContext<'a>> for ast::NodeId {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         match hcx.node_id_hashing_mode {\n             NodeIdHashingMode::Ignore => {\n@@ -270,18 +270,18 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for ast::NodeId {\n     }\n }\n \n-impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for ast::NodeId {\n+impl<'a> ToStableHashKey<StableHashingContext<'a>> for ast::NodeId {\n     type KeyType = (DefPathHash, hir::ItemLocalId);\n \n     #[inline]\n     fn to_stable_hash_key(&self,\n-                          hcx: &StableHashingContext<'gcx>)\n+                          hcx: &StableHashingContext<'a>)\n                           -> (DefPathHash, hir::ItemLocalId) {\n         hcx.definitions.node_to_hir_id(*self).to_stable_hash_key(hcx)\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for Span {\n+impl<'a> HashStable<StableHashingContext<'a>> for Span {\n \n     // Hash a span in a stable way. We can't directly hash the span's BytePos\n     // fields (that would be similar to hashing pointers, since those are just\n@@ -293,7 +293,7 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Span {\n     // Also, hashing filenames is expensive so we avoid doing it twice when the\n     // span starts and ends in the same file, which is almost always the case.\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         const TAG_VALID_SPAN: u8 = 0;\n         const TAG_INVALID_SPAN: u8 = 1;\n@@ -373,8 +373,8 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Span {\n     }\n }\n \n-pub fn hash_stable_trait_impls<'gcx, W, R>(\n-    hcx: &mut StableHashingContext<'gcx>,\n+pub fn hash_stable_trait_impls<'a, 'gcx, W, R>(\n+    hcx: &mut StableHashingContext<'a>,\n     hasher: &mut StableHasher<W>,\n     blanket_impls: &Vec<DefId>,\n     non_blanket_impls: &HashMap<fast_reject::SimplifiedType, Vec<DefId>, R>)"}, {"sha": "c085b803085a853bb1eacbf6d630c577b0a28f86", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 66, "deletions": 66, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=7d2d4e320294d69f6fff3002200b7ea8809b95d1", "patch": "@@ -21,46 +21,46 @@ use std::mem;\n use syntax::ast;\n use syntax::attr;\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for DefId {\n+impl<'a> HashStable<StableHashingContext<'a>> for DefId {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.def_path_hash(*self).hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for DefId {\n+impl<'a> ToStableHashKey<StableHashingContext<'a>> for DefId {\n     type KeyType = DefPathHash;\n \n     #[inline]\n-    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'gcx>) -> DefPathHash {\n+    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'a>) -> DefPathHash {\n         hcx.def_path_hash(*self)\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for LocalDefId {\n+impl<'a> HashStable<StableHashingContext<'a>> for LocalDefId {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.def_path_hash(self.to_def_id()).hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for LocalDefId {\n+impl<'a> ToStableHashKey<StableHashingContext<'a>> for LocalDefId {\n     type KeyType = DefPathHash;\n \n     #[inline]\n-    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'gcx>) -> DefPathHash {\n+    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'a>) -> DefPathHash {\n         hcx.def_path_hash(self.to_def_id())\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for CrateNum {\n+impl<'a> HashStable<StableHashingContext<'a>> for CrateNum {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.def_path_hash(DefId {\n             krate: *self,\n@@ -69,25 +69,25 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for CrateNum {\n     }\n }\n \n-impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for CrateNum {\n+impl<'a> ToStableHashKey<StableHashingContext<'a>> for CrateNum {\n     type KeyType = DefPathHash;\n \n     #[inline]\n-    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'gcx>) -> DefPathHash {\n+    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'a>) -> DefPathHash {\n         let def_id = DefId { krate: *self, index: CRATE_DEF_INDEX };\n         def_id.to_stable_hash_key(hcx)\n     }\n }\n \n impl_stable_hash_for!(tuple_struct hir::ItemLocalId { index });\n \n-impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>>\n+impl<'a> ToStableHashKey<StableHashingContext<'a>>\n for hir::ItemLocalId {\n     type KeyType = hir::ItemLocalId;\n \n     #[inline]\n     fn to_stable_hash_key(&self,\n-                          _: &StableHashingContext<'gcx>)\n+                          _: &StableHashingContext<'a>)\n                           -> hir::ItemLocalId {\n         *self\n     }\n@@ -100,9 +100,9 @@ for hir::ItemLocalId {\n // want to pick up on a reference changing its target, so we hash the NodeIds\n // in \"DefPath Mode\".\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::ItemId {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::ItemId {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::ItemId {\n             id\n@@ -114,9 +114,9 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::ItemId {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::TraitItemId {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitItemId {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::TraitItemId {\n             node_id\n@@ -128,9 +128,9 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::TraitItemId {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::ImplItemId {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::ImplItemId {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::ImplItemId {\n             node_id\n@@ -271,9 +271,9 @@ impl_stable_hash_for!(struct hir::TypeBinding {\n     span\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Ty {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::Ty {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.while_hashing_hir_bodies(true, |hcx| {\n             let hir::Ty {\n@@ -339,9 +339,9 @@ impl_stable_hash_for!(enum hir::FunctionRetTy {\n     Return(t)\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::TraitRef {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitRef {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::TraitRef {\n             ref path,\n@@ -376,9 +376,9 @@ impl_stable_hash_for!(struct hir::MacroDef {\n });\n \n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Block {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::Block {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::Block {\n             ref stmts,\n@@ -400,9 +400,9 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Block {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Pat {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::Pat {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::Pat {\n             id: _,\n@@ -527,9 +527,9 @@ impl_stable_hash_for!(enum hir::UnsafeSource {\n     UserProvided\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Expr {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::Expr {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.while_hashing_hir_bodies(true, |hcx| {\n             let hir::Expr {\n@@ -591,9 +591,9 @@ impl_stable_hash_for!(enum hir::LoopSource {\n     ForLoop\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::MatchSource {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::MatchSource {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use hir::MatchSource;\n \n@@ -647,9 +647,9 @@ impl_stable_hash_for!(enum hir::ScopeTarget {\n     Loop(loop_id_result)\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for ast::Ident {\n+impl<'a> HashStable<StableHashingContext<'a>> for ast::Ident {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let ast::Ident {\n             ref name,\n@@ -660,9 +660,9 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for ast::Ident {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::TraitItem {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitItem {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::TraitItem {\n             id: _,\n@@ -695,9 +695,9 @@ impl_stable_hash_for!(enum hir::TraitItemKind {\n     Type(bounds, rhs)\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::ImplItem {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::ImplItem {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::ImplItem {\n             id: _,\n@@ -729,9 +729,9 @@ impl_stable_hash_for!(enum hir::ImplItemKind {\n     Type(t)\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Visibility {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::Visibility {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -750,9 +750,9 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Visibility {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Defaultness {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::Defaultness {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -771,9 +771,9 @@ impl_stable_hash_for!(enum hir::ImplPolarity {\n     Negative\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Mod {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::Mod {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::Mod {\n             inner,\n@@ -826,9 +826,9 @@ impl_stable_hash_for!(enum hir::VariantData {\n     Unit(id)\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Item {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::Item {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::Item {\n             name,\n@@ -885,10 +885,10 @@ impl_stable_hash_for!(struct hir::ImplItemRef {\n     defaultness\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a> HashStable<StableHashingContext<'a>>\n for hir::AssociatedItemKind {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -930,9 +930,9 @@ impl_stable_hash_for!(struct hir::Arg {\n     hir_id\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Body {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::Body {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::Body {\n             ref arguments,\n@@ -948,12 +948,12 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Body {\n     }\n }\n \n-impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for hir::BodyId {\n+impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::BodyId {\n     type KeyType = (DefPathHash, hir::ItemLocalId);\n \n     #[inline]\n     fn to_stable_hash_key(&self,\n-                          hcx: &StableHashingContext<'gcx>)\n+                          hcx: &StableHashingContext<'a>)\n                           -> (DefPathHash, hir::ItemLocalId) {\n         let hir::BodyId { node_id } = *self;\n         node_id.to_stable_hash_key(hcx)\n@@ -966,9 +966,9 @@ impl_stable_hash_for!(struct hir::InlineAsmOutput {\n     is_indirect\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::GlobalAsm {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::GlobalAsm {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::GlobalAsm {\n             asm,\n@@ -979,9 +979,9 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::GlobalAsm {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::InlineAsm {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::InlineAsm {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::InlineAsm {\n             asm,\n@@ -1062,22 +1062,22 @@ impl_stable_hash_for!(enum hir::Constness {\n     NotConst\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a> HashStable<StableHashingContext<'a>>\n for hir::def_id::DefIndex {\n \n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.local_def_path_hash(*self).hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>>\n+impl<'a> ToStableHashKey<StableHashingContext<'a>>\n for hir::def_id::DefIndex {\n     type KeyType = DefPathHash;\n \n     #[inline]\n-    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'gcx>) -> DefPathHash {\n+    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'a>) -> DefPathHash {\n          hcx.local_def_path_hash(*self)\n     }\n }\n@@ -1090,10 +1090,10 @@ impl_stable_hash_for!(struct hir::def::Export {\n     is_import\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a> HashStable<StableHashingContext<'a>>\n for ::middle::lang_items::LangItem {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          _: &mut StableHashingContext<'gcx>,\n+                                          _: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         ::std::hash::Hash::hash(self, hasher);\n     }\n@@ -1104,10 +1104,10 @@ impl_stable_hash_for!(struct ::middle::lang_items::LanguageItems {\n     missing\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a> HashStable<StableHashingContext<'a>>\n for hir::TraitCandidate {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n             let hir::TraitCandidate {\n@@ -1121,11 +1121,11 @@ for hir::TraitCandidate {\n     }\n }\n \n-impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for hir::TraitCandidate {\n+impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::TraitCandidate {\n     type KeyType = (DefPathHash, Option<(DefPathHash, hir::ItemLocalId)>);\n \n     fn to_stable_hash_key(&self,\n-                          hcx: &StableHashingContext<'gcx>)\n+                          hcx: &StableHashingContext<'a>)\n                           -> Self::KeyType {\n         let hir::TraitCandidate {\n             def_id,"}, {"sha": "1e6dadae363717729d0e567fdd07686f965d725e", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=7d2d4e320294d69f6fff3002200b7ea8809b95d1", "patch": "@@ -35,11 +35,11 @@ impl_stable_hash_for!(struct mir::BasicBlockData<'tcx> { statements, terminator,\n impl_stable_hash_for!(struct mir::UnsafetyViolation { source_info, description, kind });\n impl_stable_hash_for!(struct mir::UnsafetyCheckResult { violations, unsafe_blocks });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a> HashStable<StableHashingContext<'a>>\n for mir::BorrowKind {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -54,11 +54,11 @@ for mir::BorrowKind {\n }\n \n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a> HashStable<StableHashingContext<'a>>\n for mir::UnsafetyViolationKind {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n \n         mem::discriminant(self).hash_stable(hcx, hasher);\n@@ -79,12 +79,12 @@ impl_stable_hash_for!(struct mir::Terminator<'tcx> {\n     source_info\n });\n \n-impl<'gcx, T> HashStable<StableHashingContext<'gcx>> for mir::ClearCrossCrate<T>\n-    where T: HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>> for mir::ClearCrossCrate<T>\n+    where T: HashStable<StableHashingContext<'a>>\n {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -96,61 +96,61 @@ impl<'gcx, T> HashStable<StableHashingContext<'gcx>> for mir::ClearCrossCrate<T>\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Local {\n+impl<'a> HashStable<StableHashingContext<'a>> for mir::Local {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use rustc_data_structures::indexed_vec::Idx;\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::BasicBlock {\n+impl<'a> HashStable<StableHashingContext<'a>> for mir::BasicBlock {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use rustc_data_structures::indexed_vec::Idx;\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Field {\n+impl<'a> HashStable<StableHashingContext<'a>> for mir::Field {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use rustc_data_structures::indexed_vec::Idx;\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a> HashStable<StableHashingContext<'a>>\n for mir::VisibilityScope {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use rustc_data_structures::indexed_vec::Idx;\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Promoted {\n+impl<'a> HashStable<StableHashingContext<'a>> for mir::Promoted {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use rustc_data_structures::indexed_vec::Idx;\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for mir::TerminatorKind<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -227,10 +227,10 @@ for mir::TerminatorKind<'gcx> {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for mir::AssertMessage<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -250,10 +250,10 @@ for mir::AssertMessage<'gcx> {\n \n impl_stable_hash_for!(struct mir::Statement<'tcx> { source_info, kind });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for mir::StatementKind<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -287,12 +287,12 @@ for mir::StatementKind<'gcx> {\n     }\n }\n \n-impl<'gcx, T> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>>\n     for mir::ValidationOperand<'gcx, T>\n-    where T: HashStable<StableHashingContext<'gcx>>\n+    where T: HashStable<StableHashingContext<'a>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>)\n     {\n         self.place.hash_stable(hcx, hasher);\n@@ -304,9 +304,9 @@ impl<'gcx, T> HashStable<StableHashingContext<'gcx>>\n \n impl_stable_hash_for!(enum mir::ValidationOp { Acquire, Release, Suspend(region_scope) });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Place<'gcx> {\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::Place<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -323,14 +323,14 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Place<'gcx> {\n     }\n }\n \n-impl<'gcx, B, V, T> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx, B, V, T> HashStable<StableHashingContext<'a>>\n for mir::Projection<'gcx, B, V, T>\n-    where B: HashStable<StableHashingContext<'gcx>>,\n-          V: HashStable<StableHashingContext<'gcx>>,\n-          T: HashStable<StableHashingContext<'gcx>>\n+    where B: HashStable<StableHashingContext<'a>>,\n+          V: HashStable<StableHashingContext<'a>>,\n+          T: HashStable<StableHashingContext<'a>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let mir::Projection {\n             ref base,\n@@ -342,13 +342,13 @@ for mir::Projection<'gcx, B, V, T>\n     }\n }\n \n-impl<'gcx, V, T> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx, V, T> HashStable<StableHashingContext<'a>>\n for mir::ProjectionElem<'gcx, V, T>\n-    where V: HashStable<StableHashingContext<'gcx>>,\n-          T: HashStable<StableHashingContext<'gcx>>\n+    where V: HashStable<StableHashingContext<'a>>,\n+          T: HashStable<StableHashingContext<'a>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -382,9 +382,9 @@ impl_stable_hash_for!(struct mir::VisibilityScopeInfo {\n     lint_root, safety\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Safety {\n+impl<'a> HashStable<StableHashingContext<'a>> for mir::Safety {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -399,9 +399,9 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Safety {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Operand<'gcx> {\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::Operand<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -419,9 +419,9 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Operand<'gcx> {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Rvalue<'gcx> {\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::Rvalue<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -479,10 +479,10 @@ impl_stable_hash_for!(enum mir::CastKind {\n     Unsize\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for mir::AggregateKind<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -541,9 +541,9 @@ impl_stable_hash_for!(enum mir::NullOp {\n \n impl_stable_hash_for!(struct mir::Constant<'tcx> { span, ty, literal });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Literal<'gcx> {\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::Literal<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -570,9 +570,9 @@ impl_stable_hash_for!(struct mir::ClosureOutlivesRequirement<'tcx> {\n     blame_span\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::ClosureOutlivesSubject<'gcx> {\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::ClosureOutlivesSubject<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {"}, {"sha": "52f43fbed7b0acb3e8f255afebb7153847df042b", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=7d2d4e320294d69f6fff3002200b7ea8809b95d1", "patch": "@@ -29,42 +29,42 @@ use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey,\n                                            StableHasher, StableHasherResult};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for InternedString {\n+impl<'a> HashStable<StableHashingContext<'a>> for InternedString {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let s: &str = &**self;\n         s.hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for InternedString {\n+impl<'a> ToStableHashKey<StableHashingContext<'a>> for InternedString {\n     type KeyType = InternedString;\n \n     #[inline]\n     fn to_stable_hash_key(&self,\n-                          _: &StableHashingContext<'gcx>)\n+                          _: &StableHashingContext<'a>)\n                           -> InternedString {\n         self.clone()\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for ast::Name {\n+impl<'a> HashStable<StableHashingContext<'a>> for ast::Name {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         self.as_str().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for ast::Name {\n+impl<'a> ToStableHashKey<StableHashingContext<'a>> for ast::Name {\n     type KeyType = InternedString;\n \n     #[inline]\n     fn to_stable_hash_key(&self,\n-                          _: &StableHashingContext<'gcx>)\n+                          _: &StableHashingContext<'a>)\n                           -> InternedString {\n         self.as_str()\n     }\n@@ -111,10 +111,10 @@ impl_stable_hash_for!(struct ::syntax::attr::Stability {\n     rustc_const_unstable\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a> HashStable<StableHashingContext<'a>>\n for ::syntax::attr::StabilityLevel {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -166,9 +166,9 @@ impl_stable_hash_for!(struct ::syntax::ast::Lifetime { id, span, ident });\n impl_stable_hash_for!(enum ::syntax::ast::StrStyle { Cooked, Raw(pounds) });\n impl_stable_hash_for!(enum ::syntax::ast::AttrStyle { Outer, Inner });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for [ast::Attribute] {\n+impl<'a> HashStable<StableHashingContext<'a>> for [ast::Attribute] {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         if self.len() == 0 {\n             self.len().hash_stable(hcx, hasher);\n@@ -191,9 +191,9 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for [ast::Attribute] {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for ast::Attribute {\n+impl<'a> HashStable<StableHashingContext<'a>> for ast::Attribute {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         // Make sure that these have been filtered out.\n         debug_assert!(self.name().map(|name| !hcx.is_ignored_attr(name)).unwrap_or(true));\n@@ -220,10 +220,10 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for ast::Attribute {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a> HashStable<StableHashingContext<'a>>\n for tokenstream::TokenTree {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -242,20 +242,22 @@ for tokenstream::TokenTree {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a> HashStable<StableHashingContext<'a>>\n for tokenstream::TokenStream {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         for sub_tt in self.trees() {\n             sub_tt.hash_stable(hcx, hasher);\n         }\n     }\n }\n \n-fn hash_token<'gcx, W: StableHasherResult>(token: &token::Token,\n-                                           hcx: &mut StableHashingContext<'gcx>,\n-                                           hasher: &mut StableHasher<W>) {\n+fn hash_token<'a, 'gcx, W: StableHasherResult>(\n+    token: &token::Token,\n+    hcx: &mut StableHashingContext<'a>,\n+    hasher: &mut StableHasher<W>,\n+) {\n     mem::discriminant(token).hash_stable(hcx, hasher);\n     match *token {\n         token::Token::Eq |\n@@ -383,9 +385,9 @@ impl_stable_hash_for!(enum ::syntax_pos::FileName {\n     Custom(s)\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for FileMap {\n+impl<'a> HashStable<StableHashingContext<'a>> for FileMap {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let FileMap {\n             name: _, // We hash the smaller name_hash instead of this"}, {"sha": "a92d9b16612a22c005739ec382f0f731c2518134", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 125, "deletions": 81, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=7d2d4e320294d69f6fff3002200b7ea8809b95d1", "patch": "@@ -23,11 +23,11 @@ use traits;\n use ty;\n use mir;\n \n-impl<'gcx, T> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>>\n for &'gcx ty::Slice<T>\n-    where T: HashStable<StableHashingContext<'gcx>> {\n+    where T: HashStable<StableHashingContext<'a>> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         thread_local! {\n             static CACHE: RefCell<FxHashMap<(usize, usize), Fingerprint>> =\n@@ -52,10 +52,10 @@ for &'gcx ty::Slice<T>\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for ty::subst::Kind<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         self.unpack().hash_stable(hcx, hasher);\n     }\n@@ -73,10 +73,10 @@ for ty::subst::UnpackedKind<'gcx> {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a> HashStable<StableHashingContext<'a>>\n for ty::RegionKind {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -120,20 +120,20 @@ for ty::RegionKind {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::RegionVid {\n+impl<'a> HashStable<StableHashingContext<'a>> for ty::RegionVid {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use rustc_data_structures::indexed_vec::Idx;\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for ty::adjustment::AutoBorrow<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -148,10 +148,10 @@ for ty::adjustment::AutoBorrow<'gcx> {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for ty::adjustment::Adjust<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -197,10 +197,10 @@ impl_stable_hash_for!(enum ty::BorrowKind {\n     MutBorrow\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for ty::UpvarCapture<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -224,11 +224,11 @@ impl_stable_hash_for!(struct ty::FnSig<'tcx> {\n     abi\n });\n \n-impl<'gcx, T> HashStable<StableHashingContext<'gcx>> for ty::Binder<T>\n-    where T: HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>> for ty::Binder<T>\n+    where T: HashStable<StableHashingContext<'a>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::Binder(ref inner) = *self;\n         inner.hash_stable(hcx, hasher);\n@@ -247,13 +247,13 @@ impl_stable_hash_for!(struct ty::TraitRef<'tcx> { def_id, substs });\n impl_stable_hash_for!(struct ty::TraitPredicate<'tcx> { trait_ref });\n impl_stable_hash_for!(struct ty::SubtypePredicate<'tcx> { a_is_expected, a, b });\n \n-impl<'gcx, A, B> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx, A, B> HashStable<StableHashingContext<'a>>\n for ty::OutlivesPredicate<A, B>\n-    where A: HashStable<StableHashingContext<'gcx>>,\n-          B: HashStable<StableHashingContext<'gcx>>,\n+    where A: HashStable<StableHashingContext<'a>>,\n+          B: HashStable<StableHashingContext<'a>>,\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::OutlivesPredicate(ref a, ref b) = *self;\n         a.hash_stable(hcx, hasher);\n@@ -265,9 +265,9 @@ impl_stable_hash_for!(struct ty::ProjectionPredicate<'tcx> { projection_ty, ty }\n impl_stable_hash_for!(struct ty::ProjectionTy<'tcx> { substs, item_def_id });\n \n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::Predicate<'gcx> {\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for ty::Predicate<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -305,9 +305,9 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::Predicate<'gcx> {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::AdtFlags {\n+impl<'a> HashStable<StableHashingContext<'a>> for ty::AdtFlags {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          _: &mut StableHashingContext<'gcx>,\n+                                          _: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         std_hash::Hash::hash(self, hasher);\n     }\n@@ -332,10 +332,10 @@ impl_stable_hash_for!(struct ty::FieldDef {\n     vis\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for ::middle::const_val::ConstVal<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use middle::const_val::ConstVal::*;\n \n@@ -368,7 +368,51 @@ impl_stable_hash_for!(struct mir::interpret::MemoryPointer {\n     offset\n });\n \n-impl_stable_hash_for!(tuple_struct mir::interpret::AllocId{id});\n+impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::AllocId {\n+    fn hash_stable<W: StableHasherResult>(\n+        &self,\n+        hcx: &mut StableHashingContext<'a>,\n+        hasher: &mut StableHasher<W>,\n+    ) {\n+        ty::tls::with_opt(|tcx| {\n+            let tcx = tcx.expect(\"can't hash AllocIds during hir lowering\");\n+            let interner = tcx\n+                .interpret_interner\n+                .borrow();\n+            if let Some(def_id) = interner.get_corresponding_static_def_id(*self) {\n+                0.hash_stable(hcx, hasher);\n+                // statics are unique via their DefId\n+                def_id.hash_stable(hcx, hasher);\n+            } else if let Some(alloc) = interner.get_alloc(*self) {\n+                // not a static, can't be recursive, hash the allocation\n+                1.hash_stable(hcx, hasher);\n+                alloc.hash_stable(hcx, hasher);\n+            } else if let Some(inst) = interner.get_fn(*self) {\n+                2.hash_stable(hcx, hasher);\n+                inst.hash_stable(hcx, hasher);\n+            } else {\n+                bug!(\"no allocation for {}\", self);\n+            }\n+        });\n+    }\n+}\n+\n+impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::Allocation {\n+    fn hash_stable<W: StableHasherResult>(\n+        &self,\n+        hcx: &mut StableHashingContext<'a>,\n+        hasher: &mut StableHasher<W>,\n+    ) {\n+        self.bytes.hash_stable(hcx, hasher);\n+        for reloc in self.relocations.iter() {\n+            reloc.hash_stable(hcx, hasher);\n+        }\n+        self.undef_mask.hash_stable(hcx, hasher);\n+        self.align.hash_stable(hcx, hasher);\n+        self.mutable.hash_stable(hcx, hasher);\n+    }\n+}\n+\n impl_stable_hash_for!(struct mir::interpret::Pointer{primval});\n \n impl_stable_hash_for!(enum mir::interpret::PrimVal {\n@@ -387,10 +431,10 @@ impl_stable_hash_for!(struct ::middle::const_val::ConstEvalErr<'tcx> {\n     kind\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for ::middle::const_val::ErrKind<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use middle::const_val::ErrKind::*;\n \n@@ -441,10 +485,10 @@ impl_stable_hash_for!(struct ty::GenericPredicates<'tcx> {\n     predicates\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for ::mir::interpret::EvalError<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use mir::interpret::EvalErrorKind::*;\n \n@@ -621,9 +665,9 @@ impl_stable_hash_for!(enum ty::adjustment::CustomCoerceUnsized {\n     Struct(index)\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::Generics {\n+impl<'a> HashStable<StableHashingContext<'a>> for ty::Generics {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::Generics {\n             parent,\n@@ -649,10 +693,10 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::Generics {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a> HashStable<StableHashingContext<'a>>\n for ty::RegionParameterDef {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::RegionParameterDef {\n             name,\n@@ -678,12 +722,12 @@ impl_stable_hash_for!(struct ty::TypeParameterDef {\n     synthetic\n });\n \n-impl<'gcx, T> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>>\n for ::middle::resolve_lifetime::Set1<T>\n-    where T: HashStable<StableHashingContext<'gcx>>\n+    where T: HashStable<StableHashingContext<'a>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use middle::resolve_lifetime::Set1;\n \n@@ -734,11 +778,11 @@ impl_stable_hash_for!(enum ty::cast::CastKind {\n impl_stable_hash_for!(tuple_struct ::middle::region::FirstStatementIndex { idx });\n impl_stable_hash_for!(struct ::middle::region::Scope { id, code });\n \n-impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for region::Scope {\n+impl<'a> ToStableHashKey<StableHashingContext<'a>> for region::Scope {\n     type KeyType = region::Scope;\n \n     #[inline]\n-    fn to_stable_hash_key(&self, _: &StableHashingContext<'gcx>) -> region::Scope {\n+    fn to_stable_hash_key(&self, _: &StableHashingContext<'a>) -> region::Scope {\n         *self\n     }\n }\n@@ -764,11 +808,11 @@ impl_stable_hash_for!(enum ty::BoundRegion {\n     BrEnv\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for ty::TypeVariants<'gcx>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use ty::TypeVariants::*;\n \n@@ -865,11 +909,11 @@ impl_stable_hash_for!(struct ty::TypeAndMut<'tcx> {\n     mutbl\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for ty::ExistentialPredicate<'gcx>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -902,9 +946,9 @@ impl_stable_hash_for!(struct ty::Instance<'tcx> {\n     substs\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::InstanceDef<'gcx> {\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for ty::InstanceDef<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -938,9 +982,9 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::InstanceDef<'gcx> {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::TraitDef {\n+impl<'a> HashStable<StableHashingContext<'a>> for ty::TraitDef {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::TraitDef {\n             // We already have the def_path_hash below, no need to hash it twice\n@@ -968,9 +1012,9 @@ impl_stable_hash_for!(struct ty::DtorckConstraint<'tcx> {\n });\n \n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::CrateVariancesMap {\n+impl<'a> HashStable<StableHashingContext<'a>> for ty::CrateVariancesMap {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::CrateVariancesMap {\n             ref variances,\n@@ -1004,12 +1048,12 @@ impl_stable_hash_for!(enum ty::AssociatedItemContainer {\n });\n \n \n-impl<'gcx, T> HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>>\n for ty::steal::Steal<T>\n-    where T: HashStable<StableHashingContext<'gcx>>\n+    where T: HashStable<StableHashingContext<'a>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         self.borrow().hash_stable(hcx, hasher);\n     }\n@@ -1032,10 +1076,10 @@ impl_stable_hash_for!(enum ::middle::privacy::AccessLevel {\n     Public\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+impl<'a> HashStable<StableHashingContext<'a>>\n for ::middle::privacy::AccessLevels {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n             let ::middle::privacy::AccessLevels {\n@@ -1062,10 +1106,10 @@ impl_stable_hash_for!(tuple_struct ::middle::reachable::ReachableSet {\n     reachable_set\n });\n \n-impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n-for traits::Vtable<'gcx, N> where N: HashStable<StableHashingContext<'gcx>> {\n+impl<'a, 'gcx, N> HashStable<StableHashingContext<'a>>\n+for traits::Vtable<'gcx, N> where N: HashStable<StableHashingContext<'a>> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use traits::Vtable::*;\n \n@@ -1084,10 +1128,10 @@ for traits::Vtable<'gcx, N> where N: HashStable<StableHashingContext<'gcx>> {\n     }\n }\n \n-impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n-for traits::VtableImplData<'gcx, N> where N: HashStable<StableHashingContext<'gcx>> {\n+impl<'a, 'gcx, N> HashStable<StableHashingContext<'a>>\n+for traits::VtableImplData<'gcx, N> where N: HashStable<StableHashingContext<'a>> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let traits::VtableImplData {\n             impl_def_id,\n@@ -1100,10 +1144,10 @@ for traits::VtableImplData<'gcx, N> where N: HashStable<StableHashingContext<'gc\n     }\n }\n \n-impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n-for traits::VtableAutoImplData<N> where N: HashStable<StableHashingContext<'gcx>> {\n+impl<'a, 'gcx, N> HashStable<StableHashingContext<'a>>\n+for traits::VtableAutoImplData<N> where N: HashStable<StableHashingContext<'a>> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let traits::VtableAutoImplData {\n             trait_def_id,\n@@ -1114,10 +1158,10 @@ for traits::VtableAutoImplData<N> where N: HashStable<StableHashingContext<'gcx>\n     }\n }\n \n-impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n-for traits::VtableObjectData<'gcx, N> where N: HashStable<StableHashingContext<'gcx>> {\n+impl<'a, 'gcx, N> HashStable<StableHashingContext<'a>>\n+for traits::VtableObjectData<'gcx, N> where N: HashStable<StableHashingContext<'a>> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let traits::VtableObjectData {\n             upcast_trait_ref,\n@@ -1130,10 +1174,10 @@ for traits::VtableObjectData<'gcx, N> where N: HashStable<StableHashingContext<'\n     }\n }\n \n-impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n-for traits::VtableBuiltinData<N> where N: HashStable<StableHashingContext<'gcx>> {\n+impl<'a, 'gcx, N> HashStable<StableHashingContext<'a>>\n+for traits::VtableBuiltinData<N> where N: HashStable<StableHashingContext<'a>> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let traits::VtableBuiltinData {\n             ref nested,\n@@ -1142,10 +1186,10 @@ for traits::VtableBuiltinData<N> where N: HashStable<StableHashingContext<'gcx>>\n     }\n }\n \n-impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n-for traits::VtableClosureData<'gcx, N> where N: HashStable<StableHashingContext<'gcx>> {\n+impl<'a, 'gcx, N> HashStable<StableHashingContext<'a>>\n+for traits::VtableClosureData<'gcx, N> where N: HashStable<StableHashingContext<'a>> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let traits::VtableClosureData {\n             closure_def_id,\n@@ -1158,10 +1202,10 @@ for traits::VtableClosureData<'gcx, N> where N: HashStable<StableHashingContext<\n     }\n }\n \n-impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n-for traits::VtableFnPointerData<'gcx, N> where N: HashStable<StableHashingContext<'gcx>> {\n+impl<'a, 'gcx, N> HashStable<StableHashingContext<'a>>\n+for traits::VtableFnPointerData<'gcx, N> where N: HashStable<StableHashingContext<'a>> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let traits::VtableFnPointerData {\n             fn_ty,\n@@ -1172,10 +1216,10 @@ for traits::VtableFnPointerData<'gcx, N> where N: HashStable<StableHashingContex\n     }\n }\n \n-impl<'gcx, N> HashStable<StableHashingContext<'gcx>>\n-for traits::VtableGeneratorData<'gcx, N> where N: HashStable<StableHashingContext<'gcx>> {\n+impl<'a, 'gcx, N> HashStable<StableHashingContext<'a>>\n+for traits::VtableGeneratorData<'gcx, N> where N: HashStable<StableHashingContext<'a>> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let traits::VtableGeneratorData {\n             closure_def_id,"}, {"sha": "8a899a35ecb547a7e27e5fc59549a6df067a17f3", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=7d2d4e320294d69f6fff3002200b7ea8809b95d1", "patch": "@@ -394,10 +394,10 @@ impl LintLevelMap {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for LintLevelMap {\n+impl<'a> HashStable<StableHashingContext<'a>> for LintLevelMap {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let LintLevelMap {\n             ref sets,"}, {"sha": "9a394e524817b23485270a2a7a19f3151db46fae", "filename": "src/librustc/macros.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=7d2d4e320294d69f6fff3002200b7ea8809b95d1", "patch": "@@ -73,10 +73,10 @@ macro_rules! __impl_stable_hash_field {\n #[macro_export]\n macro_rules! impl_stable_hash_for {\n     (enum $enum_name:path { $( $variant:ident $( ( $($arg:ident),* ) )* ),* }) => {\n-        impl<'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'tcx>> for $enum_name {\n+        impl<'a, 'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>> for $enum_name {\n             #[inline]\n             fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n-                                                  __ctx: &mut $crate::ich::StableHashingContext<'tcx>,\n+                                                  __ctx: &mut $crate::ich::StableHashingContext<'a>,\n                                                   __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher<W>) {\n                 use $enum_name::*;\n                 ::std::mem::discriminant(self).hash_stable(__ctx, __hasher);\n@@ -92,10 +92,10 @@ macro_rules! impl_stable_hash_for {\n         }\n     };\n     (struct $struct_name:path { $($field:ident),* }) => {\n-        impl<'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'tcx>> for $struct_name {\n+        impl<'a, 'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>> for $struct_name {\n             #[inline]\n             fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n-                                                  __ctx: &mut $crate::ich::StableHashingContext<'tcx>,\n+                                                  __ctx: &mut $crate::ich::StableHashingContext<'a>,\n                                                   __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher<W>) {\n                 let $struct_name {\n                     $(ref $field),*\n@@ -106,10 +106,10 @@ macro_rules! impl_stable_hash_for {\n         }\n     };\n     (tuple_struct $struct_name:path { $($field:ident),* }) => {\n-        impl<'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'tcx>> for $struct_name {\n+        impl<'a, 'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>> for $struct_name {\n             #[inline]\n             fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n-                                                  __ctx: &mut $crate::ich::StableHashingContext<'tcx>,\n+                                                  __ctx: &mut $crate::ich::StableHashingContext<'a>,\n                                                   __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher<W>) {\n                 let $struct_name (\n                     $(ref $field),*\n@@ -125,11 +125,11 @@ macro_rules! impl_stable_hash_for {\n macro_rules! impl_stable_hash_for_spanned {\n     ($T:path) => (\n \n-        impl<'tcx> HashStable<StableHashingContext<'tcx>> for ::syntax::codemap::Spanned<$T>\n+        impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for ::syntax::codemap::Spanned<$T>\n         {\n             #[inline]\n             fn hash_stable<W: StableHasherResult>(&self,\n-                                                  hcx: &mut StableHashingContext<'tcx>,\n+                                                  hcx: &mut StableHashingContext<'a>,\n                                                   hasher: &mut StableHasher<W>) {\n                 self.node.hash_stable(hcx, hasher);\n                 self.span.hash_stable(hcx, hasher);"}, {"sha": "6f5791ed5d71bc063c11a69b1b3a10e4525b3eef", "filename": "src/librustc/middle/borrowck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck.rs?ref=7d2d4e320294d69f6fff3002200b7ea8809b95d1", "patch": "@@ -20,9 +20,9 @@ pub struct BorrowCheckResult {\n     pub used_mut_nodes: FxHashSet<HirId>,\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for BorrowCheckResult {\n+impl<'a> HashStable<StableHashingContext<'a>> for BorrowCheckResult {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let BorrowCheckResult {\n             ref used_mut_nodes,"}, {"sha": "c73930553cdea679a69addc7499c105fe3e0218a", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=7d2d4e320294d69f6fff3002200b7ea8809b95d1", "patch": "@@ -1488,9 +1488,9 @@ pub fn provide(providers: &mut Providers) {\n     };\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for ScopeTree {\n+impl<'a> HashStable<StableHashingContext<'a>> for ScopeTree {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let ScopeTree {\n             root_body,"}, {"sha": "45cb70d00706844193586b3ebddad102646b02c5", "filename": "src/librustc/mir/cache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fcache.rs?ref=7d2d4e320294d69f6fff3002200b7ea8809b95d1", "patch": "@@ -35,9 +35,9 @@ impl serialize::Decodable for Cache {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for Cache {\n+impl<'a> HashStable<StableHashingContext<'a>> for Cache {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          _: &mut StableHashingContext<'gcx>,\n+                                          _: &mut StableHashingContext<'a>,\n                                           _: &mut StableHasher<W>) {\n         // do nothing\n     }"}, {"sha": "c395be549a397ea9e4c33b6b733bcac366120b12", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=7d2d4e320294d69f6fff3002200b7ea8809b95d1", "patch": "@@ -200,6 +200,8 @@ pub struct UndefMask {\n     len: u64,\n }\n \n+impl_stable_hash_for!(struct mir::interpret::UndefMask{blocks, len});\n+\n impl UndefMask {\n     pub fn new(size: u64) -> Self {\n         let mut m = UndefMask {"}, {"sha": "8da3a125d3ff558f86977d6132f07881638ca08b", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=7d2d4e320294d69f6fff3002200b7ea8809b95d1", "patch": "@@ -1877,7 +1877,7 @@ fn fmt_const_val<W: Write>(fmt: &mut W, const_val: &ty::Const) -> fmt::Result {\n     }\n }\n \n-fn print_miri_value<W: Write>(value: Value, ty: Ty, f: &mut W) -> fmt::Result {\n+pub fn print_miri_value<W: Write>(value: Value, ty: Ty, f: &mut W) -> fmt::Result {\n     use ty::TypeVariants::*;\n     use rustc_const_math::ConstFloat;\n     match (value, &ty.sty) {"}, {"sha": "d01059a3e017185bfd2dd001410c066c1954d926", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=7d2d4e320294d69f6fff3002200b7ea8809b95d1", "patch": "@@ -41,9 +41,9 @@ impl<'tcx> MonoItem<'tcx> {\n     }\n }\n \n-impl<'tcx> HashStable<StableHashingContext<'tcx>> for MonoItem<'tcx> {\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for MonoItem<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                           hcx: &mut StableHashingContext<'tcx>,\n+                                           hcx: &mut StableHashingContext<'a>,\n                                            hasher: &mut StableHasher<W>) {\n         ::std::mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -171,9 +171,9 @@ impl<'tcx> CodegenUnit<'tcx> {\n     }\n }\n \n-impl<'tcx> HashStable<StableHashingContext<'tcx>> for CodegenUnit<'tcx> {\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for CodegenUnit<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                           hcx: &mut StableHashingContext<'tcx>,\n+                                           hcx: &mut StableHashingContext<'a>,\n                                            hasher: &mut StableHasher<W>) {\n         let CodegenUnit {\n             ref items,"}, {"sha": "437369400ed11d1a89369b7753de726540b58599", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=7d2d4e320294d69f6fff3002200b7ea8809b95d1", "patch": "@@ -179,10 +179,10 @@ impl_stable_hash_for!(enum self::OutputType {\n     DepInfo\n });\n \n-impl<'tcx> ToStableHashKey<StableHashingContext<'tcx>> for OutputType {\n+impl<'a, 'tcx> ToStableHashKey<StableHashingContext<'a>> for OutputType {\n     type KeyType = OutputType;\n     #[inline]\n-    fn to_stable_hash_key(&self, _: &StableHashingContext<'tcx>) -> Self::KeyType {\n+    fn to_stable_hash_key(&self, _: &StableHashingContext<'a>) -> Self::KeyType {\n         *self\n     }\n }"}, {"sha": "f8b895177f381dfa74c02ca0341ceabcde309361", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=7d2d4e320294d69f6fff3002200b7ea8809b95d1", "patch": "@@ -391,9 +391,9 @@ pub fn ancestors(tcx: TyCtxt,\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for Children {\n+impl<'a> HashStable<StableHashingContext<'a>> for Children {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let Children {\n             ref nonblanket_impls,"}, {"sha": "3ec3f665db9c9aec96dd5377659d90bdf5c923f9", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=7d2d4e320294d69f6fff3002200b7ea8809b95d1", "patch": "@@ -676,9 +676,9 @@ impl<'tcx> TypeckTables<'tcx> {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for TypeckTables<'gcx> {\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for TypeckTables<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::TypeckTables {\n             local_id_root,\n@@ -1366,7 +1366,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.cstore.crate_data_as_rc_any(cnum)\n     }\n \n-    pub fn create_stable_hashing_context(self) -> StableHashingContext<'gcx> {\n+    pub fn create_stable_hashing_context(self) -> StableHashingContext<'a> {\n         let krate = self.dep_graph.with_ignore(|| self.gcx.hir.krate());\n \n         StableHashingContext::new(self.sess,"}, {"sha": "93d8a4d979de6d1b020ff0e273f7af0ba130fce9", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=7d2d4e320294d69f6fff3002200b7ea8809b95d1", "patch": "@@ -154,12 +154,12 @@ impl<D: Copy + Debug + Ord + Eq + Hash> SimplifiedTypeGen<D> {\n     }\n }\n \n-impl<'gcx, D> HashStable<StableHashingContext<'gcx>> for SimplifiedTypeGen<D>\n+impl<'a, 'gcx, D> HashStable<StableHashingContext<'a>> for SimplifiedTypeGen<D>\n     where D: Copy + Debug + Ord + Eq + Hash +\n-             HashStable<StableHashingContext<'gcx>>,\n+             HashStable<StableHashingContext<'a>>,\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {"}, {"sha": "79f01a32cd975aaa7068de550074bd41631e652c", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=7d2d4e320294d69f6fff3002200b7ea8809b95d1", "patch": "@@ -2369,9 +2369,9 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for Variants {\n+impl<'a> HashStable<StableHashingContext<'a>> for Variants {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use ty::layout::Variants::*;\n         mem::discriminant(self).hash_stable(hcx, hasher);\n@@ -2405,9 +2405,9 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Variants {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for FieldPlacement {\n+impl<'a> HashStable<StableHashingContext<'a>> for FieldPlacement {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use ty::layout::FieldPlacement::*;\n         mem::discriminant(self).hash_stable(hcx, hasher);\n@@ -2428,9 +2428,9 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for FieldPlacement {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for Abi {\n+impl<'a> HashStable<StableHashingContext<'a>> for Abi {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use ty::layout::Abi::*;\n         mem::discriminant(self).hash_stable(hcx, hasher);\n@@ -2455,9 +2455,9 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Abi {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for Scalar {\n+impl<'a> HashStable<StableHashingContext<'a>> for Scalar {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let Scalar { value, valid_range: RangeInclusive { start, end } } = *self;\n         value.hash_stable(hcx, hasher);\n@@ -2498,10 +2498,10 @@ impl_stable_hash_for!(struct ::ty::layout::Size {\n     raw\n });\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for LayoutError<'gcx>\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for LayoutError<'gcx>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         use ty::layout::LayoutError::*;\n         mem::discriminant(self).hash_stable(hcx, hasher);"}, {"sha": "2c7ec5155a627fabd77ad1739ccdfad3612cfabc", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=7d2d4e320294d69f6fff3002200b7ea8809b95d1", "patch": "@@ -80,7 +80,7 @@ pub use self::binding::BindingMode;\n pub use self::binding::BindingMode::*;\n \n pub use self::context::{TyCtxt, GlobalArenas, AllArenas, tls, keep_local};\n-pub use self::context::{Lift, TypeckTables};\n+pub use self::context::{Lift, TypeckTables, InterpretInterner};\n \n pub use self::instance::{Instance, InstanceDef};\n \n@@ -529,9 +529,9 @@ impl<'tcx> TyS<'tcx> {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::TyS<'gcx> {\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for ty::TyS<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::TyS {\n             ref sty,\n@@ -1440,11 +1440,11 @@ impl<'tcx, T> ParamEnvAnd<'tcx, T> {\n     }\n }\n \n-impl<'gcx, T> HashStable<StableHashingContext<'gcx>> for ParamEnvAnd<'gcx, T>\n-    where T: HashStable<StableHashingContext<'gcx>>\n+impl<'a, 'gcx, T> HashStable<StableHashingContext<'a>> for ParamEnvAnd<'gcx, T>\n+    where T: HashStable<StableHashingContext<'a>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let ParamEnvAnd {\n             ref param_env,\n@@ -1545,9 +1545,9 @@ impl<'tcx> serialize::UseSpecializedEncodable for &'tcx AdtDef {\n impl<'tcx> serialize::UseSpecializedDecodable for &'tcx AdtDef {}\n \n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for AdtDef {\n+impl<'a> HashStable<StableHashingContext<'a>> for AdtDef {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         thread_local! {\n             static CACHE: RefCell<FxHashMap<usize, Fingerprint>> ="}, {"sha": "32f0d3384c4dcea44d47bb5cd3086369b851dfcd", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=7d2d4e320294d69f6fff3002200b7ea8809b95d1", "patch": "@@ -186,9 +186,9 @@ pub(super) fn trait_impls_of_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     })\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for TraitImpls {\n+impl<'a> HashStable<StableHashingContext<'a>> for TraitImpls {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let TraitImpls {\n             ref blanket_impls,"}, {"sha": "593f08e90bb3b093ca2902f8ae5b69fdcec20a26", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=7d2d4e320294d69f6fff3002200b7ea8809b95d1", "patch": "@@ -227,9 +227,9 @@ pub struct TraitImpls {\n     pub impls: LazySeq<DefIndex>,\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for TraitImpls {\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for TraitImpls {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let TraitImpls {\n             trait_id: (krate, def_index),\n@@ -310,9 +310,9 @@ pub enum EntryKind<'tcx> {\n     AssociatedConst(AssociatedContainer, u8),\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for EntryKind<'gcx> {\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for EntryKind<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {"}, {"sha": "067041b14f5830fa1cf5038d72f28fb56eba0e01", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 76, "deletions": 68, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=7d2d4e320294d69f6fff3002200b7ea8809b95d1", "patch": "@@ -20,12 +20,10 @@ use build::matches::{Candidate, MatchPair, Test, TestKind};\n use hair::*;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::bitvec::BitVector;\n-use rustc::middle::const_val::ConstVal;\n use rustc::ty::{self, Ty};\n use rustc::ty::util::IntTypeExt;\n use rustc::mir::*;\n-use rustc::mir::interpret::{Value, PrimVal};\n-use rustc::hir::RangeEnd;\n+use rustc::hir::{RangeEnd, Mutability};\n use syntax_pos::Span;\n use std::cmp::Ordering;\n \n@@ -297,76 +295,86 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             TestKind::Eq { value, ty } => {\n                 let tcx = self.hir.tcx();\n                 let mut val = Operand::Copy(place.clone());\n-\n-                let bytes = match value.val {\n-                    ConstVal::Value(Value::ByVal(PrimVal::Ptr(p))) => {\n-                        let is_array_ptr = ty\n-                            .builtin_deref(true, ty::NoPreference)\n-                            .and_then(|t| t.ty.builtin_index())\n-                            .map_or(false, |t| t == self.hir.tcx().types.u8);\n-                        if is_array_ptr {\n-                            self.hir\n-                                .tcx()\n-                                .interpret_interner\n-                                .borrow()\n-                                .get_alloc(p.alloc_id)\n-                                .map(|alloc| &alloc.bytes[..])\n-                        } else {\n-                            None\n-                        }\n-                    },\n-                    _ => None,\n-                };\n-                // If we're using b\"...\" as a pattern, we need to insert an\n-                // unsizing coercion, as the byte string has the type &[u8; N].\n-                //\n-                // We want to do this even when the scrutinee is a reference to an\n-                // array, so we can call `<[u8]>::eq` rather than having to find an\n-                // `<[u8; N]>::eq`.\n-                let expect = if let Some(bytes) = bytes {\n-                    let tcx = self.hir.tcx();\n-\n-                    // Unsize the place to &[u8], too, if necessary.\n-                    if let ty::TyRef(region, mt) = ty.sty {\n-                        if let ty::TyArray(_, _) = mt.ty.sty {\n-                            ty = tcx.mk_imm_ref(region, tcx.mk_slice(tcx.types.u8));\n-                            let val_slice = self.temp(ty, test.span);\n-                            self.cfg.push_assign(block, source_info, &val_slice,\n-                                                 Rvalue::Cast(CastKind::Unsize, val, ty));\n-                            val = Operand::Move(val_slice);\n-                        }\n-                    }\n-\n-                    assert!(ty.is_slice());\n-\n-                    let array_ty = tcx.mk_array(tcx.types.u8, bytes.len() as u64);\n-                    let array_ref = tcx.mk_imm_ref(tcx.types.re_static, array_ty);\n-                    let array = self.literal_operand(test.span, array_ref, Literal::Value {\n-                        value\n-                    });\n-\n-                    let val = self.to_slice_operand(block, source_info, val);\n-                    let slice = self.to_slice_operand(block, source_info, array);\n-                    (slice, val)\n-                } else {\n-                    (self.literal_operand(test.span, ty, Literal::Value {\n-                        value\n-                    }), val)\n-                };\n-\n-                // Use PartialEq::eq for &str and &[u8] slices, instead of BinOp::Eq.\n+                let mut expect = self.literal_operand(test.span, ty, Literal::Value {\n+                    value\n+                });\n+                // Use PartialEq::eq instead of BinOp::Eq\n+                // (the binop can only handle primitives)\n                 let fail = self.cfg.start_new_block();\n-                let str_or_bytestr = ty\n-                    .builtin_deref(true, ty::NoPreference)\n-                    .and_then(|tam| match tam.ty.sty {\n-                        ty::TyStr => Some(tam.ty),\n-                        ty::TySlice(inner) if inner == self.hir.tcx().types.u8 => Some(tam.ty),\n+                if !ty.is_scalar() {\n+                    // If we're using b\"...\" as a pattern, we need to insert an\n+                    // unsizing coercion, as the byte string has the type &[u8; N].\n+                    //\n+                    // We want to do this even when the scrutinee is a reference to an\n+                    // array, so we can call `<[u8]>::eq` rather than having to find an\n+                    // `<[u8; N]>::eq`.\n+                    let unsize = |ty: Ty<'tcx>| match ty.sty {\n+                        ty::TyRef(region, tam) => match tam.ty.sty {\n+                            ty::TyArray(inner_ty, n) => Some((region, inner_ty, n)),\n+                            _ => None,\n+                        },\n                         _ => None,\n-                    });\n-                if let Some(ty) = str_or_bytestr {\n+                    };\n+                    let opt_ref_ty = unsize(ty);\n+                    let opt_ref_test_ty = unsize(value.ty);\n+                    let mut place = place.clone();\n+                    match (opt_ref_ty, opt_ref_test_ty) {\n+                        // nothing to do, neither is an array\n+                        (None, None) => {},\n+                        (Some((region, elem_ty, _)), _) |\n+                        (None, Some((region, elem_ty, _))) => {\n+                            let tcx = self.hir.tcx();\n+                            // make both a slice\n+                            ty = tcx.mk_imm_ref(region, tcx.mk_slice(elem_ty));\n+                            if opt_ref_ty.is_some() {\n+                                place = self.temp(ty, test.span);\n+                                self.cfg.push_assign(block, source_info, &place,\n+                                                    Rvalue::Cast(CastKind::Unsize, val, ty));\n+                            }\n+                            if opt_ref_test_ty.is_some() {\n+                                let array = self.literal_operand(\n+                                    test.span,\n+                                    value.ty,\n+                                    Literal::Value {\n+                                        value\n+                                    },\n+                                );\n+\n+                                let slice = self.temp(ty, test.span);\n+                                self.cfg.push_assign(block, source_info, &slice,\n+                                                    Rvalue::Cast(CastKind::Unsize, array, ty));\n+                                expect = Operand::Move(slice);\n+                            }\n+                        },\n+                    }\n                     let eq_def_id = self.hir.tcx().lang_items().eq_trait().unwrap();\n                     let (mty, method) = self.hir.trait_method(eq_def_id, \"eq\", ty, &[ty]);\n \n+                    // take the argument by reference\n+                    let region_scope = self.topmost_scope();\n+                    let region = self.hir.tcx().mk_region(ty::ReScope(region_scope));\n+                    let tam = ty::TypeAndMut {\n+                        ty,\n+                        mutbl: Mutability::MutImmutable,\n+                    };\n+                    let ref_ty = self.hir.tcx().mk_ref(region, tam);\n+\n+                    // let lhs_ref_place = &lhs;\n+                    let ref_rvalue = Rvalue::Ref(region, BorrowKind::Shared, place.clone());\n+                    let lhs_ref_place = self.temp(ref_ty, test.span);\n+                    self.cfg.push_assign(block, source_info, &lhs_ref_place, ref_rvalue);\n+                    let val = Operand::Move(lhs_ref_place);\n+\n+                    // let rhs_place = rhs;\n+                    let rhs_place = self.temp(ty, test.span);\n+                    self.cfg.push_assign(block, source_info, &rhs_place, Rvalue::Use(expect));\n+\n+                    // let rhs_ref_place = &rhs_place;\n+                    let ref_rvalue = Rvalue::Ref(region, BorrowKind::Shared, rhs_place);\n+                    let rhs_ref_place = self.temp(ref_ty, test.span);\n+                    self.cfg.push_assign(block, source_info, &rhs_ref_place, ref_rvalue);\n+                    let expect = Operand::Move(rhs_ref_place);\n+\n                     let bool_ty = self.hir.bool_ty();\n                     let eq_result = self.temp(bool_ty, test.span);\n                     let eq_block = self.cfg.start_new_block();"}, {"sha": "2000ebea25d7e3337bc47ef01a508b653668a537", "filename": "src/librustc_mir/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc_mir%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc_mir%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdiagnostics.rs?ref=7d2d4e320294d69f6fff3002200b7ea8809b95d1", "patch": "@@ -72,36 +72,6 @@ fn foo(x: Option<String>) {\n ```\n \"##,\n \n-E0003: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-Not-a-Number (NaN) values cannot be compared for equality and hence can never\n-match the input to a match expression. So, the following will not compile:\n-\n-```compile_fail\n-const NAN: f32 = 0.0 / 0.0;\n-\n-let number = 0.1f32;\n-\n-match number {\n-    NAN => { /* ... */ },\n-    _ => {}\n-}\n-```\n-\n-To match against NaN values, you should instead use the `is_nan()` method in a\n-guard, like so:\n-\n-```\n-let number = 0.1f32;\n-\n-match number {\n-    x if x.is_nan() => { /* ... */ }\n-    _ => {}\n-}\n-```\n-\"##,\n-\n E0004: r##\"\n This error indicates that the compiler cannot guarantee a matching pattern for\n one or more possible inputs to a match expression. Guaranteed matches are"}, {"sha": "2dcad403f522a37d8dafb9cef374cbe3747e4d62", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=7d2d4e320294d69f6fff3002200b7ea8809b95d1", "patch": "@@ -19,6 +19,7 @@ pub fn mk_borrowck_eval_cx<'a, 'mir, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     instance: Instance<'tcx>,\n     mir: &'mir mir::Mir<'tcx>,\n+    span: Span,\n ) -> EvalResult<'tcx, EvalContext<'a, 'mir, 'tcx, CompileTimeEvaluator>> {\n     debug!(\"mk_borrowck_eval_cx: {:?}\", instance);\n     let param_env = tcx.param_env(instance.def_id());\n@@ -27,7 +28,7 @@ pub fn mk_borrowck_eval_cx<'a, 'mir, 'tcx>(\n     // insert a stack frame so any queries have the correct substs\n     ecx.push_stack_frame(\n         instance,\n-        mir.span,\n+        span,\n         mir,\n         Place::undef(),\n         StackPopCleanup::None,\n@@ -65,7 +66,7 @@ pub fn eval_body_with_mir<'a, 'mir, 'tcx>(\n     match res {\n         Ok(val) => Some(val),\n         Err(mut err) => {\n-            ecx.report(&mut err, true);\n+            ecx.report(&mut err, true, None);\n             None\n         }\n     }\n@@ -80,7 +81,7 @@ pub fn eval_body<'a, 'tcx>(\n     match res {\n         Ok(val) => Some(val),\n         Err(mut err) => {\n-            ecx.report(&mut err, true);\n+            ecx.report(&mut err, true, None);\n             None\n         }\n     }\n@@ -483,7 +484,7 @@ pub fn const_eval_provider<'a, 'tcx>(\n         })\n     }).map_err(|mut err| {\n         if tcx.is_static(def_id).is_some() {\n-            ecx.report(&mut err, true);\n+            ecx.report(&mut err, true, None);\n         }\n         ConstEvalErr {\n             kind: err.into(),"}, {"sha": "7dafe846a334b60d654d3a83c6c847183c54fb13", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=7d2d4e320294d69f6fff3002200b7ea8809b95d1", "patch": "@@ -10,7 +10,7 @@ use rustc::ty::layout::{self, Size, Align, HasDataLayout, LayoutOf, TyLayout};\n use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc_data_structures::indexed_vec::Idx;\n-use syntax::codemap::{self, DUMMY_SP};\n+use syntax::codemap::{self, DUMMY_SP, Span};\n use syntax::ast::Mutability;\n use rustc::mir::interpret::{\n     GlobalId, Value, Pointer, PrimVal, PrimValKind,\n@@ -464,7 +464,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             StackPopCleanup::MarkStatic(mutable) => {\n                 if let Place::Ptr { ptr, .. } = frame.return_place {\n                     // FIXME: to_ptr()? might be too extreme here, static zsts might reach this under certain conditions\n-                    self.memory.mark_static_initalized(\n+                    self.memory.mark_static_initialized(\n                         ptr.to_ptr()?.alloc_id,\n                         mutable,\n                     )?\n@@ -1572,7 +1572,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         Ok(())\n     }\n \n-    pub fn report(&self, e: &mut EvalError, as_err: bool) {\n+    pub fn report(&self, e: &mut EvalError, as_err: bool, explicit_span: Option<Span>) {\n         if let EvalErrorKind::TypeckError = e.kind {\n             return;\n         }\n@@ -1608,11 +1608,12 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         }\n         if let Some(frame) = self.stack().last() {\n             let block = &frame.mir.basic_blocks()[frame.block];\n-            let span = if frame.stmt < block.statements.len() {\n+            let span = explicit_span.unwrap_or_else(|| if frame.stmt < block.statements.len() {\n                 block.statements[frame.stmt].source_info.span\n             } else {\n                 block.terminator().source_info.span\n-            };\n+            });\n+            trace!(\"reporting const eval failure at {:?}\", span);\n             let node_id = self\n                 .stack()\n                 .iter()\n@@ -1634,6 +1635,9 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             let mut last_span = None;\n             for &Frame { instance, span, .. } in self.stack().iter().rev() {\n                 // make sure we don't emit frames that are duplicates of the previous\n+                if explicit_span == Some(span) {\n+                    continue;\n+                }\n                 if let Some(last) = last_span {\n                     if last == span {\n                         continue;"}, {"sha": "eebd48f7bb95c37f9c14e1a18a35ba3f6b342977", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=7d2d4e320294d69f6fff3002200b7ea8809b95d1", "patch": "@@ -520,18 +520,18 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             // do not go into statics\n             None  => Ok(()),\n             // just locals and machine allocs\n-            Some(_) => self.mark_static_initalized(alloc, mutability),\n+            Some(_) => self.mark_static_initialized(alloc, mutability),\n         }\n     }\n \n     /// mark an allocation as static and initialized, either mutable or not\n-    pub fn mark_static_initalized(\n+    pub fn mark_static_initialized(\n         &mut self,\n         alloc_id: AllocId,\n         mutability: Mutability,\n     ) -> EvalResult<'tcx> {\n         trace!(\n-            \"mark_static_initalized {:?}, mutability: {:?}\",\n+            \"mark_static_initialized {:?}, mutability: {:?}\",\n             alloc_id,\n             mutability\n         );"}, {"sha": "03b215fa0b8eae0dc6274b50fb130481b352c685", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=7d2d4e320294d69f6fff3002200b7ea8809b95d1", "patch": "@@ -52,7 +52,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             }\n         }\n \n-        self.memory.mark_static_initalized(\n+        self.memory.mark_static_initialized(\n             vtable.alloc_id,\n             Mutability::Immutable,\n         )?;"}, {"sha": "6079e1929b57866d9f52ad8cbcc728759a52a99a", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=7d2d4e320294d69f6fff3002200b7ea8809b95d1", "patch": "@@ -23,7 +23,7 @@ use rustc_data_structures::indexed_vec::Idx;\n use std::mem;\n use std::collections::VecDeque;\n use transform::{MirPass, MirSource};\n-use syntax::codemap::{Span, DUMMY_SP};\n+use syntax::codemap::Span;\n use rustc_data_structures::control_flow_graph::ControlFlowGraph;\n use rustc::ty::subst::Substs;\n \n@@ -147,7 +147,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for InstCombineVisitor<'a, 'tcx> {\n             TerminatorKind::SwitchInt { discr: value, .. } |\n             TerminatorKind::Yield { value, .. } |\n             TerminatorKind::Assert { cond: value, .. } => {\n-                if let Some((new, ty, span)) = self.optimizations.const_prop.remove(&location) {\n+                if let Some((new, ty, span)) = self.optimizations.terminators.remove(&block) {\n                     let new = self.tcx.mk_const(ty::Const {\n                         val: ConstVal::Value(new),\n                         ty,\n@@ -190,13 +190,13 @@ impl<'b, 'a, 'tcx:'b> OptimizationFinder<'b, 'a, 'tcx> {\n         }\n     }\n \n-    fn eval_constant(&mut self, c: &Constant<'tcx>, span: Span) -> Option<Const<'tcx>> {\n+    fn eval_constant(&mut self, c: &Constant<'tcx>) -> Option<Const<'tcx>> {\n         if let Some(&val) = self.optimizations.constants.get(c) {\n             return Some(val);\n         }\n         match c.literal {\n             Literal::Value { value } => match value.val {\n-                ConstVal::Value(v) => Some((v, value.ty, span)),\n+                ConstVal::Value(v) => Some((v, value.ty, c.span)),\n                 ConstVal::Unevaluated(did, substs) => {\n                     let param_env = self.tcx.param_env(self.source.def_id);\n                     let span = self.tcx.def_span(did);\n@@ -230,20 +230,19 @@ impl<'b, 'a, 'tcx:'b> OptimizationFinder<'b, 'a, 'tcx> {\n                     instance,\n                     promoted: Some(index),\n                 };\n-                let span = self.tcx.def_span(self.source.def_id);\n                 let param_env = self.tcx.param_env(self.source.def_id);\n                 let (value, _, ty) = eval_body_with_mir(self.tcx, cid, self.mir, param_env)?;\n-                let val = (value, ty, span);\n+                let val = (value, ty, c.span);\n                 trace!(\"evaluated {:?} to {:?}\", c, val);\n                 self.optimizations.constants.insert(c.clone(), val);\n                 Some(val)\n             }\n         }\n     }\n \n-    fn eval_operand(&mut self, op: &Operand<'tcx>, span: Span) -> Option<Const<'tcx>> {\n+    fn eval_operand(&mut self, op: &Operand<'tcx>) -> Option<Const<'tcx>> {\n         match *op {\n-            Operand::Constant(ref c) => self.eval_constant(c, span),\n+            Operand::Constant(ref c) => self.eval_constant(c),\n             Operand::Move(ref place) | Operand::Copy(ref place) => match *place {\n                 Place::Local(loc) => self.optimizations.places.get(&loc).cloned(),\n                 // FIXME(oli-obk): field and index projections\n@@ -253,13 +252,13 @@ impl<'b, 'a, 'tcx:'b> OptimizationFinder<'b, 'a, 'tcx> {\n         }\n     }\n \n-    fn simplify_operand(&mut self, op: &Operand<'tcx>, span: Span) -> Option<Const<'tcx>> {\n+    fn simplify_operand(&mut self, op: &Operand<'tcx>) -> Option<Const<'tcx>> {\n         match *op {\n             Operand::Constant(ref c) => match c.literal {\n                 Literal::Value { .. } => None,\n-                _ => self.eval_operand(op, span),\n+                _ => self.eval_operand(op),\n             },\n-            _ => self.eval_operand(op, span),\n+            _ => self.eval_operand(op),\n         }\n     }\n \n@@ -270,7 +269,7 @@ impl<'b, 'a, 'tcx:'b> OptimizationFinder<'b, 'a, 'tcx> {\n         span: Span,\n     ) -> Option<Const<'tcx>> {\n         match *rvalue {\n-            Rvalue::Use(ref op) => self.simplify_operand(op, span),\n+            Rvalue::Use(ref op) => self.simplify_operand(op),\n             Rvalue::Repeat(..) |\n             Rvalue::Ref(..) |\n             Rvalue::Cast(..) |\n@@ -300,24 +299,24 @@ impl<'b, 'a, 'tcx:'b> OptimizationFinder<'b, 'a, 'tcx> {\n                 }\n                 let substs = Substs::identity_for_item(self.tcx, self.source.def_id);\n                 let instance = Instance::new(self.source.def_id, substs);\n-                let ecx = mk_borrowck_eval_cx(self.tcx, instance, self.mir).unwrap();\n+                let ecx = mk_borrowck_eval_cx(self.tcx, instance, self.mir, span).unwrap();\n \n-                let val = self.eval_operand(arg, span)?;\n+                let val = self.eval_operand(arg)?;\n                 let prim = ecx.value_to_primval(ValTy { value: val.0, ty: val.1 }).ok()?;\n                 let kind = ecx.ty_to_primval_kind(val.1).ok()?;\n                 match unary_op(op, prim, kind) {\n                     Ok(val) => Some((Value::ByVal(val), place_ty, span)),\n                     Err(mut err) => {\n-                        ecx.report(&mut err, false);\n+                        ecx.report(&mut err, false, Some(span));\n                         None\n                     },\n                 }\n             }\n             Rvalue::CheckedBinaryOp(op, ref left, ref right) |\n             Rvalue::BinaryOp(op, ref left, ref right) => {\n                 trace!(\"rvalue binop {:?} for {:?} and {:?}\", op, left, right);\n-                let left = self.eval_operand(left, span)?;\n-                let right = self.eval_operand(right, span)?;\n+                let left = self.eval_operand(left)?;\n+                let right = self.eval_operand(right)?;\n                 let def_id = if self.tcx.is_closure(self.source.def_id) {\n                     self.tcx.closure_base_def_id(self.source.def_id)\n                 } else {\n@@ -331,7 +330,7 @@ impl<'b, 'a, 'tcx:'b> OptimizationFinder<'b, 'a, 'tcx> {\n                 }\n                 let substs = Substs::identity_for_item(self.tcx, self.source.def_id);\n                 let instance = Instance::new(self.source.def_id, substs);\n-                let ecx = mk_borrowck_eval_cx(self.tcx, instance, self.mir).unwrap();\n+                let ecx = mk_borrowck_eval_cx(self.tcx, instance, self.mir, span).unwrap();\n \n                 let l = ecx.value_to_primval(ValTy { value: left.0, ty: left.1 }).ok()?;\n                 let r = ecx.value_to_primval(ValTy { value: right.0, ty: right.1 }).ok()?;\n@@ -351,15 +350,15 @@ impl<'b, 'a, 'tcx:'b> OptimizationFinder<'b, 'a, 'tcx> {\n                                     kind: EvalErrorKind::OverflowingMath,\n                                     backtrace: None,\n                                 };\n-                                ecx.report(&mut err, false);\n+                                ecx.report(&mut err, false, Some(span));\n                                 return None;\n                             }\n                             Value::ByVal(val)\n                         };\n                         Some((val, place_ty, span))\n                     },\n                     Err(mut err) => {\n-                        ecx.report(&mut err, false);\n+                        ecx.report(&mut err, false, Some(span));\n                         None\n                     },\n                 }\n@@ -500,7 +499,7 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for OptimizationFinder<'b, 'a, 'tcx> {\n     ) {\n         trace!(\"visit_constant: {:?}\", constant);\n         self.super_constant(constant, location);\n-        self.eval_constant(constant, DUMMY_SP);\n+        self.eval_constant(constant);\n     }\n \n     fn visit_statement(\n@@ -514,7 +513,7 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for OptimizationFinder<'b, 'a, 'tcx> {\n             let place_ty = place\n                 .ty(&self.mir.local_decls, self.tcx)\n                 .to_ty(self.tcx);\n-            let span = self.mir.source_info(location).span;\n+            let span = statement.source_info.span;\n             if let Some(value) = self.const_prop(rval, place_ty, span) {\n                 self.optimizations.const_prop.insert(location, value);\n                 if let Place::Local(local) = *place {\n@@ -554,17 +553,16 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for OptimizationFinder<'b, 'a, 'tcx> {\n \n     fn visit_terminator_kind(\n         &mut self,\n-        _block: BasicBlock,\n+        block: BasicBlock,\n         kind: &TerminatorKind<'tcx>,\n-        location: Location,\n+        _location: Location,\n     ) {\n-        let span = self.mir.source_info(location).span;\n         match kind {\n             TerminatorKind::SwitchInt { discr: value, .. } |\n             TerminatorKind::Yield { value, .. } |\n             TerminatorKind::Assert { cond: value, .. } => {\n-                if let Some(value) = self.simplify_operand(value, span) {\n-                    self.optimizations.const_prop.insert(location, value);\n+                if let Some(value) = self.simplify_operand(value) {\n+                    self.optimizations.terminators.insert(block, value);\n                 }\n             }\n             // FIXME: do this optimization for function calls\n@@ -578,6 +576,8 @@ struct OptimizationList<'tcx> {\n     and_stars: FxHashSet<Location>,\n     arrays_lengths: FxHashMap<Location, Constant<'tcx>>,\n     const_prop: FxHashMap<Location, Const<'tcx>>,\n+    /// Terminators that get their Operand(s) turned into constants.\n+    terminators: FxHashMap<BasicBlock, Const<'tcx>>,\n     places: FxHashMap<Local, Const<'tcx>>,\n     constants: FxHashMap<Constant<'tcx>, Const<'tcx>>,\n }"}, {"sha": "652069ab7c17ea15b753857301201d5171b6b0f0", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=7d2d4e320294d69f6fff3002200b7ea8809b95d1", "patch": "@@ -265,6 +265,7 @@ fn optimized_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx\n         generator::StateTransform,\n \n         instcombine::InstCombine,\n+        simplify_branches::SimplifyBranches::new(\"after-const-prop\"),\n         deaggregator::Deaggregator,\n         copy_prop::CopyPropagation,\n         remove_noop_landing_pads::RemoveNoopLandingPads,"}, {"sha": "cc5af9489b4cf0b8b7dfafbfd19a81fe3b83202f", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=7d2d4e320294d69f6fff3002200b7ea8809b95d1", "patch": "@@ -128,7 +128,7 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n             _ => None,\n         };\n         if let Some((def_id, args)) = check {\n-            if Some(def_id) == self.cx.ccx.tcx().lang_items().box_free_fn() {\n+            if Some(def_id) == self.fx.cx.tcx.lang_items().box_free_fn() {\n                 // box_free(x) shares with `drop x` the property that it\n                 // is not guaranteed to be statically dominated by the\n                 // definition of x, so x must always be in an alloca."}, {"sha": "cc344fdf063a21e682cbbed4c60ba945c83411c1", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=7d2d4e320294d69f6fff3002200b7ea8809b95d1", "patch": "@@ -204,7 +204,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                     let (otherwise, targets) = targets.split_last().unwrap();\n                     let switch = bx.switch(discr.immediate(),\n                                             llblock(self, *otherwise), values.len());\n-                    let switch_llty = bcx.ccx.layout_of(switch_ty).immediate_llvm_type(bcx.ccx);\n+                    let switch_llty = bx.cx.layout_of(switch_ty).immediate_llvm_type(bx.cx);\n                     for (&value, target) in values.iter().zip(targets) {\n                         let llval = C_uint_big(switch_llty, value);\n                         let llbb = llblock(self, *target);"}, {"sha": "be5cb311b9cc23f3ae08dabe563c89ae8c5b3963", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=7d2d4e320294d69f6fff3002200b7ea8809b95d1", "patch": "@@ -29,7 +29,7 @@ use type_of::LayoutLlvmExt;\n use type_::Type;\n \n use super::super::callee;\n-use super::MirContext;\n+use super::FunctionCx;\n \n fn to_const_int(value: ValueRef, t: Ty, tcx: TyCtxt) -> Option<ConstInt> {\n     match t.sty {\n@@ -135,44 +135,44 @@ pub fn const_scalar_checked_binop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-pub fn primval_to_llvm(ccx: &CrateContext,\n+pub fn primval_to_llvm(cx: &CodegenCx,\n                        cv: PrimVal,\n                        scalar: &Scalar,\n                        llty: Type) -> ValueRef {\n-    let bits = if scalar.is_bool() { 1 } else { scalar.value.size(ccx).bits() };\n+    let bits = if scalar.is_bool() { 1 } else { scalar.value.size(cx).bits() };\n     match cv {\n-        PrimVal::Undef => C_undef(Type::ix(ccx, bits)),\n+        PrimVal::Undef => C_undef(Type::ix(cx, bits)),\n         PrimVal::Bytes(b) => {\n-            let llval = C_uint_big(Type::ix(ccx, bits), b);\n+            let llval = C_uint_big(Type::ix(cx, bits), b);\n             if scalar.value == layout::Pointer {\n                 unsafe { llvm::LLVMConstIntToPtr(llval, llty.to_ref()) }\n             } else {\n                 consts::bitcast(llval, llty)\n             }\n         },\n         PrimVal::Ptr(ptr) => {\n-            let interpret_interner = ccx.tcx().interpret_interner.borrow();\n+            let interpret_interner = cx.tcx.interpret_interner.borrow();\n             if let Some(fn_instance) = interpret_interner.get_fn(ptr.alloc_id) {\n-                callee::get_fn(ccx, fn_instance)\n+                callee::get_fn(cx, fn_instance)\n             } else {\n                 let static_ = interpret_interner.get_corresponding_static_def_id(ptr.alloc_id);\n                 let base_addr = if let Some(def_id) = static_ {\n-                    assert!(ccx.tcx().is_static(def_id).is_some());\n-                    consts::get_static(ccx, def_id)\n+                    assert!(cx.tcx.is_static(def_id).is_some());\n+                    consts::get_static(cx, def_id)\n                 } else if let Some(alloc) = interpret_interner.get_alloc(ptr.alloc_id) {\n-                    let init = global_initializer(ccx, alloc);\n+                    let init = global_initializer(cx, alloc);\n                     if alloc.mutable {\n-                        consts::addr_of_mut(ccx, init, alloc.align, \"byte_str\")\n+                        consts::addr_of_mut(cx, init, alloc.align, \"byte_str\")\n                     } else {\n-                        consts::addr_of(ccx, init, alloc.align, \"byte_str\")\n+                        consts::addr_of(cx, init, alloc.align, \"byte_str\")\n                     }\n                 } else {\n                     bug!(\"missing allocation {:?}\", ptr.alloc_id);\n                 };\n \n                 let llval = unsafe { llvm::LLVMConstInBoundsGEP(\n-                    consts::bitcast(base_addr, Type::i8p(ccx)),\n-                    &C_usize(ccx, ptr.offset),\n+                    consts::bitcast(base_addr, Type::i8p(cx)),\n+                    &C_usize(cx, ptr.offset),\n                     1,\n                 ) };\n                 if scalar.value != layout::Pointer {\n@@ -185,94 +185,94 @@ pub fn primval_to_llvm(ccx: &CrateContext,\n     }\n }\n \n-pub fn global_initializer(ccx: &CrateContext, alloc: &Allocation) -> ValueRef {\n+pub fn global_initializer(cx: &CodegenCx, alloc: &Allocation) -> ValueRef {\n     let mut llvals = Vec::with_capacity(alloc.relocations.len() + 1);\n-    let layout = ccx.data_layout();\n+    let layout = cx.data_layout();\n     let pointer_size = layout.pointer_size.bytes() as usize;\n \n     let mut next_offset = 0;\n     for (&offset, &alloc_id) in &alloc.relocations {\n         assert_eq!(offset as usize as u64, offset);\n         let offset = offset as usize;\n         if offset > next_offset {\n-            llvals.push(C_bytes(ccx, &alloc.bytes[next_offset..offset]));\n+            llvals.push(C_bytes(cx, &alloc.bytes[next_offset..offset]));\n         }\n         let ptr_offset = read_target_uint(\n             layout.endian,\n             &alloc.bytes[offset..(offset + pointer_size)],\n         ).expect(\"global_initializer: could not read relocation pointer\") as u64;\n         llvals.push(primval_to_llvm(\n-            ccx,\n+            cx,\n             PrimVal::Ptr(MemoryPointer { alloc_id, offset: ptr_offset }),\n             &Scalar {\n                 value: layout::Primitive::Pointer,\n                 valid_range: 0..=!0\n             },\n-            Type::i8p(ccx)\n+            Type::i8p(cx)\n         ));\n         next_offset = offset + pointer_size;\n     }\n     if alloc.bytes.len() >= next_offset {\n-        llvals.push(C_bytes(ccx, &alloc.bytes[next_offset ..]));\n+        llvals.push(C_bytes(cx, &alloc.bytes[next_offset ..]));\n     }\n \n-    C_struct(ccx, &llvals, true)\n+    C_struct(cx, &llvals, true)\n }\n \n pub fn trans_static_initializer<'a, 'tcx>(\n     cx: &CodegenCx<'a, 'tcx>,\n     def_id: DefId)\n     -> Result<ValueRef, ConstEvalErr<'tcx>>\n {\n-    let instance = ty::Instance::mono(ccx.tcx(), def_id);\n+    let instance = ty::Instance::mono(cx.tcx, def_id);\n     let cid = GlobalId {\n         instance,\n         promoted: None\n     };\n     let param_env = ty::ParamEnv::empty(traits::Reveal::All);\n-    ccx.tcx().const_eval(param_env.and(cid))?;\n+    cx.tcx.const_eval(param_env.and(cid))?;\n \n-    let alloc_id = ccx\n-        .tcx()\n+    let alloc_id = cx\n+        .tcx\n         .interpret_interner\n         .borrow()\n         .get_cached(def_id)\n         .expect(\"global not cached\");\n \n-    let alloc = ccx\n-        .tcx()\n+    let alloc = cx\n+        .tcx\n         .interpret_interner\n         .borrow()\n         .get_alloc(alloc_id)\n         .expect(\"miri allocation never successfully created\");\n-    Ok(global_initializer(ccx, alloc))\n+    Ok(global_initializer(cx, alloc))\n }\n \n impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n     fn const_to_miri_value(\n         &mut self,\n-        bcx: &Builder<'a, 'tcx>,\n+        bx: &Builder<'a, 'tcx>,\n         constant: &'tcx ty::Const<'tcx>,\n     ) -> Result<MiriValue, ConstEvalErr<'tcx>> {\n         match constant.val {\n             ConstVal::Unevaluated(def_id, ref substs) => {\n-                let tcx = bcx.tcx();\n+                let tcx = bx.tcx();\n                 let param_env = ty::ParamEnv::empty(traits::Reveal::All);\n                 let instance = ty::Instance::resolve(tcx, param_env, def_id, substs).unwrap();\n                 let cid = GlobalId {\n                     instance,\n                     promoted: None,\n                 };\n                 let c = tcx.const_eval(param_env.and(cid))?;\n-                self.const_to_miri_value(bcx, c)\n+                self.const_to_miri_value(bx, c)\n             },\n             ConstVal::Value(miri_val) => Ok(miri_val),\n         }\n     }\n \n     pub fn mir_constant_to_miri_value(\n         &mut self,\n-        bcx: &Builder<'a, 'tcx>,\n+        bx: &Builder<'a, 'tcx>,\n         constant: &mir::Constant<'tcx>,\n     ) -> Result<MiriValue, ConstEvalErr<'tcx>> {\n         match constant.literal {\n@@ -282,49 +282,49 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                     instance: self.instance,\n                     promoted: Some(index),\n                 };\n-                bcx.tcx().const_eval(param_env.and(cid))\n+                bx.tcx().const_eval(param_env.and(cid))\n             }\n             mir::Literal::Value { value } => {\n                 Ok(self.monomorphize(&value))\n             }\n-        }.and_then(|c| self.const_to_miri_value(bcx, c))\n+        }.and_then(|c| self.const_to_miri_value(bx, c))\n     }\n \n     // Old version of trans_constant now used just for SIMD shuffle\n     pub fn remove_me_shuffle_indices(&mut self,\n-                                      bcx: &Builder<'a, 'tcx>,\n+                                      bx: &Builder<'a, 'tcx>,\n                                       constant: &mir::Constant<'tcx>)\n                                       -> (ValueRef, Ty<'tcx>)\n     {\n-        let layout = bcx.ccx.layout_of(constant.ty);\n-        self.mir_constant_to_miri_value(bcx, constant)\n+        let layout = bx.cx.layout_of(constant.ty);\n+        self.mir_constant_to_miri_value(bx, constant)\n             .and_then(|c| {\n                 let llval = match c {\n                     MiriValue::ByVal(val) => {\n                         let scalar = match layout.abi {\n                             layout::Abi::Scalar(ref x) => x,\n                             _ => bug!(\"from_const: invalid ByVal layout: {:#?}\", layout)\n                         };\n-                        primval_to_llvm(bcx.ccx, val, scalar, layout.immediate_llvm_type(bcx.ccx))\n+                        primval_to_llvm(bx.cx, val, scalar, layout.immediate_llvm_type(bx.cx))\n                     },\n                     MiriValue::ByValPair(a_val, b_val) => {\n                         let (a_scalar, b_scalar) = match layout.abi {\n                             layout::Abi::ScalarPair(ref a, ref b) => (a, b),\n                             _ => bug!(\"from_const: invalid ByValPair layout: {:#?}\", layout)\n                         };\n                         let a_llval = primval_to_llvm(\n-                            bcx.ccx,\n+                            bx.cx,\n                             a_val,\n                             a_scalar,\n-                            layout.scalar_pair_element_llvm_type(bcx.ccx, 0),\n+                            layout.scalar_pair_element_llvm_type(bx.cx, 0),\n                         );\n                         let b_llval = primval_to_llvm(\n-                            bcx.ccx,\n+                            bx.cx,\n                             b_val,\n                             b_scalar,\n-                            layout.scalar_pair_element_llvm_type(bcx.ccx, 1),\n+                            layout.scalar_pair_element_llvm_type(bx.cx, 1),\n                         );\n-                        C_struct(bcx.ccx, &[a_llval, b_llval], false)\n+                        C_struct(bx.cx, &[a_llval, b_llval], false)\n                     },\n                     MiriValue::ByRef(..) => {\n                         let field_ty = constant.ty.builtin_index().unwrap();\n@@ -334,7 +334,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                         };\n                         let values: Result<Vec<ValueRef>, _> = (0..fields).map(|field| {\n                             let field = const_val_field(\n-                                bcx.tcx(),\n+                                bx.tcx(),\n                                 ty::ParamEnv::empty(traits::Reveal::All),\n                                 self.instance,\n                                 None,\n@@ -344,29 +344,29 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                             )?;\n                             match field.val {\n                                 ConstVal::Value(MiriValue::ByVal(prim)) => {\n-                                    let layout = bcx.ccx.layout_of(field_ty);\n+                                    let layout = bx.cx.layout_of(field_ty);\n                                     let scalar = match layout.abi {\n                                         layout::Abi::Scalar(ref x) => x,\n                                         _ => bug!(\"from_const: invalid ByVal layout: {:#?}\", layout)\n                                     };\n                                     Ok(primval_to_llvm(\n-                                        bcx.ccx, prim, scalar,\n-                                        layout.immediate_llvm_type(bcx.ccx),\n+                                        bx.cx, prim, scalar,\n+                                        layout.immediate_llvm_type(bx.cx),\n                                     ))\n                                 },\n                                 other => bug!(\"simd shuffle field {:?}, {}\", other, constant.ty),\n                             }\n                         }).collect();\n-                        C_struct(bcx.ccx, &values?, false)\n+                        C_struct(bx.cx, &values?, false)\n                     },\n                 };\n                 Ok((llval, constant.ty))\n             })\n             .unwrap_or_else(|e| {\n-                e.report(bcx.tcx(), constant.span, \"shuffle_indices\");\n+                e.report(bx.tcx(), constant.span, \"shuffle_indices\");\n                 // We've errored, so we don't have to produce working code.\n                 let ty = self.monomorphize(&constant.ty);\n-                let llty = bcx.ccx.layout_of(ty).llvm_type(bcx.ccx);\n+                let llty = bx.cx.layout_of(ty).llvm_type(bx.cx);\n                 (C_undef(llty), ty)\n             })\n     }"}, {"sha": "a66528858e14a856f2d63445aa2c5e178bc312c7", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=7d2d4e320294d69f6fff3002200b7ea8809b95d1", "patch": "@@ -92,14 +92,14 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n         }\n     }\n \n-    pub fn from_const(bcx: &Builder<'a, 'tcx>,\n+    pub fn from_const(bx: &Builder<'a, 'tcx>,\n                       miri_val: MiriValue,\n                       ty: ty::Ty<'tcx>)\n                       -> Result<OperandRef<'tcx>, ConstEvalErr<'tcx>> {\n-        let layout = bcx.ccx.layout_of(ty);\n+        let layout = bx.cx.layout_of(ty);\n \n         if layout.is_zst() {\n-            return Ok(OperandRef::new_zst(bcx.ccx, layout));\n+            return Ok(OperandRef::new_zst(bx.cx, layout));\n         }\n \n         let val = match miri_val {\n@@ -109,10 +109,10 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n                     _ => bug!(\"from_const: invalid ByVal layout: {:#?}\", layout)\n                 };\n                 let llval = primval_to_llvm(\n-                    bcx.ccx,\n+                    bx.cx,\n                     x,\n                     scalar,\n-                    layout.immediate_llvm_type(bcx.ccx),\n+                    layout.immediate_llvm_type(bx.cx),\n                 );\n                 OperandValue::Immediate(llval)\n             },\n@@ -122,16 +122,16 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n                     _ => bug!(\"from_const: invalid ByValPair layout: {:#?}\", layout)\n                 };\n                 let a_llval = primval_to_llvm(\n-                    bcx.ccx,\n+                    bx.cx,\n                     a,\n                     a_scalar,\n-                    layout.scalar_pair_element_llvm_type(bcx.ccx, 0),\n+                    layout.scalar_pair_element_llvm_type(bx.cx, 0),\n                 );\n                 let b_llval = primval_to_llvm(\n-                    bcx.ccx,\n+                    bx.cx,\n                     b,\n                     b_scalar,\n-                    layout.scalar_pair_element_llvm_type(bcx.ccx, 1),\n+                    layout.scalar_pair_element_llvm_type(bx.cx, 1),\n                 );\n                 OperandValue::Pair(a_llval, b_llval)\n             },\n@@ -141,12 +141,12 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n                     valid_range: 0..=!0\n                 };\n                 let ptr = primval_to_llvm(\n-                    bcx.ccx,\n+                    bx.cx,\n                     ptr.into_inner_primval(),\n                     &scalar,\n-                    layout.llvm_type(bcx.ccx).ptr_to(),\n+                    layout.llvm_type(bx.cx).ptr_to(),\n                 );\n-                return Ok(PlaceRef::new_sized(ptr, layout, align).load(bcx));\n+                return Ok(PlaceRef::new_sized(ptr, layout, align).load(bx));\n             },\n         };\n "}, {"sha": "2372153963a1c0537c6d2e1d969834e32eeb4331", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 37, "deletions": 16, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=7d2d4e320294d69f6fff3002200b7ea8809b95d1", "patch": "@@ -34,6 +34,7 @@ use rustc::middle::privacy::AccessLevels;\n use rustc::middle::resolve_lifetime as rl;\n use rustc::ty::fold::TypeFolder;\n use rustc::middle::lang_items;\n+use rustc::mir::interpret::GlobalId;\n use rustc::hir::{self, HirVec};\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n@@ -2510,14 +2511,24 @@ impl Clean<Type> for hir::Ty {\n                         ty: cx.tcx.types.usize\n                     })\n                 });\n-                let n = if let ConstVal::Unevaluated(def_id, _) = n.val {\n-                    if let Some(node_id) = cx.tcx.hir.as_local_node_id(def_id) {\n-                        print_const_expr(cx, cx.tcx.hir.body_owned_by(node_id))\n-                    } else {\n-                        inline::print_inlined_const(cx, def_id)\n-                    }\n-                } else {\n-                    format!(\"{:?}\", n)\n+                let n = match n.val {\n+                    ConstVal::Unevaluated(def_id, _) => {\n+                        if let Some(node_id) = cx.tcx.hir.as_local_node_id(def_id) {\n+                            print_const_expr(cx, cx.tcx.hir.body_owned_by(node_id))\n+                        } else {\n+                            inline::print_inlined_const(cx, def_id)\n+                        }\n+                    },\n+                    ConstVal::Value(val) => {\n+                        let mut s = String::new();\n+                        ::rustc::mir::print_miri_value(val, n.ty, &mut s).unwrap();\n+                        // array lengths are obviously usize\n+                        if s.ends_with(\"usize\") {\n+                            let n = s.len() - \"usize\".len();\n+                            s.truncate(n);\n+                        }\n+                        s\n+                    },\n                 };\n                 Array(box ty.clean(cx), n)\n             },\n@@ -2645,14 +2656,24 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                         n = new_n;\n                     }\n                 };\n-                let n = if let ConstVal::Unevaluated(def_id, _) = n.val {\n-                    if let Some(node_id) = cx.tcx.hir.as_local_node_id(def_id) {\n-                        print_const_expr(cx, cx.tcx.hir.body_owned_by(node_id))\n-                    } else {\n-                        inline::print_inlined_const(cx, def_id)\n-                    }\n-                } else {\n-                    format!(\"{:?}\", n)\n+                let n = match n.val {\n+                    ConstVal::Unevaluated(def_id, _) => {\n+                        if let Some(node_id) = cx.tcx.hir.as_local_node_id(def_id) {\n+                            print_const_expr(cx, cx.tcx.hir.body_owned_by(node_id))\n+                        } else {\n+                            inline::print_inlined_const(cx, def_id)\n+                        }\n+                    },\n+                    ConstVal::Value(val) => {\n+                        let mut s = String::new();\n+                        ::rustc::mir::print_miri_value(val, n.ty, &mut s).unwrap();\n+                        // array lengths are obviously usize\n+                        if s.ends_with(\"usize\") {\n+                            let n = s.len() - \"usize\".len();\n+                            s.truncate(n);\n+                        }\n+                        s\n+                    },\n                 };\n                 Array(box ty.clean(cx), n)\n             }"}, {"sha": "09983f179266dc68be03946ad4a2a864d1e1d41c", "filename": "src/test/compile-fail/const-err2.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Ftest%2Fcompile-fail%2Fconst-err2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Ftest%2Fcompile-fail%2Fconst-err2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-err2.rs?ref=7d2d4e320294d69f6fff3002200b7ea8809b95d1", "patch": "@@ -19,10 +19,12 @@ fn black_box<T>(_: T) {\n fn main() {\n     let a = -std::i8::MIN;\n     //~^ ERROR const_err\n-    //~| ERROR const_err\n     let b = 200u8 + 200u8 + 200u8;\n+    //~^ ERROR const_err\n     let c = 200u8 * 4;\n+    //~^ ERROR const_err\n     let d = 42u8 - (42u8 + 1);\n+    //~^ ERROR const_err\n     let _e = [5u8][1];\n     black_box(a);\n     black_box(b);"}, {"sha": "9656af6002442c6369dd86120e9cb3008cb96b6f", "filename": "src/test/compile-fail/const-err3.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Ftest%2Fcompile-fail%2Fconst-err3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Ftest%2Fcompile-fail%2Fconst-err3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-err3.rs?ref=7d2d4e320294d69f6fff3002200b7ea8809b95d1", "patch": "@@ -18,9 +18,10 @@ fn black_box<T>(_: T) {\n fn main() {\n     let b = 200u8 + 200u8 + 200u8;\n     //~^ ERROR const_err\n-    //~| ERROR const_err\n     let c = 200u8 * 4;\n+    //~^ ERROR const_err\n     let d = 42u8 - (42u8 + 1);\n+    //~^ ERROR const_err\n     let _e = [5u8][1];\n     black_box(b);\n     black_box(c);"}, {"sha": "ad7dbeb79c721de0ebb61db486d238294e8556bb", "filename": "src/test/run-pass/ctfe/references.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Ftest%2Frun-pass%2Fctfe%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d2d4e320294d69f6fff3002200b7ea8809b95d1/src%2Ftest%2Frun-pass%2Fctfe%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fctfe%2Freferences.rs?ref=7d2d4e320294d69f6fff3002200b7ea8809b95d1", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+const FOO: &[u8] = b\"foo\";\n+const BAR: &[u8] = &[1, 2, 3];\n+\n+const BOO: &i32 = &42;\n+\n+fn main() {\n+    match &[1u8, 2, 3] as &[u8] {\n+        FOO => panic!(\"a\"),\n+        BAR => println!(\"b\"),\n+        _ => panic!(\"c\"),\n+    }\n+\n+    match b\"foo\" as &[u8] {\n+        FOO => println!(\"a\"),\n+        BAR => panic!(\"b\"),\n+        _ => panic!(\"c\"),\n+    }\n+\n+    match &43 {\n+        &42 => panic!(),\n+        BOO => panic!(),\n+        _ => println!(\"d\"),\n+    }\n+}"}]}