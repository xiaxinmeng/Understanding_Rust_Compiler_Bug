{"sha": "eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6", "node_id": "C_kwDOAAsO6NoAKGVmZjJjYjc3NjBmZmQxZWQwNmZkNWE2OGJhMDRkY2I2Njg5MTA2ZjY", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-02-06T18:38:52Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-02-16T03:39:59Z"}, "message": "Rename some region-specific stuff", "tree": {"sha": "be03b0f70bbf8f87d2ba0ea640edf25ea09a3b98", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/be03b0f70bbf8f87d2ba0ea640edf25ea09a3b98"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6", "html_url": "https://github.com/rust-lang/rust/commit/eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "262a344d7245f242586d5d5a0cc5c892f45891c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/262a344d7245f242586d5d5a0cc5c892f45891c4", "html_url": "https://github.com/rust-lang/rust/commit/262a344d7245f242586d5d5a0cc5c892f45891c4"}], "stats": {"total": 359, "additions": 185, "deletions": 174}, "files": [{"sha": "7690f44a23d6c4e2289e1bdb9f0f95a1a13129ed", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6", "patch": "@@ -14,7 +14,7 @@ use crate::errors::{\n     AmbiguousLifetimeBound, MultipleRelaxedDefaultBounds, TraitObjectDeclaredWithNoTraits,\n     TypeofReservedKeywordUsed, ValueOfAssociatedStructAlreadySpecified,\n };\n-use crate::middle::resolve_lifetime as rl;\n+use crate::middle::resolve_bound_vars as rbv;\n use crate::require_c_abi_if_c_variadic;\n use rustc_ast::TraitObjectSyntax;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -225,10 +225,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let tcx = self.tcx();\n         let lifetime_name = |def_id| tcx.hir().name(tcx.hir().local_def_id_to_hir_id(def_id));\n \n-        match tcx.named_region(lifetime.hir_id) {\n-            Some(rl::Region::Static) => tcx.lifetimes.re_static,\n+        match tcx.named_bound_var(lifetime.hir_id) {\n+            Some(rbv::ResolvedArg::StaticLifetime) => tcx.lifetimes.re_static,\n \n-            Some(rl::Region::LateBound(debruijn, index, def_id)) => {\n+            Some(rbv::ResolvedArg::LateBound(debruijn, index, def_id)) => {\n                 let name = lifetime_name(def_id.expect_local());\n                 let br = ty::BoundRegion {\n                     var: ty::BoundVar::from_u32(index),\n@@ -237,15 +237,15 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 tcx.mk_region(ty::ReLateBound(debruijn, br))\n             }\n \n-            Some(rl::Region::EarlyBound(def_id)) => {\n+            Some(rbv::ResolvedArg::EarlyBound(def_id)) => {\n                 let name = tcx.hir().ty_param_name(def_id.expect_local());\n                 let item_def_id = tcx.hir().ty_param_owner(def_id.expect_local());\n                 let generics = tcx.generics_of(item_def_id);\n                 let index = generics.param_def_id_to_index[&def_id];\n                 tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion { def_id, index, name }))\n             }\n \n-            Some(rl::Region::Free(scope, id)) => {\n+            Some(rbv::ResolvedArg::Free(scope, id)) => {\n                 let name = lifetime_name(id.expect_local());\n                 tcx.mk_region(ty::ReFree(ty::FreeRegion {\n                     scope,\n@@ -1604,7 +1604,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             self.ast_region_to_region(lifetime, None)\n         } else {\n             self.compute_object_lifetime_bound(span, existential_predicates).unwrap_or_else(|| {\n-                if tcx.named_region(lifetime.hir_id).is_some() {\n+                if tcx.named_bound_var(lifetime.hir_id).is_some() {\n                     self.ast_region_to_region(lifetime, None)\n                 } else {\n                     self.re_infer(None, span).unwrap_or_else(|| {"}, {"sha": "bd1d81c72075a72a1034905aa2e322dc58c9ab40", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6", "patch": "@@ -41,8 +41,8 @@ use std::iter;\n \n mod generics_of;\n mod item_bounds;\n-mod lifetimes;\n mod predicates_of;\n+mod resolve_bound_vars;\n mod type_of;\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -53,7 +53,7 @@ fn collect_mod_item_types(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n }\n \n pub fn provide(providers: &mut Providers) {\n-    lifetimes::provide(providers);\n+    resolve_bound_vars::provide(providers);\n     *providers = Providers {\n         opt_const_param_of: type_of::opt_const_param_of,\n         type_of: type_of::type_of,"}, {"sha": "7bcaeadbcf67b0d0fa648eb7359bdd378587327b", "filename": "compiler/rustc_hir_analysis/src/collect/generics_of.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fgenerics_of.rs?ref=eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6", "patch": "@@ -1,4 +1,4 @@\n-use crate::middle::resolve_lifetime as rl;\n+use crate::middle::resolve_bound_vars as rbv;\n use hir::{\n     intravisit::{self, Visitor},\n     GenericParamKind, HirId, Node,\n@@ -394,10 +394,11 @@ fn has_late_bound_regions<'tcx>(tcx: TyCtxt<'tcx>, node: Node<'tcx>) -> Option<S\n                 return;\n             }\n \n-            match self.tcx.named_region(lt.hir_id) {\n-                Some(rl::Region::Static | rl::Region::EarlyBound(..)) => {}\n-                Some(rl::Region::LateBound(debruijn, _, _)) if debruijn < self.outer_index => {}\n-                Some(rl::Region::LateBound(..) | rl::Region::Free(..)) | None => {\n+            match self.tcx.named_bound_var(lt.hir_id) {\n+                Some(rbv::ResolvedArg::StaticLifetime | rbv::ResolvedArg::EarlyBound(..)) => {}\n+                Some(rbv::ResolvedArg::LateBound(debruijn, _, _))\n+                    if debruijn < self.outer_index => {}\n+                Some(rbv::ResolvedArg::LateBound(..) | rbv::ResolvedArg::Free(..)) | None => {\n                     self.has_late_bound_regions = Some(lt.ident.span);\n                 }\n             }"}, {"sha": "0b570f211785dbec56eec9334651b8e3a51845ee", "filename": "compiler/rustc_hir_analysis/src/collect/resolve_bound_vars.rs", "status": "renamed", "additions": 123, "deletions": 113, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs?ref=eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6", "patch": "@@ -16,67 +16,69 @@ use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::{GenericArg, GenericParam, GenericParamKind, HirIdMap, LifetimeName, Node};\n use rustc_middle::bug;\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::middle::resolve_lifetime::*;\n+use rustc_middle::middle::resolve_bound_vars::*;\n use rustc_middle::ty::{self, ir::TypeVisitor, DefIdTree, TyCtxt, TypeSuperVisitable};\n use rustc_span::def_id::DefId;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n use std::fmt;\n \n trait RegionExt {\n-    fn early(param: &GenericParam<'_>) -> (LocalDefId, Region);\n+    fn early(param: &GenericParam<'_>) -> (LocalDefId, ResolvedArg);\n \n-    fn late(index: u32, param: &GenericParam<'_>) -> (LocalDefId, Region);\n+    fn late(index: u32, param: &GenericParam<'_>) -> (LocalDefId, ResolvedArg);\n \n     fn id(&self) -> Option<DefId>;\n \n-    fn shifted(self, amount: u32) -> Region;\n+    fn shifted(self, amount: u32) -> ResolvedArg;\n }\n \n-impl RegionExt for Region {\n-    fn early(param: &GenericParam<'_>) -> (LocalDefId, Region) {\n+impl RegionExt for ResolvedArg {\n+    fn early(param: &GenericParam<'_>) -> (LocalDefId, ResolvedArg) {\n         debug!(\"Region::early: def_id={:?}\", param.def_id);\n-        (param.def_id, Region::EarlyBound(param.def_id.to_def_id()))\n+        (param.def_id, ResolvedArg::EarlyBound(param.def_id.to_def_id()))\n     }\n \n-    fn late(idx: u32, param: &GenericParam<'_>) -> (LocalDefId, Region) {\n+    fn late(idx: u32, param: &GenericParam<'_>) -> (LocalDefId, ResolvedArg) {\n         let depth = ty::INNERMOST;\n         debug!(\n             \"Region::late: idx={:?}, param={:?} depth={:?} def_id={:?}\",\n             idx, param, depth, param.def_id,\n         );\n-        (param.def_id, Region::LateBound(depth, idx, param.def_id.to_def_id()))\n+        (param.def_id, ResolvedArg::LateBound(depth, idx, param.def_id.to_def_id()))\n     }\n \n     fn id(&self) -> Option<DefId> {\n         match *self {\n-            Region::Static => None,\n+            ResolvedArg::StaticLifetime => None,\n \n-            Region::EarlyBound(id) | Region::LateBound(_, _, id) | Region::Free(_, id) => Some(id),\n+            ResolvedArg::EarlyBound(id)\n+            | ResolvedArg::LateBound(_, _, id)\n+            | ResolvedArg::Free(_, id) => Some(id),\n         }\n     }\n \n-    fn shifted(self, amount: u32) -> Region {\n+    fn shifted(self, amount: u32) -> ResolvedArg {\n         match self {\n-            Region::LateBound(debruijn, idx, id) => {\n-                Region::LateBound(debruijn.shifted_in(amount), idx, id)\n+            ResolvedArg::LateBound(debruijn, idx, id) => {\n+                ResolvedArg::LateBound(debruijn.shifted_in(amount), idx, id)\n             }\n             _ => self,\n         }\n     }\n }\n \n-/// Maps the id of each lifetime reference to the lifetime decl\n+/// Maps the id of each bound variable reference to the variable decl\n /// that it corresponds to.\n ///\n-/// FIXME. This struct gets converted to a `ResolveLifetimes` for\n+/// FIXME. This struct gets converted to a `ResolveBoundVars` for\n /// actual use. It has the same data, but indexed by `LocalDefId`. This\n /// is silly.\n #[derive(Debug, Default)]\n-struct NamedRegionMap {\n-    // maps from every use of a named (not anonymous) lifetime to a\n-    // `Region` describing how that region is bound\n-    defs: HirIdMap<Region>,\n+struct NamedVarMap {\n+    // maps from every use of a named (not anonymous) bound var to a\n+    // `ResolvedArg` describing how that variable is bound\n+    defs: HirIdMap<ResolvedArg>,\n \n     // Maps relevant hir items to the bound vars on them. These include:\n     // - function defs\n@@ -87,9 +89,9 @@ struct NamedRegionMap {\n     late_bound_vars: HirIdMap<Vec<ty::BoundVariableKind>>,\n }\n \n-struct LifetimeContext<'a, 'tcx> {\n+struct BoundVarContext<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    map: &'a mut NamedRegionMap,\n+    map: &'a mut NamedVarMap,\n     scope: ScopeRef<'a>,\n }\n \n@@ -102,7 +104,7 @@ enum Scope<'a> {\n     Binder {\n         /// We use an IndexMap here because we want these lifetimes in order\n         /// for diagnostics.\n-        lifetimes: FxIndexMap<LocalDefId, Region>,\n+        bound_vars: FxIndexMap<LocalDefId, ResolvedArg>,\n \n         scope_type: BinderScopeType,\n \n@@ -141,7 +143,7 @@ enum Scope<'a> {\n     /// inferred in a function body or potentially error outside one),\n     /// for the default choice of lifetime in a trait object type.\n     ObjectLifetimeDefault {\n-        lifetime: Option<Region>,\n+        lifetime: Option<ResolvedArg>,\n         s: ScopeRef<'a>,\n     },\n \n@@ -150,7 +152,7 @@ enum Scope<'a> {\n     /// lifetimes encountered when identifying the trait that an associated type\n     /// is declared on.\n     Supertrait {\n-        lifetimes: Vec<ty::BoundVariableKind>,\n+        bound_vars: Vec<ty::BoundVariableKind>,\n         s: ScopeRef<'a>,\n     },\n \n@@ -185,9 +187,9 @@ struct TruncatedScopeDebug<'a>(&'a Scope<'a>);\n impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self.0 {\n-            Scope::Binder { lifetimes, scope_type, hir_id, where_bound_origin, s: _ } => f\n+            Scope::Binder { bound_vars, scope_type, hir_id, where_bound_origin, s: _ } => f\n                 .debug_struct(\"Binder\")\n-                .field(\"lifetimes\", lifetimes)\n+                .field(\"bound_vars\", bound_vars)\n                 .field(\"scope_type\", scope_type)\n                 .field(\"hir_id\", hir_id)\n                 .field(\"where_bound_origin\", where_bound_origin)\n@@ -202,9 +204,9 @@ impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n                 .field(\"lifetime\", lifetime)\n                 .field(\"s\", &\"..\")\n                 .finish(),\n-            Scope::Supertrait { lifetimes, s: _ } => f\n+            Scope::Supertrait { bound_vars, s: _ } => f\n                 .debug_struct(\"Supertrait\")\n-                .field(\"lifetimes\", lifetimes)\n+                .field(\"bound_vars\", bound_vars)\n                 .field(\"s\", &\"..\")\n                 .finish(),\n             Scope::TraitRefBoundary { s: _ } => f.debug_struct(\"TraitRefBoundary\").finish(),\n@@ -219,27 +221,27 @@ type ScopeRef<'a> = &'a Scope<'a>;\n \n pub(crate) fn provide(providers: &mut ty::query::Providers) {\n     *providers = ty::query::Providers {\n-        resolve_lifetimes,\n+        resolve_bound_vars,\n \n-        named_region_map: |tcx, id| tcx.resolve_lifetimes(id).defs.get(&id),\n+        named_variable_map: |tcx, id| tcx.resolve_bound_vars(id).defs.get(&id),\n         is_late_bound_map,\n         object_lifetime_default,\n-        late_bound_vars_map: |tcx, id| tcx.resolve_lifetimes(id).late_bound_vars.get(&id),\n+        late_bound_vars_map: |tcx, id| tcx.resolve_bound_vars(id).late_bound_vars.get(&id),\n \n         ..*providers\n     };\n }\n \n-/// Computes the `ResolveLifetimes` map that contains data for an entire `Item`.\n+/// Computes the `ResolveBoundVars` map that contains data for an entire `Item`.\n /// You should not read the result of this query directly, but rather use\n-/// `named_region_map`, `is_late_bound_map`, etc.\n+/// `named_variable_map`, `is_late_bound_map`, etc.\n #[instrument(level = \"debug\", skip(tcx))]\n-fn resolve_lifetimes(tcx: TyCtxt<'_>, local_def_id: hir::OwnerId) -> ResolveLifetimes {\n-    let mut named_region_map =\n-        NamedRegionMap { defs: Default::default(), late_bound_vars: Default::default() };\n-    let mut visitor = LifetimeContext {\n+fn resolve_bound_vars(tcx: TyCtxt<'_>, local_def_id: hir::OwnerId) -> ResolveBoundVars {\n+    let mut named_variable_map =\n+        NamedVarMap { defs: Default::default(), late_bound_vars: Default::default() };\n+    let mut visitor = BoundVarContext {\n         tcx,\n-        map: &mut named_region_map,\n+        map: &mut named_variable_map,\n         scope: &Scope::Root { opt_parent_item: None },\n     };\n     match tcx.hir().owner(local_def_id) {\n@@ -260,13 +262,13 @@ fn resolve_lifetimes(tcx: TyCtxt<'_>, local_def_id: hir::OwnerId) -> ResolveLife\n         hir::OwnerNode::Crate(_) => {}\n     }\n \n-    let mut rl = ResolveLifetimes::default();\n+    let mut rl = ResolveBoundVars::default();\n \n-    for (hir_id, v) in named_region_map.defs {\n+    for (hir_id, v) in named_variable_map.defs {\n         let map = rl.defs.entry(hir_id.owner).or_default();\n         map.insert(hir_id.local_id, v);\n     }\n-    for (hir_id, v) in named_region_map.late_bound_vars {\n+    for (hir_id, v) in named_variable_map.late_bound_vars {\n         let map = rl.late_bound_vars.entry(hir_id.owner).or_default();\n         map.insert(hir_id.local_id, v);\n     }\n@@ -276,21 +278,21 @@ fn resolve_lifetimes(tcx: TyCtxt<'_>, local_def_id: hir::OwnerId) -> ResolveLife\n     rl\n }\n \n-fn late_region_as_bound_region(tcx: TyCtxt<'_>, region: &Region) -> ty::BoundVariableKind {\n+fn late_region_as_bound_region(tcx: TyCtxt<'_>, region: &ResolvedArg) -> ty::BoundVariableKind {\n     match region {\n-        Region::LateBound(_, _, def_id) => {\n+        ResolvedArg::LateBound(_, _, def_id) => {\n             let name = tcx.hir().name(tcx.hir().local_def_id_to_hir_id(def_id.expect_local()));\n             ty::BoundVariableKind::Region(ty::BrNamed(*def_id, name))\n         }\n-        _ => bug!(\"{:?} is not a late region\", region),\n+        _ => bug!(\"{:?} is not a late argument\", region),\n     }\n }\n \n-impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n+impl<'a, 'tcx> BoundVarContext<'a, 'tcx> {\n     /// Returns the binders in scope and the type of `Binder` that should be created for a poly trait ref.\n     fn poly_trait_ref_binder_info(&mut self) -> (Vec<ty::BoundVariableKind>, BinderScopeType) {\n         let mut scope = self.scope;\n-        let mut supertrait_lifetimes = vec![];\n+        let mut supertrait_bound_vars = vec![];\n         loop {\n             match scope {\n                 Scope::Body { .. } | Scope::Root { .. } => {\n@@ -301,29 +303,29 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     scope = s;\n                 }\n \n-                Scope::Supertrait { s, lifetimes } => {\n-                    supertrait_lifetimes = lifetimes.clone();\n+                Scope::Supertrait { s, bound_vars } => {\n+                    supertrait_bound_vars = bound_vars.clone();\n                     scope = s;\n                 }\n \n                 Scope::TraitRefBoundary { .. } => {\n                     // We should only see super trait lifetimes if there is a `Binder` above\n-                    assert!(supertrait_lifetimes.is_empty());\n+                    assert!(supertrait_bound_vars.is_empty());\n                     break (vec![], BinderScopeType::Normal);\n                 }\n \n                 Scope::Binder { hir_id, .. } => {\n                     // Nested poly trait refs have the binders concatenated\n                     let mut full_binders =\n                         self.map.late_bound_vars.entry(*hir_id).or_default().clone();\n-                    full_binders.extend(supertrait_lifetimes.into_iter());\n+                    full_binders.extend(supertrait_bound_vars.into_iter());\n                     break (full_binders, BinderScopeType::Concatenating);\n                 }\n             }\n         }\n     }\n }\n-impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for BoundVarContext<'a, 'tcx> {\n     type NestedFilter = nested_filter::OnlyBodies;\n \n     fn nested_visit_map(&mut self) -> Self::Map {\n@@ -386,13 +388,13 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 }\n             }\n \n-            let (lifetimes, binders): (FxIndexMap<LocalDefId, Region>, Vec<_>) =\n+            let (bound_vars, binders): (FxIndexMap<LocalDefId, ResolvedArg>, Vec<_>) =\n                 bound_generic_params\n                     .iter()\n                     .filter(|param| matches!(param.kind, GenericParamKind::Lifetime { .. }))\n                     .enumerate()\n                     .map(|(late_bound_idx, param)| {\n-                        let pair = Region::late(late_bound_idx as u32, param);\n+                        let pair = ResolvedArg::late(late_bound_idx as u32, param);\n                         let r = late_region_as_bound_region(self.tcx, &pair.1);\n                         (pair, r)\n                     })\n@@ -401,7 +403,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             self.record_late_bound_vars(e.hir_id, binders);\n             let scope = Scope::Binder {\n                 hir_id: e.hir_id,\n-                lifetimes,\n+                bound_vars,\n                 s: self.scope,\n                 scope_type: BinderScopeType::Normal,\n                 where_bound_origin: None,\n@@ -461,7 +463,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 // conservatively add all resolved lifetimes. Otherwise we run into problems in\n                 // cases like `type Foo<'a> = impl Bar<As = impl Baz + 'a>`.\n                 let parent_item = self.tcx.hir().get_parent_item(item.hir_id());\n-                let resolved_lifetimes: &ResolveLifetimes = self.tcx.resolve_lifetimes(parent_item);\n+                let resolved_lifetimes: &ResolveBoundVars =\n+                    self.tcx.resolve_bound_vars(parent_item);\n                 // We need to add *all* deps, since opaque tys may want them from *us*\n                 for (&owner, defs) in resolved_lifetimes.defs.iter() {\n                     defs.iter().for_each(|(&local_id, region)| {\n@@ -484,21 +487,21 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             }) => {\n                 // We want to start our early-bound indices at the end of the parent scope,\n                 // not including any parent `impl Trait`s.\n-                let mut lifetimes = FxIndexMap::default();\n+                let mut bound_vars = FxIndexMap::default();\n                 debug!(?generics.params);\n                 for param in generics.params {\n                     match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n-                            let (def_id, reg) = Region::early(&param);\n-                            lifetimes.insert(def_id, reg);\n+                            let (def_id, reg) = ResolvedArg::early(&param);\n+                            bound_vars.insert(def_id, reg);\n                         }\n                         GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {}\n                     }\n                 }\n \n                 let scope = Scope::Binder {\n                     hir_id: item.hir_id(),\n-                    lifetimes,\n+                    bound_vars,\n                     s: self.scope,\n                     scope_type: BinderScopeType::Normal,\n                     where_bound_origin: None,\n@@ -516,18 +519,18 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             | hir::ItemKind::TraitAlias(generics, ..)\n             | hir::ItemKind::Impl(&hir::Impl { generics, .. }) => {\n                 // These kinds of items have only early-bound lifetime parameters.\n-                let lifetimes = generics\n+                let bound_vars = generics\n                     .params\n                     .iter()\n                     .filter_map(|param| match param.kind {\n-                        GenericParamKind::Lifetime { .. } => Some(Region::early(param)),\n+                        GenericParamKind::Lifetime { .. } => Some(ResolvedArg::early(param)),\n                         GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => None,\n                     })\n                     .collect();\n                 self.record_late_bound_vars(item.hir_id(), vec![]);\n                 let scope = Scope::Binder {\n                     hir_id: item.hir_id(),\n-                    lifetimes,\n+                    bound_vars,\n                     scope_type: BinderScopeType::Normal,\n                     s: self.scope,\n                     where_bound_origin: None,\n@@ -562,21 +565,21 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &'tcx hir::Ty<'tcx>) {\n         match ty.kind {\n             hir::TyKind::BareFn(c) => {\n-                let (lifetimes, binders): (FxIndexMap<LocalDefId, Region>, Vec<_>) = c\n+                let (bound_vars, binders): (FxIndexMap<LocalDefId, ResolvedArg>, Vec<_>) = c\n                     .generic_params\n                     .iter()\n                     .filter(|param| matches!(param.kind, GenericParamKind::Lifetime { .. }))\n                     .enumerate()\n                     .map(|(late_bound_idx, param)| {\n-                        let pair = Region::late(late_bound_idx as u32, param);\n+                        let pair = ResolvedArg::late(late_bound_idx as u32, param);\n                         let r = late_region_as_bound_region(self.tcx, &pair.1);\n                         (pair, r)\n                     })\n                     .unzip();\n                 self.record_late_bound_vars(ty.hir_id, binders);\n                 let scope = Scope::Binder {\n                     hir_id: ty.hir_id,\n-                    lifetimes,\n+                    bound_vars,\n                     s: self.scope,\n                     scope_type: BinderScopeType::Normal,\n                     where_bound_origin: None,\n@@ -674,7 +677,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     // well-supported at the moment, so this doesn't work.\n                     // In the future, this should be fixed and this error should be removed.\n                     let def = self.map.defs.get(&lifetime.hir_id).cloned();\n-                    let Some(Region::LateBound(_, _, def_id)) = def else {\n+                    let Some(ResolvedArg::LateBound(_, _, def_id)) = def else {\n                         continue\n                     };\n                     let Some(def_id) = def_id.as_local() else {\n@@ -722,18 +725,18 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             }\n             Type(bounds, ty) => {\n                 let generics = &trait_item.generics;\n-                let lifetimes = generics\n+                let bound_vars = generics\n                     .params\n                     .iter()\n                     .filter_map(|param| match param.kind {\n-                        GenericParamKind::Lifetime { .. } => Some(Region::early(param)),\n+                        GenericParamKind::Lifetime { .. } => Some(ResolvedArg::early(param)),\n                         GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => None,\n                     })\n                     .collect();\n                 self.record_late_bound_vars(trait_item.hir_id(), vec![]);\n                 let scope = Scope::Binder {\n                     hir_id: trait_item.hir_id(),\n-                    lifetimes,\n+                    bound_vars,\n                     s: self.scope,\n                     scope_type: BinderScopeType::Normal,\n                     where_bound_origin: None,\n@@ -768,18 +771,18 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             }),\n             Type(ty) => {\n                 let generics = &impl_item.generics;\n-                let lifetimes: FxIndexMap<LocalDefId, Region> = generics\n+                let bound_vars: FxIndexMap<LocalDefId, ResolvedArg> = generics\n                     .params\n                     .iter()\n                     .filter_map(|param| match param.kind {\n-                        GenericParamKind::Lifetime { .. } => Some(Region::early(param)),\n+                        GenericParamKind::Lifetime { .. } => Some(ResolvedArg::early(param)),\n                         GenericParamKind::Const { .. } | GenericParamKind::Type { .. } => None,\n                     })\n                     .collect();\n                 self.record_late_bound_vars(impl_item.hir_id(), vec![]);\n                 let scope = Scope::Binder {\n                     hir_id: impl_item.hir_id(),\n-                    lifetimes,\n+                    bound_vars,\n                     s: self.scope,\n                     scope_type: BinderScopeType::Normal,\n                     where_bound_origin: None,\n@@ -803,7 +806,9 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     #[instrument(level = \"debug\", skip(self))]\n     fn visit_lifetime(&mut self, lifetime_ref: &'tcx hir::Lifetime) {\n         match lifetime_ref.res {\n-            hir::LifetimeName::Static => self.insert_lifetime(lifetime_ref, Region::Static),\n+            hir::LifetimeName::Static => {\n+                self.insert_lifetime(lifetime_ref, ResolvedArg::StaticLifetime)\n+            }\n             hir::LifetimeName::Param(param_def_id) => {\n                 self.resolve_lifetime_ref(param_def_id, lifetime_ref)\n             }\n@@ -869,19 +874,19 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         origin,\n                         ..\n                     }) => {\n-                        let lifetimes: FxIndexMap<LocalDefId, Region> =\n+                        let bound_vars: FxIndexMap<LocalDefId, ResolvedArg> =\n                             bound_generic_params\n                                 .iter()\n                                 .filter(|param| {\n                                     matches!(param.kind, GenericParamKind::Lifetime { .. })\n                                 })\n                                 .enumerate()\n                                 .map(|(late_bound_idx, param)| {\n-                                        Region::late(late_bound_idx as u32, param)\n+                                        ResolvedArg::late(late_bound_idx as u32, param)\n                                 })\n                                 .collect();\n                         let binders: Vec<_> =\n-                            lifetimes\n+                            bound_vars\n                                 .iter()\n                                 .map(|(_, region)| {\n                                      late_region_as_bound_region(this.tcx, region)\n@@ -894,7 +899,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         // being wrong.\n                         let scope = Scope::Binder {\n                             hir_id,\n-                            lifetimes,\n+                            bound_vars,\n                             s: this.scope,\n                             scope_type: BinderScopeType::Normal,\n                             where_bound_origin: Some(origin),\n@@ -920,7 +925,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                                 if lt.res != hir::LifetimeName::Static {\n                                     continue;\n                                 }\n-                                this.insert_lifetime(lt, Region::Static);\n+                                this.insert_lifetime(lt, ResolvedArg::StaticLifetime);\n                                 this.tcx\n                                     .sess\n                                     .struct_span_warn(\n@@ -964,7 +969,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 self.record_late_bound_vars(*hir_id, binders);\n                 let scope = Scope::Binder {\n                     hir_id: *hir_id,\n-                    lifetimes: FxIndexMap::default(),\n+                    bound_vars: FxIndexMap::default(),\n                     s: self.scope,\n                     scope_type,\n                     where_bound_origin: None,\n@@ -983,16 +988,16 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         let (mut binders, scope_type) = self.poly_trait_ref_binder_info();\n \n         let initial_bound_vars = binders.len() as u32;\n-        let mut lifetimes: FxIndexMap<LocalDefId, Region> = FxIndexMap::default();\n+        let mut bound_vars: FxIndexMap<LocalDefId, ResolvedArg> = FxIndexMap::default();\n         let binders_iter = trait_ref\n             .bound_generic_params\n             .iter()\n             .filter(|param| matches!(param.kind, GenericParamKind::Lifetime { .. }))\n             .enumerate()\n             .map(|(late_bound_idx, param)| {\n-                let pair = Region::late(initial_bound_vars + late_bound_idx as u32, param);\n+                let pair = ResolvedArg::late(initial_bound_vars + late_bound_idx as u32, param);\n                 let r = late_region_as_bound_region(self.tcx, &pair.1);\n-                lifetimes.insert(pair.0, pair.1);\n+                bound_vars.insert(pair.0, pair.1);\n                 r\n             });\n         binders.extend(binders_iter);\n@@ -1006,7 +1011,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         // refs.\n         let scope = Scope::Binder {\n             hir_id: trait_ref.trait_ref.hir_ref_id,\n-            lifetimes,\n+            bound_vars,\n             s: self.scope,\n             scope_type,\n             where_bound_origin: None,\n@@ -1063,13 +1068,13 @@ fn object_lifetime_default(tcx: TyCtxt<'_>, param_def_id: DefId) -> ObjectLifeti\n     }\n }\n \n-impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n+impl<'a, 'tcx> BoundVarContext<'a, 'tcx> {\n     fn with<F>(&mut self, wrap_scope: Scope<'_>, f: F)\n     where\n-        F: for<'b> FnOnce(&mut LifetimeContext<'b, 'tcx>),\n+        F: for<'b> FnOnce(&mut BoundVarContext<'b, 'tcx>),\n     {\n-        let LifetimeContext { tcx, map, .. } = self;\n-        let mut this = LifetimeContext { tcx: *tcx, map, scope: &wrap_scope };\n+        let BoundVarContext { tcx, map, .. } = self;\n+        let mut this = BoundVarContext { tcx: *tcx, map, scope: &wrap_scope };\n         let span = debug_span!(\"scope\", scope = ?TruncatedScopeDebug(&this.scope));\n         {\n             let _enter = span.enter();\n@@ -1110,20 +1115,20 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         generics: &'tcx hir::Generics<'tcx>,\n         walk: F,\n     ) where\n-        F: for<'b, 'c> FnOnce(&'b mut LifetimeContext<'c, 'tcx>),\n+        F: for<'b, 'c> FnOnce(&'b mut BoundVarContext<'c, 'tcx>),\n     {\n         let mut named_late_bound_vars = 0;\n-        let lifetimes: FxIndexMap<LocalDefId, Region> = generics\n+        let bound_vars: FxIndexMap<LocalDefId, ResolvedArg> = generics\n             .params\n             .iter()\n             .filter_map(|param| match param.kind {\n                 GenericParamKind::Lifetime { .. } => {\n                     if self.tcx.is_late_bound(param.hir_id) {\n                         let late_bound_idx = named_late_bound_vars;\n                         named_late_bound_vars += 1;\n-                        Some(Region::late(late_bound_idx, param))\n+                        Some(ResolvedArg::late(late_bound_idx, param))\n                     } else {\n-                        Some(Region::early(param))\n+                        Some(ResolvedArg::early(param))\n                     }\n                 }\n                 GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => None,\n@@ -1139,14 +1144,14 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             })\n             .enumerate()\n             .map(|(late_bound_idx, param)| {\n-                let pair = Region::late(late_bound_idx as u32, param);\n+                let pair = ResolvedArg::late(late_bound_idx as u32, param);\n                 late_region_as_bound_region(self.tcx, &pair.1)\n             })\n             .collect();\n         self.record_late_bound_vars(hir_id, binders);\n         let scope = Scope::Binder {\n             hir_id,\n-            lifetimes,\n+            bound_vars,\n             s: self.scope,\n             scope_type: BinderScopeType::Normal,\n             where_bound_origin: None,\n@@ -1179,13 +1184,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         && let parent_generics = self.tcx.generics_of(parent_item)\n                         && parent_generics.param_def_id_to_index.contains_key(&region_def_id.to_def_id())\n                     {\n-                        break Some(Region::EarlyBound(region_def_id.to_def_id()));\n+                        break Some(ResolvedArg::EarlyBound(region_def_id.to_def_id()));\n                     }\n                     break None;\n                 }\n \n-                Scope::Binder { ref lifetimes, scope_type, s, where_bound_origin, .. } => {\n-                    if let Some(&def) = lifetimes.get(&region_def_id) {\n+                Scope::Binder { ref bound_vars, scope_type, s, where_bound_origin, .. } => {\n+                    if let Some(&def) = bound_vars.get(&region_def_id) {\n                         break Some(def.shifted(late_depth));\n                     }\n                     match scope_type {\n@@ -1259,7 +1264,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         };\n \n         if let Some(mut def) = result {\n-            if let Region::EarlyBound(..) = def {\n+            if let ResolvedArg::EarlyBound(..) = def {\n                 // Do not free early-bound regions, only late-bound ones.\n             } else if let Some(body_id) = outermost_body {\n                 let fn_id = self.tcx.hir().body_owner(body_id);\n@@ -1275,10 +1280,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         kind: hir::ImplItemKind::Fn(..),\n                         ..\n                     }) => {\n-                        def = Region::Free(owner_id.to_def_id(), def.id().unwrap());\n+                        def = ResolvedArg::Free(owner_id.to_def_id(), def.id().unwrap());\n                     }\n                     Node::Expr(hir::Expr { kind: hir::ExprKind::Closure(closure), .. }) => {\n-                        def = Region::Free(closure.def_id.to_def_id(), def.id().unwrap());\n+                        def = ResolvedArg::Free(closure.def_id.to_def_id(), def.id().unwrap());\n                     }\n                     _ => {}\n                 }\n@@ -1415,10 +1420,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     if in_body {\n                         None\n                     } else {\n-                        Some(Region::Static)\n+                        Some(ResolvedArg::StaticLifetime)\n                     }\n                 }\n-                ObjectLifetimeDefault::Static => Some(Region::Static),\n+                ObjectLifetimeDefault::Static => Some(ResolvedArg::StaticLifetime),\n                 ObjectLifetimeDefault::Param(param_def_id) => {\n                     // This index can be used with `generic_args` since `parent_count == 0`.\n                     let index = generics.param_def_id_to_index[&param_def_id] as usize;\n@@ -1507,18 +1512,19 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         // in the trait ref `YY<...>` in `Item: YY<...>`.\n         for binding in generic_args.bindings {\n             let scope = Scope::ObjectLifetimeDefault {\n-                lifetime: if has_lifetime_parameter { None } else { Some(Region::Static) },\n+                lifetime: if has_lifetime_parameter {\n+                    None\n+                } else {\n+                    Some(ResolvedArg::StaticLifetime)\n+                },\n                 s: self.scope,\n             };\n             if let Some(type_def_id) = type_def_id {\n-                let lifetimes = LifetimeContext::supertrait_hrtb_lifetimes(\n-                    self.tcx,\n-                    type_def_id,\n-                    binding.ident,\n-                );\n+                let bound_vars =\n+                    BoundVarContext::supertrait_hrtb_vars(self.tcx, type_def_id, binding.ident);\n                 self.with(scope, |this| {\n                     let scope = Scope::Supertrait {\n-                        lifetimes: lifetimes.unwrap_or_default(),\n+                        bound_vars: bound_vars.unwrap_or_default(),\n                         s: this.scope,\n                     };\n                     this.with(scope, |this| this.visit_assoc_type_binding(binding));\n@@ -1541,7 +1547,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     /// ```\n     /// In this case, if we wanted to the supertrait HRTB lifetimes for `As` on\n     /// the starting trait `Bar`, we would return `Some(['b, 'a])`.\n-    fn supertrait_hrtb_lifetimes(\n+    fn supertrait_hrtb_vars(\n         tcx: TyCtxt<'tcx>,\n         def_id: DefId,\n         assoc_name: Ident,\n@@ -1626,7 +1632,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     scope = s;\n                 }\n \n-                Scope::Root { .. } | Scope::Elision { .. } => break Region::Static,\n+                Scope::Root { .. } | Scope::Elision { .. } => break ResolvedArg::StaticLifetime,\n \n                 Scope::Body { .. } | Scope::ObjectLifetimeDefault { lifetime: None, .. } => return,\n \n@@ -1641,15 +1647,19 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     }\n \n     #[instrument(level = \"debug\", skip(self))]\n-    fn insert_lifetime(&mut self, lifetime_ref: &'tcx hir::Lifetime, def: Region) {\n+    fn insert_lifetime(&mut self, lifetime_ref: &'tcx hir::Lifetime, def: ResolvedArg) {\n         debug!(span = ?lifetime_ref.ident.span);\n         self.map.defs.insert(lifetime_ref.hir_id, def);\n     }\n \n     /// Sometimes we resolve a lifetime, but later find that it is an\n     /// error (esp. around impl trait). In that case, we remove the\n     /// entry into `map.defs` so as not to confuse later code.\n-    fn uninsert_lifetime_on_error(&mut self, lifetime_ref: &'tcx hir::Lifetime, bad_def: Region) {\n+    fn uninsert_lifetime_on_error(\n+        &mut self,\n+        lifetime_ref: &'tcx hir::Lifetime,\n+        bad_def: ResolvedArg,\n+    ) {\n         let old_value = self.map.defs.remove(&lifetime_ref.hir_id);\n         assert_eq!(old_value, Some(bad_def));\n     }", "previous_filename": "compiler/rustc_hir_analysis/src/collect/lifetimes.rs"}, {"sha": "4fe6c6618f69851f7a20aabb8c0b570ab9237d5c", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6", "patch": "@@ -2,7 +2,7 @@ use rustc_hir as hir;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_middle::hir::map::Map;\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::middle::resolve_lifetime as rl;\n+use rustc_middle::middle::resolve_bound_vars as rbv;\n use rustc_middle::ty::{self, Region, TyCtxt};\n \n /// This function calls the `visit_ty` method for the parameters\n@@ -99,11 +99,11 @@ impl<'tcx> Visitor<'tcx> for FindNestedTypeVisitor<'tcx> {\n             hir::TyKind::Ref(ref lifetime, _) => {\n                 // the lifetime of the Ref\n                 let hir_id = lifetime.hir_id;\n-                match (self.tcx.named_region(hir_id), self.bound_region) {\n+                match (self.tcx.named_bound_var(hir_id), self.bound_region) {\n                     // Find the index of the named region that was part of the\n                     // error. We will then search the function parameters for a bound\n                     // region at the right depth with the same index\n-                    (Some(rl::Region::EarlyBound(id)), ty::BrNamed(def_id, _)) => {\n+                    (Some(rbv::ResolvedArg::EarlyBound(id)), ty::BrNamed(def_id, _)) => {\n                         debug!(\"EarlyBound id={:?} def_id={:?}\", id, def_id);\n                         if id == def_id {\n                             self.found_type = Some(arg);\n@@ -115,7 +115,7 @@ impl<'tcx> Visitor<'tcx> for FindNestedTypeVisitor<'tcx> {\n                     // error. We will then search the function parameters for a bound\n                     // region at the right depth with the same index\n                     (\n-                        Some(rl::Region::LateBound(debruijn_index, _, id)),\n+                        Some(rbv::ResolvedArg::LateBound(debruijn_index, _, id)),\n                         ty::BrNamed(def_id, _),\n                     ) => {\n                         debug!(\n@@ -131,10 +131,10 @@ impl<'tcx> Visitor<'tcx> for FindNestedTypeVisitor<'tcx> {\n \n                     (\n                         Some(\n-                            rl::Region::Static\n-                            | rl::Region::Free(_, _)\n-                            | rl::Region::EarlyBound(_)\n-                            | rl::Region::LateBound(_, _, _),\n+                            rbv::ResolvedArg::StaticLifetime\n+                            | rbv::ResolvedArg::Free(_, _)\n+                            | rbv::ResolvedArg::EarlyBound(_)\n+                            | rbv::ResolvedArg::LateBound(_, _, _),\n                         )\n                         | None,\n                         _,\n@@ -186,17 +186,17 @@ impl<'tcx> Visitor<'tcx> for TyPathVisitor<'tcx> {\n     }\n \n     fn visit_lifetime(&mut self, lifetime: &hir::Lifetime) {\n-        match (self.tcx.named_region(lifetime.hir_id), self.bound_region) {\n+        match (self.tcx.named_bound_var(lifetime.hir_id), self.bound_region) {\n             // the lifetime of the TyPath!\n-            (Some(rl::Region::EarlyBound(id)), ty::BrNamed(def_id, _)) => {\n+            (Some(rbv::ResolvedArg::EarlyBound(id)), ty::BrNamed(def_id, _)) => {\n                 debug!(\"EarlyBound id={:?} def_id={:?}\", id, def_id);\n                 if id == def_id {\n                     self.found_it = true;\n                     return; // we can stop visiting now\n                 }\n             }\n \n-            (Some(rl::Region::LateBound(debruijn_index, _, id)), ty::BrNamed(def_id, _)) => {\n+            (Some(rbv::ResolvedArg::LateBound(debruijn_index, _, id)), ty::BrNamed(def_id, _)) => {\n                 debug!(\"FindNestedTypeVisitor::visit_ty: LateBound depth = {:?}\", debruijn_index,);\n                 debug!(\"id={:?}\", id);\n                 debug!(\"def_id={:?}\", def_id);\n@@ -208,10 +208,10 @@ impl<'tcx> Visitor<'tcx> for TyPathVisitor<'tcx> {\n \n             (\n                 Some(\n-                    rl::Region::Static\n-                    | rl::Region::EarlyBound(_)\n-                    | rl::Region::LateBound(_, _, _)\n-                    | rl::Region::Free(_, _),\n+                    rbv::ResolvedArg::StaticLifetime\n+                    | rbv::ResolvedArg::EarlyBound(_)\n+                    | rbv::ResolvedArg::LateBound(_, _, _)\n+                    | rbv::ResolvedArg::Free(_, _),\n                 )\n                 | None,\n                 _,"}, {"sha": "bf6a7128b1b6e03f7084811dceacf6cea7410610", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6", "patch": "@@ -2007,7 +2007,7 @@ impl ExplicitOutlivesRequirements {\n         inferred_outlives: &[ty::Region<'tcx>],\n         predicate_span: Span,\n     ) -> Vec<(usize, Span)> {\n-        use rustc_middle::middle::resolve_lifetime::Region;\n+        use rustc_middle::middle::resolve_bound_vars::ResolvedArg;\n \n         bounds\n             .iter()\n@@ -2017,8 +2017,8 @@ impl ExplicitOutlivesRequirements {\n                     return None;\n                 };\n \n-                let is_inferred = match tcx.named_region(lifetime.hir_id) {\n-                    Some(Region::EarlyBound(def_id)) => inferred_outlives\n+                let is_inferred = match tcx.named_bound_var(lifetime.hir_id) {\n+                    Some(ResolvedArg::EarlyBound(def_id)) => inferred_outlives\n                         .iter()\n                         .any(|r| matches!(**r, ty::ReEarlyBound(ebr) if { ebr.def_id == def_id })),\n                     _ => false,\n@@ -2097,7 +2097,7 @@ impl ExplicitOutlivesRequirements {\n \n impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n-        use rustc_middle::middle::resolve_lifetime::Region;\n+        use rustc_middle::middle::resolve_bound_vars::ResolvedArg;\n \n         let def_id = item.owner_id.def_id;\n         if let hir::ItemKind::Struct(_, hir_generics)\n@@ -2120,8 +2120,8 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n                 let (relevant_lifetimes, bounds, predicate_span, in_where_clause) =\n                     match where_predicate {\n                         hir::WherePredicate::RegionPredicate(predicate) => {\n-                            if let Some(Region::EarlyBound(region_def_id)) =\n-                                cx.tcx.named_region(predicate.lifetime.hir_id)\n+                            if let Some(ResolvedArg::EarlyBound(region_def_id)) =\n+                                cx.tcx.named_bound_var(predicate.lifetime.hir_id)\n                             {\n                                 (\n                                     Self::lifetimes_outliving_lifetime("}, {"sha": "a9fb8b246c679e48893c09862fce71e8a4a5b4b5", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6", "patch": "@@ -18,7 +18,7 @@ use rustc_index::vec::IndexVec;\n use rustc_middle::metadata::ModChild;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrs;\n use rustc_middle::middle::exported_symbols::{ExportedSymbol, SymbolExportInfo};\n-use rustc_middle::middle::resolve_lifetime::ObjectLifetimeDefault;\n+use rustc_middle::middle::resolve_bound_vars::ObjectLifetimeDefault;\n use rustc_middle::mir;\n use rustc_middle::ty::fast_reject::SimplifiedType;\n use rustc_middle::ty::query::Providers;"}, {"sha": "0b6774f1b1fe1d0582314b50fa764028cb2a3467", "filename": "compiler/rustc_middle/src/middle/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fmod.rs?ref=eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6", "patch": "@@ -29,7 +29,7 @@ pub mod lib_features {\n pub mod limits;\n pub mod privacy;\n pub mod region;\n-pub mod resolve_lifetime;\n+pub mod resolve_bound_vars;\n pub mod stability;\n \n pub fn provide(providers: &mut crate::ty::query::Providers) {"}, {"sha": "cd4576969421091200fbfe11401584a8d0f41c71", "filename": "compiler/rustc_middle/src/middle/resolve_bound_vars.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_bound_vars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_bound_vars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_bound_vars.rs?ref=eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6", "patch": "@@ -1,4 +1,4 @@\n-//! Name resolution for lifetimes: type declarations.\n+//! Name resolution for lifetimes and late-bound type and const variables: type declarations.\n \n use crate::ty;\n \n@@ -8,8 +8,8 @@ use rustc_hir::{ItemLocalId, OwnerId};\n use rustc_macros::HashStable;\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable, Debug, HashStable)]\n-pub enum Region {\n-    Static,\n+pub enum ResolvedArg {\n+    StaticLifetime,\n     EarlyBound(/* lifetime decl */ DefId),\n     LateBound(ty::DebruijnIndex, /* late-bound index */ u32, /* lifetime decl */ DefId),\n     Free(DefId, /* lifetime decl */ DefId),\n@@ -46,10 +46,10 @@ pub enum ObjectLifetimeDefault {\n /// Maps the id of each lifetime reference to the lifetime decl\n /// that it corresponds to.\n #[derive(Default, HashStable, Debug)]\n-pub struct ResolveLifetimes {\n+pub struct ResolveBoundVars {\n     /// Maps from every use of a named (not anonymous) lifetime to a\n     /// `Region` describing how that region is bound\n-    pub defs: FxHashMap<OwnerId, FxHashMap<ItemLocalId, Region>>,\n+    pub defs: FxHashMap<OwnerId, FxHashMap<ItemLocalId, ResolvedArg>>,\n \n     pub late_bound_vars: FxHashMap<OwnerId, FxHashMap<ItemLocalId, Vec<ty::BoundVariableKind>>>,\n }", "previous_filename": "compiler/rustc_middle/src/middle/resolve_lifetime.rs"}, {"sha": "c793676146dada41d79cdb742fbad1b58c876415", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6", "patch": "@@ -1641,12 +1641,12 @@ rustc_queries! {\n     /// Does lifetime resolution on items. Importantly, we can't resolve\n     /// lifetimes directly on things like trait methods, because of trait params.\n     /// See `rustc_resolve::late::lifetimes for details.\n-    query resolve_lifetimes(_: hir::OwnerId) -> &'tcx ResolveLifetimes {\n+    query resolve_bound_vars(_: hir::OwnerId) -> &'tcx ResolveBoundVars {\n         arena_cache\n         desc { \"resolving lifetimes\" }\n     }\n-    query named_region_map(_: hir::OwnerId) ->\n-        Option<&'tcx FxHashMap<ItemLocalId, Region>> {\n+    query named_variable_map(_: hir::OwnerId) ->\n+        Option<&'tcx FxHashMap<ItemLocalId, ResolvedArg>> {\n         desc { \"looking up a named region\" }\n     }\n     query is_late_bound_map(_: hir::OwnerId) -> Option<&'tcx FxIndexSet<ItemLocalId>> {"}, {"sha": "9c64454fbe67b88b16ef415912d5fe109ed8807e", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6", "patch": "@@ -9,7 +9,7 @@ use crate::dep_graph::{DepGraph, DepKindStruct};\n use crate::infer::canonical::{CanonicalVarInfo, CanonicalVarInfos};\n use crate::lint::struct_lint_level;\n use crate::middle::codegen_fn_attrs::CodegenFnAttrs;\n-use crate::middle::resolve_lifetime;\n+use crate::middle::resolve_bound_vars;\n use crate::middle::stability;\n use crate::mir::interpret::{self, Allocation, ConstAllocation};\n use crate::mir::{\n@@ -2278,9 +2278,9 @@ impl<'tcx> TyCtxt<'tcx> {\n         Some(&*candidates)\n     }\n \n-    pub fn named_region(self, id: HirId) -> Option<resolve_lifetime::Region> {\n+    pub fn named_bound_var(self, id: HirId) -> Option<resolve_bound_vars::ResolvedArg> {\n         debug!(?id, \"named_region\");\n-        self.named_region_map(id.owner).and_then(|map| map.get(&id.local_id).cloned())\n+        self.named_variable_map(id.owner).and_then(|map| map.get(&id.local_id).cloned())\n     }\n \n     pub fn is_late_bound(self, id: HirId) -> bool {"}, {"sha": "8849e7eab335c6b100068acc0d7aaf5c6e30bae1", "filename": "compiler/rustc_middle/src/ty/parameterized.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs?ref=eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6", "patch": "@@ -57,7 +57,7 @@ trivially_parameterized_over_tcx! {\n     crate::metadata::ModChild,\n     crate::middle::codegen_fn_attrs::CodegenFnAttrs,\n     crate::middle::exported_symbols::SymbolExportInfo,\n-    crate::middle::resolve_lifetime::ObjectLifetimeDefault,\n+    crate::middle::resolve_bound_vars::ObjectLifetimeDefault,\n     crate::mir::ConstQualifs,\n     ty::AssocItemContainer,\n     ty::DeducedParamAttrs,"}, {"sha": "f1128d7c8bb7d39ba09b8919098d74ac1c22483d", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6", "patch": "@@ -6,7 +6,7 @@ use crate::middle::codegen_fn_attrs::CodegenFnAttrs;\n use crate::middle::exported_symbols::{ExportedSymbol, SymbolExportInfo};\n use crate::middle::lib_features::LibFeatures;\n use crate::middle::privacy::EffectiveVisibilities;\n-use crate::middle::resolve_lifetime::{ObjectLifetimeDefault, Region, ResolveLifetimes};\n+use crate::middle::resolve_bound_vars::{ObjectLifetimeDefault, ResolveBoundVars, ResolvedArg};\n use crate::middle::stability::{self, DeprecationEntry};\n use crate::mir;\n use crate::mir::interpret::GlobalId;"}, {"sha": "9e7d9873bed68dde3beb688dfb7680ee5765a062", "filename": "compiler/rustc_mir_transform/src/ssa.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs?ref=eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6", "patch": "@@ -2,7 +2,7 @@ use either::Either;\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n-use rustc_middle::middle::resolve_lifetime::Set1;\n+use rustc_middle::middle::resolve_bound_vars::Set1;\n use rustc_middle::mir::visit::*;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{ParamEnv, TyCtxt};"}, {"sha": "7cff8996d248dbdd8e051f0d333ffd4430aa9207", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6", "patch": "@@ -18,7 +18,7 @@ use rustc_hir::{\n };\n use rustc_hir::{MethodKind, Target, Unsafety};\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::middle::resolve_lifetime::ObjectLifetimeDefault;\n+use rustc_middle::middle::resolve_bound_vars::ObjectLifetimeDefault;\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{ParamEnv, TyCtxt};"}, {"sha": "844afb55f1751589831f5410d27d609f16daeff7", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6", "patch": "@@ -21,7 +21,7 @@ use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorKind, DefKind, LifetimeRes, PartialRes, PerNS};\n use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_hir::{BindingAnnotation, PrimTy, TraitCandidate};\n-use rustc_middle::middle::resolve_lifetime::Set1;\n+use rustc_middle::middle::resolve_bound_vars::Set1;\n use rustc_middle::ty::DefIdTree;\n use rustc_middle::{bug, span_bug};\n use rustc_session::config::{CrateType, ResolveDocLinks};\n@@ -2505,7 +2505,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n \n             let res = match kind {\n                 ItemRibKind(..) | AssocItemRibKind => Res::Def(def_kind, def_id.to_def_id()),\n-                NormalRibKind => Res::Err,\n+                NormalRibKind => Res::Err, /* FIXME(non_lifetime_binder): Resolve this to \"late\" */\n                 _ => span_bug!(param.ident.span, \"Unexpected rib kind {:?}\", kind),\n             };\n             self.r.record_partial_res(param.id, PartialRes::new(res));"}, {"sha": "1c01a9c6249dcfe94218df70edb4717841cacdb4", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6", "patch": "@@ -19,7 +19,7 @@ use rustc_hir::def_id::{DefId, DefIdMap, DefIdSet, LocalDefId, LOCAL_CRATE};\n use rustc_hir::PredicateOrigin;\n use rustc_hir_analysis::hir_ty_to_ty;\n use rustc_infer::infer::region_constraints::{Constraint, RegionConstraintData};\n-use rustc_middle::middle::resolve_lifetime as rl;\n+use rustc_middle::middle::resolve_bound_vars as rbv;\n use rustc_middle::ty::fold::ir::TypeFolder;\n use rustc_middle::ty::InternalSubsts;\n use rustc_middle::ty::TypeVisitable;\n@@ -198,11 +198,11 @@ fn clean_poly_trait_ref_with_bindings<'tcx>(\n }\n \n fn clean_lifetime<'tcx>(lifetime: &hir::Lifetime, cx: &mut DocContext<'tcx>) -> Lifetime {\n-    let def = cx.tcx.named_region(lifetime.hir_id);\n+    let def = cx.tcx.named_bound_var(lifetime.hir_id);\n     if let Some(\n-        rl::Region::EarlyBound(node_id)\n-        | rl::Region::LateBound(_, _, node_id)\n-        | rl::Region::Free(_, node_id),\n+        rbv::ResolvedArg::EarlyBound(node_id)\n+        | rbv::ResolvedArg::LateBound(_, _, node_id)\n+        | rbv::ResolvedArg::Free(_, node_id),\n     ) = def\n     {\n         if let Some(lt) = cx.substs.get(&node_id).and_then(|p| p.as_lt()).cloned() {"}, {"sha": "fc550936165e63e21fadaf8a66f30d67549e31f1", "filename": "src/tools/clippy/clippy_lints/src/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs?ref=eff2cb7760ffd1ed06fd5a68ba04dcb6689106f6", "patch": "@@ -505,13 +505,13 @@ fn check_mut_from_ref<'tcx>(cx: &LateContext<'tcx>, sig: &FnSig<'_>, body: Optio\n     if let FnRetTy::Return(ty) = sig.decl.output\n         && let Some((out, Mutability::Mut, _)) = get_ref_lm(ty)\n     {\n-        let out_region = cx.tcx.named_region(out.hir_id);\n+        let out_region = cx.tcx.named_bound_var(out.hir_id);\n         let args: Option<Vec<_>> = sig\n             .decl\n             .inputs\n             .iter()\n             .filter_map(get_ref_lm)\n-            .filter(|&(lt, _, _)| cx.tcx.named_region(lt.hir_id) == out_region)\n+            .filter(|&(lt, _, _)| cx.tcx.named_bound_var(lt.hir_id) == out_region)\n             .map(|(_, mutability, span)| (mutability == Mutability::Not).then_some(span))\n             .collect();\n         if let Some(args) = args"}]}