{"sha": "08babdb412a87960fe3602e92abf1bf5fe26a8da", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4YmFiZGI0MTJhODc5NjBmZTM2MDJlOTJhYmYxYmY1ZmUyNmE4ZGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-01T02:39:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-01T02:39:40Z"}, "message": "Auto merge of #38653 - Mark-Simulacrum:dropless-arena, r=eddyb\n\nAdd a DroplessArena and utilize it as a more efficient arena when possible\n\nI will collect performance (probably just `-Ztime-passes`, and more if that shows significant differences, perhaps).\n\n6feba98 also fixes a potential infinite loop if inplace reallocation failed for `TypedArena` (and `DroplessArena` via copied code).\n\nr? @eddyb", "tree": {"sha": "58a3a654b7d375e210318b5032bd4968a50f2987", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58a3a654b7d375e210318b5032bd4968a50f2987"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08babdb412a87960fe3602e92abf1bf5fe26a8da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08babdb412a87960fe3602e92abf1bf5fe26a8da", "html_url": "https://github.com/rust-lang/rust/commit/08babdb412a87960fe3602e92abf1bf5fe26a8da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08babdb412a87960fe3602e92abf1bf5fe26a8da/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07412c8d253121ee912014021a1dd7308b7154a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/07412c8d253121ee912014021a1dd7308b7154a1", "html_url": "https://github.com/rust-lang/rust/commit/07412c8d253121ee912014021a1dd7308b7154a1"}, {"sha": "1676bec5bff054a31c2d2118a7cfadddbb410560", "url": "https://api.github.com/repos/rust-lang/rust/commits/1676bec5bff054a31c2d2118a7cfadddbb410560", "html_url": "https://github.com/rust-lang/rust/commit/1676bec5bff054a31c2d2118a7cfadddbb410560"}], "stats": {"total": 328, "additions": 228, "deletions": 100}, "files": [{"sha": "174a93ed23e099abe4c3175b9b338d5335a8a914", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 129, "deletions": 2, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/08babdb412a87960fe3602e92abf1bf5fe26a8da/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08babdb412a87960fe3602e92abf1bf5fe26a8da/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=08babdb412a87960fe3602e92abf1bf5fe26a8da", "patch": "@@ -196,9 +196,9 @@ impl<T> TypedArena<T> {\n                     self.end.set(last_chunk.end());\n                     return;\n                 } else {\n-                    let prev_capacity = last_chunk.storage.cap();\n+                    new_capacity = last_chunk.storage.cap();\n                     loop {\n-                        new_capacity = prev_capacity.checked_mul(2).unwrap();\n+                        new_capacity = new_capacity.checked_mul(2).unwrap();\n                         if new_capacity >= currently_used_cap + n {\n                             break;\n                         }\n@@ -280,6 +280,133 @@ impl<T> Drop for TypedArena<T> {\n \n unsafe impl<T: Send> Send for TypedArena<T> {}\n \n+pub struct DroplessArena {\n+    /// A pointer to the next object to be allocated.\n+    ptr: Cell<*mut u8>,\n+\n+    /// A pointer to the end of the allocated area. When this pointer is\n+    /// reached, a new chunk is allocated.\n+    end: Cell<*mut u8>,\n+\n+    /// A vector of arena chunks.\n+    chunks: RefCell<Vec<TypedArenaChunk<u8>>>,\n+}\n+\n+impl DroplessArena {\n+    pub fn new() -> DroplessArena {\n+        DroplessArena {\n+            ptr: Cell::new(0 as *mut u8),\n+            end: Cell::new(0 as *mut u8),\n+            chunks: RefCell::new(vec![]),\n+        }\n+    }\n+\n+    pub fn in_arena<T: ?Sized>(&self, ptr: *const T) -> bool {\n+        let ptr = ptr as *const u8 as *mut u8;\n+        for chunk in &*self.chunks.borrow() {\n+            if chunk.start() <= ptr && ptr < chunk.end() {\n+                return true;\n+            }\n+        }\n+\n+        false\n+    }\n+\n+    fn align_for<T>(&self) {\n+        let align = mem::align_of::<T>();\n+        let final_address = ((self.ptr.get() as usize) + align - 1) & !(align - 1);\n+        self.ptr.set(final_address as *mut u8);\n+        assert!(self.ptr <= self.end);\n+    }\n+\n+    #[inline(never)]\n+    #[cold]\n+    fn grow<T>(&self, n: usize) {\n+        let needed_bytes = n * mem::size_of::<T>();\n+        unsafe {\n+            let mut chunks = self.chunks.borrow_mut();\n+            let (chunk, mut new_capacity);\n+            if let Some(last_chunk) = chunks.last_mut() {\n+                let used_bytes = self.ptr.get() as usize - last_chunk.start() as usize;\n+                if last_chunk.storage.reserve_in_place(used_bytes, needed_bytes) {\n+                    self.end.set(last_chunk.end());\n+                    return;\n+                } else {\n+                    new_capacity = last_chunk.storage.cap();\n+                    loop {\n+                        new_capacity = new_capacity.checked_mul(2).unwrap();\n+                        if new_capacity >= used_bytes + needed_bytes {\n+                            break;\n+                        }\n+                    }\n+                }\n+            } else {\n+                new_capacity = cmp::max(needed_bytes, PAGE);\n+            }\n+            chunk = TypedArenaChunk::<u8>::new(new_capacity);\n+            self.ptr.set(chunk.start());\n+            self.end.set(chunk.end());\n+            chunks.push(chunk);\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn alloc<T>(&self, object: T) -> &mut T {\n+        unsafe {\n+            assert!(!intrinsics::needs_drop::<T>());\n+            assert!(mem::size_of::<T>() != 0);\n+\n+            self.align_for::<T>();\n+            let future_end = intrinsics::arith_offset(self.ptr.get(), mem::size_of::<T>() as isize);\n+            if (future_end as *mut u8) >= self.end.get() {\n+                self.grow::<T>(1)\n+            }\n+\n+            let ptr = self.ptr.get();\n+            // Set the pointer past ourselves\n+            self.ptr.set(intrinsics::arith_offset(\n+                    self.ptr.get(), mem::size_of::<T>() as isize\n+            ) as *mut u8);\n+            // Write into uninitialized memory.\n+            ptr::write(ptr as *mut T, object);\n+            &mut *(ptr as *mut T)\n+        }\n+    }\n+\n+    /// Allocates a slice of objects that are copied into the `DroplessArena`, returning a mutable\n+    /// reference to it. Will panic if passed a zero-sized type.\n+    ///\n+    /// Panics:\n+    ///  - Zero-sized types\n+    ///  - Zero-length slices\n+    #[inline]\n+    pub fn alloc_slice<T>(&self, slice: &[T]) -> &mut [T]\n+        where T: Copy {\n+        unsafe {\n+            assert!(!intrinsics::needs_drop::<T>());\n+        }\n+        assert!(mem::size_of::<T>() != 0);\n+        assert!(slice.len() != 0);\n+        self.align_for::<T>();\n+\n+        let future_end = unsafe {\n+            intrinsics::arith_offset(self.ptr.get(), (slice.len() * mem::size_of::<T>()) as isize)\n+        };\n+        if (future_end as *mut u8) >= self.end.get() {\n+            self.grow::<T>(slice.len());\n+        }\n+\n+        unsafe {\n+            let arena_slice = slice::from_raw_parts_mut(self.ptr.get() as *mut T, slice.len());\n+            self.ptr.set(intrinsics::arith_offset(\n+                    self.ptr.get(), (slice.len() * mem::size_of::<T>()) as isize\n+            ) as *mut u8);\n+            arena_slice.copy_from_slice(slice);\n+            arena_slice\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     extern crate test;"}, {"sha": "7b6ed56b779fde63de51ac2a6160875aac2a3d95", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/08babdb412a87960fe3602e92abf1bf5fe26a8da/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08babdb412a87960fe3602e92abf1bf5fe26a8da/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=08babdb412a87960fe3602e92abf1bf5fe26a8da", "patch": "@@ -41,6 +41,7 @@ use syntax::ast;\n use errors::DiagnosticBuilder;\n use syntax_pos::{self, Span, DUMMY_SP};\n use util::nodemap::{FxHashMap, FxHashSet, NodeMap};\n+use arena::DroplessArena;\n \n use self::combine::CombineFields;\n use self::higher_ranked::HrMatchResult;\n@@ -374,7 +375,7 @@ impl fmt::Display for FixupError {\n /// F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(InferCtxt<'b, 'gcx, 'tcx>).\n pub struct InferCtxtBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     global_tcx: TyCtxt<'a, 'gcx, 'gcx>,\n-    arenas: ty::CtxtArenas<'tcx>,\n+    arena: DroplessArena,\n     tables: Option<RefCell<ty::Tables<'tcx>>>,\n     param_env: Option<ty::ParameterEnvironment<'gcx>>,\n     projection_mode: Reveal,\n@@ -388,7 +389,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n                       -> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n         InferCtxtBuilder {\n             global_tcx: self,\n-            arenas: ty::CtxtArenas::new(),\n+            arena: DroplessArena::new(),\n             tables: tables.map(RefCell::new),\n             param_env: param_env,\n             projection_mode: projection_mode,\n@@ -426,7 +427,7 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n     {\n         let InferCtxtBuilder {\n             global_tcx,\n-            ref arenas,\n+            ref arena,\n             ref tables,\n             ref mut param_env,\n             projection_mode,\n@@ -439,7 +440,7 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n         let param_env = param_env.take().unwrap_or_else(|| {\n             global_tcx.empty_parameter_environment()\n         });\n-        global_tcx.enter_local(arenas, |tcx| f(InferCtxt {\n+        global_tcx.enter_local(arena, |tcx| f(InferCtxt {\n             tcx: tcx,\n             tables: tables,\n             projection_cache: RefCell::new(traits::ProjectionCache::new()),"}, {"sha": "f58d7dcb45f3043193d5b65652c79ff5f452002c", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 53, "deletions": 80, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/08babdb412a87960fe3602e92abf1bf5fe26a8da/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08babdb412a87960fe3602e92abf1bf5fe26a8da/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=08babdb412a87960fe3602e92abf1bf5fe26a8da", "patch": "@@ -39,7 +39,7 @@ use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet};\n use util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n \n-use arena::TypedArena;\n+use arena::{TypedArena, DroplessArena};\n use std::borrow::Borrow;\n use std::cell::{Cell, RefCell};\n use std::hash::{Hash, Hasher};\n@@ -55,16 +55,9 @@ use syntax::symbol::{Symbol, keywords};\n use hir;\n \n /// Internal storage\n-pub struct CtxtArenas<'tcx> {\n+pub struct GlobalArenas<'tcx> {\n     // internings\n-    type_: TypedArena<TyS<'tcx>>,\n-    type_list: TypedArena<Ty<'tcx>>,\n-    substs: TypedArena<Kind<'tcx>>,\n-    bare_fn: TypedArena<BareFnTy<'tcx>>,\n-    region: TypedArena<Region>,\n-    stability: TypedArena<attr::Stability>,\n     layout: TypedArena<Layout>,\n-    existential_predicates: TypedArena<ExistentialPredicate<'tcx>>,\n \n     // references\n     generics: TypedArena<ty::Generics<'tcx>>,\n@@ -73,29 +66,21 @@ pub struct CtxtArenas<'tcx> {\n     mir: TypedArena<RefCell<Mir<'tcx>>>,\n }\n \n-impl<'tcx> CtxtArenas<'tcx> {\n-    pub fn new() -> CtxtArenas<'tcx> {\n-        CtxtArenas {\n-            type_: TypedArena::new(),\n-            type_list: TypedArena::new(),\n-            substs: TypedArena::new(),\n-            bare_fn: TypedArena::new(),\n-            region: TypedArena::new(),\n-            stability: TypedArena::new(),\n+impl<'tcx> GlobalArenas<'tcx> {\n+    pub fn new() -> GlobalArenas<'tcx> {\n+        GlobalArenas {\n             layout: TypedArena::new(),\n-            existential_predicates: TypedArena::new(),\n-\n             generics: TypedArena::new(),\n             trait_def: TypedArena::new(),\n             adt_def: TypedArena::new(),\n-            mir: TypedArena::new()\n+            mir: TypedArena::new(),\n         }\n     }\n }\n \n pub struct CtxtInterners<'tcx> {\n-    /// The arenas that types etc are allocated from.\n-    arenas: &'tcx CtxtArenas<'tcx>,\n+    /// The arena that types, regions, etc are allocated from\n+    arena: &'tcx DroplessArena,\n \n     /// Specifically use a speedy hash algorithm for these hash sets,\n     /// they're accessed quite often.\n@@ -104,22 +89,18 @@ pub struct CtxtInterners<'tcx> {\n     substs: RefCell<FxHashSet<Interned<'tcx, Substs<'tcx>>>>,\n     bare_fn: RefCell<FxHashSet<Interned<'tcx, BareFnTy<'tcx>>>>,\n     region: RefCell<FxHashSet<Interned<'tcx, Region>>>,\n-    stability: RefCell<FxHashSet<&'tcx attr::Stability>>,\n-    layout: RefCell<FxHashSet<&'tcx Layout>>,\n     existential_predicates: RefCell<FxHashSet<Interned<'tcx, Slice<ExistentialPredicate<'tcx>>>>>,\n }\n \n impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n-    fn new(arenas: &'tcx CtxtArenas<'tcx>) -> CtxtInterners<'tcx> {\n+    fn new(arena: &'tcx DroplessArena) -> CtxtInterners<'tcx> {\n         CtxtInterners {\n-            arenas: arenas,\n+            arena: arena,\n             type_: RefCell::new(FxHashSet()),\n             type_list: RefCell::new(FxHashSet()),\n             substs: RefCell::new(FxHashSet()),\n             bare_fn: RefCell::new(FxHashSet()),\n             region: RefCell::new(FxHashSet()),\n-            stability: RefCell::new(FxHashSet()),\n-            layout: RefCell::new(FxHashSet()),\n             existential_predicates: RefCell::new(FxHashSet()),\n         }\n     }\n@@ -158,7 +139,7 @@ impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n                     let ty_struct: TyS<'gcx> = unsafe {\n                         mem::transmute(ty_struct)\n                     };\n-                    let ty: Ty<'gcx> = interner.arenas.type_.alloc(ty_struct);\n+                    let ty: Ty<'gcx> = interner.arena.alloc(ty_struct);\n                     global_interner.unwrap().insert(Interned(ty));\n                     return ty;\n                 }\n@@ -174,7 +155,7 @@ impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n             }\n \n             // Don't be &mut TyS.\n-            let ty: Ty<'tcx> = self.arenas.type_.alloc(ty_struct);\n+            let ty: Ty<'tcx> = self.arena.alloc(ty_struct);\n             interner.insert(Interned(ty));\n             ty\n         };\n@@ -391,6 +372,7 @@ impl<'a, 'gcx, 'tcx> Deref for TyCtxt<'a, 'gcx, 'tcx> {\n }\n \n pub struct GlobalCtxt<'tcx> {\n+    global_arenas: &'tcx GlobalArenas<'tcx>,\n     global_interners: CtxtInterners<'tcx>,\n \n     pub specializes_cache: RefCell<traits::SpecializesCache>,\n@@ -586,6 +568,10 @@ pub struct GlobalCtxt<'tcx> {\n     /// Map from function to the `#[derive]` mode that it's defining. Only used\n     /// by `proc-macro` crates.\n     pub derive_macros: RefCell<NodeMap<Symbol>>,\n+\n+    stability_interner: RefCell<FxHashSet<&'tcx attr::Stability>>,\n+\n+    layout_interner: RefCell<FxHashSet<&'tcx Layout>>,\n }\n \n impl<'tcx> GlobalCtxt<'tcx> {\n@@ -649,15 +635,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn alloc_generics(self, generics: ty::Generics<'gcx>)\n                           -> &'gcx ty::Generics<'gcx> {\n-        self.global_interners.arenas.generics.alloc(generics)\n+        self.global_arenas.generics.alloc(generics)\n     }\n \n     pub fn alloc_mir(self, mir: Mir<'gcx>) -> &'gcx RefCell<Mir<'gcx>> {\n-        self.global_interners.arenas.mir.alloc(RefCell::new(mir))\n+        self.global_arenas.mir.alloc(RefCell::new(mir))\n     }\n \n     pub fn alloc_trait_def(self, def: ty::TraitDef) -> &'gcx ty::TraitDef {\n-        self.global_interners.arenas.trait_def.alloc(def)\n+        self.global_arenas.trait_def.alloc(def)\n     }\n \n     pub fn alloc_adt_def(self,\n@@ -666,32 +652,28 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                          variants: Vec<ty::VariantDef>)\n                          -> &'gcx ty::AdtDef {\n         let def = ty::AdtDef::new(self, did, kind, variants);\n-        self.global_interners.arenas.adt_def.alloc(def)\n+        self.global_arenas.adt_def.alloc(def)\n     }\n \n     pub fn intern_stability(self, stab: attr::Stability) -> &'gcx attr::Stability {\n-        if let Some(st) = self.global_interners.stability.borrow().get(&stab) {\n+        if let Some(st) = self.stability_interner.borrow().get(&stab) {\n             return st;\n         }\n \n-        let interned = self.global_interners.arenas.stability.alloc(stab);\n-        if let Some(prev) = self.global_interners.stability\n-                                .borrow_mut()\n-                                .replace(interned) {\n+        let interned = self.global_interners.arena.alloc(stab);\n+        if let Some(prev) = self.stability_interner.borrow_mut().replace(interned) {\n             bug!(\"Tried to overwrite interned Stability: {:?}\", prev)\n         }\n         interned\n     }\n \n     pub fn intern_layout(self, layout: Layout) -> &'gcx Layout {\n-        if let Some(layout) = self.global_interners.layout.borrow().get(&layout) {\n+        if let Some(layout) = self.layout_interner.borrow().get(&layout) {\n             return layout;\n         }\n \n-        let interned = self.global_interners.arenas.layout.alloc(layout);\n-        if let Some(prev) = self.global_interners.layout\n-                                .borrow_mut()\n-                                .replace(interned) {\n+        let interned = self.global_arenas.layout.alloc(layout);\n+        if let Some(prev) = self.layout_interner.borrow_mut().replace(interned) {\n             bug!(\"Tried to overwrite interned Layout: {:?}\", prev)\n         }\n         interned\n@@ -728,24 +710,26 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// value (types, substs, etc.) can only be used while `ty::tls` has a valid\n     /// reference to the context, to allow formatting values that need it.\n     pub fn create_and_enter<F, R>(s: &'tcx Session,\n-                                  arenas: &'tcx CtxtArenas<'tcx>,\n+                                  arenas: &'tcx GlobalArenas<'tcx>,\n+                                  arena: &'tcx DroplessArena,\n                                   resolutions: ty::Resolutions,\n                                   named_region_map: resolve_lifetime::NamedRegionMap,\n                                   map: ast_map::Map<'tcx>,\n                                   region_maps: RegionMaps,\n                                   lang_items: middle::lang_items::LanguageItems,\n                                   stability: stability::Index<'tcx>,\n-                                 crate_name: &str,\n+                                  crate_name: &str,\n                                   f: F) -> R\n                                   where F: for<'b> FnOnce(TyCtxt<'b, 'tcx, 'tcx>) -> R\n     {\n         let data_layout = TargetDataLayout::parse(s);\n-        let interners = CtxtInterners::new(arenas);\n+        let interners = CtxtInterners::new(arena);\n         let common_types = CommonTypes::new(&interners);\n         let dep_graph = map.dep_graph.clone();\n         let fulfilled_predicates = traits::GlobalFulfilledPredicates::new(dep_graph.clone());\n         tls::enter_global(GlobalCtxt {\n             specializes_cache: RefCell::new(traits::SpecializesCache::new()),\n+            global_arenas: arenas,\n             global_interners: interners,\n             dep_graph: dep_graph.clone(),\n             types: common_types,\n@@ -794,18 +778,20 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             crate_name: Symbol::intern(crate_name),\n             data_layout: data_layout,\n             layout_cache: RefCell::new(FxHashMap()),\n+            layout_interner: RefCell::new(FxHashSet()),\n             layout_depth: Cell::new(0),\n             derive_macros: RefCell::new(NodeMap()),\n+            stability_interner: RefCell::new(FxHashSet()),\n        }, f)\n     }\n }\n \n impl<'gcx: 'tcx, 'tcx> GlobalCtxt<'gcx> {\n-    /// Call the closure with a local `TyCtxt` using the given arenas.\n-    pub fn enter_local<F, R>(&self, arenas: &'tcx CtxtArenas<'tcx>, f: F) -> R\n+    /// Call the closure with a local `TyCtxt` using the given arena.\n+    pub fn enter_local<F, R>(&self, arena: &'tcx DroplessArena, f: F) -> R\n         where F: for<'a> FnOnce(TyCtxt<'a, 'gcx, 'tcx>) -> R\n     {\n-        let interners = CtxtInterners::new(arenas);\n+        let interners = CtxtInterners::new(arena);\n         tls::enter(self, &interners, f)\n     }\n }\n@@ -835,10 +821,8 @@ pub trait Lift<'tcx> {\n impl<'a, 'tcx> Lift<'tcx> for Ty<'a> {\n     type Lifted = Ty<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Ty<'tcx>> {\n-        if let Some(&Interned(ty)) = tcx.interners.type_.borrow().get(&self.sty) {\n-            if *self as *const _ == ty as *const _ {\n-                return Some(ty);\n-            }\n+        if tcx.interners.arena.in_arena(*self as *const _) {\n+            return Some(unsafe { mem::transmute(*self) });\n         }\n         // Also try in the global tcx if we're not that.\n         if !tcx.is_global() {\n@@ -855,10 +839,8 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Substs<'a> {\n         if self.len() == 0 {\n             return Some(Slice::empty());\n         }\n-        if let Some(&Interned(substs)) = tcx.interners.substs.borrow().get(&self[..]) {\n-            if *self as *const _ == substs as *const _ {\n-                return Some(substs);\n-            }\n+        if tcx.interners.arena.in_arena(&self[..] as *const _) {\n+            return Some(unsafe { mem::transmute(*self) });\n         }\n         // Also try in the global tcx if we're not that.\n         if !tcx.is_global() {\n@@ -872,10 +854,8 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Substs<'a> {\n impl<'a, 'tcx> Lift<'tcx> for &'a Region {\n     type Lifted = &'tcx Region;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<&'tcx Region> {\n-        if let Some(&Interned(region)) = tcx.interners.region.borrow().get(*self) {\n-            if *self as *const _ == region as *const _ {\n-                return Some(region);\n-            }\n+        if tcx.interners.arena.in_arena(*self as *const _) {\n+            return Some(unsafe { mem::transmute(*self) });\n         }\n         // Also try in the global tcx if we're not that.\n         if !tcx.is_global() {\n@@ -893,10 +873,8 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Slice<Ty<'a>> {\n         if self.len() == 0 {\n             return Some(Slice::empty());\n         }\n-        if let Some(&Interned(list)) = tcx.interners.type_list.borrow().get(&self[..]) {\n-            if *self as *const _ == list as *const _ {\n-                return Some(list);\n-            }\n+        if tcx.interners.arena.in_arena(*self as *const _) {\n+            return Some(unsafe { mem::transmute(*self) });\n         }\n         // Also try in the global tcx if we're not that.\n         if !tcx.is_global() {\n@@ -914,10 +892,8 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Slice<ExistentialPredicate<'a>> {\n         if self.is_empty() {\n             return Some(Slice::empty());\n         }\n-        if let Some(&Interned(eps)) = tcx.interners.existential_predicates.borrow().get(&self[..]) {\n-            if *self as *const _ == eps as *const _ {\n-                return Some(eps);\n-            }\n+        if tcx.interners.arena.in_arena(*self as *const _) {\n+            return Some(unsafe { mem::transmute(*self) });\n         }\n         // Also try in the global tcx if we're not that.\n         if !tcx.is_global() {\n@@ -932,10 +908,8 @@ impl<'a, 'tcx> Lift<'tcx> for &'a BareFnTy<'a> {\n     type Lifted = &'tcx BareFnTy<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n                              -> Option<&'tcx BareFnTy<'tcx>> {\n-        if let Some(&Interned(fty)) = tcx.interners.bare_fn.borrow().get(*self) {\n-            if *self as *const _ == fty as *const _ {\n-                return Some(fty);\n-            }\n+        if tcx.interners.arena.in_arena(*self as *const _) {\n+            return Some(unsafe { mem::transmute(*self) });\n         }\n         // Also try in the global tcx if we're not that.\n         if !tcx.is_global() {\n@@ -1101,8 +1075,8 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         println!(\"Substs interner: #{}\", self.interners.substs.borrow().len());\n         println!(\"BareFnTy interner: #{}\", self.interners.bare_fn.borrow().len());\n         println!(\"Region interner: #{}\", self.interners.region.borrow().len());\n-        println!(\"Stability interner: #{}\", self.interners.stability.borrow().len());\n-        println!(\"Layout interner: #{}\", self.interners.layout.borrow().len());\n+        println!(\"Stability interner: #{}\", self.stability_interner.borrow().len());\n+        println!(\"Layout interner: #{}\", self.layout_interner.borrow().len());\n     }\n }\n \n@@ -1205,8 +1179,7 @@ macro_rules! intern_method {\n                         let v = unsafe {\n                             mem::transmute(v)\n                         };\n-                        let i = ($alloc_to_ret)(self.global_interners.arenas.$name\n-                                                    .$alloc_method(v));\n+                        let i = ($alloc_to_ret)(self.global_interners.arena.$alloc_method(v));\n                         self.global_interners.$name.borrow_mut().insert(Interned(i));\n                         return i;\n                     }\n@@ -1220,7 +1193,7 @@ macro_rules! intern_method {\n                     }\n                 }\n \n-                let i = ($alloc_to_ret)(self.interners.arenas.$name.$alloc_method(v));\n+                let i = ($alloc_to_ret)(self.interners.arena.$alloc_method(v));\n                 self.interners.$name.borrow_mut().insert(Interned(i));\n                 i\n             }"}, {"sha": "3e33d246b6d183046017d0ce6b0a59420fe6ea98", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08babdb412a87960fe3602e92abf1bf5fe26a8da/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08babdb412a87960fe3602e92abf1bf5fe26a8da/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=08babdb412a87960fe3602e92abf1bf5fe26a8da", "patch": "@@ -68,8 +68,8 @@ pub use self::sty::Region::*;\n pub use self::sty::TypeVariants::*;\n \n pub use self::contents::TypeContents;\n-pub use self::context::{TyCtxt, tls};\n-pub use self::context::{CtxtArenas, Lift, Tables};\n+pub use self::context::{TyCtxt, GlobalArenas, tls};\n+pub use self::context::{Lift, Tables};\n \n pub use self::trait_def::{TraitDef, TraitFlags};\n "}, {"sha": "e9c14b4f99c2224847f41f98e7b97baa1f7fd09f", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/08babdb412a87960fe3602e92abf1bf5fe26a8da/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08babdb412a87960fe3602e92abf1bf5fe26a8da/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=08babdb412a87960fe3602e92abf1bf5fe26a8da", "patch": "@@ -19,7 +19,7 @@ use rustc::session::search_paths::PathKind;\n use rustc::lint;\n use rustc::middle::{self, dependency_format, stability, reachable};\n use rustc::middle::privacy::AccessLevels;\n-use rustc::ty::{self, TyCtxt, Resolutions};\n+use rustc::ty::{self, TyCtxt, Resolutions, GlobalArenas};\n use rustc::util::common::time;\n use rustc::util::nodemap::{NodeSet, NodeMap};\n use rustc_borrowck as borrowck;\n@@ -55,6 +55,7 @@ use syntax::symbol::Symbol;\n use syntax::util::node_count::NodeCounter;\n use syntax;\n use syntax_ext;\n+use arena::DroplessArena;\n \n use derive_registrar;\n \n@@ -123,7 +124,8 @@ pub fn compile_input(sess: &Session,\n \n         write_out_deps(sess, &outputs, &crate_name);\n \n-        let arenas = ty::CtxtArenas::new();\n+        let arena = DroplessArena::new();\n+        let arenas = GlobalArenas::new();\n \n         // Construct the HIR map\n         let hir_map = time(sess.time_passes(),\n@@ -138,6 +140,7 @@ pub fn compile_input(sess: &Session,\n                                                                   sess,\n                                                                   outdir,\n                                                                   output,\n+                                                                  &arena,\n                                                                   &arenas,\n                                                                   &cstore,\n                                                                   &hir_map,\n@@ -164,6 +167,7 @@ pub fn compile_input(sess: &Session,\n                                     hir_map,\n                                     analysis,\n                                     resolutions,\n+                                    &arena,\n                                     &arenas,\n                                     &crate_name,\n                                     |tcx, analysis, incremental_hashes_map, result| {\n@@ -331,7 +335,8 @@ pub struct CompileState<'a, 'tcx: 'a> {\n     pub output_filenames: Option<&'a OutputFilenames>,\n     pub out_dir: Option<&'a Path>,\n     pub out_file: Option<&'a Path>,\n-    pub arenas: Option<&'tcx ty::CtxtArenas<'tcx>>,\n+    pub arena: Option<&'tcx DroplessArena>,\n+    pub arenas: Option<&'tcx GlobalArenas<'tcx>>,\n     pub expanded_crate: Option<&'a ast::Crate>,\n     pub hir_crate: Option<&'a hir::Crate>,\n     pub ast_map: Option<&'a hir_map::Map<'tcx>>,\n@@ -351,6 +356,7 @@ impl<'a, 'tcx> CompileState<'a, 'tcx> {\n             session: session,\n             out_dir: out_dir.as_ref().map(|s| &**s),\n             out_file: None,\n+            arena: None,\n             arenas: None,\n             krate: None,\n             registry: None,\n@@ -405,7 +411,8 @@ impl<'a, 'tcx> CompileState<'a, 'tcx> {\n                                 session: &'tcx Session,\n                                 out_dir: &'a Option<PathBuf>,\n                                 out_file: &'a Option<PathBuf>,\n-                                arenas: &'tcx ty::CtxtArenas<'tcx>,\n+                                arena: &'tcx DroplessArena,\n+                                arenas: &'tcx GlobalArenas<'tcx>,\n                                 cstore: &'a CStore,\n                                 hir_map: &'a hir_map::Map<'tcx>,\n                                 analysis: &'a ty::CrateAnalysis<'static>,\n@@ -416,6 +423,7 @@ impl<'a, 'tcx> CompileState<'a, 'tcx> {\n                                 -> Self {\n         CompileState {\n             crate_name: Some(crate_name),\n+            arena: Some(arena),\n             arenas: Some(arenas),\n             cstore: Some(cstore),\n             ast_map: Some(hir_map),\n@@ -800,7 +808,8 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                                                hir_map: hir_map::Map<'tcx>,\n                                                mut analysis: ty::CrateAnalysis<'tcx>,\n                                                resolutions: Resolutions,\n-                                               arenas: &'tcx ty::CtxtArenas<'tcx>,\n+                                               arena: &'tcx DroplessArena,\n+                                               arenas: &'tcx GlobalArenas<'tcx>,\n                                                name: &str,\n                                                f: F)\n                                                -> Result<R, usize>\n@@ -858,6 +867,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n     TyCtxt::create_and_enter(sess,\n                              arenas,\n+                             arena,\n                              resolutions,\n                              named_region_map,\n                              hir_map,"}, {"sha": "ca31022b04c648b7039d1b9e39883156eeb28978", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08babdb412a87960fe3602e92abf1bf5fe26a8da/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08babdb412a87960fe3602e92abf1bf5fe26a8da/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=08babdb412a87960fe3602e92abf1bf5fe26a8da", "patch": "@@ -462,6 +462,7 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                                                      &state.expanded_crate.take().unwrap(),\n                                                      state.crate_name.unwrap(),\n                                                      ppm,\n+                                                     state.arena.unwrap(),\n                                                      state.arenas.unwrap(),\n                                                      opt_uii.clone(),\n                                                      state.out_file);"}, {"sha": "cc288619cdee00b37c39b8879abec54e4ed7d155", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/08babdb412a87960fe3602e92abf1bf5fe26a8da/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08babdb412a87960fe3602e92abf1bf5fe26a8da/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=08babdb412a87960fe3602e92abf1bf5fe26a8da", "patch": "@@ -17,7 +17,7 @@ use self::NodesMatchingUII::*;\n \n use {abort_on_err, driver};\n \n-use rustc::ty::{self, TyCtxt, Resolutions};\n+use rustc::ty::{self, TyCtxt, GlobalArenas, Resolutions};\n use rustc::cfg;\n use rustc::cfg::graphviz::LabelledCFG;\n use rustc::dep_graph::DepGraph;\n@@ -51,6 +51,8 @@ use rustc::hir::map::blocks;\n use rustc::hir;\n use rustc::hir::print as pprust_hir;\n \n+use arena::DroplessArena;\n+\n #[derive(Copy, Clone, PartialEq, Debug)]\n pub enum PpSourceMode {\n     PpmNormal,\n@@ -201,7 +203,8 @@ impl PpSourceMode {\n                                                ast_map: &hir_map::Map<'tcx>,\n                                                analysis: &ty::CrateAnalysis<'tcx>,\n                                                resolutions: &Resolutions,\n-                                               arenas: &'tcx ty::CtxtArenas<'tcx>,\n+                                               arena: &'tcx DroplessArena,\n+                                               arenas: &'tcx GlobalArenas<'tcx>,\n                                                id: &str,\n                                                payload: B,\n                                                f: F)\n@@ -229,6 +232,7 @@ impl PpSourceMode {\n                                                                  ast_map.clone(),\n                                                                  analysis.clone(),\n                                                                  resolutions.clone(),\n+                                                                 arena,\n                                                                  arenas,\n                                                                  id,\n                                                                  |tcx, _, _, _| {\n@@ -846,7 +850,8 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n                                                 krate: &ast::Crate,\n                                                 crate_name: &str,\n                                                 ppm: PpMode,\n-                                                arenas: &'tcx ty::CtxtArenas<'tcx>,\n+                                                arena: &'tcx DroplessArena,\n+                                                arenas: &'tcx GlobalArenas<'tcx>,\n                                                 opt_uii: Option<UserIdentifiedItem>,\n                                                 ofile: Option<&Path>) {\n     let dep_graph = DepGraph::new(false);\n@@ -858,6 +863,7 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n                             analysis,\n                             resolutions,\n                             crate_name,\n+                            arena,\n                             arenas,\n                             ppm,\n                             opt_uii,\n@@ -894,6 +900,7 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n                                            ast_map,\n                                            analysis,\n                                            resolutions,\n+                                           arena,\n                                            arenas,\n                                            crate_name,\n                                            box out,\n@@ -917,6 +924,7 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n                                            ast_map,\n                                            analysis,\n                                            resolutions,\n+                                           arena,\n                                            arenas,\n                                            crate_name,\n                                            (out, uii),\n@@ -959,7 +967,8 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n                                        analysis: &ty::CrateAnalysis<'tcx>,\n                                        resolutions: &Resolutions,\n                                        crate_name: &str,\n-                                       arenas: &'tcx ty::CtxtArenas<'tcx>,\n+                                       arena: &'tcx DroplessArena,\n+                                       arenas: &'tcx GlobalArenas<'tcx>,\n                                        ppm: PpMode,\n                                        uii: Option<UserIdentifiedItem>,\n                                        ofile: Option<&Path>) {\n@@ -977,6 +986,7 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n                                                      ast_map.clone(),\n                                                      analysis.clone(),\n                                                      resolutions.clone(),\n+                                                     arena,\n                                                      arenas,\n                                                      crate_name,\n                                                      |tcx, _, _, _| {"}, {"sha": "887e586a3112e4778bf6805cc17acb6916e598e0", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/08babdb412a87960fe3602e92abf1bf5fe26a8da/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08babdb412a87960fe3602e92abf1bf5fe26a8da/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=08babdb412a87960fe3602e92abf1bf5fe26a8da", "patch": "@@ -38,6 +38,7 @@ use errors::{Level, DiagnosticBuilder};\n use syntax::feature_gate::UnstableFeatures;\n use syntax::symbol::Symbol;\n use syntax_pos::DUMMY_SP;\n+use arena::DroplessArena;\n \n use rustc::hir;\n \n@@ -128,7 +129,8 @@ fn test_env<F>(source_string: &str,\n     };\n     let _ignore = dep_graph.in_ignore();\n \n-    let arenas = ty::CtxtArenas::new();\n+    let arena = DroplessArena::new();\n+    let arenas = ty::GlobalArenas::new();\n     let ast_map = hir_map::map_crate(&mut hir_forest, defs);\n \n     // run just enough stuff to build a tcx:\n@@ -138,6 +140,7 @@ fn test_env<F>(source_string: &str,\n     let index = stability::Index::new(&ast_map);\n     TyCtxt::create_and_enter(&sess,\n                              &arenas,\n+                             &arena,\n                              resolutions,\n                              named_region_map.unwrap(),\n                              ast_map,"}, {"sha": "1f989c557d3aa7140be362292e6c6bfd01358942", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/08babdb412a87960fe3602e92abf1bf5fe26a8da/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08babdb412a87960fe3602e92abf1bf5fe26a8da/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=08babdb412a87960fe3602e92abf1bf5fe26a8da", "patch": "@@ -15,7 +15,7 @@ use rustc::session::{self, config};\n use rustc::hir::def_id::DefId;\n use rustc::hir::def::{Def, ExportMap};\n use rustc::middle::privacy::AccessLevels;\n-use rustc::ty::{self, TyCtxt, Ty};\n+use rustc::ty::{self, TyCtxt, GlobalArenas, Ty};\n use rustc::hir::map as hir_map;\n use rustc::lint;\n use rustc::util::nodemap::{FxHashMap, NodeMap};\n@@ -37,6 +37,7 @@ use visit_ast::RustdocVisitor;\n use clean;\n use clean::Clean;\n use html::render::RenderInfo;\n+use arena::DroplessArena;\n \n pub use rustc::session::config::Input;\n pub use rustc::session::search_paths::SearchPaths;\n@@ -160,13 +161,15 @@ pub fn run_core(search_paths: SearchPaths,\n         ).expect(\"phase_2_configure_and_expand aborted in rustdoc!\")\n     };\n \n-    let arenas = ty::CtxtArenas::new();\n+    let arena = DroplessArena::new();\n+    let arenas = GlobalArenas::new();\n     let hir_map = hir_map::map_crate(&mut hir_forest, defs);\n \n     abort_on_err(driver::phase_3_run_analysis_passes(&sess,\n                                                      hir_map,\n                                                      analysis,\n                                                      resolutions,\n+                                                     &arena,\n                                                      &arenas,\n                                                      &name,\n                                                      |tcx, analysis, _, result| {"}]}