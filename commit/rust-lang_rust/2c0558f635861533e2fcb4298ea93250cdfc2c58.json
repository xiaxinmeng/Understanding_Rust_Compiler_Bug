{"sha": "2c0558f635861533e2fcb4298ea93250cdfc2c58", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjMDU1OGY2MzU4NjE1MzNlMmZjYjQyOThlYTkzMjUwY2RmYzJjNTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-24T16:04:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-24T16:04:50Z"}, "message": "Auto merge of #43345 - matthewhammer:master, r=nikomatsakis\n\nProfile queries\n\nThis PR implements the \"profile queries\" debugging feature described here:\nhttps://github.com/rust-lang-nursery/rust-forge/blob/master/profile-queries.md\n\nIn particular, it implements the debugging flag `-Z profile-queries`\n\nFYI: This PR is my second attempt at pushing these changes.  My original PR required a rebase; I have now done that rebase manually, after messing up with git's \"interactive\" rebase support.  The original (now closed/cancelled) PR is this one: https://github.com/rust-lang/rust/issues/43156\n\nr? @nikomatsakis", "tree": {"sha": "bfbdb0f3363ee5993f4ff2f1d38676a76b243144", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bfbdb0f3363ee5993f4ff2f1d38676a76b243144"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c0558f635861533e2fcb4298ea93250cdfc2c58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c0558f635861533e2fcb4298ea93250cdfc2c58", "html_url": "https://github.com/rust-lang/rust/commit/2c0558f635861533e2fcb4298ea93250cdfc2c58", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c0558f635861533e2fcb4298ea93250cdfc2c58/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af6298d590785088aad92f817ce07dfd6cdebdd0", "url": "https://api.github.com/repos/rust-lang/rust/commits/af6298d590785088aad92f817ce07dfd6cdebdd0", "html_url": "https://github.com/rust-lang/rust/commit/af6298d590785088aad92f817ce07dfd6cdebdd0"}, {"sha": "43335aec22327ef542088263dd7353accda40517", "url": "https://api.github.com/repos/rust-lang/rust/commits/43335aec22327ef542088263dd7353accda40517", "html_url": "https://github.com/rust-lang/rust/commit/43335aec22327ef542088263dd7353accda40517"}], "stats": {"total": 782, "additions": 782, "deletions": 0}, "files": [{"sha": "a9701cbf23cf0290e85b990455f9fb7c4209d53b", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2c0558f635861533e2fcb4298ea93250cdfc2c58/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c0558f635861533e2fcb4298ea93250cdfc2c58/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=2c0558f635861533e2fcb4298ea93250cdfc2c58", "patch": "@@ -12,6 +12,7 @@ use rustc_data_structures::fx::FxHashMap;\n use session::config::OutputType;\n use std::cell::{Ref, RefCell};\n use std::rc::Rc;\n+use util::common::{ProfileQueriesMsg, profq_msg};\n \n use super::dep_node::{DepNode, DepKind, WorkProductId};\n use super::query::DepGraphQuery;\n@@ -118,7 +119,13 @@ impl DepGraph {\n     {\n         if let Some(ref data) = self.data {\n             data.edges.borrow_mut().push_task(key);\n+            if cfg!(debug_assertions) {\n+                profq_msg(ProfileQueriesMsg::TaskBegin(key.clone()))\n+            };\n             let result = task(cx, arg);\n+            if cfg!(debug_assertions) {\n+                profq_msg(ProfileQueriesMsg::TaskEnd)\n+            };\n             let dep_node_index = data.edges.borrow_mut().pop_task(key);\n             (result, dep_node_index)\n         } else {"}, {"sha": "99fe8e60ae52b139d049d47e6fc9ef21296b8d19", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2c0558f635861533e2fcb4298ea93250cdfc2c58/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c0558f635861533e2fcb4298ea93250cdfc2c58/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=2c0558f635861533e2fcb4298ea93250cdfc2c58", "patch": "@@ -995,6 +995,10 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"dump the dependency graph to $RUST_DEP_GRAPH (default: /tmp/dep_graph.gv)\"),\n     query_dep_graph: bool = (false, parse_bool, [UNTRACKED],\n           \"enable queries of the dependency graph for regression testing\"),\n+    profile_queries: bool = (false, parse_bool, [UNTRACKED],\n+          \"trace and profile the queries of the incremental compilation framework\"),\n+    profile_queries_and_keys: bool = (false, parse_bool, [UNTRACKED],\n+          \"trace and profile the queries and keys of the incremental compilation framework\"),\n     no_analysis: bool = (false, parse_bool, [UNTRACKED],\n           \"parse and expand the source, but run no analysis\"),\n     extra_plugins: Vec<String> = (Vec::new(), parse_list, [TRACKED],"}, {"sha": "823a637c7e0d4272c70876efd577a26c0664efdd", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2c0558f635861533e2fcb4298ea93250cdfc2c58/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c0558f635861533e2fcb4298ea93250cdfc2c58/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=2c0558f635861533e2fcb4298ea93250cdfc2c58", "patch": "@@ -389,6 +389,13 @@ impl Session {\n     }\n     pub fn verbose(&self) -> bool { self.opts.debugging_opts.verbose }\n     pub fn time_passes(&self) -> bool { self.opts.debugging_opts.time_passes }\n+    pub fn profile_queries(&self) -> bool {\n+        self.opts.debugging_opts.profile_queries ||\n+            self.opts.debugging_opts.profile_queries_and_keys\n+    }\n+    pub fn profile_queries_and_keys(&self) -> bool {\n+        self.opts.debugging_opts.profile_queries_and_keys\n+    }\n     pub fn count_llvm_insns(&self) -> bool {\n         self.opts.debugging_opts.count_llvm_insns\n     }"}, {"sha": "6e02e38aee1292bab72b3b9ccd6373bad5381574", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2c0558f635861533e2fcb4298ea93250cdfc2c58/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c0558f635861533e2fcb4298ea93250cdfc2c58/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=2c0558f635861533e2fcb4298ea93250cdfc2c58", "patch": "@@ -28,6 +28,7 @@ use ty::steal::Steal;\n use ty::subst::Substs;\n use ty::fast_reject::SimplifiedType;\n use util::nodemap::{DefIdSet, NodeSet};\n+use util::common::{profq_msg, ProfileQueriesMsg};\n \n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::fx::FxHashMap;\n@@ -513,6 +514,29 @@ impl<'tcx> QueryDescription for queries::lint_levels<'tcx> {\n     }\n }\n \n+// If enabled, send a message to the profile-queries thread\n+macro_rules! profq_msg {\n+    ($tcx:expr, $msg:expr) => {\n+        if cfg!(debug_assertions) {\n+            if  $tcx.sess.profile_queries() {\n+                profq_msg($msg)\n+            }\n+        }\n+    }\n+}\n+\n+// If enabled, format a key using its debug string, which can be\n+// expensive to compute (in terms of time).\n+macro_rules! profq_key {\n+    ($tcx:expr, $key:expr) => {\n+        if cfg!(debug_assertions) {\n+            if $tcx.sess.profile_queries_and_keys() {\n+                Some(format!(\"{:?}\", $key))\n+            } else { None }\n+        } else { None }\n+    }\n+}\n+\n macro_rules! define_maps {\n     (<$tcx:tt>\n      $($(#[$attr:meta])*\n@@ -539,6 +563,12 @@ macro_rules! define_maps {\n             $($(#[$attr])* $name($K)),*\n         }\n \n+        #[allow(bad_style)]\n+        #[derive(Clone, Debug, PartialEq, Eq)]\n+        pub enum QueryMsg {\n+            $($name(Option<String>)),*\n+        }\n+\n         impl<$tcx> Query<$tcx> {\n             pub fn describe(&self, tcx: TyCtxt) -> String {\n                 match *self {\n@@ -581,10 +611,20 @@ macro_rules! define_maps {\n                        key,\n                        span);\n \n+                profq_msg!(tcx,\n+                    ProfileQueriesMsg::QueryBegin(\n+                        span.clone(),\n+                        QueryMsg::$name(profq_key!(tcx, key))\n+                    )\n+                );\n+\n                 if let Some(&(ref result, dep_node_index)) = tcx.maps.$name.borrow().map.get(&key) {\n                     tcx.dep_graph.read_index(dep_node_index);\n+                    profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n                     return Ok(f(result));\n                 }\n+                // else, we are going to run the provider:\n+                profq_msg!(tcx, ProfileQueriesMsg::ProviderBegin);\n \n                 // FIXME(eddyb) Get more valid Span's on queries.\n                 // def_span guard is necessary to prevent a recursive loop,\n@@ -612,6 +652,7 @@ macro_rules! define_maps {\n                         tcx.dep_graph.with_task(dep_node, tcx, key, run_provider)\n                     }\n                 })?;\n+                profq_msg!(tcx, ProfileQueriesMsg::ProviderEnd);\n \n                 tcx.dep_graph.read_index(dep_node_index);\n "}, {"sha": "618a4ed331e766056cf1a207a86cd5dca747902e", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/2c0558f635861533e2fcb4298ea93250cdfc2c58/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c0558f635861533e2fcb4298ea93250cdfc2c58/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=2c0558f635861533e2fcb4298ea93250cdfc2c58", "patch": "@@ -19,6 +19,11 @@ use std::iter::repeat;\n use std::path::Path;\n use std::time::{Duration, Instant};\n \n+use std::sync::mpsc::{Sender};\n+use syntax_pos::{Span};\n+use ty::maps::{QueryMsg};\n+use dep_graph::{DepNode};\n+\n // The name of the associated type for `Fn` return types\n pub const FN_OUTPUT_NAME: &'static str = \"Output\";\n \n@@ -29,6 +34,72 @@ pub struct ErrorReported;\n \n thread_local!(static TIME_DEPTH: Cell<usize> = Cell::new(0));\n \n+/// Initialized for -Z profile-queries\n+thread_local!(static PROFQ_CHAN: RefCell<Option<Sender<ProfileQueriesMsg>>> = RefCell::new(None));\n+\n+/// Parameters to the `Dump` variant of type `ProfileQueriesMsg`.\n+#[derive(Clone,Debug)]\n+pub struct ProfQDumpParams {\n+    /// A base path for the files we will dump\n+    pub path:String,\n+    /// To ensure that the compiler waits for us to finish our dumps\n+    pub ack:Sender<()>,\n+    /// toggle dumping a log file with every `ProfileQueriesMsg`\n+    pub dump_profq_msg_log:bool,\n+}\n+\n+/// A sequence of these messages induce a trace of query-based incremental compilation.\n+/// FIXME(matthewhammer): Determine whether we should include cycle detection here or not.\n+#[derive(Clone,Debug)]\n+pub enum ProfileQueriesMsg {\n+    /// begin a timed pass\n+    TimeBegin(String),\n+    /// end a timed pass\n+    TimeEnd,\n+    /// begin a task (see dep_graph::graph::with_task)\n+    TaskBegin(DepNode),\n+    /// end a task\n+    TaskEnd,\n+    /// begin a new query\n+    QueryBegin(Span, QueryMsg),\n+    /// query is satisfied by using an already-known value for the given key\n+    CacheHit,\n+    /// query requires running a provider; providers may nest, permitting queries to nest.\n+    ProviderBegin,\n+    /// query is satisfied by a provider terminating with a value\n+    ProviderEnd,\n+    /// dump a record of the queries to the given path\n+    Dump(ProfQDumpParams),\n+    /// halt the profiling/monitoring background thread\n+    Halt\n+}\n+\n+/// If enabled, send a message to the profile-queries thread\n+pub fn profq_msg(msg: ProfileQueriesMsg) {\n+    PROFQ_CHAN.with(|sender|{\n+        if let Some(s) = sender.borrow().as_ref() {\n+            s.send(msg).unwrap()\n+        } else {\n+            // Do nothing.\n+            //\n+            // FIXME(matthewhammer): Multi-threaded translation phase triggers the panic below.\n+            // From backtrace: rustc_trans::back::write::spawn_work::{{closure}}.\n+            //\n+            // panic!(\"no channel on which to send profq_msg: {:?}\", msg)\n+        }\n+    })\n+}\n+\n+/// Set channel for profile queries channel\n+pub fn profq_set_chan(s: Sender<ProfileQueriesMsg>) -> bool {\n+    PROFQ_CHAN.with(|chan|{\n+        if chan.borrow().is_none() {\n+            *chan.borrow_mut() = Some(s);\n+            true\n+        } else { false }\n+    })\n+}\n+\n /// Read the current depth of `time()` calls. This is used to\n /// encourage indentation across threads.\n pub fn time_depth() -> usize {\n@@ -53,9 +124,15 @@ pub fn time<T, F>(do_it: bool, what: &str, f: F) -> T where\n         r\n     });\n \n+    if cfg!(debug_assertions) {\n+        profq_msg(ProfileQueriesMsg::TimeBegin(what.to_string()))\n+    };\n     let start = Instant::now();\n     let rv = f();\n     let dur = start.elapsed();\n+    if cfg!(debug_assertions) {\n+        profq_msg(ProfileQueriesMsg::TimeEnd)\n+    };\n \n     print_time_passes_entry_internal(what, dur);\n "}, {"sha": "163c698e3ff317217d642fb46c2386806722f26f", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2c0558f635861533e2fcb4298ea93250cdfc2c58/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c0558f635861533e2fcb4298ea93250cdfc2c58/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=2c0558f635861533e2fcb4298ea93250cdfc2c58", "patch": "@@ -64,6 +64,8 @@ use arena::DroplessArena;\n \n use derive_registrar;\n \n+use profile;\n+\n pub fn compile_input(sess: &Session,\n                      cstore: &CStore,\n                      input: &Input,\n@@ -105,6 +107,10 @@ pub fn compile_input(sess: &Session,\n         sess.abort_if_errors();\n     }\n \n+    if sess.profile_queries() {\n+        profile::begin();\n+    }\n+\n     // We need nested scopes here, because the intermediate results can keep\n     // large chunks of memory alive and we want to free them as soon as\n     // possible to keep the peak memory usage low\n@@ -537,6 +543,10 @@ pub fn phase_1_parse_input<'a>(control: &CompileController,\n                                -> PResult<'a, ast::Crate> {\n     sess.diagnostic().set_continue_after_error(control.continue_parse_after_error);\n \n+    if sess.profile_queries() {\n+        profile::begin();\n+    }\n+\n     let krate = time(sess.time_passes(), \"parsing\", || {\n         match *input {\n             Input::File(ref file) => {\n@@ -1120,6 +1130,10 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n              \"translation\",\n              move || trans::trans_crate(tcx, analysis, incremental_hashes_map, output_filenames));\n \n+    if tcx.sess.profile_queries() {\n+        profile::dump(\"profile_queries\".to_string())\n+    }\n+\n     translation\n }\n "}, {"sha": "d7b5d4a6fe3ba40ff73b3e56b82393ffde544040", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2c0558f635861533e2fcb4298ea93250cdfc2c58/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c0558f635861533e2fcb4298ea93250cdfc2c58/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=2c0558f635861533e2fcb4298ea93250cdfc2c58", "patch": "@@ -104,6 +104,7 @@ use syntax_pos::{DUMMY_SP, MultiSpan};\n #[cfg(test)]\n mod test;\n \n+pub mod profile;\n pub mod driver;\n pub mod pretty;\n pub mod target_features;"}, {"sha": "061077d05a438560f820b3c45d83dbf74427434a", "filename": "src/librustc_driver/profile/mod.rs", "status": "added", "additions": 316, "deletions": 0, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/2c0558f635861533e2fcb4298ea93250cdfc2c58/src%2Flibrustc_driver%2Fprofile%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c0558f635861533e2fcb4298ea93250cdfc2c58/src%2Flibrustc_driver%2Fprofile%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fprofile%2Fmod.rs?ref=2c0558f635861533e2fcb4298ea93250cdfc2c58", "patch": "@@ -0,0 +1,316 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::util::common::{ProfQDumpParams, ProfileQueriesMsg, profq_msg, profq_set_chan};\n+use std::sync::mpsc::{Receiver};\n+use std::io::{Write};\n+use rustc::dep_graph::{DepNode};\n+use std::time::{Duration, Instant};\n+\n+pub mod trace;\n+\n+/// begin a profile thread, if not already running\n+pub fn begin() {\n+    use std::thread;\n+    use std::sync::mpsc::{channel};\n+    let (tx, rx) = channel();\n+    if profq_set_chan(tx) {\n+        thread::spawn(move||profile_queries_thread(rx));\n+    }\n+}\n+\n+/// dump files with profiling information to the given base path, and\n+/// wait for this dump to complete.\n+///\n+/// wraps the RPC (send/recv channel logic) of requesting a dump.\n+pub fn dump(path:String) {\n+    use std::sync::mpsc::{channel};\n+    let (tx, rx) = channel();\n+    let params = ProfQDumpParams{\n+        path, ack:tx,\n+        // FIXME: Add another compiler flag to toggle whether this log\n+        // is written; false for now\n+        dump_profq_msg_log:true,\n+    };\n+    profq_msg(ProfileQueriesMsg::Dump(params));\n+    let _ = rx.recv().unwrap();\n+}\n+\n+// State for parsing recursive trace structure in separate thread, via messages\n+#[derive(Clone, Eq, PartialEq)]\n+enum ParseState {\n+    // No (local) parse state; may be parsing a tree, focused on a\n+    // sub-tree that could be anything.\n+    Clear,\n+    // Have Query information from the last message\n+    HaveQuery(trace::Query, Instant),\n+    // Have \"time-begin\" information from the last message (doit flag, and message)\n+    HaveTimeBegin(String, Instant),\n+    // Have \"task-begin\" information from the last message\n+    HaveTaskBegin(DepNode, Instant),\n+}\n+struct StackFrame {\n+    pub parse_st: ParseState,\n+    pub traces:   Vec<trace::Rec>,\n+}\n+\n+fn total_duration(traces: &Vec<trace::Rec>) -> Duration {\n+    let mut sum : Duration = Duration::new(0,0);\n+    for t in traces.iter() { sum += t.dur_total; }\n+    return sum\n+}\n+\n+// profiling thread; retains state (in local variables) and dump traces, upon request.\n+fn profile_queries_thread(r:Receiver<ProfileQueriesMsg>) {\n+    use self::trace::*;\n+    use std::fs::File;\n+    use std::time::{Instant};\n+\n+    let mut profq_msgs : Vec<ProfileQueriesMsg> = vec![];\n+    let mut frame : StackFrame = StackFrame{ parse_st:ParseState::Clear, traces:vec![] };\n+    let mut stack : Vec<StackFrame> = vec![];\n+    loop {\n+        let msg = r.recv();\n+        if let Err(_recv_err) = msg {\n+            // FIXME: Perhaps do something smarter than simply quitting?\n+            break\n+        };\n+        let msg = msg.unwrap();\n+        debug!(\"profile_queries_thread: {:?}\", msg);\n+\n+        // Meta-level versus _actual_ queries messages\n+        match msg {\n+            ProfileQueriesMsg::Halt => return,\n+            ProfileQueriesMsg::Dump(params) => {\n+                assert!(stack.len() == 0);\n+                assert!(frame.parse_st == ParseState::Clear);\n+                {\n+                    // write log of all messages\n+                    if params.dump_profq_msg_log {\n+                        let mut log_file =\n+                            File::create(format!(\"{}.log.txt\", params.path)).unwrap();\n+                        for m in profq_msgs.iter() {\n+                            writeln!(&mut log_file, \"{:?}\", m).unwrap()\n+                        };\n+                    }\n+\n+                    // write HTML file, and counts file\n+                    let html_path = format!(\"{}.html\", params.path);\n+                    let mut html_file = File::create(&html_path).unwrap();\n+\n+                    let counts_path = format!(\"{}.counts.txt\", params.path);\n+                    let mut counts_file = File::create(&counts_path).unwrap();\n+\n+                    write!(html_file, \"<html>\\n\").unwrap();\n+                    write!(html_file,\n+                           \"<head>\\n<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"{}\\\">\\n\",\n+                           \"profile_queries.css\").unwrap();\n+                    write!(html_file, \"<style>\\n\").unwrap();\n+                    trace::write_style(&mut html_file);\n+                    write!(html_file, \"</style>\\n\").unwrap();\n+                    write!(html_file, \"</head>\\n\").unwrap();\n+                    write!(html_file, \"<body>\\n\").unwrap();\n+                    trace::write_traces(&mut html_file, &mut counts_file, &frame.traces);\n+                    write!(html_file, \"</body>\\n</html>\\n\").unwrap();\n+\n+                    let ack_path = format!(\"{}.ack\", params.path);\n+                    let ack_file = File::create(&ack_path).unwrap();\n+                    drop(ack_file);\n+\n+                    // Tell main thread that we are done, e.g., so it can exit\n+                    params.ack.send(()).unwrap();\n+                }\n+                continue\n+            }\n+            // Actual query message:\n+            msg => {\n+                // Record msg in our log\n+                profq_msgs.push(msg.clone());\n+                // Respond to the message, knowing that we've already handled Halt and Dump, above.\n+                match (frame.parse_st.clone(), msg) {\n+                    (_,ProfileQueriesMsg::Halt) => unreachable!(),\n+                    (_,ProfileQueriesMsg::Dump(_)) => unreachable!(),\n+\n+                    // Parse State: Clear\n+                    (ParseState::Clear,\n+                     ProfileQueriesMsg::QueryBegin(span,querymsg)) => {\n+                        let start = Instant::now();\n+                        frame.parse_st = ParseState::HaveQuery\n+                            (Query{span:span, msg:querymsg}, start)\n+                    },\n+                    (ParseState::Clear,\n+                     ProfileQueriesMsg::CacheHit) => {\n+                        panic!(\"parse error: unexpected CacheHit; expected QueryBegin\")\n+                    },\n+                    (ParseState::Clear,\n+                     ProfileQueriesMsg::ProviderBegin) => {\n+                        panic!(\"parse error: expected QueryBegin before beginning a provider\")\n+                    },\n+                    (ParseState::Clear,\n+                     ProfileQueriesMsg::ProviderEnd) => {\n+                        let provider_extent = frame.traces;\n+                        match stack.pop() {\n+                            None =>\n+                                panic!(\"parse error: expected a stack frame; found an empty stack\"),\n+                            Some(old_frame) => {\n+                                match old_frame.parse_st {\n+                                    ParseState::HaveQuery(q, start) => {\n+                                        let duration = start.elapsed();\n+                                        frame = StackFrame{\n+                                            parse_st:ParseState::Clear,\n+                                            traces:old_frame.traces\n+                                        };\n+                                        let dur_extent = total_duration(&provider_extent);\n+                                        let trace = Rec {\n+                                            effect: Effect::QueryBegin(q, CacheCase::Miss),\n+                                            extent: Box::new(provider_extent),\n+                                            start: start,\n+                                            dur_self: duration - dur_extent,\n+                                            dur_total: duration,\n+                                        };\n+                                        frame.traces.push( trace );\n+                                    },\n+                                    _ => panic!(\"internal parse error: malformed parse stack\")\n+                                }\n+                            }\n+                        }\n+                    },\n+\n+\n+                    (ParseState::Clear,\n+                     ProfileQueriesMsg::TimeBegin(msg)) => {\n+                        let start = Instant::now();\n+                        frame.parse_st = ParseState::HaveTimeBegin(msg, start);\n+                        stack.push(frame);\n+                        frame = StackFrame{parse_st:ParseState::Clear, traces:vec![]};\n+                    },\n+                    (_, ProfileQueriesMsg::TimeBegin(_)) =>\n+                        panic!(\"parse error; did not expect time begin here\"),\n+\n+                    (ParseState::Clear,\n+                     ProfileQueriesMsg::TimeEnd) => {\n+                        let provider_extent = frame.traces;\n+                        match stack.pop() {\n+                            None =>\n+                                panic!(\"parse error: expected a stack frame; found an empty stack\"),\n+                            Some(old_frame) => {\n+                                match old_frame.parse_st {\n+                                    ParseState::HaveTimeBegin(msg, start) => {\n+                                        let duration = start.elapsed();\n+                                        frame = StackFrame{\n+                                            parse_st:ParseState::Clear,\n+                                            traces:old_frame.traces\n+                                        };\n+                                        let dur_extent = total_duration(&provider_extent);\n+                                        let trace = Rec {\n+                                            effect: Effect::TimeBegin(msg),\n+                                            extent: Box::new(provider_extent),\n+                                            start: start,\n+                                            dur_total: duration,\n+                                            dur_self: duration - dur_extent,\n+                                        };\n+                                        frame.traces.push( trace );\n+                                    },\n+                                    _ => panic!(\"internal parse error: malformed parse stack\")\n+                                }\n+                            }\n+                        }\n+                    },\n+                    (_, ProfileQueriesMsg::TimeEnd) => { panic!(\"parse error\") }\n+\n+                    (ParseState::Clear,\n+                     ProfileQueriesMsg::TaskBegin(key)) => {\n+                        let start = Instant::now();\n+                        frame.parse_st = ParseState::HaveTaskBegin(key, start);\n+                        stack.push(frame);\n+                        frame = StackFrame{parse_st:ParseState::Clear, traces:vec![]};\n+                    },\n+                    (_, ProfileQueriesMsg::TaskBegin(_)) =>\n+                        panic!(\"parse error; did not expect time begin here\"),\n+\n+                    (ParseState::Clear,\n+                     ProfileQueriesMsg::TaskEnd) => {\n+                        let provider_extent = frame.traces;\n+                        match stack.pop() {\n+                            None =>\n+                                panic!(\"parse error: expected a stack frame; found an empty stack\"),\n+                            Some(old_frame) => {\n+                                match old_frame.parse_st {\n+                                    ParseState::HaveTaskBegin(key, start) => {\n+                                        let duration = start.elapsed();\n+                                        frame = StackFrame{\n+                                            parse_st:ParseState::Clear,\n+                                            traces:old_frame.traces\n+                                        };\n+                                        let dur_extent = total_duration(&provider_extent);\n+                                        let trace = Rec {\n+                                            effect: Effect::TaskBegin(key),\n+                                            extent: Box::new(provider_extent),\n+                                            start: start,\n+                                            dur_total: duration,\n+                                            dur_self: duration - dur_extent,\n+                                        };\n+                                        frame.traces.push( trace );\n+                                    },\n+                                    _ => panic!(\"internal parse error: malformed parse stack\")\n+                                }\n+                            }\n+                        }\n+                    },\n+                    (_, ProfileQueriesMsg::TaskEnd) => { panic!(\"parse error\") }\n+\n+                    // Parse State: HaveQuery\n+                    (ParseState::HaveQuery(q,start),\n+                     ProfileQueriesMsg::CacheHit) => {\n+                        let duration = start.elapsed();\n+                        let trace : Rec = Rec{\n+                            effect: Effect::QueryBegin(q, CacheCase::Hit),\n+                            extent: Box::new(vec![]),\n+                            start: start,\n+                            dur_self: duration,\n+                            dur_total: duration,\n+                        };\n+                        frame.traces.push( trace );\n+                        frame.parse_st = ParseState::Clear;\n+                    },\n+                    (ParseState::HaveQuery(_,_),\n+                     ProfileQueriesMsg::ProviderBegin) => {\n+                        stack.push(frame);\n+                        frame = StackFrame{parse_st:ParseState::Clear, traces:vec![]};\n+                    },\n+\n+                    //\n+                    //\n+                    // Parse errors:\n+\n+                    (ParseState::HaveQuery(q,_),\n+                     ProfileQueriesMsg::ProviderEnd) => {\n+                        panic!(\"parse error: unexpected ProviderEnd; \\\n+                                expected something else to follow BeginQuery for {:?}\", q)\n+                    },\n+                    (ParseState::HaveQuery(q1,_),\n+                     ProfileQueriesMsg::QueryBegin(span2,querymsg2)) => {\n+                        panic!(\"parse error: unexpected QueryBegin; \\\n+                                earlier query is unfinished: {:?} and now {:?}\",\n+                               q1, Query{span:span2, msg:querymsg2})\n+                    },\n+\n+                    (ParseState::HaveTimeBegin(_, _), _) => {\n+                        unreachable!()\n+                    },\n+                    (ParseState::HaveTaskBegin(_, _), _) => {\n+                        unreachable!()\n+                    },\n+                }\n+\n+            }\n+        }\n+    }\n+}"}, {"sha": "f5079836c3ca40f6d248b42fd024bb5d23777cd3", "filename": "src/librustc_driver/profile/trace.rs", "status": "added", "additions": 315, "deletions": 0, "changes": 315, "blob_url": "https://github.com/rust-lang/rust/blob/2c0558f635861533e2fcb4298ea93250cdfc2c58/src%2Flibrustc_driver%2Fprofile%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c0558f635861533e2fcb4298ea93250cdfc2c58/src%2Flibrustc_driver%2Fprofile%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fprofile%2Ftrace.rs?ref=2c0558f635861533e2fcb4298ea93250cdfc2c58", "patch": "@@ -0,0 +1,315 @@\n+// Copyright 2012-2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::*;\n+use syntax_pos::Span;\n+use rustc::ty::maps::QueryMsg;\n+use std::fs::File;\n+use std::time::{Duration, Instant};\n+use std::collections::hash_map::HashMap;\n+use rustc::dep_graph::{DepNode};\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct Query {\n+    pub span: Span,\n+    pub msg: QueryMsg,\n+}\n+pub enum Effect {\n+    QueryBegin(Query, CacheCase),\n+    TimeBegin(String),\n+    TaskBegin(DepNode),\n+}\n+pub enum CacheCase {\n+    Hit, Miss\n+}\n+/// Recursive trace structure\n+pub struct Rec {\n+    pub effect: Effect,\n+    pub start: Instant,\n+    pub dur_self: Duration,\n+    pub dur_total: Duration,\n+    pub extent: Box<Vec<Rec>>,\n+}\n+pub struct QueryMetric {\n+    pub count: usize,\n+    pub dur_self: Duration,\n+    pub dur_total: Duration,\n+}\n+\n+pub fn cons_of_query_msg(q: &trace::Query) -> String {\n+    let s = format!(\"{:?}\", q.msg);\n+    let cons: Vec<&str> = s.split(|d| d == '(' || d == '{').collect();\n+    assert!(cons.len() > 0 && cons[0] != \"\");\n+    cons[0].to_string()\n+}\n+\n+pub fn cons_of_key(k: &DepNode) -> String {\n+    let s = format!(\"{:?}\", k);\n+    let cons: Vec<&str> = s.split(|d| d == '(' || d == '{').collect();\n+    assert!(cons.len() > 0 && cons[0] != \"\");\n+    cons[0].to_string()\n+}\n+\n+// First return value is text; second return value is a CSS class\n+pub fn html_of_effect(eff: &Effect) -> (String, String) {\n+    match *eff {\n+        Effect::TimeBegin(ref msg) => {\n+            (msg.clone(),\n+             format!(\"time-begin\"))\n+        },\n+        Effect::TaskBegin(ref key) => {\n+            let cons = cons_of_key(key);\n+            (cons.clone(), format!(\"{} task-begin\", cons))\n+        },\n+        Effect::QueryBegin(ref qmsg, ref cc) => {\n+            let cons = cons_of_query_msg(qmsg);\n+            (cons.clone(),\n+             format!(\"{} {}\",\n+                     cons,\n+                     match *cc {\n+                         CacheCase::Hit => \"hit\",\n+                         CacheCase::Miss => \"miss\",\n+                     }))\n+        }\n+    }\n+}\n+\n+// First return value is text; second return value is a CSS class\n+fn html_of_duration(_start: &Instant, dur: &Duration) -> (String, String) {\n+    use rustc::util::common::duration_to_secs_str;\n+    (duration_to_secs_str(dur.clone()),\n+     \"\".to_string()\n+    )\n+}\n+\n+fn html_of_fraction(frac: f64) -> (String, String) {\n+    let css = {\n+        if       frac > 0.50  { format!(\"frac-50\") }\n+        else if  frac > 0.40  { format!(\"frac-40\") }\n+        else if  frac > 0.30  { format!(\"frac-30\") }\n+        else if  frac > 0.20  { format!(\"frac-20\") }\n+        else if  frac > 0.10  { format!(\"frac-10\") }\n+        else if  frac > 0.05  { format!(\"frac-05\") }\n+        else if  frac > 0.02  { format!(\"frac-02\") }\n+        else if  frac > 0.01  { format!(\"frac-01\") }\n+        else if  frac > 0.001 { format!(\"frac-001\") }\n+        else                  { format!(\"frac-0\") }\n+    };\n+    let percent = frac * 100.0;\n+    if percent > 0.1 { (format!(\"{:.1}%\", percent), css) }\n+    else { (format!(\"< 0.1%\", ), css) }\n+}\n+\n+fn total_duration(traces: &Vec<Rec>) -> Duration {\n+    let mut sum : Duration = Duration::new(0,0);\n+    for t in traces.iter() {\n+        sum += t.dur_total;\n+    }\n+    return sum\n+}\n+\n+fn duration_div(nom: Duration, den: Duration) -> f64 {\n+    fn to_nanos(d: Duration) -> u64 {\n+        d.as_secs() * 1_000_000_000 + d.subsec_nanos() as u64\n+    }\n+\n+    to_nanos(nom) as f64 / to_nanos(den) as f64\n+}\n+\n+fn write_traces_rec(file: &mut File, traces: &Vec<Rec>, total: Duration, depth: usize) {\n+    for t in traces {\n+        let (eff_text, eff_css_classes) = html_of_effect(&t.effect);\n+        let (dur_text, dur_css_classes) = html_of_duration(&t.start, &t.dur_total);\n+        let fraction = duration_div(t.dur_total, total);\n+        let percent = fraction * 100.0;\n+        let (frc_text, frc_css_classes) = html_of_fraction(fraction);\n+        write!(file, \"<div class=\\\"trace depth-{} extent-{}{} {} {} {}\\\">\\n\",\n+               depth,\n+               t.extent.len(),\n+               /* Heuristic for 'important' CSS class: */\n+               if t.extent.len() > 5 || percent >= 1.0 {\n+                   \" important\" }\n+               else { \"\" },\n+               eff_css_classes,\n+               dur_css_classes,\n+               frc_css_classes,\n+        ).unwrap();\n+        write!(file, \"<div class=\\\"eff\\\">{}</div>\\n\", eff_text).unwrap();\n+        write!(file, \"<div class=\\\"dur\\\">{}</div>\\n\", dur_text).unwrap();\n+        write!(file, \"<div class=\\\"frc\\\">{}</div>\\n\", frc_text).unwrap();\n+        write_traces_rec(file, &t.extent, total, depth + 1);\n+        write!(file, \"</div>\\n\").unwrap();\n+    }\n+}\n+\n+fn compute_counts_rec(counts: &mut HashMap<String,QueryMetric>, traces: &Vec<Rec>) {\n+    for t in traces.iter() {\n+        match t.effect {\n+            Effect::TimeBegin(ref msg) => {\n+                let qm = match counts.get(msg) {\n+                    Some(_qm) => { panic!(\"TimeBegin with non-unique, repeat message\") }\n+                    None => QueryMetric{\n+                        count: 1,\n+                        dur_self: t.dur_self,\n+                        dur_total: t.dur_total,\n+                    }};\n+                counts.insert(msg.clone(), qm);\n+            },\n+            Effect::TaskBegin(ref key) => {\n+                let cons = cons_of_key(key);\n+                let qm = match counts.get(&cons) {\n+                    Some(qm) =>\n+                        QueryMetric{\n+                            count: qm.count + 1,\n+                            dur_self: qm.dur_self + t.dur_self,\n+                            dur_total: qm.dur_total + t.dur_total,\n+                        },\n+                    None => QueryMetric{\n+                        count: 1,\n+                        dur_self: t.dur_self,\n+                        dur_total: t.dur_total,\n+                    }};\n+                counts.insert(cons, qm);\n+            },\n+            Effect::QueryBegin(ref qmsg, ref _cc) => {\n+                let qcons = cons_of_query_msg(qmsg);\n+                let qm = match counts.get(&qcons) {\n+                    Some(qm) =>\n+                        QueryMetric{\n+                            count: qm.count + 1,\n+                            dur_total: qm.dur_total + t.dur_total,\n+                            dur_self: qm.dur_self + t.dur_self\n+                        },\n+                    None => QueryMetric{\n+                        count: 1,\n+                        dur_total: t.dur_total,\n+                        dur_self: t.dur_self,\n+                    }\n+                };\n+                counts.insert(qcons, qm);\n+            }\n+        }\n+        compute_counts_rec(counts, &t.extent)\n+    }\n+}\n+\n+pub fn write_counts(count_file: &mut File, counts: &mut HashMap<String,QueryMetric>) {\n+    use rustc::util::common::duration_to_secs_str;\n+    use std::cmp::Ordering;\n+\n+    let mut data = vec![];\n+    for (ref cons, ref qm) in counts.iter() {\n+        data.push((cons.clone(), qm.count.clone(), qm.dur_total.clone(), qm.dur_self.clone()));\n+    };\n+    data.sort_by(|&(_,_,_,self1),&(_,_,_,self2)|\n+                 if self1 > self2 { Ordering::Less } else { Ordering::Greater } );\n+    for (cons, count, dur_total, dur_self) in data {\n+        write!(count_file, \"{}, {}, {}, {}\\n\",\n+               cons, count,\n+               duration_to_secs_str(dur_total),\n+               duration_to_secs_str(dur_self)\n+        ).unwrap();\n+    }\n+}\n+\n+pub fn write_traces(html_file: &mut File, counts_file: &mut File, traces: &Vec<Rec>) {\n+    let mut counts : HashMap<String,QueryMetric> = HashMap::new();\n+    compute_counts_rec(&mut counts, traces);\n+    write_counts(counts_file, &mut counts);\n+\n+    let total : Duration = total_duration(traces);\n+    write_traces_rec(html_file, traces, total, 0)\n+}\n+\n+pub fn write_style(html_file: &mut File) {\n+    write!(html_file,\"{}\", \"\n+body {\n+    font-family: sans-serif;\n+    background: black;\n+}\n+.trace {\n+    color: black;\n+    display: inline-block;\n+    border-style: solid;\n+    border-color: red;\n+    border-width: 1px;\n+    border-radius: 5px;\n+    padding: 0px;\n+    margin: 1px;\n+    font-size: 0px;\n+}\n+.task-begin {\n+    border-width: 1px;\n+    color: white;\n+    border-color: #ff8;\n+    font-size: 0px;\n+}\n+.miss {\n+    border-color: red;\n+    border-width: 1px;\n+}\n+.extent-0 {\n+    padding: 2px;\n+}\n+.time-begin {\n+    border-width: 4px;\n+    font-size: 12px;\n+    color: white;\n+    border-color: #afa;\n+}\n+.important {\n+    border-width: 3px;\n+    font-size: 12px;\n+    color: white;\n+    border-color: #f77;\n+}\n+.hit {\n+    padding: 0px;\n+    border-color: blue;\n+    border-width: 3px;\n+}\n+.eff {\n+  color: #fff;\n+  display: inline-block;\n+}\n+.frc {\n+  color: #7f7;\n+  display: inline-block;\n+}\n+.dur {\n+  display: none\n+}\n+.frac-50 {\n+  padding: 10px;\n+  border-width: 10px;\n+  font-size: 32px;\n+}\n+.frac-40 {\n+  padding: 8px;\n+  border-width: 8px;\n+  font-size: 24px;\n+}\n+.frac-30 {\n+  padding: 6px;\n+  border-width: 6px;\n+  font-size: 18px;\n+}\n+.frac-20 {\n+  padding: 4px;\n+  border-width: 6px;\n+  font-size: 16px;\n+}\n+.frac-10 {\n+  padding: 2px;\n+  border-width: 6px;\n+  font-size: 14px;\n+}\n+\").unwrap();\n+}"}]}