{"sha": "31e2f4d80029fdad78d0ac34a89696f50054e690", "node_id": "C_kwDOAAsO6NoAKDMxZTJmNGQ4MDAyOWZkYWQ3OGQwYWMzNGE4OTY5NmY1MDA1NGU2OTA", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2023-05-05T03:46:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-05-05T03:46:27Z"}, "message": "Rollup merge of #111173 - nnethercote:still-more-Encoder-cleanups, r=cjgillot\n\nStill more encoder cleanups\n\nr? ``@cjgillot``", "tree": {"sha": "b9223379ebac42aed73a6e960af617e6ccd6010b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9223379ebac42aed73a6e960af617e6ccd6010b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31e2f4d80029fdad78d0ac34a89696f50054e690", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkVHwTCRBK7hj4Ov3rIwAAVEcIAC4X8VTMN0cpetnNJJqkK7XS\nR6aXCrheOVIKwT8k4UGz0UhbRxzip0coqZK/vkveZXhJXwE4sVqMkWM8Rb/lJugJ\n9euhsOm2oRKoSX4FwiFZuWsVKLS9PtkVy3ZfCSxTMrcaRa38291MSOGWaN7NsUuw\nBC3IC5Oz71AJzoiqg0DzbvMlVKcIEQK5F3SeSUBzcJ0HjjM9vw55FOdufuWXDErF\n2RWgthlnzRpFu5+KCSUeUVC1QPgbK36n1KxyTIkFTxhJPPDeq0lrP1/lBUIhTXUt\n8H0JrqpDkNeyfPSxYOzEfBcJH70LSMZQE57ymrKiRDlhUml3BBy0gewacpnPAtE=\n=0jO9\n-----END PGP SIGNATURE-----\n", "payload": "tree b9223379ebac42aed73a6e960af617e6ccd6010b\nparent f5c50e3350baaea9594196a5b7f07ec1db8445bf\nparent 723ca2a33df3774914abc68a8ab79238904ef067\nauthor Yuki Okushi <jtitor@2k36.org> 1683258387 +0900\ncommitter GitHub <noreply@github.com> 1683258387 +0900\n\nRollup merge of #111173 - nnethercote:still-more-Encoder-cleanups, r=cjgillot\n\nStill more encoder cleanups\n\nr? ``@cjgillot``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31e2f4d80029fdad78d0ac34a89696f50054e690", "html_url": "https://github.com/rust-lang/rust/commit/31e2f4d80029fdad78d0ac34a89696f50054e690", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31e2f4d80029fdad78d0ac34a89696f50054e690/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5c50e3350baaea9594196a5b7f07ec1db8445bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5c50e3350baaea9594196a5b7f07ec1db8445bf", "html_url": "https://github.com/rust-lang/rust/commit/f5c50e3350baaea9594196a5b7f07ec1db8445bf"}, {"sha": "723ca2a33df3774914abc68a8ab79238904ef067", "url": "https://api.github.com/repos/rust-lang/rust/commits/723ca2a33df3774914abc68a8ab79238904ef067", "html_url": "https://github.com/rust-lang/rust/commit/723ca2a33df3774914abc68a8ab79238904ef067"}], "stats": {"total": 186, "additions": 59, "deletions": 127}, "files": [{"sha": "82c66b9dfb9f69865d904c1fff98dc507fd1b8a2", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31e2f4d80029fdad78d0ac34a89696f50054e690/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e2f4d80029fdad78d0ac34a89696f50054e690/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=31e2f4d80029fdad78d0ac34a89696f50054e690", "patch": "@@ -108,11 +108,7 @@ impl<'a, 'tcx> Encoder for EncodeContext<'a, 'tcx> {\n         emit_i64(i64);\n         emit_i32(i32);\n         emit_i16(i16);\n-        emit_i8(i8);\n \n-        emit_bool(bool);\n-        emit_char(char);\n-        emit_str(&str);\n         emit_raw_bytes(&[u8]);\n     }\n }"}, {"sha": "220118ae5ccb8d77cc3c8cd9df4b9fee3fdf7b6c", "filename": "compiler/rustc_middle/src/query/on_disk_cache.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/31e2f4d80029fdad78d0ac34a89696f50054e690/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e2f4d80029fdad78d0ac34a89696f50054e690/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fon_disk_cache.rs?ref=31e2f4d80029fdad78d0ac34a89696f50054e690", "patch": "@@ -1026,11 +1026,7 @@ impl<'a, 'tcx> Encoder for CacheEncoder<'a, 'tcx> {\n         emit_i64(i64);\n         emit_i32(i32);\n         emit_i16(i16);\n-        emit_i8(i8);\n \n-        emit_bool(bool);\n-        emit_char(char);\n-        emit_str(&str);\n         emit_raw_bytes(&[u8]);\n     }\n }"}, {"sha": "7fc75674da53717961d9c6026240b1e0bb770690", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/31e2f4d80029fdad78d0ac34a89696f50054e690/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e2f4d80029fdad78d0ac34a89696f50054e690/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=31e2f4d80029fdad78d0ac34a89696f50054e690", "patch": "@@ -506,23 +506,18 @@ macro_rules! implement_ty_decoder {\n \n             impl<$($typaram ),*> Decoder for $DecoderName<$($typaram),*> {\n                 $crate::__impl_decoder_methods! {\n+                    read_usize -> usize;\n                     read_u128 -> u128;\n                     read_u64 -> u64;\n                     read_u32 -> u32;\n                     read_u16 -> u16;\n                     read_u8 -> u8;\n-                    read_usize -> usize;\n \n+                    read_isize -> isize;\n                     read_i128 -> i128;\n                     read_i64 -> i64;\n                     read_i32 -> i32;\n                     read_i16 -> i16;\n-                    read_i8 -> i8;\n-                    read_isize -> isize;\n-\n-                    read_bool -> bool;\n-                    read_char -> char;\n-                    read_str -> &str;\n                 }\n \n                 #[inline]\n@@ -531,13 +526,13 @@ macro_rules! implement_ty_decoder {\n                 }\n \n                 #[inline]\n-                fn position(&self) -> usize {\n-                    self.opaque.position()\n+                fn peek_byte(&self) -> u8 {\n+                    self.opaque.peek_byte()\n                 }\n \n                 #[inline]\n-                fn peek_byte(&self) -> u8 {\n-                    self.opaque.peek_byte()\n+                fn position(&self) -> usize {\n+                    self.opaque.position()\n                 }\n             }\n         }"}, {"sha": "6b559cb5b2f643ceb4c9fa901d83198e9578a1c1", "filename": "compiler/rustc_serialize/src/opaque.rs", "status": "modified", "additions": 51, "deletions": 102, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/31e2f4d80029fdad78d0ac34a89696f50054e690/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e2f4d80029fdad78d0ac34a89696f50054e690/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs?ref=31e2f4d80029fdad78d0ac34a89696f50054e690", "patch": "@@ -265,52 +265,41 @@ impl Drop for FileEncoder {\n     }\n }\n \n-macro_rules! file_encoder_write_leb128 {\n-    ($enc:expr, $value:expr, $int_ty:ty, $fun:ident) => {{\n-        const MAX_ENCODED_LEN: usize = $crate::leb128::max_leb128_len::<$int_ty>();\n+macro_rules! write_leb128 {\n+    ($this_fn:ident, $int_ty:ty, $write_leb_fn:ident) => {\n+        #[inline]\n+        fn $this_fn(&mut self, v: $int_ty) {\n+            const MAX_ENCODED_LEN: usize = $crate::leb128::max_leb128_len::<$int_ty>();\n \n-        // We ensure this during `FileEncoder` construction.\n-        debug_assert!($enc.capacity() >= MAX_ENCODED_LEN);\n+            // We ensure this during `FileEncoder` construction.\n+            debug_assert!(self.capacity() >= MAX_ENCODED_LEN);\n \n-        let mut buffered = $enc.buffered;\n+            let mut buffered = self.buffered;\n \n-        // This can't overflow. See assertion in `FileEncoder::with_capacity`.\n-        if std::intrinsics::unlikely(buffered + MAX_ENCODED_LEN > $enc.capacity()) {\n-            $enc.flush();\n-            buffered = 0;\n-        }\n+            // This can't overflow. See assertion in `FileEncoder::with_capacity`.\n+            if std::intrinsics::unlikely(buffered + MAX_ENCODED_LEN > self.capacity()) {\n+                self.flush();\n+                buffered = 0;\n+            }\n \n-        // SAFETY: The above check and flush ensures that there is enough\n-        // room to write the encoded value to the buffer.\n-        let buf = unsafe {\n-            &mut *($enc.buf.as_mut_ptr().add(buffered) as *mut [MaybeUninit<u8>; MAX_ENCODED_LEN])\n-        };\n+            // SAFETY: The above check and flush ensures that there is enough\n+            // room to write the encoded value to the buffer.\n+            let buf = unsafe {\n+                &mut *(self.buf.as_mut_ptr().add(buffered)\n+                    as *mut [MaybeUninit<u8>; MAX_ENCODED_LEN])\n+            };\n \n-        let encoded = leb128::$fun(buf, $value);\n-        $enc.buffered = buffered + encoded.len();\n-    }};\n+            let encoded = leb128::$write_leb_fn(buf, v);\n+            self.buffered = buffered + encoded.len();\n+        }\n+    };\n }\n \n impl Encoder for FileEncoder {\n-    #[inline]\n-    fn emit_usize(&mut self, v: usize) {\n-        file_encoder_write_leb128!(self, v, usize, write_usize_leb128)\n-    }\n-\n-    #[inline]\n-    fn emit_u128(&mut self, v: u128) {\n-        file_encoder_write_leb128!(self, v, u128, write_u128_leb128)\n-    }\n-\n-    #[inline]\n-    fn emit_u64(&mut self, v: u64) {\n-        file_encoder_write_leb128!(self, v, u64, write_u64_leb128)\n-    }\n-\n-    #[inline]\n-    fn emit_u32(&mut self, v: u32) {\n-        file_encoder_write_leb128!(self, v, u32, write_u32_leb128)\n-    }\n+    write_leb128!(emit_usize, usize, write_usize_leb128);\n+    write_leb128!(emit_u128, u128, write_u128_leb128);\n+    write_leb128!(emit_u64, u64, write_u64_leb128);\n+    write_leb128!(emit_u32, u32, write_u32_leb128);\n \n     #[inline]\n     fn emit_u16(&mut self, v: u16) {\n@@ -322,25 +311,10 @@ impl Encoder for FileEncoder {\n         self.write_one(v);\n     }\n \n-    #[inline]\n-    fn emit_isize(&mut self, v: isize) {\n-        file_encoder_write_leb128!(self, v, isize, write_isize_leb128)\n-    }\n-\n-    #[inline]\n-    fn emit_i128(&mut self, v: i128) {\n-        file_encoder_write_leb128!(self, v, i128, write_i128_leb128)\n-    }\n-\n-    #[inline]\n-    fn emit_i64(&mut self, v: i64) {\n-        file_encoder_write_leb128!(self, v, i64, write_i64_leb128)\n-    }\n-\n-    #[inline]\n-    fn emit_i32(&mut self, v: i32) {\n-        file_encoder_write_leb128!(self, v, i32, write_i32_leb128)\n-    }\n+    write_leb128!(emit_isize, isize, write_isize_leb128);\n+    write_leb128!(emit_i128, i128, write_i128_leb128);\n+    write_leb128!(emit_i64, i64, write_i64_leb128);\n+    write_leb128!(emit_i32, i32, write_i32_leb128);\n \n     #[inline]\n     fn emit_i16(&mut self, v: i16) {\n@@ -437,30 +411,19 @@ impl<'a> MemDecoder<'a> {\n }\n \n macro_rules! read_leb128 {\n-    ($dec:expr, $fun:ident) => {{ leb128::$fun($dec) }};\n+    ($this_fn:ident, $int_ty:ty, $read_leb_fn:ident) => {\n+        #[inline]\n+        fn $this_fn(&mut self) -> $int_ty {\n+            leb128::$read_leb_fn(self)\n+        }\n+    };\n }\n \n impl<'a> Decoder for MemDecoder<'a> {\n-    #[inline]\n-    fn position(&self) -> usize {\n-        // SAFETY: This type guarantees start <= current\n-        unsafe { self.current.sub_ptr(self.start) }\n-    }\n-\n-    #[inline]\n-    fn read_u128(&mut self) -> u128 {\n-        read_leb128!(self, read_u128_leb128)\n-    }\n-\n-    #[inline]\n-    fn read_u64(&mut self) -> u64 {\n-        read_leb128!(self, read_u64_leb128)\n-    }\n-\n-    #[inline]\n-    fn read_u32(&mut self) -> u32 {\n-        read_leb128!(self, read_u32_leb128)\n-    }\n+    read_leb128!(read_usize, usize, read_usize_leb128);\n+    read_leb128!(read_u128, u128, read_u128_leb128);\n+    read_leb128!(read_u64, u64, read_u64_leb128);\n+    read_leb128!(read_u32, u32, read_u32_leb128);\n \n     #[inline]\n     fn read_u16(&mut self) -> u16 {\n@@ -480,36 +443,16 @@ impl<'a> Decoder for MemDecoder<'a> {\n         }\n     }\n \n-    #[inline]\n-    fn read_usize(&mut self) -> usize {\n-        read_leb128!(self, read_usize_leb128)\n-    }\n-\n-    #[inline]\n-    fn read_i128(&mut self) -> i128 {\n-        read_leb128!(self, read_i128_leb128)\n-    }\n-\n-    #[inline]\n-    fn read_i64(&mut self) -> i64 {\n-        read_leb128!(self, read_i64_leb128)\n-    }\n-\n-    #[inline]\n-    fn read_i32(&mut self) -> i32 {\n-        read_leb128!(self, read_i32_leb128)\n-    }\n+    read_leb128!(read_isize, isize, read_isize_leb128);\n+    read_leb128!(read_i128, i128, read_i128_leb128);\n+    read_leb128!(read_i64, i64, read_i64_leb128);\n+    read_leb128!(read_i32, i32, read_i32_leb128);\n \n     #[inline]\n     fn read_i16(&mut self) -> i16 {\n         i16::from_le_bytes(self.read_array())\n     }\n \n-    #[inline]\n-    fn read_isize(&mut self) -> isize {\n-        read_leb128!(self, read_isize_leb128)\n-    }\n-\n     #[inline]\n     fn read_raw_bytes(&mut self, bytes: usize) -> &'a [u8] {\n         if bytes > self.remaining() {\n@@ -532,6 +475,12 @@ impl<'a> Decoder for MemDecoder<'a> {\n         // Since we just checked current == end, the current pointer must be inbounds.\n         unsafe { *self.current }\n     }\n+\n+    #[inline]\n+    fn position(&self) -> usize {\n+        // SAFETY: This type guarantees start <= current\n+        unsafe { self.current.sub_ptr(self.start) }\n+    }\n }\n \n // Specializations for contiguous byte sequences follow. The default implementations for slices"}, {"sha": "06166cabc187212eca09d6a8567bc9342d21560c", "filename": "compiler/rustc_serialize/src/serialize.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/31e2f4d80029fdad78d0ac34a89696f50054e690/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31e2f4d80029fdad78d0ac34a89696f50054e690/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs?ref=31e2f4d80029fdad78d0ac34a89696f50054e690", "patch": "@@ -1,9 +1,5 @@\n //! Support code for encoding and decoding types.\n \n-/*\n-Core encoding and decoding interfaces.\n-*/\n-\n use std::alloc::Allocator;\n use std::borrow::Cow;\n use std::cell::{Cell, RefCell};\n@@ -35,13 +31,13 @@ const STR_SENTINEL: u8 = 0xC1;\n /// really makes sense to store floating-point values at all.\n /// (If you need it, revert <https://github.com/rust-lang/rust/pull/109984>.)\n pub trait Encoder {\n-    // Primitive types:\n     fn emit_usize(&mut self, v: usize);\n     fn emit_u128(&mut self, v: u128);\n     fn emit_u64(&mut self, v: u64);\n     fn emit_u32(&mut self, v: u32);\n     fn emit_u16(&mut self, v: u16);\n     fn emit_u8(&mut self, v: u8);\n+\n     fn emit_isize(&mut self, v: isize);\n     fn emit_i128(&mut self, v: i128);\n     fn emit_i64(&mut self, v: i64);\n@@ -93,13 +89,13 @@ pub trait Encoder {\n /// really makes sense to store floating-point values at all.\n /// (If you need it, revert <https://github.com/rust-lang/rust/pull/109984>.)\n pub trait Decoder {\n-    // Primitive types:\n     fn read_usize(&mut self) -> usize;\n     fn read_u128(&mut self) -> u128;\n     fn read_u64(&mut self) -> u64;\n     fn read_u32(&mut self) -> u32;\n     fn read_u16(&mut self) -> u16;\n     fn read_u8(&mut self) -> u8;\n+\n     fn read_isize(&mut self) -> isize;\n     fn read_i128(&mut self) -> i128;\n     fn read_i64(&mut self) -> i64;"}]}