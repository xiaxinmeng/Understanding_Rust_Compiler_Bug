{"sha": "4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiZGRhMzU5YzNjZjQxZTM2YmEwMWNhNmFlZjgyNmFjYTdjYzgxYzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-11T15:31:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-11T15:31:40Z"}, "message": "auto merge of #11252 : eddyb/rust/ty-cleanup, r=pcwalton", "tree": {"sha": "87bdabc86631457e1e352294122088e8cd0722e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87bdabc86631457e1e352294122088e8cd0722e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "html_url": "https://github.com/rust-lang/rust/commit/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99df8a3f158aebc76a3bd3a87e367a9d01108633", "url": "https://api.github.com/repos/rust-lang/rust/commits/99df8a3f158aebc76a3bd3a87e367a9d01108633", "html_url": "https://github.com/rust-lang/rust/commit/99df8a3f158aebc76a3bd3a87e367a9d01108633"}, {"sha": "08ac616d379bb181e55b08f88e8c5342ee8d63a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/08ac616d379bb181e55b08f88e8c5342ee8d63a2", "html_url": "https://github.com/rust-lang/rust/commit/08ac616d379bb181e55b08f88e8c5342ee8d63a2"}], "stats": {"total": 1681, "additions": 769, "deletions": 912}, "files": [{"sha": "945ee645414b7e8ae6bd26f119feb3b69c674115", "filename": "src/librustc/back/abi.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fabi.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -44,11 +44,10 @@ pub static tydesc_field_size: uint = 0u;\n pub static tydesc_field_align: uint = 1u;\n pub static tydesc_field_take_glue: uint = 2u;\n pub static tydesc_field_drop_glue: uint = 3u;\n-pub static tydesc_field_free_glue: uint = 4u;\n-pub static tydesc_field_visit_glue: uint = 5u;\n-pub static tydesc_field_borrow_offset: uint = 6u;\n-pub static tydesc_field_name_offset: uint = 7u;\n-pub static n_tydesc_fields: uint = 8u;\n+pub static tydesc_field_visit_glue: uint = 4u;\n+pub static tydesc_field_borrow_offset: uint = 5u;\n+pub static tydesc_field_name_offset: uint = 6u;\n+pub static n_tydesc_fields: uint = 7u;\n \n // The two halves of a closure: code and environment.\n pub static fn_field_code: uint = 0u;"}, {"sha": "261cb15a7aac5d51e61c467c71b6cd1342cbbc58", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -354,11 +354,11 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n       'V' => {\n         let mt = parse_mt(st, |x,y| conv(x,y));\n         let v = parse_vstore(st, |x,y| conv(x,y));\n-        return ty::mk_evec(st.tcx, mt, v);\n+        return ty::mk_vec(st.tcx, mt, v);\n       }\n       'v' => {\n         let v = parse_vstore(st, |x,y| conv(x,y));\n-        return ty::mk_estr(st.tcx, v);\n+        return ty::mk_str(st.tcx, v);\n       }\n       'T' => {\n         assert_eq!(next(st), '[');\n@@ -410,7 +410,6 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n         let inner = parse_ty(st, |x,y| conv(x,y));\n         inner\n       }\n-      'B' => ty::mk_opaque_box(st.tcx),\n       'a' => {\n           assert_eq!(next(st), '[');\n           let did = parse_def(st, NominalType, |x,y| conv(x,y));"}, {"sha": "8a8fdd7265216c46e9bffe4e46dc8490e08ec5a4", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -299,12 +299,12 @@ fn enc_sty(w: &mut MemWriter, cx: @ctxt, st: &ty::sty) {\n             enc_region(w, cx, r);\n             enc_mt(w, cx, mt);\n         }\n-        ty::ty_evec(mt, v) => {\n+        ty::ty_vec(mt, v) => {\n             mywrite!(w, \"V\");\n             enc_mt(w, cx, mt);\n             enc_vstore(w, cx, v);\n         }\n-        ty::ty_estr(v) => {\n+        ty::ty_str(v) => {\n             mywrite!(w, \"v\");\n             enc_vstore(w, cx, v);\n         }\n@@ -331,7 +331,6 @@ fn enc_sty(w: &mut MemWriter, cx: @ctxt, st: &ty::sty) {\n             mywrite!(w, \"C&\");\n             enc_sigil(w, p);\n         }\n-        ty::ty_opaque_box => mywrite!(w, \"B\"),\n         ty::ty_struct(def, ref substs) => {\n             mywrite!(w, \"a[{}|\", (cx.ds)(def));\n             enc_substs(w, cx, substs);"}, {"sha": "675d31ebea8d5a3504ab0cba6c912698978efa6f", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -578,9 +578,6 @@ fn encode_method_map_entry(ecx: &e::EncodeContext,\n         ebml_w.emit_struct_field(\"origin\", 1u, |ebml_w| {\n             mme.origin.encode(ebml_w);\n         });\n-        ebml_w.emit_struct_field(\"self_mode\", 3, |ebml_w| {\n-            mme.self_mode.encode(ebml_w);\n-        });\n     })\n }\n \n@@ -602,11 +599,7 @@ impl<'a> read_method_map_entry_helper for reader::Decoder<'a> {\n                     let method_origin: method_origin =\n                         Decodable::decode(this);\n                     method_origin.tr(xcx)\n-                }),\n-                self_mode: this.read_struct_field(\"self_mode\", 3, |this| {\n-                    let self_mode: ty::SelfMode = Decodable::decode(this);\n-                    self_mode\n-                }),\n+                })\n             }\n         })\n     }"}, {"sha": "b1337fca0c85da8f00849dfd05d0c5cb87d7e362", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -808,7 +808,7 @@ impl<'a> GatherLoanCtxt<'a> {\n          */\n \n         match ty::get(slice_ty).sty {\n-            ty::ty_evec(slice_mt, ty::vstore_slice(slice_r)) => {\n+            ty::ty_vec(slice_mt, ty::vstore_slice(slice_r)) => {\n                 (slice_mt.mutbl, slice_r)\n             }\n "}, {"sha": "79cb1c779a02e64a264a75975e38b22804559fb7", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -195,7 +195,7 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, pats: ~[@Pat]) {\n                         }\n                     }\n                 }\n-                ty::ty_unboxed_vec(..) | ty::ty_evec(..) => {\n+                ty::ty_unboxed_vec(..) | ty::ty_vec(..) => {\n                     match *ctor {\n                         vec(n) => Some(format!(\"vectors of length {}\", n).to_managed()),\n                         _ => None\n@@ -274,10 +274,10 @@ fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@Pat]) -> useful {\n                 }\n                 not_useful\n               }\n-              ty::ty_evec(_, ty::vstore_fixed(n)) => {\n+              ty::ty_vec(_, ty::vstore_fixed(n)) => {\n                 is_useful_specialized(cx, m, v, vec(n), n, left_ty)\n               }\n-              ty::ty_unboxed_vec(..) | ty::ty_evec(..) => {\n+              ty::ty_unboxed_vec(..) | ty::ty_vec(..) => {\n                 let max_len = m.rev_iter().fold(0, |max_len, r| {\n                   match r[0].node {\n                     PatVec(ref before, _, ref after) => {\n@@ -437,7 +437,7 @@ fn missing_ctor(cx: &MatchCheckCtxt,\n         else if true_found { Some(val(const_bool(false))) }\n         else { Some(val(const_bool(true))) }\n       }\n-      ty::ty_evec(_, ty::vstore_fixed(n)) => {\n+      ty::ty_vec(_, ty::vstore_fixed(n)) => {\n         let mut missing = true;\n         let mut wrong = false;\n         for r in m.iter() {\n@@ -460,7 +460,7 @@ fn missing_ctor(cx: &MatchCheckCtxt,\n           _         => None\n         }\n       }\n-      ty::ty_unboxed_vec(..) | ty::ty_evec(..) => {\n+      ty::ty_unboxed_vec(..) | ty::ty_vec(..) => {\n \n         // Find the lengths and slices of all vector patterns.\n         let mut vec_pat_lens = m.iter().filter_map(|r| {\n@@ -525,7 +525,7 @@ fn ctor_arity(cx: &MatchCheckCtxt, ctor: &ctor, ty: ty::t) -> uint {\n         }\n       }\n       ty::ty_struct(cid, _) => ty::lookup_struct_fields(cx.tcx, cid).len(),\n-      ty::ty_unboxed_vec(..) | ty::ty_evec(..) => {\n+      ty::ty_unboxed_vec(..) | ty::ty_vec(..) => {\n         match *ctor {\n           vec(n) => n,\n           _ => 0u"}, {"sha": "e291d2595a0b2cde584098833cbdeb12605d5463", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -71,7 +71,7 @@ impl EffectCheckVisitor {\n         debug!(\"effect: checking index with base type {}\",\n                 ppaux::ty_to_str(self.tcx, base_type));\n         match ty::get(base_type).sty {\n-            ty::ty_estr(..) => {\n+            ty::ty_str(..) => {\n                 self.tcx.sess.span_err(e.span,\n                     \"modification of string types is not allowed\");\n             }"}, {"sha": "55cb9f87bcd0d446ffc61b8d9383bc8ed43e1948", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -819,13 +819,13 @@ fn check_heap_type(cx: &Context, span: Span, ty: ty::t) {\n         let mut n_uniq = 0;\n         ty::fold_ty(cx.tcx, ty, |t| {\n             match ty::get(t).sty {\n-                ty::ty_box(_) | ty::ty_estr(ty::vstore_box) |\n-                ty::ty_evec(_, ty::vstore_box) |\n+                ty::ty_box(_) | ty::ty_str(ty::vstore_box) |\n+                ty::ty_vec(_, ty::vstore_box) |\n                 ty::ty_trait(_, _, ty::BoxTraitStore, _, _) => {\n                     n_box += 1;\n                 }\n-                ty::ty_uniq(_) | ty::ty_estr(ty::vstore_uniq) |\n-                ty::ty_evec(_, ty::vstore_uniq) |\n+                ty::ty_uniq(_) | ty::ty_str(ty::vstore_uniq) |\n+                ty::ty_vec(_, ty::vstore_uniq) |\n                 ty::ty_trait(_, _, ty::UniqTraitStore, _, _) => {\n                     n_uniq += 1;\n                 }"}, {"sha": "a00b01d54ce790d3c52b890983c5a8ca757ec324", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -157,31 +157,31 @@ pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n     match ty::get(t).sty {\n         ty::ty_uniq(_) |\n         ty::ty_trait(_, _, ty::UniqTraitStore, _, _) |\n-        ty::ty_evec(_, ty::vstore_uniq) |\n-        ty::ty_estr(ty::vstore_uniq) |\n+        ty::ty_vec(_, ty::vstore_uniq) |\n+        ty::ty_str(ty::vstore_uniq) |\n         ty::ty_closure(ty::ClosureTy {sigil: ast::OwnedSigil, ..}) => {\n             Some(deref_ptr(uniq_ptr))\n         }\n \n         ty::ty_rptr(r, mt) |\n-        ty::ty_evec(mt, ty::vstore_slice(r)) => {\n+        ty::ty_vec(mt, ty::vstore_slice(r)) => {\n             Some(deref_ptr(region_ptr(mt.mutbl, r)))\n         }\n \n         ty::ty_trait(_, _, ty::RegionTraitStore(r), m, _) => {\n             Some(deref_ptr(region_ptr(m, r)))\n         }\n \n-        ty::ty_estr(ty::vstore_slice(r)) |\n+        ty::ty_str(ty::vstore_slice(r)) |\n         ty::ty_closure(ty::ClosureTy {sigil: ast::BorrowedSigil,\n                                       region: r, ..}) => {\n             Some(deref_ptr(region_ptr(ast::MutImmutable, r)))\n         }\n \n         ty::ty_box(_) |\n-        ty::ty_evec(_, ty::vstore_box) |\n+        ty::ty_vec(_, ty::vstore_box) |\n         ty::ty_trait(_, _, ty::BoxTraitStore, _, _) |\n-        ty::ty_estr(ty::vstore_box) => {\n+        ty::ty_str(ty::vstore_box) => {\n             Some(deref_ptr(gc_ptr))\n         }\n \n@@ -194,8 +194,8 @@ pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n             Some(deref_interior(InteriorField(PositionalField(0))))\n         }\n \n-        ty::ty_evec(_, ty::vstore_fixed(_)) |\n-        ty::ty_estr(ty::vstore_fixed(_)) => {\n+        ty::ty_vec(_, ty::vstore_fixed(_)) |\n+        ty::ty_str(ty::vstore_fixed(_)) => {\n             Some(deref_interior(InteriorElement(element_kind(t))))\n         }\n \n@@ -1247,8 +1247,8 @@ impl Repr for InteriorKind {\n \n fn element_kind(t: ty::t) -> ElementKind {\n     match ty::get(t).sty {\n-        ty::ty_evec(..) => VecElement,\n-        ty::ty_estr(..) => StrElement,\n+        ty::ty_vec(..) => VecElement,\n+        ty::ty_str(..) => StrElement,\n         _ => OtherElement\n     }\n }"}, {"sha": "29c82ef83f8de953254fb3bb887ec11327b82c3c", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 54, "deletions": 45, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -1078,7 +1078,7 @@ fn extract_vec_elems<'a>(\n         let slice_begin = tvec::pointer_add_byte(bcx, base, slice_byte_offset);\n         let slice_len_offset = C_uint(bcx.ccx(), elem_count - 1u);\n         let slice_len = Sub(bcx, len, slice_len_offset);\n-        let slice_ty = ty::mk_evec(bcx.tcx(),\n+        let slice_ty = ty::mk_vec(bcx.tcx(),\n             ty::mt {ty: vt.unit_ty, mutbl: ast::MutImmutable},\n             ty::vstore_slice(ty::ReStatic)\n         );\n@@ -1312,7 +1312,7 @@ fn compare_values<'a>(\n     }\n \n     match ty::get(rhs_t).sty {\n-        ty::ty_estr(ty::vstore_uniq) => {\n+        ty::ty_str(ty::vstore_uniq) => {\n             let scratch_lhs = alloca(cx, val_ty(lhs), \"__lhs\");\n             Store(cx, lhs, scratch_lhs);\n             let scratch_rhs = alloca(cx, val_ty(rhs), \"__rhs\");\n@@ -1326,7 +1326,7 @@ fn compare_values<'a>(\n                 val: bool_to_i1(result.bcx, result.val)\n             }\n         }\n-        ty::ty_estr(_) => {\n+        ty::ty_str(_) => {\n             let did = langcall(cx, None,\n                                format!(\"comparison of `{}`\", cx.ty_to_str(rhs_t)),\n                                StrEqFnLangItem);\n@@ -1392,37 +1392,41 @@ fn insert_lllocals<'a>(\n         let llval = match binding_info.trmode {\n             // By value bindings: use the stack slot that we\n             // copied/moved the value into\n-            TrByValue(lldest) => {\n-                if add_cleans {\n-                    add_clean(bcx, lldest, binding_info.ty);\n-                }\n+            TrByValue(lldest) => lldest,\n+            // By ref binding: use the ptr into the matched value\n+            TrByRef => binding_info.llmatch\n+        };\n \n-                lldest\n-            }\n+        let datum = Datum {\n+            val: llval,\n+            ty: binding_info.ty,\n+            mode: ByRef(ZeroMem)\n+        };\n \n-            // By ref binding: use the ptr into the matched value\n-            TrByRef => {\n-                binding_info.llmatch\n+        if add_cleans {\n+            match binding_info.trmode {\n+                TrByValue(_) => datum.add_clean(bcx),\n+                _ => {}\n             }\n-        };\n+        }\n \n         {\n             debug!(\"binding {:?} to {}\",\n                    binding_info.id,\n                    bcx.val_to_str(llval));\n             let mut llmap = bcx.fcx.lllocals.borrow_mut();\n-            llmap.get().insert(binding_info.id, llval);\n+            llmap.get().insert(binding_info.id, datum);\n         }\n \n         if bcx.sess().opts.extra_debuginfo {\n             debuginfo::create_match_binding_metadata(bcx,\n                                                      ident,\n                                                      binding_info.id,\n-                                                     binding_info.ty,\n-                                                     binding_info.span);\n+                                                     binding_info.span,\n+                                                     datum);\n         }\n     }\n-    return bcx;\n+    bcx\n }\n \n fn compile_guard<'r,\n@@ -2032,8 +2036,7 @@ pub fn store_local<'a>(\n                 Some(path) => {\n                     return mk_binding_alloca(\n                         bcx, pat.id, path, BindLocal,\n-                        |bcx, _, llval| expr::trans_into(bcx, init_expr,\n-                                                         expr::SaveIn(llval)));\n+                        |bcx, datum| expr::trans_into(bcx, init_expr, expr::SaveIn(datum.val)));\n                 }\n \n                 None => {}\n@@ -2067,13 +2070,13 @@ pub fn store_local<'a>(\n         pat_bindings(tcx.def_map, pat, |_, p_id, _, path| {\n             bcx = mk_binding_alloca(\n                 bcx, p_id, path, BindLocal,\n-                |bcx, var_ty, llval| { zero_mem(bcx, llval, var_ty); bcx });\n+                |bcx, datum| { datum.cancel_clean(bcx); bcx });\n         });\n         bcx\n     }\n }\n \n-pub fn store_arg<'a>(mut bcx: &'a Block<'a>, pat: @ast::Pat, llval: ValueRef)\n+pub fn store_arg<'a>(mut bcx: &'a Block<'a>, pat: @ast::Pat, arg: Datum)\n                  -> &'a Block<'a> {\n     /*!\n      * Generates code for argument patterns like `fn foo(<pat>: T)`.\n@@ -2093,13 +2096,12 @@ pub fn store_arg<'a>(mut bcx: &'a Block<'a>, pat: @ast::Pat, llval: ValueRef)\n     // Note that we cannot do it before for fear of a fn like\n     //    fn getaddr(~ref x: ~uint) -> *uint {....}\n     // (From test `run-pass/func-arg-ref-pattern.rs`)\n-    let arg_ty = node_id_type(bcx, pat.id);\n-    add_clean(bcx, llval, arg_ty);\n+    arg.add_clean(bcx);\n \n     // Debug information (the llvm.dbg.declare intrinsic to be precise) always expects to get an\n     // alloca, which only is the case on the general path, so lets disable the optimized path when\n     // debug info is enabled.\n-    let arg_is_alloca = unsafe { llvm::LLVMIsAAllocaInst(llval) != ptr::null() };\n+    let arg_is_alloca = unsafe { llvm::LLVMIsAAllocaInst(arg.val) != ptr::null() };\n \n     let fast_path = (arg_is_alloca || !bcx.ccx().sess.opts.extra_debuginfo)\n                     && simple_identifier(pat).is_some();\n@@ -2109,37 +2111,42 @@ pub fn store_arg<'a>(mut bcx: &'a Block<'a>, pat: @ast::Pat, llval: ValueRef)\n         // `llval` wholesale as the pointer for `x`, avoiding the\n         // general logic which may copy out of `llval`.\n         let mut llargs = bcx.fcx.llargs.borrow_mut();\n-        llargs.get().insert(pat.id, llval);\n+        llargs.get().insert(pat.id, arg);\n     } else {\n         // General path. Copy out the values that are used in the\n         // pattern.\n-        bcx = bind_irrefutable_pat(bcx, pat, llval, BindArgument);\n+        let llptr = arg.to_ref_llval(bcx);\n+        bcx = bind_irrefutable_pat(bcx, pat, llptr, BindArgument);\n     }\n \n     return bcx;\n }\n \n fn mk_binding_alloca<'a>(\n-                     mut bcx: &'a Block<'a>,\n+                     bcx: &'a Block<'a>,\n                      p_id: ast::NodeId,\n                      path: &ast::Path,\n                      binding_mode: IrrefutablePatternBindingMode,\n-                     populate: |&'a Block<'a>,\n-                                ty::t,\n-                                ValueRef|\n-                                -> &'a Block<'a>)\n+                     populate: |&'a Block<'a>, Datum| -> &'a Block<'a>)\n                      -> &'a Block<'a> {\n     let var_ty = node_id_type(bcx, p_id);\n     let ident = ast_util::path_to_ident(path);\n     let llval = alloc_ty(bcx, var_ty, bcx.ident(ident));\n-    bcx = populate(bcx, var_ty, llval);\n-    let mut llmap = match binding_mode {\n-        BindLocal => bcx.fcx.lllocals.borrow_mut(),\n-        BindArgument => bcx.fcx.llargs.borrow_mut(),\n+    let datum = Datum {\n+        val: llval,\n+        ty: var_ty,\n+        mode: ByRef(ZeroMem)\n     };\n-    llmap.get().insert(p_id, llval);\n-    add_clean(bcx, llval, var_ty);\n-    return bcx;\n+    {\n+        let mut llmap = match binding_mode {\n+            BindLocal => bcx.fcx.lllocals.borrow_mut(),\n+            BindArgument => bcx.fcx.llargs.borrow_mut()\n+        };\n+        llmap.get().insert(p_id, datum);\n+    }\n+    let bcx = populate(bcx, datum);\n+    datum.add_clean(bcx);\n+    bcx\n }\n \n fn bind_irrefutable_pat<'a>(\n@@ -2179,7 +2186,7 @@ fn bind_irrefutable_pat<'a>(\n \n     let _indenter = indenter();\n \n-    let _icx = push_ctxt(\"alt::bind_irrefutable_pat\");\n+    let _icx = push_ctxt(\"match::bind_irrefutable_pat\");\n     let mut bcx = bcx;\n     let tcx = bcx.tcx();\n     let ccx = bcx.ccx();\n@@ -2191,21 +2198,23 @@ fn bind_irrefutable_pat<'a>(\n                 // map.\n                 bcx = mk_binding_alloca(\n                     bcx, pat.id, path, binding_mode,\n-                    |bcx, variable_ty, llvariable_val| {\n+                    |bcx, var_datum| {\n                         match pat_binding_mode {\n                             ast::BindByValue(_) => {\n                                 // By value binding: move the value that `val`\n                                 // points at into the binding's stack slot.\n-                                let datum = Datum {val: val,\n-                                                   ty: variable_ty,\n-                                                   mode: ByRef(ZeroMem)};\n-                                datum.store_to(bcx, INIT, llvariable_val)\n+                                let datum = Datum {\n+                                    val: val,\n+                                    ty: var_datum.ty,\n+                                    mode: ByRef(ZeroMem)\n+                                };\n+                                datum.store_to(bcx, INIT, var_datum.val)\n                             }\n \n                             ast::BindByRef(_) => {\n                                 // By ref binding: the value of the variable\n                                 // is the pointer `val` itself.\n-                                Store(bcx, val, llvariable_val);\n+                                Store(bcx, val, var_datum.val);\n                                 bcx\n                             }\n                         }"}, {"sha": "11f217f3cb4b1ae3885c73fc420273d3dbdaf011", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -20,7 +20,6 @@ use middle::trans::callee;\n use middle::trans::common::*;\n use middle::trans::expr::*;\n use middle::trans::type_of::*;\n-use middle::ty;\n \n use middle::trans::type_::Type;\n \n@@ -56,7 +55,6 @@ pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::InlineAsm)\n         unpack_result!(bcx, {\n             callee::trans_arg_expr(bcx,\n                                    expr_ty(bcx, input),\n-                                   ty::ByCopy,\n                                    input,\n                                    &mut cleanups,\n                                    callee::DontAutorefArg)"}, {"sha": "6fa3764fb379bbe1431212d91ef15c84adaa3cb9", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 159, "deletions": 93, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -53,20 +53,19 @@ use middle::trans::expr;\n use middle::trans::foreign;\n use middle::trans::glue;\n use middle::trans::inline;\n-use middle::trans::llrepr::LlvmRepr;\n use middle::trans::machine;\n use middle::trans::machine::{llalign_of_min, llsize_of};\n use middle::trans::meth;\n use middle::trans::monomorphize;\n use middle::trans::tvec;\n+use middle::trans::type_::Type;\n use middle::trans::type_of;\n use middle::trans::type_of::*;\n use middle::trans::value::Value;\n use middle::ty;\n use util::common::indenter;\n use util::ppaux::{Repr, ty_to_str};\n use util::sha2::Sha256;\n-use middle::trans::type_::Type;\n \n use extra::arena::TypedArena;\n use extra::time;\n@@ -218,7 +217,7 @@ fn get_extern_rust_fn(ccx: &CrateContext, inputs: &[ty::t], output: ty::t,\n         }\n     }\n \n-    let f = decl_rust_fn(ccx, inputs, output, name);\n+    let f = decl_rust_fn(ccx, None, inputs, output, name);\n     csearch::get_item_attrs(ccx.tcx.cstore, did, |meta_items| {\n         set_llvm_fn_attrs(meta_items.iter().map(|&x| attr::mk_attr(x)).to_owned_vec(), f)\n     });\n@@ -228,8 +227,12 @@ fn get_extern_rust_fn(ccx: &CrateContext, inputs: &[ty::t], output: ty::t,\n     f\n }\n \n-fn decl_rust_fn(ccx: &CrateContext, inputs: &[ty::t], output: ty::t, name: &str) -> ValueRef {\n-    let llfty = type_of_rust_fn(ccx, inputs, output);\n+fn decl_rust_fn(ccx: &CrateContext,\n+                self_ty: Option<ty::t>,\n+                inputs: &[ty::t],\n+                output: ty::t,\n+                name: &str) -> ValueRef {\n+    let llfty = type_of_rust_fn(ccx, self_ty, inputs, output);\n     let llfn = decl_cdecl_fn(ccx.llmod, name, llfty);\n \n     match ty::get(output).sty {\n@@ -241,7 +244,7 @@ fn decl_rust_fn(ccx: &CrateContext, inputs: &[ty::t], output: ty::t, name: &str)\n         }\n         // `~` pointer return values never alias because ownership is transferred\n         ty::ty_uniq(..) |\n-        ty::ty_evec(_, ty::vstore_uniq) => {\n+        ty::ty_vec(_, ty::vstore_uniq) => {\n             unsafe {\n                 llvm::LLVMAddReturnAttribute(llfn, lib::llvm::NoAliasAttribute as c_uint);\n             }\n@@ -257,13 +260,13 @@ fn decl_rust_fn(ccx: &CrateContext, inputs: &[ty::t], output: ty::t, name: &str)\n         match ty::get(arg_ty).sty {\n             // `~` pointer parameters never alias because ownership is transferred\n             ty::ty_uniq(..) |\n-            ty::ty_evec(_, ty::vstore_uniq) |\n+            ty::ty_vec(_, ty::vstore_uniq) |\n             ty::ty_closure(ty::ClosureTy {sigil: ast::OwnedSigil, ..}) => {\n                 unsafe {\n                     llvm::LLVMAddAttribute(llarg, lib::llvm::NoAliasAttribute as c_uint);\n                 }\n             }\n-            _ => ()\n+            _ => {}\n         }\n     }\n \n@@ -281,9 +284,10 @@ fn decl_rust_fn(ccx: &CrateContext, inputs: &[ty::t], output: ty::t, name: &str)\n     llfn\n }\n \n-pub fn decl_internal_rust_fn(ccx: &CrateContext, inputs: &[ty::t], output: ty::t,\n-                             name: &str) -> ValueRef {\n-    let llfn = decl_rust_fn(ccx, inputs, output, name);\n+pub fn decl_internal_rust_fn(ccx: &CrateContext,\n+                             self_ty: Option<ty::t>, inputs: &[ty::t],\n+                             output: ty::t, name: &str) -> ValueRef {\n+    let llfn = decl_rust_fn(ccx, self_ty, inputs, output, name);\n     lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n     llfn\n }\n@@ -758,8 +762,8 @@ pub fn iter_structural_ty<'r,\n               }\n           })\n       }\n-      ty::ty_estr(ty::vstore_fixed(_)) |\n-      ty::ty_evec(_, ty::vstore_fixed(_)) => {\n+      ty::ty_str(ty::vstore_fixed(_)) |\n+      ty::ty_vec(_, ty::vstore_fixed(_)) => {\n         let (base, len) = tvec::get_base_and_byte_len(cx, av, t);\n         cx = tvec::iter_vec_raw(cx, base, t, len, f);\n       }\n@@ -913,7 +917,7 @@ pub fn trans_external_path(ccx: &CrateContext, did: ast::DefId, t: ty::t) -> Val\n                 Some(..) | None => {\n                     let c = foreign::llvm_calling_convention(ccx, fn_ty.abis);\n                     let cconv = c.unwrap_or(lib::llvm::CCallConv);\n-                    let llty = type_of_fn_from_ty(ccx, t);\n+                    let llty = type_of_fn_from_ty(ccx, None, t);\n                     let mut externs = ccx.externs.borrow_mut();\n                     get_extern_fn(externs.get(), ccx.llmod, name, cconv, llty)\n                 }\n@@ -1013,7 +1017,7 @@ pub fn need_invoke(bcx: &Block) -> bool {\n                 let cleanups = inf.cleanups.borrow();\n                 for cleanup in cleanups.get().iter() {\n                     match *cleanup {\n-                        clean(_, cleanup_type) | clean_temp(_, _, cleanup_type) => {\n+                        Clean(_, cleanup_type) | CleanTemp(_, _, cleanup_type) => {\n                             if cleanup_type == normal_exit_and_unwind {\n                                 return true;\n                             }\n@@ -1365,7 +1369,7 @@ pub fn trans_block_cleanups_<'a>(\n     let mut bcx = bcx;\n     for cu in cleanups.rev_iter() {\n         match *cu {\n-            clean(cfn, cleanup_type) | clean_temp(_, cfn, cleanup_type) => {\n+            Clean(cfn, cleanup_type) | CleanTemp(_, cfn, cleanup_type) => {\n                 // Some types don't need to be cleaned up during\n                 // landing pads because they can be freed en mass later\n                 if cleanup_type == normal_exit_and_unwind || !is_lpad {\n@@ -1639,7 +1643,7 @@ pub fn zero_mem(cx: &Block, llptr: ValueRef, t: ty::t) {\n // allocation for large data structures, and the generated code will be\n // awful. (A telltale sign of this is large quantities of\n // `mov [byte ptr foo],0` in the generated code.)\n-pub fn memzero(b: &Builder, llptr: ValueRef, ty: Type) {\n+fn memzero(b: &Builder, llptr: ValueRef, ty: Type) {\n     let _icx = push_ctxt(\"memzero\");\n     let ccx = b.ccx;\n \n@@ -1865,88 +1869,145 @@ pub fn new_fn_ctxt(ccx: @CrateContext,\n // spaces that have been created for them (by code in the llallocas field of\n // the function's fn_ctxt).  create_llargs_for_fn_args populates the llargs\n // field of the fn_ctxt with\n-pub fn create_llargs_for_fn_args(cx: &FunctionContext,\n-                                 self_arg: self_arg,\n-                                 args: &[ast::Arg])\n-                                 -> ~[ValueRef] {\n+fn create_llargs_for_fn_args(cx: &FunctionContext,\n+                             self_arg: Option<ty::t>,\n+                             arg_tys: &[ty::t])\n+                             -> ~[datum::Datum] {\n     let _icx = push_ctxt(\"create_llargs_for_fn_args\");\n \n     match self_arg {\n-      impl_self(tt, self_mode) => {\n-        cx.llself.set(Some(ValSelfData {\n-            v: cx.llenv.get(),\n-            t: tt,\n-            is_copy: self_mode == ty::ByCopy\n-        }));\n-      }\n-      no_self => ()\n+        Some(t) => {\n+            cx.llself.set(Some(datum::Datum {\n+                val: cx.llenv.get(),\n+                ty: t,\n+                mode: if arg_is_indirect(cx.ccx, t) {\n+                    datum::ByRef(datum::ZeroMem)\n+                } else {\n+                    datum::ByValue\n+                }\n+            }));\n+        }\n+        None => {}\n     }\n \n-    // Return an array containing the ValueRefs that we get from\n-    // llvm::LLVMGetParam for each argument.\n-    vec::from_fn(args.len(), |i| {\n-        unsafe { llvm::LLVMGetParam(cx.llfn, cx.arg_pos(i) as c_uint) }\n-    })\n+    // Return an array wrapping the ValueRefs that we get from\n+    // llvm::LLVMGetParam for each argument into datums.\n+    arg_tys.iter().enumerate().map(|(i, &arg_ty)| {\n+        let llarg = unsafe { llvm::LLVMGetParam(cx.llfn, cx.arg_pos(i) as c_uint) };\n+        datum::Datum {\n+            val: llarg,\n+            ty: arg_ty,\n+            mode: if arg_is_indirect(cx.ccx, arg_ty) {\n+                datum::ByRef(datum::ZeroMem)\n+            } else {\n+                datum::ByValue\n+            }\n+        }\n+    }).collect()\n }\n \n-pub fn copy_args_to_allocas<'a>(\n-                            fcx: &FunctionContext<'a>,\n+fn copy_args_to_allocas<'a>(fcx: &FunctionContext<'a>,\n                             bcx: &'a Block<'a>,\n                             args: &[ast::Arg],\n-                            raw_llargs: &[ValueRef],\n-                            arg_tys: &[ty::t])\n+                            method: Option<&ast::Method>,\n+                            raw_llargs: &[datum::Datum])\n                             -> &'a Block<'a> {\n-    debug!(\"copy_args_to_allocas: raw_llargs={} arg_tys={}\",\n-           raw_llargs.llrepr(fcx.ccx),\n-           arg_tys.repr(fcx.ccx.tcx));\n+    debug!(\"copy_args_to_allocas: args=[{}]\",\n+           raw_llargs.map(|d| d.to_str(fcx.ccx)).connect(\", \"));\n \n     let _icx = push_ctxt(\"copy_args_to_allocas\");\n     let mut bcx = bcx;\n \n     match fcx.llself.get() {\n         Some(slf) => {\n-            let self_val = if slf.is_copy\n-                    && datum::appropriate_mode(bcx.ccx(), slf.t).is_by_value() {\n-                let tmp = BitCast(bcx, slf.v, type_of(bcx.ccx(), slf.t));\n-                let alloc = alloc_ty(bcx, slf.t, \"__self\");\n-                Store(bcx, tmp, alloc);\n-                alloc\n+            let needs_indirection = if slf.mode.is_by_value() {\n+                // FIXME(eddyb) #11445 Always needs indirection because of cleanup.\n+                if true {\n+                    true\n+                } else {\n+                    match method {\n+                        Some(method) => {\n+                            match method.explicit_self.node {\n+                                ast::SelfValue(ast::MutMutable) => true,\n+                                _ => false\n+                            }\n+                        }\n+                        None => true\n+                    }\n+                }\n+            } else {\n+                false\n+            };\n+            let slf = if needs_indirection {\n+                // HACK(eddyb) this is just slf.to_ref_datum(bcx) with a named alloca.\n+                let alloc = alloc_ty(bcx, slf.ty, \"__self\");\n+                Store(bcx, slf.val, alloc);\n+                datum::Datum {\n+                    val: alloc,\n+                    ty: slf.ty,\n+                    mode: datum::ByRef(datum::ZeroMem)\n+                }\n             } else {\n-                PointerCast(bcx, slf.v, type_of(bcx.ccx(), slf.t).ptr_to())\n+                slf\n             };\n \n-            fcx.llself.set(Some(ValSelfData {v: self_val, ..slf}));\n-            add_clean(bcx, self_val, slf.t);\n+            fcx.llself.set(Some(slf));\n+            slf.add_clean(bcx);\n \n             if fcx.ccx.sess.opts.extra_debuginfo {\n-                debuginfo::create_self_argument_metadata(bcx, slf.t, self_val);\n+                debuginfo::create_self_argument_metadata(bcx, slf.ty, slf.val);\n             }\n         }\n         _ => {}\n     }\n \n-    for (arg_n, &arg_ty) in arg_tys.iter().enumerate() {\n-        let raw_llarg = raw_llargs[arg_n];\n-\n+    for (i, &arg) in raw_llargs.iter().enumerate() {\n+        let needs_indirection = if arg.mode.is_by_value() {\n+            if fcx.ccx.sess.opts.extra_debuginfo {\n+                true\n+            } else {\n+                // FIXME(eddyb) #11445 Always needs indirection because of cleanup.\n+                if true {\n+                    true\n+                } else {\n+                    match args[i].pat.node {\n+                        ast::PatIdent(ast::BindByValue(ast::MutMutable), _, _) => true,\n+                        _ => false\n+                    }\n+                }\n+            }\n+        } else {\n+            false\n+        };\n         // For certain mode/type combinations, the raw llarg values are passed\n         // by value.  However, within the fn body itself, we want to always\n         // have all locals and arguments be by-ref so that we can cancel the\n         // cleanup and for better interaction with LLVM's debug info.  So, if\n         // the argument would be passed by value, we store it into an alloca.\n         // This alloca should be optimized away by LLVM's mem-to-reg pass in\n         // the event it's not truly needed.\n-        // only by value if immediate:\n-        let llarg = if datum::appropriate_mode(bcx.ccx(), arg_ty).is_by_value() {\n-            let alloc = alloc_ty(bcx, arg_ty, \"__arg\");\n-            Store(bcx, raw_llarg, alloc);\n-            alloc\n+        let arg = if needs_indirection {\n+            // HACK(eddyb) this is just arg.to_ref_datum(bcx) with a named alloca.\n+            let alloc = match args[i].pat.node {\n+                ast::PatIdent(_, ref path, _) => {\n+                    let name = ast_util::path_to_ident(path).name;\n+                    alloc_ty(bcx, arg.ty, token::interner_get(name))\n+                }\n+                _ => alloc_ty(bcx, arg.ty, \"__arg\")\n+            };\n+            Store(bcx, arg.val, alloc);\n+            datum::Datum {\n+                val: alloc,\n+                ty: arg.ty,\n+                mode: datum::ByRef(datum::ZeroMem)\n+            }\n         } else {\n-            raw_llarg\n+            arg\n         };\n-        bcx = _match::store_arg(bcx, args[arg_n].pat, llarg);\n+        bcx = _match::store_arg(bcx, args[i].pat, arg);\n \n         if fcx.ccx.sess.opts.extra_debuginfo {\n-            debuginfo::create_argument_metadata(bcx, &args[arg_n]);\n+            debuginfo::create_argument_metadata(bcx, &args[i]);\n         }\n     }\n \n@@ -2001,8 +2062,6 @@ pub fn build_return_block(fcx: &FunctionContext, ret_cx: &Block) {\n     Ret(ret_cx, retval);\n }\n \n-pub enum self_arg { impl_self(ty::t, ty::SelfMode), no_self, }\n-\n // trans_closure: Builds an LLVM function out of a source function.\n // If the function closes over its environment a closure will be\n // returned.\n@@ -2011,9 +2070,10 @@ pub fn trans_closure(ccx: @CrateContext,\n                      decl: &ast::FnDecl,\n                      body: &ast::Block,\n                      llfndecl: ValueRef,\n-                     self_arg: self_arg,\n+                     self_arg: Option<ty::t>,\n                      param_substs: Option<@param_substs>,\n                      id: ast::NodeId,\n+                     method: Option<&ast::Method>,\n                      _attributes: &[ast::Attribute],\n                      output_type: ty::t,\n                      maybe_load_env: |&FunctionContext|) {\n@@ -2042,9 +2102,9 @@ pub fn trans_closure(ccx: @CrateContext,\n \n     // Set up arguments to the function.\n     let arg_tys = ty::ty_fn_args(node_id_type(bcx, id));\n-    let raw_llargs = create_llargs_for_fn_args(&fcx, self_arg, decl.inputs);\n+    let raw_llargs = create_llargs_for_fn_args(&fcx, self_arg, arg_tys);\n \n-    bcx = copy_args_to_allocas(&fcx, bcx, decl.inputs, raw_llargs, arg_tys);\n+    bcx = copy_args_to_allocas(&fcx, bcx, decl.inputs, method, raw_llargs);\n \n     maybe_load_env(&fcx);\n \n@@ -2089,9 +2149,10 @@ pub fn trans_fn(ccx: @CrateContext,\n                 decl: &ast::FnDecl,\n                 body: &ast::Block,\n                 llfndecl: ValueRef,\n-                self_arg: self_arg,\n+                self_arg: Option<ty::t>,\n                 param_substs: Option<@param_substs>,\n                 id: ast::NodeId,\n+                method: Option<&ast::Method>,\n                 attrs: &[ast::Attribute]) {\n \n     let the_path_str = path_str(ccx.sess, path);\n@@ -2109,6 +2170,7 @@ pub fn trans_fn(ccx: @CrateContext,\n                   self_arg,\n                   param_substs,\n                   id,\n+                  method,\n                   attrs,\n                   output_type,\n                   |_fcx| { });\n@@ -2191,14 +2253,13 @@ impl IdAndTy for ast::StructField {\n     fn ty(&self) -> ast::P<ast::Ty> { self.node.ty }\n }\n \n-pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n+fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n     ccx: @CrateContext,\n     ctor_id: ast::NodeId,\n     args: &[A],\n     disr: ty::Disr,\n     param_substs: Option<@param_substs>,\n-    llfndecl: ValueRef)\n-{\n+    llfndecl: ValueRef) {\n     // Translate variant arguments to function arguments.\n     let fn_args = args.map(|varg| {\n         ast::Arg {\n@@ -2247,12 +2308,12 @@ pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n \n     let arg_tys = ty::ty_fn_args(ctor_ty);\n \n-    let raw_llargs = create_llargs_for_fn_args(&fcx, no_self, fn_args);\n+    let raw_llargs = create_llargs_for_fn_args(&fcx, None, arg_tys);\n \n     let bcx = fcx.entry_bcx.get().unwrap();\n \n     insert_synthetic_type_entries(bcx, fn_args, arg_tys);\n-    let bcx = copy_args_to_allocas(&fcx, bcx, fn_args, raw_llargs, arg_tys);\n+    let bcx = copy_args_to_allocas(&fcx, bcx, fn_args, None, raw_llargs);\n \n     let repr = adt::represent_type(ccx, result_ty);\n     adt::trans_start_init(bcx, repr, fcx.llretptr.get().unwrap(), disr);\n@@ -2266,8 +2327,7 @@ pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n             let llargs = fcx.llargs.borrow();\n             llargs.get().get_copy(&fn_arg.pat.id)\n         };\n-        let arg_ty = arg_tys[i];\n-        memcpy_ty(bcx, lldestptr, llarg, arg_ty);\n+        llarg.move_to(bcx, datum::INIT, lldestptr);\n     }\n     finish_fn(&fcx, bcx);\n }\n@@ -2334,9 +2394,10 @@ pub fn trans_item(ccx: @CrateContext, item: &ast::Item) {\n                      decl,\n                      body,\n                      llfndecl,\n-                     no_self,\n+                     None,\n                      None,\n                      item.id,\n+                     None,\n                      item.attrs);\n         } else {\n             // Be sure to travel more than just one layer deep to catch nested\n@@ -2448,12 +2509,13 @@ fn finish_register_fn(ccx: @CrateContext, sp: Span, sym: ~str, node_id: ast::Nod\n     }\n }\n \n-pub fn register_fn(ccx: @CrateContext,\n-                   sp: Span,\n-                   sym: ~str,\n-                   node_id: ast::NodeId,\n-                   node_type: ty::t)\n-                   -> ValueRef {\n+fn register_fn(ccx: @CrateContext,\n+               sp: Span,\n+               sym: ~str,\n+               node_id: ast::NodeId,\n+               node_type: ty::t,\n+               self_ty: Option<ty::t>)\n+               -> ValueRef {\n     let f = match ty::get(node_type).sty {\n         ty::ty_bare_fn(ref f) => {\n             assert!(f.abis.is_rust() || f.abis.is_intrinsic());\n@@ -2462,7 +2524,7 @@ pub fn register_fn(ccx: @CrateContext,\n         _ => fail!(\"expected bare rust fn or an intrinsic\")\n     };\n \n-    let llfn = decl_rust_fn(ccx, f.sig.inputs, f.sig.output, sym);\n+    let llfn = decl_rust_fn(ccx, self_ty, f.sig.inputs, f.sig.output, sym);\n     finish_register_fn(ccx, sp, sym, node_id, llfn);\n     llfn\n }\n@@ -2722,7 +2784,7 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n \n                         ast::ItemFn(_, purity, _, _, _) => {\n                             let llfn = if purity != ast::ExternFn {\n-                                register_fn(ccx, i.span, sym, i.id, ty)\n+                                register_fn(ccx, i.span, sym, i.id, ty, None)\n                             } else {\n                                 foreign::register_rust_fn_with_foreign_abi(ccx,\n                                                                            i.span,\n@@ -2826,7 +2888,7 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n \n                             llfn = match enm.node {\n                                 ast::ItemEnum(_, _) => {\n-                                    register_fn(ccx, (*v).span, sym, id, ty)\n+                                    register_fn(ccx, (*v).span, sym, id, ty, None)\n                                 }\n                                 _ => fail!(\"NodeVariant, shouldn't happen\")\n                             };\n@@ -2851,7 +2913,7 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n                             let sym = exported_name(ccx, (*struct_path).clone(), ty,\n                                                     struct_item.attrs);\n                             let llfn = register_fn(ccx, struct_item.span,\n-                                                   sym, ctor_id, ty);\n+                                                   sym, ctor_id, ty, None);\n                             set_inline_hint(llfn);\n                             llfn\n                         }\n@@ -2881,18 +2943,22 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n     }\n }\n \n-pub fn register_method(ccx: @CrateContext,\n-                       id: ast::NodeId,\n-                       path: @ast_map::Path,\n-                       m: @ast::Method) -> ValueRef {\n+fn register_method(ccx: @CrateContext,\n+                   id: ast::NodeId,\n+                   path: @ast_map::Path,\n+                   m: &ast::Method) -> ValueRef {\n     let mty = ty::node_id_to_type(ccx.tcx, id);\n \n     let mut path = (*path).clone();\n     path.push(PathPrettyName(m.ident, token::gensym(\"meth\") as u64));\n \n     let sym = exported_name(ccx, path, mty, m.attrs);\n \n-    let llfn = register_fn(ccx, m.span, sym, id, mty);\n+    let self_ty = match m.explicit_self.node {\n+        ast::SelfStatic => None,\n+        _ => Some(ty::node_id_to_type(ccx.tcx, m.self_id))\n+    };\n+    let llfn = register_fn(ccx, m.span, sym, id, mty, self_ty);\n     set_llvm_fn_attrs(m.attrs, llfn);\n     llfn\n }\n@@ -3120,12 +3186,12 @@ pub fn create_module_map(ccx: &CrateContext) -> (ValueRef, uint) {\n     };\n \n     for key in keys.iter() {\n-            let llestrval = C_estr_slice(ccx, *key);\n+            let llstrval = C_str_slice(ccx, *key);\n             let module_data = ccx.module_data.borrow();\n             let val = *module_data.get().find_equiv(key).unwrap();\n             let v_ptr = p2i(ccx, val);\n             let elt = C_struct([\n-                llestrval,\n+                llstrval,\n                 v_ptr\n             ], false);\n             elts.push(elt);"}, {"sha": "c1451a8fe1e1218f98a51e921a996584c8554c34", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 8, "deletions": 23, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -60,8 +60,7 @@ pub struct FnData {\n pub struct MethodData {\n     llfn: ValueRef,\n     llself: ValueRef,\n-    temp_cleanup: Option<ValueRef>,\n-    self_mode: ty::SelfMode,\n+    temp_cleanup: Option<ValueRef>\n }\n \n pub enum CalleeData {\n@@ -398,7 +397,7 @@ pub fn trans_fn_ref_with_vtables(\n             let ref_ty = common::node_id_type(bcx, ref_id);\n \n             val = PointerCast(\n-                bcx, val, type_of::type_of_fn_from_ty(ccx, ref_ty).ptr_to());\n+                bcx, val, type_of::type_of_fn_from_ty(ccx, None, ref_ty).ptr_to());\n         }\n         return FnData {llfn: val};\n     }\n@@ -437,7 +436,7 @@ pub fn trans_fn_ref_with_vtables(\n     // This can occur on either a crate-local or crate-external\n     // reference. It also occurs when testing libcore and in some\n     // other weird situations. Annoying.\n-    let llty = type_of::type_of_fn_from_ty(ccx, fn_tpt.ty);\n+    let llty = type_of::type_of_fn_from_ty(ccx, None, fn_tpt.ty);\n     let llptrty = llty.ptr_to();\n     if val_ty(val) != llptrty {\n         val = BitCast(bcx, val, llptrty);\n@@ -496,10 +495,7 @@ pub fn trans_method_call<'a>(\n                            call_ex.repr(in_cx.tcx()),\n                            origin.repr(in_cx.tcx()));\n \n-                    meth::trans_method_callee(cx,\n-                                              callee_id,\n-                                              rcvr,\n-                                              origin)\n+                    meth::trans_method_callee(cx, callee_id, rcvr, origin)\n                 }\n                 None => {\n                     cx.tcx().sess.span_bug(call_ex.span, \"method call expr wasn't in method map\")\n@@ -704,7 +700,7 @@ pub fn trans_call_inner<'a>(\n             match ty::get(ret_ty).sty {\n                 // `~` pointer return values never alias because ownership is transferred\n                 ty::ty_uniq(..) |\n-                ty::ty_evec(_, ty::vstore_uniq) => {\n+                ty::ty_vec(_, ty::vstore_uniq) => {\n                     attrs.push((0, NoAliasAttribute));\n                 }\n                 _ => ()\n@@ -799,7 +795,6 @@ pub fn trans_args<'a>(\n             let arg_val = unpack_result!(bcx, {\n                 trans_arg_expr(bcx,\n                                arg_ty,\n-                               ty::ByCopy,\n                                *arg_expr,\n                                &mut temp_cleanups,\n                                autoref_arg)\n@@ -832,17 +827,15 @@ pub enum AutorefArg {\n pub fn trans_arg_expr<'a>(\n                       bcx: &'a Block<'a>,\n                       formal_arg_ty: ty::t,\n-                      self_mode: ty::SelfMode,\n                       arg_expr: &ast::Expr,\n                       temp_cleanups: &mut ~[ValueRef],\n                       autoref_arg: AutorefArg)\n                       -> Result<'a> {\n     let _icx = push_ctxt(\"trans_arg_expr\");\n     let ccx = bcx.ccx();\n \n-    debug!(\"trans_arg_expr(formal_arg_ty=({}), self_mode={:?}, arg_expr={})\",\n+    debug!(\"trans_arg_expr(formal_arg_ty=({}), arg_expr={})\",\n            formal_arg_ty.repr(bcx.tcx()),\n-           self_mode,\n            arg_expr.repr(bcx.tcx()));\n \n     // translate the arg expr to a datum\n@@ -888,16 +881,8 @@ pub fn trans_arg_expr<'a>(\n                     arg_datum\n                 };\n \n-                val = match self_mode {\n-                    ty::ByRef => {\n-                        debug!(\"by ref arg with type {}\", bcx.ty_to_str(arg_datum.ty));\n-                        arg_datum.to_ref_llval(bcx)\n-                    }\n-                    ty::ByCopy => {\n-                        debug!(\"by copy arg with type {}\", bcx.ty_to_str(arg_datum.ty));\n-                        arg_datum.to_appropriate_llval(bcx)\n-                    }\n-                }\n+                debug!(\"by copy arg with type {}\", bcx.ty_to_str(arg_datum.ty));\n+                val = arg_datum.to_appropriate_llval(bcx);\n             }\n         }\n "}, {"sha": "25bc968b987dc6146a4294e2a3b0ddc8c7e61089", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -405,7 +405,7 @@ pub fn trans_expr_fn<'a>(\n     let s = mangle_internal_name_by_path_and_seq(ccx,\n                                                  sub_path.clone(),\n                                                  \"expr_fn\");\n-    let llfn = decl_internal_rust_fn(ccx, f.sig.inputs, f.sig.output, s);\n+    let llfn = decl_internal_rust_fn(ccx, None, f.sig.inputs, f.sig.output, s);\n \n     // set an inline hint for all closures\n     set_inline_hint(llfn);\n@@ -423,9 +423,10 @@ pub fn trans_expr_fn<'a>(\n                           decl,\n                           body,\n                           llfn,\n-                          no_self,\n+                          None,\n                           bcx.fcx.param_substs,\n                           user_id,\n+                          None,\n                           [],\n                           ty::ty_fn_ret(fty),\n                           |fcx| load_environment(fcx, cdata_ty, cap_vars, sigil));\n@@ -474,7 +475,7 @@ pub fn make_opaque_cbox_drop_glue<'a>(\n             bcx.tcx().sess.bug(\"trying to trans drop glue of @fn\")\n         }\n         ast::OwnedSigil => {\n-            glue::free_ty(\n+            glue::make_free_glue(\n                 bcx, cboxptr,\n                 ty::mk_opaque_closure_ptr(bcx.tcx(), sigil))\n         }"}, {"sha": "7f6ab2dd9d154a6bb808fcdaeffba30b72112bd9", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 62, "deletions": 75, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -94,7 +94,6 @@ pub struct tydesc_info {\n     name: ValueRef,\n     take_glue: Cell<Option<ValueRef>>,\n     drop_glue: Cell<Option<ValueRef>>,\n-    free_glue: Cell<Option<ValueRef>>,\n     visit_glue: Cell<Option<ValueRef>>,\n }\n \n@@ -159,13 +158,6 @@ pub fn BuilderRef_res(B: BuilderRef) -> BuilderRef_res {\n \n pub type ExternMap = HashMap<~str, ValueRef>;\n \n-// Types used for llself.\n-pub struct ValSelfData {\n-    v: ValueRef,\n-    t: ty::t,\n-    is_copy: bool,\n-}\n-\n // Here `self_ty` is the real type of the self parameter to this method. It\n // will only be set in the case of default methods.\n pub struct param_substs {\n@@ -228,7 +220,7 @@ pub struct FunctionContext<'a> {\n     // NB: This is the type of the self *variable*, not the self *type*. The\n     // self type is set only for default methods, while the self variable is\n     // set for all methods.\n-    llself: Cell<Option<ValSelfData>>,\n+    llself: Cell<Option<datum::Datum>>,\n     // The a value alloca'd for calls to upcalls.rust_personality. Used when\n     // outputting the resume instruction.\n     personality: Cell<Option<ValueRef>>,\n@@ -239,10 +231,10 @@ pub struct FunctionContext<'a> {\n     caller_expects_out_pointer: bool,\n \n     // Maps arguments to allocas created for them in llallocas.\n-    llargs: RefCell<HashMap<ast::NodeId, ValueRef>>,\n+    llargs: RefCell<HashMap<ast::NodeId, datum::Datum>>,\n     // Maps the def_ids for local variables to the allocas created for\n     // them in llallocas.\n-    lllocals: RefCell<HashMap<ast::NodeId, ValueRef>>,\n+    lllocals: RefCell<HashMap<ast::NodeId, datum::Datum>>,\n     // Same as above, but for closure upvars\n     llupvars: RefCell<HashMap<ast::NodeId, ValueRef>>,\n \n@@ -343,28 +335,14 @@ pub trait CleanupFunction {\n }\n \n /// A cleanup function that calls the \"drop glue\" (destructor function) on\n-/// a typed value.\n-pub struct TypeDroppingCleanupFunction {\n-    val: ValueRef,\n-    t: ty::t,\n-}\n-\n-impl CleanupFunction for TypeDroppingCleanupFunction {\n-    fn clean<'a>(&self, block: &'a Block<'a>) -> &'a Block<'a> {\n-        glue::drop_ty(block, self.val, self.t)\n-    }\n-}\n-\n-/// A cleanup function that calls the \"drop glue\" (destructor function) on\n-/// an immediate typed value.\n-pub struct ImmediateTypeDroppingCleanupFunction {\n-    val: ValueRef,\n-    t: ty::t,\n+/// a datum.\n+struct DatumDroppingCleanupFunction {\n+    datum: datum::Datum\n }\n \n-impl CleanupFunction for ImmediateTypeDroppingCleanupFunction {\n+impl CleanupFunction for DatumDroppingCleanupFunction {\n     fn clean<'a>(&self, block: &'a Block<'a>) -> &'a Block<'a> {\n-        glue::drop_ty_immediate(block, self.val, self.t)\n+        self.datum.drop_val(block)\n     }\n }\n \n@@ -391,16 +369,16 @@ impl CleanupFunction for ExchangeHeapFreeingCleanupFunction {\n }\n \n pub enum cleanup {\n-    clean(@CleanupFunction, cleantype),\n-    clean_temp(ValueRef, @CleanupFunction, cleantype),\n+    Clean(@CleanupFunction, cleantype),\n+    CleanTemp(ValueRef, @CleanupFunction, cleantype),\n }\n \n // Can't use deriving(Clone) because of the managed closure.\n impl Clone for cleanup {\n     fn clone(&self) -> cleanup {\n         match *self {\n-            clean(f, ct) => clean(f, ct),\n-            clean_temp(v, f, ct) => clean_temp(v, f, ct),\n+            Clean(f, ct) => Clean(f, ct),\n+            CleanTemp(v, f, ct) => CleanTemp(v, f, ct),\n         }\n     }\n }\n@@ -439,42 +417,46 @@ pub fn cleanup_type(cx: ty::ctxt, ty: ty::t) -> cleantype {\n     }\n }\n \n-pub fn add_clean(bcx: &Block, val: ValueRef, t: ty::t) {\n-    if !ty::type_needs_drop(bcx.tcx(), t) {\n-        return\n-    }\n+pub fn add_clean(bcx: &Block, val: ValueRef, ty: ty::t) {\n+    if !ty::type_needs_drop(bcx.tcx(), ty) { return; }\n \n-    debug!(\"add_clean({}, {}, {})\", bcx.to_str(), bcx.val_to_str(val), t.repr(bcx.tcx()));\n+    debug!(\"add_clean({}, {}, {})\", bcx.to_str(), bcx.val_to_str(val), ty.repr(bcx.tcx()));\n \n-    let cleanup_type = cleanup_type(bcx.tcx(), t);\n+    let cleanup_type = cleanup_type(bcx.tcx(), ty);\n     in_scope_cx(bcx, None, |scope_info| {\n         {\n             let mut cleanups = scope_info.cleanups.borrow_mut();\n-            cleanups.get().push(clean(@TypeDroppingCleanupFunction {\n-                val: val,\n-                t: t,\n+            cleanups.get().push(Clean(@DatumDroppingCleanupFunction {\n+                datum: datum::Datum {\n+                    val: val,\n+                    ty: ty,\n+                    mode: datum::ByRef(datum::ZeroMem)\n+                }\n             } as @CleanupFunction,\n             cleanup_type));\n         }\n         grow_scope_clean(scope_info);\n     })\n }\n \n-pub fn add_clean_temp_immediate(cx: &Block, val: ValueRef, ty: ty::t) {\n-    if !ty::type_needs_drop(cx.tcx(), ty) { return; }\n+pub fn add_clean_temp_immediate(bcx: &Block, val: ValueRef, ty: ty::t) {\n+    if !ty::type_needs_drop(bcx.tcx(), ty) { return; }\n+\n     debug!(\"add_clean_temp_immediate({}, {}, {})\",\n-           cx.to_str(), cx.val_to_str(val),\n-           ty.repr(cx.tcx()));\n-    let cleanup_type = cleanup_type(cx.tcx(), ty);\n-    in_scope_cx(cx, None, |scope_info| {\n+           bcx.to_str(), bcx.val_to_str(val),\n+           ty.repr(bcx.tcx()));\n+    let cleanup_type = cleanup_type(bcx.tcx(), ty);\n+    in_scope_cx(bcx, None, |scope_info| {\n         {\n             let mut cleanups = scope_info.cleanups.borrow_mut();\n-            cleanups.get().push(clean_temp(val,\n-                @ImmediateTypeDroppingCleanupFunction {\n+            cleanups.get().push(CleanTemp(val, @DatumDroppingCleanupFunction {\n+                datum: datum::Datum {\n                     val: val,\n-                    t: ty,\n-                } as @CleanupFunction,\n-                cleanup_type));\n+                    ty: ty,\n+                    mode: datum::ByValue\n+                }\n+            } as @CleanupFunction,\n+            cleanup_type));\n         }\n         grow_scope_clean(scope_info);\n     })\n@@ -501,12 +483,14 @@ pub fn add_clean_temp_mem_in_scope_(bcx: &Block, scope_id: Option<ast::NodeId>,\n     in_scope_cx(bcx, scope_id, |scope_info| {\n         {\n             let mut cleanups = scope_info.cleanups.borrow_mut();\n-            cleanups.get().push(clean_temp(val,\n-                @TypeDroppingCleanupFunction {\n+            cleanups.get().push(CleanTemp(val, @DatumDroppingCleanupFunction {\n+                datum: datum::Datum {\n                     val: val,\n-                    t: t,\n-                } as @CleanupFunction,\n-                cleanup_type));\n+                    ty: t,\n+                    mode: datum::ByRef(datum::RevokeClean)\n+                }\n+            } as @CleanupFunction,\n+            cleanup_type));\n         }\n         grow_scope_clean(scope_info);\n     })\n@@ -528,7 +512,7 @@ pub fn add_clean_free(cx: &Block, ptr: ValueRef, heap: heap) {\n     in_scope_cx(cx, None, |scope_info| {\n         {\n             let mut cleanups = scope_info.cleanups.borrow_mut();\n-            cleanups.get().push(clean_temp(ptr,\n+            cleanups.get().push(CleanTemp(ptr,\n                                            free_fn,\n                                            normal_exit_and_unwind));\n         }\n@@ -544,22 +528,26 @@ pub fn revoke_clean(cx: &Block, val: ValueRef) {\n     in_scope_cx(cx, None, |scope_info| {\n         let cleanup_pos = {\n             let mut cleanups = scope_info.cleanups.borrow_mut();\n+            debug!(\"revoke_clean({}, {}) revoking {:?} from {:?}\",\n+                   cx.to_str(), cx.val_to_str(val), val, cleanups.get());\n             cleanups.get().iter().position(|cu| {\n                 match *cu {\n-                    clean_temp(v, _, _) if v == val => true,\n+                    CleanTemp(v, _, _) if v == val => true,\n                     _ => false\n                 }\n             })\n         };\n-        for i in cleanup_pos.iter() {\n+        debug!(\"revoke_clean({}, {}) revoking {:?}\",\n+               cx.to_str(), cx.val_to_str(val), cleanup_pos);\n+        for &i in cleanup_pos.iter() {\n             let new_cleanups = {\n                 let cleanups = scope_info.cleanups.borrow();\n-                vec::append(cleanups.get().slice(0u, *i).to_owned(),\n-                            cleanups.get().slice(*i + 1u, cleanups.get()\n-                                                                  .len()))\n+                vec::append(cleanups.get().slice(0u, i).to_owned(),\n+                            cleanups.get().slice(i + 1u, cleanups.get()\n+                                                                 .len()))\n             };\n             scope_info.cleanups.set(new_cleanups);\n-            shrink_scope_clean(scope_info, *i);\n+            shrink_scope_clean(scope_info, i);\n         }\n     })\n }\n@@ -768,16 +756,16 @@ pub fn in_scope_cx<'a>(\n             Some(inf) => match scope_id {\n                 Some(wanted) => match inf.node_info {\n                     Some(NodeInfo { id: actual, .. }) if wanted == actual => {\n-                        debug!(\"in_scope_cx: selected cur={} (cx={})\",\n-                               cur.to_str(), cx.to_str());\n+                        debug!(\"in_scope_cx: selected cur={} (cx={}) info={:?}\",\n+                               cur.to_str(), cx.to_str(), inf.node_info);\n                         f(inf);\n                         return;\n                     },\n                     _ => inf.parent,\n                 },\n                 None => {\n-                    debug!(\"in_scope_cx: selected cur={} (cx={})\",\n-                           cur.to_str(), cx.to_str());\n+                    debug!(\"in_scope_cx: selected cur={} (cx={}) info={:?}\",\n+                           cur.to_str(), cx.to_str(), inf.node_info);\n                     f(inf);\n                     return;\n                 }\n@@ -906,7 +894,7 @@ pub fn C_cstr(cx: &CrateContext, s: @str) -> ValueRef {\n \n // NB: Do not use `do_spill_noroot` to make this into a constant string, or\n // you will be kicked off fast isel. See issue #4352 for an example of this.\n-pub fn C_estr_slice(cx: &CrateContext, s: @str) -> ValueRef {\n+pub fn C_str_slice(cx: &CrateContext, s: @str) -> ValueRef {\n     unsafe {\n         let len = s.len();\n         let cs = llvm::LLVMConstPointerCast(C_cstr(cx, s), Type::i8p().to_ref());\n@@ -1043,10 +1031,9 @@ pub enum MonoDataClass {\n pub fn mono_data_classify(t: ty::t) -> MonoDataClass {\n     match ty::get(t).sty {\n         ty::ty_float(_) => MonoFloat,\n-        ty::ty_rptr(..) | ty::ty_uniq(..) |\n-        ty::ty_box(..) | ty::ty_opaque_box(..) |\n-        ty::ty_estr(ty::vstore_uniq) | ty::ty_evec(_, ty::vstore_uniq) |\n-        ty::ty_estr(ty::vstore_box) | ty::ty_evec(_, ty::vstore_box) |\n+        ty::ty_rptr(..) | ty::ty_uniq(..) | ty::ty_box(..) |\n+        ty::ty_str(ty::vstore_uniq) | ty::ty_vec(_, ty::vstore_uniq) |\n+        ty::ty_str(ty::vstore_box) | ty::ty_vec(_, ty::vstore_box) |\n         ty::ty_bare_fn(..) => MonoNonNull,\n         // Is that everything?  Would closures or slices qualify?\n         _ => MonoBits"}, {"sha": "1f8ac5b5aeb6d5bcfb09c0e0ed0ae413b7ba1427", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -71,7 +71,7 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: ast::Lit)\n         }\n         ast::LitBool(b) => C_bool(b),\n         ast::LitNil => C_nil(),\n-        ast::LitStr(s, _) => C_estr_slice(cx, s),\n+        ast::LitStr(s, _) => C_str_slice(cx, s),\n         ast::LitBinary(data) => C_binary_slice(cx, data),\n     }\n }\n@@ -241,7 +241,7 @@ pub fn const_expr(cx: @CrateContext, e: &ast::Expr) -> (ValueRef, bool) {\n                             assert_eq!(abi::slice_elt_len, 1);\n \n                             match ty::get(ty).sty {\n-                                ty::ty_evec(_, ty::vstore_fixed(len)) => {\n+                                ty::ty_vec(_, ty::vstore_fixed(len)) => {\n                                     llconst = C_struct([llptr, C_uint(cx, len)], false);\n                                 }\n                                 _ => {}\n@@ -419,7 +419,7 @@ fn const_expr_unadjusted(cx: @CrateContext,\n                                         \"index is not an integer-constant expression\")\n               };\n               let (arr, len) = match ty::get(bt).sty {\n-                  ty::ty_evec(_, vstore) | ty::ty_estr(vstore) =>\n+                  ty::ty_vec(_, vstore) | ty::ty_str(vstore) =>\n                       match vstore {\n                       ty::vstore_fixed(u) =>\n                           (bv, C_uint(cx, u)),\n@@ -437,7 +437,7 @@ fn const_expr_unadjusted(cx: @CrateContext,\n \n               let len = llvm::LLVMConstIntGetZExtValue(len) as u64;\n               let len = match ty::get(bt).sty {\n-                  ty::ty_estr(..) => {assert!(len > 0); len - 1},\n+                  ty::ty_str(..) => {assert!(len > 0); len - 1},\n                   _ => len\n               };\n               if iv >= len {"}, {"sha": "e7eab31ac14e7f02f4579aac7d0a3aac8adcc208", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -113,6 +113,7 @@ pub enum CopyAction {\n     DROP_EXISTING\n }\n \n+#[deriving(Clone)]\n pub struct Datum {\n     /// The llvm value.  This is either a pointer to the Rust value or\n     /// the value itself, depending on `mode` below.\n@@ -130,7 +131,7 @@ pub struct DatumBlock<'a> {\n     datum: Datum,\n }\n \n-#[deriving(Eq, IterBytes)]\n+#[deriving(Clone, Eq, IterBytes)]\n pub enum DatumMode {\n     /// `val` is a pointer to the actual value (and thus has type *T).\n     /// The argument indicates how to cancel cleanup of this datum if\n@@ -153,7 +154,7 @@ impl DatumMode {\n }\n \n /// See `Datum cleanup styles` section at the head of this module.\n-#[deriving(Eq, IterBytes)]\n+#[deriving(Clone, Eq, IterBytes)]\n pub enum DatumCleanup {\n     RevokeClean,\n     ZeroMem\n@@ -396,8 +397,7 @@ impl Datum {\n                 add_clean_temp_mem(bcx, self.val, self.ty);\n             }\n             ByRef(ZeroMem) => {\n-                bcx.tcx().sess.bug(\n-                    format!(\"Cannot add clean to a 'zero-mem' datum\"));\n+                add_clean(bcx, self.val, self.ty)\n             }\n         }\n     }\n@@ -413,7 +413,6 @@ impl Datum {\n                     // Lvalues which potentially need to be dropped\n                     // must be passed by ref, so that we can zero them\n                     // out.\n-                    assert!(self.mode.is_by_ref());\n                     zero_mem(bcx, self.val, self.ty);\n                 }\n             }\n@@ -571,7 +570,7 @@ impl Datum {\n         let (content_ty, header) = match ty::get(self.ty).sty {\n             ty::ty_box(typ) => (typ, true),\n             ty::ty_uniq(mt) => (mt.ty, false),\n-            ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq) => {\n+            ty::ty_vec(_, ty::vstore_uniq) | ty::ty_str(ty::vstore_uniq) => {\n                 let unit_ty = ty::sequence_element_type(bcx.tcx(), self.ty);\n                 let unboxed_vec_ty = ty::mk_mut_unboxed_vec(bcx.tcx(), unit_ty);\n                 (unboxed_vec_ty, true)"}, {"sha": "fa620cca35eaf26f9e71088719ecedbad4d5e0bb", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 15, "deletions": 33, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -133,6 +133,7 @@ use middle::trans::adt;\n use middle::trans::base;\n use middle::trans::build;\n use middle::trans::common::*;\n+use middle::trans::datum;\n use middle::trans::machine;\n use middle::trans::type_of;\n use middle::trans::type_::Type;\n@@ -280,12 +281,11 @@ pub fn create_local_var_metadata(bcx: &Block, local: &ast::Local) {\n \n     pat_util::pat_bindings(def_map, local.pat, |_, node_id, span, path_ref| {\n         let var_ident = ast_util::path_to_ident(path_ref);\n-        let var_type = node_id_type(bcx, node_id);\n \n-        let llptr = {\n+        let datum = {\n             let lllocals = bcx.fcx.lllocals.borrow();\n             match lllocals.get().find_copy(&node_id) {\n-                Some(v) => v,\n+                Some(datum) => datum,\n                 None => {\n                     bcx.tcx().sess.span_bug(span,\n                         format!(\"No entry in lllocals table for {:?}\",\n@@ -298,9 +298,9 @@ pub fn create_local_var_metadata(bcx: &Block, local: &ast::Local) {\n \n         declare_local(bcx,\n                       var_ident,\n-                      var_type,\n+                      datum.ty,\n                       scope_metadata,\n-                      DirectVariable { alloca: llptr },\n+                      DirectVariable { alloca: datum.val },\n                       LocalVariable,\n                       span);\n     })\n@@ -382,33 +382,19 @@ pub fn create_captured_var_metadata(bcx: &Block,\n pub fn create_match_binding_metadata(bcx: &Block,\n                                      variable_ident: ast::Ident,\n                                      node_id: ast::NodeId,\n-                                     variable_type: ty::t,\n-                                     span: Span) {\n+                                     span: Span,\n+                                     datum: datum::Datum) {\n     if fn_should_be_ignored(bcx.fcx) {\n         return;\n     }\n \n-    let llptr = {\n-        let lllocals = bcx.fcx.lllocals.borrow();\n-        match lllocals.get().find_copy(&node_id) {\n-            Some(v) => v,\n-            None => {\n-                bcx.tcx()\n-                   .sess\n-                   .span_bug(span,\n-                             format!(\"No entry in lllocals table for {:?}\",\n-                                     node_id));\n-            }\n-        }\n-    };\n-\n     let scope_metadata = scope_metadata(bcx.fcx, node_id, span);\n \n     declare_local(bcx,\n                   variable_ident,\n-                  variable_type,\n+                  datum.ty,\n                   scope_metadata,\n-                  DirectVariable { alloca: llptr },\n+                  DirectVariable { alloca: datum.val },\n                   LocalVariable,\n                   span);\n }\n@@ -506,7 +492,7 @@ pub fn create_argument_metadata(bcx: &Block, arg: &ast::Arg) {\n     let scope_metadata = bcx.fcx.debug_context.get_ref(cx, arg.pat.span).fn_metadata;\n \n     pat_util::pat_bindings(def_map, arg.pat, |_, node_id, span, path_ref| {\n-        let llptr = {\n+        let llarg = {\n             let llargs = bcx.fcx.llargs.borrow();\n             match llargs.get().find_copy(&node_id) {\n                 Some(v) => v,\n@@ -518,12 +504,11 @@ pub fn create_argument_metadata(bcx: &Block, arg: &ast::Arg) {\n             }\n         };\n \n-        if unsafe { llvm::LLVMIsAAllocaInst(llptr) } == ptr::null() {\n+        if unsafe { llvm::LLVMIsAAllocaInst(llarg.val) } == ptr::null() {\n             cx.sess.span_bug(span, \"debuginfo::create_argument_metadata() - \\\n                                     Referenced variable location is not an alloca!\");\n         }\n \n-        let argument_type = node_id_type(bcx, node_id);\n         let argument_ident = ast_util::path_to_ident(path_ref);\n \n         let argument_index = {\n@@ -535,9 +520,9 @@ pub fn create_argument_metadata(bcx: &Block, arg: &ast::Arg) {\n \n         declare_local(bcx,\n                       argument_ident,\n-                      argument_type,\n+                      llarg.ty,\n                       scope_metadata,\n-                      DirectVariable { alloca: llptr },\n+                      DirectVariable { alloca: llarg.val },\n                       ArgumentVariable(argument_index),\n                       span);\n     })\n@@ -2115,7 +2100,7 @@ fn type_metadata(cx: &CrateContext,\n         ty::ty_float(_) => {\n             basic_type_metadata(cx, t)\n         },\n-        ty::ty_estr(ref vstore) => {\n+        ty::ty_str(ref vstore) => {\n             let i8_t = ty::mk_i8();\n             match *vstore {\n                 ty::vstore_fixed(len) => {\n@@ -2140,7 +2125,7 @@ fn type_metadata(cx: &CrateContext,\n         ty::ty_box(typ) => {\n             create_pointer_to_box_metadata(cx, t, typ)\n         },\n-        ty::ty_evec(ref mt, ref vstore) => {\n+        ty::ty_vec(ref mt, ref vstore) => {\n             match *vstore {\n                 ty::vstore_fixed(len) => {\n                     fixed_vec_metadata(cx, mt.ty, len, usage_site_span)\n@@ -2185,9 +2170,6 @@ fn type_metadata(cx: &CrateContext,\n         },\n         ty::ty_tup(ref elements) => {\n             prepare_tuple_metadata(cx, t, *elements, usage_site_span).finalize(cx)\n-        },\n-        ty::ty_opaque_box => {\n-            create_pointer_to_box_metadata(cx, t, ty::mk_nil())\n         }\n         _ => cx.sess.bug(format!(\"debuginfo: unexpected type in type_metadata: {:?}\", sty))\n     };"}, {"sha": "1641e4a8bde92bbe9cea34c7e260d49f91c80447", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 13, "deletions": 23, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -287,9 +287,9 @@ pub fn trans_to_datum<'a>(bcx: &'a Block<'a>, expr: &ast::Expr)\n \n         // this type may have a different region/mutability than the\n         // real one, but it will have the same runtime representation\n-        let slice_ty = ty::mk_evec(tcx,\n-                                   ty::mt { ty: unit_ty, mutbl: ast::MutImmutable },\n-                                   ty::vstore_slice(ty::ReStatic));\n+        let slice_ty = ty::mk_vec(tcx,\n+                                  ty::mt { ty: unit_ty, mutbl: ast::MutImmutable },\n+                                  ty::vstore_slice(ty::ReStatic));\n \n         let scratch = scratch_datum(bcx, slice_ty, \"__adjust\", false);\n \n@@ -1172,7 +1172,7 @@ pub fn trans_local_var(bcx: &Block, def: ast::Def) -> Datum {\n             take_local(bcx, lllocals.get(), nid)\n         }\n         ast::DefSelf(nid, _) => {\n-            let self_info: ValSelfData = match bcx.fcx.llself.get() {\n+            let self_info = match bcx.fcx.llself.get() {\n                 Some(self_info) => self_info,\n                 None => {\n                     bcx.sess().bug(format!(\n@@ -1181,14 +1181,10 @@ pub fn trans_local_var(bcx: &Block, def: ast::Def) -> Datum {\n                 }\n             };\n \n-            debug!(\"def_self() reference, self_info.t={}\",\n-                   self_info.t.repr(bcx.tcx()));\n+            debug!(\"def_self() reference, self_info.ty={}\",\n+                   self_info.ty.repr(bcx.tcx()));\n \n-            Datum {\n-                val: self_info.v,\n-                ty: self_info.t,\n-                mode: ByRef(ZeroMem)\n-            }\n+            self_info\n         }\n         _ => {\n             bcx.sess().unimpl(format!(\n@@ -1197,24 +1193,18 @@ pub fn trans_local_var(bcx: &Block, def: ast::Def) -> Datum {\n     };\n \n     fn take_local(bcx: &Block,\n-                  table: &HashMap<ast::NodeId, ValueRef>,\n-                  nid: ast::NodeId)\n-                  -> Datum {\n-        let v = match table.find(&nid) {\n+                  table: &HashMap<ast::NodeId, Datum>,\n+                  nid: ast::NodeId) -> Datum {\n+        let datum = match table.find(&nid) {\n             Some(&v) => v,\n             None => {\n                 bcx.sess().bug(format!(\n-                    \"trans_local_var: no llval for local/arg {:?} found\", nid));\n+                    \"trans_local_var: no datum for local/arg {:?} found\", nid));\n             }\n         };\n-        let ty = node_id_type(bcx, nid);\n         debug!(\"take_local(nid={:?}, v={}, ty={})\",\n-               nid, bcx.val_to_str(v), bcx.ty_to_str(ty));\n-        Datum {\n-            val: v,\n-            ty: ty,\n-            mode: ByRef(ZeroMem)\n-        }\n+               nid, bcx.val_to_str(datum.val), bcx.ty_to_str(datum.ty));\n+        datum\n     }\n }\n "}, {"sha": "304edb2c31243b1beae71beb0be154ca8930df12", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -489,16 +489,17 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @CrateContext,\n                id,\n                t.repr(tcx));\n \n-        let llfndecl = base::decl_internal_rust_fn(ccx, f.sig.inputs, f.sig.output, ps);\n+        let llfndecl = base::decl_internal_rust_fn(ccx, None, f.sig.inputs, f.sig.output, ps);\n         base::set_llvm_fn_attrs(attrs, llfndecl);\n         base::trans_fn(ccx,\n                        (*path).clone(),\n                        decl,\n                        body,\n                        llfndecl,\n-                       base::no_self,\n+                       None,\n                        None,\n                        id,\n+                       None,\n                        []);\n         return llfndecl;\n     }"}, {"sha": "16a761a44db31f05055480aac6a3809c7d8402bd", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 96, "deletions": 212, "changes": 308, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -23,13 +23,13 @@ use middle::trans::base::*;\n use middle::trans::callee;\n use middle::trans::closure;\n use middle::trans::common::*;\n+use middle::trans::datum::immediate_rvalue;\n use middle::trans::build::*;\n use middle::trans::expr;\n use middle::trans::machine::*;\n use middle::trans::reflect;\n use middle::trans::tvec;\n use middle::trans::type_of::type_of;\n-use middle::trans::uniq;\n use middle::ty;\n use util::ppaux;\n use util::ppaux::ty_to_short_str;\n@@ -86,139 +86,74 @@ pub fn drop_ty_immediate<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n     drop_ty(bcx, vp, t)\n }\n \n-pub fn free_ty<'a>(cx: &'a Block<'a>, v: ValueRef, t: ty::t)\n-               -> &'a Block<'a> {\n-    // NB: v is an *alias* of type t here, not a direct value.\n-    let _icx = push_ctxt(\"free_ty\");\n-    if ty::type_needs_drop(cx.tcx(), t) {\n-        return call_tydesc_glue(cx, v, t, abi::tydesc_field_free_glue);\n-    }\n-    return cx;\n-}\n-\n-pub fn free_ty_immediate<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n-                         -> &'a Block<'a> {\n-    let _icx = push_ctxt(\"free_ty_immediate\");\n-    match ty::get(t).sty {\n-      ty::ty_uniq(_) |\n-      ty::ty_evec(_, ty::vstore_uniq) |\n-      ty::ty_estr(ty::vstore_uniq) |\n-      ty::ty_box(_) | ty::ty_opaque_box |\n-      ty::ty_evec(_, ty::vstore_box) |\n-      ty::ty_estr(ty::vstore_box) |\n-      ty::ty_opaque_closure_ptr(_) => {\n-        let vp = alloca(bcx, type_of(bcx.ccx(), t), \"\");\n-        Store(bcx, v, vp);\n-        free_ty(bcx, vp, t)\n-      }\n-      _ => bcx.tcx().sess.bug(\"free_ty_immediate: non-box ty\")\n-    }\n-}\n-\n pub fn lazily_emit_all_tydesc_glue(ccx: @CrateContext,\n                                    static_ti: @tydesc_info) {\n     lazily_emit_tydesc_glue(ccx, abi::tydesc_field_take_glue, static_ti);\n     lazily_emit_tydesc_glue(ccx, abi::tydesc_field_drop_glue, static_ti);\n-    lazily_emit_tydesc_glue(ccx, abi::tydesc_field_free_glue, static_ti);\n     lazily_emit_tydesc_glue(ccx, abi::tydesc_field_visit_glue, static_ti);\n }\n \n-pub fn simplified_glue_type(tcx: ty::ctxt, field: uint, t: ty::t) -> ty::t {\n-    if (field == abi::tydesc_field_take_glue ||\n-        field == abi::tydesc_field_drop_glue ||\n-        field == abi::tydesc_field_free_glue) &&\n-        ! ty::type_needs_drop(tcx, t) {\n-          return ty::mk_u32();\n+fn simplified_glue_type(tcx: ty::ctxt, field: uint, t: ty::t) -> ty::t {\n+    if (field == abi::tydesc_field_take_glue || field == abi::tydesc_field_drop_glue)\n+        && !ty::type_needs_drop(tcx, t) {\n+        return ty::mk_nil();\n     }\n \n     if field == abi::tydesc_field_take_glue {\n         match ty::get(t).sty {\n-          ty::ty_unboxed_vec(..) |\n-              ty::ty_uniq(..) |\n-              ty::ty_estr(ty::vstore_uniq) |\n-              ty::ty_evec(_, ty::vstore_uniq) => { return ty::mk_u32(); }\n-          _ => ()\n+            ty::ty_str(ty::vstore_uniq) |  ty::ty_vec(_, ty::vstore_uniq) |\n+            ty::ty_unboxed_vec(..) | ty::ty_uniq(..) => return ty::mk_nil(),\n+            _ => {}\n         }\n     }\n \n-    if field == abi::tydesc_field_take_glue &&\n-        ty::type_is_boxed(t) {\n-          return ty::mk_imm_box(tcx, ty::mk_u32());\n-    }\n-\n-    if field == abi::tydesc_field_free_glue {\n-        match ty::get(t).sty {\n-          ty::ty_bare_fn(..) |\n-          ty::ty_closure(..) |\n-          ty::ty_box(..) |\n-          ty::ty_opaque_box |\n-          ty::ty_uniq(..) |\n-          ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq) |\n-          ty::ty_evec(_, ty::vstore_box) | ty::ty_estr(ty::vstore_box) |\n-          ty::ty_opaque_closure_ptr(..) => (),\n-          _ => { return ty::mk_u32(); }\n-        }\n+    if field == abi::tydesc_field_take_glue && ty::type_is_boxed(t) {\n+        return ty::mk_imm_box(tcx, ty::mk_nil());\n     }\n \n-    if (field == abi::tydesc_field_free_glue ||\n-        field == abi::tydesc_field_drop_glue) {\n+    if field == abi::tydesc_field_drop_glue {\n         match ty::get(t).sty {\n-          ty::ty_box(typ)\n-          if ! ty::type_needs_drop(tcx, typ) =>\n-          return ty::mk_imm_box(tcx, ty::mk_u32()),\n+            ty::ty_box(typ)\n+                if !ty::type_needs_drop(tcx, typ) =>\n+            return ty::mk_imm_box(tcx, ty::mk_nil()),\n \n-          ty::ty_evec(mt, ty::vstore_box)\n-          if ! ty::type_needs_drop(tcx, mt.ty) =>\n-          return ty::mk_imm_box(tcx, ty::mk_u32()),\n+            ty::ty_vec(mt, ty::vstore_box)\n+                if !ty::type_needs_drop(tcx, mt.ty) =>\n+            return ty::mk_imm_box(tcx, ty::mk_nil()),\n \n-          ty::ty_uniq(mt) |\n-          ty::ty_evec(mt, ty::vstore_uniq)\n-          if ! ty::type_needs_drop(tcx, mt.ty) =>\n-          return ty::mk_imm_uniq(tcx, ty::mk_u32()),\n+            ty::ty_uniq(mt) | ty::ty_vec(mt, ty::vstore_uniq)\n+                if !ty::type_needs_drop(tcx, mt.ty) =>\n+            return ty::mk_imm_uniq(tcx, ty::mk_nil()),\n \n-          _ => ()\n+            _ => {}\n         }\n     }\n \n-    return t;\n+    t\n }\n \n-pub fn lazily_emit_simplified_tydesc_glue(ccx: @CrateContext,\n-                                          field: uint,\n-                                          ti: &tydesc_info)\n-                                          -> bool {\n-    let _icx = push_ctxt(\"lazily_emit_simplified_tydesc_glue\");\n+fn lazily_emit_tydesc_glue(ccx: @CrateContext, field: uint, ti: @tydesc_info) {\n+    let _icx = push_ctxt(\"lazily_emit_tydesc_glue\");\n+\n     let simpl = simplified_glue_type(ccx.tcx, field, ti.ty);\n     if simpl != ti.ty {\n+        let _icx = push_ctxt(\"lazily_emit_simplified_tydesc_glue\");\n         let simpl_ti = get_tydesc(ccx, simpl);\n         lazily_emit_tydesc_glue(ccx, field, simpl_ti);\n-        {\n-            if field == abi::tydesc_field_take_glue {\n-                ti.take_glue.set(simpl_ti.take_glue.get());\n-            } else if field == abi::tydesc_field_drop_glue {\n-                ti.drop_glue.set(simpl_ti.drop_glue.get());\n-            } else if field == abi::tydesc_field_free_glue {\n-                ti.free_glue.set(simpl_ti.free_glue.get());\n-            } else if field == abi::tydesc_field_visit_glue {\n-                ti.visit_glue.set(simpl_ti.visit_glue.get());\n-            }\n-        }\n-        return true;\n-    }\n-    return false;\n-}\n-\n \n-pub fn lazily_emit_tydesc_glue(ccx: @CrateContext,\n-                               field: uint,\n-                               ti: @tydesc_info) {\n-    let _icx = push_ctxt(\"lazily_emit_tydesc_glue\");\n-    let llfnty = Type::glue_fn(type_of(ccx, ti.ty).ptr_to());\n+        if field == abi::tydesc_field_take_glue {\n+            ti.take_glue.set(simpl_ti.take_glue.get());\n+        } else if field == abi::tydesc_field_drop_glue {\n+            ti.drop_glue.set(simpl_ti.drop_glue.get());\n+        } else if field == abi::tydesc_field_visit_glue {\n+            ti.visit_glue.set(simpl_ti.visit_glue.get());\n+        }\n \n-    if lazily_emit_simplified_tydesc_glue(ccx, field, ti) {\n         return;\n     }\n \n+    let llfnty = Type::glue_fn(type_of(ccx, ti.ty).ptr_to());\n+\n     if field == abi::tydesc_field_take_glue {\n         match ti.take_glue.get() {\n           Some(_) => (),\n@@ -245,19 +180,6 @@ pub fn lazily_emit_tydesc_glue(ccx: @CrateContext,\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n           }\n         }\n-    } else if field == abi::tydesc_field_free_glue {\n-        match ti.free_glue.get() {\n-          Some(_) => (),\n-          None => {\n-            debug!(\"+++ lazily_emit_tydesc_glue FREE {}\",\n-                   ppaux::ty_to_str(ccx.tcx, ti.ty));\n-            let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, \"free\");\n-            ti.free_glue.set(Some(glue_fn));\n-            make_generic_glue(ccx, ti.ty, glue_fn, make_free_glue, \"free\");\n-            debug!(\"--- lazily_emit_tydesc_glue FREE {}\",\n-                   ppaux::ty_to_str(ccx.tcx, ti.ty));\n-          }\n-        }\n     } else if field == abi::tydesc_field_visit_glue {\n         match ti.visit_glue.get() {\n           Some(_) => (),\n@@ -294,8 +216,6 @@ pub fn call_tydesc_glue_full(bcx: &Block,\n             sti.take_glue.get()\n         } else if field == abi::tydesc_field_drop_glue {\n             sti.drop_glue.get()\n-        } else if field == abi::tydesc_field_free_glue {\n-            sti.free_glue.get()\n         } else if field == abi::tydesc_field_visit_glue {\n             sti.visit_glue.get()\n         } else {\n@@ -334,20 +254,16 @@ pub fn call_tydesc_glue_full(bcx: &Block,\n }\n \n // See [Note-arg-mode]\n-pub fn call_tydesc_glue<'a>(\n-                        cx: &'a Block<'a>,\n-                        v: ValueRef,\n-                        t: ty::t,\n-                        field: uint)\n-                        -> &'a Block<'a> {\n+fn call_tydesc_glue<'a>(cx: &'a Block<'a>, v: ValueRef, t: ty::t, field: uint)\n+                    -> &'a Block<'a> {\n     let _icx = push_ctxt(\"call_tydesc_glue\");\n     let ti = get_tydesc(cx.ccx(), t);\n     call_tydesc_glue_full(cx, v, ti.tydesc, field, Some(ti));\n-    return cx;\n+    cx\n }\n \n-pub fn make_visit_glue<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n-                       -> &'a Block<'a> {\n+fn make_visit_glue<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n+                   -> &'a Block<'a> {\n     let _icx = push_ctxt(\"make_visit_glue\");\n     with_scope(bcx, None, \"visitor cleanup\", |bcx| {\n         let mut bcx = bcx;\n@@ -377,25 +293,25 @@ pub fn make_free_glue<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n         let bcx = drop_ty(bcx, body, body_ty);\n         trans_free(bcx, v)\n       }\n-      ty::ty_opaque_box => {\n-        let v = Load(bcx, v);\n-        let td = Load(bcx, GEPi(bcx, v, [0u, abi::box_field_tydesc]));\n-        let valptr = GEPi(bcx, v, [0u, abi::box_field_body]);\n-        // Generate code that, dynamically, indexes into the\n-        // tydesc and calls the drop glue that got set dynamically\n-        call_tydesc_glue_full(bcx, valptr, td, abi::tydesc_field_drop_glue,\n-                              None);\n-        trans_free(bcx, v)\n-      }\n       ty::ty_uniq(..) => {\n-        uniq::make_free_glue(bcx, v, t)\n+        let box_datum = immediate_rvalue(Load(bcx, v), t);\n+        let not_null = IsNotNull(bcx, box_datum.val);\n+        with_cond(bcx, not_null, |bcx| {\n+            let body_datum = box_datum.box_body(bcx);\n+            let bcx = drop_ty(bcx, body_datum.to_ref_llval(bcx), body_datum.ty);\n+            if ty::type_contents(bcx.tcx(), t).owns_managed() {\n+                trans_free(bcx, box_datum.val)\n+            } else {\n+                trans_exchange_free(bcx, box_datum.val)\n+            }\n+        })\n       }\n-      ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq) |\n-      ty::ty_evec(_, ty::vstore_box) | ty::ty_estr(ty::vstore_box) => {\n+      ty::ty_vec(_, ty::vstore_uniq) | ty::ty_str(ty::vstore_uniq) |\n+      ty::ty_vec(_, ty::vstore_box) | ty::ty_str(ty::vstore_box) => {\n         make_free_glue(bcx, v, tvec::expand_boxed_vec_ty(bcx.tcx(), t))\n       }\n       ty::ty_closure(_) => {\n-        closure::make_closure_glue(bcx, v, t, free_ty)\n+        closure::make_closure_glue(bcx, v, t, make_free_glue)\n       }\n       ty::ty_opaque_closure_ptr(ck) => {\n         closure::make_opaque_cbox_free_glue(bcx, ck, v)\n@@ -469,13 +385,13 @@ pub fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t)\n     let _icx = push_ctxt(\"make_drop_glue\");\n     let ccx = bcx.ccx();\n     match ty::get(t).sty {\n-      ty::ty_box(_) | ty::ty_opaque_box |\n-      ty::ty_estr(ty::vstore_box) | ty::ty_evec(_, ty::vstore_box) => {\n-        decr_refcnt_maybe_free(bcx, Load(bcx, v0), Some(v0), t)\n+      ty::ty_box(_) |\n+      ty::ty_str(ty::vstore_box) | ty::ty_vec(_, ty::vstore_box) => {\n+        decr_refcnt_maybe_free(bcx, v0, Some(t))\n       }\n       ty::ty_uniq(_) |\n-      ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq) => {\n-        free_ty(bcx, v0, t)\n+      ty::ty_vec(_, ty::vstore_uniq) | ty::ty_str(ty::vstore_uniq) => {\n+        make_free_glue(bcx, v0, t)\n       }\n       ty::ty_unboxed_vec(_) => {\n         tvec::make_drop_glue_unboxed(bcx, v0, t)\n@@ -500,9 +416,7 @@ pub fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t)\n       }\n       ty::ty_trait(_, _, ty::BoxTraitStore, _, _) => {\n           let llbox_ptr = GEPi(bcx, v0, [0u, abi::trt_field_box]);\n-          let llbox = Load(bcx, llbox_ptr);\n-          decr_refcnt_maybe_free(bcx, llbox, Some(llbox_ptr),\n-                                 ty::mk_opaque_box(ccx.tcx))\n+          decr_refcnt_maybe_free(bcx, llbox_ptr, None)\n       }\n       ty::ty_trait(_, _, ty::UniqTraitStore, _, _) => {\n           let lluniquevalue = GEPi(bcx, v0, [0, abi::trt_field_box]);\n@@ -517,7 +431,7 @@ pub fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t)\n               call_tydesc_glue_full(bcx,\n                                     lluniquevalue,\n                                     lltydesc,\n-                                    abi::tydesc_field_free_glue,\n+                                    abi::tydesc_field_drop_glue,\n                                     None);\n               bcx\n           })\n@@ -534,49 +448,50 @@ pub fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t)\n     }\n }\n \n-// box_ptr_ptr is optional, it is constructed if not supplied.\n-pub fn decr_refcnt_maybe_free<'a>(\n-                              bcx: &'a Block<'a>,\n-                              box_ptr: ValueRef,\n-                              box_ptr_ptr: Option<ValueRef>,\n-                              t: ty::t)\n-                              -> &'a Block<'a> {\n+fn decr_refcnt_maybe_free<'a>(bcx: &'a Block<'a>, box_ptr_ptr: ValueRef,\n+                              t: Option<ty::t>) -> &'a Block<'a> {\n     let _icx = push_ctxt(\"decr_refcnt_maybe_free\");\n     let ccx = bcx.ccx();\n \n     let decr_bcx = sub_block(bcx, \"decr\");\n     let free_bcx = sub_block(decr_bcx, \"free\");\n     let next_bcx = sub_block(bcx, \"next\");\n+    let box_ptr = Load(bcx, box_ptr_ptr);\n     let llnotnull = IsNotNull(bcx, box_ptr);\n     CondBr(bcx, llnotnull, decr_bcx.llbb, next_bcx.llbb);\n \n     let rc_ptr = GEPi(decr_bcx, box_ptr, [0u, abi::box_field_refcnt]);\n     let rc = Sub(decr_bcx, Load(decr_bcx, rc_ptr), C_int(ccx, 1));\n     Store(decr_bcx, rc, rc_ptr);\n-    let llisnull = IsNull(decr_bcx, rc);\n-    CondBr(decr_bcx, llisnull, free_bcx.llbb, next_bcx.llbb);\n-\n-    let free_bcx = match box_ptr_ptr {\n-        Some(p) => free_ty(free_bcx, p, t),\n-        None => free_ty_immediate(free_bcx, box_ptr, t)\n+    CondBr(decr_bcx, IsNull(decr_bcx, rc), free_bcx.llbb, next_bcx.llbb);\n+\n+    let free_bcx = match t {\n+        Some(t) => make_free_glue(free_bcx, box_ptr_ptr, t),\n+        None => {\n+            let v = Load(free_bcx, box_ptr_ptr);\n+            let td = Load(free_bcx, GEPi(free_bcx, v, [0u, abi::box_field_tydesc]));\n+            let valptr = GEPi(free_bcx, v, [0u, abi::box_field_body]);\n+            // Generate code that, dynamically, indexes into the\n+            // tydesc and calls the drop glue that got set dynamically\n+            call_tydesc_glue_full(free_bcx, valptr, td, abi::tydesc_field_drop_glue, None);\n+            trans_free(free_bcx, v)\n+        }\n     };\n     Br(free_bcx, next_bcx.llbb);\n \n     next_bcx\n }\n \n-\n-pub fn make_take_glue<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n-                      -> &'a Block<'a> {\n+fn make_take_glue<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t) -> &'a Block<'a> {\n     let _icx = push_ctxt(\"make_take_glue\");\n     // NB: v is a *pointer* to type t here, not a direct value.\n     match ty::get(t).sty {\n-      ty::ty_box(_) | ty::ty_opaque_box |\n-      ty::ty_evec(_, ty::vstore_box) | ty::ty_estr(ty::vstore_box) => {\n+      ty::ty_box(_) |\n+      ty::ty_vec(_, ty::vstore_box) | ty::ty_str(ty::vstore_box) => {\n         incr_refcnt_of_boxed(bcx, Load(bcx, v)); bcx\n       }\n-      ty::ty_evec(_, ty::vstore_slice(_))\n-      | ty::ty_estr(ty::vstore_slice(_)) => {\n+      ty::ty_vec(_, ty::vstore_slice(_))\n+      | ty::ty_str(ty::vstore_slice(_)) => {\n         bcx\n       }\n       ty::ty_closure(_) => bcx,\n@@ -608,7 +523,7 @@ pub fn make_take_glue<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n     }\n }\n \n-pub fn incr_refcnt_of_boxed(cx: &Block, box_ptr: ValueRef) {\n+fn incr_refcnt_of_boxed(cx: &Block, box_ptr: ValueRef) {\n     let _icx = push_ctxt(\"incr_refcnt_of_boxed\");\n     let ccx = cx.ccx();\n     let rc_ptr = GEPi(cx, box_ptr, [0u, abi::box_field_refcnt]);\n@@ -654,7 +569,7 @@ pub fn declare_tydesc(ccx: &CrateContext, t: ty::t) -> @tydesc_info {\n         }\n     });\n \n-    let ty_name = C_estr_slice(ccx, ppaux::ty_to_str(ccx.tcx, t).to_managed());\n+    let ty_name = C_str_slice(ccx, ppaux::ty_to_str(ccx.tcx, t).to_managed());\n \n     let inf = @tydesc_info {\n         ty: t,\n@@ -665,18 +580,14 @@ pub fn declare_tydesc(ccx: &CrateContext, t: ty::t) -> @tydesc_info {\n         name: ty_name,\n         take_glue: Cell::new(None),\n         drop_glue: Cell::new(None),\n-        free_glue: Cell::new(None),\n         visit_glue: Cell::new(None),\n     };\n     debug!(\"--- declare_tydesc {}\", ppaux::ty_to_str(ccx.tcx, t));\n     return inf;\n }\n \n-pub type glue_helper<'a> =\n-    'a |&'a Block<'a>, ValueRef, ty::t| -> &'a Block<'a>;\n-\n-pub fn declare_generic_glue(ccx: &CrateContext, t: ty::t, llfnty: Type,\n-                            name: &str) -> ValueRef {\n+fn declare_generic_glue(ccx: &CrateContext, t: ty::t, llfnty: Type,\n+                        name: &str) -> ValueRef {\n     let _icx = push_ctxt(\"declare_generic_glue\");\n     let fn_nm = mangle_internal_name_by_type_and_seq(ccx, t, (~\"glue_\" + name)).to_managed();\n     debug!(\"{} is for type {}\", fn_nm, ppaux::ty_to_str(ccx.tcx, t));\n@@ -685,12 +596,14 @@ pub fn declare_generic_glue(ccx: &CrateContext, t: ty::t, llfnty: Type,\n     return llfn;\n }\n \n-pub fn make_generic_glue_inner(ccx: @CrateContext,\n-                               t: ty::t,\n-                               llfn: ValueRef,\n-                               helper: glue_helper)\n-                            -> ValueRef {\n-    let _icx = push_ctxt(\"make_generic_glue_inner\");\n+pub type glue_helper<'a> =\n+    'a |&'a Block<'a>, ValueRef, ty::t| -> &'a Block<'a>;\n+\n+fn make_generic_glue(ccx: @CrateContext, t: ty::t, llfn: ValueRef,\n+                     helper: glue_helper, name: &str) -> ValueRef {\n+    let _icx = push_ctxt(\"make_generic_glue\");\n+    let glue_name = format!(\"glue {} {}\", name, ty_to_short_str(ccx.tcx, t));\n+    let _s = StatRecorder::new(ccx, glue_name);\n \n     let fcx = new_fn_ctxt(ccx, ~[], llfn, ty::mk_nil(), None);\n     init_function(&fcx, false, ty::mk_nil(), None, None);\n@@ -706,25 +619,12 @@ pub fn make_generic_glue_inner(ccx: @CrateContext,\n     // type, so we don't need to explicitly cast the function parameter.\n \n     let bcx = fcx.entry_bcx.get().unwrap();\n-    let rawptr0_arg = fcx.arg_pos(0u);\n-    let llrawptr0 = unsafe { llvm::LLVMGetParam(llfn, rawptr0_arg as c_uint) };\n+    let llrawptr0 = unsafe { llvm::LLVMGetParam(llfn, fcx.arg_pos(0) as c_uint) };\n     let bcx = helper(bcx, llrawptr0, t);\n \n     finish_fn(&fcx, bcx);\n \n-    return llfn;\n-}\n-\n-pub fn make_generic_glue(ccx: @CrateContext,\n-                         t: ty::t,\n-                         llfn: ValueRef,\n-                         helper: glue_helper,\n-                         name: &str)\n-                      -> ValueRef {\n-    let _icx = push_ctxt(\"make_generic_glue\");\n-    let glue_name = format!(\"glue {} {}\", name, ty_to_short_str(ccx.tcx, t));\n-    let _s = StatRecorder::new(ccx, glue_name);\n-    make_generic_glue_inner(ccx, t, llfn, helper)\n+    llfn\n }\n \n pub fn emit_tydescs(ccx: &CrateContext) {\n@@ -770,21 +670,6 @@ pub fn emit_tydescs(ccx: &CrateContext) {\n                 }\n               }\n             };\n-        let free_glue =\n-            match ti.free_glue.get() {\n-              None => {\n-                  ccx.stats.n_null_glues.set(ccx.stats.n_null_glues.get() +\n-                                             1u);\n-                  C_null(glue_fn_ty)\n-              }\n-              Some(v) => {\n-                unsafe {\n-                    ccx.stats.n_real_glues.set(ccx.stats.n_real_glues.get() +\n-                                               1);\n-                    llvm::LLVMConstPointerCast(v, glue_fn_ty.to_ref())\n-                }\n-              }\n-            };\n         let visit_glue =\n             match ti.visit_glue.get() {\n               None => {\n@@ -808,7 +693,6 @@ pub fn emit_tydescs(ccx: &CrateContext) {\n                                      ti.align, // align\n                                      take_glue, // take_glue\n                                      drop_glue, // drop_glue\n-                                     free_glue, // free_glue\n                                      visit_glue, // visit_glue\n                                      ti.borrow_offset, // borrow_offset\n                                      ti.name]); // name"}, {"sha": "7d0e5a435441b53e079a60052404e7997b70938d", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -11,8 +11,7 @@\n use lib::llvm::{AvailableExternallyLinkage, SetLinkage};\n use metadata::csearch;\n use middle::astencode;\n-use middle::trans::base::{push_ctxt, impl_self, no_self};\n-use middle::trans::base::{trans_item, get_item_val, trans_fn};\n+use middle::trans::base::{push_ctxt, trans_item, get_item_val, trans_fn};\n use middle::trans::common::*;\n use middle::ty;\n use util::ppaux::ty_to_str;\n@@ -162,16 +161,13 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::DefId)\n               let path = vec::append_one(\n                   ty::item_path(ccx.tcx, impl_did), PathName(mth.ident));\n               let self_kind = match mth.explicit_self.node {\n-                  ast::SelfStatic => no_self,\n+                  ast::SelfStatic => None,\n                   _ => {\n                       let self_ty = ty::node_id_to_type(ccx.tcx,\n                                                         mth.self_id);\n                       debug!(\"calling inline trans_fn with self_ty {}\",\n                              ty_to_str(ccx.tcx, self_ty));\n-                      match mth.explicit_self.node {\n-                          ast::SelfValue(_) => impl_self(self_ty, ty::ByRef),\n-                          _ => impl_self(self_ty, ty::ByCopy),\n-                      }\n+                      Some(self_ty)\n                   }\n               };\n               trans_fn(ccx,\n@@ -182,6 +178,7 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::DefId)\n                        self_kind,\n                        None,\n                        mth.id,\n+                       Some(&*mth),\n                        []);\n           }\n           local_def(mth.id)"}, {"sha": "126aa9e7be580a2f45ab18c4097414d671cf4724", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -430,7 +430,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             // XXX This is a hack to grab the address of this particular\n             // native function. There should be a general in-language\n             // way to do this\n-            let llfty = type_of_rust_fn(bcx.ccx(), [], ty::mk_nil());\n+            let llfty = type_of_rust_fn(bcx.ccx(), None, [], ty::mk_nil());\n             let morestack_addr = decl_cdecl_fn(\n                 bcx.ccx().llmod, \"__morestack\", llfty);\n             let morestack_addr = PointerCast(bcx, morestack_addr, Type::nil().ptr_to());"}, {"sha": "2ab495226a8c12ef16310d1f7808bcafcf00ceaf", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 37, "deletions": 54, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -76,7 +76,7 @@ pub fn trans_impl(ccx: @CrateContext,\n                          path,\n                          *method,\n                          None,\n-                         llfn);\n+                         |_| llfn);\n         } else {\n             let mut v = TransItemVisitor{ ccx: ccx };\n             visit::walk_method_helper(&mut v, *method, ());\n@@ -91,20 +91,18 @@ pub fn trans_impl(ccx: @CrateContext,\n /// * `method`: the AST node for the method\n /// * `param_substs`: if this is a generic method, the current values for\n ///   type parameters and so forth, else none\n-/// * `llfn`: the LLVM ValueRef for the method\n+/// * `llfn`: a closure returning the LLVM ValueRef for the method\n /// * `impl_id`: the node ID of the impl this method is inside\n ///\n /// XXX(pcwalton) Can we take `path` by reference?\n pub fn trans_method(ccx: @CrateContext,\n                     path: Path,\n                     method: &ast::Method,\n                     param_substs: Option<@param_substs>,\n-                    llfn: ValueRef) {\n+                    llfn_with_self: |Option<ty::t>| -> ValueRef) -> ValueRef {\n     // figure out how self is being passed\n-    let self_arg = match method.explicit_self.node {\n-      ast::SelfStatic => {\n-        no_self\n-      }\n+    let self_ty = match method.explicit_self.node {\n+      ast::SelfStatic => None,\n       _ => {\n         // determine the (monomorphized) type that `self` maps to for\n         // this method\n@@ -115,43 +113,25 @@ pub fn trans_method(ccx: @CrateContext,\n                 ty::subst_tps(ccx.tcx, *tys, *self_sub, self_ty)\n             }\n         };\n-        debug!(\"calling trans_fn with self_ty {}\",\n-               self_ty.repr(ccx.tcx));\n-        match method.explicit_self.node {\n-          ast::SelfValue(_) => impl_self(self_ty, ty::ByRef),\n-          _ => impl_self(self_ty, ty::ByCopy),\n-        }\n+        debug!(\"calling trans_fn with self_ty {}\", self_ty.repr(ccx.tcx));\n+        Some(self_ty)\n       }\n     };\n \n+    let llfn = llfn_with_self(self_ty);\n+\n     // generate the actual code\n     trans_fn(ccx,\n              path,\n              method.decl,\n              method.body,\n              llfn,\n-             self_arg,\n+             self_ty,\n              param_substs,\n              method.id,\n+             Some(method),\n              []);\n-}\n-\n-pub fn trans_self_arg<'a>(\n-                      bcx: &'a Block<'a>,\n-                      base: &ast::Expr,\n-                      temp_cleanups: &mut ~[ValueRef],\n-                      mentry: typeck::method_map_entry)\n-                      -> Result<'a> {\n-    let _icx = push_ctxt(\"impl::trans_self_arg\");\n-\n-    // self is passed as an opaque box in the environment slot\n-    let self_ty = ty::mk_opaque_box(bcx.tcx());\n-    trans_arg_expr(bcx,\n-                   self_ty,\n-                   mentry.self_mode,\n-                   base,\n-                   temp_cleanups,\n-                   DontAutorefArg)\n+    llfn\n }\n \n pub fn trans_method_callee<'a>(\n@@ -169,16 +149,23 @@ pub fn trans_method_callee<'a>(\n \n     match mentry.origin {\n         typeck::method_static(did) => {\n-            let callee_fn = callee::trans_fn_ref(bcx, did, callee_id);\n+            let self_ty = monomorphize_type(bcx, mentry.self_ty);\n             let mut temp_cleanups = ~[];\n-            let Result {bcx, val} = trans_self_arg(bcx, this, &mut temp_cleanups, mentry);\n+            let Result {bcx, val} = trans_arg_expr(bcx, self_ty, this,\n+                                                   &mut temp_cleanups,\n+                                                   DontAutorefArg);\n+            // HACK should not need the pointer cast, eventually trans_fn_ref\n+            // should return a function type with the right type for self.\n+            let callee_fn = callee::trans_fn_ref(bcx, did, callee_id);\n+            let fn_ty = node_id_type(bcx, callee_id);\n+            let llfn_ty = type_of_fn_from_ty(bcx.ccx(), Some(self_ty), fn_ty).ptr_to();\n+            let llfn_val = PointerCast(bcx, callee_fn.llfn, llfn_ty);\n             Callee {\n                 bcx: bcx,\n                 data: Method(MethodData {\n-                    llfn: callee_fn.llfn,\n+                    llfn: llfn_val,\n                     llself: val,\n-                    temp_cleanup: temp_cleanups.head_opt().map(|v| *v),\n-                    self_mode: mentry.self_mode,\n+                    temp_cleanup: temp_cleanups.head_opt().map(|v| *v)\n                 })\n             }\n         }\n@@ -194,8 +181,7 @@ pub fn trans_method_callee<'a>(\n                         bcx.tcx(),\n                         trait_id);\n \n-                    let vtbl = find_vtable(bcx.tcx(), substs,\n-                                           p, b);\n+                    let vtbl = find_vtable(bcx.tcx(), substs, p, b);\n                     trans_monomorphized_callee(bcx, callee_id, this, mentry,\n                                                trait_id, off, vtbl)\n                 }\n@@ -276,7 +262,7 @@ pub fn trans_static_method_callee(bcx: &Block,\n         typeck::vtable_static(impl_did, ref rcvr_substs, rcvr_origins) => {\n             assert!(rcvr_substs.iter().all(|t| !ty::type_needs_infer(*t)));\n \n-            let mth_id = method_with_name(bcx.ccx(), impl_did, mname.name);\n+            let mth_id = method_with_name(ccx, impl_did, mname.name);\n             let (callee_substs, callee_origins) =\n                 combine_impl_and_methods_tps(\n                     bcx, mth_id, callee_id,\n@@ -290,7 +276,7 @@ pub fn trans_static_method_callee(bcx: &Block,\n                                           Some(callee_origins));\n \n             let callee_ty = node_id_type(bcx, callee_id);\n-            let llty = type_of_fn_from_ty(ccx, callee_ty).ptr_to();\n+            let llty = type_of_fn_from_ty(ccx, None, callee_ty).ptr_to();\n             FnData {llfn: PointerCast(bcx, lval, llty)}\n         }\n         _ => {\n@@ -340,9 +326,11 @@ pub fn trans_monomorphized_callee<'a>(\n           let mth_id = method_with_name(bcx.ccx(), impl_did, mname.name);\n \n           // obtain the `self` value:\n+          let self_ty = monomorphize_type(bcx, mentry.self_ty);\n           let mut temp_cleanups = ~[];\n-          let Result {bcx, val: llself_val} =\n-              trans_self_arg(bcx, base, &mut temp_cleanups, mentry);\n+          let Result {bcx, val} = trans_arg_expr(bcx, self_ty, base,\n+                                                 &mut temp_cleanups,\n+                                                 DontAutorefArg);\n \n           // create a concatenated set of substitutions which includes\n           // those from the impl and those from the method:\n@@ -359,18 +347,18 @@ pub fn trans_monomorphized_callee<'a>(\n                                                  Some(callee_origins));\n \n           // create a llvalue that represents the fn ptr\n+          // HACK should not need the pointer cast (add self in trans_fn_ref_with_vtables).\n           let fn_ty = node_id_type(bcx, callee_id);\n-          let llfn_ty = type_of_fn_from_ty(ccx, fn_ty).ptr_to();\n+          let llfn_ty = type_of_fn_from_ty(ccx, Some(self_ty), fn_ty).ptr_to();\n           let llfn_val = PointerCast(bcx, callee.llfn, llfn_ty);\n \n           // combine the self environment with the rest\n           Callee {\n               bcx: bcx,\n               data: Method(MethodData {\n                   llfn: llfn_val,\n-                  llself: llself_val,\n-                  temp_cleanup: temp_cleanups.head_opt().map(|v| *v),\n-                  self_mode: mentry.self_mode,\n+                  llself: val,\n+                  temp_cleanup: temp_cleanups.head_opt().map(|v| *v)\n               })\n           }\n       }\n@@ -496,7 +484,7 @@ pub fn trans_trait_callee_from_llval<'a>(\n \n     // Load the function from the vtable and cast it to the expected type.\n     debug!(\"(translating trait callee) loading method\");\n-    let llcallee_ty = type_of_fn_from_ty(ccx, callee_ty);\n+    let llcallee_ty = type_of_fn_from_ty(ccx, None, callee_ty);\n     let llvtable = Load(bcx,\n                         PointerCast(bcx,\n                                     GEPi(bcx, llpair,\n@@ -510,12 +498,7 @@ pub fn trans_trait_callee_from_llval<'a>(\n         data: Method(MethodData {\n             llfn: mptr,\n             llself: llself,\n-            temp_cleanup: temp_cleanup,\n-\n-                // We know that the func declaration is &self, ~self,\n-                // or @self, and such functions are always by-copy\n-                // (right now, at least).\n-            self_mode: ty::ByCopy,\n+            temp_cleanup: temp_cleanup\n         })\n     };\n }"}, {"sha": "e534e087cb835f590ca2618e72c5ead5290971ce", "filename": "src/librustc/middle/trans/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -25,7 +25,6 @@ pub mod build;\n pub mod builder;\n pub mod base;\n pub mod _match;\n-pub mod uniq;\n pub mod closure;\n pub mod tvec;\n pub mod meth;"}, {"sha": "c7bf618a619c099db076f241098441739848c957", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -13,9 +13,8 @@ use back::link::mangle_exported_name;\n use driver::session;\n use lib::llvm::ValueRef;\n use middle::trans::base::{set_llvm_fn_attrs, set_inline_hint};\n-use middle::trans::base::{trans_enum_variant,push_ctxt};\n+use middle::trans::base::{trans_enum_variant, push_ctxt, get_item_val};\n use middle::trans::base::{trans_fn, decl_internal_rust_fn};\n-use middle::trans::base::{get_item_val, no_self};\n use middle::trans::base;\n use middle::trans::common::*;\n use middle::trans::meth;\n@@ -211,8 +210,8 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n     let s = mangle_exported_name(ccx, pt.clone(), mono_ty);\n     debug!(\"monomorphize_fn mangled to {}\", s);\n \n-    let mk_lldecl = || {\n-        let lldecl = decl_internal_rust_fn(ccx, f.sig.inputs, f.sig.output, s);\n+    let mk_lldecl = |self_ty| {\n+        let lldecl = decl_internal_rust_fn(ccx, self_ty, f.sig.inputs, f.sig.output, s);\n         let mut monomorphized = ccx.monomorphized.borrow_mut();\n         monomorphized.get().insert(hash_id, lldecl);\n         lldecl\n@@ -223,32 +222,33 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n                 node: ast::ItemFn(decl, _, _, _, body),\n                 ..\n             }, _) => {\n-        let d = mk_lldecl();\n+        let d = mk_lldecl(None);\n         set_llvm_fn_attrs(i.attrs, d);\n         trans_fn(ccx,\n                  pt,\n                  decl,\n                  body,\n                  d,\n-                 no_self,\n+                 None,\n                  Some(psubsts),\n                  fn_id.node,\n+                 None,\n                  []);\n         d\n       }\n       ast_map::NodeItem(..) => {\n           ccx.tcx.sess.bug(\"Can't monomorphize this kind of item\")\n       }\n       ast_map::NodeForeignItem(i, _, _, _) => {\n-          let d = mk_lldecl();\n+          let d = mk_lldecl(None);\n           intrinsic::trans_intrinsic(ccx, d, i, pt, psubsts, i.attrs,\n                                      ref_id);\n           d\n       }\n       ast_map::NodeVariant(v, enum_item, _) => {\n         let tvs = ty::enum_variants(ccx.tcx, local_def(enum_item.id));\n         let this_tv = *tvs.iter().find(|tv| { tv.id.node == fn_id.node}).unwrap();\n-        let d = mk_lldecl();\n+        let d = mk_lldecl(None);\n         set_inline_hint(d);\n         match v.node.kind {\n             ast::TupleVariantKind(ref args) => {\n@@ -266,20 +266,21 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n         d\n       }\n       ast_map::NodeMethod(mth, _, _) => {\n-        // XXX: What should the self type be here?\n-        let d = mk_lldecl();\n-        set_llvm_fn_attrs(mth.attrs, d);\n-        meth::trans_method(ccx, pt, mth, Some(psubsts), d);\n-        d\n+        meth::trans_method(ccx, pt, mth, Some(psubsts), |self_ty| {\n+            let d = mk_lldecl(self_ty);\n+            set_llvm_fn_attrs(mth.attrs, d);\n+            d\n+        })\n       }\n       ast_map::NodeTraitMethod(@ast::Provided(mth), _, pt) => {\n-        let d = mk_lldecl();\n-        set_llvm_fn_attrs(mth.attrs, d);\n-        meth::trans_method(ccx, (*pt).clone(), mth, Some(psubsts), d);\n-        d\n+        meth::trans_method(ccx, (*pt).clone(), mth, Some(psubsts), |self_ty| {\n+            let d = mk_lldecl(self_ty);\n+            set_llvm_fn_attrs(mth.attrs, d);\n+            d\n+        })\n       }\n       ast_map::NodeStructCtor(struct_def, _, _) => {\n-        let d = mk_lldecl();\n+        let d = mk_lldecl(None);\n         set_inline_hint(d);\n         base::trans_tuple_struct(ccx,\n                                  struct_def.fields,"}, {"sha": "ef9f48d478531e4da956cc5d551b18e464c77ae4", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -60,7 +60,7 @@ impl<'a> Reflector<'a> {\n         // will kick us off fast isel. (Issue #4352.)\n         let bcx = self.bcx;\n         let str_vstore = ty::vstore_slice(ty::ReStatic);\n-        let str_ty = ty::mk_estr(bcx.tcx(), str_vstore);\n+        let str_ty = ty::mk_str(bcx.tcx(), str_vstore);\n         let scratch = scratch_datum(bcx, str_ty, \"\", false);\n         let len = C_uint(bcx.ccx(), s.len());\n         let c_str = PointerCast(bcx, C_cstr(bcx.ccx(), s), Type::i8p());\n@@ -176,11 +176,11 @@ impl<'a> Reflector<'a> {\n               self.visit(\"vec\", values)\n           }\n \n-          ty::ty_estr(vst) => {\n+          ty::ty_str(vst) => {\n               let (name, extra) = self.vstore_name_and_extra(t, vst);\n               self.visit(~\"estr_\" + name, extra)\n           }\n-          ty::ty_evec(ref mt, vst) => {\n+          ty::ty_vec(ref mt, vst) => {\n               let (name, extra) = self.vstore_name_and_extra(t, vst);\n               let extra = extra + self.c_mt(mt);\n               if \"uniq\" == name && ty::type_contents(bcx.tcx(), t).owns_managed() {\n@@ -295,7 +295,7 @@ impl<'a> Reflector<'a> {\n                                                                sub_path,\n                                                                \"get_disr\");\n \n-                let llfdecl = decl_internal_rust_fn(ccx, [opaqueptrty], ty::mk_u64(), sym);\n+                let llfdecl = decl_internal_rust_fn(ccx, None, [opaqueptrty], ty::mk_u64(), sym);\n                 let fcx = new_fn_ctxt(ccx,\n                                       ~[],\n                                       llfdecl,\n@@ -362,7 +362,6 @@ impl<'a> Reflector<'a> {\n           }\n           ty::ty_self(..) => self.leaf(\"self\"),\n           ty::ty_type => self.leaf(\"type\"),\n-          ty::ty_opaque_box => self.leaf(\"opaque_box\"),\n           ty::ty_opaque_closure_ptr(ck) => {\n               let ckval = ast_sigil_constant(ck);\n               let extra = ~[self.c_uint(ckval)];"}, {"sha": "e8d4381e9f7991b98f1a9c4cdf9d381a1f66a8be", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -40,10 +40,10 @@ pub fn expand_boxed_vec_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n     let unit_ty = ty::sequence_element_type(tcx, t);\n     let unboxed_vec_ty = ty::mk_mut_unboxed_vec(tcx, unit_ty);\n     match ty::get(t).sty {\n-      ty::ty_estr(ty::vstore_uniq) | ty::ty_evec(_, ty::vstore_uniq) => {\n+      ty::ty_str(ty::vstore_uniq) | ty::ty_vec(_, ty::vstore_uniq) => {\n         ty::mk_imm_uniq(tcx, unboxed_vec_ty)\n       }\n-      ty::ty_estr(ty::vstore_box) | ty::ty_evec(_, ty::vstore_box) => {\n+      ty::ty_str(ty::vstore_box) | ty::ty_vec(_, ty::vstore_box) => {\n         ty::mk_imm_box(tcx, unboxed_vec_ty)\n       }\n       _ => tcx.sess.bug(\"non boxed-vec type \\\n@@ -239,9 +239,9 @@ pub fn trans_slice_vstore<'a>(\n     let llfixed = base::arrayalloca(bcx, vt.llunit_ty, llcount);\n \n     // Arrange for the backing array to be cleaned up.\n-    let fixed_ty = ty::mk_evec(bcx.tcx(),\n-                               ty::mt {ty: vt.unit_ty, mutbl: ast::MutMutable},\n-                               ty::vstore_fixed(count));\n+    let fixed_ty = ty::mk_vec(bcx.tcx(),\n+                              ty::mt {ty: vt.unit_ty, mutbl: ast::MutMutable},\n+                              ty::vstore_fixed(count));\n     let llfixed_ty = type_of::type_of(bcx.ccx(), fixed_ty).ptr_to();\n     let llfixed_casted = BitCast(bcx, llfixed, llfixed_ty);\n     add_clean(bcx, llfixed_casted, fixed_ty);\n@@ -323,7 +323,7 @@ pub fn trans_uniq_or_managed_vstore<'a>(\n                     let llptrval = C_cstr(bcx.ccx(), s);\n                     let llptrval = PointerCast(bcx, llptrval, Type::i8p());\n                     let llsizeval = C_uint(bcx.ccx(), s.len());\n-                    let typ = ty::mk_estr(bcx.tcx(), ty::vstore_uniq);\n+                    let typ = ty::mk_str(bcx.tcx(), ty::vstore_uniq);\n                     let lldestval = scratch_datum(bcx, typ, \"\", false);\n                     let alloc_fn = langcall(bcx, Some(span), \"\",\n                                             StrDupUniqFnLangItem);\n@@ -449,7 +449,7 @@ pub fn write_content<'a>(\n         }\n         _ => {\n             bcx.tcx().sess.span_bug(content_expr.span,\n-                                    \"Unexpected evec content\");\n+                                    \"Unexpected vec content\");\n         }\n     }\n }\n@@ -485,7 +485,7 @@ pub fn elements_required(bcx: &Block, content_expr: &ast::Expr) -> uint {\n             ty::eval_repeat_count(&bcx.tcx(), count_expr)\n         }\n         _ => bcx.tcx().sess.span_bug(content_expr.span,\n-                                     \"Unexpected evec content\")\n+                                     \"Unexpected vec content\")\n     }\n }\n \n@@ -503,7 +503,7 @@ pub fn get_base_and_byte_len(bcx: &Block, llval: ValueRef, vec_ty: ty::t)\n     let vt = vec_types(bcx, vec_ty);\n \n     let vstore = match ty::get(vt.vec_ty).sty {\n-      ty::ty_estr(vst) | ty::ty_evec(_, vst) => vst,\n+      ty::ty_str(vst) | ty::ty_vec(_, vst) => vst,\n       _ => ty::vstore_uniq\n     };\n \n@@ -540,7 +540,7 @@ pub fn get_base_and_len(bcx: &Block, llval: ValueRef, vec_ty: ty::t)\n     let vt = vec_types(bcx, vec_ty);\n \n     let vstore = match ty::get(vt.vec_ty).sty {\n-      ty::ty_estr(vst) | ty::ty_evec(_, vst) => vst,\n+      ty::ty_str(vst) | ty::ty_vec(_, vst) => vst,\n       _ => ty::vstore_uniq\n     };\n "}, {"sha": "d4ba4a76f81290bf78392a70f6c3083e06f23e4c", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -219,7 +219,6 @@ impl Type {\n                      int_ty,     // align\n                      glue_fn_ty, // take\n                      glue_fn_ty, // drop\n-                     glue_fn_ty, // free\n                      glue_fn_ty, // visit\n                      int_ty, // borrow_offset\n                      Type::struct_([Type::i8p(), Type::int(arch)], false)]; // name"}, {"sha": "f59c2acd0274c9e66f2cbcb7f79c119e3042396b", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 27, "deletions": 24, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -44,6 +44,7 @@ pub fn type_of_explicit_args(ccx: &CrateContext,\n }\n \n pub fn type_of_rust_fn(cx: &CrateContext,\n+                       self_ty: Option<ty::t>,\n                        inputs: &[ty::t],\n                        output: ty::t) -> Type {\n     let mut atys: ~[Type] = ~[];\n@@ -57,7 +58,11 @@ pub fn type_of_rust_fn(cx: &CrateContext,\n     }\n \n     // Arg 1: Environment\n-    atys.push(Type::opaque_box(cx).ptr_to());\n+    let env = match self_ty {\n+        Some(t) => type_of_explicit_arg(cx, t),\n+        None => Type::opaque_box(cx).ptr_to()\n+    };\n+    atys.push(env);\n \n     // ... then explicit args.\n     atys.push_all(type_of_explicit_args(cx, inputs));\n@@ -71,14 +76,14 @@ pub fn type_of_rust_fn(cx: &CrateContext,\n }\n \n // Given a function type and a count of ty params, construct an llvm type\n-pub fn type_of_fn_from_ty(cx: &CrateContext, fty: ty::t) -> Type {\n+pub fn type_of_fn_from_ty(cx: &CrateContext, self_ty: Option<ty::t>, fty: ty::t) -> Type {\n     return match ty::get(fty).sty {\n         ty::ty_closure(ref f) => {\n-            type_of_rust_fn(cx, f.sig.inputs, f.sig.output)\n+            type_of_rust_fn(cx, None, f.sig.inputs, f.sig.output)\n         }\n         ty::ty_bare_fn(ref f) => {\n             if f.abis.is_rust() || f.abis.is_intrinsic() {\n-                type_of_rust_fn(cx, f.sig.inputs, f.sig.output)\n+                type_of_rust_fn(cx, self_ty, f.sig.inputs, f.sig.output)\n             } else {\n                 foreign::lltype_for_foreign_fn(cx, fty)\n             }\n@@ -117,29 +122,28 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n         ty::ty_uint(t) => Type::uint_from_ty(cx, t),\n         ty::ty_float(t) => Type::float_from_ty(t),\n \n-        ty::ty_estr(ty::vstore_uniq) |\n-        ty::ty_estr(ty::vstore_box) |\n-        ty::ty_evec(_, ty::vstore_uniq) |\n-        ty::ty_evec(_, ty::vstore_box) |\n+        ty::ty_str(ty::vstore_uniq) |\n+        ty::ty_str(ty::vstore_box) |\n+        ty::ty_vec(_, ty::vstore_uniq) |\n+        ty::ty_vec(_, ty::vstore_box) |\n         ty::ty_box(..) |\n-        ty::ty_opaque_box |\n         ty::ty_uniq(..) |\n         ty::ty_ptr(..) |\n         ty::ty_rptr(..) |\n         ty::ty_type |\n         ty::ty_opaque_closure_ptr(..) => Type::i8p(),\n \n-        ty::ty_estr(ty::vstore_slice(..)) |\n-        ty::ty_evec(_, ty::vstore_slice(..)) => {\n+        ty::ty_str(ty::vstore_slice(..)) |\n+        ty::ty_vec(_, ty::vstore_slice(..)) => {\n             Type::struct_([Type::i8p(), Type::i8p()], false)\n         }\n \n         ty::ty_bare_fn(..) => Type::i8p(),\n         ty::ty_closure(..) => Type::struct_([Type::i8p(), Type::i8p()], false),\n         ty::ty_trait(_, _, store, _, _) => Type::opaque_trait(cx, store),\n \n-        ty::ty_estr(ty::vstore_fixed(size)) => Type::array(&Type::i8(), size as u64),\n-        ty::ty_evec(mt, ty::vstore_fixed(size)) => {\n+        ty::ty_str(ty::vstore_fixed(size)) => Type::array(&Type::i8(), size as u64),\n+        ty::ty_vec(mt, ty::vstore_fixed(size)) => {\n             Type::array(&sizing_type_of(cx, mt.ty), size as u64)\n         }\n \n@@ -214,7 +218,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n       ty::ty_int(t) => Type::int_from_ty(cx, t),\n       ty::ty_uint(t) => Type::uint_from_ty(cx, t),\n       ty::ty_float(t) => Type::float_from_ty(t),\n-      ty::ty_estr(ty::vstore_uniq) => {\n+      ty::ty_str(ty::vstore_uniq) => {\n         Type::vec(cx.sess.targ_cfg.arch, &Type::i8()).ptr_to()\n       }\n       ty::ty_enum(did, ref substs) => {\n@@ -226,12 +230,12 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n         let name = llvm_type_name(cx, an_enum, did, substs.tps);\n         adt::incomplete_type_of(cx, repr, name)\n       }\n-      ty::ty_estr(ty::vstore_box) => {\n+      ty::ty_str(ty::vstore_box) => {\n         Type::smart_ptr(cx,\n                         &Type::vec(cx.sess.targ_cfg.arch,\n                                    &Type::i8())).ptr_to()\n       }\n-      ty::ty_evec(ref mt, ty::vstore_box) => {\n+      ty::ty_vec(ref mt, ty::vstore_box) => {\n           let e_ty = type_of(cx, mt.ty);\n           let v_ty = Type::vec(cx.sess.targ_cfg.arch, &e_ty);\n           Type::smart_ptr(cx, &v_ty).ptr_to()\n@@ -240,7 +244,6 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n           let ty = type_of(cx, typ);\n           Type::smart_ptr(cx, &ty).ptr_to()\n       }\n-      ty::ty_opaque_box => Type::opaque_box(cx).ptr_to(),\n       ty::ty_uniq(ref mt) => {\n           let ty = type_of(cx, mt.ty);\n           if ty::type_contents(cx.tcx, mt.ty).owns_managed() {\n@@ -249,7 +252,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n               ty.ptr_to()\n           }\n       }\n-      ty::ty_evec(ref mt, ty::vstore_uniq) => {\n+      ty::ty_vec(ref mt, ty::vstore_uniq) => {\n           let ty = type_of(cx, mt.ty);\n           let ty = Type::vec(cx.sess.targ_cfg.arch, &ty);\n           if ty::type_contents(cx.tcx, mt.ty).owns_managed() {\n@@ -265,30 +268,30 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n       ty::ty_ptr(ref mt) => type_of(cx, mt.ty).ptr_to(),\n       ty::ty_rptr(_, ref mt) => type_of(cx, mt.ty).ptr_to(),\n \n-      ty::ty_evec(ref mt, ty::vstore_slice(_)) => {\n+      ty::ty_vec(ref mt, ty::vstore_slice(_)) => {\n           let p_ty = type_of(cx, mt.ty).ptr_to();\n           let u_ty = Type::uint_from_ty(cx, ast::TyU);\n           Type::struct_([p_ty, u_ty], false)\n       }\n \n-      ty::ty_estr(ty::vstore_slice(_)) => {\n+      ty::ty_str(ty::vstore_slice(_)) => {\n           // This means we get a nicer name in the output\n           cx.tn.find_type(\"str_slice\").unwrap()\n       }\n \n-      ty::ty_estr(ty::vstore_fixed(n)) => {\n+      ty::ty_str(ty::vstore_fixed(n)) => {\n           Type::array(&Type::i8(), (n + 1u) as u64)\n       }\n \n-      ty::ty_evec(ref mt, ty::vstore_fixed(n)) => {\n+      ty::ty_vec(ref mt, ty::vstore_fixed(n)) => {\n           Type::array(&type_of(cx, mt.ty), n as u64)\n       }\n \n       ty::ty_bare_fn(_) => {\n-          type_of_fn_from_ty(cx, t).ptr_to()\n+          type_of_fn_from_ty(cx, None, t).ptr_to()\n       }\n       ty::ty_closure(_) => {\n-          let ty = type_of_fn_from_ty(cx, t);\n+          let ty = type_of_fn_from_ty(cx, None, t);\n           Type::func_pair(cx, &ty)\n       }\n       ty::ty_trait(_, _, store, _, _) => Type::opaque_trait(cx, store),"}, {"sha": "91ac5f9f3b4d32d50106c0f15e0c642d05bc0c7b", "filename": "src/librustc/middle/trans/uniq.rs", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/99df8a3f158aebc76a3bd3a87e367a9d01108633/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99df8a3f158aebc76a3bd3a87e367a9d01108633/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Funiq.rs?ref=99df8a3f158aebc76a3bd3a87e367a9d01108633", "patch": "@@ -1,39 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-use lib::llvm::ValueRef;\n-use middle::trans::base::*;\n-use middle::trans::build::*;\n-use middle::trans::common::*;\n-use middle::trans::datum::immediate_rvalue;\n-use middle::trans::glue;\n-use middle::ty;\n-\n-pub fn make_free_glue<'a>(\n-                      bcx: &'a Block<'a>,\n-                      vptrptr: ValueRef,\n-                      box_ty: ty::t)\n-                      -> &'a Block<'a> {\n-    let _icx = push_ctxt(\"uniq::make_free_glue\");\n-    let box_datum = immediate_rvalue(Load(bcx, vptrptr), box_ty);\n-\n-    let not_null = IsNotNull(bcx, box_datum.val);\n-    with_cond(bcx, not_null, |bcx| {\n-        let body_datum = box_datum.box_body(bcx);\n-        let bcx = glue::drop_ty(bcx, body_datum.to_ref_llval(bcx),\n-                                body_datum.ty);\n-        if ty::type_contents(bcx.tcx(), box_ty).owns_managed() {\n-            glue::trans_free(bcx, box_datum.val)\n-        } else {\n-            glue::trans_exchange_free(bcx, box_datum.val)\n-        }\n-    })\n-}"}, {"sha": "46dc1bb68b3a048652dbfc2ac802195749d2d6dc", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 68, "deletions": 88, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -151,14 +151,6 @@ pub enum TraitStore {\n     RegionTraitStore(Region),   // &Trait\n }\n \n-// XXX: This should probably go away at some point. Maybe after destructors\n-// do?\n-#[deriving(Clone, Eq, Encodable, Decodable)]\n-pub enum SelfMode {\n-    ByCopy,\n-    ByRef,\n-}\n-\n pub struct field_ty {\n     name: Name,\n     id: DefId,\n@@ -635,11 +627,11 @@ pub enum sty {\n     ty_int(ast::IntTy),\n     ty_uint(ast::UintTy),\n     ty_float(ast::FloatTy),\n-    ty_estr(vstore),\n+    ty_str(vstore),\n     ty_enum(DefId, substs),\n     ty_box(t),\n     ty_uniq(mt),\n-    ty_evec(mt, vstore),\n+    ty_vec(mt, vstore),\n     ty_ptr(mt),\n     ty_rptr(Region, mt),\n     ty_bare_fn(BareFnTy),\n@@ -659,8 +651,7 @@ pub enum sty {\n \n     // \"Fake\" types, used for trans purposes\n     ty_type, // type_desc*\n-    ty_opaque_box, // used by monomorphizer to represent any @ box\n-    ty_opaque_closure_ptr(Sigil), // ptr to env for ||, @fn, ~fn\n+    ty_opaque_closure_ptr(Sigil), // ptr to env for || and proc\n     ty_unboxed_vec(mt),\n }\n \n@@ -1070,16 +1061,15 @@ pub fn mk_t(cx: ctxt, st: sty) -> t {\n         return f;\n     }\n     match &st {\n-      &ty_estr(vstore_slice(r)) => {\n+      &ty_str(vstore_slice(r)) => {\n         flags |= rflags(r);\n       }\n-      &ty_evec(ref mt, vstore_slice(r)) => {\n+      &ty_vec(ref mt, vstore_slice(r)) => {\n         flags |= rflags(r);\n         flags |= get(mt.ty).flags;\n       }\n       &ty_nil | &ty_bool | &ty_char | &ty_int(_) | &ty_float(_) | &ty_uint(_) |\n-      &ty_estr(_) | &ty_type | &ty_opaque_closure_ptr(_) |\n-      &ty_opaque_box => (),\n+      &ty_str(_) | &ty_type | &ty_opaque_closure_ptr(_) => {}\n       // You might think that we could just return ty_err for\n       // any type containing ty_err as a component, and get\n       // rid of the has_ty_err flag -- likewise for ty_bot (with\n@@ -1103,7 +1093,7 @@ pub fn mk_t(cx: ctxt, st: sty) -> t {\n           }\n       }\n       &ty_box(ref tt) => flags |= get(*tt).flags,\n-      &ty_uniq(ref m) | &ty_evec(ref m, _) | &ty_ptr(ref m) |\n+      &ty_uniq(ref m) | &ty_vec(ref m, _) | &ty_ptr(ref m) |\n       &ty_unboxed_vec(ref m) => {\n         flags |= get(m.ty).flags;\n       }\n@@ -1234,8 +1224,8 @@ pub fn mk_mach_float(tm: ast::FloatTy) -> t {\n #[inline]\n pub fn mk_char() -> t { mk_prim_t(&primitives::TY_CHAR) }\n \n-pub fn mk_estr(cx: ctxt, t: vstore) -> t {\n-    mk_t(cx, ty_estr(t))\n+pub fn mk_str(cx: ctxt, t: vstore) -> t {\n+    mk_t(cx, ty_str(t))\n }\n \n pub fn mk_enum(cx: ctxt, did: ast::DefId, substs: substs) -> t {\n@@ -1278,8 +1268,8 @@ pub fn mk_nil_ptr(cx: ctxt) -> t {\n     mk_ptr(cx, mt {ty: mk_nil(), mutbl: ast::MutImmutable})\n }\n \n-pub fn mk_evec(cx: ctxt, tm: mt, t: vstore) -> t {\n-    mk_t(cx, ty_evec(tm, t))\n+pub fn mk_vec(cx: ctxt, tm: mt, t: vstore) -> t {\n+    mk_t(cx, ty_vec(tm, t))\n }\n \n pub fn mk_unboxed_vec(cx: ctxt, tm: mt) -> t {\n@@ -1354,8 +1344,6 @@ pub fn mk_opaque_closure_ptr(cx: ctxt, sigil: ast::Sigil) -> t {\n     mk_t(cx, ty_opaque_closure_ptr(sigil))\n }\n \n-pub fn mk_opaque_box(cx: ctxt) -> t { mk_t(cx, ty_opaque_box) }\n-\n pub fn walk_ty(ty: t, f: |t|) {\n     maybe_walk_ty(ty, |t| { f(t); true });\n }\n@@ -1366,13 +1354,10 @@ pub fn maybe_walk_ty(ty: t, f: |t| -> bool) {\n     }\n     match get(ty).sty {\n       ty_nil | ty_bot | ty_bool | ty_char | ty_int(_) | ty_uint(_) | ty_float(_) |\n-      ty_estr(_) | ty_type | ty_opaque_box | ty_self(_) |\n-      ty_opaque_closure_ptr(_) | ty_infer(_) | ty_param(_) | ty_err => {\n-      }\n-      ty_box(ref ty) => {\n-        maybe_walk_ty(*ty, f);\n-      }\n-      ty_evec(ref tm, _) | ty_unboxed_vec(ref tm) | ty_ptr(ref tm) |\n+      ty_str(_) | ty_type | ty_self(_) |\n+      ty_opaque_closure_ptr(_) | ty_infer(_) | ty_param(_) | ty_err => {}\n+      ty_box(ref ty) => maybe_walk_ty(*ty, f),\n+      ty_vec(ref tm, _) | ty_unboxed_vec(ref tm) | ty_ptr(ref tm) |\n       ty_rptr(_, ref tm) | ty_uniq(ref tm) => {\n         maybe_walk_ty(tm.ty, f);\n       }\n@@ -1520,16 +1505,16 @@ pub fn type_is_self(ty: t) -> bool {\n pub fn type_is_structural(ty: t) -> bool {\n     match get(ty).sty {\n       ty_struct(..) | ty_tup(_) | ty_enum(..) | ty_closure(_) | ty_trait(..) |\n-      ty_evec(_, vstore_fixed(_)) | ty_estr(vstore_fixed(_)) |\n-      ty_evec(_, vstore_slice(_)) | ty_estr(vstore_slice(_))\n+      ty_vec(_, vstore_fixed(_)) | ty_str(vstore_fixed(_)) |\n+      ty_vec(_, vstore_slice(_)) | ty_str(vstore_slice(_))\n       => true,\n       _ => false\n     }\n }\n \n pub fn type_is_sequence(ty: t) -> bool {\n     match get(ty).sty {\n-      ty_estr(_) | ty_evec(_, _) => true,\n+      ty_str(_) | ty_vec(_, _) => true,\n       _ => false\n     }\n }\n@@ -1543,15 +1528,15 @@ pub fn type_is_simd(cx: ctxt, ty: t) -> bool {\n \n pub fn type_is_str(ty: t) -> bool {\n     match get(ty).sty {\n-      ty_estr(_) => true,\n+      ty_str(_) => true,\n       _ => false\n     }\n }\n \n pub fn sequence_element_type(cx: ctxt, ty: t) -> t {\n     match get(ty).sty {\n-      ty_estr(_) => return mk_mach_uint(ast::TyU8),\n-      ty_evec(mt, _) | ty_unboxed_vec(mt) => return mt.ty,\n+      ty_str(_) => return mk_mach_uint(ast::TyU8),\n+      ty_vec(mt, _) | ty_unboxed_vec(mt) => return mt.ty,\n       _ => cx.sess.bug(\"sequence_element_type called on non-sequence value\"),\n     }\n }\n@@ -1592,8 +1577,7 @@ pub fn type_is_box(ty: t) -> bool {\n \n pub fn type_is_boxed(ty: t) -> bool {\n     match get(ty).sty {\n-      ty_box(_) | ty_opaque_box |\n-      ty_evec(_, vstore_box) | ty_estr(vstore_box) => true,\n+      ty_box(_) | ty_vec(_, vstore_box) | ty_str(vstore_box) => true,\n       _ => false\n     }\n }\n@@ -1607,7 +1591,7 @@ pub fn type_is_region_ptr(ty: t) -> bool {\n \n pub fn type_is_slice(ty: t) -> bool {\n     match get(ty).sty {\n-      ty_evec(_, vstore_slice(_)) | ty_estr(vstore_slice(_)) => true,\n+      ty_vec(_, vstore_slice(_)) | ty_str(vstore_slice(_)) => true,\n       _ => return false\n     }\n }\n@@ -1628,17 +1612,17 @@ pub fn type_is_unsafe_ptr(ty: t) -> bool {\n \n pub fn type_is_vec(ty: t) -> bool {\n     return match get(ty).sty {\n-          ty_evec(_, _) | ty_unboxed_vec(_) => true,\n-          ty_estr(_) => true,\n+          ty_vec(_, _) | ty_unboxed_vec(_) => true,\n+          ty_str(_) => true,\n           _ => false\n         };\n }\n \n pub fn type_is_unique(ty: t) -> bool {\n     match get(ty).sty {\n         ty_uniq(_) |\n-        ty_evec(_, vstore_uniq) |\n-        ty_estr(vstore_uniq) |\n+        ty_vec(_, vstore_uniq) |\n+        ty_str(vstore_uniq) |\n         ty_opaque_closure_ptr(ast::OwnedSigil) => true,\n         _ => return false\n     }\n@@ -1699,7 +1683,7 @@ fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n     maybe_walk_ty(ty, |ty| {\n         let old_encountered_box = encountered_box;\n         let result = match get(ty).sty {\n-          ty_box(_) | ty_opaque_box => {\n+          ty_box(_) => {\n             encountered_box = true;\n             true\n           }\n@@ -1719,10 +1703,10 @@ fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n             !needs_unwind_cleanup\n           }\n           ty_uniq(_) |\n-          ty_estr(vstore_uniq) |\n-          ty_estr(vstore_box) |\n-          ty_evec(_, vstore_uniq) |\n-          ty_evec(_, vstore_box)\n+          ty_str(vstore_uniq) |\n+          ty_str(vstore_box) |\n+          ty_vec(_, vstore_uniq) |\n+          ty_vec(_, vstore_box)\n           => {\n             // Once we're inside a box, the annihilator will find\n             // it and destroy it.\n@@ -2031,7 +2015,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 TC::None\n             }\n \n-            ty_estr(vstore_uniq) => {\n+            ty_str(vstore_uniq) => {\n                 TC::OwnsOwned\n             }\n \n@@ -2060,32 +2044,32 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 tc_mt(cx, mt, cache).owned_pointer()\n             }\n \n-            ty_evec(mt, vstore_uniq) => {\n+            ty_vec(mt, vstore_uniq) => {\n                 tc_mt(cx, mt, cache).owned_pointer()\n             }\n \n-            ty_evec(mt, vstore_box) => {\n+            ty_vec(mt, vstore_box) => {\n                 tc_mt(cx, mt, cache).managed_pointer()\n             }\n \n-            ty_evec(ref mt, vstore_slice(r)) => {\n+            ty_vec(ref mt, vstore_slice(r)) => {\n                 tc_ty(cx, mt.ty, cache).reference(\n                     borrowed_contents(r, mt.mutbl))\n             }\n \n-            ty_evec(mt, vstore_fixed(_)) => {\n+            ty_vec(mt, vstore_fixed(_)) => {\n                 tc_mt(cx, mt, cache)\n             }\n \n-            ty_estr(vstore_box) => {\n+            ty_str(vstore_box) => {\n                 TC::Managed\n             }\n \n-            ty_estr(vstore_slice(r)) => {\n+            ty_str(vstore_slice(r)) => {\n                 borrowed_contents(r, ast::MutImmutable)\n             }\n \n-            ty_estr(vstore_fixed(_)) => {\n+            ty_str(vstore_fixed(_)) => {\n                 TC::None\n             }\n \n@@ -2145,8 +2129,6 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 // times.\n                 TC::All\n             }\n-\n-            ty_opaque_box => TC::Managed,\n             ty_unboxed_vec(mt) => TC::InteriorUnsized | tc_mt(cx, mt, cache),\n             ty_opaque_closure_ptr(sigil) => {\n                 match sigil {\n@@ -2324,17 +2306,16 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n             ty_int(_) |\n             ty_uint(_) |\n             ty_float(_) |\n-            ty_estr(_) |\n+            ty_str(_) |\n             ty_bare_fn(_) |\n             ty_closure(_) |\n             ty_infer(_) |\n             ty_err |\n             ty_param(_) |\n             ty_self(_) |\n             ty_type |\n-            ty_opaque_box |\n             ty_opaque_closure_ptr(_) |\n-            ty_evec(_, _) |\n+            ty_vec(_, _) |\n             ty_unboxed_vec(_) => {\n                 false\n             }\n@@ -2431,7 +2412,7 @@ pub fn type_structurally_contains(cx: ctxt, ty: t, test: |x: &sty| -> bool)\n         }\n         return false;\n       }\n-      ty_evec(ref mt, vstore_fixed(_)) => {\n+      ty_vec(ref mt, vstore_fixed(_)) => {\n         return type_structurally_contains(cx, mt.ty, test);\n       }\n       _ => return false\n@@ -2442,8 +2423,8 @@ pub fn type_structurally_contains_uniques(cx: ctxt, ty: t) -> bool {\n     return type_structurally_contains(cx, ty, |sty| {\n         match *sty {\n           ty_uniq(_) |\n-          ty_evec(_, vstore_uniq) |\n-          ty_estr(vstore_uniq) => true,\n+          ty_vec(_, vstore_uniq) |\n+          ty_str(vstore_uniq) => true,\n           _ => false,\n         }\n     });\n@@ -2513,9 +2494,9 @@ pub fn type_is_pod(cx: ctxt, ty: t) -> bool {\n       ty_type | ty_ptr(_) | ty_bare_fn(_) => result = true,\n       // Boxed types\n       ty_box(_) | ty_uniq(_) | ty_closure(_) |\n-      ty_estr(vstore_uniq) | ty_estr(vstore_box) |\n-      ty_evec(_, vstore_uniq) | ty_evec(_, vstore_box) |\n-      ty_trait(_, _, _, _, _) | ty_rptr(_,_) | ty_opaque_box => result = false,\n+      ty_str(vstore_uniq) | ty_str(vstore_box) |\n+      ty_vec(_, vstore_uniq) | ty_vec(_, vstore_box) |\n+      ty_trait(_, _, _, _, _) | ty_rptr(_,_) => result = false,\n       // Structural types\n       ty_enum(did, ref substs) => {\n         let variants = enum_variants(cx, did);\n@@ -2532,8 +2513,8 @@ pub fn type_is_pod(cx: ctxt, ty: t) -> bool {\n       ty_tup(ref elts) => {\n         for elt in elts.iter() { if !type_is_pod(cx, *elt) { result = false; } }\n       }\n-      ty_estr(vstore_fixed(_)) => result = true,\n-      ty_evec(ref mt, vstore_fixed(_)) | ty_unboxed_vec(ref mt) => {\n+      ty_str(vstore_fixed(_)) => result = true,\n+      ty_vec(ref mt, vstore_fixed(_)) | ty_unboxed_vec(ref mt) => {\n         result = type_is_pod(cx, mt.ty);\n       }\n       ty_param(_) => result = false,\n@@ -2547,7 +2528,7 @@ pub fn type_is_pod(cx: ctxt, ty: t) -> bool {\n         });\n       }\n \n-      ty_estr(vstore_slice(..)) | ty_evec(_, vstore_slice(..)) => {\n+      ty_str(vstore_slice(..)) | ty_vec(_, vstore_slice(..)) => {\n         result = false;\n       }\n \n@@ -2652,8 +2633,8 @@ pub fn index(t: t) -> Option<mt> {\n \n pub fn index_sty(sty: &sty) -> Option<mt> {\n     match *sty {\n-      ty_evec(mt, _) => Some(mt),\n-      ty_estr(_) => Some(mt {ty: mk_u8(), mutbl: ast::MutImmutable}),\n+      ty_vec(mt, _) => Some(mt),\n+      ty_str(_) => Some(mt {ty: mk_u8(), mutbl: ast::MutImmutable}),\n       _ => None\n     }\n }\n@@ -2765,8 +2746,8 @@ pub fn is_fn_ty(fty: t) -> bool {\n \n pub fn ty_vstore(ty: t) -> vstore {\n     match get(ty).sty {\n-        ty_evec(_, vstore) => vstore,\n-        ty_estr(vstore) => vstore,\n+        ty_vec(_, vstore) => vstore,\n+        ty_str(vstore) => vstore,\n         ref s => fail!(\"ty_vstore() called on invalid sty: {:?}\", s)\n     }\n }\n@@ -2776,8 +2757,8 @@ pub fn ty_region(tcx: ctxt,\n                  ty: t) -> Region {\n     match get(ty).sty {\n         ty_rptr(r, _) => r,\n-        ty_evec(_, vstore_slice(r)) => r,\n-        ty_estr(vstore_slice(r)) => r,\n+        ty_vec(_, vstore_slice(r)) => r,\n+        ty_str(vstore_slice(r)) => r,\n         ref s => {\n             tcx.sess.span_bug(\n                 span,\n@@ -2962,12 +2943,12 @@ pub fn adjust_ty(cx: ctxt,\n                   r: Region, m: ast::Mutability,\n                   ty: ty::t) -> ty::t {\n         match get(ty).sty {\n-            ty_evec(mt, _) => {\n-                ty::mk_evec(cx, mt {ty: mt.ty, mutbl: m}, vstore_slice(r))\n+            ty_vec(mt, _) => {\n+                ty::mk_vec(cx, mt {ty: mt.ty, mutbl: m}, vstore_slice(r))\n             }\n \n-            ty_estr(_) => {\n-                ty::mk_estr(cx, vstore_slice(r))\n+            ty_str(_) => {\n+                ty::mk_str(cx, vstore_slice(r))\n             }\n \n             ref s => {\n@@ -3344,15 +3325,15 @@ pub fn occurs_check(tcx: ctxt, sp: Span, vid: TyVid, rt: t) {\n pub fn ty_sort_str(cx: ctxt, t: t) -> ~str {\n     match get(t).sty {\n       ty_nil | ty_bot | ty_bool | ty_char | ty_int(_) |\n-      ty_uint(_) | ty_float(_) | ty_estr(_) |\n-      ty_type | ty_opaque_box | ty_opaque_closure_ptr(_) => {\n+      ty_uint(_) | ty_float(_) | ty_str(_) |\n+      ty_type | ty_opaque_closure_ptr(_) => {\n         ::util::ppaux::ty_to_str(cx, t)\n       }\n \n       ty_enum(id, _) => format!(\"enum {}\", item_path_str(cx, id)),\n       ty_box(_) => ~\"@-ptr\",\n       ty_uniq(_) => ~\"~-ptr\",\n-      ty_evec(_, _) => ~\"vector\",\n+      ty_vec(_, _) => ~\"vector\",\n       ty_unboxed_vec(_) => ~\"unboxed vector\",\n       ty_ptr(_) => ~\"*-ptr\",\n       ty_rptr(_, _) => ~\"&-ptr\",\n@@ -4814,7 +4795,7 @@ pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: @str) -> u64 {\n                 hash.input([6]);\n                 iter(&mut hash, &f);\n             }\n-            ty_estr(v) => {\n+            ty_str(v) => {\n                 hash.input([7]);\n                 vstore(&mut hash, v);\n             }\n@@ -4829,7 +4810,7 @@ pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: @str) -> u64 {\n                 hash.input([10]);\n                 mt(&mut hash, m);\n             }\n-            ty_evec(m, v) => {\n+            ty_vec(m, v) => {\n                 hash.input([11]);\n                 mt(&mut hash, m);\n                 vstore(&mut hash, v);\n@@ -4890,13 +4871,12 @@ pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: @str) -> u64 {\n             ty_infer(_) => unreachable!(),\n             ty_err => hash.input([23]),\n             ty_type => hash.input([24]),\n-            ty_opaque_box => hash.input([25]),\n             ty_opaque_closure_ptr(s) => {\n-                hash.input([26]);\n+                hash.input([25]);\n                 iter(&mut hash, &s);\n             }\n             ty_unboxed_vec(m) => {\n-                hash.input([27]);\n+                hash.input([26]);\n                 mt(&mut hash, m);\n             }\n         }"}, {"sha": "bd1f091b9d6aab8960de413aa4a2db990cd91bac", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -152,9 +152,8 @@ pub fn super_fold_sty<T:TypeFolder>(this: &mut T,\n         ty::ty_unboxed_vec(ref tm) => {\n             ty::ty_unboxed_vec(this.fold_mt(tm))\n         }\n-        ty::ty_evec(ref tm, vst) => {\n-            ty::ty_evec(this.fold_mt(tm),\n-                        this.fold_vstore(vst))\n+        ty::ty_vec(ref tm, vst) => {\n+            ty::ty_vec(this.fold_mt(tm), this.fold_vstore(vst))\n         }\n         ty::ty_enum(tid, ref substs) => {\n             ty::ty_enum(tid, this.fold_substs(substs))\n@@ -184,14 +183,14 @@ pub fn super_fold_sty<T:TypeFolder>(this: &mut T,\n             ty::ty_struct(did,\n                           this.fold_substs(substs))\n         }\n-        ty::ty_estr(vst) => {\n-            ty::ty_estr(this.fold_vstore(vst))\n+        ty::ty_str(vst) => {\n+            ty::ty_str(this.fold_vstore(vst))\n         }\n         ty::ty_nil | ty::ty_bot | ty::ty_bool | ty::ty_char |\n         ty::ty_int(_) | ty::ty_uint(_) |\n         ty::ty_float(_) | ty::ty_type |\n         ty::ty_opaque_closure_ptr(_) |\n-        ty::ty_err | ty::ty_opaque_box | ty::ty_infer(_) |\n+        ty::ty_err | ty::ty_infer(_) |\n         ty::ty_param(..) | ty::ty_self(_) => {\n             (*sty).clone()\n         }"}, {"sha": "74e4c969292507f32dd8d7ea0a2adde15f2214ed", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -293,8 +293,8 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n         ty::mt {ty: ast_ty_to_ty(this, rscope, mt.ty), mutbl: mt.mutbl}\n     }\n \n-    // Handle @, ~, and & being able to mean estrs and evecs.\n-    // If a_seq_ty is a str or a vec, make it an estr/evec.\n+    // Handle @, ~, and & being able to mean strs and vecs.\n+    // If a_seq_ty is a str or a vec, make it an str/vec.\n     // Also handle first-class trait types.\n     fn mk_pointer<AC:AstConv,\n                   RS:RegionScope>(\n@@ -314,7 +314,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                     mt = ty::mt { ty: mt.ty, mutbl: a_seq_ty.mutbl };\n                 }\n                 debug!(\"&[]: vst={:?}\", vst);\n-                return ty::mk_evec(tcx, mt, vst);\n+                return ty::mk_vec(tcx, mt, vst);\n             }\n             ast::TyPath(ref path, ref bounds, id) => {\n                 // Note that the \"bounds must be empty if path is not a trait\"\n@@ -324,7 +324,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                 match def_map.get().find(&id) {\n                     Some(&ast::DefPrimTy(ast::TyStr)) if a_seq_ty.mutbl == ast::MutImmutable => {\n                         check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n-                        return ty::mk_estr(tcx, vst);\n+                        return ty::mk_str(tcx, vst);\n                     }\n                     Some(&ast::DefTrait(trait_def_id)) => {\n                         let result = ast_path_to_trait_ref(\n@@ -415,7 +415,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n       ast::TyVec(ty) => {\n         tcx.sess.span_err(ast_ty.span, \"bare `[]` is not a type\");\n         // return /something/ so they can at least get more errors\n-        ty::mk_evec(tcx, ast_ty_to_mt(this, rscope, ty), ty::vstore_uniq)\n+        ty::mk_vec(tcx, ast_ty_to_mt(this, rscope, ty), ty::vstore_uniq)\n       }\n       ast::TyPtr(ref mt) => {\n         ty::mk_ptr(tcx, ast_mt_to_mt(this, rscope, mt))\n@@ -519,7 +519,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                 tcx.sess.span_err(ast_ty.span,\n                                   \"bare `str` is not a type\");\n                 // return /something/ so they can at least get more errors\n-                ty::mk_estr(tcx, ty::vstore_uniq)\n+                ty::mk_str(tcx, ty::vstore_uniq)\n               }\n             }\n           }\n@@ -552,11 +552,11 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n           Ok(ref r) => {\n             match *r {\n               const_eval::const_int(i) =>\n-                ty::mk_evec(tcx, ast_ty_to_mt(this, rscope, ty),\n-                            ty::vstore_fixed(i as uint)),\n+                ty::mk_vec(tcx, ast_ty_to_mt(this, rscope, ty),\n+                           ty::vstore_fixed(i as uint)),\n               const_eval::const_uint(i) =>\n-                ty::mk_evec(tcx, ast_ty_to_mt(this, rscope, ty),\n-                            ty::vstore_fixed(i as uint)),\n+                ty::mk_vec(tcx, ast_ty_to_mt(this, rscope, ty),\n+                           ty::vstore_fixed(i as uint)),\n               _ => {\n                 tcx.sess.span_fatal(\n                     ast_ty.span, \"expected constant expr for vector length\");"}, {"sha": "efd632dc80ac191380229eaea10217f02e84093c", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -602,7 +602,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n         let (elt_type, region_var) = match *structure_of(fcx,\n                                                          pat.span,\n                                                          expected) {\n-          ty::ty_evec(mt, vstore) => {\n+          ty::ty_vec(mt, vstore) => {\n             let region_var = match vstore {\n                 ty::vstore_slice(r) => r,\n                 ty::vstore_box | ty::vstore_uniq | ty::vstore_fixed(_) => {\n@@ -643,7 +643,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n         }\n         match slice {\n             Some(slice_pat) => {\n-                let slice_ty = ty::mk_evec(tcx,\n+                let slice_ty = ty::mk_vec(tcx,\n                     ty::mt {ty: elt_type.ty, mutbl: elt_type.mutbl},\n                     ty::vstore_slice(region_var)\n                 );"}, {"sha": "00f8eb6daebb398dc390d1dabcde988d1239f89e", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 19, "deletions": 29, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -648,11 +648,11 @@ impl<'a> LookupContext<'a> {\n                      autoderefs: autoderefs+1,\n                      autoref: Some(ty::AutoPtr(region, self_mt.mutbl))}))\n             }\n-            ty::ty_evec(self_mt, vstore_slice(_)) => {\n+            ty::ty_vec(self_mt, vstore_slice(_)) => {\n                 let region =\n                     self.infcx().next_region_var(\n                         infer::Autoref(self.expr.span));\n-                (ty::mk_evec(tcx, self_mt, vstore_slice(region)),\n+                (ty::mk_vec(tcx, self_mt, vstore_slice(region)),\n                  ty::AutoDerefRef(ty::AutoDerefRef {\n                      autoderefs: autoderefs,\n                      autoref: Some(ty::AutoBorrowVec(region, self_mt.mutbl))}))\n@@ -699,26 +699,26 @@ impl<'a> LookupContext<'a> {\n         let tcx = self.tcx();\n         let sty = ty::get(self_ty).sty.clone();\n         match sty {\n-            ty_evec(mt, vstore_box) |\n-            ty_evec(mt, vstore_uniq) |\n-            ty_evec(mt, vstore_slice(_)) | // NDM(#3148)\n-            ty_evec(mt, vstore_fixed(_)) => {\n+            ty_vec(mt, vstore_box) |\n+            ty_vec(mt, vstore_uniq) |\n+            ty_vec(mt, vstore_slice(_)) | // NDM(#3148)\n+            ty_vec(mt, vstore_fixed(_)) => {\n                 // First try to borrow to a slice\n                 let entry = self.search_for_some_kind_of_autorefd_method(\n                     AutoBorrowVec, autoderefs, [MutImmutable, MutMutable],\n-                    |m,r| ty::mk_evec(tcx,\n-                                      ty::mt {ty:mt.ty, mutbl:m},\n-                                      vstore_slice(r)));\n+                    |m,r| ty::mk_vec(tcx,\n+                                     ty::mt {ty:mt.ty, mutbl:m},\n+                                     vstore_slice(r)));\n \n                 if entry.is_some() { return entry; }\n \n                 // Then try to borrow to a slice *and* borrow a pointer.\n                 self.search_for_some_kind_of_autorefd_method(\n                     AutoBorrowVecRef, autoderefs, [MutImmutable, MutMutable],\n                     |m,r| {\n-                        let slice_ty = ty::mk_evec(tcx,\n-                                                   ty::mt {ty:mt.ty, mutbl:m},\n-                                                   vstore_slice(r));\n+                        let slice_ty = ty::mk_vec(tcx,\n+                                                  ty::mt {ty:mt.ty, mutbl:m},\n+                                                  vstore_slice(r));\n                         // NB: we do not try to autoref to a mutable\n                         // pointer. That would be creating a pointer\n                         // to a temporary pointer (the borrowed\n@@ -728,19 +728,19 @@ impl<'a> LookupContext<'a> {\n                     })\n             }\n \n-            ty_estr(vstore_box) |\n-            ty_estr(vstore_uniq) |\n-            ty_estr(vstore_fixed(_)) => {\n+            ty_str(vstore_box) |\n+            ty_str(vstore_uniq) |\n+            ty_str(vstore_fixed(_)) => {\n                 let entry = self.search_for_some_kind_of_autorefd_method(\n                     AutoBorrowVec, autoderefs, [MutImmutable],\n-                    |_m,r| ty::mk_estr(tcx, vstore_slice(r)));\n+                    |_m,r| ty::mk_str(tcx, vstore_slice(r)));\n \n                 if entry.is_some() { return entry; }\n \n                 self.search_for_some_kind_of_autorefd_method(\n                     AutoBorrowVecRef, autoderefs, [MutImmutable],\n                     |m,r| {\n-                        let slice_ty = ty::mk_estr(tcx, vstore_slice(r));\n+                        let slice_ty = ty::mk_str(tcx, vstore_slice(r));\n                         ty::mk_rptr(tcx, r, ty::mt {ty:slice_ty, mutbl:m})\n                     })\n             }\n@@ -782,7 +782,7 @@ impl<'a> LookupContext<'a> {\n             ty_self(_) | ty_param(..) | ty_nil | ty_bot | ty_bool |\n             ty_char | ty_int(..) | ty_uint(..) |\n             ty_float(..) | ty_enum(..) | ty_ptr(..) | ty_struct(..) | ty_tup(..) |\n-            ty_estr(..) | ty_evec(..) | ty_trait(..) | ty_closure(..) => {\n+            ty_str(..) | ty_vec(..) | ty_trait(..) | ty_closure(..) => {\n                 self.search_for_some_kind_of_autorefd_method(\n                     AutoPtr, autoderefs, [MutImmutable, MutMutable],\n                     |m,r| ty::mk_rptr(tcx, r, ty::mt {ty:self_ty, mutbl:m}))\n@@ -791,7 +791,7 @@ impl<'a> LookupContext<'a> {\n             ty_err => None,\n \n             ty_opaque_closure_ptr(_) | ty_unboxed_vec(_) |\n-            ty_opaque_box | ty_type | ty_infer(TyVar(_)) => {\n+            ty_type | ty_infer(TyVar(_)) => {\n                 self.bug(format!(\"Unexpected type: {}\",\n                               self.ty_to_str(self_ty)));\n             }\n@@ -1020,8 +1020,6 @@ impl<'a> LookupContext<'a> {\n         });\n         debug!(\"after replacing bound regions, fty={}\", self.ty_to_str(fty));\n \n-        let self_mode = get_mode_from_explicit_self(candidate.method_ty.explicit_self);\n-\n         // before we only checked whether self_ty could be a subtype\n         // of rcvr_ty; now we actually make it so (this may cause\n         // variables to unify etc).  Since we checked beforehand, and\n@@ -1041,7 +1039,6 @@ impl<'a> LookupContext<'a> {\n         self.fcx.write_substs(self.callee_id, all_substs);\n         method_map_entry {\n             self_ty: transformed_self_ty,\n-            self_mode: self_mode,\n             explicit_self: candidate.method_ty.explicit_self,\n             origin: candidate.origin,\n         }\n@@ -1375,13 +1372,6 @@ impl<'a> LookupContext<'a> {\n     }\n }\n \n-pub fn get_mode_from_explicit_self(explicit_self: ast::ExplicitSelf_) -> SelfMode {\n-    match explicit_self {\n-        SelfValue(_) => ty::ByRef,\n-        _ => ty::ByCopy,\n-    }\n-}\n-\n impl Repr for RcvrMatchCondition {\n     fn repr(&self, tcx: ty::ctxt) -> ~str {\n         match *self {"}, {"sha": "242fa1faf9772730ce9fd657c1bac736d525fd23", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -1386,10 +1386,10 @@ pub fn check_lit(fcx: @FnCtxt, lit: &ast::Lit) -> ty::t {\n     let tcx = fcx.ccx.tcx;\n \n     match lit.node {\n-        ast::LitStr(..) => ty::mk_estr(tcx, ty::vstore_slice(ty::ReStatic)),\n+        ast::LitStr(..) => ty::mk_str(tcx, ty::vstore_slice(ty::ReStatic)),\n         ast::LitBinary(..) => {\n-            ty::mk_evec(tcx, ty::mt{ ty: ty::mk_u8(), mutbl: ast::MutImmutable },\n-                        ty::vstore_slice(ty::ReStatic))\n+            ty::mk_vec(tcx, ty::mt{ ty: ty::mk_u8(), mutbl: ast::MutImmutable },\n+                       ty::vstore_slice(ty::ReStatic))\n         }\n         ast::LitChar(_) => ty::mk_char(),\n         ast::LitInt(_, t) => ty::mk_mach_int(t),\n@@ -2629,7 +2629,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         let typ = match ev.node {\n           ast::ExprLit(@codemap::Spanned { node: ast::LitStr(..), .. }) => {\n             let tt = ast_expr_vstore_to_vstore(fcx, ev, vst);\n-            ty::mk_estr(tcx, tt)\n+            ty::mk_str(tcx, tt)\n           }\n           ast::ExprVec(ref args, mutbl) => {\n             let tt = ast_expr_vstore_to_vstore(fcx, ev, vst);\n@@ -2655,7 +2655,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n             } else if any_bot {\n                 ty::mk_bot()\n             } else {\n-                ty::mk_evec(tcx, ty::mt {ty: t, mutbl: mutability}, tt)\n+                ty::mk_vec(tcx, ty::mt {ty: t, mutbl: mutability}, tt)\n             }\n           }\n           ast::ExprRepeat(element, count_expr, mutbl) => {\n@@ -2674,7 +2674,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n             } else if ty::type_is_bot(arg_t) {\n                 ty::mk_bot()\n             } else {\n-                ty::mk_evec(tcx, ty::mt {ty: t, mutbl: mutability}, tt)\n+                ty::mk_vec(tcx, ty::mt {ty: t, mutbl: mutability}, tt)\n             }\n           }\n           _ =>\n@@ -3166,7 +3166,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n \n                         fn is_vec(t: ty::t) -> bool {\n                             match ty::get(t).sty {\n-                                ty::ty_evec(_,_) => true,\n+                                ty::ty_vec(..) => true,\n                                 _ => false\n                             }\n                         }\n@@ -3223,8 +3223,8 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         for e in args.iter() {\n             check_expr_has_type(fcx, *e, t);\n         }\n-        let typ = ty::mk_evec(tcx, ty::mt {ty: t, mutbl: mutbl},\n-                              ty::vstore_fixed(args.len()));\n+        let typ = ty::mk_vec(tcx, ty::mt {ty: t, mutbl: mutbl},\n+                             ty::vstore_fixed(args.len()));\n         fcx.write_ty(id, typ);\n       }\n       ast::ExprRepeat(element, count_expr, mutbl) => {\n@@ -3240,8 +3240,8 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n             fcx.write_bot(id);\n         }\n         else {\n-            let t = ty::mk_evec(tcx, ty::mt {ty: t, mutbl: mutbl},\n-                                ty::vstore_fixed(count));\n+            let t = ty::mk_vec(tcx, ty::mt {ty: t, mutbl: mutbl},\n+                               ty::vstore_fixed(count));\n             fcx.write_ty(id, t);\n         }\n       }"}, {"sha": "032c8f45753929d812e53405af99505b1d5105f2", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -677,8 +677,8 @@ fn constrain_index(rcx: &mut Rcx,\n \n     let r_index_expr = ty::ReScope(index_expr.id);\n     match ty::get(indexed_ty).sty {\n-        ty::ty_estr(ty::vstore_slice(r_ptr)) |\n-        ty::ty_evec(_, ty::vstore_slice(r_ptr)) => {\n+        ty::ty_str(ty::vstore_slice(r_ptr)) |\n+        ty::ty_vec(_, ty::vstore_slice(r_ptr)) => {\n             rcx.fcx.mk_subr(true, infer::IndexSlice(index_expr.span),\n                             r_index_expr, r_ptr);\n         }\n@@ -1215,22 +1215,22 @@ pub mod guarantor {\n     fn pointer_categorize(ty: ty::t) -> PointerCategorization {\n         match ty::get(ty).sty {\n             ty::ty_rptr(r, _) |\n-            ty::ty_evec(_, ty::vstore_slice(r)) |\n+            ty::ty_vec(_, ty::vstore_slice(r)) |\n             ty::ty_trait(_, _, ty::RegionTraitStore(r), _, _) |\n-            ty::ty_estr(ty::vstore_slice(r)) => {\n+            ty::ty_str(ty::vstore_slice(r)) => {\n                 BorrowedPointer(r)\n             }\n             ty::ty_uniq(..) |\n-            ty::ty_estr(ty::vstore_uniq) |\n+            ty::ty_str(ty::vstore_uniq) |\n             ty::ty_trait(_, _, ty::UniqTraitStore, _, _) |\n-            ty::ty_evec(_, ty::vstore_uniq) => {\n+            ty::ty_vec(_, ty::vstore_uniq) => {\n                 OwnedPointer\n             }\n             ty::ty_box(..) |\n             ty::ty_ptr(..) |\n-            ty::ty_evec(_, ty::vstore_box) |\n+            ty::ty_vec(_, ty::vstore_box) |\n             ty::ty_trait(_, _, ty::BoxTraitStore, _, _) |\n-            ty::ty_estr(ty::vstore_box) => {\n+            ty::ty_str(ty::vstore_box) => {\n                 OtherPointer\n             }\n             ty::ty_closure(ref closure_ty) => {"}, {"sha": "c8fde97e4d6b3915512def1344d3c0b3763e39ac", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -103,7 +103,7 @@ pub fn relate_nested_regions(tcx: ty::ctxt,\n         fn fold_ty(&mut self, ty: ty::t) -> ty::t {\n             match ty::get(ty).sty {\n                 ty::ty_rptr(r, ref mt) |\n-                ty::ty_evec(ref mt, ty::vstore_slice(r)) => {\n+                ty::ty_vec(ref mt, ty::vstore_slice(r)) => {\n                     self.relate(r);\n                     self.stack.push(r);\n                     ty_fold::super_fold_ty(self, mt.ty);"}, {"sha": "6e944e82a023a13845514eb9cf300bbb43100cdd", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -20,8 +20,8 @@ use metadata::csearch;\n use middle::ty::get;\n use middle::ty::{ImplContainer, lookup_item_type, subst};\n use middle::ty::{substs, t, ty_bool, ty_char, ty_bot, ty_box, ty_enum, ty_err};\n-use middle::ty::{ty_estr, ty_evec, ty_float, ty_infer, ty_int, ty_nil};\n-use middle::ty::{ty_opaque_box, ty_param, ty_param_bounds_and_ty, ty_ptr};\n+use middle::ty::{ty_str, ty_vec, ty_float, ty_infer, ty_int, ty_nil};\n+use middle::ty::{ty_param, ty_param_bounds_and_ty, ty_ptr};\n use middle::ty::{ty_rptr, ty_self, ty_struct, ty_trait, ty_tup};\n use middle::ty::{ty_type, ty_uint, ty_uniq, ty_bare_fn, ty_closure};\n use middle::ty::{ty_opaque_closure_ptr, ty_unboxed_vec};\n@@ -82,8 +82,8 @@ pub fn get_base_type(inference_context: @InferCtxt,\n         }\n \n         ty_nil | ty_bot | ty_bool | ty_char | ty_int(..) | ty_uint(..) | ty_float(..) |\n-        ty_estr(..) | ty_evec(..) | ty_bare_fn(..) | ty_closure(..) | ty_tup(..) |\n-        ty_infer(..) | ty_param(..) | ty_self(..) | ty_type | ty_opaque_box |\n+        ty_str(..) | ty_vec(..) | ty_bare_fn(..) | ty_closure(..) | ty_tup(..) |\n+        ty_infer(..) | ty_param(..) | ty_self(..) | ty_type |\n         ty_opaque_closure_ptr(..) | ty_unboxed_vec(..) | ty_err | ty_box(_) |\n         ty_uniq(_) | ty_ptr(_) | ty_rptr(_, _) => {\n             debug!(\"(getting base type) no base type; found {:?}\","}, {"sha": "6c4a82c628afd1ae4338852e415a3db8a1372803", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -107,13 +107,13 @@ impl Coerce {\n                 });\n             }\n \n-            ty::ty_estr(vstore_slice(_)) => {\n+            ty::ty_str(vstore_slice(_)) => {\n                 return self.unpack_actual_value(a, |sty_a| {\n                     self.coerce_borrowed_string(a, sty_a, b)\n                 });\n             }\n \n-            ty::ty_evec(mt_b, vstore_slice(_)) => {\n+            ty::ty_vec(mt_b, vstore_slice(_)) => {\n                 return self.unpack_actual_value(a, |sty_a| {\n                     self.coerce_borrowed_vector(a, sty_a, b, mt_b)\n                 });\n@@ -273,15 +273,15 @@ impl Coerce {\n                b.inf_str(self.get_ref().infcx));\n \n         match *sty_a {\n-            ty::ty_estr(vstore_box) |\n-            ty::ty_estr(vstore_uniq) => {}\n+            ty::ty_str(vstore_box) |\n+            ty::ty_str(vstore_uniq) => {}\n             _ => {\n                 return self.subtype(a, b);\n             }\n         };\n \n         let r_a = self.get_ref().infcx.next_region_var(Coercion(self.get_ref().trace));\n-        let a_borrowed = ty::mk_estr(self.get_ref().infcx.tcx, vstore_slice(r_a));\n+        let a_borrowed = ty::mk_str(self.get_ref().infcx.tcx, vstore_slice(r_a));\n         if_ok!(self.subtype(a_borrowed, b));\n         Ok(Some(@AutoDerefRef(AutoDerefRef {\n             autoderefs: 0,\n@@ -302,15 +302,15 @@ impl Coerce {\n         let sub = Sub(*self.get_ref());\n         let r_borrow = self.get_ref().infcx.next_region_var(Coercion(self.get_ref().trace));\n         let ty_inner = match *sty_a {\n-            ty::ty_evec(mt, _) => mt.ty,\n+            ty::ty_vec(mt, _) => mt.ty,\n             _ => {\n                 return self.subtype(a, b);\n             }\n         };\n \n-        let a_borrowed = ty::mk_evec(self.get_ref().infcx.tcx,\n-                                     mt {ty: ty_inner, mutbl: mt_b.mutbl},\n-                                     vstore_slice(r_borrow));\n+        let a_borrowed = ty::mk_vec(self.get_ref().infcx.tcx,\n+                                    mt {ty: ty_inner, mutbl: mt_b.mutbl},\n+                                    vstore_slice(r_borrow));\n         if_ok!(sub.tys(a_borrowed, b));\n         Ok(Some(@AutoDerefRef(AutoDerefRef {\n             autoderefs: 0,"}, {"sha": "01e19f011aa61354119f3be320e37af6220a3804", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -535,17 +535,17 @@ pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n           Ok(ty::mk_rptr(tcx, r, mt))\n       }\n \n-      (&ty::ty_evec(ref a_mt, vs_a), &ty::ty_evec(ref b_mt, vs_b)) => {\n+      (&ty::ty_vec(ref a_mt, vs_a), &ty::ty_vec(ref b_mt, vs_b)) => {\n         this.mts(a_mt, b_mt).and_then(|mt| {\n             this.vstores(ty::terr_vec, vs_a, vs_b).and_then(|vs| {\n-                Ok(ty::mk_evec(tcx, mt, vs))\n+                Ok(ty::mk_vec(tcx, mt, vs))\n             })\n         })\n       }\n \n-      (&ty::ty_estr(vs_a), &ty::ty_estr(vs_b)) => {\n+      (&ty::ty_str(vs_a), &ty::ty_str(vs_b)) => {\n         let vs = if_ok!(this.vstores(ty::terr_str, vs_a, vs_b));\n-        Ok(ty::mk_estr(tcx,vs))\n+        Ok(ty::mk_str(tcx,vs))\n       }\n \n       (&ty::ty_tup(ref as_), &ty::ty_tup(ref bs)) => {"}, {"sha": "0a7f7303a3724610202261a1580b96cdd245d818", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -148,9 +148,6 @@ pub struct method_map_entry {\n     // (FIXME #3446)\n     self_ty: ty::t,\n \n-    // the mode of `self`\n-    self_mode: ty::SelfMode,\n-\n     // the type of explicit self on the method\n     explicit_self: ast::ExplicitSelf_,\n "}, {"sha": "509836512c09dcfe8ebc905432f098ff3c6980ff", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -625,11 +625,11 @@ impl<'a> ConstraintContext<'a> {\n                 self.add_constraints_from_mt(mt, variance);\n             }\n \n-            ty::ty_estr(vstore) => {\n+            ty::ty_str(vstore) => {\n                 self.add_constraints_from_vstore(vstore, variance);\n             }\n \n-            ty::ty_evec(ref mt, vstore) => {\n+            ty::ty_vec(ref mt, vstore) => {\n                 self.add_constraints_from_vstore(vstore, variance);\n                 self.add_constraints_from_mt(mt, variance);\n             }\n@@ -693,8 +693,7 @@ impl<'a> ConstraintContext<'a> {\n             }\n \n             ty::ty_infer(..) | ty::ty_err | ty::ty_type |\n-            ty::ty_opaque_box | ty::ty_opaque_closure_ptr(..) |\n-            ty::ty_unboxed_vec(..) => {\n+            ty::ty_opaque_closure_ptr(..) | ty::ty_unboxed_vec(..) => {\n                 self.tcx().sess.bug(\n                     format!(\"Unexpected type encountered in \\\n                             variance inference: {}\","}, {"sha": "84dece87750a030629a5d2f7710779c735f78119", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -17,8 +17,8 @@ use middle::ty::{mt, t, param_ty};\n use middle::ty::{ReFree, ReScope, ReInfer, ReStatic, Region,\n                  ReEmpty};\n use middle::ty::{ty_bool, ty_char, ty_bot, ty_box, ty_struct, ty_enum};\n-use middle::ty::{ty_err, ty_estr, ty_evec, ty_float, ty_bare_fn, ty_closure};\n-use middle::ty::{ty_nil, ty_opaque_box, ty_opaque_closure_ptr, ty_param};\n+use middle::ty::{ty_err, ty_str, ty_vec, ty_float, ty_bare_fn, ty_closure};\n+use middle::ty::{ty_nil, ty_opaque_closure_ptr, ty_param};\n use middle::ty::{ty_ptr, ty_rptr, ty_self, ty_tup, ty_type, ty_uniq};\n use middle::ty::{ty_trait, ty_int};\n use middle::ty::{ty_uint, ty_unboxed_vec, ty_infer};\n@@ -501,11 +501,10 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n         format!(\"{}{}{}{}{}\", trait_store_to_str(cx, s), mutability_to_str(mutbl), ty,\n                            bound_sep, bound_str)\n       }\n-      ty_evec(ref mt, vs) => {\n+      ty_vec(ref mt, vs) => {\n         vstore_ty_to_str(cx, mt, vs)\n       }\n-      ty_estr(vs) => format!(\"{}{}\", vstore_to_str(cx, vs), \"str\"),\n-      ty_opaque_box => ~\"@?\",\n+      ty_str(vs) => format!(\"{}{}\", vstore_to_str(cx, vs), \"str\"),\n       ty_opaque_closure_ptr(ast::BorrowedSigil) => ~\"&closure\",\n       ty_opaque_closure_ptr(ast::ManagedSigil) => ~\"@closure\",\n       ty_opaque_closure_ptr(ast::OwnedSigil) => ~\"~closure\","}, {"sha": "acd1cfcf9013a9261afadba520be33f2d83e53af", "filename": "src/libstd/unstable/intrinsics.rs", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibstd%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibstd%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fintrinsics.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -47,9 +47,9 @@ pub use realstd::unstable::intrinsics::{TyDesc, Opaque, TyVisitor, TypeId};\n \n pub type GlueFn = extern \"Rust\" fn(*i8);\n \n-// NB: this has to be kept in sync with `type_desc` in `rt`\n+// NOTE remove after next snapshot\n #[lang=\"ty_desc\"]\n-#[cfg(not(test))]\n+#[cfg(not(test), stage0)]\n pub struct TyDesc {\n     // sizeof(T)\n     size: uint,\n@@ -80,6 +80,35 @@ pub struct TyDesc {\n     name: &'static str\n }\n \n+#[lang=\"ty_desc\"]\n+#[cfg(not(test), not(stage0))]\n+pub struct TyDesc {\n+    // sizeof(T)\n+    size: uint,\n+\n+    // alignof(T)\n+    align: uint,\n+\n+    // Called on a copy of a value of type `T` *after* memcpy\n+    take_glue: GlueFn,\n+\n+    // Called when a value of type `T` is no longer needed\n+    drop_glue: GlueFn,\n+\n+    // Called by reflection visitor to visit a value of type `T`\n+    visit_glue: GlueFn,\n+\n+    // If T represents a box pointer (`@U` or `~U`), then\n+    // `borrow_offset` is the amount that the pointer must be adjusted\n+    // to find the payload.  This is always derivable from the type\n+    // `U`, but in the case of `@Trait` or `~Trait` objects, the type\n+    // `U` is unknown.\n+    borrow_offset: uint,\n+\n+    // Name corresponding to the type\n+    name: &'static str\n+}\n+\n #[lang=\"opaque\"]\n #[cfg(not(test))]\n pub enum Opaque { }"}, {"sha": "b783ea6da3c5471c7970b9d927f77cb0fc92154b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -2276,7 +2276,7 @@ impl Parser {\n                 let m = self.parse_mutability();\n                 let e = self.parse_prefix_expr();\n                 hi = e.span.hi;\n-                // HACK: turn &[...] into a &-evec\n+                // HACK: turn &[...] into a &-vec\n                 ex = match e.node {\n                   ExprVec(..) | ExprLit(@codemap::Spanned {\n                     node: LitStr(..), span: _\n@@ -2297,7 +2297,7 @@ impl Parser {\n             self.bump();\n             let e = self.parse_prefix_expr();\n             hi = e.span.hi;\n-            // HACK: turn @[...] into a @-evec\n+            // HACK: turn @[...] into a @-vec\n             ex = match e.node {\n               ExprVec(..) |\n               ExprLit(@codemap::Spanned { node: LitStr(..), span: _}) |\n@@ -2310,7 +2310,7 @@ impl Parser {\n \n             let e = self.parse_prefix_expr();\n             hi = e.span.hi;\n-            // HACK: turn ~[...] into a ~-evec\n+            // HACK: turn ~[...] into a ~-vec\n             ex = match e.node {\n               ExprVec(..) |\n               ExprLit(@codemap::Spanned { node: LitStr(..), span: _}) |\n@@ -2337,7 +2337,7 @@ impl Parser {\n             // Otherwise, we use the unique pointer default.\n             let subexpression = self.parse_prefix_expr();\n             hi = subexpression.span.hi;\n-            // HACK: turn `box [...]` into a boxed-evec\n+            // HACK: turn `box [...]` into a boxed-vec\n             ex = match subexpression.node {\n                 ExprVec(..) |\n                 ExprLit(@codemap::Spanned {"}, {"sha": "f2482474073e027ca44bd8502f72a88830412ab5", "filename": "src/test/run-pass/self-in-mut-slot-immediate-value.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Ftest%2Frun-pass%2Fself-in-mut-slot-immediate-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bdda359c3cf41e36ba01ca6aef826aca7cc81c0/src%2Ftest%2Frun-pass%2Fself-in-mut-slot-immediate-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fself-in-mut-slot-immediate-value.rs?ref=4bdda359c3cf41e36ba01ca6aef826aca7cc81c0", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Assert that `mut self` on an immediate value doesn't\n+// allow mutating the original - issue #10615.\n+\n+struct Value {\n+    n: int\n+}\n+\n+impl Value {\n+    fn squared(mut self) -> Value {\n+        self.n *= self.n;\n+        self\n+    }\n+}\n+\n+pub fn main() {\n+    let x = Value { n: 3 };\n+    let y = x.squared();\n+    assert_eq!(x.n, 3);\n+    assert_eq!(y.n, 9);\n+}"}]}