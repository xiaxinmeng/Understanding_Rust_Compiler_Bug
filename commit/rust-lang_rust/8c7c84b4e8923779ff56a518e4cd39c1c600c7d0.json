{"sha": "8c7c84b4e8923779ff56a518e4cd39c1c600c7d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjN2M4NGI0ZTg5MjM3NzlmZjU2YTUxOGU0Y2QzOWMxYzYwMGM3ZDA=", "commit": {"author": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2020-06-18T20:29:43Z"}, "committer": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2020-06-19T16:52:04Z"}, "message": "code coverage foundation for hash and num_counters\n\nReplaced dummy values for hash and num_counters with computed values,\nand refactored InstrumentCoverage pass to simplify injecting more\ncounters per function in upcoming versions.\n\nImproved usage documentation and error messaging.", "tree": {"sha": "b53de4f77fa3254afc910867a2b5a273918217ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b53de4f77fa3254afc910867a2b5a273918217ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c7c84b4e8923779ff56a518e4cd39c1c600c7d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c7c84b4e8923779ff56a518e4cd39c1c600c7d0", "html_url": "https://github.com/rust-lang/rust/commit/8c7c84b4e8923779ff56a518e4cd39c1c600c7d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c7c84b4e8923779ff56a518e4cd39c1c600c7d0/comments", "author": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "791ccccddc18e83faa9963824112b14b3b1a93c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/791ccccddc18e83faa9963824112b14b3b1a93c2", "html_url": "https://github.com/rust-lang/rust/commit/791ccccddc18e83faa9963824112b14b3b1a93c2"}], "stats": {"total": 316, "additions": 230, "deletions": 86}, "files": [{"sha": "8c0ccde6b16bb2bad66d520d2b6b79b94210dcff", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 14, "deletions": 23, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8c7c84b4e8923779ff56a518e4cd39c1c600c7d0/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c7c84b4e8923779ff56a518e4cd39c1c600c7d0/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=8c7c84b4e8923779ff56a518e4cd39c1c600c7d0", "patch": "@@ -16,14 +16,14 @@ use rustc_codegen_ssa::common::TypeKind;\n use rustc_codegen_ssa::glue;\n use rustc_codegen_ssa::mir::operand::{OperandRef, OperandValue};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n+use rustc_codegen_ssa::mir::FunctionCx;\n use rustc_codegen_ssa::traits::*;\n use rustc_codegen_ssa::MemFlags;\n use rustc_hir as hir;\n use rustc_middle::ty::layout::{FnAbiExt, HasTyCtxt};\n use rustc_middle::ty::{self, Ty};\n use rustc_middle::{bug, span_bug};\n use rustc_span::Span;\n-use rustc_span::Symbol;\n use rustc_target::abi::{self, HasDataLayout, LayoutOf, Primitive};\n use rustc_target::spec::PanicStrategy;\n \n@@ -82,14 +82,14 @@ fn get_simple_intrinsic(cx: &CodegenCx<'ll, '_>, name: &str) -> Option<&'ll Valu\n }\n \n impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n-    fn codegen_intrinsic_call(\n+    fn codegen_intrinsic_call<'b, Bx: BuilderMethods<'b, 'tcx>>(\n         &mut self,\n+        fx: &FunctionCx<'b, 'tcx, Bx>,\n         instance: ty::Instance<'tcx>,\n         fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n         args: &[OperandRef<'tcx, &'ll Value>],\n         llresult: &'ll Value,\n         span: Span,\n-        caller_instance: ty::Instance<'tcx>,\n     ) {\n         let tcx = self.tcx;\n         let callee_ty = instance.monomorphic_ty(tcx);\n@@ -141,26 +141,17 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 self.call(llfn, &[], None)\n             }\n             \"count_code_region\" => {\n-                if let ty::InstanceDef::Item(fn_def_id) = caller_instance.def {\n-                    let caller_fn_path = tcx.def_path_str(fn_def_id);\n-                    debug!(\n-                        \"count_code_region to llvm.instrprof.increment(fn_name={})\",\n-                        caller_fn_path\n-                    );\n-\n-                    // FIXME(richkadel): (1) Replace raw function name with mangled function name;\n-                    // (2) Replace hardcoded `1234` in `hash` with a computed hash (as discussed in)\n-                    // the MCP (compiler-team/issues/278); and replace the hardcoded `1` for\n-                    // `num_counters` with the actual number of counters per function (when the\n-                    // changes are made to inject more than one counter per function).\n-                    let (fn_name, _len_val) = self.const_str(Symbol::intern(&caller_fn_path));\n-                    let index = args[0].immediate();\n-                    let hash = self.const_u64(1234);\n-                    let num_counters = self.const_u32(1);\n-                    self.instrprof_increment(fn_name, hash, num_counters, index)\n-                } else {\n-                    bug!(\"intrinsic count_code_region: no src.instance\");\n-                }\n+                let coverage_data = fx.mir.coverage_data.as_ref().unwrap();\n+                let mangled_fn = tcx.symbol_name(fx.instance);\n+                let (mangled_fn_name, _len_val) = self.const_str(mangled_fn.name);\n+                let hash = self.const_u64(coverage_data.hash);\n+                let index = args[0].immediate();\n+                let num_counters = self.const_u32(coverage_data.num_counters as u32);\n+                debug!(\n+                    \"count_code_region to LLVM intrinsic instrprof.increment(fn_name={}, hash={:?}, num_counters={:?}, index={:?})\",\n+                    mangled_fn.name, hash, index, num_counters\n+                );\n+                self.instrprof_increment(mangled_fn_name, hash, num_counters, index)\n             }\n             \"va_start\" => self.va_start(args[0].immediate()),\n             \"va_end\" => self.va_end(args[0].immediate()),"}, {"sha": "945c3d4843471ab10bafcef1e8751e137020f9ae", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c7c84b4e8923779ff56a518e4cd39c1c600c7d0/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c7c84b4e8923779ff56a518e4cd39c1c600c7d0/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=8c7c84b4e8923779ff56a518e4cd39c1c600c7d0", "patch": "@@ -688,12 +688,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 .collect();\n \n             bx.codegen_intrinsic_call(\n+                self,\n                 *instance.as_ref().unwrap(),\n                 &fn_abi,\n                 &args,\n                 dest,\n                 terminator.source_info.span,\n-                self.instance,\n             );\n \n             if let ReturnDest::IndirectOperand(dst, _) = ret_dest {"}, {"sha": "fd2e779f681bef50debe9cacd482feb34f339429", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c7c84b4e8923779ff56a518e4cd39c1c600c7d0/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c7c84b4e8923779ff56a518e4cd39c1c600c7d0/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=8c7c84b4e8923779ff56a518e4cd39c1c600c7d0", "patch": "@@ -21,9 +21,9 @@ use self::operand::{OperandRef, OperandValue};\n \n /// Master context for codegenning from MIR.\n pub struct FunctionCx<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n-    instance: Instance<'tcx>,\n+    pub instance: Instance<'tcx>,\n \n-    mir: &'tcx mir::Body<'tcx>,\n+    pub mir: &'tcx mir::Body<'tcx>,\n \n     debug_context: Option<FunctionDebugContext<Bx::DIScope>>,\n "}, {"sha": "0036eadf4db81e185e794fbb03b7266427c05096", "filename": "src/librustc_codegen_ssa/traits/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c7c84b4e8923779ff56a518e4cd39c1c600c7d0/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c7c84b4e8923779ff56a518e4cd39c1c600c7d0/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs?ref=8c7c84b4e8923779ff56a518e4cd39c1c600c7d0", "patch": "@@ -1,5 +1,7 @@\n use super::BackendTypes;\n use crate::mir::operand::OperandRef;\n+use crate::mir::FunctionCx;\n+use crate::traits::BuilderMethods;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::Span;\n use rustc_target::abi::call::FnAbi;\n@@ -8,14 +10,14 @@ pub trait IntrinsicCallMethods<'tcx>: BackendTypes {\n     /// Remember to add all intrinsics here, in librustc_typeck/check/mod.rs,\n     /// and in libcore/intrinsics.rs; if you need access to any llvm intrinsics,\n     /// add them to librustc_codegen_llvm/context.rs\n-    fn codegen_intrinsic_call(\n+    fn codegen_intrinsic_call<'a, Bx: BuilderMethods<'a, 'tcx>>(\n         &mut self,\n+        fx: &FunctionCx<'a, 'tcx, Bx>,\n         instance: ty::Instance<'tcx>,\n         fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n         args: &[OperandRef<'tcx, Self::Value>],\n         llresult: Self::Value,\n         span: Span,\n-        caller_instance: ty::Instance<'tcx>,\n     );\n \n     fn abort(&mut self);"}, {"sha": "662794f0aa11f15ce8a6a711ffe6585e6ac6ab2f", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c7c84b4e8923779ff56a518e4cd39c1c600c7d0/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c7c84b4e8923779ff56a518e4cd39c1c600c7d0/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=8c7c84b4e8923779ff56a518e4cd39c1c600c7d0", "patch": "@@ -488,6 +488,8 @@ impl<'a> CrateLocator<'a> {\n                 && self.triple != TargetTriple::from_triple(config::host_triple())\n             {\n                 err.note(&format!(\"the `{}` target may not be installed\", self.triple));\n+            } else if self.crate_name == sym::profiler_builtins {\n+                err.note(&\"the compiler may have been built without `profiler = true`\");\n             }\n             err.span_label(self.span, \"can't find crate\");\n             err"}, {"sha": "f5b0b73c49de1cf7230f100bfd2e3d53a377d7c5", "filename": "src/librustc_middle/ich/hcx.rs", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8c7c84b4e8923779ff56a518e4cd39c1c600c7d0/src%2Flibrustc_middle%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c7c84b4e8923779ff56a518e4cd39c1c600c7d0/src%2Flibrustc_middle%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fich%2Fhcx.rs?ref=8c7c84b4e8923779ff56a518e4cd39c1c600c7d0", "patch": "@@ -67,13 +67,15 @@ impl<'a> StableHashingContext<'a> {\n     /// Don't use it for anything else or you'll run the risk of\n     /// leaking data out of the tracking system.\n     #[inline]\n-    pub fn new(\n+    fn new_with_or_without_spans(\n         sess: &'a Session,\n         krate: &'a hir::Crate<'a>,\n         definitions: &'a Definitions,\n         cstore: &'a dyn CrateStore,\n+        always_ignore_spans: bool,\n     ) -> Self {\n-        let hash_spans_initial = !sess.opts.debugging_opts.incremental_ignore_spans;\n+        let hash_spans_initial =\n+            !always_ignore_spans && !sess.opts.debugging_opts.incremental_ignore_spans;\n \n         StableHashingContext {\n             sess,\n@@ -88,6 +90,33 @@ impl<'a> StableHashingContext<'a> {\n         }\n     }\n \n+    #[inline]\n+    pub fn new(\n+        sess: &'a Session,\n+        krate: &'a hir::Crate<'a>,\n+        definitions: &'a Definitions,\n+        cstore: &'a dyn CrateStore,\n+    ) -> Self {\n+        Self::new_with_or_without_spans(\n+            sess,\n+            krate,\n+            definitions,\n+            cstore,\n+            /*always_ignore_spans=*/ false,\n+        )\n+    }\n+\n+    #[inline]\n+    pub fn ignore_spans(\n+        sess: &'a Session,\n+        krate: &'a hir::Crate<'a>,\n+        definitions: &'a Definitions,\n+        cstore: &'a dyn CrateStore,\n+    ) -> Self {\n+        let always_ignore_spans = true;\n+        Self::new_with_or_without_spans(sess, krate, definitions, cstore, always_ignore_spans)\n+    }\n+\n     #[inline]\n     pub fn sess(&self) -> &'a Session {\n         self.sess"}, {"sha": "a89a5ef3f8218772f268c069065939df693a0d1c", "filename": "src/librustc_middle/mir/mod.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8c7c84b4e8923779ff56a518e4cd39c1c600c7d0/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c7c84b4e8923779ff56a518e4cd39c1c600c7d0/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmod.rs?ref=8c7c84b4e8923779ff56a518e4cd39c1c600c7d0", "patch": "@@ -88,6 +88,19 @@ impl MirPhase {\n     }\n }\n \n+/// Coverage data computed by the `InstrumentCoverage` MIR pass, when compiling with\n+/// `-Zinstrument_coverage`.\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable, TypeFoldable)]\n+pub struct CoverageData {\n+    /// A hash value that can be used by the consumer of the coverage profile data to detect\n+    /// changes to the instrumented source of the associated MIR body (typically, for an\n+    /// individual function).\n+    pub hash: u64,\n+\n+    /// The total number of coverage region counters added to this MIR Body.\n+    pub num_counters: usize,\n+}\n+\n /// The lowered representation of a single function.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable, TypeFoldable)]\n pub struct Body<'tcx> {\n@@ -164,13 +177,17 @@ pub struct Body<'tcx> {\n     /// The user may be writing e.g. `&[(SOME_CELL, 42)][i].1` and this would get promoted, because\n     /// we'd statically know that no thing with interior mutability will ever be available to the\n     /// user without some serious unsafe code.  Now this means that our promoted is actually\n-    /// `&[(SOME_CELL, 42)]` and the MIR using it will do the `&promoted[i].1` projection because the\n-    /// index may be a runtime value. Such a promoted value is illegal because it has reachable\n+    /// `&[(SOME_CELL, 42)]` and the MIR using it will do the `&promoted[i].1` projection because\n+    /// the index may be a runtime value. Such a promoted value is illegal because it has reachable\n     /// interior mutability. This flag just makes this situation very obvious where the previous\n     /// implementation without the flag hid this situation silently.\n     /// FIXME(oli-obk): rewrite the promoted during promotion to eliminate the cell components.\n     pub ignore_interior_mut_in_const_validation: bool,\n \n+    /// If compiling with `-Zinstrument_coverage`, the `InstrumentCoverage` pass stores summary\n+    /// information associated with the MIR, used in code generation of the coverage counters.\n+    pub coverage_data: Option<CoverageData>,\n+\n     predecessor_cache: PredecessorCache,\n }\n \n@@ -211,6 +228,7 @@ impl<'tcx> Body<'tcx> {\n             required_consts: Vec::new(),\n             ignore_interior_mut_in_const_validation: false,\n             control_flow_destroyed,\n+            coverage_data: None,\n             predecessor_cache: PredecessorCache::new(),\n         }\n     }\n@@ -238,6 +256,7 @@ impl<'tcx> Body<'tcx> {\n             generator_kind: None,\n             var_debug_info: Vec::new(),\n             ignore_interior_mut_in_const_validation: false,\n+            coverage_data: None,\n             predecessor_cache: PredecessorCache::new(),\n         }\n     }"}, {"sha": "0696cae4810ec9bb1cd1dcfdefed207d4856ddff", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8c7c84b4e8923779ff56a518e4cd39c1c600c7d0/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c7c84b4e8923779ff56a518e4cd39c1c600c7d0/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=8c7c84b4e8923779ff56a518e4cd39c1c600c7d0", "patch": "@@ -1284,6 +1284,13 @@ impl<'tcx> TyCtxt<'tcx> {\n         StableHashingContext::new(self.sess, krate, self.definitions, &*self.cstore)\n     }\n \n+    #[inline(always)]\n+    pub fn create_no_span_stable_hashing_context(self) -> StableHashingContext<'tcx> {\n+        let krate = self.gcx.untracked_crate;\n+\n+        StableHashingContext::ignore_spans(self.sess, krate, self.definitions, &*self.cstore)\n+    }\n+\n     // This method makes sure that we have a DepNode and a Fingerprint for\n     // every upstream crate. It needs to be called once right after the tcx is\n     // created."}, {"sha": "793ccbb081bedcbebb62bc5cfec9e51d2fc761ab", "filename": "src/librustc_mir/transform/instrument_coverage.rs", "status": "modified", "additions": 144, "deletions": 52, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/8c7c84b4e8923779ff56a518e4cd39c1c600c7d0/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c7c84b4e8923779ff56a518e4cd39c1c600c7d0/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs?ref=8c7c84b4e8923779ff56a518e4cd39c1c600c7d0", "patch": "@@ -1,8 +1,15 @@\n use crate::transform::{MirPass, MirSource};\n use crate::util::patch::MirPatch;\n+use rustc_data_structures::fingerprint::Fingerprint;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::lang_items;\n+use rustc_hir::*;\n+use rustc_middle::ich::StableHashingContext;\n use rustc_middle::mir::interpret::Scalar;\n-use rustc_middle::mir::*;\n+use rustc_middle::mir::{\n+    self, BasicBlock, BasicBlockData, CoverageData, Operand, Place, SourceInfo, StatementKind,\n+    Terminator, TerminatorKind, START_BLOCK,\n+};\n use rustc_middle::ty;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::def_id::DefId;\n@@ -12,64 +19,104 @@ use rustc_span::Span;\n /// the intrinsic llvm.instrprof.increment.\n pub struct InstrumentCoverage;\n \n+struct Instrumentor<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    num_counters: usize,\n+}\n+\n impl<'tcx> MirPass<'tcx> for InstrumentCoverage {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, body: &mut Body<'tcx>) {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, mir_body: &mut mir::Body<'tcx>) {\n         if tcx.sess.opts.debugging_opts.instrument_coverage {\n-            debug!(\"instrumenting {:?}\", src.def_id());\n-            instrument_coverage(tcx, body);\n+            // If the InstrumentCoverage pass is called on promoted MIRs, skip them.\n+            // See: https://github.com/rust-lang/rust/pull/73011#discussion_r438317601\n+            if src.promoted.is_none() {\n+                assert!(mir_body.coverage_data.is_none());\n+\n+                let hash = hash_mir_source(tcx, &src);\n+\n+                debug!(\n+                    \"instrumenting {:?}, hash: {}, span: {}\",\n+                    src.def_id(),\n+                    hash,\n+                    tcx.sess.source_map().span_to_string(mir_body.span)\n+                );\n+\n+                let num_counters = Instrumentor::new(tcx).inject_counters(mir_body);\n+\n+                mir_body.coverage_data = Some(CoverageData { hash, num_counters });\n+            }\n         }\n     }\n }\n \n-// The first counter (start of the function) is index zero.\n-const INIT_FUNCTION_COUNTER: u32 = 0;\n-\n-/// Injects calls to placeholder function `count_code_region()`.\n-// FIXME(richkadel): As a first step, counters are only injected at the top of each function.\n-// The complete solution will inject counters at each conditional code branch.\n-pub fn instrument_coverage<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n-    let span = body.span.shrink_to_lo();\n-\n-    let count_code_region_fn = function_handle(\n-        tcx,\n-        tcx.require_lang_item(lang_items::CountCodeRegionFnLangItem, None),\n-        span,\n-    );\n-    let counter_index = Operand::const_from_scalar(\n-        tcx,\n-        tcx.types.u32,\n-        Scalar::from_u32(INIT_FUNCTION_COUNTER),\n-        span,\n-    );\n-\n-    let mut patch = MirPatch::new(body);\n-\n-    let new_block = patch.new_block(placeholder_block(SourceInfo::outermost(body.span)));\n-    let next_block = START_BLOCK;\n-\n-    let temp = patch.new_temp(tcx.mk_unit(), body.span);\n-    patch.patch_terminator(\n-        new_block,\n-        TerminatorKind::Call {\n-            func: count_code_region_fn,\n-            args: vec![counter_index],\n-            // new_block will swapped with the next_block, after applying patch\n-            destination: Some((Place::from(temp), new_block)),\n-            cleanup: None,\n-            from_hir_call: false,\n-            fn_span: span,\n-        },\n-    );\n+impl<'tcx> Instrumentor<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx>) -> Self {\n+        Self { tcx, num_counters: 0 }\n+    }\n+\n+    fn next_counter(&mut self) -> u32 {\n+        let next = self.num_counters as u32;\n+        self.num_counters += 1;\n+        next\n+    }\n+\n+    fn inject_counters(&mut self, mir_body: &mut mir::Body<'tcx>) -> usize {\n+        // FIXME(richkadel): As a first step, counters are only injected at the top of each\n+        // function. The complete solution will inject counters at each conditional code branch.\n+        let top_of_function = START_BLOCK;\n+        let entire_function = mir_body.span;\n+\n+        self.inject_counter(mir_body, top_of_function, entire_function);\n+\n+        self.num_counters\n+    }\n+\n+    fn inject_counter(\n+        &mut self,\n+        mir_body: &mut mir::Body<'tcx>,\n+        next_block: BasicBlock,\n+        code_region: Span,\n+    ) {\n+        let injection_point = code_region.shrink_to_lo();\n \n-    patch.add_statement(new_block.start_location(), StatementKind::StorageLive(temp));\n-    patch.add_statement(next_block.start_location(), StatementKind::StorageDead(temp));\n+        let count_code_region_fn = function_handle(\n+            self.tcx,\n+            self.tcx.require_lang_item(lang_items::CountCodeRegionFnLangItem, None),\n+            injection_point,\n+        );\n+        let counter_index = Operand::const_from_scalar(\n+            self.tcx,\n+            self.tcx.types.u32,\n+            Scalar::from_u32(self.next_counter()),\n+            injection_point,\n+        );\n \n-    patch.apply(body);\n+        let mut patch = MirPatch::new(mir_body);\n \n-    // To insert the `new_block` in front of the first block in the counted branch (for example,\n-    // the START_BLOCK, at the top of the function), just swap the indexes, leaving the rest of the\n-    // graph unchanged.\n-    body.basic_blocks_mut().swap(next_block, new_block);\n+        let temp = patch.new_temp(self.tcx.mk_unit(), code_region);\n+        let new_block = patch.new_block(placeholder_block(code_region));\n+        patch.patch_terminator(\n+            new_block,\n+            TerminatorKind::Call {\n+                func: count_code_region_fn,\n+                args: vec![counter_index],\n+                // new_block will swapped with the next_block, after applying patch\n+                destination: Some((Place::from(temp), new_block)),\n+                cleanup: None,\n+                from_hir_call: false,\n+                fn_span: injection_point,\n+            },\n+        );\n+\n+        patch.add_statement(new_block.start_location(), StatementKind::StorageLive(temp));\n+        patch.add_statement(next_block.start_location(), StatementKind::StorageDead(temp));\n+\n+        patch.apply(mir_body);\n+\n+        // To insert the `new_block` in front of the first block in the counted branch (the\n+        // `next_block`), just swap the indexes, leaving the rest of the graph unchanged.\n+        mir_body.basic_blocks_mut().swap(next_block, new_block);\n+    }\n }\n \n fn function_handle<'tcx>(tcx: TyCtxt<'tcx>, fn_def_id: DefId, span: Span) -> Operand<'tcx> {\n@@ -79,14 +126,59 @@ fn function_handle<'tcx>(tcx: TyCtxt<'tcx>, fn_def_id: DefId, span: Span) -> Ope\n     Operand::function_handle(tcx, fn_def_id, substs, span)\n }\n \n-fn placeholder_block<'tcx>(source_info: SourceInfo) -> BasicBlockData<'tcx> {\n+fn placeholder_block(span: Span) -> BasicBlockData<'tcx> {\n     BasicBlockData {\n         statements: vec![],\n         terminator: Some(Terminator {\n-            source_info,\n+            source_info: SourceInfo::outermost(span),\n             // this gets overwritten by the counter Call\n             kind: TerminatorKind::Unreachable,\n         }),\n         is_cleanup: false,\n     }\n }\n+\n+fn hash_mir_source<'tcx>(tcx: TyCtxt<'tcx>, src: &MirSource<'tcx>) -> u64 {\n+    let fn_body_id = match tcx.hir().get_if_local(src.def_id()) {\n+        Some(node) => match associated_body(node) {\n+            Some(body_id) => body_id,\n+            _ => bug!(\"instrumented MirSource does not include a function body: {:?}\", node),\n+        },\n+        None => bug!(\"instrumented MirSource is not local: {:?}\", src),\n+    };\n+    let hir_body = tcx.hir().body(fn_body_id);\n+    let mut hcx = tcx.create_no_span_stable_hashing_context();\n+    hash(&mut hcx, &hir_body.value).to_smaller_hash()\n+}\n+\n+fn hash(\n+    hcx: &mut StableHashingContext<'tcx>,\n+    node: &impl HashStable<StableHashingContext<'tcx>>,\n+) -> Fingerprint {\n+    let mut stable_hasher = StableHasher::new();\n+    node.hash_stable(hcx, &mut stable_hasher);\n+    stable_hasher.finish()\n+}\n+\n+fn associated_body<'hir>(node: Node<'hir>) -> Option<BodyId> {\n+    match node {\n+        Node::Item(Item {\n+            kind: ItemKind::Const(_, body) | ItemKind::Static(.., body) | ItemKind::Fn(.., body),\n+            ..\n+        })\n+        | Node::TraitItem(TraitItem {\n+            kind:\n+                TraitItemKind::Const(_, Some(body)) | TraitItemKind::Fn(_, TraitFn::Provided(body)),\n+            ..\n+        })\n+        | Node::ImplItem(ImplItem {\n+            kind: ImplItemKind::Const(_, body) | ImplItemKind::Fn(_, body),\n+            ..\n+        })\n+        | Node::Expr(Expr { kind: ExprKind::Closure(.., body, _, _), .. }) => Some(*body),\n+\n+        Node::AnonConst(constant) => Some(constant.body),\n+\n+        _ => None,\n+    }\n+}"}, {"sha": "c2d056ad26d0b3a7170dd4ace1c3ff8f71219fb5", "filename": "src/librustc_session/options.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8c7c84b4e8923779ff56a518e4cd39c1c600c7d0/src%2Flibrustc_session%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c7c84b4e8923779ff56a518e4cd39c1c600c7d0/src%2Flibrustc_session%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Foptions.rs?ref=8c7c84b4e8923779ff56a518e4cd39c1c600c7d0", "patch": "@@ -877,8 +877,9 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         (such as entering an empty infinite loop) by inserting llvm.sideeffect \\\n         (default: no)\"),\n     instrument_coverage: bool = (false, parse_bool, [TRACKED],\n-        \"instrument the generated code with LLVM code region counters to \\\n-        (in the future) generate coverage reports (experimental; default: no)\"),\n+        \"instrument the generated code with LLVM code region counters to (in the \\\n+        future) generate coverage reports (default: no; note, the compiler build \\\n+        config must include `profiler = true`)\"),\n     instrument_mcount: bool = (false, parse_bool, [TRACKED],\n         \"insert function instrument code for mcount-based tracing (default: no)\"),\n     keep_hygiene_data: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "6efe9b20d0d8f627eeee9b988f218a63a771fe37", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c7c84b4e8923779ff56a518e4cd39c1c600c7d0/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c7c84b4e8923779ff56a518e4cd39c1c600c7d0/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=8c7c84b4e8923779ff56a518e4cd39c1c600c7d0", "patch": "@@ -587,6 +587,7 @@ symbols! {\n         proc_macro_mod,\n         proc_macro_non_items,\n         proc_macro_path_invoc,\n+        profiler_builtins,\n         profiler_runtime,\n         ptr_offset_from,\n         pub_restricted,"}]}