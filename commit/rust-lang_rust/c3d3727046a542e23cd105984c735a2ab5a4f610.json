{"sha": "c3d3727046a542e23cd105984c735a2ab5a4f610", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzZDM3MjcwNDZhNTQyZTIzY2QxMDU5ODRjNzM1YTJhYjVhNGY2MTA=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-05-09T11:18:23Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-05-17T16:38:23Z"}, "message": "Clarify specialize_one_pattern\n\nUsing a more error-oriented approache to `Option`.", "tree": {"sha": "40c7fad761004eae35d83878119bc688d1631674", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40c7fad761004eae35d83878119bc688d1631674"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3d3727046a542e23cd105984c735a2ab5a4f610", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3d3727046a542e23cd105984c735a2ab5a4f610", "html_url": "https://github.com/rust-lang/rust/commit/c3d3727046a542e23cd105984c735a2ab5a4f610", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3d3727046a542e23cd105984c735a2ab5a4f610/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3551f1a0f6301e315a8ee5ea39420fa6f26d0a90", "url": "https://api.github.com/repos/rust-lang/rust/commits/3551f1a0f6301e315a8ee5ea39420fa6f26d0a90", "html_url": "https://github.com/rust-lang/rust/commit/3551f1a0f6301e315a8ee5ea39420fa6f26d0a90"}], "stats": {"total": 105, "additions": 48, "deletions": 57}, "files": [{"sha": "d76f58993883d8c822deae14f63167d497b78b0f", "filename": "src/librustc_mir_build/hair/pattern/_match.rs", "status": "modified", "additions": 48, "deletions": 57, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/c3d3727046a542e23cd105984c735a2ab5a4f610/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d3727046a542e23cd105984c735a2ab5a4f610/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs?ref=c3d3727046a542e23cd105984c735a2ab5a4f610", "patch": "@@ -2390,7 +2390,10 @@ fn specialize_one_pattern<'p, 'tcx>(\n ) -> Option<Fields<'p, 'tcx>> {\n     if let NonExhaustive = constructor {\n         // Only a wildcard pattern can match the special extra constructor\n-        return if pat.is_wildcard() { Some(Fields::empty()) } else { None };\n+        if !pat.is_wildcard() {\n+            return None;\n+        }\n+        return Some(Fields::empty());\n     }\n \n     let result = match *pat.kind {\n@@ -2400,12 +2403,11 @@ fn specialize_one_pattern<'p, 'tcx>(\n \n         PatKind::Variant { adt_def, variant_index, ref subpatterns, .. } => {\n             let variant = &adt_def.variants[variant_index];\n+            if constructor != &Variant(variant.def_id) {\n+                return None;\n+            }\n             let is_non_exhaustive = cx.is_foreign_non_exhaustive_variant(pat.ty, variant);\n-            Some(Variant(variant.def_id))\n-                .filter(|variant_constructor| variant_constructor == constructor)\n-                .map(|_| {\n-                    patterns_for_variant(cx, subpatterns, ctor_wild_subpatterns, is_non_exhaustive)\n-                })\n+            Some(patterns_for_variant(cx, subpatterns, ctor_wild_subpatterns, is_non_exhaustive))\n         }\n \n         PatKind::Leaf { ref subpatterns } => {\n@@ -2425,11 +2427,10 @@ fn specialize_one_pattern<'p, 'tcx>(\n                     // Shortcut for `n == 0` where no matter what `alloc` and `offset` we produce,\n                     // the result would be exactly what we early return here.\n                     if n == 0 {\n-                        if ctor_wild_subpatterns.len() as u64 == 0 {\n-                            return Some(Fields::empty());\n-                        } else {\n+                        if ctor_wild_subpatterns.len() as u64 != n {\n                             return None;\n                         }\n+                        return Some(Fields::empty());\n                     }\n                     match value.val {\n                         ty::ConstKind::Value(ConstValue::ByRef { offset, alloc, .. }) => {\n@@ -2463,76 +2464,66 @@ fn specialize_one_pattern<'p, 'tcx>(\n                     constructor,\n                 ),\n             };\n-            if ctor_wild_subpatterns.len() as u64 == n {\n-                // convert a constant slice/array pattern to a list of patterns.\n-                let layout = cx.tcx.layout_of(cx.param_env.and(ty)).ok()?;\n-                let ptr = Pointer::new(AllocId(0), offset);\n-                let pats = (0..n)\n-                    .map(|i| {\n-                        let ptr = ptr.offset(layout.size * i, &cx.tcx).ok()?;\n-                        let scalar = alloc.read_scalar(&cx.tcx, ptr, layout.size).ok()?;\n-                        let scalar = scalar.not_undef().ok()?;\n-                        let value = ty::Const::from_scalar(cx.tcx, scalar, ty);\n-                        let pattern =\n-                            Pat { ty, span: pat.span, kind: box PatKind::Constant { value } };\n-                        Some(&*cx.pattern_arena.alloc(pattern))\n-                    })\n-                    .collect::<Option<_>>()?;\n-                Some(Fields::from_vec(pats))\n-            } else {\n-                None\n+            if ctor_wild_subpatterns.len() as u64 != n {\n+                return None;\n             }\n+            // Convert a constant slice/array pattern to a list of patterns.\n+            let layout = cx.tcx.layout_of(cx.param_env.and(ty)).ok()?;\n+            let ptr = Pointer::new(AllocId(0), offset);\n+            let pats = (0..n)\n+                .map(|i| {\n+                    let ptr = ptr.offset(layout.size * i, &cx.tcx).ok()?;\n+                    let scalar = alloc.read_scalar(&cx.tcx, ptr, layout.size).ok()?;\n+                    let scalar = scalar.not_undef().ok()?;\n+                    let value = ty::Const::from_scalar(cx.tcx, scalar, ty);\n+                    let pattern = Pat { ty, span: pat.span, kind: box PatKind::Constant { value } };\n+                    Some(&*cx.pattern_arena.alloc(pattern))\n+                })\n+                .collect::<Option<_>>()?;\n+            Some(Fields::from_vec(pats))\n         }\n \n         PatKind::Constant { .. } | PatKind::Range { .. } => {\n             // If the constructor is a:\n             // - Single value: add a row if the pattern contains the constructor.\n             // - Range: add a row if the constructor intersects the pattern.\n             if let IntRange(ctor) = constructor {\n-                match IntRange::from_pat(cx.tcx, cx.param_env, pat) {\n-                    Some(pat) => ctor.intersection(cx.tcx, &pat).map(|_| {\n-                        // Constructor splitting should ensure that all intersections we encounter\n-                        // are actually inclusions.\n-                        assert!(ctor.is_subrange(&pat));\n-                        Fields::empty()\n-                    }),\n-                    _ => None,\n-                }\n+                let pat = IntRange::from_pat(cx.tcx, cx.param_env, pat)?;\n+                ctor.intersection(cx.tcx, &pat)?;\n+                // Constructor splitting should ensure that all intersections we encounter\n+                // are actually inclusions.\n+                assert!(ctor.is_subrange(&pat));\n             } else {\n                 // Fallback for non-ranges and ranges that involve\n                 // floating-point numbers, which are not conveniently handled\n                 // by `IntRange`. For these cases, the constructor may not be a\n                 // range so intersection actually devolves into being covered\n                 // by the pattern.\n-                constructor_covered_by_range(cx.tcx, cx.param_env, constructor, pat)\n-                    .map(|()| Fields::empty())\n+                constructor_covered_by_range(cx.tcx, cx.param_env, constructor, pat)?;\n             }\n+            Some(Fields::empty())\n         }\n \n         PatKind::Array { ref prefix, ref slice, ref suffix }\n         | PatKind::Slice { ref prefix, ref slice, ref suffix } => match *constructor {\n             Slice(_) => {\n+                // Number of subpatterns for this pattern\n                 let pat_len = prefix.len() + suffix.len();\n-                if let Some(slice_count) = ctor_wild_subpatterns.len().checked_sub(pat_len) {\n-                    if slice_count == 0 || slice.is_some() {\n-                        Some(Fields::from_vec(\n-                            prefix\n-                                .iter()\n-                                .chain(\n-                                    ctor_wild_subpatterns\n-                                        .iter()\n-                                        .skip(prefix.len())\n-                                        .take(slice_count)\n-                                        .chain(suffix.iter()),\n-                                )\n-                                .collect(),\n-                        ))\n-                    } else {\n-                        None\n-                    }\n-                } else {\n-                    None\n+                // Number of subpatterns for this constructor\n+                let arity = ctor_wild_subpatterns.len();\n+\n+                if slice.is_none() && arity != pat_len {\n+                    return None;\n                 }\n+\n+                // Number of subpatterns matched by the `..` subslice pattern (is 0 for a slice\n+                // pattern of fixed length).\n+                let subslice_count = arity.checked_sub(pat_len)?;\n+                let subslice_pats =\n+                    ctor_wild_subpatterns.iter().skip(prefix.len()).take(subslice_count);\n+                Some(Fields::from_vec(\n+                    prefix.iter().chain(subslice_pats).chain(suffix.iter()).collect(),\n+                ))\n             }\n             ConstantValue(cv) => {\n                 match slice_pat_covered_by_const("}]}