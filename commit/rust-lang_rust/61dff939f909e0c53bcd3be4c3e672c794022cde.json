{"sha": "61dff939f909e0c53bcd3be4c3e672c794022cde", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxZGZmOTM5ZjkwOWUwYzUzYmNkM2JlNGMzZTY3MmM3OTQwMjJjZGU=", "commit": {"author": {"name": "Paul Daniel Faria", "email": "Nashenas88@users.noreply.github.com", "date": "2020-07-30T13:26:40Z"}, "committer": {"name": "Paul Daniel Faria", "email": "Nashenas88@users.noreply.github.com", "date": "2020-08-10T12:46:34Z"}, "message": "Move unsafe semantics methods into `SemanticsImpl` and reference them in `Semantics`", "tree": {"sha": "3243c173e74001af89a7b35a8e901d3cbd6aaf4c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3243c173e74001af89a7b35a8e901d3cbd6aaf4c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61dff939f909e0c53bcd3be4c3e672c794022cde", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61dff939f909e0c53bcd3be4c3e672c794022cde", "html_url": "https://github.com/rust-lang/rust/commit/61dff939f909e0c53bcd3be4c3e672c794022cde", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61dff939f909e0c53bcd3be4c3e672c794022cde/comments", "author": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nashenas88", "id": 1673130, "node_id": "MDQ6VXNlcjE2NzMxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1673130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nashenas88", "html_url": "https://github.com/Nashenas88", "followers_url": "https://api.github.com/users/Nashenas88/followers", "following_url": "https://api.github.com/users/Nashenas88/following{/other_user}", "gists_url": "https://api.github.com/users/Nashenas88/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nashenas88/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nashenas88/subscriptions", "organizations_url": "https://api.github.com/users/Nashenas88/orgs", "repos_url": "https://api.github.com/users/Nashenas88/repos", "events_url": "https://api.github.com/users/Nashenas88/events{/privacy}", "received_events_url": "https://api.github.com/users/Nashenas88/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39fdd41df4052cef5da4876067ae28615012476b", "url": "https://api.github.com/repos/rust-lang/rust/commits/39fdd41df4052cef5da4876067ae28615012476b", "html_url": "https://github.com/rust-lang/rust/commit/39fdd41df4052cef5da4876067ae28615012476b"}], "stats": {"total": 154, "additions": 83, "deletions": 71}, "files": [{"sha": "758d004098647852a1b2e4113a4fa5f7463fbca7", "filename": "crates/ra_hir/src/semantics.rs", "status": "modified", "additions": 83, "deletions": 71, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/61dff939f909e0c53bcd3be4c3e672c794022cde/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61dff939f909e0c53bcd3be4c3e672c794022cde/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsemantics.rs?ref=61dff939f909e0c53bcd3be4c3e672c794022cde", "patch": "@@ -282,83 +282,15 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n     }\n \n     pub fn is_unsafe_method_call(&self, method_call_expr: ast::MethodCallExpr) -> bool {\n-        method_call_expr\n-            .expr()\n-            .and_then(|expr| {\n-                let field_expr = if let ast::Expr::FieldExpr(field_expr) = expr {\n-                    field_expr\n-                } else {\n-                    return None;\n-                };\n-                let ty = self.type_of_expr(&field_expr.expr()?)?;\n-                if !ty.is_packed(self.db) {\n-                    return None;\n-                }\n-\n-                let func = self.resolve_method_call(&method_call_expr)?;\n-                let is_unsafe = func.has_self_param(self.db)\n-                    && matches!(func.params(self.db).first(), Some(TypeRef::Reference(..)));\n-                Some(is_unsafe)\n-            })\n-            .unwrap_or(false)\n+        self.imp.is_unsafe_method_call(method_call_expr)\n     }\n \n     pub fn is_unsafe_ref_expr(&self, ref_expr: &ast::RefExpr) -> bool {\n-        ref_expr\n-            .expr()\n-            .and_then(|expr| {\n-                let field_expr = match expr {\n-                    ast::Expr::FieldExpr(field_expr) => field_expr,\n-                    _ => return None,\n-                };\n-                let expr = field_expr.expr()?;\n-                self.type_of_expr(&expr)\n-            })\n-            // Binding a reference to a packed type is possibly unsafe.\n-            .map(|ty| ty.is_packed(self.db))\n-            .unwrap_or(false)\n-\n-        // FIXME This needs layout computation to be correct. It will highlight\n-        // more than it should with the current implementation.\n+        self.imp.is_unsafe_ref_expr(ref_expr)\n     }\n \n     pub fn is_unsafe_bind_pat(&self, bind_pat: &ast::BindPat) -> bool {\n-        bind_pat\n-            .syntax()\n-            .parent()\n-            .and_then(|parent| {\n-                // `BindPat` can live under `RecordPat` directly under `RecordFieldPat` or\n-                // `RecordFieldPatList`. `RecordFieldPat` also lives under `RecordFieldPatList`,\n-                // so this tries to lookup the `BindPat` anywhere along that structure to the\n-                // `RecordPat` so we can get the containing type.\n-                let record_pat = ast::RecordFieldPat::cast(parent.clone())\n-                    .and_then(|record_pat| record_pat.syntax().parent())\n-                    .or_else(|| Some(parent.clone()))\n-                    .and_then(|parent| {\n-                        ast::RecordFieldPatList::cast(parent)?\n-                            .syntax()\n-                            .parent()\n-                            .and_then(ast::RecordPat::cast)\n-                    });\n-\n-                // If this doesn't match a `RecordPat`, fallback to a `LetStmt` to see if\n-                // this is initialized from a `FieldExpr`.\n-                if let Some(record_pat) = record_pat {\n-                    self.type_of_pat(&ast::Pat::RecordPat(record_pat))\n-                } else if let Some(let_stmt) = ast::LetStmt::cast(parent) {\n-                    let field_expr = match let_stmt.initializer()? {\n-                        ast::Expr::FieldExpr(field_expr) => field_expr,\n-                        _ => return None,\n-                    };\n-\n-                    self.type_of_expr(&field_expr.expr()?)\n-                } else {\n-                    None\n-                }\n-            })\n-            // Binding a reference to a packed type is possibly unsafe.\n-            .map(|ty| ty.is_packed(self.db))\n-            .unwrap_or(false)\n+        self.imp.is_unsafe_bind_pat(bind_pat)\n     }\n }\n \n@@ -655,6 +587,86 @@ impl<'db> SemanticsImpl<'db> {\n         });\n         InFile::new(file_id, node)\n     }\n+\n+    pub fn is_unsafe_method_call(&self, method_call_expr: ast::MethodCallExpr) -> bool {\n+        method_call_expr\n+            .expr()\n+            .and_then(|expr| {\n+                let field_expr = if let ast::Expr::FieldExpr(field_expr) = expr {\n+                    field_expr\n+                } else {\n+                    return None;\n+                };\n+                let ty = self.type_of_expr(&field_expr.expr()?)?;\n+                if !ty.is_packed(self.db) {\n+                    return None;\n+                }\n+\n+                let func = self.resolve_method_call(&method_call_expr).map(Function::from)?;\n+                let is_unsafe = func.has_self_param(self.db)\n+                    && matches!(func.params(self.db).first(), Some(TypeRef::Reference(..)));\n+                Some(is_unsafe)\n+            })\n+            .unwrap_or(false)\n+    }\n+\n+    pub fn is_unsafe_ref_expr(&self, ref_expr: &ast::RefExpr) -> bool {\n+        ref_expr\n+            .expr()\n+            .and_then(|expr| {\n+                let field_expr = match expr {\n+                    ast::Expr::FieldExpr(field_expr) => field_expr,\n+                    _ => return None,\n+                };\n+                let expr = field_expr.expr()?;\n+                self.type_of_expr(&expr)\n+            })\n+            // Binding a reference to a packed type is possibly unsafe.\n+            .map(|ty| ty.is_packed(self.db))\n+            .unwrap_or(false)\n+\n+        // FIXME This needs layout computation to be correct. It will highlight\n+        // more than it should with the current implementation.\n+    }\n+\n+    pub fn is_unsafe_bind_pat(&self, bind_pat: &ast::BindPat) -> bool {\n+        bind_pat\n+            .syntax()\n+            .parent()\n+            .and_then(|parent| {\n+                // `BindPat` can live under `RecordPat` directly under `RecordFieldPat` or\n+                // `RecordFieldPatList`. `RecordFieldPat` also lives under `RecordFieldPatList`,\n+                // so this tries to lookup the `BindPat` anywhere along that structure to the\n+                // `RecordPat` so we can get the containing type.\n+                let record_pat = ast::RecordFieldPat::cast(parent.clone())\n+                    .and_then(|record_pat| record_pat.syntax().parent())\n+                    .or_else(|| Some(parent.clone()))\n+                    .and_then(|parent| {\n+                        ast::RecordFieldPatList::cast(parent)?\n+                            .syntax()\n+                            .parent()\n+                            .and_then(ast::RecordPat::cast)\n+                    });\n+\n+                // If this doesn't match a `RecordPat`, fallback to a `LetStmt` to see if\n+                // this is initialized from a `FieldExpr`.\n+                if let Some(record_pat) = record_pat {\n+                    self.type_of_pat(&ast::Pat::RecordPat(record_pat))\n+                } else if let Some(let_stmt) = ast::LetStmt::cast(parent) {\n+                    let field_expr = match let_stmt.initializer()? {\n+                        ast::Expr::FieldExpr(field_expr) => field_expr,\n+                        _ => return None,\n+                    };\n+\n+                    self.type_of_expr(&field_expr.expr()?)\n+                } else {\n+                    None\n+                }\n+            })\n+            // Binding a reference to a packed type is possibly unsafe.\n+            .map(|ty| ty.is_packed(self.db))\n+            .unwrap_or(false)\n+    }\n }\n \n pub trait ToDef: AstNode + Clone {"}]}