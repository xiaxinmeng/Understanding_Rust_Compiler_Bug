{"sha": "0b2e908691a2d5d35ebd877a2c3339b230b81eb0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiMmU5MDg2OTFhMmQ1ZDM1ZWJkODc3YTJjMzMzOWIyMzBiODFlYjA=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2021-04-29T00:13:56Z"}, "committer": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2021-04-30T04:10:15Z"}, "message": "Add support for --run for non-ui tests", "tree": {"sha": "df3308eb8047c2c52ed6fe1d4943028f4198bcd4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df3308eb8047c2c52ed6fe1d4943028f4198bcd4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b2e908691a2d5d35ebd877a2c3339b230b81eb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b2e908691a2d5d35ebd877a2c3339b230b81eb0", "html_url": "https://github.com/rust-lang/rust/commit/0b2e908691a2d5d35ebd877a2c3339b230b81eb0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b2e908691a2d5d35ebd877a2c3339b230b81eb0/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09783815b29fe6a8d0299bf883dba733f8a6fd1d", "url": "https://api.github.com/repos/rust-lang/rust/commits/09783815b29fe6a8d0299bf883dba733f8a6fd1d", "html_url": "https://github.com/rust-lang/rust/commit/09783815b29fe6a8d0299bf883dba733f8a6fd1d"}], "stats": {"total": 65, "additions": 43, "deletions": 22}, "files": [{"sha": "dd1e48a14684f293fb95c8b77508f62ccf5e0ca4", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0b2e908691a2d5d35ebd877a2c3339b230b81eb0/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b2e908691a2d5d35ebd877a2c3339b230b81eb0/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=0b2e908691a2d5d35ebd877a2c3339b230b81eb0", "patch": "@@ -294,12 +294,7 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n                     \"force {check,build,run}-pass tests to this mode.\",\n                     \"check | build | run\",\n                 );\n-                opts.optopt(\n-                    \"\",\n-                    \"run\",\n-                    \"whether to execute run-* tests\",\n-                    \"auto | always | never\",\n-                );\n+                opts.optopt(\"\", \"run\", \"whether to execute run-* tests\", \"auto | always | never\");\n                 opts.optflag(\n                     \"\",\n                     \"rustfix-coverage\","}, {"sha": "a044c4425b4e60c3be245d80184dad41ba26e14a", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 42, "deletions": 16, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/0b2e908691a2d5d35ebd877a2c3339b230b81eb0/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b2e908691a2d5d35ebd877a2c3339b230b81eb0/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=0b2e908691a2d5d35ebd877a2c3339b230b81eb0", "patch": "@@ -359,22 +359,20 @@ impl<'test> TestCx<'test> {\n \n     fn should_run(&self, pm: Option<PassMode>) -> WillExecute {\n         let test_should_run = match self.config.mode {\n-            Ui if pm == Some(PassMode::Run) || self.props.fail_mode == Some(FailMode::Run) => {\n-                true\n-            }\n+            Ui if pm == Some(PassMode::Run) || self.props.fail_mode == Some(FailMode::Run) => true,\n             MirOpt if pm == Some(PassMode::Run) => true,\n             Ui | MirOpt => false,\n             mode => panic!(\"unimplemented for mode {:?}\", mode),\n         };\n+        if test_should_run { self.run_if_enabled() } else { WillExecute::No }\n+    }\n+\n+    fn run_if_enabled(&self) -> WillExecute {\n         let enabled = self.config.run.unwrap_or_else(|| {\n             // Auto-detect whether to run based on the platform.\n             !self.config.target.ends_with(\"-fuchsia\")\n         });\n-        match (test_should_run, enabled) {\n-            (false, _) => WillExecute::No,\n-            (true, true) => WillExecute::Yes,\n-            (true, false) => WillExecute::Disabled,\n-        }\n+        if enabled { WillExecute::Yes } else { WillExecute::Disabled }\n     }\n \n     fn should_run_successfully(&self, pm: Option<PassMode>) -> bool {\n@@ -449,12 +447,17 @@ impl<'test> TestCx<'test> {\n \n     fn run_rfail_test(&self) {\n         let pm = self.pass_mode();\n-        let proc_res = self.compile_test(WillExecute::Yes, self.should_emit_metadata(pm));\n+        let should_run = self.run_if_enabled();\n+        let proc_res = self.compile_test(should_run, self.should_emit_metadata(pm));\n \n         if !proc_res.status.success() {\n             self.fatal_proc_rec(\"compilation failed!\", &proc_res);\n         }\n \n+        if let WillExecute::Disabled = should_run {\n+            return;\n+        }\n+\n         let proc_res = self.exec_compiled_test();\n \n         // The value our Makefile configures valgrind to return on failure\n@@ -493,12 +496,17 @@ impl<'test> TestCx<'test> {\n \n     fn run_rpass_test(&self) {\n         let emit_metadata = self.should_emit_metadata(self.pass_mode());\n-        let proc_res = self.compile_test(WillExecute::Yes, emit_metadata);\n+        let should_run = self.run_if_enabled();\n+        let proc_res = self.compile_test(should_run, emit_metadata);\n \n         if !proc_res.status.success() {\n             self.fatal_proc_rec(\"compilation failed!\", &proc_res);\n         }\n \n+        if let WillExecute::Disabled = should_run {\n+            return;\n+        }\n+\n         // FIXME(#41968): Move this check to tidy?\n         let expected_errors = errors::load_errors(&self.testpaths.file, self.revision);\n         assert!(\n@@ -520,12 +528,17 @@ impl<'test> TestCx<'test> {\n             return self.run_rpass_test();\n         }\n \n-        let mut proc_res = self.compile_test(WillExecute::Yes, EmitMetadata::No);\n+        let should_run = self.run_if_enabled();\n+        let mut proc_res = self.compile_test(should_run, EmitMetadata::No);\n \n         if !proc_res.status.success() {\n             self.fatal_proc_rec(\"compilation failed!\", &proc_res);\n         }\n \n+        if let WillExecute::Disabled = should_run {\n+            return;\n+        }\n+\n         let mut new_config = self.config.clone();\n         new_config.runtool = new_config.valgrind_path.clone();\n         let new_cx = TestCx { config: &new_config, ..*self };\n@@ -742,10 +755,14 @@ impl<'test> TestCx<'test> {\n \n     fn run_debuginfo_cdb_test_no_opt(&self) {\n         // compile test file (it should have 'compile-flags:-g' in the header)\n-        let compile_result = self.compile_test(WillExecute::Yes, EmitMetadata::No);\n+        let should_run = self.run_if_enabled();\n+        let compile_result = self.compile_test(should_run, EmitMetadata::No);\n         if !compile_result.status.success() {\n             self.fatal_proc_rec(\"compilation failed!\", &compile_result);\n         }\n+        if let WillExecute::Disabled = should_run {\n+            return;\n+        }\n \n         let exe_file = self.make_exe_name();\n \n@@ -836,10 +853,14 @@ impl<'test> TestCx<'test> {\n         let mut cmds = commands.join(\"\\n\");\n \n         // compile test file (it should have 'compile-flags:-g' in the header)\n-        let compiler_run_result = self.compile_test(WillExecute::Yes, EmitMetadata::No);\n+        let should_run = self.run_if_enabled();\n+        let compiler_run_result = self.compile_test(should_run, EmitMetadata::No);\n         if !compiler_run_result.status.success() {\n             self.fatal_proc_rec(\"compilation failed!\", &compiler_run_result);\n         }\n+        if let WillExecute::Disabled = should_run {\n+            return;\n+        }\n \n         let exe_file = self.make_exe_name();\n \n@@ -1054,10 +1075,14 @@ impl<'test> TestCx<'test> {\n \n     fn run_debuginfo_lldb_test_no_opt(&self) {\n         // compile test file (it should have 'compile-flags:-g' in the header)\n-        let compile_result = self.compile_test(WillExecute::Yes, EmitMetadata::No);\n+        let should_run = self.run_if_enabled();\n+        let compile_result = self.compile_test(should_run, EmitMetadata::No);\n         if !compile_result.status.success() {\n             self.fatal_proc_rec(\"compilation failed!\", &compile_result);\n         }\n+        if let WillExecute::Disabled = should_run {\n+            return;\n+        }\n \n         let exe_file = self.make_exe_name();\n \n@@ -1541,8 +1566,9 @@ impl<'test> TestCx<'test> {\n         // Only use `make_exe_name` when the test ends up being executed.\n         let output_file = match will_execute {\n             WillExecute::Yes => TargetLocation::ThisFile(self.make_exe_name()),\n-            WillExecute::No | WillExecute::Disabled =>\n-                TargetLocation::ThisDirectory(self.output_base_dir()),\n+            WillExecute::No | WillExecute::Disabled => {\n+                TargetLocation::ThisDirectory(self.output_base_dir())\n+            }\n         };\n \n         let allow_unused = match self.config.mode {"}]}