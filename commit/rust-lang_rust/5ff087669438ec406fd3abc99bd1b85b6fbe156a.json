{"sha": "5ff087669438ec406fd3abc99bd1b85b6fbe156a", "node_id": "C_kwDOAAsO6NoAKDVmZjA4NzY2OTQzOGVjNDA2ZmQzYWJjOTliZDFiODViNmZiZTE1NmE", "commit": {"author": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2022-02-09T14:11:51Z"}, "committer": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2022-08-23T08:12:58Z"}, "message": "Move personality functions to std\n\nThese were previously in the panic_unwind crate with dummy stubs in the\npanic_abort crate. However it turns out that this is insufficient: we\nstill need a proper personality function even with -C panic=abort to\nhandle the following cases:\n\n1) `extern \"C-unwind\"` still needs to catch foreign exceptions with -C\npanic=abort to turn them into aborts. This requires landing pads and a\npersonality function.\n\n2) ARM EHABI uses the personality function when creating backtraces.\nThe dummy personality function in panic_abort was causing backtrace\ngeneration to get stuck in a loop since the personality function is\nresponsible for advancing the unwind state to the next frame.", "tree": {"sha": "d273383af8014904fa5681e65f6c43af26ca4409", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d273383af8014904fa5681e65f6c43af26ca4409"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ff087669438ec406fd3abc99bd1b85b6fbe156a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ff087669438ec406fd3abc99bd1b85b6fbe156a", "html_url": "https://github.com/rust-lang/rust/commit/5ff087669438ec406fd3abc99bd1b85b6fbe156a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ff087669438ec406fd3abc99bd1b85b6fbe156a/comments", "author": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db94dbc597ac91cd5d16e898fa9081c09c879123", "url": "https://api.github.com/repos/rust-lang/rust/commits/db94dbc597ac91cd5d16e898fa9081c09c879123", "html_url": "https://github.com/rust-lang/rust/commit/db94dbc597ac91cd5d16e898fa9081c09c879123"}], "stats": {"total": 624, "additions": 347, "deletions": 277}, "files": [{"sha": "9a7ed2469626155d1d1f73ff1411f534ffd90030", "filename": "library/panic_abort/src/lib.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5ff087669438ec406fd3abc99bd1b85b6fbe156a/library%2Fpanic_abort%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ff087669438ec406fd3abc99bd1b85b6fbe156a/library%2Fpanic_abort%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_abort%2Fsrc%2Flib.rs?ref=5ff087669438ec406fd3abc99bd1b85b6fbe156a", "patch": "@@ -113,26 +113,6 @@ pub unsafe fn __rust_start_panic(_payload: *mut &mut dyn BoxMeUp) -> u32 {\n // binaries, but it should never be called as we don't link in an unwinding\n // runtime at all.\n pub mod personalities {\n-    #[rustc_std_internal_symbol]\n-    #[cfg(not(any(\n-        all(target_family = \"wasm\", not(target_os = \"emscripten\")),\n-        all(target_os = \"windows\", target_env = \"gnu\", target_arch = \"x86_64\",),\n-    )))]\n-    pub extern \"C\" fn rust_eh_personality() {}\n-\n-    // On x86_64-pc-windows-gnu we use our own personality function that needs\n-    // to return `ExceptionContinueSearch` as we're passing on all our frames.\n-    #[rustc_std_internal_symbol]\n-    #[cfg(all(target_os = \"windows\", target_env = \"gnu\", target_arch = \"x86_64\"))]\n-    pub extern \"C\" fn rust_eh_personality(\n-        _record: usize,\n-        _frame: usize,\n-        _context: usize,\n-        _dispatcher: usize,\n-    ) -> u32 {\n-        1 // `ExceptionContinueSearch`\n-    }\n-\n     // Similar to above, this corresponds to the `eh_catch_typeinfo` lang item\n     // that's only used on Emscripten currently.\n     //"}, {"sha": "7c233c7c3a1cb0f08626653e4bd218f2ece215fe", "filename": "library/panic_unwind/src/emcc.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5ff087669438ec406fd3abc99bd1b85b6fbe156a/library%2Fpanic_unwind%2Fsrc%2Femcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ff087669438ec406fd3abc99bd1b85b6fbe156a/library%2Fpanic_unwind%2Fsrc%2Femcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_unwind%2Fsrc%2Femcc.rs?ref=5ff087669438ec406fd3abc99bd1b85b6fbe156a", "patch": "@@ -12,7 +12,6 @@ use core::intrinsics;\n use core::mem;\n use core::ptr;\n use core::sync::atomic::{AtomicBool, Ordering};\n-use libc::{self, c_int};\n use unwind as uw;\n \n // This matches the layout of std::type_info in C++\n@@ -105,21 +104,6 @@ extern \"C\" fn exception_cleanup(ptr: *mut libc::c_void) -> *mut libc::c_void {\n     }\n }\n \n-// This is required by the compiler to exist (e.g., it's a lang item), but it's\n-// never actually called by the compiler.  Emscripten EH doesn't use a\n-// personality function at all, it instead uses __cxa_find_matching_catch.\n-// Wasm error handling would use __gxx_personality_wasm0.\n-#[lang = \"eh_personality\"]\n-unsafe extern \"C\" fn rust_eh_personality(\n-    _version: c_int,\n-    _actions: uw::_Unwind_Action,\n-    _exception_class: uw::_Unwind_Exception_Class,\n-    _exception_object: *mut uw::_Unwind_Exception,\n-    _context: *mut uw::_Unwind_Context,\n-) -> uw::_Unwind_Reason_Code {\n-    core::intrinsics::abort()\n-}\n-\n extern \"C\" {\n     fn __cxa_allocate_exception(thrown_size: libc::size_t) -> *mut libc::c_void;\n     fn __cxa_begin_catch(thrown_exception: *mut libc::c_void) -> *mut libc::c_void;"}, {"sha": "a5642178c8e639b7cfce9d17fe71a683a9cf10b9", "filename": "library/panic_unwind/src/gcc.rs", "status": "modified", "additions": 0, "deletions": 228, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/5ff087669438ec406fd3abc99bd1b85b6fbe156a/library%2Fpanic_unwind%2Fsrc%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ff087669438ec406fd3abc99bd1b85b6fbe156a/library%2Fpanic_unwind%2Fsrc%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_unwind%2Fsrc%2Fgcc.rs?ref=5ff087669438ec406fd3abc99bd1b85b6fbe156a", "patch": "@@ -39,8 +39,6 @@\n use alloc::boxed::Box;\n use core::any::Any;\n \n-use crate::dwarf::eh::{self, EHAction, EHContext};\n-use libc::{c_int, uintptr_t};\n use unwind as uw;\n \n #[repr(C)]\n@@ -90,232 +88,6 @@ fn rust_exception_class() -> uw::_Unwind_Exception_Class {\n     0x4d4f5a_00_52555354\n }\n \n-// Register ids were lifted from LLVM's TargetLowering::getExceptionPointerRegister()\n-// and TargetLowering::getExceptionSelectorRegister() for each architecture,\n-// then mapped to DWARF register numbers via register definition tables\n-// (typically <arch>RegisterInfo.td, search for \"DwarfRegNum\").\n-// See also https://llvm.org/docs/WritingAnLLVMBackend.html#defining-a-register.\n-\n-#[cfg(target_arch = \"x86\")]\n-const UNWIND_DATA_REG: (i32, i32) = (0, 2); // EAX, EDX\n-\n-#[cfg(target_arch = \"x86_64\")]\n-const UNWIND_DATA_REG: (i32, i32) = (0, 1); // RAX, RDX\n-\n-#[cfg(any(target_arch = \"arm\", target_arch = \"aarch64\"))]\n-const UNWIND_DATA_REG: (i32, i32) = (0, 1); // R0, R1 / X0, X1\n-\n-#[cfg(target_arch = \"m68k\")]\n-const UNWIND_DATA_REG: (i32, i32) = (0, 1); // D0, D1\n-\n-#[cfg(any(target_arch = \"mips\", target_arch = \"mips64\"))]\n-const UNWIND_DATA_REG: (i32, i32) = (4, 5); // A0, A1\n-\n-#[cfg(any(target_arch = \"powerpc\", target_arch = \"powerpc64\"))]\n-const UNWIND_DATA_REG: (i32, i32) = (3, 4); // R3, R4 / X3, X4\n-\n-#[cfg(target_arch = \"s390x\")]\n-const UNWIND_DATA_REG: (i32, i32) = (6, 7); // R6, R7\n-\n-#[cfg(any(target_arch = \"sparc\", target_arch = \"sparc64\"))]\n-const UNWIND_DATA_REG: (i32, i32) = (24, 25); // I0, I1\n-\n-#[cfg(target_arch = \"hexagon\")]\n-const UNWIND_DATA_REG: (i32, i32) = (0, 1); // R0, R1\n-\n-#[cfg(any(target_arch = \"riscv64\", target_arch = \"riscv32\"))]\n-const UNWIND_DATA_REG: (i32, i32) = (10, 11); // x10, x11\n-\n-// The following code is based on GCC's C and C++ personality routines.  For reference, see:\n-// https://github.com/gcc-mirror/gcc/blob/master/libstdc++-v3/libsupc++/eh_personality.cc\n-// https://github.com/gcc-mirror/gcc/blob/trunk/libgcc/unwind-c.c\n-\n-cfg_if::cfg_if! {\n-    if #[cfg(all(target_arch = \"arm\", not(target_os = \"ios\"), not(target_os = \"watchos\"), not(target_os = \"netbsd\")))] {\n-        // ARM EHABI personality routine.\n-        // https://infocenter.arm.com/help/topic/com.arm.doc.ihi0038b/IHI0038B_ehabi.pdf\n-        //\n-        // iOS uses the default routine instead since it uses SjLj unwinding.\n-        #[lang = \"eh_personality\"]\n-        unsafe extern \"C\" fn rust_eh_personality(state: uw::_Unwind_State,\n-                                                 exception_object: *mut uw::_Unwind_Exception,\n-                                                 context: *mut uw::_Unwind_Context)\n-                                                 -> uw::_Unwind_Reason_Code {\n-            let state = state as c_int;\n-            let action = state & uw::_US_ACTION_MASK as c_int;\n-            let search_phase = if action == uw::_US_VIRTUAL_UNWIND_FRAME as c_int {\n-                // Backtraces on ARM will call the personality routine with\n-                // state == _US_VIRTUAL_UNWIND_FRAME | _US_FORCE_UNWIND. In those cases\n-                // we want to continue unwinding the stack, otherwise all our backtraces\n-                // would end at __rust_try\n-                if state & uw::_US_FORCE_UNWIND as c_int != 0 {\n-                    return continue_unwind(exception_object, context);\n-                }\n-                true\n-            } else if action == uw::_US_UNWIND_FRAME_STARTING as c_int {\n-                false\n-            } else if action == uw::_US_UNWIND_FRAME_RESUME as c_int {\n-                return continue_unwind(exception_object, context);\n-            } else {\n-                return uw::_URC_FAILURE;\n-            };\n-\n-            // The DWARF unwinder assumes that _Unwind_Context holds things like the function\n-            // and LSDA pointers, however ARM EHABI places them into the exception object.\n-            // To preserve signatures of functions like _Unwind_GetLanguageSpecificData(), which\n-            // take only the context pointer, GCC personality routines stash a pointer to\n-            // exception_object in the context, using location reserved for ARM's\n-            // \"scratch register\" (r12).\n-            uw::_Unwind_SetGR(context,\n-                              uw::UNWIND_POINTER_REG,\n-                              exception_object as uw::_Unwind_Ptr);\n-            // ...A more principled approach would be to provide the full definition of ARM's\n-            // _Unwind_Context in our libunwind bindings and fetch the required data from there\n-            // directly, bypassing DWARF compatibility functions.\n-\n-            let eh_action = match find_eh_action(context) {\n-                Ok(action) => action,\n-                Err(_) => return uw::_URC_FAILURE,\n-            };\n-            if search_phase {\n-                match eh_action {\n-                    EHAction::None |\n-                    EHAction::Cleanup(_) => return continue_unwind(exception_object, context),\n-                    EHAction::Catch(_) => {\n-                        // EHABI requires the personality routine to update the\n-                        // SP value in the barrier cache of the exception object.\n-                        (*exception_object).private[5] =\n-                            uw::_Unwind_GetGR(context, uw::UNWIND_SP_REG);\n-                        return uw::_URC_HANDLER_FOUND;\n-                    }\n-                    EHAction::Terminate => return uw::_URC_FAILURE,\n-                }\n-            } else {\n-                match eh_action {\n-                    EHAction::None => return continue_unwind(exception_object, context),\n-                    EHAction::Cleanup(lpad) |\n-                    EHAction::Catch(lpad) => {\n-                        uw::_Unwind_SetGR(context, UNWIND_DATA_REG.0,\n-                                          exception_object as uintptr_t);\n-                        uw::_Unwind_SetGR(context, UNWIND_DATA_REG.1, 0);\n-                        uw::_Unwind_SetIP(context, lpad);\n-                        return uw::_URC_INSTALL_CONTEXT;\n-                    }\n-                    EHAction::Terminate => return uw::_URC_FAILURE,\n-                }\n-            }\n-\n-            // On ARM EHABI the personality routine is responsible for actually\n-            // unwinding a single stack frame before returning (ARM EHABI Sec. 6.1).\n-            unsafe fn continue_unwind(exception_object: *mut uw::_Unwind_Exception,\n-                                      context: *mut uw::_Unwind_Context)\n-                                      -> uw::_Unwind_Reason_Code {\n-                if __gnu_unwind_frame(exception_object, context) == uw::_URC_NO_REASON {\n-                    uw::_URC_CONTINUE_UNWIND\n-                } else {\n-                    uw::_URC_FAILURE\n-                }\n-            }\n-            // defined in libgcc\n-            extern \"C\" {\n-                fn __gnu_unwind_frame(exception_object: *mut uw::_Unwind_Exception,\n-                                      context: *mut uw::_Unwind_Context)\n-                                      -> uw::_Unwind_Reason_Code;\n-            }\n-        }\n-    } else {\n-        // Default personality routine, which is used directly on most targets\n-        // and indirectly on Windows x86_64 via SEH.\n-        unsafe extern \"C\" fn rust_eh_personality_impl(version: c_int,\n-                                                      actions: uw::_Unwind_Action,\n-                                                      _exception_class: uw::_Unwind_Exception_Class,\n-                                                      exception_object: *mut uw::_Unwind_Exception,\n-                                                      context: *mut uw::_Unwind_Context)\n-                                                      -> uw::_Unwind_Reason_Code {\n-            if version != 1 {\n-                return uw::_URC_FATAL_PHASE1_ERROR;\n-            }\n-            let eh_action = match find_eh_action(context) {\n-                Ok(action) => action,\n-                Err(_) => return uw::_URC_FATAL_PHASE1_ERROR,\n-            };\n-            if actions as i32 & uw::_UA_SEARCH_PHASE as i32 != 0 {\n-                match eh_action {\n-                    EHAction::None |\n-                    EHAction::Cleanup(_) => uw::_URC_CONTINUE_UNWIND,\n-                    EHAction::Catch(_) => uw::_URC_HANDLER_FOUND,\n-                    EHAction::Terminate => uw::_URC_FATAL_PHASE1_ERROR,\n-                }\n-            } else {\n-                match eh_action {\n-                    EHAction::None => uw::_URC_CONTINUE_UNWIND,\n-                    EHAction::Cleanup(lpad) |\n-                    EHAction::Catch(lpad) => {\n-                        uw::_Unwind_SetGR(context, UNWIND_DATA_REG.0,\n-                            exception_object as uintptr_t);\n-                        uw::_Unwind_SetGR(context, UNWIND_DATA_REG.1, 0);\n-                        uw::_Unwind_SetIP(context, lpad);\n-                        uw::_URC_INSTALL_CONTEXT\n-                    }\n-                    EHAction::Terminate => uw::_URC_FATAL_PHASE2_ERROR,\n-                }\n-            }\n-        }\n-\n-        cfg_if::cfg_if! {\n-            if #[cfg(all(windows, target_arch = \"x86_64\", target_env = \"gnu\"))] {\n-                // On x86_64 MinGW targets, the unwinding mechanism is SEH however the unwind\n-                // handler data (aka LSDA) uses GCC-compatible encoding.\n-                #[lang = \"eh_personality\"]\n-                #[allow(nonstandard_style)]\n-                unsafe extern \"C\" fn rust_eh_personality(exceptionRecord: *mut uw::EXCEPTION_RECORD,\n-                        establisherFrame: uw::LPVOID,\n-                        contextRecord: *mut uw::CONTEXT,\n-                        dispatcherContext: *mut uw::DISPATCHER_CONTEXT)\n-                        -> uw::EXCEPTION_DISPOSITION {\n-                    uw::_GCC_specific_handler(exceptionRecord,\n-                                             establisherFrame,\n-                                             contextRecord,\n-                                             dispatcherContext,\n-                                             rust_eh_personality_impl)\n-                }\n-            } else {\n-                // The personality routine for most of our targets.\n-                #[lang = \"eh_personality\"]\n-                unsafe extern \"C\" fn rust_eh_personality(version: c_int,\n-                        actions: uw::_Unwind_Action,\n-                        exception_class: uw::_Unwind_Exception_Class,\n-                        exception_object: *mut uw::_Unwind_Exception,\n-                        context: *mut uw::_Unwind_Context)\n-                        -> uw::_Unwind_Reason_Code {\n-                    rust_eh_personality_impl(version,\n-                                             actions,\n-                                             exception_class,\n-                                             exception_object,\n-                                             context)\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-unsafe fn find_eh_action(context: *mut uw::_Unwind_Context) -> Result<EHAction, ()> {\n-    let lsda = uw::_Unwind_GetLanguageSpecificData(context) as *const u8;\n-    let mut ip_before_instr: c_int = 0;\n-    let ip = uw::_Unwind_GetIPInfo(context, &mut ip_before_instr);\n-    let eh_context = EHContext {\n-        // The return address points 1 byte past the call instruction,\n-        // which could be in the next IP range in LSDA range table.\n-        //\n-        // `ip = -1` has special meaning, so use wrapping sub to allow for that\n-        ip: if ip_before_instr != 0 { ip } else { ip.wrapping_sub(1) },\n-        func_start: uw::_Unwind_GetRegionStart(context),\n-        get_text_start: &|| uw::_Unwind_GetTextRelBase(context),\n-        get_data_start: &|| uw::_Unwind_GetDataRelBase(context),\n-    };\n-    eh::find_eh_action(lsda, &eh_context)\n-}\n-\n // Frame unwind info registration\n //\n // Each module's image contains a frame unwind info section (usually"}, {"sha": "55c3c90c42812583dba61a1accf7b79c8fe5e63a", "filename": "library/panic_unwind/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ff087669438ec406fd3abc99bd1b85b6fbe156a/library%2Fpanic_unwind%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ff087669438ec406fd3abc99bd1b85b6fbe156a/library%2Fpanic_unwind%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_unwind%2Fsrc%2Flib.rs?ref=5ff087669438ec406fd3abc99bd1b85b6fbe156a", "patch": "@@ -92,8 +92,6 @@ extern \"C\" {\n     fn __rust_foreign_exception() -> !;\n }\n \n-mod dwarf;\n-\n #[rustc_std_internal_symbol]\n #[allow(improper_ctypes_definitions)]\n pub unsafe extern \"C\" fn __rust_panic_cleanup(payload: *mut u8) -> *mut (dyn Any + Send + 'static) {"}, {"sha": "f71c47270ee371df0490d079b00f1b81144374dd", "filename": "library/panic_unwind/src/seh.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5ff087669438ec406fd3abc99bd1b85b6fbe156a/library%2Fpanic_unwind%2Fsrc%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ff087669438ec406fd3abc99bd1b85b6fbe156a/library%2Fpanic_unwind%2Fsrc%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_unwind%2Fsrc%2Fseh.rs?ref=5ff087669438ec406fd3abc99bd1b85b6fbe156a", "patch": "@@ -323,13 +323,3 @@ pub unsafe fn cleanup(payload: *mut u8) -> Box<dyn Any + Send> {\n         exception.data.take().unwrap()\n     }\n }\n-\n-// This is required by the compiler to exist (e.g., it's a lang item), but\n-// it's never actually called by the compiler because _CxxFrameHandler3\n-// is the personality function that is always used.\n-// Hence this is just an aborting stub.\n-#[lang = \"eh_personality\"]\n-#[cfg(not(test))]\n-fn rust_eh_personality() {\n-    core::intrinsics::abort()\n-}"}, {"sha": "f378c283bab542fb408b025fcfc9f06b66f34d77", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5ff087669438ec406fd3abc99bd1b85b6fbe156a/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ff087669438ec406fd3abc99bd1b85b6fbe156a/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=5ff087669438ec406fd3abc99bd1b85b6fbe156a", "patch": "@@ -591,6 +591,7 @@ pub mod alloc;\n \n // Private support modules\n mod panicking;\n+mod personality;\n \n #[path = \"../../backtrace/src/lib.rs\"]\n #[allow(dead_code, unused_attributes)]"}, {"sha": "63f0ad4f16e34f1d38f2bded34dba2b7efb0db4f", "filename": "library/std/src/personality.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5ff087669438ec406fd3abc99bd1b85b6fbe156a/library%2Fstd%2Fsrc%2Fpersonality.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ff087669438ec406fd3abc99bd1b85b6fbe156a/library%2Fstd%2Fsrc%2Fpersonality.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpersonality.rs?ref=5ff087669438ec406fd3abc99bd1b85b6fbe156a", "patch": "@@ -0,0 +1,46 @@\n+//! This module contains the implementation of the `eh_personality` lang item.\n+//!\n+//! The actual implementation is heavily dependent on the target since Rust\n+//! tries to use the native stack unwinding mechanism whenever possible.\n+//!\n+//! This personality function is still required with `-C panic=abort` because\n+//! it is used to catch foreign exceptions from `extern \"C-unwind\"` and turn\n+//! them into aborts.\n+//!\n+//! Additionally, ARM EHABI uses the personality function when generating\n+//! backtraces.\n+\n+mod dwarf;\n+\n+#[cfg(not(test))]\n+cfg_if::cfg_if! {\n+    if #[cfg(target_os = \"emscripten\")] {\n+        mod emcc;\n+    } else if #[cfg(target_env = \"msvc\")] {\n+        // This is required by the compiler to exist (e.g., it's a lang item),\n+        // but it's never actually called by the compiler because\n+        // _CxxFrameHandler3 is the personality function that is always used.\n+        // Hence this is just an aborting stub.\n+        #[lang = \"eh_personality\"]\n+        fn rust_eh_personality() {\n+            core::intrinsics::abort()\n+        }\n+    } else if #[cfg(any(\n+        all(target_family = \"windows\", target_env = \"gnu\"),\n+        target_os = \"psp\",\n+        target_os = \"solid_asp3\",\n+        all(target_family = \"unix\", not(target_os = \"espidf\")),\n+        all(target_vendor = \"fortanix\", target_env = \"sgx\"),\n+    ))] {\n+        mod gcc;\n+    } else {\n+        // Targets that don't support unwinding.\n+        // - family=wasm\n+        // - os=none (\"bare metal\" targets)\n+        // - os=uefi\n+        // - os=espidf\n+        // - os=hermit\n+        // - nvptx64-nvidia-cuda\n+        // - arch=avr\n+    }\n+}"}, {"sha": "8799137b78f98bc8cb1db7a7d4ddcc93b596fa8e", "filename": "library/std/src/personality/dwarf/eh.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ff087669438ec406fd3abc99bd1b85b6fbe156a/library%2Fstd%2Fsrc%2Fpersonality%2Fdwarf%2Feh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ff087669438ec406fd3abc99bd1b85b6fbe156a/library%2Fstd%2Fsrc%2Fpersonality%2Fdwarf%2Feh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpersonality%2Fdwarf%2Feh.rs?ref=5ff087669438ec406fd3abc99bd1b85b6fbe156a", "patch": "@@ -11,7 +11,7 @@\n #![allow(non_upper_case_globals)]\n #![allow(unused)]\n \n-use crate::dwarf::DwarfReader;\n+use super::DwarfReader;\n use core::mem;\n \n pub const DW_EH_PE_omit: u8 = 0xFF;", "previous_filename": "library/panic_unwind/src/dwarf/eh.rs"}, {"sha": "652fbe95a14d195f39281a727d056b5f78aede60", "filename": "library/std/src/personality/dwarf/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5ff087669438ec406fd3abc99bd1b85b6fbe156a/library%2Fstd%2Fsrc%2Fpersonality%2Fdwarf%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ff087669438ec406fd3abc99bd1b85b6fbe156a/library%2Fstd%2Fsrc%2Fpersonality%2Fdwarf%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpersonality%2Fdwarf%2Fmod.rs?ref=5ff087669438ec406fd3abc99bd1b85b6fbe156a", "previous_filename": "library/panic_unwind/src/dwarf/mod.rs"}, {"sha": "1644f37083a5bbdaa3f7f8fc2b44f4f93b6a9982", "filename": "library/std/src/personality/dwarf/tests.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5ff087669438ec406fd3abc99bd1b85b6fbe156a/library%2Fstd%2Fsrc%2Fpersonality%2Fdwarf%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ff087669438ec406fd3abc99bd1b85b6fbe156a/library%2Fstd%2Fsrc%2Fpersonality%2Fdwarf%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpersonality%2Fdwarf%2Ftests.rs?ref=5ff087669438ec406fd3abc99bd1b85b6fbe156a", "previous_filename": "library/panic_unwind/src/dwarf/tests.rs"}, {"sha": "f942bdf18c1806ef55ab60733e2f2bb26a7062b5", "filename": "library/std/src/personality/emcc.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5ff087669438ec406fd3abc99bd1b85b6fbe156a/library%2Fstd%2Fsrc%2Fpersonality%2Femcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ff087669438ec406fd3abc99bd1b85b6fbe156a/library%2Fstd%2Fsrc%2Fpersonality%2Femcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpersonality%2Femcc.rs?ref=5ff087669438ec406fd3abc99bd1b85b6fbe156a", "patch": "@@ -0,0 +1,20 @@\n+//! On Emscripten Rust panics are wrapped in C++ exceptions, so we just forward\n+//! to `__gxx_personality_v0` which is provided by Emscripten.\n+\n+use libc::c_int;\n+use unwind as uw;\n+\n+// This is required by the compiler to exist (e.g., it's a lang item), but it's\n+// never actually called by the compiler.  Emscripten EH doesn't use a\n+// personality function at all, it instead uses __cxa_find_matching_catch.\n+// Wasm error handling would use __gxx_personality_wasm0.\n+#[lang = \"eh_personality\"]\n+unsafe extern \"C\" fn rust_eh_personality(\n+    _version: c_int,\n+    _actions: uw::_Unwind_Action,\n+    _exception_class: uw::_Unwind_Exception_Class,\n+    _exception_object: *mut uw::_Unwind_Exception,\n+    _context: *mut uw::_Unwind_Context,\n+) -> uw::_Unwind_Reason_Code {\n+    core::intrinsics::abort()\n+}"}, {"sha": "7f0b0439cf08380ba65cf316bcf542c215bedfcd", "filename": "library/std/src/personality/gcc.rs", "status": "added", "additions": 279, "deletions": 0, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/5ff087669438ec406fd3abc99bd1b85b6fbe156a/library%2Fstd%2Fsrc%2Fpersonality%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ff087669438ec406fd3abc99bd1b85b6fbe156a/library%2Fstd%2Fsrc%2Fpersonality%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpersonality%2Fgcc.rs?ref=5ff087669438ec406fd3abc99bd1b85b6fbe156a", "patch": "@@ -0,0 +1,279 @@\n+//! Implementation of panics backed by libgcc/libunwind (in some form).\n+//!\n+//! For background on exception handling and stack unwinding please see\n+//! \"Exception Handling in LLVM\" (llvm.org/docs/ExceptionHandling.html) and\n+//! documents linked from it.\n+//! These are also good reads:\n+//!  * <https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html>\n+//!  * <https://monoinfinito.wordpress.com/series/exception-handling-in-c/>\n+//!  * <https://www.airs.com/blog/index.php?s=exception+frames>\n+//!\n+//! ## A brief summary\n+//!\n+//! Exception handling happens in two phases: a search phase and a cleanup\n+//! phase.\n+//!\n+//! In both phases the unwinder walks stack frames from top to bottom using\n+//! information from the stack frame unwind sections of the current process's\n+//! modules (\"module\" here refers to an OS module, i.e., an executable or a\n+//! dynamic library).\n+//!\n+//! For each stack frame, it invokes the associated \"personality routine\", whose\n+//! address is also stored in the unwind info section.\n+//!\n+//! In the search phase, the job of a personality routine is to examine\n+//! exception object being thrown, and to decide whether it should be caught at\n+//! that stack frame. Once the handler frame has been identified, cleanup phase\n+//! begins.\n+//!\n+//! In the cleanup phase, the unwinder invokes each personality routine again.\n+//! This time it decides which (if any) cleanup code needs to be run for\n+//! the current stack frame. If so, the control is transferred to a special\n+//! branch in the function body, the \"landing pad\", which invokes destructors,\n+//! frees memory, etc. At the end of the landing pad, control is transferred\n+//! back to the unwinder and unwinding resumes.\n+//!\n+//! Once stack has been unwound down to the handler frame level, unwinding stops\n+//! and the last personality routine transfers control to the catch block.\n+\n+use super::dwarf::eh::{self, EHAction, EHContext};\n+use libc::{c_int, uintptr_t};\n+use unwind as uw;\n+\n+// Register ids were lifted from LLVM's TargetLowering::getExceptionPointerRegister()\n+// and TargetLowering::getExceptionSelectorRegister() for each architecture,\n+// then mapped to DWARF register numbers via register definition tables\n+// (typically <arch>RegisterInfo.td, search for \"DwarfRegNum\").\n+// See also https://llvm.org/docs/WritingAnLLVMBackend.html#defining-a-register.\n+\n+#[cfg(target_arch = \"x86\")]\n+const UNWIND_DATA_REG: (i32, i32) = (0, 2); // EAX, EDX\n+\n+#[cfg(target_arch = \"x86_64\")]\n+const UNWIND_DATA_REG: (i32, i32) = (0, 1); // RAX, RDX\n+\n+#[cfg(any(target_arch = \"arm\", target_arch = \"aarch64\"))]\n+const UNWIND_DATA_REG: (i32, i32) = (0, 1); // R0, R1 / X0, X1\n+\n+#[cfg(target_arch = \"m68k\")]\n+const UNWIND_DATA_REG: (i32, i32) = (0, 1); // D0, D1\n+\n+#[cfg(any(target_arch = \"mips\", target_arch = \"mips64\"))]\n+const UNWIND_DATA_REG: (i32, i32) = (4, 5); // A0, A1\n+\n+#[cfg(any(target_arch = \"powerpc\", target_arch = \"powerpc64\"))]\n+const UNWIND_DATA_REG: (i32, i32) = (3, 4); // R3, R4 / X3, X4\n+\n+#[cfg(target_arch = \"s390x\")]\n+const UNWIND_DATA_REG: (i32, i32) = (6, 7); // R6, R7\n+\n+#[cfg(any(target_arch = \"sparc\", target_arch = \"sparc64\"))]\n+const UNWIND_DATA_REG: (i32, i32) = (24, 25); // I0, I1\n+\n+#[cfg(target_arch = \"hexagon\")]\n+const UNWIND_DATA_REG: (i32, i32) = (0, 1); // R0, R1\n+\n+#[cfg(any(target_arch = \"riscv64\", target_arch = \"riscv32\"))]\n+const UNWIND_DATA_REG: (i32, i32) = (10, 11); // x10, x11\n+\n+// The following code is based on GCC's C and C++ personality routines.  For reference, see:\n+// https://github.com/gcc-mirror/gcc/blob/master/libstdc++-v3/libsupc++/eh_personality.cc\n+// https://github.com/gcc-mirror/gcc/blob/trunk/libgcc/unwind-c.c\n+\n+cfg_if::cfg_if! {\n+    if #[cfg(all(target_arch = \"arm\", not(target_os = \"ios\"), not(target_os = \"watchos\"), not(target_os = \"netbsd\")))] {\n+        // ARM EHABI personality routine.\n+        // https://infocenter.arm.com/help/topic/com.arm.doc.ihi0038b/IHI0038B_ehabi.pdf\n+        //\n+        // iOS uses the default routine instead since it uses SjLj unwinding.\n+        #[lang = \"eh_personality\"]\n+        unsafe extern \"C\" fn rust_eh_personality(\n+            state: uw::_Unwind_State,\n+            exception_object: *mut uw::_Unwind_Exception,\n+            context: *mut uw::_Unwind_Context,\n+        ) -> uw::_Unwind_Reason_Code {\n+            let state = state as c_int;\n+            let action = state & uw::_US_ACTION_MASK as c_int;\n+            let search_phase = if action == uw::_US_VIRTUAL_UNWIND_FRAME as c_int {\n+                // Backtraces on ARM will call the personality routine with\n+                // state == _US_VIRTUAL_UNWIND_FRAME | _US_FORCE_UNWIND. In those cases\n+                // we want to continue unwinding the stack, otherwise all our backtraces\n+                // would end at __rust_try\n+                if state & uw::_US_FORCE_UNWIND as c_int != 0 {\n+                    return continue_unwind(exception_object, context);\n+                }\n+                true\n+            } else if action == uw::_US_UNWIND_FRAME_STARTING as c_int {\n+                false\n+            } else if action == uw::_US_UNWIND_FRAME_RESUME as c_int {\n+                return continue_unwind(exception_object, context);\n+            } else {\n+                return uw::_URC_FAILURE;\n+            };\n+\n+            // The DWARF unwinder assumes that _Unwind_Context holds things like the function\n+            // and LSDA pointers, however ARM EHABI places them into the exception object.\n+            // To preserve signatures of functions like _Unwind_GetLanguageSpecificData(), which\n+            // take only the context pointer, GCC personality routines stash a pointer to\n+            // exception_object in the context, using location reserved for ARM's\n+            // \"scratch register\" (r12).\n+            uw::_Unwind_SetGR(context, uw::UNWIND_POINTER_REG, exception_object as uw::_Unwind_Ptr);\n+            // ...A more principled approach would be to provide the full definition of ARM's\n+            // _Unwind_Context in our libunwind bindings and fetch the required data from there\n+            // directly, bypassing DWARF compatibility functions.\n+\n+            let eh_action = match find_eh_action(context) {\n+                Ok(action) => action,\n+                Err(_) => return uw::_URC_FAILURE,\n+            };\n+            if search_phase {\n+                match eh_action {\n+                    EHAction::None | EHAction::Cleanup(_) => {\n+                        return continue_unwind(exception_object, context);\n+                    }\n+                    EHAction::Catch(_) => {\n+                        // EHABI requires the personality routine to update the\n+                        // SP value in the barrier cache of the exception object.\n+                        (*exception_object).private[5] =\n+                            uw::_Unwind_GetGR(context, uw::UNWIND_SP_REG);\n+                        return uw::_URC_HANDLER_FOUND;\n+                    }\n+                    EHAction::Terminate => return uw::_URC_FAILURE,\n+                }\n+            } else {\n+                match eh_action {\n+                    EHAction::None => return continue_unwind(exception_object, context),\n+                    EHAction::Cleanup(lpad) | EHAction::Catch(lpad) => {\n+                        uw::_Unwind_SetGR(\n+                            context,\n+                            UNWIND_DATA_REG.0,\n+                            exception_object as uintptr_t,\n+                        );\n+                        uw::_Unwind_SetGR(context, UNWIND_DATA_REG.1, 0);\n+                        uw::_Unwind_SetIP(context, lpad);\n+                        return uw::_URC_INSTALL_CONTEXT;\n+                    }\n+                    EHAction::Terminate => return uw::_URC_FAILURE,\n+                }\n+            }\n+\n+            // On ARM EHABI the personality routine is responsible for actually\n+            // unwinding a single stack frame before returning (ARM EHABI Sec. 6.1).\n+            unsafe fn continue_unwind(\n+                exception_object: *mut uw::_Unwind_Exception,\n+                context: *mut uw::_Unwind_Context,\n+            ) -> uw::_Unwind_Reason_Code {\n+                if __gnu_unwind_frame(exception_object, context) == uw::_URC_NO_REASON {\n+                    uw::_URC_CONTINUE_UNWIND\n+                } else {\n+                    uw::_URC_FAILURE\n+                }\n+            }\n+            // defined in libgcc\n+            extern \"C\" {\n+                fn __gnu_unwind_frame(\n+                    exception_object: *mut uw::_Unwind_Exception,\n+                    context: *mut uw::_Unwind_Context,\n+                ) -> uw::_Unwind_Reason_Code;\n+            }\n+        }\n+    } else {\n+        // Default personality routine, which is used directly on most targets\n+        // and indirectly on Windows x86_64 via SEH.\n+        unsafe extern \"C\" fn rust_eh_personality_impl(\n+            version: c_int,\n+            actions: uw::_Unwind_Action,\n+            _exception_class: uw::_Unwind_Exception_Class,\n+            exception_object: *mut uw::_Unwind_Exception,\n+            context: *mut uw::_Unwind_Context,\n+        ) -> uw::_Unwind_Reason_Code {\n+            if version != 1 {\n+                return uw::_URC_FATAL_PHASE1_ERROR;\n+            }\n+            let eh_action = match find_eh_action(context) {\n+                Ok(action) => action,\n+                Err(_) => return uw::_URC_FATAL_PHASE1_ERROR,\n+            };\n+            if actions as i32 & uw::_UA_SEARCH_PHASE as i32 != 0 {\n+                match eh_action {\n+                    EHAction::None | EHAction::Cleanup(_) => uw::_URC_CONTINUE_UNWIND,\n+                    EHAction::Catch(_) => uw::_URC_HANDLER_FOUND,\n+                    EHAction::Terminate => uw::_URC_FATAL_PHASE1_ERROR,\n+                }\n+            } else {\n+                match eh_action {\n+                    EHAction::None => uw::_URC_CONTINUE_UNWIND,\n+                    EHAction::Cleanup(lpad) | EHAction::Catch(lpad) => {\n+                        uw::_Unwind_SetGR(\n+                            context,\n+                            UNWIND_DATA_REG.0,\n+                            exception_object as uintptr_t,\n+                        );\n+                        uw::_Unwind_SetGR(context, UNWIND_DATA_REG.1, 0);\n+                        uw::_Unwind_SetIP(context, lpad);\n+                        uw::_URC_INSTALL_CONTEXT\n+                    }\n+                    EHAction::Terminate => uw::_URC_FATAL_PHASE2_ERROR,\n+                }\n+            }\n+        }\n+\n+        cfg_if::cfg_if! {\n+            if #[cfg(all(windows, target_arch = \"x86_64\", target_env = \"gnu\"))] {\n+                // On x86_64 MinGW targets, the unwinding mechanism is SEH however the unwind\n+                // handler data (aka LSDA) uses GCC-compatible encoding.\n+                #[lang = \"eh_personality\"]\n+                #[allow(nonstandard_style)]\n+                unsafe extern \"C\" fn rust_eh_personality(\n+                    exceptionRecord: *mut uw::EXCEPTION_RECORD,\n+                    establisherFrame: uw::LPVOID,\n+                    contextRecord: *mut uw::CONTEXT,\n+                    dispatcherContext: *mut uw::DISPATCHER_CONTEXT,\n+                ) -> uw::EXCEPTION_DISPOSITION {\n+                    uw::_GCC_specific_handler(\n+                        exceptionRecord,\n+                        establisherFrame,\n+                        contextRecord,\n+                        dispatcherContext,\n+                        rust_eh_personality_impl,\n+                    )\n+                }\n+            } else {\n+                // The personality routine for most of our targets.\n+                #[lang = \"eh_personality\"]\n+                unsafe extern \"C\" fn rust_eh_personality(\n+                    version: c_int,\n+                    actions: uw::_Unwind_Action,\n+                    exception_class: uw::_Unwind_Exception_Class,\n+                    exception_object: *mut uw::_Unwind_Exception,\n+                    context: *mut uw::_Unwind_Context,\n+                ) -> uw::_Unwind_Reason_Code {\n+                    rust_eh_personality_impl(\n+                        version,\n+                        actions,\n+                        exception_class,\n+                        exception_object,\n+                        context,\n+                    )\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+unsafe fn find_eh_action(context: *mut uw::_Unwind_Context) -> Result<EHAction, ()> {\n+    let lsda = uw::_Unwind_GetLanguageSpecificData(context) as *const u8;\n+    let mut ip_before_instr: c_int = 0;\n+    let ip = uw::_Unwind_GetIPInfo(context, &mut ip_before_instr);\n+    let eh_context = EHContext {\n+        // The return address points 1 byte past the call instruction,\n+        // which could be in the next IP range in LSDA range table.\n+        //\n+        // `ip = -1` has special meaning, so use wrapping sub to allow for that\n+        ip: if ip_before_instr != 0 { ip } else { ip.wrapping_sub(1) },\n+        func_start: uw::_Unwind_GetRegionStart(context),\n+        get_text_start: &|| uw::_Unwind_GetTextRelBase(context),\n+        get_data_start: &|| uw::_Unwind_GetDataRelBase(context),\n+    };\n+    eh::find_eh_action(lsda, &eh_context)\n+}"}]}