{"sha": "ec48b4ebe24c24d9d43a3dbf57c28c249343d776", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjNDhiNGViZTI0YzI0ZDlkNDNhM2RiZjU3YzI4YzI0OTM0M2Q3NzY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-06-07T19:57:09Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-07-02T16:15:20Z"}, "message": "preliminary integration of \"pick constraints\" into nll solver", "tree": {"sha": "2bb1bf973eebe73f18647a4e4cdc94eeea8d8a7e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2bb1bf973eebe73f18647a4e4cdc94eeea8d8a7e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec48b4ebe24c24d9d43a3dbf57c28c249343d776", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec48b4ebe24c24d9d43a3dbf57c28c249343d776", "html_url": "https://github.com/rust-lang/rust/commit/ec48b4ebe24c24d9d43a3dbf57c28c249343d776", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec48b4ebe24c24d9d43a3dbf57c28c249343d776/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b5a7276d2ca4d3c5081db6b12114a93aeb5c822", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b5a7276d2ca4d3c5081db6b12114a93aeb5c822", "html_url": "https://github.com/rust-lang/rust/commit/3b5a7276d2ca4d3c5081db6b12114a93aeb5c822"}], "stats": {"total": 358, "additions": 231, "deletions": 127}, "files": [{"sha": "5a89fd89941d4fd6a6799fcaf6407c6125f0039c", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ec48b4ebe24c24d9d43a3dbf57c28c249343d776/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec48b4ebe24c24d9d43a3dbf57c28c249343d776/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=ec48b4ebe24c24d9d43a3dbf57c28c249343d776", "patch": "@@ -385,13 +385,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         option_regions: _,\n                     } => {\n                         let hidden_ty = self.resolve_vars_if_possible(&hidden_ty);\n-                        opaque_types::report_unexpected_hidden_region(\n+                        opaque_types::unexpected_hidden_region_diagnostic(\n                             self.tcx,\n                             Some(region_scope_tree),\n                             opaque_type_def_id,\n                             hidden_ty,\n                             pick_region,\n-                        );\n+                        ).emit();\n                     }\n                 }\n             }"}, {"sha": "1bc5ce473f5ee6f4eaad112551ff0b9fd7fdc565", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ec48b4ebe24c24d9d43a3dbf57c28c249343d776/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec48b4ebe24c24d9d43a3dbf57c28c249343d776/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=ec48b4ebe24c24d9d43a3dbf57c28c249343d776", "patch": "@@ -9,6 +9,7 @@ use crate::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder, TypeVisitor};\n use crate::ty::subst::{InternalSubsts, Kind, SubstsRef, UnpackedKind};\n use crate::ty::{self, GenericParamDefKind, Ty, TyCtxt};\n use crate::util::nodemap::DefIdMap;\n+use errors::DiagnosticBuilder;\n use rustc_data_structures::fx::FxHashMap;\n use std::rc::Rc;\n \n@@ -499,13 +500,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n }\n \n-pub fn report_unexpected_hidden_region(\n+pub fn unexpected_hidden_region_diagnostic(\n     tcx: TyCtxt<'tcx>,\n     region_scope_tree: Option<&region::ScopeTree>,\n     opaque_type_def_id: DefId,\n     hidden_ty: Ty<'tcx>,\n     hidden_region: ty::Region<'tcx>,\n-) {\n+) -> DiagnosticBuilder<'tcx> {\n     let span = tcx.def_span(opaque_type_def_id);\n     let mut err = struct_span_err!(\n         tcx.sess,\n@@ -573,7 +574,7 @@ pub fn report_unexpected_hidden_region(\n         }\n     }\n \n-    err.emit();\n+    err\n }\n \n // Visitor that requires that (almost) all regions in the type visited outlive\n@@ -724,13 +725,13 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n             None => {\n                 if !self.map_missing_regions_to_empty && !self.tainted_by_errors {\n                     if let Some(hidden_ty) = self.hidden_ty.take() {\n-                        report_unexpected_hidden_region(\n+                        unexpected_hidden_region_diagnostic(\n                             self.tcx,\n                             None,\n                             self.opaque_type_def_id,\n                             hidden_ty,\n                             r,\n-                        );\n+                        ).emit();\n                     }\n                 }\n                 self.tcx.lifetimes.re_empty"}, {"sha": "dff0801f2ebc95bb3a87a4d9e6320e2f06f11f56", "filename": "src/librustc_mir/borrow_check/nll/pick_constraints.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ec48b4ebe24c24d9d43a3dbf57c28c249343d776/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fpick_constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec48b4ebe24c24d9d43a3dbf57c28c249343d776/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fpick_constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fpick_constraints.rs?ref=ec48b4ebe24c24d9d43a3dbf57c28c249343d776", "patch": "@@ -71,10 +71,12 @@ impl<'tcx> PickConstraintSet<'tcx, ty::RegionVid> {\n         p_c: &PickConstraint<'tcx>,\n         mut to_region_vid: impl FnMut(ty::Region<'tcx>) -> ty::RegionVid,\n     ) {\n+        debug!(\"push_constraint(p_c={:?})\", p_c);\n         let pick_region_vid: ty::RegionVid = to_region_vid(p_c.pick_region);\n         let next_constraint = self.first_constraints.get(&pick_region_vid).cloned();\n         let start_index = self.option_regions.len();\n         let end_index = start_index + p_c.option_regions.len();\n+        debug!(\"push_constraint: pick_region_vid={:?}\", pick_region_vid);\n         let constraint_index = self.constraints.push(NllPickConstraint {\n             next_constraint,\n             pick_region_vid,\n@@ -136,6 +138,12 @@ impl<'tcx, R> PickConstraintSet<'tcx, R>\n where\n     R: Copy + Hash + Eq,\n {\n+    crate fn all_indices(\n+        &self,\n+    ) -> impl Iterator<Item = NllPickConstraintIndex> {\n+        self.constraints.indices()\n+    }\n+\n     /// Iterate down the constraint indices associated with a given\n     /// peek-region.  You can then use `option_regions` and other\n     /// methods to access data."}, {"sha": "ad58e4a47eb31c4e9e221ae19e2fdcf5b94e1b64", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 213, "deletions": 120, "changes": 333, "blob_url": "https://github.com/rust-lang/rust/blob/ec48b4ebe24c24d9d43a3dbf57c28c249343d776/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec48b4ebe24c24d9d43a3dbf57c28c249343d776/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=ec48b4ebe24c24d9d43a3dbf57c28c249343d776", "patch": "@@ -1,20 +1,23 @@\n use super::universal_regions::UniversalRegions;\n use crate::borrow_check::nll::constraints::graph::NormalConstraintGraph;\n-use crate::borrow_check::nll::constraints::{ConstraintSccIndex, OutlivesConstraintSet, OutlivesConstraint};\n+use crate::borrow_check::nll::constraints::{\n+    ConstraintSccIndex, OutlivesConstraint, OutlivesConstraintSet,\n+};\n use crate::borrow_check::nll::pick_constraints::PickConstraintSet;\n use crate::borrow_check::nll::region_infer::values::{\n-    PlaceholderIndices, RegionElement, ToElementIndex\n+    PlaceholderIndices, RegionElement, ToElementIndex,\n };\n-use crate::borrow_check::Upvar;\n use crate::borrow_check::nll::type_check::free_region_relations::UniversalRegionRelations;\n use crate::borrow_check::nll::type_check::Locations;\n+use crate::borrow_check::Upvar;\n use rustc::hir::def_id::DefId;\n use rustc::infer::canonical::QueryOutlivesConstraint;\n+use rustc::infer::opaque_types;\n use rustc::infer::region_constraints::{GenericKind, VarInfos, VerifyBound};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin, RegionVariableOrigin};\n use rustc::mir::{\n-    ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements,\n-    ConstraintCategory, Local, Location, Body,\n+    Body, ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements,\n+    ConstraintCategory, Local, Location,\n };\n use rustc::ty::{self, subst::SubstsRef, RegionVid, Ty, TyCtxt, TypeFoldable};\n use rustc::util::common::{self, ErrorReported};\n@@ -61,6 +64,9 @@ pub struct RegionInferenceContext<'tcx> {\n     /// compute the values of each region.\n     constraint_sccs: Rc<Sccs<RegionVid, ConstraintSccIndex>>,\n \n+    /// The \"pick R0 from [R1..Rn]\" constraints, indexed by SCC.\n+    pick_constraints: Rc<PickConstraintSet<'tcx, ConstraintSccIndex>>,\n+\n     /// Map closure bounds to a `Span` that should be used for error reporting.\n     closure_bounds_mapping:\n         FxHashMap<Location, FxHashMap<(RegionVid, RegionVid), (ConstraintCategory, Span)>>,\n@@ -188,7 +194,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         universal_region_relations: Rc<UniversalRegionRelations<'tcx>>,\n         _body: &Body<'tcx>,\n         outlives_constraints: OutlivesConstraintSet,\n-        pick_constraints: PickConstraintSet<'tcx, RegionVid>,\n+        pick_constraints_in: PickConstraintSet<'tcx, RegionVid>,\n         closure_bounds_mapping: FxHashMap<\n             Location,\n             FxHashMap<(RegionVid, RegionVid), (ConstraintCategory, Span)>,\n@@ -220,16 +226,15 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         let scc_representatives = Self::compute_scc_representatives(&constraint_sccs, &definitions);\n \n-        let _pick_constraints_scc = pick_constraints.into_mapped( // TODO\n-            |r| constraint_sccs.scc(r),\n-        );\n+        let pick_constraints = Rc::new(pick_constraints_in.into_mapped(|r| constraint_sccs.scc(r)));\n \n         let mut result = Self {\n             definitions,\n             liveness_constraints,\n             constraints,\n             constraint_graph,\n             constraint_sccs,\n+            pick_constraints,\n             closure_bounds_mapping,\n             scc_universes,\n             scc_representatives,\n@@ -347,9 +352,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         debug!(\n                             \"init_free_and_bound_regions: placeholder {:?} is \\\n                              not compatible with universe {:?} of its SCC {:?}\",\n-                            placeholder,\n-                            scc_universe,\n-                            scc,\n+                            placeholder, scc_universe, scc,\n                         );\n                         self.add_incompatible_universe(scc);\n                     }\n@@ -434,11 +437,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // to store those. Otherwise, we'll pass in `None` to the\n         // functions below, which will trigger them to report errors\n         // eagerly.\n-        let mut outlives_requirements = if infcx.tcx.is_closure(mir_def_id) {\n-            Some(vec![])\n-        } else {\n-            None\n-        };\n+        let mut outlives_requirements =\n+            if infcx.tcx.is_closure(mir_def_id) { Some(vec![]) } else { None };\n \n         self.check_type_tests(\n             infcx,\n@@ -457,16 +457,15 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             errors_buffer,\n         );\n \n+        self.check_pick_constraints(infcx, mir_def_id, errors_buffer);\n+\n         let outlives_requirements = outlives_requirements.unwrap_or(vec![]);\n \n         if outlives_requirements.is_empty() {\n             None\n         } else {\n             let num_external_vids = self.universal_regions.num_global_and_external_regions();\n-            Some(ClosureRegionRequirements {\n-                num_external_vids,\n-                outlives_requirements,\n-            })\n+            Some(ClosureRegionRequirements { num_external_vids, outlives_requirements })\n         }\n     }\n \n@@ -496,6 +495,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n     }\n \n+    /// Computes the value of the SCC `scc_a` if it has not already\n+    /// been computed. The `visited` parameter is a bitset\n     #[inline]\n     fn propagate_constraint_sccs_if_new(\n         &mut self,\n@@ -507,6 +508,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n     }\n \n+    /// Computes the value of the SCC `scc_a`, which has not yet been\n+    /// computed. This works by first computing all successors of the\n+    /// SCC (if they haven't been computed already) and then unioning\n+    /// together their elements.\n     fn propagate_constraint_sccs_new(\n         &mut self,\n         scc_a: ConstraintSccIndex,\n@@ -516,10 +521,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         // Walk each SCC `B` such that `A: B`...\n         for &scc_b in constraint_sccs.successors(scc_a) {\n-            debug!(\n-                \"propagate_constraint_sccs: scc_a = {:?} scc_b = {:?}\",\n-                scc_a, scc_b\n-            );\n+            debug!(\"propagate_constraint_sccs: scc_a = {:?} scc_b = {:?}\", scc_a, scc_b);\n \n             // ...compute the value of `B`...\n             self.propagate_constraint_sccs_if_new(scc_b, visited);\n@@ -537,13 +539,127 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n         }\n \n+        // Now take pick constraints into account\n+        let pick_constraints = self.pick_constraints.clone();\n+        for p_c_i in pick_constraints.indices(scc_a) {\n+            self.apply_pick_constraint(scc_a, pick_constraints.option_regions(p_c_i));\n+        }\n+\n         debug!(\n             \"propagate_constraint_sccs: scc_a = {:?} has value {:?}\",\n             scc_a,\n             self.scc_values.region_value_str(scc_a),\n         );\n     }\n \n+    /// Invoked for each `pick R0 from [R1..Rn]` constraint.\n+    ///\n+    /// `scc` is the SCC containing R0, and `option_regions` are the\n+    /// `R1..Rn` regions -- they are always known to be universal\n+    /// regions (and if that's not true, we just don't attempt to\n+    /// enforce the constraint).\n+    ///\n+    /// The current value of `scc` at the time the method is invoked\n+    /// is considered a *lower bound*.  If possible, we will modify\n+    /// the constraint to set it equal to one of the option regions.\n+    /// If we make any changes, returns true, else false.\n+    fn apply_pick_constraint(\n+        &mut self,\n+        scc: ConstraintSccIndex,\n+        option_regions: &[ty::RegionVid],\n+    ) -> bool {\n+        debug!(\"apply_pick_constraint(scc={:?}, option_regions={:#?})\", scc, option_regions,);\n+\n+        if let Some(uh_oh) =\n+            option_regions.iter().find(|&&r| !self.universal_regions.is_universal_region(r))\n+        {\n+            debug!(\"apply_pick_constraint: option region `{:?}` is not a universal region\", uh_oh);\n+            return false;\n+        }\n+\n+        // Create a mutable vector of the options. We'll try to winnow\n+        // them down.\n+        let mut option_regions: Vec<ty::RegionVid> = option_regions.to_vec();\n+\n+        // The 'pick-region' in a pick-constraint is part of the\n+        // hidden type, which must be in the root universe. Therefore,\n+        // it cannot have any placeholders in its value.\n+        assert!(self.scc_universes[scc] == ty::UniverseIndex::ROOT);\n+        debug_assert!(\n+            self.scc_values.placeholders_contained_in(scc).next().is_none(),\n+            \"scc {:?} in a pick-constraint has placeholder value: {:?}\",\n+            scc,\n+            self.scc_values.region_value_str(scc),\n+        );\n+\n+        // The existing value for `scc` is a lower-bound. This will\n+        // consist of some set {P} + {LB} of points {P} and\n+        // lower-bound free regions {LB}. As each option region O is a\n+        // free region, it will outlive the points. But we can only\n+        // consider the option O if O: LB.\n+        option_regions.retain(|&o_r| {\n+            self.scc_values\n+                .universal_regions_outlived_by(scc)\n+                .all(|lb| self.universal_region_relations.outlives(o_r, lb))\n+        });\n+\n+        // Now find all the *upper bounds* -- that is, each UB is a free\n+        // region that must outlive pick region R0 (`UB: R0`). Therefore,\n+        // we need only keep an option O if `UB: O`.\n+        //\n+        // TODO -- need to implement the reverse graph construction for this\n+        //\n+        // let mut upper_bounds = ...;\n+        // option_regions.retain(|&o_r| {\n+        //     upper_bounds\n+        //         .all(|ub| self.universal_region_relations.outlives(\n+        //             ub,\n+        //             o_r,\n+        //         })\n+        // });\n+\n+        // If we ruled everything out, we're done.\n+        if option_regions.is_empty() {\n+            return false;\n+        }\n+\n+        // Otherwise, we need to find the minimum option, if any, and take that.\n+        debug!(\"apply_pick_constraint: option_regions remaining are {:#?}\", option_regions);\n+        let min = |r1: ty::RegionVid, r2: ty::RegionVid| -> Option<ty::RegionVid> {\n+            let r1_outlives_r2 = self.universal_region_relations.outlives(r1, r2);\n+            let r2_outlives_r1 = self.universal_region_relations.outlives(r2, r1);\n+            if r1_outlives_r2 && r2_outlives_r1 {\n+                Some(r1.min(r2))\n+            } else if r1_outlives_r2 {\n+                Some(r2)\n+            } else if r2_outlives_r1 {\n+                Some(r1)\n+            } else {\n+                None\n+            }\n+        };\n+        let mut best_option = option_regions[0];\n+        for &other_option in &option_regions[1..] {\n+            debug!(\n+                \"apply_pick_constraint: best_option={:?} other_option={:?}\",\n+                best_option, other_option,\n+            );\n+            match min(best_option, other_option) {\n+                Some(m) => best_option = m,\n+                None => {\n+                    debug!(\n+                        \"apply_pick_constraint: {:?} and {:?} are incomparable --> no best choice\",\n+                        best_option, other_option,\n+                    );\n+                    return false;\n+                }\n+            }\n+        }\n+\n+        debug!(\"apply_pick_constraint: best_choice={:?}\", best_option);\n+        self.scc_values.add_element(scc, best_option)\n+    }\n+\n     /// Returns `true` if all the elements in the value of `scc_b` are nameable\n     /// in `scc_a`. Used during constraint propagation, and only once\n     /// the value of `scc_b` has been computed.\n@@ -560,9 +676,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // Otherwise, we have to iterate over the universe elements in\n         // B's value, and check whether all of them are nameable\n         // from universe_a\n-        self.scc_values\n-            .placeholders_contained_in(scc_b)\n-            .all(|p| universe_a.can_name(p.universe))\n+        self.scc_values.placeholders_contained_in(scc_b).all(|p| universe_a.can_name(p.universe))\n     }\n \n     /// Extend `scc` so that it can outlive some placeholder region\n@@ -737,12 +851,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) -> bool {\n         let tcx = infcx.tcx;\n \n-        let TypeTest {\n-            generic_kind,\n-            lower_bound,\n-            locations,\n-            verify_bound: _,\n-        } = type_test;\n+        let TypeTest { generic_kind, lower_bound, locations, verify_bound: _ } = type_test;\n \n         let generic_ty = generic_kind.to_ty(tcx);\n         let subject = match self.try_promote_type_test_subject(infcx, generic_ty) {\n@@ -892,22 +1001,15 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// except that it converts further takes the non-local upper\n     /// bound of `'y`, so that the final result is non-local.\n     fn non_local_universal_upper_bound(&self, r: RegionVid) -> RegionVid {\n-        debug!(\n-            \"non_local_universal_upper_bound(r={:?}={})\",\n-            r,\n-            self.region_value_str(r)\n-        );\n+        debug!(\"non_local_universal_upper_bound(r={:?}={})\", r, self.region_value_str(r));\n \n         let lub = self.universal_upper_bound(r);\n \n         // Grow further to get smallest universal region known to\n         // creator.\n         let non_local_lub = self.universal_region_relations.non_local_upper_bound(lub);\n \n-        debug!(\n-            \"non_local_universal_upper_bound: non_local_lub={:?}\",\n-            non_local_lub\n-        );\n+        debug!(\"non_local_universal_upper_bound: non_local_lub={:?}\", non_local_lub);\n \n         non_local_lub\n     }\n@@ -927,11 +1029,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// - For each `end('x)` element in `'r`, compute the mutual LUB, yielding\n     ///   a result `'y`.\n     fn universal_upper_bound(&self, r: RegionVid) -> RegionVid {\n-        debug!(\n-            \"universal_upper_bound(r={:?}={})\",\n-            r,\n-            self.region_value_str(r)\n-        );\n+        debug!(\"universal_upper_bound(r={:?}={})\", r, self.region_value_str(r));\n \n         // Find the smallest universal region that contains all other\n         // universal regions within `region`.\n@@ -956,10 +1054,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         lower_bound: RegionVid,\n         verify_bound: &VerifyBound<'tcx>,\n     ) -> bool {\n-        debug!(\n-            \"eval_verify_bound(lower_bound={:?}, verify_bound={:?})\",\n-            lower_bound, verify_bound\n-        );\n+        debug!(\"eval_verify_bound(lower_bound={:?}, verify_bound={:?})\", lower_bound, verify_bound);\n \n         match verify_bound {\n             VerifyBound::IfEq(test_ty, verify_bound1) => {\n@@ -968,7 +1063,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n             VerifyBound::OutlivedBy(r) => {\n                 let r_vid = self.to_region_vid(r);\n-                self.eval_outlives(body, r_vid, lower_bound)\n+                self.eval_outlives(r_vid, lower_bound)\n             }\n \n             VerifyBound::AnyBound(verify_bounds) => verify_bounds.iter().any(|verify_bound| {\n@@ -1041,23 +1136,17 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         })\n     }\n \n-    // Evaluate whether `sup_region: sub_region @ point`.\n-    fn eval_outlives(\n-        &self,\n-        _body: &Body<'tcx>,\n-        sup_region: RegionVid,\n-        sub_region: RegionVid,\n-    ) -> bool {\n+    // Evaluate whether `sup_region == sub_region`.\n+    fn eval_equal(&self, r1: RegionVid, r2: RegionVid) -> bool {\n+        self.eval_outlives(r1, r2) && self.eval_outlives(r2, r1)\n+    }\n+\n+    // Evaluate whether `sup_region: sub_region`.\n+    fn eval_outlives(&self, sup_region: RegionVid, sub_region: RegionVid) -> bool {\n         debug!(\"eval_outlives({:?}: {:?})\", sup_region, sub_region);\n \n-        debug!(\n-            \"eval_outlives: sup_region's value = {:?}\",\n-            self.region_value_str(sup_region),\n-        );\n-        debug!(\n-            \"eval_outlives: sub_region's value = {:?}\",\n-            self.region_value_str(sub_region),\n-        );\n+        debug!(\"eval_outlives: sup_region's value = {:?}\", self.region_value_str(sup_region),);\n+        debug!(\"eval_outlives: sub_region's value = {:?}\", self.region_value_str(sub_region),);\n \n         let sub_region_scc = self.constraint_sccs.scc(sub_region);\n         let sup_region_scc = self.constraint_sccs.scc(sup_region);\n@@ -1068,9 +1157,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // now). Therefore, the sup-region outlives the sub-region if,\n         // for each universal region R1 in the sub-region, there\n         // exists some region R2 in the sup-region that outlives R1.\n-        let universal_outlives = self.scc_values\n-            .universal_regions_outlived_by(sub_region_scc)\n-            .all(|r1| {\n+        let universal_outlives =\n+            self.scc_values.universal_regions_outlived_by(sub_region_scc).all(|r1| {\n                 self.scc_values\n                     .universal_regions_outlived_by(sup_region_scc)\n                     .any(|r2| self.universal_region_relations.outlives(r2, r1))\n@@ -1088,8 +1176,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             return true;\n         }\n \n-        self.scc_values\n-            .contains_points(sup_region_scc, sub_region_scc)\n+        self.scc_values.contains_points(sup_region_scc, sub_region_scc)\n     }\n \n     /// Once regions have been propagated, this method is used to see\n@@ -1171,12 +1258,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // Because this free region must be in the ROOT universe, we\n         // know it cannot contain any bound universes.\n         assert!(self.scc_universes[longer_fr_scc] == ty::UniverseIndex::ROOT);\n-        debug_assert!(\n-            self.scc_values\n-                .placeholders_contained_in(longer_fr_scc)\n-                .next()\n-                .is_none()\n-        );\n+        debug_assert!(self.scc_values.placeholders_contained_in(longer_fr_scc).next().is_none());\n \n         // Only check all of the relations for the main representative of each\n         // SCC, otherwise just check that we outlive said representative. This\n@@ -1230,9 +1312,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         errors_buffer: &mut Vec<Diagnostic>,\n     ) -> Option<ErrorReported> {\n         // If it is known that `fr: o`, carry on.\n-        if self.universal_region_relations\n-            .outlives(longer_fr, shorter_fr)\n-        {\n+        if self.universal_region_relations.outlives(longer_fr, shorter_fr) {\n             return None;\n         }\n \n@@ -1246,9 +1326,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // We'll call it `fr-` -- it's ever so slightly smaller than\n             // `longer_fr`.\n \n-            if let Some(fr_minus) = self\n-                .universal_region_relations\n-                .non_local_lower_bound(longer_fr)\n+            if let Some(fr_minus) = self.universal_region_relations.non_local_lower_bound(longer_fr)\n             {\n                 debug!(\"check_universal_region: fr_minus={:?}\", fr_minus);\n \n@@ -1258,12 +1336,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 // Grow `shorter_fr` until we find some non-local regions. (We\n                 // always will.)  We'll call them `shorter_fr+` -- they're ever\n                 // so slightly larger than `shorter_fr`.\n-                let shorter_fr_plus = self.universal_region_relations\n-                    .non_local_upper_bounds(&shorter_fr);\n-                debug!(\n-                    \"check_universal_region: shorter_fr_plus={:?}\",\n-                    shorter_fr_plus\n-                );\n+                let shorter_fr_plus =\n+                    self.universal_region_relations.non_local_upper_bounds(&shorter_fr);\n+                debug!(\"check_universal_region: shorter_fr_plus={:?}\", shorter_fr_plus);\n                 for &&fr in &shorter_fr_plus {\n                     // Push the constraint `fr-: shorter_fr+`\n                     propagated_outlives_requirements.push(ClosureOutlivesRequirement {\n@@ -1295,28 +1370,20 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         longer_fr: RegionVid,\n         placeholder: ty::PlaceholderRegion,\n     ) {\n-        debug!(\n-            \"check_bound_universal_region(fr={:?}, placeholder={:?})\",\n-            longer_fr, placeholder,\n-        );\n+        debug!(\"check_bound_universal_region(fr={:?}, placeholder={:?})\", longer_fr, placeholder,);\n \n         let longer_fr_scc = self.constraint_sccs.scc(longer_fr);\n-        debug!(\n-            \"check_bound_universal_region: longer_fr_scc={:?}\",\n-            longer_fr_scc,\n-        );\n+        debug!(\"check_bound_universal_region: longer_fr_scc={:?}\", longer_fr_scc,);\n \n         // If we have some bound universal region `'a`, then the only\n         // elements it can contain is itself -- we don't know anything\n         // else about it!\n         let error_element = match {\n-            self.scc_values\n-                .elements_contained_in(longer_fr_scc)\n-                .find(|element| match element {\n-                    RegionElement::Location(_) => true,\n-                    RegionElement::RootUniversalRegion(_) => true,\n-                    RegionElement::PlaceholderRegion(placeholder1) => placeholder != *placeholder1,\n-                })\n+            self.scc_values.elements_contained_in(longer_fr_scc).find(|element| match element {\n+                RegionElement::Location(_) => true,\n+                RegionElement::RootUniversalRegion(_) => true,\n+                RegionElement::PlaceholderRegion(placeholder1) => placeholder != *placeholder1,\n+            })\n         } {\n             Some(v) => v,\n             None => return,\n@@ -1327,7 +1394,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let error_region = match error_element {\n             RegionElement::Location(l) => self.find_sub_region_live_at(longer_fr, l),\n             RegionElement::RootUniversalRegion(r) => r,\n-            RegionElement::PlaceholderRegion(error_placeholder) => self.definitions\n+            RegionElement::PlaceholderRegion(error_placeholder) => self\n+                .definitions\n                 .iter_enumerated()\n                 .filter_map(|(r, definition)| match definition.origin {\n                     NLLRegionVariableOrigin::Placeholder(p) if p == error_placeholder => Some(r),\n@@ -1345,12 +1413,44 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // the AST-based checker uses a more conservative check,\n         // so to even see this error, one must pass in a special\n         // flag.\n-        let mut diag = infcx\n-            .tcx\n-            .sess\n-            .struct_span_err(span, \"higher-ranked subtype error\");\n+        let mut diag = infcx.tcx.sess.struct_span_err(span, \"higher-ranked subtype error\");\n         diag.emit();\n     }\n+\n+    fn check_pick_constraints(\n+        &self,\n+        infcx: &InferCtxt<'_, 'tcx>,\n+        mir_def_id: DefId,\n+        errors_buffer: &mut Vec<Diagnostic>, // TODO\n+    ) {\n+        let pick_constraints = self.pick_constraints.clone();\n+        for p_c_i in pick_constraints.all_indices() {\n+            debug!(\"check_pick_constraint(p_c_i={:?})\", p_c_i);\n+            let p_c = &pick_constraints[p_c_i];\n+            let pick_region_vid = p_c.pick_region_vid;\n+            debug!(\"check_pick_constraint: pick_region_vid={:?} with value {}\", pick_region_vid, self.region_value_str(pick_region_vid));\n+            let option_regions = pick_constraints.option_regions(p_c_i);\n+            debug!(\"check_pick_constraint: option_regions={:?}\", option_regions);\n+\n+            // did the pick-region wind up equal to any of the option regions?\n+            if let Some(o) = option_regions.iter().find(|&&o_r| self.eval_equal(o_r, p_c.pick_region_vid)) {\n+                debug!(\"check_pick_constraint: evaluated as equal to {:?}\", o);\n+                continue;\n+            }\n+\n+            // if not, report an error\n+            let region_scope_tree = &infcx.tcx.region_scope_tree(mir_def_id);\n+            let pick_region = infcx.tcx.mk_region(ty::ReVar(pick_region_vid)); // XXX\n+            opaque_types::unexpected_hidden_region_diagnostic(\n+                infcx.tcx,\n+                Some(region_scope_tree),\n+                p_c.opaque_type_def_id,\n+                p_c.hidden_ty,\n+                pick_region,\n+            )\n+            .buffer(errors_buffer);\n+        }\n+    }\n }\n \n impl<'tcx> RegionDefinition<'tcx> {\n@@ -1364,11 +1464,7 @@ impl<'tcx> RegionDefinition<'tcx> {\n             _ => NLLRegionVariableOrigin::Existential,\n         };\n \n-        Self {\n-            origin,\n-            universe,\n-            external_name: None,\n-        }\n+        Self { origin, universe, external_name: None }\n     }\n }\n \n@@ -1471,10 +1567,7 @@ impl<'tcx> ClosureRegionRequirementsExt<'tcx> for ClosureRegionRequirements<'tcx\n             if let ty::ReClosureBound(vid) = r {\n                 closure_mapping[*vid]\n             } else {\n-                bug!(\n-                    \"subst_closure_mapping: encountered non-closure bound free region {:?}\",\n-                    r\n-                )\n+                bug!(\"subst_closure_mapping: encountered non-closure bound free region {:?}\", r)\n             }\n         })\n     }"}, {"sha": "e7ae9de3c2e6c40e2f7037f2556937136ee25c4c", "filename": "src/librustc_mir/borrow_check/nll/type_check/constraint_conversion.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ec48b4ebe24c24d9d43a3dbf57c28c249343d776/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec48b4ebe24c24d9d43a3dbf57c28c249343d776/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs?ref=ec48b4ebe24c24d9d43a3dbf57c28c249343d776", "patch": "@@ -51,6 +51,8 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n     }\n \n     pub(super) fn convert_all(&mut self, query_constraints: &QueryRegionConstraints<'tcx>) {\n+        debug!(\"convert_all(query_constraints={:#?})\", query_constraints);\n+\n         let QueryRegionConstraints { outlives, pick_constraints } = query_constraints;\n \n         // Annoying: to invoke `self.to_region_vid`, we need access to"}]}