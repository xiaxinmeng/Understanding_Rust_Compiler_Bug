{"sha": "715d1995d7fdb28caeaa5401e1dbdbb3751bee60", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxNWQxOTk1ZDdmZGIyOGNhZWFhNTQwMWUxZGJkYmIzNzUxYmVlNjA=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-03-14T21:05:57Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-03-14T21:05:57Z"}, "message": "rustc: Make the self region work properly in enums", "tree": {"sha": "a482976575fd953756699405f6760b05b79a9713", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a482976575fd953756699405f6760b05b79a9713"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/715d1995d7fdb28caeaa5401e1dbdbb3751bee60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/715d1995d7fdb28caeaa5401e1dbdbb3751bee60", "html_url": "https://github.com/rust-lang/rust/commit/715d1995d7fdb28caeaa5401e1dbdbb3751bee60", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/715d1995d7fdb28caeaa5401e1dbdbb3751bee60/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a45f87620eb04242a63544b872ed1807cd38c72", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a45f87620eb04242a63544b872ed1807cd38c72", "html_url": "https://github.com/rust-lang/rust/commit/3a45f87620eb04242a63544b872ed1807cd38c72"}], "stats": {"total": 132, "additions": 91, "deletions": 41}, "files": [{"sha": "cee041c6f8b13c0a98f7ee7791ce817f1772bba9", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 91, "deletions": 41, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/715d1995d7fdb28caeaa5401e1dbdbb3751bee60/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/715d1995d7fdb28caeaa5401e1dbdbb3751bee60/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=715d1995d7fdb28caeaa5401e1dbdbb3751bee60", "patch": "@@ -1442,25 +1442,49 @@ fn valid_range_bounds(tcx: ty::ctxt, from: @ast::expr, to: @ast::expr)\n     ast_util::compare_lit_exprs(tcx, from, to) <= 0\n }\n \n-fn check_pat_variant(fcx: @fn_ctxt, map: pat_util::pat_id_map,\n-                     pat: @ast::pat, path: @ast::path, subpats: [@ast::pat],\n-                     expected: ty::t) {\n+type pat_ctxt = {\n+    fcx: @fn_ctxt,\n+    map: pat_util::pat_id_map,\n+    alt_region: ty::region,\n+    block_region: ty::region,\n+    /* Equal to either alt_region or block_region. */\n+    pat_region: ty::region\n+};\n+\n+fn instantiate_self_regions(pcx: pat_ctxt, args: [ty::t]) -> [ty::t] {\n+    vec::map(args, {|arg_ty|\n+        if ty::type_has_rptrs(arg_ty) {\n+            ty::fold_ty(pcx.fcx.ccx.tcx, ty::fm_rptr({|r|\n+                alt r {\n+                    ty::re_inferred | ty::re_caller(_) { pcx.pat_region }\n+                    _ { r }\n+                }\n+            }), arg_ty)\n+        } else {\n+            arg_ty\n+        }\n+    })\n+}\n+\n+fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n+                     subpats: [@ast::pat], expected: ty::t) {\n     // Typecheck the path.\n-    let tcx = fcx.ccx.tcx;\n-    let v_def = lookup_def(fcx, path.span, pat.id);\n+    let tcx = pcx.fcx.ccx.tcx;\n+    let v_def = lookup_def(pcx.fcx, path.span, pat.id);\n     let v_def_ids = ast_util::variant_def_ids(v_def);\n     let ctor_tpt = ty::lookup_item_type(tcx, v_def_ids.enm);\n-    instantiate_path(fcx, path, ctor_tpt, pat.span, pat.id);\n+    instantiate_path(pcx.fcx, path, ctor_tpt, pat.span, pat.id);\n \n     // Take the enum type params out of `expected`.\n-    alt structure_of(fcx, pat.span, expected) {\n+    alt structure_of(pcx.fcx, pat.span, expected) {\n       ty::ty_enum(_, expected_tps) {\n         let ctor_ty = ty::node_id_to_type(tcx, pat.id);\n-        demand::with_substs(fcx, pat.span, expected, ctor_ty,\n+        demand::with_substs(pcx.fcx, pat.span, expected, ctor_ty,\n                             expected_tps);\n         // Get the number of arguments in this enum variant.\n-        let arg_types = variant_arg_types(fcx.ccx, pat.span,\n+        let arg_types = variant_arg_types(pcx.fcx.ccx, pat.span,\n                                           v_def_ids.var, expected_tps);\n+        arg_types = instantiate_self_regions(pcx, arg_types);\n         let subpats_len = subpats.len(), arg_len = arg_types.len();\n         if arg_len > 0u {\n             // N-ary variant.\n@@ -1475,7 +1499,7 @@ fn check_pat_variant(fcx: @fn_ctxt, map: pat_util::pat_id_map,\n             }\n \n             vec::iter2(subpats, arg_types) {|subpat, arg_ty|\n-                check_pat(fcx, map, subpat, arg_ty);\n+                check_pat(pcx, subpat, arg_ty);\n             }\n         } else if subpats_len > 0u {\n             tcx.sess.span_err\n@@ -1497,23 +1521,23 @@ fn check_pat_variant(fcx: @fn_ctxt, map: pat_util::pat_id_map,\n \n // Pattern checking is top-down rather than bottom-up so that bindings get\n // their types immediately.\n-fn check_pat(fcx: @fn_ctxt, map: pat_util::pat_id_map, pat: @ast::pat,\n-             expected: ty::t) {\n-    let tcx = fcx.ccx.tcx;\n+fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n+    let tcx = pcx.fcx.ccx.tcx;\n     alt pat.node {\n       ast::pat_wild {\n         write_ty(tcx, pat.id, expected);\n       }\n       ast::pat_lit(lt) {\n-        check_expr_with(fcx, lt, expected);\n+        check_expr_with(pcx.fcx, lt, expected);\n         write_ty(tcx, pat.id, expr_ty(tcx, lt));\n       }\n       ast::pat_range(begin, end) {\n-        check_expr_with(fcx, begin, expected);\n-        check_expr_with(fcx, end, expected);\n-        let b_ty = resolve_type_vars_if_possible(fcx, expr_ty(tcx, begin));\n+        check_expr_with(pcx.fcx, begin, expected);\n+        check_expr_with(pcx.fcx, end, expected);\n+        let b_ty = resolve_type_vars_if_possible(pcx.fcx,\n+                                                 expr_ty(tcx, begin));\n         if !ty::same_type(tcx, b_ty, resolve_type_vars_if_possible(\n-            fcx, expr_ty(tcx, end))) {\n+            pcx.fcx, expr_ty(tcx, end))) {\n             tcx.sess.span_err(pat.span, \"mismatched types in range\");\n         } else if !ty::type_is_numeric(b_ty) {\n             tcx.sess.span_err(pat.span, \"non-numeric type used in range\");\n@@ -1525,29 +1549,30 @@ fn check_pat(fcx: @fn_ctxt, map: pat_util::pat_id_map, pat: @ast::pat,\n       }\n       ast::pat_ident(name, sub)\n       if !pat_util::pat_is_variant(tcx.def_map, pat) {\n-        let vid = lookup_local(fcx, pat.span, pat.id);\n+        let vid = lookup_local(pcx.fcx, pat.span, pat.id);\n         let typ = ty::mk_var(tcx, vid);\n-        typ = demand::simple(fcx, pat.span, expected, typ);\n-        let canon_id = map.get(path_to_ident(name));\n+        typ = demand::simple(pcx.fcx, pat.span, expected, typ);\n+        let canon_id = pcx.map.get(path_to_ident(name));\n         if canon_id != pat.id {\n-            let ct = ty::mk_var(tcx, lookup_local(fcx, pat.span, canon_id));\n-            typ = demand::simple(fcx, pat.span, ct, typ);\n+            let tv_id = lookup_local(pcx.fcx, pat.span, canon_id);\n+            let ct = ty::mk_var(tcx, tv_id);\n+            typ = demand::simple(pcx.fcx, pat.span, ct, typ);\n         }\n         write_ty(tcx, pat.id, typ);\n         alt sub {\n-          some(p) { check_pat(fcx, map, p, expected); }\n+          some(p) { check_pat(pcx, p, expected); }\n           _ {}\n         }\n       }\n       ast::pat_ident(path, _) {\n-        check_pat_variant(fcx, map, pat, path, [], expected);\n+        check_pat_variant(pcx, pat, path, [], expected);\n       }\n       ast::pat_enum(path, subpats) {\n-        check_pat_variant(fcx, map, pat, path, subpats, expected);\n+        check_pat_variant(pcx, pat, path, subpats, expected);\n       }\n       ast::pat_rec(fields, etc) {\n         let ex_fields;\n-        alt structure_of(fcx, pat.span, expected) {\n+        alt structure_of(pcx.fcx, pat.span, expected) {\n           ty::ty_rec(fields) { ex_fields = fields; }\n           _ {\n             tcx.sess.span_fatal\n@@ -1570,7 +1595,9 @@ fn check_pat(fcx: @fn_ctxt, map: pat_util::pat_id_map, pat: @ast::pat,\n         }\n         for f: ast::field_pat in fields {\n             alt vec::find(ex_fields, bind matches(f.ident, _)) {\n-              some(field) { check_pat(fcx, map, f.pat, field.mt.ty); }\n+              some(field) {\n+                check_pat(pcx, f.pat, field.mt.ty);\n+              }\n               none {\n                 tcx.sess.span_fatal(pat.span,\n                                     #fmt[\"mismatched types: did not \\\n@@ -1583,7 +1610,7 @@ fn check_pat(fcx: @fn_ctxt, map: pat_util::pat_id_map, pat: @ast::pat,\n       }\n       ast::pat_tup(elts) {\n         let ex_elts;\n-        alt structure_of(fcx, pat.span, expected) {\n+        alt structure_of(pcx.fcx, pat.span, expected) {\n           ty::ty_tup(elts) { ex_elts = elts; }\n           _ {\n             tcx.sess.span_fatal\n@@ -1600,13 +1627,17 @@ fn check_pat(fcx: @fn_ctxt, map: pat_util::pat_id_map, pat: @ast::pat,\n                       fields\", vec::len(ex_elts), e_count]);\n         }\n         let i = 0u;\n-        for elt in elts { check_pat(fcx, map, elt, ex_elts[i]); i += 1u; }\n+        for elt in elts {\n+            check_pat(pcx, elt, ex_elts[i]);\n+            i += 1u;\n+        }\n+\n         write_ty(tcx, pat.id, expected);\n       }\n       ast::pat_box(inner) {\n-        alt structure_of(fcx, pat.span, expected) {\n+        alt structure_of(pcx.fcx, pat.span, expected) {\n           ty::ty_box(e_inner) {\n-            check_pat(fcx, map, inner, e_inner.ty);\n+            check_pat(pcx, inner, e_inner.ty);\n             write_ty(tcx, pat.id, expected);\n           }\n           _ {\n@@ -1618,9 +1649,9 @@ fn check_pat(fcx: @fn_ctxt, map: pat_util::pat_id_map, pat: @ast::pat,\n         }\n       }\n       ast::pat_uniq(inner) {\n-        alt structure_of(fcx, pat.span, expected) {\n+        alt structure_of(pcx.fcx, pat.span, expected) {\n           ty::ty_uniq(e_inner) {\n-            check_pat(fcx, map, inner, e_inner.ty);\n+            check_pat(pcx, inner, e_inner.ty);\n             write_ty(tcx, pat.id, expected);\n           }\n           _ {\n@@ -2454,16 +2485,25 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n           write_ty(tcx, id, ty::mk_nil(tcx));\n           bot = !may_break(body);\n       }\n-      ast::expr_alt(expr, arms, _) {\n-        bot = check_expr(fcx, expr);\n+      ast::expr_alt(discrim, arms, _) {\n+        bot = check_expr(fcx, discrim);\n+\n+        let parent_block = tcx.region_map.rvalue_to_block.get(expr.id);\n \n         // Typecheck the patterns first, so that we get types for all the\n         // bindings.\n-        let pattern_ty = ty::expr_ty(tcx, expr);\n+        let pattern_ty = ty::expr_ty(tcx, discrim);\n         for arm: ast::arm in arms {\n-            let id_map = pat_util::pat_id_map(tcx.def_map, arm.pats[0]);\n+            let pcx = {\n+                fcx: fcx,\n+                map: pat_util::pat_id_map(tcx.def_map, arm.pats[0]),\n+                alt_region: ty::re_block(parent_block),\n+                block_region: ty::re_block(arm.body.node.id),\n+                pat_region: ty::re_block(parent_block)\n+            };\n+\n             for p: @ast::pat in arm.pats {\n-                check_pat(fcx, id_map, p, pattern_ty);\n+                check_pat(pcx, p, pattern_ty);\n             }\n         }\n         // Now typecheck the blocks.\n@@ -2797,8 +2837,18 @@ fn check_decl_local(fcx: @fn_ctxt, local: @ast::local) -> bool {\n       }\n       _ {/* fall through */ }\n     }\n-    let id_map = pat_util::pat_id_map(fcx.ccx.tcx.def_map, local.node.pat);\n-    check_pat(fcx, id_map, local.node.pat, t);\n+\n+    let block_id = fcx.ccx.tcx.region_map.rvalue_to_block.get(local.node.id);\n+    let region = ty::re_block(block_id);\n+    let pcx = {\n+        fcx: fcx,\n+        map: pat_util::pat_id_map(fcx.ccx.tcx.def_map, local.node.pat),\n+        alt_region: region,\n+        block_region: region,\n+        pat_region: region\n+    };\n+\n+    check_pat(pcx, local.node.pat, t);\n     ret bot;\n }\n "}]}