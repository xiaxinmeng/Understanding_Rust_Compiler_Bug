{"sha": "b948d81c44e20cdcbe32b27758e6259d174fc0fb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5NDhkODFjNDRlMjBjZGNiZTMyYjI3NzU4ZTYyNTlkMTc0ZmMwZmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-15T16:53:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-15T16:53:53Z"}, "message": "Auto merge of #25219 - Eljay:fix-comment-parsing, r=alexcrichton\n\nFixes #25182, parser didn't account for \\r\\n in regular comments, only doc-comments.", "tree": {"sha": "afd3babea9ba4ce569cfe196568a0d10cf083855", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/afd3babea9ba4ce569cfe196568a0d10cf083855"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b948d81c44e20cdcbe32b27758e6259d174fc0fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b948d81c44e20cdcbe32b27758e6259d174fc0fb", "html_url": "https://github.com/rust-lang/rust/commit/b948d81c44e20cdcbe32b27758e6259d174fc0fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b948d81c44e20cdcbe32b27758e6259d174fc0fb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9bebe5f3bbf2715f9c8606d672a2396216077826", "url": "https://api.github.com/repos/rust-lang/rust/commits/9bebe5f3bbf2715f9c8606d672a2396216077826", "html_url": "https://github.com/rust-lang/rust/commit/9bebe5f3bbf2715f9c8606d672a2396216077826"}, {"sha": "2dcc200be0f17ec0cab568736d9d3ccbae453a65", "url": "https://api.github.com/repos/rust-lang/rust/commits/2dcc200be0f17ec0cab568736d9d3ccbae453a65", "html_url": "https://github.com/rust-lang/rust/commit/2dcc200be0f17ec0cab568736d9d3ccbae453a65"}], "stats": {"total": 63, "additions": 39, "deletions": 24}, "files": [{"sha": "b70594a96a028eed5ed52a694ef504d8e5642254", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 39, "deletions": 24, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/b948d81c44e20cdcbe32b27758e6259d174fc0fb/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b948d81c44e20cdcbe32b27758e6259d174fc0fb/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=b948d81c44e20cdcbe32b27758e6259d174fc0fb", "patch": "@@ -403,45 +403,51 @@ impl<'a> StringReader<'a> {\n                 Some('/') => {\n                     self.bump();\n                     self.bump();\n+\n                     // line comments starting with \"///\" or \"//!\" are doc-comments\n-                    if self.curr_is('/') || self.curr_is('!') {\n-                        let start_bpos = self.pos - BytePos(3);\n-                        while !self.is_eof() {\n-                            match self.curr.unwrap() {\n-                                '\\n' => break,\n-                                '\\r' => {\n-                                    if self.nextch_is('\\n') {\n-                                        // CRLF\n-                                        break\n-                                    } else {\n-                                        self.err_span_(self.last_pos, self.pos,\n-                                                       \"bare CR not allowed in doc-comment\");\n-                                    }\n+                    let doc_comment = self.curr_is('/') || self.curr_is('!');\n+                    let start_bpos = if doc_comment {\n+                        self.pos - BytePos(3)\n+                    } else {\n+                        self.last_pos - BytePos(2)\n+                    };\n+\n+                    while !self.is_eof() {\n+                        match self.curr.unwrap() {\n+                            '\\n' => break,\n+                            '\\r' => {\n+                                if self.nextch_is('\\n') {\n+                                    // CRLF\n+                                    break\n+                                } else if doc_comment {\n+                                    self.err_span_(self.last_pos, self.pos,\n+                                                   \"bare CR not allowed in doc-comment\");\n                                 }\n-                                _ => ()\n                             }\n-                            self.bump();\n+                            _ => ()\n                         }\n-                        return self.with_str_from(start_bpos, |string| {\n-                            // but comments with only more \"/\"s are not\n+                        self.bump();\n+                    }\n+\n+                    return if doc_comment {\n+                        self.with_str_from(start_bpos, |string| {\n+                            // comments with only more \"/\"s are not doc comments\n                             let tok = if is_doc_comment(string) {\n                                 token::DocComment(token::intern(string))\n                             } else {\n                                 token::Comment\n                             };\n \n-                            return Some(TokenAndSpan{\n+                            Some(TokenAndSpan {\n                                 tok: tok,\n                                 sp: codemap::mk_sp(start_bpos, self.last_pos)\n-                            });\n-                        });\n+                            })\n+                        })\n                     } else {\n-                        let start_bpos = self.last_pos - BytePos(2);\n-                        while !self.curr_is('\\n') && !self.is_eof() { self.bump(); }\n-                        return Some(TokenAndSpan {\n+                        Some(TokenAndSpan {\n                             tok: token::Comment,\n                             sp: codemap::mk_sp(start_bpos, self.last_pos)\n-                        });\n+                        })\n                     }\n                 }\n                 Some('*') => {\n@@ -1563,4 +1569,13 @@ mod tests {\n         assert_eq!(lexer.next_token().tok, token::Literal(token::Char(token::intern(\"a\")), None));\n     }\n \n+    #[test] fn crlf_comments() {\n+        let sh = mk_sh();\n+        let mut lexer = setup(&sh, \"// test\\r\\n/// test\\r\\n\".to_string());\n+        let comment = lexer.next_token();\n+        assert_eq!(comment.tok, token::Comment);\n+        assert_eq!(comment.sp, ::codemap::mk_sp(BytePos(0), BytePos(7)));\n+        assert_eq!(lexer.next_token().tok, token::Whitespace);\n+        assert_eq!(lexer.next_token().tok, token::DocComment(token::intern(\"/// test\")));\n+    }\n }"}]}