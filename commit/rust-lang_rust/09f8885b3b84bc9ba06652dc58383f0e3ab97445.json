{"sha": "09f8885b3b84bc9ba06652dc58383f0e3ab97445", "node_id": "C_kwDOAAsO6NoAKDA5Zjg4ODViM2I4NGJjOWJhMDY2NTJkYzU4MzgzZjBlM2FiOTc0NDU", "commit": {"author": {"name": "Peter Jaszkowiak", "email": "p.jaszkow@gmail.com", "date": "2022-12-01T06:25:07Z"}, "committer": {"name": "Peter Jaszkowiak", "email": "p.jaszkow@gmail.com", "date": "2023-01-21T19:50:03Z"}, "message": "debug assertions for `slice::split_at_unchecked`, `str::get_unchecked`", "tree": {"sha": "6d6440894e20729ab54a6d1ba83bfe9d771d5a66", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d6440894e20729ab54a6d1ba83bfe9d771d5a66"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09f8885b3b84bc9ba06652dc58383f0e3ab97445", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09f8885b3b84bc9ba06652dc58383f0e3ab97445", "html_url": "https://github.com/rust-lang/rust/commit/09f8885b3b84bc9ba06652dc58383f0e3ab97445", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09f8885b3b84bc9ba06652dc58383f0e3ab97445/comments", "author": {"login": "pitaj", "id": 803701, "node_id": "MDQ6VXNlcjgwMzcwMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/803701?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pitaj", "html_url": "https://github.com/pitaj", "followers_url": "https://api.github.com/users/pitaj/followers", "following_url": "https://api.github.com/users/pitaj/following{/other_user}", "gists_url": "https://api.github.com/users/pitaj/gists{/gist_id}", "starred_url": "https://api.github.com/users/pitaj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pitaj/subscriptions", "organizations_url": "https://api.github.com/users/pitaj/orgs", "repos_url": "https://api.github.com/users/pitaj/repos", "events_url": "https://api.github.com/users/pitaj/events{/privacy}", "received_events_url": "https://api.github.com/users/pitaj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pitaj", "id": 803701, "node_id": "MDQ6VXNlcjgwMzcwMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/803701?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pitaj", "html_url": "https://github.com/pitaj", "followers_url": "https://api.github.com/users/pitaj/followers", "following_url": "https://api.github.com/users/pitaj/following{/other_user}", "gists_url": "https://api.github.com/users/pitaj/gists{/gist_id}", "starred_url": "https://api.github.com/users/pitaj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pitaj/subscriptions", "organizations_url": "https://api.github.com/users/pitaj/orgs", "repos_url": "https://api.github.com/users/pitaj/repos", "events_url": "https://api.github.com/users/pitaj/events{/privacy}", "received_events_url": "https://api.github.com/users/pitaj/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf", "url": "https://api.github.com/repos/rust-lang/rust/commits/005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf", "html_url": "https://github.com/rust-lang/rust/commit/005fc0f00f2d4ceaf523b67a8f9c5665b8ac5baf"}], "stats": {"total": 79, "additions": 44, "deletions": 35}, "files": [{"sha": "f0e5ea53d7d7002a1a5e8c5480cefd8aac2702dc", "filename": "library/core/src/slice/index.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/09f8885b3b84bc9ba06652dc58383f0e3ab97445/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f8885b3b84bc9ba06652dc58383f0e3ab97445/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Findex.rs?ref=09f8885b3b84bc9ba06652dc58383f0e3ab97445", "patch": "@@ -371,12 +371,11 @@ unsafe impl<T> const SliceIndex<[T]> for ops::Range<usize> {\n \n     #[inline]\n     unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n-        let this = ops::Range { start: self.start, end: self.end };\n+        let this = ops::Range { ..self };\n         // SAFETY: the caller guarantees that `slice` is not dangling, so it\n         // cannot be longer than `isize::MAX`. They also guarantee that\n         // `self` is in bounds of `slice` so `self` cannot overflow an `isize`,\n         // so the call to `add` is safe.\n-\n         unsafe {\n             assert_unsafe_precondition!(\n                 \"slice::get_unchecked requires that the range is within the slice\",\n@@ -389,7 +388,7 @@ unsafe impl<T> const SliceIndex<[T]> for ops::Range<usize> {\n \n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n-        let this = ops::Range { start: self.start, end: self.end };\n+        let this = ops::Range { ..self };\n         // SAFETY: see comments for `get_unchecked` above.\n         unsafe {\n             assert_unsafe_precondition!("}, {"sha": "9926bf7fbbb3f60e463d9e00344593d89a950cd3", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/09f8885b3b84bc9ba06652dc58383f0e3ab97445/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f8885b3b84bc9ba06652dc58383f0e3ab97445/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=09f8885b3b84bc9ba06652dc58383f0e3ab97445", "patch": "@@ -1679,7 +1679,13 @@ impl<T> [T] {\n         let ptr = self.as_ptr();\n \n         // SAFETY: Caller has to check that `0 <= mid <= self.len()`\n-        unsafe { (from_raw_parts(ptr, mid), from_raw_parts(ptr.add(mid), len - mid)) }\n+        unsafe {\n+            assert_unsafe_precondition!(\n+                \"slice::split_at_unchecked requires the index to be within the slice\",\n+                (mid: usize, len: usize) => mid <= len\n+            );\n+            (from_raw_parts(ptr, mid), from_raw_parts(ptr.add(mid), len - mid))\n+        }\n     }\n \n     /// Divides one mutable slice into two at an index, without doing bounds checking."}, {"sha": "a7a2b03774a8f5020cb0f2595c539b7eca41da98", "filename": "library/core/src/str/traits.rs", "status": "modified", "additions": 35, "deletions": 31, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/09f8885b3b84bc9ba06652dc58383f0e3ab97445/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f8885b3b84bc9ba06652dc58383f0e3ab97445/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs?ref=09f8885b3b84bc9ba06652dc58383f0e3ab97445", "patch": "@@ -1,6 +1,7 @@\n //! Trait implementations for `str`.\n \n use crate::cmp::Ordering;\n+use crate::intrinsics::assert_unsafe_precondition;\n use crate::ops;\n use crate::ptr;\n use crate::slice::SliceIndex;\n@@ -198,15 +199,31 @@ unsafe impl const SliceIndex<str> for ops::Range<usize> {\n         let slice = slice as *const [u8];\n         // SAFETY: the caller guarantees that `self` is in bounds of `slice`\n         // which satisfies all the conditions for `add`.\n-        let ptr = unsafe { slice.as_ptr().add(self.start) };\n+        let ptr = unsafe {\n+            let this = ops::Range { ..self };\n+            assert_unsafe_precondition!(\n+                \"str::get_unchecked requires that the range is within the string slice\",\n+                (this: ops::Range<usize>, slice: *const [u8]) =>\n+                this.end >= this.start && this.end <= slice.len()\n+            );\n+            slice.as_ptr().add(self.start)\n+        };\n         let len = self.end - self.start;\n         ptr::slice_from_raw_parts(ptr, len) as *const str\n     }\n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n         let slice = slice as *mut [u8];\n         // SAFETY: see comments for `get_unchecked`.\n-        let ptr = unsafe { slice.as_mut_ptr().add(self.start) };\n+        let ptr = unsafe {\n+            let this = ops::Range { ..self };\n+            assert_unsafe_precondition!(\n+                \"str::get_unchecked_mut requires that the range is within the string slice\",\n+                (this: ops::Range<usize>, slice: *mut [u8]) =>\n+                this.end >= this.start && this.end <= slice.len()\n+            );\n+            slice.as_mut_ptr().add(self.start)\n+        };\n         let len = self.end - self.start;\n         ptr::slice_from_raw_parts_mut(ptr, len) as *mut str\n     }\n@@ -276,15 +293,13 @@ unsafe impl const SliceIndex<str> for ops::RangeTo<usize> {\n     }\n     #[inline]\n     unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n-        let slice = slice as *const [u8];\n-        let ptr = slice.as_ptr();\n-        ptr::slice_from_raw_parts(ptr, self.end) as *const str\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n+        unsafe { (0..self.end).get_unchecked(slice) }\n     }\n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n-        let slice = slice as *mut [u8];\n-        let ptr = slice.as_mut_ptr();\n-        ptr::slice_from_raw_parts_mut(ptr, self.end) as *mut str\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n+        unsafe { (0..self.end).get_unchecked_mut(slice) }\n     }\n     #[inline]\n     fn index(self, slice: &str) -> &Self::Output {\n@@ -347,20 +362,15 @@ unsafe impl const SliceIndex<str> for ops::RangeFrom<usize> {\n     }\n     #[inline]\n     unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n-        let slice = slice as *const [u8];\n-        // SAFETY: the caller guarantees that `self` is in bounds of `slice`\n-        // which satisfies all the conditions for `add`.\n-        let ptr = unsafe { slice.as_ptr().add(self.start) };\n-        let len = slice.len() - self.start;\n-        ptr::slice_from_raw_parts(ptr, len) as *const str\n+        let len = (slice as *const [u8]).len();\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n+        unsafe { (self.start..len).get_unchecked(slice) }\n     }\n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n-        let slice = slice as *mut [u8];\n-        // SAFETY: identical to `get_unchecked`.\n-        let ptr = unsafe { slice.as_mut_ptr().add(self.start) };\n-        let len = slice.len() - self.start;\n-        ptr::slice_from_raw_parts_mut(ptr, len) as *mut str\n+        let len = (slice as *mut [u8]).len();\n+        // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n+        unsafe { (self.start..len).get_unchecked_mut(slice) }\n     }\n     #[inline]\n     fn index(self, slice: &str) -> &Self::Output {\n@@ -456,35 +466,29 @@ unsafe impl const SliceIndex<str> for ops::RangeToInclusive<usize> {\n     type Output = str;\n     #[inline]\n     fn get(self, slice: &str) -> Option<&Self::Output> {\n-        if self.end == usize::MAX { None } else { (..self.end + 1).get(slice) }\n+        (0..=self.end).get(slice)\n     }\n     #[inline]\n     fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n-        if self.end == usize::MAX { None } else { (..self.end + 1).get_mut(slice) }\n+        (0..=self.end).get_mut(slice)\n     }\n     #[inline]\n     unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n         // SAFETY: the caller must uphold the safety contract for `get_unchecked`.\n-        unsafe { (..self.end + 1).get_unchecked(slice) }\n+        unsafe { (0..=self.end).get_unchecked(slice) }\n     }\n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n         // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`.\n-        unsafe { (..self.end + 1).get_unchecked_mut(slice) }\n+        unsafe { (0..=self.end).get_unchecked_mut(slice) }\n     }\n     #[inline]\n     fn index(self, slice: &str) -> &Self::Output {\n-        if self.end == usize::MAX {\n-            str_index_overflow_fail();\n-        }\n-        (..self.end + 1).index(slice)\n+        (0..=self.end).index(slice)\n     }\n     #[inline]\n     fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n-        if self.end == usize::MAX {\n-            str_index_overflow_fail();\n-        }\n-        (..self.end + 1).index_mut(slice)\n+        (0..=self.end).index_mut(slice)\n     }\n }\n "}]}