{"sha": "14adc9bb63998d552bff351ad2184244cbc952f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0YWRjOWJiNjM5OThkNTUyYmZmMzUxYWQyMTg0MjQ0Y2JjOTUyZjY=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-02-11T18:16:33Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-02-13T10:49:24Z"}, "message": "Rename ast::Pat_ and its variants", "tree": {"sha": "0c499177783137083188b2412116e094b144a14e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c499177783137083188b2412116e094b144a14e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14adc9bb63998d552bff351ad2184244cbc952f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14adc9bb63998d552bff351ad2184244cbc952f6", "html_url": "https://github.com/rust-lang/rust/commit/14adc9bb63998d552bff351ad2184244cbc952f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14adc9bb63998d552bff351ad2184244cbc952f6/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5801991b5d54676410b7a65a664e8e83cc89136d", "url": "https://api.github.com/repos/rust-lang/rust/commits/5801991b5d54676410b7a65a664e8e83cc89136d", "html_url": "https://github.com/rust-lang/rust/commit/5801991b5d54676410b7a65a664e8e83cc89136d"}], "stats": {"total": 290, "additions": 145, "deletions": 145}, "files": [{"sha": "9be88a391ec49b0bff7f429a661efe1e7696ab59", "filename": "src/librustc_front/lowering.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/14adc9bb63998d552bff351ad2184244cbc952f6/src%2Flibrustc_front%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14adc9bb63998d552bff351ad2184244cbc952f6/src%2Flibrustc_front%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flowering.rs?ref=14adc9bb63998d552bff351ad2184244cbc952f6", "patch": "@@ -913,26 +913,26 @@ pub fn lower_pat(lctx: &LoweringContext, p: &Pat) -> P<hir::Pat> {\n     P(hir::Pat {\n         id: p.id,\n         node: match p.node {\n-            PatWild => hir::PatWild,\n-            PatIdent(ref binding_mode, pth1, ref sub) => {\n+            PatKind::Wild => hir::PatWild,\n+            PatKind::Ident(ref binding_mode, pth1, ref sub) => {\n                 hir::PatIdent(lower_binding_mode(lctx, binding_mode),\n                               respan(pth1.span, lower_ident(lctx, pth1.node)),\n                               sub.as_ref().map(|x| lower_pat(lctx, x)))\n             }\n-            PatLit(ref e) => hir::PatLit(lower_expr(lctx, e)),\n-            PatEnum(ref pth, ref pats) => {\n+            PatKind::Lit(ref e) => hir::PatLit(lower_expr(lctx, e)),\n+            PatKind::Enum(ref pth, ref pats) => {\n                 hir::PatEnum(lower_path(lctx, pth),\n                              pats.as_ref()\n                                  .map(|pats| pats.iter().map(|x| lower_pat(lctx, x)).collect()))\n             }\n-            PatQPath(ref qself, ref pth) => {\n+            PatKind::QPath(ref qself, ref pth) => {\n                 let qself = hir::QSelf {\n                     ty: lower_ty(lctx, &qself.ty),\n                     position: qself.position,\n                 };\n                 hir::PatQPath(qself, lower_path(lctx, pth))\n             }\n-            PatStruct(ref pth, ref fields, etc) => {\n+            PatKind::Struct(ref pth, ref fields, etc) => {\n                 let pth = lower_path(lctx, pth);\n                 let fs = fields.iter()\n                                .map(|f| {\n@@ -948,20 +948,22 @@ pub fn lower_pat(lctx: &LoweringContext, p: &Pat) -> P<hir::Pat> {\n                                .collect();\n                 hir::PatStruct(pth, fs, etc)\n             }\n-            PatTup(ref elts) => hir::PatTup(elts.iter().map(|x| lower_pat(lctx, x)).collect()),\n-            PatBox(ref inner) => hir::PatBox(lower_pat(lctx, inner)),\n-            PatRegion(ref inner, mutbl) => {\n+            PatKind::Tup(ref elts) => {\n+                hir::PatTup(elts.iter().map(|x| lower_pat(lctx, x)).collect())\n+            }\n+            PatKind::Box(ref inner) => hir::PatBox(lower_pat(lctx, inner)),\n+            PatKind::Ref(ref inner, mutbl) => {\n                 hir::PatRegion(lower_pat(lctx, inner), lower_mutability(lctx, mutbl))\n             }\n-            PatRange(ref e1, ref e2) => {\n+            PatKind::Range(ref e1, ref e2) => {\n                 hir::PatRange(lower_expr(lctx, e1), lower_expr(lctx, e2))\n             }\n-            PatVec(ref before, ref slice, ref after) => {\n+            PatKind::Vec(ref before, ref slice, ref after) => {\n                 hir::PatVec(before.iter().map(|x| lower_pat(lctx, x)).collect(),\n                             slice.as_ref().map(|x| lower_pat(lctx, x)),\n                             after.iter().map(|x| lower_pat(lctx, x)).collect())\n             }\n-            PatMac(_) => panic!(\"Shouldn't exist here\"),\n+            PatKind::Mac(_) => panic!(\"Shouldn't exist here\"),\n         },\n         span: p.span,\n     })"}, {"sha": "54dcda27b77a3b6823f22f6dab83ecc55d9cca46", "filename": "src/librustc_passes/const_fn.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/14adc9bb63998d552bff351ad2184244cbc952f6/src%2Flibrustc_passes%2Fconst_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14adc9bb63998d552bff351ad2184244cbc952f6/src%2Flibrustc_passes%2Fconst_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconst_fn.rs?ref=14adc9bb63998d552bff351ad2184244cbc952f6", "patch": "@@ -13,7 +13,7 @@\n \n use rustc::session::{Session, CompileResult};\n \n-use syntax::ast;\n+use syntax::ast::{self, PatKind};\n use syntax::visit::{self, Visitor, FnKind};\n use syntax::codemap::Span;\n \n@@ -104,8 +104,8 @@ impl<'a, 'v> Visitor<'v> for CheckConstFn<'a> {\n         // Ensure the arguments are simple, not mutable/by-ref or patterns.\n         for arg in &fd.inputs {\n             match arg.pat.node {\n-                ast::PatWild => {}\n-                ast::PatIdent(ast::BindingMode::ByValue(ast::Mutability::Immutable), _, None) => {}\n+                PatKind::Wild => {}\n+                PatKind::Ident(ast::BindingMode::ByValue(ast::Mutability::Immutable), _, None) => {}\n                 _ => {\n                     span_err!(self.sess, arg.pat.span, E0022,\n                               \"arguments of constant functions can only \\"}, {"sha": "d79f284a13500cd7f642d0797f01ef6d1a23e445", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14adc9bb63998d552bff351ad2184244cbc952f6/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14adc9bb63998d552bff351ad2184244cbc952f6/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=14adc9bb63998d552bff351ad2184244cbc952f6", "patch": "@@ -40,7 +40,7 @@ use std::fs::File;\n use std::hash::*;\n use std::collections::HashSet;\n \n-use syntax::ast::{self, NodeId};\n+use syntax::ast::{self, NodeId, PatKind};\n use syntax::codemap::*;\n use syntax::parse::token::{self, keywords};\n use syntax::visit::{self, Visitor};\n@@ -780,7 +780,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n \n     fn process_pat(&mut self, p: &ast::Pat) {\n         match p.node {\n-            ast::PatStruct(ref path, ref fields, _) => {\n+            PatKind::Struct(ref path, ref fields, _) => {\n                 visit::walk_path(self, path);\n                 let adt = self.tcx.node_id_to_type(p.id).ty_adt_def().unwrap();\n                 let def = self.tcx.def_map.borrow()[&p.id].full_def();"}, {"sha": "6a486501c6baeb933831318f6a40eed1cb1f7e2b", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/14adc9bb63998d552bff351ad2184244cbc952f6/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14adc9bb63998d552bff351ad2184244cbc952f6/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=14adc9bb63998d552bff351ad2184244cbc952f6", "patch": "@@ -21,7 +21,7 @@ use rustc_front::{hir, lowering};\n use rustc::front::map::NodeItem;\n use rustc::session::config::CrateType::CrateTypeExecutable;\n \n-use syntax::ast::{self, NodeId};\n+use syntax::ast::{self, NodeId, PatKind};\n use syntax::ast_util;\n use syntax::codemap::*;\n use syntax::parse::token::{self, keywords};\n@@ -758,16 +758,16 @@ impl PathCollector {\n impl<'v> Visitor<'v> for PathCollector {\n     fn visit_pat(&mut self, p: &ast::Pat) {\n         match p.node {\n-            ast::PatStruct(ref path, _, _) => {\n+            PatKind::Struct(ref path, _, _) => {\n                 self.collected_paths.push((p.id, path.clone(),\n                                            ast::Mutability::Mutable, recorder::TypeRef));\n             }\n-            ast::PatEnum(ref path, _) |\n-            ast::PatQPath(_, ref path) => {\n+            PatKind::Enum(ref path, _) |\n+            PatKind::QPath(_, ref path) => {\n                 self.collected_paths.push((p.id, path.clone(),\n                                            ast::Mutability::Mutable, recorder::VarRef));\n             }\n-            ast::PatIdent(bm, ref path1, _) => {\n+            PatKind::Ident(bm, ref path1, _) => {\n                 debug!(\"PathCollector, visit ident in pat {}: {:?} {:?}\",\n                        path1.node,\n                        p.span,"}, {"sha": "0a208082e55666ec6e8fa31a1863cf9c749efda6", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/14adc9bb63998d552bff351ad2184244cbc952f6/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14adc9bb63998d552bff351ad2184244cbc952f6/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=14adc9bb63998d552bff351ad2184244cbc952f6", "patch": "@@ -10,7 +10,6 @@\n \n // The Rust abstract syntax tree.\n \n-pub use self::Pat_::*;\n pub use self::StructFieldKind::*;\n pub use self::TyParamBound::*;\n pub use self::UnsafeSource::*;\n@@ -521,7 +520,7 @@ pub struct Block {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n pub struct Pat {\n     pub id: NodeId,\n-    pub node: Pat_,\n+    pub node: PatKind,\n     pub span: Span,\n }\n \n@@ -552,47 +551,47 @@ pub enum BindingMode {\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum Pat_ {\n+pub enum PatKind {\n     /// Represents a wildcard pattern (`_`)\n-    PatWild,\n+    Wild,\n \n-    /// A PatIdent may either be a new bound variable,\n+    /// A PatKind::Ident may either be a new bound variable,\n     /// or a nullary enum (in which case the third field\n     /// is None).\n     ///\n     /// In the nullary enum case, the parser can't determine\n     /// which it is. The resolver determines this, and\n     /// records this pattern's NodeId in an auxiliary\n     /// set (of \"PatIdents that refer to nullary enums\")\n-    PatIdent(BindingMode, SpannedIdent, Option<P<Pat>>),\n+    Ident(BindingMode, SpannedIdent, Option<P<Pat>>),\n \n     /// \"None\" means a `Variant(..)` pattern where we don't bind the fields to names.\n-    PatEnum(Path, Option<Vec<P<Pat>>>),\n+    Enum(Path, Option<Vec<P<Pat>>>),\n \n     /// An associated const named using the qualified path `<T>::CONST` or\n     /// `<T as Trait>::CONST`. Associated consts from inherent impls can be\n     /// referred to as simply `T::CONST`, in which case they will end up as\n-    /// PatEnum, and the resolver will have to sort that out.\n-    PatQPath(QSelf, Path),\n+    /// PatKind::Enum, and the resolver will have to sort that out.\n+    QPath(QSelf, Path),\n \n     /// Destructuring of a struct, e.g. `Foo {x, y, ..}`\n     /// The `bool` is `true` in the presence of a `..`\n-    PatStruct(Path, Vec<Spanned<FieldPat>>, bool),\n+    Struct(Path, Vec<Spanned<FieldPat>>, bool),\n     /// A tuple pattern `(a, b)`\n-    PatTup(Vec<P<Pat>>),\n+    Tup(Vec<P<Pat>>),\n     /// A `box` pattern\n-    PatBox(P<Pat>),\n+    Box(P<Pat>),\n     /// A reference pattern, e.g. `&mut (a, b)`\n-    PatRegion(P<Pat>, Mutability),\n+    Ref(P<Pat>, Mutability),\n     /// A literal\n-    PatLit(P<Expr>),\n+    Lit(P<Expr>),\n     /// A range pattern, e.g. `1...2`\n-    PatRange(P<Expr>, P<Expr>),\n+    Range(P<Expr>, P<Expr>),\n     /// `[a, b, ..i, y, z]` is represented as:\n-    ///     `PatVec(box [a, b], Some(i), box [y, z])`\n-    PatVec(Vec<P<Pat>>, Option<P<Pat>>, Vec<P<Pat>>),\n+    ///     `PatKind::Vec(box [a, b], Some(i), box [y, z])`\n+    Vec(Vec<P<Pat>>, Option<P<Pat>>, Vec<P<Pat>>),\n     /// A macro pattern; pre-expansion\n-    PatMac(Mac),\n+    Mac(Mac),\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n@@ -1609,7 +1608,7 @@ impl Arg {\n             }),\n             pat: P(Pat {\n                 id: DUMMY_NODE_ID,\n-                node: PatIdent(BindingMode::ByValue(mutability), path, None),\n+                node: PatKind::Ident(BindingMode::ByValue(mutability), path, None),\n                 span: span\n             }),\n             id: DUMMY_NODE_ID"}, {"sha": "5d55b6f8f88d3218e9acec6039ed77cd5321bd51", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14adc9bb63998d552bff351ad2184244cbc952f6/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14adc9bb63998d552bff351ad2184244cbc952f6/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=14adc9bb63998d552bff351ad2184244cbc952f6", "patch": "@@ -69,7 +69,7 @@ pub fn ident_to_pat(id: NodeId, s: Span, i: Ident) -> P<Pat> {\n     let spanned = codemap::Spanned{ span: s, node: i };\n     P(Pat {\n         id: id,\n-        node: PatIdent(BindingMode::ByValue(Mutability::Immutable), spanned, None),\n+        node: PatKind::Ident(BindingMode::ByValue(Mutability::Immutable), spanned, None),\n         span: s\n     })\n }\n@@ -348,7 +348,7 @@ pub fn compute_id_range_for_fn_body(fk: FnKind,\n /// and false otherwise.\n pub fn pat_is_ident(pat: P<ast::Pat>) -> bool {\n     match pat.node {\n-        ast::PatIdent(..) => true,\n+        PatKind::Ident(..) => true,\n         _ => false,\n     }\n }"}, {"sha": "8fc72418eb0bc45500658c2f42806daa0680d7b8", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/14adc9bb63998d552bff351ad2184244cbc952f6/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14adc9bb63998d552bff351ad2184244cbc952f6/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=14adc9bb63998d552bff351ad2184244cbc952f6", "patch": "@@ -11,7 +11,7 @@\n pub use self::SyntaxExtension::*;\n \n use ast;\n-use ast::Name;\n+use ast::{Name, PatKind};\n use codemap;\n use codemap::{CodeMap, Span, ExpnId, ExpnInfo, NO_EXPANSION};\n use errors::DiagnosticBuilder;\n@@ -307,7 +307,7 @@ impl MacResult for MacEager {\n                 return Some(P(ast::Pat {\n                     id: ast::DUMMY_NODE_ID,\n                     span: e.span,\n-                    node: ast::PatLit(e),\n+                    node: PatKind::Lit(e),\n                 }));\n             }\n         }\n@@ -359,7 +359,7 @@ impl DummyResult {\n     pub fn raw_pat(sp: Span) -> ast::Pat {\n         ast::Pat {\n             id: ast::DUMMY_NODE_ID,\n-            node: ast::PatWild,\n+            node: PatKind::Wild,\n             span: sp,\n         }\n     }"}, {"sha": "312154e5a8d30665490978eeed9c662dc250fdcc", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/14adc9bb63998d552bff351ad2184244cbc952f6/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14adc9bb63998d552bff351ad2184244cbc952f6/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=14adc9bb63998d552bff351ad2184244cbc952f6", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use abi::Abi;\n-use ast::{self, Ident, Generics, Expr, BlockCheckMode, UnOp};\n+use ast::{self, Ident, Generics, Expr, BlockCheckMode, UnOp, PatKind};\n use attr;\n use codemap::{Span, respan, Spanned, DUMMY_SP, Pos};\n use ext::base::ExtCtxt;\n@@ -166,7 +166,7 @@ pub trait AstBuilder {\n     fn expr_err(&self, span: Span, expr: P<ast::Expr>) -> P<ast::Expr>;\n     fn expr_try(&self, span: Span, head: P<ast::Expr>) -> P<ast::Expr>;\n \n-    fn pat(&self, span: Span, pat: ast::Pat_) -> P<ast::Pat>;\n+    fn pat(&self, span: Span, pat: PatKind) -> P<ast::Pat>;\n     fn pat_wild(&self, span: Span) -> P<ast::Pat>;\n     fn pat_lit(&self, span: Span, expr: P<ast::Expr>) -> P<ast::Pat>;\n     fn pat_ident(&self, span: Span, ident: ast::Ident) -> P<ast::Pat>;\n@@ -805,14 +805,14 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n \n-    fn pat(&self, span: Span, pat: ast::Pat_) -> P<ast::Pat> {\n+    fn pat(&self, span: Span, pat: PatKind) -> P<ast::Pat> {\n         P(ast::Pat { id: ast::DUMMY_NODE_ID, node: pat, span: span })\n     }\n     fn pat_wild(&self, span: Span) -> P<ast::Pat> {\n-        self.pat(span, ast::PatWild)\n+        self.pat(span, PatKind::Wild)\n     }\n     fn pat_lit(&self, span: Span, expr: P<ast::Expr>) -> P<ast::Pat> {\n-        self.pat(span, ast::PatLit(expr))\n+        self.pat(span, PatKind::Lit(expr))\n     }\n     fn pat_ident(&self, span: Span, ident: ast::Ident) -> P<ast::Pat> {\n         let binding_mode = ast::BindingMode::ByValue(ast::Mutability::Immutable);\n@@ -823,20 +823,20 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                               span: Span,\n                               ident: ast::Ident,\n                               bm: ast::BindingMode) -> P<ast::Pat> {\n-        let pat = ast::PatIdent(bm, Spanned{span: span, node: ident}, None);\n+        let pat = PatKind::Ident(bm, Spanned{span: span, node: ident}, None);\n         self.pat(span, pat)\n     }\n     fn pat_enum(&self, span: Span, path: ast::Path, subpats: Vec<P<ast::Pat>>) -> P<ast::Pat> {\n-        let pat = ast::PatEnum(path, Some(subpats));\n+        let pat = PatKind::Enum(path, Some(subpats));\n         self.pat(span, pat)\n     }\n     fn pat_struct(&self, span: Span,\n                   path: ast::Path, field_pats: Vec<Spanned<ast::FieldPat>>) -> P<ast::Pat> {\n-        let pat = ast::PatStruct(path, field_pats, false);\n+        let pat = PatKind::Struct(path, field_pats, false);\n         self.pat(span, pat)\n     }\n     fn pat_tuple(&self, span: Span, pats: Vec<P<ast::Pat>>) -> P<ast::Pat> {\n-        self.pat(span, ast::PatTup(pats))\n+        self.pat(span, PatKind::Tup(pats))\n     }\n \n     fn pat_some(&self, span: Span, pat: P<ast::Pat>) -> P<ast::Pat> {"}, {"sha": "e8e042c13217ab3a1c58b9ab2c2acc683ae06007", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/14adc9bb63998d552bff351ad2184244cbc952f6/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14adc9bb63998d552bff351ad2184244cbc952f6/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=14adc9bb63998d552bff351ad2184244cbc952f6", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{Block, Crate, DeclKind, PatMac};\n+use ast::{Block, Crate, DeclKind, PatKind};\n use ast::{Local, Ident, Mac_, Name};\n use ast::{MacStmtStyle, Mrk, Stmt, StmtKind, ItemKind};\n use ast::TokenTree;\n@@ -666,7 +666,7 @@ fn rename_in_scope<X, F>(pats: Vec<P<ast::Pat>>,\n     (f(&mut rename_fld, fld, x), rewritten_pats)\n }\n \n-/// A visitor that extracts the PatIdent (binding) paths\n+/// A visitor that extracts the PatKind::Ident (binding) paths\n /// from a given thingy and puts them in a mutable\n /// array\n #[derive(Clone)]\n@@ -677,9 +677,9 @@ struct PatIdentFinder {\n impl<'v> Visitor<'v> for PatIdentFinder {\n     fn visit_pat(&mut self, pattern: &ast::Pat) {\n         match *pattern {\n-            ast::Pat { id: _, node: ast::PatIdent(_, ref path1, ref inner), span: _ } => {\n+            ast::Pat { id: _, node: PatKind::Ident(_, ref path1, ref inner), span: _ } => {\n                 self.ident_accumulator.push(path1.node);\n-                // visit optional subpattern of PatIdent:\n+                // visit optional subpattern of PatKind::Ident:\n                 if let Some(ref subpat) = *inner {\n                     self.visit_pat(subpat)\n                 }\n@@ -690,14 +690,14 @@ impl<'v> Visitor<'v> for PatIdentFinder {\n     }\n }\n \n-/// find the PatIdent paths in a pattern\n+/// find the PatKind::Ident paths in a pattern\n fn pattern_bindings(pat: &ast::Pat) -> Vec<ast::Ident> {\n     let mut name_finder = PatIdentFinder{ident_accumulator:Vec::new()};\n     name_finder.visit_pat(pat);\n     name_finder.ident_accumulator\n }\n \n-/// find the PatIdent paths in a\n+/// find the PatKind::Ident paths in a\n fn fn_decl_arg_bindings(fn_decl: &ast::FnDecl) -> Vec<ast::Ident> {\n     let mut pat_idents = PatIdentFinder{ident_accumulator:Vec::new()};\n     for arg in &fn_decl.inputs {\n@@ -746,12 +746,12 @@ pub fn expand_block_elts(b: P<Block>, fld: &mut MacroExpander) -> P<Block> {\n \n fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n     match p.node {\n-        PatMac(_) => {}\n+        PatKind::Mac(_) => {}\n         _ => return noop_fold_pat(p, fld)\n     }\n     p.map(|ast::Pat {node, span, ..}| {\n         let (pth, tts) = match node {\n-            PatMac(mac) => (mac.node.path, mac.node.tts),\n+            PatKind::Mac(mac) => (mac.node.path, mac.node.tts),\n             _ => unreachable!()\n         };\n         if pth.segments.len() > 1 {\n@@ -840,7 +840,7 @@ impl<'a> Folder for IdentRenamer<'a> {\n }\n \n /// A tree-folder that applies every rename in its list to\n-/// the idents that are in PatIdent patterns. This is more narrowly\n+/// the idents that are in PatKind::Ident patterns. This is more narrowly\n /// focused than IdentRenamer, and is needed for FnDecl,\n /// where we want to rename the args but not the fn name or the generics etc.\n pub struct PatIdentRenamer<'a> {\n@@ -850,16 +850,16 @@ pub struct PatIdentRenamer<'a> {\n impl<'a> Folder for PatIdentRenamer<'a> {\n     fn fold_pat(&mut self, pat: P<ast::Pat>) -> P<ast::Pat> {\n         match pat.node {\n-            ast::PatIdent(..) => {},\n+            PatKind::Ident(..) => {},\n             _ => return noop_fold_pat(pat, self)\n         }\n \n         pat.map(|ast::Pat {id, node, span}| match node {\n-            ast::PatIdent(binding_mode, Spanned{span: sp, node: ident}, sub) => {\n+            PatKind::Ident(binding_mode, Spanned{span: sp, node: ident}, sub) => {\n                 let new_ident = Ident::new(ident.name,\n                                            mtwt::apply_renames(self.renames, ident.ctxt));\n                 let new_node =\n-                    ast::PatIdent(binding_mode,\n+                    PatKind::Ident(binding_mode,\n                                   Spanned{span: self.new_span(sp), node: new_ident},\n                                   sub.map(|p| self.fold_pat(p)));\n                 ast::Pat {"}, {"sha": "70bd85c00d453ebe74a568c8e767b4aa908c84a4", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/14adc9bb63998d552bff351ad2184244cbc952f6/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14adc9bb63998d552bff351ad2184244cbc952f6/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=14adc9bb63998d552bff351ad2184244cbc952f6", "patch": "@@ -27,7 +27,7 @@ use self::AttributeType::*;\n use self::AttributeGate::*;\n \n use abi::Abi;\n-use ast::NodeId;\n+use ast::{NodeId, PatKind};\n use ast;\n use attr;\n use attr::AttrMetaMethods;\n@@ -1005,19 +1005,19 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n \n     fn visit_pat(&mut self, pattern: &ast::Pat) {\n         match pattern.node {\n-            ast::PatVec(_, Some(_), ref last) if !last.is_empty() => {\n+            PatKind::Vec(_, Some(_), ref last) if !last.is_empty() => {\n                 self.gate_feature(\"advanced_slice_patterns\",\n                                   pattern.span,\n                                   \"multiple-element slice matches anywhere \\\n                                    but at the end of a slice (e.g. \\\n                                    `[0, ..xs, 0]`) are experimental\")\n             }\n-            ast::PatVec(..) => {\n+            PatKind::Vec(..) => {\n                 self.gate_feature(\"slice_patterns\",\n                                   pattern.span,\n                                   \"slice pattern syntax is experimental\");\n             }\n-            ast::PatBox(..) => {\n+            PatKind::Box(..) => {\n                 self.gate_feature(\"box_patterns\",\n                                   pattern.span,\n                                   \"box pattern syntax is experimental\");"}, {"sha": "548d883d93ff5020dc1318aca36b3b1b89d5d460", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/14adc9bb63998d552bff351ad2184244cbc952f6/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14adc9bb63998d552bff351ad2184244cbc952f6/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=14adc9bb63998d552bff351ad2184244cbc952f6", "patch": "@@ -1119,23 +1119,23 @@ pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n     p.map(|Pat {id, node, span}| Pat {\n         id: folder.new_id(id),\n         node: match node {\n-            PatWild => PatWild,\n-            PatIdent(binding_mode, pth1, sub) => {\n-                PatIdent(binding_mode,\n+            PatKind::Wild => PatKind::Wild,\n+            PatKind::Ident(binding_mode, pth1, sub) => {\n+                PatKind::Ident(binding_mode,\n                         Spanned{span: folder.new_span(pth1.span),\n                                 node: folder.fold_ident(pth1.node)},\n                         sub.map(|x| folder.fold_pat(x)))\n             }\n-            PatLit(e) => PatLit(folder.fold_expr(e)),\n-            PatEnum(pth, pats) => {\n-                PatEnum(folder.fold_path(pth),\n+            PatKind::Lit(e) => PatKind::Lit(folder.fold_expr(e)),\n+            PatKind::Enum(pth, pats) => {\n+                PatKind::Enum(folder.fold_path(pth),\n                         pats.map(|pats| pats.move_map(|x| folder.fold_pat(x))))\n             }\n-            PatQPath(qself, pth) => {\n+            PatKind::QPath(qself, pth) => {\n                 let qself = QSelf {ty: folder.fold_ty(qself.ty), .. qself};\n-                PatQPath(qself, folder.fold_path(pth))\n+                PatKind::QPath(qself, folder.fold_path(pth))\n             }\n-            PatStruct(pth, fields, etc) => {\n+            PatKind::Struct(pth, fields, etc) => {\n                 let pth = folder.fold_path(pth);\n                 let fs = fields.move_map(|f| {\n                     Spanned { span: folder.new_span(f.span),\n@@ -1145,20 +1145,20 @@ pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n                                   is_shorthand: f.node.is_shorthand,\n                               }}\n                 });\n-                PatStruct(pth, fs, etc)\n+                PatKind::Struct(pth, fs, etc)\n             }\n-            PatTup(elts) => PatTup(elts.move_map(|x| folder.fold_pat(x))),\n-            PatBox(inner) => PatBox(folder.fold_pat(inner)),\n-            PatRegion(inner, mutbl) => PatRegion(folder.fold_pat(inner), mutbl),\n-            PatRange(e1, e2) => {\n-                PatRange(folder.fold_expr(e1), folder.fold_expr(e2))\n+            PatKind::Tup(elts) => PatKind::Tup(elts.move_map(|x| folder.fold_pat(x))),\n+            PatKind::Box(inner) => PatKind::Box(folder.fold_pat(inner)),\n+            PatKind::Ref(inner, mutbl) => PatKind::Ref(folder.fold_pat(inner), mutbl),\n+            PatKind::Range(e1, e2) => {\n+                PatKind::Range(folder.fold_expr(e1), folder.fold_expr(e2))\n             },\n-            PatVec(before, slice, after) => {\n-                PatVec(before.move_map(|x| folder.fold_pat(x)),\n+            PatKind::Vec(before, slice, after) => {\n+                PatKind::Vec(before.move_map(|x| folder.fold_pat(x)),\n                        slice.map(|x| folder.fold_pat(x)),\n                        after.move_map(|x| folder.fold_pat(x)))\n             }\n-            PatMac(mac) => PatMac(folder.fold_mac(mac))\n+            PatKind::Mac(mac) => PatKind::Mac(folder.fold_mac(mac))\n         },\n         span: folder.new_span(span)\n     })"}, {"sha": "1ec2479058cc8d22d4deb5105b2b7a6d6840a2f7", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/14adc9bb63998d552bff351ad2184244cbc952f6/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14adc9bb63998d552bff351ad2184244cbc952f6/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=14adc9bb63998d552bff351ad2184244cbc952f6", "patch": "@@ -675,7 +675,7 @@ mod tests {\n     use super::*;\n     use std::rc::Rc;\n     use codemap::{Span, BytePos, Pos, Spanned, NO_EXPANSION};\n-    use ast::{self, TokenTree};\n+    use ast::{self, TokenTree, PatKind};\n     use abi::Abi;\n     use attr::{first_attr_value_str_by_name, AttrMetaMethods};\n     use parse;\n@@ -896,7 +896,7 @@ mod tests {\n         assert!(panictry!(parser.parse_pat())\n                 == P(ast::Pat{\n                 id: ast::DUMMY_NODE_ID,\n-                node: ast::PatIdent(ast::BindingMode::ByValue(ast::Mutability::Immutable),\n+                node: PatKind::Ident(ast::BindingMode::ByValue(ast::Mutability::Immutable),\n                                     Spanned{ span:sp(0, 1),\n                                              node: str_to_ident(\"b\")\n                     },\n@@ -931,7 +931,7 @@ mod tests {\n                                     }),\n                                     pat: P(ast::Pat {\n                                         id: ast::DUMMY_NODE_ID,\n-                                        node: ast::PatIdent(\n+                                        node: PatKind::Ident(\n                                             ast::BindingMode::ByValue(ast::Mutability::Immutable),\n                                                 Spanned{\n                                                     span: sp(6,7),\n@@ -1020,7 +1020,7 @@ mod tests {\n         impl<'v> ::visit::Visitor<'v> for PatIdentVisitor {\n             fn visit_pat(&mut self, p: &'v ast::Pat) {\n                 match p.node {\n-                    ast::PatIdent(_ , ref spannedident, _) => {\n+                    PatKind::Ident(_ , ref spannedident, _) => {\n                         self.spans.push(spannedident.span.clone());\n                     }\n                     _ => {"}, {"sha": "f1de30b373f02cdf9596b4ec001a8015ccffd408", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/14adc9bb63998d552bff351ad2184244cbc952f6/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14adc9bb63998d552bff351ad2184244cbc952f6/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=14adc9bb63998d552bff351ad2184244cbc952f6", "patch": "@@ -30,8 +30,7 @@ use ast::MacStmtStyle;\n use ast::Mac_;\n use ast::{MutTy, Mutability};\n use ast::NamedField;\n-use ast::{Pat, PatBox, PatEnum, PatIdent, PatLit, PatQPath, PatMac, PatRange};\n-use ast::{PatRegion, PatStruct, PatTup, PatVec, PatWild};\n+use ast::{Pat, PatKind};\n use ast::{PolyTraitRef, QSelf};\n use ast::{Stmt, StmtKind};\n use ast::{VariantData, StructField};\n@@ -3292,7 +3291,7 @@ impl<'a> Parser<'a> {\n                             self.check(&token::CloseDelim(token::Bracket)) {\n                         slice = Some(P(ast::Pat {\n                             id: ast::DUMMY_NODE_ID,\n-                            node: PatWild,\n+                            node: PatKind::Wild,\n                             span: self.span,\n                         }));\n                         before_slice = false;\n@@ -3370,14 +3369,14 @@ impl<'a> Parser<'a> {\n                 let fieldpath = codemap::Spanned{span:self.last_span, node:fieldname};\n                 let fieldpat = P(ast::Pat{\n                     id: ast::DUMMY_NODE_ID,\n-                    node: PatIdent(bind_type, fieldpath, None),\n+                    node: PatKind::Ident(bind_type, fieldpath, None),\n                     span: mk_sp(boxed_span_lo, hi),\n                 });\n \n                 let subpat = if is_box {\n                     P(ast::Pat{\n                         id: ast::DUMMY_NODE_ID,\n-                        node: PatBox(fieldpat),\n+                        node: PatKind::Box(fieldpat),\n                         span: mk_sp(lo, hi),\n                     })\n                 } else {\n@@ -3429,7 +3428,7 @@ impl<'a> Parser<'a> {\n           token::Underscore => {\n             // Parse _\n             self.bump();\n-            pat = PatWild;\n+            pat = PatKind::Wild;\n           }\n           token::BinOp(token::And) | token::AndAnd => {\n             // Parse &pat / &mut pat\n@@ -3440,21 +3439,21 @@ impl<'a> Parser<'a> {\n             }\n \n             let subpat = try!(self.parse_pat());\n-            pat = PatRegion(subpat, mutbl);\n+            pat = PatKind::Ref(subpat, mutbl);\n           }\n           token::OpenDelim(token::Paren) => {\n             // Parse (pat,pat,pat,...) as tuple pattern\n             self.bump();\n             let fields = try!(self.parse_pat_tuple_elements());\n             try!(self.expect(&token::CloseDelim(token::Paren)));\n-            pat = PatTup(fields);\n+            pat = PatKind::Tup(fields);\n           }\n           token::OpenDelim(token::Bracket) => {\n             // Parse [pat,pat,...] as slice pattern\n             self.bump();\n             let (before, slice, after) = try!(self.parse_pat_vec_elements());\n             try!(self.expect(&token::CloseDelim(token::Bracket)));\n-            pat = PatVec(before, slice, after);\n+            pat = PatKind::Vec(before, slice, after);\n           }\n           _ => {\n             // At this point, token != _, &, &&, (, [\n@@ -3468,7 +3467,7 @@ impl<'a> Parser<'a> {\n             } else if self.eat_keyword(keywords::Box) {\n                 // Parse box pat\n                 let subpat = try!(self.parse_pat());\n-                pat = PatBox(subpat);\n+                pat = PatKind::Box(subpat);\n             } else if self.is_path_start() {\n                 // Parse pattern starting with a path\n                 if self.token.is_plain_ident() && self.look_ahead(1, |t| *t != token::DotDotDot &&\n@@ -3487,7 +3486,7 @@ impl<'a> Parser<'a> {\n                         let tts = try!(self.parse_seq_to_end(&token::CloseDelim(delim),\n                                 seq_sep_none(), |p| p.parse_token_tree()));\n                         let mac = Mac_ { path: path, tts: tts, ctxt: EMPTY_CTXT };\n-                        pat = PatMac(codemap::Spanned {node: mac,\n+                        pat = PatKind::Mac(codemap::Spanned {node: mac,\n                                                        span: mk_sp(lo, self.last_span.hi)});\n                     } else {\n                         // Parse ident @ pat\n@@ -3513,7 +3512,7 @@ impl<'a> Parser<'a> {\n                         let begin = self.mk_expr(lo, hi, ExprKind::Path(qself, path), None);\n                         self.bump();\n                         let end = try!(self.parse_pat_range_end());\n-                        pat = PatRange(begin, end);\n+                        pat = PatKind::Range(begin, end);\n                       }\n                       token::OpenDelim(token::Brace) => {\n                          if qself.is_some() {\n@@ -3523,7 +3522,7 @@ impl<'a> Parser<'a> {\n                         self.bump();\n                         let (fields, etc) = try!(self.parse_pat_fields());\n                         self.bump();\n-                        pat = PatStruct(path, fields, etc);\n+                        pat = PatKind::Struct(path, fields, etc);\n                       }\n                       token::OpenDelim(token::Paren) => {\n                         if qself.is_some() {\n@@ -3535,22 +3534,22 @@ impl<'a> Parser<'a> {\n                             self.bump();\n                             self.bump();\n                             try!(self.expect(&token::CloseDelim(token::Paren)));\n-                            pat = PatEnum(path, None);\n+                            pat = PatKind::Enum(path, None);\n                         } else {\n                             let args = try!(self.parse_enum_variant_seq(\n                                     &token::OpenDelim(token::Paren),\n                                     &token::CloseDelim(token::Paren),\n                                     seq_sep_trailing_allowed(token::Comma),\n                                     |p| p.parse_pat()));\n-                            pat = PatEnum(path, Some(args));\n+                            pat = PatKind::Enum(path, Some(args));\n                         }\n                       }\n                       _ => {\n                         pat = match qself {\n                             // Parse qualified path\n-                            Some(qself) => PatQPath(qself, path),\n+                            Some(qself) => PatKind::QPath(qself, path),\n                             // Parse nullary enum\n-                            None => PatEnum(path, Some(vec![]))\n+                            None => PatKind::Enum(path, Some(vec![]))\n                         };\n                       }\n                     }\n@@ -3560,9 +3559,9 @@ impl<'a> Parser<'a> {\n                 let begin = try!(self.parse_pat_literal_maybe_minus());\n                 if self.eat(&token::DotDotDot) {\n                     let end = try!(self.parse_pat_range_end());\n-                    pat = PatRange(begin, end);\n+                    pat = PatKind::Range(begin, end);\n                 } else {\n-                    pat = PatLit(begin);\n+                    pat = PatKind::Lit(begin);\n                 }\n             }\n           }\n@@ -3581,7 +3580,7 @@ impl<'a> Parser<'a> {\n     /// error message when parsing mistakes like ref foo(a,b)\n     fn parse_pat_ident(&mut self,\n                        binding_mode: ast::BindingMode)\n-                       -> PResult<'a, ast::Pat_> {\n+                       -> PResult<'a, PatKind> {\n         if !self.token.is_plain_ident() {\n             let span = self.span;\n             let tok_str = self.this_token_to_string();\n@@ -3610,7 +3609,7 @@ impl<'a> Parser<'a> {\n                 \"expected identifier, found enum pattern\"))\n         }\n \n-        Ok(PatIdent(binding_mode, name, sub))\n+        Ok(PatKind::Ident(binding_mode, name, sub))\n     }\n \n     /// Parse a local variable declaration"}, {"sha": "5a1a581bc430876d31d1b9c5e9d6cfd725fde085", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/14adc9bb63998d552bff351ad2184244cbc952f6/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14adc9bb63998d552bff351ad2184244cbc952f6/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=14adc9bb63998d552bff351ad2184244cbc952f6", "patch": "@@ -11,7 +11,7 @@\n pub use self::AnnNode::*;\n \n use abi::{self, Abi};\n-use ast::{self, TokenTree, BlockCheckMode};\n+use ast::{self, TokenTree, BlockCheckMode, PatKind};\n use ast::{RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n use ast::Attribute;\n use attr::ThinAttributesExt;\n@@ -2457,8 +2457,8 @@ impl<'a> State<'a> {\n         /* Pat isn't normalized, but the beauty of it\n          is that it doesn't matter */\n         match pat.node {\n-            ast::PatWild => try!(word(&mut self.s, \"_\")),\n-            ast::PatIdent(binding_mode, ref path1, ref sub) => {\n+            PatKind::Wild => try!(word(&mut self.s, \"_\")),\n+            PatKind::Ident(binding_mode, ref path1, ref sub) => {\n                 match binding_mode {\n                     ast::BindingMode::ByRef(mutbl) => {\n                         try!(self.word_nbsp(\"ref\"));\n@@ -2478,7 +2478,7 @@ impl<'a> State<'a> {\n                     None => ()\n                 }\n             }\n-            ast::PatEnum(ref path, ref args_) => {\n+            PatKind::Enum(ref path, ref args_) => {\n                 try!(self.print_path(path, true, 0));\n                 match *args_ {\n                     None => try!(word(&mut self.s, \"(..)\")),\n@@ -2492,10 +2492,10 @@ impl<'a> State<'a> {\n                     }\n                 }\n             }\n-            ast::PatQPath(ref qself, ref path) => {\n+            PatKind::QPath(ref qself, ref path) => {\n                 try!(self.print_qpath(path, qself, false));\n             }\n-            ast::PatStruct(ref path, ref fields, etc) => {\n+            PatKind::Struct(ref path, ref fields, etc) => {\n                 try!(self.print_path(path, true, 0));\n                 try!(self.nbsp());\n                 try!(self.word_space(\"{\"));\n@@ -2518,7 +2518,7 @@ impl<'a> State<'a> {\n                 try!(space(&mut self.s));\n                 try!(word(&mut self.s, \"}\"));\n             }\n-            ast::PatTup(ref elts) => {\n+            PatKind::Tup(ref elts) => {\n                 try!(self.popen());\n                 try!(self.commasep(Inconsistent,\n                                    &elts[..],\n@@ -2528,32 +2528,32 @@ impl<'a> State<'a> {\n                 }\n                 try!(self.pclose());\n             }\n-            ast::PatBox(ref inner) => {\n+            PatKind::Box(ref inner) => {\n                 try!(word(&mut self.s, \"box \"));\n                 try!(self.print_pat(&inner));\n             }\n-            ast::PatRegion(ref inner, mutbl) => {\n+            PatKind::Ref(ref inner, mutbl) => {\n                 try!(word(&mut self.s, \"&\"));\n                 if mutbl == ast::Mutability::Mutable {\n                     try!(word(&mut self.s, \"mut \"));\n                 }\n                 try!(self.print_pat(&inner));\n             }\n-            ast::PatLit(ref e) => try!(self.print_expr(&e)),\n-            ast::PatRange(ref begin, ref end) => {\n+            PatKind::Lit(ref e) => try!(self.print_expr(&**e)),\n+            PatKind::Range(ref begin, ref end) => {\n                 try!(self.print_expr(&begin));\n                 try!(space(&mut self.s));\n                 try!(word(&mut self.s, \"...\"));\n                 try!(self.print_expr(&end));\n             }\n-            ast::PatVec(ref before, ref slice, ref after) => {\n+            PatKind::Vec(ref before, ref slice, ref after) => {\n                 try!(word(&mut self.s, \"[\"));\n                 try!(self.commasep(Inconsistent,\n                                    &before[..],\n                                    |s, p| s.print_pat(&p)));\n                 if let Some(ref p) = *slice {\n                     if !before.is_empty() { try!(self.word_space(\",\")); }\n-                    if p.node != ast::PatWild {\n+                    if p.node != PatKind::Wild {\n                         try!(self.print_pat(&p));\n                     }\n                     try!(word(&mut self.s, \"..\"));\n@@ -2564,7 +2564,7 @@ impl<'a> State<'a> {\n                                    |s, p| s.print_pat(&p)));\n                 try!(word(&mut self.s, \"]\"));\n             }\n-            ast::PatMac(ref m) => try!(self.print_mac(m, token::Paren)),\n+            PatKind::Mac(ref m) => try!(self.print_mac(m, token::Paren)),\n         }\n         self.ann.post(self, NodePat(pat))\n     }\n@@ -2671,7 +2671,7 @@ impl<'a> State<'a> {\n             let m = match *explicit_self {\n                 ast::SelfKind::Static => ast::Mutability::Immutable,\n                 _ => match decl.inputs[0].pat.node {\n-                    ast::PatIdent(ast::BindingMode::ByValue(m), _, _) => m,\n+                    PatKind::Ident(ast::BindingMode::ByValue(m), _, _) => m,\n                     _ => ast::Mutability::Immutable\n                 }\n             };\n@@ -2962,7 +2962,7 @@ impl<'a> State<'a> {\n             ast::TyKind::Infer if is_closure => try!(self.print_pat(&input.pat)),\n             _ => {\n                 match input.pat.node {\n-                    ast::PatIdent(_, ref path1, _) if\n+                    PatKind::Ident(_, ref path1, _) if\n                         path1.node.name ==\n                             parse::token::special_idents::invalid.name => {\n                         // Do nothing."}, {"sha": "bd4e8b7023111ea64660862701903a5143abefe5", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/14adc9bb63998d552bff351ad2184244cbc952f6/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14adc9bb63998d552bff351ad2184244cbc952f6/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=14adc9bb63998d552bff351ad2184244cbc952f6", "patch": "@@ -419,46 +419,46 @@ pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(visitor: &mut V,\n \n pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n     match pattern.node {\n-        PatEnum(ref path, ref opt_children) => {\n+        PatKind::Enum(ref path, ref opt_children) => {\n             visitor.visit_path(path, pattern.id);\n             if let Some(ref children) = *opt_children {\n                 walk_list!(visitor, visit_pat, children);\n             }\n         }\n-        PatQPath(ref qself, ref path) => {\n+        PatKind::QPath(ref qself, ref path) => {\n             visitor.visit_ty(&qself.ty);\n             visitor.visit_path(path, pattern.id)\n         }\n-        PatStruct(ref path, ref fields, _) => {\n+        PatKind::Struct(ref path, ref fields, _) => {\n             visitor.visit_path(path, pattern.id);\n             for field in fields {\n                 visitor.visit_ident(field.span, field.node.ident);\n                 visitor.visit_pat(&field.node.pat)\n             }\n         }\n-        PatTup(ref tuple_elements) => {\n+        PatKind::Tup(ref tuple_elements) => {\n             walk_list!(visitor, visit_pat, tuple_elements);\n         }\n-        PatBox(ref subpattern) |\n-        PatRegion(ref subpattern, _) => {\n+        PatKind::Box(ref subpattern) |\n+        PatKind::Ref(ref subpattern, _) => {\n             visitor.visit_pat(subpattern)\n         }\n-        PatIdent(_, ref pth1, ref optional_subpattern) => {\n+        PatKind::Ident(_, ref pth1, ref optional_subpattern) => {\n             visitor.visit_ident(pth1.span, pth1.node);\n             walk_list!(visitor, visit_pat, optional_subpattern);\n         }\n-        PatLit(ref expression) => visitor.visit_expr(expression),\n-        PatRange(ref lower_bound, ref upper_bound) => {\n+        PatKind::Lit(ref expression) => visitor.visit_expr(expression),\n+        PatKind::Range(ref lower_bound, ref upper_bound) => {\n             visitor.visit_expr(lower_bound);\n             visitor.visit_expr(upper_bound)\n         }\n-        PatWild => (),\n-        PatVec(ref prepatterns, ref slice_pattern, ref postpatterns) => {\n+        PatKind::Wild => (),\n+        PatKind::Vec(ref prepatterns, ref slice_pattern, ref postpatterns) => {\n             walk_list!(visitor, visit_pat, prepatterns);\n             walk_list!(visitor, visit_pat, slice_pattern);\n             walk_list!(visitor, visit_pat, postpatterns);\n         }\n-        PatMac(ref mac) => visitor.visit_mac(mac),\n+        PatKind::Mac(ref mac) => visitor.visit_mac(mac),\n     }\n }\n "}, {"sha": "bdba49f2f294ba3cf927dbc86c591f1ebaa695e1", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/14adc9bb63998d552bff351ad2184244cbc952f6/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14adc9bb63998d552bff351ad2184244cbc952f6/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=14adc9bb63998d552bff351ad2184244cbc952f6", "patch": "@@ -193,7 +193,7 @@ use std::collections::HashSet;\n use std::vec;\n \n use syntax::abi::Abi;\n-use syntax::ast::{EnumDef, Expr, Ident, Generics, VariantData, BinOpKind, self};\n+use syntax::ast::{self, EnumDef, Expr, Ident, Generics, VariantData, BinOpKind, PatKind};\n use syntax::ast_util;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n@@ -1142,7 +1142,7 @@ impl<'a> MethodDef<'a> {\n                         variant,\n                         self_arg_name,\n                         ast::Mutability::Immutable);\n-                    (cx.pat(sp, ast::PatRegion(p, ast::Mutability::Immutable)), idents)\n+                    (cx.pat(sp, PatKind::Ref(p, ast::Mutability::Immutable)), idents)\n                 };\n \n                 // A single arm has form (&VariantK, &VariantK, ...) => BodyK\n@@ -1472,7 +1472,7 @@ impl<'a> TraitDef<'a> {\n                           -> Vec<P<ast::Pat>> {\n         field_paths.iter().map(|path| {\n             cx.pat(path.span,\n-                        ast::PatIdent(ast::BindingMode::ByRef(mutbl), (*path).clone(), None))\n+                        PatKind::Ident(ast::BindingMode::ByRef(mutbl), (*path).clone(), None))\n         }).collect()\n     }\n "}]}