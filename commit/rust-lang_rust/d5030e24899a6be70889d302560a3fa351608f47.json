{"sha": "d5030e24899a6be70889d302560a3fa351608f47", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1MDMwZTI0ODk5YTZiZTcwODg5ZDMwMjU2MGEzZmEzNTE2MDhmNDc=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-04-13T22:23:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-04-13T22:23:27Z"}, "message": "Rollup merge of #59708 - matthewjasper:double-closure-unused-mut, r=pnkfelix\n\nMark variables captured by reference as mutable correctly\n\nCloses #59620\n\nr? @pnkfelix", "tree": {"sha": "6fd388ffc8463bbd38068b1bab10a5e6d6b03979", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6fd388ffc8463bbd38068b1bab10a5e6d6b03979"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5030e24899a6be70889d302560a3fa351608f47", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcsmFfCRBK7hj4Ov3rIwAAdHIIABJamv7zsC5+qiDEHfiVjpcA\n8EKO7gAM3cD15NuPCeDN3zDQqBo65mzJK+SQa0jMFHGF48WV+Ebj+7ojQvyCY6sM\nM+47Xb+QHDv9J0rvUh9F8CrXGhKRbHoQD0nKQaUmaGKXnD512cAw1A5Z5fDMs0I7\n48LU7Em9kjytD7/QngQYQ9WuIHhdW9LPlFk2d40QN7alS073vtIOVXXK4KbPoAfD\nAuJOfaZ4Y1xUASv7VrcKPlvj9xRLoWNW9U/0M4kadhshvuZdgT7+aGeSi0UIHrje\n7uZBa9GuD5OfFlaMEUpKe228qcqrIcaEcPjRfsmXxCw+vdEnLG7D8EZ7GBfyL/g=\n=cj+6\n-----END PGP SIGNATURE-----\n", "payload": "tree 6fd388ffc8463bbd38068b1bab10a5e6d6b03979\nparent bdb264ff5f4ecb39e5c8babf594d355bc4795afc\nparent 968ea1ce32ac894a7d58702c409233638aa5592d\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1555194207 +0200\ncommitter GitHub <noreply@github.com> 1555194207 +0200\n\nRollup merge of #59708 - matthewjasper:double-closure-unused-mut, r=pnkfelix\n\nMark variables captured by reference as mutable correctly\n\nCloses #59620\n\nr? @pnkfelix\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5030e24899a6be70889d302560a3fa351608f47", "html_url": "https://github.com/rust-lang/rust/commit/d5030e24899a6be70889d302560a3fa351608f47", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5030e24899a6be70889d302560a3fa351608f47/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bdb264ff5f4ecb39e5c8babf594d355bc4795afc", "url": "https://api.github.com/repos/rust-lang/rust/commits/bdb264ff5f4ecb39e5c8babf594d355bc4795afc", "html_url": "https://github.com/rust-lang/rust/commit/bdb264ff5f4ecb39e5c8babf594d355bc4795afc"}, {"sha": "968ea1ce32ac894a7d58702c409233638aa5592d", "url": "https://api.github.com/repos/rust-lang/rust/commits/968ea1ce32ac894a7d58702c409233638aa5592d", "html_url": "https://github.com/rust-lang/rust/commit/968ea1ce32ac894a7d58702c409233638aa5592d"}], "stats": {"total": 115, "additions": 87, "deletions": 28}, "files": [{"sha": "0b2c90b9160453993facdef22bd0a23c67daa097", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 76, "deletions": 20, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/d5030e24899a6be70889d302560a3fa351608f47/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5030e24899a6be70889d302560a3fa351608f47/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=d5030e24899a6be70889d302560a3fa351608f47", "patch": "@@ -30,7 +30,7 @@ use std::rc::Rc;\n use syntax_pos::{Span, DUMMY_SP};\n \n use crate::dataflow::indexes::{BorrowIndex, InitIndex, MoveOutIndex, MovePathIndex};\n-use crate::dataflow::move_paths::{HasMoveData, LookupResult, MoveData, MoveError};\n+use crate::dataflow::move_paths::{HasMoveData, InitLocation, LookupResult, MoveData, MoveError};\n use crate::dataflow::Borrows;\n use crate::dataflow::DataflowResultsConsumer;\n use crate::dataflow::FlowAtLocation;\n@@ -1277,25 +1277,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         } = self.infcx.tcx.mir_borrowck(def_id);\n                         debug!(\"{:?} used_mut_upvars={:?}\", def_id, used_mut_upvars);\n                         for field in used_mut_upvars {\n-                            // This relies on the current way that by-value\n-                            // captures of a closure are copied/moved directly\n-                            // when generating MIR.\n-                            match operands[field.index()] {\n-                                Operand::Move(Place::Base(PlaceBase::Local(local)))\n-                                | Operand::Copy(Place::Base(PlaceBase::Local(local))) => {\n-                                    self.used_mut.insert(local);\n-                                }\n-                                Operand::Move(ref place @ Place::Projection(_))\n-                                | Operand::Copy(ref place @ Place::Projection(_)) => {\n-                                    if let Some(field) = place.is_upvar_field_projection(\n-                                            self.mir, &self.infcx.tcx) {\n-                                        self.used_mut_upvars.push(field);\n-                                    }\n-                                }\n-                                Operand::Move(Place::Base(PlaceBase::Static(..)))\n-                                | Operand::Copy(Place::Base(PlaceBase::Static(..)))\n-                                | Operand::Constant(..) => {}\n-                            }\n+                            self.propagate_closure_used_mut_upvar(&operands[field.index()]);\n                         }\n                     }\n                     AggregateKind::Adt(..)\n@@ -1310,6 +1292,80 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn propagate_closure_used_mut_upvar(&mut self, operand: &Operand<'tcx>) {\n+        let propagate_closure_used_mut_place = |this: &mut Self, place: &Place<'tcx>| {\n+            match *place {\n+                Place::Projection { .. } => {\n+                    if let Some(field) = place.is_upvar_field_projection(\n+                            this.mir, &this.infcx.tcx) {\n+                        this.used_mut_upvars.push(field);\n+                    }\n+                }\n+                Place::Base(PlaceBase::Local(local)) => {\n+                    this.used_mut.insert(local);\n+                }\n+                Place::Base(PlaceBase::Static(_)) => {}\n+            }\n+        };\n+\n+        // This relies on the current way that by-value\n+        // captures of a closure are copied/moved directly\n+        // when generating MIR.\n+        match *operand {\n+            Operand::Move(Place::Base(PlaceBase::Local(local)))\n+            | Operand::Copy(Place::Base(PlaceBase::Local(local)))\n+                if self.mir.local_decls[local].is_user_variable.is_none() =>\n+            {\n+                if self.mir.local_decls[local].ty.is_mutable_pointer() {\n+                    // The variable will be marked as mutable by the borrow.\n+                    return;\n+                }\n+                // This is an edge case where we have a `move` closure\n+                // inside a non-move closure, and the inner closure\n+                // contains a mutation:\n+                //\n+                // let mut i = 0;\n+                // || { move || { i += 1; }; };\n+                //\n+                // In this case our usual strategy of assuming that the\n+                // variable will be captured by mutable reference is\n+                // wrong, since `i` can be copied into the inner\n+                // closure from a shared reference.\n+                //\n+                // As such we have to search for the local that this\n+                // capture comes from and mark it as being used as mut.\n+\n+                let temp_mpi = self.move_data.rev_lookup.find_local(local);\n+                let init = if let [init_index] = *self.move_data.init_path_map[temp_mpi] {\n+                    &self.move_data.inits[init_index]\n+                } else {\n+                    bug!(\"temporary should be initialized exactly once\")\n+                };\n+\n+                let loc = match init.location {\n+                    InitLocation::Statement(stmt) => stmt,\n+                    _ => bug!(\"temporary initialized in arguments\"),\n+                };\n+\n+                let bbd = &self.mir[loc.block];\n+                let stmt = &bbd.statements[loc.statement_index];\n+                debug!(\"temporary assigned in: stmt={:?}\", stmt);\n+\n+                if let StatementKind::Assign(_, box Rvalue::Ref(_, _, ref source)) = stmt.kind {\n+                    propagate_closure_used_mut_place(self, source);\n+                } else {\n+                    bug!(\"closures should only capture user variables \\\n+                        or references to user variables\");\n+                }\n+            }\n+            Operand::Move(ref place)\n+            | Operand::Copy(ref place) => {\n+                propagate_closure_used_mut_place(self, place);\n+            }\n+            Operand::Constant(..) => {}\n+        }\n+    }\n+\n     fn consume_operand(\n         &mut self,\n         context: Context,"}, {"sha": "6d0d6e16a677588fc15e8c568fa32a5bf2ab083b", "filename": "src/test/ui/nll/extra-unused-mut.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d5030e24899a6be70889d302560a3fa351608f47/src%2Ftest%2Fui%2Fnll%2Fextra-unused-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5030e24899a6be70889d302560a3fa351608f47/src%2Ftest%2Fui%2Fnll%2Fextra-unused-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fextra-unused-mut.rs?ref=d5030e24899a6be70889d302560a3fa351608f47", "patch": "@@ -1,6 +1,6 @@\n // extra unused mut lint tests for #51918\n \n-// run-pass\n+// compile-pass\n \n #![feature(generators, nll)]\n #![deny(unused_mut)]\n@@ -53,11 +53,14 @@ fn if_guard(x: Result<i32, i32>) {\n     }\n }\n \n-fn main() {\n-    ref_argument(0);\n-    mutable_upvar();\n-    generator_mutable_upvar();\n-    ref_closure_argument();\n-    parse_dot_or_call_expr_with(Vec::new());\n-    if_guard(Ok(0));\n+// #59620\n+fn nested_closures() {\n+    let mut i = 0;\n+    [].iter().for_each(|_: &i32| {\n+        [].iter().for_each(move |_: &i32| {\n+            i += 1;\n+        });\n+    });\n }\n+\n+fn main() {}"}]}