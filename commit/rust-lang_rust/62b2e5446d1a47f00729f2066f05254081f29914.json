{"sha": "62b2e5446d1a47f00729f2066f05254081f29914", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyYjJlNTQ0NmQxYTQ3ZjAwNzI5ZjIwNjZmMDUyNTQwODFmMjk5MTQ=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-07-11T23:02:06Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-07-11T23:38:16Z"}, "message": "Refactor: {Lvalue,Rvalue,Operand}::ty only need the locals' types, not the full &Mir", "tree": {"sha": "f159400f022e0190ce3c74e4b1c005fb78222002", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f159400f022e0190ce3c74e4b1c005fb78222002"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62b2e5446d1a47f00729f2066f05254081f29914", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62b2e5446d1a47f00729f2066f05254081f29914", "html_url": "https://github.com/rust-lang/rust/commit/62b2e5446d1a47f00729f2066f05254081f29914", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62b2e5446d1a47f00729f2066f05254081f29914/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9475ae477a4d42c564eab9621ffb6aa7c160a3dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/9475ae477a4d42c564eab9621ffb6aa7c160a3dc", "html_url": "https://github.com/rust-lang/rust/commit/9475ae477a4d42c564eab9621ffb6aa7c160a3dc"}], "stats": {"total": 141, "additions": 72, "deletions": 69}, "files": [{"sha": "8ac4e1208b0cb543344b933038cb098375a06dbd", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/62b2e5446d1a47f00729f2066f05254081f29914/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62b2e5446d1a47f00729f2066f05254081f29914/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=62b2e5446d1a47f00729f2066f05254081f29914", "patch": "@@ -66,6 +66,9 @@ macro_rules! newtype_index {\n     )\n }\n \n+/// Types for locals\n+type LocalDecls<'tcx> = IndexVec<Local, LocalDecl<'tcx>>;\n+\n /// Lowered representation of a single function.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Mir<'tcx> {\n@@ -90,7 +93,7 @@ pub struct Mir<'tcx> {\n     /// The first local is the return value pointer, followed by `arg_count`\n     /// locals for the function arguments, followed by any user-declared\n     /// variables and temporaries.\n-    pub local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n+    pub local_decls: LocalDecls<'tcx>,\n \n     /// Number of arguments this function takes.\n     ///"}, {"sha": "b99c0180eccfdc29cc8c9202d36a5755e70e5cf9", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/62b2e5446d1a47f00729f2066f05254081f29914/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62b2e5446d1a47f00729f2066f05254081f29914/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=62b2e5446d1a47f00729f2066f05254081f29914", "patch": "@@ -121,31 +121,31 @@ impl<'tcx> TypeFoldable<'tcx> for LvalueTy<'tcx> {\n }\n \n impl<'tcx> Lvalue<'tcx> {\n-    pub fn ty<'a, 'gcx>(&self, mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> LvalueTy<'tcx> {\n+    pub fn ty<'a, 'gcx>(&self, local_decls: &LocalDecls<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> LvalueTy<'tcx> {\n         match *self {\n             Lvalue::Local(index) =>\n-                LvalueTy::Ty { ty: mir.local_decls[index].ty },\n+                LvalueTy::Ty { ty: local_decls[index].ty },\n             Lvalue::Static(ref data) =>\n                 LvalueTy::Ty { ty: data.ty },\n             Lvalue::Projection(ref proj) =>\n-                proj.base.ty(mir, tcx).projection_ty(tcx, &proj.elem),\n+                proj.base.ty(local_decls, tcx).projection_ty(tcx, &proj.elem),\n         }\n     }\n }\n \n impl<'tcx> Rvalue<'tcx> {\n-    pub fn ty<'a, 'gcx>(&self, mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx>\n+    pub fn ty<'a, 'gcx>(&self, local_decls: &LocalDecls<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx>\n     {\n         match *self {\n-            Rvalue::Use(ref operand) => operand.ty(mir, tcx),\n+            Rvalue::Use(ref operand) => operand.ty(local_decls, tcx),\n             Rvalue::Repeat(ref operand, ref count) => {\n-                let op_ty = operand.ty(mir, tcx);\n+                let op_ty = operand.ty(local_decls, tcx);\n                 let count = count.as_u64(tcx.sess.target.uint_type);\n                 assert_eq!(count as usize as u64, count);\n                 tcx.mk_array(op_ty, count as usize)\n             }\n             Rvalue::Ref(reg, bk, ref lv) => {\n-                let lv_ty = lv.ty(mir, tcx).to_ty(tcx);\n+                let lv_ty = lv.ty(local_decls, tcx).to_ty(tcx);\n                 tcx.mk_ref(reg,\n                     ty::TypeAndMut {\n                         ty: lv_ty,\n@@ -156,22 +156,22 @@ impl<'tcx> Rvalue<'tcx> {\n             Rvalue::Len(..) => tcx.types.usize,\n             Rvalue::Cast(.., ty) => ty,\n             Rvalue::BinaryOp(op, ref lhs, ref rhs) => {\n-                let lhs_ty = lhs.ty(mir, tcx);\n-                let rhs_ty = rhs.ty(mir, tcx);\n+                let lhs_ty = lhs.ty(local_decls, tcx);\n+                let rhs_ty = rhs.ty(local_decls, tcx);\n                 op.ty(tcx, lhs_ty, rhs_ty)\n             }\n             Rvalue::CheckedBinaryOp(op, ref lhs, ref rhs) => {\n-                let lhs_ty = lhs.ty(mir, tcx);\n-                let rhs_ty = rhs.ty(mir, tcx);\n+                let lhs_ty = lhs.ty(local_decls, tcx);\n+                let rhs_ty = rhs.ty(local_decls, tcx);\n                 let ty = op.ty(tcx, lhs_ty, rhs_ty);\n                 tcx.intern_tup(&[ty, tcx.types.bool], false)\n             }\n             Rvalue::UnaryOp(UnOp::Not, ref operand) |\n             Rvalue::UnaryOp(UnOp::Neg, ref operand) => {\n-                operand.ty(mir, tcx)\n+                operand.ty(local_decls, tcx)\n             }\n             Rvalue::Discriminant(ref lval) => {\n-                let ty = lval.ty(mir, tcx).to_ty(tcx);\n+                let ty = lval.ty(local_decls, tcx).to_ty(tcx);\n                 if let ty::TyAdt(adt_def, _) = ty.sty {\n                     adt_def.repr.discr_type().to_ty(tcx)\n                 } else {\n@@ -189,7 +189,7 @@ impl<'tcx> Rvalue<'tcx> {\n                     }\n                     AggregateKind::Tuple => {\n                         tcx.mk_tup(\n-                            ops.iter().map(|op| op.ty(mir, tcx)),\n+                            ops.iter().map(|op| op.ty(local_decls, tcx)),\n                             false\n                         )\n                     }\n@@ -206,9 +206,9 @@ impl<'tcx> Rvalue<'tcx> {\n }\n \n impl<'tcx> Operand<'tcx> {\n-    pub fn ty<'a, 'gcx>(&self, mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n+    pub fn ty<'a, 'gcx>(&self, local_decls: &LocalDecls<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n         match self {\n-            &Operand::Consume(ref l) => l.ty(mir, tcx).to_ty(tcx),\n+            &Operand::Consume(ref l) => l.ty(local_decls, tcx).to_ty(tcx),\n             &Operand::Constant(ref c) => c.ty,\n         }\n     }"}, {"sha": "a247cd774501e6599fcadb1a660b5f97db440d7d", "filename": "src/librustc_mir/dataflow/drop_flag_effects.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/62b2e5446d1a47f00729f2066f05254081f29914/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62b2e5446d1a47f00729f2066f05254081f29914/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs?ref=62b2e5446d1a47f00729f2066f05254081f29914", "patch": "@@ -129,7 +129,7 @@ pub fn move_path_children_matching<'tcx, F>(move_data: &MoveData<'tcx>,\n fn lvalue_contents_drop_state_cannot_differ<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                       mir: &Mir<'tcx>,\n                                                       lv: &mir::Lvalue<'tcx>) -> bool {\n-    let ty = lv.ty(mir, tcx).to_ty(tcx);\n+    let ty = lv.ty(&mir.local_decls, tcx).to_ty(tcx);\n     match ty.sty {\n         ty::TyArray(..) | ty::TySlice(..) | ty::TyRef(..) | ty::TyRawPtr(..) => {\n             debug!(\"lvalue_contents_drop_state_cannot_differ lv: {:?} ty: {:?} refd => true\",\n@@ -216,7 +216,7 @@ pub(crate) fn on_all_drop_children_bits<'a, 'tcx, F>(\n {\n     on_all_children_bits(tcx, mir, &ctxt.move_data, path, |child| {\n         let lvalue = &ctxt.move_data.move_paths[path].lvalue;\n-        let ty = lvalue.ty(mir, tcx).to_ty(tcx);\n+        let ty = lvalue.ty(&mir.local_decls, tcx).to_ty(tcx);\n         debug!(\"on_all_drop_children_bits({:?}, {:?} : {:?})\", path, lvalue, ty);\n \n         if ty.needs_drop(tcx, ctxt.param_env) {\n@@ -263,7 +263,7 @@ pub(crate) fn drop_flag_effects_for_location<'a, 'tcx, F>(\n \n         // don't move out of non-Copy things\n         let lvalue = &move_data.move_paths[path].lvalue;\n-        let ty = lvalue.ty(mir, tcx).to_ty(tcx);\n+        let ty = lvalue.ty(&mir.local_decls, tcx).to_ty(tcx);\n         if !ty.moves_by_default(tcx, param_env, DUMMY_SP) {\n             continue;\n         }"}, {"sha": "e92ece7505f6dfa67114388f80c1ceb21674b073", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62b2e5446d1a47f00729f2066f05254081f29914/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62b2e5446d1a47f00729f2066f05254081f29914/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=62b2e5446d1a47f00729f2066f05254081f29914", "patch": "@@ -286,7 +286,7 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n                                 -> Result<MovePathIndex, MovePathError>\n     {\n         let base = try!(self.move_path_for(&proj.base));\n-        let lv_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+        let lv_ty = proj.base.ty(&self.mir.local_decls, self.tcx).to_ty(self.tcx);\n         match lv_ty.sty {\n             // error: can't move out of borrowed content\n             ty::TyRef(..) | ty::TyRawPtr(..) => return Err(MovePathError::IllegalMove),\n@@ -504,7 +504,7 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n     fn gather_move(&mut self, loc: Location, lval: &Lvalue<'tcx>) {\n         debug!(\"gather_move({:?}, {:?})\", loc, lval);\n \n-        let lv_ty = lval.ty(self.mir, self.tcx).to_ty(self.tcx);\n+        let lv_ty = lval.ty(&self.mir.local_decls, self.tcx).to_ty(self.tcx);\n         if !lv_ty.moves_by_default(self.tcx, self.param_env, DUMMY_SP) {\n             debug!(\"gather_move({:?}, {:?}) - {:?} is Copy. skipping\", loc, lval, lv_ty);\n             return"}, {"sha": "db951a7fef8c12a61a76b60e829be5c1457e275b", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/62b2e5446d1a47f00729f2066f05254081f29914/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62b2e5446d1a47f00729f2066f05254081f29914/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=62b2e5446d1a47f00729f2066f05254081f29914", "patch": "@@ -250,7 +250,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                     work_list.push(target);\n                     // If the location doesn't actually need dropping, treat it like\n                     // a regular goto.\n-                    let ty = location.ty(&callee_mir, tcx).subst(tcx, callsite.substs);\n+                    let ty = location.ty(&callee_mir.local_decls, tcx).subst(tcx, callsite.substs);\n                     let ty = ty.to_ty(tcx);\n                     if ty.needs_drop(tcx, param_env) {\n                         cost += CALL_PENALTY;\n@@ -390,7 +390,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                         BorrowKind::Mut,\n                         destination.0);\n \n-                    let ty = dest.ty(caller_mir, self.tcx);\n+                    let ty = dest.ty(&caller_mir.local_decls, self.tcx);\n \n                     let temp = LocalDecl::new_temp(ty, callsite.location.span);\n \n@@ -422,7 +422,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                         bug!(\"Constant arg to \\\"box_free\\\"\");\n                     };\n \n-                    let ptr_ty = args[0].ty(caller_mir, self.tcx);\n+                    let ptr_ty = args[0].ty(&caller_mir.local_decls, self.tcx);\n                     vec![self.cast_box_free_arg(arg, ptr_ty, &callsite, caller_mir)]\n                 } else {\n                     // Copy the arguments if needed.\n@@ -475,7 +475,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n             BorrowKind::Mut,\n             arg.deref());\n \n-        let ty = arg.ty(caller_mir, self.tcx);\n+        let ty = arg.ty(&caller_mir.local_decls, self.tcx);\n         let ref_tmp = LocalDecl::new_temp(ty, callsite.location.span);\n         let ref_tmp = caller_mir.local_decls.push(ref_tmp);\n         let ref_tmp = Lvalue::Local(ref_tmp);\n@@ -529,7 +529,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n             // Otherwise, create a temporary for the arg\n             let arg = Rvalue::Use(a);\n \n-            let ty = arg.ty(caller_mir, tcx);\n+            let ty = arg.ty(&caller_mir.local_decls, tcx);\n \n             let arg_tmp = LocalDecl::new_temp(ty, callsite.location.span);\n             let arg_tmp = caller_mir.local_decls.push(arg_tmp);"}, {"sha": "65d20d3be876888d0c74bce8ed667909c89e9c41", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62b2e5446d1a47f00729f2066f05254081f29914/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62b2e5446d1a47f00729f2066f05254081f29914/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=62b2e5446d1a47f00729f2066f05254081f29914", "patch": "@@ -87,7 +87,7 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for OptimizationFinder<'b, 'a, 'tcx> {\n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n         if let Rvalue::Ref(_, _, Lvalue::Projection(ref projection)) = *rvalue {\n             if let ProjectionElem::Deref = projection.elem {\n-                if projection.base.ty(self.mir, self.tcx).to_ty(self.tcx).is_region_ptr() {\n+                if projection.base.ty(&self.mir.local_decls, self.tcx).to_ty(self.tcx).is_region_ptr() {\n                     self.optimizations.and_stars.insert(location);\n                 }\n             }"}, {"sha": "8cb6c0b055e7f8a361ff9650e0479fe272e27f6b", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62b2e5446d1a47f00729f2066f05254081f29914/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62b2e5446d1a47f00729f2066f05254081f29914/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=62b2e5446d1a47f00729f2066f05254081f29914", "patch": "@@ -362,13 +362,13 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n                         continue;\n                     }\n                 }\n-                (statement.source_info.span, dest.ty(mir, tcx).to_ty(tcx))\n+                (statement.source_info.span, dest.ty(&mir.local_decls, tcx).to_ty(tcx))\n             }\n             Candidate::ShuffleIndices(bb) => {\n                 let terminator = mir[bb].terminator();\n                 let ty = match terminator.kind {\n                     TerminatorKind::Call { ref args, .. } => {\n-                        args[2].ty(mir, tcx)\n+                        args[2].ty(&mir.local_decls, tcx)\n                     }\n                     _ => {\n                         span_bug!(terminator.source_info.span,"}, {"sha": "3180133b05a5166894c288c5c285535e47f1458f", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/62b2e5446d1a47f00729f2066f05254081f29914/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62b2e5446d1a47f00729f2066f05254081f29914/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=62b2e5446d1a47f00729f2066f05254081f29914", "patch": "@@ -507,7 +507,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                                 this.add(Qualif::STATIC);\n                             }\n \n-                            let base_ty = proj.base.ty(this.mir, this.tcx).to_ty(this.tcx);\n+                            let base_ty = proj.base.ty(&this.mir.local_decls, this.tcx).to_ty(this.tcx);\n                             if let ty::TyRawPtr(_) = base_ty.sty {\n                                 this.add(Qualif::NOT_CONST);\n                                 if this.mode != Mode::Fn {\n@@ -530,7 +530,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                                           \"cannot refer to the interior of another \\\n                                            static, use a constant instead\");\n                             }\n-                            let ty = lvalue.ty(this.mir, this.tcx).to_ty(this.tcx);\n+                            let ty = lvalue.ty(&this.mir.local_decls, this.tcx).to_ty(this.tcx);\n                             this.qualif.restrict(ty, this.tcx, this.param_env);\n                         }\n \n@@ -606,7 +606,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     self.add(Qualif::STATIC_REF);\n                 }\n \n-                let ty = lvalue.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                let ty = lvalue.ty(&self.mir.local_decls, self.tcx).to_ty(self.tcx);\n                 if kind == BorrowKind::Mut {\n                     // In theory, any zero-sized value could be borrowed\n                     // mutably without consequences. However, only &mut []\n@@ -671,7 +671,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n             }\n \n             Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) => {\n-                let operand_ty = operand.ty(self.mir, self.tcx);\n+                let operand_ty = operand.ty(&self.mir.local_decls, self.tcx);\n                 let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n                 let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n                 match (cast_in, cast_out) {\n@@ -689,7 +689,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n             }\n \n             Rvalue::BinaryOp(op, ref lhs, _) => {\n-                if let ty::TyRawPtr(_) = lhs.ty(self.mir, self.tcx).sty {\n+                if let ty::TyRawPtr(_) = lhs.ty(&self.mir.local_decls, self.tcx).sty {\n                     assert!(op == BinOp::Eq || op == BinOp::Ne ||\n                             op == BinOp::Le || op == BinOp::Lt ||\n                             op == BinOp::Ge || op == BinOp::Gt ||\n@@ -727,7 +727,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     }\n \n                     if Some(def.did) == self.tcx.lang_items.unsafe_cell_type() {\n-                        let ty = rvalue.ty(self.mir, self.tcx);\n+                        let ty = rvalue.ty(&self.mir.local_decls, self.tcx);\n                         self.add_type(ty);\n                         assert!(self.qualif.intersects(Qualif::MUTABLE_INTERIOR));\n                         // Even if the value inside may not need dropping,\n@@ -748,7 +748,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n         if let TerminatorKind::Call { ref func, ref args, ref destination, .. } = *kind {\n             self.visit_operand(func, location);\n \n-            let fn_ty = func.ty(self.mir, self.tcx);\n+            let fn_ty = func.ty(&self.mir.local_decls, self.tcx);\n             let (is_shuffle, is_const_fn) = match fn_ty.sty {\n                 ty::TyFnDef(def_id, _) => {\n                     (self.tcx.fn_sig(def_id).abi() == Abi::PlatformIntrinsic &&\n@@ -828,7 +828,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 } else {\n                     // Be conservative about the returned value of a const fn.\n                     let tcx = self.tcx;\n-                    let ty = dest.ty(self.mir, tcx).to_ty(tcx);\n+                    let ty = dest.ty(&self.mir.local_decls, tcx).to_ty(tcx);\n                     self.qualif = Qualif::empty();\n                     self.add_type(ty);\n "}, {"sha": "1175f955b4ed0d9089ca1457ac71b65d5af0a12c", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/62b2e5446d1a47f00729f2066f05254081f29914/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62b2e5446d1a47f00729f2066f05254081f29914/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=62b2e5446d1a47f00729f2066f05254081f29914", "patch": "@@ -84,7 +84,7 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n \n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n         self.super_rvalue(rvalue, location);\n-        let rval_ty = rvalue.ty(self.mir, self.tcx());\n+        let rval_ty = rvalue.ty(&self.mir.local_decls, self.tcx());\n         self.sanitize_type(rvalue, rval_ty);\n     }\n \n@@ -178,7 +178,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             }\n             ProjectionElem::Index(ref i) => {\n                 self.visit_operand(i, location);\n-                let index_ty = i.ty(self.mir, tcx);\n+                let index_ty = i.ty(&self.mir.local_decls, tcx);\n                 if index_ty != tcx.types.usize {\n                     LvalueTy::Ty {\n                         ty: span_mirbug_and_err!(self, i, \"index by non-usize {:?}\", i)\n@@ -378,15 +378,15 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         let tcx = self.tcx();\n         match stmt.kind {\n             StatementKind::Assign(ref lv, ref rv) => {\n-                let lv_ty = lv.ty(mir, tcx).to_ty(tcx);\n-                let rv_ty = rv.ty(mir, tcx);\n+                let lv_ty = lv.ty(&mir.local_decls, tcx).to_ty(tcx);\n+                let rv_ty = rv.ty(&mir.local_decls, tcx);\n                 if let Err(terr) = self.sub_types(rv_ty, lv_ty) {\n                     span_mirbug!(self, stmt, \"bad assignment ({:?} = {:?}): {:?}\",\n                                  lv_ty, rv_ty, terr);\n                 }\n             }\n             StatementKind::SetDiscriminant{ ref lvalue, variant_index } => {\n-                let lvalue_type = lvalue.ty(mir, tcx).to_ty(tcx);\n+                let lvalue_type = lvalue.ty(&mir.local_decls, tcx).to_ty(tcx);\n                 let adt = match lvalue_type.sty {\n                     TypeVariants::TyAdt(adt, _) if adt.is_enum() => adt,\n                     _ => {\n@@ -438,15 +438,15 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 ref value,\n                 ..\n             } => {\n-                let lv_ty = location.ty(mir, tcx).to_ty(tcx);\n-                let rv_ty = value.ty(mir, tcx);\n+                let lv_ty = location.ty(&mir.local_decls, tcx).to_ty(tcx);\n+                let rv_ty = value.ty(&mir.local_decls, tcx);\n                 if let Err(terr) = self.sub_types(rv_ty, lv_ty) {\n                     span_mirbug!(self, term, \"bad DropAndReplace ({:?} = {:?}): {:?}\",\n                                  lv_ty, rv_ty, terr);\n                 }\n             }\n             TerminatorKind::SwitchInt { ref discr, switch_ty, .. } => {\n-                let discr_ty = discr.ty(mir, tcx);\n+                let discr_ty = discr.ty(&mir.local_decls, tcx);\n                 if let Err(terr) = self.sub_types(discr_ty, switch_ty) {\n                     span_mirbug!(self, term, \"bad SwitchInt ({:?} on {:?}): {:?}\",\n                                  switch_ty, discr_ty, terr);\n@@ -459,7 +459,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 // FIXME: check the values\n             }\n             TerminatorKind::Call { ref func, ref args, ref destination, .. } => {\n-                let func_ty = func.ty(mir, tcx);\n+                let func_ty = func.ty(&mir.local_decls, tcx);\n                 debug!(\"check_terminator: call, func_ty={:?}\", func_ty);\n                 let sig = match func_ty.sty {\n                     ty::TyFnDef(..) | ty::TyFnPtr(_) => func_ty.fn_sig(tcx),\n@@ -479,16 +479,16 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 }\n             }\n             TerminatorKind::Assert { ref cond, ref msg, .. } => {\n-                let cond_ty = cond.ty(mir, tcx);\n+                let cond_ty = cond.ty(&mir.local_decls, tcx);\n                 if cond_ty != tcx.types.bool {\n                     span_mirbug!(self, term, \"bad Assert ({:?}, not bool\", cond_ty);\n                 }\n \n                 if let AssertMessage::BoundsCheck { ref len, ref index } = *msg {\n-                    if len.ty(mir, tcx) != tcx.types.usize {\n+                    if len.ty(&mir.local_decls, tcx) != tcx.types.usize {\n                         span_mirbug!(self, len, \"bounds-check length non-usize {:?}\", len)\n                     }\n-                    if index.ty(mir, tcx) != tcx.types.usize {\n+                    if index.ty(&mir.local_decls, tcx) != tcx.types.usize {\n                         span_mirbug!(self, index, \"bounds-check index non-usize {:?}\", index)\n                     }\n                 }\n@@ -504,7 +504,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         let tcx = self.tcx();\n         match *destination {\n             Some((ref dest, _)) => {\n-                let dest_ty = dest.ty(mir, tcx).to_ty(tcx);\n+                let dest_ty = dest.ty(&mir.local_decls, tcx).to_ty(tcx);\n                 if let Err(terr) = self.sub_types(sig.output(), dest_ty) {\n                     span_mirbug!(self, term,\n                                  \"call dest mismatch ({:?} <- {:?}): {:?}\",\n@@ -532,7 +532,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             span_mirbug!(self, term, \"call to {:?} with wrong # of args\", sig);\n         }\n         for (n, (fn_arg, op_arg)) in sig.inputs().iter().zip(args).enumerate() {\n-            let op_arg_ty = op_arg.ty(mir, self.tcx());\n+            let op_arg_ty = op_arg.ty(&mir.local_decls, self.tcx());\n             if let Err(terr) = self.sub_types(op_arg_ty, fn_arg) {\n                 span_mirbug!(self, term, \"bad arg #{:?} ({:?} <- {:?}): {:?}\",\n                              n, fn_arg, op_arg_ty, terr);\n@@ -581,7 +581,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             return;\n         }\n \n-        let ty = args[0].ty(mir, self.tcx());\n+        let ty = args[0].ty(&mir.local_decls, self.tcx());\n         let arg_ty = match ty.sty {\n             ty::TyRawPtr(mt) => mt.ty,\n             ty::TyAdt(def, _) if def.is_box() => ty.boxed_ty(),"}, {"sha": "efeffbbe7d14095e64d59e0387eb256c1294fca3", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62b2e5446d1a47f00729f2066f05254081f29914/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62b2e5446d1a47f00729f2066f05254081f29914/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=62b2e5446d1a47f00729f2066f05254081f29914", "patch": "@@ -130,7 +130,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     where D: DropElaborator<'b, 'tcx>\n {\n     fn lvalue_ty(&self, lvalue: &Lvalue<'tcx>) -> Ty<'tcx> {\n-        lvalue.ty(self.elaborator.mir(), self.tcx()).to_ty(self.tcx())\n+        lvalue.ty(&self.elaborator.mir().local_decls, self.tcx()).to_ty(self.tcx())\n     }\n \n     fn tcx(&self) -> ty::TyCtxt<'b, 'tcx, 'tcx> {"}, {"sha": "4eb7efc593d8ef10758960900a89f4545981ac37", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/62b2e5446d1a47f00729f2066f05254081f29914/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62b2e5446d1a47f00729f2066f05254081f29914/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=62b2e5446d1a47f00729f2066f05254081f29914", "patch": "@@ -474,7 +474,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             mir::Rvalue::Cast(mir::CastKind::Unsize, ref operand, target_ty) => {\n                 let target_ty = self.scx.tcx().trans_apply_param_substs(self.param_substs,\n                                                                         &target_ty);\n-                let source_ty = operand.ty(self.mir, self.scx.tcx());\n+                let source_ty = operand.ty(&self.mir.local_decls, self.scx.tcx());\n                 let source_ty = self.scx.tcx().trans_apply_param_substs(self.param_substs,\n                                                                         &source_ty);\n                 let (source_ty, target_ty) = find_vtable_types_for_unsizing(self.scx,\n@@ -491,13 +491,13 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                 }\n             }\n             mir::Rvalue::Cast(mir::CastKind::ReifyFnPointer, ref operand, _) => {\n-                let fn_ty = operand.ty(self.mir, self.scx.tcx());\n+                let fn_ty = operand.ty(&self.mir.local_decls, self.scx.tcx());\n                 let fn_ty = self.scx.tcx().trans_apply_param_substs(self.param_substs,\n                                                                     &fn_ty);\n                 visit_fn_use(self.scx, fn_ty, false, &mut self.output);\n             }\n             mir::Rvalue::Cast(mir::CastKind::ClosureFnPointer, ref operand, _) => {\n-                let source_ty = operand.ty(self.mir, self.scx.tcx());\n+                let source_ty = operand.ty(&self.mir.local_decls, self.scx.tcx());\n                 let source_ty = self.scx.tcx().trans_apply_param_substs(self.param_substs,\n                                                                         &source_ty);\n                 match source_ty.sty {\n@@ -555,13 +555,13 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         let tcx = self.scx.tcx();\n         match *kind {\n             mir::TerminatorKind::Call { ref func, .. } => {\n-                let callee_ty = func.ty(self.mir, tcx);\n+                let callee_ty = func.ty(&self.mir.local_decls, tcx);\n                 let callee_ty = tcx.trans_apply_param_substs(self.param_substs, &callee_ty);\n                 visit_fn_use(self.scx, callee_ty, true, &mut self.output);\n             }\n             mir::TerminatorKind::Drop { ref location, .. } |\n             mir::TerminatorKind::DropAndReplace { ref location, .. } => {\n-                let ty = location.ty(self.mir, self.scx.tcx())\n+                let ty = location.ty(&self.mir.local_decls, self.scx.tcx())\n                     .to_ty(self.scx.tcx());\n                 let ty = tcx.trans_apply_param_substs(self.param_substs, &ty);\n                 visit_drop_use(self.scx, ty, true, self.output);"}, {"sha": "5c9f6f3b2976d192cf194fc72947131d8caf81b9", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62b2e5446d1a47f00729f2066f05254081f29914/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62b2e5446d1a47f00729f2066f05254081f29914/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=62b2e5446d1a47f00729f2066f05254081f29914", "patch": "@@ -137,7 +137,7 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n         // Allow uses of projections of immediate pair fields.\n         if let mir::Lvalue::Projection(ref proj) = *lvalue {\n             if let mir::Lvalue::Local(_) = proj.base {\n-                let ty = proj.base.ty(self.cx.mir, self.cx.ccx.tcx());\n+                let ty = proj.base.ty(&self.cx.mir.local_decls, self.cx.ccx.tcx());\n \n                 let ty = self.cx.monomorphize(&ty.to_ty(self.cx.ccx.tcx()));\n                 if common::type_is_imm_pair(self.cx.ccx, ty) {\n@@ -168,7 +168,7 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n                 }\n \n                 LvalueContext::Drop => {\n-                    let ty = lvalue.ty(self.cx.mir, self.cx.ccx.tcx());\n+                    let ty = lvalue.ty(&self.cx.mir.local_decls, self.cx.ccx.tcx());\n                     let ty = self.cx.monomorphize(&ty.to_ty(self.cx.ccx.tcx()));\n \n                     // Only need the lvalue if we're actually dropping it."}, {"sha": "8cc1e7879283fd420c51254a59499310ff27112b", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62b2e5446d1a47f00729f2066f05254081f29914/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62b2e5446d1a47f00729f2066f05254081f29914/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=62b2e5446d1a47f00729f2066f05254081f29914", "patch": "@@ -263,7 +263,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             }\n \n             mir::TerminatorKind::Drop { ref location, target, unwind } => {\n-                let ty = location.ty(&self.mir, bcx.tcx()).to_ty(bcx.tcx());\n+                let ty = location.ty(&self.mir.local_decls, bcx.tcx()).to_ty(bcx.tcx());\n                 let ty = self.monomorphize(&ty);\n                 let drop_fn = monomorphize::resolve_drop_in_place(bcx.ccx.shared(), ty);\n \n@@ -438,7 +438,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                 let extra_args = &args[sig.inputs().len()..];\n                 let extra_args = extra_args.iter().map(|op_arg| {\n-                    let op_ty = op_arg.ty(&self.mir, bcx.tcx());\n+                    let op_ty = op_arg.ty(&self.mir.local_decls, bcx.tcx());\n                     self.monomorphize(&op_ty)\n                 }).collect::<Vec<_>>();\n "}, {"sha": "d2479f1d8837858968a47ef03501fe7e2f0e6d24", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62b2e5446d1a47f00729f2066f05254081f29914/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62b2e5446d1a47f00729f2066f05254081f29914/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=62b2e5446d1a47f00729f2066f05254081f29914", "patch": "@@ -275,7 +275,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 let span = statement.source_info.span;\n                 match statement.kind {\n                     mir::StatementKind::Assign(ref dest, ref rvalue) => {\n-                        let ty = dest.ty(self.mir, tcx);\n+                        let ty = dest.ty(&self.mir.local_decls, tcx);\n                         let ty = self.monomorphize(&ty).to_ty(tcx);\n                         match self.const_rvalue(rvalue, ty, span) {\n                             Ok(value) => self.store(dest, value, span),\n@@ -331,7 +331,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 }\n \n                 mir::TerminatorKind::Call { ref func, ref args, ref destination, .. } => {\n-                    let fn_ty = func.ty(self.mir, tcx);\n+                    let fn_ty = func.ty(&self.mir.local_decls, tcx);\n                     let fn_ty = self.monomorphize(&fn_ty);\n                     let (def_id, substs) = match fn_ty.sty {\n                         ty::TyFnDef(def_id, substs) => (def_id, substs),"}, {"sha": "40cbb4e6537cbd6a89860968c905c5f91fdcfc98", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62b2e5446d1a47f00729f2066f05254081f29914/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62b2e5446d1a47f00729f2066f05254081f29914/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=62b2e5446d1a47f00729f2066f05254081f29914", "patch": "@@ -408,7 +408,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n     pub fn monomorphized_lvalue_ty(&self, lvalue: &mir::Lvalue<'tcx>) -> Ty<'tcx> {\n         let tcx = self.ccx.tcx();\n-        let lvalue_ty = lvalue.ty(&self.mir, tcx);\n+        let lvalue_ty = lvalue.ty(&self.mir.local_decls, tcx);\n         self.monomorphize(&lvalue_ty.to_ty(tcx))\n     }\n }"}, {"sha": "695dd278bc8e6f77eb773c1f78e3a84a4e62bbaf", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/62b2e5446d1a47f00729f2066f05254081f29914/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62b2e5446d1a47f00729f2066f05254081f29914/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=62b2e5446d1a47f00729f2066f05254081f29914", "patch": "@@ -422,7 +422,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::Rvalue::Discriminant(ref lvalue) => {\n                 let discr_lvalue = self.trans_lvalue(&bcx, lvalue);\n                 let enum_ty = discr_lvalue.ty.to_ty(bcx.tcx());\n-                let discr_ty = rvalue.ty(&*self.mir, bcx.tcx());\n+                let discr_ty = rvalue.ty(&self.mir.local_decls, bcx.tcx());\n                 let discr_type = type_of::immediate_type_of(bcx.ccx, discr_ty);\n                 let discr = adt::trans_get_discr(&bcx, enum_ty, discr_lvalue.llval,\n                                                   discr_lvalue.alignment, Some(discr_type), true);\n@@ -476,7 +476,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::Rvalue::Aggregate(..) => {\n                 // According to `rvalue_creates_operand`, only ZST\n                 // aggregate rvalues are allowed to be operands.\n-                let ty = rvalue.ty(self.mir, self.ccx.tcx());\n+                let ty = rvalue.ty(&self.mir.local_decls, self.ccx.tcx());\n                 (bcx, OperandRef::new_zst(self.ccx, self.monomorphize(&ty)))\n             }\n         }\n@@ -676,7 +676,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 true,\n             mir::Rvalue::Repeat(..) |\n             mir::Rvalue::Aggregate(..) => {\n-                let ty = rvalue.ty(self.mir, self.ccx.tcx());\n+                let ty = rvalue.ty(&self.mir.local_decls, self.ccx.tcx());\n                 let ty = self.monomorphize(&ty);\n                 common::type_is_zero_size(self.ccx, ty)\n             }"}]}