{"sha": "e1f3c67cb4e2eb1595040888e897e48c64afb4be", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxZjNjNjdjYjRlMmViMTU5NTA0MDg4OGU4OTdlNDhjNjRhZmI0YmU=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-03-08T21:19:09Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-03-18T00:53:07Z"}, "message": "translate closure shims using MIR", "tree": {"sha": "f38485646242ae94da7c68a6e3dd35921d0343f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f38485646242ae94da7c68a6e3dd35921d0343f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1f3c67cb4e2eb1595040888e897e48c64afb4be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1f3c67cb4e2eb1595040888e897e48c64afb4be", "html_url": "https://github.com/rust-lang/rust/commit/e1f3c67cb4e2eb1595040888e897e48c64afb4be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1f3c67cb4e2eb1595040888e897e48c64afb4be/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5e3c3d5b85e415ad2094f476d9f1ac29a48e413", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5e3c3d5b85e415ad2094f476d9f1ac29a48e413", "html_url": "https://github.com/rust-lang/rust/commit/a5e3c3d5b85e415ad2094f476d9f1ac29a48e413"}], "stats": {"total": 504, "additions": 183, "deletions": 321}, "files": [{"sha": "aeb1fe079ff25b4bc3162225030de3390cca94f9", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e1f3c67cb4e2eb1595040888e897e48c64afb4be/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1f3c67cb4e2eb1595040888e897e48c64afb4be/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=e1f3c67cb4e2eb1595040888e897e48c64afb4be", "patch": "@@ -34,10 +34,7 @@ pub enum InstanceDef<'tcx> {\n     // <Trait as Trait>::fn\n     Virtual(DefId, usize),\n     // <[mut closure] as FnOnce>::call_once\n-    ClosureOnceShim {\n-        call_once: DefId,\n-        closure_did: DefId\n-    },\n+    ClosureOnceShim { call_once: DefId },\n }\n \n impl<'tcx> InstanceDef<'tcx> {\n@@ -48,9 +45,8 @@ impl<'tcx> InstanceDef<'tcx> {\n             InstanceDef::FnPtrShim(def_id, _) |\n             InstanceDef::Virtual(def_id, _) |\n             InstanceDef::Intrinsic(def_id, ) |\n-            InstanceDef::ClosureOnceShim {\n-                call_once: def_id, closure_did: _\n-            } => def_id\n+            InstanceDef::ClosureOnceShim { call_once: def_id }\n+                => def_id\n         }\n     }\n \n@@ -98,10 +94,8 @@ impl<'tcx> fmt::Display for Instance<'tcx> {\n             InstanceDef::FnPtrShim(_, ty) => {\n                 write!(f, \" - shim({:?})\", ty)\n             }\n-            InstanceDef::ClosureOnceShim {\n-                call_once: _, closure_did\n-            } => {\n-                write!(f, \" - shim({:?})\", closure_did)\n+            InstanceDef::ClosureOnceShim { .. } => {\n+                write!(f, \" - shim\")\n             }\n         }\n     }"}, {"sha": "35ad296006dad29f36592c05193de9f236168ef2", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 94, "deletions": 27, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/e1f3c67cb4e2eb1595040888e897e48c64afb4be/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1f3c67cb4e2eb1595040888e897e48c64afb4be/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=e1f3c67cb4e2eb1595040888e897e48c64afb4be", "patch": "@@ -83,7 +83,25 @@ fn make_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n                 None\n             )\n         }\n-        _ => bug!(\"unknown shim kind\")\n+        ty::InstanceDef::ClosureOnceShim { call_once } => {\n+            let fn_mut = tcx.lang_items.fn_mut_trait().unwrap();\n+            let call_mut = tcx.global_tcx()\n+                .associated_items(fn_mut)\n+                .find(|it| it.kind == ty::AssociatedKind::Method)\n+                .unwrap().def_id;\n+\n+            build_call_shim(\n+                tcx,\n+                &param_env,\n+                call_once,\n+                Adjustment::RefMut,\n+                CallKind::Direct(call_mut),\n+                None\n+            )\n+        }\n+        ty::InstanceDef::Intrinsic(_) => {\n+            bug!(\"creating shims from intrinsics ({:?}) is unsupported\", instance)\n+        }\n     };\n     debug!(\"make_shim({:?}) = {:?}\", instance, result);\n \n@@ -97,6 +115,7 @@ fn make_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n enum Adjustment {\n     Identity,\n     Deref,\n+    RefMut,\n }\n \n #[derive(Copy, Clone, Debug, PartialEq)]\n@@ -143,18 +162,37 @@ fn build_call_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n \n     debug!(\"build_call_shim: sig={:?}\", sig);\n \n-    let local_decls = local_decls_for_sig(&sig);\n+    let mut local_decls = local_decls_for_sig(&sig);\n     let source_info = SourceInfo { span, scope: ARGUMENT_VISIBILITY_SCOPE };\n \n-    let rcvr_l = Lvalue::Local(Local::new(1+0));\n-\n-    let return_block_id = BasicBlock::new(1);\n+    let rcvr_arg = Local::new(1+0);\n+    let rcvr_l = Lvalue::Local(rcvr_arg);\n+    let mut statements = vec![];\n \n     let rcvr = match rcvr_adjustment {\n         Adjustment::Identity => Operand::Consume(rcvr_l),\n         Adjustment::Deref => Operand::Consume(Lvalue::Projection(\n             box Projection { base: rcvr_l, elem: ProjectionElem::Deref }\n-        ))\n+        )),\n+        Adjustment::RefMut => {\n+            // let rcvr = &mut rcvr;\n+            let re_erased = tcx.mk_region(ty::ReErased);\n+            let ref_rcvr = local_decls.push(temp_decl(\n+                Mutability::Not,\n+                tcx.mk_ref(re_erased, ty::TypeAndMut {\n+                    ty: sig.inputs()[0],\n+                    mutbl: hir::Mutability::MutMutable\n+                })\n+            ));\n+            statements.push(Statement {\n+                source_info: source_info,\n+                kind: StatementKind::Assign(\n+                    Lvalue::Local(ref_rcvr),\n+                    Rvalue::Ref(re_erased, BorrowKind::Mut, rcvr_l)\n+                )\n+            });\n+            Operand::Consume(Lvalue::Local(ref_rcvr))\n+        }\n     };\n \n     let (callee, mut args) = match call_kind {\n@@ -184,28 +222,57 @@ fn build_call_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     let mut blocks = IndexVec::new();\n-    blocks.push(BasicBlockData {\n-        statements: vec![],\n-        terminator: Some(Terminator {\n-            source_info: source_info,\n-            kind: TerminatorKind::Call {\n-                func: callee,\n-                args: args,\n-                destination: Some((Lvalue::Local(RETURN_POINTER),\n-                                   return_block_id)),\n-                cleanup: None\n+    let block = |blocks: &mut IndexVec<_, _>, statements, kind, is_cleanup| {\n+        blocks.push(BasicBlockData {\n+            statements,\n+            terminator: Some(Terminator { source_info, kind }),\n+            is_cleanup\n+        })\n+    };\n+\n+    let have_unwind = match (rcvr_adjustment, tcx.sess.no_landing_pads()) {\n+        (Adjustment::RefMut, false) => true,\n+        _ => false\n+    };\n+\n+    // BB #0\n+    block(&mut blocks, statements, TerminatorKind::Call {\n+        func: callee,\n+        args: args,\n+        destination: Some((Lvalue::Local(RETURN_POINTER),\n+                           BasicBlock::new(1))),\n+        cleanup: if have_unwind {\n+            Some(BasicBlock::new(3))\n+        } else {\n+            None\n+        }\n+    }, false);\n+\n+    if let Adjustment::RefMut = rcvr_adjustment {\n+        // BB #1 - drop for Self\n+        block(&mut blocks, vec![], TerminatorKind::Drop {\n+            location: Lvalue::Local(rcvr_arg),\n+            target: BasicBlock::new(2),\n+            unwind: if have_unwind {\n+                Some(BasicBlock::new(4))\n+            } else {\n+                None\n             }\n-        }),\n-        is_cleanup: false\n-    });\n-    blocks.push(BasicBlockData {\n-        statements: vec![],\n-        terminator: Some(Terminator {\n-            source_info: source_info,\n-            kind: TerminatorKind::Return\n-        }),\n-        is_cleanup: false\n-    });\n+        }, false);\n+    }\n+    // BB #1/#2 - return\n+    block(&mut blocks, vec![], TerminatorKind::Return, false);\n+    if have_unwind {\n+        // BB #3 - drop if closure panics\n+        block(&mut blocks, vec![], TerminatorKind::Drop {\n+            location: Lvalue::Local(rcvr_arg),\n+            target: BasicBlock::new(4),\n+            unwind: None\n+        }, true);\n+\n+        // BB #4 - resume\n+        block(&mut blocks, vec![], TerminatorKind::Resume, true);\n+    }\n \n     let mut mir = Mir::new(\n         blocks,"}, {"sha": "4d0bd9fa201d8db141b6457488019a89863625cb", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 7, "deletions": 166, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/e1f3c67cb4e2eb1595040888e897e48c64afb4be/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1f3c67cb4e2eb1595040888e897e48c64afb4be/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=e1f3c67cb4e2eb1595040888e897e48c64afb4be", "patch": "@@ -14,154 +14,29 @@\n //! and methods are represented as just a fn ptr and not a full\n //! closure.\n \n-use llvm::{self, ValueRef, get_params};\n+use llvm::{self, ValueRef};\n use rustc::hir::def_id::DefId;\n-use rustc::ty::subst::{Substs, Subst};\n-use abi::{Abi, FnType};\n+use rustc::ty::subst::Substs;\n use attributes;\n-use builder::Builder;\n use common::{self, CrateContext};\n-use cleanup::CleanupScope;\n-use mir::lvalue::LvalueRef;\n use monomorphize;\n use consts;\n use declare;\n-use value::Value;\n use monomorphize::Instance;\n-use back::symbol_names::symbol_name;\n use trans_item::TransItem;\n use type_of;\n-use rustc::ty::{self, TypeFoldable};\n-use std::iter;\n-\n-use mir::lvalue::Alignment;\n-\n-fn trans_fn_once_adapter_shim<'a, 'tcx>(\n-    ccx: &'a CrateContext<'a, 'tcx>,\n-    def_id: DefId,\n-    substs: ty::ClosureSubsts<'tcx>,\n-    method_instance: Instance<'tcx>,\n-    llreffn: ValueRef)\n-    -> ValueRef\n-{\n-    if let Some(&llfn) = ccx.instances().borrow().get(&method_instance) {\n-        return llfn;\n-    }\n-\n-    debug!(\"trans_fn_once_adapter_shim(def_id={:?}, substs={:?}, llreffn={:?})\",\n-           def_id, substs, Value(llreffn));\n-\n-    let tcx = ccx.tcx();\n-\n-    // Find a version of the closure type. Substitute static for the\n-    // region since it doesn't really matter.\n-    let closure_ty = tcx.mk_closure_from_closure_substs(def_id, substs);\n-    let ref_closure_ty = tcx.mk_imm_ref(tcx.mk_region(ty::ReErased), closure_ty);\n-\n-    // Make a version with the type of by-ref closure.\n-    let sig = tcx.closure_type(def_id).subst(tcx, substs.substs);\n-    let sig = tcx.erase_late_bound_regions_and_normalize(&sig);\n-    assert_eq!(sig.abi, Abi::RustCall);\n-    let llref_fn_sig = tcx.mk_fn_sig(\n-        iter::once(ref_closure_ty).chain(sig.inputs().iter().cloned()),\n-        sig.output(),\n-        sig.variadic,\n-        sig.unsafety,\n-        Abi::RustCall\n-    );\n-    let llref_fn_ty = tcx.mk_fn_ptr(ty::Binder(llref_fn_sig));\n-    debug!(\"trans_fn_once_adapter_shim: llref_fn_ty={:?}\",\n-           llref_fn_ty);\n-\n-\n-    // Make a version of the closure type with the same arguments, but\n-    // with argument #0 being by value.\n-    let sig = tcx.mk_fn_sig(\n-        iter::once(closure_ty).chain(sig.inputs().iter().cloned()),\n-        sig.output(),\n-        sig.variadic,\n-        sig.unsafety,\n-        Abi::RustCall\n-    );\n-\n-    let fn_ty = FnType::new(ccx, sig, &[]);\n-    let llonce_fn_ty = tcx.mk_fn_ptr(ty::Binder(sig));\n-\n-    // Create the by-value helper.\n-    let function_name = symbol_name(method_instance, ccx.shared());\n-    let lloncefn = declare::define_internal_fn(ccx, &function_name, llonce_fn_ty);\n-    attributes::set_frame_pointer_elimination(ccx, lloncefn);\n-\n-    let orig_fn_ty = fn_ty;\n-    let mut bcx = Builder::new_block(ccx, lloncefn, \"entry-block\");\n-\n-    // the first argument (`self`) will be the (by value) closure env.\n-\n-    let mut llargs = get_params(lloncefn);\n-    let fn_ty = FnType::new(ccx, llref_fn_sig, &[]);\n-    let self_idx = fn_ty.ret.is_indirect() as usize;\n-    let env_arg = &orig_fn_ty.args[0];\n-    let env = if env_arg.is_indirect() {\n-        LvalueRef::new_sized_ty(llargs[self_idx], closure_ty, Alignment::AbiAligned)\n-    } else {\n-        let scratch = LvalueRef::alloca(&bcx, closure_ty, \"self\");\n-        let mut llarg_idx = self_idx;\n-        env_arg.store_fn_arg(&bcx, &mut llarg_idx, scratch.llval);\n-        scratch\n-    };\n-\n-    debug!(\"trans_fn_once_adapter_shim: env={:?}\", env);\n-    // Adjust llargs such that llargs[self_idx..] has the call arguments.\n-    // For zero-sized closures that means sneaking in a new argument.\n-    if env_arg.is_ignore() {\n-        llargs.insert(self_idx, env.llval);\n-    } else {\n-        llargs[self_idx] = env.llval;\n-    }\n-\n-    // Call the by-ref closure body with `self` in a cleanup scope,\n-    // to drop `self` when the body returns, or in case it unwinds.\n-    let self_scope = CleanupScope::schedule_drop_mem(&bcx, env);\n-\n-    let llret;\n-    if let Some(landing_pad) = self_scope.landing_pad {\n-        let normal_bcx = bcx.build_sibling_block(\"normal-return\");\n-        llret = bcx.invoke(llreffn, &llargs[..], normal_bcx.llbb(), landing_pad, None);\n-        bcx = normal_bcx;\n-    } else {\n-        llret = bcx.call(llreffn, &llargs[..], None);\n-    }\n-    fn_ty.apply_attrs_callsite(llret);\n-\n-    if sig.output().is_never() {\n-        bcx.unreachable();\n-    } else {\n-        self_scope.trans(&bcx);\n-\n-        if fn_ty.ret.is_indirect() || fn_ty.ret.is_ignore() {\n-            bcx.ret_void();\n-        } else {\n-            bcx.ret(llret);\n-        }\n-    }\n-\n-    ccx.instances().borrow_mut().insert(method_instance, lloncefn);\n-\n-    lloncefn\n-}\n-\n+use rustc::ty::TypeFoldable;\n \n /// Translates a reference to a fn/method item, monomorphizing and\n /// inlining as it goes.\n ///\n /// # Parameters\n ///\n /// - `ccx`: the crate context\n-/// - `def_id`: def id of the fn or method item being referenced\n-/// - `substs`: values for each of the fn/method's parameters\n-fn do_get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                       instance: Instance<'tcx>)\n-                       -> ValueRef\n+/// - `instance`: the instance to be instantiated\n+pub fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                        instance: Instance<'tcx>)\n+                        -> ValueRef\n {\n     let tcx = ccx.tcx();\n \n@@ -248,40 +123,6 @@ fn do_get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     llfn\n }\n \n-pub fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                        instance: Instance<'tcx>)\n-                        -> ValueRef\n-{\n-    match instance.def {\n-        ty::InstanceDef::Intrinsic(_) => {\n-            bug!(\"intrinsic {} getting reified\", instance)\n-        }\n-        ty::InstanceDef::ClosureOnceShim { .. } => {\n-            let closure_ty = instance.substs.type_at(0);\n-            let (closure_def_id, closure_substs) = match closure_ty.sty {\n-                ty::TyClosure(def_id, substs) => (def_id, substs),\n-                _ => bug!(\"bad closure instance {:?}\", instance)\n-            };\n-\n-            trans_fn_once_adapter_shim(\n-                ccx,\n-                closure_def_id,\n-                closure_substs,\n-                instance,\n-                do_get_fn(\n-                    ccx,\n-                    Instance::new(closure_def_id, closure_substs.substs)\n-                )\n-            )\n-        }\n-        ty::InstanceDef::FnPtrShim(..) |\n-        ty::InstanceDef::Item(..) |\n-        ty::InstanceDef::Virtual(..) => {\n-            do_get_fn(ccx, instance)\n-        }\n-    }\n-}\n-\n pub fn resolve_and_get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                     def_id: DefId,\n                                     substs: &'tcx Substs<'tcx>)"}, {"sha": "2b2e5e85ea50d3d604ba05512cbc5ad5b2d46a7f", "filename": "src/librustc_trans/cleanup.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e1f3c67cb4e2eb1595040888e897e48c64afb4be/src%2Flibrustc_trans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1f3c67cb4e2eb1595040888e897e48c64afb4be/src%2Flibrustc_trans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcleanup.rs?ref=e1f3c67cb4e2eb1595040888e897e48c64afb4be", "patch": "@@ -93,24 +93,6 @@ impl<'tcx> DropValue<'tcx> {\n }\n \n impl<'a, 'tcx> CleanupScope<'tcx> {\n-    /// Schedules a (deep) drop of `val`, which is a pointer to an instance of `ty`\n-    pub fn schedule_drop_mem(\n-        bcx: &Builder<'a, 'tcx>, val: LvalueRef<'tcx>\n-    ) -> CleanupScope<'tcx> {\n-        if let LvalueTy::Downcast { .. } = val.ty {\n-            bug!(\"Cannot drop downcast ty yet\");\n-        }\n-        if !bcx.ccx.shared().type_needs_drop(val.ty.to_ty(bcx.tcx())) {\n-            return CleanupScope::noop();\n-        }\n-        let drop = DropValue {\n-            val: val,\n-            skip_dtor: false,\n-        };\n-\n-        CleanupScope::new(bcx, drop)\n-    }\n-\n     /// Issue #23611: Schedules a (deep) drop of the contents of\n     /// `val`, which is a pointer to an instance of struct/enum type\n     /// `ty`. The scheduled code handles extracting the discriminant"}, {"sha": "f076fc4710222a50bca3767fb79ae818fd528d87", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 6, "deletions": 37, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e1f3c67cb4e2eb1595040888e897e48c64afb4be/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1f3c67cb4e2eb1595040888e897e48c64afb4be/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=e1f3c67cb4e2eb1595040888e897e48c64afb4be", "patch": "@@ -497,11 +497,9 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                 let source_ty = operand.ty(self.mir, self.scx.tcx());\n                 match source_ty.sty {\n                     ty::TyClosure(def_id, substs) => {\n-                        let substs = monomorphize::apply_param_substs(\n-                            self.scx, self.param_substs, &substs.substs);\n-                        self.output.push(create_fn_trans_item(\n-                            Instance::new(def_id, substs)\n-                        ));\n+                        let instance = monomorphize::resolve_closure(\n+                            self.scx, def_id, substs, ty::ClosureKind::FnOnce);\n+                        self.output.push(create_fn_trans_item(instance));\n                     }\n                     _ => bug!(),\n                 }\n@@ -601,20 +599,6 @@ fn visit_fn_use<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n     }\n \n     match instance.def {\n-        ty::InstanceDef::ClosureOnceShim { .. } => {\n-            // This call will instantiate an FnOnce adapter, which\n-            // drops the closure environment. Therefore we need to\n-            // make sure that we collect the drop-glue for the\n-            // environment type along with the instance.\n-\n-            let env_ty = instance.substs.type_at(0);\n-            let env_ty = glue::get_drop_glue_type(scx, env_ty);\n-            if scx.type_needs_drop(env_ty) {\n-                let dg = DropGlueKind::Ty(env_ty);\n-                output.push(TransItem::DropGlue(dg));\n-            }\n-            output.push(create_fn_trans_item(instance));\n-        }\n         ty::InstanceDef::Intrinsic(..) => {\n             if !is_direct_call {\n                 bug!(\"intrinsic {:?} being reified\", ty);\n@@ -632,6 +616,7 @@ fn visit_fn_use<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                 output.push(create_fn_trans_item(instance));\n             }\n         }\n+        ty::InstanceDef::ClosureOnceShim { .. } |\n         ty::InstanceDef::Item(..) |\n         ty::InstanceDef::FnPtrShim(..) => {\n             output.push(create_fn_trans_item(instance));\n@@ -645,10 +630,8 @@ fn visit_fn_use<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n fn should_trans_locally<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: &Instance<'tcx>)\n                                   -> bool {\n     let def_id = match instance.def {\n-        ty::InstanceDef::Item(def_id) |\n-        ty::InstanceDef::ClosureOnceShim {\n-            call_once: _, closure_did: def_id\n-        } => def_id,\n+        ty::InstanceDef::Item(def_id) => def_id,\n+        ty::InstanceDef::ClosureOnceShim { .. } |\n         ty::InstanceDef::Virtual(..) |\n         ty::InstanceDef::FnPtrShim(..) |\n         ty::InstanceDef::Intrinsic(_) => return true\n@@ -885,20 +868,6 @@ fn find_vtable_types_for_unsizing<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n \n fn create_fn_trans_item<'a, 'tcx>(instance: Instance<'tcx>) -> TransItem<'tcx> {\n     debug!(\"create_fn_trans_item(instance={})\", instance);\n-    let instance = match instance.def {\n-        ty::InstanceDef::ClosureOnceShim { .. } => {\n-            // HACK: don't create ClosureOnce trans items for now\n-            // have someone else generate the drop glue\n-            let closure_ty = instance.substs.type_at(0);\n-            match closure_ty.sty {\n-                ty::TyClosure(def_id, substs) => {\n-                    Instance::new(def_id, substs.substs)\n-                }\n-                _ => bug!(\"bad closure instance {:?}\", instance)\n-            }\n-        }\n-        _ => instance\n-    };\n     TransItem::Fn(instance)\n }\n "}, {"sha": "178347369c91551b38cffddf6b62b51d79b0c581", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e1f3c67cb4e2eb1595040888e897e48c64afb4be/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1f3c67cb4e2eb1595040888e897e48c64afb4be/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=e1f3c67cb4e2eb1595040888e897e48c64afb4be", "patch": "@@ -12,7 +12,6 @@ use llvm::{self, ValueRef};\n use rustc::ty::{self, Ty};\n use rustc::ty::cast::{CastTy, IntTy};\n use rustc::ty::layout::Layout;\n-use rustc::ty::subst::{Kind, Subst};\n use rustc::mir::tcx::LvalueTy;\n use rustc::mir;\n use middle::lang_items::ExchangeMallocFnLangItem;\n@@ -24,6 +23,7 @@ use common::{self, val_ty, C_bool, C_null, C_uint};\n use common::{C_integral};\n use adt;\n use machine;\n+use monomorphize;\n use type_::Type;\n use type_of;\n use tvec;\n@@ -193,22 +193,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     mir::CastKind::ClosureFnPointer => {\n                         match operand.ty.sty {\n                             ty::TyClosure(def_id, substs) => {\n-                                // Get the def_id for FnOnce::call_once\n-                                let fn_once = bcx.tcx().lang_items.fn_once_trait().unwrap();\n-                                let call_once = bcx.tcx()\n-                                    .global_tcx().associated_items(fn_once)\n-                                    .find(|it| it.kind == ty::AssociatedKind::Method)\n-                                    .unwrap().def_id;\n-                                // Now create its substs [Closure, Tuple]\n-                                let input = bcx.tcx().closure_type(def_id)\n-                                    .subst(bcx.tcx(), substs.substs).input(0);\n-                                let input =\n-                                    bcx.tcx().erase_late_bound_regions_and_normalize(&input);\n-                                let substs = bcx.tcx().mk_substs([operand.ty, input]\n-                                    .iter().cloned().map(Kind::from));\n-                                OperandValue::Immediate(\n-                                    callee::resolve_and_get_fn(bcx.ccx, call_once, substs)\n-                                )\n+                                let instance = monomorphize::resolve_closure(\n+                                    bcx.ccx.shared(), def_id, substs, ty::ClosureKind::FnOnce);\n+                                OperandValue::Immediate(callee::get_fn(bcx.ccx, instance))\n                             }\n                             _ => {\n                                 bug!(\"{} cannot be cast to a fn ptr\", operand.ty)"}, {"sha": "0d8aa0f4bda0ea0d7fe0a14939a41b484e0a9362", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 51, "deletions": 44, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/e1f3c67cb4e2eb1595040888e897e48c64afb4be/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1f3c67cb4e2eb1595040888e897e48c64afb4be/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=e1f3c67cb4e2eb1595040888e897e48c64afb4be", "patch": "@@ -37,7 +37,7 @@ fn fn_once_adapter_instance<'a, 'tcx>(\n     let call_once = tcx.associated_items(fn_once)\n         .find(|it| it.kind == ty::AssociatedKind::Method)\n         .unwrap().def_id;\n-    let def = ty::InstanceDef::ClosureOnceShim { call_once, closure_did };\n+    let def = ty::InstanceDef::ClosureOnceShim { call_once };\n \n     let self_ty = tcx.mk_closure_from_closure_substs(\n         closure_did, substs);\n@@ -54,6 +54,54 @@ fn fn_once_adapter_instance<'a, 'tcx>(\n     Instance { def, substs }\n }\n \n+fn needs_fn_once_adapter_shim(actual_closure_kind: ty::ClosureKind,\n+                              trait_closure_kind: ty::ClosureKind)\n+                              -> Result<bool, ()>\n+{\n+    match (actual_closure_kind, trait_closure_kind) {\n+        (ty::ClosureKind::Fn, ty::ClosureKind::Fn) |\n+        (ty::ClosureKind::FnMut, ty::ClosureKind::FnMut) |\n+        (ty::ClosureKind::FnOnce, ty::ClosureKind::FnOnce) => {\n+            // No adapter needed.\n+           Ok(false)\n+        }\n+        (ty::ClosureKind::Fn, ty::ClosureKind::FnMut) => {\n+            // The closure fn `llfn` is a `fn(&self, ...)`.  We want a\n+            // `fn(&mut self, ...)`. In fact, at trans time, these are\n+            // basically the same thing, so we can just return llfn.\n+            Ok(false)\n+        }\n+        (ty::ClosureKind::Fn, ty::ClosureKind::FnOnce) |\n+        (ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n+            // The closure fn `llfn` is a `fn(&self, ...)` or `fn(&mut\n+            // self, ...)`.  We want a `fn(self, ...)`. We can produce\n+            // this by doing something like:\n+            //\n+            //     fn call_once(self, ...) { call_mut(&self, ...) }\n+            //     fn call_once(mut self, ...) { call_mut(&mut self, ...) }\n+            //\n+            // These are both the same at trans time.\n+            Ok(true)\n+        }\n+        _ => Err(()),\n+    }\n+}\n+\n+pub fn resolve_closure<'a, 'tcx> (\n+    scx: &SharedCrateContext<'a, 'tcx>,\n+    def_id: DefId,\n+    substs: ty::ClosureSubsts<'tcx>,\n+    requested_kind: ty::ClosureKind)\n+    -> Instance<'tcx>\n+{\n+    let actual_kind = scx.tcx().closure_kind(def_id);\n+\n+    match needs_fn_once_adapter_shim(actual_kind, requested_kind) {\n+        Ok(true) => fn_once_adapter_instance(scx.tcx(), def_id, substs),\n+        _ => Instance::new(def_id, substs.substs)\n+    }\n+}\n+\n /// Attempts to resolve an obligation. The result is a shallow vtable resolution -- meaning that we\n /// do not (necessarily) resolve all nested obligations on the impl. Note that type check should\n /// guarantee to us that all nested obligations *could be* resolved if we wanted to.\n@@ -121,39 +169,6 @@ fn fulfill_obligation<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n     })\n }\n \n-fn needs_fn_once_adapter_shim(actual_closure_kind: ty::ClosureKind,\n-                              trait_closure_kind: ty::ClosureKind)\n-                              -> Result<bool, ()>\n-{\n-    match (actual_closure_kind, trait_closure_kind) {\n-        (ty::ClosureKind::Fn, ty::ClosureKind::Fn) |\n-        (ty::ClosureKind::FnMut, ty::ClosureKind::FnMut) |\n-        (ty::ClosureKind::FnOnce, ty::ClosureKind::FnOnce) => {\n-            // No adapter needed.\n-           Ok(false)\n-        }\n-        (ty::ClosureKind::Fn, ty::ClosureKind::FnMut) => {\n-            // The closure fn `llfn` is a `fn(&self, ...)`.  We want a\n-            // `fn(&mut self, ...)`. In fact, at trans time, these are\n-            // basically the same thing, so we can just return llfn.\n-            Ok(false)\n-        }\n-        (ty::ClosureKind::Fn, ty::ClosureKind::FnOnce) |\n-        (ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n-            // The closure fn `llfn` is a `fn(&self, ...)` or `fn(&mut\n-            // self, ...)`.  We want a `fn(self, ...)`. We can produce\n-            // this by doing something like:\n-            //\n-            //     fn call_once(self, ...) { call_mut(&self, ...) }\n-            //     fn call_once(mut self, ...) { call_mut(&mut self, ...) }\n-            //\n-            // These are both the same at trans time.\n-            Ok(true)\n-        }\n-        _ => Err(()),\n-    }\n-}\n-\n fn resolve_associated_item<'a, 'tcx>(\n     scx: &SharedCrateContext<'a, 'tcx>,\n     trait_item: &ty::AssociatedItem,\n@@ -180,16 +195,9 @@ fn resolve_associated_item<'a, 'tcx>(\n             ty::Instance::new(def_id, substs)\n         }\n         traits::VtableClosure(closure_data) => {\n-            let closure_def_id = closure_data.closure_def_id;\n             let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n-            let actual_closure_kind = tcx.closure_kind(closure_def_id);\n-\n-            match needs_fn_once_adapter_shim(actual_closure_kind,\n-                                             trait_closure_kind) {\n-                Ok(true) => fn_once_adapter_instance(\n-                    tcx, closure_def_id, closure_data.substs),\n-                _ => Instance::new(closure_def_id, closure_data.substs.substs),\n-            }\n+            resolve_closure(scx, closure_data.closure_def_id, closure_data.substs,\n+                            trait_closure_kind)\n         }\n         traits::VtableFnPointer(ref data) => {\n             Instance {\n@@ -279,7 +287,6 @@ pub fn apply_param_substs<'a, 'tcx, T>(scx: &SharedCrateContext<'a, 'tcx>,\n     AssociatedTypeNormalizer::new(scx).fold(&substituted)\n }\n \n-\n /// Returns the normalized type of a struct field\n pub fn field_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           param_substs: &Substs<'tcx>,"}, {"sha": "281dde15bd336e4d45a2022e6c158e1db3e71aa1", "filename": "src/test/run-pass/issue-29948.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e1f3c67cb4e2eb1595040888e897e48c64afb4be/src%2Ftest%2Frun-pass%2Fissue-29948.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1f3c67cb4e2eb1595040888e897e48c64afb4be/src%2Ftest%2Frun-pass%2Fissue-29948.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-29948.rs?ref=e1f3c67cb4e2eb1595040888e897e48c64afb4be", "patch": "@@ -8,6 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::panic;\n+\n+impl<'a> panic::UnwindSafe for Foo<'a> {}\n+impl<'a> panic::RefUnwindSafe for Foo<'a> {}\n+\n struct Foo<'a>(&'a mut bool);\n \n impl<'a> Drop for Foo<'a> {\n@@ -28,5 +33,15 @@ fn main() {\n         f(x);\n     }\n     assert!(ran_drop);\n-}\n \n+    let mut ran_drop = false;\n+    {\n+        let x = Foo(&mut ran_drop);\n+        let result = panic::catch_unwind(move || {\n+            let x = move || { let _ = x; panic!() };\n+            f(x);\n+        });\n+        assert!(result.is_err());\n+    }\n+    assert!(ran_drop);\n+}"}]}