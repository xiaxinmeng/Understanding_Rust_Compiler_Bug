{"sha": "2362659b00c1d99ccaed64815575beba69cd3714", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzNjI2NTliMDBjMWQ5OWNjYWVkNjQ4MTU1NzViZWJhNjljZDM3MTQ=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-10-24T12:12:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-24T12:12:15Z"}, "message": "Rollup merge of #78292 - bugadani:recursion, r=nagisa\n\nLoop instead of recursion\n\nI saw the comment `// FIXME: consider not using recursion to lower this.` and considered not using recursion :)", "tree": {"sha": "47a4aff028d20c6ba18c703e4ab2cf1816d85795", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47a4aff028d20c6ba18c703e4ab2cf1816d85795"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2362659b00c1d99ccaed64815575beba69cd3714", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJflBofCRBK7hj4Ov3rIwAAdHIIAFK5zqCqxHgMAJtIevGcEgz2\n4oXXV8NCag06jmlBRAeY0xK50DVWDmvkJ+gCnPwSWKM6rKZRbFiDLs355baor4Lh\nXBYLfYBHw9p9PYNIzxaEy/+Hi9VnWiF0BKrOs5I9XSlS2JilVa0aJhHZmrtl3q+o\noFyVYgqwKz0V/OhARhDkrPHqzfbFMqwJQHLESS2oJmxQsmfxCqcliBxpJBT21jvL\nll/nKweAlh1wuUDueehEFsqKcJ8JXF4sath+2YD/ogky0st3rd0KU5sbP+jnUEdi\nOUpMzI/GJTHOS1vH+8EE2Im0YOOBCzgnt9nRPQSrH429QPAFlxcLDiYOio144fs=\n=8Luq\n-----END PGP SIGNATURE-----\n", "payload": "tree 47a4aff028d20c6ba18c703e4ab2cf1816d85795\nparent b6ae1fabee30fae23d7afb30110b4e5ea2bb92e0\nparent f88d6e8437fdf4284ca7a1548e2e5ecfe89585be\nauthor Jonas Schievink <jonasschievink@gmail.com> 1603541535 +0200\ncommitter GitHub <noreply@github.com> 1603541535 +0200\n\nRollup merge of #78292 - bugadani:recursion, r=nagisa\n\nLoop instead of recursion\n\nI saw the comment `// FIXME: consider not using recursion to lower this.` and considered not using recursion :)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2362659b00c1d99ccaed64815575beba69cd3714", "html_url": "https://github.com/rust-lang/rust/commit/2362659b00c1d99ccaed64815575beba69cd3714", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2362659b00c1d99ccaed64815575beba69cd3714/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6ae1fabee30fae23d7afb30110b4e5ea2bb92e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6ae1fabee30fae23d7afb30110b4e5ea2bb92e0", "html_url": "https://github.com/rust-lang/rust/commit/b6ae1fabee30fae23d7afb30110b4e5ea2bb92e0"}, {"sha": "f88d6e8437fdf4284ca7a1548e2e5ecfe89585be", "url": "https://api.github.com/repos/rust-lang/rust/commits/f88d6e8437fdf4284ca7a1548e2e5ecfe89585be", "html_url": "https://github.com/rust-lang/rust/commit/f88d6e8437fdf4284ca7a1548e2e5ecfe89585be"}], "stats": {"total": 150, "additions": 79, "deletions": 71}, "files": [{"sha": "a1cbcde1f4291ca9acc5195668054a90853448af", "filename": "compiler/rustc_ast_lowering/src/pat.rs", "status": "modified", "additions": 79, "deletions": 71, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/2362659b00c1d99ccaed64815575beba69cd3714/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2362659b00c1d99ccaed64815575beba69cd3714/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs?ref=2362659b00c1d99ccaed64815575beba69cd3714", "patch": "@@ -10,82 +10,90 @@ use rustc_span::symbol::Ident;\n use rustc_span::{source_map::Spanned, Span};\n \n impl<'a, 'hir> LoweringContext<'a, 'hir> {\n-    crate fn lower_pat(&mut self, p: &Pat) -> &'hir hir::Pat<'hir> {\n+    crate fn lower_pat(&mut self, mut pattern: &Pat) -> &'hir hir::Pat<'hir> {\n         ensure_sufficient_stack(|| {\n-            let node = match p.kind {\n-                PatKind::Wild => hir::PatKind::Wild,\n-                PatKind::Ident(ref binding_mode, ident, ref sub) => {\n-                    let lower_sub = |this: &mut Self| sub.as_ref().map(|s| this.lower_pat(&*s));\n-                    let node = self.lower_pat_ident(p, binding_mode, ident, lower_sub);\n-                    node\n-                }\n-                PatKind::Lit(ref e) => hir::PatKind::Lit(self.lower_expr(e)),\n-                PatKind::TupleStruct(ref path, ref pats) => {\n-                    let qpath = self.lower_qpath(\n-                        p.id,\n-                        &None,\n-                        path,\n-                        ParamMode::Optional,\n-                        ImplTraitContext::disallowed(),\n-                    );\n-                    let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple struct\");\n-                    hir::PatKind::TupleStruct(qpath, pats, ddpos)\n-                }\n-                PatKind::Or(ref pats) => hir::PatKind::Or(\n-                    self.arena.alloc_from_iter(pats.iter().map(|x| self.lower_pat(x))),\n-                ),\n-                PatKind::Path(ref qself, ref path) => {\n-                    let qpath = self.lower_qpath(\n-                        p.id,\n-                        qself,\n-                        path,\n-                        ParamMode::Optional,\n-                        ImplTraitContext::disallowed(),\n-                    );\n-                    hir::PatKind::Path(qpath)\n-                }\n-                PatKind::Struct(ref path, ref fields, etc) => {\n-                    let qpath = self.lower_qpath(\n-                        p.id,\n-                        &None,\n-                        path,\n-                        ParamMode::Optional,\n-                        ImplTraitContext::disallowed(),\n-                    );\n+            // loop here to avoid recursion\n+            let node = loop {\n+                match pattern.kind {\n+                    PatKind::Wild => break hir::PatKind::Wild,\n+                    PatKind::Ident(ref binding_mode, ident, ref sub) => {\n+                        let lower_sub = |this: &mut Self| sub.as_ref().map(|s| this.lower_pat(&*s));\n+                        break self.lower_pat_ident(pattern, binding_mode, ident, lower_sub);\n+                    }\n+                    PatKind::Lit(ref e) => break hir::PatKind::Lit(self.lower_expr(e)),\n+                    PatKind::TupleStruct(ref path, ref pats) => {\n+                        let qpath = self.lower_qpath(\n+                            pattern.id,\n+                            &None,\n+                            path,\n+                            ParamMode::Optional,\n+                            ImplTraitContext::disallowed(),\n+                        );\n+                        let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple struct\");\n+                        break hir::PatKind::TupleStruct(qpath, pats, ddpos);\n+                    }\n+                    PatKind::Or(ref pats) => {\n+                        break hir::PatKind::Or(\n+                            self.arena.alloc_from_iter(pats.iter().map(|x| self.lower_pat(x))),\n+                        );\n+                    }\n+                    PatKind::Path(ref qself, ref path) => {\n+                        let qpath = self.lower_qpath(\n+                            pattern.id,\n+                            qself,\n+                            path,\n+                            ParamMode::Optional,\n+                            ImplTraitContext::disallowed(),\n+                        );\n+                        break hir::PatKind::Path(qpath);\n+                    }\n+                    PatKind::Struct(ref path, ref fields, etc) => {\n+                        let qpath = self.lower_qpath(\n+                            pattern.id,\n+                            &None,\n+                            path,\n+                            ParamMode::Optional,\n+                            ImplTraitContext::disallowed(),\n+                        );\n \n-                    let fs = self.arena.alloc_from_iter(fields.iter().map(|f| hir::FieldPat {\n-                        hir_id: self.next_id(),\n-                        ident: f.ident,\n-                        pat: self.lower_pat(&f.pat),\n-                        is_shorthand: f.is_shorthand,\n-                        span: f.span,\n-                    }));\n-                    hir::PatKind::Struct(qpath, fs, etc)\n-                }\n-                PatKind::Tuple(ref pats) => {\n-                    let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple\");\n-                    hir::PatKind::Tuple(pats, ddpos)\n-                }\n-                PatKind::Box(ref inner) => hir::PatKind::Box(self.lower_pat(inner)),\n-                PatKind::Ref(ref inner, mutbl) => hir::PatKind::Ref(self.lower_pat(inner), mutbl),\n-                PatKind::Range(ref e1, ref e2, Spanned { node: ref end, .. }) => {\n-                    hir::PatKind::Range(\n-                        e1.as_deref().map(|e| self.lower_expr(e)),\n-                        e2.as_deref().map(|e| self.lower_expr(e)),\n-                        self.lower_range_end(end, e2.is_some()),\n-                    )\n-                }\n-                PatKind::Slice(ref pats) => self.lower_pat_slice(pats),\n-                PatKind::Rest => {\n-                    // If we reach here the `..` pattern is not semantically allowed.\n-                    self.ban_illegal_rest_pat(p.span)\n+                        let fs = self.arena.alloc_from_iter(fields.iter().map(|f| hir::FieldPat {\n+                            hir_id: self.next_id(),\n+                            ident: f.ident,\n+                            pat: self.lower_pat(&f.pat),\n+                            is_shorthand: f.is_shorthand,\n+                            span: f.span,\n+                        }));\n+                        break hir::PatKind::Struct(qpath, fs, etc);\n+                    }\n+                    PatKind::Tuple(ref pats) => {\n+                        let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple\");\n+                        break hir::PatKind::Tuple(pats, ddpos);\n+                    }\n+                    PatKind::Box(ref inner) => {\n+                        break hir::PatKind::Box(self.lower_pat(inner));\n+                    }\n+                    PatKind::Ref(ref inner, mutbl) => {\n+                        break hir::PatKind::Ref(self.lower_pat(inner), mutbl);\n+                    }\n+                    PatKind::Range(ref e1, ref e2, Spanned { node: ref end, .. }) => {\n+                        break hir::PatKind::Range(\n+                            e1.as_deref().map(|e| self.lower_expr(e)),\n+                            e2.as_deref().map(|e| self.lower_expr(e)),\n+                            self.lower_range_end(end, e2.is_some()),\n+                        );\n+                    }\n+                    PatKind::Slice(ref pats) => break self.lower_pat_slice(pats),\n+                    PatKind::Rest => {\n+                        // If we reach here the `..` pattern is not semantically allowed.\n+                        break self.ban_illegal_rest_pat(pattern.span);\n+                    }\n+                    // return inner to be processed in next loop\n+                    PatKind::Paren(ref inner) => pattern = inner,\n+                    PatKind::MacCall(_) => panic!(\"{:?} shouldn't exist here\", pattern.span),\n                 }\n-                // FIXME: consider not using recursion to lower this.\n-                PatKind::Paren(ref inner) => return self.lower_pat(inner),\n-                PatKind::MacCall(_) => panic!(\"{:?} shouldn't exist here\", p.span),\n             };\n \n-            self.pat_with_node_id_of(p, node)\n+            self.pat_with_node_id_of(pattern, node)\n         })\n     }\n "}]}