{"sha": "e073dfe9a2d53ae24db6668526ef32eb2116eb92", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwNzNkZmU5YTJkNTNhZTI0ZGI2NjY4NTI2ZWYzMmViMjExNmViOTI=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-06-11T02:57:25Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-06-11T02:57:25Z"}, "message": "Abide by the common rustc::ty conventions.", "tree": {"sha": "d59c197973a8620b0519fdf85c1a1c4d8dd74f87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d59c197973a8620b0519fdf85c1a1c4d8dd74f87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e073dfe9a2d53ae24db6668526ef32eb2116eb92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e073dfe9a2d53ae24db6668526ef32eb2116eb92", "html_url": "https://github.com/rust-lang/rust/commit/e073dfe9a2d53ae24db6668526ef32eb2116eb92", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e073dfe9a2d53ae24db6668526ef32eb2116eb92/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd89737b216c6bea5fde7c0f85777aabb2eefbf9", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd89737b216c6bea5fde7c0f85777aabb2eefbf9", "html_url": "https://github.com/rust-lang/rust/commit/cd89737b216c6bea5fde7c0f85777aabb2eefbf9"}], "stats": {"total": 193, "additions": 96, "deletions": 97}, "files": [{"sha": "1cca82d9795446a2ea18d71a671a15aac1011f60", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e073dfe9a2d53ae24db6668526ef32eb2116eb92/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e073dfe9a2d53ae24db6668526ef32eb2116eb92/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=e073dfe9a2d53ae24db6668526ef32eb2116eb92", "patch": "@@ -3,7 +3,7 @@\n use reexport::*;\n use rustc::lint::*;\n use rustc::hir::*;\n-use rustc::ty;\n+use rustc::ty::{self, TyCtxt};\n use semver::Version;\n use syntax::ast::{Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem, NestedMetaItemKind};\n use syntax::codemap::Span;\n@@ -158,22 +158,22 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AttrPass {\n     }\n }\n \n-fn is_relevant_item(tcx: ty::TyCtxt, item: &Item) -> bool {\n+fn is_relevant_item(tcx: TyCtxt, item: &Item) -> bool {\n     if let ItemFn(_, _, _, _, _, eid) = item.node {\n         is_relevant_expr(tcx, tcx.body_tables(eid), &tcx.hir.body(eid).value)\n     } else {\n         false\n     }\n }\n \n-fn is_relevant_impl(tcx: ty::TyCtxt, item: &ImplItem) -> bool {\n+fn is_relevant_impl(tcx: TyCtxt, item: &ImplItem) -> bool {\n     match item.node {\n         ImplItemKind::Method(_, eid) => is_relevant_expr(tcx, tcx.body_tables(eid), &tcx.hir.body(eid).value),\n         _ => false,\n     }\n }\n \n-fn is_relevant_trait(tcx: ty::TyCtxt, item: &TraitItem) -> bool {\n+fn is_relevant_trait(tcx: TyCtxt, item: &TraitItem) -> bool {\n     match item.node {\n         TraitItemKind::Method(_, TraitMethod::Required(_)) => true,\n         TraitItemKind::Method(_, TraitMethod::Provided(eid)) => {\n@@ -183,7 +183,7 @@ fn is_relevant_trait(tcx: ty::TyCtxt, item: &TraitItem) -> bool {\n     }\n }\n \n-fn is_relevant_block(tcx: ty::TyCtxt, tables: &ty::TypeckTables, block: &Block) -> bool {\n+fn is_relevant_block(tcx: TyCtxt, tables: &ty::TypeckTables, block: &Block) -> bool {\n     for stmt in &block.stmts {\n         match stmt.node {\n             StmtDecl(_, _) => return true,\n@@ -196,7 +196,7 @@ fn is_relevant_block(tcx: ty::TyCtxt, tables: &ty::TypeckTables, block: &Block)\n     block.expr.as_ref().map_or(false, |e| is_relevant_expr(tcx, tables, e))\n }\n \n-fn is_relevant_expr(tcx: ty::TyCtxt, tables: &ty::TypeckTables, expr: &Expr) -> bool {\n+fn is_relevant_expr(tcx: TyCtxt, tables: &ty::TypeckTables, expr: &Expr) -> bool {\n     match expr.node {\n         ExprBlock(ref block) => is_relevant_block(tcx, tables, block),\n         ExprRet(Some(ref e)) => is_relevant_expr(tcx, tables, e),"}, {"sha": "c68642da3b6217dc15dd09d81c5b4401695a4795", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e073dfe9a2d53ae24db6668526ef32eb2116eb92/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e073dfe9a2d53ae24db6668526ef32eb2116eb92/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=e073dfe9a2d53ae24db6668526ef32eb2116eb92", "patch": "@@ -5,7 +5,7 @@ use rustc::hir::def::Def;\n use rustc_const_eval::lookup_const_by_id;\n use rustc_const_math::ConstInt;\n use rustc::hir::*;\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, TyCtxt, Ty};\n use rustc::ty::subst::{Substs, Subst};\n use std::cmp::Ordering::{self, Equal};\n use std::cmp::PartialOrd;\n@@ -161,7 +161,7 @@ impl PartialOrd for Constant {\n \n /// parse a `LitKind` to a `Constant`\n #[allow(cast_possible_wrap)]\n-pub fn lit_to_constant<'a, 'tcx>(lit: &LitKind, tcx: TyCtxt<'a, 'tcx, 'tcx>, mut ty: ty::Ty<'tcx>) -> Constant {\n+pub fn lit_to_constant<'a, 'tcx>(lit: &LitKind, tcx: TyCtxt<'a, 'tcx, 'tcx>, mut ty: Ty<'tcx>) -> Constant {\n     use syntax::ast::*;\n     use syntax::ast::LitIntType::*;\n     use rustc::ty::util::IntTypeExt;"}, {"sha": "8764bbfa11bd9f985afc29d9989c2d5150063182", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e073dfe9a2d53ae24db6668526ef32eb2116eb92/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e073dfe9a2d53ae24db6668526ef32eb2116eb92/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=e073dfe9a2d53ae24db6668526ef32eb2116eb92", "patch": "@@ -1,5 +1,5 @@\n use rustc::lint::*;\n-use rustc::ty;\n+use rustc::ty::Ty;\n use rustc::hir::*;\n use std::collections::HashMap;\n use std::collections::hash_map::Entry;\n@@ -251,11 +251,11 @@ fn if_sequence(mut expr: &Expr) -> (SmallVector<&Expr>, SmallVector<&Block>) {\n }\n \n /// Return the list of bindings in a pattern.\n-fn bindings<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat) -> HashMap<InternedString, ty::Ty<'tcx>> {\n+fn bindings<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat) -> HashMap<InternedString, Ty<'tcx>> {\n     fn bindings_impl<'a, 'tcx>(\n         cx: &LateContext<'a, 'tcx>,\n         pat: &Pat,\n-        map: &mut HashMap<InternedString, ty::Ty<'tcx>>\n+        map: &mut HashMap<InternedString, Ty<'tcx>>\n     ) {\n         match pat.node {\n             PatKind::Box(ref pat) |"}, {"sha": "f6642db8fec2e33a64ad93ecbf2cc80527eea144", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e073dfe9a2d53ae24db6668526ef32eb2116eb92/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e073dfe9a2d53ae24db6668526ef32eb2116eb92/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=e073dfe9a2d53ae24db6668526ef32eb2116eb92", "patch": "@@ -1,6 +1,5 @@\n use rustc::lint::*;\n-use rustc::ty::TypeVariants;\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n use rustc::hir::*;\n use syntax::codemap::Span;\n use utils::paths;\n@@ -89,7 +88,7 @@ fn check_hash_peq<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n     span: Span,\n     trait_ref: &TraitRef,\n-    ty: ty::Ty<'tcx>,\n+    ty: Ty<'tcx>,\n     hash_is_automatically_derived: bool\n ) {\n     if_let_chain! {[\n@@ -134,27 +133,27 @@ fn check_hash_peq<'a, 'tcx>(\n }\n \n /// Implementation of the `EXPL_IMPL_CLONE_ON_COPY` lint.\n-fn check_copy_clone<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, item: &Item, trait_ref: &TraitRef, ty: ty::Ty<'tcx>) {\n+fn check_copy_clone<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, item: &Item, trait_ref: &TraitRef, ty: Ty<'tcx>) {\n     if match_path_old(&trait_ref.path, &paths::CLONE_TRAIT) {\n         if !is_copy(cx, ty) {\n             return;\n         }\n \n         match ty.sty {\n-            TypeVariants::TyAdt(def, _) if def.is_union() => return,\n+            ty::TyAdt(def, _) if def.is_union() => return,\n \n             // Some types are not Clone by default but could be cloned \u201cby hand\u201d if necessary\n-            TypeVariants::TyAdt(def, substs) => {\n+            ty::TyAdt(def, substs) => {\n                 for variant in &def.variants {\n                     for field in &variant.fields {\n                         match field.ty(cx.tcx, substs).sty {\n-                            TypeVariants::TyArray(_, size) if size > 32 => {\n+                            ty::TyArray(_, size) if size > 32 => {\n                                 return;\n                             },\n-                            TypeVariants::TyFnPtr(..) => {\n+                            ty::TyFnPtr(..) => {\n                                 return;\n                             },\n-                            TypeVariants::TyTuple(tys, _) if tys.len() > 12 => {\n+                            ty::TyTuple(tys, _) if tys.len() > 12 => {\n                                 return;\n                             },\n                             _ => (),"}, {"sha": "9f32204c437915d3e132e99cea95f726f93f2005", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e073dfe9a2d53ae24db6668526ef32eb2116eb92/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e073dfe9a2d53ae24db6668526ef32eb2116eb92/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=e073dfe9a2d53ae24db6668526ef32eb2116eb92", "patch": "@@ -4,7 +4,7 @@ use rustc::hir::map::Node::{NodeExpr, NodeStmt};\n use rustc::lint::*;\n use rustc::middle::expr_use_visitor::*;\n use rustc::middle::mem_categorization::{cmt, Categorization};\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n use rustc::util::nodemap::NodeSet;\n use syntax::ast::NodeId;\n use syntax::codemap::Span;\n@@ -37,7 +37,7 @@ declare_lint! {\n     \"using `Box<T>` where unnecessary\"\n }\n \n-fn is_non_trait_box(ty: ty::Ty) -> bool {\n+fn is_non_trait_box(ty: Ty) -> bool {\n     ty.is_box() && !ty.boxed_ty().is_trait()\n }\n \n@@ -168,7 +168,7 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> EscapeDelegate<'a, 'tcx> {\n-    fn is_large_box(&self, ty: ty::Ty<'tcx>) -> bool {\n+    fn is_large_box(&self, ty: Ty<'tcx>) -> bool {\n         // Large types need to be boxed to avoid stack\n         // overflows.\n         if ty.is_box() {"}, {"sha": "e7dbc3250f78f75afc2ab5fd772fcf09076d5395", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e073dfe9a2d53ae24db6668526ef32eb2116eb92/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e073dfe9a2d53ae24db6668526ef32eb2116eb92/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=e073dfe9a2d53ae24db6668526ef32eb2116eb92", "patch": "@@ -1,7 +1,7 @@\n use rustc::hir::*;\n use rustc::hir::map::Node::NodeItem;\n use rustc::lint::*;\n-use rustc::ty::TypeVariants;\n+use rustc::ty;\n use syntax::ast::LitKind;\n use syntax::symbol::InternedString;\n use utils::paths;\n@@ -132,7 +132,7 @@ fn check_arg_is_display(cx: &LateContext, expr: &Expr) -> bool {\n     ], {\n         let ty = walk_ptrs_ty(cx.tables.pat_ty(&pat[0]));\n \n-        return ty.sty == TypeVariants::TyStr || match_type(cx, ty, &paths::STRING);\n+        return ty.sty == ty::TyStr || match_type(cx, ty, &paths::STRING);\n     }}\n \n     false"}, {"sha": "eb4708498b6bdcb5851a49b32180ee7f33b4557d", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e073dfe9a2d53ae24db6668526ef32eb2116eb92/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e073dfe9a2d53ae24db6668526ef32eb2116eb92/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=e073dfe9a2d53ae24db6668526ef32eb2116eb92", "patch": "@@ -7,7 +7,7 @@ use rustc::hir::map::Node::NodeBlock;\n use rustc::lint::*;\n use rustc::middle::const_val::ConstVal;\n use rustc::middle::region::CodeExtent;\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n use rustc::ty::subst::Subst;\n use rustc_const_eval::ConstContext;\n use std::collections::HashMap;\n@@ -985,7 +985,7 @@ fn is_ref_iterable_type(cx: &LateContext, e: &Expr) -> bool {\n     match_type(cx, ty, &paths::BTREESET)\n }\n \n-fn is_iterable_array(ty: ty::Ty) -> bool {\n+fn is_iterable_array(ty: Ty) -> bool {\n     // IntoIterator is currently only implemented for array sizes <= 32 in rustc\n     match ty.sty {\n         ty::TyArray(_, 0...32) => true,"}, {"sha": "4ff1b5d0615e6ba3908d26c5112415b382626975", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e073dfe9a2d53ae24db6668526ef32eb2116eb92/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e073dfe9a2d53ae24db6668526ef32eb2116eb92/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=e073dfe9a2d53ae24db6668526ef32eb2116eb92", "patch": "@@ -1,7 +1,7 @@\n use rustc::hir::*;\n use rustc::lint::*;\n use rustc::middle::const_val::ConstVal;\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n use rustc_const_eval::ConstContext;\n use rustc_const_math::ConstInt;\n use std::cmp::Ordering;\n@@ -231,7 +231,7 @@ fn check_single_match_opt_like(\n     ex: &Expr,\n     arms: &[Arm],\n     expr: &Expr,\n-    ty: ty::Ty,\n+    ty: Ty,\n     els: Option<&Expr>\n ) {\n     // list of candidate Enums we know will never get any more members"}, {"sha": "9f662d57379f0df508f6adc19bf5c2723f920773", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e073dfe9a2d53ae24db6668526ef32eb2116eb92/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e073dfe9a2d53ae24db6668526ef32eb2116eb92/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=e073dfe9a2d53ae24db6668526ef32eb2116eb92", "patch": "@@ -1,7 +1,7 @@\n use rustc::hir;\n use rustc::lint::*;\n use rustc::middle::const_val::ConstVal;\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n use rustc::hir::def::Def;\n use rustc_const_eval::ConstContext;\n use std::borrow::Cow;\n@@ -819,7 +819,7 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[hir:\n }\n \n /// Checks for the `CLONE_ON_COPY` lint.\n-fn lint_clone_on_copy(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr, arg_ty: ty::Ty) {\n+fn lint_clone_on_copy(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr, arg_ty: Ty) {\n     let ty = cx.tables.expr_ty(expr);\n     if let ty::TyRef(_, ty::TypeAndMut { ty: inner, .. }) = arg_ty.sty {\n         if let ty::TyRef(..) = inner.sty {\n@@ -977,8 +977,8 @@ fn lint_iter_skip_next(cx: &LateContext, expr: &hir::Expr) {\n     }\n }\n \n-fn derefs_to_slice(cx: &LateContext, expr: &hir::Expr, ty: ty::Ty) -> Option<sugg::Sugg<'static>> {\n-    fn may_slice(cx: &LateContext, ty: ty::Ty) -> bool {\n+fn derefs_to_slice(cx: &LateContext, expr: &hir::Expr, ty: Ty) -> Option<sugg::Sugg<'static>> {\n+    fn may_slice(cx: &LateContext, ty: Ty) -> bool {\n         match ty.sty {\n             ty::TySlice(_) => true,\n             ty::TyAdt(def, _) if def.is_box() => may_slice(cx, ty.boxed_ty()),\n@@ -1251,7 +1251,7 @@ fn lint_single_char_pattern(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr)\n }\n \n /// Given a `Result<T, E>` type, return its error type (`E`).\n-fn get_error_type<'a>(cx: &LateContext, ty: ty::Ty<'a>) -> Option<ty::Ty<'a>> {\n+fn get_error_type<'a>(cx: &LateContext, ty: Ty<'a>) -> Option<Ty<'a>> {\n     if let ty::TyAdt(_, substs) = ty.sty {\n         if match_type(cx, ty, &paths::RESULT) {\n             substs.types().nth(1)\n@@ -1264,7 +1264,7 @@ fn get_error_type<'a>(cx: &LateContext, ty: ty::Ty<'a>) -> Option<ty::Ty<'a>> {\n }\n \n /// This checks whether a given type is known to implement Debug.\n-fn has_debug_impl<'a, 'b>(ty: ty::Ty<'a>, cx: &LateContext<'b, 'a>) -> bool {\n+fn has_debug_impl<'a, 'b>(ty: Ty<'a>, cx: &LateContext<'b, 'a>) -> bool {\n     match cx.tcx.lang_items.debug_trait() {\n         Some(debug) => implements_trait(cx, ty, debug, &[]),\n         None => false,"}, {"sha": "fc3107c3068d8cee621786a4be06734591e428e2", "filename": "clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e073dfe9a2d53ae24db6668526ef32eb2116eb92/clippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e073dfe9a2d53ae24db6668526ef32eb2116eb92/clippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_mut.rs?ref=e073dfe9a2d53ae24db6668526ef32eb2116eb92", "patch": "@@ -1,7 +1,7 @@\n use rustc::hir;\n use rustc::hir::intravisit;\n use rustc::lint::*;\n-use rustc::ty::{TypeAndMut, TyRef};\n+use rustc::ty;\n use utils::{higher, in_external_macro, span_lint};\n \n /// **What it does:** Checks for instances of `mut mut` references.\n@@ -68,7 +68,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for MutVisitor<'a, 'tcx> {\n                           MUT_MUT,\n                           expr.span,\n                           \"generally you want to avoid `&mut &mut _` if possible\");\n-            } else if let TyRef(_, TypeAndMut { mutbl: hir::MutMutable, .. }) = self.cx.tables.expr_ty(e).sty {\n+            } else if let ty::TyRef(_, ty::TypeAndMut { mutbl: hir::MutMutable, .. }) = self.cx.tables.expr_ty(e).sty {\n                 span_lint(self.cx,\n                           MUT_MUT,\n                           expr.span,"}, {"sha": "034e49a016c09a1ed08da904bf36d984ac2b6357", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e073dfe9a2d53ae24db6668526ef32eb2116eb92/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e073dfe9a2d53ae24db6668526ef32eb2116eb92/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=e073dfe9a2d53ae24db6668526ef32eb2116eb92", "patch": "@@ -1,5 +1,5 @@\n use rustc::lint::*;\n-use rustc::ty::{TypeAndMut, TypeVariants, TyS};\n+use rustc::ty::{self, Ty};\n use rustc::ty::subst::Subst;\n use rustc::hir::*;\n use utils::span_lint;\n@@ -55,15 +55,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnecessaryMutPassed {\n     }\n }\n \n-fn check_arguments(cx: &LateContext, arguments: &[Expr], type_definition: &TyS, name: &str) {\n+fn check_arguments(cx: &LateContext, arguments: &[Expr], type_definition: Ty, name: &str) {\n     match type_definition.sty {\n-        TypeVariants::TyFnDef(_, _, fn_type) |\n-        TypeVariants::TyFnPtr(fn_type) => {\n+        ty::TyFnDef(_, _, fn_type) |\n+        ty::TyFnPtr(fn_type) => {\n             let parameters = fn_type.skip_binder().inputs();\n             for (argument, parameter) in arguments.iter().zip(parameters.iter()) {\n                 match parameter.sty {\n-                    TypeVariants::TyRef(_, TypeAndMut { mutbl: MutImmutable, .. }) |\n-                    TypeVariants::TyRawPtr(TypeAndMut { mutbl: MutImmutable, .. }) => {\n+                    ty::TyRef(_, ty::TypeAndMut { mutbl: MutImmutable, .. }) |\n+                    ty::TyRawPtr(ty::TypeAndMut { mutbl: MutImmutable, .. }) => {\n                         if let ExprAddrOf(MutMutable, _) = argument.node {\n                             span_lint(cx,\n                                       UNNECESSARY_MUT_PASSED,"}, {"sha": "085067935a09d3df4daee209d3bfcf555a77d391", "filename": "clippy_lints/src/mutex_atomic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e073dfe9a2d53ae24db6668526ef32eb2116eb92/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e073dfe9a2d53ae24db6668526ef32eb2116eb92/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutex_atomic.rs?ref=e073dfe9a2d53ae24db6668526ef32eb2116eb92", "patch": "@@ -3,7 +3,7 @@\n //! This lint is **warn** by default\n \n use rustc::lint::{LintPass, LintArray, LateLintPass, LateContext};\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n use rustc::hir::Expr;\n use syntax::ast;\n use utils::{match_type, paths, span_lint};\n@@ -59,12 +59,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutexAtomic {\n         let ty = cx.tables.expr_ty(expr);\n         if let ty::TyAdt(_, subst) = ty.sty {\n             if match_type(cx, ty, &paths::MUTEX) {\n-                let mutex_param = &subst.type_at(0).sty;\n+                let mutex_param = subst.type_at(0);\n                 if let Some(atomic_name) = get_atomic_name(mutex_param) {\n                     let msg = format!(\"Consider using an {} instead of a Mutex here. If you just want the locking \\\n                                        behaviour and not the internal type, consider using Mutex<()>.\",\n                                       atomic_name);\n-                    match *mutex_param {\n+                    match mutex_param.sty {\n                         ty::TyUint(t) if t != ast::UintTy::Us => span_lint(cx, MUTEX_INTEGER, expr.span, &msg),\n                         ty::TyInt(t) if t != ast::IntTy::Is => span_lint(cx, MUTEX_INTEGER, expr.span, &msg),\n                         _ => span_lint(cx, MUTEX_ATOMIC, expr.span, &msg),\n@@ -75,8 +75,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutexAtomic {\n     }\n }\n \n-fn get_atomic_name(ty: &ty::TypeVariants) -> Option<(&'static str)> {\n-    match *ty {\n+fn get_atomic_name(ty: Ty) -> Option<(&'static str)> {\n+    match ty.sty {\n         ty::TyBool => Some(\"AtomicBool\"),\n         ty::TyUint(_) => Some(\"AtomicUsize\"),\n         ty::TyInt(_) => Some(\"AtomicIsize\"),"}, {"sha": "da6f635e34ef74408a23945e0d3ffed0c2775773", "filename": "clippy_lints/src/needless_update.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e073dfe9a2d53ae24db6668526ef32eb2116eb92/clippy_lints%2Fsrc%2Fneedless_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e073dfe9a2d53ae24db6668526ef32eb2116eb92/clippy_lints%2Fsrc%2Fneedless_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_update.rs?ref=e073dfe9a2d53ae24db6668526ef32eb2116eb92", "patch": "@@ -1,5 +1,5 @@\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use rustc::ty::TyAdt;\n+use rustc::ty;\n use rustc::hir::{Expr, ExprStruct};\n use utils::span_lint;\n \n@@ -34,7 +34,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprStruct(_, ref fields, Some(ref base)) = expr.node {\n             let ty = cx.tables.expr_ty(expr);\n-            if let TyAdt(def, _) = ty.sty {\n+            if let ty::TyAdt(def, _) = ty.sty {\n                 if fields.len() == def.struct_variant().fields.len() {\n                     span_lint(cx,\n                               NEEDLESS_UPDATE,"}, {"sha": "9cebe4b0be6e1a245f0b1a45ab70c950d5d34163", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e073dfe9a2d53ae24db6668526ef32eb2116eb92/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e073dfe9a2d53ae24db6668526ef32eb2116eb92/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=e073dfe9a2d53ae24db6668526ef32eb2116eb92", "patch": "@@ -2,7 +2,7 @@ use rustc::hir::intravisit::FnKind;\n use rustc::hir::def_id::DefId;\n use rustc::hir;\n use rustc::lint::*;\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n use syntax::ast;\n use syntax::codemap::Span;\n use utils::paths;\n@@ -150,7 +150,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n     }\n }\n \n-fn can_derive_default<'t, 'c>(ty: ty::Ty<'t>, cx: &LateContext<'c, 't>, default_trait_id: DefId) -> Option<Span> {\n+fn can_derive_default<'t, 'c>(ty: Ty<'t>, cx: &LateContext<'c, 't>, default_trait_id: DefId) -> Option<Span> {\n     match ty.sty {\n         ty::TyAdt(adt_def, substs) if adt_def.is_struct() => {\n             for field in adt_def.all_fields() {"}, {"sha": "1d67e06f811828d4386fbb99a40e5cb24d494292", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e073dfe9a2d53ae24db6668526ef32eb2116eb92/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e073dfe9a2d53ae24db6668526ef32eb2116eb92/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=e073dfe9a2d53ae24db6668526ef32eb2116eb92", "patch": "@@ -1,6 +1,5 @@\n use rustc::lint::*;\n-use rustc::ty::TypeVariants::{TyRawPtr, TyRef};\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n use rustc::hir::*;\n use utils::{match_def_path, paths, span_lint, span_lint_and_then, snippet, last_path_segment};\n use utils::sugg;\n@@ -101,7 +100,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                                       e.span,\n                                       &format!(\"transmute from a type (`{}`) to itself\", from_ty))\n                         },\n-                        (&TyRef(_, rty), &TyRawPtr(ptr_ty)) => {\n+                        (&ty::TyRef(_, rty), &ty::TyRawPtr(ptr_ty)) => {\n                             span_lint_and_then(cx,\n                                                USELESS_TRANSMUTE,\n                                                e.span,\n@@ -116,8 +115,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                                                    db.span_suggestion(e.span, \"try\", sugg.to_string());\n                                                })\n                         },\n-                        (&ty::TyInt(_), &TyRawPtr(_)) |\n-                        (&ty::TyUint(_), &TyRawPtr(_)) => {\n+                        (&ty::TyInt(_), &ty::TyRawPtr(_)) |\n+                        (&ty::TyUint(_), &ty::TyRawPtr(_)) => {\n                             span_lint_and_then(cx,\n                                                USELESS_TRANSMUTE,\n                                                e.span,\n@@ -128,32 +127,32 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n                                                                       arg.as_ty(&to_ty.to_string()).to_string());\n                                                })\n                         },\n-                        (&ty::TyFloat(_), &TyRef(..)) |\n-                        (&ty::TyFloat(_), &TyRawPtr(_)) |\n-                        (&ty::TyChar, &TyRef(..)) |\n-                        (&ty::TyChar, &TyRawPtr(_)) => {\n+                        (&ty::TyFloat(_), &ty::TyRef(..)) |\n+                        (&ty::TyFloat(_), &ty::TyRawPtr(_)) |\n+                        (&ty::TyChar, &ty::TyRef(..)) |\n+                        (&ty::TyChar, &ty::TyRawPtr(_)) => {\n                             span_lint(cx,\n                                       WRONG_TRANSMUTE,\n                                       e.span,\n                                       &format!(\"transmute from a `{}` to a pointer\", from_ty))\n                         },\n-                        (&TyRawPtr(from_ptr), _) if from_ptr.ty == to_ty => {\n+                        (&ty::TyRawPtr(from_ptr), _) if from_ptr.ty == to_ty => {\n                             span_lint(cx,\n                                       CROSSPOINTER_TRANSMUTE,\n                                       e.span,\n                                       &format!(\"transmute from a type (`{}`) to the type that it points to (`{}`)\",\n                                                from_ty,\n                                                to_ty))\n                         },\n-                        (_, &TyRawPtr(to_ptr)) if to_ptr.ty == from_ty => {\n+                        (_, &ty::TyRawPtr(to_ptr)) if to_ptr.ty == from_ty => {\n                             span_lint(cx,\n                                       CROSSPOINTER_TRANSMUTE,\n                                       e.span,\n                                       &format!(\"transmute from a type (`{}`) to a pointer to that type (`{}`)\",\n                                                from_ty,\n                                                to_ty))\n                         },\n-                        (&TyRawPtr(from_pty), &TyRef(_, to_rty)) => {\n+                        (&ty::TyRawPtr(from_pty), &ty::TyRef(_, to_rty)) => {\n                             span_lint_and_then(cx,\n                                                TRANSMUTE_PTR_TO_REF,\n                                                e.span,\n@@ -189,7 +188,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n /// Get the snippet of `Bar` in `\u2026::transmute<Foo, &Bar>`. If that snippet is not available , use\n /// the type's `ToString` implementation. In weird cases it could lead to types with invalid `'_`\n /// lifetime, but it should be rare.\n-fn get_type_snippet(cx: &LateContext, path: &QPath, to_rty: ty::Ty) -> String {\n+fn get_type_snippet(cx: &LateContext, path: &QPath, to_rty: Ty) -> String {\n     let seg = last_path_segment(path);\n     if_let_chain!{[\n         let PathParameters::AngleBracketedParameters(ref ang) = seg.parameters,"}, {"sha": "503904d30205fae36ee6e2cae593e38ea9156d53", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e073dfe9a2d53ae24db6668526ef32eb2116eb92/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e073dfe9a2d53ae24db6668526ef32eb2116eb92/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=e073dfe9a2d53ae24db6668526ef32eb2116eb92", "patch": "@@ -1,8 +1,9 @@\n use reexport::*;\n+use rustc::hir;\n use rustc::hir::*;\n use rustc::hir::intravisit::{FnKind, Visitor, walk_ty, NestedVisitorMap};\n use rustc::lint::*;\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n use std::cmp::Ordering;\n use syntax::ast::{IntTy, UintTy, FloatTy};\n use syntax::attr::IntType;\n@@ -106,7 +107,7 @@ fn check_fn_decl(cx: &LateContext, decl: &FnDecl) {\n     }\n }\n \n-fn check_ty(cx: &LateContext, ast_ty: &Ty) {\n+fn check_ty(cx: &LateContext, ast_ty: &hir::Ty) {\n     if in_macro(ast_ty.span) {\n         return;\n     }\n@@ -398,7 +399,7 @@ declare_lint! {\n \n /// Returns the size in bits of an integral type.\n /// Will return 0 if the type is not an int or uint variant\n-fn int_ty_to_nbits(typ: &ty::TyS) -> usize {\n+fn int_ty_to_nbits(typ: Ty) -> usize {\n     let n = match typ.sty {\n         ty::TyInt(i) => 4 << (i as usize),\n         ty::TyUint(u) => 4 << (u as usize),\n@@ -412,15 +413,15 @@ fn int_ty_to_nbits(typ: &ty::TyS) -> usize {\n     }\n }\n \n-fn is_isize_or_usize(typ: &ty::TyS) -> bool {\n+fn is_isize_or_usize(typ: Ty) -> bool {\n     match typ.sty {\n         ty::TyInt(IntTy::Is) |\n         ty::TyUint(UintTy::Us) => true,\n         _ => false,\n     }\n }\n \n-fn span_precision_loss_lint(cx: &LateContext, expr: &Expr, cast_from: &ty::TyS, cast_to_f64: bool) {\n+fn span_precision_loss_lint(cx: &LateContext, expr: &Expr, cast_from: Ty, cast_to_f64: bool) {\n     let mantissa_nbits = if cast_to_f64 { 52 } else { 23 };\n     let arch_dependent = is_isize_or_usize(cast_from) && cast_to_f64;\n     let arch_dependent_str = \"on targets with 64-bit wide pointers \";\n@@ -453,7 +454,7 @@ enum ArchSuffix {\n     None,\n }\n \n-fn check_truncation_and_wrapping(cx: &LateContext, expr: &Expr, cast_from: &ty::TyS, cast_to: &ty::TyS) {\n+fn check_truncation_and_wrapping(cx: &LateContext, expr: &Expr, cast_from: Ty, cast_to: Ty) {\n     let arch_64_suffix = \" on targets with 64-bit wide pointers\";\n     let arch_32_suffix = \" on targets with 32-bit wide pointers\";\n     let cast_unsigned_to_signed = !cast_from.is_signed() && cast_to.is_signed();\n@@ -693,7 +694,7 @@ impl<'a, 'tcx> TypeComplexityPass {\n         }\n     }\n \n-    fn check_type(&self, cx: &LateContext, ty: &Ty) {\n+    fn check_type(&self, cx: &LateContext, ty: &hir::Ty) {\n         if in_macro(ty.span) {\n             return;\n         }\n@@ -724,7 +725,7 @@ struct TypeComplexityVisitor {\n }\n \n impl<'tcx> Visitor<'tcx> for TypeComplexityVisitor {\n-    fn visit_ty(&mut self, ty: &'tcx Ty) {\n+    fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         let (add_score, sub_nest) = match ty.node {\n             // _, &x and *x have only small overhead; don't mess with nesting level\n             TyInfer | TyPtr(..) | TyRptr(..) => (1, 0),\n@@ -1070,7 +1071,6 @@ impl Ord for FullInt {\n \n \n fn numeric_cast_precast_bounds<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(FullInt, FullInt)> {\n-    use rustc::ty::TypeVariants::{TyInt, TyUint};\n     use syntax::ast::{IntTy, UintTy};\n     use std::*;\n \n@@ -1082,7 +1082,7 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(\n             return None;\n         }\n         match pre_cast_ty.sty {\n-            TyInt(int_ty) => {\n+            ty::TyInt(int_ty) => {\n                 Some(match int_ty {\n                     IntTy::I8 => (FullInt::S(i8::min_value() as i128), FullInt::S(i8::max_value() as i128)),\n                     IntTy::I16 => (FullInt::S(i16::min_value() as i128), FullInt::S(i16::max_value() as i128)),\n@@ -1092,7 +1092,7 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(\n                     IntTy::Is => (FullInt::S(isize::min_value() as i128), FullInt::S(isize::max_value() as i128)),\n                 })\n             },\n-            TyUint(uint_ty) => {\n+            ty::TyUint(uint_ty) => {\n                 Some(match uint_ty {\n                     UintTy::U8 => (FullInt::U(u8::min_value() as u128), FullInt::U(u8::max_value() as u128)),\n                     UintTy::U16 => (FullInt::U(u16::min_value() as u128), FullInt::U(u16::max_value() as u128)),"}, {"sha": "5820f600434883a74962746d2d596cad202be9ca", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e073dfe9a2d53ae24db6668526ef32eb2116eb92/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e073dfe9a2d53ae24db6668526ef32eb2116eb92/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=e073dfe9a2d53ae24db6668526ef32eb2116eb92", "previous_filename": "clippy_lints/src/utils/hir.rs"}, {"sha": "34c514360b68036d1eea2abd827e52b18c9e9875", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e073dfe9a2d53ae24db6668526ef32eb2116eb92/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e073dfe9a2d53ae24db6668526ef32eb2116eb92/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=e073dfe9a2d53ae24db6668526ef32eb2116eb92", "patch": "@@ -1,12 +1,13 @@\n use reexport::*;\n+use rustc::hir;\n use rustc::hir::*;\n use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc::hir::def::Def;\n use rustc::hir::map::Node;\n use rustc::lint::{LintContext, LateContext, Level, Lint};\n use rustc::session::Session;\n use rustc::traits;\n-use rustc::ty;\n+use rustc::ty::{self, TyCtxt, Ty};\n use rustc::mir::transform::MirSource;\n use rustc_errors;\n use std::borrow::Cow;\n@@ -23,12 +24,12 @@ use syntax::symbol::keywords;\n pub mod comparisons;\n pub mod conf;\n pub mod constants;\n-mod hir;\n+mod hir_utils;\n pub mod paths;\n pub mod sugg;\n pub mod inspector;\n pub mod internal_lints;\n-pub use self::hir::{SpanlessEq, SpanlessHash};\n+pub use self::hir_utils::{SpanlessEq, SpanlessHash};\n \n pub type MethodArgs = HirVec<P<Expr>>;\n \n@@ -146,7 +147,7 @@ pub fn in_external_macro<'a, T: LintContext<'a>>(cx: &T, span: Span) -> bool {\n /// ```\n ///\n /// See also the `paths` module.\n-pub fn match_def_path(tcx: ty::TyCtxt, def_id: DefId, path: &[&str]) -> bool {\n+pub fn match_def_path(tcx: TyCtxt, def_id: DefId, path: &[&str]) -> bool {\n     use syntax::symbol;\n \n     struct AbsolutePathBuffer {\n@@ -172,7 +173,7 @@ pub fn match_def_path(tcx: ty::TyCtxt, def_id: DefId, path: &[&str]) -> bool {\n }\n \n /// Check if type is struct, enum or union type with given def path.\n-pub fn match_type(cx: &LateContext, ty: ty::Ty, path: &[&str]) -> bool {\n+pub fn match_type(cx: &LateContext, ty: Ty, path: &[&str]) -> bool {\n     match ty.sty {\n         ty::TyAdt(adt, _) => match_def_path(cx.tcx, adt.did, path),\n         _ => false,\n@@ -308,9 +309,9 @@ pub fn get_trait_def_id(cx: &LateContext, path: &[&str]) -> Option<DefId> {\n /// See also `get_trait_def_id`.\n pub fn implements_trait<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    ty: ty::Ty<'tcx>,\n+    ty: Ty<'tcx>,\n     trait_id: DefId,\n-    ty_params: &[ty::Ty<'tcx>]\n+    ty_params: &[Ty<'tcx>]\n ) -> bool {\n     let ty = cx.tcx.erase_regions(&ty);\n     let obligation = cx.tcx.predicate_for_trait_def(\n@@ -581,16 +582,16 @@ pub fn multispan_sugg(db: &mut DiagnosticBuilder, help_msg: String, sugg: Vec<(S\n }\n \n /// Return the base type for references and raw pointers.\n-pub fn walk_ptrs_ty(ty: ty::Ty) -> ty::Ty {\n+pub fn walk_ptrs_ty(ty: Ty) -> Ty {\n     match ty.sty {\n         ty::TyRef(_, ref tm) => walk_ptrs_ty(tm.ty),\n         _ => ty,\n     }\n }\n \n /// Return the base type for references and raw pointers, and count reference depth.\n-pub fn walk_ptrs_ty_depth(ty: ty::Ty) -> (ty::Ty, usize) {\n-    fn inner(ty: ty::Ty, depth: usize) -> (ty::Ty, usize) {\n+pub fn walk_ptrs_ty_depth(ty: Ty) -> (Ty, usize) {\n+    fn inner(ty: Ty, depth: usize) -> (Ty, usize) {\n         match ty.sty {\n             ty::TyRef(_, ref tm) => inner(tm.ty, depth + 1),\n             _ => (ty, depth),\n@@ -754,7 +755,7 @@ pub fn camel_case_from(s: &str) -> usize {\n }\n \n /// Convenience function to get the return type of a function\n-pub fn return_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, fn_item: NodeId) -> ty::Ty<'tcx> {\n+pub fn return_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, fn_item: NodeId) -> Ty<'tcx> {\n     let fn_def_id = cx.tcx.hir.local_def_id(fn_item);\n     let ret_ty = cx.tcx.type_of(fn_def_id).fn_sig().output();\n     cx.tcx.erase_late_bound_regions(&ret_ty)\n@@ -765,24 +766,24 @@ pub fn return_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, fn_item: NodeId) -> ty::T\n // not for type parameters.\n pub fn same_tys<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    a: ty::Ty<'tcx>,\n-    b: ty::Ty<'tcx>\n+    a: Ty<'tcx>,\n+    b: Ty<'tcx>\n ) -> bool {\n     cx.tcx.infer_ctxt().enter(|infcx| {\n         infcx.can_eq(cx.param_env, a, b).is_ok()\n     })\n }\n \n /// Return whether the given type is an `unsafe` function.\n-pub fn type_is_unsafe_function(ty: ty::Ty) -> bool {\n+pub fn type_is_unsafe_function(ty: Ty) -> bool {\n     match ty.sty {\n         ty::TyFnDef(_, _, f) |\n         ty::TyFnPtr(f) => f.unsafety() == Unsafety::Unsafe,\n         _ => false,\n     }\n }\n \n-pub fn is_copy<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: ty::Ty<'tcx>) -> bool {\n+pub fn is_copy<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n     !ty.moves_by_default(cx.tcx.global_tcx(), cx.param_env, DUMMY_SP)\n }\n \n@@ -885,7 +886,7 @@ pub fn is_self(slf: &Arg) -> bool {\n     }\n }\n \n-pub fn is_self_ty(slf: &Ty) -> bool {\n+pub fn is_self_ty(slf: &hir::Ty) -> bool {\n     if_let_chain! {[\n         let TyPath(ref qp) = slf.node,\n         let QPath::Resolved(None, ref path) = *qp,\n@@ -944,6 +945,6 @@ pub fn is_try(expr: &Expr) -> Option<&Expr> {\n     None\n }\n \n-pub fn type_size<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: ty::Ty<'tcx>) -> Option<u64> {\n+pub fn type_size<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'tcx>) -> Option<u64> {\n     ty.layout(cx.tcx, cx.param_env).ok().map(|layout| layout.size(cx.tcx).bytes())\n }"}, {"sha": "3c672b22ee606b6011def88d1b84c743d908ed65", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e073dfe9a2d53ae24db6668526ef32eb2116eb92/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e073dfe9a2d53ae24db6668526ef32eb2116eb92/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=e073dfe9a2d53ae24db6668526ef32eb2116eb92", "patch": "@@ -1,6 +1,6 @@\n use rustc::hir::*;\n use rustc::lint::*;\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n use rustc_const_eval::ConstContext;\n use syntax::codemap::Span;\n use utils::{higher, is_copy, snippet, span_lint_and_then};\n@@ -35,8 +35,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         // search for `&vec![_]` expressions where the adjusted type is `&[_]`\n         if_let_chain!{[\n-            let ty::TypeVariants::TyRef(_, ref ty) = cx.tables.expr_ty_adjusted(expr).sty,\n-            let ty::TypeVariants::TySlice(..) = ty.ty.sty,\n+            let ty::TyRef(_, ref ty) = cx.tables.expr_ty_adjusted(expr).sty,\n+            let ty::TySlice(..) = ty.ty.sty,\n             let ExprAddrOf(_, ref addressee) = expr.node,\n             let Some(vec_args) = higher::vec_macro(cx, addressee),\n         ], {\n@@ -88,7 +88,7 @@ fn check_vec_macro(cx: &LateContext, vec_args: &higher::VecArgs, span: Span) {\n }\n \n /// Return the item type of the vector (ie. the `T` in `Vec<T>`).\n-fn vec_type(ty: ty::Ty) -> ty::Ty {\n+fn vec_type(ty: Ty) -> Ty {\n     if let ty::TyAdt(_, substs) = ty.sty {\n         substs.type_at(0)\n     } else {"}]}