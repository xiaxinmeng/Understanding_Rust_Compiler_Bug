{"sha": "578b7266f235e7563cea6f509f617d0a3cf28277", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3OGI3MjY2ZjIzNWU3NTYzY2VhNmY1MDlmNjE3ZDBhM2NmMjgyNzc=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-17T19:41:34Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-17T19:42:45Z"}, "message": "rustc: Encode reexports in the metadata and don't have each_path search tag_paths", "tree": {"sha": "346009d1fd2172b1aec774c8baccaf7e325d34d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/346009d1fd2172b1aec774c8baccaf7e325d34d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/578b7266f235e7563cea6f509f617d0a3cf28277", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/578b7266f235e7563cea6f509f617d0a3cf28277", "html_url": "https://github.com/rust-lang/rust/commit/578b7266f235e7563cea6f509f617d0a3cf28277", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/578b7266f235e7563cea6f509f617d0a3cf28277/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7bae3449ce5113596c7cdbd1df3d27bdbd0cd777", "url": "https://api.github.com/repos/rust-lang/rust/commits/7bae3449ce5113596c7cdbd1df3d27bdbd0cd777", "html_url": "https://github.com/rust-lang/rust/commit/7bae3449ce5113596c7cdbd1df3d27bdbd0cd777"}], "stats": {"total": 228, "additions": 161, "deletions": 67}, "files": [{"sha": "1fe4c5085bc7d1b772962cef146d31f7395ea3de", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/578b7266f235e7563cea6f509f617d0a3cf28277/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578b7266f235e7563cea6f509f617d0a3cf28277/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=578b7266f235e7563cea6f509f617d0a3cf28277", "patch": "@@ -176,6 +176,7 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n \n     let { def_map: def_map,\n           exp_map: exp_map,\n+          exp_map2: exp_map2,\n           impl_map: impl_map,\n           trait_map: trait_map } =\n         time(time_passes, ~\"resolution\", ||\n@@ -238,7 +239,7 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n \n     let (llmod, link_meta) = time(time_passes, ~\"translation\", ||\n         trans::base::trans_crate(sess, crate, ty_cx, outputs.obj_filename,\n-                                 exp_map, maps));\n+                                 exp_map, exp_map2, maps));\n \n     time(time_passes, ~\"LLVM passes\", ||\n         link::write::run_passes(sess, llmod, outputs.obj_filename));"}, {"sha": "0744430b8444bb981d53cdcaabedc94e01cc55cc", "filename": "src/rustc/metadata.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/578b7266f235e7563cea6f509f617d0a3cf28277/src%2Frustc%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578b7266f235e7563cea6f509f617d0a3cf28277/src%2Frustc%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata.rs?ref=578b7266f235e7563cea6f509f617d0a3cf28277", "patch": "@@ -5,6 +5,8 @@\n mod middle {\n     import ty = middle_::ty;\n     export ty;\n+    import resolve3 = middle_::resolve3;\n+    export resolve3;\n }\n \n mod front {"}, {"sha": "d65fa3a617f40456cd11a0544eee19e3f5c8fb53", "filename": "src/rustc/metadata/common.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/578b7266f235e7563cea6f509f617d0a3cf28277/src%2Frustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578b7266f235e7563cea6f509f617d0a3cf28277/src%2Frustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcommon.rs?ref=578b7266f235e7563cea6f509f617d0a3cf28277", "patch": "@@ -100,6 +100,12 @@ const tag_paths_foreign_path: uint = 0x4a;\n const tag_item_trait_method_self_ty: uint = 0x4b;\n const tag_item_trait_method_self_ty_region: uint = 0x4c;\n \n+// Reexports are found within module tags. Each reexport contains def_ids\n+// and names.\n+const tag_items_data_item_reexport: uint = 0x4d;\n+const tag_items_data_item_reexport_def_id: uint = 0x4e;\n+const tag_items_data_item_reexport_name: uint = 0x4f;\n+\n // used to encode crate_ctxt side tables\n enum astencode_tag { // Reserves 0x50 -- 0x6f\n     tag_ast = 0x50,\n@@ -115,15 +121,15 @@ enum astencode_tag { // Reserves 0x50 -- 0x6f\n     tag_table_node_type = 0x57,\n     tag_table_node_type_subst = 0x58,\n     tag_table_freevars = 0x59,\n-    tag_table_tcache,\n-    tag_table_param_bounds,\n-    tag_table_inferred_modes,\n-    tag_table_mutbl,\n-    tag_table_last_use,\n-    tag_table_spill,\n-    tag_table_method_map,\n-    tag_table_vtable_map,\n-    tag_table_borrowings\n+    tag_table_tcache = 0x5a,\n+    tag_table_param_bounds = 0x5b,\n+    tag_table_inferred_modes = 0x5c,\n+    tag_table_mutbl = 0x5d,\n+    tag_table_last_use = 0x5e,\n+    tag_table_spill = 0x5f,\n+    tag_table_method_map = 0x60,\n+    tag_table_vtable_map = 0x61,\n+    tag_table_borrowings = 0x62\n }\n \n // djb's cdb hashes."}, {"sha": "3c917e8b3d5febead4137fb39d371647897e1e68", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 55, "deletions": 50, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/578b7266f235e7563cea6f509f617d0a3cf28277/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578b7266f235e7563cea6f509f617d0a3cf28277/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=578b7266f235e7563cea6f509f617d0a3cf28277", "patch": "@@ -127,6 +127,14 @@ fn item_def_id(d: ebml::doc, cdata: cmd) -> ast::def_id {\n                                                     |d| parse_def_id(d)));\n }\n \n+fn each_reexport(d: ebml::doc, f: fn(ebml::doc) -> bool) {\n+    for ebml::tagged_docs(d, tag_items_data_item_reexport) |reexport_doc| {\n+        if !f(reexport_doc) {\n+            return;\n+        }\n+    }\n+}\n+\n fn field_mutability(d: ebml::doc) -> ast::class_mutability {\n     // Use maybe_get_doc in case it's a method\n     option::map_default(\n@@ -426,76 +434,73 @@ fn each_path(cdata: cmd, f: fn(path_entry) -> bool) {\n     // First, go through all the explicit items.\n     for ebml::tagged_docs(items_data, tag_items_data_item) |item_doc| {\n         if !broken {\n-            let name = ast_map::path_to_str_with_sep(item_path(item_doc),\n+            let path = ast_map::path_to_str_with_sep(item_path(item_doc),\n                                                      ~\"::\");\n-            if name != ~\"\" {\n+            if path != ~\"\" {\n                 // Extract the def ID.\n                 let def_id = item_def_id(item_doc, cdata);\n \n                 // Construct the def for this item.\n-                debug!{\"(each_path) yielding explicit item: %s\", name};\n+                debug!{\"(each_path) yielding explicit item: %s\", path};\n                 let def_like = item_to_def_like(item_doc, def_id, cdata.cnum);\n \n                 // Hand the information off to the iteratee.\n-                let this_path_entry = path_entry(name, def_like);\n+                let this_path_entry = path_entry(path, def_like);\n                 if !f(this_path_entry) {\n                     broken = true;      // XXX: This is awful.\n                 }\n             }\n-        }\n-    }\n-\n-    // If broken, stop here.\n-    if broken {\n-        return;\n-    }\n-\n-    // Next, go through all the paths. We will find items that we didn't know\n-    // about before (reexports in particular).\n-    //\n-    // XXX: This is broken; the paths are actually hierarchical.\n \n-    let outer_paths = ebml::get_doc(root, tag_paths);\n-    let inner_paths = ebml::get_doc(outer_paths, tag_paths);\n-\n-    fn g(cdata: cmd, items: ebml::doc, path_doc: ebml::doc, &broken: bool,\n-         f: fn(path_entry) -> bool) {\n-\n-        if !broken {\n-            let path = item_name(path_doc);\n-\n-            // Extract the def ID.\n-            let def_id = item_def_id(path_doc, cdata);\n+            // If this is a module, find the reexports.\n+            for each_reexport(item_doc) |reexport_doc| {\n+                if !broken {\n+                    let def_id_doc =\n+                        ebml::get_doc(reexport_doc,\n+                            tag_items_data_item_reexport_def_id);\n+                    let def_id =\n+                        ebml::with_doc_data(def_id_doc, |d| parse_def_id(d));\n+                    let def_id = translate_def_id(cdata, def_id);\n+\n+                    let reexport_name_doc =\n+                        ebml::get_doc(reexport_doc,\n+                                      tag_items_data_item_reexport_name);\n+                    let reexport_name = ebml::doc_as_str(reexport_name_doc);\n+\n+                    let reexport_path;\n+                    if path == ~\"\" {\n+                        reexport_path = reexport_name;\n+                    } else {\n+                        reexport_path = path + ~\"::\" + reexport_name;\n+                    }\n \n-            // Get the item.\n-            match maybe_find_item(def_id.node, items) {\n-                none => {\n-                    debug!{\"(each_path) ignoring implicit item: %s\",\n-                            *path};\n-                }\n-                some(item_doc) => {\n-                    // Construct the def for this item.\n-                    let def_like = item_to_def_like(item_doc, def_id,\n-                                                    cdata.cnum);\n-\n-                    // Hand the information off to the iteratee.\n-                    debug!{\"(each_path) yielding implicit item: %s\",\n-                            *path};\n-                    let this_path_entry = path_entry(*path, def_like);\n-                    if (!f(this_path_entry)) {\n-                        broken = true;      // XXX: This is awful.\n+                    // Get the item.\n+                    match maybe_find_item(def_id.node, items) {\n+                        none => {}\n+                        some(item_doc) => {\n+                            // Construct the def for this item.\n+                            let def_like = item_to_def_like(item_doc,\n+                                                            def_id,\n+                                                            cdata.cnum);\n+\n+                            // Hand the information off to the iteratee.\n+                            debug!(\"(each_path) yielding reexported \\\n+                                    item: %s\", reexport_path);\n+\n+                            let this_path_entry =\n+                                path_entry(reexport_path, def_like);\n+                            if (!f(this_path_entry)) {\n+                                broken = true;  // XXX: This is awful.\n+                            }\n+                        }\n                     }\n                 }\n             }\n         }\n     }\n \n-    for ebml::tagged_docs(inner_paths, tag_paths_data_item) |path_doc| {\n-        g(cdata, items, path_doc, broken, f);\n-    }\n-\n-    for ebml::tagged_docs(inner_paths, tag_paths_foreign_path) |path_doc| {\n-        g(cdata, items, path_doc, broken, f);\n+    // If broken, stop here.\n+    if broken {\n+        return;\n     }\n }\n "}, {"sha": "13ca2f5be17abc6d21fa0517f280c1293f3b3853", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/578b7266f235e7563cea6f509f617d0a3cf28277/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578b7266f235e7563cea6f509f617d0a3cf28277/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=578b7266f235e7563cea6f509f617d0a3cf28277", "patch": "@@ -13,6 +13,7 @@ import syntax::ast_util::*;\n import common::*;\n import middle::ty;\n import middle::ty::node_id_to_type;\n+import middle::resolve3;\n import syntax::ast_map;\n import syntax::attr;\n import std::serialization::serializer;\n@@ -44,6 +45,7 @@ type encode_parms = {\n     tcx: ty::ctxt,\n     reachable: hashmap<ast::node_id, ()>,\n     reexports: ~[(~str, def_id)],\n+    reexports2: middle::resolve3::ExportMap2,\n     impl_map: fn@(ast::node_id) -> ~[(ident, def_id)],\n     item_symbols: hashmap<ast::node_id, ~str>,\n     discrim_symbols: hashmap<ast::node_id, ~str>,\n@@ -57,6 +59,7 @@ enum encode_ctxt = {\n     tcx: ty::ctxt,\n     reachable: hashmap<ast::node_id, ()>,\n     reexports: ~[(~str, def_id)],\n+    reexports2: middle::resolve3::ExportMap2,\n     impl_map: fn@(ast::node_id) -> ~[(ident, def_id)],\n     item_symbols: hashmap<ast::node_id, ~str>,\n     discrim_symbols: hashmap<ast::node_id, ~str>,\n@@ -278,7 +281,7 @@ fn encode_trait_ref(ebml_w: ebml::writer, ecx: @encode_ctxt, t: @trait_ref) {\n }\n \n fn encode_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt, crate: @crate)\n-    -> ~[entry<~str>] {\n+                  -> ~[entry<~str>] {\n     let mut index: ~[entry<~str>] = ~[];\n     let mut path: ~[ident] = ~[];\n     ebml_w.start_tag(tag_paths);\n@@ -478,6 +481,31 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml::writer, md: _mod,\n     } // for\n \n     encode_path(ebml_w, path, ast_map::path_mod(name));\n+\n+    // Encode the reexports of this module.\n+    debug!(\"(encoding info for module) encoding reexports for %d\", id);\n+    match ecx.reexports2.find(id) {\n+        some(exports) => {\n+            debug!(\"(encoding info for module) found reexports for %d\", id);\n+            for exports.each |exp| {\n+                debug!(\"(encoding info for module) reexport '%s' for %d\",\n+                       exp.name, id);\n+                ebml_w.start_tag(tag_items_data_item_reexport);\n+                ebml_w.start_tag(tag_items_data_item_reexport_def_id);\n+                ebml_w.wr_str(def_to_str(exp.def_id));\n+                ebml_w.end_tag();\n+                ebml_w.start_tag(tag_items_data_item_reexport_name);\n+                ebml_w.wr_str(exp.name);\n+                ebml_w.end_tag();\n+                ebml_w.end_tag();\n+            }\n+        }\n+        none => {\n+            debug!(\"(encoding info for module) found no reexports for %d\",\n+                   id);\n+        }\n+    }\n+\n     ebml_w.end_tag();\n }\n \n@@ -1228,6 +1256,7 @@ fn encode_metadata(parms: encode_parms, crate: @crate) -> ~[u8] {\n         tcx: parms.tcx,\n         reachable: parms.reachable,\n         reexports: parms.reexports,\n+        reexports2: parms.reexports2,\n         impl_map: parms.impl_map,\n         item_symbols: parms.item_symbols,\n         discrim_symbols: parms.discrim_symbols,"}, {"sha": "9e6afc266b80cd814af92fee8c8d28a9bd5d6271", "filename": "src/rustc/middle/resolve3.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/578b7266f235e7563cea6f509f617d0a3cf28277/src%2Frustc%2Fmiddle%2Fresolve3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578b7266f235e7563cea6f509f617d0a3cf28277/src%2Frustc%2Fmiddle%2Fresolve3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve3.rs?ref=578b7266f235e7563cea6f509f617d0a3cf28277", "patch": "@@ -96,6 +96,16 @@ type TraitMap = @hashmap<node_id,@DVec<def_id>>;\n type Export = { reexp: bool, id: def_id };\n type ExportMap = hashmap<node_id, ~[Export]>;\n \n+// This is the replacement export map. It maps a module to all of the exports\n+// within.\n+type ExportMap2 = hashmap<node_id, ~[Export2]>;\n+\n+struct Export2 {\n+    name: ~str;         // The name of the target.\n+    def_id: def_id;     // The definition of the target.\n+    reexport: bool;     // Whether this is a reexport.\n+}\n+\n enum PatternBindingMode {\n     RefutableMode,\n     IrrefutableMode\n@@ -701,6 +711,7 @@ struct Resolver {\n     let def_map: DefMap;\n     let impl_map: ImplMap;\n     let export_map: ExportMap;\n+    let export_map2: ExportMap2;\n     let trait_map: TraitMap;\n \n     new(session: session, lang_items: LanguageItems, crate: @crate) {\n@@ -741,6 +752,7 @@ struct Resolver {\n         self.def_map = int_hash();\n         self.impl_map = int_hash();\n         self.export_map = int_hash();\n+        self.export_map2 = int_hash();\n         self.trait_map = @int_hash();\n     }\n \n@@ -2734,6 +2746,7 @@ struct Resolver {\n     }\n \n     fn record_exports_for_module(module_: @Module) {\n+        let mut exports2 = ~[];\n         for module_.exported_names.each |name, node_id| {\n             let mut exports = ~[];\n             for self.namespaces.each |namespace| {\n@@ -2752,22 +2765,49 @@ struct Resolver {\n                         // Nothing to do.\n                     }\n                     ChildNameDefinition(target_def) => {\n+                        debug!(\"(computing exports) found child export '%s' \\\n+                                for %?\",\n+                               *self.atom_table.atom_to_str(name),\n+                               module_.def_id);\n                         vec::push(exports, {\n                             reexp: false,\n                             id: def_id_of_def(target_def)\n                         });\n+                        vec::push(exports2, Export2 {\n+                            reexport: false,\n+                            name: copy *self.atom_table.atom_to_str(name),\n+                            def_id: def_id_of_def(target_def)\n+                        });\n                     }\n                     ImportNameDefinition(target_def) => {\n+                        debug!(\"(computing exports) found reexport '%s' for \\\n+                                %?\",\n+                               *self.atom_table.atom_to_str(name),\n+                               module_.def_id);\n                         vec::push(exports, {\n                             reexp: true,\n                             id: def_id_of_def(target_def)\n                         });\n+                        vec::push(exports2, Export2 {\n+                            reexport: true,\n+                            name: copy *self.atom_table.atom_to_str(name),\n+                            def_id: def_id_of_def(target_def)\n+                        });\n                     }\n                 }\n             }\n \n             self.export_map.insert(node_id, exports);\n         }\n+\n+        match copy module_.def_id {\n+            some(def_id) => {\n+                self.export_map2.insert(def_id.node, move exports2);\n+                debug!(\"(computing exports) writing exports for %d (some)\",\n+                       def_id.node);\n+            }\n+            none => {}\n+        }\n     }\n \n     // Implementation scope creation\n@@ -4846,6 +4886,7 @@ struct Resolver {\n fn resolve_crate(session: session, lang_items: LanguageItems, crate: @crate)\n               -> { def_map: DefMap,\n                    exp_map: ExportMap,\n+                   exp_map2: ExportMap2,\n                    impl_map: ImplMap,\n                    trait_map: TraitMap } {\n \n@@ -4854,6 +4895,7 @@ fn resolve_crate(session: session, lang_items: LanguageItems, crate: @crate)\n     return {\n         def_map: resolver.def_map,\n         exp_map: resolver.export_map,\n+        exp_map2: resolver.export_map2,\n         impl_map: resolver.impl_map,\n         trait_map: resolver.trait_map\n     };"}, {"sha": "6e1f2e79805086a6703a09d3dad741dc99e65afe", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/578b7266f235e7563cea6f509f617d0a3cf28277/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578b7266f235e7563cea6f509f617d0a3cf28277/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=578b7266f235e7563cea6f509f617d0a3cf28277", "patch": "@@ -5648,6 +5648,7 @@ fn crate_ctxt_to_encode_parms(cx: @crate_ctxt)\n         tcx: cx.tcx,\n         reachable: cx.reachable,\n         reexports: reexports(cx),\n+        reexports2: cx.exp_map2,\n         impl_map: |a| impl_map(cx, a),\n         item_symbols: cx.item_symbols,\n         discrim_symbols: cx.discrim_symbols,\n@@ -5662,9 +5663,10 @@ fn crate_ctxt_to_encode_parms(cx: @crate_ctxt)\n             for defs.each |def| {\n                 if !def.reexp { again; }\n                 let path = match check cx.tcx.items.get(exp_id) {\n-                  ast_map::node_export(_, path) => {\n-                    ast_map::path_to_str(*path)\n-                  }\n+                    ast_map::node_export(_, path) => {\n+\n+                        ast_map::path_to_str(*path)\n+                    }\n                 };\n                 vec::push(reexports, (path, def.id));\n             }\n@@ -5711,10 +5713,15 @@ fn write_abi_version(ccx: @crate_ctxt) {\n                      false);\n }\n \n-fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n-               output: ~str, emap: resolve3::ExportMap,\n+fn trans_crate(sess: session::session,\n+               crate: @ast::crate,\n+               tcx: ty::ctxt,\n+               output: ~str,\n+               emap: resolve3::ExportMap,\n+               emap2: resolve3::ExportMap2,\n                maps: astencode::maps)\n-    -> (ModuleRef, link_meta) {\n+            -> (ModuleRef, link_meta) {\n+\n     let symbol_hasher = @hash::default_state();\n     let link_meta =\n         link::build_link_meta(sess, *crate, output, symbol_hasher);\n@@ -5773,6 +5780,7 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n           intrinsics: intrinsics,\n           item_vals: int_hash::<ValueRef>(),\n           exp_map: emap,\n+          exp_map2: emap2,\n           reachable: reachable,\n           item_symbols: int_hash::<~str>(),\n           mut main_fn: none::<ValueRef>,"}, {"sha": "7930b596217a75d34dc454a6f10e49a9298440cf", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/578b7266f235e7563cea6f509f617d0a3cf28277/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/578b7266f235e7563cea6f509f617d0a3cf28277/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=578b7266f235e7563cea6f509f617d0a3cf28277", "patch": "@@ -88,6 +88,7 @@ type crate_ctxt = {\n      intrinsics: hashmap<~str, ValueRef>,\n      item_vals: hashmap<ast::node_id, ValueRef>,\n      exp_map: resolve3::ExportMap,\n+     exp_map2: resolve3::ExportMap2,\n      reachable: reachable::map,\n      item_symbols: hashmap<ast::node_id, ~str>,\n      mut main_fn: option<ValueRef>,"}]}