{"sha": "54b8d5f1abeb71808aa1e55830c7463a48ee59bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0YjhkNWYxYWJlYjcxODA4YWExZTU1ODMwYzc0NjNhNDhlZTU5YmM=", "commit": {"author": {"name": "Zack Corr", "email": "zackcorr95@gmail.com", "date": "2012-06-02T06:25:56Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-06-03T03:54:38Z"}, "message": "Cargo revamp: root in home directory, automatic init & sync for first time usage, uninstallation, improved installation usage and other usage changes. Closes #2475. Closes #1353.", "tree": {"sha": "96cb07a406c2841173cfc1de6b7f87dee7589da7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96cb07a406c2841173cfc1de6b7f87dee7589da7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54b8d5f1abeb71808aa1e55830c7463a48ee59bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54b8d5f1abeb71808aa1e55830c7463a48ee59bc", "html_url": "https://github.com/rust-lang/rust/commit/54b8d5f1abeb71808aa1e55830c7463a48ee59bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54b8d5f1abeb71808aa1e55830c7463a48ee59bc/comments", "author": {"login": "z0w0", "id": 676417, "node_id": "MDQ6VXNlcjY3NjQxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/676417?v=4", "gravatar_id": "", "url": "https://api.github.com/users/z0w0", "html_url": "https://github.com/z0w0", "followers_url": "https://api.github.com/users/z0w0/followers", "following_url": "https://api.github.com/users/z0w0/following{/other_user}", "gists_url": "https://api.github.com/users/z0w0/gists{/gist_id}", "starred_url": "https://api.github.com/users/z0w0/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/z0w0/subscriptions", "organizations_url": "https://api.github.com/users/z0w0/orgs", "repos_url": "https://api.github.com/users/z0w0/repos", "events_url": "https://api.github.com/users/z0w0/events{/privacy}", "received_events_url": "https://api.github.com/users/z0w0/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f6e6532ac17e97ce48b91e07340361a32ef480b", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f6e6532ac17e97ce48b91e07340361a32ef480b", "html_url": "https://github.com/rust-lang/rust/commit/3f6e6532ac17e97ce48b91e07340361a32ef480b"}], "stats": {"total": 499, "additions": 342, "deletions": 157}, "files": [{"sha": "fce9d42243b624bedd89f5fe188153161df775cb", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 342, "deletions": 157, "changes": 499, "blob_url": "https://github.com/rust-lang/rust/blob/54b8d5f1abeb71808aa1e55830c7463a48ee59bc/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54b8d5f1abeb71808aa1e55830c7463a48ee59bc/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=54b8d5f1abeb71808aa1e55830c7463a48ee59bc", "patch": "@@ -8,14 +8,11 @@ import syntax::diagnostic;\n \n import result::{ok, err};\n import io::writer_util;\n-import std::json;\n import result;\n-import std::map;\n-import std::map::hashmap;\n+import std::{map, json, tempfile, term, sort, getopts};\n+import map::hashmap;\n import str;\n-import std::tempfile;\n import vec;\n-import std::getopts;\n import getopts::{optflag, optopt, opt_present};\n \n type package = {\n@@ -40,6 +37,7 @@ type source = {\n type cargo = {\n     pgp: bool,\n     root: str,\n+    installdir: str,\n     bindir: str,\n     libdir: str,\n     workdir: str,\n@@ -67,20 +65,109 @@ type options = {\n enum mode { system_mode, user_mode, local_mode }\n \n fn opts() -> [getopts::opt] {\n-    [optflag(\"g\"), optflag(\"G\"), optopt(\"mode\"), optflag(\"test\"),\n+    [optflag(\"g\"), optflag(\"G\"), optflag(\"test\"),\n      optflag(\"h\"), optflag(\"help\")]\n }\n \n fn info(msg: str) {\n-    io::stdout().write_line(\"info: \" + msg);\n+    let out = io::stdout();\n+\n+    if term::color_supported() {\n+        term::fg(out, term::color_green);\n+        out.write_str(\"info: \");\n+        term::reset(out);\n+        out.write_line(msg);\n+    } else { out.write_line(\"info: \" + msg); }\n }\n \n fn warn(msg: str) {\n-    io::stdout().write_line(\"warning: \" + msg);\n+    let out = io::stdout();\n+\n+    if term::color_supported() {\n+        term::fg(out, term::color_yellow);\n+        out.write_str(\"warning: \");\n+        term::reset(out);\n+        out.write_line(msg);\n+    }else { out.write_line(\"warning: \" + msg); }\n }\n \n fn error(msg: str) {\n-    io::stdout().write_line(\"error: \" + msg);\n+    let out = io::stdout();\n+\n+    if term::color_supported() {\n+        term::fg(out, term::color_red);\n+        out.write_str(\"error: \");\n+        term::reset(out);\n+        out.write_line(msg);\n+    }\n+    else { out.write_line(\"error: \" + msg); }\n+}\n+\n+fn is_uuid(id: str) -> bool {\n+    let parts = str::split_str(id, \"-\");\n+    if vec::len(parts) == 5u {\n+        let mut correct = 0u;\n+        vec::iteri(parts) { |i, part|\n+            alt i {\n+                0u {\n+                    if str::len(part) == 8u {\n+                        correct += 1u;\n+                    }\n+                }\n+                1u | 2u | 3u {\n+                    if str::len(part) == 4u {\n+                        correct += 1u;\n+                    }\n+                }\n+                4u {\n+                    if str::len(part) == 12u {\n+                        correct += 1u;\n+                    }\n+                }\n+                _ { }\n+            }\n+        }\n+        if correct >= 5u {\n+            ret true;\n+        }\n+    }\n+    false\n+}\n+\n+// FIXME: implement URI/URL parsing so we don't have to resort to weak checks\n+\n+fn is_archive_uri(uri: str) -> bool {\n+    let (_, ext) = path::splitext(uri);\n+\n+    alt ext {\n+        \".tar\" { ret true; }\n+        \".tar.gz\" { ret true; }\n+        \".tar.xy\" { ret true; }\n+        \".tar.bz2\" { ret true; }\n+        _ { ret false; }\n+    }\n+}\n+\n+fn is_archive_url(url: str) -> bool {\n+    // FIXME: this requires the protocol bit - if we had proper URI parsing,\n+    // we wouldn't need it\n+\n+    alt str::find_str(url, \"://\") {\n+        option::some(idx) {\n+            str::ends_with(url, \".tar\")\n+            || str::ends_with(url, \".tar.gz\")\n+            || str::ends_with(url, \".tar.xy\")\n+            || str::ends_with(url, \".tar.bz2\")\n+        }\n+        option::none { false }\n+    }\n+}\n+\n+fn is_git_url(url: str) -> bool {\n+    if str::ends_with(url, \"/\") { str::ends_with(url, \".git/\") }\n+    else {\n+        str::starts_with(url, \"git://\") || str::ends_with(url, \".git\")\n+    }\n }\n \n fn load_link(mis: [@ast::meta_item]) -> (option<str>,\n@@ -186,7 +273,7 @@ fn parse_source(name: str, j: json::json) -> source {\n                 some(json::string(u)) {\n                     u\n                 }\n-                _ { fail \"Needed 'url' field in source.\"; }\n+                _ { fail \"needed 'url' field in source\"; }\n             };\n             let sig = alt _j.find(\"sig\") {\n                 some(json::string(u)) {\n@@ -209,7 +296,7 @@ fn parse_source(name: str, j: json::json) -> source {\n             ret { name: name, url: url, sig: sig, key: key, keyfp: keyfp,\n                   mut packages: [] };\n         }\n-        _ { fail \"Needed dict value in source.\"; }\n+        _ { fail \"needed dict value in source\"; }\n     };\n }\n \n@@ -232,31 +319,31 @@ fn load_one_source_package(&src: source, p: map::hashmap<str, json::json>) {\n     let name = alt p.find(\"name\") {\n         some(json::string(_n)) { _n }\n         _ {\n-            warn(\"Malformed source json: \" + src.name + \" (missing name)\");\n+            warn(\"malformed source json: \" + src.name + \" (missing name)\");\n             ret;\n         }\n     };\n \n     let uuid = alt p.find(\"uuid\") {\n         some(json::string(_n)) { _n }\n         _ {\n-            warn(\"Malformed source json: \" + src.name + \" (missing uuid)\");\n+            warn(\"malformed source json: \" + src.name + \" (missing uuid)\");\n             ret;\n         }\n     };\n \n     let url = alt p.find(\"url\") {\n         some(json::string(_n)) { _n }\n         _ {\n-            warn(\"Malformed source json: \" + src.name + \" (missing url)\");\n+            warn(\"malformed source json: \" + src.name + \" (missing url)\");\n             ret;\n         }\n     };\n \n     let method = alt p.find(\"method\") {\n         some(json::string(_n)) { _n }\n         _ {\n-            warn(\"Malformed source json: \" + src.name + \" (missing method)\");\n+            warn(\"malformed source json: \" + src.name + \" (missing method)\");\n             ret;\n         }\n     };\n@@ -282,7 +369,7 @@ fn load_one_source_package(&src: source, p: map::hashmap<str, json::json>) {\n     let description = alt p.find(\"description\") {\n         some(json::string(_n)) { _n }\n         _ {\n-            warn(\"Malformed source json: \" + src.name\n+            warn(\"malformed source json: \" + src.name\n                  + \" (missing description)\");\n             ret;\n         }\n@@ -297,11 +384,11 @@ fn load_one_source_package(&src: source, p: map::hashmap<str, json::json>) {\n         ref: ref,\n         tags: tags\n     });\n-    log(debug, \"  Loaded package: \" + src.name + \"/\" + name);\n+    log(debug, \"  loaded package: \" + src.name + \"/\" + name);\n }\n \n fn load_source_packages(&c: cargo, &src: source) {\n-    log(debug, \"Loading source: \" + src.name);\n+    log(debug, \"loading source: \" + src.name);\n     let dir = path::connect(c.sourcedir, src.name);\n     let pkgfile = path::connect(dir, \"packages.json\");\n     if !os::path_exists(pkgfile) { ret; }\n@@ -314,14 +401,14 @@ fn load_source_packages(&c: cargo, &src: source) {\n                         load_one_source_package(src, _p);\n                     }\n                     _ {\n-                        warn(\"Malformed source json: \" + src.name +\n+                        warn(\"malformed source json: \" + src.name +\n                              \" (non-dict pkg)\");\n                     }\n                 }\n             }\n         }\n         ok(_) {\n-            warn(\"Malformed source json: \" + src.name +\n+            warn(\"malformed source json: \" + src.name +\n                  \"(packages is not a list)\");\n         }\n         err(e) {\n@@ -341,40 +428,31 @@ fn build_cargo_options(argv: [str]) -> options {\n     let test = opt_present(match, \"test\");\n     let G    = opt_present(match, \"G\");\n     let g    = opt_present(match, \"g\");\n-    let m    = opt_present(match, \"mode\");\n     let help = opt_present(match, \"h\") || opt_present(match, \"help\");\n+    let len  = vec::len(match.free);\n \n-    let is_install = vec::len(match.free) > 1u && match.free[1] == \"install\";\n+    let is_install = len > 1u && match.free[1] == \"install\";\n+    let is_uninstall = len > 1u && match.free[1] == \"uninstall\";\n \n     if G && g { fail \"-G and -g both provided\"; }\n-    if g && m { fail \"--mode and -g both provided\"; }\n-    if G && m { fail \"--mode and -G both provided\"; }\n \n-    if !is_install && (g || G || m) {\n-        fail \"-g, -G, --mode are only valid for `install`\";\n+    if !is_install && !is_uninstall && (g || G) {\n+        fail \"-g and -G are only valid for `install` and `uninstall|rm`\";\n     }\n \n     let mode =\n-        if !is_install || G { system_mode }\n-        else if  g { user_mode }\n-        else if !m { local_mode }\n-        else {\n-            alt getopts::opt_str(match, \"mode\") {\n-                \"system\" { system_mode }\n-                \"user\"   { user_mode }\n-                \"local\"  { local_mode }\n-                _        { fail \"argument to `mode` must be\" +\n-                                \"one of `system`, `user`, or `local`\"; }}\n-        };\n+        if (!is_install && !is_uninstall) || g { user_mode }\n+        else if G { system_mode }\n+        else { local_mode };\n \n     {test: test, mode: mode, free: match.free, help: help}\n }\n \n fn configure(opts: options) -> cargo {\n-    // NOTE: to make init and sync save into non-root level directories\n-    // simply get rid of syscargo, below\n-\n-    let syscargo = result::get(get_cargo_sysroot());\n+    let home = alt get_cargo_root() {\n+        ok(_home) { _home }\n+        err(_err) { result::get(get_cargo_sysroot()) }\n+    };\n \n     let get_cargo_dir = alt opts.mode {\n         system_mode { get_cargo_sysroot }\n@@ -385,23 +463,25 @@ fn configure(opts: options) -> cargo {\n     let p = result::get(get_cargo_dir());\n \n     let sources = map::str_hash::<source>();\n-    try_parse_sources(path::connect(syscargo, \"sources.json\"), sources);\n-    try_parse_sources(path::connect(syscargo, \"local-sources.json\"), sources);\n+    try_parse_sources(path::connect(home, \"sources.json\"), sources);\n+    try_parse_sources(path::connect(home, \"local-sources.json\"), sources);\n \n     let mut c = {\n         pgp: pgp::supported(),\n-        root: p,\n+        root: home,\n+        installdir: p,\n         bindir: path::connect(p, \"bin\"),\n         libdir: path::connect(p, \"lib\"),\n-        workdir: path::connect(p, \"work\"),\n-        sourcedir: path::connect(syscargo, \"sources\"),\n+        workdir: path::connect(home, \"work\"),\n+        sourcedir: path::connect(home, \"sources\"),\n         sources: sources,\n         opts: opts\n     };\n \n     need_dir(c.root);\n     need_dir(c.sourcedir);\n     need_dir(c.workdir);\n+    need_dir(c.installdir);\n     need_dir(c.libdir);\n     need_dir(c.bindir);\n \n@@ -414,8 +494,8 @@ fn configure(opts: options) -> cargo {\n     if c.pgp {\n         pgp::init(c.root);\n     } else {\n-        warn(\"command \\\"gpg\\\" is not found\");\n-        warn(\"you have to install \\\"gpg\\\" from source \" +\n+        warn(\"command `gpg` was not found\");\n+        warn(\"you have to install gpg from source \" +\n              \" or package manager to get it to work correctly\");\n     }\n \n@@ -458,7 +538,7 @@ fn run_in_buildpath(what: str, path: str, subdir: str, cf: str,\n }\n \n fn test_one_crate(_c: cargo, path: str, cf: str) {\n-  let buildpath = alt run_in_buildpath(\"Testing\", path, \"/test\", cf,\n+  let buildpath = alt run_in_buildpath(\"testing\", path, \"/test\", cf,\n                                        [ \"--test\"]) {\n       none { ret; }\n       some(bp) { bp }\n@@ -467,46 +547,31 @@ fn test_one_crate(_c: cargo, path: str, cf: str) {\n }\n \n fn install_one_crate(c: cargo, path: str, cf: str) {\n-    let buildpath = alt run_in_buildpath(\"Installing\", path,\n+    let buildpath = alt run_in_buildpath(\"installing\", path,\n                                          \"/build\", cf, []) {\n       none { ret; }\n       some(bp) { bp }\n     };\n     let newv = os::list_dir_path(buildpath);\n     let exec_suffix = os::exe_suffix();\n     for newv.each {|ct|\n-        // FIXME: What's up with the dual installation?  Both `install_to_dir`\n-        // and `install_one_crate_to_sysroot` install the binary files...\n-\n         if (exec_suffix != \"\" && str::ends_with(ct, exec_suffix)) ||\n             (exec_suffix == \"\" && !str::starts_with(path::basename(ct),\n                                                     \"lib\")) {\n             #debug(\"  bin: %s\", ct);\n             install_to_dir(ct, c.bindir);\n             if c.opts.mode == system_mode {\n-                install_one_crate_to_sysroot(ct, \"bin\");\n+                // TODO: Put this file in PATH / symlink it so it can be\n+                // used as a generic executable\n+                // `cargo install -G rustray` and `rustray file.obj`\n             }\n         } else {\n             #debug(\"  lib: %s\", ct);\n             install_to_dir(ct, c.libdir);\n-            if c.opts.mode == system_mode {\n-                install_one_crate_to_sysroot(ct, libdir());\n-            }\n         }\n     }\n }\n \n-fn install_one_crate_to_sysroot(ct: str, target: str) {\n-    alt os::self_exe_path() {\n-        some(_path) {\n-            let path = [_path, \"..\", target];\n-            check vec::is_not_empty(path);\n-            let target_dir = path::normalize(path::connect_many(path));\n-            install_to_dir(ct, target_dir);\n-        }\n-        none { }\n-    }\n-}\n \n fn rustc_sysroot() -> str {\n     alt os::self_exe_path() {\n@@ -533,7 +598,7 @@ fn install_source(c: cargo, path: str) {\n     }\n \n     if vec::is_empty(cratefiles) {\n-        fail \"This doesn't look like a rust package (no .rc files).\";\n+        fail \"this doesn't look like a rust package (no .rc files)\";\n     }\n \n     for cratefiles.each {|cf|\n@@ -551,6 +616,7 @@ fn install_source(c: cargo, path: str) {\n }\n \n fn install_git(c: cargo, wd: str, url: str, ref: option<str>) {\n+    info(\"installing with git from \" + url + \"...\");\n     run::run_program(\"git\", [\"clone\", url, wd]);\n     if option::is_some::<str>(ref) {\n         let r = option::get::<str>(ref);\n@@ -562,47 +628,47 @@ fn install_git(c: cargo, wd: str, url: str, ref: option<str>) {\n }\n \n fn install_curl(c: cargo, wd: str, url: str) {\n+    info(\"installing with curl from \" + url + \"...\");\n     let tarpath = path::connect(wd, \"pkg.tar\");\n     let p = run::program_output(\"curl\", [\"-f\", \"-s\", \"-o\",\n                                          tarpath, url]);\n     if p.status != 0 {\n-        fail #fmt[\"Fetch of %s failed: %s\", url, p.err];\n+        fail #fmt[\"fetch of %s failed: %s\", url, p.err];\n     }\n     run::run_program(\"tar\", [\"-x\", \"--strip-components=1\",\n                              \"-C\", wd, \"-f\", tarpath]);\n     install_source(c, wd);\n }\n \n fn install_file(c: cargo, wd: str, path: str) {\n+    info(\"installing with file from \" + path + \"...\");\n     run::run_program(\"tar\", [\"-x\", \"--strip-components=1\",\n                              \"-C\", wd, \"-f\", path]);\n     install_source(c, wd);\n }\n \n fn install_package(c: cargo, wd: str, pkg: package) {\n-    info(\"Installing with \" + pkg.method + \" from \" + pkg.url + \"...\");\n-    if pkg.method == \"git\" {\n-        install_git(c, wd, pkg.url, pkg.ref);\n-    } else if pkg.method == \"http\" {\n-        install_curl(c, wd, pkg.url);\n-    } else if pkg.method == \"file\" {\n-        install_file(c, wd, pkg.url);\n+    alt pkg.method {\n+        \"git\" { install_git(c, wd, pkg.url, pkg.ref); }\n+        \"http\" | \"ftp\" | \"curl\" { install_curl(c, wd, pkg.url); }\n+        \"file\" { install_file(c, wd, pkg.url); }\n+        _ { fail #fmt(\"don't know how to install with: %s\", pkg.method) }\n     }\n }\n \n fn cargo_suggestion(c: cargo, syncing: bool, fallback: fn())\n {\n     if c.sources.size() == 0u {\n-        error(\"No sources defined. You may wish to run \" +\n-              \"\\\"cargo init\\\" then \\\"cargo sync\\\".\");\n+        error(\"no sources defined - you may wish to run \" +\n+              \"`cargo init` then `cargo sync`\");\n         ret;\n     }\n     if !syncing {\n         let mut npkg = 0u;\n         for c.sources.each_value { |v| npkg += vec::len(v.packages) }\n         if npkg == 0u {\n-            error(\"No packages known. You may wish to run \" +\n-                  \"\\\"cargo sync\\\".\");\n+            error(\"no packages synced - you may wish to run \" +\n+                  \"`cargo sync`\");\n             ret;\n         }\n     }\n@@ -612,7 +678,6 @@ fn cargo_suggestion(c: cargo, syncing: bool, fallback: fn())\n fn install_uuid(c: cargo, wd: str, uuid: str) {\n     let mut ps = [];\n     for_each_package(c, { |s, p|\n-        info(#fmt[\"%s ? %s\", p.uuid, uuid]);\n         if p.uuid == uuid {\n             vec::grow(ps, 1u, (s.name, p));\n         }\n@@ -622,10 +687,10 @@ fn install_uuid(c: cargo, wd: str, uuid: str) {\n         install_package(c, wd, p);\n         ret;\n     } else if vec::len(ps) == 0u {\n-        cargo_suggestion(c, false, { || error(\"No packages match uuid.\"); });\n+        cargo_suggestion(c, false, { || error(\"no packages match uuid\"); });\n         ret;\n     }\n-    error(\"Found multiple packages:\");\n+    error(\"found multiple packages:\");\n     for ps.each {|elt|\n         let (sname,p) = elt;\n         info(\"  \" + sname + \"/\" + p.uuid + \" (\" + p.name + \")\");\n@@ -644,10 +709,10 @@ fn install_named(c: cargo, wd: str, name: str) {\n         install_package(c, wd, p);\n         ret;\n     } else if vec::len(ps) == 0u {\n-        cargo_suggestion(c, false, { || error(\"No packages match name.\"); });\n+        cargo_suggestion(c, false, { || error(\"no packages match name\"); });\n         ret;\n     }\n-    error(\"Found multiple packages:\");\n+    error(\"found multiple packages:\");\n     for ps.each {|elt|\n         let (sname,p) = elt;\n         info(\"  \" + sname + \"/\" + p.uuid + \" (\" + p.name + \")\");\n@@ -667,7 +732,7 @@ fn install_uuid_specific(c: cargo, wd: str, src: str, uuid: str) {\n       }\n       _ { }\n     }\n-    error(\"Can't find package \" + src + \"/\" + uuid);\n+    error(\"can't find package \" + src + \"/\" + uuid);\n }\n \n fn install_named_specific(c: cargo, wd: str, src: str, name: str) {\n@@ -683,64 +748,113 @@ fn install_named_specific(c: cargo, wd: str, src: str, name: str) {\n         }\n         _ { }\n     }\n-    error(\"Can't find package \" + src + \"/\" + name);\n+    error(\"can't find package \" + src + \"/\" + name);\n }\n \n-fn cmd_install(c: cargo) unsafe {\n-    // cargo install <pkg>\n+fn cmd_uninstall(c: cargo) {\n     if vec::len(c.opts.free) < 3u {\n         cmd_usage();\n         ret;\n     }\n \n-    let target = c.opts.free[2];\n+    let target = c.opts.free[2u];\n+\n+    // FIXME: needs stronger pattern matching\n+    if is_uuid(target) {\n+        for os::list_dir(c.libdir).each { |file|\n+            alt str::find_str(file, \"-\" + target + \"-\") {\n+                some(idx) {\n+                    let full = path::normalize(path::connect(c.libdir, file));\n+                    if os::remove_file(full) {\n+                        info(\"uninstalled: '\" + full + \"'\");\n+                    } else {\n+                        error(\"could not uninstall: '\" + full + \"'\");\n+                    }\n+                    ret;\n+                }\n+                none { cont; }\n+            }\n+        }\n+\n+        error(\"can't find package with uuid: \" + target);\n+    } else {\n+        for os::list_dir(c.libdir).each { |file|\n+            alt str::find_str(file, \"lib\" + target + \"-\") {\n+                some(idx) {\n+                    let full = path::normalize(path::connect(c.libdir, file));\n+                    if os::remove_file(full) {\n+                        info(\"uninstalled: '\" + full + \"'\");\n+                    } else {\n+                        error(\"could not uninstall: '\" + full + \"'\");\n+                    }\n+                    ret;\n+                }\n+                none { cont; }\n+            }\n+        }\n+\n+        error(\"can't find package with name: \" + target);\n+    }\n+}\n+\n+fn cmd_install(c: cargo) unsafe {\n+    // cargo install [pkg]\n+    if vec::len(c.opts.free) < 2u {\n+        cmd_usage();\n+        ret;\n+    }\n \n     let wd_base = c.workdir + path::path_sep();\n     let wd = alt tempfile::mkdtemp(wd_base, \"\") {\n         some(_wd) { _wd }\n         none { fail #fmt(\"needed temp dir: %s\", wd_base); }\n     };\n \n-    if str::starts_with(target, \"uuid:\") {\n-        let mut uuid = rest(target, 5u);\n-        alt str::find_char(uuid, '/') {\n-            option::some(idx) {\n-               let source = str::slice(uuid, 0u, idx);\n-               uuid = str::slice(uuid, idx + 1u, str::len(uuid));\n-               install_uuid_specific(c, wd, source, uuid);\n-            }\n-            option::none {\n-               install_uuid(c, wd, uuid);\n-            }\n+    if vec::len(c.opts.free) == 2u {\n+        let cwd = os::getcwd();\n+        let status = run::run_program(\"cp\", [\"-R\", cwd, wd]);\n+\n+        if status != 0 {\n+            fail #fmt(\"could not copy directory: %s\", cwd);\n         }\n-    } else if str::starts_with(target, \"git:\") {\n+\n+        install_source(c, wd);\n+        ret;\n+    }\n+\n+    let target = c.opts.free[2];\n+\n+    if is_archive_url(target) {\n+        install_curl(c, wd, target);\n+    } else if is_git_url(target) {\n         let ref = if c.opts.free.len() >= 4u {\n             some(c.opts.free[3u])\n         } else {\n             none\n         };\n         install_git(c, wd, target, ref)\n-    } else if target == \"git\" {\n-        if c.opts.free.len() < 4u {\n-            fail #fmt(\"needed git url\");\n-        }\n-        let url = c.opts.free[3u];\n-        let ref = if c.opts.free.len() >= 5u {\n-            some(c.opts.free[4u])\n-        } else {\n-            none\n-        };\n-        install_git(c, wd, url, ref)\n+    } else if is_archive_uri(target) {\n+        install_file(c, wd, target);\n+        ret;\n     } else {\n-        let mut name = target;\n-        alt str::find_char(name, '/') {\n+        let mut ps = copy target;\n+\n+        alt str::find_char(ps, '/') {\n             option::some(idx) {\n-               let source = str::slice(name, 0u, idx);\n-               name = str::slice(name, idx + 1u, str::len(name));\n-               install_named_specific(c, wd, source, name);\n+                let source = str::slice(ps, 0u, idx);\n+                ps = str::slice(ps, idx + 1u, str::len(ps));\n+                if is_uuid(ps) {\n+                    install_uuid_specific(c, wd, source, ps);\n+                } else {\n+                    install_named_specific(c, wd, source, ps);\n+                }\n             }\n             option::none {\n-               install_named(c, wd, name);\n+                if is_uuid(ps) {\n+                    install_uuid(c, wd, ps);\n+                } else {\n+                    install_named(c, wd, ps);\n+                }\n             }\n         }\n     }\n@@ -800,12 +914,21 @@ fn sync_one(c: cargo, name: str, src: source) {\n }\n \n fn cmd_sync(c: cargo) {\n-    if vec::len(c.opts.free) == 3u {\n-        sync_one(c, c.opts.free[2], c.sources.get(c.opts.free[2]));\n+    if vec::len(c.opts.free) >= 3u {\n+        vec::iter_between(c.opts.free, 2u, vec::len(c.opts.free)) { |name|\n+            alt c.sources.find(name) {\n+                some(source) {\n+                    sync_one(c, name, source);\n+                }\n+                none {\n+                    error(#fmt(\"no such source: %s\", name));\n+                }\n+            }\n+        }\n     } else {\n         cargo_suggestion(c, true, { || } );\n-        for c.sources.each { |k, v|\n-            sync_one(c, k, v);\n+        for c.sources.each_value { |v|\n+            sync_one(c, v.name, v);\n         }\n     }\n }\n@@ -838,7 +961,7 @@ fn cmd_init(c: cargo) {\n     }\n     copy_warn(srcfile, destsrcfile);\n \n-    info(#fmt[\"Initialized .cargo in %s\", c.root]);\n+    info(#fmt[\"initialized .cargo in %s\", c.root]);\n }\n \n fn print_pkg(s: source, p: package) {\n@@ -851,14 +974,49 @@ fn print_pkg(s: source, p: package) {\n         print(\"   >> \" + p.description + \"\\n\")\n     }\n }\n-fn cmd_list(c: cargo) {\n-    for_each_package(c, { |s, p|\n-        if vec::len(c.opts.free) <= 2u || c.opts.free[2] == s.name {\n-            print_pkg(s, p);\n+\n+fn print_source(s: source) {\n+    info(s.name + \" (\" + s.url + \")\");\n+\n+    let pks = sort::merge_sort({ |a, b|\n+        a < b\n+    }, copy s.packages);\n+    let l = vec::len(pks);\n+\n+    print(io::with_str_writer() { |writer|\n+        let mut list = \"   >> \";\n+\n+        vec::iteri(pks) { |i, pk|\n+            if str::len(list) > 78u {\n+                writer.write_line(list);\n+                list = \"   >> \";\n+            }\n+            list += pk.name + (if l - 1u == i { \"\" } else { \", \" });\n         }\n+\n+        writer.write_line(list);\n     });\n }\n \n+fn cmd_list(c: cargo) {\n+    if vec::len(c.opts.free) >= 3u {\n+        vec::iter_between(c.opts.free, 2u, vec::len(c.opts.free)) { |name|\n+            alt c.sources.find(name) {\n+                some(source) {\n+                    print_source(source);\n+                }\n+                none {\n+                    error(#fmt(\"no such source: %s\", name));\n+                }\n+            }\n+        }\n+    } else {\n+        for c.sources.each_value { |v|\n+            print_source(v);\n+        }\n+    }\n+}\n+\n fn cmd_search(c: cargo) {\n     if vec::len(c.opts.free) < 3u {\n         cmd_usage();\n@@ -874,51 +1032,62 @@ fn cmd_search(c: cargo) {\n             n += 1;\n         }\n     });\n-    info(#fmt[\"Found %d packages.\", n]);\n+    info(#fmt[\"found %d packages\", n]);\n }\n \n fn install_to_dir(srcfile: str, destdir: str) {\n     let newfile = path::connect(destdir, path::basename(srcfile));\n-    info(#fmt[\"Installing '%s'...\", newfile]);\n \n-    run::run_program(\"cp\", [srcfile, newfile]);\n+    let status = run::run_program(\"cp\", [srcfile, newfile]);\n+    if status == 0 {\n+        info(#fmt[\"installed: '%s'\", newfile]);\n+    } else {\n+        error(#fmt[\"could not install: '%s'\", newfile]);\n+    }\n }\n \n fn copy_warn(srcfile: str, destfile: str) {\n   if !os::copy_file(srcfile, destfile) {\n-      warn(#fmt[\"Copying %s to %s failed\", srcfile, destfile]);\n+      warn(#fmt[\"copying %s to %s failed\", srcfile, destfile]);\n   }\n }\n \n-// FIXME: decide on either [-g | -G] or [--mode=...] and remove the other\n fn cmd_usage() {\n-    print(\"Usage: cargo <verb> [options] [args...]\\n\" +\n+    print(\"Usage: cargo <verb> [options] [args..]\\n\" +\n           \" e.g.: cargo [init | sync]\\n\" +\n-          \" e.g.: cargo install [-g | -G | --mode=MODE] ] [PACKAGE...]\n+          \" e.g.: cargo install [-g | -G] <package>\n \n-Initialization:\n-    init           Set up the cargo system near this binary,\n-                   for example, at  /usr/local/lib/cargo/\n-    sync           Sync all package sources\n+General:\n+    init                    Reinitialize cargo in ~/.cargo\n+    usage                   Display this message\n+    sync [sources..]        Sync all sources (or specific sources)\n \n Querying:\n-    list [source]                        List packages\n-    search <name | '*'> [tags...]        Search packages\n-    usage                                Display this message\n-\n-Package installation:\n-    [options] [source/]PKGNAME           Install a package by name\n-    [options] uuid:[source/]PKGUUID      Install a package by uuid\n-    [options] git [url] [ref]            Install a package by git\n-    [options] git://[url] [ref]          Install a package by git\n+    list [sources..]                        List sources and their packages\n+                                            or a single source\n+    search <name | '*'> [tags...]           Search packages\n+\n+Packages:\n+    install [options]                       Install a package from source\n+                                            code in the current directory\n+    install [options] [source/]<name>       Install a package by name\n+    install [options] [source/]<uuid>       Install a package by uuid\n+    install [options] <url>                 Install a package via curl (HTTP,\n+                                            FTP, etc.) from an .tar[.gz|bz2|xy]\n+                                            file\n+    install [options] <url> [ref]           Install a package via git\n+    install [options] <file>                Install a package directly from an\n+                                            .tar[.gz|bz2|xy] file\n+    uninstall [options] <name>              Remove a package by (meta) name\n+    uninstall [options] <uuid>              Remove a package by (meta) uuid\n \n Package installation options:\n-    --mode=MODE    Install to one of the following locations:\n-                   local (./.cargo/bin/, which is the default),\n-                   user (~/.cargo/bin/), or system (/usr/local/lib/cargo/bin/)\n-    --test         Run crate tests before installing\n-    -g             Equivalent to --mode=user\n-    -G             Equivalent to --mode=system\n+    --tests         Run crate tests before installing\n+\n+Package [un]installation options:\n+    -g              Work at the user level (~/.cargo/bin/ instead of\n+                    locally in ./.cargo/bin/ by default)\n+    -G              Work at the system level (/usr/local/lib/cargo/bin/)\n \n Other:\n     -h, --help     Display this message\n@@ -933,15 +1102,31 @@ fn main(argv: [str]) {\n         ret;\n     }\n \n-    let c = configure(o);\n+    let mut c = configure(o);\n+    let mut sources = c.sources;\n+    let home = c.root;\n+\n+    if !os::path_exists(path::connect(home, \"sources.json\")) {\n+        cmd_init(c);\n+        try_parse_sources(path::connect(home, \"sources.json\"), sources);\n+        try_parse_sources(path::connect(home, \"local-sources.json\"), sources);\n+\n+        for sources.each_value { |v|\n+            sync_one(c, v.name, v);\n+        }\n+\n+        // FIXME: shouldn't need to reconfigure\n+        c = configure(o);\n+    }\n \n     alt o.free[1] {\n         \"init\" { cmd_init(c); }\n         \"install\" { cmd_install(c); }\n+        \"uninstall\" { cmd_uninstall(c); }\n         \"list\" { cmd_list(c); }\n         \"search\" { cmd_search(c); }\n         \"sync\" { cmd_sync(c); }\n         \"usage\" { cmd_usage(); }\n         _ { cmd_usage(); }\n     }\n-}\n+}\n\\ No newline at end of file"}]}