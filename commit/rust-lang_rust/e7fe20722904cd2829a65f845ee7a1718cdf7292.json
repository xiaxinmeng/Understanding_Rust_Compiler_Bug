{"sha": "e7fe20722904cd2829a65f845ee7a1718cdf7292", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3ZmUyMDcyMjkwNGNkMjgyOWE2NWY4NDVlZTdhMTcxOGNkZjcyOTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-04T00:17:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-04T00:17:02Z"}, "message": "auto merge of #13290 : alexcrichton/rust/rollup, r=alexcrichton\n\nCloses #13285 (rustc: Stop using LLVMGetSectionName)\r\nCloses #13280 (std: override clone_from for Vec.)\r\nCloses #13277 (serialize: add a few missing pubs to base64)\r\nCloses #13275 (Add and remove some ignore-win32 flags)\r\nCloses #13273 (Removed managed boxes from libarena.)\r\nCloses #13270 (Minor copy-editing for the tutorial)\r\nCloses #13267 (fix Option<~ZeroSizeType>)\r\nCloses #13265 (Update emacs mode to support new `#![inner(attribute)]` syntax.)\r\nCloses #13263 (syntax: Remove AbiSet, use one Abi)", "tree": {"sha": "de906a26828f4a01fcdec0112047d16250d5c991", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de906a26828f4a01fcdec0112047d16250d5c991"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7fe20722904cd2829a65f845ee7a1718cdf7292", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7fe20722904cd2829a65f845ee7a1718cdf7292", "html_url": "https://github.com/rust-lang/rust/commit/e7fe20722904cd2829a65f845ee7a1718cdf7292", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7fe20722904cd2829a65f845ee7a1718cdf7292/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb31cb8d2e4e415cbb71d368918d72902e655e01", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb31cb8d2e4e415cbb71d368918d72902e655e01", "html_url": "https://github.com/rust-lang/rust/commit/bb31cb8d2e4e415cbb71d368918d72902e655e01"}, {"sha": "487fa9568b69753fecb74a8460109239f4bf3631", "url": "https://api.github.com/repos/rust-lang/rust/commits/487fa9568b69753fecb74a8460109239f4bf3631", "html_url": "https://github.com/rust-lang/rust/commit/487fa9568b69753fecb74a8460109239f4bf3631"}], "stats": {"total": 1540, "additions": 389, "deletions": 1151}, "files": [{"sha": "34918e391828955b021afe8955db842bf4f68fe4", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -13,23 +13,25 @@ use std::str;\n use std::io::process::{ProcessExit, Process, ProcessConfig, ProcessOutput};\n \n #[cfg(target_os = \"win32\")]\n-fn target_env(lib_path: &str, prog: &str) -> Vec<(~str,~str)> {\n-\n-    let mut env = os::env();\n+fn target_env(lib_path: &str, prog: &str) -> Vec<(~str, ~str)> {\n+    let env = os::env();\n \n     // Make sure we include the aux directory in the path\n     assert!(prog.ends_with(\".exe\"));\n     let aux_path = prog.slice(0u, prog.len() - 4u).to_owned() + \".libaux\";\n \n-    env = env.map(|pair| {\n-        let (k,v) = (*pair).clone();\n-        if k == ~\"PATH\" { (~\"PATH\", v + \";\" + lib_path + \";\" + aux_path) }\n-        else { (k,v) }\n-    });\n+    let mut new_env: Vec<_> = env.move_iter().map(|(k, v)| {\n+        let new_v = if \"PATH\" == k {\n+            format!(\"{};{};{}\", v, lib_path, aux_path)\n+        } else {\n+            v\n+        };\n+        (k, new_v)\n+    }).collect();\n     if prog.ends_with(\"rustc.exe\") {\n-        env.push((~\"RUST_THREADS\", ~\"1\"));\n+        new_env.push((~\"RUST_THREADS\", ~\"1\"));\n     }\n-    return env;\n+    return new_env;\n }\n \n #[cfg(target_os = \"linux\")]"}, {"sha": "e057909a06cd01c27981b7ca9da5f9a14b7f2277", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -529,7 +529,7 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError> ,\n                 c\n             }\n         } ).collect();\n-        str::from_chars( c )\n+        str::from_chars(c.as_slice())\n     }\n \n     #[cfg(target_os = \"win32\")]"}, {"sha": "b52fe81f7cdf4fbb021ca223daf404b3ed28c81d", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -2107,7 +2107,7 @@ references, or types where the only contained references\n have the `'static` lifetime. (For more on named lifetimes and their uses,\n see the [references and lifetimes guide][lifetimes].)\n \n-> ***Note:*** These two traits were referred to as 'kinds' in earlier\n+> ***Note:*** These built-in traits were referred to as 'kinds' in earlier\n > iterations of the language, and often still are.\n \n Additionally, the `Drop` trait is used to define destructors. This\n@@ -2600,8 +2600,6 @@ As you can see, your module hierarchy is now three modules deep: There is the cr\n function, and the module `farm`. The module `farm` also contains two functions and a third module `barn`,\n which contains a function `hay`.\n \n-(In case you already stumbled over `extern crate`: It isn't directly related to a bare `mod`, we'll get to it later. )\n-\n ## Paths and visibility\n \n We've now defined a nice module hierarchy. But how do we access the items in it from our `main` function?\n@@ -2843,11 +2841,11 @@ use farm::cow;\n \n The path you give to `use` is per default global, meaning relative to the crate root,\n no matter how deep the module hierarchy is, or whether the module body it's written in\n-is contained in its own file (remember: files are irrelevant).\n+is contained in its own file. (Remember: files are irrelevant.)\n \n-This is different to other languages, where you often only find a single import construct that combines the semantic\n+This is different from other languages, where you often only find a single import construct that combines the semantic\n of `mod foo;` and `use`-statements, and which tend to work relative to the source file or use an absolute file path\n-- Rubys `require` or C/C++'s `#include` come to mind.\n+- Ruby's `require` or C/C++'s `#include` come to mind.\n \n However, it's also possible to import things relative to the module of the `use`-statement:\n Adding a `super::` in front of the path will start in the parent module,\n@@ -3027,7 +3025,7 @@ The nested `barn` module is private, but the `pub use` allows users\n of the module `farm` to access a function from `barn` without needing\n to know that `barn` exists.\n \n-In other words, you can use them to decouple an public api from their internal implementation.\n+In other words, you can use it to decouple a public api from its internal implementation.\n \n ## Using libraries\n \n@@ -3050,7 +3048,6 @@ fn main() {\n }\n ~~~\n \n-Despite its name, `extern crate` is a distinct construct from regular `mod` declarations:\n A statement of the form `extern crate foo;` will cause `rustc` to search for the crate `foo`,\n and if it finds a matching binary it lets you use it from inside your crate.\n "}, {"sha": "5cee600c2c019b9bb8c7cccdb24ca7990a82a9f6", "filename": "src/etc/emacs/rust-mode.el", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Fetc%2Femacs%2Frust-mode.el", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Fetc%2Femacs%2Frust-mode.el", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Femacs%2Frust-mode.el?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -196,8 +196,8 @@\n      ;; Special types\n      (,(regexp-opt rust-special-types 'words) . font-lock-type-face)\n \n-     ;; Attributes like `#[bar(baz)]`\n-     (,(rust-re-grab (concat \"#\\\\[\" rust-re-ident \"[^]]*\\\\]\"))\n+     ;; Attributes like `#[bar(baz)]` or `#![bar(baz)]`\n+     (,(rust-re-grab (concat \"#\\\\!?[\" rust-re-ident \"[^]]*\\\\]\"))\n       1 font-lock-preprocessor-face)\n \n      ;; Syntax extension invocations like `foo!`, highlight including the !"}, {"sha": "c67efbd81719c80a6643e91741672f690e4d5f8e", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -23,8 +23,6 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://static.rust-lang.org/doc/master\")]\n #![allow(missing_doc)]\n-#![feature(managed_boxes)]\n-\n #![allow(visible_private_types)] // NOTE: remove after a stage0 snap\n \n extern crate collections;\n@@ -301,7 +299,7 @@ fn test_arena_destructors() {\n     for i in range(0u, 10) {\n         // Arena allocate something with drop glue to make sure it\n         // doesn't leak.\n-        arena.alloc(|| @i);\n+        arena.alloc(|| Rc::new(i));\n         // Allocate something with funny size and alignment, to keep\n         // things interesting.\n         arena.alloc(|| [0u8, 1u8, 2u8]);\n@@ -316,13 +314,13 @@ fn test_arena_destructors_fail() {\n     for i in range(0u, 10) {\n         // Arena allocate something with drop glue to make sure it\n         // doesn't leak.\n-        arena.alloc(|| { @i });\n+        arena.alloc(|| { Rc::new(i) });\n         // Allocate something with funny size and alignment, to keep\n         // things interesting.\n         arena.alloc(|| { [0u8, 1u8, 2u8] });\n     }\n     // Now, fail while allocating\n-    arena.alloc::<@int>(|| {\n+    arena.alloc::<Rc<int>>(|| {\n         // Now fail.\n         fail!();\n     });"}, {"sha": "cfbe772a165db032ed4596f701f5511e24300054", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -90,7 +90,7 @@ fn fold_foreign_mod(cx: &mut Context, nm: &ast::ForeignMod) -> ast::ForeignMod {\n         filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n     }).collect();\n     ast::ForeignMod {\n-        abis: nm.abis,\n+        abi: nm.abi,\n         view_items: filtered_view_items,\n         items: filtered_items\n     }"}, {"sha": "9cfe064ad986f9ee63225cf1fd7e73e2f6f0b1bc", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -1438,8 +1438,6 @@ pub mod llvm {\n                                           -> Bool;\n         /** Moves the section iterator to point to the next section. */\n         pub fn LLVMMoveToNextSection(SI: SectionIteratorRef);\n-        /** Returns the current section name. */\n-        pub fn LLVMGetSectionName(SI: SectionIteratorRef) -> *c_char;\n         /** Returns the current section size. */\n         pub fn LLVMGetSectionSize(SI: SectionIteratorRef) -> c_ulonglong;\n         /** Returns the current section contents as a string buffer. */\n@@ -1784,6 +1782,9 @@ pub mod llvm {\n \n         pub fn LLVMRustSetDLLExportStorageClass(V: ValueRef);\n         pub fn LLVMVersionMinor() -> c_int;\n+\n+        pub fn LLVMRustGetSectionName(SI: SectionIteratorRef,\n+                                      data: *mut *c_char) -> c_int;\n     }\n }\n "}, {"sha": "d957850264681d5c00f730fc221d0124ac4359c2", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -187,7 +187,7 @@ fn extract_crate_info(e: &Env, i: &ast::ViewItem) -> Option<CrateInfo> {\n fn visit_item(e: &Env, i: &ast::Item) {\n     match i.node {\n         ast::ItemForeignMod(ref fm) => {\n-            if fm.abis.is_rust() || fm.abis.is_intrinsic() {\n+            if fm.abi == abi::Rust || fm.abi == abi::RustIntrinsic {\n                 return;\n             }\n "}, {"sha": "ec6bb7de380f88fc6a5e9e9602cbe934f38d9980", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -33,7 +33,7 @@ use std::hash::Hash;\n use std::io::MemWriter;\n use std::str;\n use collections::HashMap;\n-use syntax::abi::AbiSet;\n+use syntax::abi;\n use syntax::ast::*;\n use syntax::ast;\n use syntax::ast_map::{PathElem, PathElems};\n@@ -1217,7 +1217,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n                                 nitem: &ForeignItem,\n                                 index: @RefCell<Vec<entry<i64>> >,\n                                 path: PathElems,\n-                                abi: AbiSet) {\n+                                abi: abi::Abi) {\n     index.borrow_mut().push(entry {\n         val: nitem.id as i64,\n         pos: ebml_w.writer.tell().unwrap(),\n@@ -1231,7 +1231,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n         encode_bounds_and_type(ebml_w, ecx,\n                                &lookup_item_type(ecx.tcx,local_def(nitem.id)));\n         encode_name(ebml_w, nitem.ident.name);\n-        if abi.is_intrinsic() {\n+        if abi == abi::RustIntrinsic {\n             (ecx.encode_inlined_item)(ecx, ebml_w, IIForeignRef(nitem));\n         } else {\n             encode_symbol(ecx, ebml_w, nitem.id);\n@@ -1279,11 +1279,11 @@ fn my_visit_foreign_item(ni: &ForeignItem,\n     let mut ebml_w = unsafe {\n         ebml_w.unsafe_clone()\n     };\n-    let abis = ecx.tcx.map.get_foreign_abis(ni.id);\n+    let abi = ecx.tcx.map.get_foreign_abi(ni.id);\n     ecx.tcx.map.with_path(ni.id, |path| {\n         encode_info_for_foreign_item(ecx, &mut ebml_w,\n                                      ni, index,\n-                                     path, abis);\n+                                     path, abi);\n     });\n }\n "}, {"sha": "4dd892fd703452dc87786feaf3177b00fddc87e4", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -29,9 +29,10 @@ use std::cast;\n use std::cmp;\n use std::io;\n use std::os::consts::{macos, freebsd, linux, android, win32};\n+use std::ptr;\n use std::rc::Rc;\n-use std::str;\n use std::slice;\n+use std::str;\n \n use collections::{HashMap, HashSet};\n use flate;\n@@ -439,8 +440,9 @@ fn get_metadata_section_imp(os: Os, filename: &Path) -> Result<MetadataBlob, ~st\n         };\n         let si = mk_section_iter(of.llof);\n         while llvm::LLVMIsSectionIteratorAtEnd(of.llof, si.llsi) == False {\n-            let name_buf = llvm::LLVMGetSectionName(si.llsi);\n-            let name = str::raw::from_c_str(name_buf);\n+            let mut name_buf = ptr::null();\n+            let name_len = llvm::LLVMRustGetSectionName(si.llsi, &mut name_buf);\n+            let name = str::raw::from_buf_len(name_buf as *u8, name_len as uint);\n             debug!(\"get_metadata_section: name {}\", name);\n             if read_meta_section_name(os) == name {\n                 let cbuf = llvm::LLVMGetSectionContents(si.llsi);"}, {"sha": "409957b8625d531e9b8ab080d22f3c34fcd88823", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -20,7 +20,6 @@ use middle::ty;\n \n use std::str;\n use std::uint;\n-use syntax::abi::AbiSet;\n use syntax::abi;\n use syntax::ast;\n use syntax::ast::*;\n@@ -460,18 +459,12 @@ fn parse_purity(c: char) -> Purity {\n     }\n }\n \n-fn parse_abi_set(st: &mut PState) -> AbiSet {\n+fn parse_abi_set(st: &mut PState) -> abi::Abi {\n     assert_eq!(next(st), '[');\n-    let mut abis = AbiSet::empty();\n-    while peek(st) != ']' {\n-         scan(st, |c| c == ',', |bytes| {\n-                 let abi_str = str::from_utf8(bytes).unwrap().to_owned();\n-                 let abi = abi::lookup(abi_str).expect(abi_str);\n-                 abis.add(abi);\n-              });\n-    }\n-    assert_eq!(next(st), ']');\n-    return abis;\n+    scan(st, |c| c == ']', |bytes| {\n+        let abi_str = str::from_utf8(bytes).unwrap().to_owned();\n+        abi::lookup(abi_str).expect(abi_str)\n+    })\n }\n \n fn parse_onceness(c: char) -> ast::Onceness {\n@@ -505,7 +498,7 @@ fn parse_bare_fn_ty(st: &mut PState, conv: conv_did) -> ty::BareFnTy {\n     let sig = parse_sig(st, |x,y| conv(x,y));\n     ty::BareFnTy {\n         purity: purity,\n-        abis: abi,\n+        abi: abi,\n         sig: sig\n     }\n }"}, {"sha": "4053db72a28cd31ffafec5c29684351538f6ad66", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -23,7 +23,7 @@ use std::fmt;\n use middle::ty::param_ty;\n use middle::ty;\n \n-use syntax::abi::AbiSet;\n+use syntax::abi::Abi;\n use syntax::ast;\n use syntax::ast::*;\n use syntax::diagnostic::SpanHandler;\n@@ -341,12 +341,9 @@ fn enc_purity(w: &mut MemWriter, p: Purity) {\n     }\n }\n \n-fn enc_abi_set(w: &mut MemWriter, abis: AbiSet) {\n+fn enc_abi(w: &mut MemWriter, abi: Abi) {\n     mywrite!(w, \"[\");\n-    abis.each(|abi| {\n-        mywrite!(w, \"{},\", abi.name());\n-        true\n-    });\n+    mywrite!(w, \"{}\", abi.name());\n     mywrite!(w, \"]\")\n }\n \n@@ -359,7 +356,7 @@ fn enc_onceness(w: &mut MemWriter, o: Onceness) {\n \n pub fn enc_bare_fn_ty(w: &mut MemWriter, cx: &ctxt, ft: &ty::BareFnTy) {\n     enc_purity(w, ft.purity);\n-    enc_abi_set(w, ft.abis);\n+    enc_abi(w, ft.abi);\n     enc_fn_sig(w, cx, &ft.sig);\n }\n "}, {"sha": "da74d0c7729e6f1727076a835132c58db21efcc6", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -59,6 +59,7 @@ use std::u32;\n use std::u64;\n use std::u8;\n use collections::SmallIntMap;\n+use syntax::abi;\n use syntax::ast_map;\n use syntax::ast_util::IdVisitingOperation;\n use syntax::attr::{AttrMetaMethods, AttributeMethods};\n@@ -892,7 +893,7 @@ fn check_item_ctypes(cx: &Context, it: &ast::Item) {\n     }\n \n     match it.node {\n-      ast::ItemForeignMod(ref nmod) if !nmod.abis.is_intrinsic() => {\n+      ast::ItemForeignMod(ref nmod) if nmod.abi != abi::RustIntrinsic => {\n         for ni in nmod.items.iter() {\n             match ni.node {\n                 ast::ForeignItemFn(decl, _) => check_foreign_fn(cx, decl),"}, {"sha": "09bbb95fdd04e29ca825434ff1d3c9b8abe245c3", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -855,8 +855,8 @@ pub fn trans_external_path(ccx: &CrateContext, did: ast::DefId, t: ty::t) -> Val\n     let name = csearch::get_symbol(&ccx.sess().cstore, did);\n     match ty::get(t).sty {\n         ty::ty_bare_fn(ref fn_ty) => {\n-            match fn_ty.abis.for_target(ccx.sess().targ_cfg.os,\n-                                        ccx.sess().targ_cfg.arch) {\n+            match fn_ty.abi.for_target(ccx.sess().targ_cfg.os,\n+                                       ccx.sess().targ_cfg.arch) {\n                 Some(Rust) | Some(RustIntrinsic) => {\n                     get_extern_rust_fn(ccx,\n                                        fn_ty.sig.inputs.as_slice(),\n@@ -865,7 +865,7 @@ pub fn trans_external_path(ccx: &CrateContext, did: ast::DefId, t: ty::t) -> Val\n                                        did)\n                 }\n                 Some(..) | None => {\n-                    let c = foreign::llvm_calling_convention(ccx, fn_ty.abis);\n+                    let c = foreign::llvm_calling_convention(ccx, fn_ty.abi);\n                     let cconv = c.unwrap_or(lib::llvm::CCallConv);\n                     let llty = type_of_fn_from_ty(ccx, t);\n                     get_extern_fn(&mut *ccx.externs.borrow_mut(), ccx.llmod,\n@@ -1601,7 +1601,7 @@ impl<'a> Visitor<()> for TransItemVisitor<'a> {\n pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n     let _icx = push_ctxt(\"trans_item\");\n     match item.node {\n-      ast::ItemFn(decl, purity, _abis, ref generics, body) => {\n+      ast::ItemFn(decl, purity, _abi, ref generics, body) => {\n         if purity == ast::ExternFn  {\n             let llfndecl = get_item_val(ccx, item.id);\n             foreign::trans_rust_fn_with_foreign_abi(\n@@ -1721,7 +1721,7 @@ fn register_fn(ccx: &CrateContext,\n                -> ValueRef {\n     let f = match ty::get(node_type).sty {\n         ty::ty_bare_fn(ref f) => {\n-            assert!(f.abis.is_rust() || f.abis.is_intrinsic());\n+            assert!(f.abi == Rust || f.abi == RustIntrinsic);\n             f\n         }\n         _ => fail!(\"expected bare rust fn or an intrinsic\")\n@@ -1997,8 +1997,8 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n \n             match ni.node {\n                 ast::ForeignItemFn(..) => {\n-                    let abis = ccx.tcx.map.get_foreign_abis(id);\n-                    foreign::register_foreign_item_fn(ccx, abis, ni)\n+                    let abi = ccx.tcx.map.get_foreign_abi(id);\n+                    foreign::register_foreign_item_fn(ccx, abi, ni)\n                 }\n                 ast::ForeignItemStatic(..) => {\n                     foreign::register_static(ccx, ni)"}, {"sha": "13fcaa486f172296db41c16f41034d5f79a903ce", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -50,7 +50,7 @@ use util::ppaux::Repr;\n use middle::trans::type_::Type;\n \n use syntax::ast;\n-use syntax::abi::AbiSet;\n+use synabi = syntax::abi;\n use syntax::ast_map;\n \n pub struct MethodData {\n@@ -363,7 +363,7 @@ pub fn trans_fn_ref_with_vtables(\n \n         match map_node {\n             ast_map::NodeForeignItem(_) => {\n-                tcx.map.get_foreign_abis(def_id.node).is_intrinsic()\n+                tcx.map.get_foreign_abi(def_id.node) == synabi::RustIntrinsic\n             }\n             _ => false\n         }\n@@ -572,13 +572,11 @@ pub fn trans_call_inner<'a>(\n     };\n \n     let (abi, ret_ty) = match ty::get(callee_ty).sty {\n-        ty::ty_bare_fn(ref f) => (f.abis, f.sig.output),\n-        ty::ty_closure(ref f) => (AbiSet::Rust(), f.sig.output),\n+        ty::ty_bare_fn(ref f) => (f.abi, f.sig.output),\n+        ty::ty_closure(ref f) => (synabi::Rust, f.sig.output),\n         _ => fail!(\"expected bare rust fn or closure in trans_call_inner\")\n     };\n-    let is_rust_fn =\n-        abi.is_rust() ||\n-        abi.is_intrinsic();\n+    let is_rust_fn = abi == synabi::Rust || abi == synabi::RustIntrinsic;\n \n     // Generate a location to store the result. If the user does\n     // not care about the result, just make a stack slot."}, {"sha": "49a4a3ed25ca7aab7c0656776423d906106002ca", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -67,7 +67,7 @@ use middle::typeck::MethodCall;\n use util::common::indenter;\n use util::ppaux::Repr;\n use util::nodemap::NodeMap;\n-use middle::trans::machine::llsize_of;\n+use middle::trans::machine::{llsize_of, llsize_of_alloc};\n use middle::trans::type_::Type;\n \n use std::slice;\n@@ -1200,12 +1200,19 @@ fn trans_boxed_expr<'a>(bcx: &'a Block<'a>,\n         let size = llsize_of(bcx.ccx(), llty);\n         let Result { bcx: bcx, val: val } = malloc_raw_dyn(bcx, contents_ty,\n                                                            heap_exchange, size);\n-        let custom_cleanup_scope = fcx.push_custom_cleanup_scope();\n-        fcx.schedule_free_value(cleanup::CustomScope(custom_cleanup_scope),\n-                                val, heap_exchange);\n-        let bcx = trans_into(bcx, contents, SaveIn(val));\n-        fcx.pop_custom_cleanup_scope(custom_cleanup_scope);\n-        immediate_rvalue_bcx(bcx, val, box_ty).to_expr_datumblock()\n+        // Unique boxes do not allocate for zero-size types. The standard library may assume\n+        // that `free` is never called on the pointer returned for `~ZeroSizeType`.\n+        if llsize_of_alloc(bcx.ccx(), llty) == 0 {\n+            let bcx = trans_into(bcx, contents, SaveIn(val));\n+            immediate_rvalue_bcx(bcx, val, box_ty).to_expr_datumblock()\n+        } else {\n+            let custom_cleanup_scope = fcx.push_custom_cleanup_scope();\n+            fcx.schedule_free_value(cleanup::CustomScope(custom_cleanup_scope),\n+                                    val, heap_exchange);\n+            let bcx = trans_into(bcx, contents, SaveIn(val));\n+            fcx.pop_custom_cleanup_scope(custom_cleanup_scope);\n+            immediate_rvalue_bcx(bcx, val, box_ty).to_expr_datumblock()\n+        }\n     } else {\n         let base::MallocResult { bcx, smart_ptr: bx, body } =\n             base::malloc_general(bcx, contents_ty, heap);"}, {"sha": "e70d7bf7568a8880773e9b0f1431b1fd654d5308", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -27,7 +27,7 @@ use middle::ty::FnSig;\n use middle::ty;\n use std::cmp;\n use std::libc::c_uint;\n-use syntax::abi::{Cdecl, Aapcs, C, AbiSet, Win64};\n+use syntax::abi::{Cdecl, Aapcs, C, Win64, Abi};\n use syntax::abi::{RustIntrinsic, Rust, Stdcall, Fastcall, System};\n use syntax::codemap::Span;\n use syntax::parse::token::{InternedString, special_idents};\n@@ -73,10 +73,10 @@ struct LlvmSignature {\n // Calls to external functions\n \n pub fn llvm_calling_convention(ccx: &CrateContext,\n-                               abis: AbiSet) -> Option<CallConv> {\n+                               abi: Abi) -> Option<CallConv> {\n     let os = ccx.sess().targ_cfg.os;\n     let arch = ccx.sess().targ_cfg.arch;\n-    abis.for_target(os, arch).map(|abi| {\n+    abi.for_target(os, arch).map(|abi| {\n         match abi {\n             RustIntrinsic => {\n                 // Intrinsics are emitted by monomorphic fn\n@@ -180,27 +180,27 @@ pub fn register_static(ccx: &CrateContext,\n     }\n }\n \n-pub fn register_foreign_item_fn(ccx: &CrateContext, abis: AbiSet,\n+pub fn register_foreign_item_fn(ccx: &CrateContext, abi: Abi,\n                                 foreign_item: &ast::ForeignItem) -> ValueRef {\n     /*!\n      * Registers a foreign function found in a library.\n      * Just adds a LLVM global.\n      */\n \n-    debug!(\"register_foreign_item_fn(abis={}, \\\n+    debug!(\"register_foreign_item_fn(abi={}, \\\n             path={}, \\\n             foreign_item.id={})\",\n-           abis.repr(ccx.tcx()),\n+           abi.repr(ccx.tcx()),\n            ccx.tcx.map.path_to_str(foreign_item.id),\n            foreign_item.id);\n \n-    let cc = match llvm_calling_convention(ccx, abis) {\n+    let cc = match llvm_calling_convention(ccx, abi) {\n         Some(cc) => cc,\n         None => {\n             ccx.sess().span_fatal(foreign_item.span,\n                 format!(\"ABI `{}` has no suitable calling convention \\\n                       for target architecture\",\n-                      abis.user_string(ccx.tcx())));\n+                      abi.user_string(ccx.tcx())));\n         }\n     };\n \n@@ -263,8 +263,8 @@ pub fn trans_native_call<'a>(\n            ccx.tn.val_to_str(llfn),\n            ccx.tn.val_to_str(llretptr));\n \n-    let (fn_abis, fn_sig) = match ty::get(callee_ty).sty {\n-        ty::ty_bare_fn(ref fn_ty) => (fn_ty.abis, fn_ty.sig.clone()),\n+    let (fn_abi, fn_sig) = match ty::get(callee_ty).sty {\n+        ty::ty_bare_fn(ref fn_ty) => (fn_ty.abi, fn_ty.sig.clone()),\n         _ => ccx.sess().bug(\"trans_native_call called on non-function type\")\n     };\n     let llsig = foreign_signature(ccx, &fn_sig, passed_arg_tys.as_slice());\n@@ -354,14 +354,14 @@ pub fn trans_native_call<'a>(\n         llargs_foreign.push(llarg_foreign);\n     }\n \n-    let cc = match llvm_calling_convention(ccx, fn_abis) {\n+    let cc = match llvm_calling_convention(ccx, fn_abi) {\n         Some(cc) => cc,\n         None => {\n             // FIXME(#8357) We really ought to report a span here\n             ccx.sess().fatal(\n                 format!(\"ABI string `{}` has no suitable ABI \\\n                         for target architecture\",\n-                        fn_abis.user_string(ccx.tcx())));\n+                        fn_abi.user_string(ccx.tcx())));\n         }\n     };\n \n@@ -435,9 +435,9 @@ pub fn trans_foreign_mod(ccx: &CrateContext, foreign_mod: &ast::ForeignMod) {\n     for &foreign_item in foreign_mod.items.iter() {\n         match foreign_item.node {\n             ast::ForeignItemFn(..) => {\n-                let abis = foreign_mod.abis;\n-                if !(abis.is_rust() || abis.is_intrinsic()) {\n-                    register_foreign_item_fn(ccx, abis, foreign_item);\n+                match foreign_mod.abi {\n+                    Rust | RustIntrinsic => {}\n+                    abi => { register_foreign_item_fn(ccx, abi, foreign_item); }\n                 }\n             }\n             _ => {}\n@@ -486,7 +486,7 @@ pub fn register_rust_fn_with_foreign_abi(ccx: &CrateContext,\n     let t = ty::node_id_to_type(ccx.tcx(), node_id);\n     let (cconv, output) = match ty::get(t).sty {\n         ty::ty_bare_fn(ref fn_ty) => {\n-            let c = llvm_calling_convention(ccx, fn_ty.abis);\n+            let c = llvm_calling_convention(ccx, fn_ty.abi);\n             (c.unwrap_or(lib::llvm::CCallConv), fn_ty.sig.output)\n         }\n         _ => fail!(\"expected bare fn in register_rust_fn_with_foreign_abi\")\n@@ -534,7 +534,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n         // normal Rust function. This will be the type of the wrappee fn.\n         let f = match ty::get(t).sty {\n             ty::ty_bare_fn(ref f) => {\n-                assert!(!f.abis.is_rust() && !f.abis.is_intrinsic());\n+                assert!(f.abi != Rust && f.abi != RustIntrinsic);\n                 f\n             }\n             _ => {"}, {"sha": "851f8207cb68b79647cda2c2e10214586198ca71", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -34,6 +34,7 @@ use util::common::indenter;\n use util::ppaux::Repr;\n \n use std::c_str::ToCStr;\n+use syntax::abi::Rust;\n use syntax::parse::token;\n use syntax::{ast, ast_map, visit};\n \n@@ -393,7 +394,7 @@ pub fn trans_trait_callee_from_llval<'a>(bcx: &'a Block<'a>,\n     debug!(\"(translating trait callee) loading method\");\n     // Replace the self type (&Self or ~Self) with an opaque pointer.\n     let llcallee_ty = match ty::get(callee_ty).sty {\n-        ty::ty_bare_fn(ref f) if f.abis.is_rust() => {\n+        ty::ty_bare_fn(ref f) if f.abi == Rust => {\n             type_of_rust_fn(ccx, true, f.sig.inputs.slice_from(1), f.sig.output)\n         }\n         _ => {"}, {"sha": "6f2dbc182b04f3000852d8196b3af4cbbef87bd5", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -23,6 +23,7 @@ use middle::ty;\n use middle::typeck;\n use util::ppaux::Repr;\n \n+use syntax::abi;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util::local_def;\n@@ -99,7 +100,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n \n     match map_node {\n         ast_map::NodeForeignItem(_) => {\n-            if !ccx.tcx.map.get_foreign_abis(fn_id.node).is_intrinsic() {\n+            if ccx.tcx.map.get_foreign_abi(fn_id.node) != abi::RustIntrinsic {\n                 // Foreign externs don't have to be monomorphized.\n                 return (get_item_val(ccx, fn_id.node), true);\n             }\n@@ -150,7 +151,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n \n     let f = match ty::get(mono_ty).sty {\n         ty::ty_bare_fn(ref f) => {\n-            assert!(f.abis.is_rust() || f.abis.is_intrinsic());\n+            assert!(f.abi == abi::Rust || f.abi == abi::RustIntrinsic);\n             f\n         }\n         _ => fail!(\"expected bare rust fn or an intrinsic\")"}, {"sha": "f45ef45720483deb273d75be39d8e8e3a2bbf59b", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -19,6 +19,7 @@ use util::ppaux::Repr;\n \n use middle::trans::type_::Type;\n \n+use syntax::abi;\n use syntax::ast;\n use syntax::owned_slice::OwnedSlice;\n \n@@ -75,7 +76,7 @@ pub fn type_of_fn_from_ty(cx: &CrateContext, fty: ty::t) -> Type {\n             type_of_rust_fn(cx, true, f.sig.inputs.as_slice(), f.sig.output)\n         }\n         ty::ty_bare_fn(ref f) => {\n-            if f.abis.is_rust() || f.abis.is_intrinsic() {\n+            if f.abi == abi::Rust || f.abi == abi::RustIntrinsic {\n                 type_of_rust_fn(cx,\n                                 false,\n                                 f.sig.inputs.as_slice(),"}, {"sha": "85d47424e2b9ace93dbee763429e76c4c8850222", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -51,7 +51,7 @@ use syntax::parse::token;\n use syntax::parse::token::InternedString;\n use syntax::{ast, ast_map};\n use syntax::owned_slice::OwnedSlice;\n-use syntax::abi::AbiSet;\n+use syntax::abi;\n use syntax;\n use collections::enum_set::{EnumSet, CLike};\n \n@@ -416,8 +416,8 @@ pub fn type_id(t: t) -> uint { get(t).id }\n #[deriving(Clone, Eq, TotalEq, Hash)]\n pub struct BareFnTy {\n     pub purity: ast::Purity,\n-    pub abis: AbiSet,\n-    pub sig: FnSig\n+    pub abi: abi::Abi,\n+    pub sig: FnSig,\n }\n \n #[deriving(Clone, Eq, TotalEq, Hash)]\n@@ -796,7 +796,7 @@ pub enum type_err {\n     terr_mismatch,\n     terr_purity_mismatch(expected_found<Purity>),\n     terr_onceness_mismatch(expected_found<Onceness>),\n-    terr_abi_mismatch(expected_found<AbiSet>),\n+    terr_abi_mismatch(expected_found<abi::Abi>),\n     terr_mutability,\n     terr_sigil_mismatch(expected_found<ast::Sigil>),\n     terr_box_mutability,\n@@ -1409,7 +1409,7 @@ pub fn mk_ctor_fn(cx: &ctxt,\n     mk_bare_fn(cx,\n                BareFnTy {\n                    purity: ast::ImpureFn,\n-                   abis: AbiSet::Rust(),\n+                   abi: abi::Rust,\n                    sig: FnSig {\n                     binder_id: binder_id,\n                     inputs: input_args,\n@@ -4677,7 +4677,7 @@ pub fn hash_crate_independent(tcx: &ctxt, t: t, svh: &Svh) -> u64 {\n             ty_bare_fn(ref b) => {\n                 byte!(14);\n                 hash!(b.purity);\n-                hash!(b.abis);\n+                hash!(b.abi);\n             }\n             ty_closure(ref c) => {\n                 byte!(15);"}, {"sha": "02c4ffe68c1ee3f1c8e241a158c77d7529f29249", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -48,7 +48,7 @@ pub trait TypeFolder {\n                        fty: &ty::BareFnTy)\n                        -> ty::BareFnTy {\n         ty::BareFnTy { sig: self.fold_sig(&fty.sig),\n-                       abis: fty.abis,\n+                       abi: fty.abi,\n                        purity: fty.purity }\n     }\n "}, {"sha": "82be783616888aec3e1cdbba8f7d45eb412dbcbb", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -60,7 +60,7 @@ use middle::typeck::rscope::{RegionScope};\n use middle::typeck::lookup_def_tcx;\n use util::ppaux::Repr;\n \n-use syntax::abi::AbiSet;\n+use syntax::abi;\n use syntax::{ast, ast_util};\n use syntax::codemap::Span;\n use syntax::owned_slice::OwnedSlice;\n@@ -519,12 +519,12 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                 ty::mk_tup(tcx, flds)\n             }\n             ast::TyBareFn(ref bf) => {\n-                if bf.decl.variadic && !bf.abis.is_c() {\n+                if bf.decl.variadic && bf.abi != abi::C {\n                     tcx.sess.span_err(ast_ty.span,\n                                       \"variadic function must have C calling convention\");\n                 }\n                 ty::mk_bare_fn(tcx, ty_of_bare_fn(this, ast_ty.id, bf.purity,\n-                                                  bf.abis, bf.decl))\n+                                                  bf.abi, bf.decl))\n             }\n             ast::TyClosure(ref f) => {\n                 if f.sigil == ast::ManagedSigil {\n@@ -666,20 +666,20 @@ pub fn ty_of_method<AC:AstConv>(\n     untransformed_self_ty: ty::t,\n     explicit_self: ast::ExplicitSelf,\n     decl: &ast::FnDecl) -> ty::BareFnTy {\n-    ty_of_method_or_bare_fn(this, id, purity, AbiSet::Rust(), Some(SelfInfo {\n+    ty_of_method_or_bare_fn(this, id, purity, abi::Rust, Some(SelfInfo {\n         untransformed_self_ty: untransformed_self_ty,\n         explicit_self: explicit_self\n     }), decl)\n }\n \n pub fn ty_of_bare_fn<AC:AstConv>(this: &AC, id: ast::NodeId,\n-                                 purity: ast::Purity, abi: AbiSet,\n+                                 purity: ast::Purity, abi: abi::Abi,\n                                  decl: &ast::FnDecl) -> ty::BareFnTy {\n     ty_of_method_or_bare_fn(this, id, purity, abi, None, decl)\n }\n \n fn ty_of_method_or_bare_fn<AC:AstConv>(this: &AC, id: ast::NodeId,\n-                                       purity: ast::Purity, abi: AbiSet,\n+                                       purity: ast::Purity, abi: abi::Abi,\n                                        opt_self_info: Option<SelfInfo>,\n                                        decl: &ast::FnDecl) -> ty::BareFnTy {\n     debug!(\"ty_of_method_or_bare_fn\");\n@@ -726,7 +726,7 @@ fn ty_of_method_or_bare_fn<AC:AstConv>(this: &AC, id: ast::NodeId,\n \n     return ty::BareFnTy {\n         purity: purity,\n-        abis: abi,\n+        abi: abi,\n         sig: ty::FnSig {\n             binder_id: id,\n             inputs: self_and_input_tys,"}, {"sha": "dce4e7fb06b94f627a3e9e8b8a59e050040ba306", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -1164,7 +1164,7 @@ impl<'a> LookupContext<'a> {\n         let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n             sig: fn_sig,\n             purity: bare_fn_ty.purity,\n-            abis: bare_fn_ty.abis.clone(),\n+            abi: bare_fn_ty.abi.clone(),\n         });\n         debug!(\"after replacing bound regions, fty={}\", self.ty_to_str(fty));\n "}, {"sha": "20ab2b699c2b6525eca9f30ea34c5b1212fcd84e", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -120,7 +120,7 @@ use std::mem::replace;\n use std::result;\n use std::slice;\n use std::vec::Vec;\n-use syntax::abi::AbiSet;\n+use syntax::abi;\n use syntax::ast::{Provided, Required};\n use syntax::ast;\n use syntax::ast_util::local_def;\n@@ -599,7 +599,7 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n         check_bounds_are_used(ccx, t.span, &generics.ty_params, tpt_ty);\n       }\n       ast::ItemForeignMod(ref m) => {\n-        if m.abis.is_intrinsic() {\n+        if m.abi == abi::RustIntrinsic {\n             for item in m.items.iter() {\n                 check_intrinsic_type(ccx, *item);\n             }\n@@ -612,7 +612,7 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n \n                 match item.node {\n                     ast::ForeignItemFn(ref fn_decl, _) => {\n-                        if fn_decl.variadic && !m.abis.is_c() {\n+                        if fn_decl.variadic && m.abi != abi::C {\n                             ccx.tcx.sess.span_err(\n                                 item.span, \"variadic function must have C calling convention\");\n                         }\n@@ -4224,7 +4224,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n     };\n     let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n         purity: ast::UnsafeFn,\n-        abis: AbiSet::Intrinsic(),\n+        abi: abi::RustIntrinsic,\n         sig: FnSig {binder_id: it.id,\n                     inputs: inputs,\n                     output: output,"}, {"sha": "274f88ad4c37d919bd4d6426ac4fd6cbc29b682d", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -48,7 +48,7 @@ use util::ppaux::Repr;\n use std::rc::Rc;\n use collections::HashSet;\n \n-use syntax::abi::AbiSet;\n+use syntax::abi;\n use syntax::ast::{RegionTyParamBound, TraitTyParamBound};\n use syntax::ast;\n use syntax::ast_map;\n@@ -116,8 +116,8 @@ impl<'a> AstConv for CrateCtxt<'a> {\n         match self.tcx.map.find(id.node) {\n             Some(ast_map::NodeItem(item)) => ty_of_item(self, item),\n             Some(ast_map::NodeForeignItem(foreign_item)) => {\n-                let abis = self.tcx.map.get_foreign_abis(id.node);\n-                ty_of_foreign_item(self, foreign_item, abis)\n+                let abi = self.tcx.map.get_foreign_abi(id.node);\n+                ty_of_foreign_item(self, foreign_item, abi)\n             }\n             x => {\n                 self.tcx.sess.bug(format!(\"unexpected sort of node \\\n@@ -550,10 +550,10 @@ pub fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n \n fn ensure_generics_abi(ccx: &CrateCtxt,\n                        span: Span,\n-                       abis: AbiSet,\n+                       abi: abi::Abi,\n                        generics: &ast::Generics) {\n     if generics.ty_params.len() > 0 &&\n-       !(abis.is_rust() || abis.is_intrinsic()) {\n+       !(abi == abi::Rust || abi == abi::RustIntrinsic) {\n         ccx.tcx.sess.span_err(span,\n                               \"foreign functions may not use type parameters\");\n     }\n@@ -717,9 +717,9 @@ pub fn convert_foreign(ccx: &CrateCtxt, i: &ast::ForeignItem) {\n     // map, and I regard each time that I use it as a personal and\n     // moral failing, but at the moment it seems like the only\n     // convenient way to extract the ABI. - ndm\n-    let abis = ccx.tcx.map.get_foreign_abis(i.id);\n+    let abi = ccx.tcx.map.get_foreign_abi(i.id);\n \n-    let tpt = ty_of_foreign_item(ccx, i, abis);\n+    let tpt = ty_of_foreign_item(ccx, i, abi);\n     write_ty_to_tcx(ccx.tcx, i.id, tpt.ty);\n \n     ccx.tcx.tcache.borrow_mut().insert(local_def(i.id), tpt);\n@@ -891,15 +891,15 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n \n pub fn ty_of_foreign_item(ccx: &CrateCtxt,\n                           it: &ast::ForeignItem,\n-                          abis: AbiSet) -> ty::ty_param_bounds_and_ty\n+                          abi: abi::Abi) -> ty::ty_param_bounds_and_ty\n {\n     match it.node {\n         ast::ForeignItemFn(fn_decl, ref generics) => {\n             ty_of_foreign_fn_decl(ccx,\n                                   fn_decl,\n                                   local_def(it.id),\n                                   generics,\n-                                  abis)\n+                                  abi)\n         }\n         ast::ForeignItemStatic(t, _) => {\n             ty::ty_param_bounds_and_ty {\n@@ -1003,7 +1003,7 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n                              decl: &ast::FnDecl,\n                              def_id: ast::DefId,\n                              ast_generics: &ast::Generics,\n-                             abis: AbiSet)\n+                             abi: abi::Abi)\n                           -> ty::ty_param_bounds_and_ty {\n \n     for i in decl.inputs.iter() {\n@@ -1028,7 +1028,7 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n     let t_fn = ty::mk_bare_fn(\n         ccx.tcx,\n         ty::BareFnTy {\n-            abis: abis,\n+            abi: abi,\n             purity: ast::UnsafeFn,\n             sig: ty::FnSig {binder_id: def_id.node,\n                             inputs: input_tys,"}, {"sha": "dac018fb848a996505a247f24ef5694128e50b7c", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -77,6 +77,7 @@ use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::resolve::try_resolve_tvar_shallow;\n use util::common::indenter;\n \n+use syntax::abi;\n use syntax::ast::MutImmutable;\n use syntax::ast;\n \n@@ -384,7 +385,7 @@ impl<'f> Coerce<'f> {\n             debug!(\"coerce_from_bare_fn(a={}, b={})\",\n                    a.inf_str(self.get_ref().infcx), b.inf_str(self.get_ref().infcx));\n \n-            if !fn_ty_a.abis.is_rust() || fn_ty_a.purity != ast::ImpureFn {\n+            if fn_ty_a.abi != abi::Rust || fn_ty_a.purity != ast::ImpureFn {\n                 return self.subtype(a, b);\n             }\n "}, {"sha": "749c1ee69387c886acbf160712e0c3cbe1d40541", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -67,7 +67,7 @@ use std::result;\n use syntax::ast::{Onceness, Purity};\n use syntax::ast;\n use syntax::owned_slice::OwnedSlice;\n-use syntax::abi::AbiSet;\n+use syntax::abi;\n \n pub trait Combine {\n     fn infcx<'a>(&'a self) -> &'a InferCtxt<'a>;\n@@ -195,10 +195,10 @@ pub trait Combine {\n     fn bare_fn_tys(&self, a: &ty::BareFnTy,\n                    b: &ty::BareFnTy) -> cres<ty::BareFnTy> {\n         let purity = if_ok!(self.purities(a.purity, b.purity));\n-        let abi = if_ok!(self.abis(a.abis, b.abis));\n+        let abi = if_ok!(self.abi(a.abi, b.abi));\n         let sig = if_ok!(self.fn_sigs(&a.sig, &b.sig));\n         Ok(ty::BareFnTy {purity: purity,\n-                abis: abi,\n+                abi: abi,\n                 sig: sig})\n     }\n \n@@ -248,7 +248,7 @@ pub trait Combine {\n \n     fn purities(&self, a: Purity, b: Purity) -> cres<Purity>;\n \n-    fn abis(&self, a: AbiSet, b: AbiSet) -> cres<AbiSet> {\n+    fn abi(&self, a: abi::Abi, b: abi::Abi) -> cres<abi::Abi> {\n         if a == b {\n             Ok(a)\n         } else {"}, {"sha": "d635a9bdec41e03ae058fa06efb55ceb074c691e", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -358,7 +358,7 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n             }\n             let se_ty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n                 purity: ast::ImpureFn,\n-                abis: abi::AbiSet::Rust(),\n+                abi: abi::Rust,\n                 sig: ty::FnSig {\n                     binder_id: main_id,\n                     inputs: Vec::new(),\n@@ -404,7 +404,7 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n \n             let se_ty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n                 purity: ast::ImpureFn,\n-                abis: abi::AbiSet::Rust(),\n+                abi: abi::Rust,\n                 sig: ty::FnSig {\n                     binder_id: start_id,\n                     inputs: vec!("}, {"sha": "4a1be783d9d1d3563dec2a76d259a2c9dc0a41de", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -23,7 +23,7 @@ use middle::ty::{ty_uniq, ty_trait, ty_int, ty_uint, ty_unboxed_vec, ty_infer};\n use middle::ty;\n use middle::typeck;\n \n-use syntax::abi::AbiSet;\n+use syntax::abi;\n use syntax::ast_map;\n use syntax::codemap::{Span, Pos};\n use syntax::parse::token;\n@@ -253,14 +253,14 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> ~str {\n     }\n     fn bare_fn_to_str(cx: &ctxt,\n                       purity: ast::Purity,\n-                      abis: AbiSet,\n+                      abi: abi::Abi,\n                       ident: Option<ast::Ident>,\n                       sig: &ty::FnSig)\n                       -> ~str {\n-        let mut s = if abis.is_rust() {\n+        let mut s = if abi == abi::Rust {\n             ~\"\"\n         } else {\n-            format!(\"extern {} \", abis.to_str())\n+            format!(\"extern {} \", abi.to_str())\n         };\n \n         match purity {\n@@ -406,7 +406,7 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> ~str {\n           closure_to_str(cx, *f)\n       }\n       ty_bare_fn(ref f) => {\n-          bare_fn_to_str(cx, f.purity, f.abis, None, &f.sig)\n+          bare_fn_to_str(cx, f.purity, f.abi, None, &f.sig)\n       }\n       ty_infer(infer_ty) => infer_ty.to_str(),\n       ty_err => ~\"[type error]\",\n@@ -813,9 +813,9 @@ impl Repr for ast::Visibility {\n \n impl Repr for ty::BareFnTy {\n     fn repr(&self, tcx: &ctxt) -> ~str {\n-        format!(\"BareFnTy \\\\{purity: {:?}, abis: {}, sig: {}\\\\}\",\n+        format!(\"BareFnTy \\\\{purity: {:?}, abi: {}, sig: {}\\\\}\",\n              self.purity,\n-             self.abis.to_str(),\n+             self.abi.to_str(),\n              self.sig.repr(tcx))\n     }\n }\n@@ -968,13 +968,13 @@ impl UserString for ast::Ident {\n     }\n }\n \n-impl Repr for AbiSet {\n+impl Repr for abi::Abi {\n     fn repr(&self, _tcx: &ctxt) -> ~str {\n         self.to_str()\n     }\n }\n \n-impl UserString for AbiSet {\n+impl UserString for abi::Abi {\n     fn user_string(&self, _tcx: &ctxt) -> ~str {\n         self.to_str()\n     }"}, {"sha": "e92aec8e25c7c438d86f981bae30221836d22bb0", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -975,7 +975,7 @@ impl Clean<BareFunctionDecl> for ast::BareFnTy {\n                 type_params: Vec::new(),\n             },\n             decl: self.decl.clean(),\n-            abi: self.abis.to_str(),\n+            abi: self.abi.to_str(),\n         }\n     }\n }"}, {"sha": "a6c1ece6400edee9e7a323f3e1670e1640ec2f9d", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -11,7 +11,7 @@\n //! Rust AST Visitor. Extracts useful information and massages it into a form\n //! usable for clean\n \n-use syntax::abi::AbiSet;\n+use syntax::abi;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::ast_map;\n@@ -95,7 +95,7 @@ impl<'a> RustdocVisitor<'a> {\n     }\n \n     pub fn visit_fn(&mut self, item: &ast::Item, fd: &ast::FnDecl,\n-                    purity: &ast::Purity, _abi: &AbiSet,\n+                    purity: &ast::Purity, _abi: &abi::Abi,\n                     gen: &ast::Generics) -> Function {\n         debug!(\"Visiting fn\");\n         Function {"}, {"sha": "13e4a010a5e189e74b276cf71214e50e6fe97658", "filename": "src/libserialize/base64.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibserialize%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibserialize%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fbase64.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -23,11 +23,11 @@ pub enum CharacterSet {\n /// Contains configuration parameters for `to_base64`.\n pub struct Config {\n     /// Character set to use\n-    char_set: CharacterSet,\n+    pub char_set: CharacterSet,\n     /// True to pad output with `=` characters\n-    pad: bool,\n+    pub pad: bool,\n     /// `Some(len)` to wrap lines at `len`, `None` to disable line wrapping\n-    line_length: Option<uint>\n+    pub line_length: Option<uint>\n }\n \n /// Configuration for RFC 4648 standard base64 encoding"}, {"sha": "b6e3e56835f02147dee115b5430b65af1bf5c4df", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -232,4 +232,5 @@ mod std {\n     pub use to_str;\n     pub use ty;\n     pub use unstable;\n+    pub use vec;\n }"}, {"sha": "5c1b6cd47910addec9809d2f69af499161be96f7", "filename": "src/libstd/rt/global_heap.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibstd%2Frt%2Fglobal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibstd%2Frt%2Fglobal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fglobal_heap.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -68,8 +68,17 @@ pub unsafe fn realloc_raw(ptr: *mut u8, size: uint) -> *mut u8 {\n #[cfg(not(test))]\n #[lang=\"exchange_malloc\"]\n #[inline]\n-pub unsafe fn exchange_malloc(size: uint) -> *u8 {\n-    malloc_raw(size) as *u8\n+pub unsafe fn exchange_malloc(size: uint) -> *mut u8 {\n+    // The compiler never calls `exchange_free` on ~ZeroSizeType, so zero-size\n+    // allocations can point to this `static`. It would be incorrect to use a null\n+    // pointer, due to enums assuming types like unique pointers are never null.\n+    static EMPTY: () = ();\n+\n+    if size == 0 {\n+        &EMPTY as *() as *mut u8\n+    } else {\n+        malloc_raw(size)\n+    }\n }\n \n // FIXME: #7496"}, {"sha": "e414ff25d433539eb419d3e556883f17d3e3c71e", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 52, "deletions": 4, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -310,11 +310,24 @@ impl<T: Clone> Vec<T> {\n \n impl<T:Clone> Clone for Vec<T> {\n     fn clone(&self) -> Vec<T> {\n-        let mut vector = Vec::with_capacity(self.len());\n-        for element in self.iter() {\n-            vector.push((*element).clone())\n+        self.iter().map(|x| x.clone()).collect()\n+    }\n+\n+    fn clone_from(&mut self, other: &Vec<T>) {\n+        // drop anything in self that will not be overwritten\n+        if self.len() > other.len() {\n+            self.truncate(other.len())\n         }\n-        vector\n+\n+        // reuse the contained values' allocations/resources.\n+        for (place, thing) in self.mut_iter().zip(other.iter()) {\n+            place.clone_from(thing)\n+        }\n+\n+        // self.len <= other.len due to the truncate above, so the\n+        // slice here is always in-bounds.\n+        let len = self.len();\n+        self.extend(other.slice_from(len).iter().map(|x| x.clone()));\n     }\n }\n \n@@ -1475,4 +1488,39 @@ mod tests {\n \n         assert!(values == Vec::from_slice([2u8, 3, 5, 6, 7]));\n     }\n+\n+    #[test]\n+    fn test_clone() {\n+        let v: Vec<int> = vec!();\n+        let w = vec!(1, 2, 3);\n+\n+        assert_eq!(v, v.clone());\n+\n+        let z = w.clone();\n+        assert_eq!(w, z);\n+        // they should be disjoint in memory.\n+        assert!(w.as_ptr() != z.as_ptr())\n+    }\n+\n+    #[test]\n+    fn test_clone_from() {\n+        let mut v = vec!();\n+        let three = vec!(~1, ~2, ~3);\n+        let two = vec!(~4, ~5);\n+        // zero, long\n+        v.clone_from(&three);\n+        assert_eq!(v, three);\n+\n+        // equal\n+        v.clone_from(&three);\n+        assert_eq!(v, three);\n+\n+        // long, short\n+        v.clone_from(&two);\n+        assert_eq!(v, two);\n+\n+        // short, long\n+        v.clone_from(&three);\n+        assert_eq!(v, three)\n+    }\n }"}, {"sha": "17251d31351ab303b72be6c41091c02391280fba", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 21, "deletions": 253, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -9,12 +9,11 @@\n // except according to those terms.\n \n use std::fmt;\n-use std::fmt::Show;\n \n #[deriving(Eq)]\n pub enum Os { OsWin32, OsMacos, OsLinux, OsAndroid, OsFreebsd, }\n \n-#[deriving(Eq, TotalEq, Hash)]\n+#[deriving(Eq, TotalEq, Hash, Encodable, Decodable, Clone)]\n pub enum Abi {\n     // NB: This ordering MUST match the AbiDatas array below.\n     // (This is ensured by the test indices_are_correct().)\n@@ -65,11 +64,6 @@ pub enum AbiArchitecture {\n     Archs(u32)  // Multiple architectures (bitset)\n }\n \n-#[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n-pub struct AbiSet {\n-    bits: u32   // each bit represents one of the abis below\n-}\n-\n static AbiDatas: &'static [AbiData] = &[\n     // Platform-specific ABIs\n     AbiData {abi: Cdecl, name: \"cdecl\", abi_arch: Archs(IntelBits)},\n@@ -136,12 +130,20 @@ impl Abi {\n         self.data().name\n     }\n \n-    pub fn for_target(&self, os: Os, arch: Architecture) -> Abi {\n-        match (*self, os, arch) {\n+    pub fn for_target(&self, os: Os, arch: Architecture) -> Option<Abi> {\n+        // If this ABI isn't actually for the specified architecture, then we\n+        // short circuit early\n+        match self.data().abi_arch {\n+            Archs(a) if a & arch.bit() == 0 => return None,\n+            Archs(_) | RustArch | AllArch => {}\n+        }\n+        // Transform this ABI as appropriate for the requested os/arch\n+        // combination.\n+        Some(match (*self, os, arch) {\n             (System, OsWin32, X86) => Stdcall,\n             (System, _, _) => C,\n             (me, _, _) => me,\n-        }\n+        })\n     }\n }\n \n@@ -151,138 +153,9 @@ impl Architecture {\n     }\n }\n \n-impl AbiSet {\n-    pub fn from(abi: Abi) -> AbiSet {\n-        AbiSet { bits: (1 << abi.index()) }\n-    }\n-\n-    #[inline]\n-    pub fn Rust() -> AbiSet {\n-        AbiSet::from(Rust)\n-    }\n-\n-    #[inline]\n-    pub fn C() -> AbiSet {\n-        AbiSet::from(C)\n-    }\n-\n-    #[inline]\n-    pub fn Intrinsic() -> AbiSet {\n-        AbiSet::from(RustIntrinsic)\n-    }\n-\n-    pub fn default() -> AbiSet {\n-        AbiSet::C()\n-    }\n-\n-    pub fn empty() -> AbiSet {\n-        AbiSet { bits: 0 }\n-    }\n-\n-    #[inline]\n-    pub fn is_rust(&self) -> bool {\n-        self.bits == 1 << Rust.index()\n-    }\n-\n-    #[inline]\n-    pub fn is_c(&self) -> bool {\n-        self.bits == 1 << C.index()\n-    }\n-\n-    #[inline]\n-    pub fn is_intrinsic(&self) -> bool {\n-        self.bits == 1 << RustIntrinsic.index()\n-    }\n-\n-    pub fn contains(&self, abi: Abi) -> bool {\n-        (self.bits & (1 << abi.index())) != 0\n-    }\n-\n-    pub fn subset_of(&self, other_abi_set: AbiSet) -> bool {\n-        (self.bits & other_abi_set.bits) == self.bits\n-    }\n-\n-    pub fn add(&mut self, abi: Abi) {\n-        self.bits |= 1 << abi.index();\n-    }\n-\n-    pub fn each(&self, op: |abi: Abi| -> bool) -> bool {\n-        each_abi(|abi| !self.contains(abi) || op(abi))\n-    }\n-\n-    pub fn is_empty(&self) -> bool {\n-        self.bits == 0\n-    }\n-\n-    pub fn for_target(&self, os: Os, arch: Architecture) -> Option<Abi> {\n-        // NB---Single platform ABIs come first\n-\n-        let mut res = None;\n-\n-        self.each(|abi| {\n-            let data = abi.data();\n-            match data.abi_arch {\n-                Archs(a) if (a & arch.bit()) != 0 => { res = Some(abi); false }\n-                Archs(_) => { true }\n-                RustArch | AllArch => { res = Some(abi); false }\n-            }\n-        });\n-\n-        res.map(|r| r.for_target(os, arch))\n-    }\n-\n-    pub fn check_valid(&self) -> Option<(Abi, Abi)> {\n-        let mut abis = Vec::new();\n-        self.each(|abi| { abis.push(abi); true });\n-\n-        for (i, abi) in abis.iter().enumerate() {\n-            let data = abi.data();\n-            for other_abi in abis.slice(0, i).iter() {\n-                let other_data = other_abi.data();\n-                debug!(\"abis=({:?},{:?}) datas=({:?},{:?})\",\n-                       abi, data.abi_arch,\n-                       other_abi, other_data.abi_arch);\n-                match (&data.abi_arch, &other_data.abi_arch) {\n-                    (&AllArch, &AllArch) => {\n-                        // Two cross-architecture ABIs\n-                        return Some((*abi, *other_abi));\n-                    }\n-                    (_, &RustArch) |\n-                    (&RustArch, _) => {\n-                        // Cannot combine Rust or Rust-Intrinsic with\n-                        // anything else.\n-                        return Some((*abi, *other_abi));\n-                    }\n-                    (&Archs(is), &Archs(js)) if (is & js) != 0 => {\n-                        // Two ABIs for same architecture\n-                        return Some((*abi, *other_abi));\n-                    }\n-                    _ => {}\n-                }\n-            }\n-        }\n-\n-        return None;\n-    }\n-}\n-\n impl fmt::Show for Abi {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.data().name.fmt(f)\n-    }\n-}\n-\n-impl fmt::Show for AbiSet {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f.buf, \"\\\"\"));\n-        let mut first = true;\n-        self.each(|abi| {\n-            if first { first = false; }\n-            else { let _ = write!(f.buf, \" \"); }\n-            let _ = write!(f.buf, \"{}\", abi.data().name);\n-            true\n-        });\n-        write!(f.buf, \"\\\"\")\n+        write!(f.buf, \"\\\"{}\\\"\", self.name())\n     }\n }\n \n@@ -304,95 +177,6 @@ fn lookup_baz() {\n     assert!(abi.is_none());\n }\n \n-#[cfg(test)]\n-fn cannot_combine(n: Abi, m: Abi) {\n-    let mut set = AbiSet::empty();\n-    set.add(n);\n-    set.add(m);\n-    match set.check_valid() {\n-        Some((a, b)) => {\n-            assert!((n == a && m == b) ||\n-                         (m == a && n == b));\n-        }\n-        None => {\n-            fail!(\"invalid match not detected\");\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-fn can_combine(n: Abi, m: Abi) {\n-    let mut set = AbiSet::empty();\n-    set.add(n);\n-    set.add(m);\n-    match set.check_valid() {\n-        Some((_, _)) => {\n-            fail!(\"valid match declared invalid\");\n-        }\n-        None => {}\n-    }\n-}\n-\n-#[test]\n-fn cannot_combine_cdecl_and_stdcall() {\n-    cannot_combine(Cdecl, Stdcall);\n-}\n-\n-#[test]\n-fn cannot_combine_c_and_rust() {\n-    cannot_combine(C, Rust);\n-}\n-\n-#[test]\n-fn cannot_combine_rust_and_cdecl() {\n-    cannot_combine(Rust, Cdecl);\n-}\n-\n-#[test]\n-fn cannot_combine_rust_intrinsic_and_cdecl() {\n-    cannot_combine(RustIntrinsic, Cdecl);\n-}\n-\n-#[test]\n-fn can_combine_system_and_cdecl() {\n-    can_combine(System, Cdecl);\n-}\n-\n-#[test]\n-fn can_combine_c_and_stdcall() {\n-    can_combine(C, Stdcall);\n-}\n-\n-#[test]\n-fn can_combine_aapcs_and_stdcall() {\n-    can_combine(Aapcs, Stdcall);\n-}\n-\n-#[test]\n-fn abi_to_str_stdcall_aaps() {\n-    let mut set = AbiSet::empty();\n-    set.add(Aapcs);\n-    set.add(Stdcall);\n-    assert!(set.to_str() == ~\"\\\"stdcall aapcs\\\"\");\n-}\n-\n-#[test]\n-fn abi_to_str_c_aaps() {\n-    let mut set = AbiSet::empty();\n-    set.add(Aapcs);\n-    set.add(C);\n-    debug!(\"set = {}\", set.to_str());\n-    assert!(set.to_str() == ~\"\\\"aapcs C\\\"\");\n-}\n-\n-#[test]\n-fn abi_to_str_rust() {\n-    let mut set = AbiSet::empty();\n-    set.add(Rust);\n-    debug!(\"set = {}\", set.to_str());\n-    assert!(set.to_str() == ~\"\\\"Rust\\\"\");\n-}\n-\n #[test]\n fn indices_are_correct() {\n     for (i, abi_data) in AbiDatas.iter().enumerate() {\n@@ -407,30 +191,14 @@ fn indices_are_correct() {\n     assert_eq!(ArmBits, bits);\n }\n \n-#[cfg(test)]\n-fn get_arch(abis: &[Abi], os: Os, arch: Architecture) -> Option<Abi> {\n-    let mut set = AbiSet::empty();\n-    for &abi in abis.iter() {\n-        set.add(abi);\n-    }\n-    set.for_target(os, arch)\n-}\n-\n-#[test]\n-fn pick_multiplatform() {\n-    assert_eq!(get_arch([C, Cdecl], OsLinux, X86), Some(Cdecl));\n-    assert_eq!(get_arch([C, Cdecl], OsLinux, X86_64), Some(Cdecl));\n-    assert_eq!(get_arch([C, Cdecl], OsLinux, Arm), Some(C));\n-}\n-\n #[test]\n fn pick_uniplatform() {\n-    assert_eq!(get_arch([Stdcall], OsLinux, X86), Some(Stdcall));\n-    assert_eq!(get_arch([Stdcall], OsLinux, Arm), None);\n-    assert_eq!(get_arch([System], OsLinux, X86), Some(C));\n-    assert_eq!(get_arch([System], OsWin32, X86), Some(Stdcall));\n-    assert_eq!(get_arch([System], OsWin32, X86_64), Some(C));\n-    assert_eq!(get_arch([System], OsWin32, Arm), Some(C));\n-    assert_eq!(get_arch([Stdcall], OsWin32, X86), Some(Stdcall));\n-    assert_eq!(get_arch([Stdcall], OsWin32, X86_64), Some(Stdcall));\n+    assert_eq!(Stdcall.for_target(OsLinux, X86), Some(Stdcall));\n+    assert_eq!(Stdcall.for_target(OsLinux, Arm), None);\n+    assert_eq!(System.for_target(OsLinux, X86), Some(C));\n+    assert_eq!(System.for_target(OsWin32, X86), Some(Stdcall));\n+    assert_eq!(System.for_target(OsWin32, X86_64), Some(C));\n+    assert_eq!(System.for_target(OsWin32, Arm), Some(C));\n+    assert_eq!(Stdcall.for_target(OsWin32, X86), Some(Stdcall));\n+    assert_eq!(Stdcall.for_target(OsWin32, X86_64), Some(Stdcall));\n }"}, {"sha": "4612f8e6673643186d8ff301b449b56971606832", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -11,7 +11,7 @@\n // The Rust abstract syntax tree.\n \n use codemap::{Span, Spanned, DUMMY_SP};\n-use abi::AbiSet;\n+use abi::Abi;\n use ast_util;\n use owned_slice::OwnedSlice;\n use parse::token::{InternedString, special_idents, str_to_ident};\n@@ -807,7 +807,7 @@ pub struct ClosureTy {\n #[deriving(Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct BareFnTy {\n     pub purity: Purity,\n-    pub abis: AbiSet,\n+    pub abi: Abi,\n     pub lifetimes: Vec<Lifetime>,\n     pub decl: P<FnDecl>\n }\n@@ -941,7 +941,7 @@ pub struct Mod {\n \n #[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub struct ForeignMod {\n-    pub abis: AbiSet,\n+    pub abi: Abi,\n     pub view_items: Vec<ViewItem>,\n     pub items: Vec<@ForeignItem>,\n }\n@@ -1119,7 +1119,7 @@ pub struct Item {\n #[deriving(Clone, Eq, TotalEq, Encodable, Decodable, Hash)]\n pub enum Item_ {\n     ItemStatic(P<Ty>, Mutability, @Expr),\n-    ItemFn(P<FnDecl>, Purity, AbiSet, Generics, P<Block>),\n+    ItemFn(P<FnDecl>, Purity, Abi, Generics, P<Block>),\n     ItemMod(Mod),\n     ItemForeignMod(ForeignMod),\n     ItemTy(P<Ty>, Generics),"}, {"sha": "e098dcd99fd8814083d7de2d6abbb7b705beb55a", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use abi::AbiSet;\n+use abi;\n use ast::*;\n use ast_util;\n use codemap::Span;\n@@ -224,19 +224,19 @@ impl Map {\n         }\n     }\n \n-    pub fn get_foreign_abis(&self, id: NodeId) -> AbiSet {\n+    pub fn get_foreign_abi(&self, id: NodeId) -> abi::Abi {\n         let parent = self.get_parent(id);\n-        let abis = match self.find_entry(parent) {\n+        let abi = match self.find_entry(parent) {\n             Some(EntryItem(_, i)) => match i.node {\n-                ItemForeignMod(ref nm) => Some(nm.abis),\n+                ItemForeignMod(ref nm) => Some(nm.abi),\n                 _ => None\n             },\n             // Wrong but OK, because the only inlined foreign items are intrinsics.\n-            Some(RootInlinedParent(_)) => Some(AbiSet::Intrinsic()),\n+            Some(RootInlinedParent(_)) => Some(abi::RustIntrinsic),\n             _ => None\n         };\n-        match abis {\n-            Some(abis) => abis,\n+        match abi {\n+            Some(abi) => abi,\n             None => fail!(\"expected foreign mod or inlined parent, found {}\",\n                           self.node_to_str(parent))\n         }"}, {"sha": "ef62f0a01f6c1fdb12a8bcdfdf553cd7c34157d1", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use abi::AbiSet;\n+use abi;\n use ast::{P, Ident};\n use ast;\n use ast_util;\n@@ -826,7 +826,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                   Vec::new(),\n                   ast::ItemFn(self.fn_decl(inputs, output),\n                               ast::ImpureFn,\n-                              AbiSet::Rust(),\n+                              abi::Rust,\n                               generics,\n                               body))\n     }"}, {"sha": "06bf892771dc6b6e6971c367e3d2cf9b5075f4d8", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -170,7 +170,7 @@ pub trait Folder {\n                 TyBareFn(@BareFnTy {\n                     lifetimes: f.lifetimes.iter().map(|l| fold_lifetime(l, self)).collect(),\n                     purity: f.purity,\n-                    abis: f.abis,\n+                    abi: f.abi,\n                     decl: self.fold_fn_decl(f.decl)\n                 })\n             }\n@@ -198,7 +198,7 @@ pub trait Folder {\n \n     fn fold_foreign_mod(&mut self, nm: &ForeignMod) -> ForeignMod {\n         ast::ForeignMod {\n-            abis: nm.abis,\n+            abi: nm.abi,\n             view_items: nm.view_items\n                           .iter()\n                           .map(|x| self.fold_view_item(x))"}, {"sha": "dbb85972774e71b9e3dfcda0f394c28f94bf6bd6", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -657,7 +657,7 @@ mod test {\n                                 variadic: false\n                             }),\n                                     ast::ImpureFn,\n-                                    abi::AbiSet::Rust(),\n+                                    abi::Rust,\n                                     ast::Generics{ // no idea on either of these:\n                                         lifetimes: Vec::new(),\n                                         ty_params: OwnedSlice::empty(),"}, {"sha": "2d78bfe5694c1130233afad698feef2c68d7f937", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 34, "deletions": 51, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -11,7 +11,6 @@\n #![macro_escape]\n \n use abi;\n-use abi::AbiSet;\n use ast::{Sigil, BorrowedSigil, ManagedSigil, OwnedSigil};\n use ast::{BareFnTy, ClosureTy};\n use ast::{RegionTyParamBound, TraitTyParamBound};\n@@ -873,17 +872,17 @@ impl<'a> Parser<'a> {\n \n         */\n \n-        let abis = if self.eat_keyword(keywords::Extern) {\n-            self.parse_opt_abis().unwrap_or(AbiSet::C())\n+        let abi = if self.eat_keyword(keywords::Extern) {\n+            self.parse_opt_abi().unwrap_or(abi::C)\n         } else {\n-            AbiSet::Rust()\n+            abi::Rust\n         };\n \n         let purity = self.parse_unsafety();\n         self.expect_keyword(keywords::Fn);\n         let (decl, lifetimes) = self.parse_ty_fn_decl(true);\n         return TyBareFn(@BareFnTy {\n-            abis: abis,\n+            abi: abi,\n             purity: purity,\n             lifetimes: lifetimes,\n             decl: decl\n@@ -3770,11 +3769,11 @@ impl<'a> Parser<'a> {\n     }\n \n     // parse an item-position function declaration.\n-    fn parse_item_fn(&mut self, purity: Purity, abis: AbiSet) -> ItemInfo {\n+    fn parse_item_fn(&mut self, purity: Purity, abi: abi::Abi) -> ItemInfo {\n         let (ident, generics) = self.parse_fn_header();\n         let decl = self.parse_fn_decl(false);\n         let (inner_attrs, body) = self.parse_inner_attrs_and_block();\n-        (ident, ItemFn(decl, purity, abis, generics, body), Some(inner_attrs))\n+        (ident, ItemFn(decl, purity, abi, generics, body), Some(inner_attrs))\n     }\n \n     // parse a method in a trait impl, starting with `attrs` attributes.\n@@ -4237,7 +4236,7 @@ impl<'a> Parser<'a> {\n     // at this point, this is essentially a wrapper for\n     // parse_foreign_items.\n     fn parse_foreign_mod_items(&mut self,\n-                               abis: AbiSet,\n+                               abi: abi::Abi,\n                                first_item_attrs: Vec<Attribute> )\n                                -> ForeignMod {\n         let ParsedItemsAndViewItems {\n@@ -4252,7 +4251,7 @@ impl<'a> Parser<'a> {\n         }\n         assert!(self.token == token::RBRACE);\n         ast::ForeignMod {\n-            abis: abis,\n+            abi: abi,\n             view_items: view_items,\n             items: foreign_items\n         }\n@@ -4310,17 +4309,17 @@ impl<'a> Parser<'a> {\n     /// extern {}\n     fn parse_item_foreign_mod(&mut self,\n                               lo: BytePos,\n-                              opt_abis: Option<AbiSet>,\n+                              opt_abi: Option<abi::Abi>,\n                               visibility: Visibility,\n                               attrs: Vec<Attribute> )\n                               -> ItemOrViewItem {\n \n         self.expect(&token::LBRACE);\n \n-        let abis = opt_abis.unwrap_or(AbiSet::C());\n+        let abi = opt_abi.unwrap_or(abi::C);\n \n         let (inner, next) = self.parse_inner_attrs_and_next();\n-        let m = self.parse_foreign_mod_items(abis, next);\n+        let m = self.parse_foreign_mod_items(abi, next);\n         self.expect(&token::RBRACE);\n \n         let item = self.mk_item(lo,\n@@ -4440,45 +4439,29 @@ impl<'a> Parser<'a> {\n \n     // Parses a string as an ABI spec on an extern type or module. Consumes\n     // the `extern` keyword, if one is found.\n-    fn parse_opt_abis(&mut self) -> Option<AbiSet> {\n+    fn parse_opt_abi(&mut self) -> Option<abi::Abi> {\n         match self.token {\n-            token::LIT_STR(s)\n-            | token::LIT_STR_RAW(s, _) => {\n+            token::LIT_STR(s) | token::LIT_STR_RAW(s, _) => {\n                 self.bump();\n                 let identifier_string = token::get_ident(s);\n                 let the_string = identifier_string.get();\n-                let mut abis = AbiSet::empty();\n-                for word in the_string.words() {\n-                    match abi::lookup(word) {\n-                        Some(abi) => {\n-                            if abis.contains(abi) {\n-                                self.span_err(\n-                                    self.span,\n-                                    format!(\"ABI `{}` appears twice\",\n-                                         word));\n-                            } else {\n-                                abis.add(abi);\n-                            }\n-                        }\n-\n-                        None => {\n-                            self.span_err(\n-                                self.span,\n-                                format!(\"illegal ABI: \\\n-                                      expected one of [{}], \\\n-                                      found `{}`\",\n-                                     abi::all_names().connect(\", \"),\n-                                     word));\n-                        }\n-                     }\n-                 }\n-                Some(abis)\n+                match abi::lookup(the_string) {\n+                    Some(abi) => Some(abi),\n+                    None => {\n+                        self.span_err(\n+                            self.span,\n+                            format!(\"illegal ABI: \\\n+                                  expected one of [{}], \\\n+                                  found `{}`\",\n+                                 abi::all_names().connect(\", \"),\n+                                 the_string));\n+                        None\n+                    }\n+                }\n             }\n \n-            _ => {\n-                None\n-             }\n-         }\n+            _ => None,\n+        }\n     }\n \n     // parse one of the items or view items allowed by the\n@@ -4531,13 +4514,13 @@ impl<'a> Parser<'a> {\n                 return self.parse_item_extern_crate(lo, visibility, attrs);\n             }\n \n-            let opt_abis = self.parse_opt_abis();\n+            let opt_abi = self.parse_opt_abi();\n \n             if self.eat_keyword(keywords::Fn) {\n                 // EXTERN FUNCTION ITEM\n-                let abis = opt_abis.unwrap_or(AbiSet::C());\n+                let abi = opt_abi.unwrap_or(abi::C);\n                 let (ident, item_, extra_attrs) =\n-                    self.parse_item_fn(ExternFn, abis);\n+                    self.parse_item_fn(ExternFn, abi);\n                 let item = self.mk_item(lo,\n                                         self.last_span.hi,\n                                         ident,\n@@ -4546,7 +4529,7 @@ impl<'a> Parser<'a> {\n                                         maybe_append(attrs, extra_attrs));\n                 return IoviItem(item);\n             } else if self.token == token::LBRACE {\n-                return self.parse_item_foreign_mod(lo, opt_abis, visibility, attrs);\n+                return self.parse_item_foreign_mod(lo, opt_abi, visibility, attrs);\n             }\n \n             let token_str = self.this_token_to_str();\n@@ -4572,7 +4555,7 @@ impl<'a> Parser<'a> {\n             // FUNCTION ITEM\n             self.bump();\n             let (ident, item_, extra_attrs) =\n-                self.parse_item_fn(ImpureFn, AbiSet::Rust());\n+                self.parse_item_fn(ImpureFn, abi::Rust);\n             let item = self.mk_item(lo,\n                                     self.last_span.hi,\n                                     ident,\n@@ -4587,7 +4570,7 @@ impl<'a> Parser<'a> {\n             self.bump();\n             self.expect_keyword(keywords::Fn);\n             let (ident, item_, extra_attrs) =\n-                self.parse_item_fn(UnsafeFn, AbiSet::Rust());\n+                self.parse_item_fn(UnsafeFn, abi::Rust);\n             let item = self.mk_item(lo,\n                                     self.last_span.hi,\n                                     ident,"}, {"sha": "1eee0fb87d6bf15a7edab52d6369ee6edd35ee9d", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use abi::AbiSet;\n+use abi;\n use ast::{P, RegionTyParamBound, TraitTyParamBound, Required, Provided};\n use ast;\n use ast_util;\n@@ -190,7 +190,7 @@ pub fn fun_to_str(decl: &ast::FnDecl, purity: ast::Purity, name: ast::Ident,\n                   opt_explicit_self: Option<ast::ExplicitSelf_>,\n                   generics: &ast::Generics) -> ~str {\n     to_str(|s| {\n-        try!(s.print_fn(decl, Some(purity), AbiSet::Rust(),\n+        try!(s.print_fn(decl, Some(purity), abi::Rust,\n                         name, generics, opt_explicit_self, ast::Inherited));\n         try!(s.end()); // Close the head box\n         s.end() // Close the outer box\n@@ -478,7 +478,7 @@ impl<'a> State<'a> {\n                     lifetimes: f.lifetimes.clone(),\n                     ty_params: OwnedSlice::empty()\n                 };\n-                try!(self.print_ty_fn(Some(f.abis), None, &None,\n+                try!(self.print_ty_fn(Some(f.abi), None, &None,\n                                    f.purity, ast::Many, f.decl, None, &None,\n                                    Some(&generics), None));\n             }\n@@ -524,7 +524,7 @@ impl<'a> State<'a> {\n         try!(self.print_outer_attributes(item.attrs.as_slice()));\n         match item.node {\n             ast::ForeignItemFn(decl, ref generics) => {\n-                try!(self.print_fn(decl, None, AbiSet::Rust(), item.ident, generics,\n+                try!(self.print_fn(decl, None, abi::Rust, item.ident, generics,\n                 None, item.vis));\n                 try!(self.end()); // end head-ibox\n                 try!(word(&mut self.s, \";\"));\n@@ -590,7 +590,7 @@ impl<'a> State<'a> {\n             }\n             ast::ItemForeignMod(ref nmod) => {\n                 try!(self.head(\"extern\"));\n-                try!(self.word_nbsp(nmod.abis.to_str()));\n+                try!(self.word_nbsp(nmod.abi.to_str()));\n                 try!(self.bopen());\n                 try!(self.print_foreign_mod(nmod, item.attrs.as_slice()));\n                 try!(self.bclose(item.span));\n@@ -883,7 +883,7 @@ impl<'a> State<'a> {\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(meth.span.lo));\n         try!(self.print_outer_attributes(meth.attrs.as_slice()));\n-        try!(self.print_fn(meth.decl, Some(meth.purity), AbiSet::Rust(),\n+        try!(self.print_fn(meth.decl, Some(meth.purity), abi::Rust,\n                         meth.ident, &meth.generics, Some(meth.explicit_self.node),\n                         meth.vis));\n         try!(word(&mut self.s, \" \"));\n@@ -1717,14 +1717,14 @@ impl<'a> State<'a> {\n     pub fn print_fn(&mut self,\n                     decl: &ast::FnDecl,\n                     purity: Option<ast::Purity>,\n-                    abis: AbiSet,\n+                    abi: abi::Abi,\n                     name: ast::Ident,\n                     generics: &ast::Generics,\n                     opt_explicit_self: Option<ast::ExplicitSelf_>,\n                     vis: ast::Visibility) -> IoResult<()> {\n         try!(self.head(\"\"));\n-        try!(self.print_fn_header_info(opt_explicit_self, purity, abis,\n-                                    ast::Many, None, vis));\n+        try!(self.print_fn_header_info(opt_explicit_self, purity, abi,\n+                                       ast::Many, None, vis));\n         try!(self.nbsp());\n         try!(self.print_ident(name));\n         try!(self.print_generics(generics));\n@@ -2016,7 +2016,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_ty_fn(&mut self,\n-                       opt_abis: Option<AbiSet>,\n+                       opt_abi: Option<abi::Abi>,\n                        opt_sigil: Option<ast::Sigil>,\n                        opt_region: &Option<ast::Lifetime>,\n                        purity: ast::Purity,\n@@ -2034,14 +2034,14 @@ impl<'a> State<'a> {\n         if opt_sigil == Some(ast::OwnedSigil) && onceness == ast::Once {\n             try!(word(&mut self.s, \"proc\"));\n         } else if opt_sigil == Some(ast::BorrowedSigil) {\n-            try!(self.print_extern_opt_abis(opt_abis));\n+            try!(self.print_extern_opt_abi(opt_abi));\n             for lifetime in opt_region.iter() {\n                 try!(self.print_lifetime(lifetime));\n             }\n             try!(self.print_purity(purity));\n             try!(self.print_onceness(onceness));\n         } else {\n-            try!(self.print_opt_abis_and_extern_if_nondefault(opt_abis));\n+            try!(self.print_opt_abi_and_extern_if_nondefault(opt_abi));\n             try!(self.print_opt_sigil(opt_sigil));\n             try!(self.print_opt_lifetime(opt_region));\n             try!(self.print_purity(purity));\n@@ -2303,24 +2303,25 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_opt_abis_and_extern_if_nondefault(&mut self,\n-                                                   opt_abis: Option<AbiSet>)\n+    pub fn print_opt_abi_and_extern_if_nondefault(&mut self,\n+                                                  opt_abi: Option<abi::Abi>)\n         -> IoResult<()> {\n-        match opt_abis {\n-            Some(abis) if !abis.is_rust() => {\n+        match opt_abi {\n+            Some(abi::Rust) => Ok(()),\n+            Some(abi) => {\n                 try!(self.word_nbsp(\"extern\"));\n-                self.word_nbsp(abis.to_str())\n+                self.word_nbsp(abi.to_str())\n             }\n-            Some(_) | None => Ok(())\n+            None => Ok(())\n         }\n     }\n \n-    pub fn print_extern_opt_abis(&mut self,\n-                                 opt_abis: Option<AbiSet>) -> IoResult<()> {\n-        match opt_abis {\n-            Some(abis) => {\n+    pub fn print_extern_opt_abi(&mut self,\n+                                opt_abi: Option<abi::Abi>) -> IoResult<()> {\n+        match opt_abi {\n+            Some(abi) => {\n                 try!(self.word_nbsp(\"extern\"));\n-                self.word_nbsp(abis.to_str())\n+                self.word_nbsp(abi.to_str())\n             }\n             None => Ok(())\n         }\n@@ -2339,15 +2340,15 @@ impl<'a> State<'a> {\n     pub fn print_fn_header_info(&mut self,\n                                 _opt_explicit_self: Option<ast::ExplicitSelf_>,\n                                 opt_purity: Option<ast::Purity>,\n-                                abis: AbiSet,\n+                                abi: abi::Abi,\n                                 onceness: ast::Onceness,\n                                 opt_sigil: Option<ast::Sigil>,\n                                 vis: ast::Visibility) -> IoResult<()> {\n         try!(word(&mut self.s, visibility_qualified(vis, \"\")));\n \n-        if abis != AbiSet::Rust() {\n+        if abi != abi::Rust {\n             try!(self.word_nbsp(\"extern\"));\n-            try!(self.word_nbsp(abis.to_str()));\n+            try!(self.word_nbsp(abi.to_str()));\n \n             if opt_purity != Some(ast::ExternFn) {\n                 try!(self.print_opt_purity(opt_purity));"}, {"sha": "eb03bb1f0bbe046db848bc624599fb47fbc98f23", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use abi::AbiSet;\n+use abi::Abi;\n use ast::*;\n use ast;\n use codemap::Span;\n@@ -29,7 +29,7 @@ use owned_slice::OwnedSlice;\n \n pub enum FnKind<'a> {\n     // fn foo() or extern \"Abi\" fn foo()\n-    FkItemFn(Ident, &'a Generics, Purity, AbiSet),\n+    FkItemFn(Ident, &'a Generics, Purity, Abi),\n \n     // fn foo(&self)\n     FkMethod(Ident, &'a Generics, &'a Method),"}, {"sha": "5a00a8034e6bc6dda6eb4616c6a0c8082de70a96", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -10,6 +10,7 @@\n \n #include \"rustllvm.h\"\n #include \"llvm/Object/Archive.h\"\n+#include \"llvm/Object/ObjectFile.h\"\n \n //===----------------------------------------------------------------------===\n //\n@@ -679,3 +680,27 @@ extern \"C\" int\n LLVMVersionMinor() {\n     return LLVM_VERSION_MINOR;\n }\n+\n+// Note that the two following functions look quite similar to the\n+// LLVMGetSectionName function. Sadly, it appears that this function only\n+// returns a char* pointer, which isn't guaranteed to be null-terminated. The\n+// function provided by LLVM doesn't return the length, so we've created our own\n+// function which returns the length as well as the data pointer.\n+//\n+// For an example of this not returning a null terminated string, see\n+// lib/Object/COFFObjectFile.cpp in the getSectionName function. One of the\n+// branches explicitly creates a StringRef without a null terminator, and then\n+// that's returned.\n+\n+inline section_iterator *unwrap(LLVMSectionIteratorRef SI) {\n+    return reinterpret_cast<section_iterator*>(SI);\n+}\n+\n+extern \"C\" int\n+LLVMRustGetSectionName(LLVMSectionIteratorRef SI, const char **ptr) {\n+    StringRef ret;\n+    if (error_code ec = (*unwrap(SI))->getName(ret))\n+      report_fatal_error(ec.message());\n+    *ptr = ret.data();\n+    return ret.size();\n+}"}, {"sha": "0b4a619c419903ea7aea18c2b22c3c639c33c006", "filename": "src/rustllvm/rustllvm.def.in", "status": "removed", "additions": 0, "deletions": 635, "changes": 635, "blob_url": "https://github.com/rust-lang/rust/blob/bb31cb8d2e4e415cbb71d368918d72902e655e01/src%2Frustllvm%2Frustllvm.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/bb31cb8d2e4e415cbb71d368918d72902e655e01/src%2Frustllvm%2Frustllvm.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.def.in?ref=bb31cb8d2e4e415cbb71d368918d72902e655e01", "patch": "@@ -1,635 +0,0 @@\n-LLVMRustCreateMemoryBufferWithContentsOfFile\n-LLVMRustWriteOutputFile\n-LLVMRustGetLastError\n-LLVMRustConstSmallInt\n-LLVMRustConstInt\n-LLVMRustPrintPassTimings\n-LLVMRustStartMultithreading\n-LLVMCreateObjectFile\n-LLVMDisposeObjectFile\n-LLVMDisposeExecutionEngine\n-LLVMGetSections\n-LLVMDisposeSectionIterator\n-LLVMIsSectionIteratorAtEnd\n-LLVMMoveToNextSection\n-LLVMGetSectionName\n-LLVMGetSectionSize\n-LLVMGetSectionContents\n-LLVMABIAlignmentOfType\n-LLVMABISizeOfType\n-LLVMAddAggressiveDCEPass\n-LLVMAddAlias\n-LLVMAddArgumentPromotionPass\n-LLVMAddAttribute\n-LLVMAddBasicAliasAnalysisPass\n-LLVMAddCFGSimplificationPass\n-LLVMAddCase\n-LLVMAddClause\n-LLVMAddConstantMergePass\n-LLVMAddConstantPropagationPass\n-LLVMAddCorrelatedValuePropagationPass\n-LLVMAddDeadArgEliminationPass\n-LLVMAddDeadStoreEliminationPass\n-LLVMAddDemoteMemoryToRegisterPass\n-LLVMAddDestination\n-LLVMAddEarlyCSEPass\n-LLVMAddFunction\n-LLVMAddFunctionAttr\n-LLVMAddFunctionAttrString\n-LLVMAddFunctionAttrsPass\n-LLVMAddFunctionInliningPass\n-LLVMAddGVNPass\n-LLVMAddGlobal\n-LLVMAddGlobalDCEPass\n-LLVMAddGlobalInAddressSpace\n-LLVMAddGlobalOptimizerPass\n-LLVMAddIPConstantPropagationPass\n-LLVMAddIPSCCPPass\n-LLVMAddIncoming\n-LLVMAddIndVarSimplifyPass\n-LLVMAddInstrAttribute\n-LLVMAddInstructionCombiningPass\n-LLVMAddInternalizePass\n-LLVMAddJumpThreadingPass\n-LLVMAddLICMPass\n-LLVMAddLoopDeletionPass\n-LLVMAddLoopIdiomPass\n-LLVMAddLoopRotatePass\n-LLVMAddLoopUnrollPass\n-LLVMAddLoopUnswitchPass\n-LLVMAddMemCpyOptPass\n-LLVMAddNamedMetadataOperand\n-LLVMAddPromoteMemoryToRegisterPass\n-LLVMAddPruneEHPass\n-LLVMAddReassociatePass\n-LLVMAddSCCPPass\n-LLVMAddScalarReplAggregatesPass\n-LLVMAddScalarReplAggregatesPassSSA\n-LLVMAddScalarReplAggregatesPassWithThreshold\n-LLVMAddSimplifyLibCallsPass\n-LLVMAddStripDeadPrototypesPass\n-LLVMAddStripSymbolsPass\n-LLVMAddTailCallEliminationPass\n-LLVMAddTargetData\n-LLVMAddTypeBasedAliasAnalysisPass\n-LLVMAddVerifierPass\n-LLVMAlignOf\n-LLVMAppendBasicBlock\n-LLVMAppendBasicBlockInContext\n-LLVMArrayType\n-LLVMBasicBlockAsValue\n-LLVMBlockAddress\n-LLVMBuildAShr\n-LLVMBuildAtomicLoad\n-LLVMBuildAtomicStore\n-LLVMBuildAtomicCmpXchg\n-LLVMBuildAtomicRMW\n-LLVMBuildAtomicFence\n-LLVMBuildAdd\n-LLVMBuildAggregateRet\n-LLVMBuildAlloca\n-LLVMBuildAnd\n-LLVMBuildArrayAlloca\n-LLVMBuildArrayMalloc\n-LLVMBuildBinOp\n-LLVMBuildBitCast\n-LLVMBuildBr\n-LLVMBuildCall\n-LLVMBuildCast\n-LLVMBuildCondBr\n-LLVMBuildExactSDiv\n-LLVMBuildExtractElement\n-LLVMBuildExtractValue\n-LLVMBuildFAdd\n-LLVMBuildFCmp\n-LLVMBuildFDiv\n-LLVMBuildFMul\n-LLVMBuildFNeg\n-LLVMBuildFPCast\n-LLVMBuildFPExt\n-LLVMBuildFPToSI\n-LLVMBuildFPToUI\n-LLVMBuildFPTrunc\n-LLVMBuildFRem\n-LLVMBuildFSub\n-LLVMBuildFree\n-LLVMBuildGEP\n-LLVMBuildGlobalString\n-LLVMBuildGlobalStringPtr\n-LLVMBuildICmp\n-LLVMBuildInBoundsGEP\n-LLVMBuildIndirectBr\n-LLVMBuildInsertElement\n-LLVMBuildInsertValue\n-LLVMBuildIntCast\n-LLVMBuildIntToPtr\n-LLVMBuildInvoke\n-LLVMBuildIsNotNull\n-LLVMBuildIsNull\n-LLVMBuildLandingPad\n-LLVMBuildLShr\n-LLVMBuildLoad\n-LLVMBuildMalloc\n-LLVMBuildMul\n-LLVMBuildNSWAdd\n-LLVMBuildNSWMul\n-LLVMBuildNSWNeg\n-LLVMBuildNSWSub\n-LLVMBuildNUWAdd\n-LLVMBuildNUWMul\n-LLVMBuildNUWNeg\n-LLVMBuildNUWSub\n-LLVMBuildNeg\n-LLVMBuildNot\n-LLVMBuildOr\n-LLVMBuildPhi\n-LLVMBuildPointerCast\n-LLVMBuildPtrDiff\n-LLVMBuildPtrToInt\n-LLVMBuildResume\n-LLVMBuildRet\n-LLVMBuildRetVoid\n-LLVMBuildSDiv\n-LLVMBuildSExt\n-LLVMBuildSExtOrBitCast\n-LLVMBuildSIToFP\n-LLVMBuildSRem\n-LLVMBuildSelect\n-LLVMBuildShl\n-LLVMBuildShuffleVector\n-LLVMBuildStore\n-LLVMBuildStructGEP\n-LLVMBuildSub\n-LLVMBuildSwitch\n-LLVMBuildTrunc\n-LLVMBuildTruncOrBitCast\n-LLVMBuildUDiv\n-LLVMBuildUIToFP\n-LLVMBuildURem\n-LLVMBuildUnreachable\n-LLVMBuildVAArg\n-LLVMBuildXor\n-LLVMBuildZExt\n-LLVMBuildZExtOrBitCast\n-LLVMByteOrder\n-LLVMCallFrameAlignmentOfType\n-LLVMClearInsertionPosition\n-LLVMConstAShr\n-LLVMConstAdd\n-LLVMConstAllOnes\n-LLVMConstAnd\n-LLVMConstArray\n-LLVMConstBitCast\n-LLVMConstExactSDiv\n-LLVMConstExtractElement\n-LLVMConstExtractValue\n-LLVMConstFAdd\n-LLVMConstFCmp\n-LLVMConstFDiv\n-LLVMConstFMul\n-LLVMConstFNeg\n-LLVMConstFPCast\n-LLVMConstFPExt\n-LLVMConstFPToSI\n-LLVMConstFPToUI\n-LLVMConstFPTrunc\n-LLVMConstFRem\n-LLVMConstFSub\n-LLVMConstGEP\n-LLVMConstICmp\n-LLVMConstInBoundsGEP\n-LLVMConstInlineAsm\n-LLVMConstInsertElement\n-LLVMConstInsertValue\n-LLVMConstInt\n-LLVMConstIntCast\n-LLVMConstIntGetSExtValue\n-LLVMConstIntGetZExtValue\n-LLVMConstIntOfArbitraryPrecision\n-LLVMConstIntOfString\n-LLVMConstIntOfStringAndSize\n-LLVMConstIntToPtr\n-LLVMConstLShr\n-LLVMConstMul\n-LLVMConstNSWAdd\n-LLVMConstNSWMul\n-LLVMConstNSWNeg\n-LLVMConstNSWSub\n-LLVMConstNUWAdd\n-LLVMConstNUWMul\n-LLVMConstNUWNeg\n-LLVMConstNUWSub\n-LLVMConstNeg\n-LLVMConstNot\n-LLVMConstNull\n-LLVMConstOr\n-LLVMConstPointerCast\n-LLVMConstPointerNull\n-LLVMConstPtrToInt\n-LLVMConstReal\n-LLVMConstRealOfString\n-LLVMConstRealOfStringAndSize\n-LLVMConstSDiv\n-LLVMConstSExt\n-LLVMConstSExtOrBitCast\n-LLVMConstSIToFP\n-LLVMConstSRem\n-LLVMConstSelect\n-LLVMConstShl\n-LLVMConstShuffleVector\n-LLVMConstString\n-LLVMConstStringInContext\n-LLVMConstStruct\n-LLVMConstStructInContext\n-LLVMConstSub\n-LLVMConstTrunc\n-LLVMConstTruncOrBitCast\n-LLVMConstUDiv\n-LLVMConstUIToFP\n-LLVMConstURem\n-LLVMConstVector\n-LLVMConstXor\n-LLVMConstZExt\n-LLVMConstZExtOrBitCast\n-LLVMContextCreate\n-LLVMContextDispose\n-LLVMCopyStringRepOfTargetData\n-LLVMCountBasicBlocks\n-LLVMCountIncoming\n-LLVMCountParamTypes\n-LLVMCountParams\n-LLVMCountStructElementTypes\n-LLVMCreateBuilder\n-LLVMCreateBuilderInContext\n-LLVMCreateFunctionPassManager\n-LLVMCreateFunctionPassManagerForModule\n-LLVMCreateMemoryBufferWithContentsOfFile\n-LLVMCreateMemoryBufferWithSTDIN\n-LLVMCreateModuleProviderForExistingModule\n-LLVMCreateObjectFile\n-LLVMCreatePassManager\n-LLVMCreateTargetData\n-LLVMDeleteBasicBlock\n-LLVMDeleteFunction\n-LLVMDeleteGlobal\n-LLVMDisposeBuilder\n-LLVMDisposeMemoryBuffer\n-LLVMDisposeMessage\n-LLVMDisposeModule\n-LLVMDisposeModuleProvider\n-LLVMDisposeObjectFile\n-LLVMDisposePassManager\n-LLVMDisposeSectionIterator\n-LLVMDisposeTargetData\n-LLVMDoubleType\n-LLVMDoubleTypeInContext\n-LLVMDumpModule\n-LLVMDumpValue\n-LLVMElementAtOffset\n-LLVMFP128Type\n-LLVMFP128TypeInContext\n-LLVMFinalizeFunctionPassManager\n-LLVMFloatType\n-LLVMFloatTypeInContext\n-LLVMFunctionType\n-LLVMGetAlignment\n-LLVMGetArrayLength\n-LLVMGetAttribute\n-LLVMGetBasicBlockParent\n-LLVMGetBasicBlocks\n-LLVMGetBitcodeModule\n-LLVMGetBitcodeModuleInContext\n-LLVMGetBitcodeModuleProvider\n-LLVMGetBitcodeModuleProviderInContext\n-LLVMGetConstOpcode\n-LLVMGetCurrentDebugLocation\n-LLVMGetDataLayout\n-LLVMGetElementType\n-LLVMGetEntryBasicBlock\n-LLVMGetFirstBasicBlock\n-LLVMGetFirstFunction\n-LLVMGetFirstGlobal\n-LLVMGetFirstInstruction\n-LLVMGetFirstParam\n-LLVMGetFirstUse\n-LLVMGetFunctionAttr\n-LLVMGetFunctionCallConv\n-LLVMGetGC\n-LLVMGetGlobalContext\n-LLVMGetGlobalParent\n-LLVMGetGlobalPassRegistry\n-LLVMGetIncomingBlock\n-LLVMGetIncomingValue\n-LLVMGetInitializer\n-LLVMGetInsertBlock\n-LLVMGetInstructionCallConv\n-LLVMGetInstructionParent\n-LLVMGetIntTypeWidth\n-LLVMGetIntrinsicID\n-LLVMGetLastBasicBlock\n-LLVMGetLastFunction\n-LLVMGetLastGlobal\n-LLVMGetLastInstruction\n-LLVMGetLastParam\n-LLVMGetLinkage\n-LLVMGetMDKindID\n-LLVMGetMDKindIDInContext\n-LLVMGetMetadata\n-LLVMGetModuleContext\n-LLVMGetNamedFunction\n-LLVMGetNamedGlobal\n-LLVMGetNextBasicBlock\n-LLVMGetNextFunction\n-LLVMGetNextGlobal\n-LLVMGetNextInstruction\n-LLVMGetNextParam\n-LLVMGetNextUse\n-LLVMGetNumOperands\n-LLVMGetOperand\n-LLVMGetOrInsertFunction\n-LLVMGetParam\n-LLVMGetParamParent\n-LLVMGetParamTypes\n-LLVMGetParams\n-LLVMGetPointerAddressSpace\n-LLVMGetPointerToGlobal\n-LLVMGetPreviousBasicBlock\n-LLVMGetPreviousFunction\n-LLVMGetPreviousGlobal\n-LLVMGetPreviousInstruction\n-LLVMGetPreviousParam\n-LLVMGetReturnType\n-LLVMGetSection\n-LLVMGetSectionContents\n-LLVMGetSectionName\n-LLVMGetSectionSize\n-LLVMGetSections\n-LLVMGetStructElementTypes\n-LLVMGetTarget\n-LLVMGetTypeContext\n-LLVMGetTypeKind\n-LLVMGetUndef\n-LLVMGetUsedValue\n-LLVMGetUser\n-LLVMGetValueName\n-LLVMGetVectorSize\n-LLVMGetVisibility\n-LLVMHasMetadata\n-LLVMInitializeCodeGen\n-LLVMInitializeFunctionPassManager\n-LLVMInitializeIPA\n-LLVMInitializeInstCombine\n-LLVMInitializeScalarOpts\n-LLVMInitializeTarget\n-LLVMInitializeTransformUtils\n-LLVMInitializeARMAsmParser\n-LLVMInitializeMipsAsmParser\n-LLVMInitializeX86AsmParser\n-LLVMInitializeARMAsmPrinter\n-LLVMInitializeMipsAsmPrinter\n-LLVMInitializeX86AsmPrinter\n-LLVMInitializeARMDisassembler\n-LLVMInitializeMipsDisassembler\n-LLVMInitializeX86Disassembler\n-LLVMInitializeARMTarget\n-LLVMInitializeMipsTarget\n-LLVMInitializeX86Target\n-LLVMInitializeARMTargetMC\n-LLVMInitializeMipsTargetMC\n-LLVMInitializeX86TargetMC\n-LLVMInitializeARMTargetInfo\n-LLVMInitializeMipsTargetInfo\n-LLVMInitializeX86TargetInfo\n-LLVMInsertBasicBlock\n-LLVMInsertBasicBlockInContext\n-LLVMInsertIntoBuilder\n-LLVMInsertIntoBuilderWithName\n-LLVMInstructionEraseFromParent\n-LLVMInt16Type\n-LLVMInt16TypeInContext\n-LLVMInt1Type\n-LLVMInt1TypeInContext\n-LLVMInt32Type\n-LLVMInt32TypeInContext\n-LLVMInt64Type\n-LLVMInt64TypeInContext\n-LLVMInt8Type\n-LLVMInt8TypeInContext\n-LLVMIntPtrType\n-LLVMIntType\n-LLVMIntTypeInContext\n-LLVMIsAAllocaInst\n-LLVMIsAArgument\n-LLVMIsABasicBlock\n-LLVMIsABinaryOperator\n-LLVMIsABitCastInst\n-LLVMIsABranchInst\n-LLVMIsACallInst\n-LLVMIsACastInst\n-LLVMIsACmpInst\n-LLVMIsAConstant\n-LLVMIsAConstantAggregateZero\n-LLVMIsAConstantArray\n-LLVMIsAConstantExpr\n-LLVMIsAConstantFP\n-LLVMIsAConstantInt\n-LLVMIsAConstantPointerNull\n-LLVMIsAConstantStruct\n-LLVMIsAConstantVector\n-LLVMIsADbgDeclareInst\n-LLVMIsADbgInfoIntrinsic\n-LLVMIsAExtractElementInst\n-LLVMIsAExtractValueInst\n-LLVMIsAFCmpInst\n-LLVMIsAFPExtInst\n-LLVMIsAFPToSIInst\n-LLVMIsAFPToUIInst\n-LLVMIsAFPTruncInst\n-LLVMIsAFunction\n-LLVMIsAGetElementPtrInst\n-LLVMIsAGlobalAlias\n-LLVMIsAGlobalValue\n-LLVMIsAGlobalVariable\n-LLVMIsAICmpInst\n-LLVMIsAInlineAsm\n-LLVMIsAInsertElementInst\n-LLVMIsAInsertValueInst\n-LLVMIsAInstruction\n-LLVMIsAIntToPtrInst\n-LLVMIsAIntrinsicInst\n-LLVMIsAInvokeInst\n-LLVMIsALoadInst\n-LLVMIsAMemCpyInst\n-LLVMIsAMemIntrinsic\n-LLVMIsAMemMoveInst\n-LLVMIsAMemSetInst\n-LLVMIsAPHINode\n-LLVMIsAPtrToIntInst\n-LLVMIsAReturnInst\n-LLVMIsASExtInst\n-LLVMIsASIToFPInst\n-LLVMIsASelectInst\n-LLVMIsAShuffleVectorInst\n-LLVMIsAStoreInst\n-LLVMIsASwitchInst\n-LLVMIsATerminatorInst\n-LLVMIsATruncInst\n-LLVMIsAUIToFPInst\n-LLVMIsAUnaryInstruction\n-LLVMIsAUndefValue\n-LLVMIsAUnreachableInst\n-LLVMIsAUser\n-LLVMIsAVAArgInst\n-LLVMIsAZExtInst\n-LLVMIsConstant\n-LLVMIsDeclaration\n-LLVMIsFunctionVarArg\n-LLVMIsGlobalConstant\n-LLVMIsNull\n-LLVMIsPackedStruct\n-LLVMIsSectionIteratorAtEnd\n-LLVMIsTailCall\n-LLVMIsThreadLocal\n-LLVMIsUndef\n-LLVMLabelType\n-LLVMLabelTypeInContext\n-LLVMLinkInInterpreter\n-LLVMMDNode\n-LLVMMDNodeInContext\n-LLVMMDString\n-LLVMMDStringInContext\n-LLVMMetadataTypeInContext\n-LLVMModuleCreateWithName\n-LLVMModuleCreateWithNameInContext\n-LLVMMoveBasicBlockAfter\n-LLVMMoveBasicBlockBefore\n-LLVMMoveToNextSection\n-LLVMOffsetOfElement\n-LLVMPPCFP128Type\n-LLVMPPCFP128TypeInContext\n-LLVMParseBitcode\n-LLVMParseBitcodeInContext\n-LLVMPassManagerBuilderCreate\n-LLVMPassManagerBuilderDispose\n-LLVMPassManagerBuilderPopulateModulePassManager\n-LLVMPassManagerBuilderSetDisableSimplifyLibCalls\n-LLVMPassManagerBuilderSetDisableUnitAtATime\n-LLVMPassManagerBuilderPopulateFunctionPassManager\n-LLVMPassManagerBuilderSetDisableUnrollLoops\n-LLVMPassManagerBuilderSetOptLevel\n-LLVMPassManagerBuilderSetSizeLevel\n-LLVMPassManagerBuilderUseInlinerWithThreshold\n-LLVMPointerSize\n-LLVMPointerType\n-LLVMPositionBuilder\n-LLVMPositionBuilderAtEnd\n-LLVMPositionBuilderBefore\n-LLVMPreferredAlignmentOfGlobal\n-LLVMPreferredAlignmentOfType\n-LLVMRemoveAttribute\n-LLVMRemoveFunctionAttr\n-LLVMRemoveInstrAttribute\n-LLVMReplaceAllUsesWith\n-LLVMRunFunctionPassManager\n-LLVMRunPassManager\n-LLVMSetAlignment\n-LLVMSetCleanup\n-LLVMSetCurrentDebugLocation\n-LLVMSetDataLayout\n-LLVMSetDebug\n-LLVMSetFunctionCallConv\n-LLVMSetGC\n-LLVMSetGlobalConstant\n-LLVMSetInitializer\n-LLVMSetInstDebugLocation\n-LLVMSetInstrParamAlignment\n-LLVMSetInstructionCallConv\n-LLVMSetLinkage\n-LLVMSetMetadata\n-LLVMSetModuleInlineAsm\n-LLVMSetOperand\n-LLVMSetParamAlignment\n-LLVMSetSection\n-LLVMSetTailCall\n-LLVMSetTarget\n-LLVMSetThreadLocal\n-LLVMSetValueName\n-LLVMSetVisibility\n-LLVMSizeOf\n-LLVMSizeOfTypeInBits\n-LLVMStoreSizeOfType\n-LLVMStructType\n-LLVMStructTypeInContext\n-LLVMTypeOf\n-LLVMValueAsBasicBlock\n-LLVMValueIsBasicBlock\n-LLVMVectorType\n-LLVMVerifyFunction\n-LLVMVerifyModule\n-LLVMViewFunctionCFG\n-LLVMViewFunctionCFGOnly\n-LLVMVoidType\n-LLVMVoidTypeInContext\n-LLVMWriteBitcodeToFD\n-LLVMWriteBitcodeToFile\n-LLVMWriteBitcodeToFileHandle\n-LLVMX86FP80Type\n-LLVMX86FP80TypeInContext\n-LLVMX86MMXType\n-LLVMX86MMXTypeInContext\n-LLVMConstNamedStruct\n-LLVMStructCreateNamed\n-LLVMStructSetBody\n-LLVMInlineAsm\n-LLVMInitializePasses\n-LLVMDIBuilderCreate\n-LLVMDIBuilderDispose\n-LLVMDIBuilderFinalize\n-LLVMDIBuilderCreateCompileUnit\n-LLVMDIBuilderCreateStaticVariable\n-LLVMDIBuilderCreateLocalVariable\n-LLVMDIBuilderCreateFunction\n-LLVMDIBuilderCreateFile\n-LLVMDIBuilderCreateLexicalBlock\n-LLVMDIBuilderCreateBasicType\n-LLVMDIBuilderCreatePointerType\n-LLVMDIBuilderCreateMemberType\n-LLVMDIBuilderCreateStructType\n-LLVMDIBuilderGetOrCreateSubrange\n-LLVMDIBuilderCreateArrayType\n-LLVMDIBuilderCreateVectorType\n-LLVMDIBuilderCreateSubroutineType\n-LLVMDIBuilderGetOrCreateArray\n-LLVMDIBuilderInsertDeclareAtEnd\n-LLVMDIBuilderInsertDeclareBefore\n-LLVMDIBuilderCreateEnumerator\n-LLVMDIBuilderCreateEnumerationType\n-LLVMDIBuilderCreateUnionType\n-LLVMDIBuilderCreateTemplateTypeParameter\n-LLVMDIBuilderCreateOpDeref\n-LLVMDIBuilderCreateOpPlus\n-LLVMDIBuilderCreateComplexVariable\n-LLVMDIBuilderCreateNameSpace\n-LLVMDICompositeTypeSetTypeArray\n-LLVMSetUnnamedAddr\n-LLVMRustAddPass\n-LLVMRustAddAnalysisPasses\n-LLVMRustAddLibraryInfo\n-LLVMRustCreateTargetMachine\n-LLVMRustRunFunctionPassManager\n-LLVMRustPrintModule\n-LLVMRustDisposeTargetMachine\n-LLVMRustAddBuilderLibraryInfo\n-LLVMRustSetLLVMOptions\n-LLVMRustPrintPasses\n-LLVMRustSetNormalizedTarget\n-LLVMRustAddAlwaysInlinePass\n-LLVMAddReturnAttribute\n-LLVMRemoveReturnAttribute\n-LLVMTypeToString\n-LLVMAddColdAttribute\n-LLVMCreateMemoryBufferWithMemoryRange\n-LLVMCreateMemoryBufferWithMemoryRangeCopy\n-LLVMPassManagerBuilderPopulateLTOPassManager\n-LLVMRustLinkInExternalBitcode\n-LLVMRustRunRestrictionPass"}, {"sha": "4f07660779b2692c8c5a3c9647cda6017f221fd2", "filename": "src/test/bench/rt-spawn-rate.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Ftest%2Fbench%2Frt-spawn-rate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Ftest%2Fbench%2Frt-spawn-rate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-spawn-rate.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -8,13 +8,23 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![no_start]\n+\n+extern crate green;\n+extern crate rustuv;\n+\n use std::task::spawn;\n use std::os;\n use std::uint;\n \n // Very simple spawn rate test. Spawn N tasks that do nothing and\n // return.\n \n+#[start]\n+fn start(argc: int, argv: **u8) -> int {\n+    green::start(argc, argv, rustuv::event_loop, main)\n+}\n+\n fn main() {\n \n     let args = os::args();"}, {"sha": "efc6fda26e0c021a24ad2f802f313315a193c27d", "filename": "src/test/debug-info/basic-types-globals-metadata.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Ftest%2Fdebug-info%2Fbasic-types-globals-metadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Ftest%2Fdebug-info%2Fbasic-types-globals-metadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fbasic-types-globals-metadata.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-win32: FIXME #13256\n // ignore-android: FIXME(#10381)\n \n // compile-flags:-g\n@@ -44,7 +45,9 @@\n // check:type = f64\n // debugger:continue\n \n-#[allow(unused_variable)];\n+#![allow(unused_variable)]\n+#![allow(dead_code)]\n+\n \n static B: bool = false;\n static I: int = -1;"}, {"sha": "860a383468da111c7264f56201f2b3539d60e091", "filename": "src/test/debug-info/basic-types-globals.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Ftest%2Fdebug-info%2Fbasic-types-globals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Ftest%2Fdebug-info%2Fbasic-types-globals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fbasic-types-globals.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -14,6 +14,7 @@\n // about UTF-32 character encoding and will print a rust char as only\n // its numerical value.\n \n+// ignore-win32: FIXME #13256\n // ignore-android: FIXME(#10381)\n \n // compile-flags:-g"}, {"sha": "54c2e786ac49deb1dc4e5cb22b1b90dbd6f4d6e3", "filename": "src/test/debug-info/basic-types-mut-globals.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Ftest%2Fdebug-info%2Fbasic-types-mut-globals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Ftest%2Fdebug-info%2Fbasic-types-mut-globals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fbasic-types-mut-globals.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -14,6 +14,7 @@\n // about UTF-32 character encoding and will print a rust char as only\n // its numerical value.\n \n+// ignore-win32: FIXME #13256\n // ignore-android: FIXME(#10381)\n \n // compile-flags:-g"}, {"sha": "b570110d8d013c009ada8e3931c27747539d4bd2", "filename": "src/test/debug-info/c-style-enum.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Ftest%2Fdebug-info%2Fc-style-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Ftest%2Fdebug-info%2Fc-style-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fc-style-enum.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-win32: FIXME #13256\n // ignore-android: FIXME(#10381)\n \n // compile-flags:-g\n@@ -70,7 +71,8 @@\n // debugger:print 'c-style-enum::MANUAL_THREE'\n // check:$18 = OneMillion\n \n-#[allow(unused_variable)];\n+#![allow(unused_variable)]\n+#![allow(dead_code)]\n \n enum AutoDiscriminant {\n     One,"}, {"sha": "75f1d779d01fdd242ea47e594ae32ba6da3b0fb5", "filename": "src/test/debug-info/lexical-scope-in-for-loop.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Ftest%2Fdebug-info%2Flexical-scope-in-for-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Ftest%2Fdebug-info%2Flexical-scope-in-for-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Flexical-scope-in-for-loop.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-win32\n // ignore-android: FIXME(#10381)\n \n // compile-flags:-g"}, {"sha": "712880d50f0979959ed609e3b85782f64a2bea36", "filename": "src/test/debug-info/lexical-scope-in-if.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Ftest%2Fdebug-info%2Flexical-scope-in-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Ftest%2Fdebug-info%2Flexical-scope-in-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Flexical-scope-in-if.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-win32\n // ignore-android: FIXME(#10381)\n \n // compile-flags:-g"}, {"sha": "041c8b5c13f2774d209f24b09b74b642eb98f44f", "filename": "src/test/debug-info/lexical-scope-in-match.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Ftest%2Fdebug-info%2Flexical-scope-in-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Ftest%2Fdebug-info%2Flexical-scope-in-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Flexical-scope-in-match.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-win32\n // ignore-android: FIXME(#10381)\n \n // compile-flags:-g"}, {"sha": "6626d75dc0c9869edd4a3a8fd0f893e8cd0c40b8", "filename": "src/test/debug-info/lexical-scopes-in-block-expression.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Ftest%2Fdebug-info%2Flexical-scopes-in-block-expression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Ftest%2Fdebug-info%2Flexical-scopes-in-block-expression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Flexical-scopes-in-block-expression.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-win32\n+// ignore-win32: FIXME #13256\n // ignore-android: FIXME(#10381)\n \n // compile-flags:-g"}, {"sha": "2e1cdeccad2dd2efb6e8eed9a4d1a8fd1c74438f", "filename": "src/test/debug-info/simple-struct.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Ftest%2Fdebug-info%2Fsimple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Ftest%2Fdebug-info%2Fsimple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fsimple-struct.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-win32: FIXME #13256\n // ignore-android: FIXME(#10381)\n \n // compile-flags:-g"}, {"sha": "16b0061f25e77d53955cacb0761964d9a945f3c6", "filename": "src/test/debug-info/simple-tuple.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Ftest%2Fdebug-info%2Fsimple-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Ftest%2Fdebug-info%2Fsimple-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fsimple-tuple.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-win32: FIXME #13256\n // ignore-android: FIXME(#10381)\n \n // compile-flags:-g"}, {"sha": "3bf26ae805337babd03a7ee87a93ae68d029aba2", "filename": "src/test/debug-info/var-captured-in-nested-closure.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Ftest%2Fdebug-info%2Fvar-captured-in-nested-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Ftest%2Fdebug-info%2Fvar-captured-in-nested-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fvar-captured-in-nested-closure.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-win32: FIXME #10474\n // ignore-android: FIXME(#10381)\n \n // compile-flags:-g"}, {"sha": "0c7e2740cd78e374fb37515dbdcdd78670711569", "filename": "src/test/debug-info/vec-slices.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Ftest%2Fdebug-info%2Fvec-slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Ftest%2Fdebug-info%2Fvec-slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fvec-slices.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-win32: FIXME #13256\n // ignore-android: FIXME(#10381)\n \n // compile-flags:-g"}, {"sha": "635a42d443e153e253e817db9094f7a50100f876", "filename": "src/test/debug-info/vec.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Ftest%2Fdebug-info%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Ftest%2Fdebug-info%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fvec.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-win32: FIXME #13256\n // ignore-android: FIXME(#10381)\n \n // compile-flags:-g"}, {"sha": "edf0e195cb38ba8003272974a08397e598a9a0e5", "filename": "src/test/run-pass/backtrace.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -8,8 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-win32 FIXME #13259\n // ignore-fast this is executing itself\n-#[no_uv];\n+#![no_uv]\n \n extern crate native;\n "}, {"sha": "9695296ec15610de322fd0131e531a6c01bb100b", "filename": "src/test/run-pass/empty-allocation-non-null.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Ftest%2Frun-pass%2Fempty-allocation-non-null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Ftest%2Frun-pass%2Fempty-allocation-non-null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fempty-allocation-non-null.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn main() {\n+    assert!(Some(~()).is_some());\n+\n+    struct Foo;\n+    assert!(Some(~Foo).is_some());\n+\n+    let xs: ~[()] = ~[];\n+    assert!(Some(xs).is_some());\n+}"}, {"sha": "d0f12ae7b10c63bd5107eaf35d29dd368beca711", "filename": "src/test/run-pass/extern-fn-reachable.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Ftest%2Frun-pass%2Fextern-fn-reachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fe20722904cd2829a65f845ee7a1718cdf7292/src%2Ftest%2Frun-pass%2Fextern-fn-reachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-fn-reachable.rs?ref=e7fe20722904cd2829a65f845ee7a1718cdf7292", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // ignore-fast\n+// ignore-win32 dynamic_lib can read dllexported symbols only\n // ignore-linux apparently dlsym doesn't work on program symbols?\n // ignore-android apparently dlsym doesn't work on program symbols?\n // ignore-freebsd apparently dlsym doesn't work on program symbols?"}]}