{"sha": "f829523340a84624b07a929b5092a5b996f090a6", "node_id": "C_kwDOAAsO6NoAKGY4Mjk1MjMzNDBhODQ2MjRiMDdhOTI5YjUwOTJhNWI5OTZmMDkwYTY", "commit": {"author": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2021-11-09T03:44:02Z"}, "committer": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2021-11-09T03:44:02Z"}, "message": "Simplify range comparison code\n\nReword the `Kind` type so that the `cmp` function is simpler.", "tree": {"sha": "5ebed48c3de3d831e2fe87b8f9843aa5e898f8b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ebed48c3de3d831e2fe87b8f9843aa5e898f8b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f829523340a84624b07a929b5092a5b996f090a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f829523340a84624b07a929b5092a5b996f090a6", "html_url": "https://github.com/rust-lang/rust/commit/f829523340a84624b07a929b5092a5b996f090a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f829523340a84624b07a929b5092a5b996f090a6/comments", "author": null, "committer": null, "parents": [{"sha": "949b25981cdaf2c7708ee257651f1cb9dc951332", "url": "https://api.github.com/repos/rust-lang/rust/commits/949b25981cdaf2c7708ee257651f1cb9dc951332", "html_url": "https://github.com/rust-lang/rust/commit/949b25981cdaf2c7708ee257651f1cb9dc951332"}], "stats": {"total": 65, "additions": 24, "deletions": 41}, "files": [{"sha": "cedf0777ac45190cdff5053d27c71692f9e84097", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 24, "deletions": 41, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/f829523340a84624b07a929b5092a5b996f090a6/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f829523340a84624b07a929b5092a5b996f090a6/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=f829523340a84624b07a929b5092a5b996f090a6", "patch": "@@ -1698,75 +1698,58 @@ pub fn overlapping<T>(ranges: &[SpannedRange<T>]) -> Option<(&SpannedRange<T>, &\n where\n     T: Copy + Ord,\n {\n-    #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n-    enum Kind<'a, T> {\n-        Start(T, &'a SpannedRange<T>),\n-        End(EndBound<T>, &'a SpannedRange<T>),\n+    #[derive(Copy, Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]\n+    enum BoundKind {\n+        EndExcluded,\n+        Start,\n+        EndIncluded,\n     }\n \n-    impl<'a, T: Copy> Kind<'a, T> {\n-        fn value(self) -> T {\n-            match self {\n-                Kind::Start(t, _) | Kind::End(EndBound::Included(t) | EndBound::Excluded(t), _) => t,\n-            }\n-        }\n-    }\n+    #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+    struct RangeBound<'a, T>(T, BoundKind, &'a SpannedRange<T>);\n \n-    impl<'a, T: Copy + Ord> PartialOrd for Kind<'a, T> {\n+    impl<'a, T: Copy + Ord> PartialOrd for RangeBound<'a, T> {\n         fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n             Some(self.cmp(other))\n         }\n     }\n \n-    impl<'a, T: Copy + Ord> Ord for Kind<'a, T> {\n-        fn cmp(&self, other: &Self) -> Ordering {\n-            match self.value().cmp(&other.value()) {\n-                Ordering::Equal => match (self, other) {\n-                    // End excluded before start and end included\n-                    (Kind::End(EndBound::Excluded(_), _), Kind::Start(..) | Kind::End(EndBound::Included(_), _)) => {\n-                        Ordering::Less\n-                    },\n-                    (Kind::Start(..) | Kind::End(EndBound::Included(_), _), Kind::End(EndBound::Excluded(_), _)) => {\n-                        Ordering::Greater\n-                    },\n-\n-                    // Start before end included\n-                    (Kind::Start(..), Kind::End(EndBound::Included(_), _)) => Ordering::Less,\n-                    (Kind::End(EndBound::Included(_), _), Kind::Start(..)) => Ordering::Greater,\n-\n-                    _ => Ordering::Equal,\n-                },\n-                other => other,\n-            }\n+    impl<'a, T: Copy + Ord> Ord for RangeBound<'a, T> {\n+        fn cmp(&self, RangeBound(other_value, other_kind, _): &Self) -> Ordering {\n+            let RangeBound(self_value, self_kind, _) = *self;\n+            (self_value, self_kind).cmp(&(*other_value, *other_kind))\n         }\n     }\n \n     let mut values = Vec::with_capacity(2 * ranges.len());\n \n-    for r in ranges {\n-        values.push(Kind::Start(r.node.0, r));\n-        values.push(Kind::End(r.node.1, r));\n+    for r @ SpannedRange { node: (start, end), .. } in ranges {\n+        values.push(RangeBound(*start, BoundKind::Start, r));\n+        values.push(match end {\n+            EndBound::Excluded(val) => RangeBound(*val, BoundKind::EndExcluded, r),\n+            EndBound::Included(val) => RangeBound(*val, BoundKind::EndIncluded, r),\n+        });\n     }\n \n     values.sort();\n \n     let mut started = vec![];\n \n-    for value in values {\n-        match value {\n-            Kind::Start(_, r) => started.push(r),\n-            Kind::End(_, er) => {\n+    for RangeBound(_, kind, r) in values {\n+        match kind {\n+            BoundKind::Start => started.push(r),\n+            BoundKind::EndExcluded | BoundKind::EndIncluded => {\n                 let mut overlap = None;\n \n                 while let Some(sr) = started.pop() {\n-                    if sr == er {\n+                    if sr == r {\n                         break;\n                     }\n                     overlap = Some(sr);\n                 }\n \n                 if let Some(sr) = overlap {\n-                    return Some((er, sr));\n+                    return Some((r, sr));\n                 }\n             },\n         }"}]}