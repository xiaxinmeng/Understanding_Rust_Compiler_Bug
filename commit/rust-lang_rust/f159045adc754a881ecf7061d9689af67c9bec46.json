{"sha": "f159045adc754a881ecf7061d9689af67c9bec46", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxNTkwNDVhZGM3NTRhODgxZWNmNzA2MWQ5Njg5YWY2N2M5YmVjNDY=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-01-31T00:21:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-01-31T00:21:25Z"}, "message": "Rollup merge of #68638 - GuillaumeGomez:links-cmp-traits, r=Dylan-DPC\n\nAdd missing links for cmp traits\n\nr? @Dylan-DPC", "tree": {"sha": "06b735c4d5adc686b38fcd9b82ae4c4002b492a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06b735c4d5adc686b38fcd9b82ae4c4002b492a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f159045adc754a881ecf7061d9689af67c9bec46", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeM3MGCRBK7hj4Ov3rIwAAdHIIAFKhNXBaRHbjObDjscXtRp/l\nNIMD9Y3/VS2t+/rIVIP0YOZSWEB8dnzKuShT+MKjmm0Z7mfxA2mCs0hvOTWkPWtQ\nf4llmqwGS93UM7uiPNtYhsKRbV0kJgIge3LJb1EfzjVhkuOUnQnXA85LBDKeomcm\nsRuJrURU+3jN79Nvsm++gVgVSumJ6L4IFJYXdYFZPzhaHcYX6CmXX0RxnwfXr3H7\nJ/bZsGWIVoPhGJHMhFkOBHKqjhmOhTziQR7tR38y1wc7iSkez7+oOY23M6zAuNCX\nZLLeyg6EwVsBjNeXiqbMLZ0UT4LadZCpdmEZwKIJYOekK1zAbJPNPMwpdU/U/Z4=\n=DgmA\n-----END PGP SIGNATURE-----\n", "payload": "tree 06b735c4d5adc686b38fcd9b82ae4c4002b492a5\nparent 8f5858007c7e5f8c4f348f22005018fb41750d02\nparent 2f575dab3030467525acae204e47f7a9a8311530\nauthor Dylan DPC <dylan.dpc@gmail.com> 1580430085 +0100\ncommitter GitHub <noreply@github.com> 1580430085 +0100\n\nRollup merge of #68638 - GuillaumeGomez:links-cmp-traits, r=Dylan-DPC\n\nAdd missing links for cmp traits\n\nr? @Dylan-DPC\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f159045adc754a881ecf7061d9689af67c9bec46", "html_url": "https://github.com/rust-lang/rust/commit/f159045adc754a881ecf7061d9689af67c9bec46", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f159045adc754a881ecf7061d9689af67c9bec46/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f5858007c7e5f8c4f348f22005018fb41750d02", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f5858007c7e5f8c4f348f22005018fb41750d02", "html_url": "https://github.com/rust-lang/rust/commit/8f5858007c7e5f8c4f348f22005018fb41750d02"}, {"sha": "2f575dab3030467525acae204e47f7a9a8311530", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f575dab3030467525acae204e47f7a9a8311530", "html_url": "https://github.com/rust-lang/rust/commit/2f575dab3030467525acae204e47f7a9a8311530"}], "stats": {"total": 51, "additions": 31, "deletions": 20}, "files": [{"sha": "e41a7afd3e223a4f840c8a5b5dd14d9d690df050", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 31, "deletions": 20, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/f159045adc754a881ecf7061d9689af67c9bec46/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f159045adc754a881ecf7061d9689af67c9bec46/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=f159045adc754a881ecf7061d9689af67c9bec46", "patch": "@@ -35,7 +35,7 @@ use self::Ordering::*;\n ///\n /// This trait allows for partial equality, for types that do not have a full\n /// equivalence relation. For example, in floating point numbers `NaN != NaN`,\n-/// so floating point types implement `PartialEq` but not `Eq`.\n+/// so floating point types implement `PartialEq` but not [`Eq`].\n ///\n /// Formally, the equality must be (for all `a`, `b` and `c`):\n ///\n@@ -55,12 +55,12 @@ use self::Ordering::*;\n ///\n /// ## How can I implement `PartialEq`?\n ///\n-/// PartialEq only requires the `eq` method to be implemented; `ne` is defined\n-/// in terms of it by default. Any manual implementation of `ne` *must* respect\n-/// the rule that `eq` is a strict inverse of `ne`; that is, `!(a == b)` if and\n+/// `PartialEq` only requires the [`eq`] method to be implemented; [`ne`] is defined\n+/// in terms of it by default. Any manual implementation of [`ne`] *must* respect\n+/// the rule that [`eq`] is a strict inverse of [`ne`]; that is, `!(a == b)` if and\n /// only if `a != b`.\n ///\n-/// Implementations of `PartialEq`, `PartialOrd`, and `Ord` *must* agree with\n+/// Implementations of `PartialEq`, [`PartialOrd`], and [`Ord`] *must* agree with\n /// each other. It's easy to accidentally make them disagree by deriving some\n /// of the traits and manually implementing others.\n ///\n@@ -190,6 +190,9 @@ use self::Ordering::*;\n /// assert_eq!(x == y, false);\n /// assert_eq!(x.eq(&y), false);\n /// ```\n+///\n+/// [`eq`]: PartialEq::eq\n+/// [`ne`]: PartialEq::ne\n #[lang = \"eq\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(alias = \"==\")]\n@@ -233,7 +236,7 @@ pub macro PartialEq($item:item) {\n /// - transitive: `a == b` and `b == c` implies `a == c`.\n ///\n /// This property cannot be checked by the compiler, and therefore `Eq` implies\n-/// `PartialEq`, and has no extra methods.\n+/// [`PartialEq`], and has no extra methods.\n ///\n /// ## Derivable\n ///\n@@ -370,6 +373,7 @@ impl Ordering {\n     /// Chains two orderings.\n     ///\n     /// Returns `self` when it's not `Equal`. Otherwise returns `other`.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -442,10 +446,12 @@ impl Ordering {\n \n /// A helper struct for reverse ordering.\n ///\n-/// This struct is a helper to be used with functions like `Vec::sort_by_key` and\n+/// This struct is a helper to be used with functions like [`Vec::sort_by_key`] and\n /// can be used to reverse order a part of a key.\n ///\n-/// Example usage:\n+/// [`Vec::sort_by_key`]: ../../std/vec/struct.Vec.html#method.sort_by_key\n+///\n+/// # Examples\n ///\n /// ```\n /// use std::cmp::Reverse;\n@@ -506,12 +512,12 @@ impl<T: Ord> Ord for Reverse<T> {\n ///\n /// ## How can I implement `Ord`?\n ///\n-/// `Ord` requires that the type also be `PartialOrd` and `Eq` (which requires `PartialEq`).\n+/// `Ord` requires that the type also be [`PartialOrd`] and [`Eq`] (which requires [`PartialEq`]).\n ///\n-/// Then you must define an implementation for `cmp()`. You may find it useful to use\n-/// `cmp()` on your type's fields.\n+/// Then you must define an implementation for [`cmp`]. You may find it useful to use\n+/// [`cmp`] on your type's fields.\n ///\n-/// Implementations of `PartialEq`, `PartialOrd`, and `Ord` *must*\n+/// Implementations of [`PartialEq`], [`PartialOrd`], and `Ord` *must*\n /// agree with each other. That is, `a.cmp(b) == Ordering::Equal` if\n /// and only if `a == b` and `Some(a.cmp(b)) == a.partial_cmp(b)` for\n /// all `a` and `b`. It's easy to accidentally make them disagree by\n@@ -548,13 +554,15 @@ impl<T: Ord> Ord for Reverse<T> {\n ///     }\n /// }\n /// ```\n+///\n+/// [`cmp`]: Ord::cmp\n #[doc(alias = \"<\")]\n #[doc(alias = \">\")]\n #[doc(alias = \"<=\")]\n #[doc(alias = \">=\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Ord: Eq + PartialOrd<Self> {\n-    /// This method returns an `Ordering` between `self` and `other`.\n+    /// This method returns an [`Ordering`] between `self` and `other`.\n     ///\n     /// By convention, `self.cmp(&other)` returns the ordering matching the expression\n     /// `self <operator> other` if true.\n@@ -689,20 +697,20 @@ impl PartialOrd for Ordering {\n ///\n /// ## How can I implement `PartialOrd`?\n ///\n-/// `PartialOrd` only requires implementation of the `partial_cmp` method, with the others\n+/// `PartialOrd` only requires implementation of the [`partial_cmp`] method, with the others\n /// generated from default implementations.\n ///\n /// However it remains possible to implement the others separately for types which do not have a\n /// total order. For example, for floating point numbers, `NaN < 0 == false` and `NaN >= 0 ==\n /// false` (cf. IEEE 754-2008 section 5.11).\n ///\n-/// `PartialOrd` requires your type to be `PartialEq`.\n+/// `PartialOrd` requires your type to be [`PartialEq`].\n ///\n-/// Implementations of `PartialEq`, `PartialOrd`, and `Ord` *must* agree with each other. It's\n+/// Implementations of [`PartialEq`], `PartialOrd`, and [`Ord`] *must* agree with each other. It's\n /// easy to accidentally make them disagree by deriving some of the traits and manually\n /// implementing others.\n ///\n-/// If your type is `Ord`, you can implement `partial_cmp()` by using `cmp()`:\n+/// If your type is [`Ord`], you can implement [`partial_cmp`] by using [`cmp`]:\n ///\n /// ```\n /// use std::cmp::Ordering;\n@@ -733,7 +741,7 @@ impl PartialOrd for Ordering {\n /// }\n /// ```\n ///\n-/// You may also find it useful to use `partial_cmp()` on your type's fields. Here\n+/// You may also find it useful to use [`partial_cmp`] on your type's fields. Here\n /// is an example of `Person` types who have a floating-point `height` field that\n /// is the only field to be used for sorting:\n ///\n@@ -768,6 +776,9 @@ impl PartialOrd for Ordering {\n /// assert_eq!(x < y, true);\n /// assert_eq!(x.lt(&y), true);\n /// ```\n+///\n+/// [`partial_cmp`]: PartialOrd::partial_cmp\n+/// [`cmp`]: Ord::cmp\n #[lang = \"partial_ord\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(alias = \">\")]\n@@ -893,7 +904,7 @@ pub macro PartialOrd($item:item) {\n ///\n /// Returns the first argument if the comparison determines them to be equal.\n ///\n-/// Internally uses an alias to `Ord::min`.\n+/// Internally uses an alias to [`Ord::min`].\n ///\n /// # Examples\n ///\n@@ -956,7 +967,7 @@ pub fn min_by_key<T, F: FnMut(&T) -> K, K: Ord>(v1: T, v2: T, mut f: F) -> T {\n ///\n /// Returns the second argument if the comparison determines them to be equal.\n ///\n-/// Internally uses an alias to `Ord::max`.\n+/// Internally uses an alias to [`Ord::max`].\n ///\n /// # Examples\n ///"}]}