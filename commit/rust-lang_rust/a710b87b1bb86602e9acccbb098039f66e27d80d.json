{"sha": "a710b87b1bb86602e9acccbb098039f66e27d80d", "node_id": "C_kwDOAAsO6NoAKGE3MTBiODdiMWJiODY2MDJlOWFjY2NiYjA5ODAzOWY2NmUyN2Q4MGQ", "commit": {"author": {"name": "Petr Nevyho\u0161t\u011bn\u00fd", "email": "petr.nevyhosteny@gmail.com", "date": "2022-01-07T15:41:39Z"}, "committer": {"name": "Petr Nevyho\u0161t\u011bn\u00fd", "email": "petr.nevyhosteny@gmail.com", "date": "2022-01-07T15:41:39Z"}, "message": "Fix generic type substitution in impl trait with assoc const", "tree": {"sha": "efa115cf335c4b2bc5fd79255d525903be4633b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/efa115cf335c4b2bc5fd79255d525903be4633b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a710b87b1bb86602e9acccbb098039f66e27d80d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a710b87b1bb86602e9acccbb098039f66e27d80d", "html_url": "https://github.com/rust-lang/rust/commit/a710b87b1bb86602e9acccbb098039f66e27d80d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a710b87b1bb86602e9acccbb098039f66e27d80d/comments", "author": {"login": "pnevyk", "id": 2601371, "node_id": "MDQ6VXNlcjI2MDEzNzE=", "avatar_url": "https://avatars.githubusercontent.com/u/2601371?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnevyk", "html_url": "https://github.com/pnevyk", "followers_url": "https://api.github.com/users/pnevyk/followers", "following_url": "https://api.github.com/users/pnevyk/following{/other_user}", "gists_url": "https://api.github.com/users/pnevyk/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnevyk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnevyk/subscriptions", "organizations_url": "https://api.github.com/users/pnevyk/orgs", "repos_url": "https://api.github.com/users/pnevyk/repos", "events_url": "https://api.github.com/users/pnevyk/events{/privacy}", "received_events_url": "https://api.github.com/users/pnevyk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnevyk", "id": 2601371, "node_id": "MDQ6VXNlcjI2MDEzNzE=", "avatar_url": "https://avatars.githubusercontent.com/u/2601371?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnevyk", "html_url": "https://github.com/pnevyk", "followers_url": "https://api.github.com/users/pnevyk/followers", "following_url": "https://api.github.com/users/pnevyk/following{/other_user}", "gists_url": "https://api.github.com/users/pnevyk/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnevyk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnevyk/subscriptions", "organizations_url": "https://api.github.com/users/pnevyk/orgs", "repos_url": "https://api.github.com/users/pnevyk/repos", "events_url": "https://api.github.com/users/pnevyk/events{/privacy}", "received_events_url": "https://api.github.com/users/pnevyk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9b3242bcd5f4208fad707a30907633ccf081056", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9b3242bcd5f4208fad707a30907633ccf081056", "html_url": "https://github.com/rust-lang/rust/commit/d9b3242bcd5f4208fad707a30907633ccf081056"}], "stats": {"total": 85, "additions": 71, "deletions": 14}, "files": [{"sha": "3105b28911647ec74d578f35afd6a90e08920eca", "filename": "crates/ide_assists/src/handlers/add_missing_impl_members.rs", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a710b87b1bb86602e9acccbb098039f66e27d80d/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a710b87b1bb86602e9acccbb098039f66e27d80d/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs?ref=a710b87b1bb86602e9acccbb098039f66e27d80d", "patch": "@@ -1245,6 +1245,62 @@ impl Behavior<u32> for Impl {\n     fn reproduce(&self, foo: <u32 as bar::Types2>::Bar) {\n         ${0:todo!()}\n     }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_transform_path_in_path_expr() {\n+        check_assist(\n+            add_missing_default_members,\n+            r#\"\n+pub trait Const {\n+    const FOO: u32;\n+}\n+\n+pub trait Trait<T: Const> {\n+    fn foo() -> bool {\n+        match T::FOO {\n+            0 => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+impl Const for u32 {\n+    const FOO: u32 = 1;\n+}\n+\n+struct Impl;\n+\n+impl Trait<u32> for Impl { $0 }\"#,\n+            r#\"\n+pub trait Const {\n+    const FOO: u32;\n+}\n+\n+pub trait Trait<T: Const> {\n+    fn foo() -> bool {\n+        match T::FOO {\n+            0 => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+impl Const for u32 {\n+    const FOO: u32 = 1;\n+}\n+\n+struct Impl;\n+\n+impl Trait<u32> for Impl {\n+    $0fn foo() -> bool {\n+        match <u32 as Const>::FOO {\n+            0 => true,\n+            _ => false,\n+        }\n+    }\n }\"#,\n         );\n     }"}, {"sha": "524af7fe8f01f43a7f7fc343cd39ea6a0d2a5dc2", "filename": "crates/ide_db/src/path_transform.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a710b87b1bb86602e9acccbb098039f66e27d80d/crates%2Fide_db%2Fsrc%2Fpath_transform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a710b87b1bb86602e9acccbb098039f66e27d80d/crates%2Fide_db%2Fsrc%2Fpath_transform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fpath_transform.rs?ref=a710b87b1bb86602e9acccbb098039f66e27d80d", "patch": "@@ -154,14 +154,14 @@ impl<'a> Ctx<'a> {\n                     let parent = path.syntax().parent()?;\n                     if let Some(parent) = ast::Path::cast(parent.clone()) {\n                         // Path inside path means that there is an associated\n-                        // type on the type parameter. It is necessary to fully\n-                        // qualify the type with `as Trait`. Even though it\n-                        // might be unnecessary if `subst` is generic type,\n-                        // always fully qualifying the path is safer because of\n-                        // potential clash of associated types from multiple\n-                        // traits\n+                        // type/constant on the type parameter. It is necessary\n+                        // to fully qualify the type with `as Trait`. Even\n+                        // though it might be unnecessary if `subst` is generic\n+                        // type, always fully qualifying the path is safer\n+                        // because of potential clash of associated types from\n+                        // multiple traits\n \n-                        let trait_ref = find_trait_for_assoc_type(\n+                        let trait_ref = find_trait_for_assoc_item(\n                             self.source_scope,\n                             tp,\n                             parent.segment()?.name_ref()?,\n@@ -252,24 +252,25 @@ fn get_type_args_from_arg_list(generic_arg_list: ast::GenericArgList) -> Option<\n     Some(result)\n }\n \n-fn find_trait_for_assoc_type(\n+fn find_trait_for_assoc_item(\n     scope: &SemanticsScope,\n     type_param: hir::TypeParam,\n-    assoc_type: ast::NameRef,\n+    assoc_item: ast::NameRef,\n ) -> Option<hir::Trait> {\n     let db = scope.db;\n     let trait_bounds = type_param.trait_bounds(db);\n \n-    let assoc_type_name = assoc_type.text();\n+    let assoc_item_name = assoc_item.text();\n \n     for trait_ in trait_bounds {\n-        let type_aliases = trait_.items(db).into_iter().filter_map(|item| match item {\n-            hir::AssocItem::TypeAlias(ta) => Some(ta),\n+        let names = trait_.items(db).into_iter().filter_map(|item| match item {\n+            hir::AssocItem::TypeAlias(ta) => Some(ta.name(db)),\n+            hir::AssocItem::Const(cst) => cst.name(db),\n             _ => None,\n         });\n \n-        for type_alias in type_aliases {\n-            if assoc_type_name.as_str() == type_alias.name(db).as_text()?.as_str() {\n+        for name in names {\n+            if assoc_item_name.as_str() == name.as_text()?.as_str() {\n                 // It is fine to return the first match because in case of\n                 // multiple possibilities, the exact trait must be disambiguated\n                 // in the definition of trait being implemented, so this search"}]}