{"sha": "2b862bed9889808b69629fd7246317189b9517a5", "node_id": "C_kwDOAAsO6NoAKDJiODYyYmVkOTg4OTgwOGI2OTYyOWZkNzI0NjMxNzE4OWI5NTE3YTU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-23T19:38:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-23T19:38:30Z"}, "message": "Auto merge of #89024 - oli-obk:lazy_tait_is_not_limited_to_being_used_in_return_position, r=nikomatsakis\n\nLazy TAIT preparation cleanups\n\nCheck that TAIT generics are fully generic in mir typeck instead of wf-check, as wf-check can by definition only check TAIT in return position and not account for TAITs defined in the body of the function\n\nr? `@spastorino` `@nikomatsakis`", "tree": {"sha": "2248be3a375d2c68b97c575f13295c13646cdd3f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2248be3a375d2c68b97c575f13295c13646cdd3f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b862bed9889808b69629fd7246317189b9517a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b862bed9889808b69629fd7246317189b9517a5", "html_url": "https://github.com/rust-lang/rust/commit/2b862bed9889808b69629fd7246317189b9517a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b862bed9889808b69629fd7246317189b9517a5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf642323d621dcefeef1d8ab4711aae36e357615", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf642323d621dcefeef1d8ab4711aae36e357615", "html_url": "https://github.com/rust-lang/rust/commit/bf642323d621dcefeef1d8ab4711aae36e357615"}, {"sha": "6067eadb65fbc7ba13c32cd76d888d8868a450c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/6067eadb65fbc7ba13c32cd76d888d8868a450c5", "html_url": "https://github.com/rust-lang/rust/commit/6067eadb65fbc7ba13c32cd76d888d8868a450c5"}], "stats": {"total": 705, "additions": 433, "deletions": 272}, "files": [{"sha": "b35e76b96ad9194423b0a145e6d3bd8604d96df7", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 106, "deletions": 3, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/2b862bed9889808b69629fd7246317189b9517a5/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b862bed9889808b69629fd7246317189b9517a5/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=2b862bed9889808b69629fd7246317189b9517a5", "patch": "@@ -1,5 +1,9 @@\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::vec_map::VecMap;\n+use rustc_hir::OpaqueTyOrigin;\n+use rustc_infer::infer::opaque_types::OpaqueTypeDecl;\n use rustc_infer::infer::InferCtxt;\n+use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, OpaqueTypeKey, Ty, TyCtxt, TypeFoldable};\n use rustc_span::Span;\n use rustc_trait_selection::opaque_types::InferCtxtExt;\n@@ -50,13 +54,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     pub(crate) fn infer_opaque_types(\n         &self,\n         infcx: &InferCtxt<'_, 'tcx>,\n-        opaque_ty_decls: VecMap<OpaqueTypeKey<'tcx>, Ty<'tcx>>,\n+        opaque_ty_decls: VecMap<OpaqueTypeKey<'tcx>, OpaqueTypeDecl<'tcx>>,\n         span: Span,\n     ) -> VecMap<OpaqueTypeKey<'tcx>, Ty<'tcx>> {\n         opaque_ty_decls\n             .into_iter()\n-            .map(|(opaque_type_key, concrete_type)| {\n+            .filter_map(|(opaque_type_key, decl)| {\n                 let substs = opaque_type_key.substs;\n+                let concrete_type = decl.concrete_ty;\n                 debug!(?concrete_type, ?substs);\n \n                 let mut subst_regions = vec![self.universal_regions.fr_static];\n@@ -94,7 +99,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     universal_concrete_type,\n                     span,\n                 );\n-                (opaque_type_key, remapped_type)\n+\n+                check_opaque_type_parameter_valid(\n+                    infcx.tcx,\n+                    opaque_type_key,\n+                    OpaqueTypeDecl { concrete_ty: remapped_type, ..decl },\n+                )\n+                .then_some((opaque_type_key, remapped_type))\n             })\n             .collect()\n     }\n@@ -119,3 +130,95 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         })\n     }\n }\n+\n+fn check_opaque_type_parameter_valid(\n+    tcx: TyCtxt<'_>,\n+    opaque_type_key: OpaqueTypeKey<'_>,\n+    decl: OpaqueTypeDecl<'_>,\n+) -> bool {\n+    match decl.origin {\n+        // No need to check return position impl trait (RPIT)\n+        // because for type and const parameters they are correct\n+        // by construction: we convert\n+        //\n+        // fn foo<P0..Pn>() -> impl Trait\n+        //\n+        // into\n+        //\n+        // type Foo<P0...Pn>\n+        // fn foo<P0..Pn>() -> Foo<P0...Pn>.\n+        //\n+        // For lifetime parameters we convert\n+        //\n+        // fn foo<'l0..'ln>() -> impl Trait<'l0..'lm>\n+        //\n+        // into\n+        //\n+        // type foo::<'p0..'pn>::Foo<'q0..'qm>\n+        // fn foo<l0..'ln>() -> foo::<'static..'static>::Foo<'l0..'lm>.\n+        //\n+        // which would error here on all of the `'static` args.\n+        OpaqueTyOrigin::FnReturn | OpaqueTyOrigin::AsyncFn => return true,\n+        // Check these\n+        OpaqueTyOrigin::TyAlias => {}\n+    }\n+    let span = decl.definition_span;\n+    let opaque_generics = tcx.generics_of(opaque_type_key.def_id);\n+    let mut seen_params: FxHashMap<_, Vec<_>> = FxHashMap::default();\n+    for (i, arg) in opaque_type_key.substs.iter().enumerate() {\n+        let arg_is_param = match arg.unpack() {\n+            GenericArgKind::Type(ty) => matches!(ty.kind(), ty::Param(_)),\n+            GenericArgKind::Lifetime(ty::ReStatic) => {\n+                tcx.sess\n+                    .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n+                    .span_label(\n+                        tcx.def_span(opaque_generics.param_at(i, tcx).def_id),\n+                        \"cannot use static lifetime; use a bound lifetime \\\n+                                    instead or remove the lifetime parameter from the \\\n+                                    opaque type\",\n+                    )\n+                    .emit();\n+                return false;\n+            }\n+            GenericArgKind::Lifetime(lt) => {\n+                matches!(lt, ty::ReEarlyBound(_) | ty::ReFree(_))\n+            }\n+            GenericArgKind::Const(ct) => matches!(ct.val, ty::ConstKind::Param(_)),\n+        };\n+\n+        if arg_is_param {\n+            seen_params.entry(arg).or_default().push(i);\n+        } else {\n+            // Prevent `fn foo() -> Foo<u32>` from being defining.\n+            let opaque_param = opaque_generics.param_at(i, tcx);\n+            tcx.sess\n+                .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n+                .span_note(\n+                    tcx.def_span(opaque_param.def_id),\n+                    &format!(\n+                        \"used non-generic {} `{}` for generic parameter\",\n+                        opaque_param.kind.descr(),\n+                        arg,\n+                    ),\n+                )\n+                .emit();\n+            return false;\n+        }\n+    }\n+\n+    for (_, indices) in seen_params {\n+        if indices.len() > 1 {\n+            let descr = opaque_generics.param_at(indices[0], tcx).kind.descr();\n+            let spans: Vec<_> = indices\n+                .into_iter()\n+                .map(|i| tcx.def_span(opaque_generics.param_at(i, tcx).def_id))\n+                .collect();\n+            tcx.sess\n+                .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n+                .span_note(spans, &format!(\"{} used multiple times\", descr))\n+                .emit();\n+            return false;\n+        }\n+    }\n+    true\n+}"}, {"sha": "3e536eb845f620eb50f72d0800f5e2795d45dd39", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2b862bed9889808b69629fd7246317189b9517a5/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b862bed9889808b69629fd7246317189b9517a5/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=2b862bed9889808b69629fd7246317189b9517a5", "patch": "@@ -14,6 +14,7 @@ use rustc_hir::def_id::LocalDefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_infer::infer::canonical::QueryRegionConstraints;\n+use rustc_infer::infer::opaque_types::OpaqueTypeDecl;\n use rustc_infer::infer::outlives::env::RegionBoundPairs;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{\n@@ -193,16 +194,17 @@ pub(crate) fn type_check<'mir, 'tcx>(\n \n             opaque_type_values\n                 .into_iter()\n-                .filter_map(|(opaque_type_key, decl)| {\n-                    let mut revealed_ty = infcx.resolve_vars_if_possible(decl.concrete_ty);\n-                    if revealed_ty.has_infer_types_or_consts() {\n+                .filter_map(|(opaque_type_key, mut decl)| {\n+                    decl.concrete_ty = infcx.resolve_vars_if_possible(decl.concrete_ty);\n+                    if decl.concrete_ty.has_infer_types_or_consts() {\n                         infcx.tcx.sess.delay_span_bug(\n                             body.span,\n-                            &format!(\"could not resolve {:#?}\", revealed_ty.kind()),\n+                            &format!(\"could not resolve {:#?}\", decl.concrete_ty.kind()),\n                         );\n-                        revealed_ty = infcx.tcx.ty_error();\n+                        decl.concrete_ty = infcx.tcx.ty_error();\n                     }\n-                    let concrete_is_opaque = if let ty::Opaque(def_id, _) = revealed_ty.kind() {\n+                    let concrete_is_opaque = if let ty::Opaque(def_id, _) = decl.concrete_ty.kind()\n+                    {\n                         *def_id == opaque_type_key.def_id\n                     } else {\n                         false\n@@ -234,7 +236,7 @@ pub(crate) fn type_check<'mir, 'tcx>(\n                         );\n                         None\n                     } else {\n-                        Some((opaque_type_key, revealed_ty))\n+                        Some((opaque_type_key, decl))\n                     }\n                 })\n                 .collect()\n@@ -890,7 +892,7 @@ struct BorrowCheckContext<'a, 'tcx> {\n crate struct MirTypeckResults<'tcx> {\n     crate constraints: MirTypeckRegionConstraints<'tcx>,\n     crate universal_region_relations: Frozen<UniversalRegionRelations<'tcx>>,\n-    crate opaque_type_values: VecMap<OpaqueTypeKey<'tcx>, Ty<'tcx>>,\n+    crate opaque_type_values: VecMap<OpaqueTypeKey<'tcx>, OpaqueTypeDecl<'tcx>>,\n }\n \n /// A collection of region constraints that must be satisfied for the"}, {"sha": "028f6e89f18f127eac726cb7177d1ca8d72373ee", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2b862bed9889808b69629fd7246317189b9517a5/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b862bed9889808b69629fd7246317189b9517a5/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=2b862bed9889808b69629fd7246317189b9517a5", "patch": "@@ -1062,11 +1062,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n /// Here, `def_id` is the `LocalDefId` of the defining use of the opaque type (e.g., `f1` or `f2`),\n /// and `opaque_hir_id` is the `HirId` of the definition of the opaque type `Baz`.\n /// For the above example, this function returns `true` for `f1` and `false` for `f2`.\n-pub fn may_define_opaque_type(\n-    tcx: TyCtxt<'_>,\n-    def_id: LocalDefId,\n-    opaque_hir_id: hir::HirId,\n-) -> bool {\n+fn may_define_opaque_type(tcx: TyCtxt<'_>, def_id: LocalDefId, opaque_hir_id: hir::HirId) -> bool {\n     let mut hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n \n     // Named opaque types can be defined by any siblings or children of siblings."}, {"sha": "01ec801228e2e8f0d35e3e931e94d83f4338b5cd", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 16, "deletions": 152, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/2b862bed9889808b69629fd7246317189b9517a5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b862bed9889808b69629fd7246317189b9517a5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=2b862bed9889808b69629fd7246317189b9517a5", "patch": "@@ -2,7 +2,7 @@ use crate::check::{FnCtxt, Inherited};\n use crate::constrained_generic_params::{identify_constrained_generic_params, Parameter};\n \n use rustc_ast as ast;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -12,15 +12,14 @@ use rustc_hir::itemlikevisit::ParItemLikeVisitor;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::ItemKind;\n use rustc_middle::hir::map as hir_map;\n-use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts, Subst};\n+use rustc_middle::ty::subst::{InternalSubsts, Subst};\n use rustc_middle::ty::trait_def::TraitSpecializationKind;\n use rustc_middle::ty::{\n     self, AdtKind, GenericParamDefKind, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n };\n use rustc_session::parse::feature_err;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n-use rustc_trait_selection::opaque_types::may_define_opaque_type;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode, WellFormedLoc};\n \n@@ -77,14 +76,14 @@ impl<'tcx> CheckWfFcxBuilder<'tcx> {\n /// We do this check as a pre-pass before checking fn bodies because if these constraints are\n /// not included it frequently leads to confusing errors in fn bodies. So it's better to check\n /// the types first.\n+#[instrument(skip(tcx), level = \"debug\")]\n pub fn check_item_well_formed(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n     let item = tcx.hir().expect_item(hir_id);\n \n     debug!(\n-        \"check_item_well_formed(it.def_id={:?}, it.name={})\",\n-        item.def_id,\n-        tcx.def_path_str(def_id.to_def_id())\n+        ?item.def_id,\n+        item.name = ? tcx.def_path_str(def_id.to_def_id())\n     );\n \n     match item.kind {\n@@ -557,8 +556,9 @@ fn check_type_defn<'tcx, F>(\n     });\n }\n \n+#[instrument(skip(tcx, item))]\n fn check_trait(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {\n-    debug!(\"check_trait: {:?}\", item.def_id);\n+    debug!(?item.def_id);\n \n     let trait_def = tcx.trait_def(item.def_id);\n     if trait_def.is_marker\n@@ -712,13 +712,13 @@ fn check_impl<'tcx>(\n }\n \n /// Checks where-clauses and inline bounds that are declared on `def_id`.\n+#[instrument(skip(fcx), level = \"debug\")]\n fn check_where_clauses<'tcx, 'fcx>(\n     fcx: &FnCtxt<'fcx, 'tcx>,\n     span: Span,\n     def_id: DefId,\n     return_ty: Option<(Ty<'tcx>, Span)>,\n ) {\n-    debug!(\"check_where_clauses(def_id={:?}, return_ty={:?})\", def_id, return_ty);\n     let tcx = fcx.tcx;\n \n     let predicates = tcx.predicates_of(def_id);\n@@ -888,17 +888,15 @@ fn check_where_clauses<'tcx, 'fcx>(\n \n     let predicates = predicates.instantiate_identity(tcx);\n \n-    if let Some((mut return_ty, span)) = return_ty {\n+    if let Some((return_ty, _)) = return_ty {\n         if return_ty.has_infer_types_or_consts() {\n             fcx.select_obligations_where_possible(false, |_| {});\n-            return_ty = fcx.resolve_vars_if_possible(return_ty);\n         }\n-        check_opaque_types(fcx, def_id.expect_local(), span, return_ty);\n     }\n \n     let predicates = fcx.normalize_associated_types_in(span, predicates);\n \n-    debug!(\"check_where_clauses: predicates={:?}\", predicates.predicates);\n+    debug!(?predicates.predicates);\n     assert_eq!(predicates.predicates.len(), predicates.spans.len());\n     let wf_obligations =\n         iter::zip(&predicates.predicates, &predicates.spans).flat_map(|(&p, &sp)| {\n@@ -984,143 +982,6 @@ fn check_fn_or_method<'fcx, 'tcx>(\n     check_where_clauses(fcx, span, def_id, Some((sig.output(), hir_decl.output.span())));\n }\n \n-/// Checks \"defining uses\" of opaque `impl Trait` types to ensure that they meet the restrictions\n-/// laid for \"higher-order pattern unification\".\n-/// This ensures that inference is tractable.\n-/// In particular, definitions of opaque types can only use other generics as arguments,\n-/// and they cannot repeat an argument. Example:\n-///\n-/// ```rust\n-/// type Foo<A, B> = impl Bar<A, B>;\n-///\n-/// // Okay -- `Foo` is applied to two distinct, generic types.\n-/// fn a<T, U>() -> Foo<T, U> { .. }\n-///\n-/// // Not okay -- `Foo` is applied to `T` twice.\n-/// fn b<T>() -> Foo<T, T> { .. }\n-///\n-/// // Not okay -- `Foo` is applied to a non-generic type.\n-/// fn b<T>() -> Foo<T, u32> { .. }\n-/// ```\n-///\n-fn check_opaque_types<'fcx, 'tcx>(\n-    fcx: &FnCtxt<'fcx, 'tcx>,\n-    fn_def_id: LocalDefId,\n-    span: Span,\n-    ty: Ty<'tcx>,\n-) {\n-    trace!(\"check_opaque_types(fn_def_id={:?}, ty={:?})\", fn_def_id, ty);\n-    let tcx = fcx.tcx;\n-\n-    ty.fold_with(&mut ty::fold::BottomUpFolder {\n-        tcx,\n-        ty_op: |ty| {\n-            if let ty::Opaque(def_id, substs) = *ty.kind() {\n-                trace!(\"check_opaque_types: opaque_ty, {:?}, {:?}\", def_id, substs);\n-                let generics = tcx.generics_of(def_id);\n-\n-                let opaque_hir_id = if let Some(local_id) = def_id.as_local() {\n-                    tcx.hir().local_def_id_to_hir_id(local_id)\n-                } else {\n-                    // Opaque types from other crates won't have defining uses in this crate.\n-                    return ty;\n-                };\n-                if let hir::ItemKind::OpaqueTy(hir::OpaqueTy { impl_trait_fn: Some(_), .. }) =\n-                    tcx.hir().expect_item(opaque_hir_id).kind\n-                {\n-                    // No need to check return position impl trait (RPIT)\n-                    // because for type and const parameters they are correct\n-                    // by construction: we convert\n-                    //\n-                    // fn foo<P0..Pn>() -> impl Trait\n-                    //\n-                    // into\n-                    //\n-                    // type Foo<P0...Pn>\n-                    // fn foo<P0..Pn>() -> Foo<P0...Pn>.\n-                    //\n-                    // For lifetime parameters we convert\n-                    //\n-                    // fn foo<'l0..'ln>() -> impl Trait<'l0..'lm>\n-                    //\n-                    // into\n-                    //\n-                    // type foo::<'p0..'pn>::Foo<'q0..'qm>\n-                    // fn foo<l0..'ln>() -> foo::<'static..'static>::Foo<'l0..'lm>.\n-                    //\n-                    // which would error here on all of the `'static` args.\n-                    return ty;\n-                }\n-                if !may_define_opaque_type(tcx, fn_def_id, opaque_hir_id) {\n-                    return ty;\n-                }\n-                trace!(\"check_opaque_types: may define, generics={:#?}\", generics);\n-                let mut seen_params: FxHashMap<_, Vec<_>> = FxHashMap::default();\n-                for (i, arg) in substs.iter().enumerate() {\n-                    let arg_is_param = match arg.unpack() {\n-                        GenericArgKind::Type(ty) => matches!(ty.kind(), ty::Param(_)),\n-\n-                        GenericArgKind::Lifetime(region) if let ty::ReStatic = region => {\n-                            tcx.sess\n-                                .struct_span_err(\n-                                    span,\n-                                    \"non-defining opaque type use in defining scope\",\n-                                )\n-                                .span_label(\n-                                    tcx.def_span(generics.param_at(i, tcx).def_id),\n-                                    \"cannot use static lifetime; use a bound lifetime \\\n-                                                instead or remove the lifetime parameter from the \\\n-                                                opaque type\",\n-                                )\n-                                .emit();\n-                            continue;\n-                        }\n-\n-                        GenericArgKind::Lifetime(_) => true,\n-\n-                        GenericArgKind::Const(ct) => matches!(ct.val, ty::ConstKind::Param(_)),\n-                    };\n-\n-                    if arg_is_param {\n-                        seen_params.entry(arg).or_default().push(i);\n-                    } else {\n-                        // Prevent `fn foo() -> Foo<u32>` from being defining.\n-                        let opaque_param = generics.param_at(i, tcx);\n-                        tcx.sess\n-                            .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n-                            .span_note(\n-                                tcx.def_span(opaque_param.def_id),\n-                                &format!(\n-                                    \"used non-generic {} `{}` for generic parameter\",\n-                                    opaque_param.kind.descr(),\n-                                    arg,\n-                                ),\n-                            )\n-                            .emit();\n-                    }\n-                } // for (arg, param)\n-\n-                for (_, indices) in seen_params {\n-                    if indices.len() > 1 {\n-                        let descr = generics.param_at(indices[0], tcx).kind.descr();\n-                        let spans: Vec<_> = indices\n-                            .into_iter()\n-                            .map(|i| tcx.def_span(generics.param_at(i, tcx).def_id))\n-                            .collect();\n-                        tcx.sess\n-                            .struct_span_err(span, \"non-defining opaque type use in defining scope\")\n-                            .span_note(spans, &format!(\"{} used multiple times\", descr))\n-                            .emit();\n-                    }\n-                }\n-            } // if let Opaque\n-            ty\n-        },\n-        lt_op: |lt| lt,\n-        ct_op: |ct| ct,\n-    });\n-}\n-\n const HELP_FOR_SELF_TYPE: &str = \"consider changing to `self`, `&self`, `&mut self`, `self: Box<Self>`, \\\n      `self: Rc<Self>`, `self: Arc<Self>`, or `self: Pin<P>` (where P is one \\\n      of the previous types except `Self`)\";\n@@ -1439,20 +1300,23 @@ impl Visitor<'tcx> for CheckTypeWellFormedVisitor<'tcx> {\n         hir_visit::NestedVisitorMap::OnlyBodies(self.tcx.hir())\n     }\n \n+    #[instrument(skip(self, i), level = \"debug\")]\n     fn visit_item(&mut self, i: &'tcx hir::Item<'tcx>) {\n-        debug!(\"visit_item: {:?}\", i);\n+        trace!(?i);\n         self.tcx.ensure().check_item_well_formed(i.def_id);\n         hir_visit::walk_item(self, i);\n     }\n \n+    #[instrument(skip(self, trait_item), level = \"debug\")]\n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n-        debug!(\"visit_trait_item: {:?}\", trait_item);\n+        trace!(?trait_item);\n         self.tcx.ensure().check_trait_item_well_formed(trait_item.def_id);\n         hir_visit::walk_trait_item(self, trait_item);\n     }\n \n+    #[instrument(skip(self, impl_item), level = \"debug\")]\n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n-        debug!(\"visit_impl_item: {:?}\", impl_item);\n+        trace!(?impl_item);\n         self.tcx.ensure().check_impl_item_well_formed(impl_item.def_id);\n         hir_visit::walk_impl_item(self, impl_item);\n     }"}, {"sha": "7a14d7f3d283d0afe0a412a4c49cd2bd447dfd8c", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 21, "deletions": 45, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/2b862bed9889808b69629fd7246317189b9517a5/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b862bed9889808b69629fd7246317189b9517a5/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=2b862bed9889808b69629fd7246317189b9517a5", "patch": "@@ -1,4 +1,3 @@\n-use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{Applicability, ErrorReported, StashKey};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n@@ -7,7 +6,7 @@ use rustc_hir::intravisit;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::{HirId, Node};\n use rustc_middle::hir::map::Map;\n-use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts, SubstsRef};\n+use rustc_middle::ty::subst::{InternalSubsts, SubstsRef};\n use rustc_middle::ty::util::IntTypeExt;\n use rustc_middle::ty::{self, DefIdTree, Ty, TyCtxt, TypeFoldable, TypeFolder};\n use rustc_span::symbol::Ident;\n@@ -539,6 +538,25 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n }\n \n #[instrument(skip(tcx), level = \"debug\")]\n+/// Checks \"defining uses\" of opaque `impl Trait` types to ensure that they meet the restrictions\n+/// laid for \"higher-order pattern unification\".\n+/// This ensures that inference is tractable.\n+/// In particular, definitions of opaque types can only use other generics as arguments,\n+/// and they cannot repeat an argument. Example:\n+///\n+/// ```rust\n+/// type Foo<A, B> = impl Bar<A, B>;\n+///\n+/// // Okay -- `Foo` is applied to two distinct, generic types.\n+/// fn a<T, U>() -> Foo<T, U> { .. }\n+///\n+/// // Not okay -- `Foo` is applied to `T` twice.\n+/// fn b<T>() -> Foo<T, T> { .. }\n+///\n+/// // Not okay -- `Foo` is applied to a non-generic type.\n+/// fn b<T>() -> Foo<T, u32> { .. }\n+/// ```\n+///\n fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n     use rustc_hir::{Expr, ImplItem, Item, TraitItem};\n \n@@ -584,50 +602,8 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n                 // FIXME(oli-obk): trace the actual span from inference to improve errors.\n                 let span = self.tcx.def_span(def_id);\n \n-                // HACK(eddyb) this check shouldn't be needed, as `wfcheck`\n-                // performs the same checks, in theory, but I've kept it here\n-                // using `delay_span_bug`, just in case `wfcheck` slips up.\n-                let opaque_generics = self.tcx.generics_of(self.def_id);\n-                let mut used_params: FxHashSet<_> = FxHashSet::default();\n-                for (i, arg) in opaque_type_key.substs.iter().enumerate() {\n-                    let arg_is_param = match arg.unpack() {\n-                        GenericArgKind::Type(ty) => matches!(ty.kind(), ty::Param(_)),\n-                        GenericArgKind::Lifetime(lt) => {\n-                            matches!(lt, ty::ReEarlyBound(_) | ty::ReFree(_))\n-                        }\n-                        GenericArgKind::Const(ct) => matches!(ct.val, ty::ConstKind::Param(_)),\n-                    };\n-\n-                    if arg_is_param {\n-                        if !used_params.insert(arg) {\n-                            // There was already an entry for `arg`, meaning a generic parameter\n-                            // was used twice.\n-                            self.tcx.sess.delay_span_bug(\n-                                span,\n-                                &format!(\n-                                    \"defining opaque type use restricts opaque \\\n-                                     type by using the generic parameter `{}` twice\",\n-                                    arg,\n-                                ),\n-                            );\n-                        }\n-                    } else {\n-                        let param = opaque_generics.param_at(i, self.tcx);\n-                        self.tcx.sess.delay_span_bug(\n-                            span,\n-                            &format!(\n-                                \"defining opaque type use does not fully define opaque type: \\\n-                                 generic parameter `{}` is specified as concrete {} `{}`\",\n-                                param.name,\n-                                param.kind.descr(),\n-                                arg,\n-                            ),\n-                        );\n-                    }\n-                }\n-\n                 if let Some((prev_span, prev_ty)) = self.found {\n-                    if *concrete_type != prev_ty {\n+                    if *concrete_type != prev_ty && !(*concrete_type, prev_ty).references_error() {\n                         debug!(?span);\n                         // Found different concrete types for the opaque type.\n                         let mut err = self.tcx.sess.struct_span_err("}, {"sha": "579067340e85cb72df1cb5775ab0d5df604afdf9", "filename": "src/test/ui/type-alias-impl-trait/bound_reduction2.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.rs?ref=2b862bed9889808b69629fd7246317189b9517a5", "patch": "@@ -7,12 +7,17 @@ trait TraitWithAssoc {\n }\n \n type Foo<V> = impl Trait<V>;\n+//~^ ERROR could not find defining uses\n \n trait Trait<U> {}\n \n impl<W> Trait<W> for () {}\n \n fn foo_desugared<T: TraitWithAssoc>(_: T) -> Foo<T::Assoc> {\n     //~^ ERROR non-defining opaque type use in defining scope\n+    //~| ERROR non-defining opaque type use in defining scope\n+    //~| ERROR non-defining opaque type use in defining scope\n+    //~| ERROR `T` is part of concrete type but not used in parameter list\n+    //~| ERROR `T` is part of concrete type but not used in parameter list\n     ()\n }"}, {"sha": "a77c0000f12e1a0571b4a3710747e7104226243f", "filename": "src/test/ui/type-alias-impl-trait/bound_reduction2.stderr", "status": "modified", "additions": 59, "deletions": 3, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fbound_reduction2.stderr?ref=2b862bed9889808b69629fd7246317189b9517a5", "patch": "@@ -1,14 +1,70 @@\n+error: type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n+  --> $DIR/bound_reduction2.rs:16:60\n+   |\n+LL |   fn foo_desugared<T: TraitWithAssoc>(_: T) -> Foo<T::Assoc> {\n+   |  ____________________________________________________________^\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | |     ()\n+LL | | }\n+   | |_^\n+\n+error: type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n+  --> $DIR/bound_reduction2.rs:16:60\n+   |\n+LL |   fn foo_desugared<T: TraitWithAssoc>(_: T) -> Foo<T::Assoc> {\n+   |  ____________________________________________________________^\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | |     ()\n+LL | | }\n+   | |_^\n+\n error: non-defining opaque type use in defining scope\n-  --> $DIR/bound_reduction2.rs:15:46\n+  --> $DIR/bound_reduction2.rs:16:1\n    |\n LL | fn foo_desugared<T: TraitWithAssoc>(_: T) -> Foo<T::Assoc> {\n-   |                                              ^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: used non-generic type `<T as TraitWithAssoc>::Assoc` for generic parameter\n   --> $DIR/bound_reduction2.rs:9:10\n    |\n LL | type Foo<V> = impl Trait<V>;\n    |          ^\n \n-error: aborting due to previous error\n+error: non-defining opaque type use in defining scope\n+  --> $DIR/bound_reduction2.rs:16:1\n+   |\n+LL | fn foo_desugared<T: TraitWithAssoc>(_: T) -> Foo<T::Assoc> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: used non-generic type `_` for generic parameter\n+  --> $DIR/bound_reduction2.rs:9:10\n+   |\n+LL | type Foo<V> = impl Trait<V>;\n+   |          ^\n+\n+error: non-defining opaque type use in defining scope\n+  --> $DIR/bound_reduction2.rs:16:1\n+   |\n+LL | fn foo_desugared<T: TraitWithAssoc>(_: T) -> Foo<T::Assoc> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: used non-generic type `_` for generic parameter\n+  --> $DIR/bound_reduction2.rs:9:10\n+   |\n+LL | type Foo<V> = impl Trait<V>;\n+   |          ^\n+\n+error: could not find defining uses\n+  --> $DIR/bound_reduction2.rs:9:15\n+   |\n+LL | type Foo<V> = impl Trait<V>;\n+   |               ^^^^^^^^^^^^^\n+\n+error: aborting due to 6 previous errors\n "}, {"sha": "885aae619d6a2bf5249b79df995508a4a63b336b", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_lifetime_param.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_lifetime_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_lifetime_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_lifetime_param.rs?ref=2b862bed9889808b69629fd7246317189b9517a5", "patch": "@@ -3,6 +3,7 @@\n fn main() {}\n \n type Two<'a, 'b> = impl std::fmt::Debug;\n+//~^ ERROR could not find defining uses\n \n fn one<'a>(t: &'a ()) -> Two<'a, 'a> {\n     //~^ ERROR non-defining opaque type use"}, {"sha": "b99c6a51f4b1d24faa3cf2984eb3d9ff09da53ec", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_lifetime_param.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_lifetime_param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_lifetime_param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_lifetime_param.stderr?ref=2b862bed9889808b69629fd7246317189b9517a5", "patch": "@@ -1,5 +1,5 @@\n error: non-defining opaque type use in defining scope\n-  --> $DIR/generic_duplicate_lifetime_param.rs:7:26\n+  --> $DIR/generic_duplicate_lifetime_param.rs:8:26\n    |\n LL | fn one<'a>(t: &'a ()) -> Two<'a, 'a> {\n    |                          ^^^^^^^^^^^\n@@ -10,5 +10,11 @@ note: lifetime used multiple times\n LL | type Two<'a, 'b> = impl std::fmt::Debug;\n    |          ^^  ^^\n \n-error: aborting due to previous error\n+error: could not find defining uses\n+  --> $DIR/generic_duplicate_lifetime_param.rs:5:20\n+   |\n+LL | type Two<'a, 'b> = impl std::fmt::Debug;\n+   |                    ^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "33cd2f6ba07539da18608740f78f3efa94f4de54", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.rs?ref=2b862bed9889808b69629fd7246317189b9517a5", "patch": "@@ -6,8 +6,11 @@ fn main() {}\n \n // test that unused generic parameters are ok\n type TwoTys<T, U> = impl Debug;\n+//~^ ERROR could not find defining uses\n type TwoLifetimes<'a, 'b> = impl Debug;\n+//~^ ERROR could not find defining uses\n type TwoConsts<const X: usize, const Y: usize> = impl Debug;\n+//~^ ERROR could not find defining uses\n \n fn one_ty<T: Debug>(t: T) -> TwoTys<T, T> {\n     //~^ ERROR non-defining opaque type use in defining scope"}, {"sha": "52c60d1777e49131ecfc4b132c9096dd71b700bb", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use.stderr", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use.stderr?ref=2b862bed9889808b69629fd7246317189b9517a5", "patch": "@@ -1,5 +1,5 @@\n error: non-defining opaque type use in defining scope\n-  --> $DIR/generic_duplicate_param_use.rs:12:30\n+  --> $DIR/generic_duplicate_param_use.rs:15:30\n    |\n LL | fn one_ty<T: Debug>(t: T) -> TwoTys<T, T> {\n    |                              ^^^^^^^^^^^^\n@@ -10,29 +10,47 @@ note: type used multiple times\n LL | type TwoTys<T, U> = impl Debug;\n    |             ^  ^\n \n+error: could not find defining uses\n+  --> $DIR/generic_duplicate_param_use.rs:8:21\n+   |\n+LL | type TwoTys<T, U> = impl Debug;\n+   |                     ^^^^^^^^^^\n+\n error: non-defining opaque type use in defining scope\n-  --> $DIR/generic_duplicate_param_use.rs:17:36\n+  --> $DIR/generic_duplicate_param_use.rs:20:36\n    |\n LL | fn one_lifetime<'a>(t: &'a u32) -> TwoLifetimes<'a, 'a> {\n    |                                    ^^^^^^^^^^^^^^^^^^^^\n    |\n note: lifetime used multiple times\n-  --> $DIR/generic_duplicate_param_use.rs:9:19\n+  --> $DIR/generic_duplicate_param_use.rs:10:19\n    |\n LL | type TwoLifetimes<'a, 'b> = impl Debug;\n    |                   ^^  ^^\n \n+error: could not find defining uses\n+  --> $DIR/generic_duplicate_param_use.rs:10:29\n+   |\n+LL | type TwoLifetimes<'a, 'b> = impl Debug;\n+   |                             ^^^^^^^^^^\n+\n error: non-defining opaque type use in defining scope\n-  --> $DIR/generic_duplicate_param_use.rs:22:50\n+  --> $DIR/generic_duplicate_param_use.rs:25:50\n    |\n LL | fn one_const<const N: usize>(t: *mut [u8; N]) -> TwoConsts<N, N> {\n    |                                                  ^^^^^^^^^^^^^^^\n    |\n note: constant used multiple times\n-  --> $DIR/generic_duplicate_param_use.rs:10:22\n+  --> $DIR/generic_duplicate_param_use.rs:12:22\n    |\n LL | type TwoConsts<const X: usize, const Y: usize> = impl Debug;\n    |                      ^               ^\n \n-error: aborting due to 3 previous errors\n+error: could not find defining uses\n+  --> $DIR/generic_duplicate_param_use.rs:12:50\n+   |\n+LL | type TwoConsts<const X: usize, const Y: usize> = impl Debug;\n+   |                                                  ^^^^^^^^^^\n+\n+error: aborting due to 6 previous errors\n "}, {"sha": "04fb57b39c052c3467fb45d3a7a3ab6cde829cc1", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use2.rs?ref=2b862bed9889808b69629fd7246317189b9517a5", "patch": "@@ -6,6 +6,7 @@ fn main() {}\n \n // test that unused generic parameters are ok\n type Two<T, U> = impl Debug;\n+//~^ ERROR `T` doesn't implement `Debug`\n \n fn one<T: Debug>(t: T) -> Two<T, T> {\n     //~^ ERROR non-defining opaque type use in defining scope"}, {"sha": "fca9b70d1844173127303eb69e8b2ca171e5a9c3", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use2.stderr", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use2.stderr?ref=2b862bed9889808b69629fd7246317189b9517a5", "patch": "@@ -1,5 +1,5 @@\n error: non-defining opaque type use in defining scope\n-  --> $DIR/generic_duplicate_param_use2.rs:10:27\n+  --> $DIR/generic_duplicate_param_use2.rs:11:27\n    |\n LL | fn one<T: Debug>(t: T) -> Two<T, T> {\n    |                           ^^^^^^^^^\n@@ -10,5 +10,17 @@ note: type used multiple times\n LL | type Two<T, U> = impl Debug;\n    |          ^  ^\n \n-error: aborting due to previous error\n+error[E0277]: `T` doesn't implement `Debug`\n+  --> $DIR/generic_duplicate_param_use2.rs:8:18\n+   |\n+LL | type Two<T, U> = impl Debug;\n+   |                  ^^^^^^^^^^ `T` cannot be formatted using `{:?}` because it doesn't implement `Debug`\n+   |\n+help: consider restricting type parameter `T`\n+   |\n+LL | type Two<T: std::fmt::Debug, U> = impl Debug;\n+   |           +++++++++++++++++\n+\n+error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "1a755d3902612f125a17b5f5477634743baf941a", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use3.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.rs?ref=2b862bed9889808b69629fd7246317189b9517a5", "patch": "@@ -6,6 +6,7 @@ fn main() {}\n \n // test that unused generic parameters are ok\n type Two<T, U> = impl Debug;\n+//~^ ERROR `T` doesn't implement `Debug`\n \n fn one<T: Debug>(t: T) -> Two<T, T> {\n     //~^ ERROR non-defining opaque type use in defining scope\n@@ -17,5 +18,6 @@ fn two<T: Debug, U>(t: T, _: U) -> Two<T, U> {\n }\n \n fn three<T, U: Debug>(_: T, u: U) -> Two<T, U> {\n+    //~^ ERROR concrete type differs from previous defining opaque type use\n     u\n }"}, {"sha": "90b04c043a00ccb1d0fa28571d9e7ffaaa54fdee", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use3.stderr", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.stderr?ref=2b862bed9889808b69629fd7246317189b9517a5", "patch": "@@ -1,5 +1,5 @@\n error: non-defining opaque type use in defining scope\n-  --> $DIR/generic_duplicate_param_use3.rs:10:27\n+  --> $DIR/generic_duplicate_param_use3.rs:11:27\n    |\n LL | fn one<T: Debug>(t: T) -> Two<T, T> {\n    |                           ^^^^^^^^^\n@@ -10,5 +10,29 @@ note: type used multiple times\n LL | type Two<T, U> = impl Debug;\n    |          ^  ^\n \n-error: aborting due to previous error\n+error: concrete type differs from previous defining opaque type use\n+  --> $DIR/generic_duplicate_param_use3.rs:20:1\n+   |\n+LL | fn three<T, U: Debug>(_: T, u: U) -> Two<T, U> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `T`, got `U`\n+   |\n+note: previous use here\n+  --> $DIR/generic_duplicate_param_use3.rs:16:1\n+   |\n+LL | fn two<T: Debug, U>(t: T, _: U) -> Two<T, U> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0277]: `T` doesn't implement `Debug`\n+  --> $DIR/generic_duplicate_param_use3.rs:8:18\n+   |\n+LL | type Two<T, U> = impl Debug;\n+   |                  ^^^^^^^^^^ `T` cannot be formatted using `{:?}` because it doesn't implement `Debug`\n+   |\n+help: consider restricting type parameter `T`\n+   |\n+LL | type Two<T: std::fmt::Debug, U> = impl Debug;\n+   |           +++++++++++++++++\n+\n+error: aborting due to 3 previous errors\n \n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "50d95c83d58e644600976228707615908d42cec6", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use4.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use4.rs?ref=2b862bed9889808b69629fd7246317189b9517a5", "patch": "@@ -6,6 +6,7 @@ fn main() {}\n \n // test that unused generic parameters are ok\n type Two<T, U> = impl Debug;\n+//~^ ERROR `U` doesn't implement `Debug`\n \n fn one<T: Debug>(t: T) -> Two<T, T> {\n     //~^ ERROR non-defining opaque type use in defining scope"}, {"sha": "c4be2fa83f130fd068f7be5f14eddb4ac529ef93", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use4.stderr", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use4.stderr?ref=2b862bed9889808b69629fd7246317189b9517a5", "patch": "@@ -1,5 +1,5 @@\n error: non-defining opaque type use in defining scope\n-  --> $DIR/generic_duplicate_param_use4.rs:10:27\n+  --> $DIR/generic_duplicate_param_use4.rs:11:27\n    |\n LL | fn one<T: Debug>(t: T) -> Two<T, T> {\n    |                           ^^^^^^^^^\n@@ -10,5 +10,17 @@ note: type used multiple times\n LL | type Two<T, U> = impl Debug;\n    |          ^  ^\n \n-error: aborting due to previous error\n+error[E0277]: `U` doesn't implement `Debug`\n+  --> $DIR/generic_duplicate_param_use4.rs:8:18\n+   |\n+LL | type Two<T, U> = impl Debug;\n+   |                  ^^^^^^^^^^ `U` cannot be formatted using `{:?}` because it doesn't implement `Debug`\n+   |\n+help: consider restricting type parameter `U`\n+   |\n+LL | type Two<T, U: std::fmt::Debug> = impl Debug;\n+   |              +++++++++++++++++\n+\n+error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "cf43085877f4c7864eefd534a8cb071c130989a6", "filename": "src/test/ui/type-alias-impl-trait/generic_nondefining_use.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.rs?ref=2b862bed9889808b69629fd7246317189b9517a5", "patch": "@@ -5,8 +5,11 @@ use std::fmt::Debug;\n fn main() {}\n \n type OneTy<T> = impl Debug;\n+//~^ ERROR could not find defining uses\n type OneLifetime<'a> = impl Debug;\n+//~^ ERROR could not find defining uses\n type OneConst<const X: usize> = impl Debug;\n+//~^ ERROR could not find defining uses\n \n // Not defining uses, because they doesn't define *all* possible generics.\n "}, {"sha": "3aa42a25484d1dcc169f6ed6423f5b4ded454225", "filename": "src/test/ui/type-alias-impl-trait/generic_nondefining_use.stderr", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.stderr?ref=2b862bed9889808b69629fd7246317189b9517a5", "patch": "@@ -1,5 +1,5 @@\n error: non-defining opaque type use in defining scope\n-  --> $DIR/generic_nondefining_use.rs:13:21\n+  --> $DIR/generic_nondefining_use.rs:16:21\n    |\n LL | fn concrete_ty() -> OneTy<u32> {\n    |                     ^^^^^^^^^^\n@@ -10,26 +10,44 @@ note: used non-generic type `u32` for generic parameter\n LL | type OneTy<T> = impl Debug;\n    |            ^\n \n+error: could not find defining uses\n+  --> $DIR/generic_nondefining_use.rs:7:17\n+   |\n+LL | type OneTy<T> = impl Debug;\n+   |                 ^^^^^^^^^^\n+\n error: non-defining opaque type use in defining scope\n-  --> $DIR/generic_nondefining_use.rs:18:27\n+  --> $DIR/generic_nondefining_use.rs:21:27\n    |\n LL | type OneLifetime<'a> = impl Debug;\n    |                  -- cannot use static lifetime; use a bound lifetime instead or remove the lifetime parameter from the opaque type\n ...\n LL | fn concrete_lifetime() -> OneLifetime<'static> {\n    |                           ^^^^^^^^^^^^^^^^^^^^\n \n+error: could not find defining uses\n+  --> $DIR/generic_nondefining_use.rs:9:24\n+   |\n+LL | type OneLifetime<'a> = impl Debug;\n+   |                        ^^^^^^^^^^\n+\n error: non-defining opaque type use in defining scope\n-  --> $DIR/generic_nondefining_use.rs:23:24\n+  --> $DIR/generic_nondefining_use.rs:26:24\n    |\n LL | fn concrete_const() -> OneConst<{ 123 }> {\n    |                        ^^^^^^^^^^^^^^^^^\n    |\n note: used non-generic constant `123_usize` for generic parameter\n-  --> $DIR/generic_nondefining_use.rs:9:21\n+  --> $DIR/generic_nondefining_use.rs:11:21\n    |\n LL | type OneConst<const X: usize> = impl Debug;\n    |                     ^\n \n-error: aborting due to 3 previous errors\n+error: could not find defining uses\n+  --> $DIR/generic_nondefining_use.rs:11:33\n+   |\n+LL | type OneConst<const X: usize> = impl Debug;\n+   |                                 ^^^^^^^^^^\n+\n+error: aborting due to 6 previous errors\n "}, {"sha": "4c8bf2cfca11e75e9faee943e65c572560546444", "filename": "src/test/ui/type-alias-impl-trait/incomplete-inference.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fincomplete-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fincomplete-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fincomplete-inference.rs?ref=2b862bed9889808b69629fd7246317189b9517a5", "patch": "@@ -8,7 +8,6 @@ fn bar() -> Foo {\n }\n \n fn baz() -> Foo {\n-    //~^ ERROR: concrete type differs from previous defining opaque type use\n     Some(())\n }\n "}, {"sha": "0cdd4cc8dc3bac32435aa3e1debe2d2d70ca2f35", "filename": "src/test/ui/type-alias-impl-trait/incomplete-inference.stderr", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fincomplete-inference.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fincomplete-inference.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fincomplete-inference.stderr?ref=2b862bed9889808b69629fd7246317189b9517a5", "patch": "@@ -4,18 +4,6 @@ error[E0282]: type annotations needed\n LL |     None\n    |     ^^^^ cannot infer type for type parameter `T` declared on the enum `Option`\n \n-error: concrete type differs from previous defining opaque type use\n-  --> $DIR/incomplete-inference.rs:10:1\n-   |\n-LL | fn baz() -> Foo {\n-   | ^^^^^^^^^^^^^^^ expected `[type error]`, got `Option<()>`\n-   |\n-note: previous use here\n-  --> $DIR/incomplete-inference.rs:5:1\n-   |\n-LL | fn bar() -> Foo {\n-   | ^^^^^^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0282`."}, {"sha": "9d2ba849c8667539ae6a40efbfb3505387ac0cbd", "filename": "src/test/ui/type-alias-impl-trait/issue-60371.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.rs?ref=2b862bed9889808b69629fd7246317189b9517a5", "patch": "@@ -11,6 +11,7 @@ impl Bug for &() {\n \n     const FUN: fn() -> Self::Item = || ();\n     //~^ ERROR the trait bound `(): Bug` is not satisfied\n+    //~| ERROR non-defining opaque type use in defining scope\n }\n \n fn main() {}"}, {"sha": "62ab7eb456010c8d166c7640c89ec19b532b55c3", "filename": "src/test/ui/type-alias-impl-trait/issue-60371.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.stderr?ref=2b862bed9889808b69629fd7246317189b9517a5", "patch": "@@ -16,7 +16,16 @@ LL |     const FUN: fn() -> Self::Item = || ();\n    = help: the following implementations were found:\n              <&() as Bug>\n \n-error: aborting due to 2 previous errors\n+error: non-defining opaque type use in defining scope\n+  --> $DIR/issue-60371.rs:12:37\n+   |\n+LL | impl Bug for &() {\n+   |              - cannot use static lifetime; use a bound lifetime instead or remove the lifetime parameter from the opaque type\n+...\n+LL |     const FUN: fn() -> Self::Item = || ();\n+   |                                     ^^^^^\n+\n+error: aborting due to 3 previous errors\n \n Some errors have detailed explanations: E0277, E0658.\n For more information about an error, try `rustc --explain E0277`."}, {"sha": "44dcec2c3da98f3ca47adaed7e089a8c88593ac1", "filename": "src/test/ui/type-alias-impl-trait/issue-60564.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.rs?ref=2b862bed9889808b69629fd7246317189b9517a5", "patch": "@@ -6,6 +6,7 @@ trait IterBits {\n }\n \n type IterBitsIter<T, E, I> = impl std::iter::Iterator<Item = I>;\n+//~^ ERROR could not find defining uses\n \n impl<T: Copy, E> IterBits for T\n where"}, {"sha": "6b73fbef011ec8483e3b748637f32f905223ddfa", "filename": "src/test/ui/type-alias-impl-trait/issue-60564.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.stderr?ref=2b862bed9889808b69629fd7246317189b9517a5", "patch": "@@ -1,5 +1,5 @@\n error: non-defining opaque type use in defining scope\n-  --> $DIR/issue-60564.rs:19:34\n+  --> $DIR/issue-60564.rs:20:34\n    |\n LL |     fn iter_bits(self, n: u8) -> Self::BitsIter {\n    |                                  ^^^^^^^^^^^^^^\n@@ -10,5 +10,11 @@ note: used non-generic type `u8` for generic parameter\n LL | type IterBitsIter<T, E, I> = impl std::iter::Iterator<Item = I>;\n    |                         ^\n \n-error: aborting due to previous error\n+error: could not find defining uses\n+  --> $DIR/issue-60564.rs:8:30\n+   |\n+LL | type IterBitsIter<T, E, I> = impl std::iter::Iterator<Item = I>;\n+   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "2e6354088ac5a6dfe2dc88bff55b4b7edd565682", "filename": "src/test/ui/type-alias-impl-trait/issue-68368-non-defining-use-2.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-68368-non-defining-use-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-68368-non-defining-use-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-68368-non-defining-use-2.rs?ref=2b862bed9889808b69629fd7246317189b9517a5", "patch": "@@ -0,0 +1,14 @@\n+// Regression test for issue #68368\n+// Ensures that we don't ICE when emitting an error\n+// for a non-defining use when lifetimes are involved\n+\n+#![feature(type_alias_impl_trait)]\n+trait Trait<T> {}\n+type Alias<'a, U> = impl Trait<U>;\n+//~^ ERROR could not find defining uses\n+fn f<'a>() -> Alias<'a, ()> {}\n+//~^ ERROR non-defining opaque type use in defining scope\n+\n+fn main() {}\n+\n+impl<X> Trait<X> for () {}"}, {"sha": "721f99a3f0d182f8dab52331ce8c85cb0871124a", "filename": "src/test/ui/type-alias-impl-trait/issue-68368-non-defining-use-2.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-68368-non-defining-use-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-68368-non-defining-use-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-68368-non-defining-use-2.stderr?ref=2b862bed9889808b69629fd7246317189b9517a5", "patch": "@@ -0,0 +1,20 @@\n+error: non-defining opaque type use in defining scope\n+  --> $DIR/issue-68368-non-defining-use-2.rs:9:15\n+   |\n+LL | fn f<'a>() -> Alias<'a, ()> {}\n+   |               ^^^^^^^^^^^^^\n+   |\n+note: used non-generic type `()` for generic parameter\n+  --> $DIR/issue-68368-non-defining-use-2.rs:7:16\n+   |\n+LL | type Alias<'a, U> = impl Trait<U>;\n+   |                ^\n+\n+error: could not find defining uses\n+  --> $DIR/issue-68368-non-defining-use-2.rs:7:21\n+   |\n+LL | type Alias<'a, U> = impl Trait<U>;\n+   |                     ^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "3addd8dcc4fb3486e5aa91f515a011eb9ab166b8", "filename": "src/test/ui/type-alias-impl-trait/issue-68368-non-defining-use.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-68368-non-defining-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-68368-non-defining-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-68368-non-defining-use.rs?ref=2b862bed9889808b69629fd7246317189b9517a5", "patch": "@@ -5,6 +5,7 @@\n #![feature(type_alias_impl_trait)]\n trait Trait<T> {}\n type Alias<'a, U> = impl Trait<U>;\n+//~^ ERROR could not find defining uses\n fn f<'a>() -> Alias<'a, ()> {}\n //~^ ERROR non-defining opaque type use in defining scope\n "}, {"sha": "f5b8fccf65d167779a5cc91b7185a6dd153bfec6", "filename": "src/test/ui/type-alias-impl-trait/issue-68368-non-defining-use.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-68368-non-defining-use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-68368-non-defining-use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-68368-non-defining-use.stderr?ref=2b862bed9889808b69629fd7246317189b9517a5", "patch": "@@ -1,5 +1,5 @@\n error: non-defining opaque type use in defining scope\n-  --> $DIR/issue-68368-non-defining-use.rs:8:15\n+  --> $DIR/issue-68368-non-defining-use.rs:9:15\n    |\n LL | fn f<'a>() -> Alias<'a, ()> {}\n    |               ^^^^^^^^^^^^^\n@@ -10,5 +10,11 @@ note: used non-generic type `()` for generic parameter\n LL | type Alias<'a, U> = impl Trait<U>;\n    |                ^\n \n-error: aborting due to previous error\n+error: could not find defining uses\n+  --> $DIR/issue-68368-non-defining-use.rs:7:21\n+   |\n+LL | type Alias<'a, U> = impl Trait<U>;\n+   |                     ^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "11a922443e64a33c2083c6786b8e05553f6a7566", "filename": "src/test/ui/type-alias-impl-trait/multiple-def-uses-in-one-fn3.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn3.rs?ref=2b862bed9889808b69629fd7246317189b9517a5", "patch": "@@ -11,7 +11,6 @@ fn f<A: ToString + Clone, B: ToString + Clone>(a: A, b: B) -> (X<A, B>, X<B, A>)\n }\n \n fn g<A: ToString + Clone, B: ToString + Clone>(a: A, b: B) -> (X<A, B>, X<A, B>) {\n-    //~^ ERROR concrete type differs from previous defining opaque type\n     (a, b)\n     //~^ ERROR mismatched types\n }"}, {"sha": "bbe709dccab4eb6e9404d4b5cba860ad4a7a2592", "filename": "src/test/ui/type-alias-impl-trait/multiple-def-uses-in-one-fn3.stderr", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmultiple-def-uses-in-one-fn3.stderr?ref=2b862bed9889808b69629fd7246317189b9517a5", "patch": "@@ -1,11 +1,10 @@\n error[E0308]: mismatched types\n-  --> $DIR/multiple-def-uses-in-one-fn3.rs:15:9\n+  --> $DIR/multiple-def-uses-in-one-fn3.rs:14:9\n    |\n LL | fn g<A: ToString + Clone, B: ToString + Clone>(a: A, b: B) -> (X<A, B>, X<A, B>) {\n    |      -                    - found type parameter\n    |      |\n    |      expected type parameter\n-LL |\n LL |     (a, b)\n    |         ^ expected type parameter `A`, found type parameter `B`\n    |\n@@ -14,18 +13,6 @@ LL |     (a, b)\n    = note: a type parameter was expected, but a different one was found; you might be missing a type parameter or trait bound\n    = note: for more information, visit https://doc.rust-lang.org/book/ch10-02-traits.html#traits-as-parameters\n \n-error: concrete type differs from previous defining opaque type use\n-  --> $DIR/multiple-def-uses-in-one-fn3.rs:13:1\n-   |\n-LL | fn g<A: ToString + Clone, B: ToString + Clone>(a: A, b: B) -> (X<A, B>, X<A, B>) {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `A`, got `[type error]`\n-   |\n-note: previous use here\n-  --> $DIR/multiple-def-uses-in-one-fn3.rs:9:1\n-   |\n-LL | fn f<A: ToString + Clone, B: ToString + Clone>(a: A, b: B) -> (X<A, B>, X<B, A>) {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0308`."}, {"sha": "107cd394579355d2d05b010c4615a592f13b1f35", "filename": "src/test/ui/type-alias-impl-trait/not_a_defining_use.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnot_a_defining_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnot_a_defining_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnot_a_defining_use.rs?ref=2b862bed9889808b69629fd7246317189b9517a5", "patch": "@@ -5,6 +5,7 @@ use std::fmt::Debug;\n fn main() {}\n \n type Two<T, U> = impl Debug;\n+//~^ ERROR `T` doesn't implement `Debug`\n \n fn two<T: Debug>(t: T) -> Two<T, u32> {\n     //~^ ERROR non-defining opaque type use in defining scope\n@@ -26,6 +27,7 @@ impl Bar for u32 {\n }\n \n fn four<T: Debug, U: Bar>(t: T) -> Two<T, U> {\n+    //~^ ERROR concrete type differs from previous\n     (t, <U as Bar>::FOO)\n }\n "}, {"sha": "08e49845521c6ab18e3d7dd92a2fe77f8519df4e", "filename": "src/test/ui/type-alias-impl-trait/not_a_defining_use.stderr", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnot_a_defining_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b862bed9889808b69629fd7246317189b9517a5/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnot_a_defining_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnot_a_defining_use.stderr?ref=2b862bed9889808b69629fd7246317189b9517a5", "patch": "@@ -1,5 +1,5 @@\n error: non-defining opaque type use in defining scope\n-  --> $DIR/not_a_defining_use.rs:9:27\n+  --> $DIR/not_a_defining_use.rs:10:27\n    |\n LL | fn two<T: Debug>(t: T) -> Two<T, u32> {\n    |                           ^^^^^^^^^^^\n@@ -10,5 +10,30 @@ note: used non-generic type `u32` for generic parameter\n LL | type Two<T, U> = impl Debug;\n    |             ^\n \n-error: aborting due to previous error\n+error: concrete type differs from previous defining opaque type use\n+  --> $DIR/not_a_defining_use.rs:29:1\n+   |\n+LL | fn four<T: Debug, U: Bar>(t: T) -> Two<T, U> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `(T, i8)`, got `(T, <U as Bar>::Blub)`\n+   |\n+note: previous use here\n+  --> $DIR/not_a_defining_use.rs:15:1\n+   |\n+LL | fn three<T: Debug, U>(t: T) -> Two<T, U> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0277]: `T` doesn't implement `Debug`\n+  --> $DIR/not_a_defining_use.rs:7:18\n+   |\n+LL | type Two<T, U> = impl Debug;\n+   |                  ^^^^^^^^^^ `T` cannot be formatted using `{:?}` because it doesn't implement `Debug`\n+   |\n+   = note: required because of the requirements on the impl of `Debug` for `(T, i8)`\n+help: consider restricting type parameter `T`\n+   |\n+LL | type Two<T: std::fmt::Debug, U> = impl Debug;\n+   |           +++++++++++++++++\n+\n+error: aborting due to 3 previous errors\n \n+For more information about this error, try `rustc --explain E0277`."}]}