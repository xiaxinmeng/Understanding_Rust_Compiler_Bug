{"sha": "e798cb0e52e505ed759f8af01e90a758858b115d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3OThjYjBlNTJlNTA1ZWQ3NTlmOGFmMDFlOTBhNzU4ODU4YjExNWQ=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-12-10T15:11:02Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-12-10T15:46:32Z"}, "message": "centralize `does_not_live_long_enough` error reporting", "tree": {"sha": "2941b0869d9457934a75d897d6cbfa67a804494d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2941b0869d9457934a75d897d6cbfa67a804494d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e798cb0e52e505ed759f8af01e90a758858b115d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e798cb0e52e505ed759f8af01e90a758858b115d", "html_url": "https://github.com/rust-lang/rust/commit/e798cb0e52e505ed759f8af01e90a758858b115d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e798cb0e52e505ed759f8af01e90a758858b115d/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed636c5c5a9104f1ac55a5610d162ea224965025", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed636c5c5a9104f1ac55a5610d162ea224965025", "html_url": "https://github.com/rust-lang/rust/commit/ed636c5c5a9104f1ac55a5610d162ea224965025"}], "stats": {"total": 172, "additions": 89, "deletions": 83}, "files": [{"sha": "e4d2d7228c25620318d3ab8695c539de1a80cefe", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 32, "deletions": 7, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e798cb0e52e505ed759f8af01e90a758858b115d/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e798cb0e52e505ed759f8af01e90a758858b115d/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=e798cb0e52e505ed759f8af01e90a758858b115d", "patch": "@@ -16,7 +16,7 @@ use rustc_data_structures::indexed_vec::Idx;\n \n use super::{MirBorrowckCtxt, Context};\n use super::{InitializationRequiringAction, PrefixSet};\n-use dataflow::{BorrowData, FlowAtLocation, MovingOutStatements};\n+use dataflow::{BorrowData, Borrows, FlowAtLocation, MovingOutStatements};\n use dataflow::move_paths::MovePathIndex;\n use util::borrowck_errors::{BorrowckErrors, Origin};\n \n@@ -319,18 +319,43 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     pub(super) fn report_borrowed_value_does_not_live_long_enough(\n         &mut self,\n         _: Context,\n-        (place, span): (&Place<'tcx>, Span),\n-        end_span: Option<Span>,\n+        borrow: &BorrowData<'tcx>,\n+        drop_span: Span,\n+        borrows: &Borrows<'cx, 'gcx, 'tcx>\n     ) {\n-        let root_place = self.prefixes(place, PrefixSet::All).last().unwrap();\n+        let end_span = borrows.opt_region_end_span(&borrow.region);\n+        let root_place = self.prefixes(&borrow.place, PrefixSet::All).last().unwrap();\n+\n+        match root_place {\n+            &Place::Local(local) => {\n+                if let Some(_) = self.storage_dead_or_drop_error_reported_l.replace(local) {\n+                    debug!(\"report_does_not_live_long_enough({:?}): <suppressed>\",\n+                           (borrow, drop_span));\n+                    return\n+                }\n+            }\n+            &Place::Static(ref statik) => {\n+                if let Some(_) = self.storage_dead_or_drop_error_reported_s\n+                    .replace(statik.def_id)\n+                {\n+                    debug!(\"report_does_not_live_long_enough({:?}): <suppressed>\",\n+                           (borrow, drop_span));\n+                    return\n+                }\n+            },\n+            &Place::Projection(_) =>\n+                unreachable!(\"root_place is an unreachable???\")\n+        };\n+\n         let proper_span = match *root_place {\n             Place::Local(local) => self.mir.local_decls[local].source_info.span,\n-            _ => span,\n+            _ => drop_span,\n         };\n+\n         let mut err = self.tcx\n-            .path_does_not_live_long_enough(span, \"borrowed value\", Origin::Mir);\n+            .path_does_not_live_long_enough(drop_span, \"borrowed value\", Origin::Mir);\n         err.span_label(proper_span, \"temporary value created here\");\n-        err.span_label(span, \"temporary value dropped here while still borrowed\");\n+        err.span_label(drop_span, \"temporary value dropped here while still borrowed\");\n         err.note(\"consider using a `let` binding to increase its lifetime\");\n \n         if let Some(end) = end_span {"}, {"sha": "358f96abe72e886f9904fe261990d75efea6e0ba", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 49, "deletions": 72, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/e798cb0e52e505ed759f8af01e90a758858b115d/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e798cb0e52e505ed759f8af01e90a758858b115d/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=e798cb0e52e505ed759f8af01e90a758858b115d", "patch": "@@ -233,7 +233,8 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n             hir::BodyOwnerKind::Static(_) => false,\n             hir::BodyOwnerKind::Fn => true,\n         },\n-        storage_dead_or_drop_error_reported: FxHashSet(),\n+        storage_dead_or_drop_error_reported_l: FxHashSet(),\n+        storage_dead_or_drop_error_reported_s: FxHashSet(),\n     };\n \n     mbcx.analyze_results(&mut state); // entry point for DataflowResultsConsumer\n@@ -258,7 +259,9 @@ pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     /// This field keeps track of when storage dead or drop errors are reported\n     /// in order to stop duplicate error reporting and identify the conditions required\n     /// for a \"temporary value dropped here while still borrowed\" error. See #45360.\n-    storage_dead_or_drop_error_reported: FxHashSet<Local>,\n+    storage_dead_or_drop_error_reported_l: FxHashSet<Local>,\n+    /// Same as the above, but for statics (thread-locals)\n+    storage_dead_or_drop_error_reported_s: FxHashSet<DefId>,\n }\n \n // Check that:\n@@ -502,19 +505,9 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 flow_state.borrows.with_elems_outgoing(|borrows| {\n                     for i in borrows {\n                         let borrow = &data[i];\n+                        let context = ContextKind::StorageDead.new(loc);\n \n-                        if self.place_is_invalidated_at_exit(&borrow.place) {\n-                            debug!(\"borrow conflicts at exit {:?}\", borrow);\n-                            // FIXME: should be talking about the region lifetime instead\n-                            // of just a span here.\n-                            let end_span = domain.opt_region_end_span(&borrow.region);\n-\n-                            self.report_borrowed_value_does_not_live_long_enough(\n-                                ContextKind::StorageDead.new(loc),\n-                            (&borrow.place, end_span.unwrap_or(span)),\n-                                end_span,\n-                            )\n-                        }\n+                        self.check_for_invalidation_at_exit(context, borrow, span, flow_state);\n                     }\n                 });\n             }\n@@ -663,34 +656,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     ) -> AccessErrorsReported {\n         let (sd, rw) = kind;\n \n-        let storage_dead_or_drop_local = match (place_span.0, rw) {\n-            (&Place::Local(local), Write(WriteKind::StorageDeadOrDrop)) => Some(local),\n-            _ => None,\n-        };\n-\n-        // Check if error has already been reported to stop duplicate reporting.\n-        if let Some(local) = storage_dead_or_drop_local {\n-            if self.storage_dead_or_drop_error_reported.contains(&local) {\n-                return AccessErrorsReported {\n-                    mutability_error: false,\n-                    conflict_error: true\n-                };\n-            }\n-        }\n-\n         let mutability_error =\n             self.check_access_permissions(place_span, rw, is_local_mutation_allowed);\n         let conflict_error =\n             self.check_access_for_conflict(context, place_span, sd, rw, flow_state);\n \n-        // A conflict with a storagedead/drop is a \"borrow does not live long enough\"\n-        // error. Avoid reporting such an error multiple times for the same local.\n-        if conflict_error {\n-            if let Some(local) = storage_dead_or_drop_local {\n-                self.storage_dead_or_drop_error_reported.insert(local);\n-            }\n-        }\n-\n         AccessErrorsReported { mutability_error, conflict_error }\n     }\n \n@@ -749,16 +719,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             )\n                         }\n                         WriteKind::StorageDeadOrDrop => {\n-                            let end_span = flow_state\n-                                .borrows\n-                                .operator()\n-                                .opt_region_end_span(&borrow.region);\n                             error_reported = true;\n                             this.report_borrowed_value_does_not_live_long_enough(\n-                                context,\n-                                place_span,\n-                                end_span,\n-                            )\n+                                context, borrow, place_span.1, flow_state.borrows.operator());\n                         }\n                         WriteKind::Mutate => {\n                             error_reported = true;\n@@ -947,16 +910,22 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     /// Returns whether a borrow of this place is invalidated when the function\n     /// exits\n-    fn place_is_invalidated_at_exit(&mut self, place: &Place<'tcx>) -> bool {\n-        debug!(\"place_is_invalidated_at_exit({:?})\", place);\n+    fn check_for_invalidation_at_exit(&mut self,\n+                                      context: Context,\n+                                      borrow: &BorrowData<'tcx>,\n+                                      span: Span,\n+                                      flow_state: &Flows<'cx, 'gcx, 'tcx>)\n+    {\n+        debug!(\"check_for_invalidation_at_exit({:?})\", borrow);\n+        let place = &borrow.place;\n         let root_place = self.prefixes(place, PrefixSet::All).last().unwrap();\n \n         // FIXME(nll-rfc#40): do more precise destructor tracking here. For now\n         // we just know that all locals are dropped at function exit (otherwise\n         // we'll have a memory leak) and assume that all statics have a destructor.\n         //\n         // FIXME: allow thread-locals to borrow other thread locals?\n-        let (might_be_alive, will_be_dropped, local) = match root_place {\n+        let (might_be_alive, will_be_dropped) = match root_place {\n             Place::Static(statik) => {\n                 // Thread-locals might be dropped after the function exits, but\n                 // \"true\" statics will never be.\n@@ -965,12 +934,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     .iter()\n                     .any(|attr| attr.check_name(\"thread_local\"));\n \n-                (true, is_thread_local, None)\n+                (true, is_thread_local)\n             }\n-            Place::Local(local) => {\n+            Place::Local(_) => {\n                 // Locals are always dropped at function exit, and if they\n                 // have a destructor it would've been called already.\n-                (false, self.locals_are_invalidated_at_exit, Some(*local))\n+                (false, self.locals_are_invalidated_at_exit)\n             }\n             Place::Projection(..) => {\n                 bug!(\"root of {:?} is a projection ({:?})?\", place, root_place)\n@@ -982,30 +951,28 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 \"place_is_invalidated_at_exit({:?}) - won't be dropped\",\n                 place\n             );\n-            return false;\n+            return;\n         }\n \n         // FIXME: replace this with a proper borrow_conflicts_with_place when\n         // that is merged.\n-        let prefix_set = if might_be_alive {\n-            PrefixSet::Supporting\n+        let sd = if might_be_alive {\n+            Deep\n         } else {\n-            PrefixSet::Shallow\n+            Shallow(None)\n         };\n \n-        let result =\n-            self.prefixes(place, prefix_set).any(|prefix| prefix == root_place);\n-\n-        if result {\n-            if let Some(local) = local {\n-                if let Some(_) = self.storage_dead_or_drop_error_reported.replace(local) {\n-                    debug!(\"place_is_invalidated_at_exit({:?}) - suppressed\", place);\n-                    return false;\n-                }\n-            }\n+        if self.places_conflict(place, root_place, sd) {\n+            debug!(\"check_for_invalidation_at_exit({:?}): INVALID\", place);\n+            // FIXME: should be talking about the region lifetime instead\n+            // of just a span here.\n+            self.report_borrowed_value_does_not_live_long_enough(\n+                context,\n+                borrow,\n+                span.end_point(),\n+                flow_state.borrows.operator()\n+            )\n         }\n-\n-        result\n     }\n }\n \n@@ -1358,7 +1325,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     // Mutably borrowed data is mutable, but only if we have a\n                                     // unique path to the `&mut`\n                                     hir::MutMutable => {\n-                                        let mode = match self.is_upvar_field_projection(&proj.base) {\n+                                        let mode = match\n+                                            self.is_upvar_field_projection(&proj.base)\n+                                        {\n                                             Some(field) if {\n                                                 self.mir.upvar_decls[field.index()].by_ref\n                                             } => is_local_mutation_allowed,\n@@ -1485,10 +1454,18 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     Overlap::Disjoint\n                 }\n             }\n-            (Place::Static(..), Place::Static(..)) => {\n-                // Borrows of statics do not have to be tracked here.\n-                debug!(\"place_element_conflict: IGNORED-STATIC\");\n-                Overlap::Disjoint\n+            (Place::Static(static1), Place::Static(static2)) => {\n+                if static1.def_id != static2.def_id {\n+                    debug!(\"place_element_conflict: DISJOINT-STATIC\");\n+                    Overlap::Disjoint\n+                } else if self.tcx.is_static_mut(static1.def_id) {\n+                    // We ignore mutable statics - they can only be unsafe code.\n+                    debug!(\"place_element_conflict: IGNORE-STATIC-MUT\");\n+                    Overlap::Disjoint\n+                } else {\n+                    debug!(\"place_element_conflict: DISJOINT-OR-EQ-STATIC\");\n+                    Overlap::EqualOrDisjoint\n+                }\n             }\n             (Place::Local(_), Place::Static(_)) |\n             (Place::Static(_), Place::Local(_)) => {"}, {"sha": "3e14525250de53945d919e95d115ebcbcf31a9d7", "filename": "src/test/compile-fail/issue-17954.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e798cb0e52e505ed759f8af01e90a758858b115d/src%2Ftest%2Fcompile-fail%2Fissue-17954.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e798cb0e52e505ed759f8af01e90a758858b115d/src%2Ftest%2Fcompile-fail%2Fissue-17954.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17954.rs?ref=e798cb0e52e505ed759f8af01e90a758858b115d", "patch": "@@ -8,18 +8,22 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions: ast mir\n+//[mir]compile-flags: -Z borrowck=mir\n+\n #![feature(thread_local)]\n \n #[thread_local]\n static FOO: u8 = 3;\n \n fn main() {\n     let a = &FOO;\n-    //~^ ERROR borrowed value does not live long enough\n-    //~| does not live long enough\n-    //~| NOTE borrowed value must be valid for the static lifetime\n+    //[ast]~^ ERROR borrowed value does not live long enough\n+    //[ast]~| does not live long enough\n+    //[ast]~| NOTE borrowed value must be valid for the static lifetime\n \n     std::thread::spawn(move || {\n         println!(\"{}\", a);\n     });\n-} //~ temporary value only lives until here\n+} //[ast]~ temporary value only lives until here\n+  //[mir]~^ ERROR borrowed value does not live long enough"}]}