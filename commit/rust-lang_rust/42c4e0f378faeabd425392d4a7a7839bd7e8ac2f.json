{"sha": "42c4e0f378faeabd425392d4a7a7839bd7e8ac2f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyYzRlMGYzNzhmYWVhYmQ0MjUzOTJkNGE3YTc4MzliZDdlOGFjMmY=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-04-25T18:59:34Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-04-25T18:59:34Z"}, "message": "Merge #1209\n\n1209: Bugs fixes And Improvements of MBE r=matklad a=edwin0cheng\n\nThis PR fixed / improve followings things:\r\n\r\n* Add `token` `$repeat` separator support: Previously $repeat only support single punct separator. \r\n* Fixed a bug which expand infinite pattern, see `test_match_group_in_group` \r\n* Correctly handle +,*,? case of $repeat patterns\r\n* Increase the limit of $repeat patterns (128 => 65536), personally i think we could remove this limit as we seem to fix all major loop bugs\r\n* **Re-enable tt matcher**\r\n* Better meta item parsing.\r\n* Add related tests and add some real world test cases.\r\n* Add more debug information.\r\n\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>", "tree": {"sha": "f48081403383b7a00a3c297b2ff24a7c11ddd07e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f48081403383b7a00a3c297b2ff24a7c11ddd07e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42c4e0f378faeabd425392d4a7a7839bd7e8ac2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42c4e0f378faeabd425392d4a7a7839bd7e8ac2f", "html_url": "https://github.com/rust-lang/rust/commit/42c4e0f378faeabd425392d4a7a7839bd7e8ac2f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42c4e0f378faeabd425392d4a7a7839bd7e8ac2f/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "5bbd9f43cc217a44445fde91b4b53ca85d78cd92", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bbd9f43cc217a44445fde91b4b53ca85d78cd92", "html_url": "https://github.com/rust-lang/rust/commit/5bbd9f43cc217a44445fde91b4b53ca85d78cd92"}, {"sha": "1908819bf6432016527f4bd3b0f22500b85cab5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/1908819bf6432016527f4bd3b0f22500b85cab5f", "html_url": "https://github.com/rust-lang/rust/commit/1908819bf6432016527f4bd3b0f22500b85cab5f"}], "stats": {"total": 630, "additions": 543, "deletions": 87}, "files": [{"sha": "de6e9ec9ab50288b0a2b9350f447528cad7b98b5", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e0f378faeabd425392d4a7a7839bd7e8ac2f/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e0f378faeabd425392d4a7a7839bd7e8ac2f/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=42c4e0f378faeabd425392d4a7a7839bd7e8ac2f", "patch": "@@ -1059,10 +1059,12 @@ name = \"ra_mbe\"\n version = \"0.1.0\"\n dependencies = [\n  \"itertools 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_parser 0.1.0\",\n  \"ra_syntax 0.1.0\",\n  \"ra_tt 0.1.0\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"smallvec 0.6.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]"}, {"sha": "b0e9b1f9af789b8e8d8931dd829e611da3436263", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e0f378faeabd425392d4a7a7839bd7e8ac2f/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e0f378faeabd425392d4a7a7839bd7e8ac2f/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=42c4e0f378faeabd425392d4a7a7839bd7e8ac2f", "patch": "@@ -128,8 +128,14 @@ pub struct MacroDefId(pub(crate) AstId<ast::MacroCall>);\n pub(crate) fn macro_def_query(db: &impl DefDatabase, id: MacroDefId) -> Option<Arc<MacroRules>> {\n     let macro_call = id.0.to_node(db);\n     let arg = macro_call.token_tree()?;\n-    let (tt, _) = mbe::ast_to_token_tree(arg)?;\n-    let rules = MacroRules::parse(&tt).ok()?;\n+    let (tt, _) = mbe::ast_to_token_tree(arg).or_else(|| {\n+        log::warn!(\"fail on macro_def to token tree: {:#?}\", arg);\n+        None\n+    })?;\n+    let rules = MacroRules::parse(&tt).ok().or_else(|| {\n+        log::warn!(\"fail on macro_def parse: {:#?}\", tt);\n+        None\n+    })?;\n     Some(Arc::new(rules))\n }\n "}, {"sha": "68f5592958f5e1339c1d082f567f255b9d738aea", "filename": "crates/ra_mbe/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e0f378faeabd425392d4a7a7839bd7e8ac2f/crates%2Fra_mbe%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e0f378faeabd425392d4a7a7839bd7e8ac2f/crates%2Fra_mbe%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2FCargo.toml?ref=42c4e0f378faeabd425392d4a7a7839bd7e8ac2f", "patch": "@@ -10,3 +10,5 @@ ra_parser = { path = \"../ra_parser\" }\n tt = { path = \"../ra_tt\", package = \"ra_tt\" }\n itertools = \"0.8.0\"\n rustc-hash = \"1.0.0\"\n+smallvec = \"0.6.9\"\n+log = \"0.4.5\""}, {"sha": "7817232d629ddb3b7faa92e1e20258d7c33aba81", "filename": "crates/ra_mbe/src/lib.rs", "status": "modified", "additions": 209, "deletions": 7, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e0f378faeabd425392d4a7a7839bd7e8ac2f/crates%2Fra_mbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e0f378faeabd425392d4a7a7839bd7e8ac2f/crates%2Fra_mbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Flib.rs?ref=42c4e0f378faeabd425392d4a7a7839bd7e8ac2f", "patch": "@@ -24,6 +24,7 @@ mod subtree_source;\n mod subtree_parser;\n \n use ra_syntax::SmolStr;\n+use smallvec::SmallVec;\n \n pub use tt::{Delimiter, Punct};\n \n@@ -98,11 +99,18 @@ pub(crate) struct Subtree {\n     pub(crate) token_trees: Vec<TokenTree>,\n }\n \n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub(crate) enum Separator {\n+    Literal(tt::Literal),\n+    Ident(tt::Ident),\n+    Puncts(SmallVec<[tt::Punct; 3]>),\n+}\n+\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) struct Repeat {\n     pub(crate) subtree: Subtree,\n     pub(crate) kind: RepeatKind,\n-    pub(crate) separator: Option<char>,\n+    pub(crate) separator: Option<Separator>,\n }\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n@@ -175,8 +183,8 @@ impl_froms!(TokenTree: Leaf, Subtree);\n         let expansion = rules.expand(&invocation_tt).unwrap();\n         assert_eq!(\n         expansion.to_string(),\n-        \"impl From < Leaf > for TokenTree {fn from (it : Leaf) -> TokenTree {TokenTree :: Leaf (it)}} \\\n-         impl From < Subtree > for TokenTree {fn from (it : Subtree) -> TokenTree {TokenTree :: Subtree (it)}}\"\n+        \"impl From <Leaf > for TokenTree {fn from (it : Leaf) -> TokenTree {TokenTree ::Leaf (it)}} \\\n+         impl From <Subtree > for TokenTree {fn from (it : Subtree) -> TokenTree {TokenTree ::Subtree (it)}}\"\n     )\n     }\n \n@@ -384,7 +392,7 @@ impl_froms!(TokenTree: Leaf, Subtree);\n \"#,\n         );\n \n-        assert_expansion(&rules, \"foo! { foo, bar }\", \"fn baz {foo () ; bar () ;}\");\n+        assert_expansion(&rules, \"foo! { foo, bar }\", \"fn baz {foo () ;bar ()}\");\n     }\n \n     #[test]\n@@ -416,6 +424,42 @@ impl_froms!(TokenTree: Leaf, Subtree);\n         assert_expansion(&rules, \"foo! {fn baz {a b} }\", \"fn baz () {a () ; b () ;}\");\n     }\n \n+    #[test]\n+    fn test_match_group_with_multichar_sep() {\n+        let rules = create_rules(\n+            r#\"\n+        macro_rules! foo {            \n+            (fn $name:ident {$($i:literal)*} ) => ( fn $name() -> bool { $($i)&&*} );            \n+        }\"#,\n+        );\n+\n+        assert_expansion(&rules, \"foo! (fn baz {true true} )\", \"fn baz () -> bool {true &&true}\");\n+    }\n+\n+    #[test]\n+    fn test_match_group_zero_match() {\n+        let rules = create_rules(\n+            r#\"\n+        macro_rules! foo {            \n+            ( $($i:ident)* ) => ();            \n+        }\"#,\n+        );\n+\n+        assert_expansion(&rules, \"foo! ()\", \"\");\n+    }\n+\n+    #[test]\n+    fn test_match_group_in_group() {\n+        let rules = create_rules(\n+            r#\"\n+        macro_rules! foo {            \n+            { $( ( $($i:ident)* ) )* } => ( $( ( $($i)* ) )* );\n+        }\"#,\n+        );\n+\n+        assert_expansion(&rules, \"foo! ( (a b) )\", \"(a b)\");\n+    }\n+\n     #[test]\n     fn test_expand_to_item_list() {\n         let rules = create_rules(\n@@ -597,7 +641,7 @@ MACRO_ITEMS@[0; 40)\n         assert_expansion(\n             &rules,\n             \"foo! { bar::<u8>::baz::<u8> }\",\n-            \"fn foo () {let a = bar :: < u8 > :: baz :: < u8 > ;}\",\n+            \"fn foo () {let a = bar ::< u8 >:: baz ::< u8 > ;}\",\n         );\n     }\n \n@@ -891,7 +935,7 @@ MACRO_ITEMS@[0; 40)\n         }\n \"#,\n         );\n-        assert_expansion(&rules, r#\"foo!{'a}\"#, r#\"struct Ref < 'a > {s : & 'a str}\"#);\n+        assert_expansion(&rules, r#\"foo!{'a}\"#, r#\"struct Ref <'a > {s : &'a str}\"#);\n     }\n \n     #[test]\n@@ -1063,7 +1107,165 @@ macro_rules! int_base {\n         );\n \n         assert_expansion(&rules, r#\" int_base!{Binary for isize as usize -> Binary}\"#, \n-        \"# [stable (feature = \\\"rust1\\\" , since = \\\"1.0.0\\\")] impl fmt :: Binary for isize {fn fmt (& self , f : & mut fmt :: Formatter < \\'_ >) -> fmt :: Result {Binary . fmt_int (* self as usize , f)}}\"\n+        \"# [stable (feature = \\\"rust1\\\" , since = \\\"1.0.0\\\")] impl fmt ::Binary for isize {fn fmt (& self , f : & mut fmt :: Formatter < \\'_ >) -> fmt :: Result {Binary . fmt_int (* self as usize , f)}}\"\n+        );\n+    }\n+\n+    #[test]\n+    fn test_generate_pattern_iterators() {\n+        // from https://github.com/rust-lang/rust/blob/316a391dcb7d66dc25f1f9a4ec9d368ef7615005/src/libcore/str/mod.rs\n+        let rules = create_rules(\n+            r#\"\n+macro_rules! generate_pattern_iterators {        \n+        { double ended; with $(#[$common_stability_attribute:meta])*,\n+                           $forward_iterator:ident,\n+                           $reverse_iterator:ident, $iterty:ty\n+        } => {\n+            fn foo(){}\n+        }\n+}\n+\"#,\n+        );\n+\n+        assert_expansion(&rules, r#\"generate_pattern_iterators ! ( double ended ; with # [ stable ( feature = \"rust1\" , since = \"1.0.0\" ) ] , Split , RSplit , & 'a str )\"#, \n+        \"fn foo () {}\");\n+    }\n+\n+    #[test]\n+    fn test_impl_fn_for_zst() {\n+        // from https://github.com/rust-lang/rust/blob/5d20ff4d2718c820632b38c1e49d4de648a9810b/src/libcore/internal_macros.rs\n+        let rules = create_rules(\n+            r#\"\n+macro_rules! impl_fn_for_zst  {        \n+        {  $( $( #[$attr: meta] )*\n+        struct $Name: ident impl$( <$( $lifetime : lifetime ),+> )? Fn =\n+            |$( $arg: ident: $ArgTy: ty ),*| -> $ReturnTy: ty\n+$body: block; )+\n+        } => {\n+           $(\n+            $( #[$attr] )*\n+            struct $Name;\n+\n+            impl $( <$( $lifetime ),+> )? Fn<($( $ArgTy, )*)> for $Name {\n+                #[inline]\n+                extern \"rust-call\" fn call(&self, ($( $arg, )*): ($( $ArgTy, )*)) -> $ReturnTy {\n+                    $body\n+                }\n+            }\n+\n+            impl $( <$( $lifetime ),+> )? FnMut<($( $ArgTy, )*)> for $Name {\n+                #[inline]\n+                extern \"rust-call\" fn call_mut(\n+                    &mut self,\n+                    ($( $arg, )*): ($( $ArgTy, )*)\n+                ) -> $ReturnTy {\n+                    Fn::call(&*self, ($( $arg, )*))\n+                }\n+            }\n+\n+            impl $( <$( $lifetime ),+> )? FnOnce<($( $ArgTy, )*)> for $Name {\n+                type Output = $ReturnTy;\n+\n+                #[inline]\n+                extern \"rust-call\" fn call_once(self, ($( $arg, )*): ($( $ArgTy, )*)) -> $ReturnTy {\n+                    Fn::call(&self, ($( $arg, )*))\n+                }\n+            }\n+        )+\n+}\n+        }\n+}\n+\"#,\n+        );\n+\n+        assert_expansion(&rules, r#\"\n+impl_fn_for_zst !   { \n+     # [ derive ( Clone ) ] \n+     struct   CharEscapeDebugContinue   impl   Fn   =   | c :   char |   ->   char :: EscapeDebug   { \n+         c . escape_debug_ext ( false ) \n+     } ; \n+\n+     # [ derive ( Clone ) ] \n+     struct   CharEscapeUnicode   impl   Fn   =   | c :   char |   ->   char :: EscapeUnicode   { \n+         c . escape_unicode ( ) \n+     } ; \n+     # [ derive ( Clone ) ] \n+     struct   CharEscapeDefault   impl   Fn   =   | c :   char |   ->   char :: EscapeDefault   { \n+         c . escape_default ( ) \n+     } ; \n+ }\n+\"#, \n+        \"# [derive (Clone)] struct CharEscapeDebugContinue ; impl  Fn < (char ,) > for CharEscapeDebugContinue {# [inline] extern \\\"rust-call\\\" fn call (& self , (c ,) : (char ,)) -> char :: EscapeDebug {{c . escape_debug_ext (false)}}} impl  FnMut < (char ,) > for CharEscapeDebugContinue {# [inline] extern \\\"rust-call\\\" fn call_mut (& mut self , (c ,) : (char ,)) -> char :: EscapeDebug {Fn :: call (&* self , (c ,))}} impl  FnOnce < (char ,) > for CharEscapeDebugContinue {type Output = char :: EscapeDebug ; # [inline] extern \\\"rust-call\\\" fn call_once (self , (c ,) : (char ,)) -> char :: EscapeDebug {Fn :: call (& self , (c ,))}} # [derive (Clone)] struct CharEscapeUnicode ; impl  Fn < (char ,) > for CharEscapeUnicode {# [inline] extern \\\"rust-call\\\" fn call (& self , (c ,) : (char ,)) -> char :: EscapeUnicode {{c . escape_unicode ()}}} impl  FnMut < (char ,) > for CharEscapeUnicode {# [inline] extern \\\"rust-call\\\" fn call_mut (& mut self , (c ,) : (char ,)) -> char :: EscapeUnicode {Fn :: call (&* self , (c ,))}} impl  FnOnce < (char ,) > for CharEscapeUnicode {type Output = char :: EscapeUnicode ; # [inline] extern \\\"rust-call\\\" fn call_once (self , (c ,) : (char ,)) -> char :: EscapeUnicode {Fn :: call (& self , (c ,))}} # [derive (Clone)] struct CharEscapeDefault ; impl  Fn < (char ,) > for CharEscapeDefault {# [inline] extern \\\"rust-call\\\" fn call (& self , (c ,) : (char ,)) -> char :: EscapeDefault {{c . escape_default ()}}} impl  FnMut < (char ,) > for CharEscapeDefault {# [inline] extern \\\"rust-call\\\" fn call_mut (& mut self , (c ,) : (char ,)) -> char :: EscapeDefault {Fn :: call (&* self , (c ,))}} impl  FnOnce < (char ,) > for CharEscapeDefault {type Output = char :: EscapeDefault ; # [inline] extern \\\"rust-call\\\" fn call_once (self , (c ,) : (char ,)) -> char :: EscapeDefault {Fn :: call (& self , (c ,))}}\");\n+    }\n+\n+    #[test]\n+    fn test_impl_nonzero_fmt() {\n+        // from https://github.com/rust-lang/rust/blob/316a391dcb7d66dc25f1f9a4ec9d368ef7615005/src/libcore/num/mod.rs#L12\n+        let rules = create_rules(\n+            r#\"\n+        macro_rules! impl_nonzero_fmt {\n+            ( #[$stability: meta] ( $( $Trait: ident ),+ ) for $Ty: ident ) => {\n+                fn foo() {}\n+            }\n+        }\n+\"#,\n         );\n+\n+        assert_expansion(&rules, r#\"impl_nonzero_fmt ! { # [ stable ( feature = \"nonzero\" , since = \"1.28.0\" ) ] ( Debug , Display , Binary , Octal , LowerHex , UpperHex ) for NonZeroU8 }\"#, \n+        \"fn foo () {}\");\n+    }\n+\n+    #[test]\n+    fn test_cfg_if_items() {\n+        // from https://github.com/rust-lang/rust/blob/33fe1131cadba69d317156847be9a402b89f11bb/src/libstd/macros.rs#L986\n+        let rules = create_rules(\n+            r#\"\n+        macro_rules! __cfg_if_items {\n+            (($($not:meta,)*) ; ) => {};\n+            (($($not:meta,)*) ; ( ($($m:meta),*) ($($it:item)*) ), $($rest:tt)*) => {\n+                 __cfg_if_items! { ($($not,)* $($m,)*) ; $($rest)* }\n+            }\n+        }\n+\"#,\n+        );\n+\n+        assert_expansion(&rules, r#\"__cfg_if_items ! { ( rustdoc , ) ; ( ( ) ( # [ cfg ( any ( target_os = \"redox\" , unix ) ) ] # [ stable ( feature = \"rust1\" , since = \"1.0.0\" ) ] pub use sys :: ext as unix ; # [ cfg ( windows ) ] # [ stable ( feature = \"rust1\" , since = \"1.0.0\" ) ] pub use sys :: ext as windows ; # [ cfg ( any ( target_os = \"linux\" , target_os = \"l4re\" ) ) ] pub mod linux ; ) ) , }\"#,         \n+        \"__cfg_if_items ! {(rustdoc , ) ; }\");\n+    }\n+\n+    #[test]\n+    fn test_cfg_if_main() {\n+        // from https://github.com/rust-lang/rust/blob/3d211248393686e0f73851fc7548f6605220fbe1/src/libpanic_unwind/macros.rs#L9\n+        let rules = create_rules(\n+            r#\"\n+        macro_rules! cfg_if {\n+            ($(\n+                if #[cfg($($meta:meta),*)] { $($it:item)* }\n+            ) else * else {\n+                $($it2:item)*\n+            }) => {\n+                __cfg_if_items! {\n+                    () ;\n+                    $( ( ($($meta),*) ($($it)*) ), )*\n+                    ( () ($($it2)*) ),\n+                }\n+            }\n+        }\n+\"#,\n+        );\n+\n+        assert_expansion(&rules, r#\"\n+cfg_if !   { \n+     if   # [ cfg ( target_env   =   \"msvc\" ) ]   { \n+         // no extra unwinder support needed \n+     }   else   if   # [ cfg ( all ( target_arch   =   \"wasm32\" ,   not ( target_os   =   \"emscripten\" ) ) ) ]   { \n+         // no unwinder on the system! \n+     }   else   { \n+         mod   libunwind ; \n+         pub   use   libunwind :: * ; \n+     } \n+ }        \n+\"#,         \n+        \"__cfg_if_items ! {() ;  (() (mod libunwind ; pub use libunwind :: * ;)) ,}\");\n     }\n }"}, {"sha": "d5189b53745138914d09ba8312c0b706aadf9625", "filename": "crates/ra_mbe/src/mbe_expander.rs", "status": "modified", "additions": 123, "deletions": 44, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e0f378faeabd425392d4a7a7839bd7e8ac2f/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e0f378faeabd425392d4a7a7839bd7e8ac2f/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs?ref=42c4e0f378faeabd425392d4a7a7839bd7e8ac2f", "patch": "@@ -21,7 +21,10 @@ fn expand_rule(rule: &crate::Rule, input: &tt::Subtree) -> Result<tt::Subtree, E\n     if !input.is_eof() {\n         return Err(ExpandError::UnexpectedToken);\n     }\n-    expand_subtree(&rule.rhs, &bindings, &mut Vec::new())\n+\n+    let mut ctx = ExpandCtx { bindings: &bindings, nesting: Vec::new(), var_expanded: false };\n+\n+    expand_subtree(&rule.rhs, &mut ctx)\n }\n \n /// The actual algorithm for expansion is not too hard, but is pretty tricky.\n@@ -179,10 +182,10 @@ fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Result<Bindings,\n                         // Enable followiing code when everything is fixed\n                         // At least we can dogfood itself to not stackoverflow\n                         //\n-                        // \"tt\" => {\n-                        //     let token = input.eat().ok_or(ExpandError::UnexpectedToken)?.clone();\n-                        //     res.inner.insert(text.clone(), Binding::Simple(token.into()));\n-                        // }\n+                        \"tt\" => {\n+                            let token = input.eat().ok_or(ExpandError::UnexpectedToken)?.clone();\n+                            res.inner.insert(text.clone(), Binding::Simple(token.into()));\n+                        }\n                         \"item\" => {\n                             let item =\n                                 input.eat_item().ok_or(ExpandError::UnexpectedToken)?.clone();\n@@ -196,6 +199,7 @@ fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Result<Bindings,\n                         \"literal\" => {\n                             let literal =\n                                 input.eat_literal().ok_or(ExpandError::UnexpectedToken)?.clone();\n+\n                             res.inner.insert(\n                                 text.clone(),\n                                 Binding::Simple(tt::Leaf::from(literal).into()),\n@@ -210,7 +214,7 @@ fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Result<Bindings,\n                     }\n                 }\n                 crate::Leaf::Punct(punct) => {\n-                    if input.eat_punct() != Some(punct) {\n+                    if !input.eat_punct().map(|p| p.char == punct.char).unwrap_or(false) {\n                         return Err(ExpandError::UnexpectedToken);\n                     }\n                 }\n@@ -224,20 +228,54 @@ fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Result<Bindings,\n             crate::TokenTree::Repeat(crate::Repeat { subtree, kind, separator }) => {\n                 // Dirty hack to make macro-expansion terminate.\n                 // This should be replaced by a propper macro-by-example implementation\n-                let mut limit = 128;\n+                let mut limit = 65536;\n                 let mut counter = 0;\n-                while let Ok(nested) = match_lhs(subtree, input) {\n-                    counter += 1;\n-                    limit -= 1;\n-                    if limit == 0 {\n-                        break;\n-                    }\n-                    res.push_nested(nested)?;\n-                    if let Some(separator) = *separator {\n-                        if !input.is_eof() {\n-                            if input.eat_punct().map(|p| p.char) != Some(separator) {\n-                                return Err(ExpandError::UnexpectedToken);\n+\n+                let mut memento = input.save();\n+\n+                loop {\n+                    match match_lhs(subtree, input) {\n+                        Ok(nested) => {\n+                            counter += 1;\n+                            limit -= 1;\n+                            if limit == 0 {\n+                                log::warn!(\"match_lhs excced in repeat pattern exceed limit => {:#?}\\n{:#?}\\n{:#?}\\n{:#?}\", subtree, input, kind, separator);\n+                                break;\n+                            }\n+\n+                            memento = input.save();\n+                            res.push_nested(nested)?;\n+                            if counter == 1 {\n+                                if let crate::RepeatKind::ZeroOrOne = kind {\n+                                    break;\n+                                }\n                             }\n+\n+                            if let Some(separator) = separator {\n+                                use crate::Separator::*;\n+\n+                                if !input\n+                                    .eat_seperator()\n+                                    .map(|sep| match (sep, separator) {\n+                                        (Ident(ref a), Ident(ref b)) => a.text == b.text,\n+                                        (Literal(ref a), Literal(ref b)) => a.text == b.text,\n+                                        (Puncts(ref a), Puncts(ref b)) if a.len() == b.len() => {\n+                                            let a_iter = a.iter().map(|a| a.char);\n+                                            let b_iter = b.iter().map(|b| b.char);\n+                                            a_iter.eq(b_iter)\n+                                        }\n+                                        _ => false,\n+                                    })\n+                                    .unwrap_or(false)\n+                                {\n+                                    input.rollback(memento);\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                        Err(_) => {\n+                            input.rollback(memento);\n+                            break;\n                         }\n                     }\n                 }\n@@ -246,10 +284,6 @@ fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Result<Bindings,\n                     crate::RepeatKind::OneOrMore if counter == 0 => {\n                         return Err(ExpandError::UnexpectedToken);\n                     }\n-                    crate::RepeatKind::ZeroOrOne if counter > 1 => {\n-                        return Err(ExpandError::UnexpectedToken);\n-                    }\n-\n                     _ => {}\n                 }\n             }\n@@ -273,15 +307,21 @@ fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Result<Bindings,\n     Ok(res)\n }\n \n+#[derive(Debug)]\n+struct ExpandCtx<'a> {\n+    bindings: &'a Bindings,\n+    nesting: Vec<usize>,\n+    var_expanded: bool,\n+}\n+\n fn expand_subtree(\n     template: &crate::Subtree,\n-    bindings: &Bindings,\n-    nesting: &mut Vec<usize>,\n+    ctx: &mut ExpandCtx,\n ) -> Result<tt::Subtree, ExpandError> {\n     let token_trees = template\n         .token_trees\n         .iter()\n-        .map(|it| expand_tt(it, bindings, nesting))\n+        .map(|it| expand_tt(it, ctx))\n         .collect::<Result<Vec<_>, ExpandError>>()?;\n \n     Ok(tt::Subtree { token_trees, delimiter: template.delimiter })\n@@ -303,43 +343,81 @@ fn reduce_single_token(mut subtree: tt::Subtree) -> tt::TokenTree {\n \n fn expand_tt(\n     template: &crate::TokenTree,\n-    bindings: &Bindings,\n-    nesting: &mut Vec<usize>,\n+    ctx: &mut ExpandCtx,\n ) -> Result<tt::TokenTree, ExpandError> {\n     let res: tt::TokenTree = match template {\n-        crate::TokenTree::Subtree(subtree) => expand_subtree(subtree, bindings, nesting)?.into(),\n+        crate::TokenTree::Subtree(subtree) => expand_subtree(subtree, ctx)?.into(),\n         crate::TokenTree::Repeat(repeat) => {\n             let mut token_trees: Vec<tt::TokenTree> = Vec::new();\n-            nesting.push(0);\n+            ctx.nesting.push(0);\n             // Dirty hack to make macro-expansion terminate.\n             // This should be replaced by a propper macro-by-example implementation\n-            let mut limit = 128;\n-            let mut has_sep = false;\n+            let mut limit = 65536;\n+            let mut has_seps = 0;\n+            let mut counter = 0;\n \n-            while let Ok(t) = expand_subtree(&repeat.subtree, bindings, nesting) {\n+            let mut some_var_expanded = false;\n+            ctx.var_expanded = false;\n+\n+            while let Ok(t) = expand_subtree(&repeat.subtree, ctx) {\n+                // if no var expaned in the child, we count it as a fail\n+                if !ctx.var_expanded {\n+                    break;\n+                }\n+                some_var_expanded = true;\n+                ctx.var_expanded = false;\n+\n+                counter += 1;\n                 limit -= 1;\n                 if limit == 0 {\n+                    log::warn!(\n+                        \"expand_tt excced in repeat pattern exceed limit => {:#?}\\n{:#?}\",\n+                        template,\n+                        ctx\n+                    );\n                     break;\n                 }\n-                let idx = nesting.pop().unwrap();\n-                nesting.push(idx + 1);\n+\n+                let idx = ctx.nesting.pop().unwrap();\n+                ctx.nesting.push(idx + 1);\n                 token_trees.push(reduce_single_token(t).into());\n \n-                if let Some(sep) = repeat.separator {\n-                    let punct =\n-                        tt::Leaf::from(tt::Punct { char: sep, spacing: tt::Spacing::Alone });\n-                    token_trees.push(punct.into());\n-                    has_sep = true;\n+                if let Some(ref sep) = repeat.separator {\n+                    match sep {\n+                        crate::Separator::Ident(ident) => {\n+                            has_seps = 1;\n+                            token_trees.push(tt::Leaf::from(ident.clone()).into());\n+                        }\n+                        crate::Separator::Literal(lit) => {\n+                            has_seps = 1;\n+                            token_trees.push(tt::Leaf::from(lit.clone()).into());\n+                        }\n+\n+                        crate::Separator::Puncts(puncts) => {\n+                            has_seps = puncts.len();\n+                            for punct in puncts {\n+                                token_trees.push(tt::Leaf::from(*punct).into());\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                if let crate::RepeatKind::ZeroOrOne = repeat.kind {\n+                    break;\n                 }\n             }\n-            nesting.pop().unwrap();\n \n-            // Dirty hack for remove the last sep\n-            // if it is a \",\" undo the push\n-            if has_sep && repeat.separator.unwrap() == ',' {\n+            ctx.var_expanded = some_var_expanded;\n+\n+            ctx.nesting.pop().unwrap();\n+            for _ in 0..has_seps {\n                 token_trees.pop();\n             }\n \n+            if crate::RepeatKind::OneOrMore == repeat.kind && counter == 0 {\n+                return Err(ExpandError::UnexpectedToken);\n+            }\n+\n             // Check if it is a singel token subtree without any delimiter\n             // e.g {Delimiter:None> ['>'] /Delimiter:None>}\n             reduce_single_token(tt::Subtree { token_trees, delimiter: tt::Delimiter::None })\n@@ -356,7 +434,8 @@ fn expand_tt(\n                     tt::Leaf::from(tt::Ident { text: \"$crate\".into(), id: TokenId::unspecified() })\n                         .into()\n                 } else {\n-                    let tkn = bindings.get(&v.text, nesting)?.clone();\n+                    let tkn = ctx.bindings.get(&v.text, &ctx.nesting)?.clone();\n+                    ctx.var_expanded = true;\n \n                     if let tt::TokenTree::Subtree(subtree) = tkn {\n                         reduce_single_token(subtree)"}, {"sha": "c7ab463e2cd7dcd6ac0090063488a9c69572ea3b", "filename": "crates/ra_mbe/src/mbe_parser.rs", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e0f378faeabd425392d4a7a7839bd7e8ac2f/crates%2Fra_mbe%2Fsrc%2Fmbe_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e0f378faeabd425392d4a7a7839bd7e8ac2f/crates%2Fra_mbe%2Fsrc%2Fmbe_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_parser.rs?ref=42c4e0f378faeabd425392d4a7a7839bd7e8ac2f", "patch": "@@ -74,18 +74,11 @@ fn parse_var(p: &mut TtCursor, transcriber: bool) -> Result<crate::Var, ParseErr\n     Ok(crate::Var { text, kind })\n }\n \n-fn parse_repeat(p: &mut TtCursor, transcriber: bool) -> Result<crate::Repeat, ParseError> {\n-    let subtree = p.eat_subtree().unwrap();\n-    let mut subtree = parse_subtree(subtree, transcriber)?;\n-    subtree.delimiter = crate::Delimiter::None;\n-    let sep = p.eat_punct().ok_or(ParseError::Expected(String::from(\"separator\")))?;\n-    let (separator, rep) = match sep.char {\n-        '*' | '+' | '?' => (None, sep.char),\n-        char => {\n-            (Some(char), p.eat_punct().ok_or(ParseError::Expected(String::from(\"separator\")))?.char)\n-        }\n-    };\n-\n+fn mk_repeat(\n+    rep: char,\n+    subtree: crate::Subtree,\n+    separator: Option<crate::Separator>,\n+) -> Result<crate::Repeat, ParseError> {\n     let kind = match rep {\n         '*' => crate::RepeatKind::ZeroOrMore,\n         '+' => crate::RepeatKind::OneOrMore,\n@@ -95,6 +88,27 @@ fn parse_repeat(p: &mut TtCursor, transcriber: bool) -> Result<crate::Repeat, Pa\n     Ok(crate::Repeat { subtree, kind, separator })\n }\n \n+fn parse_repeat(p: &mut TtCursor, transcriber: bool) -> Result<crate::Repeat, ParseError> {\n+    let subtree = p.eat_subtree().unwrap();\n+    let mut subtree = parse_subtree(subtree, transcriber)?;\n+    subtree.delimiter = crate::Delimiter::None;\n+\n+    if let Some(rep) = p.at_punct() {\n+        match rep.char {\n+            '*' | '+' | '?' => {\n+                p.bump();\n+                return mk_repeat(rep.char, subtree, None);\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    let sep = p.eat_seperator().ok_or(ParseError::Expected(String::from(\"separator\")))?;\n+    let rep = p.eat_punct().ok_or(ParseError::Expected(String::from(\"repeat\")))?;\n+\n+    mk_repeat(rep.char, subtree, Some(sep))\n+}\n+\n #[cfg(test)]\n mod tests {\n     use ra_syntax::{ast, AstNode};\n@@ -109,7 +123,7 @@ mod tests {\n         is_valid(\"($i:ident) => ()\");\n         expect_err(\"$i:ident => ()\", \"subtree\");\n         expect_err(\"($i:ident) ()\", \"`=`\");\n-        expect_err(\"($($i:ident)_) => ()\", \"separator\");\n+        expect_err(\"($($i:ident)_) => ()\", \"repeat\");\n     }\n \n     fn expect_err(macro_body: &str, expected: &str) {"}, {"sha": "6255ea304944e54695c7b20b64a9676ed040d649", "filename": "crates/ra_mbe/src/subtree_source.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e0f378faeabd425392d4a7a7839bd7e8ac2f/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e0f378faeabd425392d4a7a7839bd7e8ac2f/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsubtree_source.rs?ref=42c4e0f378faeabd425392d4a7a7839bd7e8ac2f", "patch": "@@ -212,7 +212,7 @@ impl<'a> SubTreeWalker<'a> {\n }\n \n pub(crate) trait Querier {\n-    fn token(&self, uidx: usize) -> (SyntaxKind, SmolStr);\n+    fn token(&self, uidx: usize) -> (SyntaxKind, SmolStr, bool);\n }\n \n // A wrapper class for ref cell\n@@ -292,9 +292,10 @@ impl<'a> WalkerOwner<'a> {\n }\n \n impl<'a> Querier for WalkerOwner<'a> {\n-    fn token(&self, uidx: usize) -> (SyntaxKind, SmolStr) {\n-        let tkn = self.get(uidx).unwrap();\n-        (tkn.kind, tkn.text)\n+    fn token(&self, uidx: usize) -> (SyntaxKind, SmolStr, bool) {\n+        self.get(uidx)\n+            .map(|tkn| (tkn.kind, tkn.text, tkn.is_joint_to_next))\n+            .unwrap_or_else(|| (SyntaxKind::EOF, \"\".into(), false))\n     }\n }\n \n@@ -342,7 +343,7 @@ impl<'a> TokenSource for SubtreeTokenSource<'a> {\n     }\n }\n \n-struct TokenPeek<'a, I>\n+pub(crate) struct TokenPeek<'a, I>\n where\n     I: Iterator<Item = &'a tt::TokenTree>,\n {\n@@ -365,7 +366,7 @@ where\n         TokenPeek { iter: itertools::multipeek(iter) }\n     }\n \n-    fn current_punct2(&mut self, p: &tt::Punct) -> Option<((char, char), bool)> {\n+    pub fn current_punct2(&mut self, p: &tt::Punct) -> Option<((char, char), bool)> {\n         if p.spacing != tt::Spacing::Joint {\n             return None;\n         }\n@@ -375,7 +376,7 @@ where\n         Some(((p.char, p1.char), p1.spacing == tt::Spacing::Joint))\n     }\n \n-    fn current_punct3(&mut self, p: &tt::Punct) -> Option<((char, char, char), bool)> {\n+    pub fn current_punct3(&mut self, p: &tt::Punct) -> Option<((char, char, char), bool)> {\n         self.current_punct2(p).and_then(|((p0, p1), last_joint)| {\n             if !last_joint {\n                 None\n@@ -437,12 +438,14 @@ fn convert_delim(d: tt::Delimiter, closing: bool) -> TtToken {\n }\n \n fn convert_literal(l: &tt::Literal) -> TtToken {\n-    TtToken {\n-        kind: classify_literal(&l.text).unwrap().kind,\n-        is_joint_to_next: false,\n-        text: l.text.clone(),\n-        n_tokens: 1,\n-    }\n+    let kind =\n+        classify_literal(&l.text).map(|tkn| tkn.kind).unwrap_or_else(|| match l.text.as_ref() {\n+            \"true\" => SyntaxKind::TRUE_KW,\n+            \"false\" => SyntaxKind::FALSE_KW,\n+            _ => panic!(\"Fail to convert given literal {:#?}\", &l),\n+        });\n+\n+    TtToken { kind, is_joint_to_next: false, text: l.text.clone(), n_tokens: 1 }\n }\n \n fn convert_ident(ident: &tt::Ident) -> TtToken {"}, {"sha": "e0f228ce9bcb866025ea82aff8f609a59e65f3ee", "filename": "crates/ra_mbe/src/syntax_bridge.rs", "status": "modified", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e0f378faeabd425392d4a7a7839bd7e8ac2f/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e0f378faeabd425392d4a7a7839bd7e8ac2f/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs?ref=42c4e0f378faeabd425392d4a7a7839bd7e8ac2f", "patch": "@@ -123,6 +123,11 @@ fn convert_tt(\n     global_offset: TextUnit,\n     tt: &SyntaxNode,\n ) -> Option<tt::Subtree> {\n+    // This tree is empty\n+    if tt.first_child_or_token().is_none() {\n+        return Some(tt::Subtree { token_trees: vec![], delimiter: tt::Delimiter::None });\n+    }\n+\n     let first_child = tt.first_child_or_token()?;\n     let last_child = tt.last_child_or_token()?;\n     let (delimiter, skip_first) = match (first_child.kind(), last_child.kind()) {\n@@ -133,7 +138,9 @@ fn convert_tt(\n     };\n \n     let mut token_trees = Vec::new();\n-    for child in tt.children_with_tokens().skip(skip_first as usize) {\n+    let mut child_iter = tt.children_with_tokens().skip(skip_first as usize).peekable();\n+\n+    while let Some(child) = child_iter.next() {\n         if (skip_first && (child == first_child || child == last_child)) || child.kind().is_trivia()\n         {\n             continue;\n@@ -152,12 +159,25 @@ fn convert_tt(\n                         prev = Some(char)\n                     }\n                     if let Some(char) = prev {\n-                        token_trees.push(\n-                            tt::Leaf::from(tt::Punct { char, spacing: tt::Spacing::Alone }).into(),\n-                        );\n+                        let spacing = match child_iter.peek() {\n+                            Some(SyntaxElement::Token(token)) => {\n+                                if token.kind().is_punct() {\n+                                    tt::Spacing::Joint\n+                                } else {\n+                                    tt::Spacing::Alone\n+                                }\n+                            }\n+                            _ => tt::Spacing::Alone,\n+                        };\n+\n+                        token_trees.push(tt::Leaf::from(tt::Punct { char, spacing }).into());\n                     }\n                 } else {\n-                    let child: tt::TokenTree = if token.kind().is_keyword()\n+                    let child: tt::TokenTree = if token.kind() == SyntaxKind::TRUE_KW\n+                        || token.kind() == SyntaxKind::FALSE_KW\n+                    {\n+                        tt::Leaf::from(tt::Literal { text: token.text().clone() }).into()\n+                    } else if token.kind().is_keyword()\n                         || token.kind() == IDENT\n                         || token.kind() == LIFETIME\n                     {\n@@ -218,7 +238,16 @@ impl<'a, Q: Querier> TreeSink for TtTreeSink<'a, Q> {\n         self.text_pos += TextUnit::of_str(&self.buf);\n         let text = SmolStr::new(self.buf.as_str());\n         self.buf.clear();\n-        self.inner.token(kind, text)\n+        self.inner.token(kind, text);\n+\n+        // // Add a white space to token\n+        // let (last_kind, _, last_joint_to_next ) = self.src_querier.token(self.token_pos-n_tokens as usize);\n+        // if !last_joint_to_next && last_kind.is_punct() {\n+        //     let (cur_kind, _, _ ) = self.src_querier.token(self.token_pos);\n+        //     if cur_kind.is_punct() {\n+        //         self.inner.token(WHITESPACE, \" \".into());\n+        //     }\n+        // }\n     }\n \n     fn start_node(&mut self, kind: SyntaxKind) {"}, {"sha": "eef642a9c0a1cd447c3c441320eecd972a9bf237", "filename": "crates/ra_mbe/src/tt_cursor.rs", "status": "modified", "additions": 105, "deletions": 1, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e0f378faeabd425392d4a7a7839bd7e8ac2f/crates%2Fra_mbe%2Fsrc%2Ftt_cursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e0f378faeabd425392d4a7a7839bd7e8ac2f/crates%2Fra_mbe%2Fsrc%2Ftt_cursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Ftt_cursor.rs?ref=42c4e0f378faeabd425392d4a7a7839bd7e8ac2f", "patch": "@@ -1,12 +1,18 @@\n use crate::ParseError;\n use crate::subtree_parser::Parser;\n+use crate::subtree_source::TokenPeek;\n+use smallvec::{SmallVec, smallvec};\n \n-#[derive(Clone)]\n+#[derive(Debug, Clone)]\n pub(crate) struct TtCursor<'a> {\n     subtree: &'a tt::Subtree,\n     pos: usize,\n }\n \n+pub(crate) struct TtCursorMemento {\n+    pos: usize,\n+}\n+\n impl<'a> TtCursor<'a> {\n     pub(crate) fn new(subtree: &'a tt::Subtree) -> TtCursor<'a> {\n         TtCursor { subtree, pos: 0 }\n@@ -157,4 +163,102 @@ impl<'a> TtCursor<'a> {\n             Err(ParseError::Expected(format!(\"`{}`\", char)))\n         }\n     }\n+\n+    fn eat_punct3(&mut self, p: &tt::Punct) -> Option<SmallVec<[tt::Punct; 3]>> {\n+        let sec = self.eat_punct()?.clone();\n+        let third = self.eat_punct()?.clone();\n+        Some(smallvec![p.clone(), sec, third])\n+    }\n+\n+    fn eat_punct2(&mut self, p: &tt::Punct) -> Option<SmallVec<[tt::Punct; 3]>> {\n+        let sec = self.eat_punct()?.clone();\n+        Some(smallvec![p.clone(), sec])\n+    }\n+\n+    fn eat_multi_char_punct<'b, I>(\n+        &mut self,\n+        p: &tt::Punct,\n+        iter: &mut TokenPeek<'b, I>,\n+    ) -> Option<SmallVec<[tt::Punct; 3]>>\n+    where\n+        I: Iterator<Item = &'b tt::TokenTree>,\n+    {\n+        if let Some((m, _)) = iter.current_punct3(p) {\n+            if let r @ Some(_) = match m {\n+                ('<', '<', '=') | ('>', '>', '=') | ('.', '.', '.') | ('.', '.', '=') => {\n+                    self.eat_punct3(p)\n+                }\n+                _ => None,\n+            } {\n+                return r;\n+            }\n+        }\n+\n+        if let Some((m, _)) = iter.current_punct2(p) {\n+            if let r @ Some(_) = match m {\n+                ('<', '=')\n+                | ('>', '=')\n+                | ('+', '=')\n+                | ('-', '=')\n+                | ('|', '=')\n+                | ('&', '=')\n+                | ('^', '=')\n+                | ('/', '=')\n+                | ('*', '=')\n+                | ('%', '=')\n+                | ('&', '&')\n+                | ('|', '|')\n+                | ('<', '<')\n+                | ('>', '>')\n+                | ('-', '>')\n+                | ('!', '=')\n+                | ('=', '>')\n+                | ('=', '=')\n+                | ('.', '.')\n+                | (':', ':') => self.eat_punct2(p),\n+\n+                _ => None,\n+            } {\n+                return r;\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    pub(crate) fn eat_seperator(&mut self) -> Option<crate::Separator> {\n+        match self.eat()? {\n+            tt::TokenTree::Leaf(tt::Leaf::Literal(lit)) => {\n+                Some(crate::Separator::Literal(lit.clone()))\n+            }\n+            tt::TokenTree::Leaf(tt::Leaf::Ident(ident)) => {\n+                Some(crate::Separator::Ident(ident.clone()))\n+            }\n+            tt::TokenTree::Leaf(tt::Leaf::Punct(punct)) => {\n+                match punct.char {\n+                    '*' | '+' | '?' => return None,\n+                    _ => {}\n+                };\n+\n+                // FIXME: The parser is only handle some compositeable punct,\n+                // But at this phase, some punct still is jointed.\n+                // So we by pass that check here.\n+                let mut peekable = TokenPeek::new(self.subtree.token_trees[self.pos..].iter());\n+                let puncts = self.eat_multi_char_punct(punct, &mut peekable);\n+                let puncts = puncts.unwrap_or_else(|| smallvec![punct.clone()]);\n+\n+                Some(crate::Separator::Puncts(puncts))\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    #[must_use]\n+    pub(crate) fn save(&self) -> TtCursorMemento {\n+        TtCursorMemento { pos: self.pos }\n+    }\n+\n+    pub(crate) fn rollback(&mut self, memento: TtCursorMemento) {\n+        self.pos = memento.pos;\n+    }\n }"}, {"sha": "a538ec081f1a62df4cc86eea990a3e5734f3b424", "filename": "crates/ra_parser/src/grammar.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/42c4e0f378faeabd425392d4a7a7839bd7e8ac2f/crates%2Fra_parser%2Fsrc%2Fgrammar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42c4e0f378faeabd425392d4a7a7839bd7e8ac2f/crates%2Fra_parser%2Fsrc%2Fgrammar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar.rs?ref=42c4e0f378faeabd425392d4a7a7839bd7e8ac2f", "patch": "@@ -119,7 +119,22 @@ pub(crate) fn meta_item(p: &mut Parser) {\n             items::token_tree(p);\n             break;\n         } else {\n-            p.bump();\n+            // https://doc.rust-lang.org/reference/attributes.html\n+            // https://doc.rust-lang.org/reference/paths.html#simple-paths\n+            // The start of an meta must be a simple path\n+            match p.current() {\n+                IDENT | COLONCOLON | SUPER_KW | SELF_KW | CRATE_KW => p.bump(),\n+                EQ => {\n+                    p.bump();\n+                    match p.current() {\n+                        c if c.is_literal() => p.bump(),\n+                        TRUE_KW | FALSE_KW => p.bump(),\n+                        _ => {}\n+                    }\n+                    break;\n+                }\n+                _ => break,\n+            }\n         }\n     }\n "}]}