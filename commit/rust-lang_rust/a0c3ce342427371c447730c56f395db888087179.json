{"sha": "a0c3ce342427371c447730c56f395db888087179", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwYzNjZTM0MjQyNzM3MWM0NDc3MzBjNTZmMzk1ZGI4ODgwODcxNzk=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-04-10T00:44:14Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-04-14T04:57:33Z"}, "message": "resolve: use the `Restricted` variant of `ty::Visibility` when privacy checking", "tree": {"sha": "1c4f59ae2a57c39b16a6ca3aaa7146fe6f8da91e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c4f59ae2a57c39b16a6ca3aaa7146fe6f8da91e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0c3ce342427371c447730c56f395db888087179", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0c3ce342427371c447730c56f395db888087179", "html_url": "https://github.com/rust-lang/rust/commit/a0c3ce342427371c447730c56f395db888087179", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0c3ce342427371c447730c56f395db888087179/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4196cd490deba9f5d885f6c9f335c05f1048c24", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4196cd490deba9f5d885f6c9f335c05f1048c24", "html_url": "https://github.com/rust-lang/rust/commit/a4196cd490deba9f5d885f6c9f335c05f1048c24"}], "stats": {"total": 48, "additions": 18, "deletions": 30}, "files": [{"sha": "e161a42032d357406864afdfcd75ced439b1d996", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a0c3ce342427371c447730c56f395db888087179/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0c3ce342427371c447730c56f395db888087179/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=a0c3ce342427371c447730c56f395db888087179", "patch": "@@ -907,15 +907,6 @@ impl<'a> ModuleS<'a> {\n             _ => false,\n         }\n     }\n-\n-    fn is_ancestor_of(&self, module: Module<'a>) -> bool {\n-        if self.def_id() == module.def_id() { return true }\n-        match module.parent_link {\n-            ParentLink::BlockParentLink(parent, _) |\n-            ParentLink::ModuleParentLink(parent, _) => self.is_ancestor_of(parent),\n-            _ => false,\n-        }\n-    }\n }\n \n impl<'a> fmt::Debug for ModuleS<'a> {\n@@ -1330,7 +1321,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     // Check to see whether there are type bindings, and, if\n                     // so, whether there is a module within.\n                     if let Some(module_def) = binding.module() {\n-                        self.check_privacy(search_module, name, binding, span);\n+                        self.check_privacy(name, binding, span);\n                         search_module = module_def;\n                     } else {\n                         let msg = format!(\"Not a module `{}`\", name);\n@@ -1461,7 +1452,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n \n     /// Returns the nearest normal module parent of the given module.\n-    fn get_nearest_normal_module_parent(&mut self, module_: Module<'a>) -> Option<Module<'a>> {\n+    fn get_nearest_normal_module_parent(&self, module_: Module<'a>) -> Option<Module<'a>> {\n         let mut module_ = module_;\n         loop {\n             match module_.parent_link {\n@@ -1480,7 +1471,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     /// Returns the nearest normal module parent of the given module, or the\n     /// module itself if it is a normal module.\n-    fn get_nearest_normal_module_parent_or_self(&mut self, module_: Module<'a>) -> Module<'a> {\n+    fn get_nearest_normal_module_parent_or_self(&self, module_: Module<'a>) -> Module<'a> {\n         if module_.is_normal() {\n             return module_;\n         }\n@@ -2768,7 +2759,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let name = segments.last().unwrap().identifier.name;\n         let result = self.resolve_name_in_module(containing_module, name, namespace, false, true);\n         result.success().map(|binding| {\n-            self.check_privacy(containing_module, name, binding, span);\n+            self.check_privacy(name, binding, span);\n             binding.def().unwrap()\n         }).ok_or(false)\n     }\n@@ -2818,7 +2809,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let name = segments.last().unwrap().identifier.name;\n         let result = self.resolve_name_in_module(containing_module, name, namespace, false, true);\n         result.success().map(|binding| {\n-            self.check_privacy(containing_module, name, binding, span);\n+            self.check_privacy(name, binding, span);\n             binding.def().unwrap()\n         }).ok_or(false)\n     }\n@@ -3412,16 +3403,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         vis\n     }\n \n-    fn is_visible(&self, binding: &'a NameBinding<'a>, parent: Module<'a>) -> bool {\n-        binding.is_public() || parent.is_ancestor_of(self.current_module)\n+    fn is_accessible(&self, vis: ty::Visibility) -> bool {\n+        let current_module = self.get_nearest_normal_module_parent_or_self(self.current_module);\n+        let node_id = self.ast_map.as_local_node_id(current_module.def_id().unwrap()).unwrap();\n+        vis.is_accessible_from(node_id, &self.ast_map)\n     }\n \n-    fn check_privacy(&mut self,\n-                     module: Module<'a>,\n-                     name: Name,\n-                     binding: &'a NameBinding<'a>,\n-                     span: Span) {\n-        if !self.is_visible(binding, module) {\n+    fn check_privacy(&mut self, name: Name, binding: &'a NameBinding<'a>, span: Span) {\n+        if !self.is_accessible(binding.vis) {\n             self.privacy_errors.push(PrivacyError(span, name, binding));\n         }\n     }"}, {"sha": "31d1c5700265794cd71e55291aa3c2748ff417ed", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a0c3ce342427371c447730c56f395db888087179/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0c3ce342427371c447730c56f395db888087179/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=a0c3ce342427371c447730c56f395db888087179", "patch": "@@ -521,7 +521,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     span_err!(self.resolver.session, directive.span, E0253, \"{}\", &msg);\n                 }\n \n-                let privacy_error = if !self.resolver.is_visible(binding, target_module) {\n+                let privacy_error = if !self.resolver.is_accessible(binding.vis) {\n                     Some(Box::new(PrivacyError(directive.span, source, binding)))\n                 } else {\n                     None\n@@ -567,10 +567,10 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n             _ => (),\n         }\n \n+        let ast_map = self.resolver.ast_map;\n         match (&value_result, &type_result) {\n-            (&Success(name_binding), _) if !name_binding.is_import() &&\n-                                           directive.vis == ty::Visibility::Public &&\n-                                           !name_binding.is_public() => {\n+            (&Success(binding), _) if !binding.vis.is_at_least(directive.vis, ast_map) &&\n+                                      self.resolver.is_accessible(binding.vis) => {\n                 let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n                 let note_msg = format!(\"consider marking `{}` as `pub` in the imported module\",\n                                         source);\n@@ -579,10 +579,9 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     .emit();\n             }\n \n-            (_, &Success(name_binding)) if !name_binding.is_import() &&\n-                                           directive.vis == ty::Visibility::Public &&\n-                                           !name_binding.is_public() => {\n-                if name_binding.is_extern_crate() {\n+            (_, &Success(binding)) if !binding.vis.is_at_least(directive.vis, ast_map) &&\n+                                      self.resolver.is_accessible(binding.vis) => {\n+                if binding.is_extern_crate() {\n                     let msg = format!(\"extern crate `{}` is private, and cannot be reexported \\\n                                        (error E0364), consider declaring with `pub`\",\n                                        source);"}]}