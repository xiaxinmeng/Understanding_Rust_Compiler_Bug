{"sha": "f29ab8c2451e59153f956d01cb1f228663ef9054", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyOWFiOGMyNDUxZTU5MTUzZjk1NmQwMWNiMWYyMjg2NjNlZjkwNTQ=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-10-24T08:39:19Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-10-24T08:39:19Z"}, "message": "Merge branch 'master' of github.com:Manishearth/rust-clippy into deep_code_inspection", "tree": {"sha": "7216880a36ba0f610ff95ba87bcdc0674aa93351", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7216880a36ba0f610ff95ba87bcdc0674aa93351"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f29ab8c2451e59153f956d01cb1f228663ef9054", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJYDci5AAoJEFbW7qD8Z6xGJTwP/AiBg3y4OhzuPW84rGe6YRLt\nTnhffWQSZLPv4IQrInWn6LSCwh8t7it8j696/1HMNWJAfbYvIZ44eWm+V+CvKEMq\nu5xjcrtUj7UBEtdq/PPTBnJ/Dfnw0X9AlPhjFk4XAjLGuU8xaOL0ldGxOJ5yOPUv\nJNfYbe0+/mm95Pn6pVw20SOx0naNO/CSrRnkiAmTqXGd3BNq3NOqpd6HL7/L6pVT\nJcRCBvEHSxozAqm8growW+3slynfgJvPXyxgLNRd+X+PeqbIu2L3hEvG+0QqByyn\nVtQl25WXiJomT4KbcaJJB3PmjsUVC17cGGBYuMjmoAst8D6kqGfpenj0bBAA4L/Y\nVEdyGfOq+bh2d1WpJoQlBM+usfzsixA2dK3OCmJWaWBE09uJJg6P57aXr+JWufwn\nrqzv7cuj+gaVbGGw6jTEupxUG4nVOqj+J2f9aIIjVoDFRh1ExKq2PIx+AeJE5u1a\n2Dd0ssATiNJISLn9oHIMqrrIuvH8I6LG4FP2l66sMROPWqf0hZeiGIYA1ytMhDgy\nQBCswWIW/1VK4ArTC0TwqlXBAh/uukQvqkvAV+YvyVVUdmkQNZhswAqTKfkrxPDO\n6LJJXnU+x+WzUvxtG3ity4AY/bp8mmawJfeBQMPjKcjabKEdEfxHYHbr061kpFuN\n0ISr4i3jFQf8VGpc7KxP\n=83QQ\n-----END PGP SIGNATURE-----", "payload": "tree 7216880a36ba0f610ff95ba87bcdc0674aa93351\nparent a177d85681d0c8eeaf641f2b1b76c6f755971a72\nparent 9fcc04e7dfe965d1eb9c6a45ad26c319525b54d7\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1477298359 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1477298359 +0200\n\nMerge branch 'master' of github.com:Manishearth/rust-clippy into deep_code_inspection\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f29ab8c2451e59153f956d01cb1f228663ef9054", "html_url": "https://github.com/rust-lang/rust/commit/f29ab8c2451e59153f956d01cb1f228663ef9054", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f29ab8c2451e59153f956d01cb1f228663ef9054/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a177d85681d0c8eeaf641f2b1b76c6f755971a72", "url": "https://api.github.com/repos/rust-lang/rust/commits/a177d85681d0c8eeaf641f2b1b76c6f755971a72", "html_url": "https://github.com/rust-lang/rust/commit/a177d85681d0c8eeaf641f2b1b76c6f755971a72"}, {"sha": "9fcc04e7dfe965d1eb9c6a45ad26c319525b54d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fcc04e7dfe965d1eb9c6a45ad26c319525b54d7", "html_url": "https://github.com/rust-lang/rust/commit/9fcc04e7dfe965d1eb9c6a45ad26c319525b54d7"}], "stats": {"total": 230, "additions": 134, "deletions": 96}, "files": [{"sha": "4c6aef22bab03734b074b0a28a7d46cbaf6d56f1", "filename": "CHANGELOG.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f29ab8c2451e59153f956d01cb1f228663ef9054/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/f29ab8c2451e59153f956d01cb1f228663ef9054/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=f29ab8c2451e59153f956d01cb1f228663ef9054", "patch": "@@ -1,6 +1,10 @@\n # Change Log\n All notable changes to this project will be documented in this file.\n \n+## 0.0.96 \u2014 2016-10-22\n+* Rustup to *rustc 1.14.0-nightly (f09420685 2016-10-20)*\n+* New lint: [`iter_skip_next`]\n+\n ## 0.0.95 \u2014 2016-10-06\n * Rustup to *rustc 1.14.0-nightly (3210fd5c2 2016-10-05)*\n "}, {"sha": "e53b1db5df9c1081399ff834e4527b0fe1c8cd21", "filename": "Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f29ab8c2451e59153f956d01cb1f228663ef9054/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f29ab8c2451e59153f956d01cb1f228663ef9054/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=f29ab8c2451e59153f956d01cb1f228663ef9054", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy\"\n-version = \"0.0.95\"\n+version = \"0.0.96\"\n authors = [\n \t\"Manish Goregaokar <manishsmail@gmail.com>\",\n \t\"Andre Bogus <bogusandre@gmail.com>\",\n@@ -25,7 +25,7 @@ test = false\n \n [dependencies]\n # begin automatic update\n-clippy_lints = { version = \"0.0.95\", path = \"clippy_lints\" }\n+clippy_lints = { version = \"0.0.96\", path = \"clippy_lints\" }\n # end automatic update\n \n [dev-dependencies]"}, {"sha": "55b2e8fcb665e71f9556923afb439869075adcd5", "filename": "clippy_lints/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f29ab8c2451e59153f956d01cb1f228663ef9054/clippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f29ab8c2451e59153f956d01cb1f228663ef9054/clippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2FCargo.toml?ref=f29ab8c2451e59153f956d01cb1f228663ef9054", "patch": "@@ -1,7 +1,7 @@\n [package]\n name = \"clippy_lints\"\n # begin automatic update\n-version = \"0.0.95\"\n+version = \"0.0.96\"\n # end automatic update\n authors = [\n \t\"Manish Goregaokar <manishsmail@gmail.com>\","}, {"sha": "fbbbf497d5964bd22c9ec7fa60b6f197e168edfe", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f29ab8c2451e59153f956d01cb1f228663ef9054/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f29ab8c2451e59153f956d01cb1f228663ef9054/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=f29ab8c2451e59153f956d01cb1f228663ef9054", "patch": "@@ -6,8 +6,7 @@ use rustc::hir::*;\n use semver::Version;\n use syntax::ast::{Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem, NestedMetaItemKind};\n use syntax::codemap::Span;\n-use utils::{in_macro, match_path, span_lint, span_lint_and_then, snippet_opt};\n-use utils::paths;\n+use utils::{in_macro, match_def_path, resolve_node, paths, span_lint, span_lint_and_then, snippet_opt};\n \n /// **What it does:** Checks for items annotated with `#[inline(always)]`,\n /// unless the annotated function is empty or simply panics.\n@@ -101,7 +100,7 @@ impl LateLintPass for AttrPass {\n     }\n \n     fn check_item(&mut self, cx: &LateContext, item: &Item) {\n-        if is_relevant_item(item) {\n+        if is_relevant_item(cx, item) {\n             check_attrs(cx, item.span, &item.name, &item.attrs)\n         }\n         match item.node {\n@@ -140,62 +139,63 @@ impl LateLintPass for AttrPass {\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext, item: &ImplItem) {\n-        if is_relevant_impl(item) {\n+        if is_relevant_impl(cx, item) {\n             check_attrs(cx, item.span, &item.name, &item.attrs)\n         }\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext, item: &TraitItem) {\n-        if is_relevant_trait(item) {\n+        if is_relevant_trait(cx, item) {\n             check_attrs(cx, item.span, &item.name, &item.attrs)\n         }\n     }\n }\n \n-fn is_relevant_item(item: &Item) -> bool {\n+fn is_relevant_item(cx: &LateContext, item: &Item) -> bool {\n     if let ItemFn(_, _, _, _, _, ref block) = item.node {\n-        is_relevant_block(block)\n+        is_relevant_block(cx, block)\n     } else {\n         false\n     }\n }\n \n-fn is_relevant_impl(item: &ImplItem) -> bool {\n+fn is_relevant_impl(cx: &LateContext, item: &ImplItem) -> bool {\n     match item.node {\n-        ImplItemKind::Method(_, ref block) => is_relevant_block(block),\n+        ImplItemKind::Method(_, ref block) => is_relevant_block(cx, block),\n         _ => false,\n     }\n }\n \n-fn is_relevant_trait(item: &TraitItem) -> bool {\n+fn is_relevant_trait(cx: &LateContext, item: &TraitItem) -> bool {\n     match item.node {\n         MethodTraitItem(_, None) => true,\n-        MethodTraitItem(_, Some(ref block)) => is_relevant_block(block),\n+        MethodTraitItem(_, Some(ref block)) => is_relevant_block(cx, block),\n         _ => false,\n     }\n }\n \n-fn is_relevant_block(block: &Block) -> bool {\n+fn is_relevant_block(cx: &LateContext, block: &Block) -> bool {\n     for stmt in &block.stmts {\n         match stmt.node {\n             StmtDecl(_, _) => return true,\n             StmtExpr(ref expr, _) |\n             StmtSemi(ref expr, _) => {\n-                return is_relevant_expr(expr);\n+                return is_relevant_expr(cx, expr);\n             }\n         }\n     }\n-    block.expr.as_ref().map_or(false, |e| is_relevant_expr(e))\n+    block.expr.as_ref().map_or(false, |e| is_relevant_expr(cx, e))\n }\n \n-fn is_relevant_expr(expr: &Expr) -> bool {\n+fn is_relevant_expr(cx: &LateContext, expr: &Expr) -> bool {\n     match expr.node {\n-        ExprBlock(ref block) => is_relevant_block(block),\n-        ExprRet(Some(ref e)) => is_relevant_expr(e),\n+        ExprBlock(ref block) => is_relevant_block(cx, block),\n+        ExprRet(Some(ref e)) => is_relevant_expr(cx, e),\n         ExprRet(None) | ExprBreak(_) => false,\n         ExprCall(ref path_expr, _) => {\n-            if let ExprPath(_, ref path) = path_expr.node {\n-                !match_path(path, &paths::BEGIN_PANIC)\n+            if let ExprPath(..) = path_expr.node {\n+                let fun_id = resolve_node(cx, path_expr.id).expect(\"function should be resolved\").def_id();\n+                !match_def_path(cx, fun_id, &paths::BEGIN_PANIC)\n             } else {\n                 true\n             }"}, {"sha": "7b178281415a1b019e4959d1970d9c103882b2d7", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f29ab8c2451e59153f956d01cb1f228663ef9054/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f29ab8c2451e59153f956d01cb1f228663ef9054/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=f29ab8c2451e59153f956d01cb1f228663ef9054", "patch": "@@ -4,7 +4,7 @@ use rustc::lint::*;\n use rustc::ty::TypeVariants;\n use syntax::ast::LitKind;\n use utils::paths;\n-use utils::{is_expn_of, match_path, match_type, span_lint, walk_ptrs_ty};\n+use utils::{is_expn_of, match_def_path, match_type, resolve_node, span_lint, walk_ptrs_ty};\n \n /// **What it does:** Checks for the use of `format!(\"string literal with no\n /// argument\")` and `format!(\"{}\", foo)` where `foo` is a string.\n@@ -44,9 +44,10 @@ impl LateLintPass for Pass {\n                 // `format!(\"{}\", foo)` expansion\n                 ExprCall(ref fun, ref args) => {\n                     if_let_chain!{[\n-                        let ExprPath(_, ref path) = fun.node,\n+                        let ExprPath(..) = fun.node,\n                         args.len() == 2,\n-                        match_path(path, &paths::FMT_ARGUMENTS_NEWV1),\n+                        let Some(fun) = resolve_node(cx, fun.id),\n+                        match_def_path(cx, fun.def_id(), &paths::FMT_ARGUMENTS_NEWV1),\n                         // ensure the format string is `\"{..}\"` with only one argument and no text\n                         check_static_str(cx, &args[0]),\n                         // ensure the format argument is `{}` ie. Display with no fancy option\n@@ -127,8 +128,9 @@ fn check_arg_is_display(cx: &LateContext, expr: &Expr) -> bool {\n         exprs.len() == 1,\n         let ExprCall(_, ref args) = exprs[0].node,\n         args.len() == 2,\n-        let ExprPath(None, ref path) = args[1].node,\n-        match_path(path, &paths::DISPLAY_FMT_METHOD)\n+        let ExprPath(None, _) = args[1].node,\n+        let Some(fun) = resolve_node(cx, args[1].id),\n+        match_def_path(cx, fun.def_id(), &paths::DISPLAY_FMT_METHOD),\n     ], {\n         let ty = walk_ptrs_ty(cx.tcx.pat_ty(&pat[0]));\n "}, {"sha": "14fe343d5a8f7e4bf6f046c96f408ab819091f5f", "filename": "clippy_lints/src/panic.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f29ab8c2451e59153f956d01cb1f228663ef9054/clippy_lints%2Fsrc%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f29ab8c2451e59153f956d01cb1f228663ef9054/clippy_lints%2Fsrc%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic.rs?ref=f29ab8c2451e59153f956d01cb1f228663ef9054", "patch": "@@ -1,7 +1,7 @@\n use rustc::hir::*;\n use rustc::lint::*;\n use syntax::ast::LitKind;\n-use utils::{is_direct_expn_of, match_path, paths, span_lint};\n+use utils::{is_direct_expn_of, match_def_path, resolve_node, paths, span_lint};\n \n /// **What it does:** Checks for missing parameters in `panic!`.\n ///\n@@ -39,8 +39,9 @@ impl LateLintPass for Pass {\n             let Some(ref ex) = block.expr,\n             let ExprCall(ref fun, ref params) = ex.node,\n             params.len() == 2,\n-            let ExprPath(None, ref path) = fun.node,\n-            match_path(path, &paths::BEGIN_PANIC),\n+            let ExprPath(None, _) = fun.node,\n+            let Some(fun) = resolve_node(cx, fun.id),\n+            match_def_path(cx, fun.def_id(), &paths::BEGIN_PANIC),\n             let ExprLit(ref lit) = params[0].node,\n             is_direct_expn_of(cx, params[0].span, \"panic\").is_some(),\n             let LitKind::Str(ref string, _) = lit.node,"}, {"sha": "46d38a67a863ca742bd477f4bc6d96ee7f80e992", "filename": "clippy_lints/src/print.rs", "status": "modified", "additions": 55, "deletions": 49, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/f29ab8c2451e59153f956d01cb1f228663ef9054/clippy_lints%2Fsrc%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f29ab8c2451e59153f956d01cb1f228663ef9054/clippy_lints%2Fsrc%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fprint.rs?ref=f29ab8c2451e59153f956d01cb1f228663ef9054", "patch": "@@ -2,7 +2,7 @@ use rustc::hir::*;\n use rustc::hir::map::Node::{NodeItem, NodeImplItem};\n use rustc::lint::*;\n use utils::paths;\n-use utils::{is_expn_of, match_path, span_lint};\n+use utils::{is_expn_of, match_path, match_def_path, resolve_node, span_lint};\n use format::get_argument_fmtstr_parts;\n \n /// **What it does:** This lint warns when you using `print!()` with a format string that\n@@ -67,63 +67,69 @@ impl LintPass for Pass {\n \n impl LateLintPass for Pass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n-        if let ExprCall(ref fun, ref args) = expr.node {\n-            if let ExprPath(_, ref path) = fun.node {\n-                // Search for `std::io::_print(..)` which is unique in a\n-                // `print!` expansion.\n-                if match_path(path, &paths::IO_PRINT) {\n-                    if let Some(span) = is_expn_of(cx, expr.span, \"print\") {\n-                        // `println!` uses `print!`.\n-                        let (span, name) = match is_expn_of(cx, span, \"println\") {\n-                            Some(span) => (span, \"println\"),\n-                            None => (span, \"print\"),\n-                        };\n+        if_let_chain! {[\n+            let ExprCall(ref fun, ref args) = expr.node,\n+            let ExprPath(..) = fun.node,\n+            let Some(fun) = resolve_node(cx, fun.id),\n+        ], {\n+            let fun_id = fun.def_id();\n \n-                        span_lint(cx, PRINT_STDOUT, span, &format!(\"use of `{}!`\", name));\n+            // Search for `std::io::_print(..)` which is unique in a\n+            // `print!` expansion.\n+            if match_def_path(cx, fun_id, &paths::IO_PRINT) {\n+                if let Some(span) = is_expn_of(cx, expr.span, \"print\") {\n+                    // `println!` uses `print!`.\n+                    let (span, name) = match is_expn_of(cx, span, \"println\") {\n+                        Some(span) => (span, \"println\"),\n+                        None => (span, \"print\"),\n+                    };\n \n-                        // Check print! with format string ending in \"\\n\".\n-                        if_let_chain!{[\n-                            name == \"print\",\n+                    span_lint(cx, PRINT_STDOUT, span, &format!(\"use of `{}!`\", name));\n \n-                            // ensure we're calling Arguments::new_v1\n-                            args.len() == 1,\n-                            let ExprCall(ref args_fun, ref args_args) = args[0].node,\n-                            let ExprPath(_, ref args_path) = args_fun.node,\n-                            match_path(args_path, &paths::FMT_ARGUMENTS_NEWV1),\n-                            args_args.len() == 2,\n-                            let ExprAddrOf(_, ref match_expr) = args_args[1].node,\n-                            let ExprMatch(ref args, _, _) = match_expr.node,\n-                            let ExprTup(ref args) = args.node,\n+                    // Check print! with format string ending in \"\\n\".\n+                    if_let_chain!{[\n+                        name == \"print\",\n \n-                            // collect the format string parts and check the last one\n-                            let Some(fmtstrs) = get_argument_fmtstr_parts(cx, &args_args[0]),\n-                            let Some(last_str) = fmtstrs.last(),\n-                            let Some('\\n') = last_str.chars().last(),\n+                        // ensure we're calling Arguments::new_v1\n+                        args.len() == 1,\n+                        let ExprCall(ref args_fun, ref args_args) = args[0].node,\n+                        let ExprPath(..) = args_fun.node,\n+                        let Some(def) = resolve_node(cx, args_fun.id),\n+                        match_def_path(cx, def.def_id(), &paths::FMT_ARGUMENTS_NEWV1),\n+                        args_args.len() == 2,\n+                        let ExprAddrOf(_, ref match_expr) = args_args[1].node,\n+                        let ExprMatch(ref args, _, _) = match_expr.node,\n+                        let ExprTup(ref args) = args.node,\n \n-                            // \"foo{}bar\" is made into two strings + one argument,\n-                            // if the format string starts with `{}` (eg. \"{}foo\"),\n-                            // the string array is prepended an empty string \"\".\n-                            // We only want to check the last string after any `{}`:\n-                            args.len() < fmtstrs.len(),\n-                        ], {\n-                            span_lint(cx, PRINT_WITH_NEWLINE, span,\n-                                      \"using `print!()` with a format string that ends in a \\\n-                                       newline, consider using `println!()` instead\");\n-                        }}\n-                    }\n+                        // collect the format string parts and check the last one\n+                        let Some(fmtstrs) = get_argument_fmtstr_parts(cx, &args_args[0]),\n+                        let Some(last_str) = fmtstrs.last(),\n+                        let Some('\\n') = last_str.chars().last(),\n+\n+                        // \"foo{}bar\" is made into two strings + one argument,\n+                        // if the format string starts with `{}` (eg. \"{}foo\"),\n+                        // the string array is prepended an empty string \"\".\n+                        // We only want to check the last string after any `{}`:\n+                        args.len() < fmtstrs.len(),\n+                    ], {\n+                        span_lint(cx, PRINT_WITH_NEWLINE, span,\n+                                  \"using `print!()` with a format string that ends in a \\\n+                                   newline, consider using `println!()` instead\");\n+                    }}\n                 }\n-                // Search for something like\n-                // `::std::fmt::ArgumentV1::new(__arg0, ::std::fmt::Debug::fmt)`\n-                else if args.len() == 2 && match_path(path, &paths::FMT_ARGUMENTV1_NEW) {\n-                    if let ExprPath(None, ref path) = args[1].node {\n-                        if match_path(path, &paths::DEBUG_FMT_METHOD) && !is_in_debug_impl(cx, expr) &&\n-                           is_expn_of(cx, expr.span, \"panic\").is_none() {\n-                            span_lint(cx, USE_DEBUG, args[0].span, \"use of `Debug`-based formatting\");\n-                        }\n+            }\n+            // Search for something like\n+            // `::std::fmt::ArgumentV1::new(__arg0, ::std::fmt::Debug::fmt)`\n+            else if args.len() == 2 && match_def_path(cx, fun_id, &paths::FMT_ARGUMENTV1_NEW) {\n+                if let ExprPath(None, _) = args[1].node {\n+                    let def_id = resolve_node(cx, args[1].id).unwrap().def_id();\n+                    if match_def_path(cx, def_id, &paths::DEBUG_FMT_METHOD) && !is_in_debug_impl(cx, expr) &&\n+                       is_expn_of(cx, expr.span, \"panic\").is_none() {\n+                        span_lint(cx, USE_DEBUG, args[0].span, \"use of `Debug`-based formatting\");\n                     }\n                 }\n             }\n-        }\n+        }}\n     }\n }\n "}, {"sha": "b9ce8626eb9bf3a5e6286d084af0aa492e2b8ec5", "filename": "clippy_lints/src/utils/cargo.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f29ab8c2451e59153f956d01cb1f228663ef9054/clippy_lints%2Fsrc%2Futils%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f29ab8c2451e59153f956d01cb1f228663ef9054/clippy_lints%2Fsrc%2Futils%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fcargo.rs?ref=f29ab8c2451e59153f956d01cb1f228663ef9054", "patch": "@@ -20,7 +20,7 @@ pub struct Package {\n     pub dependencies: Vec<Dependency>,\n     pub targets: Vec<Target>,\n     features: HashMap<String, Vec<String>>,\n-    manifest_path: String,\n+    pub manifest_path: String,\n }\n \n #[derive(RustcDecodable, Debug)]\n@@ -65,10 +65,10 @@ impl From<json::DecoderError> for Error {\n     }\n }\n \n-pub fn metadata(manifest_path: Option<String>) -> Result<Metadata, Error> {\n+pub fn metadata(manifest_path_arg: Option<&str>) -> Result<Metadata, Error> {\n     let mut cmd = Command::new(\"cargo\");\n     cmd.arg(\"metadata\").arg(\"--no-deps\");\n-    if let Some(ref mani) = manifest_path {\n+    if let Some(mani) = manifest_path_arg {\n         cmd.arg(mani);\n     }\n     let output = cmd.output()?;"}, {"sha": "d49cb7826aee40fd206b2c55319fdf1cf3a2305a", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f29ab8c2451e59153f956d01cb1f228663ef9054/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f29ab8c2451e59153f956d01cb1f228663ef9054/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=f29ab8c2451e59153f956d01cb1f228663ef9054", "patch": "@@ -6,7 +6,7 @@ use rustc::hir;\n use rustc::lint::LateContext;\n use syntax::ast;\n use syntax::ptr::P;\n-use utils::{is_expn_of, match_path, paths};\n+use utils::{is_expn_of, match_path, match_def_path, resolve_node, paths};\n \n /// Convert a hir binary operator to the corresponding `ast` type.\n pub fn binop(op: hir::BinOp_) -> ast::BinOpKind {\n@@ -170,9 +170,10 @@ pub fn vec_macro<'e>(cx: &LateContext, expr: &'e hir::Expr) -> Option<VecArgs<'e\n     if_let_chain!{[\n         let hir::ExprCall(ref fun, ref args) = expr.node,\n         let hir::ExprPath(_, ref path) = fun.node,\n-        is_expn_of(cx, fun.span, \"vec\").is_some()\n+        let Some(fun_def) = resolve_node(cx, fun.id),\n+        is_expn_of(cx, fun.span, \"vec\").is_some(),\n     ], {\n-        return if match_path(path, &paths::VEC_FROM_ELEM) && args.len() == 2 {\n+        return if match_def_path(cx, fun_def.def_id(), &paths::VEC_FROM_ELEM) && args.len() == 2 {\n             // `vec![elem; size]` case\n             Some(VecArgs::Repeat(&args[0], &args[1]))\n         }"}, {"sha": "ba57512fcd5b0ceb5143fda6f0dafdcc47ebf939", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f29ab8c2451e59153f956d01cb1f228663ef9054/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f29ab8c2451e59153f956d01cb1f228663ef9054/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=f29ab8c2451e59153f956d01cb1f228663ef9054", "patch": "@@ -280,6 +280,11 @@ pub fn implements_trait<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: ty::Ty<'tcx>,\n     })\n }\n \n+/// Resolve the definition of a node from its `NodeId`.\n+pub fn resolve_node(cx: &LateContext, id: NodeId) -> Option<def::Def> {\n+    cx.tcx.def_map.borrow().get(&id).map(|d| d.full_def())\n+}\n+\n /// Match an `Expr` against a chain of methods, and return the matched `Expr`s.\n ///\n /// For example, if `expr` represents the `.baz()` in `foo.bar().baz()`,"}, {"sha": "f182ed161637d12d536a668184df32d7c0708041", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f29ab8c2451e59153f956d01cb1f228663ef9054/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f29ab8c2451e59153f956d01cb1f228663ef9054/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=f29ab8c2451e59153f956d01cb1f228663ef9054", "patch": "@@ -1,6 +1,6 @@\n //! This module contains paths to types and functions Clippy needs to know about.\n \n-pub const BEGIN_PANIC: [&'static str; 3] = [\"std\", \"rt\", \"begin_panic\"];\n+pub const BEGIN_PANIC: [&'static str; 3] = [\"std\", \"panicking\", \"begin_panic\"];\n pub const BINARY_HEAP: [&'static str; 3] = [\"collections\", \"binary_heap\", \"BinaryHeap\"];\n pub const BOX: [&'static str; 3] = [\"std\", \"boxed\", \"Box\"];\n pub const BOX_NEW: [&'static str; 4] = [\"std\", \"boxed\", \"Box\", \"new\"];\n@@ -13,18 +13,18 @@ pub const CMP_MAX: [&'static str; 3] = [\"core\", \"cmp\", \"max\"];\n pub const CMP_MIN: [&'static str; 3] = [\"core\", \"cmp\", \"min\"];\n pub const COW: [&'static str; 3] = [\"collections\", \"borrow\", \"Cow\"];\n pub const CSTRING_NEW: [&'static str; 4] = [\"std\", \"ffi\", \"CString\", \"new\"];\n-pub const DEBUG_FMT_METHOD: [&'static str; 4] = [\"std\", \"fmt\", \"Debug\", \"fmt\"];\n+pub const DEBUG_FMT_METHOD: [&'static str; 4] = [\"core\", \"fmt\", \"Debug\", \"fmt\"];\n pub const DEFAULT_TRAIT: [&'static str; 3] = [\"core\", \"default\", \"Default\"];\n-pub const DISPLAY_FMT_METHOD: [&'static str; 4] = [\"std\", \"fmt\", \"Display\", \"fmt\"];\n+pub const DISPLAY_FMT_METHOD: [&'static str; 4] = [\"core\", \"fmt\", \"Display\", \"fmt\"];\n pub const DROP: [&'static str; 3] = [\"core\", \"mem\", \"drop\"];\n-pub const FMT_ARGUMENTS_NEWV1: [&'static str; 4] = [\"std\", \"fmt\", \"Arguments\", \"new_v1\"];\n-pub const FMT_ARGUMENTV1_NEW: [&'static str; 4] = [\"std\", \"fmt\", \"ArgumentV1\", \"new\"];\n+pub const FMT_ARGUMENTS_NEWV1: [&'static str; 4] = [\"core\", \"fmt\", \"Arguments\", \"new_v1\"];\n+pub const FMT_ARGUMENTV1_NEW: [&'static str; 4] = [\"core\", \"fmt\", \"ArgumentV1\", \"new\"];\n pub const HASH: [&'static str; 2] = [\"hash\", \"Hash\"];\n pub const HASHMAP: [&'static str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\"];\n pub const HASHMAP_ENTRY: [&'static str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"Entry\"];\n pub const HASHSET: [&'static str; 5] = [\"std\", \"collections\", \"hash\", \"set\", \"HashSet\"];\n pub const INTO_ITERATOR: [&'static str; 4] = [\"core\", \"iter\", \"traits\", \"IntoIterator\"];\n-pub const IO_PRINT: [&'static str; 3] = [\"std\", \"io\", \"_print\"];\n+pub const IO_PRINT: [&'static str; 4] = [\"std\", \"io\", \"stdio\", \"_print\"];\n pub const ITERATOR: [&'static str; 4] = [\"core\", \"iter\", \"iterator\", \"Iterator\"];\n pub const LINKED_LIST: [&'static str; 3] = [\"collections\", \"linked_list\", \"LinkedList\"];\n pub const LINT: [&'static str; 3] = [\"rustc\", \"lint\", \"Lint\"];\n@@ -64,4 +64,4 @@ pub const STRING: [&'static str; 3] = [\"collections\", \"string\", \"String\"];\n pub const TRANSMUTE: [&'static str; 4] = [\"core\", \"intrinsics\", \"\", \"transmute\"];\n pub const VEC: [&'static str; 3] = [\"collections\", \"vec\", \"Vec\"];\n pub const VEC_DEQUE: [&'static str; 3] = [\"collections\", \"vec_deque\", \"VecDeque\"];\n-pub const VEC_FROM_ELEM: [&'static str; 3] = [\"std\", \"vec\", \"from_elem\"];\n+pub const VEC_FROM_ELEM: [&'static str; 3] = [\"collections\", \"vec\", \"from_elem\"];"}, {"sha": "0eef99bfc12b39eab7a4878884083658850c652a", "filename": "src/main.rs", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f29ab8c2451e59153f956d01cb1f228663ef9054/src%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f29ab8c2451e59153f956d01cb1f228663ef9054/src%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmain.rs?ref=f29ab8c2451e59153f956d01cb1f228663ef9054", "patch": "@@ -138,10 +138,29 @@ pub fn main() {\n \n     if let Some(\"clippy\") = std::env::args().nth(1).as_ref().map(AsRef::as_ref) {\n         // this arm is executed on the initial call to `cargo clippy`\n-        let manifest_path = std::env::args().skip(2).find(|val| val.starts_with(\"--manifest-path=\"));\n-        let mut metadata = cargo::metadata(manifest_path).expect(\"could not obtain cargo metadata\");\n+        let manifest_path_arg = std::env::args().skip(2).find(|val| val.starts_with(\"--manifest-path=\"));\n+\n+        let mut metadata = cargo::metadata(manifest_path_arg.as_ref().map(AsRef::as_ref)).expect(\"could not obtain cargo metadata\");\n         assert_eq!(metadata.version, 1);\n-        for target in metadata.packages.remove(0).targets {\n+\n+        let manifest_path = manifest_path_arg.map(|arg| PathBuf::from(Path::new(&arg[\"--manifest-path=\".len()..])));\n+\n+        let current_dir = std::env::current_dir();\n+\n+        let package_index = metadata.packages.iter()\n+            .position(|package| {\n+                let package_manifest_path = Path::new(&package.manifest_path);\n+                if let Some(ref manifest_path) = manifest_path {\n+                    package_manifest_path == manifest_path\n+                } else {\n+                    let current_dir = current_dir.as_ref().expect(\"could not read current directory\");\n+                    let package_manifest_directory = package_manifest_path.parent().expect(\"could not find parent directory of package manifest\");\n+                    package_manifest_directory == current_dir\n+                }\n+            })\n+            .expect(\"could not find matching package\");\n+        let package = metadata.packages.remove(package_index);\n+        for target in package.targets {\n             let args = std::env::args().skip(2);\n             if let Some(first) = target.kind.get(0) {\n                 if target.kind.len() > 1 || first.ends_with(\"lib\") {"}, {"sha": "83b2acf7d815bbade57d0d821101aa138e642469", "filename": "tests/dogfood.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f29ab8c2451e59153f956d01cb1f228663ef9054/tests%2Fdogfood.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f29ab8c2451e59153f956d01cb1f228663ef9054/tests%2Fdogfood.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fdogfood.rs?ref=f29ab8c2451e59153f956d01cb1f228663ef9054", "patch": "@@ -24,7 +24,7 @@ fn dogfood() {\n     let mut s = String::new();\n     s.push_str(\" -L target/debug/\");\n     s.push_str(\" -L target/debug/deps\");\n-    s.push_str(\" -Zextra-plugins=clippy -Ltarget_recur/debug -Dclippy_pedantic -Dclippy -Dclippy_internal\");\n+    s.push_str(\" -Zextra-plugins=clippy -Ltarget_recur/debug -Dwarnings -Dclippy_pedantic -Dclippy -Dclippy_internal\");\n     config.target_rustcflags = Some(s);\n     if let Ok(name) = var(\"TESTNAME\") {\n         config.filter = Some(name.to_owned())"}]}