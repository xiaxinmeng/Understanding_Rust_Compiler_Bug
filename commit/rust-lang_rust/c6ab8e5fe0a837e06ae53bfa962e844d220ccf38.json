{"sha": "c6ab8e5fe0a837e06ae53bfa962e844d220ccf38", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2YWI4ZTVmZTBhODM3ZTA2YWU1M2JmYTk2MmU4NDRkMjIwY2NmMzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-18T23:38:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-18T23:38:17Z"}, "message": "Auto merge of #76787 - lzutao:slice_iters_new, r=lcnr\n\nUsing <Iter>::new instead of exposing internal fields\n\nAs requested in https://github.com/rust-lang/rust/pull/76311#discussion_r487685126", "tree": {"sha": "e65ebaefe4bfbf5a65eb554130c9cdcd60c61ef5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e65ebaefe4bfbf5a65eb554130c9cdcd60c61ef5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6ab8e5fe0a837e06ae53bfa962e844d220ccf38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6ab8e5fe0a837e06ae53bfa962e844d220ccf38", "html_url": "https://github.com/rust-lang/rust/commit/c6ab8e5fe0a837e06ae53bfa962e844d220ccf38", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6ab8e5fe0a837e06ae53bfa962e844d220ccf38/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bbc677480db8da85ea302e1e89d3df1f00e435bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbc677480db8da85ea302e1e89d3df1f00e435bf", "html_url": "https://github.com/rust-lang/rust/commit/bbc677480db8da85ea302e1e89d3df1f00e435bf"}, {"sha": "b65937031d7c5a1ad45c847e9d3d97c822c1ac81", "url": "https://api.github.com/repos/rust-lang/rust/commits/b65937031d7c5a1ad45c847e9d3d97c822c1ac81", "html_url": "https://github.com/rust-lang/rust/commit/b65937031d7c5a1ad45c847e9d3d97c822c1ac81"}], "stats": {"total": 470, "additions": 302, "deletions": 168}, "files": [{"sha": "546edef7f5753536c8cc9d38b055679453cd0c8e", "filename": "library/core/src/slice/iter.rs", "status": "modified", "additions": 276, "deletions": 57, "changes": 333, "blob_url": "https://github.com/rust-lang/rust/blob/c6ab8e5fe0a837e06ae53bfa962e844d220ccf38/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6ab8e5fe0a837e06ae53bfa962e844d220ccf38/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs?ref=c6ab8e5fe0a837e06ae53bfa962e844d220ccf38", "patch": "@@ -8,7 +8,7 @@ use crate::cmp::Ordering;\n use crate::fmt;\n use crate::intrinsics::{assume, exact_div, unchecked_sub};\n use crate::iter::{FusedIterator, TrustedLen, TrustedRandomAccess};\n-use crate::marker::{self, Send, Sized, Sync};\n+use crate::marker::{PhantomData, Send, Sized, Sync};\n use crate::mem;\n use crate::ptr::NonNull;\n \n@@ -62,11 +62,11 @@ fn size_from_ptr<T>(_: *const T) -> usize {\n /// [slices]: ../../std/primitive.slice.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, T: 'a> {\n-    pub(super) ptr: NonNull<T>,\n-    pub(super) end: *const T, // If T is a ZST, this is actually ptr+len.  This encoding is picked so that\n+    ptr: NonNull<T>,\n+    end: *const T, // If T is a ZST, this is actually ptr+len.  This encoding is picked so that\n     // ptr == end is a quick test for the Iterator being empty, that works\n     // for both ZST and non-ZST.\n-    pub(super) _marker: marker::PhantomData<&'a T>,\n+    _marker: PhantomData<&'a T>,\n }\n \n #[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n@@ -82,6 +82,23 @@ unsafe impl<T: Sync> Sync for Iter<'_, T> {}\n unsafe impl<T: Sync> Send for Iter<'_, T> {}\n \n impl<'a, T> Iter<'a, T> {\n+    #[inline]\n+    pub(super) fn new(slice: &'a [T]) -> Self {\n+        let ptr = slice.as_ptr();\n+        // SAFETY: Similar to `IterMut::new`.\n+        unsafe {\n+            assume(!ptr.is_null());\n+\n+            let end = if mem::size_of::<T>() == 0 {\n+                (ptr as *const u8).wrapping_add(slice.len()) as *const T\n+            } else {\n+                ptr.add(slice.len())\n+            };\n+\n+            Self { ptr: NonNull::new_unchecked(ptr as *mut T), end, _marker: PhantomData }\n+        }\n+    }\n+\n     /// Views the underlying data as a subslice of the original data.\n     ///\n     /// This has the same lifetime as the original slice, and so the\n@@ -164,11 +181,11 @@ impl<T> AsRef<[T]> for Iter<'_, T> {\n /// [slices]: ../../std/primitive.slice.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T: 'a> {\n-    pub(super) ptr: NonNull<T>,\n-    pub(super) end: *mut T, // If T is a ZST, this is actually ptr+len.  This encoding is picked so that\n+    ptr: NonNull<T>,\n+    end: *mut T, // If T is a ZST, this is actually ptr+len.  This encoding is picked so that\n     // ptr == end is a quick test for the Iterator being empty, that works\n     // for both ZST and non-ZST.\n-    pub(super) _marker: marker::PhantomData<&'a mut T>,\n+    _marker: PhantomData<&'a mut T>,\n }\n \n #[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n@@ -184,6 +201,38 @@ unsafe impl<T: Sync> Sync for IterMut<'_, T> {}\n unsafe impl<T: Send> Send for IterMut<'_, T> {}\n \n impl<'a, T> IterMut<'a, T> {\n+    #[inline]\n+    pub(super) fn new(slice: &'a mut [T]) -> Self {\n+        let ptr = slice.as_mut_ptr();\n+        // SAFETY: There are several things here:\n+        //\n+        // `ptr` has been obtained by `slice.as_ptr()` where `slice` is a valid\n+        // reference thus it is non-NUL and safe to use and pass to\n+        // `NonNull::new_unchecked` .\n+        //\n+        // Adding `slice.len()` to the starting pointer gives a pointer\n+        // at the end of `slice`. `end` will never be dereferenced, only checked\n+        // for direct pointer equality with `ptr` to check if the iterator is\n+        // done.\n+        //\n+        // In the case of a ZST, the end pointer is just the start pointer plus\n+        // the length, to also allows for the fast `ptr == end` check.\n+        //\n+        // See the `next_unchecked!` and `is_empty!` macros as well as the\n+        // `post_inc_start` method for more informations.\n+        unsafe {\n+            assume(!ptr.is_null());\n+\n+            let end = if mem::size_of::<T>() == 0 {\n+                (ptr as *mut u8).wrapping_add(slice.len()) as *mut T\n+            } else {\n+                ptr.add(slice.len())\n+            };\n+\n+            Self { ptr: NonNull::new_unchecked(ptr), end, _marker: PhantomData }\n+        }\n+    }\n+\n     /// Views the underlying data as a subslice of the original data.\n     ///\n     /// To avoid creating `&mut` references that alias, this is forced\n@@ -277,9 +326,16 @@ pub struct Split<'a, T: 'a, P>\n where\n     P: FnMut(&T) -> bool,\n {\n-    pub(super) v: &'a [T],\n-    pub(super) pred: P,\n-    pub(super) finished: bool,\n+    v: &'a [T],\n+    pred: P,\n+    finished: bool,\n+}\n+\n+impl<'a, T: 'a, P: FnMut(&T) -> bool> Split<'a, T, P> {\n+    #[inline]\n+    pub(super) fn new(slice: &'a [T], pred: P) -> Self {\n+        Self { v: slice, pred, finished: false }\n+    }\n }\n \n #[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n@@ -385,9 +441,16 @@ pub struct SplitInclusive<'a, T: 'a, P>\n where\n     P: FnMut(&T) -> bool,\n {\n-    pub(super) v: &'a [T],\n-    pub(super) pred: P,\n-    pub(super) finished: bool,\n+    v: &'a [T],\n+    pred: P,\n+    finished: bool,\n+}\n+\n+impl<'a, T: 'a, P: FnMut(&T) -> bool> SplitInclusive<'a, T, P> {\n+    #[inline]\n+    pub(super) fn new(slice: &'a [T], pred: P) -> Self {\n+        Self { v: slice, pred, finished: false }\n+    }\n }\n \n #[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n@@ -483,9 +546,16 @@ pub struct SplitMut<'a, T: 'a, P>\n where\n     P: FnMut(&T) -> bool,\n {\n-    pub(super) v: &'a mut [T],\n-    pub(super) pred: P,\n-    pub(super) finished: bool,\n+    v: &'a mut [T],\n+    pred: P,\n+    finished: bool,\n+}\n+\n+impl<'a, T: 'a, P: FnMut(&T) -> bool> SplitMut<'a, T, P> {\n+    #[inline]\n+    pub(super) fn new(slice: &'a mut [T], pred: P) -> Self {\n+        Self { v: slice, pred, finished: false }\n+    }\n }\n \n #[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n@@ -598,9 +668,16 @@ pub struct SplitInclusiveMut<'a, T: 'a, P>\n where\n     P: FnMut(&T) -> bool,\n {\n-    pub(super) v: &'a mut [T],\n-    pub(super) pred: P,\n-    pub(super) finished: bool,\n+    v: &'a mut [T],\n+    pred: P,\n+    finished: bool,\n+}\n+\n+impl<'a, T: 'a, P: FnMut(&T) -> bool> SplitInclusiveMut<'a, T, P> {\n+    #[inline]\n+    pub(super) fn new(slice: &'a mut [T], pred: P) -> Self {\n+        Self { v: slice, pred, finished: false }\n+    }\n }\n \n #[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n@@ -706,7 +783,14 @@ pub struct RSplit<'a, T: 'a, P>\n where\n     P: FnMut(&T) -> bool,\n {\n-    pub(super) inner: Split<'a, T, P>,\n+    inner: Split<'a, T, P>,\n+}\n+\n+impl<'a, T: 'a, P: FnMut(&T) -> bool> RSplit<'a, T, P> {\n+    #[inline]\n+    pub(super) fn new(slice: &'a [T], pred: P) -> Self {\n+        Self { inner: Split::new(slice, pred) }\n+    }\n }\n \n #[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\n@@ -777,7 +861,14 @@ pub struct RSplitMut<'a, T: 'a, P>\n where\n     P: FnMut(&T) -> bool,\n {\n-    pub(super) inner: SplitMut<'a, T, P>,\n+    inner: SplitMut<'a, T, P>,\n+}\n+\n+impl<'a, T: 'a, P: FnMut(&T) -> bool> RSplitMut<'a, T, P> {\n+    #[inline]\n+    pub(super) fn new(slice: &'a mut [T], pred: P) -> Self {\n+        Self { inner: SplitMut::new(slice, pred) }\n+    }\n }\n \n #[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\n@@ -840,9 +931,9 @@ impl<T, P> FusedIterator for RSplitMut<'_, T, P> where P: FnMut(&T) -> bool {}\n /// match a predicate function, splitting at most a fixed number of\n /// times.\n #[derive(Debug)]\n-pub(super) struct GenericSplitN<I> {\n-    pub(super) iter: I,\n-    pub(super) count: usize,\n+struct GenericSplitN<I> {\n+    iter: I,\n+    count: usize,\n }\n \n impl<T, I: SplitIter<Item = T>> Iterator for GenericSplitN<I> {\n@@ -882,7 +973,14 @@ pub struct SplitN<'a, T: 'a, P>\n where\n     P: FnMut(&T) -> bool,\n {\n-    pub(super) inner: GenericSplitN<Split<'a, T, P>>,\n+    inner: GenericSplitN<Split<'a, T, P>>,\n+}\n+\n+impl<'a, T: 'a, P: FnMut(&T) -> bool> SplitN<'a, T, P> {\n+    #[inline]\n+    pub(super) fn new(s: Split<'a, T, P>, n: usize) -> Self {\n+        Self { inner: GenericSplitN { iter: s, count: n } }\n+    }\n }\n \n #[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n@@ -908,7 +1006,14 @@ pub struct RSplitN<'a, T: 'a, P>\n where\n     P: FnMut(&T) -> bool,\n {\n-    pub(super) inner: GenericSplitN<RSplit<'a, T, P>>,\n+    inner: GenericSplitN<RSplit<'a, T, P>>,\n+}\n+\n+impl<'a, T: 'a, P: FnMut(&T) -> bool> RSplitN<'a, T, P> {\n+    #[inline]\n+    pub(super) fn new(s: RSplit<'a, T, P>, n: usize) -> Self {\n+        Self { inner: GenericSplitN { iter: s, count: n } }\n+    }\n }\n \n #[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n@@ -933,7 +1038,14 @@ pub struct SplitNMut<'a, T: 'a, P>\n where\n     P: FnMut(&T) -> bool,\n {\n-    pub(super) inner: GenericSplitN<SplitMut<'a, T, P>>,\n+    inner: GenericSplitN<SplitMut<'a, T, P>>,\n+}\n+\n+impl<'a, T: 'a, P: FnMut(&T) -> bool> SplitNMut<'a, T, P> {\n+    #[inline]\n+    pub(super) fn new(s: SplitMut<'a, T, P>, n: usize) -> Self {\n+        Self { inner: GenericSplitN { iter: s, count: n } }\n+    }\n }\n \n #[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n@@ -959,7 +1071,14 @@ pub struct RSplitNMut<'a, T: 'a, P>\n where\n     P: FnMut(&T) -> bool,\n {\n-    pub(super) inner: GenericSplitN<RSplitMut<'a, T, P>>,\n+    inner: GenericSplitN<RSplitMut<'a, T, P>>,\n+}\n+\n+impl<'a, T: 'a, P: FnMut(&T) -> bool> RSplitNMut<'a, T, P> {\n+    #[inline]\n+    pub(super) fn new(s: RSplitMut<'a, T, P>, n: usize) -> Self {\n+        Self { inner: GenericSplitN { iter: s, count: n } }\n+    }\n }\n \n #[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n@@ -986,8 +1105,15 @@ forward_iterator! { RSplitNMut: T, &'a mut [T] }\n #[derive(Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Windows<'a, T: 'a> {\n-    pub(super) v: &'a [T],\n-    pub(super) size: usize,\n+    v: &'a [T],\n+    size: usize,\n+}\n+\n+impl<'a, T: 'a> Windows<'a, T> {\n+    #[inline]\n+    pub(super) fn new(slice: &'a [T], size: usize) -> Self {\n+        Self { v: slice, size }\n+    }\n }\n \n // FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n@@ -1118,8 +1244,15 @@ unsafe impl<'a, T> TrustedRandomAccess for Windows<'a, T> {\n #[derive(Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Chunks<'a, T: 'a> {\n-    pub(super) v: &'a [T],\n-    pub(super) chunk_size: usize,\n+    v: &'a [T],\n+    chunk_size: usize,\n+}\n+\n+impl<'a, T: 'a> Chunks<'a, T> {\n+    #[inline]\n+    pub(super) fn new(slice: &'a [T], size: usize) -> Self {\n+        Self { v: slice, chunk_size: size }\n+    }\n }\n \n // FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n@@ -1272,8 +1405,15 @@ unsafe impl<'a, T> TrustedRandomAccess for Chunks<'a, T> {\n #[derive(Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct ChunksMut<'a, T: 'a> {\n-    pub(super) v: &'a mut [T],\n-    pub(super) chunk_size: usize,\n+    v: &'a mut [T],\n+    chunk_size: usize,\n+}\n+\n+impl<'a, T: 'a> ChunksMut<'a, T> {\n+    #[inline]\n+    pub(super) fn new(slice: &'a mut [T], size: usize) -> Self {\n+        Self { v: slice, chunk_size: size }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1425,12 +1565,21 @@ unsafe impl<'a, T> TrustedRandomAccess for ChunksMut<'a, T> {\n #[derive(Debug)]\n #[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n pub struct ChunksExact<'a, T: 'a> {\n-    pub(super) v: &'a [T],\n-    pub(super) rem: &'a [T],\n-    pub(super) chunk_size: usize,\n+    v: &'a [T],\n+    rem: &'a [T],\n+    chunk_size: usize,\n }\n \n impl<'a, T> ChunksExact<'a, T> {\n+    #[inline]\n+    pub(super) fn new(slice: &'a [T], chunk_size: usize) -> Self {\n+        let rem = slice.len() % chunk_size;\n+        let fst_len = slice.len() - rem;\n+        // SAFETY: 0 <= fst_len <= slice.len() by construction above\n+        let (fst, snd) = unsafe { slice.split_at_unchecked(fst_len) };\n+        Self { v: fst, rem: snd, chunk_size }\n+    }\n+\n     /// Returns the remainder of the original slice that is not going to be\n     /// returned by the iterator. The returned slice has at most `chunk_size-1`\n     /// elements.\n@@ -1565,12 +1714,21 @@ unsafe impl<'a, T> TrustedRandomAccess for ChunksExact<'a, T> {\n #[derive(Debug)]\n #[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n pub struct ChunksExactMut<'a, T: 'a> {\n-    pub(super) v: &'a mut [T],\n-    pub(super) rem: &'a mut [T],\n-    pub(super) chunk_size: usize,\n+    v: &'a mut [T],\n+    rem: &'a mut [T],\n+    chunk_size: usize,\n }\n \n impl<'a, T> ChunksExactMut<'a, T> {\n+    #[inline]\n+    pub(super) fn new(slice: &'a mut [T], chunk_size: usize) -> Self {\n+        let rem = slice.len() % chunk_size;\n+        let fst_len = slice.len() - rem;\n+        // SAFETY: 0 <= fst_len <= slice.len() by construction above\n+        let (fst, snd) = unsafe { slice.split_at_mut_unchecked(fst_len) };\n+        Self { v: fst, rem: snd, chunk_size }\n+    }\n+\n     /// Returns the remainder of the original slice that is not going to be\n     /// returned by the iterator. The returned slice has at most `chunk_size-1`\n     /// elements.\n@@ -1697,9 +1855,17 @@ unsafe impl<'a, T> TrustedRandomAccess for ChunksExactMut<'a, T> {\n #[derive(Debug, Clone, Copy)]\n #[unstable(feature = \"array_windows\", issue = \"75027\")]\n pub struct ArrayWindows<'a, T: 'a, const N: usize> {\n-    pub(crate) slice_head: *const T,\n-    pub(crate) num: usize,\n-    pub(crate) marker: marker::PhantomData<&'a [T; N]>,\n+    slice_head: *const T,\n+    num: usize,\n+    marker: PhantomData<&'a [T; N]>,\n+}\n+\n+impl<'a, T: 'a, const N: usize> ArrayWindows<'a, T, N> {\n+    #[inline]\n+    pub(super) fn new(slice: &'a [T]) -> Self {\n+        let num_windows = slice.len().saturating_sub(N - 1);\n+        Self { slice_head: slice.as_ptr(), num: num_windows, marker: PhantomData }\n+    }\n }\n \n #[unstable(feature = \"array_windows\", issue = \"75027\")]\n@@ -1802,11 +1968,22 @@ impl<T, const N: usize> ExactSizeIterator for ArrayWindows<'_, T, N> {\n #[derive(Debug)]\n #[unstable(feature = \"array_chunks\", issue = \"74985\")]\n pub struct ArrayChunks<'a, T: 'a, const N: usize> {\n-    pub(super) iter: Iter<'a, [T; N]>,\n-    pub(super) rem: &'a [T],\n+    iter: Iter<'a, [T; N]>,\n+    rem: &'a [T],\n }\n \n impl<'a, T, const N: usize> ArrayChunks<'a, T, N> {\n+    #[inline]\n+    pub(super) fn new(slice: &'a [T]) -> Self {\n+        let len = slice.len() / N;\n+        let (fst, snd) = slice.split_at(len * N);\n+        // SAFETY: We cast a slice of `len * N` elements into\n+        // a slice of `len` many `N` elements chunks.\n+        let array_slice: &[[T; N]] = unsafe { from_raw_parts(fst.as_ptr().cast(), len) };\n+\n+        Self { iter: array_slice.iter(), rem: snd }\n+    }\n+\n     /// Returns the remainder of the original slice that is not going to be\n     /// returned by the iterator. The returned slice has at most `N-1`\n     /// elements.\n@@ -1909,11 +2086,23 @@ unsafe impl<'a, T, const N: usize> TrustedRandomAccess for ArrayChunks<'a, T, N>\n #[derive(Debug)]\n #[unstable(feature = \"array_chunks\", issue = \"74985\")]\n pub struct ArrayChunksMut<'a, T: 'a, const N: usize> {\n-    pub(super) iter: IterMut<'a, [T; N]>,\n-    pub(super) rem: &'a mut [T],\n+    iter: IterMut<'a, [T; N]>,\n+    rem: &'a mut [T],\n }\n \n impl<'a, T, const N: usize> ArrayChunksMut<'a, T, N> {\n+    #[inline]\n+    pub(super) fn new(slice: &'a mut [T]) -> Self {\n+        let len = slice.len() / N;\n+        let (fst, snd) = slice.split_at_mut(len * N);\n+        // SAFETY: We cast a slice of `len * N` elements into\n+        // a slice of `len` many `N` elements chunks.\n+        unsafe {\n+            let array_slice: &mut [[T; N]] = from_raw_parts_mut(fst.as_mut_ptr().cast(), len);\n+            Self { iter: array_slice.iter_mut(), rem: snd }\n+        }\n+    }\n+\n     /// Returns the remainder of the original slice that is not going to be\n     /// returned by the iterator. The returned slice has at most `N-1`\n     /// elements.\n@@ -2006,8 +2195,15 @@ unsafe impl<'a, T, const N: usize> TrustedRandomAccess for ArrayChunksMut<'a, T,\n #[derive(Debug)]\n #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n pub struct RChunks<'a, T: 'a> {\n-    pub(super) v: &'a [T],\n-    pub(super) chunk_size: usize,\n+    v: &'a [T],\n+    chunk_size: usize,\n+}\n+\n+impl<'a, T: 'a> RChunks<'a, T> {\n+    #[inline]\n+    pub(super) fn new(slice: &'a [T], size: usize) -> Self {\n+        Self { v: slice, chunk_size: size }\n+    }\n }\n \n // FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n@@ -2156,8 +2352,15 @@ unsafe impl<'a, T> TrustedRandomAccess for RChunks<'a, T> {\n #[derive(Debug)]\n #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n pub struct RChunksMut<'a, T: 'a> {\n-    pub(super) v: &'a mut [T],\n-    pub(super) chunk_size: usize,\n+    v: &'a mut [T],\n+    chunk_size: usize,\n+}\n+\n+impl<'a, T: 'a> RChunksMut<'a, T> {\n+    #[inline]\n+    pub(super) fn new(slice: &'a mut [T], size: usize) -> Self {\n+        Self { v: slice, chunk_size: size }\n+    }\n }\n \n #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n@@ -2306,12 +2509,20 @@ unsafe impl<'a, T> TrustedRandomAccess for RChunksMut<'a, T> {\n #[derive(Debug)]\n #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n pub struct RChunksExact<'a, T: 'a> {\n-    pub(super) v: &'a [T],\n-    pub(super) rem: &'a [T],\n-    pub(super) chunk_size: usize,\n+    v: &'a [T],\n+    rem: &'a [T],\n+    chunk_size: usize,\n }\n \n impl<'a, T> RChunksExact<'a, T> {\n+    #[inline]\n+    pub(super) fn new(slice: &'a [T], chunk_size: usize) -> Self {\n+        let rem = slice.len() % chunk_size;\n+        // SAFETY: 0 <= rem <= slice.len() by construction above\n+        let (fst, snd) = unsafe { slice.split_at_unchecked(rem) };\n+        Self { v: snd, rem: fst, chunk_size }\n+    }\n+\n     /// Returns the remainder of the original slice that is not going to be\n     /// returned by the iterator. The returned slice has at most `chunk_size-1`\n     /// elements.\n@@ -2451,12 +2662,20 @@ unsafe impl<'a, T> TrustedRandomAccess for RChunksExact<'a, T> {\n #[derive(Debug)]\n #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n pub struct RChunksExactMut<'a, T: 'a> {\n-    pub(super) v: &'a mut [T],\n-    pub(super) rem: &'a mut [T],\n-    pub(super) chunk_size: usize,\n+    v: &'a mut [T],\n+    rem: &'a mut [T],\n+    chunk_size: usize,\n }\n \n impl<'a, T> RChunksExactMut<'a, T> {\n+    #[inline]\n+    pub(super) fn new(slice: &'a mut [T], chunk_size: usize) -> Self {\n+        let rem = slice.len() % chunk_size;\n+        // SAFETY: 0 <= rem <= slice.len() by construction above\n+        let (fst, snd) = unsafe { slice.split_at_mut_unchecked(rem) };\n+        Self { v: snd, rem: fst, chunk_size }\n+    }\n+\n     /// Returns the remainder of the original slice that is not going to be\n     /// returned by the iterator. The returned slice has at most `chunk_size-1`\n     /// elements."}, {"sha": "fd98f60c3ddc6348cd0abfecb2047f7900043feb", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 26, "deletions": 111, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/c6ab8e5fe0a837e06ae53bfa962e844d220ccf38/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6ab8e5fe0a837e06ae53bfa962e844d220ccf38/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=c6ab8e5fe0a837e06ae53bfa962e844d220ccf38", "patch": "@@ -9,13 +9,12 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use crate::cmp::Ordering::{self, Equal, Greater, Less};\n-use crate::intrinsics::assume;\n-use crate::marker::{self, Copy};\n+use crate::marker::Copy;\n use crate::mem;\n use crate::ops::{FnMut, Range, RangeBounds};\n use crate::option::Option;\n use crate::option::Option::{None, Some};\n-use crate::ptr::{self, NonNull};\n+use crate::ptr;\n use crate::result::Result;\n use crate::result::Result::{Err, Ok};\n \n@@ -35,8 +34,6 @@ mod raw;\n mod rotate;\n mod sort;\n \n-use iter::GenericSplitN;\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use iter::{Chunks, ChunksMut, Windows};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -681,34 +678,7 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn iter(&self) -> Iter<'_, T> {\n-        let ptr = self.as_ptr();\n-        // SAFETY: There are several things here:\n-        //\n-        // `ptr` has been obtained by `self.as_ptr()` where `self` is a valid\n-        // reference thus it is non-NUL and safe to use and pass to\n-        // `NonNull::new_unchecked` .\n-        //\n-        // Adding `self.len()` to the starting pointer gives a pointer\n-        // at the end of `self`. `end` will never be dereferenced, only checked\n-        // for direct pointer equality with `ptr` to check if the iterator is\n-        // done.\n-        //\n-        // In the case of a ZST, the end pointer is just the start pointer plus\n-        // the length, to also allows for the fast `ptr == end` check.\n-        //\n-        // See the `next_unchecked!` and `is_empty!` macros as well as the\n-        // `post_inc_start` method for more informations.\n-        unsafe {\n-            assume(!ptr.is_null());\n-\n-            let end = if mem::size_of::<T>() == 0 {\n-                (ptr as *const u8).wrapping_add(self.len()) as *const T\n-            } else {\n-                ptr.add(self.len())\n-            };\n-\n-            Iter { ptr: NonNull::new_unchecked(ptr as *mut T), end, _marker: marker::PhantomData }\n-        }\n+        Iter::new(self)\n     }\n \n     /// Returns an iterator that allows modifying each value.\n@@ -725,34 +695,7 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn iter_mut(&mut self) -> IterMut<'_, T> {\n-        let ptr = self.as_mut_ptr();\n-        // SAFETY: There are several things here:\n-        //\n-        // `ptr` has been obtained by `self.as_ptr()` where `self` is a valid\n-        // reference thus it is non-NUL and safe to use and pass to\n-        // `NonNull::new_unchecked` .\n-        //\n-        // Adding `self.len()` to the starting pointer gives a pointer\n-        // at the end of `self`. `end` will never be dereferenced, only checked\n-        // for direct pointer equality with `ptr` to check if the iterator is\n-        // done.\n-        //\n-        // In the case of a ZST, the end pointer is just the start pointer plus\n-        // the length, to also allows for the fast `ptr == end` check.\n-        //\n-        // See the `next_unchecked!` and `is_empty!` macros as well as the\n-        // `post_inc_start` method for more informations.\n-        unsafe {\n-            assume(!ptr.is_null());\n-\n-            let end = if mem::size_of::<T>() == 0 {\n-                (ptr as *mut u8).wrapping_add(self.len()) as *mut T\n-            } else {\n-                ptr.add(self.len())\n-            };\n-\n-            IterMut { ptr: NonNull::new_unchecked(ptr), end, _marker: marker::PhantomData }\n-        }\n+        IterMut::new(self)\n     }\n \n     /// Returns an iterator over all contiguous windows of length\n@@ -785,7 +728,7 @@ impl<T> [T] {\n     #[inline]\n     pub fn windows(&self, size: usize) -> Windows<'_, T> {\n         assert_ne!(size, 0);\n-        Windows { v: self, size }\n+        Windows::new(self, size)\n     }\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the\n@@ -819,7 +762,7 @@ impl<T> [T] {\n     #[inline]\n     pub fn chunks(&self, chunk_size: usize) -> Chunks<'_, T> {\n         assert_ne!(chunk_size, 0);\n-        Chunks { v: self, chunk_size }\n+        Chunks::new(self, chunk_size)\n     }\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the\n@@ -857,7 +800,7 @@ impl<T> [T] {\n     #[inline]\n     pub fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<'_, T> {\n         assert_ne!(chunk_size, 0);\n-        ChunksMut { v: self, chunk_size }\n+        ChunksMut::new(self, chunk_size)\n     }\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the\n@@ -894,11 +837,7 @@ impl<T> [T] {\n     #[inline]\n     pub fn chunks_exact(&self, chunk_size: usize) -> ChunksExact<'_, T> {\n         assert_ne!(chunk_size, 0);\n-        let rem = self.len() % chunk_size;\n-        let fst_len = self.len() - rem;\n-        // SAFETY: 0 <= fst_len <= self.len() by construction above\n-        let (fst, snd) = unsafe { self.split_at_unchecked(fst_len) };\n-        ChunksExact { v: fst, rem: snd, chunk_size }\n+        ChunksExact::new(self, chunk_size)\n     }\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the\n@@ -940,11 +879,7 @@ impl<T> [T] {\n     #[inline]\n     pub fn chunks_exact_mut(&mut self, chunk_size: usize) -> ChunksExactMut<'_, T> {\n         assert_ne!(chunk_size, 0);\n-        let rem = self.len() % chunk_size;\n-        let fst_len = self.len() - rem;\n-        // SAFETY: 0 <= fst_len <= self.len() by construction above\n-        let (fst, snd) = unsafe { self.split_at_mut_unchecked(fst_len) };\n-        ChunksExactMut { v: fst, rem: snd, chunk_size }\n+        ChunksExactMut::new(self, chunk_size)\n     }\n \n     /// Returns an iterator over `N` elements of the slice at a time, starting at the\n@@ -978,12 +913,7 @@ impl<T> [T] {\n     #[inline]\n     pub fn array_chunks<const N: usize>(&self) -> ArrayChunks<'_, T, N> {\n         assert_ne!(N, 0);\n-        let len = self.len() / N;\n-        let (fst, snd) = self.split_at(len * N);\n-        // SAFETY: We cast a slice of `len * N` elements into\n-        // a slice of `len` many `N` elements chunks.\n-        let array_slice: &[[T; N]] = unsafe { from_raw_parts(fst.as_ptr().cast(), len) };\n-        ArrayChunks { iter: array_slice.iter(), rem: snd }\n+        ArrayChunks::new(self)\n     }\n \n     /// Returns an iterator over `N` elements of the slice at a time, starting at the\n@@ -1019,14 +949,7 @@ impl<T> [T] {\n     #[inline]\n     pub fn array_chunks_mut<const N: usize>(&mut self) -> ArrayChunksMut<'_, T, N> {\n         assert_ne!(N, 0);\n-        let len = self.len() / N;\n-        let (fst, snd) = self.split_at_mut(len * N);\n-        // SAFETY: We cast a slice of `len * N` elements into\n-        // a slice of `len` many `N` elements chunks.\n-        unsafe {\n-            let array_slice: &mut [[T; N]] = from_raw_parts_mut(fst.as_mut_ptr().cast(), len);\n-            ArrayChunksMut { iter: array_slice.iter_mut(), rem: snd }\n-        }\n+        ArrayChunksMut::new(self)\n     }\n \n     /// Returns an iterator over overlapping windows of `N` elements of  a slice,\n@@ -1058,9 +981,7 @@ impl<T> [T] {\n     #[inline]\n     pub fn array_windows<const N: usize>(&self) -> ArrayWindows<'_, T, N> {\n         assert_ne!(N, 0);\n-\n-        let num_windows = self.len().saturating_sub(N - 1);\n-        ArrayWindows { slice_head: self.as_ptr(), num: num_windows, marker: marker::PhantomData }\n+        ArrayWindows::new(self)\n     }\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the end\n@@ -1094,7 +1015,7 @@ impl<T> [T] {\n     #[inline]\n     pub fn rchunks(&self, chunk_size: usize) -> RChunks<'_, T> {\n         assert!(chunk_size != 0);\n-        RChunks { v: self, chunk_size }\n+        RChunks::new(self, chunk_size)\n     }\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the end\n@@ -1132,7 +1053,7 @@ impl<T> [T] {\n     #[inline]\n     pub fn rchunks_mut(&mut self, chunk_size: usize) -> RChunksMut<'_, T> {\n         assert!(chunk_size != 0);\n-        RChunksMut { v: self, chunk_size }\n+        RChunksMut::new(self, chunk_size)\n     }\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the\n@@ -1171,10 +1092,7 @@ impl<T> [T] {\n     #[inline]\n     pub fn rchunks_exact(&self, chunk_size: usize) -> RChunksExact<'_, T> {\n         assert!(chunk_size != 0);\n-        let rem = self.len() % chunk_size;\n-        // SAFETY: 0 <= rem <= self.len() by construction above\n-        let (fst, snd) = unsafe { self.split_at_unchecked(rem) };\n-        RChunksExact { v: snd, rem: fst, chunk_size }\n+        RChunksExact::new(self, chunk_size)\n     }\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the end\n@@ -1217,10 +1135,7 @@ impl<T> [T] {\n     #[inline]\n     pub fn rchunks_exact_mut(&mut self, chunk_size: usize) -> RChunksExactMut<'_, T> {\n         assert!(chunk_size != 0);\n-        let rem = self.len() % chunk_size;\n-        // SAFETY: 0 <= rem <= self.len() by construction above\n-        let (fst, snd) = unsafe { self.split_at_mut_unchecked(rem) };\n-        RChunksExactMut { v: snd, rem: fst, chunk_size }\n+        RChunksExactMut::new(self, chunk_size)\n     }\n \n     /// Divides one slice into two at an index.\n@@ -1439,7 +1354,7 @@ impl<T> [T] {\n     where\n         F: FnMut(&T) -> bool,\n     {\n-        Split { v: self, pred, finished: false }\n+        Split::new(self, pred)\n     }\n \n     /// Returns an iterator over mutable subslices separated by elements that\n@@ -1461,7 +1376,7 @@ impl<T> [T] {\n     where\n         F: FnMut(&T) -> bool,\n     {\n-        SplitMut { v: self, pred, finished: false }\n+        SplitMut::new(self, pred)\n     }\n \n     /// Returns an iterator over subslices separated by elements that match\n@@ -1499,7 +1414,7 @@ impl<T> [T] {\n     where\n         F: FnMut(&T) -> bool,\n     {\n-        SplitInclusive { v: self, pred, finished: false }\n+        SplitInclusive::new(self, pred)\n     }\n \n     /// Returns an iterator over mutable subslices separated by elements that\n@@ -1524,7 +1439,7 @@ impl<T> [T] {\n     where\n         F: FnMut(&T) -> bool,\n     {\n-        SplitInclusiveMut { v: self, pred, finished: false }\n+        SplitInclusiveMut::new(self, pred)\n     }\n \n     /// Returns an iterator over subslices separated by elements that match\n@@ -1560,7 +1475,7 @@ impl<T> [T] {\n     where\n         F: FnMut(&T) -> bool,\n     {\n-        RSplit { inner: self.split(pred) }\n+        RSplit::new(self, pred)\n     }\n \n     /// Returns an iterator over mutable subslices separated by elements that\n@@ -1586,7 +1501,7 @@ impl<T> [T] {\n     where\n         F: FnMut(&T) -> bool,\n     {\n-        RSplitMut { inner: self.split_mut(pred) }\n+        RSplitMut::new(self, pred)\n     }\n \n     /// Returns an iterator over subslices separated by elements that match\n@@ -1614,7 +1529,7 @@ impl<T> [T] {\n     where\n         F: FnMut(&T) -> bool,\n     {\n-        SplitN { inner: GenericSplitN { iter: self.split(pred), count: n } }\n+        SplitN::new(self.split(pred), n)\n     }\n \n     /// Returns an iterator over subslices separated by elements that match\n@@ -1640,7 +1555,7 @@ impl<T> [T] {\n     where\n         F: FnMut(&T) -> bool,\n     {\n-        SplitNMut { inner: GenericSplitN { iter: self.split_mut(pred), count: n } }\n+        SplitNMut::new(self.split_mut(pred), n)\n     }\n \n     /// Returns an iterator over subslices separated by elements that match\n@@ -1669,7 +1584,7 @@ impl<T> [T] {\n     where\n         F: FnMut(&T) -> bool,\n     {\n-        RSplitN { inner: GenericSplitN { iter: self.rsplit(pred), count: n } }\n+        RSplitN::new(self.rsplit(pred), n)\n     }\n \n     /// Returns an iterator over subslices separated by elements that match\n@@ -1696,7 +1611,7 @@ impl<T> [T] {\n     where\n         F: FnMut(&T) -> bool,\n     {\n-        RSplitNMut { inner: GenericSplitN { iter: self.rsplit_mut(pred), count: n } }\n+        RSplitNMut::new(self.rsplit_mut(pred), n)\n     }\n \n     /// Returns `true` if the slice contains an element with the given value."}]}