{"sha": "68a32aad1ab60b29ebfffd7c2f8d5967371955fc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4YTMyYWFkMWFiNjBiMjllYmZmZmQ3YzJmOGQ1OTY3MzcxOTU1ZmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-14T22:55:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-14T22:55:20Z"}, "message": "auto merge of #7716 : kballard/rust/term-attr, r=cmr\n\nTeach `extra::term` to support more terminal attributes than just color.\r\n\r\nFix the compiler diagnostic messages to print in bold instead of bright white. This matches Clang's output.\r\n\r\nCache the term::Terminal instead of re-parsing for every diagnostic (fixes #6827).", "tree": {"sha": "62ece0bc2d2668d51ea96e1a4384a6ece703d831", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/62ece0bc2d2668d51ea96e1a4384a6ece703d831"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68a32aad1ab60b29ebfffd7c2f8d5967371955fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68a32aad1ab60b29ebfffd7c2f8d5967371955fc", "html_url": "https://github.com/rust-lang/rust/commit/68a32aad1ab60b29ebfffd7c2f8d5967371955fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68a32aad1ab60b29ebfffd7c2f8d5967371955fc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f333023e9d2d0b7a8d2c62df836158c880845b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f333023e9d2d0b7a8d2c62df836158c880845b4", "html_url": "https://github.com/rust-lang/rust/commit/4f333023e9d2d0b7a8d2c62df836158c880845b4"}, {"sha": "1d4c3146f5e35ce60db73849da8806d73c6ecee2", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d4c3146f5e35ce60db73849da8806d73c6ecee2", "html_url": "https://github.com/rust-lang/rust/commit/1d4c3146f5e35ce60db73849da8806d73c6ecee2"}], "stats": {"total": 177, "additions": 154, "deletions": 23}, "files": [{"sha": "1cfb4f4afa6277b6df7b3b64b4c570fe070b720a", "filename": "src/libextra/term.rs", "status": "modified", "additions": 122, "deletions": 9, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/68a32aad1ab60b29ebfffd7c2f8d5967371955fc/src%2Flibextra%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68a32aad1ab60b29ebfffd7c2f8d5967371955fc/src%2Flibextra%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterm.rs?ref=68a32aad1ab60b29ebfffd7c2f8d5967371955fc", "patch": "@@ -45,6 +45,54 @@ pub mod color {\n     pub static BRIGHT_WHITE:   Color = 15u16;\n }\n \n+pub mod attr {\n+    /// Terminal attributes for use with term.attr().\n+    /// Most attributes can only be turned on and must be turned off with term.reset().\n+    /// The ones that can be turned off explicitly take a boolean value.\n+    /// Color is also represented as an attribute for convenience.\n+    pub enum Attr {\n+        /// Bold (or possibly bright) mode\n+        Bold,\n+        /// Dim mode, also called faint or half-bright. Often not supported\n+        Dim,\n+        /// Italics mode. Often not supported\n+        Italic(bool),\n+        /// Underline mode\n+        Underline(bool),\n+        /// Blink mode\n+        Blink,\n+        /// Standout mode. Often implemented as Reverse, sometimes coupled with Bold\n+        Standout(bool),\n+        /// Reverse mode, inverts the foreground and background colors\n+        Reverse,\n+        /// Secure mode, also called invis mode. Hides the printed text\n+        Secure,\n+        /// Convenience attribute to set the foreground color\n+        ForegroundColor(super::color::Color),\n+        /// Convenience attribute to set the background color\n+        BackgroundColor(super::color::Color)\n+    }\n+}\n+\n+#[cfg(not(target_os = \"win32\"))]\n+priv fn cap_for_attr(attr: attr::Attr) -> &'static str {\n+    match attr {\n+        attr::Bold               => \"bold\",\n+        attr::Dim                => \"dim\",\n+        attr::Italic(true)       => \"sitm\",\n+        attr::Italic(false)      => \"ritm\",\n+        attr::Underline(true)    => \"smul\",\n+        attr::Underline(false)   => \"rmul\",\n+        attr::Blink              => \"blink\",\n+        attr::Standout(true)     => \"smso\",\n+        attr::Standout(false)    => \"rmso\",\n+        attr::Reverse            => \"rev\",\n+        attr::Secure             => \"invis\",\n+        attr::ForegroundColor(_) => \"setaf\",\n+        attr::BackgroundColor(_) => \"setab\"\n+    }\n+}\n+\n #[cfg(not(target_os = \"win32\"))]\n pub struct Terminal {\n     num_colors: u16,\n@@ -88,45 +136,100 @@ impl Terminal {\n     ///\n     /// If the color is a bright color, but the terminal only supports 8 colors,\n     /// the corresponding normal color will be used instead.\n-    pub fn fg(&self, color: color::Color) {\n+    ///\n+    /// Returns true if the color was set, false otherwise.\n+    pub fn fg(&self, color: color::Color) -> bool {\n         let color = self.dim_if_necessary(color);\n         if self.num_colors > color {\n             let s = expand(*self.ti.strings.find_equiv(&(\"setaf\")).unwrap(),\n                            [Number(color as int)], &mut Variables::new());\n             if s.is_ok() {\n                 self.out.write(s.unwrap());\n+                return true\n             } else {\n                 warn!(\"%s\", s.unwrap_err());\n             }\n         }\n+        false\n     }\n     /// Sets the background color to the given color.\n     ///\n     /// If the color is a bright color, but the terminal only supports 8 colors,\n     /// the corresponding normal color will be used instead.\n-    pub fn bg(&self, color: color::Color) {\n+    ///\n+    /// Rturns true if the color was set, false otherwise.\n+    pub fn bg(&self, color: color::Color) -> bool {\n         let color = self.dim_if_necessary(color);\n         if self.num_colors > color {\n             let s = expand(*self.ti.strings.find_equiv(&(\"setab\")).unwrap(),\n                            [Number(color as int)], &mut Variables::new());\n             if s.is_ok() {\n                 self.out.write(s.unwrap());\n+                return true\n             } else {\n                 warn!(\"%s\", s.unwrap_err());\n             }\n         }\n+        false\n+    }\n+\n+    /// Sets the given terminal attribute, if supported.\n+    /// Returns true if the attribute was supported, false otherwise.\n+    pub fn attr(&self, attr: attr::Attr) -> bool {\n+        match attr {\n+            attr::ForegroundColor(c) => self.fg(c),\n+            attr::BackgroundColor(c) => self.bg(c),\n+            _ => {\n+                let cap = cap_for_attr(attr);\n+                let parm = self.ti.strings.find_equiv(&cap);\n+                if parm.is_some() {\n+                    let s = expand(*parm.unwrap(), [], &mut Variables::new());\n+                    if s.is_ok() {\n+                        self.out.write(s.unwrap());\n+                        return true\n+                    } else {\n+                        warn!(\"%s\", s.unwrap_err());\n+                    }\n+                }\n+                false\n+            }\n+        }\n     }\n+\n+    /// Returns whether the given terminal attribute is supported.\n+    pub fn supports_attr(&self, attr: attr::Attr) -> bool {\n+        match attr {\n+            attr::ForegroundColor(_) | attr::BackgroundColor(_) => {\n+                self.num_colors > 0\n+            }\n+            _ => {\n+                let cap = cap_for_attr(attr);\n+                self.ti.strings.find_equiv(&cap).is_some()\n+            }\n+        }\n+    }\n+\n+    /// Resets all terminal attributes and color to the default.\n     pub fn reset(&self) {\n-        let mut vars = Variables::new();\n-        let s = do self.ti.strings.find_equiv(&(\"op\"))\n-                       .map_consume_default(Err(~\"can't find terminfo capability `op`\")) |op| {\n-                           expand(copy *op, [], &mut vars)\n-                       };\n+        let mut cap = self.ti.strings.find_equiv(&(\"sgr0\"));\n+        if cap.is_none() {\n+            // are there any terminals that have color/attrs and not sgr0?\n+            // Try falling back to sgr, then op\n+            cap = self.ti.strings.find_equiv(&(\"sgr\"));\n+            if cap.is_none() {\n+                cap = self.ti.strings.find_equiv(&(\"op\"));\n+            }\n+        }\n+        let s = do cap.map_consume_default(Err(~\"can't find terminfo capability `sgr0`\")) |op| {\n+            expand(*op, [], &mut Variables::new())\n+        };\n         if s.is_ok() {\n             self.out.write(s.unwrap());\n         } else if self.num_colors > 0 {\n             warn!(\"%s\", s.unwrap_err());\n         } else {\n+            // if we support attributes but not color, it would be nice to still warn!()\n+            // but it's not worth testing all known attributes just for this.\n             debug!(\"%s\", s.unwrap_err());\n         }\n     }\n@@ -144,10 +247,20 @@ impl Terminal {\n         return Ok(Terminal {out: out, num_colors: 0});\n     }\n \n-    pub fn fg(&self, _color: color::Color) {\n+    pub fn fg(&self, _color: color::Color) -> bool {\n+        false\n+    }\n+\n+    pub fn bg(&self, _color: color::Color) -> bool {\n+        false\n+    }\n+\n+    pub fn attr(&self, _attr: attr::Attr) -> bool {\n+        false\n     }\n \n-    pub fn bg(&self, _color: color::Color) {\n+    pub fn supports_attr(&self, _attr: attr::Attr) -> bool {\n+        false\n     }\n \n     pub fn reset(&self) {"}, {"sha": "2971ad5cc29422f73e29ebde451561804b168b59", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 32, "deletions": 14, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/68a32aad1ab60b29ebfffd7c2f8d5967371955fc/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68a32aad1ab60b29ebfffd7c2f8d5967371955fc/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=68a32aad1ab60b29ebfffd7c2f8d5967371955fc", "patch": "@@ -13,6 +13,7 @@ use codemap;\n \n use std::io;\n use std::uint;\n+use std::local_data;\n use extra::term;\n \n pub type Emitter = @fn(cmsp: Option<(@codemap::CodeMap, span)>,\n@@ -186,22 +187,38 @@ fn diagnosticcolor(lvl: level) -> term::color::Color {\n     }\n }\n \n-fn print_maybe_colored(msg: &str, color: term::color::Color) {\n+fn print_maybe_styled(msg: &str, color: term::attr::Attr) {\n+    #[cfg(not(stage0))]\n+    static tls_terminal: local_data::Key<@Option<term::Terminal>> = &local_data::Key;\n+    #[cfg(stage0)]\n+    fn tls_terminal(_: @Option<term::Terminal>) {}\n+\n     let stderr = io::stderr();\n \n-    let t = term::Terminal::new(stderr);\n+    if stderr.get_type() == io::Screen {\n+        let t = match local_data::get(tls_terminal, |v| v.map_consume(|&k|k)) {\n+            None => {\n+                let t = term::Terminal::new(stderr);\n+                let tls = @match t {\n+                    Ok(t) => Some(t),\n+                    Err(_) => None\n+                };\n+                local_data::set(tls_terminal, tls);\n+                &*tls\n+            }\n+            Some(tls) => &*tls\n+        };\n \n-    match t {\n-        Ok(term) => {\n-            if stderr.get_type() == io::Screen {\n-                term.fg(color);\n+        match t {\n+            &Some(ref term) => {\n+                term.attr(color);\n                 stderr.write_str(msg);\n                 term.reset();\n-            } else {\n-                stderr.write_str(msg);\n-            }\n-        },\n-        _ => stderr.write_str(msg)\n+            },\n+            _ => stderr.write_str(msg)\n+        }\n+    } else {\n+        stderr.write_str(msg);\n     }\n }\n \n@@ -212,8 +229,9 @@ fn print_diagnostic(topic: &str, lvl: level, msg: &str) {\n         stderr.write_str(fmt!(\"%s \", topic));\n     }\n \n-    print_maybe_colored(fmt!(\"%s: \", diagnosticstr(lvl)), diagnosticcolor(lvl));\n-    print_maybe_colored(fmt!(\"%s\\n\", msg), term::color::BRIGHT_WHITE);\n+    print_maybe_styled(fmt!(\"%s: \", diagnosticstr(lvl)),\n+                            term::attr::ForegroundColor(diagnosticcolor(lvl)));\n+    print_maybe_styled(fmt!(\"%s\\n\", msg), term::attr::Bold);\n }\n \n pub fn collect(messages: @mut ~[~str])\n@@ -312,7 +330,7 @@ fn highlight_lines(cm: @codemap::CodeMap,\n                 s.push_char('~')\n             }\n         }\n-        print_maybe_colored(s + \"\\n\", diagnosticcolor(lvl));\n+        print_maybe_styled(s + \"\\n\", term::attr::ForegroundColor(diagnosticcolor(lvl)));\n     }\n }\n "}]}