{"sha": "832fe327218e556740ba4e028b7b60cb41212469", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzMmZlMzI3MjE4ZTU1Njc0MGJhNGUwMjhiN2I2MGNiNDEyMTI0Njk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-24T05:40:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-24T05:40:53Z"}, "message": "auto merge of #7207 : DaGenix/rust/sha2, r=pcwalton\n\nThis pull request contains an unoptimized implementation of most of the SHA-2 functions (everything but the variable output size versions). I also created a common trait (Digest) for all of the interesting methods for working with digests and updated the existing SHA-1 code to use it. Finally, while working with the SHA-1 code, I got rid of the use of @ types and type objects.\r\n\r\nI've tested all functions against the Wikipedia test vectors. Additionally, I tested the SHA-512, 384, and 256 variants against the Java implementations of those digests.\r\n\r\nI did my best to try to follow Rust conventions, but, there are so many different conventions in the code base right now that I'm not sure if I'm following the correct one or not. Anyway, I'm happy to rework if I didn't get the coding convention right (or if there are bugs!).", "tree": {"sha": "1adfee92371140df3490fbcd9c198cf3c9fa98e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1adfee92371140df3490fbcd9c198cf3c9fa98e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/832fe327218e556740ba4e028b7b60cb41212469", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/832fe327218e556740ba4e028b7b60cb41212469", "html_url": "https://github.com/rust-lang/rust/commit/832fe327218e556740ba4e028b7b60cb41212469", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/832fe327218e556740ba4e028b7b60cb41212469/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac4211ef52a3577f901ed4dc7f370b05ca4e638d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac4211ef52a3577f901ed4dc7f370b05ca4e638d", "html_url": "https://github.com/rust-lang/rust/commit/ac4211ef52a3577f901ed4dc7f370b05ca4e638d"}, {"sha": "711273f5b49bacb843d672884522cd6961037669", "url": "https://api.github.com/repos/rust-lang/rust/commits/711273f5b49bacb843d672884522cd6961037669", "html_url": "https://github.com/rust-lang/rust/commit/711273f5b49bacb843d672884522cd6961037669"}], "stats": {"total": 2018, "additions": 1600, "deletions": 418}, "files": [{"sha": "60169b347ad84f61c4ab1ccce66e88ad4a98bbd4", "filename": "RELEASES.txt", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/832fe327218e556740ba4e028b7b60cb41212469/RELEASES.txt", "raw_url": "https://github.com/rust-lang/rust/raw/832fe327218e556740ba4e028b7b60cb41212469/RELEASES.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.txt?ref=832fe327218e556740ba4e028b7b60cb41212469", "patch": "@@ -78,6 +78,7 @@ Version 0.7 (July 2013)\n       * extra: `BigInt`, `BigUint` implement numeric and comparison traits.\n       * extra: `term` uses terminfo now, is more correct.\n       * extra: `arc` functions converted to methods.\n+      * extra: Implementation of fixed output size variations of SHA-2.\n \n    * Tooling\n       * `unused_unsafe` lint mode for detecting unnecessary `unsafe` blocks."}, {"sha": "8fd44bfc9abc46c17c942cb736f8c1faf8179bb4", "filename": "src/libextra/crypto/digest.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/832fe327218e556740ba4e028b7b60cb41212469/src%2Flibextra%2Fcrypto%2Fdigest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/832fe327218e556740ba4e028b7b60cb41212469/src%2Flibextra%2Fcrypto%2Fdigest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fdigest.rs?ref=832fe327218e556740ba4e028b7b60cb41212469", "patch": "@@ -0,0 +1,88 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::prelude::*;\n+\n+use core::uint;\n+use core::vec;\n+\n+/**\n+ * The Digest trait specifies an interface common to digest functions, such as SHA-1 and the SHA-2\n+ * family of digest functions.\n+ */\n+pub trait Digest {\n+    /**\n+     * Provide message data.\n+     *\n+     * # Arguments\n+     *\n+     * * input - A vector of message data\n+     */\n+    fn input(&mut self, input: &[u8]);\n+\n+    /**\n+     * Retrieve the digest result. This method may be called multiple times.\n+     */\n+    fn result(&mut self, out: &mut [u8]);\n+\n+    /**\n+     * Reset the digest. This method must be called after result() and before supplying more\n+     * data.\n+     */\n+    fn reset(&mut self);\n+\n+    /**\n+     * Get the output size in bits.\n+     */\n+    fn output_bits(&self) -> uint;\n+}\n+\n+fn to_hex(rr: &[u8]) -> ~str {\n+    let mut s = ~\"\";\n+    for rr.iter().advance() |b| {\n+        let hex = uint::to_str_radix(*b as uint, 16u);\n+        if hex.len() == 1 {\n+            s += \"0\";\n+        }\n+        s += hex;\n+    }\n+    return s;\n+}\n+\n+/// Contains utility methods for Digests.\n+/// FIXME: #7339: Convert to default methods when issues with them are resolved.\n+pub trait DigestUtil {\n+    /**\n+     * Convenience functon that feeds a string into a digest\n+     *\n+     * # Arguments\n+     *\n+     * * in The string to feed into the digest\n+     */\n+    fn input_str(&mut self, in: &str);\n+\n+    /**\n+     * Convenience functon that retrieves the result of a digest as a\n+     * ~str in hexadecimal format.\n+     */\n+    fn result_str(&mut self) -> ~str;\n+}\n+\n+impl<D: Digest> DigestUtil for D {\n+    fn input_str(&mut self, in: &str) {\n+        self.input(in.as_bytes());\n+    }\n+\n+    fn result_str(&mut self) -> ~str {\n+        let mut buf = vec::from_elem((self.output_bits()+7)/8, 0u8);\n+        self.result(buf);\n+        return to_hex(buf);\n+    }\n+}"}, {"sha": "5a67e08c1900814b6f0b8d2207af2dbd0a7135c2", "filename": "src/libextra/crypto/sha1.rs", "status": "added", "additions": 370, "deletions": 0, "changes": 370, "blob_url": "https://github.com/rust-lang/rust/blob/832fe327218e556740ba4e028b7b60cb41212469/src%2Flibextra%2Fcrypto%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/832fe327218e556740ba4e028b7b60cb41212469/src%2Flibextra%2Fcrypto%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fsha1.rs?ref=832fe327218e556740ba4e028b7b60cb41212469", "patch": "@@ -0,0 +1,370 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * An implementation of the SHA-1 cryptographic hash.\n+ *\n+ * First create a `sha1` object using the `sha1` constructor, then\n+ * feed it input using the `input` or `input_str` methods, which may be\n+ * called any number of times.\n+ *\n+ * After the entire input has been fed to the hash read the result using\n+ * the `result` or `result_str` methods.\n+ *\n+ * The `sha1` object may be reused to create multiple hashes by calling\n+ * the `reset` method.\n+ */\n+\n+use core::prelude::*;\n+\n+use digest::Digest;\n+\n+/*\n+ * A SHA-1 implementation derived from Paul E. Jones's reference\n+ * implementation, which is written for clarity, not speed. At some\n+ * point this will want to be rewritten.\n+ */\n+\n+// Some unexported constants\n+static DIGEST_BUF_LEN: uint = 5u;\n+static MSG_BLOCK_LEN: uint = 64u;\n+static WORK_BUF_LEN: uint = 80u;\n+static K0: u32 = 0x5A827999u32;\n+static K1: u32 = 0x6ED9EBA1u32;\n+static K2: u32 = 0x8F1BBCDCu32;\n+static K3: u32 = 0xCA62C1D6u32;\n+\n+/// Structure representing the state of a Sha1 computation\n+pub struct Sha1 {\n+    priv h: [u32, ..DIGEST_BUF_LEN],\n+    priv len_low: u32,\n+    priv len_high: u32,\n+    priv msg_block: [u8, ..MSG_BLOCK_LEN],\n+    priv msg_block_idx: uint,\n+    priv computed: bool,\n+    priv work_buf: [u32, ..WORK_BUF_LEN]\n+}\n+\n+fn add_input(st: &mut Sha1, msg: &[u8]) {\n+    assert!((!st.computed));\n+    for msg.iter().advance |element| {\n+        st.msg_block[st.msg_block_idx] = *element;\n+        st.msg_block_idx += 1;\n+        st.len_low += 8;\n+        if st.len_low == 0 {\n+            st.len_high += 1;\n+            if st.len_high == 0 {\n+                // FIXME: Need better failure mode (#2346)\n+                fail!();\n+            }\n+        }\n+        if st.msg_block_idx == MSG_BLOCK_LEN { process_msg_block(st); }\n+    }\n+}\n+\n+fn process_msg_block(st: &mut Sha1) {\n+    let mut t: int; // Loop counter\n+    let mut w = st.work_buf;\n+\n+    // Initialize the first 16 words of the vector w\n+    t = 0;\n+    while t < 16 {\n+        let mut tmp;\n+        tmp = (st.msg_block[t * 4] as u32) << 24u32;\n+        tmp = tmp | (st.msg_block[t * 4 + 1] as u32) << 16u32;\n+        tmp = tmp | (st.msg_block[t * 4 + 2] as u32) << 8u32;\n+        tmp = tmp | (st.msg_block[t * 4 + 3] as u32);\n+        w[t] = tmp;\n+        t += 1;\n+    }\n+\n+    // Initialize the rest of vector w\n+    while t < 80 {\n+        let val = w[t - 3] ^ w[t - 8] ^ w[t - 14] ^ w[t - 16];\n+        w[t] = circular_shift(1, val);\n+        t += 1;\n+    }\n+    let mut a = st.h[0];\n+    let mut b = st.h[1];\n+    let mut c = st.h[2];\n+    let mut d = st.h[3];\n+    let mut e = st.h[4];\n+    let mut temp: u32;\n+    t = 0;\n+    while t < 20 {\n+        temp = circular_shift(5, a) + (b & c | !b & d) + e + w[t] + K0;\n+        e = d;\n+        d = c;\n+        c = circular_shift(30, b);\n+        b = a;\n+        a = temp;\n+        t += 1;\n+    }\n+    while t < 40 {\n+        temp = circular_shift(5, a) + (b ^ c ^ d) + e + w[t] + K1;\n+        e = d;\n+        d = c;\n+        c = circular_shift(30, b);\n+        b = a;\n+        a = temp;\n+        t += 1;\n+    }\n+    while t < 60 {\n+        temp =\n+            circular_shift(5, a) + (b & c | b & d | c & d) + e + w[t] +\n+                K2;\n+        e = d;\n+        d = c;\n+        c = circular_shift(30, b);\n+        b = a;\n+        a = temp;\n+        t += 1;\n+    }\n+    while t < 80 {\n+        temp = circular_shift(5, a) + (b ^ c ^ d) + e + w[t] + K3;\n+        e = d;\n+        d = c;\n+        c = circular_shift(30, b);\n+        b = a;\n+        a = temp;\n+        t += 1;\n+    }\n+    st.h[0] = st.h[0] + a;\n+    st.h[1] = st.h[1] + b;\n+    st.h[2] = st.h[2] + c;\n+    st.h[3] = st.h[3] + d;\n+    st.h[4] = st.h[4] + e;\n+    st.msg_block_idx = 0;\n+}\n+\n+fn circular_shift(bits: u32, word: u32) -> u32 {\n+    return word << bits | word >> 32u32 - bits;\n+}\n+\n+fn mk_result(st: &mut Sha1, rs: &mut [u8]) {\n+    if !st.computed { pad_msg(st); st.computed = true; }\n+    let mut i = 0;\n+    for st.h.mut_iter().advance |ptr_hpart| {\n+        let hpart = *ptr_hpart;\n+        rs[i]   = (hpart >> 24u32 & 0xFFu32) as u8;\n+        rs[i+1] = (hpart >> 16u32 & 0xFFu32) as u8;\n+        rs[i+2] = (hpart >> 8u32 & 0xFFu32) as u8;\n+        rs[i+3] = (hpart & 0xFFu32) as u8;\n+        i += 4;\n+    }\n+}\n+\n+/*\n+ * According to the standard, the message must be padded to an even\n+ * 512 bits.  The first padding bit must be a '1'.  The last 64 bits\n+ * represent the length of the original message.  All bits in between\n+ * should be 0.  This function will pad the message according to those\n+ * rules by filling the msg_block vector accordingly.  It will also\n+ * call process_msg_block() appropriately.  When it returns, it\n+ * can be assumed that the message digest has been computed.\n+ */\n+fn pad_msg(st: &mut Sha1) {\n+    /*\n+     * Check to see if the current message block is too small to hold\n+     * the initial padding bits and length.  If so, we will pad the\n+     * block, process it, and then continue padding into a second block.\n+     */\n+    if st.msg_block_idx > 55 {\n+        st.msg_block[st.msg_block_idx] = 0x80;\n+        st.msg_block_idx += 1;\n+        while st.msg_block_idx < MSG_BLOCK_LEN {\n+            st.msg_block[st.msg_block_idx] = 0;\n+            st.msg_block_idx += 1;\n+        }\n+        process_msg_block(st);\n+    } else {\n+        st.msg_block[st.msg_block_idx] = 0x80;\n+        st.msg_block_idx += 1;\n+    }\n+    while st.msg_block_idx < 56 {\n+        st.msg_block[st.msg_block_idx] = 0u8;\n+        st.msg_block_idx += 1;\n+    }\n+\n+    // Store the message length as the last 8 octets\n+    st.msg_block[56] = (st.len_high >> 24u32 & 0xFFu32) as u8;\n+    st.msg_block[57] = (st.len_high >> 16u32 & 0xFFu32) as u8;\n+    st.msg_block[58] = (st.len_high >> 8u32 & 0xFFu32) as u8;\n+    st.msg_block[59] = (st.len_high & 0xFFu32) as u8;\n+    st.msg_block[60] = (st.len_low >> 24u32 & 0xFFu32) as u8;\n+    st.msg_block[61] = (st.len_low >> 16u32 & 0xFFu32) as u8;\n+    st.msg_block[62] = (st.len_low >> 8u32 & 0xFFu32) as u8;\n+    st.msg_block[63] = (st.len_low & 0xFFu32) as u8;\n+    process_msg_block(st);\n+}\n+\n+impl Sha1 {\n+    /// Construct a `sha` object\n+    pub fn new() -> Sha1 {\n+        let mut st = Sha1 {\n+            h: [0u32, ..DIGEST_BUF_LEN],\n+            len_low: 0u32,\n+            len_high: 0u32,\n+            msg_block: [0u8, ..MSG_BLOCK_LEN],\n+            msg_block_idx: 0,\n+            computed: false,\n+            work_buf: [0u32, ..WORK_BUF_LEN]\n+        };\n+        st.reset();\n+        return st;\n+    }\n+}\n+\n+impl Digest for Sha1 {\n+    pub fn reset(&mut self) {\n+        self.len_low = 0;\n+        self.len_high = 0;\n+        self.msg_block_idx = 0;\n+        self.h[0] = 0x67452301u32;\n+        self.h[1] = 0xEFCDAB89u32;\n+        self.h[2] = 0x98BADCFEu32;\n+        self.h[3] = 0x10325476u32;\n+        self.h[4] = 0xC3D2E1F0u32;\n+        self.computed = false;\n+    }\n+    pub fn input(&mut self, msg: &[u8]) { add_input(self, msg); }\n+    pub fn result(&mut self, out: &mut [u8]) { return mk_result(self, out); }\n+    pub fn output_bits(&self) -> uint { 160 }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use core::vec;\n+\n+    use digest::{Digest, DigestUtil};\n+    use sha1::Sha1;\n+\n+    #[test]\n+    fn test() {\n+        struct Test {\n+            input: ~str,\n+            output: ~[u8],\n+            output_str: ~str,\n+        }\n+\n+        fn a_million_letter_a() -> ~str {\n+            let mut i = 0;\n+            let mut rs = ~\"\";\n+            while i < 100000 {\n+                rs.push_str(\"aaaaaaaaaa\");\n+                i += 1;\n+            }\n+            return rs;\n+        }\n+        // Test messages from FIPS 180-1\n+\n+        let fips_180_1_tests = ~[\n+            Test {\n+                input: ~\"abc\",\n+                output: ~[\n+                    0xA9u8, 0x99u8, 0x3Eu8, 0x36u8,\n+                    0x47u8, 0x06u8, 0x81u8, 0x6Au8,\n+                    0xBAu8, 0x3Eu8, 0x25u8, 0x71u8,\n+                    0x78u8, 0x50u8, 0xC2u8, 0x6Cu8,\n+                    0x9Cu8, 0xD0u8, 0xD8u8, 0x9Du8,\n+                ],\n+                output_str: ~\"a9993e364706816aba3e25717850c26c9cd0d89d\"\n+            },\n+            Test {\n+                input:\n+                     ~\"abcdbcdecdefdefgefghfghighij\" +\n+                     \"hijkijkljklmklmnlmnomnopnopq\",\n+                output: ~[\n+                    0x84u8, 0x98u8, 0x3Eu8, 0x44u8,\n+                    0x1Cu8, 0x3Bu8, 0xD2u8, 0x6Eu8,\n+                    0xBAu8, 0xAEu8, 0x4Au8, 0xA1u8,\n+                    0xF9u8, 0x51u8, 0x29u8, 0xE5u8,\n+                    0xE5u8, 0x46u8, 0x70u8, 0xF1u8,\n+                ],\n+                output_str: ~\"84983e441c3bd26ebaae4aa1f95129e5e54670f1\"\n+            },\n+            Test {\n+                input: a_million_letter_a(),\n+                output: ~[\n+                    0x34u8, 0xAAu8, 0x97u8, 0x3Cu8,\n+                    0xD4u8, 0xC4u8, 0xDAu8, 0xA4u8,\n+                    0xF6u8, 0x1Eu8, 0xEBu8, 0x2Bu8,\n+                    0xDBu8, 0xADu8, 0x27u8, 0x31u8,\n+                    0x65u8, 0x34u8, 0x01u8, 0x6Fu8,\n+                ],\n+                output_str: ~\"34aa973cd4c4daa4f61eeb2bdbad27316534016f\"\n+            },\n+        ];\n+        // Examples from wikipedia\n+\n+        let wikipedia_tests = ~[\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog\",\n+                output: ~[\n+                    0x2fu8, 0xd4u8, 0xe1u8, 0xc6u8,\n+                    0x7au8, 0x2du8, 0x28u8, 0xfcu8,\n+                    0xedu8, 0x84u8, 0x9eu8, 0xe1u8,\n+                    0xbbu8, 0x76u8, 0xe7u8, 0x39u8,\n+                    0x1bu8, 0x93u8, 0xebu8, 0x12u8,\n+                ],\n+                output_str: ~\"2fd4e1c67a2d28fced849ee1bb76e7391b93eb12\",\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy cog\",\n+                output: ~[\n+                    0xdeu8, 0x9fu8, 0x2cu8, 0x7fu8,\n+                    0xd2u8, 0x5eu8, 0x1bu8, 0x3au8,\n+                    0xfau8, 0xd3u8, 0xe8u8, 0x5au8,\n+                    0x0bu8, 0xd1u8, 0x7du8, 0x9bu8,\n+                    0x10u8, 0x0du8, 0xb4u8, 0xb3u8,\n+                ],\n+                output_str: ~\"de9f2c7fd25e1b3afad3e85a0bd17d9b100db4b3\",\n+            },\n+        ];\n+        let tests = fips_180_1_tests + wikipedia_tests;\n+\n+        // Test that it works when accepting the message all at once\n+\n+        let mut out = [0u8, ..20];\n+\n+        let mut sh = ~Sha1::new();\n+        for tests.iter().advance |t| {\n+            (*sh).input_str(t.input);\n+            sh.result(out);\n+            assert!(vec::eq(t.output, out));\n+\n+            let out_str = (*sh).result_str();\n+            assert_eq!(out_str.len(), 40);\n+            assert!(out_str == t.output_str);\n+\n+            sh.reset();\n+        }\n+\n+\n+        // Test that it works when accepting the message in pieces\n+        for tests.iter().advance |t| {\n+            let len = t.input.len();\n+            let mut left = len;\n+            while left > 0u {\n+                let take = (left + 1u) / 2u;\n+                (*sh).input_str(t.input.slice(len - left, take + len - left));\n+                left = left - take;\n+            }\n+            sh.result(out);\n+            assert!(vec::eq(t.output, out));\n+\n+            let out_str = (*sh).result_str();\n+            assert_eq!(out_str.len(), 40);\n+            assert!(out_str == t.output_str);\n+\n+            sh.reset();\n+        }\n+    }\n+}"}, {"sha": "dd179fde70f5b7bde978b6bfd326490585138c38", "filename": "src/libextra/crypto/sha2.rs", "status": "added", "additions": 1125, "deletions": 0, "changes": 1125, "blob_url": "https://github.com/rust-lang/rust/blob/832fe327218e556740ba4e028b7b60cb41212469/src%2Flibextra%2Fcrypto%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/832fe327218e556740ba4e028b7b60cb41212469/src%2Flibextra%2Fcrypto%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fsha2.rs?ref=832fe327218e556740ba4e028b7b60cb41212469", "patch": "@@ -0,0 +1,1125 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::prelude::*;\n+\n+use core::uint;\n+use core::vec;\n+\n+use digest::Digest;\n+\n+// BitCounter is a specialized structure intended simply for counting the\n+// number of bits that have been processed by the SHA-2 512 family of functions.\n+// It does very little overflow checking since such checking is not necessary\n+// for how it is used. A more generic structure would have to do this checking.\n+// So, don't copy this structure and use it elsewhere!\n+struct BitCounter {\n+    high_bit_count: u64,\n+    low_byte_count: u64\n+}\n+\n+impl BitCounter {\n+    fn add_bytes(&mut self, bytes: uint) {\n+        self.low_byte_count += bytes as u64;\n+        if(self.low_byte_count > 0x1fffffffffffffffu64) {\n+            self.high_bit_count += (self.low_byte_count >> 61);\n+            self.low_byte_count &= 0x1fffffffffffffffu64;\n+        }\n+    }\n+\n+    fn reset(&mut self) {\n+        self.low_byte_count = 0;\n+        self.high_bit_count = 0;\n+    }\n+\n+    fn get_low_bit_count(&self) -> u64 {\n+        self.low_byte_count << 3\n+    }\n+\n+    fn get_high_bit_count(&self) -> u64 {\n+        self.high_bit_count\n+    }\n+}\n+\n+// A structure that represents that state of a digest computation\n+// for the SHA-2 512 family of digest functions\n+struct Engine512 {\n+    input_buffer: [u8, ..8],\n+    input_buffer_idx: uint,\n+    bit_counter: BitCounter,\n+    H0: u64,\n+    H1: u64,\n+    H2: u64,\n+    H3: u64,\n+    H4: u64,\n+    H5: u64,\n+    H6: u64,\n+    H7: u64,\n+    W: [u64, ..80],\n+    W_idx: uint,\n+    finished: bool,\n+}\n+\n+// Convert a [u8] to a u64 in big-endian format\n+fn to_u64(in: &[u8]) -> u64 {\n+    (in[0] as u64) << 56 |\n+    (in[1] as u64) << 48 |\n+    (in[2] as u64) << 40 |\n+    (in[3] as u64) << 32 |\n+    (in[4] as u64) << 24 |\n+    (in[5] as u64) << 16 |\n+    (in[6] as u64) << 8 |\n+    (in[7] as u64)\n+}\n+\n+// Convert a u64 to a [u8] in big endian format\n+fn from_u64(in: u64, out: &mut [u8]) {\n+    out[0] = (in >> 56) as u8;\n+    out[1] = (in >> 48) as u8;\n+    out[2] = (in >> 40) as u8;\n+    out[3] = (in >> 32) as u8;\n+    out[4] = (in >> 24) as u8;\n+    out[5] = (in >> 16) as u8;\n+    out[6] = (in >> 8) as u8;\n+    out[7] = in as u8;\n+}\n+\n+impl Engine512 {\n+    fn input_byte(&mut self, in: u8) {\n+        assert!(!self.finished)\n+\n+        self.input_buffer[self.input_buffer_idx] = in;\n+        self.input_buffer_idx += 1;\n+\n+        if (self.input_buffer_idx == 8) {\n+            self.input_buffer_idx = 0;\n+            let w = to_u64(self.input_buffer);\n+            self.process_word(w);\n+        }\n+\n+        self.bit_counter.add_bytes(1);\n+    }\n+\n+    fn input_vec(&mut self, in: &[u8]) {\n+        assert!(!self.finished)\n+\n+        let mut i = 0;\n+\n+        while i < in.len() && self.input_buffer_idx != 0 {\n+            self.input_byte(in[i]);\n+            i += 1;\n+        }\n+\n+        while in.len() - i >= 8 {\n+            let w = to_u64(vec::slice(in, i, i + 8));\n+            self.process_word(w);\n+            self.bit_counter.add_bytes(8);\n+            i += 8;\n+        }\n+\n+        while i < in.len() {\n+            self.input_byte(in[i]);\n+            i += 1;\n+        }\n+    }\n+\n+    fn reset(&mut self) {\n+        self.bit_counter.reset();\n+        self.finished = false;\n+        self.input_buffer_idx = 0;\n+        self.W_idx = 0;\n+    }\n+\n+    fn process_word(&mut self, in: u64) {\n+        self.W[self.W_idx] = in;\n+        self.W_idx += 1;\n+        if (self.W_idx == 16) {\n+            self.W_idx = 0;\n+            self.process_block();\n+        }\n+    }\n+\n+    fn process_block(&mut self) {\n+        fn ch(x: u64, y: u64, z: u64) -> u64 {\n+            ((x & y) ^ ((!x) & z))\n+        }\n+\n+        fn maj(x: u64, y: u64, z: u64) -> u64 {\n+            ((x & y) ^ (x & z) ^ (y & z))\n+        }\n+\n+        fn sum0(x: u64) -> u64 {\n+            ((x << 36) | (x >> 28)) ^ ((x << 30) | (x >> 34)) ^ ((x << 25) | (x >> 39))\n+        }\n+\n+        fn sum1(x: u64) -> u64 {\n+            ((x << 50) | (x >> 14)) ^ ((x << 46) | (x >> 18)) ^ ((x << 23) | (x >> 41))\n+        }\n+\n+        fn sigma0(x: u64) -> u64 {\n+            ((x << 63) | (x >> 1)) ^ ((x << 56) | (x >> 8)) ^ (x >> 7)\n+        }\n+\n+        fn sigma1(x: u64) -> u64 {\n+            ((x << 45) | (x >> 19)) ^ ((x << 3) | (x >> 61)) ^ (x >> 6)\n+        }\n+\n+        for uint::range(16, 80) |t| {\n+            self.W[t] = sigma1(self.W[t - 2]) + self.W[t - 7] + sigma0(self.W[t - 15]) +\n+                self.W[t - 16];\n+        }\n+\n+        let mut a = self.H0;\n+        let mut b = self.H1;\n+        let mut c = self.H2;\n+        let mut d = self.H3;\n+        let mut e = self.H4;\n+        let mut f = self.H5;\n+        let mut g = self.H6;\n+        let mut h = self.H7;\n+\n+        let mut t = 0;\n+        for uint::range(0, 10) |_| {\n+            h += sum1(e) + ch(e, f, g) + K64[t] + self.W[t];\n+            d += h;\n+            h += sum0(a) + maj(a, b, c);\n+            t += 1;\n+\n+            g += sum1(d) + ch(d, e, f) + K64[t] + self.W[t];\n+            c += g;\n+            g += sum0(h) + maj(h, a, b);\n+            t += 1;\n+\n+            f += sum1(c) + ch(c, d, e) + K64[t] + self.W[t];\n+            b += f;\n+            f += sum0(g) + maj(g, h, a);\n+            t += 1;\n+\n+            e += sum1(b) + ch(b, c, d) + K64[t] + self.W[t];\n+            a += e;\n+            e += sum0(f) + maj(f, g, h);\n+            t += 1;\n+\n+            d += sum1(a) + ch(a, b, c) + K64[t] + self.W[t];\n+            h += d;\n+            d += sum0(e) + maj(e, f, g);\n+            t += 1;\n+\n+            c += sum1(h) + ch(h, a, b) + K64[t] + self.W[t];\n+            g += c;\n+            c += sum0(d) + maj(d, e, f);\n+            t += 1;\n+\n+            b += sum1(g) + ch(g, h, a) + K64[t] + self.W[t];\n+            f += b;\n+            b += sum0(c) + maj(c, d, e);\n+            t += 1;\n+\n+            a += sum1(f) + ch(f, g, h) + K64[t] + self.W[t];\n+            e += a;\n+            a += sum0(b) + maj(b, c, d);\n+            t += 1;\n+        }\n+\n+        self.H0 += a;\n+        self.H1 += b;\n+        self.H2 += c;\n+        self.H3 += d;\n+        self.H4 += e;\n+        self.H5 += f;\n+        self.H6 += g;\n+        self.H7 += h;\n+    }\n+\n+    fn finish(&mut self) {\n+        if (self.finished) {\n+            return;\n+        }\n+\n+        // must get message length before padding is added\n+        let high_bit_count = self.bit_counter.get_high_bit_count();\n+        let low_bit_count = self.bit_counter.get_low_bit_count();\n+\n+        // add padding\n+        self.input_byte(128u8);\n+\n+        while self.input_buffer_idx != 0 {\n+            self.input_byte(0u8);\n+        }\n+\n+        // add length\n+        if (self.W_idx > 14) {\n+            for uint::range(self.W_idx, 16) |_| {\n+                self.process_word(0);\n+            }\n+        }\n+\n+        while self.W_idx < 14 {\n+            self.process_word(0);\n+        }\n+\n+        self.process_word(high_bit_count);\n+        self.process_word(low_bit_count);\n+\n+        self.finished = true;\n+    }\n+\n+    fn result_512(&mut self, out: &mut [u8]) {\n+        self.finish();\n+\n+        from_u64(self.H0, vec::mut_slice(out, 0, 8));\n+        from_u64(self.H1, vec::mut_slice(out, 8, 16));\n+        from_u64(self.H2, vec::mut_slice(out, 16, 24));\n+        from_u64(self.H3, vec::mut_slice(out, 24, 32));\n+        from_u64(self.H4, vec::mut_slice(out, 32, 40));\n+        from_u64(self.H5, vec::mut_slice(out, 40, 48));\n+        from_u64(self.H6, vec::mut_slice(out, 48, 56));\n+        from_u64(self.H7, vec::mut_slice(out, 56, 64));\n+    }\n+\n+    fn result_384(&mut self, out: &mut [u8]) {\n+        self.finish();\n+\n+        from_u64(self.H0, vec::mut_slice(out, 0, 8));\n+        from_u64(self.H1, vec::mut_slice(out, 8, 16));\n+        from_u64(self.H2, vec::mut_slice(out, 16, 24));\n+        from_u64(self.H3, vec::mut_slice(out, 24, 32));\n+        from_u64(self.H4, vec::mut_slice(out, 32, 40));\n+        from_u64(self.H5, vec::mut_slice(out, 40, 48));\n+    }\n+\n+    fn result_256(&mut self, out: &mut [u8]) {\n+        self.finish();\n+\n+        from_u64(self.H0, vec::mut_slice(out, 0, 8));\n+        from_u64(self.H1, vec::mut_slice(out, 8, 16));\n+        from_u64(self.H2, vec::mut_slice(out, 16, 24));\n+        from_u64(self.H3, vec::mut_slice(out, 24, 32));\n+    }\n+\n+    fn result_224(&mut self, out: &mut [u8]) {\n+        self.finish();\n+\n+        from_u64(self.H0, vec::mut_slice(out, 0, 8));\n+        from_u64(self.H1, vec::mut_slice(out, 8, 16));\n+        from_u64(self.H2, vec::mut_slice(out, 16, 24));\n+        from_u32((self.H3 >> 32) as u32, vec::mut_slice(out, 24, 28));\n+    }\n+}\n+\n+// Constants necessary for SHA-2 512 family of digests.\n+static K64: [u64, ..80] = [\n+    0x428a2f98d728ae22u64, 0x7137449123ef65cdu64, 0xb5c0fbcfec4d3b2fu64, 0xe9b5dba58189dbbcu64,\n+    0x3956c25bf348b538u64, 0x59f111f1b605d019u64, 0x923f82a4af194f9bu64, 0xab1c5ed5da6d8118u64,\n+    0xd807aa98a3030242u64, 0x12835b0145706fbeu64, 0x243185be4ee4b28cu64, 0x550c7dc3d5ffb4e2u64,\n+    0x72be5d74f27b896fu64, 0x80deb1fe3b1696b1u64, 0x9bdc06a725c71235u64, 0xc19bf174cf692694u64,\n+    0xe49b69c19ef14ad2u64, 0xefbe4786384f25e3u64, 0x0fc19dc68b8cd5b5u64, 0x240ca1cc77ac9c65u64,\n+    0x2de92c6f592b0275u64, 0x4a7484aa6ea6e483u64, 0x5cb0a9dcbd41fbd4u64, 0x76f988da831153b5u64,\n+    0x983e5152ee66dfabu64, 0xa831c66d2db43210u64, 0xb00327c898fb213fu64, 0xbf597fc7beef0ee4u64,\n+    0xc6e00bf33da88fc2u64, 0xd5a79147930aa725u64, 0x06ca6351e003826fu64, 0x142929670a0e6e70u64,\n+    0x27b70a8546d22ffcu64, 0x2e1b21385c26c926u64, 0x4d2c6dfc5ac42aedu64, 0x53380d139d95b3dfu64,\n+    0x650a73548baf63deu64, 0x766a0abb3c77b2a8u64, 0x81c2c92e47edaee6u64, 0x92722c851482353bu64,\n+    0xa2bfe8a14cf10364u64, 0xa81a664bbc423001u64, 0xc24b8b70d0f89791u64, 0xc76c51a30654be30u64,\n+    0xd192e819d6ef5218u64, 0xd69906245565a910u64, 0xf40e35855771202au64, 0x106aa07032bbd1b8u64,\n+    0x19a4c116b8d2d0c8u64, 0x1e376c085141ab53u64, 0x2748774cdf8eeb99u64, 0x34b0bcb5e19b48a8u64,\n+    0x391c0cb3c5c95a63u64, 0x4ed8aa4ae3418acbu64, 0x5b9cca4f7763e373u64, 0x682e6ff3d6b2b8a3u64,\n+    0x748f82ee5defb2fcu64, 0x78a5636f43172f60u64, 0x84c87814a1f0ab72u64, 0x8cc702081a6439ecu64,\n+    0x90befffa23631e28u64, 0xa4506cebde82bde9u64, 0xbef9a3f7b2c67915u64, 0xc67178f2e372532bu64,\n+    0xca273eceea26619cu64, 0xd186b8c721c0c207u64, 0xeada7dd6cde0eb1eu64, 0xf57d4f7fee6ed178u64,\n+    0x06f067aa72176fbau64, 0x0a637dc5a2c898a6u64, 0x113f9804bef90daeu64, 0x1b710b35131c471bu64,\n+    0x28db77f523047d84u64, 0x32caab7b40c72493u64, 0x3c9ebe0a15c9bebcu64, 0x431d67c49c100d4cu64,\n+    0x4cc5d4becb3e42b6u64, 0x597f299cfc657e2au64, 0x5fcb6fab3ad6faecu64, 0x6c44198c4a475817u64\n+];\n+\n+// A structure that represents that state of a digest computation\n+// for the SHA-2 256 family of digest functions\n+struct Engine256 {\n+    input_buffer: [u8, ..4],\n+    input_buffer_idx: uint,\n+    length_bytes: u64,\n+    H0: u32,\n+    H1: u32,\n+    H2: u32,\n+    H3: u32,\n+    H4: u32,\n+    H5: u32,\n+    H6: u32,\n+    H7: u32,\n+    W: [u32, ..64],\n+    W_idx: uint,\n+    finished: bool\n+}\n+\n+// Convert a [u8] to a u32 in big endian format\n+fn to_u32(in: &[u8]) -> u32 {\n+    (in[0] as u32) << 24 |\n+    (in[1] as u32) << 16 |\n+    (in[2] as u32) << 8 |\n+    (in[3] as u32)\n+}\n+\n+// Convert a u32 to a [u8] in big endian format\n+fn from_u32(in: u32, out: &mut [u8]) {\n+    out[0] = (in >> 24) as u8;\n+    out[1] = (in >> 16) as u8;\n+    out[2] = (in >> 8) as u8;\n+    out[3] = in as u8;\n+}\n+\n+impl Engine256 {\n+    fn input_byte(&mut self, in: u8) {\n+        assert!(!self.finished)\n+\n+        self.input_buffer[self.input_buffer_idx] = in;\n+        self.input_buffer_idx += 1;\n+\n+        if (self.input_buffer_idx == 4) {\n+            self.input_buffer_idx = 0;\n+            let w = to_u32(self.input_buffer);\n+            self.process_word(w);\n+        }\n+\n+        self.length_bytes += 1;\n+    }\n+\n+    fn input_vec(&mut self, in: &[u8]) {\n+        assert!(!self.finished)\n+\n+        let mut i = 0;\n+\n+        while i < in.len() && self.input_buffer_idx != 0 {\n+            self.input_byte(in[i]);\n+            i += 1;\n+        }\n+\n+        while in.len() - i >= 4 {\n+            let w = to_u32(vec::slice(in, i, i + 4));\n+            self.process_word(w);\n+            self.length_bytes += 4;\n+            i += 4;\n+        }\n+\n+        while i < in.len() {\n+            self.input_byte(in[i]);\n+            i += 1;\n+        }\n+\n+    }\n+\n+    fn reset(&mut self) {\n+        self.length_bytes = 0;\n+        self.finished = false;\n+        self.input_buffer_idx = 0;\n+        self.W_idx = 0;\n+    }\n+\n+    fn process_word(&mut self, in: u32) {\n+        self.W[self.W_idx] = in;\n+        self.W_idx += 1;\n+        if (self.W_idx == 16) {\n+            self.W_idx = 0;\n+            self.process_block();\n+        }\n+    }\n+\n+    fn process_block(&mut self) {\n+        fn ch(x: u32, y: u32, z: u32) -> u32 {\n+            ((x & y) ^ ((!x) & z))\n+        }\n+\n+        fn maj(x: u32, y: u32, z: u32) -> u32 {\n+            ((x & y) ^ (x & z) ^ (y & z))\n+        }\n+\n+        fn sum0(x: u32) -> u32 {\n+            ((x >> 2) | (x << 30)) ^ ((x >> 13) | (x << 19)) ^ ((x >> 22) | (x << 10))\n+        }\n+\n+        fn sum1(x: u32) -> u32 {\n+            ((x >> 6) | (x << 26)) ^ ((x >> 11) | (x << 21)) ^ ((x >> 25) | (x << 7))\n+        }\n+\n+        fn sigma0(x: u32) -> u32 {\n+            ((x >> 7) | (x << 25)) ^ ((x >> 18) | (x << 14)) ^ (x >> 3)\n+        }\n+\n+        fn sigma1(x: u32) -> u32 {\n+            ((x >> 17) | (x << 15)) ^ ((x >> 19) | (x << 13)) ^ (x >> 10)\n+        }\n+\n+        for uint::range(16, 64) |t| {\n+            self.W[t] = sigma1(self.W[t - 2]) + self.W[t - 7] + sigma0(self.W[t - 15]) +\n+                self.W[t - 16];\n+        }\n+\n+        let mut a = self.H0;\n+        let mut b = self.H1;\n+        let mut c = self.H2;\n+        let mut d = self.H3;\n+        let mut e = self.H4;\n+        let mut f = self.H5;\n+        let mut g = self.H6;\n+        let mut h = self.H7;\n+\n+        let mut t = 0;\n+        for uint::range(0, 8) |_| {\n+            h += sum1(e) + ch(e, f, g) + K32[t] + self.W[t];\n+            d += h;\n+            h += sum0(a) + maj(a, b, c);\n+            t += 1;\n+\n+            g += sum1(d) + ch(d, e, f) + K32[t] + self.W[t];\n+            c += g;\n+            g += sum0(h) + maj(h, a, b);\n+            t += 1;\n+\n+            f += sum1(c) + ch(c, d, e) + K32[t] + self.W[t];\n+            b += f;\n+            f += sum0(g) + maj(g, h, a);\n+            t += 1;\n+\n+            e += sum1(b) + ch(b, c, d) + K32[t] + self.W[t];\n+            a += e;\n+            e += sum0(f) + maj(f, g, h);\n+            t += 1;\n+\n+            d += sum1(a) + ch(a, b, c) + K32[t] + self.W[t];\n+            h += d;\n+            d += sum0(e) + maj(e, f, g);\n+            t += 1;\n+\n+            c += sum1(h) + ch(h, a, b) + K32[t] + self.W[t];\n+            g += c;\n+            c += sum0(d) + maj(d, e, f);\n+            t += 1;\n+\n+            b += sum1(g) + ch(g, h, a) + K32[t] + self.W[t];\n+            f += b;\n+            b += sum0(c) + maj(c, d, e);\n+            t += 1;\n+\n+            a += sum1(f) + ch(f, g, h) + K32[t] + self.W[t];\n+            e += a;\n+            a += sum0(b) + maj(b, c, d);\n+            t += 1;\n+        }\n+\n+        self.H0 += a;\n+        self.H1 += b;\n+        self.H2 += c;\n+        self.H3 += d;\n+        self.H4 += e;\n+        self.H5 += f;\n+        self.H6 += g;\n+        self.H7 += h;\n+    }\n+\n+    fn finish(&mut self) {\n+        if (self.finished) {\n+            return;\n+        }\n+\n+        // must get length before adding padding\n+        let bit_length = self.length_bytes << 3;\n+\n+        // add padding\n+        self.input_byte(128u8);\n+\n+        while self.input_buffer_idx != 0 {\n+            self.input_byte(0u8);\n+        }\n+\n+        // add length\n+        if (self.W_idx > 14) {\n+            for uint::range(self.W_idx, 16) |_| {\n+                self.process_word(0);\n+            }\n+        }\n+\n+        while self.W_idx < 14 {\n+            self.process_word(0);\n+        }\n+\n+        self.process_word((bit_length >> 32) as u32);\n+        self.process_word(bit_length as u32);\n+\n+        self.finished = true;\n+    }\n+\n+    fn result_256(&mut self, out: &mut [u8]) {\n+        self.finish();\n+\n+        from_u32(self.H0, vec::mut_slice(out, 0, 4));\n+        from_u32(self.H1, vec::mut_slice(out, 4, 8));\n+        from_u32(self.H2, vec::mut_slice(out, 8, 12));\n+        from_u32(self.H3, vec::mut_slice(out, 12, 16));\n+        from_u32(self.H4, vec::mut_slice(out, 16, 20));\n+        from_u32(self.H5, vec::mut_slice(out, 20, 24));\n+        from_u32(self.H6, vec::mut_slice(out, 24, 28));\n+        from_u32(self.H7, vec::mut_slice(out, 28, 32));\n+    }\n+\n+    fn result_224(&mut self, out: &mut [u8]) {\n+        self.finish();\n+\n+        from_u32(self.H0, vec::mut_slice(out, 0, 4));\n+        from_u32(self.H1, vec::mut_slice(out, 4, 8));\n+        from_u32(self.H2, vec::mut_slice(out, 8, 12));\n+        from_u32(self.H3, vec::mut_slice(out, 12, 16));\n+        from_u32(self.H4, vec::mut_slice(out, 16, 20));\n+        from_u32(self.H5, vec::mut_slice(out, 20, 24));\n+        from_u32(self.H6, vec::mut_slice(out, 24, 28));\n+    }\n+}\n+\n+static K32: [u32, ..64] = [\n+    0x428a2f98u32, 0x71374491u32, 0xb5c0fbcfu32, 0xe9b5dba5u32,\n+    0x3956c25bu32, 0x59f111f1u32, 0x923f82a4u32, 0xab1c5ed5u32,\n+    0xd807aa98u32, 0x12835b01u32, 0x243185beu32, 0x550c7dc3u32,\n+    0x72be5d74u32, 0x80deb1feu32, 0x9bdc06a7u32, 0xc19bf174u32,\n+    0xe49b69c1u32, 0xefbe4786u32, 0x0fc19dc6u32, 0x240ca1ccu32,\n+    0x2de92c6fu32, 0x4a7484aau32, 0x5cb0a9dcu32, 0x76f988dau32,\n+    0x983e5152u32, 0xa831c66du32, 0xb00327c8u32, 0xbf597fc7u32,\n+    0xc6e00bf3u32, 0xd5a79147u32, 0x06ca6351u32, 0x14292967u32,\n+    0x27b70a85u32, 0x2e1b2138u32, 0x4d2c6dfcu32, 0x53380d13u32,\n+    0x650a7354u32, 0x766a0abbu32, 0x81c2c92eu32, 0x92722c85u32,\n+    0xa2bfe8a1u32, 0xa81a664bu32, 0xc24b8b70u32, 0xc76c51a3u32,\n+    0xd192e819u32, 0xd6990624u32, 0xf40e3585u32, 0x106aa070u32,\n+    0x19a4c116u32, 0x1e376c08u32, 0x2748774cu32, 0x34b0bcb5u32,\n+    0x391c0cb3u32, 0x4ed8aa4au32, 0x5b9cca4fu32, 0x682e6ff3u32,\n+    0x748f82eeu32, 0x78a5636fu32, 0x84c87814u32, 0x8cc70208u32,\n+    0x90befffau32, 0xa4506cebu32, 0xbef9a3f7u32, 0xc67178f2u32\n+];\n+\n+struct Sha512 {\n+    priv engine: Engine512\n+}\n+\n+struct Sha384 {\n+    priv engine: Engine512\n+}\n+\n+struct Sha512Trunc256 {\n+    priv engine: Engine512\n+}\n+\n+struct Sha512Trunc224 {\n+    priv engine: Engine512\n+}\n+\n+struct Sha256 {\n+    priv engine: Engine256\n+}\n+\n+struct Sha224 {\n+    priv engine: Engine256\n+}\n+\n+impl Sha512 {\n+    /**\n+     * Construct an new instance of a SHA-512 digest.\n+     */\n+    pub fn new() -> Sha512 {\n+        Sha512 {\n+            engine: Engine512 {\n+                input_buffer: [0u8, ..8],\n+                input_buffer_idx: 0,\n+                bit_counter: BitCounter { high_bit_count: 0, low_byte_count: 0 },\n+                H0: 0x6a09e667f3bcc908u64,\n+                H1: 0xbb67ae8584caa73bu64,\n+                H2: 0x3c6ef372fe94f82bu64,\n+                H3: 0xa54ff53a5f1d36f1u64,\n+                H4: 0x510e527fade682d1u64,\n+                H5: 0x9b05688c2b3e6c1fu64,\n+                H6: 0x1f83d9abfb41bd6bu64,\n+                H7: 0x5be0cd19137e2179u64,\n+                W: [0u64, ..80],\n+                W_idx: 0,\n+                finished: false,\n+            }\n+        }\n+    }\n+}\n+\n+impl Sha384 {\n+    /**\n+     * Construct an new instance of a SHA-384 digest.\n+     */\n+    pub fn new() -> Sha384 {\n+        Sha384 {\n+            engine: Engine512 {\n+                input_buffer: [0u8, ..8],\n+                input_buffer_idx: 0,\n+                bit_counter: BitCounter { high_bit_count: 0, low_byte_count: 0 },\n+                H0: 0xcbbb9d5dc1059ed8u64,\n+                H1: 0x629a292a367cd507u64,\n+                H2: 0x9159015a3070dd17u64,\n+                H3: 0x152fecd8f70e5939u64,\n+                H4: 0x67332667ffc00b31u64,\n+                H5: 0x8eb44a8768581511u64,\n+                H6: 0xdb0c2e0d64f98fa7u64,\n+                H7: 0x47b5481dbefa4fa4u64,\n+                W: [0u64, ..80],\n+                W_idx: 0,\n+                finished: false,\n+            }\n+        }\n+    }\n+}\n+\n+impl Sha512Trunc256 {\n+    /**\n+     * Construct an new instance of a SHA-512/256 digest.\n+     */\n+    pub fn new() -> Sha512Trunc256 {\n+        Sha512Trunc256 {\n+            engine: Engine512 {\n+                input_buffer: [0u8, ..8],\n+                input_buffer_idx: 0,\n+                bit_counter: BitCounter { high_bit_count: 0, low_byte_count: 0 },\n+                H0: 0x22312194fc2bf72cu64,\n+                H1: 0x9f555fa3c84c64c2u64,\n+                H2: 0x2393b86b6f53b151u64,\n+                H3: 0x963877195940eabdu64,\n+                H4: 0x96283ee2a88effe3u64,\n+                H5: 0xbe5e1e2553863992u64,\n+                H6: 0x2b0199fc2c85b8aau64,\n+                H7: 0x0eb72ddc81c52ca2u64,\n+                W: [0u64, ..80],\n+                W_idx: 0,\n+                finished: false,\n+            }\n+        }\n+    }\n+}\n+\n+impl Sha512Trunc224 {\n+    /**\n+     * Construct an new instance of a SHA-512/224 digest.\n+     */\n+    pub fn new() -> Sha512Trunc224 {\n+        Sha512Trunc224 {\n+            engine: Engine512 {\n+                input_buffer: [0u8, ..8],\n+                input_buffer_idx: 0,\n+                bit_counter: BitCounter { high_bit_count: 0, low_byte_count: 0 },\n+                H0: 0x8c3d37c819544da2u64,\n+                H1: 0x73e1996689dcd4d6u64,\n+                H2: 0x1dfab7ae32ff9c82u64,\n+                H3: 0x679dd514582f9fcfu64,\n+                H4: 0x0f6d2b697bd44da8u64,\n+                H5: 0x77e36f7304c48942u64,\n+                H6: 0x3f9d85a86a1d36c8u64,\n+                H7: 0x1112e6ad91d692a1u64,\n+                W: [0u64, ..80],\n+                W_idx: 0,\n+                finished: false,\n+            }\n+        }\n+    }\n+}\n+\n+impl Sha256 {\n+    /**\n+     * Construct an new instance of a SHA-256 digest.\n+     */\n+    pub fn new() -> Sha256 {\n+        Sha256 {\n+            engine: Engine256 {\n+                input_buffer: [0u8, ..4],\n+                input_buffer_idx: 0,\n+                length_bytes: 0,\n+                H0: 0x6a09e667u32,\n+                H1: 0xbb67ae85u32,\n+                H2: 0x3c6ef372u32,\n+                H3: 0xa54ff53au32,\n+                H4: 0x510e527fu32,\n+                H5: 0x9b05688cu32,\n+                H6: 0x1f83d9abu32,\n+                H7: 0x5be0cd19u32,\n+                W: [0u32, ..64],\n+                W_idx: 0,\n+                finished: false,\n+            }\n+        }\n+    }\n+}\n+\n+impl Sha224 {\n+    /**\n+     * Construct an new instance of a SHA-224 digest.\n+     */\n+    pub fn new() -> Sha224 {\n+        Sha224 {\n+            engine: Engine256 {\n+                input_buffer: [0u8, ..4],\n+                input_buffer_idx: 0,\n+                length_bytes: 0,\n+                H0: 0xc1059ed8u32,\n+                H1: 0x367cd507u32,\n+                H2: 0x3070dd17u32,\n+                H3: 0xf70e5939u32,\n+                H4: 0xffc00b31u32,\n+                H5: 0x68581511u32,\n+                H6: 0x64f98fa7u32,\n+                H7: 0xbefa4fa4u32,\n+                W: [0u32, ..64],\n+                W_idx: 0,\n+                finished: false,\n+            }\n+        }\n+    }\n+}\n+\n+impl Digest for Sha512 {\n+    fn input(&mut self, d: &[u8]) {\n+        self.engine.input_vec(d);\n+    }\n+\n+    fn result(&mut self, out: &mut [u8]) {\n+        self.engine.result_512(out)\n+    }\n+\n+    fn reset(&mut self) {\n+        self.engine.reset();\n+\n+        self.engine.H0 = 0x6a09e667f3bcc908u64;\n+        self.engine.H1 = 0xbb67ae8584caa73bu64;\n+        self.engine.H2 = 0x3c6ef372fe94f82bu64;\n+        self.engine.H3 = 0xa54ff53a5f1d36f1u64;\n+        self.engine.H4 = 0x510e527fade682d1u64;\n+        self.engine.H5 = 0x9b05688c2b3e6c1fu64;\n+        self.engine.H6 = 0x1f83d9abfb41bd6bu64;\n+        self.engine.H7 = 0x5be0cd19137e2179u64;\n+    }\n+\n+    fn output_bits(&self) -> uint { 512 }\n+}\n+\n+impl Digest for Sha384 {\n+    fn input(&mut self, d: &[u8]) {\n+        self.engine.input_vec(d);\n+    }\n+\n+    fn result(&mut self, out: &mut [u8]) {\n+        self.engine.result_384(out)\n+    }\n+\n+    fn reset(&mut self) {\n+        self.engine.reset();\n+\n+        self.engine.H0 = 0xcbbb9d5dc1059ed8u64;\n+        self.engine.H1 = 0x629a292a367cd507u64;\n+        self.engine.H2 = 0x9159015a3070dd17u64;\n+        self.engine.H3 = 0x152fecd8f70e5939u64;\n+        self.engine.H4 = 0x67332667ffc00b31u64;\n+        self.engine.H5 = 0x8eb44a8768581511u64;\n+        self.engine.H6 = 0xdb0c2e0d64f98fa7u64;\n+        self.engine.H7 = 0x47b5481dbefa4fa4u64;\n+    }\n+\n+    fn output_bits(&self) -> uint { 384 }\n+}\n+\n+impl Digest for Sha512Trunc256 {\n+    fn input(&mut self, d: &[u8]) {\n+        self.engine.input_vec(d);\n+    }\n+\n+    fn result(&mut self, out: &mut [u8]) {\n+        self.engine.result_256(out)\n+    }\n+\n+    fn reset(&mut self) {\n+        self.engine.reset();\n+\n+        self.engine.H0 = 0x22312194fc2bf72cu64;\n+        self.engine.H1 = 0x9f555fa3c84c64c2u64;\n+        self.engine.H2 = 0x2393b86b6f53b151u64;\n+        self.engine.H3 = 0x963877195940eabdu64;\n+        self.engine.H4 = 0x96283ee2a88effe3u64;\n+        self.engine.H5 = 0xbe5e1e2553863992u64;\n+        self.engine.H6 = 0x2b0199fc2c85b8aau64;\n+        self.engine.H7 = 0x0eb72ddc81c52ca2u64;\n+    }\n+\n+    fn output_bits(&self) -> uint { 256 }\n+}\n+\n+impl Digest for Sha512Trunc224 {\n+    fn input(&mut self, d: &[u8]) {\n+        self.engine.input_vec(d);\n+    }\n+\n+    fn result(&mut self, out: &mut [u8]) {\n+        self.engine.result_224(out)\n+    }\n+\n+    fn reset(&mut self) {\n+        self.engine.reset();\n+\n+        self.engine.H0 = 0x8c3d37c819544da2u64;\n+        self.engine.H1 = 0x73e1996689dcd4d6u64;\n+        self.engine.H2 = 0x1dfab7ae32ff9c82u64;\n+        self.engine.H3 = 0x679dd514582f9fcfu64;\n+        self.engine.H4 = 0x0f6d2b697bd44da8u64;\n+        self.engine.H5 = 0x77e36f7304c48942u64;\n+        self.engine.H6 = 0x3f9d85a86a1d36c8u64;\n+        self.engine.H7 = 0x1112e6ad91d692a1u64;\n+    }\n+\n+    fn output_bits(&self) -> uint { 224 }\n+}\n+\n+impl Digest for Sha256 {\n+    fn input(&mut self, d: &[u8]) {\n+        self.engine.input_vec(d);\n+    }\n+\n+    fn result(&mut self, out: &mut [u8]) {\n+        self.engine.result_256(out)\n+    }\n+\n+    fn reset(&mut self) {\n+        self.engine.reset();\n+\n+        self.engine.H0 = 0x6a09e667u32;\n+        self.engine.H1 = 0xbb67ae85u32;\n+        self.engine.H2 = 0x3c6ef372u32;\n+        self.engine.H3 = 0xa54ff53au32;\n+        self.engine.H4 = 0x510e527fu32;\n+        self.engine.H5 = 0x9b05688cu32;\n+        self.engine.H6 = 0x1f83d9abu32;\n+        self.engine.H7 = 0x5be0cd19u32;\n+    }\n+\n+    fn output_bits(&self) -> uint { 256 }\n+}\n+\n+impl Digest for Sha224 {\n+    fn input(&mut self, d: &[u8]) {\n+        self.engine.input_vec(d);\n+    }\n+\n+    fn result(&mut self, out: &mut [u8]) {\n+        self.engine.result_224(out)\n+    }\n+\n+    fn reset(&mut self) {\n+        self.engine.reset();\n+\n+        self.engine.H0 = 0xc1059ed8u32;\n+        self.engine.H1 = 0x367cd507u32;\n+        self.engine.H2 = 0x3070dd17u32;\n+        self.engine.H3 = 0xf70e5939u32;\n+        self.engine.H4 = 0xffc00b31u32;\n+        self.engine.H5 = 0x68581511u32;\n+        self.engine.H6 = 0x64f98fa7u32;\n+        self.engine.H7 = 0xbefa4fa4u32;\n+    }\n+\n+    fn output_bits(&self) -> uint { 224 }\n+}\n+\n+\n+#[cfg(test)]\n+mod tests {\n+    use digest::{Digest, DigestUtil};\n+    use sha2::{Sha512, Sha384, Sha512Trunc256, Sha512Trunc224, Sha256, Sha224};\n+\n+    struct Test {\n+        input: ~str,\n+        output_str: ~str,\n+    }\n+\n+    fn test_hash<D: Digest>(sh: &mut D, tests: &[Test]) {\n+        // Test that it works when accepting the message all at once\n+        for tests.iter().advance() |t| {\n+            sh.input_str(t.input);\n+\n+            let out_str = sh.result_str();\n+            assert!(out_str == t.output_str);\n+\n+            sh.reset();\n+        }\n+\n+        // Test that it works when accepting the message in pieces\n+        for tests.iter().advance() |t| {\n+            let len = t.input.len();\n+            let mut left = len;\n+            while left > 0u {\n+                let take = (left + 1u) / 2u;\n+                sh.input_str(t.input.slice(len - left, take + len - left));\n+                left = left - take;\n+            }\n+\n+            let out_str = sh.result_str();\n+            assert!(out_str == t.output_str);\n+\n+            sh.reset();\n+        }\n+    }\n+\n+    #[test]\n+    fn test_sha512() {\n+        // Examples from wikipedia\n+        let wikipedia_tests = ~[\n+            Test {\n+                input: ~\"\",\n+                output_str: ~\"cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce\" +\n+                             \"47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e\"\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog\",\n+                output_str: ~\"07e547d9586f6a73f73fbac0435ed76951218fb7d0c8d788a309d785436bbb64\" +\n+                             \"2e93a252a954f23912547d1e8a3b5ed6e1bfd7097821233fa0538f3db854fee6\"\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog.\",\n+                output_str: ~\"91ea1245f20d46ae9a037a989f54f1f790f0a47607eeb8a14d12890cea77a1bb\" +\n+                             \"c6c7ed9cf205e67b7f2b8fd4c7dfd3a7a8617e45f3c463d481c7e586c39ac1ed\"\n+            },\n+        ];\n+\n+        let tests = wikipedia_tests;\n+\n+        let mut sh = ~Sha512::new();\n+\n+        test_hash(sh, tests);\n+    }\n+\n+    #[test]\n+    fn test_sha384() {\n+        // Examples from wikipedia\n+        let wikipedia_tests = ~[\n+            Test {\n+                input: ~\"\",\n+                output_str: ~\"38b060a751ac96384cd9327eb1b1e36a21fdb71114be0743\" +\n+                             \"4c0cc7bf63f6e1da274edebfe76f65fbd51ad2f14898b95b\"\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog\",\n+                output_str: ~\"ca737f1014a48f4c0b6dd43cb177b0afd9e5169367544c49\" +\n+                             \"4011e3317dbf9a509cb1e5dc1e85a941bbee3d7f2afbc9b1\"\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog.\",\n+                output_str: ~\"ed892481d8272ca6df370bf706e4d7bc1b5739fa2177aae6\" +\n+                             \"c50e946678718fc67a7af2819a021c2fc34e91bdb63409d7\"\n+            },\n+        ];\n+\n+        let tests = wikipedia_tests;\n+\n+        let mut sh = ~Sha384::new();\n+\n+        test_hash(sh, tests);\n+    }\n+\n+    #[test]\n+    fn test_sha512_256() {\n+        // Examples from wikipedia\n+        let wikipedia_tests = ~[\n+            Test {\n+                input: ~\"\",\n+                output_str: ~\"c672b8d1ef56ed28ab87c3622c5114069bdd3ad7b8f9737498d0c01ecef0967a\"\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog\",\n+                output_str: ~\"dd9d67b371519c339ed8dbd25af90e976a1eeefd4ad3d889005e532fc5bef04d\"\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog.\",\n+                output_str: ~\"1546741840f8a492b959d9b8b2344b9b0eb51b004bba35c0aebaac86d45264c3\"\n+            },\n+        ];\n+\n+        let tests = wikipedia_tests;\n+\n+        let mut sh = ~Sha512Trunc256::new();\n+\n+        test_hash(sh, tests);\n+    }\n+\n+    #[test]\n+    fn test_sha512_224() {\n+        // Examples from wikipedia\n+        let wikipedia_tests = ~[\n+            Test {\n+                input: ~\"\",\n+                output_str: ~\"6ed0dd02806fa89e25de060c19d3ac86cabb87d6a0ddd05c333b84f4\"\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog\",\n+                output_str: ~\"944cd2847fb54558d4775db0485a50003111c8e5daa63fe722c6aa37\"\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog.\",\n+                output_str: ~\"6d6a9279495ec4061769752e7ff9c68b6b0b3c5a281b7917ce0572de\"\n+            },\n+        ];\n+\n+        let tests = wikipedia_tests;\n+\n+        let mut sh = ~Sha512Trunc224::new();\n+\n+        test_hash(sh, tests);\n+    }\n+\n+    #[test]\n+    fn test_sha256() {\n+        // Examples from wikipedia\n+        let wikipedia_tests = ~[\n+            Test {\n+                input: ~\"\",\n+                output_str: ~\"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\"\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog\",\n+                output_str: ~\"d7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592\"\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog.\",\n+                output_str: ~\"ef537f25c895bfa782526529a9b63d97aa631564d5d789c2b765448c8635fb6c\"\n+            },\n+        ];\n+\n+        let tests = wikipedia_tests;\n+\n+        let mut sh = ~Sha256::new();\n+\n+        test_hash(sh, tests);\n+    }\n+\n+    #[test]\n+    fn test_sha224() {\n+        // Examples from wikipedia\n+        let wikipedia_tests = ~[\n+            Test {\n+                input: ~\"\",\n+                output_str: ~\"d14a028c2a3a2bc9476102bb288234c415a2b01f828ea62ac5b3e42f\"\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog\",\n+                output_str: ~\"730e109bd7a8a32b1cb9d9a09aa2325d2430587ddbc0c38bad911525\"\n+            },\n+            Test {\n+                input: ~\"The quick brown fox jumps over the lazy dog.\",\n+                output_str: ~\"619cba8e8e05826e9b8c519c0a5c68f4fb653e8a3d8aa04bb2c8cd4c\"\n+            },\n+        ];\n+\n+        let tests = wikipedia_tests;\n+\n+        let mut sh = ~Sha224::new();\n+\n+        test_hash(sh, tests);\n+    }\n+}"}, {"sha": "84b48c87890b2efeeaf84ec944c1002d050c5ec7", "filename": "src/libextra/sha1.rs", "status": "removed", "additions": 0, "deletions": 410, "changes": 410, "blob_url": "https://github.com/rust-lang/rust/blob/ac4211ef52a3577f901ed4dc7f370b05ca4e638d/src%2Flibextra%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac4211ef52a3577f901ed4dc7f370b05ca4e638d/src%2Flibextra%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsha1.rs?ref=ac4211ef52a3577f901ed4dc7f370b05ca4e638d", "patch": "@@ -1,410 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n- * An implementation of the SHA-1 cryptographic hash.\n- *\n- * First create a `sha1` object using the `sha1` constructor, then\n- * feed it input using the `input` or `input_str` methods, which may be\n- * called any number of times.\n- *\n- * After the entire input has been fed to the hash read the result using\n- * the `result` or `result_str` methods.\n- *\n- * The `sha1` object may be reused to create multiple hashes by calling\n- * the `reset` method.\n- */\n-\n-use core::prelude::*;\n-\n-use core::uint;\n-use core::vec;\n-\n-/*\n- * A SHA-1 implementation derived from Paul E. Jones's reference\n- * implementation, which is written for clarity, not speed. At some\n- * point this will want to be rewritten.\n- */\n-\n-/// The SHA-1 interface\n-trait Sha1 {\n-    /// Provide message input as bytes\n-    fn input(&mut self, &[u8]);\n-    /// Provide message input as string\n-    fn input_str(&mut self, &str);\n-    /**\n-     * Read the digest as a vector of 20 bytes. After calling this no further\n-     * input may be provided until reset is called.\n-     */\n-    fn result(&mut self) -> ~[u8];\n-    /**\n-     * Read the digest as a hex string. After calling this no further\n-     * input may be provided until reset is called.\n-     */\n-    fn result_str(&mut self) -> ~str;\n-    /// Reset the SHA-1 state for reuse\n-    fn reset(&mut self);\n-}\n-\n-// Some unexported constants\n-static digest_buf_len: uint = 5u;\n-static msg_block_len: uint = 64u;\n-static work_buf_len: uint = 80u;\n-static k0: u32 = 0x5A827999u32;\n-static k1: u32 = 0x6ED9EBA1u32;\n-static k2: u32 = 0x8F1BBCDCu32;\n-static k3: u32 = 0xCA62C1D6u32;\n-\n-\n-/// Construct a `sha` object\n-pub fn sha1() -> @Sha1 {\n-    struct Sha1State\n-        { h: ~[u32],\n-          len_low: u32,\n-          len_high: u32,\n-          msg_block: ~[u8],\n-          msg_block_idx: uint,\n-          computed: bool,\n-          work_buf: @mut ~[u32]};\n-\n-    fn add_input(st: &mut Sha1State, msg: &[u8]) {\n-        assert!((!st.computed));\n-        for msg.iter().advance |element| {\n-            st.msg_block[st.msg_block_idx] = *element;\n-            st.msg_block_idx += 1u;\n-            st.len_low += 8u32;\n-            if st.len_low == 0u32 {\n-                st.len_high += 1u32;\n-                if st.len_high == 0u32 {\n-                    // FIXME: Need better failure mode (#2346)\n-                    fail!();\n-                }\n-            }\n-            if st.msg_block_idx == msg_block_len { process_msg_block(st); }\n-        }\n-    }\n-    fn process_msg_block(st: &mut Sha1State) {\n-        assert_eq!(st.h.len(), digest_buf_len);\n-        assert_eq!(st.work_buf.len(), work_buf_len);\n-        let mut t: int; // Loop counter\n-        let w = st.work_buf;\n-\n-        // Initialize the first 16 words of the vector w\n-        t = 0;\n-        while t < 16 {\n-            let mut tmp;\n-            tmp = (st.msg_block[t * 4] as u32) << 24u32;\n-            tmp = tmp | (st.msg_block[t * 4 + 1] as u32) << 16u32;\n-            tmp = tmp | (st.msg_block[t * 4 + 2] as u32) << 8u32;\n-            tmp = tmp | (st.msg_block[t * 4 + 3] as u32);\n-            w[t] = tmp;\n-            t += 1;\n-        }\n-\n-        // Initialize the rest of vector w\n-        while t < 80 {\n-            let val = w[t - 3] ^ w[t - 8] ^ w[t - 14] ^ w[t - 16];\n-            w[t] = circular_shift(1u32, val);\n-            t += 1;\n-        }\n-        let mut a = st.h[0];\n-        let mut b = st.h[1];\n-        let mut c = st.h[2];\n-        let mut d = st.h[3];\n-        let mut e = st.h[4];\n-        let mut temp: u32;\n-        t = 0;\n-        while t < 20 {\n-            temp = circular_shift(5u32, a) + (b & c | !b & d) + e + w[t] + k0;\n-            e = d;\n-            d = c;\n-            c = circular_shift(30u32, b);\n-            b = a;\n-            a = temp;\n-            t += 1;\n-        }\n-        while t < 40 {\n-            temp = circular_shift(5u32, a) + (b ^ c ^ d) + e + w[t] + k1;\n-            e = d;\n-            d = c;\n-            c = circular_shift(30u32, b);\n-            b = a;\n-            a = temp;\n-            t += 1;\n-        }\n-        while t < 60 {\n-            temp =\n-                circular_shift(5u32, a) + (b & c | b & d | c & d) + e + w[t] +\n-                    k2;\n-            e = d;\n-            d = c;\n-            c = circular_shift(30u32, b);\n-            b = a;\n-            a = temp;\n-            t += 1;\n-        }\n-        while t < 80 {\n-            temp = circular_shift(5u32, a) + (b ^ c ^ d) + e + w[t] + k3;\n-            e = d;\n-            d = c;\n-            c = circular_shift(30u32, b);\n-            b = a;\n-            a = temp;\n-            t += 1;\n-        }\n-        st.h[0] = st.h[0] + a;\n-        st.h[1] = st.h[1] + b;\n-        st.h[2] = st.h[2] + c;\n-        st.h[3] = st.h[3] + d;\n-        st.h[4] = st.h[4] + e;\n-        st.msg_block_idx = 0u;\n-    }\n-    fn circular_shift(bits: u32, word: u32) -> u32 {\n-        return word << bits | word >> 32u32 - bits;\n-    }\n-    fn mk_result(st: &mut Sha1State) -> ~[u8] {\n-        if !(*st).computed { pad_msg(st); (*st).computed = true; }\n-        let mut rs: ~[u8] = ~[];\n-        for st.h.mut_iter().advance |ptr_hpart| {\n-            let hpart = *ptr_hpart;\n-            let a = (hpart >> 24u32 & 0xFFu32) as u8;\n-            let b = (hpart >> 16u32 & 0xFFu32) as u8;\n-            let c = (hpart >> 8u32 & 0xFFu32) as u8;\n-            let d = (hpart & 0xFFu32) as u8;\n-            rs = vec::append(copy rs, [a, b, c, d]);\n-        }\n-        return rs;\n-    }\n-\n-    /*\n-     * According to the standard, the message must be padded to an even\n-     * 512 bits.  The first padding bit must be a '1'.  The last 64 bits\n-     * represent the length of the original message.  All bits in between\n-     * should be 0.  This function will pad the message according to those\n-     * rules by filling the msg_block vector accordingly.  It will also\n-     * call process_msg_block() appropriately.  When it returns, it\n-     * can be assumed that the message digest has been computed.\n-     */\n-    fn pad_msg(st: &mut Sha1State) {\n-        assert_eq!((*st).msg_block.len(), msg_block_len);\n-\n-        /*\n-         * Check to see if the current message block is too small to hold\n-         * the initial padding bits and length.  If so, we will pad the\n-         * block, process it, and then continue padding into a second block.\n-         */\n-        if (*st).msg_block_idx > 55u {\n-            (*st).msg_block[(*st).msg_block_idx] = 0x80u8;\n-            (*st).msg_block_idx += 1u;\n-            while (*st).msg_block_idx < msg_block_len {\n-                (*st).msg_block[(*st).msg_block_idx] = 0u8;\n-                (*st).msg_block_idx += 1u;\n-            }\n-            process_msg_block(st);\n-        } else {\n-            (*st).msg_block[(*st).msg_block_idx] = 0x80u8;\n-            (*st).msg_block_idx += 1u;\n-        }\n-        while (*st).msg_block_idx < 56u {\n-            (*st).msg_block[(*st).msg_block_idx] = 0u8;\n-            (*st).msg_block_idx += 1u;\n-        }\n-\n-        // Store the message length as the last 8 octets\n-        (*st).msg_block[56] = ((*st).len_high >> 24u32 & 0xFFu32) as u8;\n-        (*st).msg_block[57] = ((*st).len_high >> 16u32 & 0xFFu32) as u8;\n-        (*st).msg_block[58] = ((*st).len_high >> 8u32 & 0xFFu32) as u8;\n-        (*st).msg_block[59] = ((*st).len_high & 0xFFu32) as u8;\n-        (*st).msg_block[60] = ((*st).len_low >> 24u32 & 0xFFu32) as u8;\n-        (*st).msg_block[61] = ((*st).len_low >> 16u32 & 0xFFu32) as u8;\n-        (*st).msg_block[62] = ((*st).len_low >> 8u32 & 0xFFu32) as u8;\n-        (*st).msg_block[63] = ((*st).len_low & 0xFFu32) as u8;\n-        process_msg_block(st);\n-    }\n-\n-    impl Sha1 for Sha1State {\n-        fn reset(&mut self) {\n-            assert_eq!(self.h.len(), digest_buf_len);\n-            self.len_low = 0u32;\n-            self.len_high = 0u32;\n-            self.msg_block_idx = 0u;\n-            self.h[0] = 0x67452301u32;\n-            self.h[1] = 0xEFCDAB89u32;\n-            self.h[2] = 0x98BADCFEu32;\n-            self.h[3] = 0x10325476u32;\n-            self.h[4] = 0xC3D2E1F0u32;\n-            self.computed = false;\n-        }\n-        fn input(&mut self, msg: &[u8]) { add_input(self, msg); }\n-        fn input_str(&mut self, msg: &str) {\n-            add_input(self, msg.as_bytes());\n-        }\n-        fn result(&mut self) -> ~[u8] { return mk_result(self); }\n-        fn result_str(&mut self) -> ~str {\n-            let rr = mk_result(self);\n-            let mut s = ~\"\";\n-            for rr.iter().advance |b| {\n-                let hex = uint::to_str_radix(*b as uint, 16u);\n-                if hex.len() == 1 {\n-                    s += \"0\";\n-                }\n-                s += hex;\n-            }\n-            return s;\n-        }\n-    }\n-    let st = Sha1State {\n-         h: vec::from_elem(digest_buf_len, 0u32),\n-         len_low: 0u32,\n-         len_high: 0u32,\n-         msg_block: vec::from_elem(msg_block_len, 0u8),\n-         msg_block_idx: 0u,\n-         computed: false,\n-         work_buf: @mut vec::from_elem(work_buf_len, 0u32)\n-    };\n-    let mut sh = @st as @Sha1;\n-    sh.reset();\n-    return sh;\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use sha1;\n-\n-    #[test]\n-    fn test() {\n-        struct Test {\n-            input: ~str,\n-            output: ~[u8],\n-            output_str: ~str,\n-        }\n-\n-        fn a_million_letter_a() -> ~str {\n-            let mut i = 0;\n-            let mut rs = ~\"\";\n-            while i < 100000 {\n-                rs.push_str(\"aaaaaaaaaa\");\n-                i += 1;\n-            }\n-            return rs;\n-        }\n-        // Test messages from FIPS 180-1\n-\n-        let fips_180_1_tests = ~[\n-            Test {\n-                input: ~\"abc\",\n-                output: ~[\n-                    0xA9u8, 0x99u8, 0x3Eu8, 0x36u8,\n-                    0x47u8, 0x06u8, 0x81u8, 0x6Au8,\n-                    0xBAu8, 0x3Eu8, 0x25u8, 0x71u8,\n-                    0x78u8, 0x50u8, 0xC2u8, 0x6Cu8,\n-                    0x9Cu8, 0xD0u8, 0xD8u8, 0x9Du8,\n-                ],\n-                output_str: ~\"a9993e364706816aba3e25717850c26c9cd0d89d\"\n-            },\n-            Test {\n-                input:\n-                     ~\"abcdbcdecdefdefgefghfghighij\" +\n-                     \"hijkijkljklmklmnlmnomnopnopq\",\n-                output: ~[\n-                    0x84u8, 0x98u8, 0x3Eu8, 0x44u8,\n-                    0x1Cu8, 0x3Bu8, 0xD2u8, 0x6Eu8,\n-                    0xBAu8, 0xAEu8, 0x4Au8, 0xA1u8,\n-                    0xF9u8, 0x51u8, 0x29u8, 0xE5u8,\n-                    0xE5u8, 0x46u8, 0x70u8, 0xF1u8,\n-                ],\n-                output_str: ~\"84983e441c3bd26ebaae4aa1f95129e5e54670f1\"\n-            },\n-            Test {\n-                input: a_million_letter_a(),\n-                output: ~[\n-                    0x34u8, 0xAAu8, 0x97u8, 0x3Cu8,\n-                    0xD4u8, 0xC4u8, 0xDAu8, 0xA4u8,\n-                    0xF6u8, 0x1Eu8, 0xEBu8, 0x2Bu8,\n-                    0xDBu8, 0xADu8, 0x27u8, 0x31u8,\n-                    0x65u8, 0x34u8, 0x01u8, 0x6Fu8,\n-                ],\n-                output_str: ~\"34aa973cd4c4daa4f61eeb2bdbad27316534016f\"\n-            },\n-        ];\n-        // Examples from wikipedia\n-\n-        let wikipedia_tests = ~[\n-            Test {\n-                input: ~\"The quick brown fox jumps over the lazy dog\",\n-                output: ~[\n-                    0x2fu8, 0xd4u8, 0xe1u8, 0xc6u8,\n-                    0x7au8, 0x2du8, 0x28u8, 0xfcu8,\n-                    0xedu8, 0x84u8, 0x9eu8, 0xe1u8,\n-                    0xbbu8, 0x76u8, 0xe7u8, 0x39u8,\n-                    0x1bu8, 0x93u8, 0xebu8, 0x12u8,\n-                ],\n-                output_str: ~\"2fd4e1c67a2d28fced849ee1bb76e7391b93eb12\",\n-            },\n-            Test {\n-                input: ~\"The quick brown fox jumps over the lazy cog\",\n-                output: ~[\n-                    0xdeu8, 0x9fu8, 0x2cu8, 0x7fu8,\n-                    0xd2u8, 0x5eu8, 0x1bu8, 0x3au8,\n-                    0xfau8, 0xd3u8, 0xe8u8, 0x5au8,\n-                    0x0bu8, 0xd1u8, 0x7du8, 0x9bu8,\n-                    0x10u8, 0x0du8, 0xb4u8, 0xb3u8,\n-                ],\n-                output_str: ~\"de9f2c7fd25e1b3afad3e85a0bd17d9b100db4b3\",\n-            },\n-        ];\n-        let tests = fips_180_1_tests + wikipedia_tests;\n-        fn check_vec_eq(v0: ~[u8], v1: ~[u8]) {\n-            assert_eq!(v0.len(), v1.len());\n-            let len = v0.len();\n-            let mut i = 0u;\n-            while i < len {\n-                let a = v0[i];\n-                let b = v1[i];\n-                assert_eq!(a, b);\n-                i += 1u;\n-            }\n-        }\n-        // Test that it works when accepting the message all at once\n-\n-        let mut sh = sha1::sha1();\n-        for tests.iter().advance |t| {\n-            sh.input_str(t.input);\n-            let out = sh.result();\n-            check_vec_eq(copy t.output, out);\n-\n-            let out_str = sh.result_str();\n-            assert_eq!(out_str.len(), 40);\n-            assert!(out_str == t.output_str);\n-\n-            sh.reset();\n-        }\n-\n-\n-        // Test that it works when accepting the message in pieces\n-        for tests.iter().advance |t| {\n-            let len = t.input.len();\n-            let mut left = len;\n-            while left > 0u {\n-                let take = (left + 1u) / 2u;\n-                sh.input_str(t.input.slice(len - left, take + len - left));\n-                left = left - take;\n-            }\n-            let out = sh.result();\n-            check_vec_eq(copy t.output, out);\n-\n-            let out_str = sh.result_str();\n-            assert_eq!(out_str.len(), 40);\n-            assert!(out_str == t.output_str);\n-\n-            sh.reset();\n-        }\n-    }\n-}"}, {"sha": "11aebdf467ff29ac7ba8857d0b26adcb3156f0ac", "filename": "src/libextra/std.rc", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/832fe327218e556740ba4e028b7b60cb41212469/src%2Flibextra%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/832fe327218e556740ba4e028b7b60cb41212469/src%2Flibextra%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstd.rc?ref=832fe327218e556740ba4e028b7b60cb41212469", "patch": "@@ -86,13 +86,20 @@ pub mod sort;\n pub mod dlist;\n pub mod treemap;\n \n+// Crypto\n+#[path=\"crypto/digest.rs\"]\n+pub mod digest;\n+#[path=\"crypto/sha1.rs\"]\n+pub mod sha1;\n+#[path=\"crypto/sha2.rs\"]\n+pub mod sha2;\n+\n // And ... other stuff\n \n pub mod ebml;\n pub mod dbg;\n pub mod getopts;\n pub mod json;\n-pub mod sha1;\n pub mod md4;\n pub mod tempfile;\n pub mod term;"}, {"sha": "ed675bf99e9dd72dd0da3446c2b729dfc5fea77d", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/832fe327218e556740ba4e028b7b60cb41212469/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/832fe327218e556740ba4e028b7b60cb41212469/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=832fe327218e556740ba4e028b7b60cb41212469", "patch": "@@ -12,8 +12,9 @@\n \n use core::prelude::*;\n \n+use digest::DigestUtil;\n use json;\n-use sha1;\n+use sha1::Sha1;\n use serialize::{Encoder, Encodable, Decoder, Decodable};\n use sort;\n \n@@ -248,16 +249,16 @@ fn json_decode<T:Decodable<json::Decoder>>(s: &str) -> T {\n }\n \n fn digest<T:Encodable<json::Encoder>>(t: &T) -> ~str {\n-    let mut sha = sha1::sha1();\n-    sha.input_str(json_encode(t));\n-    sha.result_str()\n+    let mut sha = ~Sha1::new();\n+    (*sha).input_str(json_encode(t));\n+    (*sha).result_str()\n }\n \n fn digest_file(path: &Path) -> ~str {\n-    let mut sha = sha1::sha1();\n+    let mut sha = ~Sha1::new();\n     let s = io::read_whole_file_str(path);\n-    sha.input_str(*s.get_ref());\n-    sha.result_str()\n+    (*sha).input_str(*s.get_ref());\n+    (*sha).result_str()\n }\n \n impl Context {"}]}