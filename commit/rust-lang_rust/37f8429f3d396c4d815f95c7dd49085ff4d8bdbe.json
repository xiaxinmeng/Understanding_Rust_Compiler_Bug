{"sha": "37f8429f3d396c4d815f95c7dd49085ff4d8bdbe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3Zjg0MjlmM2QzOTZjNGQ4MTVmOTVjN2RkNDkwODVmZjRkOGJkYmU=", "commit": {"author": {"name": "Benjamin Herr", "email": "ben@0x539.de", "date": "2016-03-28T21:21:01Z"}, "committer": {"name": "Benjamin Herr", "email": "ben@0x539.de", "date": "2016-03-31T20:06:52Z"}, "message": "librustc_save_analysis: use bug!(), span_bug!()", "tree": {"sha": "07417a25ff9cfbe24f2ef1c5685ce3844831eb18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07417a25ff9cfbe24f2ef1c5685ce3844831eb18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37f8429f3d396c4d815f95c7dd49085ff4d8bdbe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37f8429f3d396c4d815f95c7dd49085ff4d8bdbe", "html_url": "https://github.com/rust-lang/rust/commit/37f8429f3d396c4d815f95c7dd49085ff4d8bdbe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37f8429f3d396c4d815f95c7dd49085ff4d8bdbe/comments", "author": {"login": "ben0x539", "id": 24142, "node_id": "MDQ6VXNlcjI0MTQy", "avatar_url": "https://avatars.githubusercontent.com/u/24142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ben0x539", "html_url": "https://github.com/ben0x539", "followers_url": "https://api.github.com/users/ben0x539/followers", "following_url": "https://api.github.com/users/ben0x539/following{/other_user}", "gists_url": "https://api.github.com/users/ben0x539/gists{/gist_id}", "starred_url": "https://api.github.com/users/ben0x539/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ben0x539/subscriptions", "organizations_url": "https://api.github.com/users/ben0x539/orgs", "repos_url": "https://api.github.com/users/ben0x539/repos", "events_url": "https://api.github.com/users/ben0x539/events{/privacy}", "received_events_url": "https://api.github.com/users/ben0x539/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ben0x539", "id": 24142, "node_id": "MDQ6VXNlcjI0MTQy", "avatar_url": "https://avatars.githubusercontent.com/u/24142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ben0x539", "html_url": "https://github.com/ben0x539", "followers_url": "https://api.github.com/users/ben0x539/followers", "following_url": "https://api.github.com/users/ben0x539/following{/other_user}", "gists_url": "https://api.github.com/users/ben0x539/gists{/gist_id}", "starred_url": "https://api.github.com/users/ben0x539/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ben0x539/subscriptions", "organizations_url": "https://api.github.com/users/ben0x539/orgs", "repos_url": "https://api.github.com/users/ben0x539/repos", "events_url": "https://api.github.com/users/ben0x539/events{/privacy}", "received_events_url": "https://api.github.com/users/ben0x539/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d05f726eed5a977d546a92d64d2402cb049e505e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d05f726eed5a977d546a92d64d2402cb049e505e", "html_url": "https://github.com/rust-lang/rust/commit/d05f726eed5a977d546a92d64d2402cb049e505e"}], "stats": {"total": 134, "additions": 63, "deletions": 71}, "files": [{"sha": "ed0930128e5485b05e32c4cfd93d62a8f271360e", "filename": "src/librustc_save_analysis/data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37f8429f3d396c4d815f95c7dd49085ff4d8bdbe/src%2Flibrustc_save_analysis%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37f8429f3d396c4d815f95c7dd49085ff4d8bdbe/src%2Flibrustc_save_analysis%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdata.rs?ref=37f8429f3d396c4d815f95c7dd49085ff4d8bdbe", "patch": "@@ -22,11 +22,11 @@ use syntax::codemap::Span;\n \n #[macro_export]\n macro_rules! down_cast_data {\n-    ($id:ident, $kind:ident, $this:ident, $sp:expr) => {\n+    ($id:ident, $kind:ident, $sp:expr) => {\n         let $id = if let super::Data::$kind(data) = $id {\n             data\n         } else {\n-            $this.sess.span_bug($sp, &format!(\"unexpected data kind: {:?}\", $id));\n+            span_bug!($sp, \"unexpected data kind: {:?}\", $id);\n         }\n     };\n }"}, {"sha": "35ca2a9b0149a5c80acb5df9795f604924b75e08", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 26, "deletions": 29, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/37f8429f3d396c4d815f95c7dd49085ff4d8bdbe/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37f8429f3d396c4d815f95c7dd49085ff4d8bdbe/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=37f8429f3d396c4d815f95c7dd49085ff4d8bdbe", "patch": "@@ -51,11 +51,11 @@ use super::span_utils::SpanUtils;\n use super::recorder;\n \n macro_rules! down_cast_data {\n-    ($id:ident, $kind:ident, $this:ident, $sp:expr) => {\n+    ($id:ident, $kind:ident, $sp:expr) => {\n         let $id = if let super::Data::$kind(data) = $id {\n             data\n         } else {\n-            $this.sess.span_bug($sp, &format!(\"unexpected data kind: {:?}\", $id));\n+            span_bug!($sp, \"unexpected data kind: {:?}\", $id);\n         }\n     };\n }\n@@ -271,8 +271,7 @@ where D: Dump\n     // looks up anything, not just a type\n     fn lookup_type_ref(&self, ref_id: NodeId) -> Option<DefId> {\n         if !self.tcx.def_map.borrow().contains_key(&ref_id) {\n-            self.sess.bug(&format!(\"def_map has no key for {} in lookup_type_ref\",\n-                                   ref_id));\n+            bug!(\"def_map has no key for {} in lookup_type_ref\", ref_id);\n         }\n         let def = self.tcx.def_map.borrow().get(&ref_id).unwrap().full_def();\n         match def {\n@@ -294,9 +293,9 @@ where D: Dump\n \n         let def_map = self.tcx.def_map.borrow();\n         if !def_map.contains_key(&ref_id) {\n-            self.sess.span_bug(span,\n-                               &format!(\"def_map has no key for {} in lookup_def_kind\",\n-                                        ref_id));\n+            span_bug!(span,\n+                      \"def_map has no key for {} in lookup_def_kind\",\n+                      ref_id);\n         }\n         let def = def_map.get(&ref_id).unwrap().full_def();\n         match def {\n@@ -347,8 +346,9 @@ where D: Dump\n             Def::Method(..) |\n             Def::PrimTy(_) |\n             Def::Err => {\n-                self.sess.span_bug(span,\n-                                   &format!(\"process_def_kind for unexpected item: {:?}\", def));\n+               span_bug!(span,\n+                         \"process_def_kind for unexpected item: {:?}\",\n+                         def);\n             }\n         }\n     }\n@@ -480,7 +480,7 @@ where D: Dump\n                   ty_params: &ast::Generics,\n                   body: &ast::Block) {\n         if let Some(fn_data) = self.save_ctxt.get_item_data(item) {\n-            down_cast_data!(fn_data, FunctionData, self, item.span);\n+            down_cast_data!(fn_data, FunctionData, item.span);\n             if !self.span.filter_generated(Some(fn_data.span), item.span) {\n                 self.dumper.function(item.span, fn_data.clone().normalize(&self.tcx));\n             }\n@@ -502,7 +502,7 @@ where D: Dump\n \n     fn process_static_or_const_item(&mut self, item: &ast::Item, typ: &ast::Ty, expr: &ast::Expr) {\n         if let Some(var_data) = self.save_ctxt.get_item_data(item) {\n-            down_cast_data!(var_data, VariableData, self, item.span);\n+            down_cast_data!(var_data, VariableData, item.span);\n             if !self.span.filter_generated(Some(var_data.span), item.span) {\n                 let mut var_data = var_data;\n                 var_data.scope = normalize_node_id(&self.tcx, var_data.scope) as u32;\n@@ -578,7 +578,7 @@ where D: Dump\n             None => return,\n             Some(data) => data,\n         };\n-        down_cast_data!(enum_data, EnumData, self, item.span);\n+        down_cast_data!(enum_data, EnumData, item.span);\n         let normalized = enum_data.clone().normalize(&self.tcx);\n         if !self.span.filter_generated(Some(normalized.span), item.span) {\n             self.dumper.enum_data(item.span, normalized);\n@@ -638,7 +638,7 @@ where D: Dump\n                     impl_items: &[ast::ImplItem]) {\n         let mut has_self_ref = false;\n         if let Some(impl_data) = self.save_ctxt.get_item_data(item) {\n-            down_cast_data!(impl_data, ImplData, self, item.span);\n+            down_cast_data!(impl_data, ImplData, item.span);\n             if let Some(ref self_ref) = impl_data.self_ref {\n                 has_self_ref = true;\n                 if !self.span.filter_generated(Some(self_ref.span), item.span) {\n@@ -734,7 +734,7 @@ where D: Dump\n     // `item` is the module in question, represented as an item.\n     fn process_mod(&mut self, item: &ast::Item) {\n         if let Some(mod_data) = self.save_ctxt.get_item_data(item) {\n-            down_cast_data!(mod_data, ModData, self, item.span);\n+            down_cast_data!(mod_data, ModData, item.span);\n             if !self.span.filter_generated(Some(mod_data.span), item.span) {\n                 self.dumper.mod_data(mod_data.normalize(&self.tcx));\n             }\n@@ -750,10 +750,9 @@ where D: Dump\n         let path_data = match path_data {\n             Some(pd) => pd,\n             None => {\n-                self.tcx.sess.span_bug(path.span,\n-                                       &format!(\"Unexpected def kind while looking up path in \\\n-                                                 `{}`\",\n-                                                self.span.snippet(path.span)))\n+                span_bug!(path.span,\n+                          \"Unexpected def kind while looking up path in `{}`\",\n+                          self.span.snippet(path.span))\n             }\n         };\n \n@@ -807,8 +806,7 @@ where D: Dump\n                 }\n             }\n             _ => {\n-                self.sess.span_bug(path.span,\n-                                   &format!(\"Unexpected data: {:?}\", path_data));\n+               span_bug!(path.span, \"Unexpected data: {:?}\", path_data);\n             }\n         }\n \n@@ -844,7 +842,7 @@ where D: Dump\n         self.write_sub_paths_truncated(path, false);\n \n         if let Some(struct_lit_data) = self.save_ctxt.get_expr_data(ex) {\n-            down_cast_data!(struct_lit_data, TypeRefData, self, ex.span);\n+            down_cast_data!(struct_lit_data, TypeRefData, ex.span);\n             if !self.span.filter_generated(Some(struct_lit_data.span), ex.span) {\n                 self.dumper.type_ref(ex.span, struct_lit_data.normalize(&self.tcx));\n             }\n@@ -869,7 +867,7 @@ where D: Dump\n \n     fn process_method_call(&mut self, ex: &ast::Expr, args: &Vec<P<ast::Expr>>) {\n         if let Some(mcd) = self.save_ctxt.get_expr_data(ex) {\n-            down_cast_data!(mcd, MethodCallData, self, ex.span);\n+            down_cast_data!(mcd, MethodCallData, ex.span);\n             if !self.span.filter_generated(Some(mcd.span), ex.span) {\n                 self.dumper.method_call(ex.span, mcd.normalize(&self.tcx));\n             }\n@@ -1234,7 +1232,7 @@ impl<'l, 'tcx, 'v, D: Dump + 'l> Visitor<'v> for DumpVisitor<'l, 'tcx, D> {\n                 self.visit_expr(&sub_ex);\n \n                 if let Some(field_data) = self.save_ctxt.get_expr_data(ex) {\n-                    down_cast_data!(field_data, VariableRefData, self, ex.span);\n+                    down_cast_data!(field_data, VariableRefData, ex.span);\n                     if !self.span.filter_generated(Some(field_data.span), ex.span) {\n                         self.dumper.variable_ref(ex.span, field_data.normalize(&self.tcx));\n                     }\n@@ -1258,9 +1256,9 @@ impl<'l, 'tcx, 'v, D: Dump + 'l> Visitor<'v> for DumpVisitor<'l, 'tcx, D> {\n                         }\n                     }\n                     ty::TyTuple(_) => {}\n-                    _ => self.sess.span_bug(ex.span,\n-                                            &format!(\"Expected struct or tuple type, found {:?}\",\n-                                                     ty)),\n+                    _ => span_bug!(ex.span,\n+                                   \"Expected struct or tuple type, found {:?}\",\n+                                   ty),\n                 }\n             }\n             ast::ExprKind::Closure(_, ref decl, ref body) => {\n@@ -1302,7 +1300,7 @@ impl<'l, 'tcx, 'v, D: Dump + 'l> Visitor<'v> for DumpVisitor<'l, 'tcx, D> {\n \n     fn visit_mac(&mut self, mac: &ast::Mac) {\n         // These shouldn't exist in the AST at this point, log a span bug.\n-        self.sess.span_bug(mac.span, \"macro invocation should have been expanded out of AST\");\n+        span_bug!(mac.span, \"macro invocation should have been expanded out of AST\");\n     }\n \n     fn visit_pat(&mut self, p: &ast::Pat) {\n@@ -1325,8 +1323,7 @@ impl<'l, 'tcx, 'v, D: Dump + 'l> Visitor<'v> for DumpVisitor<'l, 'tcx, D> {\n         for &(id, ref p, immut, ref_kind) in &collector.collected_paths {\n             let def_map = self.tcx.def_map.borrow();\n             if !def_map.contains_key(&id) {\n-                self.sess.span_bug(p.span,\n-                                   &format!(\"def_map has no key for {} in visit_arm\", id));\n+                span_bug!(p.span, \"def_map has no key for {} in visit_arm\", id);\n             }\n             let def = def_map.get(&id).unwrap().full_def();\n             match def {"}, {"sha": "486966fa3a262b0c09e216a5740f00c3b4ebf28b", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 22, "deletions": 27, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/37f8429f3d396c4d815f95c7dd49085ff4d8bdbe/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37f8429f3d396c4d815f95c7dd49085ff4d8bdbe/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=37f8429f3d396c4d815f95c7dd49085ff4d8bdbe", "patch": "@@ -22,7 +22,7 @@\n #![feature(rustc_private)]\n #![feature(staged_api)]\n \n-extern crate rustc;\n+#[macro_use] extern crate rustc;\n extern crate rustc_front;\n \n #[macro_use] extern crate log;\n@@ -240,7 +240,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             }\n             _ => {\n                 // FIXME\n-                unimplemented!();\n+                bug!();\n             }\n         }\n     }\n@@ -292,21 +292,19 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                             result\n                         }\n                         _ => {\n-                            self.tcx.sess.span_bug(span,\n-                                                   &format!(\"Container {:?} for method {} not \\\n-                                                             an impl?\",\n-                                                            impl_id,\n-                                                            id));\n+                            span_bug!(span,\n+                                      \"Container {:?} for method {} not an impl?\",\n+                                      impl_id,\n+                                      id);\n                         }\n                     }\n                 }\n                 r => {\n-                    self.tcx.sess.span_bug(span,\n-                                           &format!(\"Container {:?} for method {} is not a node \\\n-                                                     item {:?}\",\n-                                                    impl_id,\n-                                                    id,\n-                                                    r));\n+                    span_bug!(span,\n+                              \"Container {:?} for method {} is not a node item {:?}\",\n+                              impl_id,\n+                              id,\n+                              r);\n                 }\n             },\n             None => match self.tcx.trait_of_item(self.tcx.map.local_def_id(id)) {\n@@ -316,18 +314,17 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                             format!(\"::{}\", self.tcx.item_path_str(def_id))\n                         }\n                         r => {\n-                            self.tcx.sess.span_bug(span,\n-                                                   &format!(\"Could not find container {:?} for \\\n-                                                             method {}, got {:?}\",\n-                                                            def_id,\n-                                                            id,\n-                                                            r));\n+                            span_bug!(span,\n+                                      \"Could not find container {:?} for \\\n+                                       method {}, got {:?}\",\n+                                      def_id,\n+                                      id,\n+                                      r);\n                         }\n                     }\n                 }\n                 None => {\n-                    self.tcx.sess.span_bug(span,\n-                                           &format!(\"Could not find container for method {}\", id));\n+                    span_bug!(span, \"Could not find container for method {}\", id);\n                 }\n             },\n         };\n@@ -443,16 +440,15 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             }\n             _ => {\n                 // FIXME\n-                unimplemented!();\n+                bug!();\n             }\n         }\n     }\n \n     pub fn get_path_data(&self, id: NodeId, path: &ast::Path) -> Option<Data> {\n         let def_map = self.tcx.def_map.borrow();\n         if !def_map.contains_key(&id) {\n-            self.tcx.sess.span_bug(path.span,\n-                                   &format!(\"def_map has no key for {} in visit_expr\", id));\n+            span_bug!(path.span, \"def_map has no key for {} in visit_expr\", id);\n         }\n         let def = def_map.get(&id).unwrap().full_def();\n         let sub_span = self.span_utils.span_for_last_ident(path.span);\n@@ -618,13 +614,12 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n     pub fn get_data_for_id(&self, _id: &NodeId) -> Data {\n         // FIXME\n-        unimplemented!();\n+        bug!();\n     }\n \n     fn lookup_ref_id(&self, ref_id: NodeId) -> Option<DefId> {\n         if !self.tcx.def_map.borrow().contains_key(&ref_id) {\n-            self.tcx.sess.bug(&format!(\"def_map has no key for {} in lookup_type_ref\",\n-                                       ref_id));\n+            bug!(\"def_map has no key for {} in lookup_type_ref\", ref_id);\n         }\n         let def = self.tcx.def_map.borrow().get(&ref_id).unwrap().full_def();\n         match def {"}, {"sha": "f410d428177cd6a920706d9d84d3970183bf60ec", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/37f8429f3d396c4d815f95c7dd49085ff4d8bdbe/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37f8429f3d396c4d815f95c7dd49085ff4d8bdbe/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=37f8429f3d396c4d815f95c7dd49085ff4d8bdbe", "patch": "@@ -223,12 +223,12 @@ impl<'a> SpanUtils<'a> {\n         }\n         if bracket_count != 0 {\n             let loc = self.sess.codemap().lookup_char_pos(span.lo);\n-            self.sess.span_bug(span,\n-                               &format!(\"Mis-counted brackets when breaking path? Parsing '{}' \\\n-                                         in {}, line {}\",\n-                                        self.snippet(span),\n-                                        loc.file.name,\n-                                        loc.line));\n+            span_bug!(span,\n+                      \"Mis-counted brackets when breaking path? Parsing '{}' \\\n+                       in {}, line {}\",\n+                      self.snippet(span),\n+                      loc.file.name,\n+                      loc.line);\n         }\n         if result.is_none() && prev.tok.is_ident() && bracket_count == 0 {\n             return self.make_sub_span(span, Some(prev.sp));\n@@ -256,12 +256,12 @@ impl<'a> SpanUtils<'a> {\n                         return vec!();\n                     }\n                     let loc = self.sess.codemap().lookup_char_pos(span.lo);\n-                    self.sess.span_bug(span,\n-                                       &format!(\"Mis-counted brackets when breaking path? \\\n-                                                 Parsing '{}' in {}, line {}\",\n-                                                self.snippet(span),\n-                                                loc.file.name,\n-                                                loc.line));\n+                    span_bug!(span,\n+                              \"Mis-counted brackets when breaking path? \\\n+                               Parsing '{}' in {}, line {}\",\n+                              self.snippet(span),\n+                              loc.file.name,\n+                              loc.line);\n                 }\n                 return result\n             }\n@@ -374,7 +374,7 @@ impl<'a> SpanUtils<'a> {\n               loc.line);\n         self.err_count.set(self.err_count.get() + 1);\n         if self.err_count.get() > 1000 {\n-            self.sess.bug(\"span errors reached 1000, giving up\");\n+            bug!(\"span errors reached 1000, giving up\");\n         }\n     }\n "}]}