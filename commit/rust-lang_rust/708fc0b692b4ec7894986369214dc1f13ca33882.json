{"sha": "708fc0b692b4ec7894986369214dc1f13ca33882", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwOGZjMGI2OTJiNGVjNzg5NDk4NjM2OTIxNGRjMWYxM2NhMzM4ODI=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-02-08T19:28:19Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-10-21T01:43:55Z"}, "message": "rustc_mir: use Instance more in the inliner.", "tree": {"sha": "74d8da4fc5978a3726f62dc74f268813643fc216", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74d8da4fc5978a3726f62dc74f268813643fc216"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/708fc0b692b4ec7894986369214dc1f13ca33882", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/708fc0b692b4ec7894986369214dc1f13ca33882", "html_url": "https://github.com/rust-lang/rust/commit/708fc0b692b4ec7894986369214dc1f13ca33882", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/708fc0b692b4ec7894986369214dc1f13ca33882/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c942c1511cc99fbc8f3e6ed56e5e3cfd8c0ff4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c942c1511cc99fbc8f3e6ed56e5e3cfd8c0ff4a", "html_url": "https://github.com/rust-lang/rust/commit/8c942c1511cc99fbc8f3e6ed56e5e3cfd8c0ff4a"}], "stats": {"total": 53, "additions": 28, "deletions": 25}, "files": [{"sha": "1b8cf2c7121c543bc0968dfb9aff3ae73f660b24", "filename": "compiler/rustc_mir/src/transform/inline.rs", "status": "modified", "additions": 28, "deletions": 25, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/708fc0b692b4ec7894986369214dc1f13ca33882/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/708fc0b692b4ec7894986369214dc1f13ca33882/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs?ref=708fc0b692b4ec7894986369214dc1f13ca33882", "patch": "@@ -1,13 +1,12 @@\n //! Inlining pass for MIR functions\n \n use rustc_attr as attr;\n-use rustc_hir::def_id::DefId;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc_middle::mir::visit::*;\n use rustc_middle::mir::*;\n-use rustc_middle::ty::subst::{Subst, SubstsRef};\n+use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::{self, ConstKind, Instance, InstanceDef, ParamEnv, Ty, TyCtxt};\n use rustc_target::spec::abi::Abi;\n \n@@ -30,8 +29,7 @@ pub struct Inline;\n \n #[derive(Copy, Clone, Debug)]\n struct CallSite<'tcx> {\n-    callee: DefId,\n-    substs: SubstsRef<'tcx>,\n+    callee: Instance<'tcx>,\n     bb: BasicBlock,\n     source_info: SourceInfo,\n }\n@@ -101,12 +99,18 @@ impl Inliner<'tcx> {\n             local_change = false;\n             while let Some(callsite) = callsites.pop_front() {\n                 debug!(\"checking whether to inline callsite {:?}\", callsite);\n-                if !self.tcx.is_mir_available(callsite.callee) {\n-                    debug!(\"checking whether to inline callsite {:?} - MIR unavailable\", callsite);\n-                    continue;\n+\n+                if let InstanceDef::Item(_) = callsite.callee.def {\n+                    if !self.tcx.is_mir_available(callsite.callee.def_id()) {\n+                        debug!(\n+                            \"checking whether to inline callsite {:?} - MIR unavailable\",\n+                            callsite,\n+                        );\n+                        continue;\n+                    }\n                 }\n \n-                let callee_body = if let Some(callee_def_id) = callsite.callee.as_local() {\n+                let callee_body = if let Some(callee_def_id) = callsite.callee.def_id().as_local() {\n                     let callee_hir_id = self.tcx.hir().local_def_id_to_hir_id(callee_def_id);\n                     // Avoid a cycle here by only using `optimized_mir` only if we have\n                     // a lower `HirId` than the callee. This ensures that the callee will\n@@ -119,19 +123,21 @@ impl Inliner<'tcx> {\n                         && self_hir_id < callee_hir_id\n                         && caller_body.generator_kind.is_none()\n                     {\n-                        self.tcx.optimized_mir(callsite.callee)\n+                        self.tcx.instance_mir(callsite.callee.def)\n                     } else {\n                         continue;\n                     }\n                 } else {\n                     // This cannot result in a cycle since the callee MIR is from another crate\n                     // and is already optimized.\n-                    self.tcx.optimized_mir(callsite.callee)\n+                    self.tcx.instance_mir(callsite.callee.def)\n                 };\n \n+                let callee_body: &Body<'tcx> = &*callee_body;\n+\n                 let callee_body = if self.consider_optimizing(callsite, callee_body) {\n                     self.tcx.subst_and_normalize_erasing_regions(\n-                        &callsite.substs,\n+                        &callsite.callee.substs,\n                         self.param_env,\n                         callee_body,\n                     )\n@@ -204,21 +210,16 @@ impl Inliner<'tcx> {\n                 // To resolve an instance its substs have to be fully normalized, so\n                 // we do this here.\n                 let normalized_substs = self.tcx.normalize_erasing_regions(self.param_env, substs);\n-                let instance =\n+                let callee =\n                     Instance::resolve(self.tcx, self.param_env, callee_def_id, normalized_substs)\n                         .ok()\n                         .flatten()?;\n \n-                if let InstanceDef::Virtual(..) = instance.def {\n+                if let InstanceDef::Virtual(..) | InstanceDef::Intrinsic(_) = callee.def {\n                     return None;\n                 }\n \n-                return Some(CallSite {\n-                    callee: instance.def_id(),\n-                    substs: instance.substs,\n-                    bb,\n-                    source_info: terminator.source_info,\n-                });\n+                return Some(CallSite { callee, bb, source_info: terminator.source_info });\n             }\n         }\n \n@@ -243,7 +244,7 @@ impl Inliner<'tcx> {\n             return false;\n         }\n \n-        let codegen_fn_attrs = tcx.codegen_fn_attrs(callsite.callee);\n+        let codegen_fn_attrs = tcx.codegen_fn_attrs(callsite.callee.def_id());\n \n         if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::TRACK_CALLER) {\n             debug!(\"`#[track_caller]` present - not inlining\");\n@@ -282,8 +283,8 @@ impl Inliner<'tcx> {\n         // Only inline local functions if they would be eligible for cross-crate\n         // inlining. This is to ensure that the final crate doesn't have MIR that\n         // reference unexported symbols\n-        if callsite.callee.is_local() {\n-            if callsite.substs.non_erasable_generics().count() == 0 && !hinted {\n+        if callsite.callee.def_id().is_local() {\n+            if callsite.callee.substs.non_erasable_generics().count() == 0 && !hinted {\n                 debug!(\"    callee is an exported function - not inlining\");\n                 return false;\n             }\n@@ -336,7 +337,7 @@ impl Inliner<'tcx> {\n                     work_list.push(target);\n                     // If the place doesn't actually need dropping, treat it like\n                     // a regular goto.\n-                    let ty = place.ty(callee_body, tcx).subst(tcx, callsite.substs).ty;\n+                    let ty = place.ty(callee_body, tcx).subst(tcx, callsite.callee.substs).ty;\n                     if ty.needs_drop(tcx, self.param_env) {\n                         cost += CALL_PENALTY;\n                         if let Some(unwind) = unwind {\n@@ -399,7 +400,7 @@ impl Inliner<'tcx> {\n \n         for v in callee_body.vars_and_temps_iter() {\n             let v = &callee_body.local_decls[v];\n-            let ty = v.ty.subst(tcx, callsite.substs);\n+            let ty = v.ty.subst(tcx, callsite.callee.substs);\n             // Cost of the var is the size in machine-words, if we know\n             // it.\n             if let Some(size) = type_size_of(tcx, self.param_env, ty) {\n@@ -583,7 +584,9 @@ impl Inliner<'tcx> {\n         //     tmp2 = tuple_tmp.2\n         //\n         // and the vector is `[closure_ref, tmp0, tmp1, tmp2]`.\n-        if tcx.is_closure(callsite.callee) {\n+        // FIXME(eddyb) make this check for `\"rust-call\"` ABI combined with\n+        // `callee_body.spread_arg == None`, instead of special-casing closures.\n+        if tcx.is_closure(callsite.callee.def_id()) {\n             let mut args = args.into_iter();\n             let self_ = self.create_temp_if_necessary(\n                 args.next().unwrap(),"}]}