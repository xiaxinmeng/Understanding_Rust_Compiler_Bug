{"sha": "30f081e54843952e34b0632e1b0ec54547bf6e3c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwZjA4MWU1NDg0Mzk1MmUzNGIwNjMyZTFiMGVjNTQ1NDdiZjZlM2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-18T09:21:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-18T09:21:42Z"}, "message": "auto merge of #21276 : huonw/rust/trait-suggestion-nits, r=nikomatsakis\n\nFollow up to #21008.\r\n\r\nr? @nikomatsakis", "tree": {"sha": "de3a3606eb86aa19718f42a68723c05f575ea611", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de3a3606eb86aa19718f42a68723c05f575ea611"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30f081e54843952e34b0632e1b0ec54547bf6e3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30f081e54843952e34b0632e1b0ec54547bf6e3c", "html_url": "https://github.com/rust-lang/rust/commit/30f081e54843952e34b0632e1b0ec54547bf6e3c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30f081e54843952e34b0632e1b0ec54547bf6e3c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a833337943300db1c310a4cf9c84b7b4ef4e9468", "url": "https://api.github.com/repos/rust-lang/rust/commits/a833337943300db1c310a4cf9c84b7b4ef4e9468", "html_url": "https://github.com/rust-lang/rust/commit/a833337943300db1c310a4cf9c84b7b4ef4e9468"}, {"sha": "ada312ffbbfa03ac15c620f7a5702ef29b6e1321", "url": "https://api.github.com/repos/rust-lang/rust/commits/ada312ffbbfa03ac15c620f7a5702ef29b6e1321", "html_url": "https://github.com/rust-lang/rust/commit/ada312ffbbfa03ac15c620f7a5702ef29b6e1321"}], "stats": {"total": 107, "additions": 50, "deletions": 57}, "files": [{"sha": "9bbc7b258e244986cd8521c0f4b220ea12e60e75", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 35, "deletions": 44, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/30f081e54843952e34b0632e1b0ec54547bf6e3c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30f081e54843952e34b0632e1b0ec54547bf6e3c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=30f081e54843952e34b0632e1b0ec54547bf6e3c", "patch": "@@ -44,7 +44,6 @@ struct ProbeContext<'a, 'tcx:'a> {\n     extension_candidates: Vec<Candidate<'tcx>>,\n     impl_dups: HashSet<ast::DefId>,\n     static_candidates: Vec<CandidateSource>,\n-    all_traits_search: bool,\n }\n \n struct CandidateStep<'tcx> {\n@@ -211,7 +210,6 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             steps: Rc::new(steps),\n             opt_simplified_steps: opt_simplified_steps,\n             static_candidates: Vec::new(),\n-            all_traits_search: false,\n         }\n     }\n \n@@ -724,60 +722,53 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     // THE ACTUAL SEARCH\n \n     fn pick(mut self) -> PickResult<'tcx> {\n-        let steps = self.steps.clone();\n-\n-        for step in steps.iter() {\n-            match self.pick_step(step) {\n-                Some(r) => {\n-                    return r;\n-                }\n-                None => { }\n-            }\n+        match self.pick_core() {\n+            Some(r) => return r,\n+            None => {}\n         }\n \n         let static_candidates = mem::replace(&mut self.static_candidates, vec![]);\n \n-        let out_of_scope_traits = if !self.all_traits_search {\n-            // things failed, and we haven't yet looked through all\n-            // traits, so lets do that now:\n-            self.reset();\n-            self.all_traits_search = true;\n-\n-            let span = self.span;\n-            let tcx = self.tcx();\n-\n-            self.assemble_extension_candidates_for_all_traits();\n-\n-            match self.pick() {\n-                Ok(p) => vec![p.method_ty.container.id()],\n-                Err(Ambiguity(v)) => v.into_iter().map(|source| {\n-                    match source {\n-                        TraitSource(id) => id,\n-                        ImplSource(impl_id) => {\n-                            match ty::trait_id_of_impl(tcx, impl_id) {\n-                                Some(id) => id,\n-                                None => tcx.sess.span_bug(span,\n-                                                          \"found inherent method when looking \\\n-                                                           at traits\")\n-                            }\n+        // things failed, so lets look at all traits, for diagnostic purposes now:\n+        self.reset();\n+\n+        let span = self.span;\n+        let tcx = self.tcx();\n+\n+        self.assemble_extension_candidates_for_all_traits();\n+\n+        let out_of_scope_traits = match self.pick_core() {\n+            Some(Ok(p)) => vec![p.method_ty.container.id()],\n+            Some(Err(Ambiguity(v))) => v.into_iter().map(|source| {\n+                match source {\n+                    TraitSource(id) => id,\n+                    ImplSource(impl_id) => {\n+                        match ty::trait_id_of_impl(tcx, impl_id) {\n+                            Some(id) => id,\n+                            None =>\n+                                tcx.sess.span_bug(span,\n+                                                  \"found inherent method when looking at traits\")\n                         }\n                     }\n-                }).collect(),\n-                // it'd be really weird for this assertion to trigger,\n-                // given the `vec![]` in the else branch below\n-                Err(NoMatch(_, others)) => {\n-                    assert!(others.is_empty());\n-                    vec![]\n                 }\n+            }).collect(),\n+            Some(Err(NoMatch(_, others))) => {\n+                assert!(others.is_empty());\n+                vec![]\n             }\n-        } else {\n-            // we've just looked through all traits and didn't find\n-            // anything at all.\n-            vec![]\n+            None => vec![],\n         };\n+;\n         Err(NoMatch(static_candidates, out_of_scope_traits))\n     }\n \n+    fn pick_core(&mut self) -> Option<PickResult<'tcx>> {\n+        let steps = self.steps.clone();\n+\n+        // find the first step that works\n+        steps.iter().filter_map(|step| self.pick_step(step)).next()\n+    }\n+\n     fn pick_step(&mut self, step: &CandidateStep<'tcx>) -> Option<PickResult<'tcx>> {\n         debug!(\"pick_step: step={}\", step.repr(self.tcx()));\n "}, {"sha": "2a89a1d28bfc6e344828072857649f48662036dd", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/30f081e54843952e34b0632e1b0ec54547bf6e3c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30f081e54843952e34b0632e1b0ec54547bf6e3c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=30f081e54843952e34b0632e1b0ec54547bf6e3c", "patch": "@@ -147,16 +147,16 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         candidates.sort();\n         let msg = format!(\n             \"methods from traits can only be called if the trait is in scope; \\\n-             the following {traits_are} implemented and {define} a method `{name}`:\",\n+             the following {traits_are} implemented but not in scope, \\\n+             perhaps add a `use` for {one_of_them}:\",\n             traits_are = if candidates.len() == 1 {\"trait is\"} else {\"traits are\"},\n-            define = if candidates.len() == 1 {\"defines\"} else {\"define\"},\n-            name = method_ustring);\n+            one_of_them = if candidates.len() == 1 {\"it\"} else {\"one of them\"});\n \n         fcx.sess().fileline_help(span, &msg[]);\n \n         for (i, trait_did) in candidates.iter().enumerate() {\n             fcx.sess().fileline_help(span,\n-                                     &*format!(\"candidate #{}: `{}`\",\n+                                     &*format!(\"candidate #{}: use `{}`\",\n                                                i + 1,\n                                                ty::item_path_str(fcx.tcx(), *trait_did)))\n \n@@ -174,9 +174,11 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         candidates.sort_by(|a, b| a.cmp(b).reverse());\n \n         let msg = format!(\n-            \"methods from traits can only be called if the trait is implemented and \\\n-             in scope; no such traits are but the following {traits_define} a method `{name}`:\",\n+            \"methods from traits can only be called if the trait is implemented and in scope; \\\n+             the following {traits_define} a method `{name}`, \\\n+             perhaps you need to implement {one_of_them}:\",\n             traits_define = if candidates.len() == 1 {\"trait defines\"} else {\"traits define\"},\n+            one_of_them = if candidates.len() == 1 {\"it\"} else {\"one of them\"},\n             name = method_ustring);\n \n         fcx.sess().fileline_help(span, &msg[]);"}, {"sha": "ba8121eb5cc35883be6c409cbc72de4d3a8bc783", "filename": "src/test/compile-fail/no-method-suggested-traits.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/30f081e54843952e34b0632e1b0ec54547bf6e3c/src%2Ftest%2Fcompile-fail%2Fno-method-suggested-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30f081e54843952e34b0632e1b0ec54547bf6e3c/src%2Ftest%2Fcompile-fail%2Fno-method-suggested-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-method-suggested-traits.rs?ref=30f081e54843952e34b0632e1b0ec54547bf6e3c", "patch": "@@ -26,24 +26,24 @@ mod foo {\n \n fn main() {\n     1u32.method();\n-    //~^ ERROR does not implement\n-    //~^^ HELP the following traits are implemented and define a method `method`\n+    //~^ HELP following traits are implemented but not in scope, perhaps add a `use` for one of them\n+    //~^^ ERROR does not implement\n     //~^^^ HELP `foo::Bar`\n     //~^^^^ HELP `no_method_suggested_traits::foo::PubPub`\n \n     'a'.method();\n     //~^ ERROR does not implement\n-    //~^^ HELP the following trait is implemented and defines a method `method`\n+    //~^^ HELP the following trait is implemented but not in scope, perhaps add a `use` for it:\n     //~^^^ HELP `foo::Bar`\n \n     1i32.method();\n     //~^ ERROR does not implement\n-    //~^^ HELP the following trait is implemented and defines a method `method`\n+    //~^^ HELP the following trait is implemented but not in scope, perhaps add a `use` for it:\n     //~^^^ HELP `no_method_suggested_traits::foo::PubPub`\n \n     1u64.method();\n     //~^ ERROR does not implement\n-    //~^^ HELP the following traits define a method `method`\n+    //~^^ HELP following traits define a method `method`, perhaps you need to implement one of them\n     //~^^^ HELP `foo::Bar`\n     //~^^^^ HELP `no_method_suggested_traits::foo::PubPub`\n     //~^^^^^ HELP `no_method_suggested_traits::reexport::Reexported`\n@@ -53,10 +53,10 @@ fn main() {\n \n     1u64.method2();\n     //~^ ERROR does not implement\n-    //~^^ HELP the following trait defines a method `method2`\n+    //~^^ HELP the following trait defines a method `method2`, perhaps you need to implement it\n     //~^^^ HELP `foo::Bar`\n     1u64.method3();\n     //~^ ERROR does not implement\n-    //~^^ HELP the following trait defines a method `method3`\n+    //~^^ HELP the following trait defines a method `method3`, perhaps you need to implement it\n     //~^^^ HELP `no_method_suggested_traits::foo::PubPub`\n }"}]}