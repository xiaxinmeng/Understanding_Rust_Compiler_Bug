{"sha": "5efcfe5ca983afea02b81c3e413d9064b013c514", "node_id": "C_kwDOAAsO6NoAKDVlZmNmZTVjYTk4M2FmZWEwMmI4MWMzZTQxM2Q5MDY0YjAxM2M1MTQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-04T08:31:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-04T08:31:20Z"}, "message": "Auto merge of #14244 - Veykril:metrics, r=lnicola\n\ninternal: Report type metrics for patterns\n\n```\n\u276f cargo run --release -p rust-analyzer -q analysis-stats --memory-usage .\nDatabase loaded:     2.09s, 218mb (metadata 275.07ms, 21mb; build 1.29s, 504kb)\n  crates: 44, mods: 916, decls: 19582, fns: 14631\nItem Collection:     14.33s, 472mb\n  exprs: 420422, ??ty: 68 (0%), ?ty: 141 (0%), !ty: 1\n  pats: 82968, ??ty: 11 (0%), ?ty: 10 (0%), !ty: 178\nInference:           47.84s, 745mb\nTotal:               62.16s, 1217mb\n```\nWe currently have 178 mismatches on r-a itself", "tree": {"sha": "69574b931c4778ba62dbf17d264c7c0a044c31e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69574b931c4778ba62dbf17d264c7c0a044c31e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5efcfe5ca983afea02b81c3e413d9064b013c514", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5efcfe5ca983afea02b81c3e413d9064b013c514", "html_url": "https://github.com/rust-lang/rust/commit/5efcfe5ca983afea02b81c3e413d9064b013c514", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5efcfe5ca983afea02b81c3e413d9064b013c514/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b330f52f6afe46839c5e24b4324969b06c3f439", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b330f52f6afe46839c5e24b4324969b06c3f439", "html_url": "https://github.com/rust-lang/rust/commit/4b330f52f6afe46839c5e24b4324969b06c3f439"}, {"sha": "800ab650ac7a0833c4a7ca667a84ea8316b6cf3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/800ab650ac7a0833c4a7ca667a84ea8316b6cf3b", "html_url": "https://github.com/rust-lang/rust/commit/800ab650ac7a0833c4a7ca667a84ea8316b6cf3b"}], "stats": {"total": 187, "additions": 179, "deletions": 8}, "files": [{"sha": "e8c10927d62c4db971187f841e183d638ee059a9", "filename": "crates/rust-analyzer/src/cli/analysis_stats.rs", "status": "modified", "additions": 179, "deletions": 8, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/5efcfe5ca983afea02b81c3e413d9064b013c514/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5efcfe5ca983afea02b81c3e413d9064b013c514/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs?ref=5efcfe5ca983afea02b81c3e413d9064b013c514", "patch": "@@ -12,7 +12,7 @@ use hir::{\n };\n use hir_def::{\n     body::{BodySourceMap, SyntheticSyntax},\n-    expr::ExprId,\n+    expr::{ExprId, PatId},\n     FunctionId,\n };\n use hir_ty::{Interner, TyExt, TypeFlags};\n@@ -222,7 +222,11 @@ impl flags::AnalysisStats {\n         let mut num_exprs = 0;\n         let mut num_exprs_unknown = 0;\n         let mut num_exprs_partially_unknown = 0;\n-        let mut num_type_mismatches = 0;\n+        let mut num_expr_type_mismatches = 0;\n+        let mut num_pats = 0;\n+        let mut num_pats_unknown = 0;\n+        let mut num_pats_partially_unknown = 0;\n+        let mut num_pat_type_mismatches = 0;\n         let analysis = host.analysis();\n         for f in funcs.iter().copied() {\n             let name = f.name(db);\n@@ -255,6 +259,8 @@ impl flags::AnalysisStats {\n             let f_id = FunctionId::from(f);\n             let (body, sm) = db.body_with_source_map(f_id.into());\n             let inference_result = db.infer(f_id.into());\n+\n+            // region:expressions\n             let (previous_exprs, previous_unknown, previous_partially_unknown) =\n                 (num_exprs, num_exprs_unknown, num_exprs_partially_unknown);\n             for (expr_id, _) in body.exprs.iter() {\n@@ -307,12 +313,12 @@ impl flags::AnalysisStats {\n                 if unknown_or_partial && self.output == Some(OutputFormat::Csv) {\n                     println!(\n                         r#\"{},type,\"{}\"\"#,\n-                        location_csv(db, &analysis, vfs, &sm, expr_id),\n+                        location_csv_expr(db, &analysis, vfs, &sm, expr_id),\n                         ty.display(db)\n                     );\n                 }\n                 if let Some(mismatch) = inference_result.type_mismatch_for_expr(expr_id) {\n-                    num_type_mismatches += 1;\n+                    num_expr_type_mismatches += 1;\n                     if verbosity.is_verbose() {\n                         if let Some((path, start, end)) =\n                             expr_syntax_range(db, &analysis, vfs, &sm, expr_id)\n@@ -339,7 +345,7 @@ impl flags::AnalysisStats {\n                     if self.output == Some(OutputFormat::Csv) {\n                         println!(\n                             r#\"{},mismatch,\"{}\",\"{}\"\"#,\n-                            location_csv(db, &analysis, vfs, &sm, expr_id),\n+                            location_csv_expr(db, &analysis, vfs, &sm, expr_id),\n                             mismatch.expected.display(db),\n                             mismatch.actual.display(db)\n                         );\n@@ -355,6 +361,109 @@ impl flags::AnalysisStats {\n                     num_exprs_partially_unknown - previous_partially_unknown\n                 ));\n             }\n+            // endregion:expressions\n+\n+            // region:patterns\n+            let (previous_pats, previous_unknown, previous_partially_unknown) =\n+                (num_pats, num_pats_unknown, num_pats_partially_unknown);\n+            for (pat_id, _) in body.pats.iter() {\n+                let ty = &inference_result[pat_id];\n+                num_pats += 1;\n+                let unknown_or_partial = if ty.is_unknown() {\n+                    num_pats_unknown += 1;\n+                    if verbosity.is_spammy() {\n+                        if let Some((path, start, end)) =\n+                            pat_syntax_range(db, &analysis, vfs, &sm, pat_id)\n+                        {\n+                            bar.println(format!(\n+                                \"{} {}:{}-{}:{}: Unknown type\",\n+                                path,\n+                                start.line + 1,\n+                                start.col,\n+                                end.line + 1,\n+                                end.col,\n+                            ));\n+                        } else {\n+                            bar.println(format!(\"{name}: Unknown type\",));\n+                        }\n+                    }\n+                    true\n+                } else {\n+                    let is_partially_unknown =\n+                        ty.data(Interner).flags.contains(TypeFlags::HAS_ERROR);\n+                    if is_partially_unknown {\n+                        num_pats_partially_unknown += 1;\n+                    }\n+                    is_partially_unknown\n+                };\n+                if self.only.is_some() && verbosity.is_spammy() {\n+                    // in super-verbose mode for just one function, we print every single pattern\n+                    if let Some((_, start, end)) = pat_syntax_range(db, &analysis, vfs, &sm, pat_id)\n+                    {\n+                        bar.println(format!(\n+                            \"{}:{}-{}:{}: {}\",\n+                            start.line + 1,\n+                            start.col,\n+                            end.line + 1,\n+                            end.col,\n+                            ty.display(db)\n+                        ));\n+                    } else {\n+                        bar.println(format!(\"unknown location: {}\", ty.display(db)));\n+                    }\n+                }\n+                if unknown_or_partial && self.output == Some(OutputFormat::Csv) {\n+                    println!(\n+                        r#\"{},type,\"{}\"\"#,\n+                        location_csv_pat(db, &analysis, vfs, &sm, pat_id),\n+                        ty.display(db)\n+                    );\n+                }\n+                if let Some(mismatch) = inference_result.type_mismatch_for_pat(pat_id) {\n+                    num_pat_type_mismatches += 1;\n+                    if verbosity.is_verbose() {\n+                        if let Some((path, start, end)) =\n+                            pat_syntax_range(db, &analysis, vfs, &sm, pat_id)\n+                        {\n+                            bar.println(format!(\n+                                \"{} {}:{}-{}:{}: Expected {}, got {}\",\n+                                path,\n+                                start.line + 1,\n+                                start.col,\n+                                end.line + 1,\n+                                end.col,\n+                                mismatch.expected.display(db),\n+                                mismatch.actual.display(db)\n+                            ));\n+                        } else {\n+                            bar.println(format!(\n+                                \"{}: Expected {}, got {}\",\n+                                name,\n+                                mismatch.expected.display(db),\n+                                mismatch.actual.display(db)\n+                            ));\n+                        }\n+                    }\n+                    if self.output == Some(OutputFormat::Csv) {\n+                        println!(\n+                            r#\"{},mismatch,\"{}\",\"{}\"\"#,\n+                            location_csv_pat(db, &analysis, vfs, &sm, pat_id),\n+                            mismatch.expected.display(db),\n+                            mismatch.actual.display(db)\n+                        );\n+                    }\n+                }\n+            }\n+            if verbosity.is_spammy() {\n+                bar.println(format!(\n+                    \"In {}: {} pats, {} unknown, {} partial\",\n+                    full_name,\n+                    num_pats - previous_pats,\n+                    num_pats_unknown - previous_unknown,\n+                    num_pats_partially_unknown - previous_partially_unknown\n+                ));\n+            }\n+            // endregion:patterns\n             bar.inc(1);\n         }\n \n@@ -366,10 +475,21 @@ impl flags::AnalysisStats {\n             percentage(num_exprs_unknown, num_exprs),\n             num_exprs_partially_unknown,\n             percentage(num_exprs_partially_unknown, num_exprs),\n-            num_type_mismatches\n+            num_expr_type_mismatches\n+        );\n+        eprintln!(\n+            \"  pats: {}, ??ty: {} ({}%), ?ty: {} ({}%), !ty: {}\",\n+            num_pats,\n+            num_pats_unknown,\n+            percentage(num_pats_unknown, num_pats),\n+            num_pats_partially_unknown,\n+            percentage(num_pats_partially_unknown, num_pats),\n+            num_pat_type_mismatches\n         );\n         report_metric(\"unknown type\", num_exprs_unknown, \"#\");\n-        report_metric(\"type mismatches\", num_type_mismatches, \"#\");\n+        report_metric(\"type mismatches\", num_expr_type_mismatches, \"#\");\n+        report_metric(\"pattern unknown type\", num_pats_unknown, \"#\");\n+        report_metric(\"pattern type mismatches\", num_pat_type_mismatches, \"#\");\n \n         eprintln!(\"{:<20} {}\", \"Inference:\", inference_sw.elapsed());\n     }\n@@ -379,7 +499,7 @@ impl flags::AnalysisStats {\n     }\n }\n \n-fn location_csv(\n+fn location_csv_expr(\n     db: &RootDatabase,\n     analysis: &Analysis,\n     vfs: &Vfs,\n@@ -401,6 +521,30 @@ fn location_csv(\n     format!(\"{path},{}:{},{}:{}\", start.line + 1, start.col, end.line + 1, end.col)\n }\n \n+fn location_csv_pat(\n+    db: &RootDatabase,\n+    analysis: &Analysis,\n+    vfs: &Vfs,\n+    sm: &BodySourceMap,\n+    pat_id: PatId,\n+) -> String {\n+    let src = match sm.pat_syntax(pat_id) {\n+        Ok(s) => s,\n+        Err(SyntheticSyntax) => return \"synthetic,,\".to_string(),\n+    };\n+    let root = db.parse_or_expand(src.file_id).unwrap();\n+    let node = src.map(|e| {\n+        e.either(|it| it.to_node(&root).syntax().clone(), |it| it.to_node(&root).syntax().clone())\n+    });\n+    let original_range = node.as_ref().original_file_range(db);\n+    let path = vfs.file_path(original_range.file_id);\n+    let line_index = analysis.file_line_index(original_range.file_id).unwrap();\n+    let text_range = original_range.range;\n+    let (start, end) =\n+        (line_index.line_col(text_range.start()), line_index.line_col(text_range.end()));\n+    format!(\"{path},{}:{},{}:{}\", start.line + 1, start.col, end.line + 1, end.col)\n+}\n+\n fn expr_syntax_range(\n     db: &RootDatabase,\n     analysis: &Analysis,\n@@ -423,6 +567,33 @@ fn expr_syntax_range(\n         None\n     }\n }\n+fn pat_syntax_range(\n+    db: &RootDatabase,\n+    analysis: &Analysis,\n+    vfs: &Vfs,\n+    sm: &BodySourceMap,\n+    pat_id: PatId,\n+) -> Option<(VfsPath, LineCol, LineCol)> {\n+    let src = sm.pat_syntax(pat_id);\n+    if let Ok(src) = src {\n+        let root = db.parse_or_expand(src.file_id).unwrap();\n+        let node = src.map(|e| {\n+            e.either(\n+                |it| it.to_node(&root).syntax().clone(),\n+                |it| it.to_node(&root).syntax().clone(),\n+            )\n+        });\n+        let original_range = node.as_ref().original_file_range(db);\n+        let path = vfs.file_path(original_range.file_id);\n+        let line_index = analysis.file_line_index(original_range.file_id).unwrap();\n+        let text_range = original_range.range;\n+        let (start, end) =\n+            (line_index.line_col(text_range.start()), line_index.line_col(text_range.end()));\n+        Some((path, start, end))\n+    } else {\n+        None\n+    }\n+}\n \n fn shuffle<T>(rng: &mut Rand32, slice: &mut [T]) {\n     for i in 0..slice.len() {"}]}