{"sha": "a2f68b2d585f0b467f0911d162f3cb9bc7d1ad14", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyZjY4YjJkNTg1ZjBiNDY3ZjA5MTFkMTYyZjNjYjliYzdkMWFkMTQ=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-04-29T15:26:28Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-04-29T15:26:28Z"}, "message": "Intern metadata while writing, shrink stage1 from 12mb to 5.7mb.", "tree": {"sha": "d91937cb020dd2e69aa94bbe987b4851cf9c1d4f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d91937cb020dd2e69aa94bbe987b4851cf9c1d4f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2f68b2d585f0b467f0911d162f3cb9bc7d1ad14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2f68b2d585f0b467f0911d162f3cb9bc7d1ad14", "html_url": "https://github.com/rust-lang/rust/commit/a2f68b2d585f0b467f0911d162f3cb9bc7d1ad14", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2f68b2d585f0b467f0911d162f3cb9bc7d1ad14/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6daf440037cb10baab332fde2b471712a3a42c76", "url": "https://api.github.com/repos/rust-lang/rust/commits/6daf440037cb10baab332fde2b471712a3a42c76", "html_url": "https://github.com/rust-lang/rust/commit/6daf440037cb10baab332fde2b471712a3a42c76"}], "stats": {"total": 318, "additions": 224, "deletions": 94}, "files": [{"sha": "f48d47c90be608f93122e422f6ab2e536c043793", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 49, "deletions": 16, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/a2f68b2d585f0b467f0911d162f3cb9bc7d1ad14/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f68b2d585f0b467f0911d162f3cb9bc7d1ad14/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=a2f68b2d585f0b467f0911d162f3cb9bc7d1ad14", "patch": "@@ -43,34 +43,29 @@ tag resolve_result {\n \n // Compact string representation for ty.t values. API ty_str & parse_from_str.\n // (The second has to be authed pure.) Extra parameters are for converting\n-// to/from def_ids in the string rep. Whatever format you choose should not\n+// to/from def_ids in the data buffer. Whatever format you choose should not\n // contain pipe characters.\n \n // Callback to translate defs to strs or back.\n type str_def = fn(str) -> ast.def_id;\n \n-type pstate = rec(str rep, mutable uint pos, uint len, ty.ctxt tcx);\n+type pstate = rec(vec[u8] data, int crate,\n+                  mutable uint pos, uint len, ty.ctxt tcx);\n \n fn peek(@pstate st) -> u8 {\n-    if (st.pos < st.len) {ret st.rep.(st.pos) as u8;}\n-    else {ret ' ' as u8;}\n+    ret st.data.(st.pos);\n }\n fn next(@pstate st) -> u8 {\n-    if (st.pos >= st.len) {fail;}\n-    auto ch = st.rep.(st.pos);\n+    auto ch = st.data.(st.pos);\n     st.pos = st.pos + 1u;\n-    ret ch as u8;\n+    ret ch;\n }\n \n-fn parse_ty_str(str rep, str_def sd, ty.ctxt tcx) -> ty.t {\n-    auto len = _str.byte_len(rep);\n-    auto st = @rec(rep=rep, mutable pos=0u, len=len, tcx=tcx);\n+fn parse_ty_data(vec[u8] data, int crate_num, uint pos, uint len,\n+                 str_def sd, ty.ctxt tcx) -> ty.t {\n+    auto st = @rec(data=data, crate=crate_num,\n+                   mutable pos=pos, len=len, tcx=tcx);\n     auto result = parse_ty(st, sd);\n-    if (st.pos != len) {\n-        log_err \"parse_ty_str: incomplete parse, stopped at byte \"\n-            + _uint.to_str(st.pos, 10u) + \" of \"\n-            + _uint.to_str(len, 10u) + \" in str '\" + rep + \"'\";\n-    }\n     ret result;\n }\n \n@@ -178,6 +173,26 @@ fn parse_ty(@pstate st, str_def sd) -> ty.t {\n         case ('X') { ret ty.mk_var(st.tcx, parse_int(st)); }\n         case ('E') { ret ty.mk_native(st.tcx); }\n         case ('Y') { ret ty.mk_type(st.tcx); }\n+        case ('#') {\n+            auto pos = parse_hex(st);\n+            check (next(st) as char == ':');\n+            auto len = parse_hex(st);\n+            check (next(st) as char == '#');\n+            alt (st.tcx.rcache.find(tup(st.crate,pos,len))) {\n+                case (some[ty.t](?tt)) { ret tt; }\n+                case (none[ty.t]) {\n+                    auto ps = @rec(pos=pos, len=len with *st);\n+                    auto tt = parse_ty(ps, sd);\n+                    st.tcx.rcache.insert(tup(st.crate,pos,len), tt);\n+                    ret tt;\n+                }\n+            }\n+        }\n+        case (?c) {\n+            log_err \"unexpected char in type string: \";\n+            log_err c;\n+            fail;\n+        }\n     }\n }\n \n@@ -212,6 +227,23 @@ fn parse_int(@pstate st) -> int {\n     ret n;\n }\n \n+fn parse_hex(@pstate st) -> uint {\n+    auto n = 0u;\n+    while (true) {\n+        auto cur = peek(st) as char;\n+        if ((cur < '0' || cur > '9') &&\n+            (cur < 'a' || cur > 'f')) {break;}\n+        st.pos = st.pos + 1u;\n+        n *= 16u;\n+        if ('0' <= cur && cur <= '9') {\n+            n += (cur as uint) - ('0' as uint);\n+        } else {\n+            n += (10u + (cur as uint) - ('a' as uint));\n+        }\n+    }\n+    ret n;\n+}\n+\n fn parse_ty_fn(@pstate st, str_def sd) -> tup(vec[ty.arg], ty.t) {\n     check(next(st) as char == '[');\n     let vec[ty.arg] inputs = vec();\n@@ -343,7 +375,8 @@ fn item_type(&ebml.doc item, int this_cnum, ty.ctxt tcx) -> ty.t {\n \n     auto tp = ebml.get_doc(item, metadata.tag_items_data_item_type);\n     auto s = _str.unsafe_from_bytes(ebml.doc_data(tp));\n-    ret parse_ty_str(s, bind parse_external_def_id(this_cnum, _), tcx);\n+    ret parse_ty_data(item.data, this_cnum, tp.start, tp.end - tp.start,\n+                      bind parse_external_def_id(this_cnum, _), tcx);\n }\n \n fn item_ty_param_count(&ebml.doc item, int this_cnum) -> uint {"}, {"sha": "0cfe09b76abef2591d52b177d33611b6d44e2290", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 138, "deletions": 70, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/a2f68b2d585f0b467f0911d162f3cb9bc7d1ad14/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f68b2d585f0b467f0911d162f3cb9bc7d1ad14/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=a2f68b2d585f0b467f0911d162f3cb9bc7d1ad14", "patch": "@@ -1,9 +1,12 @@\n import std._str;\n import std._uint;\n import std._vec;\n+import std.map.hashmap;\n import std.ebml;\n import std.io;\n import std.option;\n+import std.option.some;\n+import std.option.none;\n \n import front.ast;\n import middle.fold;\n@@ -48,119 +51,185 @@ const uint tag_index_table = 0x15u;\n // Extra parameters are for converting to/from def_ids in the string rep.\n // Whatever format you choose should not contain pipe characters.\n \n+type ty_abbrev = rec(uint pos, uint len, str s);\n+\n mod Encode {\n \n     type ctxt = rec(\n-        fn(ast.def_id) -> str ds,   // Callback to translate defs to strs.\n-        ty.ctxt tcx                 // The type context.\n+        fn(ast.def_id) -> str ds,           // Def -> str Callback.\n+        ty.ctxt tcx,                        // The type context.\n+        bool use_abbrevs,\n+        hashmap[ty.t, ty_abbrev] abbrevs    // Type abbrevs.\n     );\n \n     fn ty_str(@ctxt cx, ty.t t) -> str {\n-        ret sty_str(cx, ty.struct(cx.tcx, t));\n+        check (! cx.use_abbrevs);\n+        auto sw = io.string_writer();\n+        enc_ty(sw.get_writer(), cx, t);\n+        ret sw.get_str();\n+    }\n+\n+    fn enc_ty(io.writer w, @ctxt cx, ty.t t) {\n+        if (cx.use_abbrevs) {\n+            alt (cx.abbrevs.find(t)) {\n+                case (some[ty_abbrev](?a)) {\n+                    w.write_str(a.s);\n+                    ret;\n+                }\n+                case (none[ty_abbrev]) {\n+                    auto pos = w.get_buf_writer().tell();\n+                    auto ss = enc_sty(w, cx, ty.struct(cx.tcx, t));\n+                    auto end = w.get_buf_writer().tell();\n+                    auto len = end-pos;\n+                    fn estimate_sz(uint u) -> uint {\n+                        auto n = u;\n+                        auto len = 0u;\n+                        while (n != 0u) {\n+                            len += 1u;\n+                            n = n >> 4u;\n+                        }\n+                        ret len;\n+                    }\n+                    auto abbrev_len =\n+                        3u + estimate_sz(pos) + estimate_sz(len);\n+\n+                    if (abbrev_len < len) {\n+                        // I.e. it's actually an abbreviation.\n+                        auto s = (\"#\"\n+                                  + _uint.to_str(pos, 16u) + \":\"\n+                                  + _uint.to_str(len, 16u) + \"#\");\n+                        auto a = rec(pos=pos, len=len, s=s);\n+                        cx.abbrevs.insert(t, a);\n+                    }\n+                    ret;\n+                }\n+            }\n+        }\n+        enc_sty(w, cx, ty.struct(cx.tcx, t));\n     }\n \n-    fn mt_str(@ctxt cx, &ty.mt mt) -> str {\n-        auto mut_str;\n+    fn enc_mt(io.writer w, @ctxt cx, &ty.mt mt) {\n         alt (mt.mut) {\n-            case (ast.imm)       { mut_str = \"\";  }\n-            case (ast.mut)       { mut_str = \"m\"; }\n-            case (ast.maybe_mut) { mut_str = \"?\"; }\n+            case (ast.imm)       { }\n+            case (ast.mut)       { w.write_char('m'); }\n+            case (ast.maybe_mut) { w.write_char('?'); }\n         }\n-        ret mut_str + ty_str(cx, mt.ty);\n+        enc_ty(w, cx, mt.ty);\n     }\n \n-    fn sty_str(@ctxt cx, ty.sty st) -> str {\n+    fn enc_sty(io.writer w, @ctxt cx, ty.sty st) {\n         alt (st) {\n-            case (ty.ty_nil) {ret \"n\";}\n-            case (ty.ty_bool) {ret \"b\";}\n-            case (ty.ty_int) {ret \"i\";}\n-            case (ty.ty_uint) {ret \"u\";}\n-            case (ty.ty_float) {ret \"l\";}\n+            case (ty.ty_nil) { w.write_char('n'); }\n+            case (ty.ty_bool) { w.write_char('b'); }\n+            case (ty.ty_int) { w.write_char('i'); }\n+            case (ty.ty_uint) { w.write_char('u'); }\n+            case (ty.ty_float) { w.write_char('l'); }\n             case (ty.ty_machine(?mach)) {\n                 alt (mach) {\n-                    case (common.ty_u8) {ret \"Mb\";}\n-                    case (common.ty_u16) {ret \"Mw\";}\n-                    case (common.ty_u32) {ret \"Ml\";}\n-                    case (common.ty_u64) {ret \"Md\";}\n-                    case (common.ty_i8) {ret \"MB\";}\n-                    case (common.ty_i16) {ret \"MW\";}\n-                    case (common.ty_i32) {ret \"ML\";}\n-                    case (common.ty_i64) {ret \"MD\";}\n-                    case (common.ty_f32) {ret \"Mf\";}\n-                    case (common.ty_f64) {ret \"MF\";}\n+                    case (common.ty_u8) { w.write_str(\"Mb\"); }\n+                    case (common.ty_u16) { w.write_str(\"Mw\"); }\n+                    case (common.ty_u32) { w.write_str(\"Ml\"); }\n+                    case (common.ty_u64) { w.write_str(\"Md\"); }\n+                    case (common.ty_i8) { w.write_str(\"MB\"); }\n+                    case (common.ty_i16) { w.write_str(\"MW\"); }\n+                    case (common.ty_i32) { w.write_str(\"ML\"); }\n+                    case (common.ty_i64) { w.write_str(\"MD\"); }\n+                    case (common.ty_f32) { w.write_str(\"Mf\"); }\n+                    case (common.ty_f64) { w.write_str(\"MF\"); }\n                 }\n             }\n-            case (ty.ty_char) {ret \"c\";}\n-            case (ty.ty_str) {ret \"s\";}\n+            case (ty.ty_char) {w.write_char('c');}\n+            case (ty.ty_str) {w.write_char('s');}\n             case (ty.ty_tag(?def,?tys)) { // TODO restore def_id\n-                auto acc = \"t[\" + cx.ds(def) + \"|\";\n-                for (ty.t t in tys) {acc += ty_str(cx, t);}\n-                ret acc + \"]\";\n+                w.write_str(\"t[\");\n+                w.write_str(cx.ds(def));\n+                w.write_char('|');\n+                for (ty.t t in tys) {\n+                    enc_ty(w, cx, t);\n+                }\n+                w.write_char(']');\n             }\n-            case (ty.ty_box(?mt)) {ret \"@\" + mt_str(cx, mt);}\n-            case (ty.ty_vec(?mt)) {ret \"V\" + mt_str(cx, mt);}\n-            case (ty.ty_port(?t)) {ret \"P\" + ty_str(cx, t);}\n-            case (ty.ty_chan(?t)) {ret \"C\" + ty_str(cx, t);}\n+            case (ty.ty_box(?mt)) {w.write_char('@'); enc_mt(w, cx, mt); }\n+            case (ty.ty_vec(?mt)) {w.write_char('V'); enc_mt(w, cx, mt); }\n+            case (ty.ty_port(?t)) {w.write_char('P'); enc_ty(w, cx, t); }\n+            case (ty.ty_chan(?t)) {w.write_char('C'); enc_ty(w, cx, t); }\n             case (ty.ty_tup(?mts)) {\n-                auto acc = \"T[\";\n-                for (ty.mt mt in mts) {acc += mt_str(cx, mt);}\n-                ret acc + \"]\";\n+                w.write_str(\"T[\");\n+                for (ty.mt mt in mts) {\n+                    enc_mt(w, cx, mt);\n+                }\n+                w.write_char(']');\n             }\n             case (ty.ty_rec(?fields)) {\n-                auto acc = \"R[\";\n+                w.write_str(\"R[\");\n                 for (ty.field field in fields) {\n-                    acc += field.ident + \"=\";\n-                    acc += mt_str(cx, field.mt);\n+                    w.write_str(field.ident);\n+                    w.write_char('=');\n+                    enc_mt(w, cx, field.mt);\n                 }\n-                ret acc + \"]\";\n+                w.write_char(']');\n             }\n             case (ty.ty_fn(?proto,?args,?out)) {\n-                ret proto_str(proto) + ty_fn_str(cx, args, out);\n+                enc_proto(w, proto);\n+                enc_ty_fn(w, cx, args, out);\n             }\n             case (ty.ty_native_fn(?abi,?args,?out)) {\n-                auto abistr;\n+                w.write_char('N');\n                 alt (abi) {\n-                    case (ast.native_abi_rust) {abistr = \"r\";}\n-                    case (ast.native_abi_cdecl) {abistr = \"c\";}\n-                    case (ast.native_abi_llvm) {abistr = \"l\";}\n+                    case (ast.native_abi_rust) { w.write_char('r'); }\n+                    case (ast.native_abi_cdecl) { w.write_char('c'); }\n+                    case (ast.native_abi_llvm) { w.write_char('l'); }\n                 }\n-                ret \"N\" + abistr + ty_fn_str(cx, args, out);\n+                enc_ty_fn(w, cx, args, out);\n             }\n             case (ty.ty_obj(?methods)) {\n-                auto acc = \"O[\";\n+                w.write_str(\"O[\");\n                 for (ty.method m in methods) {\n-                    acc += proto_str(m.proto);\n-                    acc += m.ident;\n-                    acc += ty_fn_str(cx, m.inputs, m.output);\n+                    enc_proto(w, m.proto);\n+                    w.write_str(m.ident);\n+                    enc_ty_fn(w, cx, m.inputs, m.output);\n                 }\n-                ret acc + \"]\";\n+                w.write_char(']');\n+            }\n+            case (ty.ty_var(?id)) {\n+                w.write_char('X');\n+                w.write_str(common.istr(id));\n             }\n-            case (ty.ty_var(?id)) {ret \"X\" + common.istr(id);}\n-            case (ty.ty_native) {ret \"E\";}\n-            case (ty.ty_param(?id)) {ret \"p\" + common.uistr(id);}\n-            case (ty.ty_type) {ret \"Y\";}\n+            case (ty.ty_native) {w.write_char('E');}\n+            case (ty.ty_param(?id)) {\n+                w.write_char('p');\n+                w.write_str(common.uistr(id));\n+            }\n+            case (ty.ty_type) {w.write_char('Y');}\n \n             // These two don't appear in crate metadata, but are here because\n             // `hash_ty()` uses this function.\n-            case (ty.ty_bound_param(?id)) {ret \"o\" + common.uistr(id);}\n-            case (ty.ty_local(?def)) {ret \"L\" + cx.ds(def);}\n+            case (ty.ty_bound_param(?id)) {\n+                w.write_char('o');\n+                w.write_str(common.uistr(id));\n+            }\n+            case (ty.ty_local(?def)) {\n+                w.write_char('L');\n+                w.write_str(cx.ds(def));\n+            }\n         }\n     }\n \n-    fn proto_str(ast.proto proto) -> str {\n+    fn enc_proto(io.writer w, ast.proto proto) {\n         alt (proto) {\n-            case (ast.proto_iter) {ret \"W\";}\n-            case (ast.proto_fn) {ret \"F\";}\n+            case (ast.proto_iter) { w.write_char('W'); }\n+            case (ast.proto_fn) { w.write_char('F'); }\n         }\n     }\n \n-    fn ty_fn_str(@ctxt cx, vec[ty.arg] args, ty.t out) -> str {\n-        auto acc = \"[\";\n+    fn enc_ty_fn(io.writer w, @ctxt cx, vec[ty.arg] args, ty.t out) {\n+        w.write_char('[');\n         for (ty.arg arg in args) {\n-            if (arg.mode == ast.alias) {acc += \"&\";}\n-            acc += ty_str(cx, arg.ty);\n+            if (arg.mode == ast.alias) { w.write_char('&'); }\n+            enc_ty(w, cx, arg.ty);\n         }\n-        ret acc + \"]\" + ty_str(cx, out);\n+        w.write_char(']');\n+        enc_ty(w, cx, out);\n     }\n \n }\n@@ -336,9 +405,9 @@ fn encode_type(@trans.crate_ctxt cx, &ebml.writer ebml_w, ty.t typ) {\n     ebml.start_tag(ebml_w, tag_items_data_item_type);\n \n     auto f = def_to_str;\n-    auto ty_str_ctxt = @rec(ds=f, tcx=cx.tcx);\n-    ebml_w.writer.write(_str.bytes(Encode.ty_str(ty_str_ctxt, typ)));\n-\n+    auto ty_str_ctxt = @rec(ds=f, tcx=cx.tcx,\n+                            use_abbrevs=true, abbrevs=cx.type_abbrevs);\n+    Encode.enc_ty(io.new_writer_(ebml_w.writer), ty_str_ctxt, typ);\n     ebml.end_tag(ebml_w);\n }\n \n@@ -565,7 +634,6 @@ fn encode_index[T](&ebml.writer ebml_w, vec[vec[tup(T, uint)]] buckets,\n     ebml.end_tag(ebml_w);\n }\n \n-\n fn write_str(io.writer writer, &str s) {\n     writer.write_str(s);\n }"}, {"sha": "788c2fee0aba354f176351788ae788120a3d72df", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a2f68b2d585f0b467f0911d162f3cb9bc7d1ad14/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f68b2d585f0b467f0911d162f3cb9bc7d1ad14/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=a2f68b2d585f0b467f0911d162f3cb9bc7d1ad14", "patch": "@@ -114,6 +114,7 @@ state type crate_ctxt = rec(session.session sess,\n                             namegen names,\n                             std.sha1.sha1 sha,\n                             hashmap[ty.t, str] type_sha1s,\n+                            hashmap[ty.t, metadata.ty_abbrev] type_abbrevs,\n                             ty.ctxt tcx);\n \n type local_ctxt = rec(vec[str] path,\n@@ -189,7 +190,10 @@ fn mangle_name_by_type(@crate_ctxt ccx, vec[str] path, ty.t t) -> str {\n         case (none[str]) {\n             ccx.sha.reset();\n             auto f = metadata.def_to_str;\n-            auto cx = @rec(ds=f, tcx=ccx.tcx);\n+            // NB: do *not* use abbrevs here as we want the symbol names\n+            // to be independent of one another in the crate.\n+            auto cx = @rec(ds=f, tcx=ccx.tcx,\n+                           use_abbrevs=false, abbrevs=ccx.type_abbrevs);\n             ccx.sha.input_str(metadata.Encode.ty_str(cx, t));\n             hash = _str.substr(ccx.sha.result_str(), 0u, 16u);\n             ccx.type_sha1s.insert(t, hash);\n@@ -791,7 +795,9 @@ fn type_of_inner(@crate_ctxt cx, ty.t t) -> TypeRef {\n     }\n \n     check (llty as int != 0);\n-    llvm.LLVMAddTypeName(cx.llmod, _str.buf(ty.ty_to_abbrev_str(cx.tcx, t)),\n+    llvm.LLVMAddTypeName(cx.llmod,\n+                         _str.buf(ty.ty_to_short_str(cx.tcx,\n+                                                     cx.type_abbrevs, t)),\n                          llty);\n     cx.lltypes.insert(t, llty);\n     ret llty;\n@@ -1673,8 +1679,7 @@ fn declare_tydesc(@local_ctxt cx, ty.t t) -> @tydesc_info {\n \n     auto glue_fn_ty = T_ptr(T_glue_fn(ccx.tn));\n \n-    auto name = sanitize(ccx.names.next(\"tydesc_\" +\n-        ty.ty_to_abbrev_str(cx.ccx.tcx, t)));\n+    auto name = mangle_name_by_seq(ccx, cx.path, \"tydesc\");\n     auto gvar = llvm.LLVMAddGlobal(ccx.llmod, T_tydesc(ccx.tn),\n                                    _str.buf(name));\n     auto tydesc = C_struct(vec(C_null(T_ptr(T_ptr(T_tydesc(ccx.tn)))),\n@@ -7672,6 +7677,7 @@ fn trans_crate(session.session sess, @ast.crate crate, ty.ctxt tcx,\n     auto tydescs = map.mk_hashmap[ty.t,@tydesc_info](hasher, eqer);\n     auto lltypes = map.mk_hashmap[ty.t,TypeRef](hasher, eqer);\n     auto sha1s = map.mk_hashmap[ty.t,str](hasher, eqer);\n+    auto abbrevs = map.mk_hashmap[ty.t,metadata.ty_abbrev](hasher, eqer);\n \n     auto ccx = @rec(sess = sess,\n                     llmod = llmod,\n@@ -7698,6 +7704,7 @@ fn trans_crate(session.session sess, @ast.crate crate, ty.ctxt tcx,\n                     names = namegen(0),\n                     sha = std.sha1.mk_sha1(),\n                     type_sha1s = sha1s,\n+                    type_abbrevs = abbrevs,\n                     tcx = tcx);\n     auto cx = new_local_ctxt(ccx);\n "}, {"sha": "83befefc701227145c761afd283235c7adf19e88", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a2f68b2d585f0b467f0911d162f3cb9bc7d1ad14/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f68b2d585f0b467f0911d162f3cb9bc7d1ad14/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=a2f68b2d585f0b467f0911d162f3cb9bc7d1ad14", "patch": "@@ -46,7 +46,10 @@ type mt = rec(t ty, ast.mutability mut);\n \n // Contains information needed to resolve types and (in the future) look up\n // the types of AST nodes.\n-type ctxt = rec(@type_store ts, session.session sess);\n+type creader_cache = hashmap[tup(int,uint,uint),ty.t];\n+type ctxt = rec(@type_store ts,\n+                session.session sess,\n+                creader_cache rcache);\n type ty_ctxt = ctxt;    // Needed for disambiguation from Unify.ctxt.\n \n // Convert from method type to function type.  Pretty easy; we just drop\n@@ -200,8 +203,26 @@ fn mk_type_store() -> @type_store {\n              others=map.mk_hashmap[t,t](hasher, eqer));\n }\n \n-fn mk_ctxt(session.session s) -> ctxt { ret rec(ts=mk_type_store(), sess=s); }\n+fn mk_rcache() -> creader_cache {\n+    fn hash_cache_entry(&tup(int,uint,uint) k) -> uint {\n+        ret (k._0 as uint) + k._1 + k._2;\n+    }\n+    fn eq_cache_entries(&tup(int,uint,uint) a,\n+                        &tup(int,uint,uint) b) -> bool {\n+        ret a._0 == b._0 &&\n+            a._1 == b._1 &&\n+            a._2 == b._2;\n+    }\n+    auto h = hash_cache_entry;\n+    auto e = eq_cache_entries;\n+    ret map.mk_hashmap[tup(int,uint,uint),t](h, e);\n+}\n \n+fn mk_ctxt(session.session s) -> ctxt {\n+    ret rec(ts = mk_type_store(),\n+            sess = s,\n+            rcache = mk_rcache());\n+}\n // Type constructors\n \n fn mk_ty_full(&sty st, option.t[str] cname) -> t {\n@@ -627,9 +648,10 @@ fn ty_to_str(ctxt cx, &t typ) -> str {\n     ret s;\n }\n \n-fn ty_to_abbrev_str(ctxt cx, t typ) -> str {\n+fn ty_to_short_str(ctxt cx, hashmap[ty.t, metadata.ty_abbrev] abbrevs,\n+                   t typ) -> str {\n     auto f = def_to_str;\n-    auto ecx = @rec(ds=f, tcx=cx);\n+    auto ecx = @rec(ds=f, tcx=cx,  use_abbrevs=false, abbrevs=abbrevs);\n     auto s = metadata.Encode.ty_str(ecx, typ);\n     if (_str.byte_len(s) >= 64u) { s = _str.substr(s, 0u, 64u); }\n     ret s;"}]}