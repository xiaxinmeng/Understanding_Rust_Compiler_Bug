{"sha": "3b98c08288528c243973a54934e4be75bcf20c31", "node_id": "C_kwDOAAsO6NoAKDNiOThjMDgyODg1MjhjMjQzOTczYTU0OTM0ZTRiZTc1YmNmMjBjMzE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-19T00:25:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-19T00:25:25Z"}, "message": "Auto merge of #98242 - matthiaskrgr:rollup-qbbkwtf, r=matthiaskrgr\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #97511 (Don't build the compiler before building rust-demangler)\n - #98165 (once cell renamings)\n - #98207 (Update cargo)\n - #98229 (Add new eslint checks)\n - #98230 (Fix weird js condition)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "cbfd0796bbc2b1be86a2c0770bf56eff1061993b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cbfd0796bbc2b1be86a2c0770bf56eff1061993b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b98c08288528c243973a54934e4be75bcf20c31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b98c08288528c243973a54934e4be75bcf20c31", "html_url": "https://github.com/rust-lang/rust/commit/3b98c08288528c243973a54934e4be75bcf20c31", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b98c08288528c243973a54934e4be75bcf20c31/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e430bfa9a6a9d81b25bddf6325069d217dc6f3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e430bfa9a6a9d81b25bddf6325069d217dc6f3f", "html_url": "https://github.com/rust-lang/rust/commit/8e430bfa9a6a9d81b25bddf6325069d217dc6f3f"}, {"sha": "267fe3bf81f0ef2200fb55f12e130d05b1a71aa5", "url": "https://api.github.com/repos/rust-lang/rust/commits/267fe3bf81f0ef2200fb55f12e130d05b1a71aa5", "html_url": "https://github.com/rust-lang/rust/commit/267fe3bf81f0ef2200fb55f12e130d05b1a71aa5"}], "stats": {"total": 2532, "additions": 1288, "deletions": 1244}, "files": [{"sha": "671f85ca3b6c379d407e572b4cd6c48cedf20b7b", "filename": "Cargo.lock", "status": "modified", "additions": 27, "deletions": 21, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -332,7 +332,7 @@ dependencies = [\n  \"cargo-test-macro\",\n  \"cargo-test-support\",\n  \"cargo-util\",\n- \"clap 3.1.1\",\n+ \"clap 3.2.5\",\n  \"crates-io\",\n  \"crossbeam-utils\",\n  \"curl\",\n@@ -470,7 +470,7 @@ dependencies = [\n \n [[package]]\n name = \"cargo-util\"\n-version = \"0.1.3\"\n+version = \"0.1.4\"\n dependencies = [\n  \"anyhow\",\n  \"core-foundation\",\n@@ -615,19 +615,19 @@ dependencies = [\n \n [[package]]\n name = \"clap\"\n-version = \"3.1.1\"\n+version = \"3.2.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6d76c22c9b9b215eeb8d016ad3a90417bd13cb24cf8142756e6472445876cab7\"\n+checksum = \"d53da17d37dba964b9b3ecb5c5a1f193a2762c700e6829201e645b9381c99dc7\"\n dependencies = [\n  \"atty\",\n  \"bitflags\",\n  \"clap_derive\",\n+ \"clap_lex\",\n  \"indexmap\",\n- \"lazy_static\",\n- \"os_str_bytes\",\n+ \"once_cell\",\n  \"strsim 0.10.0\",\n  \"termcolor\",\n- \"textwrap 0.14.2\",\n+ \"textwrap 0.15.0\",\n ]\n \n [[package]]\n@@ -636,14 +636,14 @@ version = \"3.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"df6f3613c0a3cddfd78b41b10203eb322cb29b600cbdf808a7d3db95691b8e25\"\n dependencies = [\n- \"clap 3.1.1\",\n+ \"clap 3.2.5\",\n ]\n \n [[package]]\n name = \"clap_derive\"\n-version = \"3.1.18\"\n+version = \"3.2.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"25320346e922cffe59c0bbc5410c8d8784509efb321488971081313cb1e1a33c\"\n+checksum = \"c11d40217d16aee8508cc8e5fde8b4ff24639758608e5374e731b53f85749fb9\"\n dependencies = [\n  \"heck 0.4.0\",\n  \"proc-macro-error\",\n@@ -652,6 +652,15 @@ dependencies = [\n  \"syn\",\n ]\n \n+[[package]]\n+name = \"clap_lex\"\n+version = \"0.2.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5538cd660450ebeb4234cfecf8f2284b844ffc4c50531e66d584ad5b91293613\"\n+dependencies = [\n+ \"os_str_bytes\",\n+]\n+\n [[package]]\n name = \"clippy\"\n version = \"0.1.63\"\n@@ -684,7 +693,7 @@ name = \"clippy_dev\"\n version = \"0.0.1\"\n dependencies = [\n  \"aho-corasick\",\n- \"clap 3.1.1\",\n+ \"clap 3.2.5\",\n  \"indoc\",\n  \"itertools\",\n  \"opener\",\n@@ -2334,7 +2343,7 @@ dependencies = [\n  \"ammonia\",\n  \"anyhow\",\n  \"chrono\",\n- \"clap 3.1.1\",\n+ \"clap 3.2.5\",\n  \"clap_complete\",\n  \"elasticlunr-rs\",\n  \"env_logger 0.7.1\",\n@@ -2572,9 +2581,9 @@ dependencies = [\n \n [[package]]\n name = \"once_cell\"\n-version = \"1.10.0\"\n+version = \"1.12.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"87f3e037eac156d1775da914196f0f37741a274155e34a0b7e427c35d2a2ecb9\"\n+checksum = \"7709cef83f0c1f58f666e746a08b21e0085f7440fa6a29cc194d68aac97a4225\"\n \n [[package]]\n name = \"opaque-debug\"\n@@ -2657,9 +2666,6 @@ name = \"os_str_bytes\"\n version = \"6.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"8e22443d1643a904602595ba1cd8f7d896afe56d26712531c5ff73a15b2fbf64\"\n-dependencies = [\n- \"memchr\",\n-]\n \n [[package]]\n name = \"output_vt100\"\n@@ -3515,7 +3521,7 @@ version = \"1.0.0\"\n dependencies = [\n  \"bstr\",\n  \"byteorder\",\n- \"clap 3.1.1\",\n+ \"clap 3.2.5\",\n  \"crossbeam-utils\",\n  \"libc\",\n  \"libz-sys\",\n@@ -4696,7 +4702,7 @@ dependencies = [\n  \"anyhow\",\n  \"bytecount\",\n  \"cargo_metadata\",\n- \"clap 3.1.1\",\n+ \"clap 3.2.5\",\n  \"derive-new\",\n  \"diff\",\n  \"dirs\",\n@@ -5259,9 +5265,9 @@ dependencies = [\n \n [[package]]\n name = \"textwrap\"\n-version = \"0.14.2\"\n+version = \"0.15.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0066c8d12af8b5acd21e00547c3797fde4e8677254a7ee429176ccebbe93dd80\"\n+checksum = \"b1141d4d61095b28419e22cb0bbf02755f5e54e0526f97f1e3d1d160e60885fb\"\n \n [[package]]\n name = \"thiserror\""}, {"sha": "a56a91000596c226441defac6acfdee86a814fe5", "filename": "compiler/rustc_codegen_cranelift/src/driver/jit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fdriver%2Fjit.rs?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -13,7 +13,7 @@ use rustc_span::Symbol;\n \n use cranelift_jit::{JITBuilder, JITModule};\n \n-// FIXME use std::lazy::SyncOnceCell once it stabilizes\n+// FIXME use std::sync::OnceLock once it stabilizes\n use once_cell::sync::OnceCell;\n \n use crate::{prelude::*, BackendConfig};"}, {"sha": "71699b5cf38306dcad52c67822fbb4302892268e", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -36,9 +36,9 @@ use rustc_target::abi::Size;\n \n use libc::c_uint;\n use smallvec::SmallVec;\n+use std::cell::OnceCell;\n use std::cell::RefCell;\n use std::iter;\n-use std::lazy::OnceCell;\n use tracing::debug;\n \n mod create_scope_map;"}, {"sha": "39c7a408fb50f4fc5ec48ddb7a6e93435b83ba11", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -38,11 +38,11 @@ use regex::Regex;\n use tempfile::Builder as TempFileBuilder;\n \n use std::borrow::Borrow;\n+use std::cell::OnceCell;\n use std::collections::BTreeSet;\n use std::ffi::OsString;\n use std::fs::{File, OpenOptions};\n use std::io::{BufWriter, Write};\n-use std::lazy::OnceCell;\n use std::ops::Deref;\n use std::path::{Path, PathBuf};\n use std::process::{ExitStatus, Output, Stdio};"}, {"sha": "09baa3095a4d40141c3d6c516f5472b95add6d48", "filename": "compiler/rustc_data_structures/src/jobserver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/compiler%2Frustc_data_structures%2Fsrc%2Fjobserver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/compiler%2Frustc_data_structures%2Fsrc%2Fjobserver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fjobserver.rs?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -1,5 +1,5 @@\n pub use jobserver_crate::Client;\n-use std::lazy::SyncLazy;\n+use std::sync::LazyLock;\n \n // We can only call `from_env` once per process\n \n@@ -18,7 +18,7 @@ use std::lazy::SyncLazy;\n // Also note that we stick this in a global because there could be\n // multiple rustc instances in this process, and the jobserver is\n // per-process.\n-static GLOBAL_CLIENT: SyncLazy<Client> = SyncLazy::new(|| unsafe {\n+static GLOBAL_CLIENT: LazyLock<Client> = LazyLock::new(|| unsafe {\n     Client::from_env().unwrap_or_else(|| {\n         let client = Client::new(32).expect(\"failed to create jobserver\");\n         // Acquire a token for the main thread which we can release later"}, {"sha": "feb82cb093818a27a66100ccf148746440665aef", "filename": "compiler/rustc_data_structures/src/sync.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsync.rs?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -173,7 +173,7 @@ cfg_if! {\n         pub use std::cell::RefMut as LockGuard;\n         pub use std::cell::RefMut as MappedLockGuard;\n \n-        pub use std::lazy::OnceCell;\n+        pub use std::cell::OnceCell;\n \n         use std::cell::RefCell as InnerRwLock;\n         use std::cell::RefCell as InnerLock;\n@@ -258,7 +258,7 @@ cfg_if! {\n         pub use parking_lot::MutexGuard as LockGuard;\n         pub use parking_lot::MappedMutexGuard as MappedLockGuard;\n \n-        pub use std::lazy::SyncOnceCell as OnceCell;\n+        pub use std::sync::OnceLock as OnceCell;\n \n         pub use std::sync::atomic::{AtomicBool, AtomicUsize, AtomicU32, AtomicU64};\n "}, {"sha": "caa92e74808c0eb991cf46e50c638bdae4922182", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -47,11 +47,11 @@ use std::env;\n use std::ffi::OsString;\n use std::fs;\n use std::io::{self, Read, Write};\n-use std::lazy::SyncLazy;\n use std::panic::{self, catch_unwind};\n use std::path::PathBuf;\n use std::process::{self, Command, Stdio};\n use std::str;\n+use std::sync::LazyLock;\n use std::time::Instant;\n \n pub mod args;\n@@ -1141,8 +1141,8 @@ pub fn catch_with_exit_code(f: impl FnOnce() -> interface::Result<()>) -> i32 {\n     }\n }\n \n-static DEFAULT_HOOK: SyncLazy<Box<dyn Fn(&panic::PanicInfo<'_>) + Sync + Send + 'static>> =\n-    SyncLazy::new(|| {\n+static DEFAULT_HOOK: LazyLock<Box<dyn Fn(&panic::PanicInfo<'_>) + Sync + Send + 'static>> =\n+    LazyLock::new(|| {\n         let hook = panic::take_hook();\n         panic::set_hook(Box::new(|info| {\n             // Invoke the default handler, which prints the actual panic message and optionally a backtrace\n@@ -1237,7 +1237,7 @@ pub fn install_ice_hook() {\n     if std::env::var(\"RUST_BACKTRACE\").is_err() {\n         std::env::set_var(\"RUST_BACKTRACE\", \"full\");\n     }\n-    SyncLazy::force(&DEFAULT_HOOK);\n+    LazyLock::force(&DEFAULT_HOOK);\n }\n \n /// This allows tools to enable rust logging without having to magically match rustc's"}, {"sha": "fefcaa898c1b9bebfd719f86053bf9f277662ee4", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -18,9 +18,9 @@ use std::path::{Path, PathBuf};\n use tracing::{instrument, trace};\n \n #[cfg(not(parallel_compiler))]\n-use std::lazy::Lazy;\n+use std::cell::LazyCell as Lazy;\n #[cfg(parallel_compiler)]\n-use std::lazy::SyncLazy as Lazy;\n+use std::sync::LazyLock as Lazy;\n \n #[cfg(parallel_compiler)]\n use intl_memoizer::concurrent::IntlLangMemoizer;"}, {"sha": "6fcdfe44d8f64b229f309e5535c2f57d9622ba7d", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -9,7 +9,7 @@ use crate::{Features, Stability};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_span::symbol::{sym, Symbol};\n \n-use std::lazy::SyncLazy;\n+use std::sync::LazyLock;\n \n type GateFn = fn(&Features) -> bool;\n \n@@ -809,8 +809,8 @@ pub fn is_builtin_only_local(name: Symbol) -> bool {\n     BUILTIN_ATTRIBUTE_MAP.get(&name).map_or(false, |attr| attr.only_local)\n }\n \n-pub static BUILTIN_ATTRIBUTE_MAP: SyncLazy<FxHashMap<Symbol, &BuiltinAttribute>> =\n-    SyncLazy::new(|| {\n+pub static BUILTIN_ATTRIBUTE_MAP: LazyLock<FxHashMap<Symbol, &BuiltinAttribute>> =\n+    LazyLock::new(|| {\n         let mut map = FxHashMap::default();\n         for attr in BUILTIN_ATTRIBUTES.iter() {\n             if map.insert(attr.name, attr).is_some() {"}, {"sha": "b0bfac8e1f5ecb40ed9f7ef7fd80c0c358089de0", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -17,7 +17,7 @@ use rustc_macros::HashStable_Generic;\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n \n-use std::lazy::SyncLazy;\n+use std::sync::LazyLock;\n \n pub enum LangItemGroup {\n     Op,\n@@ -134,7 +134,7 @@ macro_rules! language_item_table {\n         }\n \n         /// A mapping from the name of the lang item to its order and the form it must be of.\n-        pub static ITEM_REFS: SyncLazy<FxHashMap<Symbol, (usize, Target)>> = SyncLazy::new(|| {\n+        pub static ITEM_REFS: LazyLock<FxHashMap<Symbol, (usize, Target)>> = LazyLock::new(|| {\n             let mut item_refs = FxHashMap::default();\n             $( item_refs.insert($module::$name, (LangItem::$variant as usize, $target)); )*\n             item_refs"}, {"sha": "dad22725511edcd547fcbf9fd79d10aca3929f73", "filename": "compiler/rustc_hir/src/weak_lang_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/compiler%2Frustc_hir%2Fsrc%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/compiler%2Frustc_hir%2Fsrc%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fweak_lang_items.rs?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -7,12 +7,12 @@ use rustc_ast as ast;\n use rustc_data_structures::stable_map::StableMap;\n use rustc_span::symbol::{sym, Symbol};\n \n-use std::lazy::SyncLazy;\n+use std::sync::LazyLock;\n \n macro_rules! weak_lang_items {\n     ($($name:ident, $item:ident, $sym:ident;)*) => (\n \n-pub static WEAK_ITEMS_REFS: SyncLazy<StableMap<Symbol, LangItem>> = SyncLazy::new(|| {\n+pub static WEAK_ITEMS_REFS: LazyLock<StableMap<Symbol, LangItem>> = LazyLock::new(|| {\n     let mut map = StableMap::default();\n     $(map.insert(sym::$name, LangItem::$item);)*\n     map"}, {"sha": "502afa493fe66b609ccc5dd9783b83cd0019b599", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -44,11 +44,11 @@ use std::any::Any;\n use std::cell::RefCell;\n use std::ffi::OsString;\n use std::io::{self, BufWriter, Write};\n-use std::lazy::SyncLazy;\n use std::marker::PhantomPinned;\n use std::path::{Path, PathBuf};\n use std::pin::Pin;\n use std::rc::Rc;\n+use std::sync::LazyLock;\n use std::{env, fs, iter};\n \n pub fn parse<'a>(sess: &'a Session, input: &Input) -> PResult<'a, ast::Crate> {\n@@ -774,7 +774,7 @@ pub fn prepare_outputs(\n     Ok(outputs)\n }\n \n-pub static DEFAULT_QUERY_PROVIDERS: SyncLazy<Providers> = SyncLazy::new(|| {\n+pub static DEFAULT_QUERY_PROVIDERS: LazyLock<Providers> = LazyLock::new(|| {\n     let providers = &mut Providers::default();\n     providers.analysis = analysis;\n     proc_macro_decls::provide(providers);\n@@ -799,7 +799,7 @@ pub static DEFAULT_QUERY_PROVIDERS: SyncLazy<Providers> = SyncLazy::new(|| {\n     *providers\n });\n \n-pub static DEFAULT_EXTERN_QUERY_PROVIDERS: SyncLazy<ExternProviders> = SyncLazy::new(|| {\n+pub static DEFAULT_EXTERN_QUERY_PROVIDERS: LazyLock<ExternProviders> = LazyLock::new(|| {\n     let mut extern_providers = ExternProviders::default();\n     rustc_metadata::provide_extern(&mut extern_providers);\n     rustc_codegen_ssa::provide_extern(&mut extern_providers);"}, {"sha": "fb9258eb4a938fbaf6bea530446b297b4efc1f2e", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -24,12 +24,12 @@ use rustc_span::source_map::FileLoader;\n use rustc_span::symbol::{sym, Symbol};\n use std::env;\n use std::env::consts::{DLL_PREFIX, DLL_SUFFIX};\n-use std::lazy::SyncOnceCell;\n use std::mem;\n #[cfg(not(parallel_compiler))]\n use std::panic;\n use std::path::{Path, PathBuf};\n use std::sync::atomic::{AtomicBool, Ordering};\n+use std::sync::OnceLock;\n use std::thread;\n use tracing::info;\n \n@@ -242,7 +242,7 @@ pub fn get_codegen_backend(\n     maybe_sysroot: &Option<PathBuf>,\n     backend_name: Option<&str>,\n ) -> Box<dyn CodegenBackend> {\n-    static LOAD: SyncOnceCell<unsafe fn() -> Box<dyn CodegenBackend>> = SyncOnceCell::new();\n+    static LOAD: OnceLock<unsafe fn() -> Box<dyn CodegenBackend>> = OnceLock::new();\n \n     let load = LOAD.get_or_init(|| {\n         let default_codegen_backend = option_env!(\"CFG_DEFAULT_CODEGEN_BACKEND\").unwrap_or(\"llvm\");\n@@ -265,7 +265,7 @@ pub fn get_codegen_backend(\n // loading, so we leave the code here. It is potentially useful for other tools\n // that want to invoke the rustc binary while linking to rustc as well.\n pub fn rustc_path<'a>() -> Option<&'a Path> {\n-    static RUSTC_PATH: SyncOnceCell<Option<PathBuf>> = SyncOnceCell::new();\n+    static RUSTC_PATH: OnceLock<Option<PathBuf>> = OnceLock::new();\n \n     const BIN_PATH: &str = env!(\"RUSTC_INSTALL_BINDIR\");\n "}, {"sha": "c94198c56a8d1239e5417250dd1f855c48e7d10a", "filename": "compiler/rustc_mir_dataflow/src/framework/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fframework%2Fgraphviz.rs?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -1,7 +1,7 @@\n //! A helpful diagram for debugging dataflow problems.\n \n use std::borrow::Cow;\n-use std::lazy::SyncOnceCell;\n+use std::sync::OnceLock;\n use std::{io, ops, str};\n \n use regex::Regex;\n@@ -590,7 +590,7 @@ where\n \n macro_rules! regex {\n     ($re:literal $(,)?) => {{\n-        static RE: SyncOnceCell<regex::Regex> = SyncOnceCell::new();\n+        static RE: OnceLock<regex::Regex> = OnceLock::new();\n         RE.get_or_init(|| Regex::new($re).unwrap())\n     }};\n }"}, {"sha": "0f8679b0bd69dd0f797e684aa3cb3a9584907f63", "filename": "compiler/rustc_mir_transform/src/coverage/debug.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fdebug.rs?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -123,15 +123,15 @@ use rustc_middle::ty::TyCtxt;\n use rustc_span::Span;\n \n use std::iter;\n-use std::lazy::SyncOnceCell;\n use std::ops::Deref;\n+use std::sync::OnceLock;\n \n pub const NESTED_INDENT: &str = \"    \";\n \n const RUSTC_COVERAGE_DEBUG_OPTIONS: &str = \"RUSTC_COVERAGE_DEBUG_OPTIONS\";\n \n pub(super) fn debug_options<'a>() -> &'a DebugOptions {\n-    static DEBUG_OPTIONS: SyncOnceCell<DebugOptions> = SyncOnceCell::new();\n+    static DEBUG_OPTIONS: OnceLock<DebugOptions> = OnceLock::new();\n \n     &DEBUG_OPTIONS.get_or_init(DebugOptions::from_env)\n }"}, {"sha": "ad85ac71fc8862c5d2ed8be9e84bcef8f7262b8b", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -29,9 +29,9 @@ use rustc_span::{Span, DUMMY_SP};\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode, WellFormedLoc};\n \n+use std::cell::LazyCell;\n use std::convert::TryInto;\n use std::iter;\n-use std::lazy::Lazy;\n use std::ops::ControlFlow;\n \n /// Helper type of a temporary returned by `.for_item(...)`.\n@@ -1728,7 +1728,7 @@ fn check_variances_for_type_defn<'tcx>(\n     identify_constrained_generic_params(tcx, ty_predicates, None, &mut constrained_parameters);\n \n     // Lazily calculated because it is only needed in case of an error.\n-    let explicitly_bounded_params = Lazy::new(|| {\n+    let explicitly_bounded_params = LazyCell::new(|| {\n         let icx = crate::collect::ItemCtxt::new(tcx, item.def_id.to_def_id());\n         hir_generics\n             .predicates"}, {"sha": "63c83ddb6f7cf637488ab7bea7fdf36d5e43914b", "filename": "library/core/src/cell.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/library%2Fcore%2Fsrc%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/library%2Fcore%2Fsrc%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell.rs?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -199,6 +199,14 @@ use crate::mem;\n use crate::ops::{CoerceUnsized, Deref, DerefMut};\n use crate::ptr::{self, NonNull};\n \n+mod lazy;\n+mod once;\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+pub use lazy::LazyCell;\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+pub use once::OnceCell;\n+\n /// A mutable memory location.\n ///\n /// # Examples"}, {"sha": "7844be5f783a9d46d933cd1bbfc147f32253090f", "filename": "library/core/src/cell/lazy.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/library%2Fcore%2Fsrc%2Fcell%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/library%2Fcore%2Fsrc%2Fcell%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell%2Flazy.rs?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -0,0 +1,104 @@\n+use crate::cell::{Cell, OnceCell};\n+use crate::fmt;\n+use crate::ops::Deref;\n+\n+/// A value which is initialized on the first access.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(once_cell)]\n+///\n+/// use std::cell::LazyCell;\n+///\n+/// let lazy: LazyCell<i32> = LazyCell::new(|| {\n+///     println!(\"initializing\");\n+///     92\n+/// });\n+/// println!(\"ready\");\n+/// println!(\"{}\", *lazy);\n+/// println!(\"{}\", *lazy);\n+///\n+/// // Prints:\n+/// //   ready\n+/// //   initializing\n+/// //   92\n+/// //   92\n+/// ```\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+pub struct LazyCell<T, F = fn() -> T> {\n+    cell: OnceCell<T>,\n+    init: Cell<Option<F>>,\n+}\n+\n+impl<T, F> LazyCell<T, F> {\n+    /// Creates a new lazy value with the given initializing function.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::cell::LazyCell;\n+    ///\n+    /// let hello = \"Hello, World!\".to_string();\n+    ///\n+    /// let lazy = LazyCell::new(|| hello.to_uppercase());\n+    ///\n+    /// assert_eq!(&*lazy, \"HELLO, WORLD!\");\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub const fn new(init: F) -> LazyCell<T, F> {\n+        LazyCell { cell: OnceCell::new(), init: Cell::new(Some(init)) }\n+    }\n+}\n+\n+impl<T, F: FnOnce() -> T> LazyCell<T, F> {\n+    /// Forces the evaluation of this lazy value and returns a reference to\n+    /// the result.\n+    ///\n+    /// This is equivalent to the `Deref` impl, but is explicit.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::cell::LazyCell;\n+    ///\n+    /// let lazy = LazyCell::new(|| 92);\n+    ///\n+    /// assert_eq!(LazyCell::force(&lazy), &92);\n+    /// assert_eq!(&*lazy, &92);\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn force(this: &LazyCell<T, F>) -> &T {\n+        this.cell.get_or_init(|| match this.init.take() {\n+            Some(f) => f(),\n+            None => panic!(\"`Lazy` instance has previously been poisoned\"),\n+        })\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T, F: FnOnce() -> T> Deref for LazyCell<T, F> {\n+    type Target = T;\n+    fn deref(&self) -> &T {\n+        LazyCell::force(self)\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: Default> Default for LazyCell<T> {\n+    /// Creates a new lazy value using `Default` as the initializing function.\n+    fn default() -> LazyCell<T> {\n+        LazyCell::new(T::default)\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: fmt::Debug, F> fmt::Debug for LazyCell<T, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Lazy\").field(\"cell\", &self.cell).field(\"init\", &\"..\").finish()\n+    }\n+}"}, {"sha": "3c39394dd8c8e7007200f4c063e523d72ca87368", "filename": "library/core/src/cell/once.rs", "status": "added", "additions": 283, "deletions": 0, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/library%2Fcore%2Fsrc%2Fcell%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/library%2Fcore%2Fsrc%2Fcell%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell%2Fonce.rs?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -0,0 +1,283 @@\n+use crate::cell::UnsafeCell;\n+use crate::fmt;\n+use crate::mem;\n+\n+/// A cell which can be written to only once.\n+///\n+/// Unlike `RefCell`, a `OnceCell` only provides shared `&T` references to its value.\n+/// Unlike `Cell`, a `OnceCell` doesn't require copying or replacing the value to access it.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(once_cell)]\n+///\n+/// use std::cell::OnceCell;\n+///\n+/// let cell = OnceCell::new();\n+/// assert!(cell.get().is_none());\n+///\n+/// let value: &String = cell.get_or_init(|| {\n+///     \"Hello, World!\".to_string()\n+/// });\n+/// assert_eq!(value, \"Hello, World!\");\n+/// assert!(cell.get().is_some());\n+/// ```\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+pub struct OnceCell<T> {\n+    // Invariant: written to at most once.\n+    inner: UnsafeCell<Option<T>>,\n+}\n+\n+impl<T> OnceCell<T> {\n+    /// Creates a new empty cell.\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    #[must_use]\n+    pub const fn new() -> OnceCell<T> {\n+        OnceCell { inner: UnsafeCell::new(None) }\n+    }\n+\n+    /// Gets the reference to the underlying value.\n+    ///\n+    /// Returns `None` if the cell is empty.\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn get(&self) -> Option<&T> {\n+        // SAFETY: Safe due to `inner`'s invariant\n+        unsafe { &*self.inner.get() }.as_ref()\n+    }\n+\n+    /// Gets the mutable reference to the underlying value.\n+    ///\n+    /// Returns `None` if the cell is empty.\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn get_mut(&mut self) -> Option<&mut T> {\n+        self.inner.get_mut().as_mut()\n+    }\n+\n+    /// Sets the contents of the cell to `value`.\n+    ///\n+    /// # Errors\n+    ///\n+    /// This method returns `Ok(())` if the cell was empty and `Err(value)` if\n+    /// it was full.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::cell::OnceCell;\n+    ///\n+    /// let cell = OnceCell::new();\n+    /// assert!(cell.get().is_none());\n+    ///\n+    /// assert_eq!(cell.set(92), Ok(()));\n+    /// assert_eq!(cell.set(62), Err(62));\n+    ///\n+    /// assert!(cell.get().is_some());\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn set(&self, value: T) -> Result<(), T> {\n+        // SAFETY: Safe because we cannot have overlapping mutable borrows\n+        let slot = unsafe { &*self.inner.get() };\n+        if slot.is_some() {\n+            return Err(value);\n+        }\n+\n+        // SAFETY: This is the only place where we set the slot, no races\n+        // due to reentrancy/concurrency are possible, and we've\n+        // checked that slot is currently `None`, so this write\n+        // maintains the `inner`'s invariant.\n+        let slot = unsafe { &mut *self.inner.get() };\n+        *slot = Some(value);\n+        Ok(())\n+    }\n+\n+    /// Gets the contents of the cell, initializing it with `f`\n+    /// if the cell was empty.\n+    ///\n+    /// # Panics\n+    ///\n+    /// If `f` panics, the panic is propagated to the caller, and the cell\n+    /// remains uninitialized.\n+    ///\n+    /// It is an error to reentrantly initialize the cell from `f`. Doing\n+    /// so results in a panic.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::cell::OnceCell;\n+    ///\n+    /// let cell = OnceCell::new();\n+    /// let value = cell.get_or_init(|| 92);\n+    /// assert_eq!(value, &92);\n+    /// let value = cell.get_or_init(|| unreachable!());\n+    /// assert_eq!(value, &92);\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn get_or_init<F>(&self, f: F) -> &T\n+    where\n+        F: FnOnce() -> T,\n+    {\n+        match self.get_or_try_init(|| Ok::<T, !>(f())) {\n+            Ok(val) => val,\n+        }\n+    }\n+\n+    /// Gets the contents of the cell, initializing it with `f` if\n+    /// the cell was empty. If the cell was empty and `f` failed, an\n+    /// error is returned.\n+    ///\n+    /// # Panics\n+    ///\n+    /// If `f` panics, the panic is propagated to the caller, and the cell\n+    /// remains uninitialized.\n+    ///\n+    /// It is an error to reentrantly initialize the cell from `f`. Doing\n+    /// so results in a panic.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::cell::OnceCell;\n+    ///\n+    /// let cell = OnceCell::new();\n+    /// assert_eq!(cell.get_or_try_init(|| Err(())), Err(()));\n+    /// assert!(cell.get().is_none());\n+    /// let value = cell.get_or_try_init(|| -> Result<i32, ()> {\n+    ///     Ok(92)\n+    /// });\n+    /// assert_eq!(value, Ok(&92));\n+    /// assert_eq!(cell.get(), Some(&92))\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn get_or_try_init<F, E>(&self, f: F) -> Result<&T, E>\n+    where\n+        F: FnOnce() -> Result<T, E>,\n+    {\n+        if let Some(val) = self.get() {\n+            return Ok(val);\n+        }\n+        /// Avoid inlining the initialization closure into the common path that fetches\n+        /// the already initialized value\n+        #[cold]\n+        fn outlined_call<F, T, E>(f: F) -> Result<T, E>\n+        where\n+            F: FnOnce() -> Result<T, E>,\n+        {\n+            f()\n+        }\n+        let val = outlined_call(f)?;\n+        // Note that *some* forms of reentrant initialization might lead to\n+        // UB (see `reentrant_init` test). I believe that just removing this\n+        // `assert`, while keeping `set/get` would be sound, but it seems\n+        // better to panic, rather than to silently use an old value.\n+        assert!(self.set(val).is_ok(), \"reentrant init\");\n+        Ok(self.get().unwrap())\n+    }\n+\n+    /// Consumes the cell, returning the wrapped value.\n+    ///\n+    /// Returns `None` if the cell was empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::cell::OnceCell;\n+    ///\n+    /// let cell: OnceCell<String> = OnceCell::new();\n+    /// assert_eq!(cell.into_inner(), None);\n+    ///\n+    /// let cell = OnceCell::new();\n+    /// cell.set(\"hello\".to_string()).unwrap();\n+    /// assert_eq!(cell.into_inner(), Some(\"hello\".to_string()));\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn into_inner(self) -> Option<T> {\n+        // Because `into_inner` takes `self` by value, the compiler statically verifies\n+        // that it is not currently borrowed. So it is safe to move out `Option<T>`.\n+        self.inner.into_inner()\n+    }\n+\n+    /// Takes the value out of this `OnceCell`, moving it back to an uninitialized state.\n+    ///\n+    /// Has no effect and returns `None` if the `OnceCell` hasn't been initialized.\n+    ///\n+    /// Safety is guaranteed by requiring a mutable reference.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::cell::OnceCell;\n+    ///\n+    /// let mut cell: OnceCell<String> = OnceCell::new();\n+    /// assert_eq!(cell.take(), None);\n+    ///\n+    /// let mut cell = OnceCell::new();\n+    /// cell.set(\"hello\".to_string()).unwrap();\n+    /// assert_eq!(cell.take(), Some(\"hello\".to_string()));\n+    /// assert_eq!(cell.get(), None);\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn take(&mut self) -> Option<T> {\n+        mem::take(self).into_inner()\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T> Default for OnceCell<T> {\n+    fn default() -> Self {\n+        Self::new()\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: fmt::Debug> fmt::Debug for OnceCell<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self.get() {\n+            Some(v) => f.debug_tuple(\"OnceCell\").field(v).finish(),\n+            None => f.write_str(\"OnceCell(Uninit)\"),\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: Clone> Clone for OnceCell<T> {\n+    fn clone(&self) -> OnceCell<T> {\n+        let res = OnceCell::new();\n+        if let Some(value) = self.get() {\n+            match res.set(value.clone()) {\n+                Ok(()) => (),\n+                Err(_) => unreachable!(),\n+            }\n+        }\n+        res\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: PartialEq> PartialEq for OnceCell<T> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.get() == other.get()\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: Eq> Eq for OnceCell<T> {}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T> const From<T> for OnceCell<T> {\n+    /// Creates a new `OnceCell<T>` which already contains the given `value`.\n+    fn from(value: T) -> Self {\n+        OnceCell { inner: UnsafeCell::new(Some(value)) }\n+    }\n+}"}, {"sha": "f8c06c3f9aedb794a06851ff2f7ae988b4ebb020", "filename": "library/core/src/lazy.rs", "status": "modified", "additions": 0, "deletions": 388, "changes": 388, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/library%2Fcore%2Fsrc%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/library%2Fcore%2Fsrc%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flazy.rs?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -1,389 +1 @@\n //! Lazy values and one-time initialization of static data.\n-\n-use crate::cell::{Cell, UnsafeCell};\n-use crate::fmt;\n-use crate::mem;\n-use crate::ops::Deref;\n-\n-/// A cell which can be written to only once.\n-///\n-/// Unlike `RefCell`, a `OnceCell` only provides shared `&T` references to its value.\n-/// Unlike `Cell`, a `OnceCell` doesn't require copying or replacing the value to access it.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// #![feature(once_cell)]\n-///\n-/// use std::lazy::OnceCell;\n-///\n-/// let cell = OnceCell::new();\n-/// assert!(cell.get().is_none());\n-///\n-/// let value: &String = cell.get_or_init(|| {\n-///     \"Hello, World!\".to_string()\n-/// });\n-/// assert_eq!(value, \"Hello, World!\");\n-/// assert!(cell.get().is_some());\n-/// ```\n-#[unstable(feature = \"once_cell\", issue = \"74465\")]\n-pub struct OnceCell<T> {\n-    // Invariant: written to at most once.\n-    inner: UnsafeCell<Option<T>>,\n-}\n-\n-#[unstable(feature = \"once_cell\", issue = \"74465\")]\n-impl<T> Default for OnceCell<T> {\n-    fn default() -> Self {\n-        Self::new()\n-    }\n-}\n-\n-#[unstable(feature = \"once_cell\", issue = \"74465\")]\n-impl<T: fmt::Debug> fmt::Debug for OnceCell<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.get() {\n-            Some(v) => f.debug_tuple(\"OnceCell\").field(v).finish(),\n-            None => f.write_str(\"OnceCell(Uninit)\"),\n-        }\n-    }\n-}\n-\n-#[unstable(feature = \"once_cell\", issue = \"74465\")]\n-impl<T: Clone> Clone for OnceCell<T> {\n-    fn clone(&self) -> OnceCell<T> {\n-        let res = OnceCell::new();\n-        if let Some(value) = self.get() {\n-            match res.set(value.clone()) {\n-                Ok(()) => (),\n-                Err(_) => unreachable!(),\n-            }\n-        }\n-        res\n-    }\n-}\n-\n-#[unstable(feature = \"once_cell\", issue = \"74465\")]\n-impl<T: PartialEq> PartialEq for OnceCell<T> {\n-    fn eq(&self, other: &Self) -> bool {\n-        self.get() == other.get()\n-    }\n-}\n-\n-#[unstable(feature = \"once_cell\", issue = \"74465\")]\n-impl<T: Eq> Eq for OnceCell<T> {}\n-\n-#[unstable(feature = \"once_cell\", issue = \"74465\")]\n-impl<T> const From<T> for OnceCell<T> {\n-    /// Creates a new `OnceCell<T>` which already contains the given `value`.\n-    fn from(value: T) -> Self {\n-        OnceCell { inner: UnsafeCell::new(Some(value)) }\n-    }\n-}\n-\n-impl<T> OnceCell<T> {\n-    /// Creates a new empty cell.\n-    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n-    #[must_use]\n-    pub const fn new() -> OnceCell<T> {\n-        OnceCell { inner: UnsafeCell::new(None) }\n-    }\n-\n-    /// Gets the reference to the underlying value.\n-    ///\n-    /// Returns `None` if the cell is empty.\n-    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n-    pub fn get(&self) -> Option<&T> {\n-        // SAFETY: Safe due to `inner`'s invariant\n-        unsafe { &*self.inner.get() }.as_ref()\n-    }\n-\n-    /// Gets the mutable reference to the underlying value.\n-    ///\n-    /// Returns `None` if the cell is empty.\n-    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n-    pub fn get_mut(&mut self) -> Option<&mut T> {\n-        self.inner.get_mut().as_mut()\n-    }\n-\n-    /// Sets the contents of the cell to `value`.\n-    ///\n-    /// # Errors\n-    ///\n-    /// This method returns `Ok(())` if the cell was empty and `Err(value)` if\n-    /// it was full.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(once_cell)]\n-    ///\n-    /// use std::lazy::OnceCell;\n-    ///\n-    /// let cell = OnceCell::new();\n-    /// assert!(cell.get().is_none());\n-    ///\n-    /// assert_eq!(cell.set(92), Ok(()));\n-    /// assert_eq!(cell.set(62), Err(62));\n-    ///\n-    /// assert!(cell.get().is_some());\n-    /// ```\n-    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n-    pub fn set(&self, value: T) -> Result<(), T> {\n-        // SAFETY: Safe because we cannot have overlapping mutable borrows\n-        let slot = unsafe { &*self.inner.get() };\n-        if slot.is_some() {\n-            return Err(value);\n-        }\n-\n-        // SAFETY: This is the only place where we set the slot, no races\n-        // due to reentrancy/concurrency are possible, and we've\n-        // checked that slot is currently `None`, so this write\n-        // maintains the `inner`'s invariant.\n-        let slot = unsafe { &mut *self.inner.get() };\n-        *slot = Some(value);\n-        Ok(())\n-    }\n-\n-    /// Gets the contents of the cell, initializing it with `f`\n-    /// if the cell was empty.\n-    ///\n-    /// # Panics\n-    ///\n-    /// If `f` panics, the panic is propagated to the caller, and the cell\n-    /// remains uninitialized.\n-    ///\n-    /// It is an error to reentrantly initialize the cell from `f`. Doing\n-    /// so results in a panic.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(once_cell)]\n-    ///\n-    /// use std::lazy::OnceCell;\n-    ///\n-    /// let cell = OnceCell::new();\n-    /// let value = cell.get_or_init(|| 92);\n-    /// assert_eq!(value, &92);\n-    /// let value = cell.get_or_init(|| unreachable!());\n-    /// assert_eq!(value, &92);\n-    /// ```\n-    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n-    pub fn get_or_init<F>(&self, f: F) -> &T\n-    where\n-        F: FnOnce() -> T,\n-    {\n-        match self.get_or_try_init(|| Ok::<T, !>(f())) {\n-            Ok(val) => val,\n-        }\n-    }\n-\n-    /// Gets the contents of the cell, initializing it with `f` if\n-    /// the cell was empty. If the cell was empty and `f` failed, an\n-    /// error is returned.\n-    ///\n-    /// # Panics\n-    ///\n-    /// If `f` panics, the panic is propagated to the caller, and the cell\n-    /// remains uninitialized.\n-    ///\n-    /// It is an error to reentrantly initialize the cell from `f`. Doing\n-    /// so results in a panic.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(once_cell)]\n-    ///\n-    /// use std::lazy::OnceCell;\n-    ///\n-    /// let cell = OnceCell::new();\n-    /// assert_eq!(cell.get_or_try_init(|| Err(())), Err(()));\n-    /// assert!(cell.get().is_none());\n-    /// let value = cell.get_or_try_init(|| -> Result<i32, ()> {\n-    ///     Ok(92)\n-    /// });\n-    /// assert_eq!(value, Ok(&92));\n-    /// assert_eq!(cell.get(), Some(&92))\n-    /// ```\n-    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n-    pub fn get_or_try_init<F, E>(&self, f: F) -> Result<&T, E>\n-    where\n-        F: FnOnce() -> Result<T, E>,\n-    {\n-        if let Some(val) = self.get() {\n-            return Ok(val);\n-        }\n-        /// Avoid inlining the initialization closure into the common path that fetches\n-        /// the already initialized value\n-        #[cold]\n-        fn outlined_call<F, T, E>(f: F) -> Result<T, E>\n-        where\n-            F: FnOnce() -> Result<T, E>,\n-        {\n-            f()\n-        }\n-        let val = outlined_call(f)?;\n-        // Note that *some* forms of reentrant initialization might lead to\n-        // UB (see `reentrant_init` test). I believe that just removing this\n-        // `assert`, while keeping `set/get` would be sound, but it seems\n-        // better to panic, rather than to silently use an old value.\n-        assert!(self.set(val).is_ok(), \"reentrant init\");\n-        Ok(self.get().unwrap())\n-    }\n-\n-    /// Consumes the cell, returning the wrapped value.\n-    ///\n-    /// Returns `None` if the cell was empty.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(once_cell)]\n-    ///\n-    /// use std::lazy::OnceCell;\n-    ///\n-    /// let cell: OnceCell<String> = OnceCell::new();\n-    /// assert_eq!(cell.into_inner(), None);\n-    ///\n-    /// let cell = OnceCell::new();\n-    /// cell.set(\"hello\".to_string()).unwrap();\n-    /// assert_eq!(cell.into_inner(), Some(\"hello\".to_string()));\n-    /// ```\n-    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n-    pub fn into_inner(self) -> Option<T> {\n-        // Because `into_inner` takes `self` by value, the compiler statically verifies\n-        // that it is not currently borrowed. So it is safe to move out `Option<T>`.\n-        self.inner.into_inner()\n-    }\n-\n-    /// Takes the value out of this `OnceCell`, moving it back to an uninitialized state.\n-    ///\n-    /// Has no effect and returns `None` if the `OnceCell` hasn't been initialized.\n-    ///\n-    /// Safety is guaranteed by requiring a mutable reference.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(once_cell)]\n-    ///\n-    /// use std::lazy::OnceCell;\n-    ///\n-    /// let mut cell: OnceCell<String> = OnceCell::new();\n-    /// assert_eq!(cell.take(), None);\n-    ///\n-    /// let mut cell = OnceCell::new();\n-    /// cell.set(\"hello\".to_string()).unwrap();\n-    /// assert_eq!(cell.take(), Some(\"hello\".to_string()));\n-    /// assert_eq!(cell.get(), None);\n-    /// ```\n-    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n-    pub fn take(&mut self) -> Option<T> {\n-        mem::take(self).into_inner()\n-    }\n-}\n-\n-/// A value which is initialized on the first access.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// #![feature(once_cell)]\n-///\n-/// use std::lazy::Lazy;\n-///\n-/// let lazy: Lazy<i32> = Lazy::new(|| {\n-///     println!(\"initializing\");\n-///     92\n-/// });\n-/// println!(\"ready\");\n-/// println!(\"{}\", *lazy);\n-/// println!(\"{}\", *lazy);\n-///\n-/// // Prints:\n-/// //   ready\n-/// //   initializing\n-/// //   92\n-/// //   92\n-/// ```\n-#[unstable(feature = \"once_cell\", issue = \"74465\")]\n-pub struct Lazy<T, F = fn() -> T> {\n-    cell: OnceCell<T>,\n-    init: Cell<Option<F>>,\n-}\n-\n-#[unstable(feature = \"once_cell\", issue = \"74465\")]\n-impl<T: fmt::Debug, F> fmt::Debug for Lazy<T, F> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Lazy\").field(\"cell\", &self.cell).field(\"init\", &\"..\").finish()\n-    }\n-}\n-\n-impl<T, F> Lazy<T, F> {\n-    /// Creates a new lazy value with the given initializing function.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(once_cell)]\n-    ///\n-    /// # fn main() {\n-    /// use std::lazy::Lazy;\n-    ///\n-    /// let hello = \"Hello, World!\".to_string();\n-    ///\n-    /// let lazy = Lazy::new(|| hello.to_uppercase());\n-    ///\n-    /// assert_eq!(&*lazy, \"HELLO, WORLD!\");\n-    /// # }\n-    /// ```\n-    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n-    pub const fn new(init: F) -> Lazy<T, F> {\n-        Lazy { cell: OnceCell::new(), init: Cell::new(Some(init)) }\n-    }\n-}\n-\n-impl<T, F: FnOnce() -> T> Lazy<T, F> {\n-    /// Forces the evaluation of this lazy value and returns a reference to\n-    /// the result.\n-    ///\n-    /// This is equivalent to the `Deref` impl, but is explicit.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(once_cell)]\n-    ///\n-    /// use std::lazy::Lazy;\n-    ///\n-    /// let lazy = Lazy::new(|| 92);\n-    ///\n-    /// assert_eq!(Lazy::force(&lazy), &92);\n-    /// assert_eq!(&*lazy, &92);\n-    /// ```\n-    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n-    pub fn force(this: &Lazy<T, F>) -> &T {\n-        this.cell.get_or_init(|| match this.init.take() {\n-            Some(f) => f(),\n-            None => panic!(\"`Lazy` instance has previously been poisoned\"),\n-        })\n-    }\n-}\n-\n-#[unstable(feature = \"once_cell\", issue = \"74465\")]\n-impl<T, F: FnOnce() -> T> Deref for Lazy<T, F> {\n-    type Target = T;\n-    fn deref(&self) -> &T {\n-        Lazy::force(self)\n-    }\n-}\n-\n-#[unstable(feature = \"once_cell\", issue = \"74465\")]\n-impl<T: Default> Default for Lazy<T> {\n-    /// Creates a new lazy value using `Default` as the initializing function.\n-    fn default() -> Lazy<T> {\n-        Lazy::new(T::default)\n-    }\n-}"}, {"sha": "70fcc6d2d4bf7d9d1de717d017073ca85c9e97b1", "filename": "library/core/tests/lazy.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/library%2Fcore%2Ftests%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/library%2Fcore%2Ftests%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flazy.rs?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -1,6 +1,5 @@\n use core::{\n-    cell::Cell,\n-    lazy::{Lazy, OnceCell},\n+    cell::{Cell, LazyCell, OnceCell},\n     sync::atomic::{AtomicUsize, Ordering::SeqCst},\n };\n \n@@ -91,7 +90,7 @@ fn into_inner() {\n #[test]\n fn lazy_new() {\n     let called = Cell::new(0);\n-    let x = Lazy::new(|| {\n+    let x = LazyCell::new(|| {\n         called.set(called.get() + 1);\n         92\n     });"}, {"sha": "e3b62894d0f22d8a136fc01ecf63b8d0001a17e4", "filename": "library/std/src/io/stdio.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -8,10 +8,9 @@ use crate::io::prelude::*;\n use crate::cell::{Cell, RefCell};\n use crate::fmt;\n use crate::io::{self, BufReader, IoSlice, IoSliceMut, LineWriter, Lines};\n-use crate::lazy::SyncOnceCell;\n use crate::pin::Pin;\n use crate::sync::atomic::{AtomicBool, Ordering};\n-use crate::sync::{Arc, Mutex, MutexGuard};\n+use crate::sync::{Arc, Mutex, MutexGuard, OnceLock};\n use crate::sys::stdio;\n use crate::sys_common::remutex::{ReentrantMutex, ReentrantMutexGuard};\n \n@@ -318,7 +317,7 @@ pub struct StdinLock<'a> {\n #[must_use]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn stdin() -> Stdin {\n-    static INSTANCE: SyncOnceCell<Mutex<BufReader<StdinRaw>>> = SyncOnceCell::new();\n+    static INSTANCE: OnceLock<Mutex<BufReader<StdinRaw>>> = OnceLock::new();\n     Stdin {\n         inner: INSTANCE.get_or_init(|| {\n             Mutex::new(BufReader::with_capacity(stdio::STDIN_BUF_SIZE, stdin_raw()))\n@@ -552,7 +551,7 @@ pub struct StdoutLock<'a> {\n     inner: ReentrantMutexGuard<'a, RefCell<LineWriter<StdoutRaw>>>,\n }\n \n-static STDOUT: SyncOnceCell<ReentrantMutex<RefCell<LineWriter<StdoutRaw>>>> = SyncOnceCell::new();\n+static STDOUT: OnceLock<ReentrantMutex<RefCell<LineWriter<StdoutRaw>>>> = OnceLock::new();\n \n /// Constructs a new handle to the standard output of the current process.\n ///\n@@ -837,7 +836,7 @@ pub fn stderr() -> Stderr {\n     // Note that unlike `stdout()` we don't use `at_exit` here to register a\n     // destructor. Stderr is not buffered , so there's no need to run a\n     // destructor for flushing the buffer\n-    static INSTANCE: SyncOnceCell<ReentrantMutex<RefCell<StderrRaw>>> = SyncOnceCell::new();\n+    static INSTANCE: OnceLock<ReentrantMutex<RefCell<StderrRaw>>> = OnceLock::new();\n \n     Stderr {\n         inner: Pin::static_ref(&INSTANCE).get_or_init_pin("}, {"sha": "f8c06c3f9aedb794a06851ff2f7ae988b4ebb020", "filename": "library/std/src/lazy.rs", "status": "modified", "additions": 0, "deletions": 616, "changes": 616, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/library%2Fstd%2Fsrc%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/library%2Fstd%2Fsrc%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flazy.rs?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -1,617 +1 @@\n //! Lazy values and one-time initialization of static data.\n-\n-#[cfg(test)]\n-mod tests;\n-\n-use crate::{\n-    cell::{Cell, UnsafeCell},\n-    fmt,\n-    marker::PhantomData,\n-    mem::MaybeUninit,\n-    ops::{Deref, Drop},\n-    panic::{RefUnwindSafe, UnwindSafe},\n-    pin::Pin,\n-    sync::Once,\n-};\n-\n-#[doc(inline)]\n-#[unstable(feature = \"once_cell\", issue = \"74465\")]\n-pub use core::lazy::*;\n-\n-/// A synchronization primitive which can be written to only once.\n-///\n-/// This type is a thread-safe `OnceCell`.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// #![feature(once_cell)]\n-///\n-/// use std::lazy::SyncOnceCell;\n-///\n-/// static CELL: SyncOnceCell<String> = SyncOnceCell::new();\n-/// assert!(CELL.get().is_none());\n-///\n-/// std::thread::spawn(|| {\n-///     let value: &String = CELL.get_or_init(|| {\n-///         \"Hello, World!\".to_string()\n-///     });\n-///     assert_eq!(value, \"Hello, World!\");\n-/// }).join().unwrap();\n-///\n-/// let value: Option<&String> = CELL.get();\n-/// assert!(value.is_some());\n-/// assert_eq!(value.unwrap().as_str(), \"Hello, World!\");\n-/// ```\n-#[unstable(feature = \"once_cell\", issue = \"74465\")]\n-pub struct SyncOnceCell<T> {\n-    once: Once,\n-    // Whether or not the value is initialized is tracked by `state_and_queue`.\n-    value: UnsafeCell<MaybeUninit<T>>,\n-    /// `PhantomData` to make sure dropck understands we're dropping T in our Drop impl.\n-    ///\n-    /// ```compile_fail,E0597\n-    /// #![feature(once_cell)]\n-    ///\n-    /// use std::lazy::SyncOnceCell;\n-    ///\n-    /// struct A<'a>(&'a str);\n-    ///\n-    /// impl<'a> Drop for A<'a> {\n-    ///     fn drop(&mut self) {}\n-    /// }\n-    ///\n-    /// let cell = SyncOnceCell::new();\n-    /// {\n-    ///     let s = String::new();\n-    ///     let _ = cell.set(A(&s));\n-    /// }\n-    /// ```\n-    _marker: PhantomData<T>,\n-}\n-\n-// Why do we need `T: Send`?\n-// Thread A creates a `SyncOnceCell` and shares it with\n-// scoped thread B, which fills the cell, which is\n-// then destroyed by A. That is, destructor observes\n-// a sent value.\n-#[unstable(feature = \"once_cell\", issue = \"74465\")]\n-unsafe impl<T: Sync + Send> Sync for SyncOnceCell<T> {}\n-#[unstable(feature = \"once_cell\", issue = \"74465\")]\n-unsafe impl<T: Send> Send for SyncOnceCell<T> {}\n-\n-#[unstable(feature = \"once_cell\", issue = \"74465\")]\n-impl<T: RefUnwindSafe + UnwindSafe> RefUnwindSafe for SyncOnceCell<T> {}\n-#[unstable(feature = \"once_cell\", issue = \"74465\")]\n-impl<T: UnwindSafe> UnwindSafe for SyncOnceCell<T> {}\n-\n-#[unstable(feature = \"once_cell\", issue = \"74465\")]\n-#[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n-impl<T> const Default for SyncOnceCell<T> {\n-    /// Creates a new empty cell.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// #![feature(once_cell)]\n-    ///\n-    /// use std::lazy::SyncOnceCell;\n-    ///\n-    /// fn main() {\n-    ///     assert_eq!(SyncOnceCell::<()>::new(), SyncOnceCell::default());\n-    /// }\n-    /// ```\n-    fn default() -> SyncOnceCell<T> {\n-        SyncOnceCell::new()\n-    }\n-}\n-\n-#[unstable(feature = \"once_cell\", issue = \"74465\")]\n-impl<T: fmt::Debug> fmt::Debug for SyncOnceCell<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.get() {\n-            Some(v) => f.debug_tuple(\"Once\").field(v).finish(),\n-            None => f.write_str(\"Once(Uninit)\"),\n-        }\n-    }\n-}\n-\n-#[unstable(feature = \"once_cell\", issue = \"74465\")]\n-impl<T: Clone> Clone for SyncOnceCell<T> {\n-    fn clone(&self) -> SyncOnceCell<T> {\n-        let cell = Self::new();\n-        if let Some(value) = self.get() {\n-            match cell.set(value.clone()) {\n-                Ok(()) => (),\n-                Err(_) => unreachable!(),\n-            }\n-        }\n-        cell\n-    }\n-}\n-\n-#[unstable(feature = \"once_cell\", issue = \"74465\")]\n-impl<T> From<T> for SyncOnceCell<T> {\n-    /// Create a new cell with its contents set to `value`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// #![feature(once_cell)]\n-    ///\n-    /// use std::lazy::SyncOnceCell;\n-    ///\n-    /// # fn main() -> Result<(), i32> {\n-    /// let a = SyncOnceCell::from(3);\n-    /// let b = SyncOnceCell::new();\n-    /// b.set(3)?;\n-    /// assert_eq!(a, b);\n-    /// Ok(())\n-    /// # }\n-    /// ```\n-    fn from(value: T) -> Self {\n-        let cell = Self::new();\n-        match cell.set(value) {\n-            Ok(()) => cell,\n-            Err(_) => unreachable!(),\n-        }\n-    }\n-}\n-\n-#[unstable(feature = \"once_cell\", issue = \"74465\")]\n-impl<T: PartialEq> PartialEq for SyncOnceCell<T> {\n-    fn eq(&self, other: &SyncOnceCell<T>) -> bool {\n-        self.get() == other.get()\n-    }\n-}\n-\n-#[unstable(feature = \"once_cell\", issue = \"74465\")]\n-impl<T: Eq> Eq for SyncOnceCell<T> {}\n-\n-impl<T> SyncOnceCell<T> {\n-    /// Creates a new empty cell.\n-    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n-    #[must_use]\n-    pub const fn new() -> SyncOnceCell<T> {\n-        SyncOnceCell {\n-            once: Once::new(),\n-            value: UnsafeCell::new(MaybeUninit::uninit()),\n-            _marker: PhantomData,\n-        }\n-    }\n-\n-    /// Gets the reference to the underlying value.\n-    ///\n-    /// Returns `None` if the cell is empty, or being initialized. This\n-    /// method never blocks.\n-    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n-    pub fn get(&self) -> Option<&T> {\n-        if self.is_initialized() {\n-            // Safe b/c checked is_initialized\n-            Some(unsafe { self.get_unchecked() })\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Gets the mutable reference to the underlying value.\n-    ///\n-    /// Returns `None` if the cell is empty. This method never blocks.\n-    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n-    pub fn get_mut(&mut self) -> Option<&mut T> {\n-        if self.is_initialized() {\n-            // Safe b/c checked is_initialized and we have a unique access\n-            Some(unsafe { self.get_unchecked_mut() })\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Sets the contents of this cell to `value`.\n-    ///\n-    /// May block if another thread is currently attempting to initialize the cell. The cell is\n-    /// guaranteed to contain a value when set returns, though not necessarily the one provided.\n-    ///\n-    /// Returns `Ok(())` if the cell's value was set by this call.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(once_cell)]\n-    ///\n-    /// use std::lazy::SyncOnceCell;\n-    ///\n-    /// static CELL: SyncOnceCell<i32> = SyncOnceCell::new();\n-    ///\n-    /// fn main() {\n-    ///     assert!(CELL.get().is_none());\n-    ///\n-    ///     std::thread::spawn(|| {\n-    ///         assert_eq!(CELL.set(92), Ok(()));\n-    ///     }).join().unwrap();\n-    ///\n-    ///     assert_eq!(CELL.set(62), Err(62));\n-    ///     assert_eq!(CELL.get(), Some(&92));\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n-    pub fn set(&self, value: T) -> Result<(), T> {\n-        let mut value = Some(value);\n-        self.get_or_init(|| value.take().unwrap());\n-        match value {\n-            None => Ok(()),\n-            Some(value) => Err(value),\n-        }\n-    }\n-\n-    /// Gets the contents of the cell, initializing it with `f` if the cell\n-    /// was empty.\n-    ///\n-    /// Many threads may call `get_or_init` concurrently with different\n-    /// initializing functions, but it is guaranteed that only one function\n-    /// will be executed.\n-    ///\n-    /// # Panics\n-    ///\n-    /// If `f` panics, the panic is propagated to the caller, and the cell\n-    /// remains uninitialized.\n-    ///\n-    /// It is an error to reentrantly initialize the cell from `f`. The\n-    /// exact outcome is unspecified. Current implementation deadlocks, but\n-    /// this may be changed to a panic in the future.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(once_cell)]\n-    ///\n-    /// use std::lazy::SyncOnceCell;\n-    ///\n-    /// let cell = SyncOnceCell::new();\n-    /// let value = cell.get_or_init(|| 92);\n-    /// assert_eq!(value, &92);\n-    /// let value = cell.get_or_init(|| unreachable!());\n-    /// assert_eq!(value, &92);\n-    /// ```\n-    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n-    pub fn get_or_init<F>(&self, f: F) -> &T\n-    where\n-        F: FnOnce() -> T,\n-    {\n-        match self.get_or_try_init(|| Ok::<T, !>(f())) {\n-            Ok(val) => val,\n-        }\n-    }\n-\n-    /// Gets the contents of the cell, initializing it with `f` if\n-    /// the cell was empty. If the cell was empty and `f` failed, an\n-    /// error is returned.\n-    ///\n-    /// # Panics\n-    ///\n-    /// If `f` panics, the panic is propagated to the caller, and\n-    /// the cell remains uninitialized.\n-    ///\n-    /// It is an error to reentrantly initialize the cell from `f`.\n-    /// The exact outcome is unspecified. Current implementation\n-    /// deadlocks, but this may be changed to a panic in the future.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(once_cell)]\n-    ///\n-    /// use std::lazy::SyncOnceCell;\n-    ///\n-    /// let cell = SyncOnceCell::new();\n-    /// assert_eq!(cell.get_or_try_init(|| Err(())), Err(()));\n-    /// assert!(cell.get().is_none());\n-    /// let value = cell.get_or_try_init(|| -> Result<i32, ()> {\n-    ///     Ok(92)\n-    /// });\n-    /// assert_eq!(value, Ok(&92));\n-    /// assert_eq!(cell.get(), Some(&92))\n-    /// ```\n-    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n-    pub fn get_or_try_init<F, E>(&self, f: F) -> Result<&T, E>\n-    where\n-        F: FnOnce() -> Result<T, E>,\n-    {\n-        // Fast path check\n-        // NOTE: We need to perform an acquire on the state in this method\n-        // in order to correctly synchronize `SyncLazy::force`. This is\n-        // currently done by calling `self.get()`, which in turn calls\n-        // `self.is_initialized()`, which in turn performs the acquire.\n-        if let Some(value) = self.get() {\n-            return Ok(value);\n-        }\n-        self.initialize(f)?;\n-\n-        debug_assert!(self.is_initialized());\n-\n-        // SAFETY: The inner value has been initialized\n-        Ok(unsafe { self.get_unchecked() })\n-    }\n-\n-    /// Internal-only API that gets the contents of the cell, initializing it\n-    /// in two steps with `f` and `g` if the cell was empty.\n-    ///\n-    /// `f` is called to construct the value, which is then moved into the cell\n-    /// and given as a (pinned) mutable reference to `g` to finish\n-    /// initialization.\n-    ///\n-    /// This allows `g` to inspect an manipulate the value after it has been\n-    /// moved into its final place in the cell, but before the cell is\n-    /// considered initialized.\n-    ///\n-    /// # Panics\n-    ///\n-    /// If `f` or `g` panics, the panic is propagated to the caller, and the\n-    /// cell remains uninitialized.\n-    ///\n-    /// With the current implementation, if `g` panics, the value from `f` will\n-    /// not be dropped. This should probably be fixed if this is ever used for\n-    /// a type where this matters.\n-    ///\n-    /// It is an error to reentrantly initialize the cell from `f`. The exact\n-    /// outcome is unspecified. Current implementation deadlocks, but this may\n-    /// be changed to a panic in the future.\n-    pub(crate) fn get_or_init_pin<F, G>(self: Pin<&Self>, f: F, g: G) -> Pin<&T>\n-    where\n-        F: FnOnce() -> T,\n-        G: FnOnce(Pin<&mut T>),\n-    {\n-        if let Some(value) = self.get_ref().get() {\n-            // SAFETY: The inner value was already initialized, and will not be\n-            // moved anymore.\n-            return unsafe { Pin::new_unchecked(value) };\n-        }\n-\n-        let slot = &self.value;\n-\n-        // Ignore poisoning from other threads\n-        // If another thread panics, then we'll be able to run our closure\n-        self.once.call_once_force(|_| {\n-            let value = f();\n-            // SAFETY: We use the Once (self.once) to guarantee unique access\n-            // to the UnsafeCell (slot).\n-            let value: &mut T = unsafe { (&mut *slot.get()).write(value) };\n-            // SAFETY: The value has been written to its final place in\n-            // self.value. We do not to move it anymore, which we promise here\n-            // with a Pin<&mut T>.\n-            g(unsafe { Pin::new_unchecked(value) });\n-        });\n-\n-        // SAFETY: The inner value has been initialized, and will not be moved\n-        // anymore.\n-        unsafe { Pin::new_unchecked(self.get_ref().get_unchecked()) }\n-    }\n-\n-    /// Consumes the `SyncOnceCell`, returning the wrapped value. Returns\n-    /// `None` if the cell was empty.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(once_cell)]\n-    ///\n-    /// use std::lazy::SyncOnceCell;\n-    ///\n-    /// let cell: SyncOnceCell<String> = SyncOnceCell::new();\n-    /// assert_eq!(cell.into_inner(), None);\n-    ///\n-    /// let cell = SyncOnceCell::new();\n-    /// cell.set(\"hello\".to_string()).unwrap();\n-    /// assert_eq!(cell.into_inner(), Some(\"hello\".to_string()));\n-    /// ```\n-    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n-    pub fn into_inner(mut self) -> Option<T> {\n-        self.take()\n-    }\n-\n-    /// Takes the value out of this `SyncOnceCell`, moving it back to an uninitialized state.\n-    ///\n-    /// Has no effect and returns `None` if the `SyncOnceCell` hasn't been initialized.\n-    ///\n-    /// Safety is guaranteed by requiring a mutable reference.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(once_cell)]\n-    ///\n-    /// use std::lazy::SyncOnceCell;\n-    ///\n-    /// let mut cell: SyncOnceCell<String> = SyncOnceCell::new();\n-    /// assert_eq!(cell.take(), None);\n-    ///\n-    /// let mut cell = SyncOnceCell::new();\n-    /// cell.set(\"hello\".to_string()).unwrap();\n-    /// assert_eq!(cell.take(), Some(\"hello\".to_string()));\n-    /// assert_eq!(cell.get(), None);\n-    /// ```\n-    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n-    pub fn take(&mut self) -> Option<T> {\n-        if self.is_initialized() {\n-            self.once = Once::new();\n-            // SAFETY: `self.value` is initialized and contains a valid `T`.\n-            // `self.once` is reset, so `is_initialized()` will be false again\n-            // which prevents the value from being read twice.\n-            unsafe { Some((&mut *self.value.get()).assume_init_read()) }\n-        } else {\n-            None\n-        }\n-    }\n-\n-    #[inline]\n-    fn is_initialized(&self) -> bool {\n-        self.once.is_completed()\n-    }\n-\n-    #[cold]\n-    fn initialize<F, E>(&self, f: F) -> Result<(), E>\n-    where\n-        F: FnOnce() -> Result<T, E>,\n-    {\n-        let mut res: Result<(), E> = Ok(());\n-        let slot = &self.value;\n-\n-        // Ignore poisoning from other threads\n-        // If another thread panics, then we'll be able to run our closure\n-        self.once.call_once_force(|p| {\n-            match f() {\n-                Ok(value) => {\n-                    unsafe { (&mut *slot.get()).write(value) };\n-                }\n-                Err(e) => {\n-                    res = Err(e);\n-\n-                    // Treat the underlying `Once` as poisoned since we\n-                    // failed to initialize our value. Calls\n-                    p.poison();\n-                }\n-            }\n-        });\n-        res\n-    }\n-\n-    /// # Safety\n-    ///\n-    /// The value must be initialized\n-    unsafe fn get_unchecked(&self) -> &T {\n-        debug_assert!(self.is_initialized());\n-        (&*self.value.get()).assume_init_ref()\n-    }\n-\n-    /// # Safety\n-    ///\n-    /// The value must be initialized\n-    unsafe fn get_unchecked_mut(&mut self) -> &mut T {\n-        debug_assert!(self.is_initialized());\n-        (&mut *self.value.get()).assume_init_mut()\n-    }\n-}\n-\n-unsafe impl<#[may_dangle] T> Drop for SyncOnceCell<T> {\n-    fn drop(&mut self) {\n-        if self.is_initialized() {\n-            // SAFETY: The cell is initialized and being dropped, so it can't\n-            // be accessed again. We also don't touch the `T` other than\n-            // dropping it, which validates our usage of #[may_dangle].\n-            unsafe { (&mut *self.value.get()).assume_init_drop() };\n-        }\n-    }\n-}\n-\n-/// A value which is initialized on the first access.\n-///\n-/// This type is a thread-safe `Lazy`, and can be used in statics.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// #![feature(once_cell)]\n-///\n-/// use std::collections::HashMap;\n-///\n-/// use std::lazy::SyncLazy;\n-///\n-/// static HASHMAP: SyncLazy<HashMap<i32, String>> = SyncLazy::new(|| {\n-///     println!(\"initializing\");\n-///     let mut m = HashMap::new();\n-///     m.insert(13, \"Spica\".to_string());\n-///     m.insert(74, \"Hoyten\".to_string());\n-///     m\n-/// });\n-///\n-/// fn main() {\n-///     println!(\"ready\");\n-///     std::thread::spawn(|| {\n-///         println!(\"{:?}\", HASHMAP.get(&13));\n-///     }).join().unwrap();\n-///     println!(\"{:?}\", HASHMAP.get(&74));\n-///\n-///     // Prints:\n-///     //   ready\n-///     //   initializing\n-///     //   Some(\"Spica\")\n-///     //   Some(\"Hoyten\")\n-/// }\n-/// ```\n-#[unstable(feature = \"once_cell\", issue = \"74465\")]\n-pub struct SyncLazy<T, F = fn() -> T> {\n-    cell: SyncOnceCell<T>,\n-    init: Cell<Option<F>>,\n-}\n-\n-#[unstable(feature = \"once_cell\", issue = \"74465\")]\n-impl<T: fmt::Debug, F> fmt::Debug for SyncLazy<T, F> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Lazy\").field(\"cell\", &self.cell).finish_non_exhaustive()\n-    }\n-}\n-\n-// We never create a `&F` from a `&SyncLazy<T, F>` so it is fine\n-// to not impl `Sync` for `F`\n-// we do create a `&mut Option<F>` in `force`, but this is\n-// properly synchronized, so it only happens once\n-// so it also does not contribute to this impl.\n-#[unstable(feature = \"once_cell\", issue = \"74465\")]\n-unsafe impl<T, F: Send> Sync for SyncLazy<T, F> where SyncOnceCell<T>: Sync {}\n-// auto-derived `Send` impl is OK.\n-\n-#[unstable(feature = \"once_cell\", issue = \"74465\")]\n-impl<T, F: UnwindSafe> RefUnwindSafe for SyncLazy<T, F> where SyncOnceCell<T>: RefUnwindSafe {}\n-#[unstable(feature = \"once_cell\", issue = \"74465\")]\n-impl<T, F: UnwindSafe> UnwindSafe for SyncLazy<T, F> where SyncOnceCell<T>: UnwindSafe {}\n-\n-impl<T, F> SyncLazy<T, F> {\n-    /// Creates a new lazy value with the given initializing\n-    /// function.\n-    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n-    pub const fn new(f: F) -> SyncLazy<T, F> {\n-        SyncLazy { cell: SyncOnceCell::new(), init: Cell::new(Some(f)) }\n-    }\n-}\n-\n-impl<T, F: FnOnce() -> T> SyncLazy<T, F> {\n-    /// Forces the evaluation of this lazy value and\n-    /// returns a reference to result. This is equivalent\n-    /// to the `Deref` impl, but is explicit.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(once_cell)]\n-    ///\n-    /// use std::lazy::SyncLazy;\n-    ///\n-    /// let lazy = SyncLazy::new(|| 92);\n-    ///\n-    /// assert_eq!(SyncLazy::force(&lazy), &92);\n-    /// assert_eq!(&*lazy, &92);\n-    /// ```\n-    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n-    pub fn force(this: &SyncLazy<T, F>) -> &T {\n-        this.cell.get_or_init(|| match this.init.take() {\n-            Some(f) => f(),\n-            None => panic!(\"Lazy instance has previously been poisoned\"),\n-        })\n-    }\n-}\n-\n-#[unstable(feature = \"once_cell\", issue = \"74465\")]\n-impl<T, F: FnOnce() -> T> Deref for SyncLazy<T, F> {\n-    type Target = T;\n-    fn deref(&self) -> &T {\n-        SyncLazy::force(self)\n-    }\n-}\n-\n-#[unstable(feature = \"once_cell\", issue = \"74465\")]\n-impl<T: Default> Default for SyncLazy<T> {\n-    /// Creates a new lazy value using `Default` as the initializing function.\n-    fn default() -> SyncLazy<T> {\n-        SyncLazy::new(T::default)\n-    }\n-}"}, {"sha": "535cc1c42fcfda8d859603e0fd89aeddb69f6094", "filename": "library/std/src/sync/lazy_lock.rs", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/library%2Fstd%2Fsrc%2Fsync%2Flazy_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/library%2Fstd%2Fsrc%2Fsync%2Flazy_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Flazy_lock.rs?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -0,0 +1,121 @@\n+use crate::cell::Cell;\n+use crate::fmt;\n+use crate::ops::Deref;\n+use crate::panic::{RefUnwindSafe, UnwindSafe};\n+use crate::sync::OnceLock;\n+\n+/// A value which is initialized on the first access.\n+///\n+/// This type is a thread-safe `Lazy`, and can be used in statics.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(once_cell)]\n+///\n+/// use std::collections::HashMap;\n+///\n+/// use std::sync::LazyLock;\n+///\n+/// static HASHMAP: LazyLock<HashMap<i32, String>> = LazyLock::new(|| {\n+///     println!(\"initializing\");\n+///     let mut m = HashMap::new();\n+///     m.insert(13, \"Spica\".to_string());\n+///     m.insert(74, \"Hoyten\".to_string());\n+///     m\n+/// });\n+///\n+/// fn main() {\n+///     println!(\"ready\");\n+///     std::thread::spawn(|| {\n+///         println!(\"{:?}\", HASHMAP.get(&13));\n+///     }).join().unwrap();\n+///     println!(\"{:?}\", HASHMAP.get(&74));\n+///\n+///     // Prints:\n+///     //   ready\n+///     //   initializing\n+///     //   Some(\"Spica\")\n+///     //   Some(\"Hoyten\")\n+/// }\n+/// ```\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+pub struct LazyLock<T, F = fn() -> T> {\n+    cell: OnceLock<T>,\n+    init: Cell<Option<F>>,\n+}\n+\n+impl<T, F> LazyLock<T, F> {\n+    /// Creates a new lazy value with the given initializing\n+    /// function.\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub const fn new(f: F) -> LazyLock<T, F> {\n+        LazyLock { cell: OnceLock::new(), init: Cell::new(Some(f)) }\n+    }\n+}\n+\n+impl<T, F: FnOnce() -> T> LazyLock<T, F> {\n+    /// Forces the evaluation of this lazy value and\n+    /// returns a reference to result. This is equivalent\n+    /// to the `Deref` impl, but is explicit.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::sync::LazyLock;\n+    ///\n+    /// let lazy = LazyLock::new(|| 92);\n+    ///\n+    /// assert_eq!(LazyLock::force(&lazy), &92);\n+    /// assert_eq!(&*lazy, &92);\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn force(this: &LazyLock<T, F>) -> &T {\n+        this.cell.get_or_init(|| match this.init.take() {\n+            Some(f) => f(),\n+            None => panic!(\"Lazy instance has previously been poisoned\"),\n+        })\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T, F: FnOnce() -> T> Deref for LazyLock<T, F> {\n+    type Target = T;\n+    fn deref(&self) -> &T {\n+        LazyLock::force(self)\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: Default> Default for LazyLock<T> {\n+    /// Creates a new lazy value using `Default` as the initializing function.\n+    fn default() -> LazyLock<T> {\n+        LazyLock::new(T::default)\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: fmt::Debug, F> fmt::Debug for LazyLock<T, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Lazy\").field(\"cell\", &self.cell).finish_non_exhaustive()\n+    }\n+}\n+\n+// We never create a `&F` from a `&LazyLock<T, F>` so it is fine\n+// to not impl `Sync` for `F`\n+// we do create a `&mut Option<F>` in `force`, but this is\n+// properly synchronized, so it only happens once\n+// so it also does not contribute to this impl.\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+unsafe impl<T, F: Send> Sync for LazyLock<T, F> where OnceLock<T>: Sync {}\n+// auto-derived `Send` impl is OK.\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T, F: UnwindSafe> RefUnwindSafe for LazyLock<T, F> where OnceLock<T>: RefUnwindSafe {}\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T, F: UnwindSafe> UnwindSafe for LazyLock<T, F> where OnceLock<T>: UnwindSafe {}\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "f11b66bfca56a90f06993439862464d1ded29d4b", "filename": "library/std/src/sync/lazy_lock/tests.rs", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/library%2Fstd%2Fsrc%2Fsync%2Flazy_lock%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/library%2Fstd%2Fsrc%2Fsync%2Flazy_lock%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Flazy_lock%2Ftests.rs?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -0,0 +1,143 @@\n+use crate::{\n+    cell::LazyCell,\n+    panic,\n+    sync::{\n+        atomic::{AtomicUsize, Ordering::SeqCst},\n+        Mutex,\n+    },\n+    sync::{LazyLock, OnceLock},\n+    thread,\n+};\n+\n+fn spawn_and_wait<R: Send + 'static>(f: impl FnOnce() -> R + Send + 'static) -> R {\n+    thread::spawn(f).join().unwrap()\n+}\n+\n+#[test]\n+fn lazy_default() {\n+    static CALLED: AtomicUsize = AtomicUsize::new(0);\n+\n+    struct Foo(u8);\n+    impl Default for Foo {\n+        fn default() -> Self {\n+            CALLED.fetch_add(1, SeqCst);\n+            Foo(42)\n+        }\n+    }\n+\n+    let lazy: LazyCell<Mutex<Foo>> = <_>::default();\n+\n+    assert_eq!(CALLED.load(SeqCst), 0);\n+\n+    assert_eq!(lazy.lock().unwrap().0, 42);\n+    assert_eq!(CALLED.load(SeqCst), 1);\n+\n+    lazy.lock().unwrap().0 = 21;\n+\n+    assert_eq!(lazy.lock().unwrap().0, 21);\n+    assert_eq!(CALLED.load(SeqCst), 1);\n+}\n+\n+#[test]\n+fn lazy_poisoning() {\n+    let x: LazyCell<String> = LazyCell::new(|| panic!(\"kaboom\"));\n+    for _ in 0..2 {\n+        let res = panic::catch_unwind(panic::AssertUnwindSafe(|| x.len()));\n+        assert!(res.is_err());\n+    }\n+}\n+\n+#[test]\n+#[cfg_attr(target_os = \"emscripten\", ignore)]\n+fn sync_lazy_new() {\n+    static CALLED: AtomicUsize = AtomicUsize::new(0);\n+    static SYNC_LAZY: LazyLock<i32> = LazyLock::new(|| {\n+        CALLED.fetch_add(1, SeqCst);\n+        92\n+    });\n+\n+    assert_eq!(CALLED.load(SeqCst), 0);\n+\n+    spawn_and_wait(|| {\n+        let y = *SYNC_LAZY - 30;\n+        assert_eq!(y, 62);\n+        assert_eq!(CALLED.load(SeqCst), 1);\n+    });\n+\n+    let y = *SYNC_LAZY - 30;\n+    assert_eq!(y, 62);\n+    assert_eq!(CALLED.load(SeqCst), 1);\n+}\n+\n+#[test]\n+fn sync_lazy_default() {\n+    static CALLED: AtomicUsize = AtomicUsize::new(0);\n+\n+    struct Foo(u8);\n+    impl Default for Foo {\n+        fn default() -> Self {\n+            CALLED.fetch_add(1, SeqCst);\n+            Foo(42)\n+        }\n+    }\n+\n+    let lazy: LazyLock<Mutex<Foo>> = <_>::default();\n+\n+    assert_eq!(CALLED.load(SeqCst), 0);\n+\n+    assert_eq!(lazy.lock().unwrap().0, 42);\n+    assert_eq!(CALLED.load(SeqCst), 1);\n+\n+    lazy.lock().unwrap().0 = 21;\n+\n+    assert_eq!(lazy.lock().unwrap().0, 21);\n+    assert_eq!(CALLED.load(SeqCst), 1);\n+}\n+\n+#[test]\n+#[cfg_attr(target_os = \"emscripten\", ignore)]\n+fn static_sync_lazy() {\n+    static XS: LazyLock<Vec<i32>> = LazyLock::new(|| {\n+        let mut xs = Vec::new();\n+        xs.push(1);\n+        xs.push(2);\n+        xs.push(3);\n+        xs\n+    });\n+\n+    spawn_and_wait(|| {\n+        assert_eq!(&*XS, &vec![1, 2, 3]);\n+    });\n+\n+    assert_eq!(&*XS, &vec![1, 2, 3]);\n+}\n+\n+#[test]\n+fn static_sync_lazy_via_fn() {\n+    fn xs() -> &'static Vec<i32> {\n+        static XS: OnceLock<Vec<i32>> = OnceLock::new();\n+        XS.get_or_init(|| {\n+            let mut xs = Vec::new();\n+            xs.push(1);\n+            xs.push(2);\n+            xs.push(3);\n+            xs\n+        })\n+    }\n+    assert_eq!(xs(), &vec![1, 2, 3]);\n+}\n+\n+#[test]\n+fn sync_lazy_poisoning() {\n+    let x: LazyLock<String> = LazyLock::new(|| panic!(\"kaboom\"));\n+    for _ in 0..2 {\n+        let res = panic::catch_unwind(|| x.len());\n+        assert!(res.is_err());\n+    }\n+}\n+\n+#[test]\n+fn is_sync_send() {\n+    fn assert_traits<T: Send + Sync>() {}\n+    assert_traits::<LazyLock<String>>();\n+}"}, {"sha": "5fc18fda6a83b16a2b3557b025b7e717783abe77", "filename": "library/std/src/sync/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/library%2Fstd%2Fsrc%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/library%2Fstd%2Fsrc%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmod.rs?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -170,11 +170,18 @@ pub use self::poison::{LockResult, PoisonError, TryLockError, TryLockResult};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::rwlock::{RwLock, RwLockReadGuard, RwLockWriteGuard};\n \n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+pub use self::lazy_lock::LazyLock;\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+pub use self::once_lock::OnceLock;\n+\n pub mod mpsc;\n \n mod barrier;\n mod condvar;\n+mod lazy_lock;\n mod mutex;\n mod once;\n+mod once_lock;\n mod poison;\n mod rwlock;"}, {"sha": "813516040cdb6f7c274ec7d20f9b80b3391407bd", "filename": "library/std/src/sync/once_lock.rs", "status": "added", "additions": 496, "deletions": 0, "changes": 496, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/library%2Fstd%2Fsrc%2Fsync%2Fonce_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/library%2Fstd%2Fsrc%2Fsync%2Fonce_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fonce_lock.rs?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -0,0 +1,496 @@\n+use crate::cell::UnsafeCell;\n+use crate::fmt;\n+use crate::marker::PhantomData;\n+use crate::mem::MaybeUninit;\n+use crate::panic::{RefUnwindSafe, UnwindSafe};\n+use crate::pin::Pin;\n+use crate::sync::Once;\n+\n+/// A synchronization primitive which can be written to only once.\n+///\n+/// This type is a thread-safe `OnceCell`.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(once_cell)]\n+///\n+/// use std::sync::OnceLock;\n+///\n+/// static CELL: OnceLock<String> = OnceLock::new();\n+/// assert!(CELL.get().is_none());\n+///\n+/// std::thread::spawn(|| {\n+///     let value: &String = CELL.get_or_init(|| {\n+///         \"Hello, World!\".to_string()\n+///     });\n+///     assert_eq!(value, \"Hello, World!\");\n+/// }).join().unwrap();\n+///\n+/// let value: Option<&String> = CELL.get();\n+/// assert!(value.is_some());\n+/// assert_eq!(value.unwrap().as_str(), \"Hello, World!\");\n+/// ```\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+pub struct OnceLock<T> {\n+    once: Once,\n+    // Whether or not the value is initialized is tracked by `state_and_queue`.\n+    value: UnsafeCell<MaybeUninit<T>>,\n+    /// `PhantomData` to make sure dropck understands we're dropping T in our Drop impl.\n+    ///\n+    /// ```compile_fail,E0597\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::sync::OnceLock;\n+    ///\n+    /// struct A<'a>(&'a str);\n+    ///\n+    /// impl<'a> Drop for A<'a> {\n+    ///     fn drop(&mut self) {}\n+    /// }\n+    ///\n+    /// let cell = OnceLock::new();\n+    /// {\n+    ///     let s = String::new();\n+    ///     let _ = cell.set(A(&s));\n+    /// }\n+    /// ```\n+    _marker: PhantomData<T>,\n+}\n+\n+impl<T> OnceLock<T> {\n+    /// Creates a new empty cell.\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    #[must_use]\n+    pub const fn new() -> OnceLock<T> {\n+        OnceLock {\n+            once: Once::new(),\n+            value: UnsafeCell::new(MaybeUninit::uninit()),\n+            _marker: PhantomData,\n+        }\n+    }\n+\n+    /// Gets the reference to the underlying value.\n+    ///\n+    /// Returns `None` if the cell is empty, or being initialized. This\n+    /// method never blocks.\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn get(&self) -> Option<&T> {\n+        if self.is_initialized() {\n+            // Safe b/c checked is_initialized\n+            Some(unsafe { self.get_unchecked() })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Gets the mutable reference to the underlying value.\n+    ///\n+    /// Returns `None` if the cell is empty. This method never blocks.\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn get_mut(&mut self) -> Option<&mut T> {\n+        if self.is_initialized() {\n+            // Safe b/c checked is_initialized and we have a unique access\n+            Some(unsafe { self.get_unchecked_mut() })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Sets the contents of this cell to `value`.\n+    ///\n+    /// May block if another thread is currently attempting to initialize the cell. The cell is\n+    /// guaranteed to contain a value when set returns, though not necessarily the one provided.\n+    ///\n+    /// Returns `Ok(())` if the cell's value was set by this call.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::sync::OnceLock;\n+    ///\n+    /// static CELL: OnceLock<i32> = OnceLock::new();\n+    ///\n+    /// fn main() {\n+    ///     assert!(CELL.get().is_none());\n+    ///\n+    ///     std::thread::spawn(|| {\n+    ///         assert_eq!(CELL.set(92), Ok(()));\n+    ///     }).join().unwrap();\n+    ///\n+    ///     assert_eq!(CELL.set(62), Err(62));\n+    ///     assert_eq!(CELL.get(), Some(&92));\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn set(&self, value: T) -> Result<(), T> {\n+        let mut value = Some(value);\n+        self.get_or_init(|| value.take().unwrap());\n+        match value {\n+            None => Ok(()),\n+            Some(value) => Err(value),\n+        }\n+    }\n+\n+    /// Gets the contents of the cell, initializing it with `f` if the cell\n+    /// was empty.\n+    ///\n+    /// Many threads may call `get_or_init` concurrently with different\n+    /// initializing functions, but it is guaranteed that only one function\n+    /// will be executed.\n+    ///\n+    /// # Panics\n+    ///\n+    /// If `f` panics, the panic is propagated to the caller, and the cell\n+    /// remains uninitialized.\n+    ///\n+    /// It is an error to reentrantly initialize the cell from `f`. The\n+    /// exact outcome is unspecified. Current implementation deadlocks, but\n+    /// this may be changed to a panic in the future.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::sync::OnceLock;\n+    ///\n+    /// let cell = OnceLock::new();\n+    /// let value = cell.get_or_init(|| 92);\n+    /// assert_eq!(value, &92);\n+    /// let value = cell.get_or_init(|| unreachable!());\n+    /// assert_eq!(value, &92);\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn get_or_init<F>(&self, f: F) -> &T\n+    where\n+        F: FnOnce() -> T,\n+    {\n+        match self.get_or_try_init(|| Ok::<T, !>(f())) {\n+            Ok(val) => val,\n+        }\n+    }\n+\n+    /// Gets the contents of the cell, initializing it with `f` if\n+    /// the cell was empty. If the cell was empty and `f` failed, an\n+    /// error is returned.\n+    ///\n+    /// # Panics\n+    ///\n+    /// If `f` panics, the panic is propagated to the caller, and\n+    /// the cell remains uninitialized.\n+    ///\n+    /// It is an error to reentrantly initialize the cell from `f`.\n+    /// The exact outcome is unspecified. Current implementation\n+    /// deadlocks, but this may be changed to a panic in the future.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::sync::OnceLock;\n+    ///\n+    /// let cell = OnceLock::new();\n+    /// assert_eq!(cell.get_or_try_init(|| Err(())), Err(()));\n+    /// assert!(cell.get().is_none());\n+    /// let value = cell.get_or_try_init(|| -> Result<i32, ()> {\n+    ///     Ok(92)\n+    /// });\n+    /// assert_eq!(value, Ok(&92));\n+    /// assert_eq!(cell.get(), Some(&92))\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn get_or_try_init<F, E>(&self, f: F) -> Result<&T, E>\n+    where\n+        F: FnOnce() -> Result<T, E>,\n+    {\n+        // Fast path check\n+        // NOTE: We need to perform an acquire on the state in this method\n+        // in order to correctly synchronize `LazyLock::force`. This is\n+        // currently done by calling `self.get()`, which in turn calls\n+        // `self.is_initialized()`, which in turn performs the acquire.\n+        if let Some(value) = self.get() {\n+            return Ok(value);\n+        }\n+        self.initialize(f)?;\n+\n+        debug_assert!(self.is_initialized());\n+\n+        // SAFETY: The inner value has been initialized\n+        Ok(unsafe { self.get_unchecked() })\n+    }\n+\n+    /// Internal-only API that gets the contents of the cell, initializing it\n+    /// in two steps with `f` and `g` if the cell was empty.\n+    ///\n+    /// `f` is called to construct the value, which is then moved into the cell\n+    /// and given as a (pinned) mutable reference to `g` to finish\n+    /// initialization.\n+    ///\n+    /// This allows `g` to inspect an manipulate the value after it has been\n+    /// moved into its final place in the cell, but before the cell is\n+    /// considered initialized.\n+    ///\n+    /// # Panics\n+    ///\n+    /// If `f` or `g` panics, the panic is propagated to the caller, and the\n+    /// cell remains uninitialized.\n+    ///\n+    /// With the current implementation, if `g` panics, the value from `f` will\n+    /// not be dropped. This should probably be fixed if this is ever used for\n+    /// a type where this matters.\n+    ///\n+    /// It is an error to reentrantly initialize the cell from `f`. The exact\n+    /// outcome is unspecified. Current implementation deadlocks, but this may\n+    /// be changed to a panic in the future.\n+    pub(crate) fn get_or_init_pin<F, G>(self: Pin<&Self>, f: F, g: G) -> Pin<&T>\n+    where\n+        F: FnOnce() -> T,\n+        G: FnOnce(Pin<&mut T>),\n+    {\n+        if let Some(value) = self.get_ref().get() {\n+            // SAFETY: The inner value was already initialized, and will not be\n+            // moved anymore.\n+            return unsafe { Pin::new_unchecked(value) };\n+        }\n+\n+        let slot = &self.value;\n+\n+        // Ignore poisoning from other threads\n+        // If another thread panics, then we'll be able to run our closure\n+        self.once.call_once_force(|_| {\n+            let value = f();\n+            // SAFETY: We use the Once (self.once) to guarantee unique access\n+            // to the UnsafeCell (slot).\n+            let value: &mut T = unsafe { (&mut *slot.get()).write(value) };\n+            // SAFETY: The value has been written to its final place in\n+            // self.value. We do not to move it anymore, which we promise here\n+            // with a Pin<&mut T>.\n+            g(unsafe { Pin::new_unchecked(value) });\n+        });\n+\n+        // SAFETY: The inner value has been initialized, and will not be moved\n+        // anymore.\n+        unsafe { Pin::new_unchecked(self.get_ref().get_unchecked()) }\n+    }\n+\n+    /// Consumes the `OnceLock`, returning the wrapped value. Returns\n+    /// `None` if the cell was empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::sync::OnceLock;\n+    ///\n+    /// let cell: OnceLock<String> = OnceLock::new();\n+    /// assert_eq!(cell.into_inner(), None);\n+    ///\n+    /// let cell = OnceLock::new();\n+    /// cell.set(\"hello\".to_string()).unwrap();\n+    /// assert_eq!(cell.into_inner(), Some(\"hello\".to_string()));\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn into_inner(mut self) -> Option<T> {\n+        self.take()\n+    }\n+\n+    /// Takes the value out of this `OnceLock`, moving it back to an uninitialized state.\n+    ///\n+    /// Has no effect and returns `None` if the `OnceLock` hasn't been initialized.\n+    ///\n+    /// Safety is guaranteed by requiring a mutable reference.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::sync::OnceLock;\n+    ///\n+    /// let mut cell: OnceLock<String> = OnceLock::new();\n+    /// assert_eq!(cell.take(), None);\n+    ///\n+    /// let mut cell = OnceLock::new();\n+    /// cell.set(\"hello\".to_string()).unwrap();\n+    /// assert_eq!(cell.take(), Some(\"hello\".to_string()));\n+    /// assert_eq!(cell.get(), None);\n+    /// ```\n+    #[unstable(feature = \"once_cell\", issue = \"74465\")]\n+    pub fn take(&mut self) -> Option<T> {\n+        if self.is_initialized() {\n+            self.once = Once::new();\n+            // SAFETY: `self.value` is initialized and contains a valid `T`.\n+            // `self.once` is reset, so `is_initialized()` will be false again\n+            // which prevents the value from being read twice.\n+            unsafe { Some((&mut *self.value.get()).assume_init_read()) }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn is_initialized(&self) -> bool {\n+        self.once.is_completed()\n+    }\n+\n+    #[cold]\n+    fn initialize<F, E>(&self, f: F) -> Result<(), E>\n+    where\n+        F: FnOnce() -> Result<T, E>,\n+    {\n+        let mut res: Result<(), E> = Ok(());\n+        let slot = &self.value;\n+\n+        // Ignore poisoning from other threads\n+        // If another thread panics, then we'll be able to run our closure\n+        self.once.call_once_force(|p| {\n+            match f() {\n+                Ok(value) => {\n+                    unsafe { (&mut *slot.get()).write(value) };\n+                }\n+                Err(e) => {\n+                    res = Err(e);\n+\n+                    // Treat the underlying `Once` as poisoned since we\n+                    // failed to initialize our value. Calls\n+                    p.poison();\n+                }\n+            }\n+        });\n+        res\n+    }\n+\n+    /// # Safety\n+    ///\n+    /// The value must be initialized\n+    unsafe fn get_unchecked(&self) -> &T {\n+        debug_assert!(self.is_initialized());\n+        (&*self.value.get()).assume_init_ref()\n+    }\n+\n+    /// # Safety\n+    ///\n+    /// The value must be initialized\n+    unsafe fn get_unchecked_mut(&mut self) -> &mut T {\n+        debug_assert!(self.is_initialized());\n+        (&mut *self.value.get()).assume_init_mut()\n+    }\n+}\n+\n+// Why do we need `T: Send`?\n+// Thread A creates a `OnceLock` and shares it with\n+// scoped thread B, which fills the cell, which is\n+// then destroyed by A. That is, destructor observes\n+// a sent value.\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+unsafe impl<T: Sync + Send> Sync for OnceLock<T> {}\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+unsafe impl<T: Send> Send for OnceLock<T> {}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: RefUnwindSafe + UnwindSafe> RefUnwindSafe for OnceLock<T> {}\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: UnwindSafe> UnwindSafe for OnceLock<T> {}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+#[rustc_const_unstable(feature = \"const_default_impls\", issue = \"87864\")]\n+impl<T> const Default for OnceLock<T> {\n+    /// Creates a new empty cell.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::sync::OnceLock;\n+    ///\n+    /// fn main() {\n+    ///     assert_eq!(OnceLock::<()>::new(), OnceLock::default());\n+    /// }\n+    /// ```\n+    fn default() -> OnceLock<T> {\n+        OnceLock::new()\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: fmt::Debug> fmt::Debug for OnceLock<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self.get() {\n+            Some(v) => f.debug_tuple(\"Once\").field(v).finish(),\n+            None => f.write_str(\"Once(Uninit)\"),\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: Clone> Clone for OnceLock<T> {\n+    fn clone(&self) -> OnceLock<T> {\n+        let cell = Self::new();\n+        if let Some(value) = self.get() {\n+            match cell.set(value.clone()) {\n+                Ok(()) => (),\n+                Err(_) => unreachable!(),\n+            }\n+        }\n+        cell\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T> From<T> for OnceLock<T> {\n+    /// Create a new cell with its contents set to `value`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// #![feature(once_cell)]\n+    ///\n+    /// use std::sync::OnceLock;\n+    ///\n+    /// # fn main() -> Result<(), i32> {\n+    /// let a = OnceLock::from(3);\n+    /// let b = OnceLock::new();\n+    /// b.set(3)?;\n+    /// assert_eq!(a, b);\n+    /// Ok(())\n+    /// # }\n+    /// ```\n+    fn from(value: T) -> Self {\n+        let cell = Self::new();\n+        match cell.set(value) {\n+            Ok(()) => cell,\n+            Err(_) => unreachable!(),\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: PartialEq> PartialEq for OnceLock<T> {\n+    fn eq(&self, other: &OnceLock<T>) -> bool {\n+        self.get() == other.get()\n+    }\n+}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T: Eq> Eq for OnceLock<T> {}\n+\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+unsafe impl<#[may_dangle] T> Drop for OnceLock<T> {\n+    fn drop(&mut self) {\n+        if self.is_initialized() {\n+            // SAFETY: The cell is initialized and being dropped, so it can't\n+            // be accessed again. We also don't touch the `T` other than\n+            // dropping it, which validates our usage of #[may_dangle].\n+            unsafe { (&mut *self.value.get()).assume_init_drop() };\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests;"}, {"sha": "46695225b9f5a0766ce0daaa4286154c953bd8c7", "filename": "library/std/src/sync/once_lock/tests.rs", "status": "renamed", "additions": 20, "deletions": 145, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/library%2Fstd%2Fsrc%2Fsync%2Fonce_lock%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/library%2Fstd%2Fsrc%2Fsync%2Fonce_lock%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fonce_lock%2Ftests.rs?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -1,56 +1,21 @@\n use crate::{\n-    lazy::{Lazy, SyncLazy, SyncOnceCell},\n     panic,\n+    sync::OnceLock,\n     sync::{\n         atomic::{AtomicUsize, Ordering::SeqCst},\n         mpsc::channel,\n-        Mutex,\n     },\n     thread,\n };\n \n-#[test]\n-fn lazy_default() {\n-    static CALLED: AtomicUsize = AtomicUsize::new(0);\n-\n-    struct Foo(u8);\n-    impl Default for Foo {\n-        fn default() -> Self {\n-            CALLED.fetch_add(1, SeqCst);\n-            Foo(42)\n-        }\n-    }\n-\n-    let lazy: Lazy<Mutex<Foo>> = <_>::default();\n-\n-    assert_eq!(CALLED.load(SeqCst), 0);\n-\n-    assert_eq!(lazy.lock().unwrap().0, 42);\n-    assert_eq!(CALLED.load(SeqCst), 1);\n-\n-    lazy.lock().unwrap().0 = 21;\n-\n-    assert_eq!(lazy.lock().unwrap().0, 21);\n-    assert_eq!(CALLED.load(SeqCst), 1);\n-}\n-\n-#[test]\n-fn lazy_poisoning() {\n-    let x: Lazy<String> = Lazy::new(|| panic!(\"kaboom\"));\n-    for _ in 0..2 {\n-        let res = panic::catch_unwind(panic::AssertUnwindSafe(|| x.len()));\n-        assert!(res.is_err());\n-    }\n-}\n-\n fn spawn_and_wait<R: Send + 'static>(f: impl FnOnce() -> R + Send + 'static) -> R {\n     thread::spawn(f).join().unwrap()\n }\n \n #[test]\n #[cfg_attr(target_os = \"emscripten\", ignore)]\n fn sync_once_cell() {\n-    static ONCE_CELL: SyncOnceCell<i32> = SyncOnceCell::new();\n+    static ONCE_CELL: OnceLock<i32> = OnceLock::new();\n \n     assert!(ONCE_CELL.get().is_none());\n \n@@ -65,7 +30,7 @@ fn sync_once_cell() {\n \n #[test]\n fn sync_once_cell_get_mut() {\n-    let mut c = SyncOnceCell::new();\n+    let mut c = OnceLock::new();\n     assert!(c.get_mut().is_none());\n     c.set(90).unwrap();\n     *c.get_mut().unwrap() += 2;\n@@ -74,7 +39,7 @@ fn sync_once_cell_get_mut() {\n \n #[test]\n fn sync_once_cell_get_unchecked() {\n-    let c = SyncOnceCell::new();\n+    let c = OnceLock::new();\n     c.set(92).unwrap();\n     unsafe {\n         assert_eq!(c.get_unchecked(), &92);\n@@ -92,7 +57,7 @@ fn sync_once_cell_drop() {\n         }\n     }\n \n-    let x = SyncOnceCell::new();\n+    let x = OnceLock::new();\n     spawn_and_wait(move || {\n         x.get_or_init(|| Dropper);\n         assert_eq!(DROP_CNT.load(SeqCst), 0);\n@@ -104,13 +69,13 @@ fn sync_once_cell_drop() {\n \n #[test]\n fn sync_once_cell_drop_empty() {\n-    let x = SyncOnceCell::<String>::new();\n+    let x = OnceLock::<String>::new();\n     drop(x);\n }\n \n #[test]\n fn clone() {\n-    let s = SyncOnceCell::new();\n+    let s = OnceLock::new();\n     let c = s.clone();\n     assert!(c.get().is_none());\n \n@@ -121,7 +86,7 @@ fn clone() {\n \n #[test]\n fn get_or_try_init() {\n-    let cell: SyncOnceCell<String> = SyncOnceCell::new();\n+    let cell: OnceLock<String> = OnceLock::new();\n     assert!(cell.get().is_none());\n \n     let res = panic::catch_unwind(|| cell.get_or_try_init(|| -> Result<_, ()> { panic!() }));\n@@ -137,122 +102,32 @@ fn get_or_try_init() {\n \n #[test]\n fn from_impl() {\n-    assert_eq!(SyncOnceCell::from(\"value\").get(), Some(&\"value\"));\n-    assert_ne!(SyncOnceCell::from(\"foo\").get(), Some(&\"bar\"));\n+    assert_eq!(OnceLock::from(\"value\").get(), Some(&\"value\"));\n+    assert_ne!(OnceLock::from(\"foo\").get(), Some(&\"bar\"));\n }\n \n #[test]\n fn partialeq_impl() {\n-    assert!(SyncOnceCell::from(\"value\") == SyncOnceCell::from(\"value\"));\n-    assert!(SyncOnceCell::from(\"foo\") != SyncOnceCell::from(\"bar\"));\n+    assert!(OnceLock::from(\"value\") == OnceLock::from(\"value\"));\n+    assert!(OnceLock::from(\"foo\") != OnceLock::from(\"bar\"));\n \n-    assert!(SyncOnceCell::<String>::new() == SyncOnceCell::new());\n-    assert!(SyncOnceCell::<String>::new() != SyncOnceCell::from(\"value\".to_owned()));\n+    assert!(OnceLock::<String>::new() == OnceLock::new());\n+    assert!(OnceLock::<String>::new() != OnceLock::from(\"value\".to_owned()));\n }\n \n #[test]\n fn into_inner() {\n-    let cell: SyncOnceCell<String> = SyncOnceCell::new();\n+    let cell: OnceLock<String> = OnceLock::new();\n     assert_eq!(cell.into_inner(), None);\n-    let cell = SyncOnceCell::new();\n+    let cell = OnceLock::new();\n     cell.set(\"hello\".to_string()).unwrap();\n     assert_eq!(cell.into_inner(), Some(\"hello\".to_string()));\n }\n \n-#[test]\n-#[cfg_attr(target_os = \"emscripten\", ignore)]\n-fn sync_lazy_new() {\n-    static CALLED: AtomicUsize = AtomicUsize::new(0);\n-    static SYNC_LAZY: SyncLazy<i32> = SyncLazy::new(|| {\n-        CALLED.fetch_add(1, SeqCst);\n-        92\n-    });\n-\n-    assert_eq!(CALLED.load(SeqCst), 0);\n-\n-    spawn_and_wait(|| {\n-        let y = *SYNC_LAZY - 30;\n-        assert_eq!(y, 62);\n-        assert_eq!(CALLED.load(SeqCst), 1);\n-    });\n-\n-    let y = *SYNC_LAZY - 30;\n-    assert_eq!(y, 62);\n-    assert_eq!(CALLED.load(SeqCst), 1);\n-}\n-\n-#[test]\n-fn sync_lazy_default() {\n-    static CALLED: AtomicUsize = AtomicUsize::new(0);\n-\n-    struct Foo(u8);\n-    impl Default for Foo {\n-        fn default() -> Self {\n-            CALLED.fetch_add(1, SeqCst);\n-            Foo(42)\n-        }\n-    }\n-\n-    let lazy: SyncLazy<Mutex<Foo>> = <_>::default();\n-\n-    assert_eq!(CALLED.load(SeqCst), 0);\n-\n-    assert_eq!(lazy.lock().unwrap().0, 42);\n-    assert_eq!(CALLED.load(SeqCst), 1);\n-\n-    lazy.lock().unwrap().0 = 21;\n-\n-    assert_eq!(lazy.lock().unwrap().0, 21);\n-    assert_eq!(CALLED.load(SeqCst), 1);\n-}\n-\n-#[test]\n-#[cfg_attr(target_os = \"emscripten\", ignore)]\n-fn static_sync_lazy() {\n-    static XS: SyncLazy<Vec<i32>> = SyncLazy::new(|| {\n-        let mut xs = Vec::new();\n-        xs.push(1);\n-        xs.push(2);\n-        xs.push(3);\n-        xs\n-    });\n-\n-    spawn_and_wait(|| {\n-        assert_eq!(&*XS, &vec![1, 2, 3]);\n-    });\n-\n-    assert_eq!(&*XS, &vec![1, 2, 3]);\n-}\n-\n-#[test]\n-fn static_sync_lazy_via_fn() {\n-    fn xs() -> &'static Vec<i32> {\n-        static XS: SyncOnceCell<Vec<i32>> = SyncOnceCell::new();\n-        XS.get_or_init(|| {\n-            let mut xs = Vec::new();\n-            xs.push(1);\n-            xs.push(2);\n-            xs.push(3);\n-            xs\n-        })\n-    }\n-    assert_eq!(xs(), &vec![1, 2, 3]);\n-}\n-\n-#[test]\n-fn sync_lazy_poisoning() {\n-    let x: SyncLazy<String> = SyncLazy::new(|| panic!(\"kaboom\"));\n-    for _ in 0..2 {\n-        let res = panic::catch_unwind(|| x.len());\n-        assert!(res.is_err());\n-    }\n-}\n-\n #[test]\n fn is_sync_send() {\n     fn assert_traits<T: Send + Sync>() {}\n-    assert_traits::<SyncOnceCell<String>>();\n-    assert_traits::<SyncLazy<String>>();\n+    assert_traits::<OnceLock<String>>();\n }\n \n #[test]\n@@ -261,7 +136,7 @@ fn eval_once_macro() {\n         (|| -> $ty:ty {\n             $($body:tt)*\n         }) => {{\n-            static ONCE_CELL: SyncOnceCell<$ty> = SyncOnceCell::new();\n+            static ONCE_CELL: OnceLock<$ty> = OnceLock::new();\n             fn init() -> $ty {\n                 $($body)*\n             }\n@@ -285,7 +160,7 @@ fn eval_once_macro() {\n #[test]\n #[cfg_attr(target_os = \"emscripten\", ignore)]\n fn sync_once_cell_does_not_leak_partially_constructed_boxes() {\n-    static ONCE_CELL: SyncOnceCell<String> = SyncOnceCell::new();\n+    static ONCE_CELL: OnceLock<String> = OnceLock::new();\n \n     let n_readers = 10;\n     let n_writers = 3;\n@@ -320,7 +195,7 @@ fn sync_once_cell_does_not_leak_partially_constructed_boxes() {\n \n #[test]\n fn dropck() {\n-    let cell = SyncOnceCell::new();\n+    let cell = OnceLock::new();\n     {\n         let s = String::new();\n         cell.set(&s).unwrap();", "previous_filename": "library/std/src/lazy/tests.rs"}, {"sha": "d1e72cd54437c82eae56bbf52e6b9a16cf0f1c2a", "filename": "library/std/src/sys/windows/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -2,13 +2,13 @@\n \n use crate::cmp;\n use crate::io::{self, IoSlice, IoSliceMut, Read};\n-use crate::lazy::SyncOnceCell;\n use crate::mem;\n use crate::net::{Shutdown, SocketAddr};\n use crate::os::windows::io::{\n     AsRawSocket, AsSocket, BorrowedSocket, FromRawSocket, IntoRawSocket, OwnedSocket, RawSocket,\n };\n use crate::ptr;\n+use crate::sync::OnceLock;\n use crate::sys;\n use crate::sys::c;\n use crate::sys_common::net;\n@@ -29,7 +29,7 @@ pub mod netc {\n \n pub struct Socket(OwnedSocket);\n \n-static WSA_CLEANUP: SyncOnceCell<unsafe extern \"system\" fn() -> i32> = SyncOnceCell::new();\n+static WSA_CLEANUP: OnceLock<unsafe extern \"system\" fn() -> i32> = OnceLock::new();\n \n /// Checks whether the Windows socket interface has been started already, and\n /// if not, starts it."}, {"sha": "57248e3651ba2773806eddeb34e6b1abb939c9f2", "filename": "library/std/src/sys/windows/rand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Frand.rs?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -1,6 +1,6 @@\n use crate::io;\n-use crate::lazy;\n use crate::mem;\n+use crate::sync;\n use crate::sys::c;\n \n /// The kinds of HashMap RNG that may be available\n@@ -28,7 +28,7 @@ fn get_hashmap_rng() -> HashMapRng {\n     // Assume that if the preferred RNG is broken the first time we use it, it likely means\n     // that: the DLL has failed to load, there is no point to calling it over-and-over again,\n     // and we should cache the result\n-    static VALUE: lazy::SyncOnceCell<HashMapRng> = lazy::SyncOnceCell::new();\n+    static VALUE: sync::OnceLock<HashMapRng> = sync::OnceLock::new();\n     *VALUE.get_or_init(choose_hashmap_rng)\n }\n "}, {"sha": "905fa431d29d123f380522030b831875c25427b6", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -692,6 +692,7 @@ macro_rules! tool_extended {\n        stable = $stable:expr,\n        $(in_tree = $in_tree:expr,)?\n        $(submodule = $submodule:literal,)?\n+       $(tool_std = $tool_std:literal,)?\n        $extra_deps:block;)+) => {\n         $(\n             #[derive(Debug, Clone, Hash, PartialEq, Eq)]\n@@ -740,7 +741,7 @@ macro_rules! tool_extended {\n                     compiler: $sel.compiler,\n                     target: $sel.target,\n                     tool: $tool_name,\n-                    mode: Mode::ToolRustc,\n+                    mode: if false $(|| $tool_std)? { Mode::ToolStd } else { Mode::ToolRustc },\n                     path: $path,\n                     extra_features: $sel.extra_features,\n                     is_optional_tool: true,\n@@ -774,7 +775,10 @@ tool_extended!((self, builder),\n         });\n         self.extra_features.push(\"clippy\".to_owned());\n     };\n-    RustDemangler, rust_demangler, \"src/tools/rust-demangler\", \"rust-demangler\", stable=false, in_tree=true, {};\n+    // FIXME: tool_std is not quite right, we shouldn't allow nightly features.\n+    // But `builder.cargo` doesn't know how to handle ToolBootstrap in stages other than 0,\n+    // and this is close enough for now.\n+    RustDemangler, rust_demangler, \"src/tools/rust-demangler\", \"rust-demangler\", stable=false, in_tree=true, tool_std=true, {};\n     Rustfmt, rustfmt, \"src/tools/rustfmt\", \"rustfmt\", stable=true, in_tree=true, {};\n     RustAnalyzer, rust_analyzer, \"src/tools/rust-analyzer/crates/rust-analyzer\", \"rust-analyzer\", stable=false, submodule=\"rust-analyzer\", {};\n );"}, {"sha": "2762d5e8502b2cf373da340f7b5b27664e837e46", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -1,10 +1,10 @@\n use std::cell::RefCell;\n use std::default::Default;\n use std::hash::Hash;\n-use std::lazy::SyncOnceCell as OnceCell;\n use std::path::PathBuf;\n use std::rc::Rc;\n use std::sync::Arc;\n+use std::sync::OnceLock as OnceCell;\n use std::{cmp, fmt, iter};\n \n use arrayvec::ArrayVec;"}, {"sha": "51b245e36ba3b20de83143aa20344fc511b22a15", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -21,9 +21,9 @@ use rustc_span::symbol::sym;\n use rustc_span::{source_map, Span, Symbol};\n \n use std::cell::RefCell;\n-use std::lazy::SyncLazy;\n use std::mem;\n use std::rc::Rc;\n+use std::sync::LazyLock;\n \n use crate::clean::inline::build_external_trait;\n use crate::clean::{self, ItemId, TraitWithExtraInfo};\n@@ -293,8 +293,8 @@ pub(crate) fn create_config(\n             providers.typeck_item_bodies = |_, _| {};\n             // hack so that `used_trait_imports` won't try to call typeck\n             providers.used_trait_imports = |_, _| {\n-                static EMPTY_SET: SyncLazy<FxHashSet<LocalDefId>> =\n-                    SyncLazy::new(FxHashSet::default);\n+                static EMPTY_SET: LazyLock<FxHashSet<LocalDefId>> =\n+                    LazyLock::new(FxHashSet::default);\n                 &EMPTY_SET\n             };\n             // In case typeck does end up being called, don't ICE in case there were name resolution errors"}, {"sha": "9bddee199c7bf3331508baa5522ed940d8f38950", "filename": "src/librustdoc/html/render/write_shared.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -3,9 +3,9 @@ use std::fmt::Write;\n use std::fs::{self, File};\n use std::io::prelude::*;\n use std::io::{self, BufReader};\n-use std::lazy::SyncLazy as Lazy;\n use std::path::{Component, Path, PathBuf};\n use std::rc::Rc;\n+use std::sync::LazyLock as Lazy;\n \n use itertools::Itertools;\n use rustc_data_structures::flock;"}, {"sha": "2817a8fe144885755f411700ab39a08dd6126146", "filename": "src/librustdoc/html/static/.eslintrc.js", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/src%2Flibrustdoc%2Fhtml%2Fstatic%2F.eslintrc.js", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/src%2Flibrustdoc%2Fhtml%2Fstatic%2F.eslintrc.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2F.eslintrc.js?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -89,5 +89,7 @@ module.exports = {\n         \"no-multi-assign\": \"error\",\n         \"no-return-assign\": \"error\",\n         \"no-script-url\": \"error\",\n+        \"no-sequences\": \"error\",\n+        \"no-throw-literal\": \"error\",\n     }\n };"}, {"sha": "c0b274c0a3fd3c01c551038b28dc07d5e8ddc74d", "filename": "src/librustdoc/html/static/js/search.js", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -1333,10 +1333,7 @@ function initSearch(rawSearchIndex) {\n             if (searchWord.indexOf(elem.pathLast) > -1 ||\n                 row.normalizedName.indexOf(elem.pathLast) > -1\n             ) {\n-                // filter type: ... queries\n-                if (!results_others[fullId] !== undefined) {\n-                    index = row.normalizedName.indexOf(elem.pathLast);\n-                }\n+                index = row.normalizedName.indexOf(elem.pathLast);\n             }\n             lev = levenshtein(searchWord, elem.pathLast);\n             if (lev > 0 && elem.pathLast.length > 2 && searchWord.indexOf(elem.pathLast) > -1) {"}, {"sha": "240aec52cff020f94b8317fb158890c4029aee83", "filename": "src/librustdoc/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/src%2Flibrustdoc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/src%2Flibrustdoc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flint.rs?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -3,7 +3,7 @@ use rustc_lint::LintStore;\n use rustc_lint_defs::{declare_tool_lint, Lint, LintId};\n use rustc_session::{lint, Session};\n \n-use std::lazy::SyncLazy as Lazy;\n+use std::sync::LazyLock as Lazy;\n \n /// This function is used to setup the lint initialization. By default, in rustdoc, everything\n /// is \"allowed\". Depending if we run in test mode or not, we want some of them to be at their"}, {"sha": "392e26ea6ac4c3ebffe55c046aaf70365465f26d", "filename": "src/librustdoc/passes/bare_urls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/src%2Flibrustdoc%2Fpasses%2Fbare_urls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/src%2Flibrustdoc%2Fpasses%2Fbare_urls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fbare_urls.rs?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -9,16 +9,16 @@ use core::ops::Range;\n use pulldown_cmark::{Event, Parser, Tag};\n use regex::Regex;\n use rustc_errors::Applicability;\n-use std::lazy::SyncLazy;\n use std::mem;\n+use std::sync::LazyLock;\n \n pub(crate) const CHECK_BARE_URLS: Pass = Pass {\n     name: \"check-bare-urls\",\n     run: check_bare_urls,\n     description: \"detects URLs that are not hyperlinks\",\n };\n \n-static URL_REGEX: SyncLazy<Regex> = SyncLazy::new(|| {\n+static URL_REGEX: LazyLock<Regex> = LazyLock::new(|| {\n     Regex::new(concat!(\n         r\"https?://\",                          // url scheme\n         r\"([-a-zA-Z0-9@:%._\\+~#=]{2,256}\\.)+\", // one or more subdomains"}, {"sha": "26bc29216cf1a56207e9669bd491c67c2e4d60c7", "filename": "src/test/run-make/libtest-thread-limit/test.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/src%2Ftest%2Frun-make%2Flibtest-thread-limit%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/src%2Ftest%2Frun-make%2Flibtest-thread-limit%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flibtest-thread-limit%2Ftest.rs?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -1,8 +1,12 @@\n #![feature(once_cell)]\n \n-use std::{io::ErrorKind, lazy::SyncOnceCell, thread::{self, Builder, ThreadId}};\n+use std::{\n+    io::ErrorKind,\n+    sync::OnceLock,\n+    thread::{self, Builder, ThreadId},\n+};\n \n-static THREAD_ID: SyncOnceCell<ThreadId> = SyncOnceCell::new();\n+static THREAD_ID: OnceLock<ThreadId> = OnceLock::new();\n \n #[test]\n fn spawn_thread_would_block() {"}, {"sha": "8d42b0e8794ce3787c9f7d6d88b02ae80ebe8d19", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -1 +1 @@\n-Subproject commit 4d92f07f34ba7fb7d7f207564942508f46c225d3\n+Subproject commit 8d42b0e8794ce3787c9f7d6d88b02ae80ebe8d19"}, {"sha": "f5c51b9474fcd878cf631441cc03a194d239301b", "filename": "src/tools/clippy/clippy_dev/src/bless.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fbless.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fbless.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_dev%2Fsrc%2Fbless.rs?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -4,12 +4,12 @@\n use crate::cargo_clippy_path;\n use std::ffi::OsStr;\n use std::fs;\n-use std::lazy::SyncLazy;\n use std::path::{Path, PathBuf};\n+use std::sync::LazyLock;\n use walkdir::{DirEntry, WalkDir};\n \n-static CLIPPY_BUILD_TIME: SyncLazy<Option<std::time::SystemTime>> =\n-    SyncLazy::new(|| cargo_clippy_path().metadata().ok()?.modified().ok());\n+static CLIPPY_BUILD_TIME: LazyLock<Option<std::time::SystemTime>> =\n+    LazyLock::new(|| cargo_clippy_path().metadata().ok()?.modified().ok());\n \n /// # Panics\n ///"}, {"sha": "5106c39b5c6fca70687f31e2737e3f58d633bd8c", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -64,7 +64,7 @@ pub use self::hir_utils::{\n \n use std::collections::hash_map::Entry;\n use std::hash::BuildHasherDefault;\n-use std::lazy::SyncOnceCell;\n+use std::sync::OnceLock;\n use std::sync::{Mutex, MutexGuard};\n \n use if_chain::if_chain;\n@@ -2080,7 +2080,7 @@ pub fn is_hir_ty_cfg_dependant(cx: &LateContext<'_>, ty: &hir::Ty<'_>) -> bool {\n     false\n }\n \n-static TEST_ITEM_NAMES_CACHE: SyncOnceCell<Mutex<FxHashMap<LocalDefId, Vec<Symbol>>>> = SyncOnceCell::new();\n+static TEST_ITEM_NAMES_CACHE: OnceLock<Mutex<FxHashMap<LocalDefId, Vec<Symbol>>>> = OnceLock::new();\n \n fn with_test_item_names<'tcx>(tcx: TyCtxt<'tcx>, module: LocalDefId, f: impl Fn(&[Symbol]) -> bool) -> bool {\n     let cache = TEST_ITEM_NAMES_CACHE.get_or_init(|| Mutex::new(FxHashMap::default()));"}, {"sha": "67467f89b475fe4bda8d2e7be90dbf4b1cd84c10", "filename": "src/tools/clippy/src/driver.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -21,11 +21,11 @@ use rustc_tools_util::VersionInfo;\n \n use std::borrow::Cow;\n use std::env;\n-use std::lazy::SyncLazy;\n use std::ops::Deref;\n use std::panic;\n use std::path::{Path, PathBuf};\n use std::process::{exit, Command};\n+use std::sync::LazyLock;\n \n /// If a command-line option matches `find_arg`, then apply the predicate `pred` on its value. If\n /// true, then return it. The parameter is assumed to be either `--arg=value` or `--arg value`.\n@@ -152,7 +152,7 @@ You can use tool lints to allow or deny lints from your code, eg.:\n \n const BUG_REPORT_URL: &str = \"https://github.com/rust-lang/rust-clippy/issues/new\";\n \n-static ICE_HOOK: SyncLazy<Box<dyn Fn(&panic::PanicInfo<'_>) + Sync + Send + 'static>> = SyncLazy::new(|| {\n+static ICE_HOOK: LazyLock<Box<dyn Fn(&panic::PanicInfo<'_>) + Sync + Send + 'static>> = LazyLock::new(|| {\n     let hook = panic::take_hook();\n     panic::set_hook(Box::new(|info| report_clippy_ice(info, BUG_REPORT_URL)));\n     hook\n@@ -219,7 +219,7 @@ fn toolchain_path(home: Option<String>, toolchain: Option<String>) -> Option<Pat\n #[allow(clippy::too_many_lines)]\n pub fn main() {\n     rustc_driver::init_rustc_env_logger();\n-    SyncLazy::force(&ICE_HOOK);\n+    LazyLock::force(&ICE_HOOK);\n     exit(rustc_driver::catch_with_exit_code(move || {\n         let mut orig_args: Vec<String> = env::args().collect();\n "}, {"sha": "061cda7e01e5b800c34c8da98d8f20b4aac9e109", "filename": "src/tools/clippy/tests/compile-test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/src%2Ftools%2Fclippy%2Ftests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/src%2Ftools%2Fclippy%2Ftests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fcompile-test.rs?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -12,8 +12,8 @@ use std::env::{self, remove_var, set_var, var_os};\n use std::ffi::{OsStr, OsString};\n use std::fs;\n use std::io;\n-use std::lazy::SyncLazy;\n use std::path::{Path, PathBuf};\n+use std::sync::LazyLock;\n use test_utils::IS_RUSTC_TEST_SUITE;\n \n mod test_utils;\n@@ -69,7 +69,7 @@ extern crate tokio;\n /// dependencies must be added to Cargo.toml at the project root. Test\n /// dependencies that are not *directly* used by this test module require an\n /// `extern crate` declaration.\n-static EXTERN_FLAGS: SyncLazy<String> = SyncLazy::new(|| {\n+static EXTERN_FLAGS: LazyLock<String> = LazyLock::new(|| {\n     let current_exe_depinfo = {\n         let mut path = env::current_exe().unwrap();\n         path.set_extension(\"d\");"}, {"sha": "ea8c54e08b33806ca6bad8e4420618530d671632", "filename": "src/tools/clippy/tests/test_utils/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/src%2Ftools%2Fclippy%2Ftests%2Ftest_utils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/src%2Ftools%2Fclippy%2Ftests%2Ftest_utils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Ftest_utils%2Fmod.rs?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -1,9 +1,9 @@\n #![allow(dead_code)] // see https://github.com/rust-lang/rust/issues/46379\n \n-use std::lazy::SyncLazy;\n use std::path::PathBuf;\n+use std::sync::LazyLock;\n \n-pub static CARGO_CLIPPY_PATH: SyncLazy<PathBuf> = SyncLazy::new(|| {\n+pub static CARGO_CLIPPY_PATH: LazyLock<PathBuf> = LazyLock::new(|| {\n     let mut path = std::env::current_exe().unwrap();\n     assert!(path.pop()); // deps\n     path.set_file_name(\"cargo-clippy\");"}, {"sha": "40aa0e8f715af0191a37cd3f0c26f2ebd796d2ef", "filename": "src/tools/rustc-workspace-hack/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b98c08288528c243973a54934e4be75bcf20c31/src%2Ftools%2Frustc-workspace-hack%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3b98c08288528c243973a54934e4be75bcf20c31/src%2Ftools%2Frustc-workspace-hack%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustc-workspace-hack%2FCargo.toml?ref=3b98c08288528c243973a54934e4be75bcf20c31", "patch": "@@ -73,7 +73,7 @@ features = [\n [dependencies]\n bstr = { version = \"0.2.13\", features = [\"default\"] }\n byteorder = { version = \"1\", features = ['default', 'std'] }\n-clap = { version = \"3.1.1\", features = [\"lazy_static\", \"derive\", \"clap_derive\"]}\n+clap = { version = \"3.1.1\", features = [\"derive\", \"clap_derive\"]}\n curl-sys = { version = \"0.4.13\", features = [\"http2\", \"libnghttp2-sys\"], optional = true }\n crossbeam-utils = { version = \"0.8.0\", features = [\"nightly\"] }\n libc = { version = \"0.2.79\", features = [\"align\"] }"}]}