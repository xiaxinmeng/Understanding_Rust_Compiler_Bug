{"sha": "30f0ad159a0f260f54356385de63c171722adb72", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwZjBhZDE1OWEwZjI2MGY1NDM1NjM4NWRlNjNjMTcxNzIyYWRiNzI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-04-09T16:15:21Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-09T16:15:21Z"}, "message": "Merge #3915\n\n3915: Prettify generated code r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "f31bae40498218a51c368b0ae1c18018ac1d9565", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f31bae40498218a51c368b0ae1c18018ac1d9565"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30f0ad159a0f260f54356385de63c171722adb72", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJej0oZCRBK7hj4Ov3rIwAAdHIIAKvOviCn6BQCn1TUXxWXwZvw\nUwqryW0CBWJ8UO0UWT3UyJQJ0dxUJeuIB6w9tA5dsNzv2X6lSm2/n/Rv64Z/pKW2\nIywwAftYZ3zRWG95sBs1Nik7mV/u8Zco9ttmQWVY3R9vrG2oJKyJh25r6YmA2/cU\n8erWwSlGR39zvg7tOK/j7Wc8F7ERYvH+9r/11nTavqMdnvzRgWjOLavuTXWRzDVJ\n/2NQH6MjpLNb/Lh74kA0NE4Hlz9ZmiJTatTJbOmZQwzy7oTPVABK5XrpwXfOXLfY\nXBswed1NgHsbE3xzv0z1dzsO8SO/PZ83uszvsXkjll7UidS2gwAjzvKFQtY8Dwo=\n=HRLG\n-----END PGP SIGNATURE-----\n", "payload": "tree f31bae40498218a51c368b0ae1c18018ac1d9565\nparent d416d892fc149c226599d011063e6aaea61a5cc5\nparent 56c8581b901427ee3e63052c531f3ba3b1ec112d\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1586448921 +0000\ncommitter GitHub <noreply@github.com> 1586448921 +0000\n\nMerge #3915\n\n3915: Prettify generated code r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30f0ad159a0f260f54356385de63c171722adb72", "html_url": "https://github.com/rust-lang/rust/commit/30f0ad159a0f260f54356385de63c171722adb72", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30f0ad159a0f260f54356385de63c171722adb72/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d416d892fc149c226599d011063e6aaea61a5cc5", "url": "https://api.github.com/repos/rust-lang/rust/commits/d416d892fc149c226599d011063e6aaea61a5cc5", "html_url": "https://github.com/rust-lang/rust/commit/d416d892fc149c226599d011063e6aaea61a5cc5"}, {"sha": "56c8581b901427ee3e63052c531f3ba3b1ec112d", "url": "https://api.github.com/repos/rust-lang/rust/commits/56c8581b901427ee3e63052c531f3ba3b1ec112d", "html_url": "https://github.com/rust-lang/rust/commit/56c8581b901427ee3e63052c531f3ba3b1ec112d"}], "stats": {"total": 16900, "additions": 7154, "deletions": 9746}, "files": [{"sha": "a42eec91a9c20965dcb8955c8d37026a4068d547", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30f0ad159a0f260f54356385de63c171722adb72/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30f0ad159a0f260f54356385de63c171722adb72/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=30f0ad159a0f260f54356385de63c171722adb72", "patch": "@@ -21,7 +21,7 @@ pub use self::{\n         AttrKind, FieldKind, PathSegmentKind, SelfParamKind, SlicePatComponents, StructKind,\n         TypeBoundKind, VisibilityKind,\n     },\n-    generated::*,\n+    generated::{nodes::*, tokens::*},\n     tokens::*,\n     traits::*,\n };"}, {"sha": "f5199e09f21066cd1b0d38f49737bdfaac53d904", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 5, "deletions": 9624, "changes": 9629, "blob_url": "https://github.com/rust-lang/rust/blob/30f0ad159a0f260f54356385de63c171722adb72/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30f0ad159a0f260f54356385de63c171722adb72/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=30f0ad159a0f260f54356385de63c171722adb72"}, {"sha": "8b348ad6e1369ac18db51c3832573ad35c2e010e", "filename": "crates/ra_syntax/src/ast/generated/nodes.rs", "status": "added", "additions": 4177, "deletions": 0, "changes": 4177, "blob_url": "https://github.com/rust-lang/rust/blob/30f0ad159a0f260f54356385de63c171722adb72/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30f0ad159a0f260f54356385de63c171722adb72/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=30f0ad159a0f260f54356385de63c171722adb72"}, {"sha": "e64b8bce6a488ac8f59fac85d9faa33d7b283408", "filename": "crates/ra_syntax/src/ast/generated/tokens.rs", "status": "added", "additions": 2808, "deletions": 0, "changes": 2808, "blob_url": "https://github.com/rust-lang/rust/blob/30f0ad159a0f260f54356385de63c171722adb72/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Ftokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30f0ad159a0f260f54356385de63c171722adb72/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Ftokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated%2Ftokens.rs?ref=30f0ad159a0f260f54356385de63c171722adb72", "patch": "@@ -0,0 +1,2808 @@\n+//! Generated file, do not edit by hand, see `xtask/src/codegen`\n+\n+use crate::{\n+    ast::AstToken,\n+    SyntaxKind::{self, *},\n+    SyntaxToken,\n+};\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Semi {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Semi {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Semi {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == SEMI }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Comma {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Comma {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Comma {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == COMMA }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct LParen {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for LParen {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for LParen {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == L_PAREN }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct RParen {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for RParen {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for RParen {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == R_PAREN }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct LCurly {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for LCurly {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for LCurly {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == L_CURLY }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct RCurly {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for RCurly {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for RCurly {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == R_CURLY }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct LBrack {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for LBrack {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for LBrack {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == L_BRACK }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct RBrack {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for RBrack {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for RBrack {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == R_BRACK }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct LAngle {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for LAngle {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for LAngle {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == L_ANGLE }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct RAngle {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for RAngle {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for RAngle {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == R_ANGLE }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct At {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for At {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for At {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == AT }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Pound {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Pound {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Pound {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == POUND }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Tilde {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Tilde {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Tilde {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == TILDE }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Question {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Question {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Question {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == QUESTION }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Dollar {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Dollar {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Dollar {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == DOLLAR }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Amp {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Amp {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Amp {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == AMP }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Pipe {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Pipe {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Pipe {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == PIPE }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Plus {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Plus {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Plus {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == PLUS }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Star {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Star {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Star {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == STAR }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Slash {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Slash {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Slash {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == SLASH }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Caret {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Caret {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Caret {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == CARET }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Percent {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Percent {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Percent {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == PERCENT }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Underscore {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Underscore {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Underscore {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == UNDERSCORE }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Dot {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Dot {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Dot {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == DOT }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Dotdot {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Dotdot {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Dotdot {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == DOTDOT }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Dotdotdot {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Dotdotdot {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Dotdotdot {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == DOTDOTDOT }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Dotdoteq {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Dotdoteq {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Dotdoteq {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == DOTDOTEQ }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Colon {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Colon {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Colon {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == COLON }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Coloncolon {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Coloncolon {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Coloncolon {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == COLONCOLON }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Eq {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Eq {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Eq {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == EQ }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Eqeq {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Eqeq {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Eqeq {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == EQEQ }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct FatArrow {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for FatArrow {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for FatArrow {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == FAT_ARROW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Excl {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Excl {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Excl {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == EXCL }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Neq {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Neq {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Neq {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == NEQ }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Minus {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Minus {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Minus {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == MINUS }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct ThinArrow {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for ThinArrow {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for ThinArrow {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == THIN_ARROW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Lteq {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Lteq {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Lteq {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == LTEQ }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Gteq {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Gteq {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Gteq {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == GTEQ }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Pluseq {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Pluseq {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Pluseq {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == PLUSEQ }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Minuseq {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Minuseq {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Minuseq {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == MINUSEQ }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Pipeeq {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Pipeeq {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Pipeeq {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == PIPEEQ }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Ampeq {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Ampeq {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Ampeq {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == AMPEQ }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Careteq {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Careteq {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Careteq {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == CARETEQ }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Slasheq {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Slasheq {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Slasheq {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == SLASHEQ }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Stareq {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Stareq {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Stareq {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == STAREQ }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Percenteq {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Percenteq {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Percenteq {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == PERCENTEQ }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Ampamp {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Ampamp {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Ampamp {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == AMPAMP }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Pipepipe {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Pipepipe {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Pipepipe {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == PIPEPIPE }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Shl {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Shl {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Shl {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == SHL }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Shr {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Shr {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Shr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == SHR }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Shleq {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Shleq {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Shleq {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == SHLEQ }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Shreq {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Shreq {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Shreq {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == SHREQ }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct AsKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for AsKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for AsKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == AS_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct AsyncKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for AsyncKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for AsyncKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == ASYNC_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct AwaitKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for AwaitKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for AwaitKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == AWAIT_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct BoxKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for BoxKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for BoxKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == BOX_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct BreakKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for BreakKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for BreakKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == BREAK_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct ConstKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for ConstKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for ConstKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == CONST_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct ContinueKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for ContinueKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for ContinueKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == CONTINUE_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct CrateKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for CrateKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for CrateKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == CRATE_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct DynKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for DynKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for DynKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == DYN_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct ElseKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for ElseKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for ElseKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == ELSE_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct EnumKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for EnumKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for EnumKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == ENUM_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct ExternKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for ExternKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for ExternKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == EXTERN_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct FalseKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for FalseKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for FalseKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == FALSE_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct FnKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for FnKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for FnKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == FN_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct ForKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for ForKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for ForKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == FOR_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct IfKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for IfKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for IfKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == IF_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct ImplKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for ImplKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for ImplKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == IMPL_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct InKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for InKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for InKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == IN_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct LetKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for LetKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for LetKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == LET_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct LoopKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for LoopKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for LoopKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == LOOP_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct MacroKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for MacroKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for MacroKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == MACRO_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct MatchKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for MatchKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for MatchKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == MATCH_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct ModKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for ModKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for ModKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == MOD_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct MoveKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for MoveKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for MoveKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == MOVE_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct MutKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for MutKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for MutKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == MUT_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct PubKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for PubKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for PubKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == PUB_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct RefKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for RefKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for RefKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == REF_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct ReturnKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for ReturnKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for ReturnKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == RETURN_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct SelfKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for SelfKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for SelfKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == SELF_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct StaticKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for StaticKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for StaticKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == STATIC_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct StructKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for StructKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for StructKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == STRUCT_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct SuperKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for SuperKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for SuperKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == SUPER_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct TraitKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for TraitKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for TraitKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == TRAIT_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct TrueKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for TrueKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for TrueKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == TRUE_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct TryKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for TryKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for TryKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == TRY_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct TypeKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for TypeKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for TypeKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct UnsafeKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for UnsafeKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for UnsafeKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == UNSAFE_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct UseKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for UseKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for UseKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == USE_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct WhereKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for WhereKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for WhereKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == WHERE_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct WhileKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for WhileKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for WhileKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == WHILE_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct AutoKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for AutoKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for AutoKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == AUTO_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct DefaultKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for DefaultKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for DefaultKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == DEFAULT_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct ExistentialKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for ExistentialKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for ExistentialKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == EXISTENTIAL_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct UnionKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for UnionKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for UnionKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == UNION_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct RawKw {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for RawKw {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for RawKw {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == RAW_KW }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct IntNumber {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for IntNumber {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for IntNumber {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == INT_NUMBER }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct FloatNumber {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for FloatNumber {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for FloatNumber {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == FLOAT_NUMBER }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Char {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Char {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Char {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == CHAR }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Byte {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Byte {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Byte {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == BYTE }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct String {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for String {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for String {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == STRING }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct RawString {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for RawString {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for RawString {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == RAW_STRING }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct ByteString {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for ByteString {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for ByteString {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == BYTE_STRING }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct RawByteString {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for RawByteString {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for RawByteString {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == RAW_BYTE_STRING }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Error {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Error {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Error {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == ERROR }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Ident {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Ident {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Ident {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == IDENT }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Whitespace {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Whitespace {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Whitespace {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == WHITESPACE }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Lifetime {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Lifetime {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Lifetime {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == LIFETIME }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Comment {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Comment {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Comment {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == COMMENT }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct Shebang {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for Shebang {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for Shebang {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == SHEBANG }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct LDollar {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for LDollar {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for LDollar {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == L_DOLLAR }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct RDollar {\n+    pub(crate) syntax: SyntaxToken,\n+}\n+impl std::fmt::Display for RDollar {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(&self.syntax, f)\n+    }\n+}\n+impl AstToken for RDollar {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == R_DOLLAR }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum LeftDelimiter {\n+    LParen(LParen),\n+    LBrack(LBrack),\n+    LCurly(LCurly),\n+}\n+impl From<LParen> for LeftDelimiter {\n+    fn from(node: LParen) -> LeftDelimiter { LeftDelimiter::LParen(node) }\n+}\n+impl From<LBrack> for LeftDelimiter {\n+    fn from(node: LBrack) -> LeftDelimiter { LeftDelimiter::LBrack(node) }\n+}\n+impl From<LCurly> for LeftDelimiter {\n+    fn from(node: LCurly) -> LeftDelimiter { LeftDelimiter::LCurly(node) }\n+}\n+impl std::fmt::Display for LeftDelimiter {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl AstToken for LeftDelimiter {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            L_PAREN | L_BRACK | L_CURLY => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            L_PAREN => LeftDelimiter::LParen(LParen { syntax }),\n+            L_BRACK => LeftDelimiter::LBrack(LBrack { syntax }),\n+            L_CURLY => LeftDelimiter::LCurly(LCurly { syntax }),\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxToken {\n+        match self {\n+            LeftDelimiter::LParen(it) => &it.syntax,\n+            LeftDelimiter::LBrack(it) => &it.syntax,\n+            LeftDelimiter::LCurly(it) => &it.syntax,\n+        }\n+    }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum RightDelimiter {\n+    RParen(RParen),\n+    RBrack(RBrack),\n+    RCurly(RCurly),\n+}\n+impl From<RParen> for RightDelimiter {\n+    fn from(node: RParen) -> RightDelimiter { RightDelimiter::RParen(node) }\n+}\n+impl From<RBrack> for RightDelimiter {\n+    fn from(node: RBrack) -> RightDelimiter { RightDelimiter::RBrack(node) }\n+}\n+impl From<RCurly> for RightDelimiter {\n+    fn from(node: RCurly) -> RightDelimiter { RightDelimiter::RCurly(node) }\n+}\n+impl std::fmt::Display for RightDelimiter {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl AstToken for RightDelimiter {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            R_PAREN | R_BRACK | R_CURLY => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            R_PAREN => RightDelimiter::RParen(RParen { syntax }),\n+            R_BRACK => RightDelimiter::RBrack(RBrack { syntax }),\n+            R_CURLY => RightDelimiter::RCurly(RCurly { syntax }),\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxToken {\n+        match self {\n+            RightDelimiter::RParen(it) => &it.syntax,\n+            RightDelimiter::RBrack(it) => &it.syntax,\n+            RightDelimiter::RCurly(it) => &it.syntax,\n+        }\n+    }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum RangeSeparator {\n+    Dotdot(Dotdot),\n+    Dotdotdot(Dotdotdot),\n+    Dotdoteq(Dotdoteq),\n+}\n+impl From<Dotdot> for RangeSeparator {\n+    fn from(node: Dotdot) -> RangeSeparator { RangeSeparator::Dotdot(node) }\n+}\n+impl From<Dotdotdot> for RangeSeparator {\n+    fn from(node: Dotdotdot) -> RangeSeparator { RangeSeparator::Dotdotdot(node) }\n+}\n+impl From<Dotdoteq> for RangeSeparator {\n+    fn from(node: Dotdoteq) -> RangeSeparator { RangeSeparator::Dotdoteq(node) }\n+}\n+impl std::fmt::Display for RangeSeparator {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl AstToken for RangeSeparator {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            DOTDOT | DOTDOTDOT | DOTDOTEQ => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            DOTDOT => RangeSeparator::Dotdot(Dotdot { syntax }),\n+            DOTDOTDOT => RangeSeparator::Dotdotdot(Dotdotdot { syntax }),\n+            DOTDOTEQ => RangeSeparator::Dotdoteq(Dotdoteq { syntax }),\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxToken {\n+        match self {\n+            RangeSeparator::Dotdot(it) => &it.syntax,\n+            RangeSeparator::Dotdotdot(it) => &it.syntax,\n+            RangeSeparator::Dotdoteq(it) => &it.syntax,\n+        }\n+    }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum BinOp {\n+    Pipepipe(Pipepipe),\n+    Ampamp(Ampamp),\n+    Eqeq(Eqeq),\n+    Neq(Neq),\n+    Lteq(Lteq),\n+    Gteq(Gteq),\n+    LAngle(LAngle),\n+    RAngle(RAngle),\n+    Plus(Plus),\n+    Star(Star),\n+    Minus(Minus),\n+    Slash(Slash),\n+    Percent(Percent),\n+    Shl(Shl),\n+    Shr(Shr),\n+    Caret(Caret),\n+    Pipe(Pipe),\n+    Amp(Amp),\n+    Eq(Eq),\n+    Pluseq(Pluseq),\n+    Slasheq(Slasheq),\n+    Stareq(Stareq),\n+    Percenteq(Percenteq),\n+    Shreq(Shreq),\n+    Shleq(Shleq),\n+    Minuseq(Minuseq),\n+    Pipeeq(Pipeeq),\n+    Ampeq(Ampeq),\n+    Careteq(Careteq),\n+}\n+impl From<Pipepipe> for BinOp {\n+    fn from(node: Pipepipe) -> BinOp { BinOp::Pipepipe(node) }\n+}\n+impl From<Ampamp> for BinOp {\n+    fn from(node: Ampamp) -> BinOp { BinOp::Ampamp(node) }\n+}\n+impl From<Eqeq> for BinOp {\n+    fn from(node: Eqeq) -> BinOp { BinOp::Eqeq(node) }\n+}\n+impl From<Neq> for BinOp {\n+    fn from(node: Neq) -> BinOp { BinOp::Neq(node) }\n+}\n+impl From<Lteq> for BinOp {\n+    fn from(node: Lteq) -> BinOp { BinOp::Lteq(node) }\n+}\n+impl From<Gteq> for BinOp {\n+    fn from(node: Gteq) -> BinOp { BinOp::Gteq(node) }\n+}\n+impl From<LAngle> for BinOp {\n+    fn from(node: LAngle) -> BinOp { BinOp::LAngle(node) }\n+}\n+impl From<RAngle> for BinOp {\n+    fn from(node: RAngle) -> BinOp { BinOp::RAngle(node) }\n+}\n+impl From<Plus> for BinOp {\n+    fn from(node: Plus) -> BinOp { BinOp::Plus(node) }\n+}\n+impl From<Star> for BinOp {\n+    fn from(node: Star) -> BinOp { BinOp::Star(node) }\n+}\n+impl From<Minus> for BinOp {\n+    fn from(node: Minus) -> BinOp { BinOp::Minus(node) }\n+}\n+impl From<Slash> for BinOp {\n+    fn from(node: Slash) -> BinOp { BinOp::Slash(node) }\n+}\n+impl From<Percent> for BinOp {\n+    fn from(node: Percent) -> BinOp { BinOp::Percent(node) }\n+}\n+impl From<Shl> for BinOp {\n+    fn from(node: Shl) -> BinOp { BinOp::Shl(node) }\n+}\n+impl From<Shr> for BinOp {\n+    fn from(node: Shr) -> BinOp { BinOp::Shr(node) }\n+}\n+impl From<Caret> for BinOp {\n+    fn from(node: Caret) -> BinOp { BinOp::Caret(node) }\n+}\n+impl From<Pipe> for BinOp {\n+    fn from(node: Pipe) -> BinOp { BinOp::Pipe(node) }\n+}\n+impl From<Amp> for BinOp {\n+    fn from(node: Amp) -> BinOp { BinOp::Amp(node) }\n+}\n+impl From<Eq> for BinOp {\n+    fn from(node: Eq) -> BinOp { BinOp::Eq(node) }\n+}\n+impl From<Pluseq> for BinOp {\n+    fn from(node: Pluseq) -> BinOp { BinOp::Pluseq(node) }\n+}\n+impl From<Slasheq> for BinOp {\n+    fn from(node: Slasheq) -> BinOp { BinOp::Slasheq(node) }\n+}\n+impl From<Stareq> for BinOp {\n+    fn from(node: Stareq) -> BinOp { BinOp::Stareq(node) }\n+}\n+impl From<Percenteq> for BinOp {\n+    fn from(node: Percenteq) -> BinOp { BinOp::Percenteq(node) }\n+}\n+impl From<Shreq> for BinOp {\n+    fn from(node: Shreq) -> BinOp { BinOp::Shreq(node) }\n+}\n+impl From<Shleq> for BinOp {\n+    fn from(node: Shleq) -> BinOp { BinOp::Shleq(node) }\n+}\n+impl From<Minuseq> for BinOp {\n+    fn from(node: Minuseq) -> BinOp { BinOp::Minuseq(node) }\n+}\n+impl From<Pipeeq> for BinOp {\n+    fn from(node: Pipeeq) -> BinOp { BinOp::Pipeeq(node) }\n+}\n+impl From<Ampeq> for BinOp {\n+    fn from(node: Ampeq) -> BinOp { BinOp::Ampeq(node) }\n+}\n+impl From<Careteq> for BinOp {\n+    fn from(node: Careteq) -> BinOp { BinOp::Careteq(node) }\n+}\n+impl std::fmt::Display for BinOp {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl AstToken for BinOp {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            PIPEPIPE | AMPAMP | EQEQ | NEQ | LTEQ | GTEQ | L_ANGLE | R_ANGLE | PLUS | STAR\n+            | MINUS | SLASH | PERCENT | SHL | SHR | CARET | PIPE | AMP | EQ | PLUSEQ | SLASHEQ\n+            | STAREQ | PERCENTEQ | SHREQ | SHLEQ | MINUSEQ | PIPEEQ | AMPEQ | CARETEQ => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            PIPEPIPE => BinOp::Pipepipe(Pipepipe { syntax }),\n+            AMPAMP => BinOp::Ampamp(Ampamp { syntax }),\n+            EQEQ => BinOp::Eqeq(Eqeq { syntax }),\n+            NEQ => BinOp::Neq(Neq { syntax }),\n+            LTEQ => BinOp::Lteq(Lteq { syntax }),\n+            GTEQ => BinOp::Gteq(Gteq { syntax }),\n+            L_ANGLE => BinOp::LAngle(LAngle { syntax }),\n+            R_ANGLE => BinOp::RAngle(RAngle { syntax }),\n+            PLUS => BinOp::Plus(Plus { syntax }),\n+            STAR => BinOp::Star(Star { syntax }),\n+            MINUS => BinOp::Minus(Minus { syntax }),\n+            SLASH => BinOp::Slash(Slash { syntax }),\n+            PERCENT => BinOp::Percent(Percent { syntax }),\n+            SHL => BinOp::Shl(Shl { syntax }),\n+            SHR => BinOp::Shr(Shr { syntax }),\n+            CARET => BinOp::Caret(Caret { syntax }),\n+            PIPE => BinOp::Pipe(Pipe { syntax }),\n+            AMP => BinOp::Amp(Amp { syntax }),\n+            EQ => BinOp::Eq(Eq { syntax }),\n+            PLUSEQ => BinOp::Pluseq(Pluseq { syntax }),\n+            SLASHEQ => BinOp::Slasheq(Slasheq { syntax }),\n+            STAREQ => BinOp::Stareq(Stareq { syntax }),\n+            PERCENTEQ => BinOp::Percenteq(Percenteq { syntax }),\n+            SHREQ => BinOp::Shreq(Shreq { syntax }),\n+            SHLEQ => BinOp::Shleq(Shleq { syntax }),\n+            MINUSEQ => BinOp::Minuseq(Minuseq { syntax }),\n+            PIPEEQ => BinOp::Pipeeq(Pipeeq { syntax }),\n+            AMPEQ => BinOp::Ampeq(Ampeq { syntax }),\n+            CARETEQ => BinOp::Careteq(Careteq { syntax }),\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxToken {\n+        match self {\n+            BinOp::Pipepipe(it) => &it.syntax,\n+            BinOp::Ampamp(it) => &it.syntax,\n+            BinOp::Eqeq(it) => &it.syntax,\n+            BinOp::Neq(it) => &it.syntax,\n+            BinOp::Lteq(it) => &it.syntax,\n+            BinOp::Gteq(it) => &it.syntax,\n+            BinOp::LAngle(it) => &it.syntax,\n+            BinOp::RAngle(it) => &it.syntax,\n+            BinOp::Plus(it) => &it.syntax,\n+            BinOp::Star(it) => &it.syntax,\n+            BinOp::Minus(it) => &it.syntax,\n+            BinOp::Slash(it) => &it.syntax,\n+            BinOp::Percent(it) => &it.syntax,\n+            BinOp::Shl(it) => &it.syntax,\n+            BinOp::Shr(it) => &it.syntax,\n+            BinOp::Caret(it) => &it.syntax,\n+            BinOp::Pipe(it) => &it.syntax,\n+            BinOp::Amp(it) => &it.syntax,\n+            BinOp::Eq(it) => &it.syntax,\n+            BinOp::Pluseq(it) => &it.syntax,\n+            BinOp::Slasheq(it) => &it.syntax,\n+            BinOp::Stareq(it) => &it.syntax,\n+            BinOp::Percenteq(it) => &it.syntax,\n+            BinOp::Shreq(it) => &it.syntax,\n+            BinOp::Shleq(it) => &it.syntax,\n+            BinOp::Minuseq(it) => &it.syntax,\n+            BinOp::Pipeeq(it) => &it.syntax,\n+            BinOp::Ampeq(it) => &it.syntax,\n+            BinOp::Careteq(it) => &it.syntax,\n+        }\n+    }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum PrefixOp {\n+    Minus(Minus),\n+    Excl(Excl),\n+    Star(Star),\n+}\n+impl From<Minus> for PrefixOp {\n+    fn from(node: Minus) -> PrefixOp { PrefixOp::Minus(node) }\n+}\n+impl From<Excl> for PrefixOp {\n+    fn from(node: Excl) -> PrefixOp { PrefixOp::Excl(node) }\n+}\n+impl From<Star> for PrefixOp {\n+    fn from(node: Star) -> PrefixOp { PrefixOp::Star(node) }\n+}\n+impl std::fmt::Display for PrefixOp {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl AstToken for PrefixOp {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            MINUS | EXCL | STAR => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            MINUS => PrefixOp::Minus(Minus { syntax }),\n+            EXCL => PrefixOp::Excl(Excl { syntax }),\n+            STAR => PrefixOp::Star(Star { syntax }),\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxToken {\n+        match self {\n+            PrefixOp::Minus(it) => &it.syntax,\n+            PrefixOp::Excl(it) => &it.syntax,\n+            PrefixOp::Star(it) => &it.syntax,\n+        }\n+    }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum RangeOp {\n+    Dotdot(Dotdot),\n+    Dotdoteq(Dotdoteq),\n+}\n+impl From<Dotdot> for RangeOp {\n+    fn from(node: Dotdot) -> RangeOp { RangeOp::Dotdot(node) }\n+}\n+impl From<Dotdoteq> for RangeOp {\n+    fn from(node: Dotdoteq) -> RangeOp { RangeOp::Dotdoteq(node) }\n+}\n+impl std::fmt::Display for RangeOp {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl AstToken for RangeOp {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            DOTDOT | DOTDOTEQ => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            DOTDOT => RangeOp::Dotdot(Dotdot { syntax }),\n+            DOTDOTEQ => RangeOp::Dotdoteq(Dotdoteq { syntax }),\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxToken {\n+        match self {\n+            RangeOp::Dotdot(it) => &it.syntax,\n+            RangeOp::Dotdoteq(it) => &it.syntax,\n+        }\n+    }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum LiteralToken {\n+    IntNumber(IntNumber),\n+    FloatNumber(FloatNumber),\n+    String(String),\n+    RawString(RawString),\n+    TrueKw(TrueKw),\n+    FalseKw(FalseKw),\n+    ByteString(ByteString),\n+    RawByteString(RawByteString),\n+    Char(Char),\n+    Byte(Byte),\n+}\n+impl From<IntNumber> for LiteralToken {\n+    fn from(node: IntNumber) -> LiteralToken { LiteralToken::IntNumber(node) }\n+}\n+impl From<FloatNumber> for LiteralToken {\n+    fn from(node: FloatNumber) -> LiteralToken { LiteralToken::FloatNumber(node) }\n+}\n+impl From<String> for LiteralToken {\n+    fn from(node: String) -> LiteralToken { LiteralToken::String(node) }\n+}\n+impl From<RawString> for LiteralToken {\n+    fn from(node: RawString) -> LiteralToken { LiteralToken::RawString(node) }\n+}\n+impl From<TrueKw> for LiteralToken {\n+    fn from(node: TrueKw) -> LiteralToken { LiteralToken::TrueKw(node) }\n+}\n+impl From<FalseKw> for LiteralToken {\n+    fn from(node: FalseKw) -> LiteralToken { LiteralToken::FalseKw(node) }\n+}\n+impl From<ByteString> for LiteralToken {\n+    fn from(node: ByteString) -> LiteralToken { LiteralToken::ByteString(node) }\n+}\n+impl From<RawByteString> for LiteralToken {\n+    fn from(node: RawByteString) -> LiteralToken { LiteralToken::RawByteString(node) }\n+}\n+impl From<Char> for LiteralToken {\n+    fn from(node: Char) -> LiteralToken { LiteralToken::Char(node) }\n+}\n+impl From<Byte> for LiteralToken {\n+    fn from(node: Byte) -> LiteralToken { LiteralToken::Byte(node) }\n+}\n+impl std::fmt::Display for LiteralToken {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl AstToken for LiteralToken {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            INT_NUMBER | FLOAT_NUMBER | STRING | RAW_STRING | TRUE_KW | FALSE_KW | BYTE_STRING\n+            | RAW_BYTE_STRING | CHAR | BYTE => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            INT_NUMBER => LiteralToken::IntNumber(IntNumber { syntax }),\n+            FLOAT_NUMBER => LiteralToken::FloatNumber(FloatNumber { syntax }),\n+            STRING => LiteralToken::String(String { syntax }),\n+            RAW_STRING => LiteralToken::RawString(RawString { syntax }),\n+            TRUE_KW => LiteralToken::TrueKw(TrueKw { syntax }),\n+            FALSE_KW => LiteralToken::FalseKw(FalseKw { syntax }),\n+            BYTE_STRING => LiteralToken::ByteString(ByteString { syntax }),\n+            RAW_BYTE_STRING => LiteralToken::RawByteString(RawByteString { syntax }),\n+            CHAR => LiteralToken::Char(Char { syntax }),\n+            BYTE => LiteralToken::Byte(Byte { syntax }),\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxToken {\n+        match self {\n+            LiteralToken::IntNumber(it) => &it.syntax,\n+            LiteralToken::FloatNumber(it) => &it.syntax,\n+            LiteralToken::String(it) => &it.syntax,\n+            LiteralToken::RawString(it) => &it.syntax,\n+            LiteralToken::TrueKw(it) => &it.syntax,\n+            LiteralToken::FalseKw(it) => &it.syntax,\n+            LiteralToken::ByteString(it) => &it.syntax,\n+            LiteralToken::RawByteString(it) => &it.syntax,\n+            LiteralToken::Char(it) => &it.syntax,\n+            LiteralToken::Byte(it) => &it.syntax,\n+        }\n+    }\n+}\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum NameRefToken {\n+    Ident(Ident),\n+    IntNumber(IntNumber),\n+}\n+impl From<Ident> for NameRefToken {\n+    fn from(node: Ident) -> NameRefToken { NameRefToken::Ident(node) }\n+}\n+impl From<IntNumber> for NameRefToken {\n+    fn from(node: IntNumber) -> NameRefToken { NameRefToken::IntNumber(node) }\n+}\n+impl std::fmt::Display for NameRefToken {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n+impl AstToken for NameRefToken {\n+    fn can_cast(kind: SyntaxKind) -> bool {\n+        match kind {\n+            IDENT | INT_NUMBER => true,\n+            _ => false,\n+        }\n+    }\n+    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+        let res = match syntax.kind() {\n+            IDENT => NameRefToken::Ident(Ident { syntax }),\n+            INT_NUMBER => NameRefToken::IntNumber(IntNumber { syntax }),\n+            _ => return None,\n+        };\n+        Some(res)\n+    }\n+    fn syntax(&self) -> &SyntaxToken {\n+        match self {\n+            NameRefToken::Ident(it) => &it.syntax,\n+            NameRefToken::IntNumber(it) => &it.syntax,\n+        }\n+    }\n+}"}, {"sha": "eba66ff4d90ff6052924769a9d6fa12d7a67a1b0", "filename": "xtask/src/ast_src.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/30f0ad159a0f260f54356385de63c171722adb72/xtask%2Fsrc%2Fast_src.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30f0ad159a0f260f54356385de63c171722adb72/xtask%2Fsrc%2Fast_src.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fast_src.rs?ref=30f0ad159a0f260f54356385de63c171722adb72", "patch": "@@ -227,6 +227,7 @@ pub(crate) const KINDS_SRC: KindsSrc = KindsSrc {\n pub(crate) struct AstSrc<'a> {\n     pub(crate) nodes: &'a [AstNodeSrc<'a>],\n     pub(crate) enums: &'a [AstEnumSrc<'a>],\n+    pub(crate) token_enums: &'a [AstEnumSrc<'a>],\n }\n \n pub(crate) struct AstNodeSrc<'a> {\n@@ -753,6 +754,13 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             // macro calls are parsed as expression statements */\n         }\n \n+        enum FieldDefList {\n+            RecordFieldDefList,\n+            TupleFieldDefList,\n+        }\n+    },\n+\n+    token_enums: &ast_enums! {\n         enum LeftDelimiter { LParen, LBrack, LCurly }\n         enum RightDelimiter { RParen, RBrack, RCurly }\n         enum RangeSeparator { Dotdot, Dotdotdot, Dotdoteq}\n@@ -817,10 +825,5 @@ pub(crate) const AST_SRC: AstSrc = AstSrc {\n             Ident,\n             IntNumber\n         }\n-\n-        enum FieldDefList {\n-            RecordFieldDefList,\n-            TupleFieldDefList,\n-        }\n     },\n };"}, {"sha": "678b40133b0c9244f7deaf2b93b59b37e0e177bf", "filename": "xtask/src/codegen.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/30f0ad159a0f260f54356385de63c171722adb72/xtask%2Fsrc%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30f0ad159a0f260f54356385de63c171722adb72/xtask%2Fsrc%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen.rs?ref=30f0ad159a0f260f54356385de63c171722adb72", "patch": "@@ -22,8 +22,9 @@ const GRAMMAR_DIR: &str = \"crates/ra_parser/src/grammar\";\n const OK_INLINE_TESTS_DIR: &str = \"crates/ra_syntax/test_data/parser/inline/ok\";\n const ERR_INLINE_TESTS_DIR: &str = \"crates/ra_syntax/test_data/parser/inline/err\";\n \n-pub const SYNTAX_KINDS: &str = \"crates/ra_parser/src/syntax_kind/generated.rs\";\n-pub const AST: &str = \"crates/ra_syntax/src/ast/generated.rs\";\n+const SYNTAX_KINDS: &str = \"crates/ra_parser/src/syntax_kind/generated.rs\";\n+const AST_NODES: &str = \"crates/ra_syntax/src/ast/generated/nodes.rs\";\n+const AST_TOKENS: &str = \"crates/ra_syntax/src/ast/generated/tokens.rs\";\n \n const ASSISTS_DIR: &str = \"crates/ra_assists/src/handlers\";\n const ASSISTS_TESTS: &str = \"crates/ra_assists/src/doc_tests/generated.rs\";"}, {"sha": "6657c9fc5f08cd4aa136838002932bc447c01043", "filename": "xtask/src/codegen/gen_syntax.rs", "status": "modified", "additions": 151, "deletions": 114, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/30f0ad159a0f260f54356385de63c171722adb72/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30f0ad159a0f260f54356385de63c171722adb72/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs?ref=30f0ad159a0f260f54356385de63c171722adb72", "patch": "@@ -3,10 +3,13 @@\n //! Specifically, it generates the `SyntaxKind` enum and a number of newtype\n //! wrappers around `SyntaxNode` which implement `ra_syntax::AstNode`.\n \n+use std::{\n+    borrow::Cow,\n+    collections::{BTreeSet, HashSet},\n+};\n+\n use proc_macro2::{Punct, Spacing};\n use quote::{format_ident, quote};\n-use std::borrow::Cow;\n-use std::collections::{BTreeSet, HashMap, HashSet};\n \n use crate::{\n     ast_src::{AstSrc, FieldSrc, KindsSrc, AST_SRC, KINDS_SRC},\n@@ -19,9 +22,13 @@ pub fn generate_syntax(mode: Mode) -> Result<()> {\n     let syntax_kinds = generate_syntax_kinds(KINDS_SRC)?;\n     update(syntax_kinds_file.as_path(), &syntax_kinds, mode)?;\n \n-    let ast_file = project_root().join(codegen::AST);\n-    let ast = generate_ast(KINDS_SRC, AST_SRC)?;\n-    update(ast_file.as_path(), &ast, mode)?;\n+    let ast_nodes_file = project_root().join(codegen::AST_NODES);\n+    let contents = generate_nodes(KINDS_SRC, AST_SRC)?;\n+    update(ast_nodes_file.as_path(), &contents, mode)?;\n+\n+    let ast_tokens_file = project_root().join(codegen::AST_TOKENS);\n+    let contents = generate_tokens(KINDS_SRC, AST_SRC)?;\n+    update(ast_tokens_file.as_path(), &contents, mode)?;\n \n     Ok(())\n }\n@@ -33,7 +40,7 @@ struct ElementKinds {\n     has_tokens: bool,\n }\n \n-fn generate_ast(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n+fn generate_tokens(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n     let all_token_kinds: Vec<_> = kinds\n         .punct\n         .into_iter()\n@@ -51,46 +58,6 @@ fn generate_ast(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n         .chain(kinds.tokens.into_iter().copied().map(|x| x.into()))\n         .collect();\n \n-    let mut element_kinds_map = HashMap::new();\n-    for kind in &all_token_kinds {\n-        let kind = &**kind;\n-        let name = to_pascal_case(kind);\n-        element_kinds_map.insert(\n-            name,\n-            ElementKinds {\n-                kinds: Some(format_ident!(\"{}\", kind)).into_iter().collect(),\n-                has_nodes: false,\n-                has_tokens: true,\n-            },\n-        );\n-    }\n-\n-    for kind in kinds.nodes {\n-        let name = to_pascal_case(kind);\n-        element_kinds_map.insert(\n-            name,\n-            ElementKinds {\n-                kinds: Some(format_ident!(\"{}\", *kind)).into_iter().collect(),\n-                has_nodes: true,\n-                has_tokens: false,\n-            },\n-        );\n-    }\n-\n-    for en in grammar.enums {\n-        let mut element_kinds: ElementKinds = Default::default();\n-        for variant in en.variants {\n-            if let Some(variant_element_kinds) = element_kinds_map.get(*variant) {\n-                element_kinds.kinds.extend(variant_element_kinds.kinds.iter().cloned());\n-                element_kinds.has_tokens |= variant_element_kinds.has_tokens;\n-                element_kinds.has_nodes |= variant_element_kinds.has_nodes;\n-            } else {\n-                panic!(\"Enum variant has type that does not exist or was not declared before the enum: {}\", *variant);\n-            }\n-        }\n-        element_kinds_map.insert(en.name.to_string(), element_kinds);\n-    }\n-\n     let tokens = all_token_kinds.iter().map(|kind_str| {\n         let kind_str = &**kind_str;\n         let kind = format_ident!(\"{}\", kind_str);\n@@ -108,12 +75,7 @@ fn generate_ast(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n             }\n \n             impl AstToken for #name {\n-                fn can_cast(kind: SyntaxKind) -> bool {\n-                    match kind {\n-                        #kind => true,\n-                        _ => false,\n-                    }\n-                }\n+                fn can_cast(kind: SyntaxKind) -> bool { kind == #kind }\n                 fn cast(syntax: SyntaxToken) -> Option<Self> {\n                     if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }\n                 }\n@@ -122,6 +84,99 @@ fn generate_ast(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n         }\n     });\n \n+    let enums = grammar.token_enums.iter().map(|en| {\n+        let variants = en.variants.iter().map(|var| format_ident!(\"{}\", var)).collect::<Vec<_>>();\n+        let name = format_ident!(\"{}\", en.name);\n+        let kinds = variants\n+            .iter()\n+            .map(|name| format_ident!(\"{}\", to_upper_snake_case(&name.to_string())))\n+            .collect::<Vec<_>>();\n+        assert!(en.traits.is_empty());\n+\n+        quote! {\n+                #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+                pub enum #name {\n+                    #(#variants(#variants),)*\n+                }\n+\n+                #(\n+                impl From<#variants> for #name {\n+                    fn from(node: #variants) -> #name {\n+                        #name::#variants(node)\n+                    }\n+                }\n+                )*\n+\n+                impl std::fmt::Display for #name {\n+                    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+                        std::fmt::Display::fmt(self.syntax(), f)\n+                    }\n+                }\n+\n+                impl AstToken for #name {\n+                    fn can_cast(kind: SyntaxKind) -> bool {\n+                        match kind {\n+                            #(#kinds)|* => true,\n+                            _ => false,\n+                        }\n+                    }\n+                    fn cast(syntax: SyntaxToken) -> Option<Self> {\n+                        let res = match syntax.kind() {\n+                            #(\n+                            #kinds => #name::#variants(#variants { syntax }),\n+                            )*\n+                            _ => return None,\n+                        };\n+                        Some(res)\n+                    }\n+                    fn syntax(&self) -> &SyntaxToken {\n+                        match self {\n+                            #(\n+                            #name::#variants(it) => &it.syntax,\n+                            )*\n+                        }\n+                    }\n+                }\n+        }\n+    });\n+\n+    crate::reformat(quote! {\n+        use crate::{SyntaxToken, SyntaxKind::{self, *}, ast::AstToken};\n+\n+        #(#tokens)*\n+        #(#enums)*\n+    })\n+}\n+\n+fn generate_nodes(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n+    let all_token_kinds: Vec<_> = kinds\n+        .punct\n+        .into_iter()\n+        .map(|(_, kind)| kind)\n+        .copied()\n+        .map(|x| x.into())\n+        .chain(\n+            kinds\n+                .keywords\n+                .into_iter()\n+                .chain(kinds.contextual_keywords.into_iter())\n+                .map(|name| Cow::Owned(format!(\"{}_KW\", to_upper_snake_case(&name)))),\n+        )\n+        .chain(kinds.literals.into_iter().copied().map(|x| x.into()))\n+        .chain(kinds.tokens.into_iter().copied().map(|x| x.into()))\n+        .collect();\n+\n+    let mut token_kinds = HashSet::new();\n+    for kind in &all_token_kinds {\n+        let kind = &**kind;\n+        let name = to_pascal_case(kind);\n+        token_kinds.insert(name);\n+    }\n+\n+    for en in grammar.token_enums {\n+        token_kinds.insert(en.name.to_string());\n+    }\n+\n     let nodes = grammar.nodes.iter().map(|node| {\n         let name = format_ident!(\"{}\", node.name);\n         let kind = format_ident!(\"{}\", to_upper_snake_case(&name.to_string()));\n@@ -151,7 +206,7 @@ fn generate_ast(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n                     }\n                 }\n                 FieldSrc::Optional(_) | FieldSrc::Shorthand => {\n-                    let is_token = element_kinds_map[&ty.to_string()].has_tokens;\n+                    let is_token = token_kinds.contains(&ty.to_string());\n                     if is_token {\n                         quote! {\n                             pub fn #method_name(&self) -> Option<#ty> {\n@@ -175,18 +230,9 @@ fn generate_ast(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n                 pub(crate) syntax: SyntaxNode,\n             }\n \n-            impl std::fmt::Display for #name {\n-                fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-                    std::fmt::Display::fmt(self.syntax(), f)\n-                }\n-            }\n-\n             impl AstNode for #name {\n                 fn can_cast(kind: SyntaxKind) -> bool {\n-                    match kind {\n-                        #kind => true,\n-                        _ => false,\n-                    }\n+                    kind == #kind\n                 }\n                 fn cast(syntax: SyntaxNode) -> Option<Self> {\n                     if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }\n@@ -214,48 +260,6 @@ fn generate_ast(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n             quote!(impl ast::#trait_name for #name {})\n         });\n \n-        let element_kinds = &element_kinds_map[&en.name.to_string()];\n-        assert!(\n-            element_kinds.has_nodes ^ element_kinds.has_tokens,\n-            \"{}: {:#?}\",\n-            name,\n-            element_kinds\n-        );\n-        let specific_ast_trait = {\n-            let (ast_trait, syntax_type) = if element_kinds.has_tokens {\n-                (quote!(AstToken), quote!(SyntaxToken))\n-            } else {\n-                (quote!(AstNode), quote!(SyntaxNode))\n-            };\n-\n-            quote! {\n-                impl #ast_trait for #name {\n-                    fn can_cast(kind: SyntaxKind) -> bool {\n-                        match kind {\n-                            #(#kinds)|* => true,\n-                            _ => false,\n-                        }\n-                    }\n-                    fn cast(syntax: #syntax_type) -> Option<Self> {\n-                        let res = match syntax.kind() {\n-                            #(\n-                            #kinds => #name::#variants(#variants { syntax }),\n-                            )*\n-                            _ => return None,\n-                        };\n-                        Some(res)\n-                    }\n-                    fn syntax(&self) -> &#syntax_type {\n-                        match self {\n-                            #(\n-                            #name::#variants(it) => &it.syntax,\n-                            )*\n-                        }\n-                    }\n-                }\n-            }\n-        };\n-\n         quote! {\n             #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n             pub enum #name {\n@@ -270,18 +274,50 @@ fn generate_ast(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n             }\n             )*\n \n-            impl std::fmt::Display for #name {\n-                fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n-                    std::fmt::Display::fmt(self.syntax(), f)\n+            impl AstNode for #name {\n+                fn can_cast(kind: SyntaxKind) -> bool {\n+                    match kind {\n+                        #(#kinds)|* => true,\n+                        _ => false,\n+                    }\n+                }\n+                fn cast(syntax: SyntaxNode) -> Option<Self> {\n+                    let res = match syntax.kind() {\n+                        #(\n+                        #kinds => #name::#variants(#variants { syntax }),\n+                        )*\n+                        _ => return None,\n+                    };\n+                    Some(res)\n+                }\n+                fn syntax(&self) -> &SyntaxNode {\n+                    match self {\n+                        #(\n+                        #name::#variants(it) => &it.syntax,\n+                        )*\n+                    }\n                 }\n             }\n \n-            #specific_ast_trait\n-\n             #(#traits)*\n         }\n     });\n \n+    let displays = grammar\n+        .enums\n+        .iter()\n+        .map(|it| format_ident!(\"{}\", it.name))\n+        .chain(grammar.nodes.iter().map(|it| format_ident!(\"{}\", it.name)))\n+        .map(|name| {\n+            quote! {\n+                impl std::fmt::Display for #name {\n+                    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+                        std::fmt::Display::fmt(self.syntax(), f)\n+                    }\n+                }\n+            }\n+        });\n+\n     let defined_nodes: HashSet<_> = grammar.nodes.iter().map(|node| node.name).collect();\n \n     for node in kinds\n@@ -294,15 +330,16 @@ fn generate_ast(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n     }\n \n     let ast = quote! {\n-        #[allow(unused_imports)]\n         use crate::{\n-            SyntaxNode, SyntaxToken, SyntaxElement, NodeOrToken, SyntaxKind::{self, *},\n-            ast::{self, AstNode, AstToken, AstChildren, support},\n+            SyntaxNode, SyntaxKind::{self, *},\n+            ast::{self, AstNode, AstChildren, support},\n         };\n \n-        #(#tokens)*\n+        use super::tokens::*;\n+\n         #(#nodes)*\n         #(#enums)*\n+        #(#displays)*\n     };\n \n     let pretty = crate::reformat(ast)?;"}, {"sha": "ec824a5183d498bd5f14ade7609862499732dea6", "filename": "xtask/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/30f0ad159a0f260f54356385de63c171722adb72/xtask%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30f0ad159a0f260f54356385de63c171722adb72/xtask%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Flib.rs?ref=30f0ad159a0f260f54356385de63c171722adb72", "patch": "@@ -67,6 +67,7 @@ fn reformat(text: impl std::fmt::Display) -> Result<String> {\n     let mut rustfmt = Command::new(\"rustup\")\n         .args(&[\"run\", TOOLCHAIN, \"--\", \"rustfmt\", \"--config-path\"])\n         .arg(project_root().join(\"rustfmt.toml\"))\n+        .args(&[\"--config\", \"fn_single_line=true\"])\n         .stdin(Stdio::piped())\n         .stdout(Stdio::piped())\n         .spawn()?;"}]}