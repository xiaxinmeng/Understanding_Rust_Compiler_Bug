{"sha": "34d5624255737db8478dab62d9dc3940495062e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0ZDU2MjQyNTU3MzdkYjg0NzhkYWI2MmQ5ZGMzOTQwNDk1MDYyZTY=", "commit": {"author": {"name": "Clar Fon", "email": "them@lightdark.xyz", "date": "2018-12-17T22:27:22Z"}, "committer": {"name": "Clar Fon", "email": "them@lightdark.xyz", "date": "2019-01-22T22:45:11Z"}, "message": "Move DoubleEndedIterator to own module", "tree": {"sha": "5f381ffc8151b62c2e25fd494410cb5ed8c6d5d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f381ffc8151b62c2e25fd494410cb5ed8c6d5d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34d5624255737db8478dab62d9dc3940495062e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34d5624255737db8478dab62d9dc3940495062e6", "html_url": "https://github.com/rust-lang/rust/commit/34d5624255737db8478dab62d9dc3940495062e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34d5624255737db8478dab62d9dc3940495062e6/comments", "author": {"login": "clarfonthey", "id": 15850505, "node_id": "MDQ6VXNlcjE1ODUwNTA1", "avatar_url": "https://avatars.githubusercontent.com/u/15850505?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clarfonthey", "html_url": "https://github.com/clarfonthey", "followers_url": "https://api.github.com/users/clarfonthey/followers", "following_url": "https://api.github.com/users/clarfonthey/following{/other_user}", "gists_url": "https://api.github.com/users/clarfonthey/gists{/gist_id}", "starred_url": "https://api.github.com/users/clarfonthey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clarfonthey/subscriptions", "organizations_url": "https://api.github.com/users/clarfonthey/orgs", "repos_url": "https://api.github.com/users/clarfonthey/repos", "events_url": "https://api.github.com/users/clarfonthey/events{/privacy}", "received_events_url": "https://api.github.com/users/clarfonthey/received_events", "type": "User", "site_admin": false}, "committer": {"login": "clarfonthey", "id": 15850505, "node_id": "MDQ6VXNlcjE1ODUwNTA1", "avatar_url": "https://avatars.githubusercontent.com/u/15850505?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clarfonthey", "html_url": "https://github.com/clarfonthey", "followers_url": "https://api.github.com/users/clarfonthey/followers", "following_url": "https://api.github.com/users/clarfonthey/following{/other_user}", "gists_url": "https://api.github.com/users/clarfonthey/gists{/gist_id}", "starred_url": "https://api.github.com/users/clarfonthey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clarfonthey/subscriptions", "organizations_url": "https://api.github.com/users/clarfonthey/orgs", "repos_url": "https://api.github.com/users/clarfonthey/repos", "events_url": "https://api.github.com/users/clarfonthey/events{/privacy}", "received_events_url": "https://api.github.com/users/clarfonthey/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c40450ce65d11e771a32feaa8a1df9dbea480486", "url": "https://api.github.com/repos/rust-lang/rust/commits/c40450ce65d11e771a32feaa8a1df9dbea480486", "html_url": "https://github.com/rust-lang/rust/commit/c40450ce65d11e771a32feaa8a1df9dbea480486"}], "stats": {"total": 598, "additions": 300, "deletions": 298}, "files": [{"sha": "2976afc0b4f81db5729d175f596a791b85e6eac3", "filename": "src/libcore/iter/traits/double_ended.rs", "status": "added", "additions": 297, "deletions": 0, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/34d5624255737db8478dab62d9dc3940495062e6/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d5624255737db8478dab62d9dc3940495062e6/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs?ref=34d5624255737db8478dab62d9dc3940495062e6", "patch": "@@ -0,0 +1,297 @@\n+use ops::Try;\n+use iter::LoopState;\n+\n+/// An iterator able to yield elements from both ends.\n+///\n+/// Something that implements `DoubleEndedIterator` has one extra capability\n+/// over something that implements [`Iterator`]: the ability to also take\n+/// `Item`s from the back, as well as the front.\n+///\n+/// It is important to note that both back and forth work on the same range,\n+/// and do not cross: iteration is over when they meet in the middle.\n+///\n+/// In a similar fashion to the [`Iterator`] protocol, once a\n+/// `DoubleEndedIterator` returns `None` from a `next_back()`, calling it again\n+/// may or may not ever return `Some` again. `next()` and `next_back()` are\n+/// interchangeable for this purpose.\n+///\n+/// [`Iterator`]: trait.Iterator.html\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// let numbers = vec![1, 2, 3, 4, 5, 6];\n+///\n+/// let mut iter = numbers.iter();\n+///\n+/// assert_eq!(Some(&1), iter.next());\n+/// assert_eq!(Some(&6), iter.next_back());\n+/// assert_eq!(Some(&5), iter.next_back());\n+/// assert_eq!(Some(&2), iter.next());\n+/// assert_eq!(Some(&3), iter.next());\n+/// assert_eq!(Some(&4), iter.next());\n+/// assert_eq!(None, iter.next());\n+/// assert_eq!(None, iter.next_back());\n+/// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait DoubleEndedIterator: Iterator {\n+    /// Removes and returns an element from the end of the iterator.\n+    ///\n+    /// Returns `None` when there are no more elements.\n+    ///\n+    /// The [trait-level] docs contain more details.\n+    ///\n+    /// [trait-level]: trait.DoubleEndedIterator.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let numbers = vec![1, 2, 3, 4, 5, 6];\n+    ///\n+    /// let mut iter = numbers.iter();\n+    ///\n+    /// assert_eq!(Some(&1), iter.next());\n+    /// assert_eq!(Some(&6), iter.next_back());\n+    /// assert_eq!(Some(&5), iter.next_back());\n+    /// assert_eq!(Some(&2), iter.next());\n+    /// assert_eq!(Some(&3), iter.next());\n+    /// assert_eq!(Some(&4), iter.next());\n+    /// assert_eq!(None, iter.next());\n+    /// assert_eq!(None, iter.next_back());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn next_back(&mut self) -> Option<Self::Item>;\n+\n+    /// Returns the `n`th element from the end of the iterator.\n+    ///\n+    /// This is essentially the reversed version of [`nth`]. Although like most indexing\n+    /// operations, the count starts from zero, so `nth_back(0)` returns the first value fro\n+    /// the end, `nth_back(1)` the second, and so on.\n+    ///\n+    /// Note that all elements between the end and the returned element will be\n+    /// consumed, including the returned element. This also means that calling\n+    /// `nth_back(0)` multiple times on the same iterator will return different\n+    /// elements.\n+    ///\n+    /// `nth_back()` will return [`None`] if `n` is greater than or equal to the length of the\n+    /// iterator.\n+    ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`nth`]: ../../std/iter/trait.Iterator.html#method.nth\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(iter_nth_back)]\n+    /// let a = [1, 2, 3];\n+    /// assert_eq!(a.iter().nth_back(2), Some(&1));\n+    /// ```\n+    ///\n+    /// Calling `nth_back()` multiple times doesn't rewind the iterator:\n+    ///\n+    /// ```\n+    /// #![feature(iter_nth_back)]\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.iter();\n+    ///\n+    /// assert_eq!(iter.nth_back(1), Some(&2));\n+    /// assert_eq!(iter.nth_back(1), None);\n+    /// ```\n+    ///\n+    /// Returning `None` if there are less than `n + 1` elements:\n+    ///\n+    /// ```\n+    /// #![feature(iter_nth_back)]\n+    /// let a = [1, 2, 3];\n+    /// assert_eq!(a.iter().nth_back(10), None);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"iter_nth_back\", issue = \"56995\")]\n+    fn nth_back(&mut self, mut n: usize) -> Option<Self::Item> {\n+        for x in self.rev() {\n+            if n == 0 { return Some(x) }\n+            n -= 1;\n+        }\n+        None\n+    }\n+\n+    /// This is the reverse version of [`try_fold()`]: it takes elements\n+    /// starting from the back of the iterator.\n+    ///\n+    /// [`try_fold()`]: trait.Iterator.html#method.try_fold\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [\"1\", \"2\", \"3\"];\n+    /// let sum = a.iter()\n+    ///     .map(|&s| s.parse::<i32>())\n+    ///     .try_rfold(0, |acc, x| x.and_then(|y| Ok(acc + y)));\n+    /// assert_eq!(sum, Ok(6));\n+    /// ```\n+    ///\n+    /// Short-circuiting:\n+    ///\n+    /// ```\n+    /// let a = [\"1\", \"rust\", \"3\"];\n+    /// let mut it = a.iter();\n+    /// let sum = it\n+    ///     .by_ref()\n+    ///     .map(|&s| s.parse::<i32>())\n+    ///     .try_rfold(0, |acc, x| x.and_then(|y| Ok(acc + y)));\n+    /// assert!(sum.is_err());\n+    ///\n+    /// // Because it short-circuited, the remaining elements are still\n+    /// // available through the iterator.\n+    /// assert_eq!(it.next_back(), Some(&\"1\"));\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"iterator_try_fold\", since = \"1.27.0\")]\n+    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok=B>\n+    {\n+        let mut accum = init;\n+        while let Some(x) = self.next_back() {\n+            accum = f(accum, x)?;\n+        }\n+        Try::from_ok(accum)\n+    }\n+\n+    /// An iterator method that reduces the iterator's elements to a single,\n+    /// final value, starting from the back.\n+    ///\n+    /// This is the reverse version of [`fold()`]: it takes elements starting from\n+    /// the back of the iterator.\n+    ///\n+    /// `rfold()` takes two arguments: an initial value, and a closure with two\n+    /// arguments: an 'accumulator', and an element. The closure returns the value that\n+    /// the accumulator should have for the next iteration.\n+    ///\n+    /// The initial value is the value the accumulator will have on the first\n+    /// call.\n+    ///\n+    /// After applying this closure to every element of the iterator, `rfold()`\n+    /// returns the accumulator.\n+    ///\n+    /// This operation is sometimes called 'reduce' or 'inject'.\n+    ///\n+    /// Folding is useful whenever you have a collection of something, and want\n+    /// to produce a single value from it.\n+    ///\n+    /// [`fold()`]: trait.Iterator.html#method.fold\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// // the sum of all of the elements of a\n+    /// let sum = a.iter()\n+    ///            .rfold(0, |acc, &x| acc + x);\n+    ///\n+    /// assert_eq!(sum, 6);\n+    /// ```\n+    ///\n+    /// This example builds a string, starting with an initial value\n+    /// and continuing with each element from the back until the front:\n+    ///\n+    /// ```\n+    /// let numbers = [1, 2, 3, 4, 5];\n+    ///\n+    /// let zero = \"0\".to_string();\n+    ///\n+    /// let result = numbers.iter().rfold(zero, |acc, &x| {\n+    ///     format!(\"({} + {})\", x, acc)\n+    /// });\n+    ///\n+    /// assert_eq!(result, \"(1 + (2 + (3 + (4 + (5 + 0)))))\");\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"iter_rfold\", since = \"1.27.0\")]\n+    fn rfold<B, F>(mut self, accum: B, mut f: F) -> B\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> B,\n+    {\n+        self.try_rfold(accum, move |acc, x| Ok::<B, !>(f(acc, x))).unwrap()\n+    }\n+\n+    /// Searches for an element of an iterator from the back that satisfies a predicate.\n+    ///\n+    /// `rfind()` takes a closure that returns `true` or `false`. It applies\n+    /// this closure to each element of the iterator, starting at the end, and if any\n+    /// of them return `true`, then `rfind()` returns [`Some(element)`]. If they all return\n+    /// `false`, it returns [`None`].\n+    ///\n+    /// `rfind()` is short-circuiting; in other words, it will stop processing\n+    /// as soon as the closure returns `true`.\n+    ///\n+    /// Because `rfind()` takes a reference, and many iterators iterate over\n+    /// references, this leads to a possibly confusing situation where the\n+    /// argument is a double reference. You can see this effect in the\n+    /// examples below, with `&&x`.\n+    ///\n+    /// [`Some(element)`]: ../../std/option/enum.Option.html#variant.Some\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// assert_eq!(a.iter().rfind(|&&x| x == 2), Some(&2));\n+    ///\n+    /// assert_eq!(a.iter().rfind(|&&x| x == 5), None);\n+    /// ```\n+    ///\n+    /// Stopping at the first `true`:\n+    ///\n+    /// ```\n+    /// let a = [1, 2, 3];\n+    ///\n+    /// let mut iter = a.iter();\n+    ///\n+    /// assert_eq!(iter.rfind(|&&x| x == 2), Some(&2));\n+    ///\n+    /// // we can still use `iter`, as there are more elements.\n+    /// assert_eq!(iter.next_back(), Some(&1));\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"iter_rfind\", since = \"1.27.0\")]\n+    fn rfind<P>(&mut self, mut predicate: P) -> Option<Self::Item>\n+    where\n+        Self: Sized,\n+        P: FnMut(&Self::Item) -> bool\n+    {\n+        self.try_rfold((), move |(), x| {\n+            if predicate(&x) { LoopState::Break(x) }\n+            else { LoopState::Continue(()) }\n+        }).break_value()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, I: DoubleEndedIterator + ?Sized> DoubleEndedIterator for &'a mut I {\n+    fn next_back(&mut self) -> Option<I::Item> {\n+        (**self).next_back()\n+    }\n+    fn nth_back(&mut self, n: usize) -> Option<I::Item> {\n+        (**self).nth_back(n)\n+    }\n+}"}, {"sha": "d0a10d27db8c43e97b561ebf01161a7cdd0fd206", "filename": "src/libcore/iter/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 298, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/34d5624255737db8478dab62d9dc3940495062e6/src%2Flibcore%2Fiter%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34d5624255737db8478dab62d9dc3940495062e6/src%2Flibcore%2Fiter%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fmod.rs?ref=34d5624255737db8478dab62d9dc3940495062e6", "patch": "@@ -1,11 +1,11 @@\n-use ops::{Mul, Add, Try};\n+use ops::{Mul, Add};\n use num::Wrapping;\n \n-use super::LoopState;\n-\n mod iterator;\n+mod double_ended;\n \n pub use self::iterator::Iterator;\n+pub use self::double_ended::DoubleEndedIterator;\n \n /// Conversion from an `Iterator`.\n ///\n@@ -357,301 +357,6 @@ impl Extend<()> for () {\n     }\n }\n \n-/// An iterator able to yield elements from both ends.\n-///\n-/// Something that implements `DoubleEndedIterator` has one extra capability\n-/// over something that implements [`Iterator`]: the ability to also take\n-/// `Item`s from the back, as well as the front.\n-///\n-/// It is important to note that both back and forth work on the same range,\n-/// and do not cross: iteration is over when they meet in the middle.\n-///\n-/// In a similar fashion to the [`Iterator`] protocol, once a\n-/// `DoubleEndedIterator` returns `None` from a `next_back()`, calling it again\n-/// may or may not ever return `Some` again. `next()` and `next_back()` are\n-/// interchangeable for this purpose.\n-///\n-/// [`Iterator`]: trait.Iterator.html\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// let numbers = vec![1, 2, 3, 4, 5, 6];\n-///\n-/// let mut iter = numbers.iter();\n-///\n-/// assert_eq!(Some(&1), iter.next());\n-/// assert_eq!(Some(&6), iter.next_back());\n-/// assert_eq!(Some(&5), iter.next_back());\n-/// assert_eq!(Some(&2), iter.next());\n-/// assert_eq!(Some(&3), iter.next());\n-/// assert_eq!(Some(&4), iter.next());\n-/// assert_eq!(None, iter.next());\n-/// assert_eq!(None, iter.next_back());\n-/// ```\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait DoubleEndedIterator: Iterator {\n-    /// Removes and returns an element from the end of the iterator.\n-    ///\n-    /// Returns `None` when there are no more elements.\n-    ///\n-    /// The [trait-level] docs contain more details.\n-    ///\n-    /// [trait-level]: trait.DoubleEndedIterator.html\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let numbers = vec![1, 2, 3, 4, 5, 6];\n-    ///\n-    /// let mut iter = numbers.iter();\n-    ///\n-    /// assert_eq!(Some(&1), iter.next());\n-    /// assert_eq!(Some(&6), iter.next_back());\n-    /// assert_eq!(Some(&5), iter.next_back());\n-    /// assert_eq!(Some(&2), iter.next());\n-    /// assert_eq!(Some(&3), iter.next());\n-    /// assert_eq!(Some(&4), iter.next());\n-    /// assert_eq!(None, iter.next());\n-    /// assert_eq!(None, iter.next_back());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn next_back(&mut self) -> Option<Self::Item>;\n-\n-    /// Returns the `n`th element from the end of the iterator.\n-    ///\n-    /// This is essentially the reversed version of [`nth`]. Although like most indexing\n-    /// operations, the count starts from zero, so `nth_back(0)` returns the first value fro\n-    /// the end, `nth_back(1)` the second, and so on.\n-    ///\n-    /// Note that all elements between the end and the returned element will be\n-    /// consumed, including the returned element. This also means that calling\n-    /// `nth_back(0)` multiple times on the same iterator will return different\n-    /// elements.\n-    ///\n-    /// `nth_back()` will return [`None`] if `n` is greater than or equal to the length of the\n-    /// iterator.\n-    ///\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    /// [`nth`]: ../../std/iter/trait.Iterator.html#method.nth\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// #![feature(iter_nth_back)]\n-    /// let a = [1, 2, 3];\n-    /// assert_eq!(a.iter().nth_back(2), Some(&1));\n-    /// ```\n-    ///\n-    /// Calling `nth_back()` multiple times doesn't rewind the iterator:\n-    ///\n-    /// ```\n-    /// #![feature(iter_nth_back)]\n-    /// let a = [1, 2, 3];\n-    ///\n-    /// let mut iter = a.iter();\n-    ///\n-    /// assert_eq!(iter.nth_back(1), Some(&2));\n-    /// assert_eq!(iter.nth_back(1), None);\n-    /// ```\n-    ///\n-    /// Returning `None` if there are less than `n + 1` elements:\n-    ///\n-    /// ```\n-    /// #![feature(iter_nth_back)]\n-    /// let a = [1, 2, 3];\n-    /// assert_eq!(a.iter().nth_back(10), None);\n-    /// ```\n-    #[inline]\n-    #[unstable(feature = \"iter_nth_back\", issue = \"56995\")]\n-    fn nth_back(&mut self, mut n: usize) -> Option<Self::Item> {\n-        for x in self.rev() {\n-            if n == 0 { return Some(x) }\n-            n -= 1;\n-        }\n-        None\n-    }\n-\n-    /// This is the reverse version of [`try_fold()`]: it takes elements\n-    /// starting from the back of the iterator.\n-    ///\n-    /// [`try_fold()`]: trait.Iterator.html#method.try_fold\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let a = [\"1\", \"2\", \"3\"];\n-    /// let sum = a.iter()\n-    ///     .map(|&s| s.parse::<i32>())\n-    ///     .try_rfold(0, |acc, x| x.and_then(|y| Ok(acc + y)));\n-    /// assert_eq!(sum, Ok(6));\n-    /// ```\n-    ///\n-    /// Short-circuiting:\n-    ///\n-    /// ```\n-    /// let a = [\"1\", \"rust\", \"3\"];\n-    /// let mut it = a.iter();\n-    /// let sum = it\n-    ///     .by_ref()\n-    ///     .map(|&s| s.parse::<i32>())\n-    ///     .try_rfold(0, |acc, x| x.and_then(|y| Ok(acc + y)));\n-    /// assert!(sum.is_err());\n-    ///\n-    /// // Because it short-circuited, the remaining elements are still\n-    /// // available through the iterator.\n-    /// assert_eq!(it.next_back(), Some(&\"1\"));\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"iterator_try_fold\", since = \"1.27.0\")]\n-    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R\n-    where\n-        Self: Sized,\n-        F: FnMut(B, Self::Item) -> R,\n-        R: Try<Ok=B>\n-    {\n-        let mut accum = init;\n-        while let Some(x) = self.next_back() {\n-            accum = f(accum, x)?;\n-        }\n-        Try::from_ok(accum)\n-    }\n-\n-    /// An iterator method that reduces the iterator's elements to a single,\n-    /// final value, starting from the back.\n-    ///\n-    /// This is the reverse version of [`fold()`]: it takes elements starting from\n-    /// the back of the iterator.\n-    ///\n-    /// `rfold()` takes two arguments: an initial value, and a closure with two\n-    /// arguments: an 'accumulator', and an element. The closure returns the value that\n-    /// the accumulator should have for the next iteration.\n-    ///\n-    /// The initial value is the value the accumulator will have on the first\n-    /// call.\n-    ///\n-    /// After applying this closure to every element of the iterator, `rfold()`\n-    /// returns the accumulator.\n-    ///\n-    /// This operation is sometimes called 'reduce' or 'inject'.\n-    ///\n-    /// Folding is useful whenever you have a collection of something, and want\n-    /// to produce a single value from it.\n-    ///\n-    /// [`fold()`]: trait.Iterator.html#method.fold\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let a = [1, 2, 3];\n-    ///\n-    /// // the sum of all of the elements of a\n-    /// let sum = a.iter()\n-    ///            .rfold(0, |acc, &x| acc + x);\n-    ///\n-    /// assert_eq!(sum, 6);\n-    /// ```\n-    ///\n-    /// This example builds a string, starting with an initial value\n-    /// and continuing with each element from the back until the front:\n-    ///\n-    /// ```\n-    /// let numbers = [1, 2, 3, 4, 5];\n-    ///\n-    /// let zero = \"0\".to_string();\n-    ///\n-    /// let result = numbers.iter().rfold(zero, |acc, &x| {\n-    ///     format!(\"({} + {})\", x, acc)\n-    /// });\n-    ///\n-    /// assert_eq!(result, \"(1 + (2 + (3 + (4 + (5 + 0)))))\");\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"iter_rfold\", since = \"1.27.0\")]\n-    fn rfold<B, F>(mut self, accum: B, mut f: F) -> B\n-    where\n-        Self: Sized,\n-        F: FnMut(B, Self::Item) -> B,\n-    {\n-        self.try_rfold(accum, move |acc, x| Ok::<B, !>(f(acc, x))).unwrap()\n-    }\n-\n-    /// Searches for an element of an iterator from the back that satisfies a predicate.\n-    ///\n-    /// `rfind()` takes a closure that returns `true` or `false`. It applies\n-    /// this closure to each element of the iterator, starting at the end, and if any\n-    /// of them return `true`, then `rfind()` returns [`Some(element)`]. If they all return\n-    /// `false`, it returns [`None`].\n-    ///\n-    /// `rfind()` is short-circuiting; in other words, it will stop processing\n-    /// as soon as the closure returns `true`.\n-    ///\n-    /// Because `rfind()` takes a reference, and many iterators iterate over\n-    /// references, this leads to a possibly confusing situation where the\n-    /// argument is a double reference. You can see this effect in the\n-    /// examples below, with `&&x`.\n-    ///\n-    /// [`Some(element)`]: ../../std/option/enum.Option.html#variant.Some\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let a = [1, 2, 3];\n-    ///\n-    /// assert_eq!(a.iter().rfind(|&&x| x == 2), Some(&2));\n-    ///\n-    /// assert_eq!(a.iter().rfind(|&&x| x == 5), None);\n-    /// ```\n-    ///\n-    /// Stopping at the first `true`:\n-    ///\n-    /// ```\n-    /// let a = [1, 2, 3];\n-    ///\n-    /// let mut iter = a.iter();\n-    ///\n-    /// assert_eq!(iter.rfind(|&&x| x == 2), Some(&2));\n-    ///\n-    /// // we can still use `iter`, as there are more elements.\n-    /// assert_eq!(iter.next_back(), Some(&1));\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"iter_rfind\", since = \"1.27.0\")]\n-    fn rfind<P>(&mut self, mut predicate: P) -> Option<Self::Item>\n-    where\n-        Self: Sized,\n-        P: FnMut(&Self::Item) -> bool\n-    {\n-        self.try_rfold((), move |(), x| {\n-            if predicate(&x) { LoopState::Break(x) }\n-            else { LoopState::Continue(()) }\n-        }).break_value()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, I: DoubleEndedIterator + ?Sized> DoubleEndedIterator for &'a mut I {\n-    fn next_back(&mut self) -> Option<I::Item> {\n-        (**self).next_back()\n-    }\n-    fn nth_back(&mut self, n: usize) -> Option<I::Item> {\n-        (**self).nth_back(n)\n-    }\n-}\n-\n /// An iterator that knows its exact length.\n ///\n /// Many [`Iterator`]s don't know how many times they will iterate, but some do."}]}