{"sha": "c2769285ad6d078c9a4499ad9e11278e4b78023c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyNzY5Mjg1YWQ2ZDA3OGM5YTQ0OTlhZDllMTEyNzhlNGI3ODAyM2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-09-26T14:53:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-26T14:53:27Z"}, "message": "Auto merge of #36735 - srinivasreddy:typck/variance, r=nrc\n\nrun rustfmt on librustc_typeck/variance folder", "tree": {"sha": "9ddc4b2cea9b7755fb9b0be99aba4c095e16ed10", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ddc4b2cea9b7755fb9b0be99aba4c095e16ed10"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2769285ad6d078c9a4499ad9e11278e4b78023c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2769285ad6d078c9a4499ad9e11278e4b78023c", "html_url": "https://github.com/rust-lang/rust/commit/c2769285ad6d078c9a4499ad9e11278e4b78023c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2769285ad6d078c9a4499ad9e11278e4b78023c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bf4a7ad45bceef2e7ac666f4cbb41a37d6af763", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bf4a7ad45bceef2e7ac666f4cbb41a37d6af763", "html_url": "https://github.com/rust-lang/rust/commit/3bf4a7ad45bceef2e7ac666f4cbb41a37d6af763"}, {"sha": "765eaac000849932a22af2058d345ff2b7b750b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/765eaac000849932a22af2058d345ff2b7b750b8", "html_url": "https://github.com/rust-lang/rust/commit/765eaac000849932a22af2058d345ff2b7b750b8"}], "stats": {"total": 297, "additions": 145, "deletions": 152}, "files": [{"sha": "c9e93a1a46d622e2ebbd4add2529e81dc31c1e6e", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 70, "deletions": 78, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/c2769285ad6d078c9a4499ad9e11278e4b78023c/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2769285ad6d078c9a4499ad9e11278e4b78023c/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=c2769285ad6d078c9a4499ad9e11278e4b78023c", "patch": "@@ -37,7 +37,7 @@ pub struct ConstraintContext<'a, 'tcx: 'a> {\n     invariant: VarianceTermPtr<'a>,\n     bivariant: VarianceTermPtr<'a>,\n \n-    pub constraints: Vec<Constraint<'a>> ,\n+    pub constraints: Vec<Constraint<'a>>,\n }\n \n /// Declares that the variable `decl_id` appears in a location with\n@@ -49,8 +49,7 @@ pub struct Constraint<'a> {\n }\n \n pub fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>)\n-                                            -> ConstraintContext<'a, 'tcx>\n-{\n+                                            -> ConstraintContext<'a, 'tcx> {\n     let tcx = terms_cx.tcx;\n     let covariant = terms_cx.arena.alloc(ConstantTerm(ty::Covariant));\n     let contravariant = terms_cx.arena.alloc(ConstantTerm(ty::Contravariant));\n@@ -80,7 +79,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n         debug!(\"visit_item item={}\", tcx.map.node_to_string(item.id));\n \n         match item.node {\n-            hir::ItemEnum(..) | hir::ItemStruct(..) | hir::ItemUnion(..) => {\n+            hir::ItemEnum(..) |\n+            hir::ItemStruct(..) |\n+            hir::ItemUnion(..) => {\n                 let scheme = tcx.lookup_item_type(did);\n \n                 // Not entirely obvious: constraints on structs/enums do not\n@@ -111,16 +112,16 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n             hir::ItemForeignMod(..) |\n             hir::ItemTy(..) |\n             hir::ItemImpl(..) |\n-            hir::ItemDefaultImpl(..) => {\n-            }\n+            hir::ItemDefaultImpl(..) => {}\n         }\n     }\n }\n \n /// Is `param_id` a lifetime according to `map`?\n fn is_lifetime(map: &hir_map::Map, param_id: ast::NodeId) -> bool {\n     match map.find(param_id) {\n-        Some(hir_map::NodeLifetime(..)) => true, _ => false\n+        Some(hir_map::NodeLifetime(..)) => true,\n+        _ => false,\n     }\n }\n \n@@ -143,13 +144,12 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         let tcx = self.terms_cx.tcx;\n         assert!(is_lifetime(&tcx.map, param_id));\n         match tcx.named_region_map.defs.get(&param_id) {\n-            Some(&rl::DefEarlyBoundRegion(_, lifetime_decl_id))\n-                => lifetime_decl_id,\n+            Some(&rl::DefEarlyBoundRegion(_, lifetime_decl_id)) => lifetime_decl_id,\n             Some(_) => bug!(\"should not encounter non early-bound cases\"),\n \n             // The lookup should only fail when `param_id` is\n             // itself a lifetime binding: use it as the decl_id.\n-            None    => param_id,\n+            None => param_id,\n         }\n \n     }\n@@ -163,14 +163,15 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         // parameter (by inspecting parent of its binding declaration\n         // to see if it is introduced by a type or by a fn/impl).\n \n-        let check_result = |this:&ConstraintContext| -> bool {\n+        let check_result = |this: &ConstraintContext| -> bool {\n             let tcx = this.terms_cx.tcx;\n             let decl_id = this.find_binding_for_lifetime(param_id);\n             // Currently only called on lifetimes; double-checking that.\n             assert!(is_lifetime(&tcx.map, param_id));\n             let parent_id = tcx.map.get_parent(decl_id);\n-            let parent = tcx.map.find(parent_id).unwrap_or_else(\n-                || bug!(\"tcx.map missing entry for id: {}\", parent_id));\n+            let parent = tcx.map\n+                .find(parent_id)\n+                .unwrap_or_else(|| bug!(\"tcx.map missing entry for id: {}\", parent_id));\n \n             let is_inferred;\n             macro_rules! cannot_happen { () => { {\n@@ -186,14 +187,14 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                         hir::ItemEnum(..) |\n                         hir::ItemStruct(..) |\n                         hir::ItemUnion(..) |\n-                        hir::ItemTrait(..)   => is_inferred = true,\n-                        hir::ItemFn(..)      => is_inferred = false,\n-                        _                    => cannot_happen!(),\n+                        hir::ItemTrait(..) => is_inferred = true,\n+                        hir::ItemFn(..) => is_inferred = false,\n+                        _ => cannot_happen!(),\n                     }\n                 }\n-                hir_map::NodeTraitItem(..)   => is_inferred = false,\n-                hir_map::NodeImplItem(..)    => is_inferred = false,\n-                _                            => cannot_happen!(),\n+                hir_map::NodeTraitItem(..) => is_inferred = false,\n+                hir_map::NodeImplItem(..) => is_inferred = false,\n+                _ => cannot_happen!(),\n             }\n \n             return is_inferred;\n@@ -230,21 +231,18 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     fn add_constraint(&mut self,\n                       InferredIndex(index): InferredIndex,\n                       variance: VarianceTermPtr<'a>) {\n-        debug!(\"add_constraint(index={}, variance={:?})\",\n-                index, variance);\n-        self.constraints.push(Constraint { inferred: InferredIndex(index),\n-                                           variance: variance });\n+        debug!(\"add_constraint(index={}, variance={:?})\", index, variance);\n+        self.constraints.push(Constraint {\n+            inferred: InferredIndex(index),\n+            variance: variance,\n+        });\n     }\n \n-    fn contravariant(&mut self,\n-                     variance: VarianceTermPtr<'a>)\n-                     -> VarianceTermPtr<'a> {\n+    fn contravariant(&mut self, variance: VarianceTermPtr<'a>) -> VarianceTermPtr<'a> {\n         self.xform(variance, self.contravariant)\n     }\n \n-    fn invariant(&mut self,\n-                 variance: VarianceTermPtr<'a>)\n-                 -> VarianceTermPtr<'a> {\n+    fn invariant(&mut self, variance: VarianceTermPtr<'a>) -> VarianceTermPtr<'a> {\n         self.xform(variance, self.invariant)\n     }\n \n@@ -257,23 +255,16 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         }\n     }\n \n-    fn xform(&mut self,\n-             v1: VarianceTermPtr<'a>,\n-             v2: VarianceTermPtr<'a>)\n-             -> VarianceTermPtr<'a> {\n+    fn xform(&mut self, v1: VarianceTermPtr<'a>, v2: VarianceTermPtr<'a>) -> VarianceTermPtr<'a> {\n         match (*v1, *v2) {\n             (_, ConstantTerm(ty::Covariant)) => {\n                 // Applying a \"covariant\" transform is always a no-op\n                 v1\n             }\n \n-            (ConstantTerm(c1), ConstantTerm(c2)) => {\n-                self.constant_term(c1.xform(c2))\n-            }\n+            (ConstantTerm(c1), ConstantTerm(c2)) => self.constant_term(c1.xform(c2)),\n \n-            _ => {\n-                &*self.terms_cx.arena.alloc(TransformTerm(v1, v2))\n-            }\n+            _ => &*self.terms_cx.arena.alloc(TransformTerm(v1, v2)),\n         }\n     }\n \n@@ -292,13 +283,12 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         // README.md for a discussion on dep-graph management.\n         self.tcx().dep_graph.read(ItemVariances::to_dep_node(&trait_ref.def_id));\n \n-        self.add_constraints_from_substs(\n-            generics,\n-            trait_ref.def_id,\n-            &trait_def.generics.types,\n-            &trait_def.generics.regions,\n-            trait_ref.substs,\n-            variance);\n+        self.add_constraints_from_substs(generics,\n+                                         trait_ref.def_id,\n+                                         &trait_def.generics.types,\n+                                         &trait_def.generics.regions,\n+                                         trait_ref.substs,\n+                                         variance);\n     }\n \n     /// Adds constraints appropriate for an instance of `ty` appearing\n@@ -313,13 +303,13 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                variance);\n \n         match ty.sty {\n-            ty::TyBool |\n-            ty::TyChar | ty::TyInt(_) | ty::TyUint(_) |\n-            ty::TyFloat(_) | ty::TyStr | ty::TyNever => {\n-                /* leaf type -- noop */\n+            ty::TyBool | ty::TyChar | ty::TyInt(_) | ty::TyUint(_) | ty::TyFloat(_) |\n+            ty::TyStr | ty::TyNever => {\n+                // leaf type -- noop\n             }\n \n-            ty::TyClosure(..) | ty::TyAnon(..) => {\n+            ty::TyClosure(..) |\n+            ty::TyAnon(..) => {\n                 bug!(\"Unexpected closure type in variance computation\");\n             }\n \n@@ -329,11 +319,12 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 self.add_constraints_from_mt(generics, mt, variance);\n             }\n \n-            ty::TyBox(typ) | ty::TyArray(typ, _) | ty::TySlice(typ) => {\n+            ty::TyBox(typ) |\n+            ty::TyArray(typ, _) |\n+            ty::TySlice(typ) => {\n                 self.add_constraints_from_ty(generics, typ, variance);\n             }\n \n-\n             ty::TyRawPtr(ref mt) => {\n                 self.add_constraints_from_mt(generics, mt, variance);\n             }\n@@ -352,13 +343,12 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 // README.md for a discussion on dep-graph management.\n                 self.tcx().dep_graph.read(ItemVariances::to_dep_node(&def.did));\n \n-                self.add_constraints_from_substs(\n-                    generics,\n-                    def.did,\n-                    &item_type.generics.types,\n-                    &item_type.generics.regions,\n-                    substs,\n-                    variance);\n+                self.add_constraints_from_substs(generics,\n+                                                 def.did,\n+                                                 &item_type.generics.types,\n+                                                 &item_type.generics.regions,\n+                                                 substs,\n+                                                 variance);\n             }\n \n             ty::TyProjection(ref data) => {\n@@ -370,22 +360,20 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 // README.md for a discussion on dep-graph management.\n                 self.tcx().dep_graph.read(ItemVariances::to_dep_node(&trait_ref.def_id));\n \n-                self.add_constraints_from_substs(\n-                    generics,\n-                    trait_ref.def_id,\n-                    &trait_def.generics.types,\n-                    &trait_def.generics.regions,\n-                    trait_ref.substs,\n-                    variance);\n+                self.add_constraints_from_substs(generics,\n+                                                 trait_ref.def_id,\n+                                                 &trait_def.generics.types,\n+                                                 &trait_def.generics.regions,\n+                                                 trait_ref.substs,\n+                                                 variance);\n             }\n \n             ty::TyTrait(ref data) => {\n                 // The type `Foo<T+'a>` is contravariant w/r/t `'a`:\n                 let contra = self.contravariant(variance);\n                 self.add_constraints_from_region(generics, data.region_bound, contra);\n \n-                let poly_trait_ref =\n-                    data.principal.with_self_ty(self.tcx(), self.tcx().types.err);\n+                let poly_trait_ref = data.principal.with_self_ty(self.tcx(), self.tcx().types.err);\n                 self.add_constraints_from_trait_ref(generics, poly_trait_ref.0, variance);\n \n                 for projection in &data.projection_bounds {\n@@ -425,7 +413,8 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n             ty::TyInfer(..) => {\n                 bug!(\"unexpected type encountered in \\\n-                      variance inference: {}\", ty);\n+                      variance inference: {}\",\n+                     ty);\n             }\n         }\n     }\n@@ -445,18 +434,17 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                variance);\n \n         for p in type_param_defs {\n-            let variance_decl =\n-                self.declared_variance(p.def_id, def_id, p.index as usize);\n+            let variance_decl = self.declared_variance(p.def_id, def_id, p.index as usize);\n             let variance_i = self.xform(variance, variance_decl);\n             let substs_ty = substs.type_for_def(p);\n             debug!(\"add_constraints_from_substs: variance_decl={:?} variance_i={:?}\",\n-                   variance_decl, variance_i);\n+                   variance_decl,\n+                   variance_i);\n             self.add_constraints_from_ty(generics, substs_ty, variance_i);\n         }\n \n         for p in region_param_defs {\n-            let variance_decl =\n-                self.declared_variance(p.def_id, def_id, p.index as usize);\n+            let variance_decl = self.declared_variance(p.def_id, def_id, p.index as usize);\n             let variance_i = self.xform(variance, variance_decl);\n             let substs_r = substs.region_for_def(p);\n             self.add_constraints_from_region(generics, substs_r, variance_i);\n@@ -494,15 +482,19 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 }\n             }\n \n-            ty::ReStatic => { }\n+            ty::ReStatic => {}\n \n             ty::ReLateBound(..) => {\n                 // We do not infer variance for region parameters on\n                 // methods or in fn types.\n             }\n \n-            ty::ReFree(..) | ty::ReScope(..) | ty::ReVar(..) |\n-            ty::ReSkolemized(..) | ty::ReEmpty | ty::ReErased => {\n+            ty::ReFree(..) |\n+            ty::ReScope(..) |\n+            ty::ReVar(..) |\n+            ty::ReSkolemized(..) |\n+            ty::ReEmpty |\n+            ty::ReErased => {\n                 // We don't expect to see anything but 'static or bound\n                 // regions when visiting member types or method types.\n                 bug!(\"unexpected region encountered in variance \\"}, {"sha": "cd0ab1cbb9543bd685819eae0c350267ce6ecbe1", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c2769285ad6d078c9a4499ad9e11278e4b78023c/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2769285ad6d078c9a4499ad9e11278e4b78023c/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=c2769285ad6d078c9a4499ad9e11278e4b78023c", "patch": "@@ -34,4 +34,3 @@ pub fn infer_variance<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     solve::solve_constraints(constraints_cx);\n     tcx.variance_computed.set(true);\n }\n-"}, {"sha": "a5c53b4c6291ce9469df680e114f7f2d5bd569c6", "filename": "src/librustc_typeck/variance/solve.rs", "status": "modified", "additions": 29, "deletions": 27, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/c2769285ad6d078c9a4499ad9e11278e4b78023c/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2769285ad6d078c9a4499ad9e11278e4b78023c/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs?ref=c2769285ad6d078c9a4499ad9e11278e4b78023c", "patch": "@@ -25,24 +25,24 @@ use super::xform::*;\n \n struct SolveContext<'a, 'tcx: 'a> {\n     terms_cx: TermsContext<'a, 'tcx>,\n-    constraints: Vec<Constraint<'a>> ,\n+    constraints: Vec<Constraint<'a>>,\n \n     // Maps from an InferredIndex to the inferred value for that variable.\n-    solutions: Vec<ty::Variance>\n+    solutions: Vec<ty::Variance>,\n }\n \n pub fn solve_constraints(constraints_cx: ConstraintContext) {\n     let ConstraintContext { terms_cx, constraints, .. } = constraints_cx;\n \n-    let solutions =\n-        terms_cx.inferred_infos.iter()\n-                               .map(|ii| ii.initial_variance)\n-                               .collect();\n+    let solutions = terms_cx.inferred_infos\n+        .iter()\n+        .map(|ii| ii.initial_variance)\n+        .collect();\n \n     let mut solutions_cx = SolveContext {\n         terms_cx: terms_cx,\n         constraints: constraints,\n-        solutions: solutions\n+        solutions: solutions,\n     };\n     solutions_cx.solve();\n     solutions_cx.write();\n@@ -68,13 +68,13 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n                 if old_value != new_value {\n                     debug!(\"Updating inferred {} (node {}) \\\n                             from {:?} to {:?} due to {:?}\",\n-                            inferred,\n-                            self.terms_cx\n-                                .inferred_infos[inferred]\n-                                .param_id,\n-                            old_value,\n-                            new_value,\n-                            term);\n+                           inferred,\n+                           self.terms_cx\n+                                   .inferred_infos[inferred]\n+                               .param_id,\n+                           old_value,\n+                           new_value,\n+                           term);\n \n                     self.solutions[inferred] = new_value;\n                     changed = true;\n@@ -114,46 +114,48 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n                 let info = &inferred_infos[index];\n                 let variance = solutions[index];\n                 debug!(\"Index {} Info {} Variance {:?}\",\n-                       index, info.index, variance);\n+                       index,\n+                       info.index,\n+                       variance);\n \n                 assert_eq!(item_variances.len(), info.index);\n                 item_variances.push(variance);\n                 index += 1;\n             }\n \n-            debug!(\"item_id={} item_variances={:?}\",\n-                    item_id,\n-                    item_variances);\n+            debug!(\"item_id={} item_variances={:?}\", item_id, item_variances);\n \n             let item_def_id = tcx.map.local_def_id(item_id);\n \n             // For unit testing: check for a special \"rustc_variance\"\n             // attribute and report an error with various results if found.\n             if tcx.has_attr(item_def_id, \"rustc_variance\") {\n-                span_err!(tcx.sess, tcx.map.span(item_id), E0208, \"{:?}\", item_variances);\n+                span_err!(tcx.sess,\n+                          tcx.map.span(item_id),\n+                          E0208,\n+                          \"{:?}\",\n+                          item_variances);\n             }\n \n-            let newly_added = tcx.item_variance_map.borrow_mut()\n-                                 .insert(item_def_id, Rc::new(item_variances)).is_none();\n+            let newly_added = tcx.item_variance_map\n+                .borrow_mut()\n+                .insert(item_def_id, Rc::new(item_variances))\n+                .is_none();\n             assert!(newly_added);\n         }\n     }\n \n     fn evaluate(&self, term: VarianceTermPtr<'a>) -> ty::Variance {\n         match *term {\n-            ConstantTerm(v) => {\n-                v\n-            }\n+            ConstantTerm(v) => v,\n \n             TransformTerm(t1, t2) => {\n                 let v1 = self.evaluate(t1);\n                 let v2 = self.evaluate(t2);\n                 v1.xform(v2)\n             }\n \n-            InferredTerm(InferredIndex(index)) => {\n-                self.solutions[index]\n-            }\n+            InferredTerm(InferredIndex(index)) => self.solutions[index],\n         }\n     }\n }"}, {"sha": "f6732f36e355aabc1647c50178fafce02c7e16af", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 42, "deletions": 44, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/c2769285ad6d078c9a4499ad9e11278e4b78023c/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2769285ad6d078c9a4499ad9e11278e4b78023c/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=c2769285ad6d078c9a4499ad9e11278e4b78023c", "patch": "@@ -49,7 +49,12 @@ impl<'a> fmt::Debug for VarianceTerm<'a> {\n         match *self {\n             ConstantTerm(c1) => write!(f, \"{:?}\", c1),\n             TransformTerm(v1, v2) => write!(f, \"({:?} \\u{00D7} {:?})\", v1, v2),\n-            InferredTerm(id) => write!(f, \"[{}]\", { let InferredIndex(i) = id; i })\n+            InferredTerm(id) => {\n+                write!(f, \"[{}]\", {\n+                    let InferredIndex(i) = id;\n+                    i\n+                })\n+            }\n         }\n     }\n }\n@@ -72,7 +77,7 @@ pub struct TermsContext<'a, 'tcx: 'a> {\n     pub inferred_map: NodeMap<InferredIndex>,\n \n     // Maps from an InferredIndex to the info for that variable.\n-    pub inferred_infos: Vec<InferredInfo<'a>> ,\n+    pub inferred_infos: Vec<InferredInfo<'a>>,\n }\n \n pub struct InferredInfo<'a> {\n@@ -87,11 +92,9 @@ pub struct InferredInfo<'a> {\n     pub initial_variance: ty::Variance,\n }\n \n-pub fn determine_parameters_to_be_inferred<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    arena: &'a mut TypedArena<VarianceTerm<'a>>)\n-    -> TermsContext<'a, 'tcx>\n-{\n+pub fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                                     arena: &'a mut TypedArena<VarianceTerm<'a>>)\n+                                                     -> TermsContext<'a, 'tcx> {\n     let mut terms_cx = TermsContext {\n         tcx: tcx,\n         arena: arena,\n@@ -102,17 +105,16 @@ pub fn determine_parameters_to_be_inferred<'a, 'tcx>(\n \n         // cache and share the variance struct used for items with\n         // no type/region parameters\n-        empty_variances: Rc::new(vec![])\n+        empty_variances: Rc::new(vec![]),\n     };\n \n     // See README.md for a discussion on dep-graph management.\n-    tcx.visit_all_items_in_krate(|def_id| ItemVariances::to_dep_node(&def_id),\n-                                 &mut terms_cx);\n+    tcx.visit_all_items_in_krate(|def_id| ItemVariances::to_dep_node(&def_id), &mut terms_cx);\n \n     terms_cx\n }\n \n-fn lang_items(tcx: TyCtxt) -> Vec<(ast::NodeId,Vec<ty::Variance>)> {\n+fn lang_items(tcx: TyCtxt) -> Vec<(ast::NodeId, Vec<ty::Variance>)> {\n     let all = vec![\n         (tcx.lang_items.phantom_data(), vec![ty::Covariant]),\n         (tcx.lang_items.unsafe_cell_type(), vec![ty::Invariant]),\n@@ -138,15 +140,13 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n     fn add_inferreds_for_item(&mut self,\n                               item_id: ast::NodeId,\n                               has_self: bool,\n-                              generics: &hir::Generics)\n-    {\n-        /*!\n-         * Add \"inferreds\" for the generic parameters declared on this\n-         * item. This has a lot of annoying parameters because we are\n-         * trying to drive this from the AST, rather than the\n-         * ty::Generics, so that we can get span info -- but this\n-         * means we must accommodate syntactic distinctions.\n-         */\n+                              generics: &hir::Generics) {\n+        //! Add \"inferreds\" for the generic parameters declared on this\n+        //! item. This has a lot of annoying parameters because we are\n+        //! trying to drive this from the AST, rather than the\n+        //! ty::Generics, so that we can get span info -- but this\n+        //! means we must accommodate syntactic distinctions.\n+        //!\n \n         // NB: In the code below for writing the results back into the\n         // tcx, we rely on the fact that all inferreds for a particular\n@@ -178,26 +178,26 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n         // parameters\".\n         if self.num_inferred() == inferreds_on_entry {\n             let item_def_id = self.tcx.map.local_def_id(item_id);\n-            let newly_added =\n-                self.tcx.item_variance_map.borrow_mut().insert(\n-                    item_def_id,\n-                    self.empty_variances.clone()).is_none();\n+            let newly_added = self.tcx\n+                .item_variance_map\n+                .borrow_mut()\n+                .insert(item_def_id, self.empty_variances.clone())\n+                .is_none();\n             assert!(newly_added);\n         }\n     }\n \n-    fn add_inferred(&mut self,\n-                    item_id: ast::NodeId,\n-                    index: usize,\n-                    param_id: ast::NodeId) {\n+    fn add_inferred(&mut self, item_id: ast::NodeId, index: usize, param_id: ast::NodeId) {\n         let inf_index = InferredIndex(self.inferred_infos.len());\n         let term = self.arena.alloc(InferredTerm(inf_index));\n         let initial_variance = self.pick_initial_variance(item_id, index);\n-        self.inferred_infos.push(InferredInfo { item_id: item_id,\n-                                                index: index,\n-                                                param_id: param_id,\n-                                                term: term,\n-                                                initial_variance: initial_variance });\n+        self.inferred_infos.push(InferredInfo {\n+            item_id: item_id,\n+            index: index,\n+            param_id: param_id,\n+            term: term,\n+            initial_variance: initial_variance,\n+        });\n         let newly_added = self.inferred_map.insert(param_id, inf_index).is_none();\n         assert!(newly_added);\n \n@@ -208,18 +208,17 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n                 inf_index={:?}, \\\n                 initial_variance={:?})\",\n                self.tcx.item_path_str(self.tcx.map.local_def_id(item_id)),\n-               item_id, index, param_id, inf_index,\n+               item_id,\n+               index,\n+               param_id,\n+               inf_index,\n                initial_variance);\n     }\n \n-    fn pick_initial_variance(&self,\n-                             item_id: ast::NodeId,\n-                             index: usize)\n-                             -> ty::Variance\n-    {\n+    fn pick_initial_variance(&self, item_id: ast::NodeId, index: usize) -> ty::Variance {\n         match self.lang_items.iter().find(|&&(n, _)| n == item_id) {\n             Some(&(_, ref variances)) => variances[index],\n-            None => ty::Bivariant\n+            None => ty::Bivariant,\n         }\n     }\n \n@@ -230,7 +229,8 @@ impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n \n impl<'a, 'tcx, 'v> Visitor<'v> for TermsContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n-        debug!(\"add_inferreds for item {}\", self.tcx.map.node_to_string(item.id));\n+        debug!(\"add_inferreds for item {}\",\n+               self.tcx.map.node_to_string(item.id));\n \n         match item.node {\n             hir::ItemEnum(_, ref generics) |\n@@ -254,9 +254,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for TermsContext<'a, 'tcx> {\n             hir::ItemFn(..) |\n             hir::ItemMod(..) |\n             hir::ItemForeignMod(..) |\n-            hir::ItemTy(..) => {\n-            }\n+            hir::ItemTy(..) => {}\n         }\n     }\n }\n-"}, {"sha": "507734ce35e44fdcf1695911ac48b7c7190b6293", "filename": "src/librustc_typeck/variance/xform.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c2769285ad6d078c9a4499ad9e11278e4b78023c/src%2Flibrustc_typeck%2Fvariance%2Fxform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2769285ad6d078c9a4499ad9e11278e4b78023c/src%2Flibrustc_typeck%2Fvariance%2Fxform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fxform.rs?ref=c2769285ad6d078c9a4499ad9e11278e4b78023c", "patch": "@@ -47,7 +47,8 @@ pub fn glb(v1: ty::Variance, v2: ty::Variance) -> ty::Variance {\n     //    -     +\n     //       o\n     match (v1, v2) {\n-        (ty::Invariant, _) | (_, ty::Invariant) => ty::Invariant,\n+        (ty::Invariant, _) |\n+        (_, ty::Invariant) => ty::Invariant,\n \n         (ty::Covariant, ty::Contravariant) => ty::Invariant,\n         (ty::Contravariant, ty::Covariant) => ty::Invariant,\n@@ -56,6 +57,7 @@ pub fn glb(v1: ty::Variance, v2: ty::Variance) -> ty::Variance {\n \n         (ty::Contravariant, ty::Contravariant) => ty::Contravariant,\n \n-        (x, ty::Bivariant) | (ty::Bivariant, x) => x,\n+        (x, ty::Bivariant) |\n+        (ty::Bivariant, x) => x,\n     }\n }"}]}