{"sha": "6e2ae2c2c131bfbf2d8ab1b8ff9874e23abb7003", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlMmFlMmMyYzEzMWJmYmYyZDhhYjFiOGZmOTg3NGUyM2FiYjcwMDM=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-01-18T06:21:07Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-01-25T00:24:30Z"}, "message": "remove support for records from auto_encode", "tree": {"sha": "69811508877a62752be0ab6a4d239ffaba37b34f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69811508877a62752be0ab6a4d239ffaba37b34f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e2ae2c2c131bfbf2d8ab1b8ff9874e23abb7003", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e2ae2c2c131bfbf2d8ab1b8ff9874e23abb7003", "html_url": "https://github.com/rust-lang/rust/commit/6e2ae2c2c131bfbf2d8ab1b8ff9874e23abb7003", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e2ae2c2c131bfbf2d8ab1b8ff9874e23abb7003/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ff6beed60fe3a1b783968deda9b5ca99afbeba6", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ff6beed60fe3a1b783968deda9b5ca99afbeba6", "html_url": "https://github.com/rust-lang/rust/commit/5ff6beed60fe3a1b783968deda9b5ca99afbeba6"}], "stats": {"total": 285, "additions": 91, "deletions": 194}, "files": [{"sha": "77f230311358e8a851927c96ed9b6515572ca053", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 75, "deletions": 182, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/6e2ae2c2c131bfbf2d8ab1b8ff9874e23abb7003/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2ae2c2c131bfbf2d8ab1b8ff9874e23abb7003/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=6e2ae2c2c131bfbf2d8ab1b8ff9874e23abb7003", "patch": "@@ -130,20 +130,6 @@ fn expand_auto_encode(\n     do vec::flat_map(in_items) |item| {\n         if item.attrs.any(is_auto_encode) {\n             match item.node {\n-                ast::item_ty(\n-                    @ast::Ty {node: ast::ty_rec(ref fields), _},\n-                    tps\n-                ) => {\n-                    let ser_impl = mk_rec_ser_impl(\n-                        cx,\n-                        item.span,\n-                        item.ident,\n-                        (*fields),\n-                        tps\n-                    );\n-\n-                    ~[filter_attrs(*item), ser_impl]\n-                },\n                 ast::item_struct(@ast::struct_def { fields, _}, tps) => {\n                     let ser_impl = mk_struct_ser_impl(\n                         cx,\n@@ -199,20 +185,6 @@ fn expand_auto_decode(\n     do vec::flat_map(in_items) |item| {\n         if item.attrs.any(is_auto_decode) {\n             match item.node {\n-                ast::item_ty(\n-                    @ast::Ty {node: ast::ty_rec(ref fields), _},\n-                    tps\n-                ) => {\n-                    let deser_impl = mk_rec_deser_impl(\n-                        cx,\n-                        item.span,\n-                        item.ident,\n-                        (*fields),\n-                        tps\n-                    );\n-\n-                    ~[filter_attrs(*item), deser_impl]\n-                },\n                 ast::item_struct(@ast::struct_def { fields, _}, tps) => {\n                     let deser_impl = mk_struct_deser_impl(\n                         cx,\n@@ -693,67 +665,48 @@ fn mk_deser_method(\n     }\n }\n \n-fn mk_rec_ser_impl(\n-    cx: ext_ctxt,\n-    span: span,\n-    ident: ast::ident,\n-    fields: ~[ast::ty_field],\n-    tps: ~[ast::ty_param]\n-) -> @ast::item {\n-    let fields = mk_ser_fields(cx, span, mk_rec_fields(fields));\n-\n-    // ast for `__s.emit_rec(|| $(fields))`\n-    let body = cx.expr_call(\n-        span,\n-        cx.expr_field(\n-            span,\n-            cx.expr_var(span, ~\"__s\"),\n-            cx.ident_of(~\"emit_rec\")\n-        ),\n-        ~[cx.lambda_stmts(span, fields)]\n-    );\n-\n-    mk_ser_impl(cx, span, ident, tps, body)\n-}\n-\n-fn mk_rec_deser_impl(\n+fn mk_struct_ser_impl(\n     cx: ext_ctxt,\n     span: span,\n     ident: ast::ident,\n-    fields: ~[ast::ty_field],\n+    fields: ~[@ast::struct_field],\n     tps: ~[ast::ty_param]\n ) -> @ast::item {\n-    let fields = mk_deser_fields(cx, span, mk_rec_fields(fields));\n-\n-    // ast for `read_rec(|| $(fields))`\n-    let body = cx.expr_call(\n-        span,\n-        cx.expr_field(\n-            span,\n-            cx.expr_var(span, ~\"__d\"),\n-            cx.ident_of(~\"read_rec\")\n-        ),\n-        ~[\n-            cx.lambda_expr(\n-                cx.expr(\n+    let fields = do mk_struct_fields(fields).mapi |idx, field| {\n+        // ast for `|| self.$(name).encode(__s)`\n+        let expr_lambda = cx.lambda_expr(\n+            cx.expr_call(\n+                span,\n+                cx.expr_field(\n                     span,\n-                    ast::expr_rec(fields, None)\n-                )\n+                    cx.expr_field(\n+                        span,\n+                        cx.expr_var(span, ~\"self\"),\n+                        field.ident\n+                    ),\n+                    cx.ident_of(~\"encode\")\n+                ),\n+                ~[cx.expr_var(span, ~\"__s\")]\n             )\n-        ]\n-    );\n-\n-    mk_deser_impl(cx, span, ident, tps, body)\n-}\n+        );\n \n-fn mk_struct_ser_impl(\n-    cx: ext_ctxt,\n-    span: span,\n-    ident: ast::ident,\n-    fields: ~[@ast::struct_field],\n-    tps: ~[ast::ty_param]\n-) -> @ast::item {\n-    let fields = mk_ser_fields(cx, span, mk_struct_fields(fields));\n+        // ast for `__s.emit_field($(name), $(idx), $(expr_lambda))`\n+        cx.stmt(\n+            cx.expr_call(\n+                span,\n+                cx.expr_field(\n+                    span,\n+                    cx.expr_var(span, ~\"__s\"),\n+                    cx.ident_of(~\"emit_field\")\n+                ),\n+                ~[\n+                    cx.lit_str(span, @cx.str_of(field.ident)),\n+                    cx.lit_uint(span, idx),\n+                    expr_lambda,\n+                ]\n+            )\n+        )\n+    };\n \n     // ast for `__s.emit_struct($(name), || $(fields))`\n     let ser_body = cx.expr_call(\n@@ -780,7 +733,47 @@ fn mk_struct_deser_impl(\n     fields: ~[@ast::struct_field],\n     tps: ~[ast::ty_param]\n ) -> @ast::item {\n-    let fields = mk_deser_fields(cx, span, mk_struct_fields(fields));\n+    let fields = do mk_struct_fields(fields).mapi |idx, field| {\n+        // ast for `|| std::serialize::decode(__d)`\n+        let expr_lambda = cx.lambda(\n+            cx.expr_blk(\n+                cx.expr_call(\n+                    span,\n+                    cx.expr_path_global(span, ~[\n+                        cx.ident_of(~\"std\"),\n+                        cx.ident_of(~\"serialize\"),\n+                        cx.ident_of(~\"Decodable\"),\n+                        cx.ident_of(~\"decode\"),\n+                    ]),\n+                    ~[cx.expr_var(span, ~\"__d\")]\n+                )\n+            )\n+        );\n+\n+        // ast for `__d.read_field($(name), $(idx), $(expr_lambda))`\n+        let expr: @ast::expr = cx.expr_call(\n+            span,\n+            cx.expr_field(\n+                span,\n+                cx.expr_var(span, ~\"__d\"),\n+                cx.ident_of(~\"read_field\")\n+            ),\n+            ~[\n+                cx.lit_str(span, @cx.str_of(field.ident)),\n+                cx.lit_uint(span, idx),\n+                expr_lambda,\n+            ]\n+        );\n+\n+        ast::spanned {\n+            node: ast::field_ {\n+                mutbl: field.mutbl,\n+                ident: field.ident,\n+                expr: expr,\n+            },\n+            span: span,\n+        }\n+    };\n \n     // ast for `read_struct($(name), || $(fields))`\n     let body = cx.expr_call(\n@@ -818,16 +811,6 @@ struct field {\n     mutbl: ast::mutability,\n }\n \n-fn mk_rec_fields(fields: ~[ast::ty_field]) -> ~[field] {\n-    do fields.map |field| {\n-        field {\n-            span: field.span,\n-            ident: field.node.ident,\n-            mutbl: field.node.mt.mutbl,\n-        }\n-    }\n-}\n-\n fn mk_struct_fields(fields: ~[@ast::struct_field]) -> ~[field] {\n     do fields.map |field| {\n         let (ident, mutbl) = match field.node.kind {\n@@ -847,96 +830,6 @@ fn mk_struct_fields(fields: ~[@ast::struct_field]) -> ~[field] {\n     }\n }\n \n-fn mk_ser_fields(\n-    cx: ext_ctxt,\n-    span: span,\n-    fields: ~[field]\n-) -> ~[@ast::stmt] {\n-    do fields.mapi |idx, field| {\n-        // ast for `|| self.$(name).encode(__s)`\n-        let expr_lambda = cx.lambda_expr(\n-            cx.expr_call(\n-                span,\n-                cx.expr_field(\n-                    span,\n-                    cx.expr_field(\n-                        span,\n-                        cx.expr_var(span, ~\"self\"),\n-                        field.ident\n-                    ),\n-                    cx.ident_of(~\"encode\")\n-                ),\n-                ~[cx.expr_var(span, ~\"__s\")]\n-            )\n-        );\n-\n-        // ast for `__s.emit_field($(name), $(idx), $(expr_lambda))`\n-        cx.stmt(\n-            cx.expr_call(\n-                span,\n-                cx.expr_field(\n-                    span,\n-                    cx.expr_var(span, ~\"__s\"),\n-                    cx.ident_of(~\"emit_field\")\n-                ),\n-                ~[\n-                    cx.lit_str(span, @cx.str_of(field.ident)),\n-                    cx.lit_uint(span, idx),\n-                    expr_lambda,\n-                ]\n-            )\n-        )\n-    }\n-}\n-\n-fn mk_deser_fields(\n-    cx: ext_ctxt,\n-    span: span,\n-    fields: ~[field]\n-) -> ~[ast::field] {\n-    do fields.mapi |idx, field| {\n-        // ast for `|| std::serialize::decode(__d)`\n-        let expr_lambda = cx.lambda(\n-            cx.expr_blk(\n-                cx.expr_call(\n-                    span,\n-                    cx.expr_path_global(span, ~[\n-                        cx.ident_of(~\"std\"),\n-                        cx.ident_of(~\"serialize\"),\n-                        cx.ident_of(~\"Decodable\"),\n-                        cx.ident_of(~\"decode\"),\n-                    ]),\n-                    ~[cx.expr_var(span, ~\"__d\")]\n-                )\n-            )\n-        );\n-\n-        // ast for `__d.read_field($(name), $(idx), $(expr_lambda))`\n-        let expr: @ast::expr = cx.expr_call(\n-            span,\n-            cx.expr_field(\n-                span,\n-                cx.expr_var(span, ~\"__d\"),\n-                cx.ident_of(~\"read_field\")\n-            ),\n-            ~[\n-                cx.lit_str(span, @cx.str_of(field.ident)),\n-                cx.lit_uint(span, idx),\n-                expr_lambda,\n-            ]\n-        );\n-\n-        ast::spanned {\n-            node: ast::field_ {\n-                mutbl: field.mutbl,\n-                ident: field.ident,\n-                expr: expr,\n-            },\n-            span: span,\n-        }\n-    }\n-}\n-\n fn mk_enum_ser_impl(\n     cx: ext_ctxt,\n     span: span,"}, {"sha": "6ea08d200e77d0bebb757c42ee308c79234044bb", "filename": "src/test/run-pass/auto-encode.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6e2ae2c2c131bfbf2d8ab1b8ff9874e23abb7003/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e2ae2c2c131bfbf2d8ab1b8ff9874e23abb7003/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-encode.rs?ref=6e2ae2c2c131bfbf2d8ab1b8ff9874e23abb7003", "patch": "@@ -123,29 +123,33 @@ impl CLike : cmp::Eq {\n     pure fn eq(&self, other: &CLike) -> bool {\n         (*self) as int == *other as int\n     }\n-    pure fn ne(&self, other: &CLike) -> bool { !(*self).eq(other) }\n+    pure fn ne(&self, other: &CLike) -> bool { !self.eq(other) }\n }\n \n #[auto_encode]\n #[auto_decode]\n-type Spanned<T> = {lo: uint, hi: uint, node: T};\n+struct Spanned<T> {\n+    lo: uint,\n+    hi: uint,\n+    node: T,\n+}\n \n impl<T:cmp::Eq> Spanned<T> : cmp::Eq {\n     pure fn eq(&self, other: &Spanned<T>) -> bool {\n-        (*self).lo == other.lo &&\n-        (*self).hi == other.hi &&\n-        (*self).node == other.node\n+        self.lo == other.lo &&\n+        self.hi == other.hi &&\n+        self.node == other.node\n     }\n-    pure fn ne(&self, other: &Spanned<T>) -> bool { !(*self).eq(other) }\n+    pure fn ne(&self, other: &Spanned<T>) -> bool { !self.eq(other) }\n }\n \n #[auto_encode]\n #[auto_decode]\n-type SomeRec = {v: ~[uint]};\n+struct SomeStruct { v: ~[uint] }\n \n #[auto_encode]\n #[auto_decode]\n-enum AnEnum = SomeRec;\n+enum AnEnum = SomeStruct;\n \n #[auto_encode]\n #[auto_decode]\n@@ -168,12 +172,12 @@ fn main() {\n                            @Plus(@Val(22u), @Val(5u)))\");\n     test_ebml(a);\n \n-    let a = &{lo: 0u, hi: 5u, node: 22u};\n-    test_prettyprint(a, &~\"{lo: 0u, hi: 5u, node: 22u}\");\n+    let a = &Spanned {lo: 0u, hi: 5u, node: 22u};\n+    test_prettyprint(a, &~\"Spanned {lo: 0u, hi: 5u, node: 22u}\");\n     test_ebml(a);\n \n-    let a = &AnEnum({v: ~[1u, 2u, 3u]});\n-    test_prettyprint(a, &~\"AnEnum({v: ~[1u, 2u, 3u]})\");\n+    let a = &AnEnum(SomeStruct {v: ~[1u, 2u, 3u]});\n+    test_prettyprint(a, &~\"AnEnum(SomeStruct {v: ~[1u, 2u, 3u]})\");\n     test_ebml(a);\n \n     let a = &Point {x: 3u, y: 5u};"}]}