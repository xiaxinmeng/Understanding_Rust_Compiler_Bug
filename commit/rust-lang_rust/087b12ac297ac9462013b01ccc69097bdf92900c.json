{"sha": "087b12ac297ac9462013b01ccc69097bdf92900c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4N2IxMmFjMjk3YWM5NDYyMDEzYjAxY2NjNjkwOTdiZGY5MjkwMGM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-20T04:33:51Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-20T04:58:45Z"}, "message": "syntax: Reorganize mod parse", "tree": {"sha": "8d4cc82d03dc3d70966a9c8af65064395170fe73", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d4cc82d03dc3d70966a9c8af65064395170fe73"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/087b12ac297ac9462013b01ccc69097bdf92900c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/087b12ac297ac9462013b01ccc69097bdf92900c", "html_url": "https://github.com/rust-lang/rust/commit/087b12ac297ac9462013b01ccc69097bdf92900c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/087b12ac297ac9462013b01ccc69097bdf92900c/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7fa7e56341a222fd0984e8be7569915a8a90ae33", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fa7e56341a222fd0984e8be7569915a8a90ae33", "html_url": "https://github.com/rust-lang/rust/commit/7fa7e56341a222fd0984e8be7569915a8a90ae33"}], "stats": {"total": 152, "additions": 77, "deletions": 75}, "files": [{"sha": "4a04fe7850cb15c6381ef1bbd67b356c447fcf76", "filename": "src/librustsyntax/parse.rs", "status": "modified", "additions": 77, "deletions": 75, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/087b12ac297ac9462013b01ccc69097bdf92900c/src%2Flibrustsyntax%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/087b12ac297ac9462013b01ccc69097bdf92900c/src%2Flibrustsyntax%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse.rs?ref=087b12ac297ac9462013b01ccc69097bdf92900c", "patch": "@@ -1,3 +1,5 @@\n+#[doc = \"The main parser interface\"];\n+\n export parse_sess;\n export next_node_id;\n export new_parser_from_file;\n@@ -22,63 +24,16 @@ type parse_sess = @{\n     mut byte_pos: uint\n };\n \n-fn next_node_id(sess: parse_sess) -> node_id {\n-    let rv = sess.next_id;\n-    sess.next_id += 1;\n-    // ID 0 is reserved for the crate and doesn't actually exist in the AST\n-    assert rv != 0;\n-    ret rv;\n-}\n-\n-fn new_parser_from_file(sess: parse_sess, cfg: ast::crate_cfg, path: str,\n-                        ftype: parser::file_type) ->\n-   parser {\n-    let src = alt io::read_whole_file_str(path) {\n-      result::ok(src) {\n-        // FIXME: This copy is unfortunate\n-        @src\n-      }\n-      result::err(e) {\n-        sess.span_diagnostic.handler().fatal(e)\n-      }\n-    };\n-    let filemap = codemap::new_filemap(path, src,\n-                                       sess.chpos, sess.byte_pos);\n-    sess.cm.files += [filemap];\n-    let itr = @interner::mk(str::hash, str::eq);\n-    let rdr = lexer::new_reader(sess.span_diagnostic, filemap, itr);\n-    ret new_parser(sess, cfg, rdr, ftype);\n-}\n-\n-fn new_parser_from_source_str(sess: parse_sess, cfg: ast::crate_cfg,\n-                              name: str, ss: codemap::file_substr,\n-                              source: @str) -> parser {\n-    let ftype = parser::SOURCE_FILE;\n-    let filemap = codemap::new_filemap_w_substr\n-        (name, ss, source, sess.chpos, sess.byte_pos);\n-    sess.cm.files += [filemap];\n-    let itr = @interner::mk(str::hash, str::eq);\n-    let rdr = lexer::new_reader(sess.span_diagnostic,\n-                                filemap, itr);\n-    ret new_parser(sess, cfg, rdr, ftype);\n-}\n-\n-fn new_parser(sess: parse_sess, cfg: ast::crate_cfg, rdr: lexer::reader,\n-              ftype: parser::file_type) -> parser {\n-    let tok0 = lexer::next_token(rdr);\n-    let span0 = ast_util::mk_sp(tok0.chpos, rdr.chpos);\n-    @{sess: sess,\n-      cfg: cfg,\n-      file_type: ftype,\n-      mut token: tok0.tok,\n-      mut span: span0,\n-      mut last_span: span0,\n-      mut buffer: [],\n-      mut restriction: parser::UNRESTRICTED,\n-      reader: rdr,\n-      binop_precs: prec::binop_prec_table(),\n-      keywords: token::keyword_table(),\n-      bad_expr_words: token::bad_expr_word_table()}\n+fn parse_crate_from_file(input: str, cfg: ast::crate_cfg, sess: parse_sess) ->\n+   @ast::crate {\n+    if str::ends_with(input, \".rc\") {\n+        parse_crate_from_crate_file(input, cfg, sess)\n+    } else if str::ends_with(input, \".rs\") {\n+        parse_crate_from_source_file(input, cfg, sess)\n+    } else {\n+        sess.span_diagnostic.handler().fatal(\"unknown input file type: \" +\n+                                             input)\n+    }\n }\n \n fn parse_crate_from_crate_file(input: str, cfg: ast::crate_cfg,\n@@ -109,18 +64,6 @@ fn parse_crate_from_crate_file(input: str, cfg: ast::crate_cfg,\n                            config: p.cfg});\n }\n \n-fn parse_crate_from_file(input: str, cfg: ast::crate_cfg, sess: parse_sess) ->\n-   @ast::crate {\n-    if str::ends_with(input, \".rc\") {\n-        parse_crate_from_crate_file(input, cfg, sess)\n-    } else if str::ends_with(input, \".rs\") {\n-        parse_crate_from_source_file(input, cfg, sess)\n-    } else {\n-        sess.span_diagnostic.handler().fatal(\"unknown input file type: \" +\n-                                             input)\n-    }\n-}\n-\n fn parse_crate_from_source_file(input: str, cfg: ast::crate_cfg,\n                                 sess: parse_sess) -> @ast::crate {\n     let p = new_parser_from_file(sess, cfg, input, parser::SOURCE_FILE);\n@@ -130,21 +73,21 @@ fn parse_crate_from_source_file(input: str, cfg: ast::crate_cfg,\n     ret r;\n }\n \n-fn parse_expr_from_source_str(name: str, source: @str, cfg: ast::crate_cfg,\n-                              sess: parse_sess) -> @ast::expr {\n+fn parse_crate_from_source_str(name: str, source: @str, cfg: ast::crate_cfg,\n+                               sess: parse_sess) -> @ast::crate {\n     let p = new_parser_from_source_str(\n         sess, cfg, name, codemap::fss_none, source);\n-    let r = parser::parse_expr(p);\n+    let r = parser::parse_crate_mod(p, cfg);\n     sess.chpos = p.reader.chpos;\n     sess.byte_pos = sess.byte_pos + p.reader.pos;\n     ret r;\n }\n \n-fn parse_crate_from_source_str(name: str, source: @str, cfg: ast::crate_cfg,\n-                               sess: parse_sess) -> @ast::crate {\n+fn parse_expr_from_source_str(name: str, source: @str, cfg: ast::crate_cfg,\n+                              sess: parse_sess) -> @ast::expr {\n     let p = new_parser_from_source_str(\n         sess, cfg, name, codemap::fss_none, source);\n-    let r = parser::parse_crate_mod(p, cfg);\n+    let r = parser::parse_expr(p);\n     sess.chpos = p.reader.chpos;\n     sess.byte_pos = sess.byte_pos + p.reader.pos;\n     ret r;\n@@ -165,3 +108,62 @@ fn parse_from_source_str<T>(f: fn (p: parser) -> T,\n     sess.byte_pos = sess.byte_pos + p.reader.pos;\n     ret r;\n }\n+\n+fn next_node_id(sess: parse_sess) -> node_id {\n+    let rv = sess.next_id;\n+    sess.next_id += 1;\n+    // ID 0 is reserved for the crate and doesn't actually exist in the AST\n+    assert rv != 0;\n+    ret rv;\n+}\n+\n+fn new_parser(sess: parse_sess, cfg: ast::crate_cfg, rdr: lexer::reader,\n+              ftype: parser::file_type) -> parser {\n+    let tok0 = lexer::next_token(rdr);\n+    let span0 = ast_util::mk_sp(tok0.chpos, rdr.chpos);\n+    @{sess: sess,\n+      cfg: cfg,\n+      file_type: ftype,\n+      mut token: tok0.tok,\n+      mut span: span0,\n+      mut last_span: span0,\n+      mut buffer: [],\n+      mut restriction: parser::UNRESTRICTED,\n+      reader: rdr,\n+      binop_precs: prec::binop_prec_table(),\n+      keywords: token::keyword_table(),\n+      bad_expr_words: token::bad_expr_word_table()}\n+}\n+\n+fn new_parser_from_source_str(sess: parse_sess, cfg: ast::crate_cfg,\n+                              name: str, ss: codemap::file_substr,\n+                              source: @str) -> parser {\n+    let ftype = parser::SOURCE_FILE;\n+    let filemap = codemap::new_filemap_w_substr\n+        (name, ss, source, sess.chpos, sess.byte_pos);\n+    sess.cm.files += [filemap];\n+    let itr = @interner::mk(str::hash, str::eq);\n+    let rdr = lexer::new_reader(sess.span_diagnostic,\n+                                filemap, itr);\n+    ret new_parser(sess, cfg, rdr, ftype);\n+}\n+\n+fn new_parser_from_file(sess: parse_sess, cfg: ast::crate_cfg, path: str,\n+                        ftype: parser::file_type) ->\n+   parser {\n+    let src = alt io::read_whole_file_str(path) {\n+      result::ok(src) {\n+        // FIXME: This copy is unfortunate\n+        @src\n+      }\n+      result::err(e) {\n+        sess.span_diagnostic.handler().fatal(e)\n+      }\n+    };\n+    let filemap = codemap::new_filemap(path, src,\n+                                       sess.chpos, sess.byte_pos);\n+    sess.cm.files += [filemap];\n+    let itr = @interner::mk(str::hash, str::eq);\n+    let rdr = lexer::new_reader(sess.span_diagnostic, filemap, itr);\n+    ret new_parser(sess, cfg, rdr, ftype);\n+}"}]}