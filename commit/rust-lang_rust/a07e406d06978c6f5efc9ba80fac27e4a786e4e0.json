{"sha": "a07e406d06978c6f5efc9ba80fac27e4a786e4e0", "node_id": "C_kwDOAAsO6NoAKGEwN2U0MDZkMDY5NzhjNmY1ZWZjOWJhODBmYWMyN2U0YTc4NmU0ZTA", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-11-22T17:01:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-11-22T17:01:40Z"}, "message": "Merge #10839\n\n10839: fix: Fix mbe::Shift::new not accounting for non-ident token ids r=Veykril a=Veykril\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/9371\r\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "50978a2d900cd85b46e8eff6fbf824c89868073e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50978a2d900cd85b46e8eff6fbf824c89868073e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a07e406d06978c6f5efc9ba80fac27e4a786e4e0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhm8z0CRBK7hj4Ov3rIwAAWycIAAyPe4367HaGWTW3aPUX658W\n+rloCvrKeCa3Zzp9c9YnupL3gNibnIzYsmdGQLboEARLsqA2UuKKlYUwF2M/gBs7\nC+S/C5Y2aqHNcbFut+QYT8Y+xwKYDrMaAlAQvkdUeBHcH6BGBPq+CjjI3pq//LtN\nNZ1BPcJQs+ofqKY3J9TJLB0ndGMdc0mbUA/jHG7kSUv7XDWW6Y5DyrfJu7++2pKp\nhqpdcEAlZxalUSoiNdAHFglTCwBdg5rBwgk56E6PJqOgYRjg1Fh/a5yFZo6Bfwpo\nH2h+6Udfx13jblwSodzxOEu2NAiymWjWvldbFO9DGmlWpLrHkj0YbUEYU0Z4KVw=\n=C01y\n-----END PGP SIGNATURE-----\n", "payload": "tree 50978a2d900cd85b46e8eff6fbf824c89868073e\nparent a0f01ec14e4f7ead2153c62f189ad85a34ae513c\nparent a9c4c6da4cf7f7907b0b0a00b896fcb4b128ec2d\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1637600500 +0000\ncommitter GitHub <noreply@github.com> 1637600500 +0000\n\nMerge #10839\n\n10839: fix: Fix mbe::Shift::new not accounting for non-ident token ids r=Veykril a=Veykril\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/9371\r\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a07e406d06978c6f5efc9ba80fac27e4a786e4e0", "html_url": "https://github.com/rust-lang/rust/commit/a07e406d06978c6f5efc9ba80fac27e4a786e4e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a07e406d06978c6f5efc9ba80fac27e4a786e4e0/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a0f01ec14e4f7ead2153c62f189ad85a34ae513c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0f01ec14e4f7ead2153c62f189ad85a34ae513c", "html_url": "https://github.com/rust-lang/rust/commit/a0f01ec14e4f7ead2153c62f189ad85a34ae513c"}, {"sha": "a9c4c6da4cf7f7907b0b0a00b896fcb4b128ec2d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9c4c6da4cf7f7907b0b0a00b896fcb4b128ec2d", "html_url": "https://github.com/rust-lang/rust/commit/a9c4c6da4cf7f7907b0b0a00b896fcb4b128ec2d"}], "stats": {"total": 90, "additions": 62, "deletions": 28}, "files": [{"sha": "466c85fc5b092f0c80377a557b6008936575e196", "filename": "crates/hir_def/src/macro_expansion_tests/mbe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a07e406d06978c6f5efc9ba80fac27e4a786e4e0/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07e406d06978c6f5efc9ba80fac27e4a786e4e0/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fmacro_expansion_tests%2Fmbe.rs?ref=a07e406d06978c6f5efc9ba80fac27e4a786e4e0", "patch": "@@ -27,7 +27,7 @@ macro_rules! f {\n f!(struct MyTraitMap2);\n \"#,\n         expect![[r##\"\n-// call ids will be shifted by Shift(27)\n+// call ids will be shifted by Shift(30)\n // +tokenids\n macro_rules! f {#0\n     (#1 struct#2 $#3ident#4:#5ident#6 )#1 =#7>#8 {#9\n@@ -39,7 +39,7 @@ macro_rules! f {#0\n \n // // +tokenids\n // f!(struct#1 MyTraitMap2#2);\n-struct#10 MyTraitMap2#29 {#13\n+struct#10 MyTraitMap2#32 {#13\n     map#14:#15 ::std#18::collections#21::HashSet#24<#25(#26)#26>#27,#28\n }#13\n \"##]],"}, {"sha": "bca380a4d6f8e6c660d2f07393ed958068eb8b6b", "filename": "crates/hir_expand/src/lib.rs", "status": "modified", "additions": 52, "deletions": 21, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/a07e406d06978c6f5efc9ba80fac27e4a786e4e0/crates%2Fhir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07e406d06978c6f5efc9ba80fac27e4a786e4e0/crates%2Fhir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Flib.rs?ref=a07e406d06978c6f5efc9ba80fac27e4a786e4e0", "patch": "@@ -279,6 +279,13 @@ impl HirFileId {\n     pub fn is_macro(self) -> bool {\n         matches!(self.0, HirFileIdRepr::MacroFile(_))\n     }\n+\n+    pub fn macro_file(self) -> Option<MacroFile> {\n+        match self.0 {\n+            HirFileIdRepr::FileId(_) => None,\n+            HirFileIdRepr::MacroFile(m) => Some(m),\n+        }\n+    }\n }\n \n impl MacroDefId {\n@@ -377,6 +384,8 @@ pub struct ExpansionInfo {\n \n     macro_def: Arc<TokenExpander>,\n     macro_arg: Arc<(tt::Subtree, mbe::TokenMap)>,\n+    /// A shift built from `macro_arg`'s subtree, relevant for attributes as the item is the macro arg\n+    /// and as such we need to shift tokens if they are part of an attributes input instead of their item.\n     macro_arg_shift: mbe::Shift,\n     exp_map: Arc<mbe::TokenMap>,\n }\n@@ -390,19 +399,31 @@ impl ExpansionInfo {\n         Some(self.arg.with_value(self.arg.value.parent()?))\n     }\n \n+    /// Map a token down from macro input into the macro expansion.\n+    ///\n+    /// The inner workings of this function differ slightly depending on the type of macro we are dealing with:\n+    /// - declarative:\n+    ///     For declarative macros, we need to accommodate for the macro definition site(which acts as a second unchanging input)\n+    ///     , as tokens can mapped in and out of it.\n+    ///     To do this we shift all ids in the expansion by the maximum id of the definition site giving us an easy\n+    ///     way to map all the tokens.\n+    /// - attribute:\n+    ///     Attributes have two different inputs, the input tokentree in the attribute node and the item\n+    ///     the attribute is annotating. Similarly as for declarative macros we need to do a shift here\n+    ///     as well. Currently this is done by shifting the attribute input by the maximum id of the item.\n+    /// - function-like and derives:\n+    ///     Both of these only have one simple call site input so no special handling is required here.\n     pub fn map_token_down(\n         &self,\n         db: &dyn db::AstDatabase,\n         item: Option<ast::Item>,\n         token: InFile<&SyntaxToken>,\n     ) -> Option<impl Iterator<Item = InFile<SyntaxToken>> + '_> {\n         assert_eq!(token.file_id, self.arg.file_id);\n-        let token_id = if let Some(item) = item {\n+        let token_id_in_attr_input = if let Some(item) = item {\n             // check if we are mapping down in an attribute input\n-            let call_id = match self.expanded.file_id.0 {\n-                HirFileIdRepr::FileId(_) => return None,\n-                HirFileIdRepr::MacroFile(macro_file) => macro_file.macro_call_id,\n-            };\n+            // this is a special case as attributes can have two inputs\n+            let call_id = self.expanded.file_id.macro_file()?.macro_call_id;\n             let loc = db.lookup_intern_macro_call(call_id);\n \n             let token_range = token.value.text_range();\n@@ -415,9 +436,12 @@ impl ExpansionInfo {\n                         {\n                             let attr_input_start =\n                                 token_tree.left_delimiter_token()?.text_range().start();\n-                            let range = token.value.text_range().checked_sub(attr_input_start)?;\n-                            let token_id =\n-                                self.macro_arg_shift.shift(attr_args.1.token_by_range(range)?);\n+                            let relative_range =\n+                                token.value.text_range().checked_sub(attr_input_start)?;\n+                            // shift by the item's tree's max id\n+                            let token_id = self\n+                                .macro_arg_shift\n+                                .shift(attr_args.1.token_by_range(relative_range)?);\n                             Some(token_id)\n                         }\n                         _ => None,\n@@ -429,12 +453,14 @@ impl ExpansionInfo {\n             None\n         };\n \n-        let token_id = match token_id {\n+        let token_id = match token_id_in_attr_input {\n             Some(token_id) => token_id,\n+            // the token is not inside an attribute's input so do the lookup in the macro_arg as ususal\n             None => {\n-                let range =\n+                let relative_range =\n                     token.value.text_range().checked_sub(self.arg.value.text_range().start())?;\n-                let token_id = self.macro_arg.1.token_by_range(range)?;\n+                let token_id = self.macro_arg.1.token_by_range(relative_range)?;\n+                // conditionally shift the id by a declaratives macro definition\n                 self.macro_def.map_id_down(token_id)\n             }\n         };\n@@ -447,28 +473,33 @@ impl ExpansionInfo {\n         Some(tokens.map(move |token| self.expanded.with_value(token)))\n     }\n \n+    /// Map a token up out of the expansion it resides in into the arguments of the macro call of the expansion.\n     pub fn map_token_up(\n         &self,\n         db: &dyn db::AstDatabase,\n         token: InFile<&SyntaxToken>,\n     ) -> Option<(InFile<SyntaxToken>, Origin)> {\n+        // Fetch the id through its text range,\n         let token_id = self.exp_map.token_by_range(token.value.text_range())?;\n+        // conditionally unshifting the id to accommodate for macro-rules def site\n         let (mut token_id, origin) = self.macro_def.map_id_up(token_id);\n \n-        let call_id = match self.expanded.file_id.0 {\n-            HirFileIdRepr::FileId(_) => return None,\n-            HirFileIdRepr::MacroFile(macro_file) => macro_file.macro_call_id,\n-        };\n+        let call_id = self.expanded.file_id.macro_file()?.macro_call_id;\n         let loc = db.lookup_intern_macro_call(call_id);\n \n+        // Attributes are a bit special for us, they have two inputs, the input tokentree and the annotated item.\n         let (token_map, tt) = match &loc.kind {\n-            MacroCallKind::Attr { attr_args, .. } => match self.macro_arg_shift.unshift(token_id) {\n-                Some(unshifted) => {\n-                    token_id = unshifted;\n-                    (&attr_args.1, self.attr_input_or_mac_def.clone()?.syntax().cloned())\n+            MacroCallKind::Attr { attr_args: (_, arg_token_map), .. } => {\n+                // try unshifting the the token id, if unshifting fails, the token resides in the non-item attribute input\n+                // note that the `TokenExpander::map_id_up` earlier only unshifts for declarative macros, so we don't double unshift with this\n+                match self.macro_arg_shift.unshift(token_id) {\n+                    Some(unshifted) => {\n+                        token_id = unshifted;\n+                        (arg_token_map, self.attr_input_or_mac_def.clone()?.syntax().cloned())\n+                    }\n+                    None => (&self.macro_arg.1, self.arg.clone()),\n                 }\n-                None => (&self.macro_arg.1, self.arg.clone()),\n-            },\n+            }\n             _ => match origin {\n                 mbe::Origin::Call => (&self.macro_arg.1, self.arg.clone()),\n                 mbe::Origin::Def => match (&*self.macro_def, &self.attr_input_or_mac_def) {"}, {"sha": "b58b86b38d665e0476c2eedab4f5857b6f252f28", "filename": "crates/mbe/src/lib.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a07e406d06978c6f5efc9ba80fac27e4a786e4e0/crates%2Fmbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07e406d06978c6f5efc9ba80fac27e4a786e4e0/crates%2Fmbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Flib.rs?ref=a07e406d06978c6f5efc9ba80fac27e4a786e4e0", "patch": "@@ -120,12 +120,15 @@ impl Shift {\n                             _ => tree_id,\n                         }\n                     }\n-                    tt::TokenTree::Leaf(tt::Leaf::Ident(ident))\n-                        if ident.id != tt::TokenId::unspecified() =>\n-                    {\n-                        Some(ident.id.0)\n+                    tt::TokenTree::Leaf(leaf) => {\n+                        let id = match leaf {\n+                            tt::Leaf::Literal(it) => it.id,\n+                            tt::Leaf::Punct(it) => it.id,\n+                            tt::Leaf::Ident(it) => it.id,\n+                        };\n+\n+                        (id != tt::TokenId::unspecified()).then(|| id.0)\n                     }\n-                    _ => None,\n                 })\n                 .max()\n         }"}]}