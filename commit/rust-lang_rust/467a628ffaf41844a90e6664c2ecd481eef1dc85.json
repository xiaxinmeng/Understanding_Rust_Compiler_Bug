{"sha": "467a628ffaf41844a90e6664c2ecd481eef1dc85", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2N2E2MjhmZmFmNDE4NDRhOTBlNjY2NGMyZWNkNDgxZWVmMWRjODU=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-02-09T02:09:50Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-02-09T02:09:50Z"}, "message": "Add the single instruction required in activate glue to fix burning darwin tinderbox. And transplant 100 lines of comments from the ML code.", "tree": {"sha": "1bd0dfdc6476de1b4ac6de2706c3e310ef5235bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1bd0dfdc6476de1b4ac6de2706c3e310ef5235bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/467a628ffaf41844a90e6664c2ecd481eef1dc85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/467a628ffaf41844a90e6664c2ecd481eef1dc85", "html_url": "https://github.com/rust-lang/rust/commit/467a628ffaf41844a90e6664c2ecd481eef1dc85", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/467a628ffaf41844a90e6664c2ecd481eef1dc85/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f25d9c983c5730d79cc14278e666b8eb6531b10", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f25d9c983c5730d79cc14278e666b8eb6531b10", "html_url": "https://github.com/rust-lang/rust/commit/2f25d9c983c5730d79cc14278e666b8eb6531b10"}], "stats": {"total": 101, "additions": 99, "deletions": 2}, "files": [{"sha": "907cb32e3fe8ffaa85350616ad2ec508f16375a7", "filename": "src/comp/back/x86.rs", "status": "modified", "additions": 99, "deletions": 2, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/467a628ffaf41844a90e6664c2ecd481eef1dc85/src%2Fcomp%2Fback%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/467a628ffaf41844a90e6664c2ecd481eef1dc85/src%2Fcomp%2Fback%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fx86.rs?ref=467a628ffaf41844a90e6664c2ecd481eef1dc85", "patch": "@@ -41,20 +41,117 @@ fn store_esp_to_runtime_sp() -> vec[str] {\n     ret vec(\"movl  %esp, \" + wstr(abi.task_field_runtime_sp) + \"(%ecx)\");\n }\n \n+/*\n+ * This is a bit of glue-code. It should be emitted once per\n+ * compilation unit.\n+ *\n+ *   - save regs on C stack\n+ *   - align sp on a 16-byte boundary\n+ *   - save sp to task.runtime_sp (runtime_sp is thus always aligned)\n+ *   - load saved task sp (switch stack)\n+ *   - restore saved task regs\n+ *   - return to saved task pc\n+ *\n+ * Our incoming stack looks like this:\n+ *\n+ *   *esp+4        = [arg1   ] = task ptr\n+ *   *esp          = [retpc  ]\n+ */\n+\n fn rust_activate_glue() -> vec[str] {\n     ret vec(\"movl  4(%esp), %ecx    # ecx = rust_task\")\n         + save_callee_saves()\n         + store_esp_to_runtime_sp()\n         + load_esp_from_rust_sp()\n \n-        // This 'add' instruction is a bit surprising.\n-        // See lengthy comment in boot/be/x86.ml activate_glue.\n+        /*\n+         * There are two paths we can arrive at this code from:\n+         *\n+         *\n+         *   1. We are activating a task for the first time. When we switch\n+         *      into the task stack and 'ret' to its first instruction, we'll\n+         *      start doing whatever the first instruction says. Probably\n+         *      saving registers and starting to establish a frame. Harmless\n+         *      stuff, doesn't look at task->rust_sp again except when it\n+         *      clobbers it during a later upcall.\n+         *\n+         *\n+         *   2. We are resuming a task that was descheduled by the yield glue\n+         *      below.  When we switch into the task stack and 'ret', we'll be\n+         *      ret'ing to a very particular instruction:\n+         *\n+         *              \"esp <- task->rust_sp\"\n+         *\n+         *      this is the first instruction we 'ret' to after this glue,\n+         *      because it is the first instruction following *any* upcall,\n+         *      and the task we are activating was descheduled mid-upcall.\n+         *\n+         *      Unfortunately for us, we have already restored esp from\n+         *      task->rust_sp and are about to eat the 5 words off the top of\n+         *      it.\n+         *\n+         *\n+         *      | ...    | <-- where esp will be once we restore + ret, below,\n+         *      | retpc  |     and where we'd *like* task->rust_sp to wind up.\n+         *      | ebp    |\n+         *      | edi    |\n+         *      | esi    |\n+         *      | ebx    | <-- current task->rust_sp == current esp\n+         *\n+         * \n+         *      This is a problem. If we return to \"esp <- task->rust_sp\" it\n+         *      will push esp back down by 5 words. This manifests as a rust\n+         *      stack that grows by 5 words on each yield/reactivate. Not\n+         *      good.\n+         * \n+         *      So what we do here is just adjust task->rust_sp up 5 words as\n+         *      well, to mirror the movement in esp we're about to\n+         *      perform. That way the \"esp <- task->rust_sp\" we 'ret' to below\n+         *      will be a no-op. Esp won't move, and the task's stack won't\n+         *      grow.\n+         */\n         + vec(\"addl  $20, \" + wstr(abi.task_field_rust_sp) + \"(%ecx)\")\n \n+\n+        /*\n+         * In most cases, the function we're returning to (activating)\n+         * will have saved any caller-saves before it yielded via upcalling,\n+         * so no work to do here. With one exception: when we're initially\n+         * activating, the task needs to be in the fastcall 2nd parameter\n+         * expected by the rust main function. That's edx.\n+         */\n+        + vec(\"mov  %ecx, %edx\")\n+\n         + restore_callee_saves()\n         + vec(\"ret\");\n }\n \n+/* More glue code, this time the 'bottom half' of yielding.\n+ *\n+ * We arrived here because an upcall decided to deschedule the\n+ * running task. So the upcall's return address got patched to the\n+ * first instruction of this glue code.\n+ *\n+ * When the upcall does 'ret' it will come here, and its esp will be\n+ * pointing to the last argument pushed on the C stack before making\n+ * the upcall: the 0th argument to the upcall, which is always the\n+ * task ptr performing the upcall. That's where we take over.\n+ *\n+ * Our goal is to complete the descheduling\n+ *\n+ *   - Switch over to the task stack temporarily.\n+ *\n+ *   - Save the task's callee-saves onto the task stack.\n+ *     (the task is now 'descheduled', safe to set aside)\n+ *\n+ *   - Switch *back* to the C stack.\n+ *\n+ *   - Restore the C-stack callee-saves.\n+ *\n+ *   - Return to the caller on the C stack that activated the task.\n+ *\n+ */\n+\n fn rust_yield_glue() -> vec[str] {\n     ret vec(\"movl  0(%esp), %ecx    # ecx = rust_task\")\n         + load_esp_from_rust_sp()"}]}