{"sha": "87c8437af32779e1fd42d94b4c4147f6dd2b8157", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3Yzg0MzdhZjMyNzc5ZTFmZDQyZDk0YjRjNDE0N2Y2ZGQyYjgxNTc=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-05-29T11:59:38Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-05-29T11:59:38Z"}, "message": "Merge #1341\n\n1341: log the actual time of requests r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "fa95043e19fdd2390f5c4ce73a5be05e6b1ea8ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa95043e19fdd2390f5c4ce73a5be05e6b1ea8ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87c8437af32779e1fd42d94b4c4147f6dd2b8157", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87c8437af32779e1fd42d94b4c4147f6dd2b8157", "html_url": "https://github.com/rust-lang/rust/commit/87c8437af32779e1fd42d94b4c4147f6dd2b8157", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87c8437af32779e1fd42d94b4c4147f6dd2b8157/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "9eef546ca2f59d0ebc0e5dc443fc1a5d93926030", "url": "https://api.github.com/repos/rust-lang/rust/commits/9eef546ca2f59d0ebc0e5dc443fc1a5d93926030", "html_url": "https://github.com/rust-lang/rust/commit/9eef546ca2f59d0ebc0e5dc443fc1a5d93926030"}, {"sha": "e45c350a3b0ec5b25c23c334e09eba2901adbcd4", "url": "https://api.github.com/repos/rust-lang/rust/commits/e45c350a3b0ec5b25c23c334e09eba2901adbcd4", "html_url": "https://github.com/rust-lang/rust/commit/e45c350a3b0ec5b25c23c334e09eba2901adbcd4"}], "stats": {"total": 61, "additions": 42, "deletions": 19}, "files": [{"sha": "c3580ab679564673b43f7ee636307af6a654864f", "filename": "crates/ra_lsp_server/src/main_loop.rs", "status": "modified", "additions": 42, "deletions": 19, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/87c8437af32779e1fd42d94b4c4147f6dd2b8157/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87c8437af32779e1fd42d94b4c4147f6dd2b8157/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs?ref=87c8437af32779e1fd42d94b4c4147f6dd2b8157", "patch": "@@ -1,7 +1,7 @@\n mod handlers;\n mod subscriptions;\n \n-use std::{fmt, path::PathBuf, sync::Arc};\n+use std::{fmt, path::PathBuf, sync::Arc, time::Instant};\n \n use crossbeam_channel::{select, unbounded, Receiver, RecvError, Sender};\n use failure::{bail, format_err};\n@@ -12,7 +12,7 @@ use gen_lsp_server::{\n use lsp_types::NumberOrString;\n use ra_ide_api::{Canceled, FileId, LibraryData};\n use ra_vfs::VfsTask;\n-use rustc_hash::FxHashSet;\n+use rustc_hash::FxHashMap;\n use serde::{de::DeserializeOwned, Serialize};\n use threadpool::ThreadPool;\n \n@@ -82,7 +82,7 @@ pub fn main_loop(\n \n     log::info!(\"server initialized, serving requests\");\n \n-    let mut pending_requests = FxHashSet::default();\n+    let mut pending_requests = FxHashMap::default();\n     let mut subs = Subscriptions::new();\n     let main_res = main_loop_inner(\n         options,\n@@ -159,7 +159,7 @@ fn main_loop_inner(\n     task_sender: Sender<Task>,\n     task_receiver: Receiver<Task>,\n     state: &mut ServerWorldState,\n-    pending_requests: &mut FxHashSet<u64>,\n+    pending_requests: &mut FxHashMap<u64, Instant>,\n     subs: &mut Subscriptions,\n ) -> Result<()> {\n     // We try not to index more than THREADPOOL_SIZE - 3 libraries at the same\n@@ -170,7 +170,6 @@ fn main_loop_inner(\n \n     let (libdata_sender, libdata_receiver) = unbounded();\n     loop {\n-        state.maybe_collect_garbage();\n         log::trace!(\"selecting\");\n         let event = select! {\n             recv(msg_receiver) -> msg => match msg {\n@@ -184,17 +183,28 @@ fn main_loop_inner(\n             },\n             recv(libdata_receiver) -> data => Event::Lib(data.unwrap())\n         };\n-        log::info!(\"loop_turn = {:?}\", event);\n-        let _p = profile(\"loop_turn\");\n+        // NOTE: don't count blocking select! call as a loop-turn time\n+        let _p = profile(\"main_loop_inner/loop-turn\");\n+        let loop_start = Instant::now();\n+\n+        log::info!(\"loop turn = {:?}\", event);\n+        let queue_count = pool.queued_count();\n+        if queue_count > 0 {\n+            log::info!(\"queued count = {}\", queue_count);\n+        }\n         let mut state_changed = false;\n         match event {\n-            Event::Task(task) => on_task(task, msg_sender, pending_requests),\n+            Event::Task(task) => {\n+                on_task(task, msg_sender, pending_requests);\n+                state.maybe_collect_garbage();\n+            }\n             Event::Vfs(task) => {\n                 state.vfs.write().handle_task(task);\n                 state_changed = true;\n             }\n             Event::Lib(lib) => {\n                 state.add_lib(lib);\n+                state.maybe_collect_garbage();\n                 in_flight_libraries -= 1;\n             }\n             Event::Msg(msg) => match msg {\n@@ -210,7 +220,14 @@ fn main_loop_inner(\n                             msg_sender.send(resp.into()).unwrap()\n                         }\n                         Err(req) => {\n-                            match on_request(state, pending_requests, pool, &task_sender, req)? {\n+                            match on_request(\n+                                state,\n+                                pending_requests,\n+                                pool,\n+                                &task_sender,\n+                                loop_start,\n+                                req,\n+                            )? {\n                                 None => (),\n                                 Some(req) => {\n                                     log::error!(\"unknown request: {:?}\", req);\n@@ -272,10 +289,15 @@ fn main_loop_inner(\n     }\n }\n \n-fn on_task(task: Task, msg_sender: &Sender<RawMessage>, pending_requests: &mut FxHashSet<u64>) {\n+fn on_task(\n+    task: Task,\n+    msg_sender: &Sender<RawMessage>,\n+    pending_requests: &mut FxHashMap<u64, Instant>,\n+) {\n     match task {\n         Task::Respond(response) => {\n-            if pending_requests.remove(&response.id) {\n+            if let Some(request_received) = pending_requests.remove(&response.id) {\n+                log::info!(\"handled req#{} in {:?}\", response.id, request_received.elapsed());\n                 msg_sender.send(response.into()).unwrap();\n             }\n         }\n@@ -287,9 +309,10 @@ fn on_task(task: Task, msg_sender: &Sender<RawMessage>, pending_requests: &mut F\n \n fn on_request(\n     world: &mut ServerWorldState,\n-    pending_requests: &mut FxHashSet<u64>,\n+    pending_requests: &mut FxHashMap<u64, Instant>,\n     pool: &ThreadPool,\n     sender: &Sender<Task>,\n+    request_received: Instant,\n     req: RawRequest,\n ) -> Result<Option<RawRequest>> {\n     let mut pool_dispatcher = PoolDispatcher { req: Some(req), res: None, pool, world, sender };\n@@ -325,8 +348,8 @@ fn on_request(\n         .finish();\n     match req {\n         Ok(id) => {\n-            let inserted = pending_requests.insert(id);\n-            assert!(inserted, \"duplicate request: {}\", id);\n+            let prev = pending_requests.insert(id, request_received);\n+            assert!(prev.is_none(), \"duplicate request: {}\", id);\n             Ok(None)\n         }\n         Err(req) => Ok(Some(req)),\n@@ -336,7 +359,7 @@ fn on_request(\n fn on_notification(\n     msg_sender: &Sender<RawMessage>,\n     state: &mut ServerWorldState,\n-    pending_requests: &mut FxHashSet<u64>,\n+    pending_requests: &mut FxHashMap<u64, Instant>,\n     subs: &mut Subscriptions,\n     not: RawNotification,\n ) -> Result<()> {\n@@ -348,7 +371,7 @@ fn on_notification(\n                     panic!(\"string id's not supported: {:?}\", id);\n                 }\n             };\n-            if pending_requests.remove(&id) {\n+            if pending_requests.remove(&id).is_some() {\n                 let response = RawResponse::err(\n                     id,\n                     ErrorCode::RequestCanceled as i32,\n@@ -426,7 +449,7 @@ impl<'a> PoolDispatcher<'a> {\n                 let world = self.world.snapshot();\n                 let sender = self.sender.clone();\n                 self.pool.execute(move || {\n-                    let resp = match f(world, params) {\n+                    let response = match f(world, params) {\n                         Ok(resp) => RawResponse::ok::<R>(id, &resp),\n                         Err(e) => match e.downcast::<LspError>() {\n                             Ok(lsp_error) => {\n@@ -458,7 +481,7 @@ impl<'a> PoolDispatcher<'a> {\n                             }\n                         },\n                     };\n-                    let task = Task::Respond(resp);\n+                    let task = Task::Respond(response);\n                     sender.send(task).unwrap();\n                 });\n                 self.res = Some(id);\n@@ -468,7 +491,7 @@ impl<'a> PoolDispatcher<'a> {\n         Ok(self)\n     }\n \n-    fn finish(&mut self) -> ::std::result::Result<u64, RawRequest> {\n+    fn finish(&mut self) -> std::result::Result<u64, RawRequest> {\n         match (self.res.take(), self.req.take()) {\n             (Some(res), None) => Ok(res),\n             (None, Some(req)) => Err(req),"}]}