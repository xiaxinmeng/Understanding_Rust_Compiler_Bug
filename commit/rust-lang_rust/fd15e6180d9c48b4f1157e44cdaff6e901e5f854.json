{"sha": "fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkMTVlNjE4MGQ5YzQ4YjRmMTE1N2U0NGNkYWZmNmU5MDFlNWY4NTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-26T06:44:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-26T06:44:28Z"}, "message": "Auto merge of #70743 - oli-obk:eager_const_to_pat_conversion, r=eddyb\n\nFully destructure constants into patterns\n\nr? `@varkor`\n\nas discussed in https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/constants.20in.20patterns/near/192789924\n\nwe should probably crater it once reviewed", "tree": {"sha": "11801a40b3c4b0ccc7c10b589347b28348705871", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11801a40b3c4b0ccc7c10b589347b28348705871"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "html_url": "https://github.com/rust-lang/rust/commit/fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e1c4361780e69ed54444a3b03fef0cbbc26b547", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e1c4361780e69ed54444a3b03fef0cbbc26b547", "html_url": "https://github.com/rust-lang/rust/commit/9e1c4361780e69ed54444a3b03fef0cbbc26b547"}, {"sha": "daf976f6129e5fb16effc48bf91853548774e235", "url": "https://api.github.com/repos/rust-lang/rust/commits/daf976f6129e5fb16effc48bf91853548774e235", "html_url": "https://github.com/rust-lang/rust/commit/daf976f6129e5fb16effc48bf91853548774e235"}], "stats": {"total": 1229, "additions": 795, "deletions": 434}, "files": [{"sha": "784d6c3b2cee4e1557c03ce398dfcb58e4dd7a25", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -742,6 +742,14 @@ rustc_queries! {\n             desc { \"destructure constant\" }\n         }\n \n+        /// Dereference a constant reference or raw pointer and turn the result into a constant\n+        /// again.\n+        query deref_const(\n+            key: ty::ParamEnvAnd<'tcx, &'tcx ty::Const<'tcx>>\n+        ) -> &'tcx ty::Const<'tcx> {\n+            desc { \"deref constant\" }\n+        }\n+\n         query const_caller_location(key: (rustc_span::Symbol, u32, u32)) -> ConstValue<'tcx> {\n             desc { \"get a &core::panic::Location referring to a span\" }\n         }"}, {"sha": "978d2fe000468bc81535b66543a42eb1a3b50da2", "filename": "compiler/rustc_mir/src/const_eval/mod.rs", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmod.rs?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -2,11 +2,14 @@\n \n use std::convert::TryFrom;\n \n+use rustc_hir::Mutability;\n use rustc_middle::mir;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::{source_map::DUMMY_SP, symbol::Symbol};\n \n-use crate::interpret::{intern_const_alloc_recursive, ConstValue, InternKind, InterpCx};\n+use crate::interpret::{\n+    intern_const_alloc_recursive, ConstValue, InternKind, InterpCx, MemPlaceMeta, Scalar,\n+};\n \n mod error;\n mod eval_queries;\n@@ -67,3 +70,39 @@ pub(crate) fn destructure_const<'tcx>(\n \n     mir::DestructuredConst { variant, fields }\n }\n+\n+pub(crate) fn deref_const<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    val: &'tcx ty::Const<'tcx>,\n+) -> &'tcx ty::Const<'tcx> {\n+    trace!(\"deref_const: {:?}\", val);\n+    let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env, false);\n+    let op = ecx.const_to_op(val, None).unwrap();\n+    let mplace = ecx.deref_operand(op).unwrap();\n+    if let Scalar::Ptr(ptr) = mplace.ptr {\n+        assert_eq!(\n+            ecx.memory.get_raw(ptr.alloc_id).unwrap().mutability,\n+            Mutability::Not,\n+            \"deref_const cannot be used with mutable allocations as \\\n+            that could allow pattern matching to observe mutable statics\",\n+        );\n+    }\n+\n+    let ty = match mplace.meta {\n+        MemPlaceMeta::None => mplace.layout.ty,\n+        MemPlaceMeta::Poison => bug!(\"poison metadata in `deref_const`: {:#?}\", mplace),\n+        // In case of unsized types, figure out the real type behind.\n+        MemPlaceMeta::Meta(scalar) => match mplace.layout.ty.kind() {\n+            ty::Str => bug!(\"there's no sized equivalent of a `str`\"),\n+            ty::Slice(elem_ty) => tcx.mk_array(elem_ty, scalar.to_machine_usize(&tcx).unwrap()),\n+            _ => bug!(\n+                \"type {} should not have metadata, but had {:?}\",\n+                mplace.layout.ty,\n+                mplace.meta\n+            ),\n+        },\n+    };\n+\n+    tcx.mk_const(ty::Const { val: ty::ConstKind::Value(op_to_const(&ecx, mplace.into())), ty })\n+}"}, {"sha": "c00c6860903c8d73e01224a3677c9b4cef809915", "filename": "compiler/rustc_mir/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Flib.rs?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -59,4 +59,8 @@ pub fn provide(providers: &mut Providers) {\n         let (param_env, value) = param_env_and_value.into_parts();\n         const_eval::destructure_const(tcx, param_env, value)\n     };\n+    providers.deref_const = |tcx, param_env_and_value| {\n+        let (param_env, value) = param_env_and_value.into_parts();\n+        const_eval::deref_const(tcx, param_env, value)\n+    };\n }"}, {"sha": "a203b3a142863bcdb3ab2ea7a5f046596937e0cc", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 340, "deletions": 110, "changes": 450, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -3,7 +3,7 @@ use rustc_index::vec::Idx;\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n use rustc_middle::mir::Field;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{self, AdtDef, Ty, TyCtxt};\n use rustc_session::lint;\n use rustc_span::Span;\n use rustc_trait_selection::traits::predicate_for_trait_def;\n@@ -28,10 +28,13 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         debug!(\"const_to_pat: cv={:#?} id={:?}\", cv, id);\n         debug!(\"const_to_pat: cv.ty={:?} span={:?}\", cv.ty, span);\n \n-        self.tcx.infer_ctxt().enter(|infcx| {\n+        let pat = self.tcx.infer_ctxt().enter(|infcx| {\n             let mut convert = ConstToPat::new(self, id, span, infcx);\n             convert.to_pat(cv, mir_structural_match_violation)\n-        })\n+        });\n+\n+        debug!(\"const_to_pat: pat={:?}\", pat);\n+        pat\n     }\n }\n \n@@ -40,17 +43,44 @@ struct ConstToPat<'a, 'tcx> {\n     span: Span,\n     param_env: ty::ParamEnv<'tcx>,\n \n-    // This tracks if we signal some hard error for a given const value, so that\n+    // This tracks if we emitted some hard error for a given const value, so that\n     // we will not subsequently issue an irrelevant lint for the same const\n     // value.\n     saw_const_match_error: Cell<bool>,\n \n+    // This tracks if we emitted some diagnostic for a given const value, so that\n+    // we will not subsequently issue an irrelevant lint for the same const\n+    // value.\n+    saw_const_match_lint: Cell<bool>,\n+\n+    // For backcompat we need to keep allowing non-structurally-eq types behind references.\n+    // See also all the `cant-hide-behind` tests.\n+    behind_reference: Cell<bool>,\n+\n     // inference context used for checking `T: Structural` bounds.\n     infcx: InferCtxt<'a, 'tcx>,\n \n     include_lint_checks: bool,\n }\n \n+mod fallback_to_const_ref {\n+    #[derive(Debug)]\n+    /// This error type signals that we encountered a non-struct-eq situation behind a reference.\n+    /// We bubble this up in order to get back to the reference destructuring and make that emit\n+    /// a const pattern instead of a deref pattern. This allows us to simply call `PartialEq::eq`\n+    /// on such patterns (since that function takes a reference) and not have to jump through any\n+    /// hoops to get a reference to the value.\n+    pub(super) struct FallbackToConstRef(());\n+\n+    pub(super) fn fallback_to_const_ref<'a, 'tcx>(\n+        c2p: &super::ConstToPat<'a, 'tcx>,\n+    ) -> FallbackToConstRef {\n+        assert!(c2p.behind_reference.get());\n+        FallbackToConstRef(())\n+    }\n+}\n+use fallback_to_const_ref::{fallback_to_const_ref, FallbackToConstRef};\n+\n impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n     fn new(\n         pat_ctxt: &PatCtxt<'_, 'tcx>,\n@@ -65,18 +95,53 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n             param_env: pat_ctxt.param_env,\n             include_lint_checks: pat_ctxt.include_lint_checks,\n             saw_const_match_error: Cell::new(false),\n+            saw_const_match_lint: Cell::new(false),\n+            behind_reference: Cell::new(false),\n         }\n     }\n \n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn search_for_structural_match_violation(\n-        &self,\n-        ty: Ty<'tcx>,\n-    ) -> Option<traits::NonStructuralMatchTy<'tcx>> {\n-        traits::search_for_structural_match_violation(self.id, self.span, self.tcx(), ty)\n+    fn adt_derive_msg(&self, adt_def: &AdtDef) -> String {\n+        let path = self.tcx().def_path_str(adt_def.did);\n+        format!(\n+            \"to use a constant of type `{}` in a pattern, \\\n+            `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n+            path, path,\n+        )\n+    }\n+\n+    fn search_for_structural_match_violation(&self, ty: Ty<'tcx>) -> Option<String> {\n+        traits::search_for_structural_match_violation(self.id, self.span, self.tcx(), ty).map(\n+            |non_sm_ty| {\n+                with_no_trimmed_paths(|| match non_sm_ty {\n+                    traits::NonStructuralMatchTy::Adt(adt) => self.adt_derive_msg(adt),\n+                    traits::NonStructuralMatchTy::Dynamic => {\n+                        \"trait objects cannot be used in patterns\".to_string()\n+                    }\n+                    traits::NonStructuralMatchTy::Opaque => {\n+                        \"opaque types cannot be used in patterns\".to_string()\n+                    }\n+                    traits::NonStructuralMatchTy::Generator => {\n+                        \"generators cannot be used in patterns\".to_string()\n+                    }\n+                    traits::NonStructuralMatchTy::Closure => {\n+                        \"closures cannot be used in patterns\".to_string()\n+                    }\n+                    traits::NonStructuralMatchTy::Param => {\n+                        bug!(\"use of a constant whose type is a parameter inside a pattern\")\n+                    }\n+                    traits::NonStructuralMatchTy::Projection => {\n+                        bug!(\"use of a constant whose type is a projection inside a pattern\")\n+                    }\n+                    traits::NonStructuralMatchTy::Foreign => {\n+                        bug!(\"use of a value of a foreign type inside a pattern\")\n+                    }\n+                })\n+            },\n+        )\n     }\n \n     fn type_marked_structural(&self, ty: Ty<'tcx>) -> bool {\n@@ -95,7 +160,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n         // once indirect_structural_match is a full fledged error, this\n         // level of indirection can be eliminated\n \n-        let inlined_const_as_pat = self.recur(cv);\n+        let inlined_const_as_pat = self.recur(cv, mir_structural_match_violation).unwrap();\n \n         if self.include_lint_checks && !self.saw_const_match_error.get() {\n             // If we were able to successfully convert the const to some pat,\n@@ -118,70 +183,11 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 return inlined_const_as_pat;\n             }\n \n-            if let Some(non_sm_ty) = structural {\n-                let msg = with_no_trimmed_paths(|| match non_sm_ty {\n-                    traits::NonStructuralMatchTy::Adt(adt_def) => {\n-                        let path = self.tcx().def_path_str(adt_def.did);\n-                        format!(\n-                            \"to use a constant of type `{}` in a pattern, \\\n-                             `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n-                            path, path,\n-                        )\n-                    }\n-                    traits::NonStructuralMatchTy::Dynamic => {\n-                        \"trait objects cannot be used in patterns\".to_string()\n-                    }\n-                    traits::NonStructuralMatchTy::Opaque => {\n-                        \"opaque types cannot be used in patterns\".to_string()\n-                    }\n-                    traits::NonStructuralMatchTy::Generator => {\n-                        \"generators cannot be used in patterns\".to_string()\n-                    }\n-                    traits::NonStructuralMatchTy::Closure => {\n-                        \"closures cannot be used in patterns\".to_string()\n-                    }\n-                    traits::NonStructuralMatchTy::Param => {\n-                        bug!(\"use of a constant whose type is a parameter inside a pattern\")\n-                    }\n-                    traits::NonStructuralMatchTy::Projection => {\n-                        bug!(\"use of a constant whose type is a projection inside a pattern\")\n-                    }\n-                    traits::NonStructuralMatchTy::Foreign => {\n-                        bug!(\"use of a value of a foreign type inside a pattern\")\n-                    }\n-                });\n-\n-                // double-check there even *is* a semantic `PartialEq` to dispatch to.\n-                //\n-                // (If there isn't, then we can safely issue a hard\n-                // error, because that's never worked, due to compiler\n-                // using `PartialEq::eq` in this scenario in the past.)\n-                //\n-                // Note: To fix rust-lang/rust#65466, one could lift this check\n-                // *before* any structural-match checking, and unconditionally error\n-                // if `PartialEq` is not implemented. However, that breaks stable\n-                // code at the moment, because types like `for <'a> fn(&'a ())` do\n-                // not *yet* implement `PartialEq`. So for now we leave this here.\n-                let ty_is_partial_eq: bool = {\n-                    let partial_eq_trait_id =\n-                        self.tcx().require_lang_item(hir::LangItem::PartialEq, Some(self.span));\n-                    let obligation: PredicateObligation<'_> = predicate_for_trait_def(\n-                        self.tcx(),\n-                        self.param_env,\n-                        ObligationCause::misc(self.span, self.id),\n-                        partial_eq_trait_id,\n-                        0,\n-                        cv.ty,\n-                        &[],\n-                    );\n-                    // FIXME: should this call a `predicate_must_hold` variant instead?\n-                    self.infcx.predicate_may_hold(&obligation)\n-                };\n-\n-                if !ty_is_partial_eq {\n+            if let Some(msg) = structural {\n+                if !self.type_may_have_partial_eq_impl(cv.ty) {\n                     // span_fatal avoids ICE from resolution of non-existent method (rare case).\n                     self.tcx().sess.span_fatal(self.span, &msg);\n-                } else if mir_structural_match_violation {\n+                } else if mir_structural_match_violation && !self.saw_const_match_lint.get() {\n                     self.tcx().struct_span_lint_hir(\n                         lint::builtin::INDIRECT_STRUCTURAL_MATCH,\n                         self.id,\n@@ -200,19 +206,57 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n         inlined_const_as_pat\n     }\n \n+    fn type_may_have_partial_eq_impl(&self, ty: Ty<'tcx>) -> bool {\n+        // double-check there even *is* a semantic `PartialEq` to dispatch to.\n+        //\n+        // (If there isn't, then we can safely issue a hard\n+        // error, because that's never worked, due to compiler\n+        // using `PartialEq::eq` in this scenario in the past.)\n+        let partial_eq_trait_id =\n+            self.tcx().require_lang_item(hir::LangItem::PartialEq, Some(self.span));\n+        let obligation: PredicateObligation<'_> = predicate_for_trait_def(\n+            self.tcx(),\n+            self.param_env,\n+            ObligationCause::misc(self.span, self.id),\n+            partial_eq_trait_id,\n+            0,\n+            ty,\n+            &[],\n+        );\n+        // FIXME: should this call a `predicate_must_hold` variant instead?\n+\n+        let has_impl = self.infcx.predicate_may_hold(&obligation);\n+\n+        // Note: To fix rust-lang/rust#65466, we could just remove this type\n+        // walk hack for function pointers, and unconditionally error\n+        // if `PartialEq` is not implemented. However, that breaks stable\n+        // code at the moment, because types like `for <'a> fn(&'a ())` do\n+        // not *yet* implement `PartialEq`. So for now we leave this here.\n+        has_impl\n+            || ty.walk().any(|t| match t.unpack() {\n+                ty::subst::GenericArgKind::Lifetime(_) => false,\n+                ty::subst::GenericArgKind::Type(t) => t.is_fn_ptr(),\n+                ty::subst::GenericArgKind::Const(_) => false,\n+            })\n+    }\n+\n     // Recursive helper for `to_pat`; invoke that (instead of calling this directly).\n-    fn recur(&self, cv: &'tcx ty::Const<'tcx>) -> Pat<'tcx> {\n+    fn recur(\n+        &self,\n+        cv: &'tcx ty::Const<'tcx>,\n+        mir_structural_match_violation: bool,\n+    ) -> Result<Pat<'tcx>, FallbackToConstRef> {\n         let id = self.id;\n         let span = self.span;\n         let tcx = self.tcx();\n         let param_env = self.param_env;\n \n-        let field_pats = |vals: &[&'tcx ty::Const<'tcx>]| {\n+        let field_pats = |vals: &[&'tcx ty::Const<'tcx>]| -> Result<_, _> {\n             vals.iter()\n                 .enumerate()\n                 .map(|(idx, val)| {\n                     let field = Field::new(idx);\n-                    FieldPat { field, pattern: self.recur(val) }\n+                    Ok(FieldPat { field, pattern: self.recur(val, false)? })\n                 })\n                 .collect()\n         };\n@@ -230,42 +274,77 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n             ty::Adt(adt_def, _) if adt_def.is_union() => {\n                 // Matching on union fields is unsafe, we can't hide it in constants\n                 self.saw_const_match_error.set(true);\n-                tcx.sess.span_err(span, \"cannot use unions in constant patterns\");\n+                let msg = \"cannot use unions in constant patterns\";\n+                if self.include_lint_checks {\n+                    tcx.sess.span_err(span, msg);\n+                } else {\n+                    tcx.sess.delay_span_bug(span, msg)\n+                }\n                 PatKind::Wild\n             }\n-            // keep old code until future-compat upgraded to errors.\n-            ty::Adt(adt_def, _) if !self.type_marked_structural(cv.ty) => {\n-                debug!(\"adt_def {:?} has !type_marked_structural for cv.ty: {:?}\", adt_def, cv.ty);\n-                let path = tcx.def_path_str(adt_def.did);\n-                let msg = format!(\n-                    \"to use a constant of type `{}` in a pattern, \\\n-                     `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n-                    path, path,\n-                );\n+            ty::Adt(..)\n+                if !self.type_may_have_partial_eq_impl(cv.ty)\n+                    // FIXME(#73448): Find a way to bring const qualification into parity with\n+                    // `search_for_structural_match_violation` and then remove this condition.\n+                    && self.search_for_structural_match_violation(cv.ty).is_some() =>\n+            {\n+                // Obtain the actual type that isn't annotated. If we just looked at `cv.ty` we\n+                // could get `Option<NonStructEq>`, even though `Option` is annotated with derive.\n+                let msg = self.search_for_structural_match_violation(cv.ty).unwrap();\n                 self.saw_const_match_error.set(true);\n-                tcx.sess.span_err(span, &msg);\n+                if self.include_lint_checks {\n+                    tcx.sess.span_err(self.span, &msg);\n+                } else {\n+                    tcx.sess.delay_span_bug(self.span, &msg)\n+                }\n                 PatKind::Wild\n             }\n-            // keep old code until future-compat upgraded to errors.\n-            ty::Ref(_, adt_ty, _) if adt_ty.is_adt() && !self.type_marked_structural(adt_ty) => {\n-                let adt_def =\n-                    if let ty::Adt(adt_def, _) = adt_ty.kind() { adt_def } else { unreachable!() };\n-\n-                debug!(\n-                    \"adt_def {:?} has !type_marked_structural for adt_ty: {:?}\",\n-                    adt_def, adt_ty\n-                );\n-\n-                // HACK(estebank): Side-step ICE #53708, but anything other than erroring here\n-                // would be wrong. Returnging `PatKind::Wild` is not technically correct.\n+            // If the type is not structurally comparable, just emit the constant directly,\n+            // causing the pattern match code to treat it opaquely.\n+            // FIXME: This code doesn't emit errors itself, the caller emits the errors.\n+            // So instead of specific errors, you just get blanket errors about the whole\n+            // const type. See\n+            // https://github.com/rust-lang/rust/pull/70743#discussion_r404701963 for\n+            // details.\n+            // Backwards compatibility hack because we can't cause hard errors on these\n+            // types, so we compare them via `PartialEq::eq` at runtime.\n+            ty::Adt(..) if !self.type_marked_structural(cv.ty) && self.behind_reference.get() => {\n+                if self.include_lint_checks\n+                    && !self.saw_const_match_error.get()\n+                    && !self.saw_const_match_lint.get()\n+                {\n+                    self.saw_const_match_lint.set(true);\n+                    let msg = format!(\n+                        \"to use a constant of type `{}` in a pattern, \\\n+                        `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n+                        cv.ty, cv.ty,\n+                    );\n+                    tcx.struct_span_lint_hir(\n+                        lint::builtin::INDIRECT_STRUCTURAL_MATCH,\n+                        id,\n+                        span,\n+                        |lint| lint.build(&msg).emit(),\n+                    );\n+                }\n+                // Since we are behind a reference, we can just bubble the error up so we get a\n+                // constant at reference type, making it easy to let the fallback call\n+                // `PartialEq::eq` on it.\n+                return Err(fallback_to_const_ref(self));\n+            }\n+            ty::Adt(adt_def, _) if !self.type_marked_structural(cv.ty) => {\n+                debug!(\"adt_def {:?} has !type_marked_structural for cv.ty: {:?}\", adt_def, cv.ty);\n                 let path = tcx.def_path_str(adt_def.did);\n                 let msg = format!(\n                     \"to use a constant of type `{}` in a pattern, \\\n                      `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n                     path, path,\n                 );\n                 self.saw_const_match_error.set(true);\n-                tcx.sess.span_err(span, &msg);\n+                if self.include_lint_checks {\n+                    tcx.sess.span_err(span, &msg);\n+                } else {\n+                    tcx.sess.delay_span_bug(span, &msg)\n+                }\n                 PatKind::Wild\n             }\n             ty::Adt(adt_def, substs) if adt_def.is_enum() => {\n@@ -276,30 +355,181 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                     variant_index: destructured\n                         .variant\n                         .expect(\"destructed const of adt without variant id\"),\n-                    subpatterns: field_pats(destructured.fields),\n+                    subpatterns: field_pats(destructured.fields)?,\n                 }\n             }\n-            ty::Adt(_, _) => {\n-                let destructured = tcx.destructure_const(param_env.and(cv));\n-                PatKind::Leaf { subpatterns: field_pats(destructured.fields) }\n-            }\n-            ty::Tuple(_) => {\n+            ty::Tuple(_) | ty::Adt(_, _) => {\n                 let destructured = tcx.destructure_const(param_env.and(cv));\n-                PatKind::Leaf { subpatterns: field_pats(destructured.fields) }\n+                PatKind::Leaf { subpatterns: field_pats(destructured.fields)? }\n             }\n             ty::Array(..) => PatKind::Array {\n                 prefix: tcx\n                     .destructure_const(param_env.and(cv))\n                     .fields\n                     .iter()\n-                    .map(|val| self.recur(val))\n-                    .collect(),\n+                    .map(|val| self.recur(val, false))\n+                    .collect::<Result<_, _>>()?,\n                 slice: None,\n                 suffix: Vec::new(),\n             },\n-            _ => PatKind::Constant { value: cv },\n+            ty::Ref(_, pointee_ty, ..) => match *pointee_ty.kind() {\n+                // These are not allowed and will error elsewhere anyway.\n+                ty::Dynamic(..) => {\n+                    self.saw_const_match_error.set(true);\n+                    let msg = format!(\"`{}` cannot be used in patterns\", cv.ty);\n+                    if self.include_lint_checks {\n+                        tcx.sess.span_err(span, &msg);\n+                    } else {\n+                        tcx.sess.delay_span_bug(span, &msg)\n+                    }\n+                    PatKind::Wild\n+                }\n+                // `&str` and `&[u8]` are represented as `ConstValue::Slice`, let's keep using this\n+                // optimization for now.\n+                ty::Str => PatKind::Constant { value: cv },\n+                ty::Slice(elem_ty) if elem_ty == tcx.types.u8 => PatKind::Constant { value: cv },\n+                // `b\"foo\"` produces a `&[u8; 3]`, but you can't use constants of array type when\n+                // matching against references, you can only use byte string literals.\n+                // FIXME: clean this up, likely by permitting array patterns when matching on slices\n+                ty::Array(elem_ty, _) if elem_ty == tcx.types.u8 => PatKind::Constant { value: cv },\n+                // Cannot merge this with the catch all branch below, because the `const_deref`\n+                // changes the type from slice to array, and slice patterns behave differently from\n+                // array patterns.\n+                ty::Slice(..) => {\n+                    let old = self.behind_reference.replace(true);\n+                    let array = tcx.deref_const(self.param_env.and(cv));\n+                    let val = PatKind::Deref {\n+                        subpattern: Pat {\n+                            kind: Box::new(PatKind::Slice {\n+                                prefix: tcx\n+                                    .destructure_const(param_env.and(array))\n+                                    .fields\n+                                    .iter()\n+                                    .map(|val| self.recur(val, false))\n+                                    .collect::<Result<_, _>>()?,\n+                                slice: None,\n+                                suffix: vec![],\n+                            }),\n+                            span,\n+                            ty: pointee_ty,\n+                        },\n+                    };\n+                    self.behind_reference.set(old);\n+                    val\n+                }\n+                // Backwards compatibility hack: support references to non-structural types.\n+                // We'll lower\n+                // this pattern to a `PartialEq::eq` comparison and `PartialEq::eq` takes a\n+                // reference. This makes the rest of the matching logic simpler as it doesn't have\n+                // to figure out how to get a reference again.\n+                ty::Adt(adt_def, _) if !self.type_marked_structural(pointee_ty) => {\n+                    if self.behind_reference.get() {\n+                        if self.include_lint_checks\n+                            && !self.saw_const_match_error.get()\n+                            && !self.saw_const_match_lint.get()\n+                        {\n+                            self.saw_const_match_lint.set(true);\n+                            let msg = self.adt_derive_msg(adt_def);\n+                            self.tcx().struct_span_lint_hir(\n+                                lint::builtin::INDIRECT_STRUCTURAL_MATCH,\n+                                self.id,\n+                                self.span,\n+                                |lint| lint.build(&msg).emit(),\n+                            );\n+                        }\n+                        PatKind::Constant { value: cv }\n+                    } else {\n+                        if !self.saw_const_match_error.get() {\n+                            self.saw_const_match_error.set(true);\n+                            let msg = self.adt_derive_msg(adt_def);\n+                            if self.include_lint_checks {\n+                                tcx.sess.span_err(span, &msg);\n+                            } else {\n+                                tcx.sess.delay_span_bug(span, &msg)\n+                            }\n+                        }\n+                        PatKind::Wild\n+                    }\n+                }\n+                // All other references are converted into deref patterns and then recursively\n+                // convert the dereferenced constant to a pattern that is the sub-pattern of the\n+                // deref pattern.\n+                _ => {\n+                    let old = self.behind_reference.replace(true);\n+                    // In case there are structural-match violations somewhere in this subpattern,\n+                    // we fall back to a const pattern. If we do not do this, we may end up with\n+                    // a !structural-match constant that is not of reference type, which makes it\n+                    // very hard to invoke `PartialEq::eq` on it as a fallback.\n+                    let val = match self.recur(tcx.deref_const(self.param_env.and(cv)), false) {\n+                        Ok(subpattern) => PatKind::Deref { subpattern },\n+                        Err(_) => PatKind::Constant { value: cv },\n+                    };\n+                    self.behind_reference.set(old);\n+                    val\n+                }\n+            },\n+            ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::FnDef(..) => {\n+                PatKind::Constant { value: cv }\n+            }\n+            ty::RawPtr(pointee) if pointee.ty.is_sized(tcx.at(span), param_env) => {\n+                PatKind::Constant { value: cv }\n+            }\n+            // FIXME: these can have very suprising behaviour where optimization levels or other\n+            // compilation choices change the runtime behaviour of the match.\n+            // See https://github.com/rust-lang/rust/issues/70861 for examples.\n+            ty::FnPtr(..) | ty::RawPtr(..) => {\n+                if self.include_lint_checks\n+                    && !self.saw_const_match_error.get()\n+                    && !self.saw_const_match_lint.get()\n+                {\n+                    self.saw_const_match_lint.set(true);\n+                    let msg = \"function pointers and unsized pointers in patterns behave \\\n+                        unpredictably and should not be relied upon. \\\n+                        See https://github.com/rust-lang/rust/issues/70861 for details.\";\n+                    tcx.struct_span_lint_hir(\n+                        lint::builtin::POINTER_STRUCTURAL_MATCH,\n+                        id,\n+                        span,\n+                        |lint| lint.build(&msg).emit(),\n+                    );\n+                }\n+                PatKind::Constant { value: cv }\n+            }\n+            _ => {\n+                self.saw_const_match_error.set(true);\n+                let msg = format!(\"`{}` cannot be used in patterns\", cv.ty);\n+                if self.include_lint_checks {\n+                    tcx.sess.span_err(span, &msg);\n+                } else {\n+                    tcx.sess.delay_span_bug(span, &msg)\n+                }\n+                PatKind::Wild\n+            }\n         };\n \n-        Pat { span, ty: cv.ty, kind: Box::new(kind) }\n+        if self.include_lint_checks\n+            && !self.saw_const_match_error.get()\n+            && !self.saw_const_match_lint.get()\n+            && mir_structural_match_violation\n+            // FIXME(#73448): Find a way to bring const qualification into parity with\n+            // `search_for_structural_match_violation` and then remove this condition.\n+            && self.search_for_structural_match_violation(cv.ty).is_some()\n+        {\n+            self.saw_const_match_lint.set(true);\n+            // Obtain the actual type that isn't annotated. If we just looked at `cv.ty` we\n+            // could get `Option<NonStructEq>`, even though `Option` is annotated with derive.\n+            let msg = self.search_for_structural_match_violation(cv.ty).unwrap().replace(\n+                \"in a pattern,\",\n+                \"in a pattern, the constant's initializer must be trivial or\",\n+            );\n+            tcx.struct_span_lint_hir(\n+                lint::builtin::NONTRIVIAL_STRUCTURAL_MATCH,\n+                id,\n+                span,\n+                |lint| lint.build(&msg).emit(),\n+            );\n+        }\n+\n+        Ok(Pat { span, ty: cv.ty, kind: Box::new(kind) })\n     }\n }"}, {"sha": "13a4057a35bdf5858c4c8cb797e67e01d7e0f18c", "filename": "compiler/rustc_session/src/lint/builtin.rs", "status": "modified", "additions": 90, "deletions": 18, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/compiler%2Frustc_session%2Fsrc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/compiler%2Frustc_session%2Fsrc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Flint%2Fbuiltin.rs?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -2138,22 +2138,16 @@ declare_lint! {\n     /// ```rust,compile_fail\n     /// #![deny(indirect_structural_match)]\n     ///\n-    /// struct Plus(i32, i32);\n-    /// const ONE_PLUS_TWO: &&Plus = &&Plus(1, 2);\n-    ///\n-    /// impl PartialEq for Plus {\n-    ///     fn eq(&self, other: &Self) -> bool {\n-    ///         self.0 + self.1 == other.0 + other.1\n-    ///     }\n-    /// }\n-    ///\n-    /// impl Eq for Plus {}\n-    ///\n+    /// struct NoDerive(i32);\n+    /// impl PartialEq for NoDerive { fn eq(&self, _: &Self) -> bool { false } }\n+    /// impl Eq for NoDerive { }\n+    /// #[derive(PartialEq, Eq)]\n+    /// struct WrapParam<T>(T);\n+    /// const WRAP_INDIRECT_PARAM: & &WrapParam<NoDerive> = & &WrapParam(NoDerive(0));\n     /// fn main() {\n-    ///     if let ONE_PLUS_TWO = &&Plus(3, 0) {\n-    ///         println!(\"semantic!\");\n-    ///     } else {\n-    ///         println!(\"structural!\");\n+    ///     match WRAP_INDIRECT_PARAM {\n+    ///         WRAP_INDIRECT_PARAM => { }\n+    ///         _ => { }\n     ///     }\n     /// }\n     /// ```\n@@ -2170,9 +2164,8 @@ declare_lint! {\n     /// [issue #62411]: https://github.com/rust-lang/rust/issues/62411\n     /// [future-incompatible]: ../index.md#future-incompatible-lints\n     pub INDIRECT_STRUCTURAL_MATCH,\n-    // defaulting to allow until rust-lang/rust#62614 is fixed.\n-    Allow,\n-    \"pattern with const indirectly referencing non-structural-match type\",\n+    Warn,\n+    \"constant used in pattern contains value of non-structural-match type in a field or a variant\",\n     @future_incompatible = FutureIncompatibleInfo {\n         reference: \"issue #62411 <https://github.com/rust-lang/rust/issues/62411>\",\n         edition: None,\n@@ -2197,6 +2190,83 @@ declare_lint! {\n     report_in_external_macro\n }\n \n+declare_lint! {\n+    /// The `pointer_structural_match` lint detects pointers used in patterns whose behaviour\n+    /// cannot be relied upon across compiler versions and optimization levels.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(pointer_structural_match)]\n+    /// fn foo(a: usize, b: usize) -> usize { a + b }\n+    /// const FOO: fn(usize, usize) -> usize = foo;\n+    /// fn main() {\n+    ///     match FOO {\n+    ///         FOO => {},\n+    ///         _ => {},\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Previous versions of Rust allowed function pointers and wide raw pointers in patterns.\n+    /// While these work in many cases as expected by users, it is possible that due to\n+    /// optimizations pointers are \"not equal to themselves\" or pointers to different functions\n+    /// compare as equal during runtime. This is because LLVM optimizations can deduplicate\n+    /// functions if their bodies are the same, thus also making pointers to these functions point\n+    /// to the same location. Additionally functions may get duplicated if they are instantiated\n+    /// in different crates and not deduplicated again via LTO.\n+    pub POINTER_STRUCTURAL_MATCH,\n+    Allow,\n+    \"pointers are not structural-match\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #62411 <https://github.com/rust-lang/rust/issues/70861>\",\n+        edition: None,\n+    };\n+}\n+\n+declare_lint! {\n+    /// The `nontrivial_structural_match` lint detects constants that are used in patterns,\n+    /// whose type is not structural-match and whose initializer body actually uses values\n+    /// that are not structural-match. So `Option<NotStruturalMatch>` is ok if the constant\n+    /// is just `None`.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(nontrivial_structural_match)]\n+    ///\n+    /// #[derive(Copy, Clone, Debug)]\n+    /// struct NoDerive(u32);\n+    /// impl PartialEq for NoDerive { fn eq(&self, _: &Self) -> bool { false } }\n+    /// impl Eq for NoDerive { }\n+    /// fn main() {\n+    ///     const INDEX: Option<NoDerive> = [None, Some(NoDerive(10))][0];\n+    ///     match None { Some(_) => panic!(\"whoops\"), INDEX => dbg!(INDEX), };\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Previous versions of Rust accepted constants in patterns, even if those constants's types\n+    /// did not have `PartialEq` derived. Thus the compiler falls back to runtime execution of\n+    /// `PartialEq`, which can report that two constants are not equal even if they are\n+    /// bit-equivalent.\n+    pub NONTRIVIAL_STRUCTURAL_MATCH,\n+    Warn,\n+    \"constant used in pattern of non-structural-match type and the constant's initializer \\\n+    expression contains values of non-structural-match types\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #73448 <https://github.com/rust-lang/rust/issues/73448>\",\n+        edition: None,\n+    };\n+}\n+\n declare_lint! {\n     /// The `ambiguous_associated_items` lint detects ambiguity between\n     /// [associated items] and [enum variants].\n@@ -2630,6 +2700,8 @@ declare_lint_pass! {\n         AMBIGUOUS_ASSOCIATED_ITEMS,\n         MUTABLE_BORROW_RESERVATION_CONFLICT,\n         INDIRECT_STRUCTURAL_MATCH,\n+        POINTER_STRUCTURAL_MATCH,\n+        NONTRIVIAL_STRUCTURAL_MATCH,\n         SOFT_UNSTABLE,\n         INLINE_NO_SANITIZE,\n         ASM_SUB_REGISTER,"}, {"sha": "2663f682a1de82ab490e61e70bedf21c5ced597d", "filename": "library/std/src/ffi/os_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fos_str.rs?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -94,7 +94,7 @@ pub struct OsString {\n // `OsStr::from_inner` current implementation relies\n // on `OsStr` being layout-compatible with `Slice`.\n // When attribute privacy is implemented, `OsStr` should be annotated as `#[repr(transparent)]`.\n-// Anyway, `OsStr` representation and layout are considered implementation detail, are\n+// Anyway, `OsStr` representation and layout are considered implementation details, are\n // not documented and must not be relied upon.\n pub struct OsStr {\n     inner: Slice,"}, {"sha": "ab297f54dff3ea243372e3be3e7f4beb8dbc7d98", "filename": "src/test/ui/consts/const_in_pattern/cross-crate-fail.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fcross-crate-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fcross-crate-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fcross-crate-fail.rs?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -12,15 +12,13 @@ fn main() {\n     match None {\n         consts::SOME => panic!(),\n         //~^ must be annotated with `#[derive(PartialEq, Eq)]`\n-        //~| must be annotated with `#[derive(PartialEq, Eq)]`\n \n         _ => {}\n     }\n \n     match None {\n         <Defaulted as consts::AssocConst>::SOME  => panic!(),\n         //~^ must be annotated with `#[derive(PartialEq, Eq)]`\n-        //~| must be annotated with `#[derive(PartialEq, Eq)]`\n \n         _ => {}\n     }"}, {"sha": "a8066a88c35a6675d706ce29a9edfe7a7a8b0a29", "filename": "src/test/ui/consts/const_in_pattern/cross-crate-fail.stderr", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fcross-crate-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fcross-crate-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fcross-crate-fail.stderr?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -5,22 +5,10 @@ LL |         consts::SOME => panic!(),\n    |         ^^^^^^^^^^^^\n \n error: to use a constant of type `CustomEq` in a pattern, `CustomEq` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/cross-crate-fail.rs:21:9\n+  --> $DIR/cross-crate-fail.rs:20:9\n    |\n LL |         <Defaulted as consts::AssocConst>::SOME  => panic!(),\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: to use a constant of type `CustomEq` in a pattern, `CustomEq` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/cross-crate-fail.rs:13:9\n-   |\n-LL |         consts::SOME => panic!(),\n-   |         ^^^^^^^^^^^^\n-\n-error: to use a constant of type `CustomEq` in a pattern, `CustomEq` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/cross-crate-fail.rs:21:9\n-   |\n-LL |         <Defaulted as consts::AssocConst>::SOME  => panic!(),\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 4 previous errors\n+error: aborting due to 2 previous errors\n "}, {"sha": "856d204178d42b8d3ed289567e1412ea70d86d55", "filename": "src/test/ui/consts/const_in_pattern/custom-eq-branch-warn.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fcustom-eq-branch-warn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fcustom-eq-branch-warn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fcustom-eq-branch-warn.rs?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -1,8 +1,5 @@\n // check-pass\n \n-#![warn(indirect_structural_match)]\n-//~^ NOTE lint level is defined here\n-\n struct CustomEq;\n \n impl Eq for CustomEq {}\n@@ -32,7 +29,8 @@ fn main() {\n         BAR_BAZ => panic!(),\n         //~^ WARN must be annotated with `#[derive(PartialEq, Eq)]`\n         //~| WARN this was previously accepted\n-        //~| NOTE see issue #62411\n+        //~| NOTE see issue #73448\n+        //~| NOTE `#[warn(nontrivial_structural_match)]` on by default\n         _ => {}\n     }\n }"}, {"sha": "e51d6f916498ef4cb36f416d7a7feba1afa7fdb7", "filename": "src/test/ui/consts/const_in_pattern/custom-eq-branch-warn.stderr", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fcustom-eq-branch-warn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fcustom-eq-branch-warn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fcustom-eq-branch-warn.stderr?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -1,16 +1,12 @@\n-warning: to use a constant of type `CustomEq` in a pattern, `CustomEq` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/custom-eq-branch-warn.rs:32:9\n+warning: to use a constant of type `CustomEq` in a pattern, the constant's initializer must be trivial or `CustomEq` must be annotated with `#[derive(PartialEq, Eq)]`\n+  --> $DIR/custom-eq-branch-warn.rs:29:9\n    |\n LL |         BAR_BAZ => panic!(),\n    |         ^^^^^^^\n    |\n-note: the lint level is defined here\n-  --> $DIR/custom-eq-branch-warn.rs:3:9\n-   |\n-LL | #![warn(indirect_structural_match)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: `#[warn(nontrivial_structural_match)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #62411 <https://github.com/rust-lang/rust/issues/62411>\n+   = note: for more information, see issue #73448 <https://github.com/rust-lang/rust/issues/73448>\n \n warning: 1 warning emitted\n "}, {"sha": "2b421f4c705ecddea3ab9d3cc5b94b6c4fdf14cf", "filename": "src/test/ui/consts/const_in_pattern/issue-65466.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-65466.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-65466.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-65466.rs?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -1,9 +1,7 @@\n-// FIXME: This still ICEs.\n-//\n-// ignore-test\n-\n #![deny(indirect_structural_match)]\n \n+// check-pass\n+\n #[derive(PartialEq, Eq)]\n enum O<T> {\n     Some(*const T), // Can also use PhantomData<T>"}, {"sha": "9fe3049d1d85f3a6346dc25a90a0f104de7f6784", "filename": "src/test/ui/consts/const_in_pattern/issue-65466.stderr", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9e1c4361780e69ed54444a3b03fef0cbbc26b547/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-65466.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e1c4361780e69ed54444a3b03fef0cbbc26b547/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-65466.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fissue-65466.stderr?ref=9e1c4361780e69ed54444a3b03fef0cbbc26b547", "patch": "@@ -1,15 +0,0 @@\n-error[E0601]: `main` function not found in crate `issue_65466`\n-  --> $DIR/issue-65466.rs:1:1\n-   |\n-LL | / #![deny(indirect_structural_match)]\n-LL | |\n-LL | | #[derive(PartialEq, Eq)]\n-LL | | enum O<T> {\n-...  |\n-LL | |     }\n-LL | | }\n-   | |_^ consider adding a `main` function to `$DIR/issue-65466.rs`\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0601`."}, {"sha": "fc80d51c72daa80c48f5c4c7fbdc7bcc30883f70", "filename": "src/test/ui/consts/const_in_pattern/no-eq-branch-fail.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fno-eq-branch-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fno-eq-branch-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fno-eq-branch-fail.rs?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -20,7 +20,6 @@ fn main() {\n     match Foo::Qux(NoEq) {\n         BAR_BAZ => panic!(),\n         //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n-        //~| ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n         _ => {}\n     }\n }"}, {"sha": "e505dad69be072f8b014abd77f21173dc8a54f45", "filename": "src/test/ui/consts/const_in_pattern/no-eq-branch-fail.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fno-eq-branch-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fno-eq-branch-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fno-eq-branch-fail.stderr?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -4,11 +4,5 @@ error: to use a constant of type `Foo` in a pattern, `Foo` must be annotated wit\n LL |         BAR_BAZ => panic!(),\n    |         ^^^^^^^\n \n-error: to use a constant of type `Foo` in a pattern, `Foo` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/no-eq-branch-fail.rs:21:9\n-   |\n-LL |         BAR_BAZ => panic!(),\n-   |         ^^^^^^^\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n "}, {"sha": "7a8169bec45beadbcd6d6ed6ab72b61f87055ceb", "filename": "src/test/ui/consts/const_in_pattern/reject_non_structural.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Freject_non_structural.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Freject_non_structural.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Freject_non_structural.rs?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -39,51 +39,41 @@ fn main() {\n     const ENUM: Derive<NoDerive> = Derive::Some(NoDerive);\n     match Derive::Some(NoDerive) { ENUM => dbg!(ENUM), _ => panic!(\"whoops\"), };\n     //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n-    //~| ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n \n     const FIELD: OND = TrivialEq(Some(NoDerive)).0;\n     match Some(NoDerive) { FIELD => dbg!(FIELD), _ => panic!(\"whoops\"), };\n     //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n-    //~| ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n \n     const NO_DERIVE_SOME: OND = Some(NoDerive);\n     const INDIRECT: OND = NO_DERIVE_SOME;\n     match Some(NoDerive) {INDIRECT => dbg!(INDIRECT), _ => panic!(\"whoops\"), };\n     //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n-    //~| ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n \n     const TUPLE: (OND, OND) = (None, Some(NoDerive));\n     match (None, Some(NoDerive)) { TUPLE => dbg!(TUPLE), _ => panic!(\"whoops\"), };\n     //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n-    //~| ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n \n     const TYPE_ASCRIPTION: OND = Some(NoDerive): OND;\n     match Some(NoDerive) { TYPE_ASCRIPTION => dbg!(TYPE_ASCRIPTION), _ => panic!(\"whoops\"), };\n     //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n-    //~| ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n \n     const ARRAY: [OND; 2] = [None, Some(NoDerive)];\n     match [None, Some(NoDerive)] { ARRAY => dbg!(ARRAY), _ => panic!(\"whoops\"), };\n     //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n-    //~| ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n \n     const REPEAT: [OND; 2] = [Some(NoDerive); 2];\n     match [Some(NoDerive); 2] { REPEAT => dbg!(REPEAT), _ => panic!(\"whoops\"), };\n     //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n     //~| ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n-    //~| ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n-    //~| ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n \n     trait Trait: Sized { const ASSOC: Option<Self>; }\n     impl Trait for NoDerive { const ASSOC: Option<NoDerive> = Some(NoDerive); }\n     match Some(NoDerive) { NoDerive::ASSOC => dbg!(NoDerive::ASSOC), _ => panic!(\"whoops\"), };\n     //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n-    //~| ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n \n     const BLOCK: OND = { NoDerive; Some(NoDerive) };\n     match Some(NoDerive) { BLOCK => dbg!(BLOCK), _ => panic!(\"whoops\"), };\n     //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n-    //~| ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n \n     const ADDR_OF: &OND = &Some(NoDerive);\n     match &Some(NoDerive) { ADDR_OF => dbg!(ADDR_OF), _ => panic!(\"whoops\"), };"}, {"sha": "56405a55d699d83770ec8af3293b47199052c724", "filename": "src/test/ui/consts/const_in_pattern/reject_non_structural.stderr", "status": "modified", "additions": 11, "deletions": 71, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Freject_non_structural.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Freject_non_structural.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Freject_non_structural.stderr?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -5,61 +5,61 @@ LL |     match Derive::Some(NoDerive) { ENUM => dbg!(ENUM), _ => panic!(\"whoops\"\n    |                                    ^^^^\n \n error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/reject_non_structural.rs:45:28\n+  --> $DIR/reject_non_structural.rs:44:28\n    |\n LL |     match Some(NoDerive) { FIELD => dbg!(FIELD), _ => panic!(\"whoops\"), };\n    |                            ^^^^^\n \n error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/reject_non_structural.rs:51:27\n+  --> $DIR/reject_non_structural.rs:49:27\n    |\n LL |     match Some(NoDerive) {INDIRECT => dbg!(INDIRECT), _ => panic!(\"whoops\"), };\n    |                           ^^^^^^^^\n \n error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/reject_non_structural.rs:56:36\n+  --> $DIR/reject_non_structural.rs:53:36\n    |\n LL |     match (None, Some(NoDerive)) { TUPLE => dbg!(TUPLE), _ => panic!(\"whoops\"), };\n    |                                    ^^^^^\n \n error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/reject_non_structural.rs:61:28\n+  --> $DIR/reject_non_structural.rs:57:28\n    |\n LL |     match Some(NoDerive) { TYPE_ASCRIPTION => dbg!(TYPE_ASCRIPTION), _ => panic!(\"whoops\"), };\n    |                            ^^^^^^^^^^^^^^^\n \n error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/reject_non_structural.rs:66:36\n+  --> $DIR/reject_non_structural.rs:61:36\n    |\n LL |     match [None, Some(NoDerive)] { ARRAY => dbg!(ARRAY), _ => panic!(\"whoops\"), };\n    |                                    ^^^^^\n \n error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/reject_non_structural.rs:71:33\n+  --> $DIR/reject_non_structural.rs:65:33\n    |\n LL |     match [Some(NoDerive); 2] { REPEAT => dbg!(REPEAT), _ => panic!(\"whoops\"), };\n    |                                 ^^^^^^\n \n error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/reject_non_structural.rs:71:33\n+  --> $DIR/reject_non_structural.rs:65:33\n    |\n LL |     match [Some(NoDerive); 2] { REPEAT => dbg!(REPEAT), _ => panic!(\"whoops\"), };\n    |                                 ^^^^^^\n \n error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/reject_non_structural.rs:79:28\n+  --> $DIR/reject_non_structural.rs:71:28\n    |\n LL |     match Some(NoDerive) { NoDerive::ASSOC => dbg!(NoDerive::ASSOC), _ => panic!(\"whoops\"), };\n    |                            ^^^^^^^^^^^^^^^\n \n error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/reject_non_structural.rs:84:28\n+  --> $DIR/reject_non_structural.rs:75:28\n    |\n LL |     match Some(NoDerive) { BLOCK => dbg!(BLOCK), _ => panic!(\"whoops\"), };\n    |                            ^^^^^\n \n warning: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/reject_non_structural.rs:89:29\n+  --> $DIR/reject_non_structural.rs:79:29\n    |\n LL |     match &Some(NoDerive) { ADDR_OF => dbg!(ADDR_OF), _ => panic!(\"whoops\"), };\n    |                             ^^^^^^^\n@@ -72,65 +72,5 @@ LL | #![warn(indirect_structural_match)]\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #62411 <https://github.com/rust-lang/rust/issues/62411>\n \n-error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/reject_non_structural.rs:40:36\n-   |\n-LL |     match Derive::Some(NoDerive) { ENUM => dbg!(ENUM), _ => panic!(\"whoops\"), };\n-   |                                    ^^^^\n-\n-error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/reject_non_structural.rs:45:28\n-   |\n-LL |     match Some(NoDerive) { FIELD => dbg!(FIELD), _ => panic!(\"whoops\"), };\n-   |                            ^^^^^\n-\n-error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/reject_non_structural.rs:51:27\n-   |\n-LL |     match Some(NoDerive) {INDIRECT => dbg!(INDIRECT), _ => panic!(\"whoops\"), };\n-   |                           ^^^^^^^^\n-\n-error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/reject_non_structural.rs:56:36\n-   |\n-LL |     match (None, Some(NoDerive)) { TUPLE => dbg!(TUPLE), _ => panic!(\"whoops\"), };\n-   |                                    ^^^^^\n-\n-error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/reject_non_structural.rs:61:28\n-   |\n-LL |     match Some(NoDerive) { TYPE_ASCRIPTION => dbg!(TYPE_ASCRIPTION), _ => panic!(\"whoops\"), };\n-   |                            ^^^^^^^^^^^^^^^\n-\n-error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/reject_non_structural.rs:66:36\n-   |\n-LL |     match [None, Some(NoDerive)] { ARRAY => dbg!(ARRAY), _ => panic!(\"whoops\"), };\n-   |                                    ^^^^^\n-\n-error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/reject_non_structural.rs:71:33\n-   |\n-LL |     match [Some(NoDerive); 2] { REPEAT => dbg!(REPEAT), _ => panic!(\"whoops\"), };\n-   |                                 ^^^^^^\n-\n-error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/reject_non_structural.rs:71:33\n-   |\n-LL |     match [Some(NoDerive); 2] { REPEAT => dbg!(REPEAT), _ => panic!(\"whoops\"), };\n-   |                                 ^^^^^^\n-\n-error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/reject_non_structural.rs:79:28\n-   |\n-LL |     match Some(NoDerive) { NoDerive::ASSOC => dbg!(NoDerive::ASSOC), _ => panic!(\"whoops\"), };\n-   |                            ^^^^^^^^^^^^^^^\n-\n-error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/reject_non_structural.rs:84:28\n-   |\n-LL |     match Some(NoDerive) { BLOCK => dbg!(BLOCK), _ => panic!(\"whoops\"), };\n-   |                            ^^^^^\n-\n-error: aborting due to 20 previous errors; 1 warning emitted\n+error: aborting due to 10 previous errors; 1 warning emitted\n "}, {"sha": "a24c8d181843d9973e2a238c0bf6f2ecd0b48b4f", "filename": "src/test/ui/consts/const_in_pattern/warn_corner_cases.stderr", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fwarn_corner_cases.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fwarn_corner_cases.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_in_pattern%2Fwarn_corner_cases.stderr?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -1,34 +1,30 @@\n-warning: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+warning: to use a constant of type `NoDerive` in a pattern, the constant's initializer must be trivial or `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n   --> $DIR/warn_corner_cases.rs:26:47\n    |\n LL |     match None { Some(_) => panic!(\"whoops\"), INDEX => dbg!(INDEX), };\n    |                                               ^^^^^\n    |\n-note: the lint level is defined here\n-  --> $DIR/warn_corner_cases.rs:15:9\n-   |\n-LL | #![warn(indirect_structural_match)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: `#[warn(nontrivial_structural_match)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #62411 <https://github.com/rust-lang/rust/issues/62411>\n+   = note: for more information, see issue #73448 <https://github.com/rust-lang/rust/issues/73448>\n \n-warning: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+warning: to use a constant of type `NoDerive` in a pattern, the constant's initializer must be trivial or `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n   --> $DIR/warn_corner_cases.rs:32:47\n    |\n LL |     match None { Some(_) => panic!(\"whoops\"), CALL => dbg!(CALL), };\n    |                                               ^^^^\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #62411 <https://github.com/rust-lang/rust/issues/62411>\n+   = note: for more information, see issue #73448 <https://github.com/rust-lang/rust/issues/73448>\n \n-warning: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n+warning: to use a constant of type `NoDerive` in a pattern, the constant's initializer must be trivial or `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n   --> $DIR/warn_corner_cases.rs:38:47\n    |\n LL |     match None { Some(_) => panic!(\"whoops\"), METHOD_CALL => dbg!(METHOD_CALL), };\n    |                                               ^^^^^^^^^^^\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #62411 <https://github.com/rust-lang/rust/issues/62411>\n+   = note: for more information, see issue #73448 <https://github.com/rust-lang/rust/issues/73448>\n \n warning: 3 warnings emitted\n "}, {"sha": "0295204c879ca8d12c1863b8c94c3140c8264e97", "filename": "src/test/ui/consts/consts-in-patterns.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fconsts%2Fconsts-in-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fconsts%2Fconsts-in-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconsts-in-patterns.rs?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -19,8 +19,6 @@ pub fn main() {\n     assert_eq!(y, 2);\n     let z = match &() {\n         ZST => 9,\n-        // FIXME: this should not be required\n-        _ => 42,\n     };\n     assert_eq!(z, 9);\n     let z = match b\"\" {"}, {"sha": "632335c841e3a51239a5f7662468d0de78a00b02", "filename": "src/test/ui/consts/match_ice.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fconsts%2Fmatch_ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fconsts%2Fmatch_ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmatch_ice.rs?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -9,11 +9,10 @@ fn main() {\n     const C: &S = &S;\n     match C {\n         C => {}\n-        //~^ ERROR to use a constant of type `S` in a pattern, `S` must be annotated with\n-        //~| ERROR to use a constant of type `S` in a pattern, `S` must be annotated with\n+        //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n     }\n     const K: &T = &T;\n-    match K { //~ ERROR non-exhaustive patterns: `&T` not covered\n+    match K {\n         K => {}\n     }\n }"}, {"sha": "699b4a5e200e41311cfaabfdde075b812b89098e", "filename": "src/test/ui/consts/match_ice.stderr", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fconsts%2Fmatch_ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fconsts%2Fmatch_ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmatch_ice.stderr?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -4,24 +4,5 @@ error: to use a constant of type `S` in a pattern, `S` must be annotated with `#\n LL |         C => {}\n    |         ^\n \n-error[E0004]: non-exhaustive patterns: `&T` not covered\n-  --> $DIR/match_ice.rs:16:11\n-   |\n-LL | struct T;\n-   | --------- `T` defined here\n-...\n-LL |     match K {\n-   |           ^ pattern `&T` not covered\n-   |\n-   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n-   = note: the matched value is of type `&T`\n-\n-error: to use a constant of type `S` in a pattern, `S` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/match_ice.rs:11:9\n-   |\n-LL |         C => {}\n-   |         ^\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0004`."}, {"sha": "98d943470a7f9ac05aa3e31abd1997fca5e3b7a5", "filename": "src/test/ui/issues/issue-34784.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fissues%2Fissue-34784.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fissues%2Fissue-34784.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-34784.rs?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -1,4 +1,6 @@\n // run-pass\n+\n+#![warn(pointer_structural_match)]\n #![allow(dead_code)]\n const C: *const u8 = &0;\n "}, {"sha": "96e8795e52d56687ceb660c8d9a5bd1833f1e8e4", "filename": "src/test/ui/issues/issue-44333.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fissues%2Fissue-44333.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fissues%2Fissue-44333.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-44333.rs?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -1,4 +1,7 @@\n // run-pass\n+\n+#![warn(pointer_structural_match)]\n+\n type Func = fn(usize, usize) -> usize;\n \n fn foo(a: usize, b: usize) -> usize { a + b }\n@@ -13,8 +16,10 @@ const BAR: Func = bar;\n \n fn main() {\n     match test(std::env::consts::ARCH.len()) {\n-        FOO => println!(\"foo\"),\n-        BAR => println!(\"bar\"),\n+        FOO => println!(\"foo\"), //~ WARN pointers in patterns behave unpredictably\n+        //~^ WARN will become a hard error\n+        BAR => println!(\"bar\"), //~ WARN pointers in patterns behave unpredictably\n+        //~^ WARN will become a hard error\n         _ => unreachable!(),\n     }\n }"}, {"sha": "8302b09e5334d0b62919327b4258d3bbc85b69a5", "filename": "src/test/ui/issues/issue-44333.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fissues%2Fissue-44333.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fissues%2Fissue-44333.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-44333.stderr?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -0,0 +1,25 @@\n+warning: function pointers and unsized pointers in patterns behave unpredictably and should not be relied upon. See https://github.com/rust-lang/rust/issues/70861 for details.\n+  --> $DIR/issue-44333.rs:19:9\n+   |\n+LL |         FOO => println!(\"foo\"),\n+   |         ^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-44333.rs:3:9\n+   |\n+LL | #![warn(pointer_structural_match)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #62411 <https://github.com/rust-lang/rust/issues/70861>\n+\n+warning: function pointers and unsized pointers in patterns behave unpredictably and should not be relied upon. See https://github.com/rust-lang/rust/issues/70861 for details.\n+  --> $DIR/issue-44333.rs:21:9\n+   |\n+LL |         BAR => println!(\"bar\"),\n+   |         ^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #62411 <https://github.com/rust-lang/rust/issues/70861>\n+\n+warning: 2 warnings emitted\n+"}, {"sha": "97d161c59ec2a8fd8e7308d20111dad6a2b8f3e2", "filename": "src/test/ui/match/issue-70972-dyn-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fmatch%2Fissue-70972-dyn-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fmatch%2Fissue-70972-dyn-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fissue-70972-dyn-trait.rs?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -4,7 +4,7 @@ fn main() {\n     let a: &dyn Send = &7u32;\n     match a {\n         F => panic!(),\n-        //~^ ERROR trait objects cannot be used in patterns\n+        //~^ ERROR `&dyn Send` cannot be used in patterns\n         _ => {}\n     }\n }"}, {"sha": "7581070ebc1726b64189ae39b522703c0492448e", "filename": "src/test/ui/match/issue-70972-dyn-trait.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fmatch%2Fissue-70972-dyn-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fmatch%2Fissue-70972-dyn-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fissue-70972-dyn-trait.stderr?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -1,4 +1,4 @@\n-error: trait objects cannot be used in patterns\n+error: `&dyn Send` cannot be used in patterns\n   --> $DIR/issue-70972-dyn-trait.rs:6:9\n    |\n LL |         F => panic!(),"}, {"sha": "caa6d184a92ddc2aeff326180a93585798bce045", "filename": "src/test/ui/match/pattern-deref-miscompile.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fmatch%2Fpattern-deref-miscompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fmatch%2Fpattern-deref-miscompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fpattern-deref-miscompile.rs?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -0,0 +1,46 @@\n+// run-pass\n+\n+fn main() {\n+    match b\".\" as &[u8] {\n+        b\".\" if true => {},\n+        b\".\" => panic!(),\n+        b\"..\" => panic!(),\n+        b\"\" => panic!(),\n+        _ => panic!(),\n+    }\n+    match b\".\" as &[u8] {\n+        b\".\" if false => panic!(),\n+        b\".\" => {},\n+        b\"..\" => panic!(),\n+        b\"\" => panic!(),\n+        _ => panic!(),\n+    }\n+    match b\"..\" as &[u8] {\n+        b\".\" if true => panic!(), // the miscompile caused this arm to be reached\n+        b\".\" => panic!(),\n+        b\"..\" => {},\n+        b\"\" => panic!(),\n+        _ => panic!(),\n+    }\n+    match b\"..\" as &[u8] {\n+        b\".\" if false => panic!(),\n+        b\".\" => panic!(),\n+        b\"..\" => {},\n+        b\"\" => panic!(),\n+        _ => panic!(),\n+    }\n+    match b\"\" as &[u8] {\n+        b\".\" if true => panic!(),\n+        b\".\" => panic!(),\n+        b\"..\" => panic!(),\n+        b\"\" => {},\n+        _ => panic!(),\n+    }\n+    match b\"\" as &[u8] {\n+        b\".\" if false => panic!(),\n+        b\".\" => panic!(),\n+        b\"..\" => panic!(),\n+        b\"\" => {},\n+        _ => panic!(),\n+    }\n+}"}, {"sha": "abfacf3936b6dd61d00415f37fcaa0d74a456769", "filename": "src/test/ui/pattern/const-pat-ice.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fpattern%2Fconst-pat-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fpattern%2Fconst-pat-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fconst-pat-ice.rs?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -1,10 +1,4 @@\n-// failure-status: 101\n-// rustc-env:RUST_BACKTRACE=0\n-// normalize-stderr-test \"note: rustc 1.* running on .*\" -> \"note: rustc VERSION running on TARGET\"\n-// normalize-stderr-test \"note: compiler flags: .*\" -> \"note: compiler flags: FLAGS\"\n-// normalize-stderr-test \"/_match.rs:[0-9]+:[0-9]+\" -> \"/_match.rs:LL:CC\"\n-\n-// This is a repro test for an ICE in our pattern handling of constants.\n+// check-pass\n \n const FOO: &&&u32 = &&&42;\n "}, {"sha": "6b42c0e0848e9538a5efa0992504c96833e003a5", "filename": "src/test/ui/pattern/const-pat-ice.stderr", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9e1c4361780e69ed54444a3b03fef0cbbc26b547/src%2Ftest%2Fui%2Fpattern%2Fconst-pat-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e1c4361780e69ed54444a3b03fef0cbbc26b547/src%2Ftest%2Fui%2Fpattern%2Fconst-pat-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fconst-pat-ice.stderr?ref=9e1c4361780e69ed54444a3b03fef0cbbc26b547", "patch": "@@ -1,13 +0,0 @@\n-thread 'rustc' panicked at 'assertion failed: rows.iter().all(|r| r.len() == v.len())', compiler/rustc_mir_build/src/thir/pattern/_match.rs:LL:CC\n-note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n-\n-error: internal compiler error: unexpected panic\n-\n-note: the compiler unexpectedly panicked. this is a bug.\n-\n-note: we would appreciate a bug report: https://github.com/rust-lang/rust/issues/new?labels=C-bug%2C+I-ICE%2C+T-compiler&template=ice.md\n-\n-note: rustc VERSION running on TARGET\n-\n-note: compiler flags: FLAGS\n-"}, {"sha": "65f27cf78f12030517ec0ccb73b4a3be40fdd48f", "filename": "src/test/ui/pattern/issue-71042-opaquely-typed-constant-used-in-pattern.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fpattern%2Fissue-71042-opaquely-typed-constant-used-in-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fpattern%2Fissue-71042-opaquely-typed-constant-used-in-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fissue-71042-opaquely-typed-constant-used-in-pattern.rs?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -4,6 +4,7 @@\n fn main() {\n     const C: impl Copy = 0;\n     match C {\n-        C | _ => {} //~ ERROR: opaque types cannot be used in patterns\n+        C | //~ ERROR: `impl Copy` cannot be used in patterns\n+        _ => {}\n     }\n }"}, {"sha": "62dc856be821fdbe804167f76d83423c35f444c0", "filename": "src/test/ui/pattern/issue-71042-opaquely-typed-constant-used-in-pattern.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fpattern%2Fissue-71042-opaquely-typed-constant-used-in-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fpattern%2Fissue-71042-opaquely-typed-constant-used-in-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fissue-71042-opaquely-typed-constant-used-in-pattern.stderr?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -1,7 +1,7 @@\n-error: opaque types cannot be used in patterns\n+error: `impl Copy` cannot be used in patterns\n   --> $DIR/issue-71042-opaquely-typed-constant-used-in-pattern.rs:7:9\n    |\n-LL |         C | _ => {}\n+LL |         C |\n    |         ^\n \n error: aborting due to previous error"}, {"sha": "78cc0d28fb0375b56f314e9079ef3815eabde3eb", "filename": "src/test/ui/pattern/usefulness/exhaustive_integer_patterns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fexhaustive_integer_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fexhaustive_integer_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fexhaustive_integer_patterns.rs?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -160,7 +160,7 @@ fn main() {\n     match &0 {\n         &42 => {}\n         &FOO => {} //~ ERROR unreachable pattern\n-        BAR => {} // Not detected as unreachable because `try_eval_bits` fails on `BAR`.\n+        BAR => {} //~ ERROR unreachable pattern\n         _ => {}\n     }\n "}, {"sha": "9f076c50a8f09999c167d3aaf5ea37918c39d397", "filename": "src/test/ui/pattern/usefulness/exhaustive_integer_patterns.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fexhaustive_integer_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fexhaustive_integer_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fexhaustive_integer_patterns.stderr?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -135,6 +135,12 @@ error: unreachable pattern\n LL |         &FOO => {}\n    |         ^^^^\n \n-error: aborting due to 15 previous errors\n+error: unreachable pattern\n+  --> $DIR/exhaustive_integer_patterns.rs:163:9\n+   |\n+LL |         BAR => {}\n+   |         ^^^\n+\n+error: aborting due to 16 previous errors\n \n For more information about this error, try `rustc --explain E0004`."}, {"sha": "4bf8d0fd2d306064ca283b6dc13e36c9e800d22a", "filename": "src/test/ui/pattern/usefulness/slice-pattern-const-2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const-2.rs?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -6,19 +6,19 @@ fn main() {\n     match s {\n         MAGIC_TEST => (),\n         [0x00, 0x00, 0x00, 0x00] => (),\n-        [4, 5, 6, 7] => (), // FIXME(oli-obk): this should warn, but currently does not\n+        [4, 5, 6, 7] => (), //~ ERROR unreachable pattern\n         _ => (),\n     }\n     match s {\n         [0x00, 0x00, 0x00, 0x00] => (),\n         MAGIC_TEST => (),\n-        [4, 5, 6, 7] => (), // FIXME(oli-obk): this should warn, but currently does not\n+        [4, 5, 6, 7] => (), //~ ERROR unreachable pattern\n         _ => (),\n     }\n     match s {\n         [0x00, 0x00, 0x00, 0x00] => (),\n         [4, 5, 6, 7] => (),\n-        MAGIC_TEST => (), // FIXME(oli-obk): this should warn, but currently does not\n+        MAGIC_TEST => (), //~ ERROR unreachable pattern\n         _ => (),\n     }\n     const FOO: [u32; 1] = [4];"}, {"sha": "dcad11a38a7ebadd8bc0b6350afd8f355a450b1c", "filename": "src/test/ui/pattern/usefulness/slice-pattern-const-2.stderr", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const-2.stderr?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -1,14 +1,32 @@\n error: unreachable pattern\n-  --> $DIR/slice-pattern-const-2.rs:28:9\n+  --> $DIR/slice-pattern-const-2.rs:9:9\n    |\n-LL |         FOO => (),\n-   |         ^^^\n+LL |         [4, 5, 6, 7] => (),\n+   |         ^^^^^^^^^^^^\n    |\n note: the lint level is defined here\n   --> $DIR/slice-pattern-const-2.rs:1:9\n    |\n LL | #![deny(unreachable_patterns)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error: unreachable pattern\n+  --> $DIR/slice-pattern-const-2.rs:15:9\n+   |\n+LL |         [4, 5, 6, 7] => (),\n+   |         ^^^^^^^^^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/slice-pattern-const-2.rs:21:9\n+   |\n+LL |         MAGIC_TEST => (),\n+   |         ^^^^^^^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/slice-pattern-const-2.rs:28:9\n+   |\n+LL |         FOO => (),\n+   |         ^^^\n+\n+error: aborting due to 4 previous errors\n "}, {"sha": "2ca8323f00295dfb780efa71683b002a5c7c24e8", "filename": "src/test/ui/pattern/usefulness/slice-pattern-const-3.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const-3.rs?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -6,19 +6,19 @@ fn main() {\n     match s {\n         MAGIC_TEST => (),\n         [\"0x00\", \"0x00\", \"0x00\", \"0x00\"] => (),\n-        [\"4\", \"5\", \"6\", \"7\"] => (), // FIXME(oli-obk): this should warn, but currently does not\n+        [\"4\", \"5\", \"6\", \"7\"] => (), //~ ERROR unreachable pattern\n         _ => (),\n     }\n     match s {\n         [\"0x00\", \"0x00\", \"0x00\", \"0x00\"] => (),\n         MAGIC_TEST => (),\n-        [\"4\", \"5\", \"6\", \"7\"] => (), // FIXME(oli-obk): this should warn, but currently does not\n+        [\"4\", \"5\", \"6\", \"7\"] => (), //~ ERROR unreachable pattern\n         _ => (),\n     }\n     match s {\n         [\"0x00\", \"0x00\", \"0x00\", \"0x00\"] => (),\n         [\"4\", \"5\", \"6\", \"7\"] => (),\n-        MAGIC_TEST => (), // FIXME(oli-obk): this should warn, but currently does not\n+        MAGIC_TEST => (), //~ ERROR unreachable pattern\n         _ => (),\n     }\n     const FOO: [&str; 1] = [\"boo\"];"}, {"sha": "b90b3a88a18602cb72bed06fa7dc92c6fa9f57a1", "filename": "src/test/ui/pattern/usefulness/slice-pattern-const-3.stderr", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-pattern-const-3.stderr?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -1,14 +1,32 @@\n error: unreachable pattern\n-  --> $DIR/slice-pattern-const-3.rs:28:9\n+  --> $DIR/slice-pattern-const-3.rs:9:9\n    |\n-LL |         FOO => (),\n-   |         ^^^\n+LL |         [\"4\", \"5\", \"6\", \"7\"] => (),\n+   |         ^^^^^^^^^^^^^^^^^^^^\n    |\n note: the lint level is defined here\n   --> $DIR/slice-pattern-const-3.rs:1:9\n    |\n LL | #![deny(unreachable_patterns)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error: unreachable pattern\n+  --> $DIR/slice-pattern-const-3.rs:15:9\n+   |\n+LL |         [\"4\", \"5\", \"6\", \"7\"] => (),\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/slice-pattern-const-3.rs:21:9\n+   |\n+LL |         MAGIC_TEST => (),\n+   |         ^^^^^^^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/slice-pattern-const-3.rs:28:9\n+   |\n+LL |         FOO => (),\n+   |         ^^^\n+\n+error: aborting due to 4 previous errors\n "}, {"sha": "46e0da5be9b4fdf126f3c7041fb16c28b6245568", "filename": "src/test/ui/pattern/usefulness/slice-patterns-exhaustiveness.rs", "status": "modified", "additions": 43, "deletions": 19, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.rs?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -6,15 +6,15 @@ fn main() {\n     let s10: &[bool; 10] = &[false; 10];\n \n     match s2 {\n-    //~^ ERROR `&[false, _]` not covered\n+        //~^ ERROR `&[false, _]` not covered\n         [true, .., true] => {}\n     }\n     match s3 {\n-    //~^ ERROR `&[false, ..]` not covered\n+        //~^ ERROR `&[false, ..]` not covered\n         [true, .., true] => {}\n     }\n     match s10 {\n-    //~^ ERROR `&[false, ..]` not covered\n+        //~^ ERROR `&[false, ..]` not covered\n         [true, .., true] => {}\n     }\n \n@@ -23,58 +23,58 @@ fn main() {\n         [.., false] => {}\n     }\n     match s2 {\n-    //~^ ERROR `&[false, true]` not covered\n+        //~^ ERROR `&[false, true]` not covered\n         [true, ..] => {}\n         [.., false] => {}\n     }\n     match s3 {\n-    //~^ ERROR `&[false, .., true]` not covered\n+        //~^ ERROR `&[false, .., true]` not covered\n         [true, ..] => {}\n         [.., false] => {}\n     }\n     match s {\n-    //~^ ERROR `&[false, .., true]` not covered\n+        //~^ ERROR `&[false, .., true]` not covered\n         [] => {}\n         [true, ..] => {}\n         [.., false] => {}\n     }\n \n     match s {\n-    //~^ ERROR `&[_, ..]` not covered\n+        //~^ ERROR `&[_, ..]` not covered\n         [] => {}\n     }\n     match s {\n-    //~^ ERROR `&[_, _, ..]` not covered\n+        //~^ ERROR `&[_, _, ..]` not covered\n         [] => {}\n         [_] => {}\n     }\n     match s {\n-    //~^ ERROR `&[false, ..]` not covered\n+        //~^ ERROR `&[false, ..]` not covered\n         [] => {}\n         [true, ..] => {}\n     }\n     match s {\n-    //~^ ERROR `&[false, _, ..]` not covered\n+        //~^ ERROR `&[false, _, ..]` not covered\n         [] => {}\n         [_] => {}\n         [true, ..] => {}\n     }\n     match s {\n-    //~^ ERROR `&[_, .., false]` not covered\n+        //~^ ERROR `&[_, .., false]` not covered\n         [] => {}\n         [_] => {}\n         [.., true] => {}\n     }\n \n     match s {\n-    //~^ ERROR `&[_, _, .., true]` not covered\n+        //~^ ERROR `&[_, _, .., true]` not covered\n         [] => {}\n         [_] => {}\n         [_, _] => {}\n         [.., false] => {}\n     }\n     match s {\n-    //~^ ERROR `&[true, _, .., _]` not covered\n+        //~^ ERROR `&[true, _, .., _]` not covered\n         [] => {}\n         [_] => {}\n         [_, _] => {}\n@@ -83,19 +83,43 @@ fn main() {\n \n     const CONST: &[bool] = &[true];\n     match s {\n-    //~^ ERROR `&[..]` not covered\n+        //~^ ERROR `&[]` and `&[_, _, ..]` not covered\n+        &[true] => {}\n+    }\n+    match s {\n+        //~^ ERROR `&[]` and `&[_, _, ..]` not covered\n+        CONST => {}\n+    }\n+    match s {\n+        //~^ ERROR `&[]` and `&[_, _, ..]` not covered\n         CONST => {}\n+        &[false] => {}\n     }\n     match s {\n-    //~^ ERROR `&[true]` not covered\n-        [] => {},\n-        [false] => {},\n-        CONST => {},\n+        //~^ ERROR `&[]` and `&[_, _, ..]` not covered\n+        &[false] => {}\n+        CONST => {}\n+    }\n+    match s {\n+        //~^ ERROR `&[_, _, ..]` not covered\n+        &[] => {}\n+        CONST => {}\n+    }\n+    match s {\n+        //~^ ERROR `&[false]` not covered\n+        &[] => {}\n+        CONST => {}\n+        &[_, _, ..] => {}\n+    }\n+    match s {\n+        [] => {}\n+        [false] => {}\n+        CONST => {}\n         [_, _, ..] => {}\n     }\n     const CONST1: &[bool; 1] = &[true];\n     match s1 {\n-    //~^ ERROR `&[false]` not covered\n+        //~^ ERROR `&[false]` not covered\n         CONST1 => {}\n     }\n     match s1 {"}, {"sha": "e34770fb912e79437a0b98a901590bc3eaecacb8", "filename": "src/test/ui/pattern/usefulness/slice-patterns-exhaustiveness.stderr", "status": "modified", "additions": 42, "deletions": 6, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fslice-patterns-exhaustiveness.stderr?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -115,33 +115,69 @@ LL |     match s {\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[bool]`\n \n-error[E0004]: non-exhaustive patterns: `&[..]` not covered\n+error[E0004]: non-exhaustive patterns: `&[]` and `&[_, _, ..]` not covered\n   --> $DIR/slice-patterns-exhaustiveness.rs:85:11\n    |\n LL |     match s {\n-   |           ^ pattern `&[..]` not covered\n+   |           ^ patterns `&[]` and `&[_, _, ..]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[bool]`\n \n-error[E0004]: non-exhaustive patterns: `&[true]` not covered\n+error[E0004]: non-exhaustive patterns: `&[]` and `&[_, _, ..]` not covered\n   --> $DIR/slice-patterns-exhaustiveness.rs:89:11\n    |\n LL |     match s {\n-   |           ^ pattern `&[true]` not covered\n+   |           ^ patterns `&[]` and `&[_, _, ..]` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `&[bool]`\n+\n+error[E0004]: non-exhaustive patterns: `&[]` and `&[_, _, ..]` not covered\n+  --> $DIR/slice-patterns-exhaustiveness.rs:93:11\n+   |\n+LL |     match s {\n+   |           ^ patterns `&[]` and `&[_, _, ..]` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `&[bool]`\n+\n+error[E0004]: non-exhaustive patterns: `&[]` and `&[_, _, ..]` not covered\n+  --> $DIR/slice-patterns-exhaustiveness.rs:98:11\n+   |\n+LL |     match s {\n+   |           ^ patterns `&[]` and `&[_, _, ..]` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `&[bool]`\n+\n+error[E0004]: non-exhaustive patterns: `&[_, _, ..]` not covered\n+  --> $DIR/slice-patterns-exhaustiveness.rs:103:11\n+   |\n+LL |     match s {\n+   |           ^ pattern `&[_, _, ..]` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `&[bool]`\n+\n+error[E0004]: non-exhaustive patterns: `&[false]` not covered\n+  --> $DIR/slice-patterns-exhaustiveness.rs:108:11\n+   |\n+LL |     match s {\n+   |           ^ pattern `&[false]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[bool]`\n \n error[E0004]: non-exhaustive patterns: `&[false]` not covered\n-  --> $DIR/slice-patterns-exhaustiveness.rs:97:11\n+  --> $DIR/slice-patterns-exhaustiveness.rs:121:11\n    |\n LL |     match s1 {\n    |           ^^ pattern `&[false]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[bool; 1]`\n \n-error: aborting due to 16 previous errors\n+error: aborting due to 20 previous errors\n \n For more information about this error, try `rustc --explain E0004`."}, {"sha": "c6d7166e74065bde8a2c5ca1fc42619a8193a632", "filename": "src/test/ui/rfc1445/allow-hide-behind-direct-unsafe-ptr-embedded.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Frfc1445%2Fallow-hide-behind-direct-unsafe-ptr-embedded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Frfc1445%2Fallow-hide-behind-direct-unsafe-ptr-embedded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fallow-hide-behind-direct-unsafe-ptr-embedded.rs?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -3,6 +3,8 @@\n \n // run-pass\n \n+#![warn(pointer_structural_match)]\n+\n struct NoDerive(i32);\n \n // This impl makes NoDerive irreflexive"}, {"sha": "cc7ea6cde8d7f3bea786f4460fc9a2f0197dac34", "filename": "src/test/ui/rfc1445/allow-hide-behind-direct-unsafe-ptr-param.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Frfc1445%2Fallow-hide-behind-direct-unsafe-ptr-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Frfc1445%2Fallow-hide-behind-direct-unsafe-ptr-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fallow-hide-behind-direct-unsafe-ptr-param.rs?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -3,6 +3,8 @@\n \n // run-pass\n \n+#![warn(pointer_structural_match)]\n+\n struct NoDerive(i32);\n \n // This impl makes NoDerive irreflexive"}, {"sha": "86db09cc08fc8a0194f16c0dc92ba14fbb1ab02f", "filename": "src/test/ui/rfc1445/allow-hide-behind-indirect-unsafe-ptr-embedded.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Frfc1445%2Fallow-hide-behind-indirect-unsafe-ptr-embedded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Frfc1445%2Fallow-hide-behind-indirect-unsafe-ptr-embedded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fallow-hide-behind-indirect-unsafe-ptr-embedded.rs?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -3,6 +3,8 @@\n \n // run-pass\n \n+#![warn(pointer_structural_match)]\n+\n struct NoDerive(i32);\n \n // This impl makes NoDerive irreflexive"}, {"sha": "99c574d0780457345a05e8d9387df403d39b142d", "filename": "src/test/ui/rfc1445/allow-hide-behind-indirect-unsafe-ptr-param.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Frfc1445%2Fallow-hide-behind-indirect-unsafe-ptr-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Frfc1445%2Fallow-hide-behind-indirect-unsafe-ptr-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fallow-hide-behind-indirect-unsafe-ptr-param.rs?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -3,6 +3,8 @@\n \n // run-pass\n \n+#![warn(pointer_structural_match)]\n+\n struct NoDerive(i32);\n \n // This impl makes NoDerive irreflexive"}, {"sha": "4a8a09493798eb33ae463005dfef96d95b74ecbe", "filename": "src/test/ui/rfc1445/cant-hide-behind-direct-struct-embedded.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-direct-struct-embedded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-direct-struct-embedded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-direct-struct-embedded.rs?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -21,7 +21,6 @@ fn main() {\n     match WRAP_DIRECT_INLINE {\n         WRAP_DIRECT_INLINE => { panic!(\"WRAP_DIRECT_INLINE matched itself\"); }\n         //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n-        //~| ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n         _ => { println!(\"WRAP_DIRECT_INLINE did not match itself\"); }\n     }\n }"}, {"sha": "c73a6cf1326b3e3a7401deec42407cebeeb144f8", "filename": "src/test/ui/rfc1445/cant-hide-behind-direct-struct-embedded.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-direct-struct-embedded.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-direct-struct-embedded.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-direct-struct-embedded.stderr?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -4,11 +4,5 @@ error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be ann\n LL |         WRAP_DIRECT_INLINE => { panic!(\"WRAP_DIRECT_INLINE matched itself\"); }\n    |         ^^^^^^^^^^^^^^^^^^\n \n-error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/cant-hide-behind-direct-struct-embedded.rs:22:9\n-   |\n-LL |         WRAP_DIRECT_INLINE => { panic!(\"WRAP_DIRECT_INLINE matched itself\"); }\n-   |         ^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n "}, {"sha": "93022a23dbfb8d5b74868f529e320e5eb9c5ad99", "filename": "src/test/ui/rfc1445/cant-hide-behind-direct-struct-param.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-direct-struct-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-direct-struct-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-direct-struct-param.rs?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -21,7 +21,6 @@ fn main() {\n     match WRAP_DIRECT_PARAM {\n         WRAP_DIRECT_PARAM => { panic!(\"WRAP_DIRECT_PARAM matched itself\"); }\n         //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n-        //~| ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n         _ => { println!(\"WRAP_DIRECT_PARAM did not match itself\"); }\n     }\n }"}, {"sha": "6fdf9db89b8dc4a74c007e6089bbe434394a39eb", "filename": "src/test/ui/rfc1445/cant-hide-behind-direct-struct-param.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-direct-struct-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-direct-struct-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-direct-struct-param.stderr?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -4,11 +4,5 @@ error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be ann\n LL |         WRAP_DIRECT_PARAM => { panic!(\"WRAP_DIRECT_PARAM matched itself\"); }\n    |         ^^^^^^^^^^^^^^^^^\n \n-error: to use a constant of type `NoDerive` in a pattern, `NoDerive` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/cant-hide-behind-direct-struct-param.rs:22:9\n-   |\n-LL |         WRAP_DIRECT_PARAM => { panic!(\"WRAP_DIRECT_PARAM matched itself\"); }\n-   |         ^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n "}, {"sha": "fe62774d220d4efe825d320b60cab4a143c9278c", "filename": "src/test/ui/rfc1445/cant-hide-behind-doubly-indirect-embedded.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-doubly-indirect-embedded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-doubly-indirect-embedded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-doubly-indirect-embedded.rs?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -23,7 +23,7 @@ fn main() {\n     match WRAP_DOUBLY_INDIRECT_INLINE {\n         WRAP_DOUBLY_INDIRECT_INLINE => { panic!(\"WRAP_DOUBLY_INDIRECT_INLINE matched itself\"); }\n         //~^ WARN must be annotated with `#[derive(PartialEq, Eq)]`\n-        //~| WARN will become a hard error in a future release\n+        //~| WARN this was previously accepted\n         _ => { println!(\"WRAP_DOUBLY_INDIRECT_INLINE correctly did not match itself\"); }\n     }\n }"}, {"sha": "c3a30674ea3878b766306c5692bad45266ca35ae", "filename": "src/test/ui/rfc1445/cant-hide-behind-doubly-indirect-param.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-doubly-indirect-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-doubly-indirect-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-doubly-indirect-param.rs?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -23,7 +23,7 @@ fn main() {\n     match WRAP_DOUBLY_INDIRECT_PARAM {\n         WRAP_DOUBLY_INDIRECT_PARAM => { panic!(\"WRAP_DOUBLY_INDIRECT_PARAM matched itself\"); }\n         //~^ WARN must be annotated with `#[derive(PartialEq, Eq)]`\n-        //~| WARN will become a hard error in a future release\n+        //~| WARN this was previously accepted\n         _ => { println!(\"WRAP_DOUBLY_INDIRECT_PARAM correctly did not match itself\"); }\n     }\n }"}, {"sha": "4d0e80d5af31235f237855afa3839a5f2b0125e2", "filename": "src/test/ui/rfc1445/cant-hide-behind-indirect-struct-embedded.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-indirect-struct-embedded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-indirect-struct-embedded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-indirect-struct-embedded.rs?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -23,7 +23,7 @@ fn main() {\n     match WRAP_INDIRECT_INLINE {\n         WRAP_INDIRECT_INLINE => { panic!(\"WRAP_INDIRECT_INLINE matched itself\"); }\n         //~^ WARN must be annotated with `#[derive(PartialEq, Eq)]`\n-        //~| WARN will become a hard error in a future release\n+        //~| WARN this was previously accepted\n         _ => { println!(\"WRAP_INDIRECT_INLINE did not match itself\"); }\n     }\n }"}, {"sha": "432f196ec81279fd82854e5449661beef1004fa8", "filename": "src/test/ui/rfc1445/cant-hide-behind-indirect-struct-param.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-indirect-struct-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-indirect-struct-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fcant-hide-behind-indirect-struct-param.rs?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -23,7 +23,7 @@ fn main() {\n     match WRAP_INDIRECT_PARAM {\n         WRAP_INDIRECT_PARAM => { panic!(\"WRAP_INDIRECT_PARAM matched itself\"); }\n         //~^ WARN must be annotated with `#[derive(PartialEq, Eq)]`\n-        //~| WARN will become a hard error in a future release\n+        //~| WARN this was previously accepted\n         _ => { println!(\"WRAP_INDIRECT_PARAM correctly did not match itself\"); }\n     }\n }"}, {"sha": "46d8ee3b6be9c0c5a2b1eb9efc87e696529c1898", "filename": "src/test/ui/rfc1445/issue-62307-match-ref-ref-forbidden-without-eq.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Frfc1445%2Fissue-62307-match-ref-ref-forbidden-without-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Frfc1445%2Fissue-62307-match-ref-ref-forbidden-without-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fissue-62307-match-ref-ref-forbidden-without-eq.rs?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -10,7 +10,7 @@\n \n // Issue 62307 pointed out a case where the structural-match checking\n // was too shallow.\n-#![warn(indirect_structural_match)]\n+#![warn(indirect_structural_match, nontrivial_structural_match)]\n // run-pass\n \n #[derive(Debug)]\n@@ -30,14 +30,14 @@ fn main() {\n     match RR_B0 {\n         RR_B1 => { println!(\"CLAIM RR0: {:?} matches {:?}\", RR_B1, RR_B0); }\n         //~^ WARN must be annotated with `#[derive(PartialEq, Eq)]`\n-        //~| WARN will become a hard error in a future release\n+        //~| WARN this was previously accepted\n         _ => { }\n     }\n \n     match RR_B1 {\n         RR_B1 => { println!(\"CLAIM RR1: {:?} matches {:?}\", RR_B1, RR_B1); }\n         //~^ WARN must be annotated with `#[derive(PartialEq, Eq)]`\n-        //~| WARN will become a hard error in a future release\n+        //~| WARN this was previously accepted\n         _ => { }\n     }\n }"}, {"sha": "a50093a5b1128bc225f42adc76f561ff6a083342", "filename": "src/test/ui/rfc1445/issue-62307-match-ref-ref-forbidden-without-eq.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Frfc1445%2Fissue-62307-match-ref-ref-forbidden-without-eq.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Frfc1445%2Fissue-62307-match-ref-ref-forbidden-without-eq.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fissue-62307-match-ref-ref-forbidden-without-eq.stderr?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -7,7 +7,7 @@ LL |         RR_B1 => { println!(\"CLAIM RR0: {:?} matches {:?}\", RR_B1, RR_B0);\n note: the lint level is defined here\n   --> $DIR/issue-62307-match-ref-ref-forbidden-without-eq.rs:13:9\n    |\n-LL | #![warn(indirect_structural_match)]\n+LL | #![warn(indirect_structural_match, nontrivial_structural_match)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #62411 <https://github.com/rust-lang/rust/issues/62411>"}, {"sha": "567685950e9e4aaf7d77fbf0efc02123285fafe2", "filename": "src/test/ui/rfc1445/issue-63479-match-fnptr.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Frfc1445%2Fissue-63479-match-fnptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Frfc1445%2Fissue-63479-match-fnptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fissue-63479-match-fnptr.rs?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -5,6 +5,8 @@\n // cover the case this hit; I've since expanded it accordingly, but the\n // experience left me wary of leaving this regression test out.)\n \n+#![warn(pointer_structural_match)]\n+\n #[derive(Eq)]\n struct A {\n   a: i64\n@@ -31,6 +33,8 @@ fn main() {\n   let s = B(my_fn);\n   match s {\n     B(TEST) => println!(\"matched\"),\n+     //~^ WARN pointers in patterns behave unpredictably\n+    //~| WARN this was previously accepted by the compiler but is being phased out\n     _ => panic!(\"didn't match\")\n   };\n }"}, {"sha": "8cf87cc85a1d44e6eaf243e78e5ba214a80791fb", "filename": "src/test/ui/rfc1445/issue-63479-match-fnptr.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Frfc1445%2Fissue-63479-match-fnptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Frfc1445%2Fissue-63479-match-fnptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fissue-63479-match-fnptr.stderr?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -0,0 +1,16 @@\n+warning: function pointers and unsized pointers in patterns behave unpredictably and should not be relied upon. See https://github.com/rust-lang/rust/issues/70861 for details.\n+  --> $DIR/issue-63479-match-fnptr.rs:35:7\n+   |\n+LL |     B(TEST) => println!(\"matched\"),\n+   |       ^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-63479-match-fnptr.rs:8:9\n+   |\n+LL | #![warn(pointer_structural_match)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #62411 <https://github.com/rust-lang/rust/issues/70861>\n+\n+warning: 1 warning emitted\n+"}, {"sha": "1cca27520618d531e7ce2f964320e1c3f9ad1162", "filename": "src/test/ui/rfc1445/match-forbidden-without-eq.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Frfc1445%2Fmatch-forbidden-without-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Frfc1445%2Fmatch-forbidden-without-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fmatch-forbidden-without-eq.rs?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -12,7 +12,6 @@ fn main() {\n     match y {\n         FOO => { }\n         //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n-        //~| ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n         _ => { }\n     }\n "}, {"sha": "02fa23981894a07a307a9e87bd856b2768864883", "filename": "src/test/ui/rfc1445/match-forbidden-without-eq.stderr", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Frfc1445%2Fmatch-forbidden-without-eq.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Frfc1445%2Fmatch-forbidden-without-eq.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fmatch-forbidden-without-eq.stderr?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -5,7 +5,7 @@ LL |         FOO => { }\n    |         ^^^\n \n warning: floating-point types cannot be used in patterns\n-  --> $DIR/match-forbidden-without-eq.rs:21:9\n+  --> $DIR/match-forbidden-without-eq.rs:20:9\n    |\n LL |         f32::INFINITY => { }\n    |         ^^^^^^^^^^^^^\n@@ -14,20 +14,14 @@ LL |         f32::INFINITY => { }\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #41620 <https://github.com/rust-lang/rust/issues/41620>\n \n-error: to use a constant of type `Foo` in a pattern, `Foo` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/match-forbidden-without-eq.rs:13:9\n-   |\n-LL |         FOO => { }\n-   |         ^^^\n-\n warning: floating-point types cannot be used in patterns\n-  --> $DIR/match-forbidden-without-eq.rs:21:9\n+  --> $DIR/match-forbidden-without-eq.rs:20:9\n    |\n LL |         f32::INFINITY => { }\n    |         ^^^^^^^^^^^^^\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #41620 <https://github.com/rust-lang/rust/issues/41620>\n \n-error: aborting due to 2 previous errors; 2 warnings emitted\n+error: aborting due to previous error; 2 warnings emitted\n "}, {"sha": "151a475c9190644e6423056229902d45b842e4f6", "filename": "src/test/ui/rfc1445/match-nonempty-array-forbidden-without-eq.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Frfc1445%2Fmatch-nonempty-array-forbidden-without-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Frfc1445%2Fmatch-nonempty-array-forbidden-without-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fmatch-nonempty-array-forbidden-without-eq.rs?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -15,6 +15,5 @@ fn main() {\n     match [B(1)] {\n         FOO => { }\n         //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n-        //~| ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n     }\n }"}, {"sha": "371f8a0aa1d7745e6e47ed08873335bbe4a1d9ed", "filename": "src/test/ui/rfc1445/match-nonempty-array-forbidden-without-eq.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Frfc1445%2Fmatch-nonempty-array-forbidden-without-eq.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Frfc1445%2Fmatch-nonempty-array-forbidden-without-eq.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fmatch-nonempty-array-forbidden-without-eq.stderr?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -4,11 +4,5 @@ error: to use a constant of type `B` in a pattern, `B` must be annotated with `#\n LL |         FOO => { }\n    |         ^^^\n \n-error: to use a constant of type `B` in a pattern, `B` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/match-nonempty-array-forbidden-without-eq.rs:16:9\n-   |\n-LL |         FOO => { }\n-   |         ^^^\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n "}, {"sha": "6b7d94603b567d889aff97f257d49b29d09c257c", "filename": "src/test/ui/rfc1445/match-requires-both-partialeq-and-eq.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Frfc1445%2Fmatch-requires-both-partialeq-and-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Frfc1445%2Fmatch-requires-both-partialeq-and-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fmatch-requires-both-partialeq-and-eq.rs?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -16,7 +16,6 @@ fn main() {\n     match y {\n         FOO => { }\n         //~^ ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n-        //~| ERROR must be annotated with `#[derive(PartialEq, Eq)]`\n         _ => { }\n     }\n }"}, {"sha": "4157cf65283e3d24ae23c88e23d5c9b9692f0716", "filename": "src/test/ui/rfc1445/match-requires-both-partialeq-and-eq.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Frfc1445%2Fmatch-requires-both-partialeq-and-eq.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Frfc1445%2Fmatch-requires-both-partialeq-and-eq.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fmatch-requires-both-partialeq-and-eq.stderr?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -4,11 +4,5 @@ error: to use a constant of type `Foo` in a pattern, `Foo` must be annotated wit\n LL |         FOO => { }\n    |         ^^^\n \n-error: to use a constant of type `Foo` in a pattern, `Foo` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/match-requires-both-partialeq-and-eq.rs:17:9\n-   |\n-LL |         FOO => { }\n-   |         ^^^\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n "}, {"sha": "d50835608fad1d03c74cd21ff4fabeda7aaeb691", "filename": "src/test/ui/type-alias-impl-trait/structural-match-no-leak.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fstructural-match-no-leak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fstructural-match-no-leak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fstructural-match-no-leak.rs?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -12,9 +12,9 @@ const LEAK_FREE: Bar = leak_free();\n fn leak_free_test() {\n     match todo!() {\n         LEAK_FREE => (),\n-        //~^ opaque types cannot be used in patterns\n+        //~^ `impl Send` cannot be used in patterns\n         _ => (),\n     }\n }\n \n-fn main() { }\n+fn main() {}"}, {"sha": "889c4fd4b040556184b8dca4d8019f5486144b22", "filename": "src/test/ui/type-alias-impl-trait/structural-match-no-leak.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fstructural-match-no-leak.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fstructural-match-no-leak.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fstructural-match-no-leak.stderr?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -1,4 +1,4 @@\n-error: opaque types cannot be used in patterns\n+error: `impl Send` cannot be used in patterns\n   --> $DIR/structural-match-no-leak.rs:14:9\n    |\n LL |         LEAK_FREE => (),"}, {"sha": "a3ff4ad1d47054f238203ed5d2474497714540fd", "filename": "src/test/ui/type-alias-impl-trait/structural-match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fstructural-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fstructural-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fstructural-match.rs?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -13,9 +13,9 @@ const VALUE: Foo = value();\n fn test() {\n     match todo!() {\n         VALUE => (),\n-        //~^ opaque types cannot be used in patterns\n+        //~^ `impl Send` cannot be used in patterns\n         _ => (),\n     }\n }\n \n-fn main() { }\n+fn main() {}"}, {"sha": "262fd0726137e63c9547b43ea4977c99070bd147", "filename": "src/test/ui/type-alias-impl-trait/structural-match.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fstructural-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fstructural-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fstructural-match.stderr?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -1,4 +1,4 @@\n-error: opaque types cannot be used in patterns\n+error: `impl Send` cannot be used in patterns\n   --> $DIR/structural-match.rs:15:9\n    |\n LL |         VALUE => (),"}, {"sha": "e7cb248a201acb8d0dffa58ca3a1cee2803d7613", "filename": "src/test/ui/union/union-const-pat.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Funion%2Funion-const-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Funion%2Funion-const-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-const-pat.rs?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -8,7 +8,6 @@ const C: U = U { a: 10 };\n fn main() {\n     match C {\n         C => {} //~ ERROR cannot use unions in constant patterns\n-                //~| ERROR cannot use unions in constant patterns\n         _ => {}\n     }\n }"}, {"sha": "dc87f4de5219f445a8f25fabd598bcaab18fb592", "filename": "src/test/ui/union/union-const-pat.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Funion%2Funion-const-pat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fd15e6180d9c48b4f1157e44cdaff6e901e5f854/src%2Ftest%2Fui%2Funion%2Funion-const-pat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-const-pat.stderr?ref=fd15e6180d9c48b4f1157e44cdaff6e901e5f854", "patch": "@@ -4,11 +4,5 @@ error: cannot use unions in constant patterns\n LL |         C => {}\n    |         ^\n \n-error: cannot use unions in constant patterns\n-  --> $DIR/union-const-pat.rs:10:9\n-   |\n-LL |         C => {}\n-   |         ^\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n "}]}