{"sha": "6d4538734e48d74be5f64c87dbac188cfdb1e1fd", "node_id": "C_kwDOAAsO6NoAKDZkNDUzODczNGU0OGQ3NGJlNWY2NGM4N2RiYWMxODhjZmRiMWUxZmQ", "commit": {"author": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2022-11-22T09:36:58Z"}, "committer": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2022-12-02T16:22:00Z"}, "message": "Add `move_const_to_impl` assist", "tree": {"sha": "24ffa91ae2701bf2466c3e954ceb9d4f50a6ea7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24ffa91ae2701bf2466c3e954ceb9d4f50a6ea7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d4538734e48d74be5f64c87dbac188cfdb1e1fd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEkSbsQIURluxz4rzf4laYqTBYYXEFAmOKJigACgkQ4laYqTBY\nYXHh/g/+PhS86/O1vxQfXY6TuOPwm0JMa0KDvJFdRJY0AEVw0EKSPaGaDjTByEo2\n4TlhMA/KWuq2YE++jo7V/4z2XwHiEUIkNr0fVRSREx0S9QpWWOS3eXlMSf3vHZ49\noKtLh6JSfUnd0KWZF5cARDfQXWEfUBkjSePc8iuQISyHAihpLaKBhiUd+xw9jn5R\nuJIB/IfUl+FjRIMtzqK9zSkqCk0IjwuakVxbY1ENVxUb05WFkkna51TkyHvWyVFj\n0KXHg4nSmAOR57J6pNm2/IL5/RDLrOtI1Hl3oDPSKMrvPPeRs4Ka46MLrRK7FYC+\nV39BlUsx6chIV/kYsjCzDqGR8hRi2iDZtKntU97wgGmZBlmkXTz5KHHZYTUunGu0\nTb6LihDnCqJTq0IH5Ia4rLXcp12WZmD+JPo+8optbucotiXvu7Iffl0jbWZaEaG8\n+q5jSK6pSgSPWY0WXN5OXod4rTbc7Eq3zxSet8oTEXBH+roKQFZWj9xrxgz0rpMd\nAkot58vJ8wv8rjFHa4d1gI7LSksXsA2XPXHu2Bhk5QV/776JxtbvEG04IPpvyLVa\ne20Aqcqf+GgGuPXWOxrSzb8+G3e5UPVPYGPXysskb0pEuX0GYJrXqbesUt7sO70+\ns/Hna1qUnKfrXsBefILU2IggL8g8qfUtsc8pPrQlyf85dvJLSN4=\n=v3KT\n-----END PGP SIGNATURE-----", "payload": "tree 24ffa91ae2701bf2466c3e954ceb9d4f50a6ea7d\nparent 398a71affb05aeeea1991044ec9ca1229e68f0f3\nauthor Ryo Yoshida <low.ryoshida@gmail.com> 1669109818 +0900\ncommitter Ryo Yoshida <low.ryoshida@gmail.com> 1669998120 +0900\n\nAdd `move_const_to_impl` assist\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d4538734e48d74be5f64c87dbac188cfdb1e1fd", "html_url": "https://github.com/rust-lang/rust/commit/6d4538734e48d74be5f64c87dbac188cfdb1e1fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d4538734e48d74be5f64c87dbac188cfdb1e1fd/comments", "author": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "398a71affb05aeeea1991044ec9ca1229e68f0f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/398a71affb05aeeea1991044ec9ca1229e68f0f3", "html_url": "https://github.com/rust-lang/rust/commit/398a71affb05aeeea1991044ec9ca1229e68f0f3"}], "stats": {"total": 529, "additions": 529, "deletions": 0}, "files": [{"sha": "0e3a1e652b0dc68ba732da5e6e21c25b526d493f", "filename": "crates/ide-assists/src/handlers/move_const_to_impl.rs", "status": "added", "additions": 481, "deletions": 0, "changes": 481, "blob_url": "https://github.com/rust-lang/rust/blob/6d4538734e48d74be5f64c87dbac188cfdb1e1fd/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_const_to_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d4538734e48d74be5f64c87dbac188cfdb1e1fd/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_const_to_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_const_to_impl.rs?ref=6d4538734e48d74be5f64c87dbac188cfdb1e1fd", "patch": "@@ -0,0 +1,481 @@\n+use hir::{AsAssocItem, AssocItemContainer, HasCrate, HasSource};\n+use ide_db::{assists::AssistId, base_db::FileRange, defs::Definition, search::SearchScope};\n+use syntax::{\n+    ast::{self, edit::IndentLevel, edit_in_place::Indent, AstNode},\n+    SyntaxKind,\n+};\n+\n+use crate::{\n+    assist_context::{AssistContext, Assists},\n+    utils,\n+};\n+\n+// NOTE: Code may break if the self type implements a trait that has associated const with the same\n+// name, but it's pretty expensive to check that (`hir::Impl::all_for_type()`) and we assume that's\n+// pretty rare case.\n+\n+// Assist: move_const_to_impl\n+//\n+// Move a local constant item in a method to impl's associated constant. All the references will be\n+// qualified with `Self::`.\n+//\n+// ```\n+// struct S;\n+// impl S {\n+//     fn foo() -> usize {\n+//         /// The answer.\n+//         const C$0: usize = 42;\n+//\n+//         C * C\n+//     }\n+// }\n+// ```\n+// ->\n+// ```\n+// struct S;\n+// impl S {\n+//     /// The answer.\n+//     const C: usize = 42;\n+//\n+//     fn foo() -> usize {\n+//         Self::C * Self::C\n+//     }\n+// }\n+// ```\n+pub(crate) fn move_const_to_impl(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n+    let db = ctx.db();\n+    let const_: ast::Const = ctx.find_node_at_offset()?;\n+    // Don't show the assist when the cursor is at the const's body.\n+    if let Some(body) = const_.body() {\n+        if body.syntax().text_range().contains(ctx.offset()) {\n+            return None;\n+        }\n+    }\n+\n+    let parent_fn = const_.syntax().ancestors().find_map(ast::Fn::cast)?;\n+\n+    // NOTE: We can technically provide this assist for default methods in trait definitions, but\n+    // it's somewhat complex to handle it correctly when the const's name conflicts with\n+    // supertrait's item. We may want to consider implementing it in the future.\n+    let AssocItemContainer::Impl(impl_) = ctx.sema.to_def(&parent_fn)?.as_assoc_item(db)?.container(db) else { return None; };\n+    if impl_.trait_(db).is_some() {\n+        return None;\n+    }\n+\n+    let def = ctx.sema.to_def(&const_)?;\n+    let name = def.name(db)?;\n+    let items = impl_.source(db)?.value.assoc_item_list()?;\n+\n+    let ty = impl_.self_ty(db);\n+    // If there exists another associated item with the same name, skip the assist.\n+    if ty\n+        .iterate_assoc_items(db, ty.krate(db), |assoc| {\n+            // Type aliases wouldn't conflict due to different namespaces, but we're only checking\n+            // the items in inherent impls, so we assume `assoc` is never type alias for the sake\n+            // of brevity (inherent associated types exist in nightly Rust, but it's *very*\n+            // unstable and we don't support them either).\n+            assoc.name(db).filter(|it| it == &name)\n+        })\n+        .is_some()\n+    {\n+        return None;\n+    }\n+\n+    let usages =\n+        Definition::Const(def).usages(&ctx.sema).in_scope(SearchScope::file_range(FileRange {\n+            file_id: ctx.file_id(),\n+            range: parent_fn.syntax().text_range(),\n+        }));\n+\n+    acc.add(\n+        AssistId(\"move_const_to_impl\", crate::AssistKind::RefactorRewrite),\n+        \"Move const to impl block\",\n+        const_.syntax().text_range(),\n+        |builder| {\n+            let range_to_delete = match const_.syntax().next_sibling_or_token() {\n+                Some(s) if matches!(s.kind(), SyntaxKind::WHITESPACE) => {\n+                    // Remove following whitespaces too.\n+                    const_.syntax().text_range().cover(s.text_range())\n+                }\n+                _ => const_.syntax().text_range(),\n+            };\n+            builder.delete(range_to_delete);\n+\n+            let const_ref = format!(\"Self::{name}\");\n+            for range in usages.all().file_ranges().map(|it| it.range) {\n+                builder.replace(range, const_ref.clone());\n+            }\n+\n+            // Heuristically inserting the extracted const after the consecutive existing consts\n+            // from the beginning of assoc items. We assume there are no inherent assoc type as\n+            // above.\n+            let last_const =\n+                items.assoc_items().take_while(|it| matches!(it, ast::AssocItem::Const(_))).last();\n+            let insert_offset = match &last_const {\n+                Some(it) => it.syntax().text_range().end(),\n+                None => match items.l_curly_token() {\n+                    Some(l_curly) => l_curly.text_range().end(),\n+                    // Not sure if this branch is ever reachable, but it wouldn't hurt to have a\n+                    // fallback.\n+                    None => items.syntax().text_range().start(),\n+                },\n+            };\n+\n+            // If the moved const will be the first item of the impl, add a new line after that.\n+            //\n+            // We're assuming the code is formatted according to Rust's standard style guidelines\n+            // (i.e. no empty lines between impl's `{` token and its first assoc item).\n+            let fixup = if last_const.is_none() { \"\\n\" } else { \"\" };\n+            let indent = IndentLevel::from_node(parent_fn.syntax());\n+\n+            let const_ = const_.clone_for_update();\n+            const_.reindent_to(indent);\n+            let mut const_text = format!(\"\\n{indent}{const_}{fixup}\");\n+            utils::escape_non_snippet(&mut const_text);\n+            builder.insert(insert_offset, const_text);\n+        },\n+    )\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn not_applicable_to_top_level_const() {\n+        check_assist_not_applicable(\n+            move_const_to_impl,\n+            r#\"\n+const C$0: () = ();\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_to_free_fn() {\n+        check_assist_not_applicable(\n+            move_const_to_impl,\n+            r#\"\n+fn f() {\n+    const C$0: () = ();\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_when_at_const_body() {\n+        check_assist_not_applicable(\n+            move_const_to_impl,\n+            r#\"\n+struct S;\n+impl S {\n+    fn f() {\n+        const C: () = ($0);\n+    }\n+}\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_when_inside_const_body_block() {\n+        check_assist_not_applicable(\n+            move_const_to_impl,\n+            r#\"\n+struct S;\n+impl S {\n+    fn f() {\n+        const C: () = {\n+            ($0)\n+        };\n+    }\n+}\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_to_trait_impl_fn() {\n+        check_assist_not_applicable(\n+            move_const_to_impl,\n+            r#\"\n+trait Trait {\n+    fn f();\n+}\n+impl Trait for () {\n+    fn f() {\n+        const C$0: () = ();\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_to_non_assoc_fn_inside_impl() {\n+        check_assist_not_applicable(\n+            move_const_to_impl,\n+            r#\"\n+struct S;\n+impl S {\n+    fn f() {\n+        fn g() {\n+            const C$0: () = ();\n+        }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_when_const_with_same_name_exists() {\n+        check_assist_not_applicable(\n+            move_const_to_impl,\n+            r#\"\n+struct S;\n+impl S {\n+    const C: usize = 42;\n+    fn f() {\n+        const C$0: () = ();\n+    }\n+\"#,\n+        );\n+\n+        check_assist_not_applicable(\n+            move_const_to_impl,\n+            r#\"\n+struct S;\n+impl S {\n+    const C: usize = 42;\n+}\n+impl S {\n+    fn f() {\n+        const C$0: () = ();\n+    }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn move_const_simple_body() {\n+        check_assist(\n+            move_const_to_impl,\n+            r#\"\n+struct S;\n+impl S {\n+    fn f() -> usize {\n+        /// doc comment\n+        const C$0: usize = 42;\n+\n+        C * C\n+    }\n+}\n+\"#,\n+            r#\"\n+struct S;\n+impl S {\n+    /// doc comment\n+    const C: usize = 42;\n+\n+    fn f() -> usize {\n+        Self::C * Self::C\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn move_const_simple_body_existing_const() {\n+        check_assist(\n+            move_const_to_impl,\n+            r#\"\n+struct S;\n+impl S {\n+    const X: () = ();\n+    const Y: () = ();\n+\n+    fn f() -> usize {\n+        /// doc comment\n+        const C$0: usize = 42;\n+\n+        C * C\n+    }\n+}\n+\"#,\n+            r#\"\n+struct S;\n+impl S {\n+    const X: () = ();\n+    const Y: () = ();\n+    /// doc comment\n+    const C: usize = 42;\n+\n+    fn f() -> usize {\n+        Self::C * Self::C\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn move_const_block_body() {\n+        check_assist(\n+            move_const_to_impl,\n+            r#\"\n+struct S;\n+impl S {\n+    fn f() -> usize {\n+        /// doc comment\n+        const C$0: usize = {\n+            let a = 3;\n+            let b = 4;\n+            a * b\n+        };\n+\n+        C * C\n+    }\n+}\n+\"#,\n+            r#\"\n+struct S;\n+impl S {\n+    /// doc comment\n+    const C: usize = {\n+        let a = 3;\n+        let b = 4;\n+        a * b\n+    };\n+\n+    fn f() -> usize {\n+        Self::C * Self::C\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn correct_indent_when_nested() {\n+        check_assist(\n+            move_const_to_impl,\n+            r#\"\n+fn main() {\n+    struct S;\n+    impl S {\n+        fn f() -> usize {\n+            /// doc comment\n+            const C$0: usize = 42;\n+\n+            C * C\n+        }\n+    }\n+}\n+\"#,\n+            r#\"\n+fn main() {\n+    struct S;\n+    impl S {\n+        /// doc comment\n+        const C: usize = 42;\n+\n+        fn f() -> usize {\n+            Self::C * Self::C\n+        }\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn move_const_in_nested_scope_with_same_name_in_other_scope() {\n+        check_assist(\n+            move_const_to_impl,\n+            r#\"\n+struct S;\n+impl S {\n+    fn f() -> usize {\n+        const C: &str = \"outer\";\n+\n+        let n = {\n+            /// doc comment\n+            const C$0: usize = 42;\n+\n+            let m = {\n+                const C: &str = \"inner\";\n+                C.len()\n+            };\n+\n+            C * m\n+        };\n+\n+        n + C.len()\n+    }\n+}\n+\"#,\n+            r#\"\n+struct S;\n+impl S {\n+    /// doc comment\n+    const C: usize = 42;\n+\n+    fn f() -> usize {\n+        const C: &str = \"outer\";\n+\n+        let n = {\n+            let m = {\n+                const C: &str = \"inner\";\n+                C.len()\n+            };\n+\n+            Self::C * m\n+        };\n+\n+        n + C.len()\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn moved_const_body_is_escaped() {\n+        // Note that the last argument is what *lsp clients would see* rather than\n+        // what users would see. Unescaping happens thereafter.\n+        check_assist(\n+            move_const_to_impl,\n+            r#\"\n+struct S;\n+impl S {\n+    fn f() -> usize {\n+        /// doc comment\n+        /// \\\\\n+        /// ${snippet}\n+        const C$0: &str = \"\\ and $1\";\n+\n+        C.len()\n+    }\n+}\n+\"#,\n+            r#\"\n+struct S;\n+impl S {\n+    /// doc comment\n+    /// \\\\\\\\\n+    /// \\${snippet}\n+    const C: &str = \"\\\\ and \\$1\";\n+\n+    fn f() -> usize {\n+        Self::C.len()\n+    }\n+}\n+\"#,\n+        )\n+    }\n+}"}, {"sha": "a55de800b39eeaa2c24217ec2a3cf035a268ca39", "filename": "crates/ide-assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d4538734e48d74be5f64c87dbac188cfdb1e1fd/crates%2Fide-assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d4538734e48d74be5f64c87dbac188cfdb1e1fd/crates%2Fide-assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Flib.rs?ref=6d4538734e48d74be5f64c87dbac188cfdb1e1fd", "patch": "@@ -165,6 +165,7 @@ mod handlers {\n     mod merge_imports;\n     mod merge_match_arms;\n     mod move_bounds;\n+    mod move_const_to_impl;\n     mod move_guard;\n     mod move_module_to_file;\n     mod move_to_mod_rs;\n@@ -261,6 +262,7 @@ mod handlers {\n             merge_imports::merge_imports,\n             merge_match_arms::merge_match_arms,\n             move_bounds::move_bounds_to_where_clause,\n+            move_const_to_impl::move_const_to_impl,\n             move_format_string_arg::move_format_string_arg,\n             move_guard::move_arm_cond_to_match_guard,\n             move_guard::move_guard_to_arm_body,"}, {"sha": "ccd38119c4a7dc16610fa2051a687ddbc91deb30", "filename": "crates/ide-assists/src/tests/generated.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6d4538734e48d74be5f64c87dbac188cfdb1e1fd/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d4538734e48d74be5f64c87dbac188cfdb1e1fd/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=6d4538734e48d74be5f64c87dbac188cfdb1e1fd", "patch": "@@ -1674,6 +1674,35 @@ fn apply<T, U, F>(f: F, x: T) -> U where F: FnOnce(T) -> U {\n     )\n }\n \n+#[test]\n+fn doctest_move_const_to_impl() {\n+    check_doc_test(\n+        \"move_const_to_impl\",\n+        r#####\"\n+struct S;\n+impl S {\n+    fn foo() -> usize {\n+        /// The answer.\n+        const C$0: usize = 42;\n+\n+        C * C\n+    }\n+}\n+\"#####,\n+        r#####\"\n+struct S;\n+impl S {\n+    /// The answer.\n+    const C: usize = 42;\n+\n+    fn foo() -> usize {\n+        Self::C * Self::C\n+    }\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_move_format_string_arg() {\n     check_doc_test("}, {"sha": "f38a2d04ff6e5b9f03b34d5525052e828a55a00c", "filename": "crates/ide-assists/src/utils.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6d4538734e48d74be5f64c87dbac188cfdb1e1fd/crates%2Fide-assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d4538734e48d74be5f64c87dbac188cfdb1e1fd/crates%2Fide-assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Futils.rs?ref=6d4538734e48d74be5f64c87dbac188cfdb1e1fd", "patch": "@@ -208,6 +208,23 @@ pub(crate) fn render_snippet(_cap: SnippetCap, node: &SyntaxNode, cursor: Cursor\n     }\n }\n \n+/// Escapes text that should be rendered as-is, typically those that we're copy-pasting what the\n+/// users wrote.\n+///\n+/// This function should only be used when the text doesn't contain snippet **AND** the text\n+/// wouldn't be included in a snippet.\n+pub(crate) fn escape_non_snippet(text: &mut String) {\n+    // While we *can* escape `}`, we don't really have to in this specific case. We only need to\n+    // escape it inside `${}` to disambiguate it from the ending token of the syntax, but after we\n+    // escape every occurrence of `$`, we wouldn't have `${}` in the first place.\n+    //\n+    // This will break if the text contains snippet or it will be included in a snippet (hence doc\n+    // comment). Compare `fn escape(buf)` in `render_snippet()` above, where the escaped text is\n+    // included in a snippet.\n+    stdx::replace(text, '\\\\', r\"\\\\\");\n+    stdx::replace(text, '$', r\"\\$\");\n+}\n+\n pub(crate) fn vis_offset(node: &SyntaxNode) -> TextSize {\n     node.children_with_tokens()\n         .find(|it| !matches!(it.kind(), WHITESPACE | COMMENT | ATTR))"}]}