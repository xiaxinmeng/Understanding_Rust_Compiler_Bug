{"sha": "3e3ff4b6526c19b5bb5dd67a9431479244874ed3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlM2ZmNGI2NTI2YzE5YjViYjVkZDY3YTk0MzE0NzkyNDQ4NzRlZDM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-07-28T11:20:07Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-01T22:33:03Z"}, "message": "macro-inline len() and is_empty() to fix performance regressions\n\nThis also changes the IR for nth(), but the new IR actually looks nicer that the old\n(and it is one instruction shorter).", "tree": {"sha": "09d7ee67a7202975b3dad41478475c9517d366e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09d7ee67a7202975b3dad41478475c9517d366e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e3ff4b6526c19b5bb5dd67a9431479244874ed3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e3ff4b6526c19b5bb5dd67a9431479244874ed3", "html_url": "https://github.com/rust-lang/rust/commit/3e3ff4b6526c19b5bb5dd67a9431479244874ed3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e3ff4b6526c19b5bb5dd67a9431479244874ed3/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b3c6bac8b91d881b2e8b9cb6ea35a8a13c1f804", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b3c6bac8b91d881b2e8b9cb6ea35a8a13c1f804", "html_url": "https://github.com/rust-lang/rust/commit/1b3c6bac8b91d881b2e8b9cb6ea35a8a13c1f804"}], "stats": {"total": 49, "additions": 29, "deletions": 20}, "files": [{"sha": "0b62fdce7f39a31f38891b1005262975b6039c82", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 29, "deletions": 20, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/3e3ff4b6526c19b5bb5dd67a9431479244874ed3/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e3ff4b6526c19b5bb5dd67a9431479244874ed3/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=3e3ff4b6526c19b5bb5dd67a9431479244874ed3", "patch": "@@ -2337,14 +2337,30 @@ impl<'a, T> IntoIterator for &'a mut [T] {\n     }\n }\n \n+// Inlining is_empty and len makes a huge performance difference\n+macro_rules! is_empty {\n+    // The way we encode the length of a ZST iterator, this works both for ZST\n+    // and non-ZST.\n+    ($self: expr) => {$self.ptr == $self.end}\n+}\n+macro_rules! len {\n+    ($T: ty, $self: expr) => {{\n+        if mem::size_of::<$T>() == 0 {\n+            ($self.end as usize).wrapping_sub($self.ptr as usize)\n+        } else {\n+            $self.end.offset_from($self.ptr) as usize\n+        }\n+    }}\n+}\n+\n // The shared definition of the `Iter` and `IterMut` iterators\n macro_rules! iterator {\n     (struct $name:ident -> $ptr:ty, $elem:ty, $raw_mut:tt, $( $mut_:tt )*) => {\n         impl<'a, T> $name<'a, T> {\n             // Helper function for creating a slice from the iterator.\n             #[inline(always)]\n             fn make_slice(&self) -> &'a [T] {\n-                unsafe { from_raw_parts(self.ptr, self.len()) }\n+                unsafe { from_raw_parts(self.ptr, len!(T, self)) }\n             }\n \n             // Helper function for moving the start of the iterator forwards by `offset` elements,\n@@ -2382,20 +2398,12 @@ macro_rules! iterator {\n         impl<'a, T> ExactSizeIterator for $name<'a, T> {\n             #[inline(always)]\n             fn len(&self) -> usize {\n-                let diff = (self.end as usize).wrapping_sub(self.ptr as usize);\n-                if mem::size_of::<T>() == 0 {\n-                    // end is really ptr+len, so we are already done\n-                    diff\n-                } else {\n-                    diff / mem::size_of::<T>()\n-                }\n+                unsafe { len!(T, self) }\n             }\n \n             #[inline(always)]\n             fn is_empty(&self) -> bool {\n-                // The way we encode the length of a ZST iterator, this works both for ZST\n-                // and non-ZST.\n-                self.ptr == self.end\n+                is_empty!(self)\n             }\n         }\n \n@@ -2411,7 +2419,7 @@ macro_rules! iterator {\n                     if mem::size_of::<T>() != 0 {\n                         assume(!self.end.is_null());\n                     }\n-                    if self.is_empty() {\n+                    if is_empty!(self) {\n                         None\n                     } else {\n                         Some(& $( $mut_ )* *self.post_inc_start(1))\n@@ -2421,7 +2429,7 @@ macro_rules! iterator {\n \n             #[inline]\n             fn size_hint(&self) -> (usize, Option<usize>) {\n-                let exact = self.len();\n+                let exact = unsafe { len!(T, self) };\n                 (exact, Some(exact))\n             }\n \n@@ -2432,7 +2440,7 @@ macro_rules! iterator {\n \n             #[inline]\n             fn nth(&mut self, n: usize) -> Option<$elem> {\n-                if n >= self.len() {\n+                if n >= unsafe { len!(T, self) } {\n                     // This iterator is now empty.\n                     if mem::size_of::<T>() == 0 {\n                         // We have to do it this way as `ptr` may never be 0, but `end`\n@@ -2463,13 +2471,13 @@ macro_rules! iterator {\n                 // manual unrolling is needed when there are conditional exits from the loop\n                 let mut accum = init;\n                 unsafe {\n-                    while self.len() >= 4 {\n+                    while len!(T, self) >= 4 {\n                         accum = f(accum, & $( $mut_ )* *self.post_inc_start(1))?;\n                         accum = f(accum, & $( $mut_ )* *self.post_inc_start(1))?;\n                         accum = f(accum, & $( $mut_ )* *self.post_inc_start(1))?;\n                         accum = f(accum, & $( $mut_ )* *self.post_inc_start(1))?;\n                     }\n-                    while !self.is_empty() {\n+                    while !is_empty!(self) {\n                         accum = f(accum, & $( $mut_ )* *self.post_inc_start(1))?;\n                     }\n                 }\n@@ -2539,7 +2547,7 @@ macro_rules! iterator {\n                     if mem::size_of::<T>() != 0 {\n                         assume(!self.end.is_null());\n                     }\n-                    if self.is_empty() {\n+                    if is_empty!(self) {\n                         None\n                     } else {\n                         Some(& $( $mut_ )* *self.pre_dec_end(1))\n@@ -2554,13 +2562,14 @@ macro_rules! iterator {\n                 // manual unrolling is needed when there are conditional exits from the loop\n                 let mut accum = init;\n                 unsafe {\n-                    while self.len() >= 4 {\n+                    while len!(T, self) >= 4 {\n                         accum = f(accum, & $( $mut_ )* *self.pre_dec_end(1))?;\n                         accum = f(accum, & $( $mut_ )* *self.pre_dec_end(1))?;\n                         accum = f(accum, & $( $mut_ )* *self.pre_dec_end(1))?;\n                         accum = f(accum, & $( $mut_ )* *self.pre_dec_end(1))?;\n                     }\n-                    while !self.is_empty() {\n+                    // inlining is_empty everywhere makes a huge performance difference\n+                    while !is_empty!(self) {\n                         accum = f(accum, & $( $mut_ )* *self.pre_dec_end(1))?;\n                     }\n                 }\n@@ -2760,7 +2769,7 @@ impl<'a, T> IterMut<'a, T> {\n     /// ```\n     #[stable(feature = \"iter_to_slice\", since = \"1.4.0\")]\n     pub fn into_slice(self) -> &'a mut [T] {\n-        unsafe { from_raw_parts_mut(self.ptr, self.len()) }\n+        unsafe { from_raw_parts_mut(self.ptr, len!(T, self)) }\n     }\n }\n "}]}