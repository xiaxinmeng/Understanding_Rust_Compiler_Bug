{"sha": "1b19284ad9d85f2848650be6dd466ad0e1e2d82c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiMTkyODRhZDlkODVmMjg0ODY1MGJlNmRkNDY2YWQwZTFlMmQ4MmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-11T22:48:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-11T22:48:14Z"}, "message": "Auto merge of #40220 - jseyfried:ast_macro_def, r=nrc\n\nsyntax: add `ast::ItemKind::MacroDef`, simplify hygiene info\n\nThis PR\n - adds a new variant `MacroDef` to `ast::ItemKind` for `macro_rules!` and eventually `macro` items,\n - [breaking-change] forbids macro defs without a name (`macro_rules! { () => {} }` compiles today),\n - removes `ast::MacroDef`, and\n - no longer uses `Mark` and `Invocation` to identify and characterize macro definitions.\n   - We used to apply (at least) two `Mark`s to an expanded identifier's `SyntaxContext` -- the definition mark(s) and the expansion mark(s). We now only apply the latter.\n\nr? @nrc", "tree": {"sha": "5d37bae176049302af3b44b780e7b344a51a15d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d37bae176049302af3b44b780e7b344a51a15d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1b19284ad9d85f2848650be6dd466ad0e1e2d82c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1b19284ad9d85f2848650be6dd466ad0e1e2d82c", "html_url": "https://github.com/rust-lang/rust/commit/1b19284ad9d85f2848650be6dd466ad0e1e2d82c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4eb964dd950eb9afe861efc4ea5fc58c33b8296", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4eb964dd950eb9afe861efc4ea5fc58c33b8296", "html_url": "https://github.com/rust-lang/rust/commit/e4eb964dd950eb9afe861efc4ea5fc58c33b8296"}, {"sha": "8c98996934658631308e8fb4069d2db68ff44927", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c98996934658631308e8fb4069d2db68ff44927", "html_url": "https://github.com/rust-lang/rust/commit/8c98996934658631308e8fb4069d2db68ff44927"}], "stats": {"total": 621, "additions": 305, "deletions": 316}, "files": [{"sha": "aa6614b0af4f7b492dd84a49635fa0614a12c428", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=1b19284ad9d85f2848650be6dd466ad0e1e2d82c", "patch": "@@ -79,6 +79,7 @@ pub struct LoweringContext<'a> {\n     trait_items: BTreeMap<hir::TraitItemId, hir::TraitItem>,\n     impl_items: BTreeMap<hir::ImplItemId, hir::ImplItem>,\n     bodies: BTreeMap<hir::BodyId, hir::Body>,\n+    exported_macros: Vec<hir::MacroDef>,\n \n     trait_impls: BTreeMap<DefId, Vec<NodeId>>,\n     trait_default_impl: BTreeMap<DefId, NodeId>,\n@@ -121,6 +122,7 @@ pub fn lower_crate(sess: &Session,\n         bodies: BTreeMap::new(),\n         trait_impls: BTreeMap::new(),\n         trait_default_impl: BTreeMap::new(),\n+        exported_macros: Vec::new(),\n         loop_scopes: Vec::new(),\n         is_in_loop_condition: false,\n         type_def_lifetime_params: DefIdMap(),\n@@ -170,9 +172,10 @@ impl<'a> LoweringContext<'a> {\n \n         impl<'lcx, 'interner> Visitor<'lcx> for ItemLowerer<'lcx, 'interner> {\n             fn visit_item(&mut self, item: &'lcx Item) {\n-                let hir_item = self.lctx.lower_item(item);\n-                self.lctx.items.insert(item.id, hir_item);\n-                visit::walk_item(self, item);\n+                if let Some(hir_item) = self.lctx.lower_item(item) {\n+                    self.lctx.items.insert(item.id, hir_item);\n+                    visit::walk_item(self, item);\n+                }\n             }\n \n             fn visit_trait_item(&mut self, item: &'lcx TraitItem) {\n@@ -195,14 +198,13 @@ impl<'a> LoweringContext<'a> {\n \n         let module = self.lower_mod(&c.module);\n         let attrs = self.lower_attrs(&c.attrs);\n-        let exported_macros = c.exported_macros.iter().map(|m| self.lower_macro_def(m)).collect();\n         let body_ids = body_ids(&self.bodies);\n \n         hir::Crate {\n             module: module,\n             attrs: attrs,\n             span: c.span,\n-            exported_macros: exported_macros,\n+            exported_macros: hir::HirVec::from(self.exported_macros),\n             items: self.items,\n             trait_items: self.trait_items,\n             impl_items: self.impl_items,\n@@ -1134,7 +1136,7 @@ impl<'a> LoweringContext<'a> {\n                                bounds,\n                                items)\n             }\n-            ItemKind::Mac(_) => panic!(\"Shouldn't still be around\"),\n+            ItemKind::MacroDef(..) | ItemKind::Mac(..) => panic!(\"Shouldn't still be around\"),\n         }\n     }\n \n@@ -1256,42 +1258,45 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_macro_def(&mut self, m: &MacroDef) -> hir::MacroDef {\n-        hir::MacroDef {\n-            name: m.ident.name,\n-            attrs: self.lower_attrs(&m.attrs),\n-            id: m.id,\n-            span: m.span,\n-            body: m.body.clone().into(),\n-        }\n-    }\n-\n     fn lower_item_id(&mut self, i: &Item) -> SmallVector<hir::ItemId> {\n-        if let ItemKind::Use(ref view_path) = i.node {\n-            if let ViewPathList(_, ref imports) = view_path.node {\n-                return iter::once(i.id).chain(imports.iter().map(|import| import.node.id))\n-                    .map(|id| hir::ItemId { id: id }).collect();\n+        match i.node {\n+            ItemKind::Use(ref view_path) => {\n+                if let ViewPathList(_, ref imports) = view_path.node {\n+                    return iter::once(i.id).chain(imports.iter().map(|import| import.node.id))\n+                        .map(|id| hir::ItemId { id: id }).collect();\n+                }\n             }\n+            ItemKind::MacroDef(..) => return SmallVector::new(),\n+            _ => {}\n         }\n         SmallVector::one(hir::ItemId { id: i.id })\n     }\n \n-    pub fn lower_item(&mut self, i: &Item) -> hir::Item {\n+    pub fn lower_item(&mut self, i: &Item) -> Option<hir::Item> {\n         let mut name = i.ident.name;\n         let attrs = self.lower_attrs(&i.attrs);\n         let mut vis = self.lower_visibility(&i.vis);\n+        if let ItemKind::MacroDef(ref tts) = i.node {\n+            if i.attrs.iter().any(|attr| attr.name() == \"macro_export\") {\n+                self.exported_macros.push(hir::MacroDef {\n+                    name: name, attrs: attrs, id: i.id, span: i.span, body: tts.clone().into(),\n+                });\n+            }\n+            return None;\n+        }\n+\n         let node = self.with_parent_def(i.id, |this| {\n             this.lower_item_kind(i.id, &mut name, &attrs, &mut vis, &i.node)\n         });\n \n-        hir::Item {\n+        Some(hir::Item {\n             id: i.id,\n             name: name,\n             attrs: attrs,\n             node: node,\n             vis: vis,\n             span: i.span,\n-        }\n+        })\n     }\n \n     fn lower_foreign_item(&mut self, i: &ForeignItem) -> hir::ForeignItem {"}, {"sha": "f15e063e81e337ce6e53e9df924fc67a234ebf4e", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=1b19284ad9d85f2848650be6dd466ad0e1e2d82c", "patch": "@@ -108,7 +108,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             ItemKind::Mod(..) => DefPathData::Module(i.ident.name.as_str()),\n             ItemKind::Static(..) | ItemKind::Const(..) | ItemKind::Fn(..) =>\n                 DefPathData::ValueNs(i.ident.name.as_str()),\n-            ItemKind::Mac(..) if i.id == DUMMY_NODE_ID => return, // Scope placeholder\n+            ItemKind::MacroDef(..) => DefPathData::MacroDef(i.ident.name.as_str()),\n             ItemKind::Mac(..) => return self.visit_macro_invoc(i.id, false),\n             ItemKind::Use(ref view_path) => {\n                 match view_path.node {\n@@ -269,10 +269,6 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n         self.create_def(def.lifetime.id, DefPathData::LifetimeDef(def.lifetime.name.as_str()));\n     }\n \n-    fn visit_macro_def(&mut self, macro_def: &'a MacroDef) {\n-        self.create_def(macro_def.id, DefPathData::MacroDef(macro_def.ident.name.as_str()));\n-    }\n-\n     fn visit_stmt(&mut self, stmt: &'a Stmt) {\n         match stmt.node {\n             StmtKind::Mac(..) => self.visit_macro_invoc(stmt.id, false),"}, {"sha": "e9fb4632fa178c4cb6029adb0faae13aecd2d718", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=1b19284ad9d85f2848650be6dd466ad0e1e2d82c", "patch": "@@ -136,7 +136,7 @@ pub struct NativeLibrary {\n }\n \n pub enum LoadedMacro {\n-    MacroRules(ast::MacroDef),\n+    MacroDef(ast::Item),\n     ProcMacro(Rc<SyntaxExtension>),\n }\n "}, {"sha": "2126a5a7c71bd5e5f201713fe1770df063b6585f", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=1b19284ad9d85f2848650be6dd466ad0e1e2d82c", "patch": "@@ -43,7 +43,6 @@ use super::Compilation;\n use serialize::json;\n \n use std::env;\n-use std::mem;\n use std::ffi::{OsString, OsStr};\n use std::fs;\n use std::io::{self, Write};\n@@ -708,8 +707,6 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n         krate\n     });\n \n-    krate.exported_macros = mem::replace(&mut resolver.exported_macros, Vec::new());\n-\n     krate = time(time_passes, \"maybe building test harness\", || {\n         syntax::test::modify_for_testing(&sess.parse_sess,\n                                          &mut resolver,"}, {"sha": "2a67b79eaa52e6022ef699ee90fcbad76e91380c", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=1b19284ad9d85f2848650be6dd466ad0e1e2d82c", "patch": "@@ -414,12 +414,13 @@ impl CrateStore for cstore::CStore {\n         sess.imported_macro_spans.borrow_mut()\n             .insert(local_span, (name.to_string(), data.get_span(id.index, sess)));\n \n-        LoadedMacro::MacroRules(ast::MacroDef {\n+        LoadedMacro::MacroDef(ast::Item {\n             ident: ast::Ident::with_empty_ctxt(name),\n             id: ast::DUMMY_NODE_ID,\n             span: local_span,\n             attrs: attrs,\n-            body: body.into(),\n+            node: ast::ItemKind::MacroDef(body.into()),\n+            vis: ast::Visibility::Inherited,\n         })\n     }\n "}, {"sha": "749146fe49672a766c755e2fd02b180fbadf57cc", "filename": "src/librustc_passes/hir_stats.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=1b19284ad9d85f2848650be6dd466ad0e1e2d82c", "patch": "@@ -375,9 +375,4 @@ impl<'v> ast_visit::Visitor<'v> for StatCollector<'v> {\n     fn visit_attribute(&mut self, attr: &'v ast::Attribute) {\n         self.record(\"Attribute\", Id::None, attr);\n     }\n-\n-    fn visit_macro_def(&mut self, macro_def: &'v ast::MacroDef) {\n-        self.record(\"MacroDef\", Id::None, macro_def);\n-        ast_visit::walk_macro_def(self, macro_def)\n-    }\n }"}, {"sha": "03c61067d64c20d44b2a7aebf412519f68739b8e", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=1b19284ad9d85f2848650be6dd466ad0e1e2d82c", "patch": "@@ -37,7 +37,6 @@ use syntax::ast::{Mutability, StmtKind, TraitItem, TraitItemKind};\n use syntax::ast::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n use syntax::ext::base::SyntaxExtension;\n use syntax::ext::base::Determinacy::Undetermined;\n-use syntax::ext::expand::mark_tts;\n use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n use syntax::parse::token;\n@@ -373,7 +372,7 @@ impl<'a> Resolver<'a> {\n                 self.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n                 self.current_module = module;\n             }\n-            ItemKind::Mac(_) => panic!(\"unexpanded macro in resolve!\"),\n+            ItemKind::MacroDef(..) | ItemKind::Mac(_) => unreachable!(),\n         }\n     }\n \n@@ -493,6 +492,16 @@ impl<'a> Resolver<'a> {\n         })\n     }\n \n+    pub fn macro_def_scope(&mut self, expansion: Mark) -> Module<'a> {\n+        let def_id = self.macro_defs[&expansion];\n+        if let Some(id) = self.definitions.as_local_node_id(def_id) {\n+            self.local_macro_def_scopes[&id]\n+        } else {\n+            let module_def_id = ty::DefIdTree::parent(&*self, def_id).unwrap();\n+            self.get_extern_crate_root(module_def_id.krate)\n+        }\n+    }\n+\n     pub fn get_macro(&mut self, def: Def) -> Rc<SyntaxExtension> {\n         let def_id = match def {\n             Def::Macro(def_id, ..) => def_id,\n@@ -502,22 +511,12 @@ impl<'a> Resolver<'a> {\n             return ext.clone();\n         }\n \n-        let mut macro_rules = match self.session.cstore.load_macro(def_id, &self.session) {\n-            LoadedMacro::MacroRules(macro_rules) => macro_rules,\n+        let macro_def = match self.session.cstore.load_macro(def_id, &self.session) {\n+            LoadedMacro::MacroDef(macro_def) => macro_def,\n             LoadedMacro::ProcMacro(ext) => return ext,\n         };\n \n-        let mark = Mark::fresh();\n-        let invocation = self.arenas.alloc_invocation_data(InvocationData {\n-            module: Cell::new(self.get_extern_crate_root(def_id.krate)),\n-            def_index: CRATE_DEF_INDEX,\n-            const_expr: false,\n-            legacy_scope: Cell::new(LegacyScope::Empty),\n-            expansion: Cell::new(LegacyScope::Empty),\n-        });\n-        self.invocations.insert(mark, invocation);\n-        macro_rules.body = mark_tts(macro_rules.stream(), mark).into();\n-        let ext = Rc::new(macro_rules::compile(&self.session.parse_sess, &macro_rules));\n+        let ext = Rc::new(macro_rules::compile(&self.session.parse_sess, &macro_def));\n         self.macro_map.insert(def_id, ext.clone());\n         ext\n     }\n@@ -707,12 +706,12 @@ impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> {\n \n     fn visit_item(&mut self, item: &'a Item) {\n         let macro_use = match item.node {\n-            ItemKind::Mac(ref mac) => {\n-                if mac.node.path.segments.is_empty() {\n-                    self.legacy_scope = LegacyScope::Expansion(self.visit_invoc(item.id));\n-                } else {\n-                    self.resolver.define_macro(item, &mut self.legacy_scope);\n-                }\n+            ItemKind::MacroDef(..) => {\n+                self.resolver.define_macro(item, &mut self.legacy_scope);\n+                return\n+            }\n+            ItemKind::Mac(..) => {\n+                self.legacy_scope = LegacyScope::Expansion(self.visit_invoc(item.id));\n                 return\n             }\n             ItemKind::Mod(..) => self.resolver.contains_macro_use(&item.attrs),"}, {"sha": "0958748ed092fc88ffd76c61b5d2076a39cf29d7", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 37, "deletions": 31, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=1b19284ad9d85f2848650be6dd466ad0e1e2d82c", "patch": "@@ -779,8 +779,8 @@ enum RibKind<'a> {\n     // We passed through a module.\n     ModuleRibKind(Module<'a>),\n \n-    // We passed through a `macro_rules!` statement with the given expansion\n-    MacroDefinition(Mark),\n+    // We passed through a `macro_rules!` statement\n+    MacroDefinition(DefId),\n \n     // All bindings in this rib are type parameters that can't be used\n     // from the default of a type parameter because they're not declared\n@@ -997,14 +997,18 @@ impl<'a> NameBinding<'a> {\n         }\n     }\n \n-    fn get_macro(&self, resolver: &mut Resolver<'a>) -> Rc<SyntaxExtension> {\n+    fn def_ignoring_ambiguity(&self) -> Def {\n         match self.kind {\n-            NameBindingKind::Import { binding, .. } => binding.get_macro(resolver),\n-            NameBindingKind::Ambiguity { b1, .. } => b1.get_macro(resolver),\n-            _ => resolver.get_macro(self.def()),\n+            NameBindingKind::Import { binding, .. } => binding.def_ignoring_ambiguity(),\n+            NameBindingKind::Ambiguity { b1, .. } => b1.def_ignoring_ambiguity(),\n+            _ => self.def(),\n         }\n     }\n \n+    fn get_macro(&self, resolver: &mut Resolver<'a>) -> Rc<SyntaxExtension> {\n+        resolver.get_macro(self.def_ignoring_ambiguity())\n+    }\n+\n     // We sometimes need to treat variants as `pub` for backwards compatibility\n     fn pseudo_vis(&self) -> ty::Visibility {\n         if self.is_variant() { ty::Visibility::Public } else { self.vis }\n@@ -1092,10 +1096,6 @@ pub struct Resolver<'a> {\n \n     pub definitions: Definitions,\n \n-    // Maps the node id of a statement to the expansions of the `macro_rules!`s\n-    // immediately above the statement (if appropriate).\n-    macros_at_scope: FxHashMap<NodeId, Vec<Mark>>,\n-\n     graph_root: Module<'a>,\n \n     prelude: Option<Module<'a>>,\n@@ -1171,12 +1171,13 @@ pub struct Resolver<'a> {\n     dummy_binding: &'a NameBinding<'a>,\n     use_extern_macros: bool, // true if `#![feature(use_extern_macros)]`\n \n-    pub exported_macros: Vec<ast::MacroDef>,\n     crate_loader: &'a mut CrateLoader,\n     macro_names: FxHashSet<Name>,\n     builtin_macros: FxHashMap<Name, &'a NameBinding<'a>>,\n     lexical_macro_resolutions: Vec<(Name, &'a Cell<LegacyScope<'a>>)>,\n     macro_map: FxHashMap<DefId, Rc<SyntaxExtension>>,\n+    macro_defs: FxHashMap<Mark, DefId>,\n+    local_macro_def_scopes: FxHashMap<NodeId, Module<'a>>,\n     macro_exports: Vec<Export>,\n     pub whitelisted_legacy_custom_derives: Vec<Name>,\n     pub found_unresolved_macro: bool,\n@@ -1305,11 +1306,13 @@ impl<'a> Resolver<'a> {\n \n         let features = session.features.borrow();\n \n+        let mut macro_defs = FxHashMap();\n+        macro_defs.insert(Mark::root(), root_def_id);\n+\n         Resolver {\n             session: session,\n \n             definitions: definitions,\n-            macros_at_scope: FxHashMap(),\n \n             // The outermost module has def ID 0; this is not reflected in the\n             // AST.\n@@ -1365,14 +1368,15 @@ impl<'a> Resolver<'a> {\n             // `#![feature(proc_macro)]` implies `#[feature(extern_macros)]`\n             use_extern_macros: features.use_extern_macros || features.proc_macro,\n \n-            exported_macros: Vec::new(),\n             crate_loader: crate_loader,\n             macro_names: FxHashSet(),\n             builtin_macros: FxHashMap(),\n             lexical_macro_resolutions: Vec::new(),\n             macro_map: FxHashMap(),\n             macro_exports: Vec::new(),\n             invocations: invocations,\n+            macro_defs: macro_defs,\n+            local_macro_def_scopes: FxHashMap(),\n             name_already_seen: FxHashMap(),\n             whitelisted_legacy_custom_derives: Vec::new(),\n             proc_macro_enabled: features.proc_macro,\n@@ -1510,24 +1514,25 @@ impl<'a> Resolver<'a> {\n                 }\n             }\n \n-            if let MacroDefinition(mac) = self.ribs[ns][i].kind {\n+            if let MacroDefinition(def) = self.ribs[ns][i].kind {\n                 // If an invocation of this macro created `ident`, give up on `ident`\n                 // and switch to `ident`'s source from the macro definition.\n-                let (source_ctxt, source_macro) = ident.ctxt.source();\n-                if source_macro == mac {\n-                    ident.ctxt = source_ctxt;\n+                let ctxt_data = ident.ctxt.data();\n+                if def == self.macro_defs[&ctxt_data.outer_mark] {\n+                    ident.ctxt = ctxt_data.prev_ctxt;\n                 }\n             }\n         }\n \n         None\n     }\n \n-    fn resolve_crate_var(&mut self, mut crate_var_ctxt: SyntaxContext) -> Module<'a> {\n-        while crate_var_ctxt.source().0 != SyntaxContext::empty() {\n-            crate_var_ctxt = crate_var_ctxt.source().0;\n+    fn resolve_crate_var(&mut self, crate_var_ctxt: SyntaxContext) -> Module<'a> {\n+        let mut ctxt_data = crate_var_ctxt.data();\n+        while ctxt_data.prev_ctxt != SyntaxContext::empty() {\n+            ctxt_data = ctxt_data.prev_ctxt.data();\n         }\n-        let module = self.invocations[&crate_var_ctxt.source().1].module.get();\n+        let module = self.macro_def_scope(ctxt_data.outer_mark);\n         if module.is_local() { self.graph_root } else { module }\n     }\n \n@@ -1579,12 +1584,12 @@ impl<'a> Resolver<'a> {\n                 NormalRibKind => {\n                     // Continue\n                 }\n-                MacroDefinition(mac) => {\n+                MacroDefinition(def) => {\n                     // If an invocation of this macro created `ident`, give up on `ident`\n                     // and switch to `ident`'s source from the macro definition.\n-                    let (source_ctxt, source_macro) = ident.ctxt.source();\n-                    if source_macro == mac {\n-                        ident.ctxt = source_ctxt;\n+                    let ctxt_data = ident.ctxt.data();\n+                    if def == self.macro_defs[&ctxt_data.outer_mark] {\n+                        ident.ctxt = ctxt_data.prev_ctxt;\n                     }\n                 }\n                 _ => {\n@@ -1696,7 +1701,7 @@ impl<'a> Resolver<'a> {\n                 }\n             }\n \n-            ItemKind::ExternCrate(_) => {\n+            ItemKind::ExternCrate(_) | ItemKind::MacroDef(..) => {\n                 // do nothing, these are just around to be encoded\n             }\n \n@@ -2031,11 +2036,12 @@ impl<'a> Resolver<'a> {\n \n         // Descend into the block.\n         for stmt in &block.stmts {\n-            if let Some(marks) = self.macros_at_scope.remove(&stmt.id) {\n-                num_macro_definition_ribs += marks.len() as u32;\n-                for mark in marks {\n-                    self.ribs[ValueNS].push(Rib::new(MacroDefinition(mark)));\n-                    self.label_ribs.push(Rib::new(MacroDefinition(mark)));\n+            if let ast::StmtKind::Item(ref item) = stmt.node {\n+                if let ast::ItemKind::MacroDef(..) = item.node {\n+                    num_macro_definition_ribs += 1;\n+                    let def = self.definitions.local_def_id(item.id);\n+                    self.ribs[ValueNS].push(Rib::new(MacroDefinition(def)));\n+                    self.label_ribs.push(Rib::new(MacroDefinition(def)));\n                 }\n             }\n "}, {"sha": "7ad122d1c31d8d13373dfc90eff69071702beb7e", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 105, "deletions": 57, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=1b19284ad9d85f2848650be6dd466ad0e1e2d82c", "patch": "@@ -17,25 +17,26 @@ use rustc::hir::def_id::{DefId, BUILTIN_MACROS_CRATE, CRATE_DEF_INDEX, DefIndex}\n use rustc::hir::def::{Def, Export};\n use rustc::hir::map::{self, DefCollector};\n use rustc::ty;\n-use std::cell::Cell;\n-use std::rc::Rc;\n use syntax::ast::{self, Name, Ident};\n-use syntax::attr;\n+use syntax::attr::{self, HasAttrs};\n use syntax::errors::DiagnosticBuilder;\n-use syntax::ext::base::{self, Determinacy, MultiModifier, MultiDecorator};\n-use syntax::ext::base::{Resolver as SyntaxResolver, SyntaxExtension};\n-use syntax::ext::base::MacroKind;\n-use syntax::ext::expand::{Expansion, mark_tts};\n+use syntax::ext::base::{self, Annotatable, Determinacy, MultiModifier, MultiDecorator};\n+use syntax::ext::base::{MacroKind, SyntaxExtension, Resolver as SyntaxResolver};\n+use syntax::ext::expand::{Expansion, ExpansionKind, Invocation, InvocationKind, find_attr_invoc};\n use syntax::ext::hygiene::Mark;\n+use syntax::ext::placeholders::placeholder;\n use syntax::ext::tt::macro_rules;\n use syntax::feature_gate::{self, emit_feature_err, GateIssue};\n use syntax::fold::{self, Folder};\n use syntax::ptr::P;\n use syntax::symbol::{Symbol, keywords};\n use syntax::util::lev_distance::find_best_match_for_name;\n-use syntax::visit::Visitor;\n use syntax_pos::{Span, DUMMY_SP};\n \n+use std::cell::Cell;\n+use std::mem;\n+use std::rc::Rc;\n+\n #[derive(Clone)]\n pub struct InvocationData<'a> {\n     pub module: Cell<Module<'a>>,\n@@ -73,7 +74,7 @@ pub enum LegacyScope<'a> {\n pub struct LegacyBinding<'a> {\n     pub parent: Cell<LegacyScope<'a>>,\n     pub name: ast::Name,\n-    ext: Rc<SyntaxExtension>,\n+    def_id: DefId,\n     pub span: Span,\n }\n \n@@ -151,7 +152,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n         invocation.expansion.set(visitor.legacy_scope);\n     }\n \n-    fn add_ext(&mut self, ident: ast::Ident, ext: Rc<SyntaxExtension>) {\n+    fn add_builtin(&mut self, ident: ast::Ident, ext: Rc<SyntaxExtension>) {\n         let def_id = DefId {\n             krate: BUILTIN_MACROS_CRATE,\n             index: DefIndex::new(self.macro_map.len()),\n@@ -167,10 +168,6 @@ impl<'a> base::Resolver for Resolver<'a> {\n         self.builtin_macros.insert(ident.name, binding);\n     }\n \n-    fn add_expansions_at_stmt(&mut self, id: ast::NodeId, macros: Vec<Mark>) {\n-        self.macros_at_scope.insert(id, macros);\n-    }\n-\n     fn resolve_imports(&mut self) {\n         ImportResolver { resolver: self }.resolve_imports()\n     }\n@@ -240,8 +237,83 @@ impl<'a> base::Resolver for Resolver<'a> {\n         None\n     }\n \n-    fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, kind: MacroKind,\n-                     force: bool) -> Result<Rc<SyntaxExtension>, Determinacy> {\n+    fn resolve_invoc(&mut self, invoc: &mut Invocation, scope: Mark, force: bool)\n+                     -> Result<Option<Rc<SyntaxExtension>>, Determinacy> {\n+        let def = match invoc.kind {\n+            InvocationKind::Attr { attr: None, .. } => return Ok(None),\n+            _ => match self.resolve_invoc_to_def(invoc, scope, force) {\n+                Ok(def) => def,\n+                Err(determinacy) => return Err(determinacy),\n+            },\n+        };\n+        self.macro_defs.insert(invoc.expansion_data.mark, def.def_id());\n+        Ok(Some(self.get_macro(def)))\n+    }\n+\n+    fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, kind: MacroKind, force: bool)\n+                     -> Result<Rc<SyntaxExtension>, Determinacy> {\n+        self.resolve_macro_to_def(scope, path, kind, force).map(|def| self.get_macro(def))\n+    }\n+}\n+\n+impl<'a> Resolver<'a> {\n+    fn resolve_invoc_to_def(&mut self, invoc: &mut Invocation, scope: Mark, force: bool)\n+                            -> Result<Def, Determinacy> {\n+        let (attr, traits, item) = match invoc.kind {\n+            InvocationKind::Attr { ref mut attr, ref traits, ref mut item } => (attr, traits, item),\n+            InvocationKind::Bang { ref mac, .. } => {\n+                return self.resolve_macro_to_def(scope, &mac.node.path, MacroKind::Bang, force);\n+            }\n+            InvocationKind::Derive { name, span, .. } => {\n+                let path = ast::Path::from_ident(span, Ident::with_empty_ctxt(name));\n+                return self.resolve_macro_to_def(scope, &path, MacroKind::Derive, force);\n+            }\n+        };\n+\n+        let (attr_name, path) = {\n+            let attr = attr.as_ref().unwrap();\n+            (attr.name(), ast::Path::from_ident(attr.span, Ident::with_empty_ctxt(attr.name())))\n+        };\n+\n+        let mut determined = true;\n+        match self.resolve_macro_to_def(scope, &path, MacroKind::Attr, force) {\n+            Ok(def) => return Ok(def),\n+            Err(Determinacy::Undetermined) => determined = false,\n+            Err(Determinacy::Determined) if force => return Err(Determinacy::Determined),\n+            Err(Determinacy::Determined) => {}\n+        }\n+\n+        for &(name, span) in traits {\n+            let path = ast::Path::from_ident(span, Ident::with_empty_ctxt(name));\n+            match self.resolve_macro(scope, &path, MacroKind::Derive, force) {\n+                Ok(ext) => if let SyntaxExtension::ProcMacroDerive(_, ref inert_attrs) = *ext {\n+                    if inert_attrs.contains(&attr_name) {\n+                        // FIXME(jseyfried) Avoid `mem::replace` here.\n+                        let dummy_item = placeholder(ExpansionKind::Items, ast::DUMMY_NODE_ID)\n+                            .make_items().pop().unwrap();\n+                        let dummy_item = Annotatable::Item(dummy_item);\n+                        *item = mem::replace(item, dummy_item).map_attrs(|mut attrs| {\n+                            let inert_attr = attr.take().unwrap();\n+                            attr::mark_known(&inert_attr);\n+                            if self.proc_macro_enabled {\n+                                *attr = find_attr_invoc(&mut attrs);\n+                            }\n+                            attrs.push(inert_attr);\n+                            attrs\n+                        });\n+                    }\n+                    return Err(Determinacy::Undetermined);\n+                },\n+                Err(Determinacy::Undetermined) => determined = false,\n+                Err(Determinacy::Determined) => {}\n+            }\n+        }\n+\n+        Err(if determined { Determinacy::Determined } else { Determinacy::Undetermined })\n+    }\n+\n+    fn resolve_macro_to_def(&mut self, scope: Mark, path: &ast::Path, kind: MacroKind, force: bool)\n+                            -> Result<Def, Determinacy> {\n         let ast::Path { ref segments, span } = *path;\n         if segments.iter().any(|segment| segment.parameters.is_some()) {\n             let kind =\n@@ -264,10 +336,10 @@ impl<'a> base::Resolver for Resolver<'a> {\n                 return Err(Determinacy::Determined);\n             }\n \n-            let ext = match self.resolve_path(&path, Some(MacroNS), None) {\n+            let def = match self.resolve_path(&path, Some(MacroNS), None) {\n                 PathResult::NonModule(path_res) => match path_res.base_def() {\n                     Def::Err => Err(Determinacy::Determined),\n-                    def @ _ => Ok(self.get_macro(def)),\n+                    def @ _ => Ok(def),\n                 },\n                 PathResult::Module(..) => unreachable!(),\n                 PathResult::Indeterminate if !force => return Err(Determinacy::Undetermined),\n@@ -278,15 +350,15 @@ impl<'a> base::Resolver for Resolver<'a> {\n             };\n             self.current_module.macro_resolutions.borrow_mut()\n                 .push((path.into_boxed_slice(), span));\n-            return ext;\n+            return def;\n         }\n \n         let name = path[0].name;\n         let result = match self.resolve_legacy_scope(&invocation.legacy_scope, name, false) {\n-            Some(MacroBinding::Legacy(binding)) => Ok(binding.ext.clone()),\n-            Some(MacroBinding::Modern(binding)) => Ok(binding.get_macro(self)),\n+            Some(MacroBinding::Legacy(binding)) => Ok(Def::Macro(binding.def_id, MacroKind::Bang)),\n+            Some(MacroBinding::Modern(binding)) => Ok(binding.def_ignoring_ambiguity()),\n             None => match self.resolve_lexical_macro_path_segment(path[0], MacroNS, None) {\n-                Ok(binding) => Ok(binding.get_macro(self)),\n+                Ok(binding) => Ok(binding.def_ignoring_ambiguity()),\n                 Err(Determinacy::Undetermined) if !force =>\n                     return Err(Determinacy::Undetermined),\n                 Err(_) => {\n@@ -301,9 +373,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n         result\n     }\n-}\n \n-impl<'a> Resolver<'a> {\n     // Resolve the initial segment of a non-global macro path (e.g. `foo` in `foo::bar!();`)\n     pub fn resolve_lexical_macro_path_segment(&mut self,\n                                               ident: Ident,\n@@ -544,45 +614,23 @@ impl<'a> Resolver<'a> {\n     }\n \n     pub fn define_macro(&mut self, item: &ast::Item, legacy_scope: &mut LegacyScope<'a>) {\n-        let tts = match item.node {\n-            ast::ItemKind::Mac(ref mac) => mac.node.stream(),\n-            _ => unreachable!(),\n-        };\n-\n-        if item.ident.name == \"macro_rules\" {\n+        self.local_macro_def_scopes.insert(item.id, self.current_module);\n+        let ident = item.ident;\n+        if ident.name == \"macro_rules\" {\n             self.session.span_err(item.span, \"user-defined macros may not be named `macro_rules`\");\n         }\n \n-        let mark = Mark::from_placeholder_id(item.id);\n-        let invocation = self.invocations[&mark];\n-        invocation.module.set(self.current_module);\n-\n-        let mut def = ast::MacroDef {\n-            ident: item.ident,\n-            attrs: item.attrs.clone(),\n-            id: ast::DUMMY_NODE_ID,\n-            span: item.span,\n-            body: mark_tts(tts, mark).into(),\n-        };\n-\n+        let def_id = self.definitions.local_def_id(item.id);\n+        let ext = Rc::new(macro_rules::compile(&self.session.parse_sess, item));\n+        self.macro_map.insert(def_id, ext);\n         *legacy_scope = LegacyScope::Binding(self.arenas.alloc_legacy_binding(LegacyBinding {\n-            parent: Cell::new(*legacy_scope),\n-            name: def.ident.name,\n-            ext: Rc::new(macro_rules::compile(&self.session.parse_sess, &def)),\n-            span: def.span,\n+            parent: Cell::new(*legacy_scope), name: ident.name, def_id: def_id, span: item.span,\n         }));\n-        self.macro_names.insert(def.ident.name);\n+        self.macro_names.insert(ident.name);\n \n-        if attr::contains_name(&def.attrs, \"macro_export\") {\n-            def.id = self.next_node_id();\n-            DefCollector::new(&mut self.definitions).with_parent(CRATE_DEF_INDEX, |collector| {\n-                collector.visit_macro_def(&def)\n-            });\n-            self.macro_exports.push(Export {\n-                name: def.ident.name,\n-                def: Def::Macro(self.definitions.local_def_id(def.id), MacroKind::Bang),\n-            });\n-            self.exported_macros.push(def);\n+        if attr::contains_name(&item.attrs, \"macro_export\") {\n+            let def = Def::Macro(def_id, MacroKind::Bang);\n+            self.macro_exports.push(Export { name: ident.name, def: def });\n         }\n     }\n "}, {"sha": "b80de3cc505464450aa0a00483fe73ca5dd67495", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=1b19284ad9d85f2848650be6dd466ad0e1e2d82c", "patch": "@@ -16,6 +16,7 @@ use std::mem;\n use syntax::abi;\n use syntax::ast;\n use syntax::attr;\n+use syntax::tokenstream::TokenStream;\n use syntax_pos::Span;\n \n use rustc::hir::map as hir_map;\n@@ -205,14 +206,17 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     }\n                     let imported_from = self.cx.sess().cstore.original_crate_name(def_id.krate);\n                     let def = match self.cx.sess().cstore.load_macro(def_id, self.cx.sess()) {\n-                        LoadedMacro::MacroRules(macro_rules) => macro_rules,\n+                        LoadedMacro::MacroDef(macro_def) => macro_def,\n                         // FIXME(jseyfried): document proc macro reexports\n                         LoadedMacro::ProcMacro(..) => continue,\n                     };\n \n-                    // FIXME(jseyfried) merge with `self.visit_macro()`\n-                    let tts = def.stream().trees().collect::<Vec<_>>();\n-                    let matchers = tts.chunks(4).map(|arm| arm[0].span()).collect();\n+                    let matchers = if let ast::ItemKind::MacroDef(ref tokens) = def.node {\n+                        let tts: Vec<_> = TokenStream::from(tokens.clone()).into_trees().collect();\n+                        tts.chunks(4).map(|arm| arm[0].span()).collect()\n+                    } else {\n+                        unreachable!()\n+                    };\n                     om.macros.push(Macro {\n                         def_id: def_id,\n                         attrs: def.attrs.clone().into(),"}, {"sha": "981667337d59a9d02b839ab772411276d6344436", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=1b19284ad9d85f2848650be6dd466ad0e1e2d82c", "patch": "@@ -414,7 +414,6 @@ pub struct Crate {\n     pub module: Mod,\n     pub attrs: Vec<Attribute>,\n     pub span: Span,\n-    pub exported_macros: Vec<MacroDef>,\n }\n \n /// A spanned compile-time attribute list item.\n@@ -1855,10 +1854,13 @@ pub enum ItemKind {\n              Option<TraitRef>, // (optional) trait this impl implements\n              P<Ty>, // self\n              Vec<ImplItem>),\n-    /// A macro invocation (which includes macro definition).\n+    /// A macro invocation.\n     ///\n     /// E.g. `macro_rules! foo { .. }` or `foo!(..)`\n     Mac(Mac),\n+\n+    /// A macro definition.\n+    MacroDef(ThinTokenStream),\n }\n \n impl ItemKind {\n@@ -1877,6 +1879,7 @@ impl ItemKind {\n             ItemKind::Union(..) => \"union\",\n             ItemKind::Trait(..) => \"trait\",\n             ItemKind::Mac(..) |\n+            ItemKind::MacroDef(..) |\n             ItemKind::Impl(..) |\n             ItemKind::DefaultImpl(..) => \"item\"\n         }\n@@ -1912,24 +1915,6 @@ impl ForeignItemKind {\n     }\n }\n \n-/// A macro definition, in this crate or imported from another.\n-///\n-/// Not parsed directly, but created on macro import or `macro_rules!` expansion.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct MacroDef {\n-    pub ident: Ident,\n-    pub attrs: Vec<Attribute>,\n-    pub id: NodeId,\n-    pub span: Span,\n-    pub body: ThinTokenStream,\n-}\n-\n-impl MacroDef {\n-    pub fn stream(&self) -> TokenStream {\n-        self.body.clone().into()\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use serialize;"}, {"sha": "dc7e7673eb03cb1c1d6282852131824c94d99cb0", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=1b19284ad9d85f2848650be6dd466ad0e1e2d82c", "patch": "@@ -15,7 +15,7 @@ use attr::HasAttrs;\n use codemap::{self, CodeMap, ExpnInfo, Spanned, respan};\n use syntax_pos::{Span, ExpnId, NO_EXPANSION};\n use errors::{DiagnosticBuilder, FatalError};\n-use ext::expand::{self, Expansion};\n+use ext::expand::{self, Expansion, Invocation};\n use ext::hygiene::Mark;\n use fold::{self, Folder};\n use parse::{self, parser, DirectoryOwnership};\n@@ -552,14 +552,15 @@ pub trait Resolver {\n     fn is_whitelisted_legacy_custom_derive(&self, name: Name) -> bool;\n \n     fn visit_expansion(&mut self, mark: Mark, expansion: &Expansion, derives: &[Mark]);\n-    fn add_ext(&mut self, ident: ast::Ident, ext: Rc<SyntaxExtension>);\n-    fn add_expansions_at_stmt(&mut self, id: ast::NodeId, macros: Vec<Mark>);\n+    fn add_builtin(&mut self, ident: ast::Ident, ext: Rc<SyntaxExtension>);\n \n     fn resolve_imports(&mut self);\n     // Resolves attribute and derive legacy macros from `#![plugin(..)]`.\n     fn find_legacy_attr_invoc(&mut self, attrs: &mut Vec<Attribute>) -> Option<Attribute>;\n-    fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, kind: MacroKind,\n-                     force: bool) -> Result<Rc<SyntaxExtension>, Determinacy>;\n+    fn resolve_invoc(&mut self, invoc: &mut Invocation, scope: Mark, force: bool)\n+                     -> Result<Option<Rc<SyntaxExtension>>, Determinacy>;\n+    fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, kind: MacroKind, force: bool)\n+                     -> Result<Rc<SyntaxExtension>, Determinacy>;\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -577,11 +578,14 @@ impl Resolver for DummyResolver {\n     fn is_whitelisted_legacy_custom_derive(&self, _name: Name) -> bool { false }\n \n     fn visit_expansion(&mut self, _invoc: Mark, _expansion: &Expansion, _derives: &[Mark]) {}\n-    fn add_ext(&mut self, _ident: ast::Ident, _ext: Rc<SyntaxExtension>) {}\n-    fn add_expansions_at_stmt(&mut self, _id: ast::NodeId, _macros: Vec<Mark>) {}\n+    fn add_builtin(&mut self, _ident: ast::Ident, _ext: Rc<SyntaxExtension>) {}\n \n     fn resolve_imports(&mut self) {}\n     fn find_legacy_attr_invoc(&mut self, _attrs: &mut Vec<Attribute>) -> Option<Attribute> { None }\n+    fn resolve_invoc(&mut self, _invoc: &mut Invocation, _scope: Mark, _force: bool)\n+                     -> Result<Option<Rc<SyntaxExtension>>, Determinacy> {\n+        Err(Determinacy::Determined)\n+    }\n     fn resolve_macro(&mut self, _scope: Mark, _path: &ast::Path, _kind: MacroKind,\n                      _force: bool) -> Result<Rc<SyntaxExtension>, Determinacy> {\n         Err(Determinacy::Determined)"}, {"sha": "10168f010a077c9b94f2ec1d8e130fc108426252", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 10, "deletions": 79, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=1b19284ad9d85f2848650be6dd466ad0e1e2d82c", "patch": "@@ -154,7 +154,7 @@ impl ExpansionKind {\n pub struct Invocation {\n     pub kind: InvocationKind,\n     expansion_kind: ExpansionKind,\n-    expansion_data: ExpansionData,\n+    pub expansion_data: ExpansionData,\n }\n \n pub enum InvocationKind {\n@@ -251,7 +251,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n             let scope =\n                 if self.monotonic { invoc.expansion_data.mark } else { orig_expansion_data.mark };\n-            let ext = match self.resolve_invoc(&mut invoc, scope, force) {\n+            let ext = match self.cx.resolver.resolve_invoc(&mut invoc, scope, force) {\n                 Ok(ext) => Some(ext),\n                 Err(Determinacy::Determined) => None,\n                 Err(Determinacy::Undetermined) => {\n@@ -364,64 +364,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         result\n     }\n \n-    fn resolve_invoc(&mut self, invoc: &mut Invocation, scope: Mark, force: bool)\n-                     -> Result<Option<Rc<SyntaxExtension>>, Determinacy> {\n-        let (attr, traits, item) = match invoc.kind {\n-            InvocationKind::Bang { ref mac, .. } => {\n-                return self.cx.resolver.resolve_macro(scope, &mac.node.path,\n-                                                      MacroKind::Bang, force).map(Some);\n-            }\n-            InvocationKind::Attr { attr: None, .. } => return Ok(None),\n-            InvocationKind::Derive { name, span, .. } => {\n-                let path = ast::Path::from_ident(span, Ident::with_empty_ctxt(name));\n-                return self.cx.resolver.resolve_macro(scope, &path,\n-                                                      MacroKind::Derive, force).map(Some)\n-            }\n-            InvocationKind::Attr { ref mut attr, ref traits, ref mut item } => (attr, traits, item),\n-        };\n-\n-        let (attr_name, path) = {\n-            let attr = attr.as_ref().unwrap();\n-            (attr.name(), ast::Path::from_ident(attr.span, Ident::with_empty_ctxt(attr.name())))\n-        };\n-\n-        let mut determined = true;\n-        match self.cx.resolver.resolve_macro(scope, &path, MacroKind::Attr, force) {\n-            Ok(ext) => return Ok(Some(ext)),\n-            Err(Determinacy::Undetermined) => determined = false,\n-            Err(Determinacy::Determined) if force => return Err(Determinacy::Determined),\n-            _ => {}\n-        }\n-\n-        for &(name, span) in traits {\n-            let path = ast::Path::from_ident(span, Ident::with_empty_ctxt(name));\n-            match self.cx.resolver.resolve_macro(scope, &path, MacroKind::Derive, force) {\n-                Ok(ext) => if let SyntaxExtension::ProcMacroDerive(_, ref inert_attrs) = *ext {\n-                    if inert_attrs.contains(&attr_name) {\n-                        // FIXME(jseyfried) Avoid `mem::replace` here.\n-                        let dummy_item = placeholder(ExpansionKind::Items, ast::DUMMY_NODE_ID)\n-                            .make_items().pop().unwrap();\n-                        *item = mem::replace(item, Annotatable::Item(dummy_item))\n-                            .map_attrs(|mut attrs| {\n-                                let inert_attr = attr.take().unwrap();\n-                                attr::mark_known(&inert_attr);\n-                                if self.cx.ecfg.proc_macro_enabled() {\n-                                    *attr = find_attr_invoc(&mut attrs);\n-                                }\n-                                attrs.push(inert_attr);\n-                                attrs\n-                            });\n-                    }\n-                    return Err(Determinacy::Undetermined);\n-                },\n-                Err(Determinacy::Undetermined) => determined = false,\n-                Err(Determinacy::Determined) => {}\n-            }\n-        }\n-\n-        Err(if determined { Determinacy::Determined } else { Determinacy::Undetermined })\n-    }\n-\n     fn expand_invoc(&mut self, invoc: Invocation, ext: Rc<SyntaxExtension>) -> Expansion {\n         match invoc.kind {\n             InvocationKind::Bang { .. } => self.expand_bang_invoc(invoc, ext),\n@@ -502,7 +444,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n         let extname = path.segments.last().unwrap().identifier.name;\n         let ident = ident.unwrap_or(keywords::Invalid.ident());\n-        let marked_tts = mark_tts(mac.node.stream(), mark);\n+        let marked_tts =\n+            noop_fold_tts(mac.node.stream(), &mut Marker { mark: mark, expn_id: None });\n         let opt_expanded = match *ext {\n             NormalTT(ref expandfun, exp_span, allow_internal_unstable) => {\n                 if ident.name != keywords::Invalid.name() {\n@@ -814,7 +757,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n     }\n }\n \n-fn find_attr_invoc(attrs: &mut Vec<ast::Attribute>) -> Option<ast::Attribute> {\n+pub fn find_attr_invoc(attrs: &mut Vec<ast::Attribute>) -> Option<ast::Attribute> {\n     for i in 0 .. attrs.len() {\n         if !attr::is_known(&attrs[i]) && !is_builtin_attr(&attrs[i]) {\n              return Some(attrs.remove(i));\n@@ -960,17 +903,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n         match item.node {\n             ast::ItemKind::Mac(..) => {\n                 self.check_attributes(&item.attrs);\n-                let is_macro_def = if let ItemKind::Mac(ref mac) = item.node {\n-                    mac.node.path.segments[0].identifier.name == \"macro_rules\"\n-                } else {\n-                    unreachable!()\n-                };\n-\n-                item.and_then(|mut item| match item.node {\n-                    ItemKind::Mac(_) if is_macro_def => {\n-                        item.id = Mark::fresh().as_placeholder_id();\n-                        SmallVector::one(P(item))\n-                    }\n+                item.and_then(|item| match item.node {\n                     ItemKind::Mac(mac) => {\n                         self.collect(ExpansionKind::Items, InvocationKind::Bang {\n                             mac: mac,\n@@ -1090,7 +1023,10 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n     }\n \n     fn fold_item_kind(&mut self, item: ast::ItemKind) -> ast::ItemKind {\n-        noop_fold_item_kind(self.cfg.configure_item_kind(item), self)\n+        match item {\n+            ast::ItemKind::MacroDef(..) => item,\n+            _ => noop_fold_item_kind(self.cfg.configure_item_kind(item), self),\n+        }\n     }\n \n     fn new_id(&mut self, id: ast::NodeId) -> ast::NodeId {\n@@ -1171,8 +1107,3 @@ impl Folder for Marker {\n         span\n     }\n }\n-\n-// apply a given mark to the given token trees. Used prior to expansion of a macro.\n-pub fn mark_tts(tts: TokenStream, m: Mark) -> TokenStream {\n-    noop_fold_tts(tts, &mut Marker{mark:m, expn_id: None})\n-}"}, {"sha": "57f5ab73d37062fbbb4079dae08a649e273e0f0c", "filename": "src/libsyntax/ext/hygiene.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibsyntax%2Fext%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibsyntax%2Fext%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fhygiene.rs?ref=1b19284ad9d85f2848650be6dd466ad0e1e2d82c", "patch": "@@ -31,7 +31,7 @@ pub struct SyntaxContextData {\n }\n \n /// A mark is a unique id associated with a macro expansion.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, Default)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, Default, RustcEncodable, RustcDecodable)]\n pub struct Mark(u32);\n \n impl Mark {\n@@ -118,13 +118,6 @@ impl SyntaxContext {\n             })\n         })\n     }\n-\n-    /// If `ident` is macro expanded, return the source ident from the macro definition\n-    /// and the mark of the expansion that created the macro definition.\n-    pub fn source(self) -> (Self /* source context */, Mark /* source macro */) {\n-         let macro_def_ctxt = self.data().prev_ctxt.data();\n-         (macro_def_ctxt.prev_ctxt, macro_def_ctxt.outer_mark)\n-    }\n }\n \n impl fmt::Debug for SyntaxContext {"}, {"sha": "f60b1d17a5e2f0c3c74058602712b3d172b35148", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=1b19284ad9d85f2848650be6dd466ad0e1e2d82c", "patch": "@@ -21,7 +21,6 @@ use util::move_map::MoveMap;\n use util::small_vector::SmallVector;\n \n use std::collections::HashMap;\n-use std::mem;\n \n pub fn placeholder(kind: ExpansionKind, id: ast::NodeId) -> Expansion {\n     fn mac_placeholder() -> ast::Mac {\n@@ -174,20 +173,11 @@ impl<'a, 'b> Folder for PlaceholderExpander<'a, 'b> {\n \n     fn fold_block(&mut self, block: P<ast::Block>) -> P<ast::Block> {\n         noop_fold_block(block, self).map(|mut block| {\n-            let mut macros = Vec::new();\n             let mut remaining_stmts = block.stmts.len();\n \n             block.stmts = block.stmts.move_flat_map(|mut stmt| {\n                 remaining_stmts -= 1;\n \n-                // `macro_rules!` macro definition\n-                if let ast::StmtKind::Item(ref item) = stmt.node {\n-                    if let ast::ItemKind::Mac(_) = item.node {\n-                        macros.push(Mark::from_placeholder_id(item.id));\n-                        return None;\n-                    }\n-                }\n-\n                 match stmt.node {\n                     // Avoid wasting a node id on a trailing expression statement,\n                     // which shares a HIR node with the expression itself.\n@@ -201,11 +191,6 @@ impl<'a, 'b> Folder for PlaceholderExpander<'a, 'b> {\n                     _ => {}\n                 }\n \n-                if self.monotonic && !macros.is_empty() {\n-                    let macros = mem::replace(&mut macros, Vec::new());\n-                    self.cx.resolver.add_expansions_at_stmt(stmt.id, macros);\n-                }\n-\n                 Some(stmt)\n             });\n "}, {"sha": "7aa1230f9aeea9a9eb664be80fed382307e9039a", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=1b19284ad9d85f2848650be6dd466ad0e1e2d82c", "patch": "@@ -153,7 +153,7 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n // Holy self-referential!\n \n /// Converts a `macro_rules!` invocation into a syntax extension.\n-pub fn compile(sess: &ParseSess, def: &ast::MacroDef) -> SyntaxExtension {\n+pub fn compile(sess: &ParseSess, def: &ast::Item) -> SyntaxExtension {\n     let lhs_nm = ast::Ident::with_empty_ctxt(Symbol::gensym(\"lhs\"));\n     let rhs_nm = ast::Ident::with_empty_ctxt(Symbol::gensym(\"rhs\"));\n \n@@ -183,7 +183,11 @@ pub fn compile(sess: &ParseSess, def: &ast::MacroDef) -> SyntaxExtension {\n     ];\n \n     // Parse the macro_rules! invocation\n-    let argument_map = match parse(sess, def.body.clone().into(), &argument_gram, None) {\n+    let body = match def.node {\n+        ast::ItemKind::MacroDef(ref body) => body.clone().into(),\n+        _ => unreachable!(),\n+    };\n+    let argument_map = match parse(sess, body, &argument_gram, None) {\n         Success(m) => m,\n         Failure(sp, tok) => {\n             let s = parse_failure_msg(tok);"}, {"sha": "fb4eb19be2b15d8f1a1f56fb019d3fa32cdbf80c", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=1b19284ad9d85f2848650be6dd466ad0e1e2d82c", "patch": "@@ -899,6 +899,7 @@ pub fn noop_fold_item_kind<T: Folder>(i: ItemKind, folder: &mut T) -> ItemKind {\n             items.move_flat_map(|item| folder.fold_trait_item(item)),\n         ),\n         ItemKind::Mac(m) => ItemKind::Mac(folder.fold_mac(m)),\n+        ItemKind::MacroDef(tts) => ItemKind::MacroDef(folder.fold_tts(tts.into()).into()),\n     }\n }\n \n@@ -959,7 +960,7 @@ pub fn noop_fold_mod<T: Folder>(Mod {inner, items}: Mod, folder: &mut T) -> Mod\n     }\n }\n \n-pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, mut exported_macros, span}: Crate,\n+pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, span}: Crate,\n                                   folder: &mut T) -> Crate {\n     let mut items = folder.fold_item(P(ast::Item {\n         ident: keywords::Invalid.ident(),\n@@ -987,14 +988,9 @@ pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, mut exported_macros, spa\n         }, vec![], span)\n     };\n \n-    for def in &mut exported_macros {\n-        def.id = folder.new_id(def.id);\n-    }\n-\n     Crate {\n         module: module,\n         attrs: attrs,\n-        exported_macros: exported_macros,\n         span: span,\n     }\n }\n@@ -1387,6 +1383,6 @@ mod tests {\n             matches_codepattern,\n             \"matches_codepattern\",\n             pprust::to_string(|s| fake_print_crate(s, &folded_crate)),\n-            \"zz!zz((zz$zz:zz$(zz $zz:zz)zz+=>(zz$(zz$zz$zz)+)));\".to_string());\n+            \"macro_rules! zz((zz$zz:zz$(zz $zz:zz)zz+=>(zz$(zz$zz$zz)+)));\".to_string());\n     }\n }"}, {"sha": "6446d38e5ef707e616e995c989afb3ac1c3038b5", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 42, "deletions": 3, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=1b19284ad9d85f2848650be6dd466ad0e1e2d82c", "patch": "@@ -1048,7 +1048,7 @@ impl<'a> Parser<'a> {\n         self.expected_tokens.clear();\n     }\n \n-    pub fn look_ahead<R, F>(&mut self, dist: usize, f: F) -> R where\n+    pub fn look_ahead<R, F>(&self, dist: usize, f: F) -> R where\n         F: FnOnce(&token::Token) -> R,\n     {\n         if dist == 0 {\n@@ -3699,11 +3699,41 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    fn is_union_item(&mut self) -> bool {\n+    fn is_union_item(&self) -> bool {\n         self.token.is_keyword(keywords::Union) &&\n         self.look_ahead(1, |t| t.is_ident() && !t.is_any_keyword())\n     }\n \n+    fn eat_macro_def(&mut self, attrs: &[Attribute], vis: &Visibility)\n+                     -> PResult<'a, Option<P<Item>>> {\n+        let lo = self.span.lo;\n+        match self.token {\n+            token::Ident(ident) if ident.name == \"macro_rules\" => {\n+                if self.look_ahead(1, |t| *t == token::Not) {\n+                    let prev_span = self.prev_span;\n+                    self.complain_if_pub_macro(vis, prev_span);\n+                    self.bump();\n+                    self.bump();\n+                }\n+            }\n+            _ => return Ok(None),\n+        };\n+\n+        let id = self.parse_ident()?;\n+        let (delim, tts) = self.expect_delimited_token_tree()?;\n+        if delim != token::Brace {\n+            if !self.eat(&token::Semi) {\n+                let msg = \"macros that expand to items must either be surrounded with braces \\\n+                           or followed by a semicolon\";\n+                self.span_err(self.prev_span, msg);\n+            }\n+        }\n+\n+        let hi = self.prev_span.hi;\n+        let kind = ItemKind::MacroDef(tts);\n+        Ok(Some(self.mk_item(lo, hi, id, kind, Visibility::Inherited, attrs.to_owned())))\n+    }\n+\n     fn parse_stmt_without_recovery(&mut self,\n                                    macro_legacy_warnings: bool)\n                                    -> PResult<'a, Option<Stmt>> {\n@@ -3718,6 +3748,12 @@ impl<'a> Parser<'a> {\n                 node: StmtKind::Local(self.parse_local(attrs.into())?),\n                 span: mk_sp(lo, self.prev_span.hi),\n             }\n+        } else if let Some(macro_def) = self.eat_macro_def(&attrs, &Visibility::Inherited)? {\n+            Stmt {\n+                id: ast::DUMMY_NODE_ID,\n+                node: StmtKind::Item(macro_def),\n+                span: mk_sp(lo, self.prev_span.hi),\n+            }\n         // Starts like a simple path, but not a union item.\n         } else if self.token.is_path_start() &&\n                   !self.token.is_qpath_start() &&\n@@ -5767,6 +5803,10 @@ impl<'a> Parser<'a> {\n                                     maybe_append(attrs, extra_attrs));\n             return Ok(Some(item));\n         }\n+        if let Some(macro_def) = self.eat_macro_def(&attrs, &visibility)? {\n+            return Ok(Some(macro_def));\n+        }\n+\n         self.parse_macro_use_or_failure(attrs,macros_allowed,attributes_allowed,lo,visibility)\n     }\n \n@@ -5948,7 +5988,6 @@ impl<'a> Parser<'a> {\n             attrs: self.parse_inner_attributes()?,\n             module: self.parse_mod_items(&token::Eof, lo)?,\n             span: mk_sp(lo, self.span.lo),\n-            exported_macros: Vec::new(),\n         })\n     }\n "}, {"sha": "3efadbd00d1e080924cd28dd33a46a6a9613b183", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=1b19284ad9d85f2848650be6dd466ad0e1e2d82c", "patch": "@@ -1318,7 +1318,6 @@ impl<'a> State<'a> {\n                 self.bclose(item.span)?;\n             }\n             ast::ItemKind::Mac(codemap::Spanned { ref node, .. }) => {\n-                self.print_visibility(&item.vis)?;\n                 self.print_path(&node.path, false, 0, false)?;\n                 word(&mut self.s, \"! \")?;\n                 self.print_ident(item.ident)?;\n@@ -1329,6 +1328,16 @@ impl<'a> State<'a> {\n                 word(&mut self.s, \";\")?;\n                 self.end()?;\n             }\n+            ast::ItemKind::MacroDef(ref tts) => {\n+                word(&mut self.s, \"macro_rules! \")?;\n+                self.print_ident(item.ident)?;\n+                self.cbox(INDENT_UNIT)?;\n+                self.popen()?;\n+                self.print_tts(tts.clone().into())?;\n+                self.pclose()?;\n+                word(&mut self.s, \";\")?;\n+                self.end()?;\n+            }\n         }\n         self.ann.post(self, NodeItem(item))\n     }"}, {"sha": "9d9957a0f45341c06746f44d886b842b1caa0c28", "filename": "src/libsyntax/util/node_count.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibsyntax%2Futil%2Fnode_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibsyntax%2Futil%2Fnode_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fnode_count.rs?ref=1b19284ad9d85f2848650be6dd466ad0e1e2d82c", "patch": "@@ -148,9 +148,4 @@ impl<'ast> Visitor<'ast> for NodeCounter {\n     fn visit_attribute(&mut self, _attr: &Attribute) {\n         self.count += 1;\n     }\n-    fn visit_macro_def(&mut self, macro_def: &MacroDef) {\n-        self.count += 1;\n-        walk_macro_def(self, macro_def)\n-    }\n-\n }"}, {"sha": "ee7dd18247b213d4b6b6a7c153b8db3c74ca3d60", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=1b19284ad9d85f2848650be6dd466ad0e1e2d82c", "patch": "@@ -125,9 +125,6 @@ pub trait Visitor<'ast>: Sized {\n         walk_assoc_type_binding(self, type_binding)\n     }\n     fn visit_attribute(&mut self, _attr: &'ast Attribute) {}\n-    fn visit_macro_def(&mut self, macro_def: &'ast MacroDef) {\n-        walk_macro_def(self, macro_def)\n-    }\n     fn visit_vis(&mut self, vis: &'ast Visibility) {\n         walk_vis(self, vis)\n     }\n@@ -176,12 +173,6 @@ pub fn walk_ident<'a, V: Visitor<'a>>(visitor: &mut V, span: Span, ident: Ident)\n pub fn walk_crate<'a, V: Visitor<'a>>(visitor: &mut V, krate: &'a Crate) {\n     visitor.visit_mod(&krate.module, krate.span, CRATE_NODE_ID);\n     walk_list!(visitor, visit_attribute, &krate.attrs);\n-    walk_list!(visitor, visit_macro_def, &krate.exported_macros);\n-}\n-\n-pub fn walk_macro_def<'a, V: Visitor<'a>>(visitor: &mut V, macro_def: &'a MacroDef) {\n-    visitor.visit_ident(macro_def.span, macro_def.ident);\n-    walk_list!(visitor, visit_attribute, &macro_def.attrs);\n }\n \n pub fn walk_mod<'a, V: Visitor<'a>>(visitor: &mut V, module: &'a Mod) {\n@@ -295,6 +286,7 @@ pub fn walk_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a Item) {\n             walk_list!(visitor, visit_trait_item, methods);\n         }\n         ItemKind::Mac(ref mac) => visitor.visit_mac(mac),\n+        ItemKind::MacroDef(..) => {},\n     }\n     walk_list!(visitor, visit_attribute, &item.attrs);\n }"}, {"sha": "b51591bf89d5e2275724a87d7a41c6d82dcb72c6", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=1b19284ad9d85f2848650be6dd466ad0e1e2d82c", "patch": "@@ -99,7 +99,7 @@ macro_rules! derive_traits {\n \n         pub fn register_builtin_derives(resolver: &mut Resolver) {\n             $(\n-                resolver.add_ext(\n+                resolver.add_builtin(\n                     ast::Ident::with_empty_ctxt(Symbol::intern($name)),\n                     Rc::new(SyntaxExtension::BuiltinDerive($func))\n                 );"}, {"sha": "1e9b112b6df564263738be5f058d2e4c1a54bed6", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=1b19284ad9d85f2848650be6dd466ad0e1e2d82c", "patch": "@@ -59,7 +59,7 @@ pub fn register_builtins(resolver: &mut syntax::ext::base::Resolver,\n     deriving::register_builtin_derives(resolver);\n \n     let mut register = |name, ext| {\n-        resolver.add_ext(ast::Ident::with_empty_ctxt(name), Rc::new(ext));\n+        resolver.add_builtin(ast::Ident::with_empty_ctxt(name), Rc::new(ext));\n     };\n \n     macro_rules! register {"}, {"sha": "5adaf470f2374be020e1e2b0330ad3d87cd99762", "filename": "src/libsyntax_ext/proc_macro_registrar.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs?ref=1b19284ad9d85f2848650be6dd466ad0e1e2d82c", "patch": "@@ -90,12 +90,7 @@ pub fn modify(sess: &ParseSess,\n \n     krate.module.items.push(mk_registrar(&mut cx, &derives, &attr_macros, &bang_macros));\n \n-    if krate.exported_macros.len() > 0 {\n-        handler.err(\"cannot export macro_rules! macros from a `proc-macro` \\\n-                     crate type currently\");\n-    }\n-\n-    return krate\n+    krate\n }\n \n fn is_proc_macro_attr(attr: &ast::Attribute) -> bool {\n@@ -251,6 +246,15 @@ impl<'a> CollectProcMacros<'a> {\n \n impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n     fn visit_item(&mut self, item: &'a ast::Item) {\n+        if let ast::ItemKind::MacroDef(..) = item.node {\n+            if self.is_proc_macro_crate &&\n+               item.attrs.iter().any(|attr| attr.name() == \"macro_export\") {\n+                let msg =\n+                    \"cannot export macro_rules! macros from a `proc-macro` crate type currently\";\n+                self.handler.span_err(item.span, msg);\n+            }\n+        }\n+\n         // First up, make sure we're checking a bare function. If we're not then\n         // we're just not interested in this item.\n         //"}, {"sha": "3d2dd380e488e76abadd2afed8c68435b56f4909", "filename": "src/test/run-make/pretty-expanded-hygiene/input.pp.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Ftest%2Frun-make%2Fpretty-expanded-hygiene%2Finput.pp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b19284ad9d85f2848650be6dd466ad0e1e2d82c/src%2Ftest%2Frun-make%2Fpretty-expanded-hygiene%2Finput.pp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fpretty-expanded-hygiene%2Finput.pp.rs?ref=1b19284ad9d85f2848650be6dd466ad0e1e2d82c", "patch": "@@ -12,6 +12,7 @@\n #![feature(no_core)]\n #![no_core]\n \n+macro_rules! foo /* 60#0 */(( $ x : ident ) => { y + $ x });\n \n fn bar /* 62#0 */() { let x /* 59#2 */ = 1; y /* 61#4 */ + x /* 59#5 */ }\n "}]}