{"sha": "92f57211c1ed9a27fcd86bf05ee9c930b1b4449a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyZjU3MjExYzFlZDlhMjdmY2Q4NmJmMDVlZTljOTMwYjFiNDQ0OWE=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2019-03-17T03:25:59Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2019-03-17T03:33:13Z"}, "message": "Support path-clarity submodule", "tree": {"sha": "39cfd2c617c44313bc043cd95529c842ef972234", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39cfd2c617c44313bc043cd95529c842ef972234"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92f57211c1ed9a27fcd86bf05ee9c930b1b4449a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92f57211c1ed9a27fcd86bf05ee9c930b1b4449a", "html_url": "https://github.com/rust-lang/rust/commit/92f57211c1ed9a27fcd86bf05ee9c930b1b4449a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92f57211c1ed9a27fcd86bf05ee9c930b1b4449a/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bde77714e696602f52ca6d9378eabd9a642a1a27", "url": "https://api.github.com/repos/rust-lang/rust/commits/bde77714e696602f52ca6d9378eabd9a642a1a27", "html_url": "https://github.com/rust-lang/rust/commit/bde77714e696602f52ca6d9378eabd9a642a1a27"}], "stats": {"total": 280, "additions": 192, "deletions": 88}, "files": [{"sha": "56adfa9b1a3889b9f6ca5dc9fd025dfd63c53411", "filename": "src/formatting.rs", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/92f57211c1ed9a27fcd86bf05ee9c930b1b4449a/src%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f57211c1ed9a27fcd86bf05ee9c930b1b4449a/src%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformatting.rs?ref=92f57211c1ed9a27fcd86bf05ee9c930b1b4449a", "patch": "@@ -10,7 +10,7 @@ use syntax::ast;\n use syntax::errors::emitter::{ColorConfig, EmitterWriter};\n use syntax::errors::{DiagnosticBuilder, Handler};\n use syntax::parse::{self, ParseSess};\n-use syntax::source_map::{FilePathMapping, SourceMap, Span};\n+use syntax::source_map::{FilePathMapping, SourceMap, Span, DUMMY_SP};\n \n use crate::comment::{CharClasses, FullCodeCharKind};\n use crate::config::{Config, FileName, Verbosity};\n@@ -73,7 +73,14 @@ fn format_project<T: FormatHandler>(\n     let source_map = Rc::new(SourceMap::new(FilePathMapping::empty()));\n     let mut parse_session = make_parse_sess(source_map.clone(), config);\n     let mut report = FormatReport::new();\n-    let krate = match parse_crate(input, &parse_session, config, &mut report) {\n+    let directory_ownership = input.to_directory_ownership();\n+    let krate = match parse_crate(\n+        input,\n+        &parse_session,\n+        config,\n+        &mut report,\n+        directory_ownership,\n+    ) {\n         Ok(krate) => krate,\n         // Surface parse error via Session (errors are merged there from report)\n         Err(ErrorKind::ParseError) => return Ok(report),\n@@ -87,8 +94,14 @@ fn format_project<T: FormatHandler>(\n \n     let mut context = FormatContext::new(&krate, report, parse_session, config, handler);\n \n-    let files = modules::list_files(&krate, context.parse_session.source_map())?;\n-    for (path, module) in files {\n+    let files = modules::ModResolver::new(\n+        context.parse_session.source_map(),\n+        directory_ownership.unwrap_or(parse::DirectoryOwnership::UnownedViaMod(false)),\n+        input_is_stdin,\n+    )\n+    .visit_crate(&krate)\n+    .map_err(|e| io::Error::new(io::ErrorKind::Other, e))?;\n+    for (path, (module, _)) in files {\n         if (config.skip_children() && path != main_file) || config.ignore().skip_file(&path) {\n             continue;\n         }\n@@ -593,11 +606,19 @@ fn parse_crate(\n     parse_session: &ParseSess,\n     config: &Config,\n     report: &mut FormatReport,\n+    directory_ownership: Option<parse::DirectoryOwnership>,\n ) -> Result<ast::Crate, ErrorKind> {\n     let input_is_stdin = input.is_text();\n \n     let parser = match input {\n-        Input::File(file) => Ok(parse::new_parser_from_file(parse_session, &file)),\n+        Input::File(ref file) => {\n+            // Use `new_sub_parser_from_file` when we the input is a submodule.\n+            Ok(if let Some(dir_own) = directory_ownership {\n+                parse::new_sub_parser_from_file(parse_session, file, dir_own, None, DUMMY_SP)\n+            } else {\n+                parse::new_parser_from_file(parse_session, file)\n+            })\n+        }\n         Input::Text(text) => parse::maybe_new_parser_from_source_str(\n             parse_session,\n             syntax::source_map::FileName::Custom(\"stdin\".to_owned()),"}, {"sha": "b1090e95ff374c12531c694428ef73576419b2e1", "filename": "src/lib.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/92f57211c1ed9a27fcd86bf05ee9c930b1b4449a/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f57211c1ed9a27fcd86bf05ee9c930b1b4449a/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=92f57211c1ed9a27fcd86bf05ee9c930b1b4449a", "patch": "@@ -20,7 +20,7 @@ use std::path::PathBuf;\n use std::rc::Rc;\n \n use failure::Fail;\n-use syntax::ast;\n+use syntax::{ast, parse::DirectoryOwnership};\n \n use crate::comment::LineClasses;\n use crate::formatting::{FormatErrorMap, FormattingError, ReportedErrors, SourceFile};\n@@ -586,6 +586,24 @@ impl Input {\n             Input::Text(..) => FileName::Stdin,\n         }\n     }\n+\n+    fn to_directory_ownership(&self) -> Option<DirectoryOwnership> {\n+        match self {\n+            Input::File(ref file) => {\n+                // If there exists a directory with the same name as an input,\n+                // then the input should be parsed as a sub module.\n+                let file_stem = file.file_stem()?;\n+                if file.parent()?.to_path_buf().join(file_stem).is_dir() {\n+                    Some(DirectoryOwnership::Owned {\n+                        relative: file_stem.to_str().map(ast::Ident::from_str),\n+                    })\n+                } else {\n+                    None\n+                }\n+            }\n+            _ => None,\n+        }\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "01a0784c6f41c06061a023ca6331e7312392ce09", "filename": "src/modules.rs", "status": "modified", "additions": 147, "deletions": 82, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/92f57211c1ed9a27fcd86bf05ee9c930b1b4449a/src%2Fmodules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f57211c1ed9a27fcd86bf05ee9c930b1b4449a/src%2Fmodules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmodules.rs?ref=92f57211c1ed9a27fcd86bf05ee9c930b1b4449a", "patch": "@@ -1,5 +1,4 @@\n use std::collections::BTreeMap;\n-use std::io;\n use std::path::{Path, PathBuf};\n \n use syntax::ast;\n@@ -8,25 +7,157 @@ use syntax::source_map;\n use syntax_pos::symbol::Symbol;\n \n use crate::config::FileName;\n+use crate::items::is_mod_decl;\n use crate::utils::contains_skip;\n \n-/// List all the files containing modules of a crate.\n-/// If a file is used twice in a crate, it appears only once.\n-pub fn list_files<'a>(\n-    krate: &'a ast::Crate,\n-    source_map: &source_map::SourceMap,\n-) -> Result<BTreeMap<FileName, &'a ast::Mod>, io::Error> {\n-    let mut result = BTreeMap::new(); // Enforce file order determinism\n-    let root_filename = source_map.span_to_filename(krate.span);\n-    {\n-        let parent = match root_filename {\n-            source_map::FileName::Real(ref path) => path.parent().unwrap(),\n-            _ => Path::new(\"\"),\n+type FileModMap<'a> = BTreeMap<FileName, (&'a ast::Mod, &'a str)>;\n+\n+/// Maps each module to the corresponding file.\n+pub struct ModResolver<'a, 'b> {\n+    source_map: &'b source_map::SourceMap,\n+    directory: Directory,\n+    file_map: FileModMap<'a>,\n+    is_input_stdin: bool,\n+}\n+\n+#[derive(Clone)]\n+struct Directory {\n+    path: PathBuf,\n+    ownership: DirectoryOwnership,\n+}\n+\n+impl<'a, 'b> ModResolver<'a, 'b> {\n+    /// Creates a new `ModResolver`.\n+    pub fn new(\n+        source_map: &'b source_map::SourceMap,\n+        directory_ownership: DirectoryOwnership,\n+        is_input_stdin: bool,\n+    ) -> Self {\n+        ModResolver {\n+            directory: Directory {\n+                path: PathBuf::new(),\n+                ownership: directory_ownership,\n+            },\n+            file_map: BTreeMap::new(),\n+            source_map,\n+            is_input_stdin,\n+        }\n+    }\n+\n+    /// Creates a map that maps a file name to the module in AST.\n+    pub fn visit_crate(mut self, krate: &'a ast::Crate) -> Result<FileModMap<'a>, String> {\n+        let root_filename = self.source_map.span_to_filename(krate.span);\n+        self.directory.path = match root_filename {\n+            source_map::FileName::Real(ref path) => path\n+                .parent()\n+                .expect(\"Parent directory should exists\")\n+                .to_path_buf(),\n+            _ => PathBuf::new(),\n+        };\n+\n+        // Skip visiting sub modules when the input is from stdin.\n+        if !self.is_input_stdin {\n+            self.visit_mod(&krate.module)?;\n+        }\n+\n+        self.file_map\n+            .insert(root_filename.into(), (&krate.module, \"\"));\n+        Ok(self.file_map)\n+    }\n+\n+    fn visit_mod(&mut self, module: &'a ast::Mod) -> Result<(), String> {\n+        for item in &module.items {\n+            if let ast::ItemKind::Mod(ref sub_mod) = item.node {\n+                if contains_skip(&item.attrs) {\n+                    continue;\n+                }\n+\n+                let old_direcotry = self.directory.clone();\n+                if is_mod_decl(item) {\n+                    // mod foo;\n+                    // Look for an extern file.\n+                    let (mod_path, directory_ownership) =\n+                        self.find_external_module(item.ident, &item.attrs)?;\n+                    self.file_map.insert(\n+                        FileName::Real(mod_path.clone()),\n+                        (sub_mod, item.ident.name.as_str().get()),\n+                    );\n+                    self.directory = Directory {\n+                        path: mod_path.parent().unwrap().to_path_buf(),\n+                        ownership: directory_ownership,\n+                    }\n+                } else {\n+                    // An internal module (`mod foo { /* ... */ }`);\n+                    if let Some(path) = find_path_value(&item.attrs) {\n+                        // All `#[path]` files are treated as though they are a `mod.rs` file.\n+                        self.directory = Directory {\n+                            path: Path::new(&path.as_str()).to_path_buf(),\n+                            ownership: DirectoryOwnership::Owned { relative: None },\n+                        };\n+                    } else {\n+                        self.push_inline_mod_directory(item.ident, &item.attrs);\n+                    }\n+                }\n+                self.visit_mod(sub_mod)?;\n+                self.directory = old_direcotry;\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    fn find_external_module(\n+        &self,\n+        mod_name: ast::Ident,\n+        attrs: &[ast::Attribute],\n+    ) -> Result<(PathBuf, DirectoryOwnership), String> {\n+        if let Some(path) = parser::Parser::submod_path_from_attr(attrs, &self.directory.path) {\n+            return Ok((path, DirectoryOwnership::Owned { relative: None }));\n+        }\n+\n+        let relative = match self.directory.ownership {\n+            DirectoryOwnership::Owned { relative } => relative,\n+            DirectoryOwnership::UnownedViaBlock | DirectoryOwnership::UnownedViaMod(_) => None,\n         };\n-        list_submodules(&krate.module, parent, None, source_map, &mut result)?;\n+        match parser::Parser::default_submod_path(\n+            mod_name,\n+            relative,\n+            &self.directory.path,\n+            self.source_map,\n+        )\n+        .result\n+        {\n+            Ok(parser::ModulePathSuccess {\n+                path,\n+                directory_ownership,\n+                ..\n+            }) => Ok((path, directory_ownership)),\n+            Err(_) => Err(format!(\n+                \"Failed to find module {} in {:?} {:?}\",\n+                mod_name, self.directory.path, relative,\n+            )),\n+        }\n+    }\n+\n+    fn push_inline_mod_directory(&mut self, id: ast::Ident, attrs: &[ast::Attribute]) {\n+        if let Some(path) = find_path_value(attrs) {\n+            self.directory.path.push(&path.as_str());\n+            self.directory.ownership = DirectoryOwnership::Owned { relative: None };\n+        } else {\n+            // We have to push on the current module name in the case of relative\n+            // paths in order to ensure that any additional module paths from inline\n+            // `mod x { ... }` come after the relative extension.\n+            //\n+            // For example, a `mod z { ... }` inside `x/y.rs` should set the current\n+            // directory path to `/x/y/z`, not `/x/z` with a relative offset of `y`.\n+            if let DirectoryOwnership::Owned { relative } = &mut self.directory.ownership {\n+                if let Some(ident) = relative.take() {\n+                    // remove the relative offset\n+                    self.directory.path.push(ident.as_str());\n+                }\n+            }\n+            self.directory.path.push(&id.as_str());\n+        }\n     }\n-    result.insert(root_filename.into(), &krate.module);\n-    Ok(result)\n }\n \n fn path_value(attr: &ast::Attribute) -> Option<Symbol> {\n@@ -43,69 +174,3 @@ fn path_value(attr: &ast::Attribute) -> Option<Symbol> {\n fn find_path_value(attrs: &[ast::Attribute]) -> Option<Symbol> {\n     attrs.iter().flat_map(path_value).next()\n }\n-\n-/// Recursively list all external modules included in a module.\n-fn list_submodules<'a>(\n-    module: &'a ast::Mod,\n-    search_dir: &Path,\n-    relative: Option<ast::Ident>,\n-    source_map: &source_map::SourceMap,\n-    result: &mut BTreeMap<FileName, &'a ast::Mod>,\n-) -> Result<(), io::Error> {\n-    debug!(\"list_submodules: search_dir: {:?}\", search_dir);\n-    for item in &module.items {\n-        if let ast::ItemKind::Mod(ref sub_mod) = item.node {\n-            if !contains_skip(&item.attrs) {\n-                let is_internal = source_map.span_to_filename(item.span)\n-                    == source_map.span_to_filename(sub_mod.inner);\n-                let (dir_path, relative) = if is_internal {\n-                    if let Some(path) = find_path_value(&item.attrs) {\n-                        (search_dir.join(&path.as_str()), None)\n-                    } else {\n-                        (search_dir.join(&item.ident.to_string()), None)\n-                    }\n-                } else {\n-                    let (mod_path, relative) =\n-                        module_file(item.ident, &item.attrs, search_dir, relative, source_map)?;\n-                    let dir_path = mod_path.parent().unwrap().to_owned();\n-                    result.insert(FileName::Real(mod_path), sub_mod);\n-                    (dir_path, relative)\n-                };\n-                list_submodules(sub_mod, &dir_path, relative, source_map, result)?;\n-            }\n-        }\n-    }\n-    Ok(())\n-}\n-\n-/// Finds the file corresponding to an external mod\n-fn module_file(\n-    id: ast::Ident,\n-    attrs: &[ast::Attribute],\n-    dir_path: &Path,\n-    relative: Option<ast::Ident>,\n-    source_map: &source_map::SourceMap,\n-) -> Result<(PathBuf, Option<ast::Ident>), io::Error> {\n-    if let Some(path) = parser::Parser::submod_path_from_attr(attrs, dir_path) {\n-        return Ok((path, None));\n-    }\n-\n-    match parser::Parser::default_submod_path(id, relative, dir_path, source_map).result {\n-        Ok(parser::ModulePathSuccess {\n-            path,\n-            directory_ownership,\n-            ..\n-        }) => {\n-            let relative = if let DirectoryOwnership::Owned { relative } = directory_ownership {\n-                relative\n-            } else {\n-                None\n-            };\n-            Ok((path, relative))\n-        }\n-        Err(_) => Err(io::Error::new(\n-            io::ErrorKind::Other,\n-            format!(\"Couldn't find module {}\", id),\n-        )),\n-    }\n-}"}]}