{"sha": "7724d6773d3fe4ac1e57e4e13d67fedbf7cae0ba", "node_id": "C_kwDOAAsO6NoAKDc3MjRkNjc3M2QzZmU0YWMxZTU3ZTRlMTNkNjdmZWRiZjdjYWUwYmE", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-02-13T23:43:19Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-02-17T05:02:33Z"}, "message": "Move some cases from `redundant_slicing` to `deref_by_slicing`", "tree": {"sha": "812c538043f60f455d99809838be25dc7104da16", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/812c538043f60f455d99809838be25dc7104da16"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7724d6773d3fe4ac1e57e4e13d67fedbf7cae0ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7724d6773d3fe4ac1e57e4e13d67fedbf7cae0ba", "html_url": "https://github.com/rust-lang/rust/commit/7724d6773d3fe4ac1e57e4e13d67fedbf7cae0ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7724d6773d3fe4ac1e57e4e13d67fedbf7cae0ba/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "113ac6e15e16efb193985be9c5329a72d55df30b", "url": "https://api.github.com/repos/rust-lang/rust/commits/113ac6e15e16efb193985be9c5329a72d55df30b", "html_url": "https://github.com/rust-lang/rust/commit/113ac6e15e16efb193985be9c5329a72d55df30b"}], "stats": {"total": 133, "additions": 81, "deletions": 52}, "files": [{"sha": "25a9072ef6e0cf0a2ccd2eb395ec90d49c6cf3c0", "filename": "clippy_lints/src/redundant_slicing.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7724d6773d3fe4ac1e57e4e13d67fedbf7cae0ba/clippy_lints%2Fsrc%2Fredundant_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7724d6773d3fe4ac1e57e4e13d67fedbf7cae0ba/clippy_lints%2Fsrc%2Fredundant_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_slicing.rs?ref=7724d6773d3fe4ac1e57e4e13d67fedbf7cae0ba", "patch": "@@ -6,7 +6,7 @@ use if_chain::if_chain;\n use rustc_ast::util::parser::PREC_PREFIX;\n use rustc_errors::Applicability;\n use rustc_hir::{BorrowKind, Expr, ExprKind, LangItem, Mutability};\n-use rustc_lint::{LateContext, LateLintPass};\n+use rustc_lint::{LateContext, LateLintPass, Lint};\n use rustc_middle::ty::adjustment::{Adjust, AutoBorrow, AutoBorrowMutability};\n use rustc_middle::ty::subst::GenericArg;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -44,7 +44,7 @@ declare_clippy_lint! {\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// Checks for slicing expression which are equivalent to dereferencing the\n+    /// Checks for slicing expressions which are equivalent to dereferencing the\n     /// value.\n     ///\n     /// ### Why is this bad?\n@@ -68,6 +68,9 @@ declare_clippy_lint! {\n \n declare_lint_pass!(RedundantSlicing => [REDUNDANT_SLICING, DEREF_BY_SLICING]);\n \n+static REDUNDANT_SLICING_LINT: (&Lint, &str) = (REDUNDANT_SLICING, \"redundant slicing of the whole range\");\n+static DEREF_BY_SLICING_LINT: (&Lint, &str) = (DEREF_BY_SLICING, \"slicing when dereferencing would work\");\n+\n impl<'tcx> LateLintPass<'tcx> for RedundantSlicing {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if expr.span.from_expansion() {\n@@ -89,7 +92,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantSlicing {\n                 });\n                 let mut app = Applicability::MachineApplicable;\n \n-                let (lint, msg, help, sugg) = if expr_ty == indexed_ty {\n+                let ((lint, msg), help, sugg) = if expr_ty == indexed_ty {\n                     if expr_ref_count > indexed_ref_count {\n                         // Indexing takes self by reference and can't return a reference to that\n                         // reference as it's a local variable. The only way this could happen is if\n@@ -100,9 +103,9 @@ impl<'tcx> LateLintPass<'tcx> for RedundantSlicing {\n                     }\n                     let deref_count = indexed_ref_count - expr_ref_count;\n \n-                    let (reborrow_str, help_str) = if mutability == Mutability::Mut {\n+                    let (lint, reborrow_str, help_str) = if mutability == Mutability::Mut {\n                         // The slice was used to reborrow the mutable reference.\n-                        (\"&mut *\", \"reborrow the original value instead\")\n+                        (DEREF_BY_SLICING_LINT, \"&mut *\", \"reborrow the original value instead\")\n                     } else if matches!(\n                         parent_expr,\n                         Some(Expr {\n@@ -113,11 +116,11 @@ impl<'tcx> LateLintPass<'tcx> for RedundantSlicing {\n                         matches!(a.kind, Adjust::Borrow(AutoBorrow::Ref(_, AutoBorrowMutability::Mut { .. })))\n                     }) {\n                         // The slice was used to make a temporary reference.\n-                        (\"&*\", \"reborrow the original value instead\")\n+                        (DEREF_BY_SLICING_LINT, \"&*\", \"reborrow the original value instead\")\n                     } else if deref_count != 0 {\n-                        (\"\", \"dereference the original value instead\")\n+                        (DEREF_BY_SLICING_LINT, \"\", \"dereference the original value instead\")\n                     } else {\n-                        (\"\", \"use the original value instead\")\n+                        (REDUNDANT_SLICING_LINT, \"\", \"use the original value instead\")\n                     };\n \n                     let snip = snippet_with_context(cx, indexed.span, ctxt, \"..\", &mut app).0;\n@@ -127,7 +130,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantSlicing {\n                         format!(\"{}{}{}\", reborrow_str, \"*\".repeat(deref_count), snip)\n                     };\n \n-                    (REDUNDANT_SLICING, \"redundant slicing of the whole range\", help_str, sugg)\n+                    (lint, help_str, sugg)\n                 } else if let Some(target_id) = cx.tcx.lang_items().deref_target() {\n                     if let Ok(deref_ty) = cx.tcx.try_normalize_erasing_regions(\n                         cx.param_env,\n@@ -140,7 +143,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantSlicing {\n                             } else {\n                                 format!(\"&{}{}*{}\", mutability.prefix_str(), \"*\".repeat(indexed_ref_count), snip)\n                             };\n-                            (DEREF_BY_SLICING, \"slicing when dereferencing would work\", \"dereference the original value instead\", sugg)\n+                            (DEREF_BY_SLICING_LINT, \"dereference the original value instead\", sugg)\n                         } else {\n                             return;\n                         }"}, {"sha": "b26276218b78c7e0c110cb4c1831689a27372afb", "filename": "tests/ui/deref_by_slicing.fixed", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7724d6773d3fe4ac1e57e4e13d67fedbf7cae0ba/tests%2Fui%2Fderef_by_slicing.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7724d6773d3fe4ac1e57e4e13d67fedbf7cae0ba/tests%2Fui%2Fderef_by_slicing.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderef_by_slicing.fixed?ref=7724d6773d3fe4ac1e57e4e13d67fedbf7cae0ba", "patch": "@@ -2,15 +2,28 @@\n \n #![warn(clippy::deref_by_slicing)]\n \n+use std::io::Read;\n+\n fn main() {\n     let mut vec = vec![0];\n     let _ = &*vec;\n     let _ = &mut *vec;\n \n     let ref_vec = &mut vec;\n     let _ = &**ref_vec;\n-    let _ = &mut **ref_vec;\n+    let mut_slice = &mut **ref_vec;\n+    let _ = &mut *mut_slice; // Err, re-borrows slice\n \n     let s = String::new();\n     let _ = &*s;\n+\n+    static S: &[u8] = &[0, 1, 2];\n+    let _ = &mut &*S; // Err, re-borrows slice\n+\n+    let slice: &[u32] = &[0u32, 1u32];\n+    let slice_ref = &slice;\n+    let _ = *slice_ref; // Err, derefs slice\n+\n+    let bytes: &[u8] = &[];\n+    let _ = (&*bytes).read_to_end(&mut vec![]).unwrap(); // Err, re-borrows slice\n }"}, {"sha": "6aa1408ba17698854ad1f9bcf361694b6aa5343e", "filename": "tests/ui/deref_by_slicing.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7724d6773d3fe4ac1e57e4e13d67fedbf7cae0ba/tests%2Fui%2Fderef_by_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7724d6773d3fe4ac1e57e4e13d67fedbf7cae0ba/tests%2Fui%2Fderef_by_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderef_by_slicing.rs?ref=7724d6773d3fe4ac1e57e4e13d67fedbf7cae0ba", "patch": "@@ -2,15 +2,28 @@\n \n #![warn(clippy::deref_by_slicing)]\n \n+use std::io::Read;\n+\n fn main() {\n     let mut vec = vec![0];\n     let _ = &vec[..];\n     let _ = &mut vec[..];\n \n     let ref_vec = &mut vec;\n     let _ = &ref_vec[..];\n-    let _ = &mut ref_vec[..];\n+    let mut_slice = &mut ref_vec[..];\n+    let _ = &mut mut_slice[..]; // Err, re-borrows slice\n \n     let s = String::new();\n     let _ = &s[..];\n+\n+    static S: &[u8] = &[0, 1, 2];\n+    let _ = &mut &S[..]; // Err, re-borrows slice\n+\n+    let slice: &[u32] = &[0u32, 1u32];\n+    let slice_ref = &slice;\n+    let _ = &slice_ref[..]; // Err, derefs slice\n+\n+    let bytes: &[u8] = &[];\n+    let _ = (&bytes[..]).read_to_end(&mut vec![]).unwrap(); // Err, re-borrows slice\n }"}, {"sha": "ffd76de378df1d314b7d95fa04cf96f6efaac800", "filename": "tests/ui/deref_by_slicing.stderr", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7724d6773d3fe4ac1e57e4e13d67fedbf7cae0ba/tests%2Fui%2Fderef_by_slicing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7724d6773d3fe4ac1e57e4e13d67fedbf7cae0ba/tests%2Fui%2Fderef_by_slicing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderef_by_slicing.stderr?ref=7724d6773d3fe4ac1e57e4e13d67fedbf7cae0ba", "patch": "@@ -1,34 +1,58 @@\n error: slicing when dereferencing would work\n-  --> $DIR/deref_by_slicing.rs:7:13\n+  --> $DIR/deref_by_slicing.rs:9:13\n    |\n LL |     let _ = &vec[..];\n    |             ^^^^^^^^ help: dereference the original value instead: `&*vec`\n    |\n    = note: `-D clippy::deref-by-slicing` implied by `-D warnings`\n \n error: slicing when dereferencing would work\n-  --> $DIR/deref_by_slicing.rs:8:13\n+  --> $DIR/deref_by_slicing.rs:10:13\n    |\n LL |     let _ = &mut vec[..];\n    |             ^^^^^^^^^^^^ help: dereference the original value instead: `&mut *vec`\n \n error: slicing when dereferencing would work\n-  --> $DIR/deref_by_slicing.rs:11:13\n+  --> $DIR/deref_by_slicing.rs:13:13\n    |\n LL |     let _ = &ref_vec[..];\n    |             ^^^^^^^^^^^^ help: dereference the original value instead: `&**ref_vec`\n \n error: slicing when dereferencing would work\n-  --> $DIR/deref_by_slicing.rs:12:13\n+  --> $DIR/deref_by_slicing.rs:14:21\n    |\n-LL |     let _ = &mut ref_vec[..];\n-   |             ^^^^^^^^^^^^^^^^ help: dereference the original value instead: `&mut **ref_vec`\n+LL |     let mut_slice = &mut ref_vec[..];\n+   |                     ^^^^^^^^^^^^^^^^ help: dereference the original value instead: `&mut **ref_vec`\n \n error: slicing when dereferencing would work\n   --> $DIR/deref_by_slicing.rs:15:13\n    |\n+LL |     let _ = &mut mut_slice[..]; // Err, re-borrows slice\n+   |             ^^^^^^^^^^^^^^^^^^ help: reborrow the original value instead: `&mut *mut_slice`\n+\n+error: slicing when dereferencing would work\n+  --> $DIR/deref_by_slicing.rs:18:13\n+   |\n LL |     let _ = &s[..];\n    |             ^^^^^^ help: dereference the original value instead: `&*s`\n \n-error: aborting due to 5 previous errors\n+error: slicing when dereferencing would work\n+  --> $DIR/deref_by_slicing.rs:21:18\n+   |\n+LL |     let _ = &mut &S[..]; // Err, re-borrows slice\n+   |                  ^^^^^^ help: reborrow the original value instead: `&*S`\n+\n+error: slicing when dereferencing would work\n+  --> $DIR/deref_by_slicing.rs:25:13\n+   |\n+LL |     let _ = &slice_ref[..]; // Err, derefs slice\n+   |             ^^^^^^^^^^^^^^ help: dereference the original value instead: `*slice_ref`\n+\n+error: slicing when dereferencing would work\n+  --> $DIR/deref_by_slicing.rs:28:13\n+   |\n+LL |     let _ = (&bytes[..]).read_to_end(&mut vec![]).unwrap(); // Err, re-borrows slice\n+   |             ^^^^^^^^^^^^ help: reborrow the original value instead: `(&*bytes)`\n+\n+error: aborting due to 9 previous errors\n "}, {"sha": "8dd8d3092378e1dd225e7c8171f345e91b354498", "filename": "tests/ui/redundant_slicing.fixed", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7724d6773d3fe4ac1e57e4e13d67fedbf7cae0ba/tests%2Fui%2Fredundant_slicing.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7724d6773d3fe4ac1e57e4e13d67fedbf7cae0ba/tests%2Fui%2Fredundant_slicing.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_slicing.fixed?ref=7724d6773d3fe4ac1e57e4e13d67fedbf7cae0ba", "patch": "@@ -14,11 +14,11 @@ fn main() {\n     let _ = (&*v); // Outer borrow is redundant\n \n     static S: &[u8] = &[0, 1, 2];\n-    let err = &mut &*S; // Should reborrow instead of slice\n+    let _ = &mut &S[..]; // Ok, re-borrows slice\n \n     let mut vec = vec![0];\n     let mut_slice = &mut vec[..]; // Ok, results in `&mut [_]`\n-    let _ = &mut *mut_slice; // Should reborrow instead of slice\n+    let _ = &mut mut_slice[..]; // Ok, re-borrows slice\n \n     let ref_vec = &vec;\n     let _ = &ref_vec[..]; // Ok, results in `&[_]`\n@@ -38,9 +38,9 @@ fn main() {\n     let _ = m2!(slice); // Don't lint in a macro\n \n     let slice_ref = &slice;\n-    let _ = *slice_ref; // Deref instead of slice\n+    let _ = &slice_ref[..]; // Ok, derefs slice\n \n     // Issue #7972\n     let bytes: &[u8] = &[];\n-    let _ = (&*bytes).read_to_end(&mut vec![]).unwrap();\n+    let _ = (&bytes[..]).read_to_end(&mut vec![]).unwrap(); // Ok, re-borrows slice\n }"}, {"sha": "51c16dd8d65a2b67fb33256d564259193790dafd", "filename": "tests/ui/redundant_slicing.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7724d6773d3fe4ac1e57e4e13d67fedbf7cae0ba/tests%2Fui%2Fredundant_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7724d6773d3fe4ac1e57e4e13d67fedbf7cae0ba/tests%2Fui%2Fredundant_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_slicing.rs?ref=7724d6773d3fe4ac1e57e4e13d67fedbf7cae0ba", "patch": "@@ -14,11 +14,11 @@ fn main() {\n     let _ = &(&*v)[..]; // Outer borrow is redundant\n \n     static S: &[u8] = &[0, 1, 2];\n-    let err = &mut &S[..]; // Should reborrow instead of slice\n+    let _ = &mut &S[..]; // Ok, re-borrows slice\n \n     let mut vec = vec![0];\n     let mut_slice = &mut vec[..]; // Ok, results in `&mut [_]`\n-    let _ = &mut mut_slice[..]; // Should reborrow instead of slice\n+    let _ = &mut mut_slice[..]; // Ok, re-borrows slice\n \n     let ref_vec = &vec;\n     let _ = &ref_vec[..]; // Ok, results in `&[_]`\n@@ -38,9 +38,9 @@ fn main() {\n     let _ = m2!(slice); // Don't lint in a macro\n \n     let slice_ref = &slice;\n-    let _ = &slice_ref[..]; // Deref instead of slice\n+    let _ = &slice_ref[..]; // Ok, derefs slice\n \n     // Issue #7972\n     let bytes: &[u8] = &[];\n-    let _ = (&bytes[..]).read_to_end(&mut vec![]).unwrap();\n+    let _ = (&bytes[..]).read_to_end(&mut vec![]).unwrap(); // Ok, re-borrows slice\n }"}, {"sha": "82367143c07fa40f395768d038a734e0bfeaa619", "filename": "tests/ui/redundant_slicing.stderr", "status": "modified", "additions": 1, "deletions": 25, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7724d6773d3fe4ac1e57e4e13d67fedbf7cae0ba/tests%2Fui%2Fredundant_slicing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7724d6773d3fe4ac1e57e4e13d67fedbf7cae0ba/tests%2Fui%2Fredundant_slicing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_slicing.stderr?ref=7724d6773d3fe4ac1e57e4e13d67fedbf7cae0ba", "patch": "@@ -12,35 +12,11 @@ error: redundant slicing of the whole range\n LL |     let _ = &(&*v)[..]; // Outer borrow is redundant\n    |             ^^^^^^^^^^ help: use the original value instead: `(&*v)`\n \n-error: redundant slicing of the whole range\n-  --> $DIR/redundant_slicing.rs:17:20\n-   |\n-LL |     let err = &mut &S[..]; // Should reborrow instead of slice\n-   |                    ^^^^^^ help: reborrow the original value instead: `&*S`\n-\n-error: redundant slicing of the whole range\n-  --> $DIR/redundant_slicing.rs:21:13\n-   |\n-LL |     let _ = &mut mut_slice[..]; // Should reborrow instead of slice\n-   |             ^^^^^^^^^^^^^^^^^^ help: reborrow the original value instead: `&mut *mut_slice`\n-\n error: redundant slicing of the whole range\n   --> $DIR/redundant_slicing.rs:31:13\n    |\n LL |     let _ = &m!(slice)[..];\n    |             ^^^^^^^^^^^^^^ help: use the original value instead: `slice`\n \n-error: redundant slicing of the whole range\n-  --> $DIR/redundant_slicing.rs:41:13\n-   |\n-LL |     let _ = &slice_ref[..]; // Deref instead of slice\n-   |             ^^^^^^^^^^^^^^ help: dereference the original value instead: `*slice_ref`\n-\n-error: redundant slicing of the whole range\n-  --> $DIR/redundant_slicing.rs:45:13\n-   |\n-LL |     let _ = (&bytes[..]).read_to_end(&mut vec![]).unwrap();\n-   |             ^^^^^^^^^^^^ help: reborrow the original value instead: `(&*bytes)`\n-\n-error: aborting due to 7 previous errors\n+error: aborting due to 3 previous errors\n "}]}