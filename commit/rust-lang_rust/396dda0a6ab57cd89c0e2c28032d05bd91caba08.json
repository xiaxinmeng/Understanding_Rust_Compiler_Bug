{"sha": "396dda0a6ab57cd89c0e2c28032d05bd91caba08", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5NmRkYTBhNmFiNTdjZDg5YzBlMmMyODAzMmQwNWJkOTFjYWJhMDg=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-08-04T15:09:12Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-08-04T15:09:12Z"}, "message": "Rollup merge of #53062 - ljedrz:redundant_field_names, r=Mark-Simulacrum\n\nRemove redundant field names in structs", "tree": {"sha": "ec0774a68324a0b81cc699137de200d8fb1c296d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec0774a68324a0b81cc699137de200d8fb1c296d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/396dda0a6ab57cd89c0e2c28032d05bd91caba08", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZ1R8CLMp8f2GxWoQ/vbIBR0OATwFAltlwZkACgkQ/vbIBR0O\nATyF7RAAlO7ttYx+s2irAZ42BPZdVFq9PYkcOjTiWNVjM47G0zWpKxCW9MHJcIEB\njXad3FMasOQg8b7iYLs3WHwxN20p+orgKbFWDjhU+dbKvvd8Fs45xWiK4D8qXvC1\nuJOe+t+PnAr7qRmELJThZiAYcImqmPWulK48hOo2wWEGBS9BSIBoRMuciawzElgi\nnpCrB2+mEUTXkbthEaBwpf1MkNbNqVrH6R+CnxO9t7TDg0Ie7gWajEp6Ysm5aK3/\nOQ/QCpn5YX08DcJV51O2lgbvKRBlnHKAjdy6e+ZwjeBqNpK/XRUt0Cz54rnqF+67\nfnC9aWJFiVdq0Fp+nf0gpH9pijvxv2LNNskZj9aFGYIYlb4r9QgPc3qacDI07mp8\nPXkxNszDau85xdpbrvi8x0CnCD0xvm9MHp5gvk6L9e6mTIl+uWwLw/3uPa5EWm6q\n3x4LVUFQTHwExZQDsWoncEzFuKCMibkZ3LwdPcUyWCtwsUIc9QJC3SsyJHy80WZZ\n1X26T7Uc17MIPnX0mHFau7/6vIm0R4k+Ry6tnm83OXKQYxSwMovDDrOHBfqHySQj\noIWF1gTzsAtaY/BeCVPoIYWbZGchMcAWOTTPC7TMFaUWCG1tN+Pyw4v/onwFY2iP\nnjoNUfBXloM4JjUE+SI5acD54hrZpHtmqPVFODdr7O6sNXl2imQ=\n=hUOz\n-----END PGP SIGNATURE-----", "payload": "tree ec0774a68324a0b81cc699137de200d8fb1c296d\nparent b643351c081fdab7934bb801ba372844be73974f\nparent d46dca66c9c18477ddebe87edb6b8f0f8ca22aa3\nauthor kennytm <kennytm@gmail.com> 1533395352 +0800\ncommitter kennytm <kennytm@gmail.com> 1533395352 +0800\n\nRollup merge of #53062 - ljedrz:redundant_field_names, r=Mark-Simulacrum\n\nRemove redundant field names in structs\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/396dda0a6ab57cd89c0e2c28032d05bd91caba08", "html_url": "https://github.com/rust-lang/rust/commit/396dda0a6ab57cd89c0e2c28032d05bd91caba08", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/396dda0a6ab57cd89c0e2c28032d05bd91caba08/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b643351c081fdab7934bb801ba372844be73974f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b643351c081fdab7934bb801ba372844be73974f", "html_url": "https://github.com/rust-lang/rust/commit/b643351c081fdab7934bb801ba372844be73974f"}, {"sha": "d46dca66c9c18477ddebe87edb6b8f0f8ca22aa3", "url": "https://api.github.com/repos/rust-lang/rust/commits/d46dca66c9c18477ddebe87edb6b8f0f8ca22aa3", "html_url": "https://github.com/rust-lang/rust/commit/d46dca66c9c18477ddebe87edb6b8f0f8ca22aa3"}], "stats": {"total": 100, "additions": 50, "deletions": 50}, "files": [{"sha": "009aba5f59869d0c01500a5f485fc633028c73e4", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/396dda0a6ab57cd89c0e2c28032d05bd91caba08/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/396dda0a6ab57cd89c0e2c28032d05bd91caba08/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=396dda0a6ab57cd89c0e2c28032d05bd91caba08", "patch": "@@ -1258,7 +1258,7 @@ impl<'b, T: ?Sized> RefMut<'b, T> {\n         let RefMut { value, borrow } = orig;\n         RefMut {\n             value: f(value),\n-            borrow: borrow,\n+            borrow,\n         }\n     }\n \n@@ -1324,7 +1324,7 @@ impl<'b> BorrowRefMut<'b> {\n         match borrow.get() {\n             UNUSED => {\n                 borrow.set(UNUSED - 1);\n-                Some(BorrowRefMut { borrow: borrow })\n+                Some(BorrowRefMut { borrow })\n             },\n             _ => None,\n         }\n@@ -1467,7 +1467,7 @@ impl<T> UnsafeCell<T> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub const fn new(value: T) -> UnsafeCell<T> {\n-        UnsafeCell { value: value }\n+        UnsafeCell { value }\n     }\n \n     /// Unwraps the value."}, {"sha": "5681cfb04f2088c1fece1a7ede7c9d835b3eb0b5", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/396dda0a6ab57cd89c0e2c28032d05bd91caba08/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/396dda0a6ab57cd89c0e2c28032d05bd91caba08/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=396dda0a6ab57cd89c0e2c28032d05bd91caba08", "patch": "@@ -507,7 +507,7 @@ pub trait Iterator {\n     fn map<B, F>(self, f: F) -> Map<Self, F> where\n         Self: Sized, F: FnMut(Self::Item) -> B,\n     {\n-        Map{iter: self, f: f}\n+        Map { iter: self, f }\n     }\n \n     /// Calls a closure on each element of an iterator.\n@@ -618,7 +618,7 @@ pub trait Iterator {\n     fn filter<P>(self, predicate: P) -> Filter<Self, P> where\n         Self: Sized, P: FnMut(&Self::Item) -> bool,\n     {\n-        Filter{iter: self, predicate: predicate}\n+        Filter {iter: self, predicate }\n     }\n \n     /// Creates an iterator that both filters and maps.\n@@ -675,7 +675,7 @@ pub trait Iterator {\n     fn filter_map<B, F>(self, f: F) -> FilterMap<Self, F> where\n         Self: Sized, F: FnMut(Self::Item) -> Option<B>,\n     {\n-        FilterMap { iter: self, f: f }\n+        FilterMap { iter: self, f }\n     }\n \n     /// Creates an iterator which gives the current iteration count as well as\n@@ -828,7 +828,7 @@ pub trait Iterator {\n     fn skip_while<P>(self, predicate: P) -> SkipWhile<Self, P> where\n         Self: Sized, P: FnMut(&Self::Item) -> bool,\n     {\n-        SkipWhile{iter: self, flag: false, predicate: predicate}\n+        SkipWhile { iter: self, flag: false, predicate }\n     }\n \n     /// Creates an iterator that yields elements based on a predicate.\n@@ -908,7 +908,7 @@ pub trait Iterator {\n     fn take_while<P>(self, predicate: P) -> TakeWhile<Self, P> where\n         Self: Sized, P: FnMut(&Self::Item) -> bool,\n     {\n-        TakeWhile{iter: self, flag: false, predicate: predicate}\n+        TakeWhile { iter: self, flag: false, predicate }\n     }\n \n     /// Creates an iterator that skips the first `n` elements.\n@@ -930,7 +930,7 @@ pub trait Iterator {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn skip(self, n: usize) -> Skip<Self> where Self: Sized {\n-        Skip{iter: self, n: n}\n+        Skip { iter: self, n }\n     }\n \n     /// Creates an iterator that yields its first `n` elements.\n@@ -962,7 +962,7 @@ pub trait Iterator {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn take(self, n: usize) -> Take<Self> where Self: Sized, {\n-        Take{iter: self, n: n}\n+        Take { iter: self, n }\n     }\n \n     /// An iterator adaptor similar to [`fold`] that holds internal state and\n@@ -1007,7 +1007,7 @@ pub trait Iterator {\n     fn scan<St, B, F>(self, initial_state: St, f: F) -> Scan<Self, St, F>\n         where Self: Sized, F: FnMut(&mut St, Self::Item) -> Option<B>,\n     {\n-        Scan{iter: self, f: f, state: initial_state}\n+        Scan { iter: self, f, state: initial_state }\n     }\n \n     /// Creates an iterator that works like map, but flattens nested structure.\n@@ -1256,7 +1256,7 @@ pub trait Iterator {\n     fn inspect<F>(self, f: F) -> Inspect<Self, F> where\n         Self: Sized, F: FnMut(&Self::Item),\n     {\n-        Inspect{iter: self, f: f}\n+        Inspect { iter: self, f }\n     }\n \n     /// Borrows an iterator, rather than consuming it."}, {"sha": "e7ed94d4d91c2a0646dc7545849108bc4ae36582", "filename": "src/libcore/num/dec2flt/parse.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/396dda0a6ab57cd89c0e2c28032d05bd91caba08/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/396dda0a6ab57cd89c0e2c28032d05bd91caba08/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs?ref=396dda0a6ab57cd89c0e2c28032d05bd91caba08", "patch": "@@ -40,7 +40,7 @@ pub struct Decimal<'a> {\n \n impl<'a> Decimal<'a> {\n     pub fn new(integral: &'a [u8], fractional: &'a [u8], exp: i64) -> Decimal<'a> {\n-        Decimal { integral: integral, fractional: fractional, exp: exp }\n+        Decimal { integral, fractional, exp }\n     }\n }\n "}, {"sha": "38f4e4687a99b6358b946eb7ced49fd7796bcb2e", "filename": "src/libcore/num/dec2flt/rawfp.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/396dda0a6ab57cd89c0e2c28032d05bd91caba08/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/396dda0a6ab57cd89c0e2c28032d05bd91caba08/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs?ref=396dda0a6ab57cd89c0e2c28032d05bd91caba08", "patch": "@@ -45,7 +45,7 @@ pub struct Unpacked {\n \n impl Unpacked {\n     pub fn new(sig: u64, k: i16) -> Self {\n-        Unpacked { sig: sig, k: k }\n+        Unpacked { sig, k }\n     }\n }\n \n@@ -317,13 +317,13 @@ pub fn big_to_fp(f: &Big) -> Fp {\n     // We cut off all bits prior to the index `start`, i.e., we effectively right-shift by\n     // an amount of `start`, so this is also the exponent we need.\n     let e = start as i16;\n-    let rounded_down = Fp { f: leading, e: e }.normalize();\n+    let rounded_down = Fp { f: leading, e }.normalize();\n     // Round (half-to-even) depending on the truncated bits.\n     match num::compare_with_half_ulp(f, start) {\n         Less => rounded_down,\n         Equal if leading % 2 == 0 => rounded_down,\n         Equal | Greater => match leading.checked_add(1) {\n-            Some(f) => Fp { f: f, e: e }.normalize(),\n+            Some(f) => Fp { f, e }.normalize(),\n             None => Fp { f: 1 << 63, e: e + 1 },\n         }\n     }"}, {"sha": "b0561da5934c0be5fa06e8dd0b9ec7da27ab04da", "filename": "src/libcore/num/diy_float.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/396dda0a6ab57cd89c0e2c28032d05bd91caba08/src%2Flibcore%2Fnum%2Fdiy_float.rs", "raw_url": "https://github.com/rust-lang/rust/raw/396dda0a6ab57cd89c0e2c28032d05bd91caba08/src%2Flibcore%2Fnum%2Fdiy_float.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdiy_float.rs?ref=396dda0a6ab57cd89c0e2c28032d05bd91caba08", "patch": "@@ -42,7 +42,7 @@ impl Fp {\n         let tmp = (bd >> 32) + (ad & MASK) + (bc & MASK) + (1 << 31) /* round */;\n         let f = ac + (ad >> 32) + (bc >> 32) + (tmp >> 32);\n         let e = self.e + other.e + 64;\n-        Fp { f: f, e: e }\n+        Fp { f, e }\n     }\n \n     /// Normalizes itself so that the resulting mantissa is at least `2^63`.\n@@ -74,7 +74,7 @@ impl Fp {\n             e -= 1;\n         }\n         debug_assert!(f >= (1 >> 63));\n-        Fp { f: f, e: e }\n+        Fp { f, e }\n     }\n \n     /// Normalizes itself to have the shared exponent."}, {"sha": "c34a56f288fd44c3555f6dabf3fe18e99a641306", "filename": "src/libcore/num/flt2dec/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/396dda0a6ab57cd89c0e2c28032d05bd91caba08/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/396dda0a6ab57cd89c0e2c28032d05bd91caba08/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs?ref=396dda0a6ab57cd89c0e2c28032d05bd91caba08", "patch": "@@ -77,8 +77,8 @@ pub fn decode<T: DecodableFloat>(v: T) -> (/*negative?*/ bool, FullDecoded) {\n             // neighbors: (mant - 2, exp) -- (mant, exp) -- (mant + 2, exp)\n             // Float::integer_decode always preserves the exponent,\n             // so the mantissa is scaled for subnormals.\n-            FullDecoded::Finite(Decoded { mant: mant, minus: 1, plus: 1,\n-                                          exp: exp, inclusive: even })\n+            FullDecoded::Finite(Decoded { mant, minus: 1, plus: 1,\n+                                          exp, inclusive: even })\n         }\n         FpCategory::Normal => {\n             let minnorm = <T as DecodableFloat>::min_pos_norm_value().integer_decode();"}, {"sha": "21a2e72dac8c37f7411b18841087689a37bc1b24", "filename": "src/libcore/num/flt2dec/mod.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/396dda0a6ab57cd89c0e2c28032d05bd91caba08/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/396dda0a6ab57cd89c0e2c28032d05bd91caba08/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs?ref=396dda0a6ab57cd89c0e2c28032d05bd91caba08", "patch": "@@ -424,20 +424,20 @@ pub fn to_shortest_str<'a, T, F>(mut format_shortest: F, v: T,\n     match full_decoded {\n         FullDecoded::Nan => {\n             parts[0] = Part::Copy(b\"NaN\");\n-            Formatted { sign: sign, parts: &parts[..1] }\n+            Formatted { sign, parts: &parts[..1] }\n         }\n         FullDecoded::Infinite => {\n             parts[0] = Part::Copy(b\"inf\");\n-            Formatted { sign: sign, parts: &parts[..1] }\n+            Formatted { sign, parts: &parts[..1] }\n         }\n         FullDecoded::Zero => {\n             if frac_digits > 0 { // [0.][0000]\n                 parts[0] = Part::Copy(b\"0.\");\n                 parts[1] = Part::Zero(frac_digits);\n-                Formatted { sign: sign, parts: &parts[..2] }\n+                Formatted { sign, parts: &parts[..2] }\n             } else {\n                 parts[0] = Part::Copy(b\"0\");\n-                Formatted { sign: sign, parts: &parts[..1] }\n+                Formatted { sign, parts: &parts[..1] }\n             }\n         }\n         FullDecoded::Finite(ref decoded) => {\n@@ -480,19 +480,19 @@ pub fn to_shortest_exp_str<'a, T, F>(mut format_shortest: F, v: T,\n     match full_decoded {\n         FullDecoded::Nan => {\n             parts[0] = Part::Copy(b\"NaN\");\n-            Formatted { sign: sign, parts: &parts[..1] }\n+            Formatted { sign, parts: &parts[..1] }\n         }\n         FullDecoded::Infinite => {\n             parts[0] = Part::Copy(b\"inf\");\n-            Formatted { sign: sign, parts: &parts[..1] }\n+            Formatted { sign, parts: &parts[..1] }\n         }\n         FullDecoded::Zero => {\n             parts[0] = if dec_bounds.0 <= 0 && 0 < dec_bounds.1 {\n                 Part::Copy(b\"0\")\n             } else {\n                 Part::Copy(if upper { b\"0E0\" } else { b\"0e0\" })\n             };\n-            Formatted { sign: sign, parts: &parts[..1] }\n+            Formatted { sign, parts: &parts[..1] }\n         }\n         FullDecoded::Finite(ref decoded) => {\n             let (len, exp) = format_shortest(decoded, buf);\n@@ -502,7 +502,7 @@ pub fn to_shortest_exp_str<'a, T, F>(mut format_shortest: F, v: T,\n             } else {\n                 digits_to_exp_str(&buf[..len], exp, 0, upper, parts)\n             };\n-            Formatted { sign: sign, parts: parts }\n+            Formatted { sign, parts }\n         }\n     }\n }\n@@ -558,21 +558,21 @@ pub fn to_exact_exp_str<'a, T, F>(mut format_exact: F, v: T,\n     match full_decoded {\n         FullDecoded::Nan => {\n             parts[0] = Part::Copy(b\"NaN\");\n-            Formatted { sign: sign, parts: &parts[..1] }\n+            Formatted { sign, parts: &parts[..1] }\n         }\n         FullDecoded::Infinite => {\n             parts[0] = Part::Copy(b\"inf\");\n-            Formatted { sign: sign, parts: &parts[..1] }\n+            Formatted { sign, parts: &parts[..1] }\n         }\n         FullDecoded::Zero => {\n             if ndigits > 1 { // [0.][0000][e0]\n                 parts[0] = Part::Copy(b\"0.\");\n                 parts[1] = Part::Zero(ndigits - 1);\n                 parts[2] = Part::Copy(if upper { b\"E0\" } else { b\"e0\" });\n-                Formatted { sign: sign, parts: &parts[..3] }\n+                Formatted { sign, parts: &parts[..3] }\n             } else {\n                 parts[0] = Part::Copy(if upper { b\"0E0\" } else { b\"0e0\" });\n-                Formatted { sign: sign, parts: &parts[..1] }\n+                Formatted { sign, parts: &parts[..1] }\n             }\n         }\n         FullDecoded::Finite(ref decoded) => {\n@@ -613,20 +613,20 @@ pub fn to_exact_fixed_str<'a, T, F>(mut format_exact: F, v: T,\n     match full_decoded {\n         FullDecoded::Nan => {\n             parts[0] = Part::Copy(b\"NaN\");\n-            Formatted { sign: sign, parts: &parts[..1] }\n+            Formatted { sign, parts: &parts[..1] }\n         }\n         FullDecoded::Infinite => {\n             parts[0] = Part::Copy(b\"inf\");\n-            Formatted { sign: sign, parts: &parts[..1] }\n+            Formatted { sign, parts: &parts[..1] }\n         }\n         FullDecoded::Zero => {\n             if frac_digits > 0 { // [0.][0000]\n                 parts[0] = Part::Copy(b\"0.\");\n                 parts[1] = Part::Zero(frac_digits);\n-                Formatted { sign: sign, parts: &parts[..2] }\n+                Formatted { sign, parts: &parts[..2] }\n             } else {\n                 parts[0] = Part::Copy(b\"0\");\n-                Formatted { sign: sign, parts: &parts[..1] }\n+                Formatted { sign, parts: &parts[..1] }\n             }\n         }\n         FullDecoded::Finite(ref decoded) => {\n@@ -646,10 +646,10 @@ pub fn to_exact_fixed_str<'a, T, F>(mut format_exact: F, v: T,\n                 if frac_digits > 0 { // [0.][0000]\n                     parts[0] = Part::Copy(b\"0.\");\n                     parts[1] = Part::Zero(frac_digits);\n-                    Formatted { sign: sign, parts: &parts[..2] }\n+                    Formatted { sign, parts: &parts[..2] }\n                 } else {\n                     parts[0] = Part::Copy(b\"0\");\n-                    Formatted { sign: sign, parts: &parts[..1] }\n+                    Formatted { sign, parts: &parts[..1] }\n                 }\n             } else {\n                 Formatted { sign,"}, {"sha": "effe073c3816c4936eabadc58944a62679c34f7f", "filename": "src/libcore/num/flt2dec/strategy/grisu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/396dda0a6ab57cd89c0e2c28032d05bd91caba08/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/396dda0a6ab57cd89c0e2c28032d05bd91caba08/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs?ref=396dda0a6ab57cd89c0e2c28032d05bd91caba08", "patch": "@@ -129,7 +129,7 @@ pub fn cached_power(alpha: i16, gamma: i16) -> (i16, Fp) {\n     let idx = ((gamma as i32) - offset) * range / domain;\n     let (f, e, k) = CACHED_POW10[idx as usize];\n     debug_assert!(alpha <= e && e <= gamma);\n-    (k, Fp { f: f, e: e })\n+    (k, Fp { f, e })\n }\n \n /// Given `x > 0`, returns `(k, 10^k)` such that `10^k <= x < 10^(k+1)`."}, {"sha": "dfebe460ff80150eb1f44e1075f723d18e6fb9ce", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/396dda0a6ab57cd89c0e2c28032d05bd91caba08/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/396dda0a6ab57cd89c0e2c28032d05bd91caba08/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=396dda0a6ab57cd89c0e2c28032d05bd91caba08", "patch": "@@ -621,7 +621,7 @@ impl<T> [T] {\n     #[inline]\n     pub fn windows(&self, size: usize) -> Windows<T> {\n         assert!(size != 0);\n-        Windows { v: self, size: size }\n+        Windows { v: self, size }\n     }\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a\n@@ -652,7 +652,7 @@ impl<T> [T] {\n     #[inline]\n     pub fn chunks(&self, chunk_size: usize) -> Chunks<T> {\n         assert!(chunk_size != 0);\n-        Chunks { v: self, chunk_size: chunk_size }\n+        Chunks { v: self, chunk_size }\n     }\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a time.\n@@ -687,7 +687,7 @@ impl<T> [T] {\n     #[inline]\n     pub fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<T> {\n         assert!(chunk_size != 0);\n-        ChunksMut { v: self, chunk_size: chunk_size }\n+        ChunksMut { v: self, chunk_size }\n     }\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a\n@@ -724,7 +724,7 @@ impl<T> [T] {\n         let rem = self.len() % chunk_size;\n         let len = self.len() - rem;\n         let (fst, snd) = self.split_at(len);\n-        ExactChunks { v: fst, rem: snd, chunk_size: chunk_size}\n+        ExactChunks { v: fst, rem: snd, chunk_size }\n     }\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a time.\n@@ -766,7 +766,7 @@ impl<T> [T] {\n         let rem = self.len() % chunk_size;\n         let len = self.len() - rem;\n         let (fst, snd) = self.split_at_mut(len);\n-        ExactChunksMut { v: fst, rem: snd, chunk_size: chunk_size}\n+        ExactChunksMut { v: fst, rem: snd, chunk_size }\n     }\n \n     /// Divides one slice into two at an index.\n@@ -916,7 +916,7 @@ impl<T> [T] {\n     pub fn split_mut<F>(&mut self, pred: F) -> SplitMut<T, F>\n         where F: FnMut(&T) -> bool\n     {\n-        SplitMut { v: self, pred: pred, finished: false }\n+        SplitMut { v: self, pred, finished: false }\n     }\n \n     /// Returns an iterator over subslices separated by elements that match"}, {"sha": "121f93b666bcecbe3dbe4e180e1a68e5fa33473b", "filename": "src/libcore/task/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/396dda0a6ab57cd89c0e2c28032d05bd91caba08/src%2Flibcore%2Ftask%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/396dda0a6ab57cd89c0e2c28032d05bd91caba08/src%2Flibcore%2Ftask%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fcontext.rs?ref=396dda0a6ab57cd89c0e2c28032d05bd91caba08", "patch": "@@ -86,7 +86,7 @@ impl<'a> Context<'a> {\n     {\n         Context {\n             local_waker: self.local_waker,\n-            executor: executor,\n+            executor,\n         }\n     }\n }"}, {"sha": "b58920224eb702217dd6009740fe5c11b0ea0ae7", "filename": "src/libcore/time.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/396dda0a6ab57cd89c0e2c28032d05bd91caba08/src%2Flibcore%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/396dda0a6ab57cd89c0e2c28032d05bd91caba08/src%2Flibcore%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftime.rs?ref=396dda0a6ab57cd89c0e2c28032d05bd91caba08", "patch": "@@ -91,7 +91,7 @@ impl Duration {\n         let secs = secs.checked_add((nanos / NANOS_PER_SEC) as u64)\n             .expect(\"overflow in Duration::new\");\n         let nanos = nanos % NANOS_PER_SEC;\n-        Duration { secs: secs, nanos: nanos }\n+        Duration { secs, nanos }\n     }\n \n     /// Creates a new `Duration` from the specified number of whole seconds.\n@@ -109,7 +109,7 @@ impl Duration {\n     #[stable(feature = \"duration\", since = \"1.3.0\")]\n     #[inline]\n     pub const fn from_secs(secs: u64) -> Duration {\n-        Duration { secs: secs, nanos: 0 }\n+        Duration { secs, nanos: 0 }\n     }\n \n     /// Creates a new `Duration` from the specified number of milliseconds.\n@@ -387,7 +387,7 @@ impl Duration {\n                 }\n             };\n             debug_assert!(nanos < NANOS_PER_SEC);\n-            Some(Duration { secs: secs, nanos: nanos })\n+            Some(Duration { secs, nanos })\n         } else {\n             None\n         }\n@@ -453,7 +453,7 @@ impl Duration {\n             let extra_nanos = carry * (NANOS_PER_SEC as u64) / (rhs as u64);\n             let nanos = self.nanos / rhs + (extra_nanos as u32);\n             debug_assert!(nanos < NANOS_PER_SEC);\n-            Some(Duration { secs: secs, nanos: nanos })\n+            Some(Duration { secs, nanos })\n         } else {\n             None\n         }"}]}