{"sha": "0b6c9e9f8853c30640e08088c2fae681afaa4b4f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiNmM5ZTlmODg1M2MzMDY0MGUwODA4OGMyZmFlNjgxYWZhYTRiNGY=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-11-15T17:02:00Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-01-23T12:42:56Z"}, "message": "Encode DefKind directly.", "tree": {"sha": "40aadc6115521da31a459e15a2952437d4cae495", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40aadc6115521da31a459e15a2952437d4cae495"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b6c9e9f8853c30640e08088c2fae681afaa4b4f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b6c9e9f8853c30640e08088c2fae681afaa4b4f", "html_url": "https://github.com/rust-lang/rust/commit/0b6c9e9f8853c30640e08088c2fae681afaa4b4f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b6c9e9f8853c30640e08088c2fae681afaa4b4f/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "064a351953c0491eaa3eff8c9359bc0d2aed1129", "url": "https://api.github.com/repos/rust-lang/rust/commits/064a351953c0491eaa3eff8c9359bc0d2aed1129", "html_url": "https://github.com/rust-lang/rust/commit/064a351953c0491eaa3eff8c9359bc0d2aed1129"}], "stats": {"total": 302, "additions": 160, "deletions": 142}, "files": [{"sha": "e3c353907985757ff09593b609820e4cd7b6af50", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 24, "deletions": 54, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c9e9f8853c30640e08088c2fae681afaa4b4f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c9e9f8853c30640e08088c2fae681afaa4b4f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=0b6c9e9f8853c30640e08088c2fae681afaa4b4f", "patch": "@@ -618,43 +618,6 @@ impl MetadataBlob {\n     }\n }\n \n-impl EntryKind {\n-    fn def_kind(&self) -> DefKind {\n-        match *self {\n-            EntryKind::AnonConst(..) => DefKind::AnonConst,\n-            EntryKind::Const(..) => DefKind::Const,\n-            EntryKind::AssocConst(..) => DefKind::AssocConst,\n-            EntryKind::ImmStatic\n-            | EntryKind::MutStatic\n-            | EntryKind::ForeignImmStatic\n-            | EntryKind::ForeignMutStatic => DefKind::Static,\n-            EntryKind::Struct(_, _) => DefKind::Struct,\n-            EntryKind::Union(_, _) => DefKind::Union,\n-            EntryKind::Fn(_) | EntryKind::ForeignFn(_) => DefKind::Fn,\n-            EntryKind::AssocFn(_) => DefKind::AssocFn,\n-            EntryKind::Type => DefKind::TyAlias,\n-            EntryKind::TypeParam => DefKind::TyParam,\n-            EntryKind::ConstParam => DefKind::ConstParam,\n-            EntryKind::OpaqueTy => DefKind::OpaqueTy,\n-            EntryKind::AssocType(_) => DefKind::AssocTy,\n-            EntryKind::Mod(_) => DefKind::Mod,\n-            EntryKind::Variant(_) => DefKind::Variant,\n-            EntryKind::Trait(_) => DefKind::Trait,\n-            EntryKind::TraitAlias => DefKind::TraitAlias,\n-            EntryKind::Enum(..) => DefKind::Enum,\n-            EntryKind::MacroDef(_) => DefKind::Macro(MacroKind::Bang),\n-            EntryKind::ProcMacro(kind) => DefKind::Macro(kind),\n-            EntryKind::ForeignType => DefKind::ForeignTy,\n-            EntryKind::Impl(_) => DefKind::Impl,\n-            EntryKind::Closure => DefKind::Closure,\n-            EntryKind::ForeignMod => DefKind::ForeignMod,\n-            EntryKind::GlobalAsm => DefKind::GlobalAsm,\n-            EntryKind::Field => DefKind::Field,\n-            EntryKind::Generator(_) => DefKind::Generator,\n-        }\n-    }\n-}\n-\n impl CrateRoot<'_> {\n     crate fn is_proc_macro_crate(&self) -> bool {\n         self.proc_macro_data.is_some()\n@@ -685,21 +648,6 @@ impl CrateRoot<'_> {\n }\n \n impl<'a, 'tcx> CrateMetadataRef<'a> {\n-    fn maybe_kind(&self, item_id: DefIndex) -> Option<EntryKind> {\n-        self.root.tables.kind.get(self, item_id).map(|k| k.decode(self))\n-    }\n-\n-    fn kind(&self, item_id: DefIndex) -> EntryKind {\n-        self.maybe_kind(item_id).unwrap_or_else(|| {\n-            bug!(\n-                \"CrateMetadata::kind({:?}): id not found, in crate {:?} with number {}\",\n-                item_id,\n-                self.root.name,\n-                self.cnum,\n-            )\n-        })\n-    }\n-\n     fn raw_proc_macro(&self, id: DefIndex) -> &ProcMacro {\n         // DefIndex's in root.proc_macro_data have a one-to-one correspondence\n         // with items in 'raw_proc_macros'.\n@@ -736,8 +684,30 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         self.try_item_ident(item_index, sess).unwrap()\n     }\n \n-    fn def_kind(&self, index: DefIndex) -> DefKind {\n-        self.kind(index).def_kind()\n+    fn maybe_kind(&self, item_id: DefIndex) -> Option<EntryKind> {\n+        self.root.tables.kind.get(self, item_id).map(|k| k.decode(self))\n+    }\n+\n+    fn kind(&self, item_id: DefIndex) -> EntryKind {\n+        self.maybe_kind(item_id).unwrap_or_else(|| {\n+            bug!(\n+                \"CrateMetadata::kind({:?}): id not found, in crate {:?} with number {}\",\n+                item_id,\n+                self.root.name,\n+                self.cnum,\n+            )\n+        })\n+    }\n+\n+    fn def_kind(&self, item_id: DefIndex) -> DefKind {\n+        self.root.tables.def_kind.get(self, item_id).map(|k| k.decode(self)).unwrap_or_else(|| {\n+            bug!(\n+                \"CrateMetadata::def_kind({:?}): id not found, in crate {:?} with number {}\",\n+                item_id,\n+                self.root.name,\n+                self.cnum,\n+            )\n+        })\n     }\n \n     fn get_span(&self, index: DefIndex, sess: &Session) -> Span {"}, {"sha": "600f521318b92758429b87facc52677aa2f9bb92", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 134, "deletions": 87, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c9e9f8853c30640e08088c2fae681afaa4b4f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c9e9f8853c30640e08088c2fae681afaa4b4f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=0b6c9e9f8853c30640e08088c2fae681afaa4b4f", "patch": "@@ -7,7 +7,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_data_structures::sync::{join, Lrc};\n use rustc_hir as hir;\n-use rustc_hir::def::CtorKind;\n+use rustc_hir::def::{CtorKind, DefKind};\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::definitions::DefPathData;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n@@ -739,6 +739,7 @@ impl EncodeContext<'a, 'tcx> {\n             is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n         };\n \n+        record!(self.tables.def_kind[def_id] <- DefKind::Variant);\n         record!(self.tables.kind[def_id] <- EntryKind::Variant(self.lazy(data)));\n         record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n         record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n@@ -779,6 +780,7 @@ impl EncodeContext<'a, 'tcx> {\n             is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n         };\n \n+        record!(self.tables.def_kind[def_id] <- DefKind::Variant);\n         record!(self.tables.kind[def_id] <- EntryKind::Variant(self.lazy(data)));\n         record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n         record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n@@ -831,6 +833,7 @@ impl EncodeContext<'a, 'tcx> {\n             expansion: tcx.hir().definitions().expansion_that_defined(local_def_id),\n         };\n \n+        record!(self.tables.def_kind[def_id] <- DefKind::Mod);\n         record!(self.tables.kind[def_id] <- EntryKind::Mod(self.lazy(data)));\n         record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n         record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n@@ -862,6 +865,7 @@ impl EncodeContext<'a, 'tcx> {\n         let variant_id = tcx.hir().local_def_id_to_hir_id(variant.def_id.expect_local());\n         let variant_data = tcx.hir().expect_variant_data(variant_id);\n \n+        record!(self.tables.def_kind[def_id] <- DefKind::Field);\n         record!(self.tables.kind[def_id] <- EntryKind::Field);\n         record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n         record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n@@ -888,6 +892,7 @@ impl EncodeContext<'a, 'tcx> {\n             is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n         };\n \n+        record!(self.tables.def_kind[def_id] <- DefKind::Struct);\n         record!(self.tables.kind[def_id] <- EntryKind::Struct(self.lazy(data), adt_def.repr));\n         record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n         record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n@@ -955,29 +960,26 @@ impl EncodeContext<'a, 'tcx> {\n             hir::Defaultness::Final => span_bug!(ast_item.span, \"traits cannot have final items\"),\n         };\n \n-        record!(self.tables.kind[def_id] <- match trait_item.kind {\n+        match trait_item.kind {\n             ty::AssocKind::Const => {\n                 let rendered = rustc_hir_pretty::to_string(\n                     &(&self.tcx.hir() as &dyn intravisit::Map<'_>),\n-                    |s| s.print_trait_item(ast_item)\n+                    |s| s.print_trait_item(ast_item),\n                 );\n                 let rendered_const = self.lazy(RenderedConst(rendered));\n \n-                EntryKind::AssocConst(\n+                record!(self.tables.def_kind[def_id] <- DefKind::AssocConst);\n+                record!(self.tables.kind[def_id] <- EntryKind::AssocConst(\n                     container,\n                     Default::default(),\n                     rendered_const,\n-                )\n+                ));\n             }\n             ty::AssocKind::Fn => {\n                 let fn_data = if let hir::TraitItemKind::Fn(m_sig, m) = &ast_item.kind {\n                     let param_names = match *m {\n-                        hir::TraitFn::Required(ref names) => {\n-                            self.encode_fn_param_names(names)\n-                        }\n-                        hir::TraitFn::Provided(body) => {\n-                            self.encode_fn_param_names_for_body(body)\n-                        }\n+                        hir::TraitFn::Required(ref names) => self.encode_fn_param_names(names),\n+                        hir::TraitFn::Provided(body) => self.encode_fn_param_names_for_body(body),\n                     };\n                     FnData {\n                         asyncness: m_sig.header.asyncness,\n@@ -987,17 +989,19 @@ impl EncodeContext<'a, 'tcx> {\n                 } else {\n                     bug!()\n                 };\n-                EntryKind::AssocFn(self.lazy(AssocFnData {\n+                record!(self.tables.def_kind[def_id] <- DefKind::AssocFn);\n+                record!(self.tables.kind[def_id] <- EntryKind::AssocFn(self.lazy(AssocFnData {\n                     fn_data,\n                     container,\n                     has_self: trait_item.fn_has_self_parameter,\n-                }))\n+                })));\n             }\n             ty::AssocKind::Type => {\n                 self.encode_explicit_item_bounds(def_id);\n-                EntryKind::AssocType(container)\n+                record!(self.tables.def_kind[def_id] <- DefKind::AssocTy);\n+                record!(self.tables.kind[def_id] <- EntryKind::AssocType(container));\n             }\n-        });\n+        }\n         record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n         record!(self.tables.span[def_id] <- ast_item.span);\n         record!(self.tables.attributes[def_id] <- ast_item.attrs);\n@@ -1068,15 +1072,17 @@ impl EncodeContext<'a, 'tcx> {\n             }\n         };\n \n-        record!(self.tables.kind[def_id] <- match impl_item.kind {\n+        match impl_item.kind {\n             ty::AssocKind::Const => {\n                 if let hir::ImplItemKind::Const(_, body_id) = ast_item.kind {\n                     let qualifs = self.tcx.at(ast_item.span).mir_const_qualif(def_id);\n \n-                    EntryKind::AssocConst(\n+                    record!(self.tables.def_kind[def_id] <- DefKind::AssocConst);\n+                    record!(self.tables.kind[def_id] <- EntryKind::AssocConst(\n                         container,\n                         qualifs,\n                         self.encode_rendered_const_for_body(body_id))\n+                    );\n                 } else {\n                     bug!()\n                 }\n@@ -1091,14 +1097,18 @@ impl EncodeContext<'a, 'tcx> {\n                 } else {\n                     bug!()\n                 };\n-                EntryKind::AssocFn(self.lazy(AssocFnData {\n+                record!(self.tables.def_kind[def_id] <- DefKind::AssocFn);\n+                record!(self.tables.kind[def_id] <- EntryKind::AssocFn(self.lazy(AssocFnData {\n                     fn_data,\n                     container,\n                     has_self: impl_item.fn_has_self_parameter,\n-                }))\n+                })));\n             }\n-            ty::AssocKind::Type => EntryKind::AssocType(container)\n-        });\n+            ty::AssocKind::Type => {\n+                record!(self.tables.def_kind[def_id] <- DefKind::AssocTy);\n+                record!(self.tables.kind[def_id] <- EntryKind::AssocType(container));\n+            }\n+        }\n         record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n         record!(self.tables.span[def_id] <- ast_item.span);\n         record!(self.tables.attributes[def_id] <- ast_item.attrs);\n@@ -1235,14 +1245,18 @@ impl EncodeContext<'a, 'tcx> {\n \n         self.encode_ident_span(def_id, item.ident);\n \n-        record!(self.tables.kind[def_id] <- match item.kind {\n-            hir::ItemKind::Static(_, hir::Mutability::Mut, _) => EntryKind::MutStatic,\n-            hir::ItemKind::Static(_, hir::Mutability::Not, _) => EntryKind::ImmStatic,\n+        let (def_kind, entry_kind) = match item.kind {\n+            hir::ItemKind::Static(_, hir::Mutability::Mut, _) => {\n+                (DefKind::Static, EntryKind::MutStatic)\n+            }\n+            hir::ItemKind::Static(_, hir::Mutability::Not, _) => {\n+                (DefKind::Static, EntryKind::ImmStatic)\n+            }\n             hir::ItemKind::Const(_, body_id) => {\n                 let qualifs = self.tcx.at(item.span).mir_const_qualif(def_id);\n-                EntryKind::Const(\n-                    qualifs,\n-                    self.encode_rendered_const_for_body(body_id)\n+                (\n+                    DefKind::Const,\n+                    EntryKind::Const(qualifs, self.encode_rendered_const_for_body(body_id)),\n                 )\n             }\n             hir::ItemKind::Fn(ref sig, .., body) => {\n@@ -1252,83 +1266,87 @@ impl EncodeContext<'a, 'tcx> {\n                     param_names: self.encode_fn_param_names_for_body(body),\n                 };\n \n-                EntryKind::Fn(self.lazy(data))\n+                (DefKind::Fn, EntryKind::Fn(self.lazy(data)))\n             }\n             hir::ItemKind::Mod(ref m) => {\n                 return self.encode_info_for_mod(item.hir_id, m, &item.attrs);\n             }\n-            hir::ItemKind::ForeignMod { .. } => EntryKind::ForeignMod,\n-            hir::ItemKind::GlobalAsm(..) => EntryKind::GlobalAsm,\n-            hir::ItemKind::TyAlias(..) => EntryKind::Type,\n+            hir::ItemKind::ForeignMod { .. } => (DefKind::ForeignMod, EntryKind::ForeignMod),\n+            hir::ItemKind::GlobalAsm(..) => (DefKind::GlobalAsm, EntryKind::GlobalAsm),\n+            hir::ItemKind::TyAlias(..) => (DefKind::TyAlias, EntryKind::Type),\n             hir::ItemKind::OpaqueTy(..) => {\n                 self.encode_explicit_item_bounds(def_id);\n-                EntryKind::OpaqueTy\n+                (DefKind::OpaqueTy, EntryKind::OpaqueTy)\n+            }\n+            hir::ItemKind::Enum(..) => {\n+                (DefKind::Enum, EntryKind::Enum(self.tcx.adt_def(def_id).repr))\n             }\n-            hir::ItemKind::Enum(..) => EntryKind::Enum(self.tcx.adt_def(def_id).repr),\n             hir::ItemKind::Struct(ref struct_def, _) => {\n                 let adt_def = self.tcx.adt_def(def_id);\n                 let variant = adt_def.non_enum_variant();\n \n                 // Encode def_ids for each field and method\n                 // for methods, write all the stuff get_trait_method\n                 // needs to know\n-                let ctor = struct_def.ctor_hir_id().map(|ctor_hir_id| {\n-                    self.tcx.hir().local_def_id(ctor_hir_id).local_def_index\n-                });\n-\n-                EntryKind::Struct(self.lazy(VariantData {\n-                    ctor_kind: variant.ctor_kind,\n-                    discr: variant.discr,\n-                    ctor,\n-                    is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n-                }), adt_def.repr)\n+                let ctor = struct_def\n+                    .ctor_hir_id()\n+                    .map(|ctor_hir_id| self.tcx.hir().local_def_id(ctor_hir_id).local_def_index);\n+\n+                let ek = EntryKind::Struct(\n+                    self.lazy(VariantData {\n+                        ctor_kind: variant.ctor_kind,\n+                        discr: variant.discr,\n+                        ctor,\n+                        is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n+                    }),\n+                    adt_def.repr,\n+                );\n+                (DefKind::Struct, ek)\n             }\n             hir::ItemKind::Union(..) => {\n                 let adt_def = self.tcx.adt_def(def_id);\n                 let variant = adt_def.non_enum_variant();\n \n-                EntryKind::Union(self.lazy(VariantData {\n-                    ctor_kind: variant.ctor_kind,\n-                    discr: variant.discr,\n-                    ctor: None,\n-                    is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n-                }), adt_def.repr)\n+                let ek = EntryKind::Union(\n+                    self.lazy(VariantData {\n+                        ctor_kind: variant.ctor_kind,\n+                        discr: variant.discr,\n+                        ctor: None,\n+                        is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n+                    }),\n+                    adt_def.repr,\n+                );\n+                (DefKind::Union, ek)\n             }\n             hir::ItemKind::Impl(hir::Impl { defaultness, .. }) => {\n                 let trait_ref = self.tcx.impl_trait_ref(def_id);\n                 let polarity = self.tcx.impl_polarity(def_id);\n                 let parent = if let Some(trait_ref) = trait_ref {\n                     let trait_def = self.tcx.trait_def(trait_ref.def_id);\n-                    trait_def.ancestors(self.tcx, def_id).ok()\n-                        .and_then(|mut an| an.nth(1).and_then(|node| {\n-                            match node {\n-                                specialization_graph::Node::Impl(parent) => Some(parent),\n-                                _ => None,\n-                            }\n-                        }))\n+                    trait_def.ancestors(self.tcx, def_id).ok().and_then(|mut an| {\n+                        an.nth(1).and_then(|node| match node {\n+                            specialization_graph::Node::Impl(parent) => Some(parent),\n+                            _ => None,\n+                        })\n+                    })\n                 } else {\n                     None\n                 };\n \n                 // if this is an impl of `CoerceUnsized`, create its\n                 // \"unsized info\", else just store None\n-                let coerce_unsized_info =\n-                    trait_ref.and_then(|t| {\n-                        if Some(t.def_id) == self.tcx.lang_items().coerce_unsized_trait() {\n-                            Some(self.tcx.at(item.span).coerce_unsized_info(def_id))\n-                        } else {\n-                            None\n-                        }\n-                    });\n+                let coerce_unsized_info = trait_ref.and_then(|t| {\n+                    if Some(t.def_id) == self.tcx.lang_items().coerce_unsized_trait() {\n+                        Some(self.tcx.at(item.span).coerce_unsized_info(def_id))\n+                    } else {\n+                        None\n+                    }\n+                });\n \n-                let data = ImplData {\n-                    polarity,\n-                    defaultness,\n-                    parent_impl: parent,\n-                    coerce_unsized_info,\n-                };\n+                let data =\n+                    ImplData { polarity, defaultness, parent_impl: parent, coerce_unsized_info };\n \n-                EntryKind::Impl(self.lazy(data))\n+                (DefKind::Impl, EntryKind::Impl(self.lazy(data)))\n             }\n             hir::ItemKind::Trait(..) => {\n                 let trait_def = self.tcx.trait_def(def_id);\n@@ -1340,12 +1358,15 @@ impl EncodeContext<'a, 'tcx> {\n                     specialization_kind: trait_def.specialization_kind,\n                 };\n \n-                EntryKind::Trait(self.lazy(data))\n+                (DefKind::Trait, EntryKind::Trait(self.lazy(data)))\n             }\n-            hir::ItemKind::TraitAlias(..) => EntryKind::TraitAlias,\n-            hir::ItemKind::ExternCrate(_) |\n-            hir::ItemKind::Use(..) => bug!(\"cannot encode info for item {:?}\", item),\n-        });\n+            hir::ItemKind::TraitAlias(..) => (DefKind::TraitAlias, EntryKind::TraitAlias),\n+            hir::ItemKind::ExternCrate(_) | hir::ItemKind::Use(..) => {\n+                bug!(\"cannot encode info for item {:?}\", item)\n+            }\n+        };\n+        record!(self.tables.def_kind[def_id] <- def_kind);\n+        record!(self.tables.kind[def_id] <- entry_kind);\n         record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n         record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n         record!(self.tables.attributes[def_id] <- item.attrs);\n@@ -1465,6 +1486,7 @@ impl EncodeContext<'a, 'tcx> {\n     /// Serialize the text of exported macros\n     fn encode_info_for_macro_def(&mut self, macro_def: &hir::MacroDef<'_>) {\n         let def_id = self.tcx.hir().local_def_id(macro_def.hir_id).to_def_id();\n+        record!(self.tables.def_kind[def_id] <- DefKind::Macro(MacroKind::Bang));\n         record!(self.tables.kind[def_id] <- EntryKind::MacroDef(self.lazy(macro_def.ast.clone())));\n         record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n         record!(self.tables.span[def_id] <- macro_def.span);\n@@ -1474,7 +1496,14 @@ impl EncodeContext<'a, 'tcx> {\n         self.encode_deprecation(def_id);\n     }\n \n-    fn encode_info_for_generic_param(&mut self, def_id: DefId, kind: EntryKind, encode_type: bool) {\n+    fn encode_info_for_generic_param(\n+        &mut self,\n+        def_id: DefId,\n+        def_kind: DefKind,\n+        kind: EntryKind,\n+        encode_type: bool,\n+    ) {\n+        record!(self.tables.def_kind[def_id] <- def_kind);\n         record!(self.tables.kind[def_id] <- kind);\n         record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n         if encode_type {\n@@ -1490,16 +1519,20 @@ impl EncodeContext<'a, 'tcx> {\n         let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n         let ty = self.tcx.typeck(def_id).node_type(hir_id);\n \n-        record!(self.tables.kind[def_id.to_def_id()] <- match ty.kind() {\n+        match ty.kind() {\n             ty::Generator(..) => {\n                 let data = self.tcx.generator_kind(def_id).unwrap();\n-                EntryKind::Generator(data)\n+                record!(self.tables.def_kind[def_id.to_def_id()] <- DefKind::Generator);\n+                record!(self.tables.kind[def_id.to_def_id()] <- EntryKind::Generator(data));\n             }\n \n-            ty::Closure(..) => EntryKind::Closure,\n+            ty::Closure(..) => {\n+                record!(self.tables.def_kind[def_id.to_def_id()] <- DefKind::Closure);\n+                record!(self.tables.kind[def_id.to_def_id()] <- EntryKind::Closure);\n+            }\n \n             _ => bug!(\"closure that is neither generator nor closure\"),\n-        });\n+        }\n         record!(self.tables.span[def_id.to_def_id()] <- self.tcx.def_span(def_id));\n         record!(self.tables.attributes[def_id.to_def_id()] <- &self.tcx.get_attrs(def_id.to_def_id())[..]);\n         self.encode_item_type(def_id.to_def_id());\n@@ -1524,6 +1557,7 @@ impl EncodeContext<'a, 'tcx> {\n         let const_data = self.encode_rendered_const_for_body(body_id);\n         let qualifs = self.tcx.mir_const_qualif(def_id);\n \n+        record!(self.tables.def_kind[def_id.to_def_id()] <- DefKind::AnonConst);\n         record!(self.tables.kind[def_id.to_def_id()] <- EntryKind::AnonConst(qualifs, const_data));\n         record!(self.tables.span[def_id.to_def_id()] <- self.tcx.def_span(def_id));\n         self.encode_item_type(def_id.to_def_id());\n@@ -1606,6 +1640,7 @@ impl EncodeContext<'a, 'tcx> {\n                 def_key.disambiguated_data.data = DefPathData::MacroNs(name);\n \n                 let def_id = DefId::local(id);\n+                record!(self.tables.def_kind[def_id] <- DefKind::Macro(macro_kind));\n                 record!(self.tables.kind[def_id] <- EntryKind::ProcMacro(macro_kind));\n                 record!(self.tables.attributes[def_id] <- attrs);\n                 record!(self.tables.def_keys[def_id] <- def_key);\n@@ -1773,7 +1808,7 @@ impl EncodeContext<'a, 'tcx> {\n \n         debug!(\"EncodeContext::encode_info_for_foreign_item({:?})\", def_id);\n \n-        record!(self.tables.kind[def_id] <- match nitem.kind {\n+        match nitem.kind {\n             hir::ForeignItemKind::Fn(_, ref names, _) => {\n                 let data = FnData {\n                     asyncness: hir::IsAsync::NotAsync,\n@@ -1784,12 +1819,22 @@ impl EncodeContext<'a, 'tcx> {\n                     },\n                     param_names: self.encode_fn_param_names(names),\n                 };\n-                EntryKind::ForeignFn(self.lazy(data))\n+                record!(self.tables.def_kind[def_id] <- DefKind::Fn);\n+                record!(self.tables.kind[def_id] <- EntryKind::ForeignFn(self.lazy(data)));\n             }\n-            hir::ForeignItemKind::Static(_, hir::Mutability::Mut) => EntryKind::ForeignMutStatic,\n-            hir::ForeignItemKind::Static(_, hir::Mutability::Not) => EntryKind::ForeignImmStatic,\n-            hir::ForeignItemKind::Type => EntryKind::ForeignType,\n-        });\n+            hir::ForeignItemKind::Static(_, hir::Mutability::Mut) => {\n+                record!(self.tables.def_kind[def_id] <- DefKind::Static);\n+                record!(self.tables.kind[def_id] <- EntryKind::ForeignMutStatic);\n+            }\n+            hir::ForeignItemKind::Static(_, hir::Mutability::Not) => {\n+                record!(self.tables.def_kind[def_id] <- DefKind::Static);\n+                record!(self.tables.kind[def_id] <- EntryKind::ForeignImmStatic);\n+            }\n+            hir::ForeignItemKind::Type => {\n+                record!(self.tables.def_kind[def_id] <- DefKind::ForeignTy);\n+                record!(self.tables.kind[def_id] <- EntryKind::ForeignType);\n+            }\n+        }\n         record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n         record!(self.tables.span[def_id] <- nitem.span);\n         record!(self.tables.attributes[def_id] <- nitem.attrs);\n@@ -1865,6 +1910,7 @@ impl EncodeContext<'a, 'tcx> {\n                 GenericParamKind::Type { ref default, .. } => {\n                     self.encode_info_for_generic_param(\n                         def_id.to_def_id(),\n+                        DefKind::TyParam,\n                         EntryKind::TypeParam,\n                         default.is_some(),\n                     );\n@@ -1875,6 +1921,7 @@ impl EncodeContext<'a, 'tcx> {\n                 GenericParamKind::Const { .. } => {\n                     self.encode_info_for_generic_param(\n                         def_id.to_def_id(),\n+                        DefKind::ConstParam,\n                         EntryKind::ConstParam,\n                         true,\n                     );"}, {"sha": "b44c3bfcac647ca0c4616311ad94bab471c0a0c5", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b6c9e9f8853c30640e08088c2fae681afaa4b4f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b6c9e9f8853c30640e08088c2fae681afaa4b4f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=0b6c9e9f8853c30640e08088c2fae681afaa4b4f", "patch": "@@ -6,7 +6,7 @@ use rustc_attr as attr;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::MetadataRef;\n use rustc_hir as hir;\n-use rustc_hir::def::CtorKind;\n+use rustc_hir::def::{CtorKind, DefKind};\n use rustc_hir::def_id::{DefId, DefIndex, DefPathHash};\n use rustc_hir::definitions::DefKey;\n use rustc_hir::lang_items;\n@@ -279,6 +279,7 @@ macro_rules! define_tables {\n }\n \n define_tables! {\n+    def_kind: Table<DefIndex, Lazy<DefKind>>,\n     kind: Table<DefIndex, Lazy<EntryKind>>,\n     visibility: Table<DefIndex, Lazy<ty::Visibility>>,\n     span: Table<DefIndex, Lazy<Span>>,"}]}