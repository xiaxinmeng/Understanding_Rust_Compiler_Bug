{"sha": "78fbcca3e10b6671ca54bd4c01cb84b3f6f13cf3", "node_id": "C_kwDOAAsO6NoAKDc4ZmJjY2EzZTEwYjY2NzFjYTU0YmQ0YzAxY2I4NGIzZjZmMTNjZjM", "commit": {"author": {"name": "klensy", "email": "klensy@users.noreply.github.com", "date": "2022-02-08T19:21:16Z"}, "committer": {"name": "klensy", "email": "klensy@users.noreply.github.com", "date": "2022-03-28T05:37:32Z"}, "message": "use cfg attribute instead of macro", "tree": {"sha": "f264eb00016dd954403ddade4697ecf5c9a5f8d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f264eb00016dd954403ddade4697ecf5c9a5f8d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78fbcca3e10b6671ca54bd4c01cb84b3f6f13cf3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78fbcca3e10b6671ca54bd4c01cb84b3f6f13cf3", "html_url": "https://github.com/rust-lang/rust/commit/78fbcca3e10b6671ca54bd4c01cb84b3f6f13cf3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78fbcca3e10b6671ca54bd4c01cb84b3f6f13cf3/comments", "author": {"login": "klensy", "id": 1782831, "node_id": "MDQ6VXNlcjE3ODI4MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1782831?v=4", "gravatar_id": "", "url": "https://api.github.com/users/klensy", "html_url": "https://github.com/klensy", "followers_url": "https://api.github.com/users/klensy/followers", "following_url": "https://api.github.com/users/klensy/following{/other_user}", "gists_url": "https://api.github.com/users/klensy/gists{/gist_id}", "starred_url": "https://api.github.com/users/klensy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/klensy/subscriptions", "organizations_url": "https://api.github.com/users/klensy/orgs", "repos_url": "https://api.github.com/users/klensy/repos", "events_url": "https://api.github.com/users/klensy/events{/privacy}", "received_events_url": "https://api.github.com/users/klensy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "klensy", "id": 1782831, "node_id": "MDQ6VXNlcjE3ODI4MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1782831?v=4", "gravatar_id": "", "url": "https://api.github.com/users/klensy", "html_url": "https://github.com/klensy", "followers_url": "https://api.github.com/users/klensy/followers", "following_url": "https://api.github.com/users/klensy/following{/other_user}", "gists_url": "https://api.github.com/users/klensy/gists{/gist_id}", "starred_url": "https://api.github.com/users/klensy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/klensy/subscriptions", "organizations_url": "https://api.github.com/users/klensy/orgs", "repos_url": "https://api.github.com/users/klensy/repos", "events_url": "https://api.github.com/users/klensy/events{/privacy}", "received_events_url": "https://api.github.com/users/klensy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1fca19c8ca4ae5e71e8b17a82c3acfeb78c48891", "url": "https://api.github.com/repos/rust-lang/rust/commits/1fca19c8ca4ae5e71e8b17a82c3acfeb78c48891", "html_url": "https://github.com/rust-lang/rust/commit/1fca19c8ca4ae5e71e8b17a82c3acfeb78c48891"}], "stats": {"total": 52, "additions": 27, "deletions": 25}, "files": [{"sha": "010560248054ebcb4441da4e49d32ea34c0bbcf4", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/78fbcca3e10b6671ca54bd4c01cb84b3f6f13cf3/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78fbcca3e10b6671ca54bd4c01cb84b3f6f13cf3/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=78fbcca3e10b6671ca54bd4c01cb84b3f6f13cf3", "patch": "@@ -14,6 +14,8 @@ use crate::{CachedModuleCodegen, CompiledModule, CrateInfo, MemFlags, ModuleCode\n use rustc_attr as attr;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::profiling::{get_resident_set_size, print_time_passes_entry};\n+\n+#[cfg(parallel_compiler)]\n use rustc_data_structures::sync::{par_iter, ParallelIterator};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n@@ -622,34 +624,34 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n     // This likely is a temporary measure. Once we don't have to support the\n     // non-parallel compiler anymore, we can compile CGUs end-to-end in\n     // parallel and get rid of the complicated scheduling logic.\n+    #[cfg(parallel_compiler)]\n     let pre_compile_cgus = |cgu_reuse: &[CguReuse]| {\n-        if cfg!(parallel_compiler) {\n-            tcx.sess.time(\"compile_first_CGU_batch\", || {\n-                // Try to find one CGU to compile per thread.\n-                let cgus: Vec<_> = cgu_reuse\n-                    .iter()\n-                    .enumerate()\n-                    .filter(|&(_, reuse)| reuse == &CguReuse::No)\n-                    .take(tcx.sess.threads())\n-                    .collect();\n-\n-                // Compile the found CGUs in parallel.\n-                let start_time = Instant::now();\n-\n-                let pre_compiled_cgus = par_iter(cgus)\n-                    .map(|(i, _)| {\n-                        let module = backend.compile_codegen_unit(tcx, codegen_units[i].name());\n-                        (i, module)\n-                    })\n-                    .collect();\n-\n-                (pre_compiled_cgus, start_time.elapsed())\n-            })\n-        } else {\n-            (FxHashMap::default(), Duration::new(0, 0))\n-        }\n+        tcx.sess.time(\"compile_first_CGU_batch\", || {\n+            // Try to find one CGU to compile per thread.\n+            let cgus: Vec<_> = cgu_reuse\n+                .iter()\n+                .enumerate()\n+                .filter(|&(_, reuse)| reuse == &CguReuse::No)\n+                .take(tcx.sess.threads())\n+                .collect();\n+\n+            // Compile the found CGUs in parallel.\n+            let start_time = Instant::now();\n+\n+            let pre_compiled_cgus = par_iter(cgus)\n+                .map(|(i, _)| {\n+                    let module = backend.compile_codegen_unit(tcx, codegen_units[i].name());\n+                    (i, module)\n+                })\n+                .collect();\n+\n+            (pre_compiled_cgus, start_time.elapsed())\n+        })\n     };\n \n+    #[cfg(not(parallel_compiler))]\n+    let pre_compile_cgus = |_: &[CguReuse]| (FxHashMap::default(), Duration::new(0, 0));\n+\n     let mut cgu_reuse = Vec::new();\n     let mut pre_compiled_cgus: Option<FxHashMap<usize, _>> = None;\n     let mut total_codegen_time = Duration::new(0, 0);"}]}