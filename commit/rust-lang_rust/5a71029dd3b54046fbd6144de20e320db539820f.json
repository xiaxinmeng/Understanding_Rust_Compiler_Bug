{"sha": "5a71029dd3b54046fbd6144de20e320db539820f", "node_id": "C_kwDOAAsO6NoAKDVhNzEwMjlkZDNiNTQwNDZmYmQ2MTQ0ZGUyMGUzMjBkYjUzOTgyMGY", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-03-03T00:44:22Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-04-12T23:20:12Z"}, "message": "Properly note source of arg mismatch", "tree": {"sha": "fa711dff5802b38df8cd818d7b00ab49a377542e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa711dff5802b38df8cd818d7b00ab49a377542e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a71029dd3b54046fbd6144de20e320db539820f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a71029dd3b54046fbd6144de20e320db539820f", "html_url": "https://github.com/rust-lang/rust/commit/5a71029dd3b54046fbd6144de20e320db539820f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a71029dd3b54046fbd6144de20e320db539820f/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29aee6a125ac65a01932cb0ece5485e7cf8cfe87", "url": "https://api.github.com/repos/rust-lang/rust/commits/29aee6a125ac65a01932cb0ece5485e7cf8cfe87", "html_url": "https://github.com/rust-lang/rust/commit/29aee6a125ac65a01932cb0ece5485e7cf8cfe87"}], "stats": {"total": 81, "additions": 74, "deletions": 7}, "files": [{"sha": "9ffee567023298d23d4a77474e9ddab89f08ebd0", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 54, "deletions": 3, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/5a71029dd3b54046fbd6144de20e320db539820f/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a71029dd3b54046fbd6144de20e320db539820f/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=5a71029dd3b54046fbd6144de20e320db539820f", "patch": "@@ -62,7 +62,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             || self.suggest_coercing_result_via_try_operator(err, expr, expected, expr_ty);\n \n         if !suggested {\n-            self.note_source_of_type_mismatch_constraint(err, expr, expected);\n+            self.note_source_of_type_mismatch_constraint(\n+                err,\n+                expr,\n+                TypeMismatchSource::Ty(expected),\n+            );\n         }\n     }\n \n@@ -222,7 +226,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         err: &mut Diagnostic,\n         expr: &hir::Expr<'_>,\n-        expected_ty: Ty<'tcx>,\n+        source: TypeMismatchSource<'tcx>,\n     ) -> bool {\n         let hir = self.tcx.hir();\n \n@@ -295,6 +299,46 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             },\n         };\n \n+        let expected_ty = match source {\n+            TypeMismatchSource::Ty(expected_ty) => expected_ty,\n+            TypeMismatchSource::Arg(call_expr, idx) => {\n+                let hir::ExprKind::MethodCall(segment, _, args, _) = call_expr.kind else {\n+                    return false;\n+                };\n+                let Some(arg_ty) = self.node_ty_opt(args[idx].hir_id) else {\n+                    return false;\n+                };\n+                let possible_rcvr_ty = expr_finder.uses.iter().find_map(|binding| {\n+                    let possible_rcvr_ty = self.node_ty_opt(binding.hir_id)?;\n+                    let possible_rcvr_ty = possible_rcvr_ty.fold_with(&mut fudger);\n+                    let method = self\n+                        .lookup_method(\n+                            possible_rcvr_ty,\n+                            segment,\n+                            DUMMY_SP,\n+                            call_expr,\n+                            binding,\n+                            args,\n+                        )\n+                        .ok()?;\n+                    let _ = self\n+                        .at(&ObligationCause::dummy(), self.param_env)\n+                        .eq(DefineOpaqueTypes::No, method.sig.inputs()[idx + 1], arg_ty)\n+                        .ok()?;\n+                    self.select_obligations_where_possible(|errs| {\n+                        // Yeet the errors, we're already reporting errors.\n+                        errs.clear();\n+                    });\n+                    Some(self.resolve_vars_if_possible(possible_rcvr_ty))\n+                });\n+                if let Some(rcvr_ty) = possible_rcvr_ty {\n+                    rcvr_ty\n+                } else {\n+                    return false;\n+                }\n+            }\n+        };\n+\n         if !self.can_eq(self.param_env, expected_ty, init_ty.fold_with(&mut fudger)) {\n             return false;\n         }\n@@ -360,7 +404,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             \"... which constrains `{ident}` to have type `{next_use_ty}`\"\n                         ),\n                     );\n-                    if let Ok(ideal_method_sig) = ideal_method_sig {\n+                    if matches!(source, TypeMismatchSource::Ty(_))\n+                        && let Ok(ideal_method_sig) = ideal_method_sig\n+                    {\n                         self.emit_type_mismatch_suggestions(\n                             err,\n                             arg_expr,\n@@ -2044,3 +2090,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n }\n+\n+pub enum TypeMismatchSource<'tcx> {\n+    Ty(Ty<'tcx>),\n+    Arg(&'tcx hir::Expr<'tcx>, usize),\n+}"}, {"sha": "9ecb78e2dda80ccc109c8b63466971e7c2913fbf", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5a71029dd3b54046fbd6144de20e320db539820f/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a71029dd3b54046fbd6144de20e320db539820f/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=5a71029dd3b54046fbd6144de20e320db539820f", "patch": "@@ -472,7 +472,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         err_code: &str,\n         fn_def_id: Option<DefId>,\n         call_span: Span,\n-        call_expr: &hir::Expr<'tcx>,\n+        call_expr: &'tcx hir::Expr<'tcx>,\n     ) {\n         // Next, let's construct the error\n         let (error_span, full_call_span, call_name, is_method) = match &call_expr.kind {\n@@ -808,8 +808,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 format!(\"arguments to this {} are incorrect\", call_name),\n             );\n \n-            // TODO: We would like to point out when the rcvr was constrained\n-            // such that the arg mismatch occurs.\n+            if let hir::ExprKind::MethodCall(_, rcvr, _, _) = call_expr.kind\n+                && provided_idx.as_usize() == expected_idx.as_usize()\n+            {\n+                self.note_source_of_type_mismatch_constraint(\n+                    &mut err,\n+                    rcvr,\n+                    crate::demand::TypeMismatchSource::Arg(call_expr, provided_idx.as_usize()),\n+                );\n+            }\n \n             // Call out where the function is defined\n             self.label_fn_like("}, {"sha": "15a3b580568d6228164a4b6296c9b5de623b96f0", "filename": "tests/ui/type/type-check/point-at-inference-3.fixed", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a71029dd3b54046fbd6144de20e320db539820f/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5a71029dd3b54046fbd6144de20e320db539820f/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.fixed?ref=5a71029dd3b54046fbd6144de20e320db539820f", "patch": "@@ -2,6 +2,8 @@\n fn main() {\n     let mut v = Vec::new();\n     v.push(0i32);\n+    //~^ NOTE this argument has type `i32`...\n+    //~| NOTE ... which causes `v` to have type `Vec<i32>`\n     v.push(0);\n     v.push(1i32); //~ ERROR mismatched types\n     //~^ NOTE expected `i32`, found `u32`"}, {"sha": "a48c4f9862f75777befe63a3371d5e43735e0e5a", "filename": "tests/ui/type/type-check/point-at-inference-3.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a71029dd3b54046fbd6144de20e320db539820f/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a71029dd3b54046fbd6144de20e320db539820f/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.rs?ref=5a71029dd3b54046fbd6144de20e320db539820f", "patch": "@@ -2,6 +2,8 @@\n fn main() {\n     let mut v = Vec::new();\n     v.push(0i32);\n+    //~^ NOTE this argument has type `i32`...\n+    //~| NOTE ... which causes `v` to have type `Vec<i32>`\n     v.push(0);\n     v.push(1u32); //~ ERROR mismatched types\n     //~^ NOTE expected `i32`, found `u32`"}, {"sha": "238764812364cc1c56053efa9b728c665bf4df4d", "filename": "tests/ui/type/type-check/point-at-inference-3.stderr", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5a71029dd3b54046fbd6144de20e320db539820f/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5a71029dd3b54046fbd6144de20e320db539820f/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-3.stderr?ref=5a71029dd3b54046fbd6144de20e320db539820f", "patch": "@@ -1,6 +1,11 @@\n error[E0308]: mismatched types\n-  --> $DIR/point-at-inference-3.rs:6:12\n+  --> $DIR/point-at-inference-3.rs:8:12\n    |\n+LL |     v.push(0i32);\n+   |     -      ---- this argument has type `i32`...\n+   |     |\n+   |     ... which causes `v` to have type `Vec<i32>`\n+...\n LL |     v.push(1u32);\n    |       ---- ^^^^ expected `i32`, found `u32`\n    |       |"}]}