{"sha": "3bf0a9b0945f297d1aea330b6afcf98052e6de1e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiZjBhOWIwOTQ1ZjI5N2QxYWVhMzMwYjZhZmNmOTgwNTJlNmRlMWU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-10-23T00:57:10Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-10-23T17:45:23Z"}, "message": "rustc: Implement typechecking for simple monomorphic derivable traits on monomorphic types. r=brson", "tree": {"sha": "0908f3cc9095dbbc6b8aa508d3dac2c9b4a40afa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0908f3cc9095dbbc6b8aa508d3dac2c9b4a40afa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3bf0a9b0945f297d1aea330b6afcf98052e6de1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3bf0a9b0945f297d1aea330b6afcf98052e6de1e", "html_url": "https://github.com/rust-lang/rust/commit/3bf0a9b0945f297d1aea330b6afcf98052e6de1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "575950d12c38d79dcb2cac906f6664325d10ec9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/575950d12c38d79dcb2cac906f6664325d10ec9d", "html_url": "https://github.com/rust-lang/rust/commit/575950d12c38d79dcb2cac906f6664325d10ec9d"}], "stats": {"total": 545, "additions": 422, "deletions": 123}, "files": [{"sha": "579699c995878ffd366e601763c6a838dcc96a2a", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=3bf0a9b0945f297d1aea330b6afcf98052e6de1e", "patch": "@@ -1508,7 +1508,7 @@ enum item_ {\n     item_impl(~[ty_param],\n               Option<@trait_ref>, /* (optional) trait this impl implements */\n               @Ty, /* self */\n-              ~[@method]),\n+              Option<~[@method]>),\n     item_mac(mac),\n }\n "}, {"sha": "bcda838b2486cd210a0bfd596cca555e0b1458d5", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=3bf0a9b0945f297d1aea330b6afcf98052e6de1e", "patch": "@@ -202,11 +202,13 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n     let item_path = @/* FIXME (#2543) */ copy cx.path;\n     cx.map.insert(i.id, node_item(i, item_path));\n     match i.node {\n-      item_impl(_, _, _, ms) => {\n+      item_impl(_, _, _, ms_opt) => {\n         let impl_did = ast_util::local_def(i.id);\n-        for ms.each |m| {\n-            map_method(impl_did, extend(cx, i.ident), *m,\n-                       cx);\n+        for ms_opt.each |ms| {\n+            for ms.each |m| {\n+                map_method(impl_did, extend(cx, i.ident), *m,\n+                           cx);\n+            }\n         }\n       }\n       item_enum(enum_definition, _) => {"}, {"sha": "707787e78b9a1ea3d276ef4d2cda1a8da3fd49b6", "filename": "src/libsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize.rs?ref=3bf0a9b0945f297d1aea330b6afcf98052e6de1e", "patch": "@@ -398,7 +398,7 @@ fn mk_impl(\n         ident: ast::token::special_idents::clownshoes_extensions,\n         attrs: ~[],\n         id: cx.next_id(),\n-        node: ast::item_impl(trait_tps, opt_trait, ty, ~[f(ty)]),\n+        node: ast::item_impl(trait_tps, opt_trait, ty, Some(~[f(ty)])),\n         vis: ast::public,\n         span: span,\n     }"}, {"sha": "7eb7b2853e358ed486028e5418aa98cba35e231c", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=3bf0a9b0945f297d1aea330b6afcf98052e6de1e", "patch": "@@ -248,11 +248,13 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n             let struct_def = fold_struct_def(struct_def, fld);\n               item_class(struct_def, /* FIXME (#2543) */ copy typms)\n           }\n-          item_impl(tps, ifce, ty, methods) => {\n+          item_impl(tps, ifce, ty, ref methods_opt) => {\n               item_impl(fold_ty_params(tps, fld),\n                         ifce.map(|p| fold_trait_ref(*p, fld)),\n                         fld.fold_ty(ty),\n-                        vec::map(methods, |x| fld.fold_method(*x)))\n+                        option::map(methods_opt,\n+                                    |methods| vec::map(\n+                                        *methods, |x| fld.fold_method(*x))))\n           }\n           item_trait(tps, traits, methods) => {\n             item_trait(fold_ty_params(tps, fld),"}, {"sha": "672f86b7a107fa7b2c9181eaa18d6b9e9db2fe32", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=3bf0a9b0945f297d1aea330b6afcf98052e6de1e", "patch": "@@ -2603,13 +2603,20 @@ impl Parser {\n             None\n         };\n \n-        let mut meths = ~[];\n-        self.expect(token::LBRACE);\n-        while !self.eat(token::RBRACE) {\n-            let vis = self.parse_visibility();\n-            meths.push(self.parse_method(vis));\n+        let meths_opt;\n+        if self.eat(token::SEMI) {\n+            meths_opt = None;\n+        } else {\n+            let mut meths = ~[];\n+            self.expect(token::LBRACE);\n+            while !self.eat(token::RBRACE) {\n+                let vis = self.parse_visibility();\n+                meths.push(self.parse_method(vis));\n+            }\n+            meths_opt = Some(move meths);\n         }\n-        (ident, item_impl(tps, opt_trait, ty, meths), None)\n+\n+        (ident, item_impl(tps, opt_trait, ty, meths_opt), None)\n     }\n \n     // Instantiates ident <i> with references to <typarams> as arguments."}, {"sha": "d68b28c68367a7460d9c0f01d978333b35fa7318", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=3bf0a9b0945f297d1aea330b6afcf98052e6de1e", "patch": "@@ -522,7 +522,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n           print_struct(s, struct_def, tps, item.ident, item.span);\n       }\n \n-      ast::item_impl(tps, opt_trait, ty, methods) => {\n+      ast::item_impl(tps, opt_trait, ty, methods_opt) => {\n         head(s, visibility_qualified(item.vis, ~\"impl\"));\n         if tps.is_not_empty() {\n             print_type_params(s, tps);\n@@ -539,11 +539,18 @@ fn print_item(s: ps, &&item: @ast::item) {\n         };\n         space(s.s);\n \n-        bopen(s);\n-        for methods.each |meth| {\n-           print_method(s, *meth);\n+        match methods_opt {\n+            None => {\n+                word(s.s, ~\";\");\n+            }\n+            Some(methods) => {\n+                bopen(s);\n+                for methods.each |meth| {\n+                   print_method(s, *meth);\n+                }\n+                bclose(s, item.span);\n+            }\n         }\n-        bclose(s, item.span);\n       }\n       ast::item_trait(tps, traits, methods) => {\n         head(s, visibility_qualified(item.vis, ~\"trait\"));"}, {"sha": "7035400f92dedf747285678c786aef75fda0d2d8", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=3bf0a9b0945f297d1aea330b6afcf98052e6de1e", "patch": "@@ -142,14 +142,16 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n         v.visit_ty_params(tps, e, v);\n         visit_enum_def(enum_definition, tps, e, v);\n       }\n-      item_impl(tps, traits, ty, methods) => {\n+      item_impl(tps, traits, ty, methods_opt) => {\n         v.visit_ty_params(tps, e, v);\n         for traits.each |p| {\n             visit_path(p.path, e, v);\n         }\n         v.visit_ty(ty, e, v);\n-        for methods.each |m| {\n-            visit_method_helper(*m, e, v)\n+        for methods_opt.each |methods| {\n+            for methods.each |m| {\n+                visit_method_helper(*m, e, v)\n+            }\n         }\n       }\n       item_class(struct_def, tps) => {"}, {"sha": "259d3aa6221a7f82909e088ba8045da58732c9e4", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=3bf0a9b0945f297d1aea330b6afcf98052e6de1e", "patch": "@@ -712,7 +712,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n         encode_index(ebml_w, bkts, write_int);\n         ebml_w.end_tag();\n       }\n-      item_impl(tps, opt_trait, ty, methods) => {\n+      item_impl(tps, opt_trait, ty, methods_opt) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n@@ -729,10 +729,13 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n             }\n             _ => {}\n         }\n-        for methods.each |m| {\n-            ebml_w.start_tag(tag_item_impl_method);\n-            ebml_w.writer.write(str::to_bytes(def_to_str(local_def(m.id))));\n-            ebml_w.end_tag();\n+        for methods_opt.each |methods| {\n+            for methods.each |m| {\n+                ebml_w.start_tag(tag_item_impl_method);\n+                let method_def_id = local_def(m.id);\n+                ebml_w.writer.write(str::to_bytes(def_to_str(method_def_id)));\n+                ebml_w.end_tag();\n+            }\n         }\n         do opt_trait.iter() |associated_trait| {\n            encode_trait_ref(ebml_w, ecx, *associated_trait)\n@@ -742,11 +745,13 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::Serializer,\n \n         let impl_path = vec::append_one(path,\n                                         ast_map::path_name(item.ident));\n-        for methods.each |m| {\n-            index.push({val: m.id, pos: ebml_w.writer.tell()});\n-            encode_info_for_method(ecx, ebml_w, impl_path,\n-                                   should_inline(m.attrs), item.id, *m,\n-                                   vec::append(tps, m.tps));\n+        for methods_opt.each |methods| {\n+            for methods.each |m| {\n+                index.push({val: m.id, pos: ebml_w.writer.tell()});\n+                encode_info_for_method(ecx, ebml_w, impl_path,\n+                                       should_inline(m.attrs), item.id, *m,\n+                                       vec::append(tps, m.tps));\n+            }\n         }\n       }\n       item_trait(tps, traits, ms) => {"}, {"sha": "73720648798eb523cb7c519eb31b0f213b62ddbd", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 58, "deletions": 44, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=3bf0a9b0945f297d1aea330b6afcf98052e6de1e", "patch": "@@ -1192,7 +1192,7 @@ impl Resolver {\n                 visit_item(item, new_parent, visitor);\n             }\n \n-            item_impl(_, trait_ref_opt, ty, methods) => {\n+            item_impl(_, trait_ref_opt, ty, methods_opt) => {\n                 // If this implements an anonymous trait and it has static\n                 // methods, then add all the static methods within to a new\n                 // module, if the type was defined within this module.\n@@ -1203,10 +1203,12 @@ impl Resolver {\n \n                 // Bail out early if there are no static methods.\n                 let mut has_static_methods = false;\n-                for methods.each |method| {\n-                    match method.self_ty.node {\n-                        sty_static => has_static_methods = true,\n-                        _ => {}\n+                for methods_opt.each |methods| {\n+                    for methods.each |method| {\n+                        match method.self_ty.node {\n+                            sty_static => has_static_methods = true,\n+                            _ => {}\n+                        }\n                     }\n                 }\n \n@@ -1233,22 +1235,26 @@ impl Resolver {\n                             name_bindings.get_module());\n \n                         // For each static method...\n-                        for methods.each |method| {\n-                            match method.self_ty.node {\n-                                sty_static => {\n-                                    // Add the static method to the module.\n-                                    let ident = method.ident;\n-                                    let (method_name_bindings, _) =\n-                                        self.add_child(ident,\n-                                                       new_parent,\n-                                                       ForbidDuplicateValues,\n-                                                       method.span);\n-                                    let def = def_fn(local_def(method.id),\n-                                                     method.purity);\n-                                    method_name_bindings.define_value(\n-                                        Public, def, method.span);\n+                        for methods_opt.each |methods| {\n+                            for methods.each |method| {\n+                                match method.self_ty.node {\n+                                    sty_static => {\n+                                        // Add the static method to the\n+                                        // module.\n+                                        let ident = method.ident;\n+                                        let (method_name_bindings, _) =\n+                                            self.add_child(\n+                                                ident,\n+                                                new_parent,\n+                                                ForbidDuplicateValues,\n+                                                method.span);\n+                                        let def = def_fn(local_def(method.id),\n+                                                         method.purity);\n+                                        method_name_bindings.define_value(\n+                                            Public, def, method.span);\n+                                    }\n+                                    _ => {}\n                                 }\n-                                _ => {}\n                             }\n                         }\n                     }\n@@ -3446,12 +3452,14 @@ impl Resolver {\n             }\n \n             item_impl(type_parameters, implemented_traits, self_type,\n-                      methods) => {\n-\n-                self.resolve_implementation(item.id, item.span,\n+                      methods_opt) => {\n+                self.resolve_implementation(item.id,\n+                                            item.span,\n                                             type_parameters,\n                                             implemented_traits,\n-                                            self_type, methods, visitor);\n+                                            self_type,\n+                                            methods_opt,\n+                                            visitor);\n             }\n \n             item_trait(type_parameters, traits, methods) => {\n@@ -3876,7 +3884,7 @@ impl Resolver {\n                               type_parameters: ~[ty_param],\n                               opt_trait_reference: Option<@trait_ref>,\n                               self_type: @Ty,\n-                              methods: ~[@method],\n+                              opt_methods: Option<~[@method]>,\n                               visitor: ResolveVisitor) {\n         // If applicable, create a rib for the type parameters.\n         let outer_type_parameter_count = type_parameters.len();\n@@ -3915,27 +3923,33 @@ impl Resolver {\n             // Resolve the self type.\n             self.resolve_type(self_type, visitor);\n \n-            for methods.each |method| {\n-                // We also need a new scope for the method-specific\n-                // type parameters.\n-                self.resolve_method(MethodRibKind(id, Provided(method.id)),\n-                                    *method,\n-                                    outer_type_parameter_count,\n-                                    visitor);\n+            for opt_methods.each |methods| {\n+                for methods.each |method| {\n+                    // We also need a new scope for the method-specific\n+                    // type parameters.\n+                    self.resolve_method(MethodRibKind(\n+                        id,\n+                        Provided(method.id)),\n+                        *method,\n+                        outer_type_parameter_count,\n+                        visitor);\n /*\n-                let borrowed_type_parameters = &method.tps;\n-                self.resolve_function(MethodRibKind(id, Provided(method.id)),\n-                                      Some(@method.decl),\n-                                      HasTypeParameters\n-                                        (borrowed_type_parameters,\n-                                         method.id,\n-                                         outer_type_parameter_count,\n-                                         NormalRibKind),\n-                                      method.body,\n-                                      HasSelfBinding(method.self_id),\n-                                      NoCaptureClause,\n-                                      visitor);\n+                    let borrowed_type_parameters = &method.tps;\n+                    self.resolve_function(MethodRibKind(\n+                                          id,\n+                                          Provided(method.id)),\n+                                          Some(@method.decl),\n+                                          HasTypeParameters\n+                                            (borrowed_type_parameters,\n+                                             method.id,\n+                                             outer_type_parameter_count,\n+                                             NormalRibKind),\n+                                          method.body,\n+                                          HasSelfBinding(method.self_id),\n+                                          NoCaptureClause,\n+                                          visitor);\n */\n+                }\n             }\n \n             // Restore the original trait references."}, {"sha": "61d4e6379a296611fba793c5cd063c42f1cc78e8", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=3bf0a9b0945f297d1aea330b6afcf98052e6de1e", "patch": "@@ -1798,8 +1798,17 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n             }\n         }\n       }\n-      ast::item_impl(tps, _, _, ms) => {\n-        meth::trans_impl(ccx, *path, item.ident, ms, tps, None, item.id);\n+      ast::item_impl(tps, _, _, ms_opt) => {\n+        match ms_opt {\n+            None => {\n+                deriving::trans_deriving_impl(ccx, *path, item.ident, tps,\n+                                              None, item.id);\n+            }\n+            Some(ms) => {\n+                meth::trans_impl(ccx, *path, item.ident, ms, tps, None,\n+                                 item.id);\n+            }\n+        }\n       }\n       ast::item_mod(m) => {\n         trans_mod(ccx, m);"}, {"sha": "5ef412888b9cc9e7031cac6d74c98407303ea7db", "filename": "src/rustc/middle/trans/deriving.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Frustc%2Fmiddle%2Ftrans%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Frustc%2Fmiddle%2Ftrans%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fderiving.rs?ref=3bf0a9b0945f297d1aea330b6afcf98052e6de1e", "patch": "@@ -0,0 +1,21 @@\n+// Translation of automatically-derived trait implementations. This handles\n+// enums and structs only; other types cannot be automatically derived.\n+\n+use middle::trans::base::get_insn_ctxt;\n+use middle::trans::common::crate_ctxt;\n+use syntax::ast::{ident, node_id, ty_param};\n+use syntax::ast_map::path;\n+\n+/// The main \"translation\" pass for automatically-derived impls. Generates\n+/// code for monomorphic methods only. Other methods will be generated when\n+/// they are invoked with specific type parameters; see\n+/// `trans::base::lval_static_fn()` or `trans::base::monomorphic_fn()`.\n+pub fn trans_deriving_impl(ccx: @crate_ctxt, _path: path, _name: ident,\n+                           tps: ~[ty_param], _self_ty: Option<ty::t>,\n+                           _id: node_id) {\n+    let _icx = ccx.insn_ctxt(\"deriving::trans_deriving_impl\");\n+    if tps.len() > 0 { return; }\n+\n+    // XXX: Unimplemented.\n+}\n+"}, {"sha": "e7c134fe546971d1cd60d277d55298f673e414c1", "filename": "src/rustc/middle/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Frustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Frustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=3bf0a9b0945f297d1aea330b6afcf98052e6de1e", "patch": "@@ -306,7 +306,8 @@ fn method_with_name(ccx: @crate_ctxt, impl_id: ast::def_id,\n                     name: ast::ident) -> ast::def_id {\n     if impl_id.crate == ast::local_crate {\n         match ccx.tcx.items.get(impl_id.node) {\n-          ast_map::node_item(@{node: ast::item_impl(_, _, _, ms), _}, _) => {\n+          ast_map::node_item(@{node: ast::item_impl(_, _, _, Some(ms)), _},\n+                             _) => {\n             method_from_methods(ms, name)\n           }\n           ast_map::node_item(@{node:"}, {"sha": "87cb4716cd2f6d69beec47c36a01ee06736082da", "filename": "src/rustc/middle/trans/reachable.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=3bf0a9b0945f297d1aea330b6afcf98052e6de1e", "patch": "@@ -90,12 +90,14 @@ fn traverse_public_item(cx: ctx, item: @item) {\n             traverse_inline_body(cx, blk);\n         }\n       }\n-      item_impl(tps, _, _, ms) => {\n-        for vec::each(ms) |m| {\n-            if tps.len() > 0u || m.tps.len() > 0u ||\n-               attr::find_inline_attr(m.attrs) != attr::ia_none {\n-                cx.rmap.insert(m.id, ());\n-                traverse_inline_body(cx, m.body);\n+      item_impl(tps, _, _, ms_opt) => {\n+        for ms_opt.each |ms| {\n+            for vec::each(*ms) |m| {\n+                if tps.len() > 0u || m.tps.len() > 0u ||\n+                   attr::find_inline_attr(m.attrs) != attr::ia_none {\n+                    cx.rmap.insert(m.id, ());\n+                    traverse_inline_body(cx, m.body);\n+                }\n             }\n         }\n       }"}, {"sha": "03e75957a92f1be95622e37b695b043089268f67", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=3bf0a9b0945f297d1aea330b6afcf98052e6de1e", "patch": "@@ -374,7 +374,9 @@ type ctxt =\n       lang_items: middle::lang_items::LanguageItems,\n       legacy_boxed_traits: HashMap<node_id, ()>,\n       provided_method_sources: HashMap<ast::def_id, ProvidedMethodSource>,\n-      supertraits: HashMap<ast::def_id, @~[InstantiatedTraitRef]>};\n+      supertraits: HashMap<ast::def_id, @~[InstantiatedTraitRef]>,\n+      deriving_struct_methods: HashMap<ast::def_id,\n+                                       @~[typeck::method_origin]>};\n \n enum tbox_flag {\n     has_params = 1,\n@@ -901,7 +903,8 @@ fn mk_ctxt(s: session::Session,\n       lang_items: move lang_items,\n       legacy_boxed_traits: HashMap(),\n       provided_method_sources: HashMap(),\n-      supertraits: HashMap()}\n+      supertraits: HashMap(),\n+      deriving_struct_methods: HashMap()}\n }\n \n "}, {"sha": "2e55dd702f09bc14703538f602aa15fdbcfc8b0a", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=3bf0a9b0945f297d1aea330b6afcf98052e6de1e", "patch": "@@ -334,6 +334,7 @@ fn check_crate(tcx: ty::ctxt,\n                             tcx: tcx});\n     collect::collect_item_types(ccx, crate);\n     coherence::check_coherence(ccx, crate);\n+    deriving::check_deriving(ccx, crate);\n \n     check::check_item_types(ccx, crate);\n     check_for_main_fn(ccx);"}, {"sha": "0641dc3bd7cf932779c0622edada8aad8daf15ce", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=3bf0a9b0945f297d1aea330b6afcf98052e6de1e", "patch": "@@ -489,13 +489,15 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n       ast::item_fn(decl, _, _, body) => {\n         check_bare_fn(ccx, decl, body, it.id, None);\n       }\n-      ast::item_impl(_, _, ty, ms) => {\n+      ast::item_impl(_, _, ty, ms_opt) => {\n         let rp = ccx.tcx.region_paramd_items.find(it.id);\n         debug!(\"item_impl %s with id %d rp %?\",\n                ccx.tcx.sess.str_of(it.ident), it.id, rp);\n         let self_ty = ccx.to_ty(rscope::type_rscope(rp), ty);\n-        for ms.each |m| {\n-            check_method(ccx, *m, self_ty, local_def(it.id));\n+        for ms_opt.each |ms| {\n+            for ms.each |m| {\n+                check_method(ccx, *m, self_ty, local_def(it.id));\n+            }\n         }\n       }\n       ast::item_trait(_, _, trait_methods) => {"}, {"sha": "b6b7a4c5f348639d081340c8f9ef1de0e3085cc3", "filename": "src/rustc/middle/typeck/coherence.rs", "status": "modified", "additions": 47, "deletions": 4, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=3bf0a9b0945f297d1aea330b6afcf98052e6de1e", "patch": "@@ -591,6 +591,32 @@ impl CoherenceChecker {\n         return trait_id;\n     }\n \n+    fn add_automatically_derived_methods_from_trait(\n+        all_methods: &mut ~[@MethodInfo], trait_did: def_id, self_ty: ty::t) {\n+        let tcx = self.crate_context.tcx;\n+        for (*ty::trait_methods(tcx, trait_did)).each |method| {\n+            // Generate a def ID for each node.\n+            let new_def_id = local_def(tcx.sess.next_node_id());\n+            all_methods.push(@{\n+                did: new_def_id,\n+                n_tps: method.tps.len(),\n+                ident: method.ident,\n+                self_type: method.self_ty\n+            });\n+\n+            // Additionally, generate the type for the derived method and add\n+            // it to the type cache.\n+            //\n+            // XXX: Handle generics correctly.\n+            let substs = { self_r: None, self_ty: Some(self_ty), tps: ~[] };\n+            tcx.tcache.insert(new_def_id, {\n+                bounds: @~[],\n+                region_param: None,\n+                ty: ty::subst(tcx, &substs, ty::mk_fn(tcx, method.fty))\n+            });\n+        }\n+    }\n+\n     // Converts an implementation in the AST to an Impl structure.\n     fn create_impl_from_item(item: @item) -> @Impl {\n         fn add_provided_methods(all_methods: &mut ~[@MethodInfo],\n@@ -605,19 +631,36 @@ impl CoherenceChecker {\n         }\n \n         match item.node {\n-            item_impl(_, trait_refs, _, ast_methods) => {\n+            item_impl(_, trait_refs, _, ast_methods_opt) => {\n                 let mut methods = ~[];\n \n-                for ast_methods.each |ast_method| {\n-                    methods.push(method_to_MethodInfo(*ast_method));\n+                match ast_methods_opt {\n+                    Some(ast_methods) => {\n+                        for ast_methods.each |ast_method| {\n+                            methods.push(method_to_MethodInfo(*ast_method));\n+                        }\n+                    }\n+                    None => {\n+                        // This is a \"deriving\" impl. For each trait, collect\n+                        // all the \"required\" methods and add them to the\n+                        // Impl structure.\n+                        let tcx = self.crate_context.tcx;\n+                        let self_ty =\n+                            ty::lookup_item_type(tcx, local_def(item.id));\n+                        for trait_refs.each |trait_ref| {\n+                            let trait_did =\n+                                self.trait_ref_to_trait_def_id(*trait_ref);\n+                            self.add_automatically_derived_methods_from_trait(\n+                                &mut methods, trait_did, self_ty.ty);\n+                        }\n+                    }\n                 }\n \n                 // For each trait that the impl implements, see what\n                 // methods are provided.  For each of those methods,\n                 // if a method of that name is not inherent to the\n                 // impl, use the provided definition in the trait.\n                 for trait_refs.each |trait_ref| {\n-\n                     let trait_did =\n                         self.trait_ref_to_trait_def_id(*trait_ref);\n "}, {"sha": "262a8121ec5377796daae33f1597e522c045f5fa", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=3bf0a9b0945f297d1aea330b6afcf98052e6de1e", "patch": "@@ -463,7 +463,7 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n         get_enum_variant_types(ccx, tpt.ty, enum_definition.variants,\n                                ty_params, rp);\n       }\n-      ast::item_impl(tps, trait_ref, selfty, ms) => {\n+      ast::item_impl(tps, trait_ref, selfty, ms_opt) => {\n         let i_bounds = ty_param_bounds(ccx, tps);\n         let selfty = ccx.to_ty(type_rscope(rp), selfty);\n         write_ty_to_tcx(tcx, it.id, selfty);\n@@ -472,9 +472,11 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n                            region_param: rp,\n                            ty: selfty});\n \n-        let cms = convert_methods(ccx, ms, rp, i_bounds);\n-        for trait_ref.each |t| {\n-            check_methods_against_trait(ccx, tps, rp, selfty, *t, cms);\n+        for ms_opt.each |ms| {\n+            let cms = convert_methods(ccx, *ms, rp, i_bounds);\n+            for trait_ref.each |t| {\n+                check_methods_against_trait(ccx, tps, rp, selfty, *t, cms);\n+            }\n         }\n       }\n       ast::item_trait(tps, supertraits, trait_methods) => {"}, {"sha": "9a5d3ba027c3aa12861d4698cf4225901a6e0ae6", "filename": "src/rustc/middle/typeck/deriving.rs", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Frustc%2Fmiddle%2Ftypeck%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Frustc%2Fmiddle%2Ftypeck%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fderiving.rs?ref=3bf0a9b0945f297d1aea330b6afcf98052e6de1e", "patch": "@@ -0,0 +1,158 @@\n+// Deriving phase\n+//\n+// The purpose of the deriving phase of typechecking is to ensure that, for\n+// each automatically derived implementation of an automatically-derivable\n+// trait (for example, Eq), all the subcomponents of the type in question\n+// also implement the trait. This phase runs after coherence.\n+\n+use syntax::ast::crate;\n+use syntax::ast::{def_id, ident};\n+use syntax::ast::item_impl;\n+use syntax::ast::node_id;\n+use syntax::ast::self_ty_;\n+use syntax::ast::trait_ref;\n+use syntax::ast_util::def_id_of_def;\n+use syntax::codemap::span;\n+use syntax::print::pprust;\n+use syntax::visit::{default_simple_visitor, mk_simple_visitor, visit_crate};\n+use middle::resolve::{Impl, MethodInfo};\n+use middle::ty;\n+use middle::ty::{substs, ty_class, ty_enum, ty_param_bounds_and_ty};\n+use /*middle::typeck::*/check::method;\n+use /*middle::typeck::*/infer::infer_ctxt;\n+\n+struct DerivingChecker {\n+    crate_context: @crate_ctxt,\n+    inference_context: infer_ctxt\n+}\n+\n+fn DerivingChecker_new(crate_context: @crate_ctxt) -> DerivingChecker {\n+    DerivingChecker {\n+        crate_context: crate_context,\n+        inference_context: infer::new_infer_ctxt(crate_context.tcx)\n+    }\n+}\n+\n+impl DerivingChecker {\n+    /// Matches one substructure type against an implementation.\n+    fn match_impl_method(impl_info: @Impl,\n+                         substructure_type: ty::t,\n+                         method_info: @MethodInfo) -> bool {\n+        // XXX: Generics and regions are not handled properly.\n+        let tcx = self.crate_context.tcx;\n+        let impl_self_ty = ty::lookup_item_type(tcx, impl_info.did).ty;\n+        let transformed_type = method::transform_self_type_for_method(\n+            tcx, None, impl_self_ty, method_info.self_type);\n+        return infer::can_mk_subty(self.inference_context,\n+                                   substructure_type,\n+                                   transformed_type).is_ok();\n+    }\n+\n+    fn check_deriving_for_substructure_type(substructure_type: ty::t,\n+                                            trait_ref: @trait_ref,\n+                                            impl_span: span) ->\n+                                            Option<def_id> {\n+        let tcx = self.crate_context.tcx;\n+        let sess = tcx.sess;\n+        let coherence_info = self.crate_context.coherence_info;\n+        let trait_id = def_id_of_def(tcx.def_map.get(trait_ref.ref_id));\n+        match coherence_info.extension_methods.find(trait_id) {\n+            None => {\n+                sess.span_bug(impl_span, ~\"no extension method info found \\\n+                                           for this trait\");\n+            }\n+            Some(impls) => {\n+                // Try to unify each of these impls with the substructure\n+                // type.\n+                for impls.each |impl_info| {\n+                    for impl_info.methods.each |method_info| {\n+                        if self.match_impl_method(*impl_info,\n+                                                  substructure_type,\n+                                                  *method_info) {\n+                            return Some(method_info.did);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        return None;\n+    }\n+\n+    fn check_deriving_for_struct(struct_def_id: def_id,\n+                                 struct_substs: &substs,\n+                                 trait_ref: @trait_ref,\n+                                 impl_id: node_id,\n+                                 impl_span: span) {\n+        let tcx = self.crate_context.tcx;\n+        let field_info = dvec::DVec();\n+        for ty::lookup_class_fields(tcx, struct_def_id).each |field| {\n+            let field_type = ty::lookup_field_type(\n+                tcx, struct_def_id, field.id, struct_substs);\n+            match self.check_deriving_for_substructure_type(field_type,\n+                                                            trait_ref,\n+                                                            impl_span) {\n+                Some(method_target_def_id) => {\n+                    field_info.push(method_static(method_target_def_id));\n+                }\n+                None => {\n+                    let trait_str = pprust::path_to_str(\n+                        trait_ref.path, tcx.sess.parse_sess.interner);\n+                    tcx.sess.span_err(impl_span,\n+                                      fmt!(\"cannot automatically derive an \\\n+                                            implementation for `%s`: field \\\n+                                            `%s` does not implement the \\\n+                                            trait `%s`\",\n+                                           trait_str,\n+                                           tcx.sess.str_of(field.ident),\n+                                           trait_str));\n+                }\n+            }\n+        }\n+\n+        let field_info = @dvec::unwrap(move field_info);\n+        tcx.deriving_struct_methods.insert(local_def(impl_id), field_info);\n+    }\n+\n+    fn check_deriving(crate: @crate) {\n+        let tcx = self.crate_context.tcx;\n+        visit_crate(*crate, (), mk_simple_visitor(@{\n+            visit_item: |item| {\n+                match item.node {\n+                    item_impl(_, Some(trait_ref), _, None) => {\n+                        // XXX: This does not handle generic impls.\n+                        let superty = ty::lookup_item_type(\n+                            tcx, local_def(item.id)).ty;\n+                        match ty::get(superty).sty {\n+                            ty_enum(_def_id, _substs) => {\n+                                // XXX: Handle enums.\n+                            }\n+                            ty_class(def_id, ref substs) => {\n+                                self.check_deriving_for_struct(\n+                                    def_id,\n+                                    substs,\n+                                    trait_ref,\n+                                    item.id,\n+                                    item.span);\n+                            }\n+                            _ => {\n+                                tcx.sess.span_err(item.span,\n+                                                  ~\"only enums and structs \\\n+                                                    may have implementations \\\n+                                                    automatically derived \\\n+                                                    for them\");\n+                            }\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            },\n+            ..*default_simple_visitor()\n+        }));\n+    }\n+}\n+\n+pub fn check_deriving(crate_context: @crate_ctxt, crate: @crate) {\n+    let deriving_checker = @DerivingChecker_new(crate_context);\n+    deriving_checker.check_deriving(crate);\n+}\n+"}, {"sha": "10fd378ed171113cdee4fd3a7ba45e526abfcc13", "filename": "src/rustc/rustc.rc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Frustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Frustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Frustc.rc?ref=3bf0a9b0945f297d1aea330b6afcf98052e6de1e", "patch": "@@ -89,6 +89,7 @@ mod middle {\n         #[legacy_exports]\n         mod reachable;\n         mod machine;\n+        mod deriving;\n     }\n     #[legacy_exports]\n     mod ty;\n@@ -146,6 +147,7 @@ mod middle {\n         mod collect;\n         #[legacy_exports]\n         mod coherence;\n+        mod deriving;\n     }\n     #[legacy_exports]\n     mod check_loop;"}, {"sha": "92ab33e36142159b2db336ca3cdcaf145ec4b451", "filename": "src/rustdoc/attr_pass.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Frustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Frustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_pass.rs?ref=3bf0a9b0945f297d1aea330b6afcf98052e6de1e", "patch": "@@ -221,11 +221,17 @@ fn merge_method_attrs(\n             })\n           }\n           ast_map::node_item(@{\n-            node: ast::item_impl(_, _, _, methods), _\n+            node: ast::item_impl(_, _, _, methods_opt), _\n           }, _) => {\n-            vec::map(methods, |method| {\n-                (to_str(method.ident), attr_parser::parse_desc(method.attrs))\n-            })\n+            match methods_opt {\n+                None => ~[],\n+                Some(methods) => {\n+                    vec::map(methods, |method| {\n+                        (to_str(method.ident),\n+                         attr_parser::parse_desc(method.attrs))\n+                    })\n+                }\n+            }\n           }\n           _ => fail ~\"unexpected item\"\n         }"}, {"sha": "8ac74f4663cc250201d920c9353a2923ea483cfc", "filename": "src/rustdoc/extract.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Frustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Frustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fextract.rs?ref=3bf0a9b0945f297d1aea330b6afcf98052e6de1e", "patch": "@@ -258,20 +258,25 @@ fn should_extract_trait_methods() {\n \n fn impldoc_from_impl(\n     itemdoc: doc::ItemDoc,\n-    methods: ~[@ast::method]\n+    methods_opt: Option<~[@ast::method]>\n ) -> doc::ImplDoc {\n     {\n         item: itemdoc,\n         trait_types: ~[],\n         self_ty: None,\n-        methods: do vec::map(methods) |method| {\n-            {\n-                name: to_str(method.ident),\n-                brief: None,\n-                desc: None,\n-                sections: ~[],\n-                sig: None,\n-                implementation: doc::Provided,\n+        methods: match methods_opt {\n+            None => ~[],\n+            Some(methods) => {\n+                do vec::map(methods) |method| {\n+                    {\n+                        name: to_str(method.ident),\n+                        brief: None,\n+                        desc: None,\n+                        sections: ~[],\n+                        sig: None,\n+                        implementation: doc::Provided,\n+                    }\n+                }\n             }\n         }\n     }"}, {"sha": "fb47e58f769b6b691a9322d7236c4eb459f3b475", "filename": "src/rustdoc/tystr_pass.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Frustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bf0a9b0945f297d1aea330b6afcf98052e6de1e/src%2Frustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftystr_pass.rs?ref=3bf0a9b0945f297d1aea330b6afcf98052e6de1e", "patch": "@@ -207,20 +207,25 @@ fn get_method_sig(\n             }\n           }\n           ast_map::node_item(@{\n-            node: ast::item_impl(_, _, _, methods), _\n+            node: ast::item_impl(_, _, _, methods_opt), _\n           }, _) => {\n-            match vec::find(methods, |method| {\n-                to_str(method.ident) == method_name\n-            }) {\n-                Some(method) => {\n-                    Some(pprust::fun_to_str(\n-                        method.decl,\n-                        method.ident,\n-                        method.tps,\n-                        extract::interner()\n-                    ))\n+            match methods_opt {\n+                None => fail ~\"no methods in this impl\",\n+                Some(methods) => {\n+                    match vec::find(methods, |method| {\n+                        to_str(method.ident) == method_name\n+                    }) {\n+                        Some(method) => {\n+                            Some(pprust::fun_to_str(\n+                                method.decl,\n+                                method.ident,\n+                                method.tps,\n+                                extract::interner()\n+                            ))\n+                        }\n+                        None => fail ~\"method not found\"\n+                    }\n                 }\n-                None => fail ~\"method not found\"\n             }\n           }\n           _ => fail ~\"get_method_sig: item ID not bound to trait or impl\""}]}