{"sha": "5c06b23025b587f8665b2177369ad4a1da4d2153", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjMDZiMjMwMjViNTg3Zjg2NjViMjE3NzM2OWFkNGExZGE0ZDIxNTM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-27T17:32:00Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-27T17:32:00Z"}, "message": "run rustfmt", "tree": {"sha": "9369f5c258f7eba1b8551ed776dca50753555643", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9369f5c258f7eba1b8551ed776dca50753555643"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c06b23025b587f8665b2177369ad4a1da4d2153", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c06b23025b587f8665b2177369ad4a1da4d2153", "html_url": "https://github.com/rust-lang/rust/commit/5c06b23025b587f8665b2177369ad4a1da4d2153", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c06b23025b587f8665b2177369ad4a1da4d2153/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "497273620bc019bedc1c47ff541e768a4176beff", "url": "https://api.github.com/repos/rust-lang/rust/commits/497273620bc019bedc1c47ff541e768a4176beff", "html_url": "https://github.com/rust-lang/rust/commit/497273620bc019bedc1c47ff541e768a4176beff"}], "stats": {"total": 86, "additions": 38, "deletions": 48}, "files": [{"sha": "92f5dc76bfca8771db18761e87c2eb8fd9df7ae3", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 38, "deletions": 48, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/5c06b23025b587f8665b2177369ad4a1da4d2153/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c06b23025b587f8665b2177369ad4a1da4d2153/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=5c06b23025b587f8665b2177369ad4a1da4d2153", "patch": "@@ -10,7 +10,7 @@\n \n use borrow_check::ArtificialField;\n use borrow_check::Overlap;\n-use borrow_check::{ShallowOrDeep, Deep, Shallow};\n+use borrow_check::{Deep, Shallow, ShallowOrDeep};\n use rustc::hir;\n use rustc::mir::{Mir, Place};\n use rustc::mir::{Projection, ProjectionElem};\n@@ -148,19 +148,19 @@ fn place_components_conflict<'gcx, 'tcx>(\n \n                 match (elem, &base_ty.sty, access) {\n                     (_, _, Shallow(Some(ArtificialField::Discriminant)))\n-                        | (_, _, Shallow(Some(ArtificialField::ArrayLength))) => {\n-                            // The discriminant and array length are like\n-                            // additional fields on the type; they do not\n-                            // overlap any existing data there. Furthermore,\n-                            // they cannot actually be a prefix of any\n-                            // borrowed place (at least in MIR as it is\n-                            // currently.)\n-                            //\n-                            // e.g. a (mutable) borrow of `a[5]` while we read the\n-                            // array length of `a`.\n-                            debug!(\"places_conflict: implicit field\");\n-                            return false;\n-                        }\n+                    | (_, _, Shallow(Some(ArtificialField::ArrayLength))) => {\n+                        // The discriminant and array length are like\n+                        // additional fields on the type; they do not\n+                        // overlap any existing data there. Furthermore,\n+                        // they cannot actually be a prefix of any\n+                        // borrowed place (at least in MIR as it is\n+                        // currently.)\n+                        //\n+                        // e.g. a (mutable) borrow of `a[5]` while we read the\n+                        // array length of `a`.\n+                        debug!(\"places_conflict: implicit field\");\n+                        return false;\n+                    }\n \n                     (ProjectionElem::Deref, _, Shallow(None)) => {\n                         // e.g. a borrow of `*x.y` while we shallowly access `x.y` or some\n@@ -169,11 +169,7 @@ fn place_components_conflict<'gcx, 'tcx>(\n                         debug!(\"places_conflict: shallow access behind ptr\");\n                         return false;\n                     }\n-                    (\n-                        ProjectionElem::Deref,\n-                        ty::TyRef( _, _, hir::MutImmutable),\n-                        _,\n-                    ) => {\n+                    (ProjectionElem::Deref, ty::TyRef(_, _, hir::MutImmutable), _) => {\n                         // the borrow goes through a dereference of a shared reference.\n                         //\n                         // I'm not sure why we are tracking these borrows - shared\n@@ -184,16 +180,16 @@ fn place_components_conflict<'gcx, 'tcx>(\n                     }\n \n                     (ProjectionElem::Deref, _, Deep)\n-                        | (ProjectionElem::Field { .. }, _, _)\n-                        | (ProjectionElem::Index { .. }, _, _)\n-                        | (ProjectionElem::ConstantIndex { .. }, _, _)\n-                        | (ProjectionElem::Subslice { .. }, _, _)\n-                        | (ProjectionElem::Downcast { .. }, _, _) => {\n-                            // Recursive case. This can still be disjoint on a\n-                            // further iteration if this a shallow access and\n-                            // there's a deref later on, e.g. a borrow\n-                            // of `*x.y` while accessing `x`.\n-                        }\n+                    | (ProjectionElem::Field { .. }, _, _)\n+                    | (ProjectionElem::Index { .. }, _, _)\n+                    | (ProjectionElem::ConstantIndex { .. }, _, _)\n+                    | (ProjectionElem::Subslice { .. }, _, _)\n+                    | (ProjectionElem::Downcast { .. }, _, _) => {\n+                        // Recursive case. This can still be disjoint on a\n+                        // further iteration if this a shallow access and\n+                        // there's a deref later on, e.g. a borrow\n+                        // of `*x.y` while accessing `x`.\n+                    }\n                 }\n             }\n         } else {\n@@ -250,7 +246,7 @@ impl<'p, 'tcx> PlaceComponents<'p, 'tcx> {\n /// manually invokes `next`. This is because we (sometimes) want to\n /// keep executing even after `None` has been returned.\n struct PlaceComponentsIter<'p, 'tcx: 'p> {\n-    value: Option<&'p PlaceComponents<'p, 'tcx>>\n+    value: Option<&'p PlaceComponents<'p, 'tcx>>,\n }\n \n impl<'p, 'tcx> PlaceComponentsIter<'p, 'tcx> {\n@@ -269,19 +265,17 @@ impl<'p, 'tcx> PlaceComponentsIter<'p, 'tcx> {\n fn unroll_place<'tcx, R>(\n     place: &Place<'tcx>,\n     next: Option<&PlaceComponents<'_, 'tcx>>,\n-    op: impl FnOnce(PlaceComponentsIter<'_, 'tcx>) -> R\n+    op: impl FnOnce(PlaceComponentsIter<'_, 'tcx>) -> R,\n ) -> R {\n     match place {\n-        Place::Projection(interior) => {\n-            unroll_place(\n-                &interior.base,\n-                Some(&PlaceComponents {\n-                    component: place,\n-                    next,\n-                }),\n-                op,\n-            )\n-        }\n+        Place::Projection(interior) => unroll_place(\n+            &interior.base,\n+            Some(&PlaceComponents {\n+                component: place,\n+                next,\n+            }),\n+            op,\n+        ),\n \n         Place::Local(_) | Place::Static(_) => {\n             let list = PlaceComponents {\n@@ -300,7 +294,7 @@ fn place_element_conflict<'a, 'gcx: 'tcx, 'tcx>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     mir: &Mir<'tcx>,\n     elem1: &Place<'tcx>,\n-    elem2: &Place<'tcx>\n+    elem2: &Place<'tcx>,\n ) -> Overlap {\n     match (elem1, elem2) {\n         (Place::Local(l1), Place::Local(l2)) => {\n@@ -318,8 +312,7 @@ fn place_element_conflict<'a, 'gcx: 'tcx, 'tcx>(\n             if static1.def_id != static2.def_id {\n                 debug!(\"place_element_conflict: DISJOINT-STATIC\");\n                 Overlap::Disjoint\n-            } else if tcx.is_static(static1.def_id) ==\n-                        Some(hir::Mutability::MutMutable) {\n+            } else if tcx.is_static(static1.def_id) == Some(hir::Mutability::MutMutable) {\n                 // We ignore mutable statics - they can only be unsafe code.\n                 debug!(\"place_element_conflict: IGNORE-STATIC-MUT\");\n                 Overlap::Disjoint\n@@ -397,10 +390,7 @@ fn place_element_conflict<'a, 'gcx: 'tcx, 'tcx>(\n                 | (ProjectionElem::Index(..), ProjectionElem::ConstantIndex { .. })\n                 | (ProjectionElem::Index(..), ProjectionElem::Subslice { .. })\n                 | (ProjectionElem::ConstantIndex { .. }, ProjectionElem::Index(..))\n-                | (\n-                    ProjectionElem::ConstantIndex { .. },\n-                    ProjectionElem::ConstantIndex { .. },\n-                )\n+                | (ProjectionElem::ConstantIndex { .. }, ProjectionElem::ConstantIndex { .. })\n                 | (ProjectionElem::ConstantIndex { .. }, ProjectionElem::Subslice { .. })\n                 | (ProjectionElem::Subslice { .. }, ProjectionElem::Index(..))\n                 | (ProjectionElem::Subslice { .. }, ProjectionElem::ConstantIndex { .. })"}]}