{"sha": "758a9fd0f9ac191f0ea99215e07816631f402b7e", "node_id": "C_kwDOAAsO6NoAKDc1OGE5ZmQwZjlhYzE5MWYwZWE5OTIxNWUwNzgxNjYzMWY0MDJiN2U", "commit": {"author": {"name": "Aaron Kofsky", "email": "aaronko@umich.edu", "date": "2022-06-02T18:58:44Z"}, "committer": {"name": "Aaron Kofsky", "email": "aaronko@umich.edu", "date": "2022-06-04T19:35:08Z"}, "message": " Add `let_underscore_must_use` lint.\n\nSimilar to `let_underscore_drop`, this lint checks for statements similar\nto `let _ = foo`, where `foo` is an expression marked `must_use`.", "tree": {"sha": "ceaa4a555c0f8fd3501404dbe9f3d97098fa9aa2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ceaa4a555c0f8fd3501404dbe9f3d97098fa9aa2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/758a9fd0f9ac191f0ea99215e07816631f402b7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/758a9fd0f9ac191f0ea99215e07816631f402b7e", "html_url": "https://github.com/rust-lang/rust/commit/758a9fd0f9ac191f0ea99215e07816631f402b7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/758a9fd0f9ac191f0ea99215e07816631f402b7e/comments", "author": {"login": "a2aaron", "id": 15718048, "node_id": "MDQ6VXNlcjE1NzE4MDQ4", "avatar_url": "https://avatars.githubusercontent.com/u/15718048?v=4", "gravatar_id": "", "url": "https://api.github.com/users/a2aaron", "html_url": "https://github.com/a2aaron", "followers_url": "https://api.github.com/users/a2aaron/followers", "following_url": "https://api.github.com/users/a2aaron/following{/other_user}", "gists_url": "https://api.github.com/users/a2aaron/gists{/gist_id}", "starred_url": "https://api.github.com/users/a2aaron/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/a2aaron/subscriptions", "organizations_url": "https://api.github.com/users/a2aaron/orgs", "repos_url": "https://api.github.com/users/a2aaron/repos", "events_url": "https://api.github.com/users/a2aaron/events{/privacy}", "received_events_url": "https://api.github.com/users/a2aaron/received_events", "type": "User", "site_admin": false}, "committer": {"login": "a2aaron", "id": 15718048, "node_id": "MDQ6VXNlcjE1NzE4MDQ4", "avatar_url": "https://avatars.githubusercontent.com/u/15718048?v=4", "gravatar_id": "", "url": "https://api.github.com/users/a2aaron", "html_url": "https://github.com/a2aaron", "followers_url": "https://api.github.com/users/a2aaron/followers", "following_url": "https://api.github.com/users/a2aaron/following{/other_user}", "gists_url": "https://api.github.com/users/a2aaron/gists{/gist_id}", "starred_url": "https://api.github.com/users/a2aaron/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/a2aaron/subscriptions", "organizations_url": "https://api.github.com/users/a2aaron/orgs", "repos_url": "https://api.github.com/users/a2aaron/repos", "events_url": "https://api.github.com/users/a2aaron/events{/privacy}", "received_events_url": "https://api.github.com/users/a2aaron/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad7587fedcf29a6629e0218f0e180ddf8960461d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad7587fedcf29a6629e0218f0e180ddf8960461d", "html_url": "https://github.com/rust-lang/rust/commit/ad7587fedcf29a6629e0218f0e180ddf8960461d"}], "stats": {"total": 146, "additions": 143, "deletions": 3}, "files": [{"sha": "40e6d12abf91066771f978d56ab647bfdf77ff28", "filename": "compiler/rustc_lint/src/let_underscore.rs", "status": "modified", "additions": 104, "deletions": 2, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/758a9fd0f9ac191f0ea99215e07816631f402b7e/compiler%2Frustc_lint%2Fsrc%2Flet_underscore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/758a9fd0f9ac191f0ea99215e07816631f402b7e/compiler%2Frustc_lint%2Fsrc%2Flet_underscore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flet_underscore.rs?ref=758a9fd0f9ac191f0ea99215e07816631f402b7e", "patch": "@@ -1,6 +1,6 @@\n use crate::{LateContext, LateLintPass, LintContext};\n use rustc_hir as hir;\n-use rustc_middle::ty::{self, subst::GenericArgKind};\n+use rustc_middle::ty::{self, subst::GenericArgKind, Ty};\n use rustc_span::Symbol;\n \n declare_lint! {\n@@ -83,7 +83,32 @@ declare_lint! {\n     \"non-binding let on a synchronization lock\"\n }\n \n-declare_lint_pass!(LetUnderscore => [LET_UNDERSCORE_DROP, LET_UNDERSCORE_LOCK]);\n+declare_lint! {\n+    /// The `let_underscore_must_use` lint checks for statements which don't bind\n+    /// a `must_use` expression to anything, causing the lock to be released\n+    /// immediately instead of at end of scope, which is typically incorrect.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// #[must_use]\n+    /// struct SomeStruct;\n+    ///\n+    /// fn main() {\n+    ///     // SomeStuct is dropped immediately instead of at end of scope.\n+    ///     let _ = SomeStruct;\n+    /// }\n+    /// ```\n+    /// ### Explanation\n+    ///\n+    /// Statements which assign an expression to an underscore causes the\n+    /// expression to immediately drop. Usually, it's better to explicitly handle\n+    /// the `must_use` expression.\n+    pub LET_UNDERSCORE_MUST_USE,\n+    Warn,\n+    \"non-binding let on a expression marked `must_use`\"\n+}\n+\n+declare_lint_pass!(LetUnderscore => [LET_UNDERSCORE_DROP, LET_UNDERSCORE_LOCK, LET_UNDERSCORE_MUST_USE]);\n \n const SYNC_GUARD_PATHS: [&[&str]; 5] = [\n     &[\"std\", \"sync\", \"mutex\", \"MutexGuard\"],\n@@ -114,13 +139,22 @@ impl<'tcx> LateLintPass<'tcx> for LetUnderscore {\n \n                 GenericArgKind::Lifetime(_) | GenericArgKind::Const(_) => false,\n             });\n+            let is_must_use_ty = is_must_use_ty(cx, cx.typeck_results().expr_ty(init));\n+            let is_must_use_func_call = is_must_use_func_call(cx, init);\n             if is_sync_lock {\n                 cx.struct_span_lint(LET_UNDERSCORE_LOCK, local.span, |lint| {\n                     lint.build(\"non-binding let on a synchronization lock\")\n                         .help(\"consider binding to an unused variable\")\n                         .help(\"consider explicitly droping with `std::mem::drop`\")\n                         .emit();\n                 })\n+            } else if is_must_use_ty || is_must_use_func_call {\n+                cx.struct_span_lint(LET_UNDERSCORE_MUST_USE, local.span, |lint| {\n+                    lint.build(\"non-binding let on a expression marked `must_use`\")\n+                        .help(\"consider binding to an unused variable\")\n+                        .help(\"consider explicitly droping with `std::mem::drop`\")\n+                        .emit();\n+                })\n             } else if needs_drop {\n                 cx.struct_span_lint(LET_UNDERSCORE_DROP, local.span, |lint| {\n                     lint.build(\"non-binding let on a type that implements `Drop`\")\n@@ -130,5 +164,73 @@ impl<'tcx> LateLintPass<'tcx> for LetUnderscore {\n                 })\n             }\n         }\n+\n+        fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n+            match ty.kind() {\n+                ty::Adt(adt, _) => has_must_use_attr(cx, adt.did()),\n+                ty::Foreign(ref did) => has_must_use_attr(cx, *did),\n+                ty::Slice(ty)\n+                | ty::Array(ty, _)\n+                | ty::RawPtr(ty::TypeAndMut { ty, .. })\n+                | ty::Ref(_, ty, _) => {\n+                    // for the Array case we don't need to care for the len == 0 case\n+                    // because we don't want to lint functions returning empty arrays\n+                    is_must_use_ty(cx, *ty)\n+                }\n+                ty::Tuple(substs) => substs.iter().any(|ty| is_must_use_ty(cx, ty)),\n+                ty::Opaque(ref def_id, _) => {\n+                    for (predicate, _) in cx.tcx.explicit_item_bounds(*def_id) {\n+                        if let ty::PredicateKind::Trait(trait_predicate) =\n+                            predicate.kind().skip_binder()\n+                        {\n+                            if has_must_use_attr(cx, trait_predicate.trait_ref.def_id) {\n+                                return true;\n+                            }\n+                        }\n+                    }\n+                    false\n+                }\n+                ty::Dynamic(binder, _) => {\n+                    for predicate in binder.iter() {\n+                        if let ty::ExistentialPredicate::Trait(ref trait_ref) =\n+                            predicate.skip_binder()\n+                        {\n+                            if has_must_use_attr(cx, trait_ref.def_id) {\n+                                return true;\n+                            }\n+                        }\n+                    }\n+                    false\n+                }\n+                _ => false,\n+            }\n+        }\n+\n+        // check if expr is calling method or function with #[must_use] attribute\n+        fn is_must_use_func_call(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> bool {\n+            let did = match expr.kind {\n+                hir::ExprKind::Call(path, _) if let hir::ExprKind::Path(ref qpath) = path.kind => {\n+                    if let hir::def::Res::Def(_, did) = cx.qpath_res(qpath, path.hir_id) {\n+                        Some(did)\n+                    } else {\n+                        None\n+                    }\n+                },\n+                hir::ExprKind::MethodCall(..) => {\n+                    cx.typeck_results().type_dependent_def_id(expr.hir_id)\n+                }\n+                _ => None,\n+            };\n+\n+            did.map_or(false, |did| has_must_use_attr(cx, did))\n+        }\n+\n+        // returns true if DefId contains a `#[must_use]` attribute\n+        fn has_must_use_attr(cx: &LateContext<'_>, did: hir::def_id::DefId) -> bool {\n+            cx.tcx\n+                .get_attrs(did, rustc_span::sym::must_use)\n+                .find(|a| a.has_name(rustc_span::sym::must_use))\n+                .is_some()\n+        }\n     }\n }"}, {"sha": "4359a54b698dc9dffe6e494bbbe12800a2c76b99", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/758a9fd0f9ac191f0ea99215e07816631f402b7e/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/758a9fd0f9ac191f0ea99215e07816631f402b7e/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=758a9fd0f9ac191f0ea99215e07816631f402b7e", "patch": "@@ -317,7 +317,12 @@ fn register_builtins(store: &mut LintStore, no_interleave_lints: bool) {\n         REDUNDANT_SEMICOLONS\n     );\n \n-    add_lint_group!(\"let_underscore\", LET_UNDERSCORE_DROP, LET_UNDERSCORE_LOCK);\n+    add_lint_group!(\n+        \"let_underscore\",\n+        LET_UNDERSCORE_DROP,\n+        LET_UNDERSCORE_LOCK,\n+        LET_UNDERSCORE_MUST_USE\n+    );\n \n     add_lint_group!(\n         \"rust_2018_idioms\","}, {"sha": "6a78e3fc4b402402938d3fc65631bc2e838331b1", "filename": "src/test/ui/let_underscore_must_use.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/758a9fd0f9ac191f0ea99215e07816631f402b7e/src%2Ftest%2Fui%2Flet_underscore_must_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/758a9fd0f9ac191f0ea99215e07816631f402b7e/src%2Ftest%2Fui%2Flet_underscore_must_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet_underscore_must_use.rs?ref=758a9fd0f9ac191f0ea99215e07816631f402b7e", "patch": "@@ -0,0 +1,12 @@\n+// run-pass\n+\n+#[must_use]\n+struct MustUseType;\n+\n+#[must_use]\n+fn must_use_function() -> () {}\n+\n+fn main() {\n+    let _ = MustUseType; //~WARNING non-binding let on a expression marked `must_use`\n+    let _ = must_use_function(); //~WARNING non-binding let on a expression marked `must_use`\n+}"}, {"sha": "0b840385e5dfa7c3ea11ba1be53b45af20b50166", "filename": "src/test/ui/let_underscore_must_use.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/758a9fd0f9ac191f0ea99215e07816631f402b7e/src%2Ftest%2Fui%2Flet_underscore_must_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/758a9fd0f9ac191f0ea99215e07816631f402b7e/src%2Ftest%2Fui%2Flet_underscore_must_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flet_underscore_must_use.stderr?ref=758a9fd0f9ac191f0ea99215e07816631f402b7e", "patch": "@@ -0,0 +1,21 @@\n+warning: non-binding let on a expression marked `must_use`\n+  --> $DIR/let_underscore_must_use.rs:10:5\n+   |\n+LL |     let _ = MustUseType;\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(let_underscore_must_use)]` on by default\n+   = help: consider binding to an unused variable\n+   = help: consider explicitly droping with `std::mem::drop`\n+\n+warning: non-binding let on a expression marked `must_use`\n+  --> $DIR/let_underscore_must_use.rs:11:5\n+   |\n+LL |     let _ = must_use_function();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider binding to an unused variable\n+   = help: consider explicitly droping with `std::mem::drop`\n+\n+warning: 2 warnings emitted\n+"}]}