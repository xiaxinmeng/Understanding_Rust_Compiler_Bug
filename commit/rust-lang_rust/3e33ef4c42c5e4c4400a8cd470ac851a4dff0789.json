{"sha": "3e33ef4c42c5e4c4400a8cd470ac851a4dff0789", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlMzNlZjRjNDJjNWU0YzQ0MDBhOGNkNDcwYWM4NTFhNGRmZjA3ODk=", "commit": {"author": {"name": "mitaa", "email": "mitaa.ceb@gmail.com", "date": "2016-03-24T05:10:52Z"}, "committer": {"name": "mitaa", "email": "mitaa.ceb@gmail.com", "date": "2016-03-26T23:20:55Z"}, "message": "Correct anchor for links to associated trait items", "tree": {"sha": "b09877d208e79d8dbd5d0330b7bfaf9145015084", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b09877d208e79d8dbd5d0330b7bfaf9145015084"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e33ef4c42c5e4c4400a8cd470ac851a4dff0789", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e33ef4c42c5e4c4400a8cd470ac851a4dff0789", "html_url": "https://github.com/rust-lang/rust/commit/3e33ef4c42c5e4c4400a8cd470ac851a4dff0789", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e33ef4c42c5e4c4400a8cd470ac851a4dff0789/comments", "author": {"login": "mitaa", "id": 6785936, "node_id": "MDQ6VXNlcjY3ODU5MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/6785936?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mitaa", "html_url": "https://github.com/mitaa", "followers_url": "https://api.github.com/users/mitaa/followers", "following_url": "https://api.github.com/users/mitaa/following{/other_user}", "gists_url": "https://api.github.com/users/mitaa/gists{/gist_id}", "starred_url": "https://api.github.com/users/mitaa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mitaa/subscriptions", "organizations_url": "https://api.github.com/users/mitaa/orgs", "repos_url": "https://api.github.com/users/mitaa/repos", "events_url": "https://api.github.com/users/mitaa/events{/privacy}", "received_events_url": "https://api.github.com/users/mitaa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mitaa", "id": 6785936, "node_id": "MDQ6VXNlcjY3ODU5MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/6785936?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mitaa", "html_url": "https://github.com/mitaa", "followers_url": "https://api.github.com/users/mitaa/followers", "following_url": "https://api.github.com/users/mitaa/following{/other_user}", "gists_url": "https://api.github.com/users/mitaa/gists{/gist_id}", "starred_url": "https://api.github.com/users/mitaa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mitaa/subscriptions", "organizations_url": "https://api.github.com/users/mitaa/orgs", "repos_url": "https://api.github.com/users/mitaa/repos", "events_url": "https://api.github.com/users/mitaa/events{/privacy}", "received_events_url": "https://api.github.com/users/mitaa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc1f6831eb0d0e5cca16395f14b7406ff85c4c3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc1f6831eb0d0e5cca16395f14b7406ff85c4c3d", "html_url": "https://github.com/rust-lang/rust/commit/dc1f6831eb0d0e5cca16395f14b7406ff85c4c3d"}], "stats": {"total": 224, "additions": 143, "deletions": 81}, "files": [{"sha": "265b43ca16b38ea96b3637965d68df3d6446ed43", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3e33ef4c42c5e4c4400a8cd470ac851a4dff0789/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e33ef4c42c5e4c4400a8cd470ac851a4dff0789/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=3e33ef4c42c5e4c4400a8cd470ac851a4dff0789", "patch": "@@ -26,7 +26,7 @@ use rustc::middle::const_eval;\n \n use core::DocContext;\n use doctree;\n-use clean::{self, Attributes};\n+use clean::{self, Attributes, GetDefId};\n \n use super::{Clean, ToSource};\n \n@@ -414,15 +414,22 @@ pub fn build_impl(cx: &DocContext,\n             clean::RegionBound(..) => unreachable!(),\n         }\n     });\n-    if let Some(clean::ResolvedPath { did, .. }) = trait_ {\n-        if Some(did) == cx.deref_trait_did.get() {\n-            super::build_deref_target_impls(cx, &trait_items, ret);\n-        }\n+    if trait_.def_id() == cx.deref_trait_did.get() {\n+        super::build_deref_target_impls(cx, &trait_items, ret);\n     }\n+\n+    let provided = trait_.def_id().map(|did| {\n+        cx.tcx().provided_trait_methods(did)\n+                .into_iter()\n+                .map(|meth| meth.name.to_string())\n+                .collect()\n+    }).unwrap_or(HashSet::new());\n+\n     ret.push(clean::Item {\n         inner: clean::ImplItem(clean::Impl {\n             unsafety: hir::Unsafety::Normal, // FIXME: this should be decoded\n             derived: clean::detect_derived(&attrs),\n+            provided_trait_methods: provided,\n             trait_: trait_,\n             for_: ty.ty.clean(cx),\n             generics: (&ty.generics, &predicates, subst::TypeSpace).clean(cx),"}, {"sha": "bec3ae799cace02c710c65a815ae15d48a38ddcc", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 40, "deletions": 23, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/3e33ef4c42c5e4c4400a8cd470ac851a4dff0789/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e33ef4c42c5e4c4400a8cd470ac851a4dff0789/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=3e33ef4c42c5e4c4400a8cd470ac851a4dff0789", "patch": "@@ -44,7 +44,7 @@ use rustc::middle::stability;\n \n use rustc_front::hir;\n \n-use std::collections::HashMap;\n+use std::collections::{HashMap, HashSet};\n use std::path::PathBuf;\n use std::rc::Rc;\n use std::u32;\n@@ -559,15 +559,9 @@ impl TyParamBound {\n     fn is_sized_bound(&self, cx: &DocContext) -> bool {\n         use rustc_front::hir::TraitBoundModifier as TBM;\n         if let Some(tcx) = cx.tcx_opt() {\n-            let sized_did = match tcx.lang_items.sized_trait() {\n-                Some(did) => did,\n-                None => return false\n-            };\n-            if let TyParamBound::TraitBound(PolyTrait {\n-                trait_: Type::ResolvedPath { did, .. }, ..\n-            }, TBM::None) = *self {\n-                if did == sized_did {\n-                    return true\n+            if let TyParamBound::TraitBound(PolyTrait { ref trait_, .. }, TBM::None) = *self {\n+                if trait_.def_id() == tcx.lang_items.sized_trait() {\n+                    return true;\n                 }\n             }\n         }\n@@ -724,15 +718,18 @@ impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n             }\n         }\n \n-        TraitBound(PolyTrait {\n-            trait_: ResolvedPath {\n-                path: path,\n-                typarams: None,\n-                did: self.def_id,\n-                is_generic: false,\n+        TraitBound(\n+            PolyTrait {\n+                trait_: ResolvedPath {\n+                    path: path,\n+                    typarams: None,\n+                    did: self.def_id,\n+                    is_generic: false,\n+                },\n+                lifetimes: late_bounds,\n             },\n-            lifetimes: late_bounds\n-        }, hir::TraitBoundModifier::None)\n+            hir::TraitBoundModifier::None\n+        )\n     }\n }\n \n@@ -932,7 +929,6 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics<'tcx>,\n                                     &'a ty::GenericPredicates<'tcx>,\n                                     subst::ParamSpace) {\n     fn clean(&self, cx: &DocContext) -> Generics {\n-        use std::collections::HashSet;\n         use self::WherePredicate as WP;\n \n         let (gens, preds, space) = *self;\n@@ -1486,6 +1482,16 @@ pub enum TypeKind {\n     TypeTypedef,\n }\n \n+pub trait GetDefId {\n+    fn def_id(&self) -> Option<DefId>;\n+}\n+\n+impl<T: GetDefId> GetDefId for Option<T> {\n+    fn def_id(&self) -> Option<DefId> {\n+        self.as_ref().and_then(|d| d.def_id())\n+    }\n+}\n+\n impl Type {\n     pub fn primitive_type(&self) -> Option<PrimitiveType> {\n         match *self {\n@@ -1499,7 +1505,9 @@ impl Type {\n             _ => None,\n         }\n     }\n+}\n \n+impl GetDefId for Type {\n     fn def_id(&self) -> Option<DefId> {\n         match *self {\n             ResolvedPath { did, .. } => Some(did),\n@@ -2208,6 +2216,7 @@ impl Clean<ImplPolarity> for hir::ImplPolarity {\n pub struct Impl {\n     pub unsafety: hir::Unsafety,\n     pub generics: Generics,\n+    pub provided_trait_methods: HashSet<String>,\n     pub trait_: Option<Type>,\n     pub for_: Type,\n     pub items: Vec<Item>,\n@@ -2227,12 +2236,19 @@ impl Clean<Vec<Item>> for doctree::Impl {\n \n         // If this impl block is an implementation of the Deref trait, then we\n         // need to try inlining the target's inherent impl blocks as well.\n-        if let Some(ResolvedPath { did, .. }) = trait_ {\n-            if Some(did) == cx.deref_trait_did.get() {\n-                build_deref_target_impls(cx, &items, &mut ret);\n-            }\n+        if trait_.def_id() == cx.deref_trait_did.get() {\n+            build_deref_target_impls(cx, &items, &mut ret);\n         }\n \n+        let provided = trait_.def_id().and_then(|did| {\n+            cx.tcx_opt().map(|tcx| {\n+                tcx.provided_trait_methods(did)\n+                   .into_iter()\n+                   .map(|meth| meth.name.to_string())\n+                   .collect()\n+            })\n+        }).unwrap_or(HashSet::new());\n+\n         ret.push(Item {\n             name: None,\n             attrs: self.attrs.clean(cx),\n@@ -2244,6 +2260,7 @@ impl Clean<Vec<Item>> for doctree::Impl {\n             inner: ImplItem(Impl {\n                 unsafety: self.unsafety,\n                 generics: self.generics.clean(cx),\n+                provided_trait_methods: provided,\n                 trait_: trait_,\n                 for_: self.for_.clean(cx),\n                 items: items,"}, {"sha": "51e069c66681e5dd32801a5946fc7e15dfdd93d9", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 47, "deletions": 45, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/3e33ef4c42c5e4c4400a8cd470ac851a4dff0789/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e33ef4c42c5e4c4400a8cd470ac851a4dff0789/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=3e33ef4c42c5e4c4400a8cd470ac851a4dff0789", "patch": "@@ -62,7 +62,7 @@ use rustc::middle::stability;\n use rustc::session::config::get_unstable_features_setting;\n use rustc_front::hir;\n \n-use clean::{self, SelfTy, Attributes};\n+use clean::{self, SelfTy, Attributes, GetDefId};\n use doctree;\n use fold::DocFolder;\n use html::escape::Escape;\n@@ -144,9 +144,7 @@ pub struct Impl {\n \n impl Impl {\n     fn trait_did(&self) -> Option<DefId> {\n-        self.impl_.trait_.as_ref().and_then(|tr| {\n-            if let clean::ResolvedPath { did, .. } = *tr {Some(did)} else {None}\n-        })\n+        self.impl_.trait_.def_id()\n     }\n }\n \n@@ -967,7 +965,7 @@ impl DocFolder for Cache {\n \n         // Collect all the implementors of traits.\n         if let clean::ImplItem(ref i) = item.inner {\n-            if let Some(clean::ResolvedPath{ did, .. }) = i.trait_ {\n+            if let Some(did) = i.trait_.def_id() {\n                 self.implementors.entry(did).or_insert(vec![]).push(Implementor {\n                     def_id: item.def_id,\n                     stability: item.stability.clone(),\n@@ -2066,10 +2064,11 @@ fn render_stability_since(w: &mut fmt::Formatter,\n     render_stability_since_raw(w, item.stable_since(), containing_item.stable_since())\n }\n \n-fn render_assoc_item(w: &mut fmt::Formatter, meth: &clean::Item,\n+fn render_assoc_item(w: &mut fmt::Formatter,\n+                     item: &clean::Item,\n                      link: AssocItemLink) -> fmt::Result {\n     fn method(w: &mut fmt::Formatter,\n-              it: &clean::Item,\n+              meth: &clean::Item,\n               unsafety: hir::Unsafety,\n               constness: hir::Constness,\n               abi: abi::Abi,\n@@ -2080,12 +2079,20 @@ fn render_assoc_item(w: &mut fmt::Formatter, meth: &clean::Item,\n               -> fmt::Result {\n         use syntax::abi::Abi;\n \n-        let name = it.name.as_ref().unwrap();\n-        let anchor = format!(\"#{}.{}\", shortty(it), name);\n+        let name = meth.name.as_ref().unwrap();\n+        let anchor = format!(\"#{}.{}\", shortty(meth), name);\n         let href = match link {\n             AssocItemLink::Anchor => anchor,\n-            AssocItemLink::GotoSource(did) => {\n-                href(did).map(|p| format!(\"{}{}\", p.0, anchor)).unwrap_or(anchor)\n+            AssocItemLink::GotoSource(did, provided_methods) => {\n+                // We're creating a link from an impl-item to the corresponding\n+                // trait-item and need to map the anchored type accordingly.\n+                let ty = if provided_methods.contains(name) {\n+                    ItemType::Method\n+                } else {\n+                    ItemType::TyMethod\n+                };\n+\n+                href(did).map(|p| format!(\"{}#{}.{}\", p.0, ty, name)).unwrap_or(anchor)\n             }\n         };\n         let vis_constness = match get_unstable_features_setting() {\n@@ -2106,21 +2113,21 @@ fn render_assoc_item(w: &mut fmt::Formatter, meth: &clean::Item,\n                decl = Method(selfty, d),\n                where_clause = WhereClause(g))\n     }\n-    match meth.inner {\n+    match item.inner {\n         clean::TyMethodItem(ref m) => {\n-            method(w, meth, m.unsafety, hir::Constness::NotConst,\n+            method(w, item, m.unsafety, hir::Constness::NotConst,\n                    m.abi, &m.generics, &m.self_, &m.decl, link)\n         }\n         clean::MethodItem(ref m) => {\n-            method(w, meth, m.unsafety, m.constness,\n+            method(w, item, m.unsafety, m.constness,\n                    m.abi, &m.generics, &m.self_, &m.decl,\n                    link)\n         }\n         clean::AssociatedConstItem(ref ty, ref default) => {\n-            assoc_const(w, meth, ty, default.as_ref())\n+            assoc_const(w, item, ty, default.as_ref())\n         }\n         clean::AssociatedTypeItem(ref bounds, ref default) => {\n-            assoc_type(w, meth, bounds, default)\n+            assoc_type(w, item, bounds, default)\n         }\n         _ => panic!(\"render_assoc_item called on non-associated-item\")\n     }\n@@ -2338,9 +2345,9 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n }\n \n #[derive(Copy, Clone)]\n-enum AssocItemLink {\n+enum AssocItemLink<'a> {\n     Anchor,\n-    GotoSource(DefId),\n+    GotoSource(DefId, &'a HashSet<String>),\n }\n \n enum AssocItemRender<'a> {\n@@ -2383,12 +2390,7 @@ fn render_assoc_items(w: &mut fmt::Formatter,\n     }\n     if !traits.is_empty() {\n         let deref_impl = traits.iter().find(|t| {\n-            match *t.impl_.trait_.as_ref().unwrap() {\n-                clean::ResolvedPath { did, .. } => {\n-                    Some(did) == c.deref_trait_did\n-                }\n-                _ => false\n-            }\n+            t.impl_.trait_.def_id() == c.deref_trait_did\n         });\n         if let Some(impl_) = deref_impl {\n             render_deref_methods(w, cx, impl_, containing_item)?;\n@@ -2400,17 +2402,17 @@ fn render_assoc_items(w: &mut fmt::Formatter,\n         });\n         for i in &manual {\n             let did = i.trait_did().unwrap();\n-            render_impl(w, cx, i, AssocItemLink::GotoSource(did), true,\n-                        containing_item.stable_since())?;\n+            let assoc_link = AssocItemLink::GotoSource(did, &i.impl_.provided_trait_methods);\n+            render_impl(w, cx, i, assoc_link, true, containing_item.stable_since())?;\n         }\n         if !derived.is_empty() {\n             write!(w, \"<h3 id='derived_implementations'>\\\n                            Derived Implementations \\\n                        </h3>\")?;\n             for i in &derived {\n                 let did = i.trait_did().unwrap();\n-                render_impl(w, cx, i, AssocItemLink::GotoSource(did), true,\n-                            containing_item.stable_since())?;\n+                let assoc_link = AssocItemLink::GotoSource(did, &i.impl_.provided_trait_methods);\n+                render_impl(w, cx, i, assoc_link, true, containing_item.stable_since())?;\n             }\n         }\n     }\n@@ -2427,17 +2429,16 @@ fn render_deref_methods(w: &mut fmt::Formatter, cx: &Context, impl_: &Impl,\n         }\n     }).next().expect(\"Expected associated type binding\");\n     let what = AssocItemRender::DerefFor { trait_: deref_type, type_: target };\n-    match *target {\n-        clean::ResolvedPath { did, .. } => render_assoc_items(w, cx, container_item, did, what),\n-        _ => {\n-            if let Some(prim) = target.primitive_type() {\n-                if let Some(c) = cache().primitive_locations.get(&prim) {\n-                    let did = DefId { krate: *c, index: prim.to_def_index() };\n-                    render_assoc_items(w, cx, container_item, did, what)?;\n-                }\n+    if let Some(did) = target.def_id() {\n+        render_assoc_items(w, cx, container_item, did, what)\n+    } else {\n+        if let Some(prim) = target.primitive_type() {\n+            if let Some(c) = cache().primitive_locations.get(&prim) {\n+                let did = DefId { krate: *c, index: prim.to_def_index() };\n+                render_assoc_items(w, cx, container_item, did, what)?;\n             }\n-            Ok(())\n         }\n+        Ok(())\n     }\n }\n \n@@ -2521,18 +2522,19 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n \n     fn render_default_items(w: &mut fmt::Formatter,\n                             cx: &Context,\n-                            did: DefId,\n                             t: &clean::Trait,\n-                              i: &clean::Impl,\n-                              render_static: bool,\n-                              outer_version: Option<&str>) -> fmt::Result {\n+                            i: &clean::Impl,\n+                            render_static: bool,\n+                            outer_version: Option<&str>) -> fmt::Result {\n         for trait_item in &t.items {\n             let n = trait_item.name.clone();\n-            if i.items.iter().find(|m| { m.name == n }).is_some() {\n+            if i.items.iter().find(|m| m.name == n).is_some() {\n                 continue;\n             }\n+            let did = i.trait_.as_ref().unwrap().def_id().unwrap();\n+            let assoc_link = AssocItemLink::GotoSource(did, &i.provided_trait_methods);\n \n-            doctraititem(w, cx, trait_item, AssocItemLink::GotoSource(did), render_static,\n+            doctraititem(w, cx, trait_item, assoc_link, render_static,\n                          outer_version)?;\n         }\n         Ok(())\n@@ -2542,9 +2544,9 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n     // default methods which weren't overridden in the implementation block.\n     // FIXME: this also needs to be done for associated types, whenever defaults\n     // for them work.\n-    if let Some(clean::ResolvedPath { did, .. }) = i.impl_.trait_ {\n+    if let Some(did) = i.trait_did() {\n         if let Some(t) = cache().traits.get(&did) {\n-            render_default_items(w, cx, did, t, &i.impl_, render_header, outer_version)?;\n+            render_default_items(w, cx, t, &i.impl_, render_header, outer_version)?;\n         }\n     }\n     write!(w, \"</div>\")?;"}, {"sha": "88cb20991d66059e8edb3051aeb31c855621beb7", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3e33ef4c42c5e4c4400a8cd470ac851a4dff0789/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e33ef4c42c5e4c4400a8cd470ac851a4dff0789/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=3e33ef4c42c5e4c4400a8cd470ac851a4dff0789", "patch": "@@ -16,7 +16,7 @@ use std::string::String;\n use std::usize;\n use rustc_front::hir;\n \n-use clean::{self, Attributes};\n+use clean::{self, Attributes, GetDefId};\n use clean::Item;\n use plugins;\n use fold;\n@@ -74,7 +74,7 @@ pub fn strip_hidden(krate: clean::Crate) -> plugins::PluginResult {\n                         return None;\n                     }\n                     // Impls of stripped traits also don't need to exist\n-                    if let Some(clean::ResolvedPath { did, .. }) = *trait_ {\n+                    if let Some(did) = trait_.def_id() {\n                         if self.stripped.contains(&did) {\n                             return None;\n                         }\n@@ -223,13 +223,10 @@ struct ImplStripper<'a>(&'a DefIdSet);\n impl<'a> fold::DocFolder for ImplStripper<'a> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         if let clean::ImplItem(ref imp) = i.inner {\n-            match imp.trait_ {\n-                Some(clean::ResolvedPath{ did, .. }) => {\n-                    if did.is_local() && !self.0.contains(&did) {\n-                        return None;\n-                    }\n+            if let Some(did) = imp.trait_.def_id() {\n+                if did.is_local() && !self.0.contains(&did) {\n+                    return None;\n                 }\n-                Some(..) | None => {}\n             }\n         }\n         self.fold_item_recur(i)"}, {"sha": "9d3433fb3997d1fd42ba57186c84bf0c95b149be", "filename": "src/test/rustdoc/issue-28478.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/3e33ef4c42c5e4c4400a8cd470ac851a4dff0789/src%2Ftest%2Frustdoc%2Fissue-28478.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e33ef4c42c5e4c4400a8cd470ac851a4dff0789/src%2Ftest%2Frustdoc%2Fissue-28478.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-28478.rs?ref=3e33ef4c42c5e4c4400a8cd470ac851a4dff0789", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_type_defaults)]\n+#![feature(associated_consts)]\n+\n+// @has issue_28478/trait.Bar.html\n+pub trait Bar {\n+    // @has - '//*[@id=\"associatedtype.Bar\"]' 'type Bar = ()'\n+    type Bar = ();\n+\n+    // @has - '//*[@id=\"associatedconstant.Baz\"]' 'const Baz: usize = 7'\n+    const Baz: usize = 7;\n+    // @has - '//*[@id=\"tymethod.bar\"]' 'fn bar'\n+    fn bar();\n+    // @has - '//*[@id=\"method.baz\"]' 'fn baz'\n+    fn baz() { }\n+}\n+\n+// @has issue_28478/struct.Foo.html\n+pub struct Foo;\n+\n+impl Foo {\n+    // @has - '//*[@href=\"#method.foo\"]' 'foo'\n+    pub fn foo() {}\n+}\n+\n+impl Bar for Foo {\n+    // @has - '//*[@href=\"../issue_28478/trait.Bar.html#tymethod.bar\"]' 'bar'\n+    fn bar() {}\n+    // @has - '//*[@href=\"../issue_28478/trait.Bar.html#method.baz\"]' 'baz'\n+}"}]}