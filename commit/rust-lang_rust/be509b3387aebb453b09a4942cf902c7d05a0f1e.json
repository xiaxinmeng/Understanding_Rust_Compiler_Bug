{"sha": "be509b3387aebb453b09a4942cf902c7d05a0f1e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlNTA5YjMzODdhZWJiNDUzYjA5YTQ5NDJjZjkwMmM3ZDA1YTBmMWU=", "commit": {"author": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2017-07-05T19:03:17Z"}, "committer": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2017-07-07T16:19:04Z"}, "message": "Skip the main thread's manual stack guard on Linux\n\nLinux doesn't allocate the whole stack right away, and the kernel has\nits own stack-guard mechanism to fault when growing too close to an\nexisting mapping.  If we map our own guard, then the kernel starts\nenforcing a rather large gap above that, rendering much of the possible\nstack space useless.\n\nInstead, we'll just note where we expect rlimit to start faulting, so\nour handler can report \"stack overflow\", and trust that the kernel's own\nstack guard will work.\n\nFixes #43052.", "tree": {"sha": "22312aa799c622b13bcec2c413f27a9d8b773ed2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22312aa799c622b13bcec2c413f27a9d8b773ed2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be509b3387aebb453b09a4942cf902c7d05a0f1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be509b3387aebb453b09a4942cf902c7d05a0f1e", "html_url": "https://github.com/rust-lang/rust/commit/be509b3387aebb453b09a4942cf902c7d05a0f1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be509b3387aebb453b09a4942cf902c7d05a0f1e/comments", "author": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "703341051d857bba054f97c38f80d10aab44521c", "url": "https://api.github.com/repos/rust-lang/rust/commits/703341051d857bba054f97c38f80d10aab44521c", "html_url": "https://github.com/rust-lang/rust/commit/703341051d857bba054f97c38f80d10aab44521c"}], "stats": {"total": 44, "additions": 29, "deletions": 15}, "files": [{"sha": "15747746611c9dd72efac438e8b52fe5c96869b5", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 29, "deletions": 15, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/be509b3387aebb453b09a4942cf902c7d05a0f1e/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be509b3387aebb453b09a4942cf902c7d05a0f1e/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=be509b3387aebb453b09a4942cf902c7d05a0f1e", "patch": "@@ -264,23 +264,37 @@ pub mod guard {\n                 as *mut libc::c_void;\n         }\n \n-        // Rellocate the last page of the stack.\n-        // This ensures SIGBUS will be raised on\n-        // stack overflow.\n-        let result = mmap(stackaddr, psize, PROT_NONE,\n-                          MAP_PRIVATE | MAP_ANON | MAP_FIXED, -1, 0);\n-\n-        if result != stackaddr || result == MAP_FAILED {\n-            panic!(\"failed to allocate a guard page\");\n-        }\n-\n-        let offset = if cfg!(any(target_os = \"linux\", target_os = \"freebsd\")) {\n-            2\n+        if cfg!(target_os = \"linux\") {\n+            // Linux doesn't allocate the whole stack right away, and\n+            // the kernel has its own stack-guard mechanism to fault\n+            // when growing too close to an existing mapping.  If we map\n+            // our own guard, then the kernel starts enforcing a rather\n+            // large gap above that, rendering much of the possible\n+            // stack space useless.  See #43052.\n+            //\n+            // Instead, we'll just note where we expect rlimit to start\n+            // faulting, so our handler can report \"stack overflow\", and\n+            // trust that the kernel's own stack guard will work.\n+            Some(stackaddr as usize)\n         } else {\n-            1\n-        };\n+            // Reallocate the last page of the stack.\n+            // This ensures SIGBUS will be raised on\n+            // stack overflow.\n+            let result = mmap(stackaddr, psize, PROT_NONE,\n+                              MAP_PRIVATE | MAP_ANON | MAP_FIXED, -1, 0);\n+\n+            if result != stackaddr || result == MAP_FAILED {\n+                panic!(\"failed to allocate a guard page\");\n+            }\n \n-        Some(stackaddr as usize + offset * psize)\n+            let offset = if cfg!(target_os = \"freebsd\") {\n+                2\n+            } else {\n+                1\n+            };\n+\n+            Some(stackaddr as usize + offset * psize)\n+        }\n     }\n \n     #[cfg(target_os = \"solaris\")]"}]}