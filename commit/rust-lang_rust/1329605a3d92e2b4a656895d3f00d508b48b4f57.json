{"sha": "1329605a3d92e2b4a656895d3f00d508b48b4f57", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzMjk2MDVhM2Q5MmUyYjRhNjU2ODk1ZDNmMDBkNTA4YjQ4YjRmNTc=", "commit": {"author": {"name": "Zack M. Davis", "email": "code@zackmdavis.net", "date": "2018-05-21T03:19:34Z"}, "committer": {"name": "Zack M. Davis", "email": "code@zackmdavis.net", "date": "2018-05-28T16:20:14Z"}, "message": "operate on `HirId` in `hir::Pat::each_binding`, and consequences of that\n\nChanging the `each_binding` utility method to take the `HirId` of a\nbinding pattern rather than its `NodeId` seems like a modest first step\nin support of the `HirId`ification initiative #50928. (The inspiration\nfor choosing this in particular came from the present author's previous\nwork on diagnostics issued during liveness analysis, which is the most\ngreatly affected module in this change.)", "tree": {"sha": "468142a89a80d3e7914ed6793256e7524f486495", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/468142a89a80d3e7914ed6793256e7524f486495"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1329605a3d92e2b4a656895d3f00d508b48b4f57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1329605a3d92e2b4a656895d3f00d508b48b4f57", "html_url": "https://github.com/rust-lang/rust/commit/1329605a3d92e2b4a656895d3f00d508b48b4f57", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1329605a3d92e2b4a656895d3f00d508b48b4f57/comments", "author": {"login": "zackmdavis", "id": 1076988, "node_id": "MDQ6VXNlcjEwNzY5ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/1076988?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zackmdavis", "html_url": "https://github.com/zackmdavis", "followers_url": "https://api.github.com/users/zackmdavis/followers", "following_url": "https://api.github.com/users/zackmdavis/following{/other_user}", "gists_url": "https://api.github.com/users/zackmdavis/gists{/gist_id}", "starred_url": "https://api.github.com/users/zackmdavis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zackmdavis/subscriptions", "organizations_url": "https://api.github.com/users/zackmdavis/orgs", "repos_url": "https://api.github.com/users/zackmdavis/repos", "events_url": "https://api.github.com/users/zackmdavis/events{/privacy}", "received_events_url": "https://api.github.com/users/zackmdavis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "zackmdavis", "id": 1076988, "node_id": "MDQ6VXNlcjEwNzY5ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/1076988?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zackmdavis", "html_url": "https://github.com/zackmdavis", "followers_url": "https://api.github.com/users/zackmdavis/followers", "following_url": "https://api.github.com/users/zackmdavis/following{/other_user}", "gists_url": "https://api.github.com/users/zackmdavis/gists{/gist_id}", "starred_url": "https://api.github.com/users/zackmdavis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zackmdavis/subscriptions", "organizations_url": "https://api.github.com/users/zackmdavis/orgs", "repos_url": "https://api.github.com/users/zackmdavis/repos", "events_url": "https://api.github.com/users/zackmdavis/events{/privacy}", "received_events_url": "https://api.github.com/users/zackmdavis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b1d69d6b520046108dae04c625f15ea35127388", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b1d69d6b520046108dae04c625f15ea35127388", "html_url": "https://github.com/rust-lang/rust/commit/2b1d69d6b520046108dae04c625f15ea35127388"}], "stats": {"total": 235, "additions": 131, "deletions": 104}, "files": [{"sha": "5a059b6a219a21e7e5468ab99ecaf3459b1cac37", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1329605a3d92e2b4a656895d3f00d508b48b4f57/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1329605a3d92e2b4a656895d3f00d508b48b4f57/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=1329605a3d92e2b4a656895d3f00d508b48b4f57", "patch": "@@ -10,7 +10,7 @@\n \n use hir::def::Def;\n use hir::def_id::DefId;\n-use hir::{self, PatKind};\n+use hir::{self, HirId, PatKind};\n use syntax::ast;\n use syntax::codemap::Spanned;\n use syntax_pos::Span;\n@@ -91,11 +91,11 @@ impl hir::Pat {\n     /// Call `f` on every \"binding\" in a pattern, e.g., on `a` in\n     /// `match foo() { Some(a) => (), None => () }`\n     pub fn each_binding<F>(&self, mut f: F)\n-        where F: FnMut(hir::BindingAnnotation, ast::NodeId, Span, &Spanned<ast::Name>),\n+        where F: FnMut(hir::BindingAnnotation, HirId, Span, &Spanned<ast::Name>),\n     {\n         self.walk(|p| {\n             if let PatKind::Binding(binding_mode, _, ref pth, _) = p.node {\n-                f(binding_mode, p.id, p.span, pth);\n+                f(binding_mode, p.hir_id, p.span, pth);\n             }\n             true\n         });"}, {"sha": "66c6cf73513ec921d4cfe36e604b1740b8ca454c", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1329605a3d92e2b4a656895d3f00d508b48b4f57/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1329605a3d92e2b4a656895d3f00d508b48b4f57/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=1329605a3d92e2b4a656895d3f00d508b48b4f57", "patch": "@@ -608,9 +608,10 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     fn walk_local(&mut self, local: &hir::Local) {\n         match local.init {\n             None => {\n-                let delegate = &mut self.delegate;\n-                local.pat.each_binding(|_, id, span, _| {\n-                    delegate.decl_without_init(id, span);\n+                local.pat.each_binding(|_, hir_id, span, _| {\n+                    // FIXME: converting HirId \u2192 NodeId is said to be relatively expensive\n+                    let node_id = self.mc.tcx.hir.definitions().find_node_for_hir_id(hir_id);\n+                    self.delegate.decl_without_init(node_id, span);\n                 })\n             }\n "}, {"sha": "82686bc737bc818eb7a7dc2e9f9374164701acf0", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 77, "deletions": 81, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/1329605a3d92e2b4a656895d3f00d508b48b4f57/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1329605a3d92e2b4a656895d3f00d508b48b4f57/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=1329605a3d92e2b4a656895d3f00d508b48b4f57", "patch": "@@ -110,7 +110,7 @@ use hir::def::*;\n use ty::{self, TyCtxt};\n use lint;\n use errors::Applicability;\n-use util::nodemap::{NodeMap, NodeSet};\n+use util::nodemap::{NodeMap, HirIdMap, HirIdSet};\n \n use std::collections::VecDeque;\n use std::{fmt, u32};\n@@ -122,7 +122,7 @@ use syntax::ptr::P;\n use syntax::symbol::keywords;\n use syntax_pos::Span;\n \n-use hir::Expr;\n+use hir::{Expr, HirId};\n use hir;\n use hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n \n@@ -236,19 +236,19 @@ fn invalid_node() -> LiveNode { LiveNode(u32::MAX) }\n \n struct CaptureInfo {\n     ln: LiveNode,\n-    var_nid: NodeId\n+    var_hid: HirId\n }\n \n #[derive(Copy, Clone, Debug)]\n struct LocalInfo {\n-    id: NodeId,\n+    id: HirId,\n     name: ast::Name,\n     is_shorthand: bool,\n }\n \n #[derive(Copy, Clone, Debug)]\n enum VarKind {\n-    Arg(NodeId, ast::Name),\n+    Arg(HirId, ast::Name),\n     Local(LocalInfo),\n     CleanExit\n }\n@@ -258,8 +258,8 @@ struct IrMaps<'a, 'tcx: 'a> {\n \n     num_live_nodes: usize,\n     num_vars: usize,\n-    live_node_map: NodeMap<LiveNode>,\n-    variable_map: NodeMap<Variable>,\n+    live_node_map: HirIdMap<LiveNode>,\n+    variable_map: HirIdMap<Variable>,\n     capture_info_map: NodeMap<Rc<Vec<CaptureInfo>>>,\n     var_kinds: Vec<VarKind>,\n     lnks: Vec<LiveNodeKind>,\n@@ -271,8 +271,8 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n             tcx,\n             num_live_nodes: 0,\n             num_vars: 0,\n-            live_node_map: NodeMap(),\n-            variable_map: NodeMap(),\n+            live_node_map: HirIdMap(),\n+            variable_map: HirIdMap(),\n             capture_info_map: NodeMap(),\n             var_kinds: Vec::new(),\n             lnks: Vec::new(),\n@@ -290,11 +290,11 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n         ln\n     }\n \n-    fn add_live_node_for_node(&mut self, node_id: NodeId, lnk: LiveNodeKind) {\n+    fn add_live_node_for_node(&mut self, hir_id: HirId, lnk: LiveNodeKind) {\n         let ln = self.add_live_node(lnk);\n-        self.live_node_map.insert(node_id, ln);\n+        self.live_node_map.insert(hir_id, ln);\n \n-        debug!(\"{:?} is node {}\", ln, node_id);\n+        debug!(\"{:?} is node {:?}\", ln, hir_id);\n     }\n \n     fn add_variable(&mut self, vk: VarKind) -> Variable {\n@@ -314,11 +314,11 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n         v\n     }\n \n-    fn variable(&self, node_id: NodeId, span: Span) -> Variable {\n-        match self.variable_map.get(&node_id) {\n+    fn variable(&self, hir_id: HirId, span: Span) -> Variable {\n+        match self.variable_map.get(&hir_id) {\n             Some(&var) => var,\n             None => {\n-                span_bug!(span, \"no variable registered for id {}\", node_id);\n+                span_bug!(span, \"no variable registered for id {:?}\", hir_id);\n             }\n         }\n     }\n@@ -374,10 +374,10 @@ fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'a, 'tcx>,\n     let body = ir.tcx.hir.body(body_id);\n \n     for arg in &body.arguments {\n-        arg.pat.each_binding(|_bm, arg_id, _x, path1| {\n-            debug!(\"adding argument {}\", arg_id);\n+        arg.pat.each_binding(|_bm, hir_id, _x, path1| {\n+            debug!(\"adding argument {:?}\", hir_id);\n             let name = path1.node;\n-            fn_maps.add_variable(Arg(arg_id, name));\n+            fn_maps.add_variable(Arg(hir_id, name));\n         })\n     };\n \n@@ -397,11 +397,7 @@ fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'a, 'tcx>,\n fn add_from_pat<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, pat: &P<hir::Pat>) {\n     // For struct patterns, take note of which fields used shorthand\n     // (`x` rather than `x: x`).\n-    //\n-    // FIXME: according to the rust-lang-nursery/rustc-guide book, `NodeId`s are to be\n-    // phased out in favor of `HirId`s; however, we need to match the signature of\n-    // `each_binding`, which uses `NodeIds`.\n-    let mut shorthand_field_ids = NodeSet();\n+    let mut shorthand_field_ids = HirIdSet();\n     let mut pats = VecDeque::new();\n     pats.push_back(pat);\n     while let Some(pat) = pats.pop_front() {\n@@ -413,7 +409,7 @@ fn add_from_pat<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, pat: &P<hir::Pat>) {\n             Struct(_, ref fields, _) => {\n                 for field in fields {\n                     if field.node.is_shorthand {\n-                        shorthand_field_ids.insert(field.node.pat.id);\n+                        shorthand_field_ids.insert(field.node.pat.hir_id);\n                     }\n                 }\n             }\n@@ -434,13 +430,13 @@ fn add_from_pat<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, pat: &P<hir::Pat>) {\n         }\n     }\n \n-    pat.each_binding(|_bm, p_id, _sp, path1| {\n+    pat.each_binding(|_bm, hir_id, _sp, path1| {\n         let name = path1.node;\n-        ir.add_live_node_for_node(p_id, VarDefNode(path1.span));\n+        ir.add_live_node_for_node(hir_id, VarDefNode(path1.span));\n         ir.add_variable(Local(LocalInfo {\n-            id: p_id,\n+            id: hir_id,\n             name,\n-            is_shorthand: shorthand_field_ids.contains(&p_id)\n+            is_shorthand: shorthand_field_ids.contains(&hir_id)\n         }));\n     });\n }\n@@ -463,14 +459,14 @@ fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n       hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n         debug!(\"expr {}: path that leads to {:?}\", expr.id, path.def);\n         if let Def::Local(..) = path.def {\n-            ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n+            ir.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n         }\n         intravisit::walk_expr(ir, expr);\n       }\n       hir::ExprClosure(..) => {\n         // Interesting control flow (for loops can contain labeled\n         // breaks or continues)\n-        ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n+        ir.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n \n         // Make a live_node for each captured variable, with the span\n         // being the location that the variable is used.  This results\n@@ -481,8 +477,8 @@ fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n             for fv in freevars {\n                 if let Def::Local(rv) = fv.def {\n                     let fv_ln = ir.add_live_node(FreeVarNode(fv.span));\n-                    call_caps.push(CaptureInfo {ln: fv_ln,\n-                                                var_nid: rv});\n+                    let var_hid = ir.tcx.hir.node_to_hir_id(rv);\n+                    call_caps.push(CaptureInfo { ln: fv_ln, var_hid });\n                 }\n             }\n         });\n@@ -493,11 +489,11 @@ fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n \n       // live nodes required for interesting control flow:\n       hir::ExprIf(..) | hir::ExprMatch(..) | hir::ExprWhile(..) | hir::ExprLoop(..) => {\n-        ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n+        ir.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n         intravisit::walk_expr(ir, expr);\n       }\n       hir::ExprBinary(op, ..) if op.node.is_lazy() => {\n-        ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n+        ir.add_live_node_for_node(expr.hir_id, ExprNode(expr.span));\n         intravisit::walk_expr(ir, expr);\n       }\n \n@@ -590,8 +586,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         }\n     }\n \n-    fn live_node(&self, node_id: NodeId, span: Span) -> LiveNode {\n-        match self.ir.live_node_map.get(&node_id) {\n+    fn live_node(&self, hir_id: HirId, span: Span) -> LiveNode {\n+        match self.ir.live_node_map.get(&hir_id) {\n           Some(&ln) => ln,\n           None => {\n             // This must be a mismatch between the ir_map construction\n@@ -600,28 +596,28 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             // creating liveness nodes for.\n             span_bug!(\n                 span,\n-                \"no live node registered for node {}\",\n-                node_id);\n+                \"no live node registered for node {:?}\",\n+                hir_id);\n           }\n         }\n     }\n \n-    fn variable(&self, node_id: NodeId, span: Span) -> Variable {\n-        self.ir.variable(node_id, span)\n+    fn variable(&self, hir_id: HirId, span: Span) -> Variable {\n+        self.ir.variable(hir_id, span)\n     }\n \n     fn pat_bindings<F>(&mut self, pat: &hir::Pat, mut f: F) where\n-        F: FnMut(&mut Liveness<'a, 'tcx>, LiveNode, Variable, Span, NodeId),\n+        F: FnMut(&mut Liveness<'a, 'tcx>, LiveNode, Variable, Span, HirId),\n     {\n-        pat.each_binding(|_bm, p_id, sp, n| {\n-            let ln = self.live_node(p_id, sp);\n-            let var = self.variable(p_id, n.span);\n-            f(self, ln, var, n.span, p_id);\n+        pat.each_binding(|_bm, hir_id, sp, n| {\n+            let ln = self.live_node(hir_id, sp);\n+            let var = self.variable(hir_id, n.span);\n+            f(self, ln, var, n.span, hir_id);\n         })\n     }\n \n     fn arm_pats_bindings<F>(&mut self, pat: Option<&hir::Pat>, f: F) where\n-        F: FnMut(&mut Liveness<'a, 'tcx>, LiveNode, Variable, Span, NodeId),\n+        F: FnMut(&mut Liveness<'a, 'tcx>, LiveNode, Variable, Span, HirId),\n     {\n         if let Some(pat) = pat {\n             self.pat_bindings(pat, f);\n@@ -927,7 +923,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         match expr.node {\n           // Interesting cases with control flow or which gen/kill\n           hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n-              self.access_path(expr.id, path, succ, ACC_READ | ACC_USE)\n+              self.access_path(expr.hir_id, path, succ, ACC_READ | ACC_USE)\n           }\n \n           hir::ExprField(ref e, _) => {\n@@ -937,11 +933,9 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           hir::ExprClosure(.., blk_id, _, _) => {\n               debug!(\"{} is an ExprClosure\", self.ir.tcx.hir.node_to_pretty_string(expr.id));\n \n-              /*\n-              The next-node for a break is the successor of the entire\n-              loop. The next-node for a continue is the top of this loop.\n-              */\n-              let node = self.live_node(expr.id, expr.span);\n+              // The next-node for a break is the successor of the entire\n+              // loop. The next-node for a continue is the top of this loop.\n+              let node = self.live_node(expr.hir_id, expr.span);\n \n               let break_ln = succ;\n               let cont_ln = node;\n@@ -958,7 +952,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               };\n               caps.iter().rev().fold(succ, |succ, cap| {\n                   self.init_from_succ(cap.ln, succ);\n-                  let var = self.variable(cap.var_nid, expr.span);\n+                  let var = self.variable(cap.var_hid, expr.span);\n                   self.acc(cap.ln, var, ACC_READ | ACC_USE);\n                   cap.ln\n               })\n@@ -980,7 +974,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             //\n             let else_ln = self.propagate_through_opt_expr(els.as_ref().map(|e| &**e), succ);\n             let then_ln = self.propagate_through_expr(&then, succ);\n-            let ln = self.live_node(expr.id, expr.span);\n+            let ln = self.live_node(expr.hir_id, expr.span);\n             self.init_from_succ(ln, else_ln);\n             self.merge_from_succ(ln, then_ln, false);\n             self.propagate_through_expr(&cond, ln)\n@@ -1011,7 +1005,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             //   (  succ  )\n             //\n             //\n-            let ln = self.live_node(expr.id, expr.span);\n+            let ln = self.live_node(expr.hir_id, expr.span);\n             self.init_empty(ln, succ);\n             let mut first_merge = true;\n             for arm in arms {\n@@ -1132,7 +1126,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           hir::ExprBinary(op, ref l, ref r) if op.node.is_lazy() => {\n             let r_succ = self.propagate_through_expr(&r, succ);\n \n-            let ln = self.live_node(expr.id, expr.span);\n+            let ln = self.live_node(expr.hir_id, expr.span);\n             self.init_from_succ(ln, succ);\n             self.merge_from_succ(ln, r_succ, false);\n \n@@ -1249,7 +1243,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                     -> LiveNode {\n         match expr.node {\n           hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n-              self.access_path(expr.id, path, succ, acc)\n+              self.access_path(expr.hir_id, path, succ, acc)\n           }\n \n           // We do not track other places, so just propagate through\n@@ -1260,22 +1254,23 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         }\n     }\n \n-    fn access_var(&mut self, id: NodeId, nid: NodeId, succ: LiveNode, acc: u32, span: Span)\n+    fn access_var(&mut self, hir_id: HirId, nid: NodeId, succ: LiveNode, acc: u32, span: Span)\n                   -> LiveNode {\n-        let ln = self.live_node(id, span);\n+        let ln = self.live_node(hir_id, span);\n         if acc != 0 {\n             self.init_from_succ(ln, succ);\n-            let var = self.variable(nid, span);\n+            let var_hid = self.ir.tcx.hir.node_to_hir_id(nid);\n+            let var = self.variable(var_hid, span);\n             self.acc(ln, var, acc);\n         }\n         ln\n     }\n \n-    fn access_path(&mut self, id: NodeId, path: &hir::Path, succ: LiveNode, acc: u32)\n+    fn access_path(&mut self, hir_id: HirId, path: &hir::Path, succ: LiveNode, acc: u32)\n                    -> LiveNode {\n         match path.def {\n           Def::Local(nid) => {\n-            self.access_var(id, nid, succ, acc, path.span)\n+            self.access_var(hir_id, nid, succ, acc, path.span)\n           }\n           _ => succ\n         }\n@@ -1309,7 +1304,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n         // first iteration:\n         let mut first_merge = true;\n-        let ln = self.live_node(expr.id, expr.span);\n+        let ln = self.live_node(expr.hir_id, expr.span);\n         self.init_empty(ln, succ);\n         match kind {\n             LoopLoop => {}\n@@ -1455,9 +1450,10 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                     // if there is no later assignment. If this local is actually\n                     // mutable, then check for a reassignment to flag the mutability\n                     // as being used.\n-                    let ln = self.live_node(expr.id, expr.span);\n-                    let var = self.variable(nid, expr.span);\n-                    self.warn_about_dead_assign(expr.span, expr.id, ln, var);\n+                    let ln = self.live_node(expr.hir_id, expr.span);\n+                    let var_hid = self.ir.tcx.hir.node_to_hir_id(nid);\n+                    let var = self.variable(var_hid, expr.span);\n+                    self.warn_about_dead_assign(expr.span, expr.hir_id, ln, var);\n                 }\n             }\n             _ => {\n@@ -1479,15 +1475,15 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn warn_about_unused_args(&self, body: &hir::Body, entry_ln: LiveNode) {\n         for arg in &body.arguments {\n-            arg.pat.each_binding(|_bm, p_id, _, path1| {\n+            arg.pat.each_binding(|_bm, hir_id, _, path1| {\n                 let sp = path1.span;\n-                let var = self.variable(p_id, sp);\n+                let var = self.variable(hir_id, sp);\n                 // Ignore unused self.\n                 let name = path1.node;\n                 if name != keywords::SelfValue.name() {\n-                    if !self.warn_about_unused(sp, p_id, entry_ln, var) {\n+                    if !self.warn_about_unused(sp, hir_id, entry_ln, var) {\n                         if self.live_on_entry(entry_ln, var).is_none() {\n-                            self.report_dead_assign(p_id, sp, var, true);\n+                            self.report_dead_assign(hir_id, sp, var, true);\n                         }\n                     }\n                 }\n@@ -1505,7 +1501,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn warn_about_unused(&self,\n                          sp: Span,\n-                         id: NodeId,\n+                         hir_id: HirId,\n                          ln: LiveNode,\n                          var: Variable)\n                          -> bool {\n@@ -1527,14 +1523,14 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n                 if is_assigned {\n                     self.ir.tcx\n-                        .lint_node_note(lint::builtin::UNUSED_VARIABLES, id, sp,\n-                                        &format!(\"variable `{}` is assigned to, but never used\",\n-                                                 name),\n-                                        &suggest_underscore_msg);\n+                        .lint_hir_note(lint::builtin::UNUSED_VARIABLES, hir_id, sp,\n+                                       &format!(\"variable `{}` is assigned to, but never used\",\n+                                                name),\n+                                       &suggest_underscore_msg);\n                 } else if name != \"self\" {\n                     let msg = format!(\"unused variable: `{}`\", name);\n                     let mut err = self.ir.tcx\n-                        .struct_span_lint_node(lint::builtin::UNUSED_VARIABLES, id, sp, &msg);\n+                        .struct_span_lint_hir(lint::builtin::UNUSED_VARIABLES, hir_id, sp, &msg);\n                     if self.ir.variable_is_shorthand(var) {\n                         err.span_suggestion_with_applicability(sp, \"try ignoring the field\",\n                                                                format!(\"{}: _\", name),\n@@ -1557,21 +1553,21 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn warn_about_dead_assign(&self,\n                               sp: Span,\n-                              id: NodeId,\n+                              hir_id: HirId,\n                               ln: LiveNode,\n                               var: Variable) {\n         if self.live_on_exit(ln, var).is_none() {\n-            self.report_dead_assign(id, sp, var, false);\n+            self.report_dead_assign(hir_id, sp, var, false);\n         }\n     }\n \n-    fn report_dead_assign(&self, id: NodeId, sp: Span, var: Variable, is_argument: bool) {\n+    fn report_dead_assign(&self, hir_id: HirId, sp: Span, var: Variable, is_argument: bool) {\n         if let Some(name) = self.should_warn(var) {\n             if is_argument {\n-                self.ir.tcx.lint_node(lint::builtin::UNUSED_ASSIGNMENTS, id, sp,\n+                self.ir.tcx.lint_hir(lint::builtin::UNUSED_ASSIGNMENTS, hir_id, sp,\n                     &format!(\"value passed to `{}` is never read\", name));\n             } else {\n-                self.ir.tcx.lint_node(lint::builtin::UNUSED_ASSIGNMENTS, id, sp,\n+                self.ir.tcx.lint_hir(lint::builtin::UNUSED_ASSIGNMENTS, hir_id, sp,\n                     &format!(\"value assigned to `{}` is never read\", name));\n             }\n         }"}, {"sha": "df2996d7ee1f55f6a9529764107697102c912886", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1329605a3d92e2b4a656895d3f00d508b48b4f57/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1329605a3d92e2b4a656895d3f00d508b48b4f57/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=1329605a3d92e2b4a656895d3f00d508b48b4f57", "patch": "@@ -2544,6 +2544,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         &self.intern_goals(&[goal])[0]\n     }\n \n+    pub fn lint_hir<S: Into<MultiSpan>>(self,\n+                                        lint: &'static Lint,\n+                                        hir_id: HirId,\n+                                        span: S,\n+                                        msg: &str) {\n+        self.struct_span_lint_hir(lint, hir_id, span.into(), msg).emit()\n+    }\n+\n     pub fn lint_node<S: Into<MultiSpan>>(self,\n                                          lint: &'static Lint,\n                                          id: NodeId,\n@@ -2552,6 +2560,17 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.struct_span_lint_node(lint, id, span.into(), msg).emit()\n     }\n \n+    pub fn lint_hir_note<S: Into<MultiSpan>>(self,\n+                                              lint: &'static Lint,\n+                                              hir_id: HirId,\n+                                              span: S,\n+                                              msg: &str,\n+                                              note: &str) {\n+        let mut err = self.struct_span_lint_hir(lint, hir_id, span.into(), msg);\n+        err.note(note);\n+        err.emit()\n+    }\n+\n     pub fn lint_node_note<S: Into<MultiSpan>>(self,\n                                               lint: &'static Lint,\n                                               id: NodeId,\n@@ -2590,6 +2609,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         })\n     }\n \n+    pub fn struct_span_lint_hir<S: Into<MultiSpan>>(self,\n+                                                    lint: &'static Lint,\n+                                                    hir_id: HirId,\n+                                                    span: S,\n+                                                    msg: &str)\n+        -> DiagnosticBuilder<'tcx>\n+    {\n+        // FIXME: converting HirId \u2192 NodeId is said to be relatively expensive\n+        let node_id = self.hir.definitions().find_node_for_hir_id(hir_id);\n+        let (level, src) = self.lint_level_at_node(lint, node_id);\n+        lint::struct_lint_level(self.sess, lint, level, src, Some(span.into()), msg)\n+    }\n+\n     pub fn struct_span_lint_node<S: Into<MultiSpan>>(self,\n                                                      lint: &'static Lint,\n                                                      id: NodeId,"}, {"sha": "c92aa24b8cf5a93681a70a605826124840a39eae", "filename": "src/librustc/util/nodemap.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1329605a3d92e2b4a656895d3f00d508b48b4f57/src%2Flibrustc%2Futil%2Fnodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1329605a3d92e2b4a656895d3f00d508b48b4f57/src%2Flibrustc%2Futil%2Fnodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fnodemap.rs?ref=1329605a3d92e2b4a656895d3f00d508b48b4f57", "patch": "@@ -31,8 +31,9 @@ pub type ItemLocalSet = FxHashSet<ItemLocalId>;\n \n pub fn NodeMap<T>() -> NodeMap<T> { FxHashMap() }\n pub fn DefIdMap<T>() -> DefIdMap<T> { FxHashMap() }\n+pub fn HirIdMap<T>() -> HirIdMap<T> { FxHashMap() }\n pub fn ItemLocalMap<T>() -> ItemLocalMap<T> { FxHashMap() }\n pub fn NodeSet() -> NodeSet { FxHashSet() }\n pub fn DefIdSet() -> DefIdSet { FxHashSet() }\n+pub fn HirIdSet() -> HirIdSet { FxHashSet() }\n pub fn ItemLocalSet() -> ItemLocalSet { FxHashSet() }\n-"}, {"sha": "b2b4c7d777eabdc20136e9d1a7ca20326d43c165", "filename": "src/librustc_borrowck/borrowck/unused.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1329605a3d92e2b4a656895d3f00d508b48b4f57/src%2Flibrustc_borrowck%2Fborrowck%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1329605a3d92e2b4a656895d3f00d508b48b4f57/src%2Flibrustc_borrowck%2Fborrowck%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Funused.rs?ref=1329605a3d92e2b4a656895d3f00d508b48b4f57", "patch": "@@ -46,17 +46,16 @@ impl<'a, 'tcx> UnusedMutCx<'a, 'tcx> {\n         let tcx = self.bccx.tcx;\n         let mut mutables = FxHashMap();\n         for p in pats {\n-            p.each_binding(|_, id, span, path1| {\n+            p.each_binding(|_, hir_id, span, path1| {\n                 let name = path1.node;\n \n                 // Skip anything that looks like `_foo`\n                 if name.as_str().starts_with(\"_\") {\n-                    return\n+                    return;\n                 }\n \n                 // Skip anything that looks like `&foo` or `&mut foo`, only look\n                 // for by-value bindings\n-                let hir_id = tcx.hir.node_to_hir_id(id);\n                 let bm = match self.bccx.tables.pat_binding_modes().get(hir_id) {\n                     Some(&bm) => bm,\n                     None => span_bug!(span, \"missing binding mode\"),\n@@ -66,25 +65,26 @@ impl<'a, 'tcx> UnusedMutCx<'a, 'tcx> {\n                     _ => return,\n                 }\n \n-                mutables.entry(name).or_insert(Vec::new()).push((id, hir_id, span));\n+                mutables.entry(name).or_insert(Vec::new()).push((hir_id, span));\n             });\n         }\n \n         for (_name, ids) in mutables {\n             // If any id for this name was used mutably then consider them all\n             // ok, so move on to the next\n-            if ids.iter().any(|&(_, ref id, _)| self.used_mut.contains(id)) {\n-                continue\n+            if ids.iter().any(|&(ref hir_id, _)| self.used_mut.contains(hir_id)) {\n+                continue;\n             }\n \n-            let mut_span = tcx.sess.codemap().span_until_non_whitespace(ids[0].2);\n+            let (hir_id, span) = ids[0];\n+            let mut_span = tcx.sess.codemap().span_until_non_whitespace(span);\n \n             // Ok, every name wasn't used mutably, so issue a warning that this\n             // didn't need to be mutable.\n-            tcx.struct_span_lint_node(UNUSED_MUT,\n-                                      ids[0].0,\n-                                      ids[0].2,\n-                                      \"variable does not need to be mutable\")\n+            tcx.struct_span_lint_hir(UNUSED_MUT,\n+                                     hir_id,\n+                                     span,\n+                                     \"variable does not need to be mutable\")\n                 .span_suggestion_short(mut_span, \"remove this `mut`\", \"\".to_owned())\n                 .emit();\n         }"}, {"sha": "7c44a8d4d5f3b7b2251c391b93627d73fd1165c7", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1329605a3d92e2b4a656895d3f00d508b48b4f57/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1329605a3d92e2b4a656895d3f00d508b48b4f57/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=1329605a3d92e2b4a656895d3f00d508b48b4f57", "patch": "@@ -499,8 +499,7 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n                                    pats: &[P<Pat>]) {\n     let mut by_ref_span = None;\n     for pat in pats {\n-        pat.each_binding(|_, id, span, _path| {\n-            let hir_id = cx.tcx.hir.node_to_hir_id(id);\n+        pat.each_binding(|_, hir_id, span, _path| {\n             let bm = *cx.tables\n                         .pat_binding_modes()\n                         .get(hir_id)"}, {"sha": "fa8045d70321f4c9a7deedc8c00daf60babcdb3f", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1329605a3d92e2b4a656895d3f00d508b48b4f57/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1329605a3d92e2b4a656895d3f00d508b48b4f57/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=1329605a3d92e2b4a656895d3f00d508b48b4f57", "patch": "@@ -380,7 +380,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n     fn constrain_bindings_in_pat(&mut self, pat: &hir::Pat) {\n         debug!(\"regionck::visit_pat(pat={:?})\", pat);\n-        pat.each_binding(|_, id, span, _| {\n+        pat.each_binding(|_, hir_id, span, _| {\n             // If we have a variable that contains region'd data, that\n             // data will be accessible from anywhere that the variable is\n             // accessed. We must be wary of loops like this:\n@@ -403,8 +403,6 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             // iteration. The easiest way to guarantee this is to require\n             // that the lifetime of any regions that appear in a\n             // variable's type enclose at least the variable's scope.\n-\n-            let hir_id = self.tcx.hir.node_to_hir_id(id);\n             let var_scope = self.region_scope_tree.var_scope(hir_id.local_id);\n             let var_region = self.tcx.mk_region(ty::ReScope(var_scope));\n "}]}