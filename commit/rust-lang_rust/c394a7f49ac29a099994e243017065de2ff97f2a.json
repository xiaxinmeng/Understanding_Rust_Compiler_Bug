{"sha": "c394a7f49ac29a099994e243017065de2ff97f2a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzOTRhN2Y0OWFjMjlhMDk5OTk0ZTI0MzAxNzA2NWRlMmZmOTdmMmE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-06-19T05:41:20Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-06-19T09:40:59Z"}, "message": "rustc: Rename session.span_err -> span_fatal, err -> fatal\n\nIssue #440", "tree": {"sha": "599e4f2fc554d22817f990031448f3db8f041444", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/599e4f2fc554d22817f990031448f3db8f041444"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c394a7f49ac29a099994e243017065de2ff97f2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c394a7f49ac29a099994e243017065de2ff97f2a", "html_url": "https://github.com/rust-lang/rust/commit/c394a7f49ac29a099994e243017065de2ff97f2a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c394a7f49ac29a099994e243017065de2ff97f2a/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "514813148b68d86a0dd9b5ebea9ec4fc415fdac0", "url": "https://api.github.com/repos/rust-lang/rust/commits/514813148b68d86a0dd9b5ebea9ec4fc415fdac0", "html_url": "https://github.com/rust-lang/rust/commit/514813148b68d86a0dd9b5ebea9ec4fc415fdac0"}], "stats": {"total": 266, "additions": 136, "deletions": 130}, "files": [{"sha": "73f3832270a8266d4b72857fbe4c5f2bd1d51786", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c394a7f49ac29a099994e243017065de2ff97f2a/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c394a7f49ac29a099994e243017065de2ff97f2a/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=c394a7f49ac29a099994e243017065de2ff97f2a", "patch": "@@ -33,8 +33,8 @@ tag output_type {\n fn llvm_err(session::session sess, str msg) {\n     auto buf = llvm::LLVMRustGetLastError();\n     if (buf as uint == 0u) {\n-        sess.err(msg);\n-    } else { sess.err(msg + \": \" + str::str_from_cstr(buf)); }\n+        sess.fatal(msg);\n+    } else { sess.fatal(msg + \": \" + str::str_from_cstr(buf)); }\n     fail;\n }\n \n@@ -276,7 +276,7 @@ fn get_crate_meta_export(&session::session sess, &ast::crate c, str k,\n         }\n         case (1u) { ret v.(0).node.value; }\n         case (_) {\n-            sess.span_err(v.(1).span, #fmt(\"duplicate meta '%s'\", k));\n+            sess.span_fatal(v.(1).span, #fmt(\"duplicate meta '%s'\", k));\n         }\n     }\n }"}, {"sha": "1094d0c7a5d2523ac8dd396d25bc300dea7ae359", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c394a7f49ac29a099994e243017065de2ff97f2a/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c394a7f49ac29a099994e243017065de2ff97f2a/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=c394a7f49ac29a099994e243017065de2ff97f2a", "patch": "@@ -59,7 +59,7 @@ fn parse_input(session::session sess, parser::parser p, str input) ->\n             parser::parse_crate_from_crate_file(p)\n         } else if (str::ends_with(input, \".rs\")) {\n             parser::parse_crate_from_source_file(p)\n-        } else { sess.err(\"unknown input file type: \" + input); fail };\n+        } else { sess.fatal(\"unknown input file type: \" + input); fail };\n }\n \n fn time[T](bool do_it, str what, fn() -> T  thunk) -> T {\n@@ -282,7 +282,7 @@ fn parse_pretty(session::session sess, &str name) -> pp_mode {\n     } else if (str::eq(name, \"typed\")) {\n         ret ppm_typed;\n     } else if (str::eq(name, \"identified\")) { ret ppm_identified; }\n-    sess.err(\"argument to `pretty` must be one of `normal`, `typed`, or \" +\n+    sess.fatal(\"argument to `pretty` must be one of `normal`, `typed`, or \" +\n                  \"`identified`\");\n }\n \n@@ -321,16 +321,16 @@ fn main(vec[str] args) {\n     auto glue = opt_present(match, \"glue\");\n     if (glue) {\n         if (n_inputs > 0u) {\n-            sess.err(\"No input files allowed with --glue.\");\n+            sess.fatal(\"No input files allowed with --glue.\");\n         }\n         auto out = option::from_maybe[str](\"glue.bc\", output_file);\n         middle::trans::make_common_glue(sess, out);\n         ret;\n     }\n     if (n_inputs == 0u) {\n-        sess.err(\"No input filename given.\");\n+        sess.fatal(\"No input filename given.\");\n     } else if (n_inputs > 1u) {\n-        sess.err(\"Multiple input filenames provided.\");\n+        sess.fatal(\"Multiple input filenames provided.\");\n     }\n     auto ifile = match.free.(0);\n     let str saved_out_filename = \"\";"}, {"sha": "e6eefcfaa56192ada17df266c8534f7ebc949f2c", "filename": "src/comp/driver/session.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c394a7f49ac29a099994e243017065de2ff97f2a/src%2Fcomp%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c394a7f49ac29a099994e243017065de2ff97f2a/src%2Fcomp%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fsession.rs?ref=c394a7f49ac29a099994e243017065de2ff97f2a", "patch": "@@ -70,13 +70,13 @@ obj session(ast::crate_num cnum,\n     fn get_targ_cfg() -> @config { ret targ_cfg; }\n     fn get_opts() -> @options { ret opts; }\n     fn get_targ_crate_num() -> ast::crate_num { ret cnum; }\n-    fn span_err(span sp, str msg) -> ! {\n+    fn span_fatal(span sp, str msg) -> ! {\n         // FIXME: Use constants, but rustboot doesn't know how to export them.\n \n         emit_diagnostic(some(sp), msg, \"error\", 9u8, cm);\n         fail;\n     }\n-    fn err(str msg) -> ! {\n+    fn fatal(str msg) -> ! {\n         emit_diagnostic(none[span], msg, \"error\", 9u8, cm);\n         fail;\n     }\n@@ -94,10 +94,10 @@ obj session(ast::crate_num cnum,\n         emit_diagnostic(some(sp), msg, \"note\", 10u8, cm);\n     }\n     fn span_bug(span sp, str msg) -> ! {\n-        self.span_err(sp, #fmt(\"internal compiler error %s\", msg));\n+        self.span_fatal(sp, #fmt(\"internal compiler error %s\", msg));\n     }\n     fn bug(str msg) -> ! {\n-        self.err(#fmt(\"internal compiler error %s\", msg));\n+        self.fatal(#fmt(\"internal compiler error %s\", msg));\n     }\n     fn span_unimpl(span sp, str msg) -> ! {\n         self.span_bug(sp, \"unimplemented \" + msg);"}, {"sha": "4553ff2fc0a16880d49bb5e0e674392fb4318687", "filename": "src/comp/front/eval.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/c394a7f49ac29a099994e243017065de2ff97f2a/src%2Fcomp%2Ffront%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c394a7f49ac29a099994e243017065de2ff97f2a/src%2Fcomp%2Ffront%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Feval.rs?ref=c394a7f49ac29a099994e243017065de2ff97f2a", "patch": "@@ -63,15 +63,15 @@ fn lookup(session::session sess, env e, span sp, ident i) -> val {\n     for (tup(ident, val) pair in e) {\n         if (str::eq(i, pair._0)) { ret pair._1; }\n     }\n-    sess.span_err(sp, \"unknown variable: \" + i)\n+    sess.span_fatal(sp, \"unknown variable: \" + i)\n }\n \n fn eval_lit(ctx cx, span sp, @ast::lit lit) -> val {\n     alt (lit.node) {\n         case (ast::lit_bool(?b)) { val_bool(b) }\n         case (ast::lit_int(?i)) { val_int(i) }\n         case (ast::lit_str(?s, _)) { val_str(s) }\n-        case (_) { cx.sess.span_err(sp, \"evaluating unsupported literal\") }\n+        case (_) { cx.sess.span_fatal(sp, \"evaluating unsupported literal\") }\n     }\n }\n \n@@ -82,18 +82,18 @@ fn eval_expr(ctx cx, env e, @ast::expr x) -> val {\n                     vec::len[@ast::ty](pth.node.types) == 0u) {\n                 ret lookup(cx.sess, e, x.span, pth.node.idents.(0));\n             }\n-            cx.sess.span_err(x.span, \"evaluating structured path-name\");\n+            cx.sess.span_fatal(x.span, \"evaluating structured path-name\");\n         }\n         case (ast::expr_lit(?lit, _)) { ret eval_lit(cx, x.span, lit); }\n         case (ast::expr_unary(?op, ?a, _)) {\n             auto av = eval_expr(cx, e, a);\n             alt (op) {\n                 case (ast::not) {\n                     if (val_is_bool(av)) { ret val_bool(!val_as_bool(av)); }\n-                    cx.sess.span_err(x.span, \"bad types in '!' expression\");\n+                    cx.sess.span_fatal(x.span, \"bad types in '!' expression\");\n                 }\n                 case (_) {\n-                    cx.sess.span_err(x.span, \"evaluating unsupported unop\");\n+                    cx.sess.span_fatal(x.span, \"evaluating unsupported unop\");\n                 }\n             }\n         }\n@@ -108,43 +108,45 @@ fn eval_expr(ctx cx, env e, @ast::expr x) -> val {\n                     if (val_is_str(av) && val_is_str(bv)) {\n                         ret val_str(val_as_str(av) + val_as_str(bv));\n                     }\n-                    cx.sess.span_err(x.span, \"bad types in '+' expression\");\n+                    cx.sess.span_fatal(x.span, \"bad types in '+' expression\");\n                 }\n                 case (ast::sub) {\n                     if (val_is_int(av) && val_is_int(bv)) {\n                         ret val_int(val_as_int(av) - val_as_int(bv));\n                     }\n-                    cx.sess.span_err(x.span, \"bad types in '-' expression\");\n+                    cx.sess.span_fatal(x.span, \"bad types in '-' expression\");\n                 }\n                 case (ast::mul) {\n                     if (val_is_int(av) && val_is_int(bv)) {\n                         ret val_int(val_as_int(av) * val_as_int(bv));\n                     }\n-                    cx.sess.span_err(x.span, \"bad types in '*' expression\");\n+                    cx.sess.span_fatal(x.span, \"bad types in '*' expression\");\n                 }\n                 case (ast::div) {\n                     if (val_is_int(av) && val_is_int(bv)) {\n                         ret val_int(val_as_int(av) / val_as_int(bv));\n                     }\n-                    cx.sess.span_err(x.span, \"bad types in '/' expression\");\n+                    cx.sess.span_fatal(x.span, \"bad types in '/' expression\");\n                 }\n                 case (ast::rem) {\n                     if (val_is_int(av) && val_is_int(bv)) {\n                         ret val_int(val_as_int(av) % val_as_int(bv));\n                     }\n-                    cx.sess.span_err(x.span, \"bad types in '%' expression\");\n+                    cx.sess.span_fatal(x.span, \"bad types in '%' expression\");\n                 }\n                 case (ast::and) {\n                     if (val_is_bool(av) && val_is_bool(bv)) {\n                         ret val_bool(val_as_bool(av) && val_as_bool(bv));\n                     }\n-                    cx.sess.span_err(x.span, \"bad types in '&&' expression\");\n+                    cx.sess.span_fatal(x.span,\n+                                       \"bad types in '&&' expression\");\n                 }\n                 case (ast::or) {\n                     if (val_is_bool(av) && val_is_bool(bv)) {\n                         ret val_bool(val_as_bool(av) || val_as_bool(bv));\n                     }\n-                    cx.sess.span_err(x.span, \"bad types in '||' expression\");\n+                    cx.sess.span_fatal(x.span,\n+                                       \"bad types in '||' expression\");\n                 }\n                 case (ast::eq) {\n                     ret val_bool(val_eq(cx.sess, x.span, av, bv));\n@@ -153,12 +155,13 @@ fn eval_expr(ctx cx, env e, @ast::expr x) -> val {\n                     ret val_bool(!val_eq(cx.sess, x.span, av, bv));\n                 }\n                 case (_) {\n-                    cx.sess.span_err(x.span, \"evaluating unsupported binop\");\n+                    cx.sess.span_fatal(x.span,\n+                                       \"evaluating unsupported binop\");\n                 }\n             }\n         }\n         case (_) {\n-            cx.sess.span_err(x.span, \"evaluating unsupported expression\");\n+            cx.sess.span_fatal(x.span, \"evaluating unsupported expression\");\n         }\n     }\n     fail;\n@@ -171,7 +174,7 @@ fn val_eq(session::session sess, span sp, val av, val bv) -> bool {\n         val_as_int(av) == val_as_int(bv)\n     } else if (val_is_str(av) && val_is_str(bv)) {\n         str::eq(val_as_str(av), val_as_str(bv))\n-    } else { sess.span_err(sp, \"bad types in comparison\") }\n+    } else { sess.span_fatal(sp, \"bad types in comparison\") }\n }\n \n fn eval_crate_directives(ctx cx, env e, vec[@ast::crate_directive] cdirs,\n@@ -200,7 +203,7 @@ fn eval_crate_directive_block(ctx cx, env e, &ast::block blk, str prefix,\n                 eval_crate_directive(cx, e, cdir, prefix, view_items, items);\n             }\n             case (_) {\n-                cx.sess.span_err(s.span,\n+                cx.sess.span_fatal(s.span,\n                                  \"unsupported stmt in crate-directive block\");\n             }\n         }\n@@ -214,7 +217,7 @@ fn eval_crate_directive_expr(ctx cx, env e, @ast::expr x, str prefix,\n         case (ast::expr_if(?cond, ?thn, ?elopt, _)) {\n             auto cv = eval_expr(cx, e, cond);\n             if (!val_is_bool(cv)) {\n-                cx.sess.span_err(x.span, \"bad cond type in 'if'\");\n+                cx.sess.span_fatal(x.span, \"bad cond type in 'if'\");\n             }\n             if (val_as_bool(cv)) {\n                 ret eval_crate_directive_block(cx, e, thn, prefix, view_items,\n@@ -249,18 +252,18 @@ fn eval_crate_directive_expr(ctx cx, env e, @ast::expr x, str prefix,\n                                                        items);\n                     }\n                     case (_) {\n-                        cx.sess.span_err(arm.pat.span,\n+                        cx.sess.span_fatal(arm.pat.span,\n                                          \"bad pattern type in 'alt'\");\n                     }\n                 }\n             }\n-            cx.sess.span_err(x.span, \"no cases matched in 'alt'\");\n+            cx.sess.span_fatal(x.span, \"no cases matched in 'alt'\");\n         }\n         case (ast::expr_block(?block, _)) {\n             ret eval_crate_directive_block(cx, e, block, prefix, view_items,\n                                            items);\n         }\n-        case (_) { cx.sess.span_err(x.span, \"unsupported expr type\"); }\n+        case (_) { cx.sess.span_fatal(x.span, \"unsupported expr type\"); }\n     }\n }\n "}, {"sha": "782c135482a0b1b9fdb8f21093476fc2af7f5474", "filename": "src/comp/front/ext.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c394a7f49ac29a099994e243017065de2ff97f2a/src%2Fcomp%2Ffront%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c394a7f49ac29a099994e243017065de2ff97f2a/src%2Fcomp%2Ffront%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fext.rs?ref=c394a7f49ac29a099994e243017065de2ff97f2a", "patch": "@@ -31,21 +31,23 @@ type next_ann_fn = fn() -> ast::ann ;\n // Provides a limited set of services necessary for syntax extensions\n // to do their thing\n type ext_ctxt =\n-    rec(span_msg_fn span_err, span_msg_fn span_unimpl, next_ann_fn next_ann);\n+    rec(span_msg_fn span_fatal,\n+        span_msg_fn span_unimpl,\n+        next_ann_fn next_ann);\n \n fn mk_ctxt(parser parser) -> ext_ctxt {\n     auto sess = parser.get_session();\n-    fn ext_span_err_(session sess, span sp, str msg) -> ! {\n-        sess.span_err(sp, msg);\n+    fn ext_span_fatal_(session sess, span sp, str msg) -> ! {\n+        sess.span_fatal(sp, msg);\n     }\n-    auto ext_span_err = bind ext_span_err_(sess, _, _);\n+    auto ext_span_fatal = bind ext_span_fatal_(sess, _, _);\n     fn ext_span_unimpl_(session sess, span sp, str msg) -> ! {\n         sess.span_unimpl(sp, msg);\n     }\n     auto ext_span_unimpl = bind ext_span_unimpl_(sess, _, _);\n     fn ext_next_ann_(parser parser) -> ast::ann { parser.get_ann() }\n     auto ext_next_ann = bind ext_next_ann_(parser);\n-    ret rec(span_err=ext_span_err,\n+    ret rec(span_fatal=ext_span_fatal,\n             span_unimpl=ext_span_unimpl,\n             next_ann=ext_next_ann);\n }"}, {"sha": "373685a4240e582165015c7d57872dc27c58cc06", "filename": "src/comp/front/extenv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c394a7f49ac29a099994e243017065de2ff97f2a/src%2Fcomp%2Ffront%2Fextenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c394a7f49ac29a099994e243017065de2ff97f2a/src%2Fcomp%2Ffront%2Fextenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fextenv.rs?ref=c394a7f49ac29a099994e243017065de2ff97f2a", "patch": "@@ -16,7 +16,7 @@ export expand_syntax_ext;\n fn expand_syntax_ext(&ext_ctxt cx, common::span sp, &vec[@ast::expr] args,\n                      option::t[str] body) -> @ast::expr {\n     if (vec::len[@ast::expr](args) != 1u) {\n-        cx.span_err(sp, \"malformed #env call\");\n+        cx.span_fatal(sp, \"malformed #env call\");\n     }\n     // FIXME: if this was more thorough it would manufacture an\n     // option::t[str] rather than just an maybe-empty string.\n@@ -35,10 +35,10 @@ fn expr_to_str(&ext_ctxt cx, @ast::expr expr) -> str {\n         case (ast::expr_lit(?l, _)) {\n             alt (l.node) {\n                 case (ast::lit_str(?s, _)) { ret s; }\n-                case (_) { cx.span_err(l.span, \"malformed #env call\"); }\n+                case (_) { cx.span_fatal(l.span, \"malformed #env call\"); }\n             }\n         }\n-        case (_) { cx.span_err(expr.span, \"malformed #env call\"); }\n+        case (_) { cx.span_fatal(expr.span, \"malformed #env call\"); }\n     }\n }\n "}, {"sha": "831b846d5f179421de9befff64ecca4167124d0e", "filename": "src/comp/front/extfmt.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c394a7f49ac29a099994e243017065de2ff97f2a/src%2Fcomp%2Ffront%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c394a7f49ac29a099994e243017065de2ff97f2a/src%2Fcomp%2Ffront%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fextfmt.rs?ref=c394a7f49ac29a099994e243017065de2ff97f2a", "patch": "@@ -18,14 +18,14 @@ export expand_syntax_ext;\n fn expand_syntax_ext(&ext_ctxt cx, common::span sp, &vec[@ast::expr] args,\n                      option::t[str] body) -> @ast::expr {\n     if (vec::len[@ast::expr](args) == 0u) {\n-        cx.span_err(sp, \"#fmt requires a format string\");\n+        cx.span_fatal(sp, \"#fmt requires a format string\");\n     }\n     auto fmt = expr_to_str(cx, args.(0));\n     auto fmtspan = args.(0).span;\n     log \"Format string:\";\n     log fmt;\n     fn parse_fmt_err_(&ext_ctxt cx, common::span sp, str msg) -> ! {\n-        cx.span_err(sp, msg);\n+        cx.span_fatal(sp, msg);\n     }\n     auto parse_fmt_err = bind parse_fmt_err_(cx, fmtspan, _);\n     auto pieces = parse_fmt_string(fmt, parse_fmt_err);\n@@ -40,10 +40,10 @@ fn expr_to_str(&ext_ctxt cx, @ast::expr expr) -> str {\n         case (ast::expr_lit(?l, _)) {\n             alt (l.node) {\n                 case (ast::lit_str(?s, _)) { ret s; }\n-                case (_) { cx.span_err(l.span, err_msg); }\n+                case (_) { cx.span_fatal(l.span, err_msg); }\n             }\n         }\n-        case (_) { cx.span_err(expr.span, err_msg); }\n+        case (_) { cx.span_fatal(expr.span, err_msg); }\n     }\n }\n \n@@ -236,14 +236,14 @@ fn pieces_to_expr(&ext_ctxt cx, common::span sp, vec[piece] pieces,\n                 case (flag_left_justify) { }\n                 case (flag_sign_always) {\n                     if (!is_signed_type(cnv)) {\n-                        cx.span_err(sp,\n+                        cx.span_fatal(sp,\n                                     \"+ flag only valid in \" +\n                                         \"signed #fmt conversion\");\n                     }\n                 }\n                 case (flag_space_for_sign) {\n                     if (!is_signed_type(cnv)) {\n-                        cx.span_err(sp,\n+                        cx.span_fatal(sp,\n                                     \"space flag only valid in \" +\n                                         \"signed #fmt conversions\");\n                     }\n@@ -361,7 +361,7 @@ fn pieces_to_expr(&ext_ctxt cx, common::span sp, vec[piece] pieces,\n             case (piece_conv(?conv)) {\n                 n += 1u;\n                 if (n >= nargs) {\n-                    cx.span_err(sp,\n+                    cx.span_fatal(sp,\n                                 \"not enough arguments to #fmt \" +\n                                     \"for the given format string\");\n                 }\n@@ -376,7 +376,7 @@ fn pieces_to_expr(&ext_ctxt cx, common::span sp, vec[piece] pieces,\n     auto expected_nargs = n + 1u; // n conversions + the fmt string\n \n     if (expected_nargs < nargs) {\n-        cx.span_err(sp,\n+        cx.span_fatal(sp,\n                     #fmt(\"too many arguments to #fmt. found %u, expected %u\",\n                          nargs, expected_nargs));\n     }"}, {"sha": "eaf1eca64ba8ce609b9ec2b2e934795d7cd69019", "filename": "src/comp/front/lexer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c394a7f49ac29a099994e243017065de2ff97f2a/src%2Fcomp%2Ffront%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c394a7f49ac29a099994e243017065de2ff97f2a/src%2Fcomp%2Ffront%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Flexer.rs?ref=c394a7f49ac29a099994e243017065de2ff97f2a", "patch": "@@ -75,7 +75,7 @@ fn new_reader(session sess, io::reader rdr, codemap::filemap filemap,\n         fn get_interner() -> @interner::interner[str] { ret itr; }\n         fn get_col() -> uint { ret col; }\n         fn get_filemap() -> codemap::filemap { ret fm; }\n-        fn err(str m) { sess.span_err(rec(lo=chpos, hi=chpos), m); }\n+        fn err(str m) { sess.span_fatal(rec(lo=chpos, hi=chpos), m); }\n     }\n     auto file = str::unsafe_from_bytes(rdr.read_whole_stream());\n     let vec[str] strs = [];"}, {"sha": "b9cc1d17d1eb304fe16ccf643f3f59546237b220", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c394a7f49ac29a099994e243017065de2ff97f2a/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c394a7f49ac29a099994e243017065de2ff97f2a/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=c394a7f49ac29a099994e243017065de2ff97f2a", "patch": "@@ -78,7 +78,7 @@ fn new_parser(session::session sess, eval::env env, ast::def_id initial_def,\n             lo = rdr.get_mark_chpos();\n             hi = rdr.get_chpos();\n         }\n-        fn err(str m) -> ! { sess.span_err(rec(lo=lo, hi=hi), m); }\n+        fn err(str m) -> ! { sess.span_fatal(rec(lo=lo, hi=hi), m); }\n         fn restrict(restriction r) { res = r; }\n         fn get_restriction() -> restriction { ret res; }\n         fn get_session() -> session::session { ret sess; }\n@@ -353,7 +353,7 @@ fn parse_ty_field(&parser p) -> ast::ty_field {\n fn ident_index(&parser p, &vec[ast::arg] args, &ast::ident i) -> uint {\n     auto j = 0u;\n     for (ast::arg a in args) { if (a.ident == i) { ret j; } j += 1u; }\n-    p.get_session().span_err(p.get_span(),\n+    p.get_session().span_fatal(p.get_span(),\n                              \"Unbound variable \" + i + \" in constraint arg\");\n }\n "}, {"sha": "8705b342502f8c76d6703ca8efa77f86445920e2", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c394a7f49ac29a099994e243017065de2ff97f2a/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c394a7f49ac29a099994e243017065de2ff97f2a/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=c394a7f49ac29a099994e243017065de2ff97f2a", "patch": "@@ -92,7 +92,7 @@ fn visit_expr(@ctx cx, &@ast::expr ex, &scope sc, &vt[scope] v) {\n                 case (some(?ex)) {\n                     auto root = expr_root(*cx, ex, false);\n                     if (mut_field(root.ds)) {\n-                        cx.tcx.sess.span_err(ex.span,\n+                        cx.tcx.sess.span_fatal(ex.span,\n                                              \"result of put must be\" +\n                                                  \" immutably rooted\");\n                     }\n@@ -148,7 +148,7 @@ fn check_call(&ctx cx, &@ast::expr f, &vec[@ast::expr] args, &scope sc) ->\n                             auto m =\n                                 \"passing a temporary value or \\\n                                  immutable field by mutable alias\";\n-                            cx.tcx.sess.span_err(arg.span, m);\n+                            cx.tcx.sess.span_fatal(arg.span, m);\n                         }\n                     }\n                 }\n@@ -171,7 +171,7 @@ fn check_call(&ctx cx, &@ast::expr f, &vec[@ast::expr] args, &scope sc) ->\n         alt (f.node) {\n             case (ast::expr_path(_, ?ann)) {\n                 if (def_is_local(cx.tcx.def_map.get(ann.id), true)) {\n-                    cx.tcx.sess.span_err(f.span,\n+                    cx.tcx.sess.span_fatal(f.span,\n                                          #fmt(\"function may alias with \\\n                          argument %u, which is not immutably rooted\",\n                                               unsafe_t_offsets.(0)));\n@@ -190,7 +190,7 @@ fn check_call(&ctx cx, &@ast::expr f, &vec[@ast::expr] args, &scope sc) ->\n             if (i != offset &&\n                     ty_can_unsafely_include(cx, unsafe, arg_t.ty, mut_alias))\n                {\n-                cx.tcx.sess.span_err(args.(i).span,\n+                cx.tcx.sess.span_fatal(args.(i).span,\n                                      #fmt(\"argument %u may alias with \\\n                      argument %u, which is not immutably rooted\",\n                                           i, offset));\n@@ -208,7 +208,7 @@ fn check_call(&ctx cx, &@ast::expr f, &vec[@ast::expr] args, &scope sc) ->\n             }\n         }\n         if (mut_alias_to_root) {\n-            cx.tcx.sess.span_err(args.(root._0).span,\n+            cx.tcx.sess.span_fatal(args.(root._0).span,\n                                  \"passing a mutable alias to a \\\n                  variable that roots another alias\");\n         }\n@@ -377,10 +377,10 @@ fn check_assign(&@ctx cx, &@ast::expr dest, &@ast::expr src, &scope sc,\n         case (ast::expr_path(?p, ?ann)) {\n             auto dnum = ast::def_id_of_def(cx.tcx.def_map.get(ann.id))._1;\n             if (is_immutable_alias(cx, sc, dnum)) {\n-                cx.tcx.sess.span_err(dest.span,\n+                cx.tcx.sess.span_fatal(dest.span,\n                                      \"assigning to immutable alias\");\n             } else if (is_immutable_objfield(cx, dnum)) {\n-                cx.tcx.sess.span_err(dest.span,\n+                cx.tcx.sess.span_fatal(dest.span,\n                                      \"assigning to immutable obj field\");\n             }\n             auto var_t = ty::expr_ty(*cx.tcx, dest);\n@@ -394,15 +394,15 @@ fn check_assign(&@ctx cx, &@ast::expr dest, &@ast::expr src, &scope sc,\n         case (_) {\n             auto root = expr_root(*cx, dest, false);\n             if (vec::len(root.ds) == 0u) {\n-                cx.tcx.sess.span_err(dest.span, \"assignment to non-lvalue\");\n+                cx.tcx.sess.span_fatal(dest.span, \"assignment to non-lvalue\");\n             } else if (!root.ds.(0).mut) {\n                 auto name =\n                     alt (root.ds.(0).kind) {\n                         case (unbox) { \"box\" }\n                         case (field) { \"field\" }\n                         case (index) { \"vec content\" }\n                     };\n-                cx.tcx.sess.span_err(dest.span,\n+                cx.tcx.sess.span_fatal(dest.span,\n                                      \"assignment to immutable \" + name);\n             }\n             visit_expr(cx, dest, sc, v);\n@@ -441,7 +441,7 @@ fn test_scope(&ctx cx, &scope sc, &restrict r, &ast::path p) {\n                     tup(sp, \"taking the value of \" + ast::path_name(vpt))\n                 }\n             };\n-        cx.tcx.sess.span_err(msg._0,\n+        cx.tcx.sess.span_fatal(msg._0,\n                              msg._1 + \" will invalidate alias \" +\n                                  ast::path_name(p) + \", which is still used\");\n     }"}, {"sha": "8033b8123dc6d0a596ae5d55c5290e2e1cee3a22", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c394a7f49ac29a099994e243017065de2ff97f2a/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c394a7f49ac29a099994e243017065de2ff97f2a/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=c394a7f49ac29a099994e243017065de2ff97f2a", "patch": "@@ -307,7 +307,7 @@ fn resolve_names(&@env e, &@ast::crate c) {\n                         e.def_map.insert(a.id, fnd);\n                     }\n                     case (_) {\n-                        e.sess.span_err(p.span,\n+                        e.sess.span_fatal(p.span,\n                                         \"not a tag variant: \" +\n                                             ast::path_name(p));\n                     }\n@@ -380,7 +380,7 @@ fn follow_import(&env e, &scopes sc, vec[ident] path, &span sp) -> def {\n         case (ast::def_mod(?def_id)) { ret dcur; }\n         case (ast::def_native_mod(?def_id)) { ret dcur; }\n         case (_) {\n-            e.sess.span_err(sp,\n+            e.sess.span_fatal(sp,\n                             str::connect(path, \"::\") +\n                                 \" does not name a module.\");\n         }\n@@ -399,7 +399,7 @@ fn resolve_constr(@env e, &def_id d_id, &@ast::constr c, &scopes sc,\n             add_constr(e, d_id, new_constr);\n         }\n         case (_) {\n-            e.sess.span_err(c.span,\n+            e.sess.span_fatal(c.span,\n                             \"Non-predicate in constraint: \" +\n                                 ty::path_to_str(c.node.path));\n         }\n@@ -478,7 +478,7 @@ fn ns_name(namespace ns) -> str {\n }\n \n fn unresolved(&env e, &span sp, &ident id, &str kind) -> ! {\n-    e.sess.span_err(sp, \"unresolved \" + kind + \": \" + id);\n+    e.sess.span_fatal(sp, \"unresolved \" + kind + \": \" + id);\n }\n \n \n@@ -599,7 +599,7 @@ fn lookup_in_scope(&env e, scopes sc, &span sp, &ident id, namespace ns) ->\n                     auto df = option::get(fnd);\n                     if (left_fn && def_is_local(df) ||\n                             left_fn_level2 && def_is_obj_field(df)) {\n-                        e.sess.span_err(sp,\n+                        e.sess.span_fatal(sp,\n                                         \"attempted dynamic \\\n                                          environment-capture\");\n                     }\n@@ -806,7 +806,7 @@ fn lookup_import(&env e, def_id defid, namespace ns) -> option::t[def] {\n             resolve_import(e, item, sc);\n             ret lookup_import(e, defid, ns);\n         }\n-        case (resolving(?sp)) { e.sess.span_err(sp, \"cyclic import\"); }\n+        case (resolving(?sp)) { e.sess.span_fatal(sp, \"cyclic import\"); }\n         case (resolved(?val, ?typ, ?md)) {\n             ret alt (ns) {\n                     case (ns_value) { val }\n@@ -881,7 +881,7 @@ fn lookup_glob_in_mod(&env e, @indexed_mod info, &span sp, &ident id,\n                     }\n                 }\n             }\n-            e.sess.span_err(sp,\n+            e.sess.span_fatal(sp,\n                             \"'\" + id + \"' is glob-imported from\" +\n                                 \" multiple different modules.\");\n         }\n@@ -1086,7 +1086,7 @@ fn check_mod_name(&env e, &ident name, list[mod_index_entry] entries) {\n     auto saw_type = false;\n     auto saw_value = false;\n     fn dup(&env e, &span sp, &str word, &ident name) {\n-        e.sess.span_err(sp, \"duplicate definition of \" + word + name);\n+        e.sess.span_fatal(sp, \"duplicate definition of \" + word + name);\n     }\n     while (true) {\n         alt (entries) {\n@@ -1222,7 +1222,7 @@ fn checker(&env e, str kind) -> checker {\n fn add_name(&checker ch, &span sp, &ident id) {\n     for (ident s in ch.seen) {\n         if (str::eq(s, id)) {\n-            ch.sess.span_err(sp, \"duplicate \" + ch.kind + \" name: \" + id);\n+            ch.sess.span_fatal(sp, \"duplicate \" + ch.kind + \" name: \" + id);\n         }\n     }\n     vec::push(ch.seen, id);"}, {"sha": "5596b83697f68592d15bcd6fc054c64aa58c5a9f", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c394a7f49ac29a099994e243017065de2ff97f2a/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c394a7f49ac29a099994e243017065de2ff97f2a/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=c394a7f49ac29a099994e243017065de2ff97f2a", "patch": "@@ -677,7 +677,7 @@ fn T_opaque_chan_ptr() -> TypeRef { ret T_ptr(T_i8()); }\n // TODO: Enforce via a predicate.\n fn type_of(&@crate_ctxt cx, &span sp, &ty::t t) -> TypeRef {\n     if (ty::type_has_dynamic_size(cx.tcx, t)) {\n-        cx.sess.span_err(sp,\n+        cx.sess.span_fatal(sp,\n                          \"type_of() called on a type with dynamic size: \" +\n                              ty_to_str(cx.tcx, t));\n     }\n@@ -881,7 +881,7 @@ fn type_of_inner(&@crate_ctxt cx, &span sp, &ty::t t) -> TypeRef {\n             llty = abs_pair;\n         }\n         case (ty::ty_var(_)) {\n-            cx.tcx.sess.span_err(sp, \"trans::type_of called on ty_var\");\n+            cx.tcx.sess.span_fatal(sp, \"trans::type_of called on ty_var\");\n         }\n         case (ty::ty_param(_)) { llty = T_i8(); }\n         case (ty::ty_type) { llty = T_ptr(T_tydesc(cx.tn)); }\n@@ -1226,7 +1226,7 @@ fn simplify_type(&@crate_ctxt ccx, &ty::t typ) -> ty::t {\n // Computes the size of the data part of a non-dynamically-sized tag.\n fn static_size_of_tag(&@crate_ctxt cx, &span sp, &ty::t t) -> uint {\n     if (ty::type_has_dynamic_size(cx.tcx, t)) {\n-        cx.tcx.sess.span_err(sp,\n+        cx.tcx.sess.span_fatal(sp,\n                              \"dynamically sized type passed to \" +\n                                  \"static_size_of_tag()\");\n     }\n@@ -1236,7 +1236,7 @@ fn static_size_of_tag(&@crate_ctxt cx, &span sp, &ty::t t) -> uint {\n     alt (ty::struct(cx.tcx, t)) {\n         case (ty::ty_tag(?tid_, ?subtys_)) { tid = tid_; subtys = subtys_; }\n         case (_) {\n-            cx.tcx.sess.span_err(sp,\n+            cx.tcx.sess.span_fatal(sp,\n                                  \"non-tag passed to \" +\n                                      \"static_size_of_tag()\");\n         }\n@@ -5983,7 +5983,7 @@ fn trans_log(int lvl, &@block_ctxt cx, &@ast::expr e) -> result {\n             case (_) {\n                 // FIXME: Support these types.\n \n-                cx.fcx.lcx.ccx.sess.span_err(e.span,\n+                cx.fcx.lcx.ccx.sess.span_fatal(e.span,\n                                              \"log called on unsupported type \"\n                                                  +\n                                                  ty_to_str(cx.fcx.lcx.ccx.tcx,\n@@ -6088,7 +6088,7 @@ fn trans_break_cont(&span sp, &@block_ctxt cx, bool to_end) -> result {\n                 alt ({ cleanup_cx.parent }) {\n                     case (parent_some(?cx)) { cleanup_cx = cx; }\n                     case (parent_none) {\n-                        cx.fcx.lcx.ccx.sess.span_err(sp,\n+                        cx.fcx.lcx.ccx.sess.span_fatal(sp,\n                                                      if (to_end) {\n                                                          \"Break\"\n                                                      } else { \"Cont\" } +\n@@ -7621,7 +7621,7 @@ fn decl_fn_and_pair(&@crate_ctxt ccx, &span sp, vec[str] path, str flav,\n     register_fn_pair(ccx, ps, llfty, llfn, id);\n     if (is_main) {\n         if (ccx.main_fn != none[ValueRef]) {\n-            ccx.sess.span_err(sp, \"multiple 'main' functions\");\n+            ccx.sess.span_fatal(sp, \"multiple 'main' functions\");\n         }\n         llvm::LLVMSetLinkage(llfn,\n                              lib::llvm::LLVMExternalLinkage as llvm::Linkage);"}, {"sha": "efd69f137c6a5bb1361268f9a457a79665f50cbb", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c394a7f49ac29a099994e243017065de2ff97f2a/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c394a7f49ac29a099994e243017065de2ff97f2a/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=c394a7f49ac29a099994e243017065de2ff97f2a", "patch": "@@ -560,7 +560,7 @@ fn expr_to_constr_arg(ty::ctxt tcx, &@expr e) -> @constr_arg_use {\n         }\n         case (expr_lit(?l, _)) { ret @respan(e.span, carg_lit(l)); }\n         case (_) {\n-            tcx.sess.span_err(e.span,\n+            tcx.sess.span_fatal(e.span,\n                               \"Arguments to constrained functions must be \"\n                               + \"literals or local variables\");\n         }\n@@ -587,15 +587,15 @@ fn expr_to_constr(ty::ctxt tcx, &@expr e) -> constr {\n                                            exprs_to_constr_args(tcx, args))));\n                 }\n                 case (_) {\n-                    tcx.sess.span_err(operator.span,\n+                    tcx.sess.span_fatal(operator.span,\n                                       \"Internal error: \" +\n                                           \" ill-formed operator \\\n                                             in predicate\");\n                 }\n             }\n         }\n         case (_) {\n-            tcx.sess.span_err(e.span,\n+            tcx.sess.span_fatal(e.span,\n                               \"Internal error: \" + \" ill-formed predicate\");\n         }\n     }\n@@ -626,7 +626,8 @@ fn substitute_arg(&ty::ctxt cx, &vec[@expr] actuals, @ast::constr_arg a) ->\n             if (i < num_actuals) {\n                 ret expr_to_constr_arg(cx, actuals.(i));\n             } else {\n-                cx.sess.span_err(a.span, \"Constraint argument out of bounds\");\n+                cx.sess.span_fatal(a.span,\n+                                   \"Constraint argument out of bounds\");\n             }\n         }\n         case (carg_base) { ret @respan(a.span, carg_base); }\n@@ -636,7 +637,7 @@ fn substitute_arg(&ty::ctxt cx, &vec[@expr] actuals, @ast::constr_arg a) ->\n \n fn path_to_ident(&ty::ctxt cx, &path p) -> ident {\n     alt (vec::last(p.node.idents)) {\n-        case (none) { cx.sess.span_err(p.span, \"Malformed path\"); }\n+        case (none) { cx.sess.span_fatal(p.span, \"Malformed path\"); }\n         case (some(?i)) { ret i; }\n     }\n }"}, {"sha": "7098d070660fa987db476cb2fcc3462616f626fc", "filename": "src/comp/middle/tstate/ck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c394a7f49ac29a099994e243017065de2ff97f2a/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c394a7f49ac29a099994e243017065de2ff97f2a/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=c394a7f49ac29a099994e243017065de2ff97f2a", "patch": "@@ -85,7 +85,7 @@ fn check_states_expr(&fn_ctxt fcx, &@expr e) {\n         s += bitv_to_str(fcx, prec);\n         s += \"\\nPrestate:\\n\";\n         s += bitv_to_str(fcx, pres);\n-        fcx.ccx.tcx.sess.span_err(e.span, s);\n+        fcx.ccx.tcx.sess.span_fatal(e.span, s);\n     }\n }\n \n@@ -114,7 +114,7 @@ fn check_states_stmt(&fn_ctxt fcx, &@stmt s) {\n         ss += bitv_to_str(fcx, prec);\n         ss += \"\\nPrestate: \\n\";\n         ss += bitv_to_str(fcx, pres);\n-        fcx.ccx.tcx.sess.span_err(s.span, ss);\n+        fcx.ccx.tcx.sess.span_fatal(s.span, ss);\n     }\n }\n \n@@ -153,7 +153,7 @@ fn check_states_against_conditions(&fn_ctxt fcx, &_fn f, &ann a,\n                                    \"In function \" + fcx.name +\n                                        \", not all control paths \\\n                                         return a value\");\n-        fcx.ccx.tcx.sess.span_err(f.decl.output.span,\n+        fcx.ccx.tcx.sess.span_fatal(f.decl.output.span,\n                                   \"see declared return type of '\" +\n                                       ty_to_str(*f.decl.output) + \"'\");\n     } else if (f.decl.cf == noreturn) {\n@@ -162,7 +162,7 @@ fn check_states_against_conditions(&fn_ctxt fcx, &_fn f, &ann a,\n         // the fcx.id bit means \"returns\" for a returning fn,\n         // \"diverges\" for a non-returning fn\n         if (!promises(fcx, post, ret_c)) {\n-            fcx.ccx.tcx.sess.span_err(f.body.span,\n+            fcx.ccx.tcx.sess.span_fatal(f.body.span,\n                                       \"In non-returning function \" + fcx.name\n                                           +\n                                           \", some control paths may \\"}, {"sha": "825eed7024bb492f696529094188cb3d1e74fb74", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c394a7f49ac29a099994e243017065de2ff97f2a/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c394a7f49ac29a099994e243017065de2ff97f2a/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=c394a7f49ac29a099994e243017065de2ff97f2a", "patch": "@@ -1679,7 +1679,7 @@ fn field_num(&session::session sess, &span sp, &ast::ident id) -> uint {\n     for (u8 c in id) {\n         if (i == 0u) {\n             if (c != '_' as u8) {\n-                sess.span_err(sp,\n+                sess.span_fatal(sp,\n                               \"bad numeric field on tuple: \" +\n                                   \"missing leading underscore\");\n             }\n@@ -1690,7 +1690,7 @@ fn field_num(&session::session sess, &span sp, &ast::ident id) -> uint {\n             } else {\n                 auto s = \"\";\n                 s += str::unsafe_from_byte(c);\n-                sess.span_err(sp,\n+                sess.span_fatal(sp,\n                               \"bad numeric field on tuple: \" +\n                                   \" non-digit character: \" + s);\n             }\n@@ -1704,14 +1704,14 @@ fn field_idx(&session::session sess, &span sp, &ast::ident id,\n              &vec[field] fields) -> uint {\n     let uint i = 0u;\n     for (field f in fields) { if (str::eq(f.ident, id)) { ret i; } i += 1u; }\n-    sess.span_err(sp, \"unknown field '\" + id + \"' of record\");\n+    sess.span_fatal(sp, \"unknown field '\" + id + \"' of record\");\n }\n \n fn method_idx(&session::session sess, &span sp, &ast::ident id,\n               &vec[method] meths) -> uint {\n     let uint i = 0u;\n     for (method m in meths) { if (str::eq(m.ident, id)) { ret i; } i += 1u; }\n-    sess.span_err(sp, \"unknown method '\" + id + \"' of obj\");\n+    sess.span_fatal(sp, \"unknown method '\" + id + \"' of obj\");\n }\n \n fn sort_methods(&vec[method] meths) -> vec[method] {"}, {"sha": "42a4cec1499cc34512c949733c031221f3702a90", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/c394a7f49ac29a099994e243017065de2ff97f2a/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c394a7f49ac29a099994e243017065de2ff97f2a/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=c394a7f49ac29a099994e243017065de2ff97f2a", "patch": "@@ -114,7 +114,7 @@ fn ty_param_count_and_ty_for_def(&@fn_ctxt fcx, &span sp, &ast::def defn) ->\n             ret tup(0u, ty::mk_nil(fcx.ccx.tcx));\n         }\n         case (ast::def_ty(_)) {\n-            fcx.ccx.tcx.sess.span_err(sp, \"expected value but found type\");\n+            fcx.ccx.tcx.sess.span_fatal(sp, \"expected value but found type\");\n         }\n         case (_) {\n             // FIXME: handle other names.\n@@ -152,7 +152,7 @@ fn instantiate_path(&@fn_ctxt fcx, &ast::path pth, &ty_param_count_and_ty tpt,\n         }\n         ty_substs_opt = some[vec[ty::t]](ty_substs);\n         if (ty_param_count == 0u) {\n-            fcx.ccx.tcx.sess.span_err(sp,\n+            fcx.ccx.tcx.sess.span_fatal(sp,\n                                       \"this item does not take type \" +\n                                           \"parameters\");\n             fail;\n@@ -188,7 +188,7 @@ fn structurally_resolved_type(&@fn_ctxt fcx, &span sp, ty::t typ) -> ty::t {\n     alt (r) {\n         case (fix_ok(?typ_s)) { ret typ_s; }\n         case (fix_err(_)) {\n-            fcx.ccx.tcx.sess.span_err(sp,\n+            fcx.ccx.tcx.sess.span_fatal(sp,\n                                       \"the type of this value must be \" +\n                                           \"known in this context\");\n         }\n@@ -219,7 +219,7 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n     alt (tcx.ast_ty_to_ty_cache.find(ast_ty)) {\n         case (some[option::t[ty::t]](some[ty::t](?ty))) { ret ty; }\n         case (some[option::t[ty::t]](none)) {\n-            tcx.sess.span_err(ast_ty.span,\n+            tcx.sess.span_fatal(ast_ty.span,\n                               \"illegal recursive type \" +\n                               \"(insert a tag in the cycle, \" +\n                               \"if this is desired)\");\n@@ -252,7 +252,7 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n         }\n         if (vec::len(param_bindings) !=\n                 ty::count_ty_params(tcx, params_opt_and_ty._1)) {\n-            tcx.sess.span_err(sp,\n+            tcx.sess.span_fatal(sp,\n                               \"Wrong number of type arguments for a\" +\n                                   \" polymorphic tag\");\n         }\n@@ -333,7 +333,7 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n                 }\n                 case (ast::def_ty_arg(?id)) { typ = ty::mk_param(tcx, id); }\n                 case (_) {\n-                    tcx.sess.span_err(ast_ty.span,\n+                    tcx.sess.span_fatal(ast_ty.span,\n                                       \"found type name used as a variable\");\n                 }\n             }\n@@ -508,7 +508,7 @@ mod collect {\n         if (ty::type_has_dynamic_size(cx.tcx, tt)) {\n             alt (ty_mode) {\n                 case (mo_val) {\n-                    cx.tcx.sess.span_err(a.ty.span,\n+                    cx.tcx.sess.span_fatal(a.ty.span,\n                                          \"Dynamically sized arguments \\\n                                           must be passed by alias\");\n                 }\n@@ -916,7 +916,7 @@ mod demand {\n             case (ures_err(?err)) {\n                 auto e_err = resolve_type_vars_if_possible(fcx, expected_1);\n                 auto a_err = resolve_type_vars_if_possible(fcx, actual_1);\n-                fcx.ccx.tcx.sess.span_err(sp,\n+                fcx.ccx.tcx.sess.span_fatal(sp,\n                                           \"mismatched types: expected \" +\n                                               ty_to_str(fcx.ccx.tcx, e_err) +\n                                               \" but found \" +\n@@ -982,7 +982,7 @@ mod writeback {\n         alt (ty::unify::fixup_vars(fcx.ccx.tcx, fcx.var_bindings, typ)) {\n             case (fix_ok(?new_type)) { ret new_type; }\n             case (fix_err(?vid)) {\n-                fcx.ccx.tcx.sess.span_err(sp,\n+                fcx.ccx.tcx.sess.span_fatal(sp,\n                                           \"cannot determine a type \\\n                                            for this expression\");\n             }\n@@ -1026,7 +1026,7 @@ mod writeback {\n                 write::ty_only(fcx.ccx.tcx, l.node.ann.id, lty);\n             }\n             case (fix_err(_)) {\n-                fcx.ccx.tcx.sess.span_err(l.span,\n+                fcx.ccx.tcx.sess.span_fatal(l.span,\n                                           \"cannot determine a type \\\n                                            for this local variable\");\n             }\n@@ -1232,7 +1232,7 @@ fn check_pat(&@fn_ctxt fcx, &@ast::pat pat, ty::t expected) {\n                     // FIXME: Switch expected and actual in this message? I\n                     // can never tell.\n \n-                    fcx.ccx.tcx.sess.span_err(pat.span,\n+                    fcx.ccx.tcx.sess.span_fatal(pat.span,\n                                               #fmt(\"mismatched types: \\\n                                                     expected tag, found %s\",\n                                                    ty_to_str(fcx.ccx.tcx,\n@@ -1271,7 +1271,7 @@ fn check_pat(&@fn_ctxt fcx, &@ast::pat pat, ty::t expected) {\n                                   if (arg_len == 1u) {\n                                       \"\"\n                                   } else { \"s\" });\n-                    fcx.ccx.tcx.sess.span_err(pat.span, s);\n+                    fcx.ccx.tcx.sess.span_fatal(pat.span, s);\n                 }\n                 // TODO: vec::iter2\n \n@@ -1285,7 +1285,7 @@ fn check_pat(&@fn_ctxt fcx, &@ast::pat pat, ty::t expected) {\n                 // TODO (issue #448): Wrap a #fmt string over multiple\n                 // lines...\n \n-                fcx.ccx.tcx.sess.span_err(pat.span,\n+                fcx.ccx.tcx.sess.span_fatal(pat.span,\n                                           #fmt(\"this pattern has %u field%s, \\\n                                                 but the corresponding \\\n                                                 variant has no fields\",\n@@ -1303,7 +1303,7 @@ fn require_impure(&session::session sess, &ast::purity f_purity, &span sp) {\n     alt (f_purity) {\n         case (ast::impure_fn) { ret; }\n         case (ast::pure_fn) {\n-            sess.span_err(sp,\n+            sess.span_fatal(sp,\n                           \"Found impure expression in pure function decl\");\n         }\n     }\n@@ -1328,14 +1328,14 @@ fn require_pure_call(@crate_ctxt ccx, &ast::purity caller_purity,\n                     alt (get_function_purity(ccx, d_id)) {\n                         case (ast::pure_fn) { ret; }\n                         case (_) {\n-                            ccx.tcx.sess.span_err(sp,\n+                            ccx.tcx.sess.span_fatal(sp,\n                                                   \"Pure function calls \\\n                                                    impure function\");\n                         }\n                     }\n                 }\n                 case (_) {\n-                    ccx.tcx.sess.span_err(sp,\n+                    ccx.tcx.sess.span_fatal(sp,\n                                           \"Pure function calls \\\n                                            unknown function\");\n                 }\n@@ -1347,7 +1347,7 @@ fn require_pure_call(@crate_ctxt ccx, &ast::purity caller_purity,\n fn require_pure_function(@crate_ctxt ccx, &ast::def_id d_id, &span sp) {\n     alt (get_function_purity(ccx, d_id)) {\n         case (ast::impure_fn) {\n-            ccx.tcx.sess.span_err(sp,\n+            ccx.tcx.sess.span_fatal(sp,\n                                   \"Found non-predicate in check expression\");\n         }\n         case (_) { ret; }\n@@ -1376,7 +1376,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             case (ty::ty_fn(_, ?arg_tys_0, _, _, _)) { arg_tys = arg_tys_0; }\n             case (ty::ty_native_fn(_, ?arg_tys_0, _)) { arg_tys = arg_tys_0; }\n             case (_) {\n-                fcx.ccx.tcx.sess.span_err(f.span,\n+                fcx.ccx.tcx.sess.span_fatal(f.span,\n                                           \"mismatched types: \\\n                                            expected function or native \\\n                                            function but found \"\n@@ -1388,7 +1388,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n         auto expected_arg_count = vec::len[ty::arg](arg_tys);\n         auto supplied_arg_count = vec::len[option::t[@ast::expr]](args);\n         if (expected_arg_count != supplied_arg_count) {\n-            fcx.ccx.tcx.sess.span_err(sp,\n+            fcx.ccx.tcx.sess.span_fatal(sp,\n                                       #fmt(\"this function takes %u \\\n                                             parameter%s but %u parameter%s \\\n                                             supplied\",\n@@ -1474,20 +1474,20 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                                 if (!ast::is_constraint_arg(operand)) {\n                                     auto s = \"Constraint args must be \\\n                                               slot variables or literals\";\n-                                    fcx.ccx.tcx.sess.span_err(e.span, s);\n+                                    fcx.ccx.tcx.sess.span_fatal(e.span, s);\n                                 }\n                             }\n                             require_pure_function(fcx.ccx, d_id, e.span);\n                          }\n                         case (_) {\n                             auto s = \"In a constraint, expected the \\\n                                       constraint name to be an explicit name\";\n-                            fcx.ccx.tcx.sess.span_err(e.span,s);\n+                            fcx.ccx.tcx.sess.span_fatal(e.span,s);\n                         }\n                     }\n                 }\n                 case (_) {\n-                    fcx.ccx.tcx.sess.span_err(e.span,\n+                    fcx.ccx.tcx.sess.span_fatal(e.span,\n                                               \"check on non-predicate\");\n                 }\n             }\n@@ -1555,15 +1555,15 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                         case (_) {\n                             auto s = \"dereferencing non-box type: \" +\n                                 ty_to_str(fcx.ccx.tcx, oper_t);\n-                            fcx.ccx.tcx.sess.span_err(expr.span, s);\n+                            fcx.ccx.tcx.sess.span_fatal(expr.span, s);\n                         }\n                     }\n                 }\n                 case (ast::not) {\n                     if (!type_is_integral(fcx, oper.span, oper_t) &&\n                             structure_of(fcx, oper.span, oper_t) !=\n                                 ty::ty_bool) {\n-                        fcx.ccx.tcx.sess.span_err(expr.span,\n+                        fcx.ccx.tcx.sess.span_fatal(expr.span,\n                                                   #fmt(\"mismatched types: \\\n                                                         expected bool or \\\n                                                         integer but found %s\",\n@@ -1588,7 +1588,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             // supplied some, that's an error.\n \n             if (vec::len[@ast::ty](pth.node.types) > 0u) {\n-                fcx.ccx.tcx.sess.span_err(expr.span,\n+                fcx.ccx.tcx.sess.span_fatal(expr.span,\n                                           \"this kind of value does not \\\n                                            take type parameters\");\n             }\n@@ -1607,7 +1607,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                 case (none) {\n                     auto nil = ty::mk_nil(fcx.ccx.tcx);\n                     if (!are_compatible(fcx, fcx.ret_ty, nil)) {\n-                        fcx.ccx.tcx.sess.span_err(expr.span,\n+                        fcx.ccx.tcx.sess.span_fatal(expr.span,\n                                                   \"ret; in function \\\n                                                    returning non-nil\");\n                     }\n@@ -1627,7 +1627,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                 case (none) {\n                     auto nil = ty::mk_nil(fcx.ccx.tcx);\n                     if (!are_compatible(fcx, fcx.ret_ty, nil)) {\n-                        fcx.ccx.tcx.sess.span_err(expr.span,\n+                        fcx.ccx.tcx.sess.span_fatal(expr.span,\n                                                   \"put; in iterator \\\n                                                    yielding non-nil\");\n                     }\n@@ -1696,7 +1696,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                                    but found %s\",\n                                   ty_to_str(fcx.ccx.tcx,\n                                             lhs_t));\n-                    fcx.ccx.tcx.sess.span_err(expr.span,s);\n+                    fcx.ccx.tcx.sess.span_fatal(expr.span,s);\n                 }\n             }\n             write::ty_only_fixup(fcx, a.id, chan_t);\n@@ -1726,7 +1726,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                     elt_ty = ty::mk_mach(fcx.ccx.tcx, util::common::ty_u8);\n                 }\n                 case (_) {\n-                    fcx.ccx.tcx.sess.span_err(expr.span,\n+                    fcx.ccx.tcx.sess.span_fatal(expr.span,\n                                               \"type of for loop iterator \\\n                                                is not a vector or string\");\n                 }\n@@ -1916,7 +1916,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n \n             if (!(type_is_scalar(fcx, expr.span, expr_ty(fcx.ccx.tcx, e)) &&\n                       type_is_scalar(fcx, expr.span, t_1))) {\n-                fcx.ccx.tcx.sess.span_err(expr.span,\n+                fcx.ccx.tcx.sess.span_fatal(expr.span,\n                                           \"non-scalar cast: \" +\n                                               ty_to_str(fcx.ccx.tcx,\n                                                         expr_ty(fcx.ccx.tcx,\n@@ -1984,7 +1984,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                     alt (structure_of(fcx, expr.span, bexpr_t)) {\n                         case (ty::ty_rec(?flds)) { base_fields = flds; }\n                         case (_) {\n-                            fcx.ccx.tcx.sess.span_err(expr.span,\n+                            fcx.ccx.tcx.sess.span_fatal(expr.span,\n                                                       \"record update \\\n                                                        non-record base\");\n                         }\n@@ -2000,7 +2000,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                             }\n                         }\n                         if (!found) {\n-                            fcx.ccx.tcx.sess.span_err(expr.span,\n+                            fcx.ccx.tcx.sess.span_fatal(expr.span,\n                                                       \"unknown field in \\\n                                                        record update: \"\n                                                       + f.ident);\n@@ -2018,7 +2018,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                     let uint ix =\n                         ty::field_num(fcx.ccx.tcx.sess, expr.span, field);\n                     if (ix >= vec::len[ty::mt](args)) {\n-                        fcx.ccx.tcx.sess.span_err(expr.span,\n+                        fcx.ccx.tcx.sess.span_fatal(expr.span,\n                                                   \"bad index on tuple\");\n                     }\n                     write::ty_only_fixup(fcx, a.id, args.(ix).ty);\n@@ -2028,7 +2028,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                         ty::field_idx(fcx.ccx.tcx.sess, expr.span, field,\n                                       fields);\n                     if (ix >= vec::len[ty::field](fields)) {\n-                        fcx.ccx.tcx.sess.span_err(expr.span,\n+                        fcx.ccx.tcx.sess.span_fatal(expr.span,\n                                                   \"bad index on record\");\n                     }\n                     write::ty_only_fixup(fcx, a.id, fields.(ix).mt.ty);\n@@ -2038,7 +2038,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                         ty::method_idx(fcx.ccx.tcx.sess, expr.span, field,\n                                        methods);\n                     if (ix >= vec::len[ty::method](methods)) {\n-                        fcx.ccx.tcx.sess.span_err(expr.span,\n+                        fcx.ccx.tcx.sess.span_fatal(expr.span,\n                                                   \"bad index on obj\");\n                     }\n                     auto meth = methods.(ix);\n@@ -2063,7 +2063,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             check_expr(fcx, idx);\n             auto idx_t = expr_ty(fcx.ccx.tcx, idx);\n             if (!type_is_integral(fcx, idx.span, idx_t)) {\n-                fcx.ccx.tcx.sess.span_err(idx.span,\n+                fcx.ccx.tcx.sess.span_fatal(idx.span,\n                                           \"mismatched types: expected \\\n                                            integer but found \"\n                                           + ty_to_str(fcx.ccx.tcx, idx_t));\n@@ -2084,7 +2084,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                     write::ty_only_fixup(fcx, a.id, typ);\n                 }\n                 case (_) {\n-                    fcx.ccx.tcx.sess.span_err(expr.span,\n+                    fcx.ccx.tcx.sess.span_fatal(expr.span,\n                                               \"vector-indexing bad type: \" +\n                                                   ty_to_str(fcx.ccx.tcx,\n                                                             base_t));\n@@ -2105,7 +2105,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                     write::ty_only_fixup(fcx, a.id, ct);\n                 }\n                 case (_) {\n-                    fcx.ccx.tcx.sess.span_err(expr.span,\n+                    fcx.ccx.tcx.sess.span_fatal(expr.span,\n                                               \"bad port type: \" +\n                                                   ty_to_str(fcx.ccx.tcx,\n                                                             port_t));\n@@ -2218,7 +2218,7 @@ fn ast_constr_to_constr(ty::ctxt tcx, &@ast::constr c)\n                                     id=pred_id));\n         }\n         case (_) {\n-            tcx.sess.span_err(c.span, \"Predicate \"\n+            tcx.sess.span_fatal(c.span, \"Predicate \"\n                               + path_to_str(c.node.path)\n                               + \" is unbound or bound to a non-function\");\n         }\n@@ -2339,7 +2339,7 @@ fn check_fn(&@crate_ctxt ccx, &ast::fn_decl decl, ast::proto proto,\n             // per the previous comment, this just checks that the declared\n             // type is bool, and trusts that that's the actual return type.\n             if (!ty::type_is_bool(ccx.tcx, fcx.ret_ty)) {\n-                ccx.tcx.sess.span_err(body.span,\n+                ccx.tcx.sess.span_fatal(body.span,\n                                       \"Non-boolean return type in pred\");\n             }\n         }"}]}