{"sha": "659994627234ce7d95a1a52ad8756ce661059adf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1OTk5NDYyNzIzNGNlN2Q5NWExYTUyYWQ4NzU2Y2U2NjEwNTlhZGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-17T07:36:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-17T07:36:37Z"}, "message": "Auto merge of #57520 - alexreg:tidy-copyright-lint, r=Mark-Simulacrum\n\nAdd lint for copyright headers to 'tidy' tool\n\nr? @Mark-Simulacrum\n\nCC @centril", "tree": {"sha": "586c03dceeb3feed831dbfd4c5233f8ceef76ae8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/586c03dceeb3feed831dbfd4c5233f8ceef76ae8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/659994627234ce7d95a1a52ad8756ce661059adf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/659994627234ce7d95a1a52ad8756ce661059adf", "html_url": "https://github.com/rust-lang/rust/commit/659994627234ce7d95a1a52ad8756ce661059adf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/659994627234ce7d95a1a52ad8756ce661059adf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "722b4d695964906807b12379577bce5ee3d23e08", "url": "https://api.github.com/repos/rust-lang/rust/commits/722b4d695964906807b12379577bce5ee3d23e08", "html_url": "https://github.com/rust-lang/rust/commit/722b4d695964906807b12379577bce5ee3d23e08"}, {"sha": "4d1802308b128c757d443d39945bd335515ef4ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d1802308b128c757d443d39945bd335515ef4ee", "html_url": "https://github.com/rust-lang/rust/commit/4d1802308b128c757d443d39945bd335515ef4ee"}], "stats": {"total": 372, "additions": 165, "deletions": 207}, "files": [{"sha": "0e9061cbaf95adfb9f3ed36c6cef4c046f282e86", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=659994627234ce7d95a1a52ad8756ce661059adf", "patch": "@@ -1 +1 @@\n-Subproject commit 74d81d80052cb88925f0e73b12fbd0b73ab7b5a0\n+Subproject commit 0e9061cbaf95adfb9f3ed36c6cef4c046f282e86"}, {"sha": "1c775a1dc5e29bc44b36604b510d6196d98077fa", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=659994627234ce7d95a1a52ad8756ce661059adf", "patch": "@@ -1 +1 @@\n-Subproject commit 60077efda319c95a89fe39609803c5433567adbf\n+Subproject commit 1c775a1dc5e29bc44b36604b510d6196d98077fa"}, {"sha": "312838a170c6b7423dabead7f3a50bb04fec79b8", "filename": "src/libcore/slice/memchr.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/659994627234ce7d95a1a52ad8756ce661059adf/src%2Flibcore%2Fslice%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/659994627234ce7d95a1a52ad8756ce661059adf/src%2Flibcore%2Fslice%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmemchr.rs?ref=659994627234ce7d95a1a52ad8756ce661059adf", "patch": "@@ -1,5 +1,4 @@\n-//\n-// Original implementation taken from rust-memchr\n+// Original implementation taken from rust-memchr.\n // Copyright 2015 Andrew Gallant, bluss and Nicolas Koch\n \n use cmp;\n@@ -8,13 +7,13 @@ use mem;\n const LO_U64: u64 = 0x0101010101010101;\n const HI_U64: u64 = 0x8080808080808080;\n \n-// use truncation\n+// Use truncation.\n const LO_USIZE: usize = LO_U64 as usize;\n const HI_USIZE: usize = HI_U64 as usize;\n \n-/// Return `true` if `x` contains any zero byte.\n+/// Returns whether `x` contains any zero byte.\n ///\n-/// From *Matters Computational*, J. Arndt\n+/// From *Matters Computational*, J. Arndt:\n ///\n /// \"The idea is to subtract one from each of the bytes and then look for\n /// bytes where the borrow propagated all the way to the most significant\n@@ -36,7 +35,7 @@ fn repeat_byte(b: u8) -> usize {\n     (b as usize) * (::usize::MAX / 255)\n }\n \n-/// Return the first index matching the byte `x` in `text`.\n+/// Returns the first index matching the byte `x` in `text`.\n pub fn memchr(x: u8, text: &[u8]) -> Option<usize> {\n     // Scan for a single byte value by reading two `usize` words at a time.\n     //\n@@ -77,18 +76,18 @@ pub fn memchr(x: u8, text: &[u8]) -> Option<usize> {\n         }\n     }\n \n-    // find the byte after the point the body loop stopped\n+    // Find the byte after the point the body loop stopped.\n     text[offset..].iter().position(|elt| *elt == x).map(|i| offset + i)\n }\n \n-/// Return the last index matching the byte `x` in `text`.\n+/// Returns the last index matching the byte `x` in `text`.\n pub fn memrchr(x: u8, text: &[u8]) -> Option<usize> {\n     // Scan for a single byte value by reading two `usize` words at a time.\n     //\n-    // Split `text` in three parts\n-    // - unaligned tail, after the last word aligned address in text\n-    // - body, scan by 2 words at a time\n-    // - the first remaining bytes, < 2 word size\n+    // Split `text` in three parts:\n+    // - unaligned tail, after the last word aligned address in text,\n+    // - body, scanned by 2 words at a time,\n+    // - the first remaining bytes, < 2 word size.\n     let len = text.len();\n     let ptr = text.as_ptr();\n     type Chunk = usize;\n@@ -105,7 +104,7 @@ pub fn memrchr(x: u8, text: &[u8]) -> Option<usize> {\n         return Some(offset + index);\n     }\n \n-    // search the body of the text, make sure we don't cross min_aligned_offset.\n+    // Search the body of the text, make sure we don't cross min_aligned_offset.\n     // offset is always aligned, so just testing `>` is sufficient and avoids possible\n     // overflow.\n     let repeated_x = repeat_byte(x);\n@@ -116,7 +115,7 @@ pub fn memrchr(x: u8, text: &[u8]) -> Option<usize> {\n             let u = *(ptr.offset(offset as isize - 2 * chunk_bytes as isize) as *const Chunk);\n             let v = *(ptr.offset(offset as isize - chunk_bytes as isize) as *const Chunk);\n \n-            // break if there is a matching byte\n+            // Break if there is a matching byte.\n             let zu = contains_zero_byte(u ^ repeated_x);\n             let zv = contains_zero_byte(v ^ repeated_x);\n             if zu || zv {\n@@ -126,6 +125,6 @@ pub fn memrchr(x: u8, text: &[u8]) -> Option<usize> {\n         offset -= 2 * chunk_bytes;\n     }\n \n-    // find the byte before the point the body loop stopped\n+    // Find the byte before the point the body loop stopped.\n     text[..offset].iter().rposition(|elt| *elt == x)\n }"}, {"sha": "362b4574ee24ed4559c179ed73b3cc6111fc196b", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/659994627234ce7d95a1a52ad8756ce661059adf/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/659994627234ce7d95a1a52ad8756ce661059adf/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=659994627234ce7d95a1a52ad8756ce661059adf", "patch": "@@ -1,4 +1,4 @@\n-// Rust JSON serialization library\n+// Rust JSON serialization library.\n // Copyright (c) 2011 Google Inc.\n \n #![forbid(non_camel_case_types)]"}, {"sha": "9f44c67c1cc5cb2256c574222bd76b23f0b55c71", "filename": "src/libstd/memchr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/659994627234ce7d95a1a52ad8756ce661059adf/src%2Flibstd%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/659994627234ce7d95a1a52ad8756ce661059adf/src%2Flibstd%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmemchr.rs?ref=659994627234ce7d95a1a52ad8756ce661059adf", "patch": "@@ -1,5 +1,4 @@\n-//\n-// Original implementation taken from rust-memchr\n+// Original implementation taken from rust-memchr.\n // Copyright 2015 Andrew Gallant, bluss and Nicolas Koch\n \n /// A safe interface to `memchr`."}, {"sha": "0bf8c2d599813d12ea73db6f8155198bf2910ea8", "filename": "src/libstd/sys/cloudabi/abi/cloudabi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/659994627234ce7d95a1a52ad8756ce661059adf/src%2Flibstd%2Fsys%2Fcloudabi%2Fabi%2Fcloudabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/659994627234ce7d95a1a52ad8756ce661059adf/src%2Flibstd%2Fsys%2Fcloudabi%2Fabi%2Fcloudabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fabi%2Fcloudabi.rs?ref=659994627234ce7d95a1a52ad8756ce661059adf", "patch": "@@ -1,4 +1,4 @@\n-// Copyright (c) 2016-2017 Nuxi (https://nuxi.nl/) and contributors.\n+// Copyright (c) 2016-2017 Nuxi <https://nuxi.nl/> and contributors.\n //\n // Redistribution and use in source and binary forms, with or without\n // modification, are permitted provided that the following conditions"}, {"sha": "d2bfcce86f414bca0c93bad4a80f22bcaf354ca9", "filename": "src/libstd/sys/redox/memchr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/659994627234ce7d95a1a52ad8756ce661059adf/src%2Flibstd%2Fsys%2Fredox%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/659994627234ce7d95a1a52ad8756ce661059adf/src%2Flibstd%2Fsys%2Fredox%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fmemchr.rs?ref=659994627234ce7d95a1a52ad8756ce661059adf", "patch": "@@ -1,5 +1,4 @@\n-//\n-// Original implementation taken from rust-memchr\n+// Original implementation taken from rust-memchr.\n // Copyright 2015 Andrew Gallant, bluss and Nicolas Koch\n \n pub use core::slice::memchr::{memchr, memrchr};"}, {"sha": "ec04a22a0d2e841e69e9c54a117396891f4b7f57", "filename": "src/libstd/sys/unix/memchr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/659994627234ce7d95a1a52ad8756ce661059adf/src%2Flibstd%2Fsys%2Funix%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/659994627234ce7d95a1a52ad8756ce661059adf/src%2Flibstd%2Fsys%2Funix%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmemchr.rs?ref=659994627234ce7d95a1a52ad8756ce661059adf", "patch": "@@ -1,5 +1,4 @@\n-//\n-// Original implementation taken from rust-memchr\n+// Original implementation taken from rust-memchr.\n // Copyright 2015 Andrew Gallant, bluss and Nicolas Koch\n \n pub fn memchr(needle: u8, haystack: &[u8]) -> Option<usize> {"}, {"sha": "b9e5bcc1b4bbd26d1532f2e84be0e0819ad01759", "filename": "src/libstd/sys/windows/memchr.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/659994627234ce7d95a1a52ad8756ce661059adf/src%2Flibstd%2Fsys%2Fwindows%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/659994627234ce7d95a1a52ad8756ce661059adf/src%2Flibstd%2Fsys%2Fwindows%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmemchr.rs?ref=659994627234ce7d95a1a52ad8756ce661059adf", "patch": "@@ -1,6 +1,5 @@\n-//\n-// Original implementation taken from rust-memchr\n+// Original implementation taken from rust-memchr.\n // Copyright 2015 Andrew Gallant, bluss and Nicolas Koch\n \n-// Fallback memchr is fastest on windows\n+// Fallback memchr is fastest on Windows.\n pub use core::slice::memchr::{memchr, memrchr};"}, {"sha": "cf11ac550b76388c1a89e618d224f556f8047cec", "filename": "src/libsyntax/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/659994627234ce7d95a1a52ad8756ce661059adf/src%2Flibsyntax%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/659994627234ce7d95a1a52ad8756ce661059adf/src%2Flibsyntax%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fjson.rs?ref=659994627234ce7d95a1a52ad8756ce661059adf", "patch": "@@ -7,7 +7,7 @@\n //! The format of the JSON output should be considered *unstable*. For now the\n //! structs at the end of this file (Diagnostic*) specify the error format.\n \n-// FIXME spec the JSON output properly.\n+// FIXME: spec the JSON output properly.\n \n use source_map::{SourceMap, FilePathMapping};\n use syntax_pos::{self, MacroBacktrace, Span, SpanLabel, MultiSpan};"}, {"sha": "bca1d7a72b4abc77cb687271b5e9732976662f7e", "filename": "src/test/compile-fail-fulldeps/auxiliary/lint_group_plugin_test.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/659994627234ce7d95a1a52ad8756ce661059adf/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Flint_group_plugin_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/659994627234ce7d95a1a52ad8756ce661059adf/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Flint_group_plugin_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Flint_group_plugin_test.rs?ref=659994627234ce7d95a1a52ad8756ce661059adf", "patch": "@@ -1,13 +1,3 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n // force-host\n \n #![feature(plugin_registrar)]"}, {"sha": "b74eba3f66b81272a8d2a354cd0ac241b518545e", "filename": "src/test/rustdoc-ui/deny-missing-docs-crate.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/659994627234ce7d95a1a52ad8756ce661059adf/src%2Ftest%2Frustdoc-ui%2Fdeny-missing-docs-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/659994627234ce7d95a1a52ad8756ce661059adf/src%2Ftest%2Frustdoc-ui%2Fdeny-missing-docs-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fdeny-missing-docs-crate.rs?ref=659994627234ce7d95a1a52ad8756ce661059adf", "patch": "@@ -1,13 +1,3 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n #![deny(missing_docs)] //~ ERROR\n \n pub struct Foo; //~ ERROR"}, {"sha": "1cfd6092cb3a5f85da08d2c94cd6861fb2d4b48d", "filename": "src/test/rustdoc-ui/deny-missing-docs-crate.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/659994627234ce7d95a1a52ad8756ce661059adf/src%2Ftest%2Frustdoc-ui%2Fdeny-missing-docs-crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/659994627234ce7d95a1a52ad8756ce661059adf/src%2Ftest%2Frustdoc-ui%2Fdeny-missing-docs-crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fdeny-missing-docs-crate.stderr?ref=659994627234ce7d95a1a52ad8756ce661059adf", "patch": "@@ -1,19 +1,19 @@\n error: missing documentation for crate\n-  --> $DIR/deny-missing-docs-crate.rs:11:1\n+  --> $DIR/deny-missing-docs-crate.rs:1:1\n    |\n LL | / #![deny(missing_docs)] //~ ERROR\n LL | |\n LL | | pub struct Foo; //~ ERROR\n    | |_______________^\n    |\n note: lint level defined here\n-  --> $DIR/deny-missing-docs-crate.rs:11:9\n+  --> $DIR/deny-missing-docs-crate.rs:1:9\n    |\n LL | #![deny(missing_docs)] //~ ERROR\n    |         ^^^^^^^^^^^^\n \n error: missing documentation for a struct\n-  --> $DIR/deny-missing-docs-crate.rs:13:1\n+  --> $DIR/deny-missing-docs-crate.rs:3:1\n    |\n LL | pub struct Foo; //~ ERROR\n    | ^^^^^^^^^^^^^^^"}, {"sha": "b1c1253176b303dc9401929865abc75d4cd7c748", "filename": "src/test/rustdoc-ui/deny-missing-docs-macro.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/659994627234ce7d95a1a52ad8756ce661059adf/src%2Ftest%2Frustdoc-ui%2Fdeny-missing-docs-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/659994627234ce7d95a1a52ad8756ce661059adf/src%2Ftest%2Frustdoc-ui%2Fdeny-missing-docs-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fdeny-missing-docs-macro.rs?ref=659994627234ce7d95a1a52ad8756ce661059adf", "patch": "@@ -1,13 +1,3 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n //! foo\n \n #![deny(missing_docs)]"}, {"sha": "b87e60d8269ea24202cc45068226c8b603e3caa5", "filename": "src/test/rustdoc-ui/deny-missing-docs-macro.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/659994627234ce7d95a1a52ad8756ce661059adf/src%2Ftest%2Frustdoc-ui%2Fdeny-missing-docs-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/659994627234ce7d95a1a52ad8756ce661059adf/src%2Ftest%2Frustdoc-ui%2Fdeny-missing-docs-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fdeny-missing-docs-macro.stderr?ref=659994627234ce7d95a1a52ad8756ce661059adf", "patch": "@@ -1,11 +1,11 @@\n error: missing documentation for macro\n-  --> $DIR/deny-missing-docs-macro.rs:16:1\n+  --> $DIR/deny-missing-docs-macro.rs:6:1\n    |\n LL | macro_rules! foo { //~ ERROR\n    | ^^^^^^^^^^^^^^^^\n    |\n note: lint level defined here\n-  --> $DIR/deny-missing-docs-macro.rs:13:9\n+  --> $DIR/deny-missing-docs-macro.rs:3:9\n    |\n LL | #![deny(missing_docs)]\n    |         ^^^^^^^^^^^^"}, {"sha": "eff47e8d8dde921c413999ac40ad55de1fd2d009", "filename": "src/test/rustdoc/auxiliary/enum_primitive.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/659994627234ce7d95a1a52ad8756ce661059adf/src%2Ftest%2Frustdoc%2Fauxiliary%2Fenum_primitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/659994627234ce7d95a1a52ad8756ce661059adf/src%2Ftest%2Frustdoc%2Fauxiliary%2Fenum_primitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fauxiliary%2Fenum_primitive.rs?ref=659994627234ce7d95a1a52ad8756ce661059adf", "patch": "@@ -19,7 +19,6 @@\n // TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n // SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n \n-\n //! This crate exports a macro `enum_from_primitive!` that wraps an\n //! `enum` declaration and automatically adds an implementation of\n //! `num::FromPrimitive` (reexported here), to allow conversion from\n@@ -52,7 +51,6 @@\n //! }\n //! ```\n \n-\n pub mod num_traits {\n     pub trait FromPrimitive: Sized {\n         fn from_i64(n: i64) -> Option<Self>;\n@@ -207,4 +205,3 @@ macro_rules! enum_from_primitive {\n         enum_from_primitive_impl! { $name, $( $( $variant )+ )+ }\n     };\n }\n-"}, {"sha": "c694d1456ef349558fd768982a37af526f518908", "filename": "src/test/rustdoc/no-crate-filter.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/659994627234ce7d95a1a52ad8756ce661059adf/src%2Ftest%2Frustdoc%2Fno-crate-filter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/659994627234ce7d95a1a52ad8756ce661059adf/src%2Ftest%2Frustdoc%2Fno-crate-filter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fno-crate-filter.rs?ref=659994627234ce7d95a1a52ad8756ce661059adf", "patch": "@@ -1,13 +1,3 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n #![crate_name = \"foo\"]\n \n // compile-flags: -Z unstable-options --disable-per-crate-search"}, {"sha": "c7d3304a128ddcff548f9a6f60b42d70dce98560", "filename": "src/test/ui/feature-gates/feature-gate-type_alias_enum_variants.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/659994627234ce7d95a1a52ad8756ce661059adf/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_enum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/659994627234ce7d95a1a52ad8756ce661059adf/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_enum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_enum_variants.rs?ref=659994627234ce7d95a1a52ad8756ce661059adf", "patch": "@@ -1,13 +1,3 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n enum Foo {\n     Bar(i32),\n     Baz { i: i32 },"}, {"sha": "43535af7c69d8aef897234e0a255ac0bcc7552c3", "filename": "src/test/ui/feature-gates/feature-gate-type_alias_enum_variants.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/659994627234ce7d95a1a52ad8756ce661059adf/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_enum_variants.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/659994627234ce7d95a1a52ad8756ce661059adf/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_enum_variants.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-type_alias_enum_variants.stderr?ref=659994627234ce7d95a1a52ad8756ce661059adf", "patch": "@@ -1,29 +1,29 @@\n error: enum variants on type aliases are experimental\n-  --> $DIR/feature-gate-type_alias_enum_variants.rs:19:13\n+  --> $DIR/feature-gate-type_alias_enum_variants.rs:9:13\n    |\n LL |     let t = Alias::Bar(0);\n    |             ^^^^^^^^^^\n    |\n    = help: add `#![feature(type_alias_enum_variants)]` to the crate attributes to enable\n \n error: enum variants on type aliases are experimental\n-  --> $DIR/feature-gate-type_alias_enum_variants.rs:21:13\n+  --> $DIR/feature-gate-type_alias_enum_variants.rs:11:13\n    |\n LL |     let t = Alias::Baz { i: 0 };\n    |             ^^^^^^^^^^\n    |\n    = help: add `#![feature(type_alias_enum_variants)]` to the crate attributes to enable\n \n error: enum variants on type aliases are experimental\n-  --> $DIR/feature-gate-type_alias_enum_variants.rs:24:9\n+  --> $DIR/feature-gate-type_alias_enum_variants.rs:14:9\n    |\n LL |         Alias::Bar(_i) => {}\n    |         ^^^^^^^^^^^^^^\n    |\n    = help: add `#![feature(type_alias_enum_variants)]` to the crate attributes to enable\n \n error: enum variants on type aliases are experimental\n-  --> $DIR/feature-gate-type_alias_enum_variants.rs:26:9\n+  --> $DIR/feature-gate-type_alias_enum_variants.rs:16:9\n    |\n LL |         Alias::Baz { i: _i } => {}\n    |         ^^^^^^^^^^"}, {"sha": "610d1d8af3b5e8fbe834540b9509b87c61142ca2", "filename": "src/tools/tidy/src/bins.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/659994627234ce7d95a1a52ad8756ce661059adf/src%2Ftools%2Ftidy%2Fsrc%2Fbins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/659994627234ce7d95a1a52ad8756ce661059adf/src%2Ftools%2Ftidy%2Fsrc%2Fbins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fbins.rs?ref=659994627234ce7d95a1a52ad8756ce661059adf", "patch": "@@ -2,12 +2,12 @@\n //! by accident.\n //!\n //! In the past we've accidentally checked in test binaries and such which add a\n-//! huge amount of bloat to the git history, so it's good to just ensure we\n-//! don't do that again :)\n+//! huge amount of bloat to the Git history, so it's good to just ensure we\n+//! don't do that again.\n \n use std::path::Path;\n \n-// All files are executable on Windows, so just check on Unix\n+// All files are executable on Windows, so just check on Unix.\n #[cfg(windows)]\n pub fn check(_path: &Path, _bad: &mut bool) {}\n "}, {"sha": "26ced7fc8297acc28d13325dccaac555fc1ac3d1", "filename": "src/tools/tidy/src/cargo.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/659994627234ce7d95a1a52ad8756ce661059adf/src%2Ftools%2Ftidy%2Fsrc%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/659994627234ce7d95a1a52ad8756ce661059adf/src%2Ftools%2Ftidy%2Fsrc%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fcargo.rs?ref=659994627234ce7d95a1a52ad8756ce661059adf", "patch": "@@ -13,7 +13,7 @@ pub fn check(path: &Path, bad: &mut bool) {\n         return\n     }\n     for entry in t!(path.read_dir(), path).map(|e| t!(e)) {\n-        // Look for `Cargo.toml` with a sibling `src/lib.rs` or `lib.rs`\n+        // Look for `Cargo.toml` with a sibling `src/lib.rs` or `lib.rs`.\n         if entry.file_name().to_str() == Some(\"Cargo.toml\") {\n             if path.join(\"src/lib.rs\").is_file() {\n                 verify(&entry.path(), &path.join(\"src/lib.rs\"), bad)\n@@ -27,8 +27,8 @@ pub fn check(path: &Path, bad: &mut bool) {\n     }\n }\n \n-// Verify that the dependencies in Cargo.toml at `tomlfile` are sync'd with the\n-// `extern crate` annotations in the lib.rs at `libfile`.\n+/// Verifies that the dependencies in Cargo.toml at `tomlfile` are synced with\n+/// the `extern crate` annotations in the lib.rs at `libfile`.\n fn verify(tomlfile: &Path, libfile: &Path, bad: &mut bool) {\n     let toml = t!(fs::read_to_string(&tomlfile));\n     let librs = t!(fs::read_to_string(&libfile));\n@@ -37,14 +37,16 @@ fn verify(tomlfile: &Path, libfile: &Path, bad: &mut bool) {\n         return\n     }\n \n-    // \"Poor man's TOML parser\", just assume we use one syntax for now\n+    // \"Poor man's TOML parser\" -- just assume we use one syntax for now.\n     //\n     // We just look for:\n     //\n-    //      [dependencies]\n-    //      name = ...\n-    //      name2 = ...\n-    //      name3 = ...\n+    // ````\n+    // [dependencies]\n+    // name = ...\n+    // name2 = ...\n+    // name3 = ...\n+    // ```\n     //\n     // If we encounter a line starting with `[` then we assume it's the end of\n     // the dependency section and bail out.\n@@ -63,14 +65,14 @@ fn verify(tomlfile: &Path, libfile: &Path, bad: &mut bool) {\n             continue\n         }\n \n-        // Don't worry about depending on core/std but not saying `extern crate\n-        // core/std`, that's intentional.\n+        // Don't worry about depending on core/std while not writing `extern crate\n+        // core/std` -- that's intentional.\n         if krate == \"core\" || krate == \"std\" {\n             continue\n         }\n \n-        // This is intentional, this dependency just makes the crate available\n-        // for others later on. Cover cases\n+        // This is intentional -- this dependency just makes the crate available\n+        // for others later on.\n         let whitelisted = krate.starts_with(\"panic\");\n         if toml.contains(\"name = \\\"std\\\"\") && whitelisted {\n             continue"}, {"sha": "f1bfb6efc2f0712ed1d6cba64a53a3265205f0b7", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/659994627234ce7d95a1a52ad8756ce661059adf/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/659994627234ce7d95a1a52ad8756ce661059adf/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=659994627234ce7d95a1a52ad8756ce661059adf", "patch": "@@ -1,4 +1,4 @@\n-//! Check license of third-party deps by inspecting vendor\n+//! Checks the licenses of third-party dependencies by inspecting vendors.\n \n use std::collections::{BTreeSet, HashSet, HashMap};\n use std::fs;\n@@ -21,7 +21,7 @@ const LICENSES: &[&str] = &[\n /// These are exceptions to Rust's permissive licensing policy, and\n /// should be considered bugs. Exceptions are only allowed in Rust\n /// tooling. It is _crucial_ that no exception crates be dependencies\n-/// of the Rust runtime (std / test).\n+/// of the Rust runtime (std/test).\n const EXCEPTIONS: &[&str] = &[\n     \"mdbook\",             // MPL2, mdbook\n     \"openssl\",            // BSD+advertising clause, cargo, mdbook\n@@ -39,11 +39,11 @@ const EXCEPTIONS: &[&str] = &[\n     \"colored\",            // MPL-2.0, rustfmt\n     \"ordslice\",           // Apache-2.0, rls\n     \"cloudabi\",           // BSD-2-Clause, (rls -> crossbeam-channel 0.2 -> rand 0.5)\n-    \"ryu\",                // Apache-2.0, rls/cargo/... (b/c of serde)\n+    \"ryu\",                // Apache-2.0, rls/cargo/... (because of serde)\n     \"bytesize\",           // Apache-2.0, cargo\n     \"im-rc\",              // MPL-2.0+, cargo\n     \"adler32\",            // BSD-3-Clause AND Zlib, cargo dep that isn't used\n-    \"fortanix-sgx-abi\",   // MPL-2.0+, libstd but only for sgx target\n+    \"fortanix-sgx-abi\",   // MPL-2.0+, libstd but only for `sgx` target\n ];\n \n /// Which crates to check against the whitelist?\n@@ -156,7 +156,7 @@ const WHITELIST: &[Crate] = &[\n     Crate(\"wincolor\"),\n ];\n \n-// Some types for Serde to deserialize the output of `cargo metadata` to...\n+// Some types for Serde to deserialize the output of `cargo metadata` to.\n \n #[derive(Deserialize)]\n struct Output {\n@@ -174,9 +174,9 @@ struct ResolveNode {\n     dependencies: Vec<String>,\n }\n \n-/// A unique identifier for a crate\n+/// A unique identifier for a crate.\n #[derive(Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Debug, Hash)]\n-struct Crate<'a>(&'a str); // (name,)\n+struct Crate<'a>(&'a str); // (name)\n \n #[derive(Copy, Clone, PartialOrd, Ord, PartialEq, Eq, Debug, Hash)]\n struct CrateVersion<'a>(&'a str, &'a str); // (name, version)\n@@ -188,7 +188,7 @@ impl<'a> Crate<'a> {\n }\n \n impl<'a> CrateVersion<'a> {\n-    /// Returns the struct and whether or not the dep is in-tree\n+    /// Returns the struct and whether or not the dependency is in-tree.\n     pub fn from_str(s: &'a str) -> (Self, bool) {\n         let mut parts = s.split(' ');\n         let name = parts.next().unwrap();\n@@ -215,15 +215,15 @@ impl<'a> From<CrateVersion<'a>> for Crate<'a> {\n ///\n /// Specifically, this checks that the license is correct.\n pub fn check(path: &Path, bad: &mut bool) {\n-    // Check licences\n+    // Check licences.\n     let path = path.join(\"../vendor\");\n     assert!(path.exists(), \"vendor directory missing\");\n     let mut saw_dir = false;\n     for dir in t!(path.read_dir()) {\n         saw_dir = true;\n         let dir = t!(dir);\n \n-        // skip our exceptions\n+        // Skip our exceptions.\n         let is_exception = EXCEPTIONS.iter().any(|exception| {\n             dir.path()\n                 .to_str()\n@@ -240,18 +240,18 @@ pub fn check(path: &Path, bad: &mut bool) {\n     assert!(saw_dir, \"no vendored source\");\n }\n \n-/// Checks the dependency of WHITELIST_CRATES at the given path. Changes `bad` to `true` if a check\n-/// failed.\n+/// Checks the dependency of `WHITELIST_CRATES` at the given path. Changes `bad` to `true` if a\n+/// check failed.\n ///\n-/// Specifically, this checks that the dependencies are on the WHITELIST.\n+/// Specifically, this checks that the dependencies are on the `WHITELIST`.\n pub fn check_whitelist(path: &Path, cargo: &Path, bad: &mut bool) {\n-    // Get dependencies from cargo metadata\n+    // Get dependencies from Cargo metadata.\n     let resolve = get_deps(path, cargo);\n \n-    // Get the whitelist into a convenient form\n+    // Get the whitelist in a convenient form.\n     let whitelist: HashSet<_> = WHITELIST.iter().cloned().collect();\n \n-    // Check dependencies\n+    // Check dependencies.\n     let mut visited = BTreeSet::new();\n     let mut unapproved = BTreeSet::new();\n     for &krate in WHITELIST_CRATES.iter() {\n@@ -308,9 +308,9 @@ fn extract_license(line: &str) -> String {\n     }\n }\n \n-/// Get the dependencies of the crate at the given path using `cargo metadata`.\n+/// Gets the dependencies of the crate at the given path using `cargo metadata`.\n fn get_deps(path: &Path, cargo: &Path) -> Resolve {\n-    // Run `cargo metadata` to get the set of dependencies\n+    // Run `cargo metadata` to get the set of dependencies.\n     let output = Command::new(cargo)\n         .arg(\"metadata\")\n         .arg(\"--format-version\")\n@@ -335,25 +335,25 @@ fn check_crate_whitelist<'a, 'b>(\n     krate: CrateVersion<'a>,\n     must_be_on_whitelist: bool,\n ) -> BTreeSet<Crate<'a>> {\n-    // Will contain bad deps\n+    // This will contain bad deps.\n     let mut unapproved = BTreeSet::new();\n \n-    // Check if we have already visited this crate\n+    // Check if we have already visited this crate.\n     if visited.contains(&krate) {\n         return unapproved;\n     }\n \n     visited.insert(krate);\n \n-    // If this path is in-tree, we don't require it to be on the whitelist\n+    // If this path is in-tree, we don't require it to be on the whitelist.\n     if must_be_on_whitelist {\n-        // If this dependency is not on the WHITELIST, add to bad set\n+        // If this dependency is not on `WHITELIST`, add to bad set.\n         if !whitelist.contains(&krate.into()) {\n             unapproved.insert(krate.into());\n         }\n     }\n \n-    // Do a DFS in the crate graph (it's a DAG, so we know we have no cycles!)\n+    // Do a DFS in the crate graph (it's a DAG, so we know we have no cycles!).\n     let to_check = resolve\n         .nodes\n         .iter()\n@@ -372,9 +372,10 @@ fn check_crate_whitelist<'a, 'b>(\n \n fn check_crate_duplicate(resolve: &Resolve, bad: &mut bool) {\n     const FORBIDDEN_TO_HAVE_DUPLICATES: &[&str] = &[\n-        // These two crates take quite a long time to build, let's not let two\n-        // versions of them accidentally sneak into our dependency graph to\n-        // ensure we keep our CI times under control\n+        // These two crates take quite a long time to build, so don't allow two versions of them\n+        // to accidentally sneak into our dependency graph, in order to ensure we keep our CI times\n+        // under control.\n+\n         // \"cargo\", // FIXME(#53005)\n         \"rustc-ap-syntax\",\n     ];"}, {"sha": "76ebc9b601099c326bd7fb9f584f670704311592", "filename": "src/tools/tidy/src/errors.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/659994627234ce7d95a1a52ad8756ce661059adf/src%2Ftools%2Ftidy%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/659994627234ce7d95a1a52ad8756ce661059adf/src%2Ftools%2Ftidy%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ferrors.rs?ref=659994627234ce7d95a1a52ad8756ce661059adf", "patch": "@@ -22,11 +22,13 @@ pub fn check(path: &Path, bad: &mut bool) {\n         contents.truncate(0);\n         t!(t!(File::open(file)).read_to_string(&mut contents));\n \n-        // In the register_long_diagnostics! macro, entries look like this:\n+        // In the `register_long_diagnostics!` macro, entries look like this:\n         //\n+        // ```\n         // EXXXX: r##\"\n         // <Long diagnostic message>\n         // \"##,\n+        // ```\n         //\n         // and these long messages often have error codes themselves inside\n         // them, but we don't want to report duplicates in these cases. This"}, {"sha": "52e263df5e3d3be963e3cdf4a30481dbc836339e", "filename": "src/tools/tidy/src/extdeps.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/659994627234ce7d95a1a52ad8756ce661059adf/src%2Ftools%2Ftidy%2Fsrc%2Fextdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/659994627234ce7d95a1a52ad8756ce661059adf/src%2Ftools%2Ftidy%2Fsrc%2Fextdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fextdeps.rs?ref=659994627234ce7d95a1a52ad8756ce661059adf", "patch": "@@ -1,33 +1,32 @@\n-// ! Check for external package sources. Allow only vendorable packages.\n+//! Check for external package sources. Allow only vendorable packages.\n \n use std::fs;\n use std::path::Path;\n \n-/// List of whitelisted sources for packages\n+/// List of whitelisted sources for packages.\n const WHITELISTED_SOURCES: &[&str] = &[\n     \"\\\"registry+https://github.com/rust-lang/crates.io-index\\\"\",\n ];\n \n-/// check for external package sources\n+/// Checks for external package sources.\n pub fn check(path: &Path, bad: &mut bool) {\n-    // Cargo.lock of rust (tidy runs inside src/)\n+    // `Cargo.lock` of rust (tidy runs inside `src/`).\n     let path = path.join(\"../Cargo.lock\");\n \n-    // open and read the whole file\n+    // Open and read the whole file.\n     let cargo_lock = t!(fs::read_to_string(&path));\n \n-    // process each line\n+    // Process each line.\n     for line in cargo_lock.lines() {\n-\n-        // consider only source entries\n+        // Consider only source entries.\n         if ! line.starts_with(\"source = \") {\n             continue;\n         }\n \n-        // extract source value\n+        // Extract source value.\n         let source = line.splitn(2, '=').nth(1).unwrap().trim();\n \n-        // ensure source is whitelisted\n+        // Ensure source is whitelisted.\n         if !WHITELISTED_SOURCES.contains(&&*source) {\n             println!(\"invalid source: {}\", source);\n             *bad = true;"}, {"sha": "16f2e3ba27dbb86c11c28026e02ba0ea9fb9dfed", "filename": "src/tools/tidy/src/features.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/659994627234ce7d95a1a52ad8756ce661059adf/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/659994627234ce7d95a1a52ad8756ce661059adf/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs?ref=659994627234ce7d95a1a52ad8756ce661059adf", "patch": "@@ -1,12 +1,12 @@\n-//! Tidy check to ensure that unstable features are all in order\n+//! Tidy check to ensure that unstable features are all in order.\n //!\n //! This check will ensure properties like:\n //!\n-//! * All stability attributes look reasonably well formed\n-//! * The set of library features is disjoint from the set of language features\n-//! * Library features have at most one stability level\n-//! * Library features have at most one `since` value\n-//! * All unstable lang features have tests to ensure they are actually unstable\n+//! * All stability attributes look reasonably well formed.\n+//! * The set of library features is disjoint from the set of language features.\n+//! * Library features have at most one stability level.\n+//! * Library features have at most one `since` value.\n+//! * All unstable lang features have tests to ensure they are actually unstable.\n \n use std::collections::HashMap;\n use std::fmt;\n@@ -172,8 +172,8 @@ fn test_filen_gate(filen_underscore: &str, features: &mut Features) -> bool {\n pub fn collect_lang_features(base_src_path: &Path, bad: &mut bool) -> Features {\n     let contents = t!(fs::read_to_string(base_src_path.join(\"libsyntax/feature_gate.rs\")));\n \n-    // we allow rustc-internal features to omit a tracking issue.\n-    // these features must be marked with `// rustc internal` in its own group.\n+    // We allow rustc-internal features to omit a tracking issue.\n+    // These features must be marked with a `// rustc internal` in its own group.\n     let mut next_feature_is_rustc_internal = false;\n \n     contents.lines().zip(1..)\n@@ -327,7 +327,7 @@ fn map_lib_features(base_src_path: &Path,\n             }\n             becoming_feature = None;\n             if line.contains(\"rustc_const_unstable(\") {\n-                // const fn features are handled specially\n+                // `const fn` features are handled specially.\n                 let feature_name = match find_attr_val(line, \"feature\") {\n                     Some(name) => name,\n                     None => err!(\"malformed stability attribute\"),\n@@ -337,9 +337,8 @@ fn map_lib_features(base_src_path: &Path,\n                     since: \"None\".to_owned(),\n                     has_gate_test: false,\n                     // FIXME(#57563): #57563 is now used as a common tracking issue,\n-                    // although we would like to have specific tracking\n-                    // issues for each `rustc_const_unstable` in the\n-                    // future.\n+                    // although we would like to have specific tracking issues for each\n+                    // `rustc_const_unstable` in the future.\n                     tracking_issue: Some(57563),\n                 };\n                 mf(Ok((feature_name, feature)), file, i + 1);"}, {"sha": "a10332526d13bec2f9d26eb975018f9ba2111424", "filename": "src/tools/tidy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/659994627234ce7d95a1a52ad8756ce661059adf/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/659994627234ce7d95a1a52ad8756ce661059adf/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs?ref=659994627234ce7d95a1a52ad8756ce661059adf", "patch": "@@ -1,4 +1,4 @@\n-//! Library used by tidy and other tools\n+//! Library used by tidy and other tools.\n //!\n //! This library contains the tidy lints and exposes it\n //! to be used by tools."}, {"sha": "81b7b2a7731aec8870563045f2a974c43515829c", "filename": "src/tools/tidy/src/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/659994627234ce7d95a1a52ad8756ce661059adf/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/659994627234ce7d95a1a52ad8756ce661059adf/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs?ref=659994627234ce7d95a1a52ad8756ce661059adf", "patch": "@@ -1,4 +1,4 @@\n-//! Tidy checks source code in this repository\n+//! Tidy checks source code in this repository.\n //!\n //! This program runs all of the various tidy checks for style, cleanliness,\n //! etc. This is run by default on `make check` and as part of the auto"}, {"sha": "ce5e15af2f97c9dae0ba6639151ba88138ea900b", "filename": "src/tools/tidy/src/pal.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/659994627234ce7d95a1a52ad8756ce661059adf/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/659994627234ce7d95a1a52ad8756ce661059adf/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs?ref=659994627234ce7d95a1a52ad8756ce661059adf", "patch": "@@ -1,4 +1,4 @@\n-//! Tidy check to enforce rules about platform-specific code in std\n+//! Tidy check to enforce rules about platform-specific code in std.\n //!\n //! This is intended to maintain existing standards of code\n //! organization in hopes that the standard library will continue to\n@@ -15,15 +15,15 @@\n //! Following are the basic rules, though there are currently\n //! exceptions:\n //!\n-//! - core may not have platform-specific code\n-//! - libpanic_abort may have platform-specific code\n-//! - libpanic_unwind may have platform-specific code\n-//! - libunwind may have platform-specific code\n-//! - other crates in the std facade may not\n-//! - std may have platform-specific code in the following places\n-//!   - sys/unix/\n-//!   - sys/windows/\n-//!   - os/\n+//! - core may not have platform-specific code.\n+//! - libpanic_abort may have platform-specific code.\n+//! - libpanic_unwind may have platform-specific code.\n+//! - libunwind may have platform-specific code.\n+//! - other crates in the std facade may not.\n+//! - std may have platform-specific code in the following places:\n+//!   - `sys/unix/`\n+//!   - `sys/windows/`\n+//!   - `os/`\n //!\n //! `std/sys_common` should _not_ contain platform-specific code.\n //! Finally, because std contains tests with platform-specific\n@@ -36,7 +36,7 @@ use std::io::Read;\n use std::path::Path;\n use std::iter::Iterator;\n \n-// Paths that may contain platform-specific code\n+// Paths that may contain platform-specific code.\n const EXCEPTION_PATHS: &[&str] = &[\n     // std crates\n     \"src/libpanic_abort\",\n@@ -54,10 +54,10 @@ const EXCEPTION_PATHS: &[&str] = &[\n     \"src/libstd/f64.rs\",\n     \"src/libstd/sys_common/mod.rs\",\n     \"src/libstd/sys_common/net.rs\",\n-    \"src/libterm\", // Not sure how to make this crate portable, but test needs it\n-    \"src/libtest\", // Probably should defer to unstable std::sys APIs\n+    \"src/libterm\", // Not sure how to make this crate portable, but test crate needs it.\n+    \"src/libtest\", // Probably should defer to unstable `std::sys` APIs.\n \n-    // std testing crates, ok for now at least\n+    // std testing crates, okay for now at least\n     \"src/libcore/tests\",\n     \"src/liballoc/tests/lib.rs\",\n \n@@ -79,7 +79,7 @@ const EXCEPTION_PATHS: &[&str] = &[\n \n pub fn check(path: &Path, bad: &mut bool) {\n     let mut contents = String::new();\n-    // Sanity check that the complex parsing here works\n+    // Sanity check that the complex parsing here works.\n     let mut saw_target_arch = false;\n     let mut saw_cfg_bang = false;\n     super::walk(path, &mut super::filter_dirs, &mut |file| {\n@@ -104,7 +104,7 @@ fn check_cfgs(contents: &mut String, file: &Path,\n     // For now it's ok to have platform-specific code after 'mod tests'.\n     let mod_tests_idx = find_test_mod(contents);\n     let contents = &contents[..mod_tests_idx];\n-    // Pull out all \"cfg(...)\" and \"cfg!(...)\" strings\n+    // Pull out all `cfg(...)` and `cfg!(...)` strings.\n     let cfgs = parse_cfgs(contents);\n \n     let mut line_numbers: Option<Vec<usize>> = None;\n@@ -121,7 +121,7 @@ fn check_cfgs(contents: &mut String, file: &Path,\n     };\n \n     for (idx, cfg) in cfgs {\n-        // Sanity check that the parsing here works\n+        // Sanity check that the parsing here works.\n         if !*saw_target_arch && cfg.contains(\"target_arch\") { *saw_target_arch = true }\n         if !*saw_cfg_bang && cfg.contains(\"cfg!\") { *saw_cfg_bang = true }\n \n@@ -153,7 +153,7 @@ fn check_cfgs(contents: &mut String, file: &Path,\n \n fn find_test_mod(contents: &str) -> usize {\n     if let Some(mod_tests_idx) = contents.find(\"mod tests\") {\n-        // Also capture a previous line indicating \"mod tests\" in cfg-ed out\n+        // Also capture a previous line indicating that \"mod tests\" is cfg'd out.\n         let prev_newline_idx = contents[..mod_tests_idx].rfind('\\n').unwrap_or(mod_tests_idx);\n         let prev_newline_idx = contents[..prev_newline_idx].rfind('\\n');\n         if let Some(nl) = prev_newline_idx {\n@@ -176,7 +176,7 @@ fn parse_cfgs<'a>(contents: &'a str) -> Vec<(usize, &'a str)> {\n     let candidate_cfgs = contents.match_indices(\"cfg\");\n     let candidate_cfg_idxs = candidate_cfgs.map(|(i, _)| i);\n     // This is puling out the indexes of all \"cfg\" strings\n-    // that appear to be tokens succeeded by a paren.\n+    // that appear to be tokens followed by a parenthesis.\n     let cfgs = candidate_cfg_idxs.filter(|i| {\n         let pre_idx = i.saturating_sub(*i);\n         let succeeds_non_ident = !contents.as_bytes().get(pre_idx)"}, {"sha": "df54afe160b33014d40a659ec882ec4924be7dee", "filename": "src/tools/tidy/src/style.rs", "status": "modified", "additions": 25, "deletions": 15, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/659994627234ce7d95a1a52ad8756ce661059adf/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/659994627234ce7d95a1a52ad8756ce661059adf/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs?ref=659994627234ce7d95a1a52ad8756ce661059adf", "patch": "@@ -2,12 +2,12 @@\n //!\n //! Example checks are:\n //!\n-//! * No lines over 100 characters\n-//! * No tabs\n-//! * No trailing whitespace\n-//! * No CR characters\n-//! * No `TODO` or `XXX` directives\n-//! * No unexplained ` ```ignore ` or ` ```rust,ignore ` doc tests\n+//! * No lines over 100 characters.\n+//! * No tabs.\n+//! * No trailing whitespace.\n+//! * No CR characters.\n+//! * No `TODO` or `XXX` directives.\n+//! * No unexplained ` ```ignore ` or ` ```rust,ignore ` doc tests.\n //!\n //! A number of these checks can be opted-out of with various directives like\n //! `// ignore-tidy-linelength`.\n@@ -34,15 +34,17 @@ C++ code used llvm_unreachable, which triggers undefined behavior\n when executed when assertions are disabled.\n Use llvm::report_fatal_error for increased robustness.\";\n \n-/// Parser states for line_is_url.\n+/// Parser states for `line_is_url`.\n #[derive(PartialEq)]\n #[allow(non_camel_case_types)]\n-enum LIUState { EXP_COMMENT_START,\n-                EXP_LINK_LABEL_OR_URL,\n-                EXP_URL,\n-                EXP_END }\n+enum LIUState {\n+    EXP_COMMENT_START,\n+    EXP_LINK_LABEL_OR_URL,\n+    EXP_URL,\n+    EXP_END,\n+}\n \n-/// True if LINE appears to be a line comment containing an URL,\n+/// Returns whether `line` appears to be a line comment containing an URL,\n /// possibly with a Markdown link label in front, and nothing else.\n /// The Markdown link label, if present, may not contain whitespace.\n /// Lines of this form are allowed to be overlength, because Markdown\n@@ -77,7 +79,7 @@ fn line_is_url(line: &str) -> bool {\n     state == EXP_END\n }\n \n-/// True if LINE is allowed to be longer than the normal limit.\n+/// Returns whether `line` is allowed to be longer than the normal limit.\n /// Currently there is only one exception, for long URLs, but more\n /// may be added in the future.\n fn long_line_is_ok(line: &str) -> bool {\n@@ -109,6 +111,7 @@ pub fn check(path: &Path, bad: &mut bool) {\n         let skip_tab = contents.contains(\"ignore-tidy-tab\");\n         let skip_length = contents.contains(\"ignore-tidy-linelength\");\n         let skip_end_whitespace = contents.contains(\"ignore-tidy-end-whitespace\");\n+        let skip_copyright = contents.contains(\"ignore-tidy-copyright\");\n         let mut trailing_new_lines = 0;\n         for (i, line) in contents.split('\\n').enumerate() {\n             let mut err = |msg: &str| {\n@@ -118,13 +121,13 @@ pub fn check(path: &Path, bad: &mut bool) {\n                 && !long_line_is_ok(line) {\n                     err(&format!(\"line longer than {} chars\", COLS));\n             }\n-            if line.contains('\\t') && !skip_tab {\n+            if !skip_tab && line.contains('\\t') {\n                 err(\"tab character\");\n             }\n             if !skip_end_whitespace && (line.ends_with(' ') || line.ends_with('\\t')) {\n                 err(\"trailing whitespace\");\n             }\n-            if line.contains('\\r') && !skip_cr {\n+            if !skip_cr && line.contains('\\r') {\n                 err(\"CR character\");\n             }\n             if filename != \"style.rs\" {\n@@ -135,6 +138,13 @@ pub fn check(path: &Path, bad: &mut bool) {\n                     err(\"XXX is deprecated; use FIXME\")\n                 }\n             }\n+            if !skip_copyright && (line.starts_with(\"// Copyright\") ||\n+                                   line.starts_with(\"# Copyright\") ||\n+                                   line.starts_with(\"Copyright\"))\n+                               && (line.contains(\"Rust Developers\") ||\n+                                   line.contains(\"Rust Project Developers\")) {\n+                err(\"copyright notices attributed to the Rust Project Developers are deprecated\");\n+            }\n             if line.ends_with(\"```ignore\") || line.ends_with(\"```rust,ignore\") {\n                 err(UNEXPLAINED_IGNORE_DOCTEST_INFO);\n             }"}, {"sha": "b572b52ea8f35df02c8fdf7e5725c777c41eeeeb", "filename": "src/tools/tidy/src/ui_tests.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/659994627234ce7d95a1a52ad8756ce661059adf/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/659994627234ce7d95a1a52ad8756ce661059adf/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs?ref=659994627234ce7d95a1a52ad8756ce661059adf", "patch": "@@ -10,14 +10,16 @@ pub fn check(path: &Path, bad: &mut bool) {\n         &mut |file_path| {\n             if let Some(ext) = file_path.extension() {\n                 if ext == \"stderr\" || ext == \"stdout\" {\n-                    // Test output filenames have the format:\n+                    // Test output filenames have one of the formats:\n+                    // ```\n                     // $testname.stderr\n                     // $testname.$mode.stderr\n                     // $testname.$revision.stderr\n                     // $testname.$revision.$mode.stderr\n+                    // ```\n                     //\n                     // For now, just make sure that there is a corresponding\n-                    // $testname.rs file.\n+                    // `$testname.rs` file.\n                     let testname = file_path\n                         .file_name()\n                         .unwrap()"}, {"sha": "bd3b1f033c7617f1cf0878ec5440c0dd319ff820", "filename": "src/tools/tidy/src/unstable_book.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/659994627234ce7d95a1a52ad8756ce661059adf/src%2Ftools%2Ftidy%2Fsrc%2Funstable_book.rs", "raw_url": "https://github.com/rust-lang/rust/raw/659994627234ce7d95a1a52ad8756ce661059adf/src%2Ftools%2Ftidy%2Fsrc%2Funstable_book.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Funstable_book.rs?ref=659994627234ce7d95a1a52ad8756ce661059adf", "patch": "@@ -11,30 +11,32 @@ pub const LANG_FEATURES_DIR: &str = \"language-features\";\n \n pub const LIB_FEATURES_DIR: &str = \"library-features\";\n \n-/// Build the path to the Unstable Book source directory from the Rust 'src' directory\n+/// Builds the path to the Unstable Book source directory from the Rust 'src' directory.\n pub fn unstable_book_path(base_src_path: &path::Path) -> path::PathBuf {\n     base_src_path.join(PATH_STR)\n }\n \n-/// Directory where the features are documented within the Unstable Book source directory\n+/// Builds the path to the directory where the features are documented within the Unstable Book\n+/// source directory.\n pub fn unstable_book_lang_features_path(base_src_path: &path::Path) -> path::PathBuf {\n     unstable_book_path(base_src_path).join(LANG_FEATURES_DIR)\n }\n \n-/// Directory where the features are documented within the Unstable Book source directory\n+/// Builds the path to the directory where the features are documented within the Unstable Book\n+/// source directory.\n pub fn unstable_book_lib_features_path(base_src_path: &path::Path) -> path::PathBuf {\n     unstable_book_path(base_src_path).join(LIB_FEATURES_DIR)\n }\n \n-/// Test to determine if DirEntry is a file\n+/// Tests whether `DirEntry` is a file.\n fn dir_entry_is_file(dir_entry: &fs::DirEntry) -> bool {\n     dir_entry\n         .file_type()\n         .expect(\"could not determine file type of directory entry\")\n         .is_file()\n }\n \n-/// Retrieve names of all unstable features\n+/// Retrieves names of all unstable features.\n pub fn collect_unstable_feature_names(features: &Features) -> BTreeSet<String> {\n     features\n         .iter()\n@@ -56,24 +58,23 @@ pub fn collect_unstable_book_section_file_names(dir: &path::Path) -> BTreeSet<St\n \n /// Retrieve file names of all library feature sections in the Unstable Book with:\n ///\n-/// * hyphens replaced by underscores\n-/// * the markdown suffix ('.md') removed\n+/// * hyphens replaced by underscores,\n+/// * the markdown suffix ('.md') removed.\n fn collect_unstable_book_lang_features_section_file_names(base_src_path: &path::Path)\n                                                           -> BTreeSet<String> {\n     collect_unstable_book_section_file_names(&unstable_book_lang_features_path(base_src_path))\n }\n \n-/// Retrieve file names of all language feature sections in the Unstable Book with:\n+/// Retrieves file names of all language feature sections in the Unstable Book with:\n ///\n-/// * hyphens replaced by underscores\n-/// * the markdown suffix ('.md') removed\n+/// * hyphens replaced by underscores,\n+/// * the markdown suffix ('.md') removed.\n fn collect_unstable_book_lib_features_section_file_names(base_src_path: &path::Path)\n                                                          -> BTreeSet<String> {\n     collect_unstable_book_section_file_names(&unstable_book_lib_features_path(base_src_path))\n }\n \n pub fn check(path: &path::Path, bad: &mut bool) {\n-\n     // Library features\n \n     let lang_features = collect_lang_features(path, bad);\n@@ -100,7 +101,7 @@ pub fn check(path: &path::Path, bad: &mut bool) {\n     let unstable_book_lang_features_section_file_names =\n         collect_unstable_book_lang_features_section_file_names(path);\n \n-    // Check for Unstable Book sections that don't have a corresponding unstable feature\n+    // Check for Unstable Book sections that don't have a corresponding unstable feature.\n     for feature_name in &unstable_book_lang_features_section_file_names -\n                         &unstable_lang_feature_names {\n         tidy_error!(bad,\n@@ -109,8 +110,8 @@ pub fn check(path: &path::Path, bad: &mut bool) {\n                     feature_name)\n     }\n \n-    // List unstable features that don't have Unstable Book sections\n-    // Remove the comment marker if you want the list printed\n+    // List unstable features that don't have Unstable Book sections.\n+    // Remove the comment marker if you want the list printed.\n     /*\n     println!(\"Lib features without unstable book sections:\");\n     for feature_name in &unstable_lang_feature_names -"}]}