{"sha": "7db115834f24eb9d9ccbd2468c9145fdf86be514", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkYjExNTgzNGYyNGViOWQ5Y2NiZDI0NjhjOTE0NWZkZjg2YmU1MTQ=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-11-02T22:24:46Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-11-02T22:24:46Z"}, "message": "Split out stratum-checking pass, implement more-strict (overly aggressive) impure-effect checking.", "tree": {"sha": "5e5e1463ba1201524c6d10690c0982f4b168ba9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e5e1463ba1201524c6d10690c0982f4b168ba9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7db115834f24eb9d9ccbd2468c9145fdf86be514", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7db115834f24eb9d9ccbd2468c9145fdf86be514", "html_url": "https://github.com/rust-lang/rust/commit/7db115834f24eb9d9ccbd2468c9145fdf86be514", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7db115834f24eb9d9ccbd2468c9145fdf86be514/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da13c508d83032ca13679e1e122e96d25ac23283", "url": "https://api.github.com/repos/rust-lang/rust/commits/da13c508d83032ca13679e1e122e96d25ac23283", "html_url": "https://github.com/rust-lang/rust/commit/da13c508d83032ca13679e1e122e96d25ac23283"}], "stats": {"total": 341, "additions": 198, "deletions": 143}, "files": [{"sha": "8406d307ec7e537b77be948c067a402d1e4a0cff", "filename": "src/Makefile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7db115834f24eb9d9ccbd2468c9145fdf86be514/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/7db115834f24eb9d9ccbd2468c9145fdf86be514/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=7db115834f24eb9d9ccbd2468c9145fdf86be514", "patch": "@@ -261,8 +261,8 @@ BE_MLS := $(addprefix boot/be/, x86.ml ra.ml pe.ml elf.ml \\\n           macho.ml)\n IL_MLS := $(addprefix boot/be/, asm.ml il.ml abi.ml)\n ME_MLS := $(addprefix boot/me/, walk.ml semant.ml resolve.ml alias.ml \\\n-            simplify.ml type.ml dead.ml effect.ml typestate.ml loop.ml \\\n-            layout.ml transutil.ml trans.ml dwarf.ml)\n+            simplify.ml type.ml dead.ml stratum.ml effect.ml typestate.ml \\\n+            loop.ml layout.ml transutil.ml trans.ml dwarf.ml)\n FE_MLS := $(addprefix boot/fe/, ast.ml token.ml lexer.ml parser.ml \\\n             extfmt.ml pexp.ml item.ml cexp.ml fuzz.ml)\n DRIVER_TOP_MLS := $(addprefix boot/driver/, lib.ml $(VARIANT)/glue.ml main.ml)"}, {"sha": "da5e5b9dea99e7a39f9e6fe07d19e5d40c582226", "filename": "src/boot/driver/llvm/glue.ml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7db115834f24eb9d9ccbd2468c9145fdf86be514/src%2Fboot%2Fdriver%2Fllvm%2Fglue.ml", "raw_url": "https://github.com/rust-lang/rust/raw/7db115834f24eb9d9ccbd2468c9145fdf86be514/src%2Fboot%2Fdriver%2Fllvm%2Fglue.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fdriver%2Fllvm%2Fglue.ml?ref=7db115834f24eb9d9ccbd2468c9145fdf86be514", "patch": "@@ -18,6 +18,7 @@ let alt_pipeline sess sem_cx crate =\n       Simplify.process_crate;\n       Type.process_crate;\n       Typestate.process_crate;\n+      Stratum.process_crate;\n       Effect.process_crate;\n       Loop.process_crate;\n       Alias.process_crate;"}, {"sha": "30310b100f0ff0a60b2c0169bb0408c1b6850af9", "filename": "src/boot/driver/main.ml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7db115834f24eb9d9ccbd2468c9145fdf86be514/src%2Fboot%2Fdriver%2Fmain.ml", "raw_url": "https://github.com/rust-lang/rust/raw/7db115834f24eb9d9ccbd2468c9145fdf86be514/src%2Fboot%2Fdriver%2Fmain.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fdriver%2Fmain.ml?ref=7db115834f24eb9d9ccbd2468c9145fdf86be514", "patch": "@@ -37,6 +37,7 @@ let (sess:Session.sess) =\n     Session.sess_log_resolve = false;\n     Session.sess_log_type = false;\n     Session.sess_log_simplify = false;\n+    Session.sess_log_stratum = false;\n     Session.sess_log_effect = false;\n     Session.sess_log_typestate = false;\n     Session.sess_log_loop = false;\n@@ -175,6 +176,8 @@ let argspecs =\n        \"-ltype\"     \"log type checking\");\n     (flag (fun _ -> sess.Session.sess_log_simplify <- true)\n        \"-lsimplify\" \"log simplification\");\n+    (flag (fun _ -> sess.Session.sess_log_stratum <- true)\n+       \"-lstratum\"  \"log stratum checking\");\n     (flag (fun _ -> sess.Session.sess_log_effect <- true)\n        \"-leffect\"   \"log effect checking\");\n     (flag (fun _ -> sess.Session.sess_log_typestate <- true)\n@@ -378,6 +381,7 @@ let main_pipeline _ =\n          Simplify.process_crate;\n          Type.process_crate;\n          Typestate.process_crate;\n+         Stratum.process_crate;\n          Effect.process_crate;\n          Loop.process_crate;\n          Alias.process_crate;"}, {"sha": "49242ac6c2608ada78f6f1717e3750a52729c290", "filename": "src/boot/driver/session.ml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7db115834f24eb9d9ccbd2468c9145fdf86be514/src%2Fboot%2Fdriver%2Fsession.ml", "raw_url": "https://github.com/rust-lang/rust/raw/7db115834f24eb9d9ccbd2468c9145fdf86be514/src%2Fboot%2Fdriver%2Fsession.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fdriver%2Fsession.ml?ref=7db115834f24eb9d9ccbd2468c9145fdf86be514", "patch": "@@ -23,6 +23,7 @@ type sess =\n   mutable sess_log_resolve: bool;\n   mutable sess_log_type: bool;\n   mutable sess_log_simplify: bool;\n+  mutable sess_log_stratum: bool;\n   mutable sess_log_effect: bool;\n   mutable sess_log_typestate: bool;\n   mutable sess_log_dead: bool;"}, {"sha": "238e3e5b0f13a95648372e8c2532ce95f4b6fd7a", "filename": "src/boot/me/effect.ml", "status": "modified", "additions": 34, "deletions": 93, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/7db115834f24eb9d9ccbd2468c9145fdf86be514/src%2Fboot%2Fme%2Feffect.ml", "raw_url": "https://github.com/rust-lang/rust/raw/7db115834f24eb9d9ccbd2468c9145fdf86be514/src%2Fboot%2Fme%2Feffect.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Feffect.ml?ref=7db115834f24eb9d9ccbd2468c9145fdf86be514", "patch": "@@ -12,78 +12,7 @@ let iflog cx thunk =\n   else ()\n ;;\n \n-let mutability_checking_visitor\n-    (cx:ctxt)\n-    (inner:Walk.visitor)\n-    : Walk.visitor =\n-  (* \n-   * This visitor enforces the following rules:\n-   * \n-   * - A channel type carrying a mutable type is illegal.\n-   * \n-   * - Writing to an immutable slot is illegal.\n-   * \n-   * - Forming a mutable alias to an immutable slot is illegal.\n-   * \n-   *)\n-  let visit_ty_pre t =\n-    match t with\n-        Ast.TY_chan t' when type_has_state cx t' ->\n-          err None \"channel of mutable type: %a \" Ast.sprintf_ty t'\n-      | _ -> ()\n-  in\n-\n-  let check_write s dst =\n-    let is_init = Hashtbl.mem cx.ctxt_stmt_is_init s.id in\n-    let dst_ty = lval_ty cx dst in\n-    let is_mutable =\n-      match dst_ty with\n-          Ast.TY_mutable _ -> true\n-        | _ -> false\n-    in\n-      iflog cx\n-        (fun _ -> log cx \"checking %swrite to %slval #%d = %a of type %a\"\n-           (if is_init then \"initializing \" else \"\")\n-           (if is_mutable then \"mutable \" else \"\")\n-           (int_of_node (lval_base_id dst))\n-           Ast.sprintf_lval dst\n-           Ast.sprintf_ty dst_ty);\n-      if (is_mutable or is_init)\n-      then ()\n-      else err (Some s.id)\n-        \"writing to immutable type %a in statement %a\"\n-        Ast.sprintf_ty dst_ty Ast.sprintf_stmt s\n-  in\n-    (* FIXME (issue #75): enforce the no-write-alias-to-immutable-slot\n-     * rule.\n-     *)\n-  let visit_stmt_pre s =\n-    begin\n-      match s.node with\n-            Ast.STMT_copy (lv_dst, _)\n-          | Ast.STMT_call (lv_dst, _, _)\n-          | Ast.STMT_spawn (lv_dst, _, _, _, _)\n-          | Ast.STMT_recv (lv_dst, _)\n-          | Ast.STMT_bind (lv_dst, _, _)\n-          | Ast.STMT_new_rec (lv_dst, _, _)\n-          | Ast.STMT_new_tup (lv_dst, _)\n-          | Ast.STMT_new_vec (lv_dst, _, _)\n-          | Ast.STMT_new_str (lv_dst, _)\n-          | Ast.STMT_new_port lv_dst\n-          | Ast.STMT_new_chan (lv_dst, _)\n-          | Ast.STMT_new_box (lv_dst, _, _) ->\n-              check_write s lv_dst\n-        | _ -> ()\n-    end;\n-    inner.Walk.visit_stmt_pre s\n-  in\n-\n-    { inner with\n-        Walk.visit_ty_pre = visit_ty_pre;\n-        Walk.visit_stmt_pre = visit_stmt_pre }\n-;;\n-\n-let function_effect_propagation_visitor\n+let effect_calculating_visitor\n     (item_effect:(node_id, Ast.effect) Hashtbl.t)\n     (cx:ctxt)\n     (inner:Walk.visitor)\n@@ -93,6 +22,7 @@ let function_effect_propagation_visitor\n    * its statements:\n    * \n    *    - Communication statements lower to 'impure'\n+   *    - Writing to anything other than a local slot lowers to 'impure'\n    *    - Native calls lower to 'unsafe'\n    *    - Calling a function with effect e lowers to e.\n    *)\n@@ -159,13 +89,27 @@ let function_effect_propagation_visitor\n         end;\n   in\n \n+  let note_write s dst =\n+    (* FIXME (issue #182): this is too aggressive; won't permit writes to\n+     * interior components of records or tuples. It should at least do that,\n+     * possibly handle escape analysis on the pointee for things like vecs as\n+     * well.  *)\n+    if lval_base_is_slot cx dst\n+    then\n+      let base_slot = lval_base_slot cx dst in\n+        match dst, base_slot.Ast.slot_mode with\n+            (Ast.LVAL_base _, Ast.MODE_local) -> ()\n+          | _ -> lower_to s Ast.EFF_impure\n+  in\n+\n   let visit_stmt_pre s =\n     begin\n       match s.node with\n           Ast.STMT_send _\n         | Ast.STMT_recv _ -> lower_to s Ast.EFF_impure\n \n-        | Ast.STMT_call (_, fn, _) ->\n+        | Ast.STMT_call (lv_dst, fn, _) ->\n+            note_write s lv_dst;\n             let lower_to_callee_ty t =\n               match simplified_ty t with\n                   Ast.TY_fn (_, taux) ->\n@@ -185,6 +129,19 @@ let function_effect_propagation_visitor\n                       | Some (REQUIRED_LIB_rust _, _) -> ()\n                       | Some _ -> lower_to s Ast.EFF_unsafe\n                 end\n+\n+        | Ast.STMT_copy (lv_dst, _)\n+        | Ast.STMT_spawn (lv_dst, _, _, _, _)\n+        | Ast.STMT_bind (lv_dst, _, _)\n+        | Ast.STMT_new_rec (lv_dst, _, _)\n+        | Ast.STMT_new_tup (lv_dst, _)\n+        | Ast.STMT_new_vec (lv_dst, _, _)\n+        | Ast.STMT_new_str (lv_dst, _)\n+        | Ast.STMT_new_port lv_dst\n+        | Ast.STMT_new_chan (lv_dst, _)\n+        | Ast.STMT_new_box (lv_dst, _, _) ->\n+            note_write s lv_dst\n+\n         | _ -> ()\n     end;\n     inner.Walk.visit_stmt_pre s\n@@ -200,19 +157,6 @@ let function_effect_propagation_visitor\n         Walk.visit_stmt_pre = visit_stmt_pre }\n ;;\n \n-let binding_effect_propagation_visitor\n-    ((*cx*)_:ctxt)\n-    (inner:Walk.visitor)\n-    : Walk.visitor =\n-  (* This visitor lowers the effect of an object or binding according\n-   * to its slots: holding a 'state' slot lowers any obj item, or\n-   * bind-stmt LHS, to 'state'.\n-   * \n-   * Binding (or implicitly just making a native 1st-class) makes the LHS\n-   * unsafe.\n-   *)\n-  inner\n-;;\n \n let effect_checking_visitor\n     (item_auth:(node_id, Ast.effect) Hashtbl.t)\n@@ -221,7 +165,7 @@ let effect_checking_visitor\n     (inner:Walk.visitor)\n     : Walk.visitor =\n   (*\n-   * This visitor checks that each type, item and obj declares\n+   * This visitor checks that each fn declares\n    * effects consistent with what we calculated.\n    *)\n   let auth_stack = Stack.create () in\n@@ -250,7 +194,8 @@ let effect_checking_visitor\n     end;\n     begin\n       match i.node.Ast.decl_item with\n-          Ast.MOD_ITEM_fn f ->\n+          Ast.MOD_ITEM_fn f\n+            when htab_search cx.ctxt_required_items i.id = None ->\n             let e =\n               match htab_search item_effect i.id with\n                 None -> Ast.EFF_pure\n@@ -319,11 +264,7 @@ let process_crate\n   let item_effect = Hashtbl.create 0 in\n   let passes =\n     [|\n-      (mutability_checking_visitor cx\n-         Walk.empty_visitor);\n-      (function_effect_propagation_visitor item_effect cx\n-         Walk.empty_visitor);\n-      (binding_effect_propagation_visitor cx\n+      (effect_calculating_visitor item_effect cx\n          Walk.empty_visitor);\n       (effect_checking_visitor item_auth item_effect cx\n          Walk.empty_visitor);"}, {"sha": "21598d557ef12e7a8bc98ba3906559596a2bba9a", "filename": "src/boot/me/stratum.ml", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/7db115834f24eb9d9ccbd2468c9145fdf86be514/src%2Fboot%2Fme%2Fstratum.ml", "raw_url": "https://github.com/rust-lang/rust/raw/7db115834f24eb9d9ccbd2468c9145fdf86be514/src%2Fboot%2Fme%2Fstratum.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fstratum.ml?ref=7db115834f24eb9d9ccbd2468c9145fdf86be514", "patch": "@@ -0,0 +1,108 @@\n+open Semant;;\n+open Common;;\n+\n+let log cx = Session.log \"stratum\"\n+  (should_log cx cx.ctxt_sess.Session.sess_log_stratum)\n+  cx.ctxt_sess.Session.sess_log_out\n+;;\n+\n+let iflog cx thunk =\n+  if (should_log cx cx.ctxt_sess.Session.sess_log_stratum)\n+  then thunk ()\n+  else ()\n+;;\n+\n+\n+let state_stratum_checking_visitor\n+    (cx:ctxt)\n+    (inner:Walk.visitor)\n+    : Walk.visitor =\n+  (* \n+   * This visitor enforces the following rules:\n+   * \n+   * - A channel type carrying a state type is illegal.\n+   * \n+   * - Writing to an immutable slot is illegal.\n+   * \n+   * - Forming a mutable alias to an immutable slot is illegal.\n+   * \n+   *)\n+  let visit_ty_pre t =\n+    match t with\n+        Ast.TY_chan t' when type_has_state cx t' ->\n+          err None \"channel of state type: %a \" Ast.sprintf_ty t'\n+      | _ -> ()\n+  in\n+\n+  let check_write s dst =\n+    let is_init = Hashtbl.mem cx.ctxt_stmt_is_init s.id in\n+    let dst_ty = lval_ty cx dst in\n+    let is_mutable =\n+      match dst_ty with\n+          Ast.TY_mutable _ -> true\n+        | _ -> false\n+    in\n+      iflog cx\n+        (fun _ -> log cx \"checking %swrite to %slval #%d = %a of type %a\"\n+           (if is_init then \"initializing \" else \"\")\n+           (if is_mutable then \"mutable \" else \"\")\n+           (int_of_node (lval_base_id dst))\n+           Ast.sprintf_lval dst\n+           Ast.sprintf_ty dst_ty);\n+      if (is_mutable or is_init)\n+      then ()\n+      else err (Some s.id)\n+        \"writing to immutable type %a in statement %a\"\n+        Ast.sprintf_ty dst_ty Ast.sprintf_stmt s\n+  in\n+    (* FIXME (issue #75): enforce the no-write-alias-to-immutable-slot\n+     * rule.\n+     *)\n+  let visit_stmt_pre s =\n+    begin\n+      match s.node with\n+            Ast.STMT_copy (lv_dst, _)\n+          | Ast.STMT_call (lv_dst, _, _)\n+          | Ast.STMT_spawn (lv_dst, _, _, _, _)\n+          | Ast.STMT_recv (lv_dst, _)\n+          | Ast.STMT_bind (lv_dst, _, _)\n+          | Ast.STMT_new_rec (lv_dst, _, _)\n+          | Ast.STMT_new_tup (lv_dst, _)\n+          | Ast.STMT_new_vec (lv_dst, _, _)\n+          | Ast.STMT_new_str (lv_dst, _)\n+          | Ast.STMT_new_port lv_dst\n+          | Ast.STMT_new_chan (lv_dst, _)\n+          | Ast.STMT_new_box (lv_dst, _, _) ->\n+              check_write s lv_dst\n+        | _ -> ()\n+    end;\n+    inner.Walk.visit_stmt_pre s\n+  in\n+\n+    { inner with\n+        Walk.visit_ty_pre = visit_ty_pre;\n+        Walk.visit_stmt_pre = visit_stmt_pre }\n+;;\n+\n+let process_crate\n+    (cx:ctxt)\n+    (crate:Ast.crate)\n+    : unit =\n+  let passes =\n+    [|\n+      (state_stratum_checking_visitor cx\n+         Walk.empty_visitor);\n+    |]\n+  in\n+    run_passes cx \"stratum\" passes\n+      cx.ctxt_sess.Session.sess_log_stratum log crate\n+;;\n+\n+(*\n+ * Local Variables:\n+ * fill-column: 78;\n+ * indent-tabs-mode: nil\n+ * buffer-file-coding-system: utf-8-unix\n+ * compile-command: \"make -k -C ../.. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+ * End:\n+ *)"}, {"sha": "9fefcf55981d2c81f1691a55dc7265263e921f5e", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7db115834f24eb9d9ccbd2468c9145fdf86be514/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7db115834f24eb9d9ccbd2468c9145fdf86be514/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=7db115834f24eb9d9ccbd2468c9145fdf86be514", "patch": "@@ -408,7 +408,7 @@ fn trans_drop_str(@block_ctxt cx, ValueRef v) -> result {\n                                 T_int(), C_int(0));\n }\n \n-fn trans_lit(@block_ctxt cx, &ast.lit lit) -> result {\n+impure fn trans_lit(@block_ctxt cx, &ast.lit lit) -> result {\n     alt (lit.node) {\n         case (ast.lit_int(?i)) {\n             ret res(cx, C_int(i));\n@@ -438,7 +438,7 @@ fn trans_lit(@block_ctxt cx, &ast.lit lit) -> result {\n     }\n }\n \n-fn trans_unary(@block_ctxt cx, ast.unop op, &ast.expr e) -> result {\n+impure fn trans_unary(@block_ctxt cx, ast.unop op, &ast.expr e) -> result {\n \n     auto sub = trans_expr(cx, e);\n \n@@ -461,8 +461,8 @@ fn trans_unary(@block_ctxt cx, ast.unop op, &ast.expr e) -> result {\n     fail;\n }\n \n-fn trans_binary(@block_ctxt cx, ast.binop op,\n-                &ast.expr a, &ast.expr b) -> result {\n+impure fn trans_binary(@block_ctxt cx, ast.binop op,\n+                       &ast.expr a, &ast.expr b) -> result {\n \n     // First couple cases are lazy:\n \n@@ -612,8 +612,8 @@ fn trans_binary(@block_ctxt cx, ast.binop op,\n     fail;\n }\n \n-fn trans_if(@block_ctxt cx, &ast.expr cond,\n-            &ast.block thn, &option[ast.block] els) -> result {\n+impure fn trans_if(@block_ctxt cx, &ast.expr cond,\n+                   &ast.block thn, &option[ast.block] els) -> result {\n \n     auto cond_res = trans_expr(cx, cond);\n \n@@ -691,7 +691,7 @@ fn trans_lval(@block_ctxt cx, &ast.expr e)\n     fail;\n }\n \n-fn trans_exprs(@block_ctxt cx, &vec[@ast.expr] es)\n+impure fn trans_exprs(@block_ctxt cx, &vec[@ast.expr] es)\n     -> tup(@block_ctxt, vec[ValueRef]) {\n     let vec[ValueRef] vs = vec();\n     let @block_ctxt bcx = cx;\n@@ -705,7 +705,7 @@ fn trans_exprs(@block_ctxt cx, &vec[@ast.expr] es)\n     ret tup(bcx, vs);\n }\n \n-fn trans_expr(@block_ctxt cx, &ast.expr e) -> result {\n+impure fn trans_expr(@block_ctxt cx, &ast.expr e) -> result {\n     alt (e.node) {\n         case (ast.expr_lit(?lit, _)) {\n             ret trans_lit(cx, *lit);\n@@ -777,7 +777,7 @@ fn trans_expr(@block_ctxt cx, &ast.expr e) -> result {\n     fail;\n }\n \n-fn trans_log(@block_ctxt cx, &ast.expr e) -> result {\n+impure fn trans_log(@block_ctxt cx, &ast.expr e) -> result {\n     alt (e.node) {\n         case (ast.expr_lit(?lit, _)) {\n             alt (lit.node) {\n@@ -805,7 +805,7 @@ fn trans_log(@block_ctxt cx, &ast.expr e) -> result {\n     }\n }\n \n-fn trans_check_expr(@block_ctxt cx, &ast.expr e) -> result {\n+impure fn trans_check_expr(@block_ctxt cx, &ast.expr e) -> result {\n     auto cond_res = trans_expr(cx, e);\n \n     // FIXME: need pretty-printer.\n@@ -825,7 +825,7 @@ fn trans_check_expr(@block_ctxt cx, &ast.expr e) -> result {\n     ret res(next_cx, C_nil());\n }\n \n-fn trans_ret(@block_ctxt cx, &option[@ast.expr] e) -> result {\n+impure fn trans_ret(@block_ctxt cx, &option[@ast.expr] e) -> result {\n     auto r = res(cx, C_nil());\n     alt (e) {\n         case (some[@ast.expr](?x)) {\n@@ -841,7 +841,7 @@ fn trans_ret(@block_ctxt cx, &option[@ast.expr] e) -> result {\n     ret r;\n }\n \n-fn trans_stmt(@block_ctxt cx, &ast.stmt s) -> result {\n+impure fn trans_stmt(@block_ctxt cx, &ast.stmt s) -> result {\n     auto sub = res(cx, C_nil());\n     alt (s.node) {\n         case (ast.stmt_log(?a)) {\n@@ -957,7 +957,7 @@ iter block_locals(&ast.block b) -> @ast.local {\n     }\n }\n \n-fn trans_block(@block_ctxt cx, &ast.block b) -> result {\n+impure fn trans_block(@block_ctxt cx, &ast.block b) -> result {\n     auto bcx = cx;\n \n     for each (@ast.local local in block_locals(b)) {\n@@ -1011,14 +1011,14 @@ fn new_fn_ctxt(@trans_ctxt cx,\n              tcx=cx);\n }\n \n-fn trans_fn(@trans_ctxt cx, &ast._fn f, ast.def_id fid) {\n+impure fn trans_fn(@trans_ctxt cx, &ast._fn f, ast.def_id fid) {\n \n     auto fcx = new_fn_ctxt(cx, cx.path, f, fid);\n \n     trans_block(new_top_block_ctxt(fcx), f.body);\n }\n \n-fn trans_item(@trans_ctxt cx, &ast.item item) {\n+impure fn trans_item(@trans_ctxt cx, &ast.item item) {\n     alt (item.node) {\n         case (ast.item_fn(?name, ?f, ?fid)) {\n             auto sub_cx = @rec(path=cx.path + \".\" + name with *cx);\n@@ -1031,7 +1031,7 @@ fn trans_item(@trans_ctxt cx, &ast.item item) {\n     }\n }\n \n-fn trans_mod(@trans_ctxt cx, &ast._mod m) {\n+impure fn trans_mod(@trans_ctxt cx, &ast._mod m) {\n     for (@ast.item item in m.items) {\n         trans_item(cx, *item);\n     }"}, {"sha": "2a8c7d0ee53ca8800101493b58ddfe9b5558994f", "filename": "src/lib/bitv.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7db115834f24eb9d9ccbd2468c9145fdf86be514/src%2Flib%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7db115834f24eb9d9ccbd2468c9145fdf86be514/src%2Flib%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fbitv.rs?ref=7db115834f24eb9d9ccbd2468c9145fdf86be514", "patch": "@@ -29,7 +29,7 @@ fn create(uint nbits, bool init) -> t {\n     ret rec(storage = storage, nbits = nbits);\n }\n \n-fn process(&fn(uint, uint) -> uint op, &t v0, &t v1) -> bool {\n+impure fn process(&fn(uint, uint) -> uint op, &t v0, &t v1) -> bool {\n     auto len = _vec.len[mutable uint](v1.storage);\n \n     check (_vec.len[mutable uint](v0.storage) == len);\n@@ -55,7 +55,7 @@ fn lor(uint w0, uint w1) -> uint {\n     ret w0 | w1;\n }\n \n-fn union(&t v0, &t v1) -> bool {\n+impure fn union(&t v0, &t v1) -> bool {\n     auto sub = lor;\n     ret process(sub, v0, v1);\n }\n@@ -64,7 +64,7 @@ fn land(uint w0, uint w1) -> uint {\n     ret w0 & w1;\n }\n \n-fn intersect(&t v0, &t v1) -> bool {\n+impure fn intersect(&t v0, &t v1) -> bool {\n     auto sub = land;\n     ret process(sub, v0, v1);\n }\n@@ -73,7 +73,7 @@ fn right(uint w0, uint w1) -> uint {\n     ret w1;\n }\n \n-fn copy(&t v0, t v1) -> bool {\n+impure fn copy(&t v0, t v1) -> bool {\n     auto sub = right;\n     ret process(sub, v0, v1);\n }\n@@ -103,27 +103,27 @@ fn equal(&t v0, &t v1) -> bool {\n     ret true;\n }\n \n-fn clear(&t v) {\n+impure fn clear(&t v) {\n     for each (uint i in _uint.range(0u, _vec.len[mutable uint](v.storage))) {\n         v.storage.(i) = 0u;\n     }\n }\n \n-fn invert(&t v) {\n+impure fn invert(&t v) {\n     for each (uint i in _uint.range(0u, _vec.len[mutable uint](v.storage))) {\n         v.storage.(i) = ~v.storage.(i);\n     }\n }\n \n /* v0 = v0 - v1 */\n-fn difference(&t v0, &t v1) -> bool {\n+impure fn difference(&t v0, &t v1) -> bool {\n     invert(v1);\n     auto b = intersect(v0, v1);\n     invert(v1);\n     ret b;\n }\n \n-fn set(&t v, uint i, bool x) {\n+impure fn set(&t v, uint i, bool x) {\n     check (i < v.nbits);\n \n     auto bits = uint_bits();\n@@ -175,6 +175,6 @@ fn eq_vec(&t v0, &vec[uint] v1) -> bool {\n // indent-tabs-mode: nil\n // c-basic-offset: 4\n // buffer-file-coding-system: utf-8-unix\n-// compile-command: \"make -k -C ../.. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n // End:\n //"}, {"sha": "2693441bfa586c3e58d0b36e654d30225f03f053", "filename": "src/lib/map.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7db115834f24eb9d9ccbd2468c9145fdf86be514/src%2Flib%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7db115834f24eb9d9ccbd2468c9145fdf86be514/src%2Flib%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmap.rs?ref=7db115834f24eb9d9ccbd2468c9145fdf86be514", "patch": "@@ -70,12 +70,12 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n      * We attempt to never call this with a full table.  If we do, it\n      * will fail.\n      */\n-    fn insert_common[K, V](&hashfn[K] hasher,\n-                           &eqfn[K] eqer,\n-                           vec[mutable bucket[K, V]] bkts,\n-                           uint nbkts,\n-                           &K key,\n-                           &V val)\n+    impure fn insert_common[K, V](&hashfn[K] hasher,\n+                                  &eqfn[K] eqer,\n+                                  vec[mutable bucket[K, V]] bkts,\n+                                  uint nbkts,\n+                                  &K key,\n+                                  &V val)\n         -> bool\n         {\n             let uint i = 0u;\n@@ -125,10 +125,10 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n         }\n \n \n-    fn rehash[K, V](&hashfn[K] hasher,\n-                    &eqfn[K] eqer,\n-                    vec[mutable bucket[K, V]] oldbkts, uint noldbkts,\n-                    vec[mutable bucket[K, V]] newbkts, uint nnewbkts)\n+   impure fn rehash[K, V](&hashfn[K] hasher,\n+                          &eqfn[K] eqer,\n+                          vec[mutable bucket[K, V]] oldbkts, uint noldbkts,\n+                          vec[mutable bucket[K, V]] newbkts, uint nnewbkts)\n         {\n             for (bucket[K, V] b in oldbkts) {\n                 alt (b) {"}, {"sha": "b1ae7907d2e96dd6d2f15cc295e7b241dd4fa350", "filename": "src/test/run-pass/box-in-tup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7db115834f24eb9d9ccbd2468c9145fdf86be514/src%2Ftest%2Frun-pass%2Fbox-in-tup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7db115834f24eb9d9ccbd2468c9145fdf86be514/src%2Ftest%2Frun-pass%2Fbox-in-tup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-in-tup.rs?ref=7db115834f24eb9d9ccbd2468c9145fdf86be514", "patch": "@@ -1,4 +1,4 @@\n-fn main() {\n+impure fn main() {\n   let tup(mutable @int) i = tup(mutable @10);\n   i._0 = @11;\n }\n\\ No newline at end of file"}, {"sha": "e131e38db136a8cde49afd8881dee5181dbda5de", "filename": "src/test/run-pass/exterior.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7db115834f24eb9d9ccbd2468c9145fdf86be514/src%2Ftest%2Frun-pass%2Fexterior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7db115834f24eb9d9ccbd2468c9145fdf86be514/src%2Ftest%2Frun-pass%2Fexterior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexterior.rs?ref=7db115834f24eb9d9ccbd2468c9145fdf86be514", "patch": "@@ -2,13 +2,13 @@\n \n type point = rec(int x, int y, mutable int z);\n \n-fn f(@point p) {\n+impure fn f(@point p) {\n   check (p.z == 12);\n   p.z = 13;\n   check (p.z == 13);\n }\n \n-fn main() {\n+impure fn main() {\n   let point a = rec(x=10, y=11, mutable z=12);\n   let @point b = @a;\n   check (b.z == 12);"}, {"sha": "f06474b35fd8b22a8ffbc8edbbacd7ff41203a1d", "filename": "src/test/run-pass/foreach-nested-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7db115834f24eb9d9ccbd2468c9145fdf86be514/src%2Ftest%2Frun-pass%2Fforeach-nested-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7db115834f24eb9d9ccbd2468c9145fdf86be514/src%2Ftest%2Frun-pass%2Fforeach-nested-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-nested-2.rs?ref=7db115834f24eb9d9ccbd2468c9145fdf86be514", "patch": "@@ -13,7 +13,7 @@ iter range(int start, int stop) -> int {\n     }\n }\n \n-fn main() {\n+impure fn main() {\n     let vec[mutable int] a =\n       vec[mutable](-1, -1, -1, -1, -1, -1, -1, -1);\n     let int p = 0;"}, {"sha": "1da1d05bdc26f831c5506702ccf6e8529dcdd045", "filename": "src/test/run-pass/foreach-nested.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7db115834f24eb9d9ccbd2468c9145fdf86be514/src%2Ftest%2Frun-pass%2Fforeach-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7db115834f24eb9d9ccbd2468c9145fdf86be514/src%2Ftest%2Frun-pass%2Fforeach-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-nested.rs?ref=7db115834f24eb9d9ccbd2468c9145fdf86be514", "patch": "@@ -5,7 +5,7 @@ iter two() -> int {\n     put 1;\n }\n \n-fn main() {\n+impure fn main() {\n     let vec[mutable int] a = vec[mutable](-1, -1, -1, -1);\n     let int p = 0;\n "}, {"sha": "c3ffa8ea0ca64193deb27a0211ddad6052821690", "filename": "src/test/run-pass/lib-bitv.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7db115834f24eb9d9ccbd2468c9145fdf86be514/src%2Ftest%2Frun-pass%2Flib-bitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7db115834f24eb9d9ccbd2468c9145fdf86be514/src%2Ftest%2Frun-pass%2Flib-bitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-bitv.rs?ref=7db115834f24eb9d9ccbd2468c9145fdf86be514", "patch": "@@ -22,7 +22,7 @@ fn test_1_element() {\n   check (bitv.eq_vec(act, vec(1u)));\n }\n \n-fn test_10_elements() {\n+impure fn test_10_elements() {\n   auto act;\n \n   // all 0\n@@ -60,7 +60,7 @@ fn test_10_elements() {\n   check (bitv.eq_vec(act, vec(1u, 0u, 0u, 1u, 0u, 0u, 1u, 0u, 0u, 1u)));\n }\n \n-fn test_31_elements() {\n+impure fn test_31_elements() {\n   auto act;\n \n   // all 0\n@@ -132,7 +132,7 @@ fn test_31_elements() {\n                               0u, 0u, 0u, 0u, 0u, 0u, 1u)));\n }\n \n-fn test_32_elements() {\n+impure fn test_32_elements() {\n   auto act;\n \n   // all 0\n@@ -206,7 +206,7 @@ fn test_32_elements() {\n                               0u, 0u, 0u, 0u, 0u, 0u, 1u, 1u)));\n }\n \n-fn test_33_elements() {\n+impure fn test_33_elements() {\n   auto act;\n \n   // all 0\n@@ -287,7 +287,7 @@ fn test_33_elements() {\n                               1u)));\n }\n \n-fn main() {\n+impure fn main() {\n   test_0_elements();\n   test_1_element();\n   test_10_elements();"}, {"sha": "97eb222edaf203a1bcb044912e463fd63bd101b6", "filename": "src/test/run-pass/vec-in-tup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7db115834f24eb9d9ccbd2468c9145fdf86be514/src%2Ftest%2Frun-pass%2Fvec-in-tup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7db115834f24eb9d9ccbd2468c9145fdf86be514/src%2Ftest%2Frun-pass%2Fvec-in-tup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-in-tup.rs?ref=7db115834f24eb9d9ccbd2468c9145fdf86be514", "patch": "@@ -1,4 +1,4 @@\n-fn main() {\n+impure fn main() {\n   let tup(mutable vec[int]) i = tup(mutable vec(1,2,3));\n   i._0 = vec(4,5,6);\n }"}, {"sha": "551fb7d317dc938b6d1b632963708c3e2b3ceaab", "filename": "src/test/run-pass/writealias.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7db115834f24eb9d9ccbd2468c9145fdf86be514/src%2Ftest%2Frun-pass%2Fwritealias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7db115834f24eb9d9ccbd2468c9145fdf86be514/src%2Ftest%2Frun-pass%2Fwritealias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwritealias.rs?ref=7db115834f24eb9d9ccbd2468c9145fdf86be514", "patch": "@@ -2,11 +2,11 @@\n \n type point = rec(int x, int y, mutable int z);\n \n-fn f(& mutable point p) {\n+impure fn f(& mutable point p) {\n   p.z = 13;\n }\n \n-fn main() {\n+impure fn main() {\n   let point x = rec(x=10, y=11, mutable z=12);\n   f(x);\n   check (x.z == 13);"}]}