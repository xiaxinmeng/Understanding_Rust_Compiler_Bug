{"sha": "752befe2a6401108f27ff0141bdd73baac44c41c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1MmJlZmUyYTY0MDExMDhmMjdmZjAxNDFiZGQ3M2JhYWM0NGM0MWM=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-02-24T18:52:06Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-02-26T07:15:22Z"}, "message": "libsyntax: change token_is_{word,keyword} to take &Token", "tree": {"sha": "495e06e94bfc52ab0e36a757b0ebf0be5775b911", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/495e06e94bfc52ab0e36a757b0ebf0be5775b911"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/752befe2a6401108f27ff0141bdd73baac44c41c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/752befe2a6401108f27ff0141bdd73baac44c41c", "html_url": "https://github.com/rust-lang/rust/commit/752befe2a6401108f27ff0141bdd73baac44c41c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/752befe2a6401108f27ff0141bdd73baac44c41c/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "272c25e9383be490c5fc67cb09773fe2563ef3a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/272c25e9383be490c5fc67cb09773fe2563ef3a7", "html_url": "https://github.com/rust-lang/rust/commit/272c25e9383be490c5fc67cb09773fe2563ef3a7"}], "stats": {"total": 44, "additions": 22, "deletions": 22}, "files": [{"sha": "91abd804fb3ed95b80a09d329be68fd1469cb6f4", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/752befe2a6401108f27ff0141bdd73baac44c41c/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/752befe2a6401108f27ff0141bdd73baac44c41c/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=752befe2a6401108f27ff0141bdd73baac44c41c", "patch": "@@ -136,24 +136,24 @@ pub impl Parser {\n         }\n     }\n \n-    fn token_is_word(word: &~str, tok: token::Token) -> bool {\n-        match tok {\n+    fn token_is_word(word: &~str, tok: &token::Token) -> bool {\n+        match *tok {\n           token::IDENT(sid, false) => { *self.id_to_str(sid) == *word }\n           _ => { false }\n         }\n     }\n \n-    fn token_is_keyword(word: &~str, ++tok: token::Token) -> bool {\n+    fn token_is_keyword(word: &~str, tok: &token::Token) -> bool {\n         self.require_keyword(word);\n         self.token_is_word(word, tok)\n     }\n \n     fn is_keyword(word: &~str) -> bool {\n-        self.token_is_keyword(word, *self.token)\n+        self.token_is_keyword(word, &*self.token)\n     }\n \n-    fn is_any_keyword(tok: token::Token) -> bool {\n-        match tok {\n+    fn is_any_keyword(tok: &token::Token) -> bool {\n+        match *tok {\n           token::IDENT(sid, false) => {\n             self.keywords.contains_key(self.id_to_str(sid))\n           }"}, {"sha": "7a0f248cd3df0137b7a3a2ccd782d5724835d21e", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/752befe2a6401108f27ff0141bdd73baac44c41c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/752befe2a6401108f27ff0141bdd73baac44c41c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=752befe2a6401108f27ff0141bdd73baac44c41c", "patch": "@@ -309,7 +309,7 @@ pub impl Parser {\n \n     pure fn id_to_str(id: ident) -> @~str { self.sess.interner.get(id) }\n \n-    fn token_is_closure_keyword(+tok: token::Token) -> bool {\n+    fn token_is_closure_keyword(tok: &token::Token) -> bool {\n         self.token_is_keyword(&~\"pure\", tok) ||\n             self.token_is_keyword(&~\"unsafe\", tok) ||\n             self.token_is_keyword(&~\"once\", tok) ||\n@@ -649,7 +649,7 @@ pub impl Parser {\n             self.parse_borrowed_pointee()\n         } else if self.eat_keyword(&~\"extern\") {\n             self.parse_ty_bare_fn()\n-        } else if self.token_is_closure_keyword(*self.token) {\n+        } else if self.token_is_closure_keyword(&*self.token) {\n             self.parse_ty_closure(None, None)\n         } else if *self.token == token::MOD_SEP\n             || is_ident_or_path(*self.token) {\n@@ -676,12 +676,12 @@ pub impl Parser {\n \n             token::IDENT(rname, _) => {\n                 if self.look_ahead(1u) == token::BINOP(token::SLASH) &&\n-                    self.token_is_closure_keyword(self.look_ahead(2u))\n+                    self.token_is_closure_keyword(&self.look_ahead(2u))\n                 {\n                     self.bump();\n                     self.bump();\n                     return self.parse_ty_closure(Some(sigil), Some(rname));\n-                } else if self.token_is_closure_keyword(*self.token) {\n+                } else if self.token_is_closure_keyword(&*self.token) {\n                     return self.parse_ty_closure(Some(sigil), None);\n                 }\n             }\n@@ -716,7 +716,7 @@ pub impl Parser {\n             _ => { None }\n         };\n \n-        if self.token_is_closure_keyword(*self.token) {\n+        if self.token_is_closure_keyword(&*self.token) {\n             return self.parse_ty_closure(Some(BorrowedSigil), rname);\n         }\n \n@@ -1912,7 +1912,7 @@ pub impl Parser {\n         // labeled loop headers look like 'loop foo: {'\n         let is_labeled_loop_header =\n             is_ident(*self.token)\n-            && !self.is_any_keyword(*self.token)\n+            && !self.is_any_keyword(&*self.token)\n             && self.look_ahead(1) == token::COLON;\n \n         if is_loop_header || is_labeled_loop_header {\n@@ -1946,7 +1946,7 @@ pub impl Parser {\n     fn looking_at_record_literal() -> bool {\n         let lookahead = self.look_ahead(1);\n         *self.token == token::LBRACE &&\n-            (self.token_is_keyword(&~\"mut\", lookahead) ||\n+            (self.token_is_keyword(&~\"mut\", &lookahead) ||\n              (is_plain_ident(lookahead) &&\n               self.look_ahead(2) == token::COLON))\n     }\n@@ -2446,7 +2446,7 @@ pub impl Parser {\n             let decl = self.parse_let();\n             return @spanned(lo, decl.span.hi, stmt_decl(decl, self.get_id()));\n         } else if is_ident(*self.token)\n-            && !self.is_any_keyword(*self.token)\n+            && !self.is_any_keyword(&*self.token)\n             && self.look_ahead(1) == token::NOT {\n \n             check_expected_item(self, first_item_attrs);\n@@ -2812,10 +2812,10 @@ pub impl Parser {\n         fn maybe_parse_self_ty(cnstr: fn(+v: mutability) -> ast::self_ty_,\n                                p: Parser) -> ast::self_ty_ {\n             // We need to make sure it isn't a mode or a type\n-            if p.token_is_keyword(&~\"self\", p.look_ahead(1)) ||\n-                ((p.token_is_keyword(&~\"const\", p.look_ahead(1)) ||\n-                  p.token_is_keyword(&~\"mut\", p.look_ahead(1))) &&\n-                 p.token_is_keyword(&~\"self\", p.look_ahead(2))) {\n+            if p.token_is_keyword(&~\"self\", &p.look_ahead(1)) ||\n+                ((p.token_is_keyword(&~\"const\", &p.look_ahead(1)) ||\n+                  p.token_is_keyword(&~\"mut\", &p.look_ahead(1))) &&\n+                 p.token_is_keyword(&~\"self\", &p.look_ahead(2))) {\n \n                 p.bump();\n                 let mutability = p.parse_mutability();\n@@ -3948,7 +3948,7 @@ pub impl Parser {\n                 vis: visibility,\n                 span: mk_sp(lo, self.last_span.hi)\n             });\n-        } else if macros_allowed && !self.is_any_keyword(*self.token)\n+        } else if macros_allowed && !self.is_any_keyword(&*self.token)\n                 && self.look_ahead(1) == token::NOT\n                 && (is_plain_ident(self.look_ahead(2))\n                     || self.look_ahead(2) == token::LPAREN\n@@ -4127,9 +4127,9 @@ pub impl Parser {\n             tok = self.look_ahead(1);\n             next_tok = self.look_ahead(2);\n         };\n-        self.token_is_keyword(&~\"use\", tok)\n-            || (self.token_is_keyword(&~\"extern\", tok) &&\n-                self.token_is_keyword(&~\"mod\", next_tok))\n+        self.token_is_keyword(&~\"use\", &tok)\n+            || (self.token_is_keyword(&~\"extern\", &tok) &&\n+                self.token_is_keyword(&~\"mod\", &next_tok))\n     }\n \n     // parse a view item."}]}