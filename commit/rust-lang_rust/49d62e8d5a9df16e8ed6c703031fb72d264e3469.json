{"sha": "49d62e8d5a9df16e8ed6c703031fb72d264e3469", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5ZDYyZThkNWE5ZGYxNmU4ZWQ2YzcwMzAzMWZiNzJkMjY0ZTM0Njk=", "commit": {"author": {"name": "Igor Matuszewski", "email": "Xanewok@gmail.com", "date": "2019-05-13T18:21:44Z"}, "committer": {"name": "Igor Matuszewski", "email": "Xanewok@gmail.com", "date": "2019-06-08T20:58:53Z"}, "message": "Prohibit bare CRs in raw byte strings", "tree": {"sha": "432febaebf84a451599d8ba3db0ab1cb8447694c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/432febaebf84a451599d8ba3db0ab1cb8447694c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49d62e8d5a9df16e8ed6c703031fb72d264e3469", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49d62e8d5a9df16e8ed6c703031fb72d264e3469", "html_url": "https://github.com/rust-lang/rust/commit/49d62e8d5a9df16e8ed6c703031fb72d264e3469", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49d62e8d5a9df16e8ed6c703031fb72d264e3469/comments", "author": {"login": "Xanewok", "id": 3093213, "node_id": "MDQ6VXNlcjMwOTMyMTM=", "avatar_url": "https://avatars.githubusercontent.com/u/3093213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Xanewok", "html_url": "https://github.com/Xanewok", "followers_url": "https://api.github.com/users/Xanewok/followers", "following_url": "https://api.github.com/users/Xanewok/following{/other_user}", "gists_url": "https://api.github.com/users/Xanewok/gists{/gist_id}", "starred_url": "https://api.github.com/users/Xanewok/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Xanewok/subscriptions", "organizations_url": "https://api.github.com/users/Xanewok/orgs", "repos_url": "https://api.github.com/users/Xanewok/repos", "events_url": "https://api.github.com/users/Xanewok/events{/privacy}", "received_events_url": "https://api.github.com/users/Xanewok/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Xanewok", "id": 3093213, "node_id": "MDQ6VXNlcjMwOTMyMTM=", "avatar_url": "https://avatars.githubusercontent.com/u/3093213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Xanewok", "html_url": "https://github.com/Xanewok", "followers_url": "https://api.github.com/users/Xanewok/followers", "following_url": "https://api.github.com/users/Xanewok/following{/other_user}", "gists_url": "https://api.github.com/users/Xanewok/gists{/gist_id}", "starred_url": "https://api.github.com/users/Xanewok/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Xanewok/subscriptions", "organizations_url": "https://api.github.com/users/Xanewok/orgs", "repos_url": "https://api.github.com/users/Xanewok/repos", "events_url": "https://api.github.com/users/Xanewok/events{/privacy}", "received_events_url": "https://api.github.com/users/Xanewok/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cab7e7fe76c3c881078f068a8da4a863efdd2c77", "url": "https://api.github.com/repos/rust-lang/rust/commits/cab7e7fe76c3c881078f068a8da4a863efdd2c77", "html_url": "https://github.com/rust-lang/rust/commit/cab7e7fe76c3c881078f068a8da4a863efdd2c77"}], "stats": {"total": 140, "additions": 66, "deletions": 74}, "files": [{"sha": "685c17d104bbb1c5648a427c3af962609756cfc4", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 24, "deletions": 70, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/49d62e8d5a9df16e8ed6c703031fb72d264e3469/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49d62e8d5a9df16e8ed6c703031fb72d264e3469/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=49d62e8d5a9df16e8ed6c703031fb72d264e3469", "patch": "@@ -292,15 +292,6 @@ impl<'a> StringReader<'a> {\n         self.sess.span_diagnostic.struct_span_fatal(self.mk_sp(from_pos, to_pos), &m[..])\n     }\n \n-    /// Report a lexical error spanning [`from_pos`, `to_pos`), appending an\n-    /// escaped character to the error message\n-    fn err_span_char(&self, from_pos: BytePos, to_pos: BytePos, m: &str, c: char) {\n-        let mut m = m.to_string();\n-        m.push_str(\": \");\n-        push_escaped_char(&mut m, c);\n-        self.err_span_(from_pos, to_pos, &m[..]);\n-    }\n-\n     /// Advance peek_token to refer to the next token, and\n     /// possibly update the interner.\n     fn advance_token(&mut self) -> Result<(), ()> {\n@@ -1070,7 +1061,13 @@ impl<'a> StringReader<'a> {\n                         self.validate_byte_str_escape(start_with_quote);\n                         (token::ByteStr, symbol)\n                     },\n-                    Some('r') => self.scan_raw_byte_string(),\n+                    Some('r') => {\n+                        let (start, end, hash_count) = self.scan_raw_string();\n+                        let symbol = self.name_from_to(start, end);\n+                        self.validate_raw_byte_str_escape(start, end);\n+\n+                        (token::ByteStrRaw(hash_count), symbol)\n+                    }\n                     _ => unreachable!(),  // Should have been a token::Ident above.\n                 };\n                 let suffix = self.scan_optional_raw_name();\n@@ -1300,66 +1297,6 @@ impl<'a> StringReader<'a> {\n         (content_start_bpos, content_end_bpos, hash_count)\n     }\n \n-    fn scan_raw_byte_string(&mut self) -> (token::LitKind, Symbol) {\n-        let start_bpos = self.pos;\n-        self.bump();\n-        let mut hash_count = 0;\n-        while self.ch_is('#') {\n-            if hash_count == 65535 {\n-                let bpos = self.next_pos;\n-                self.fatal_span_(start_bpos,\n-                                 bpos,\n-                                 \"too many `#` symbols: raw strings may be \\\n-                                 delimited by up to 65535 `#` symbols\").raise();\n-            }\n-            self.bump();\n-            hash_count += 1;\n-        }\n-\n-        if self.is_eof() {\n-            self.fail_unterminated_raw_string(start_bpos, hash_count);\n-        } else if !self.ch_is('\"') {\n-            let last_bpos = self.pos;\n-            let curr_char = self.ch.unwrap();\n-            self.fatal_span_char(start_bpos,\n-                                        pos,\n-                                        \"found invalid character; only `#` is allowed in raw \\\n-                                         string delimitation\",\n-                                        ch).raise();\n-        }\n-        self.bump();\n-        let content_start_bpos = self.pos;\n-        let mut content_end_bpos;\n-        'outer: loop {\n-            match self.ch {\n-                None => {\n-                    self.fail_unterminated_raw_string(start_bpos, hash_count);\n-                }\n-                Some('\"') => {\n-                    content_end_bpos = self.pos;\n-                    for _ in 0..hash_count {\n-                        self.bump();\n-                        if !self.ch_is('#') {\n-                            continue 'outer;\n-                        }\n-                    }\n-                    break;\n-                }\n-                Some(c) => {\n-                    if c > '\\x7F' {\n-                        let pos = self.pos;\n-                        self.err_span_char(pos, pos, \"raw byte string must be ASCII\", c);\n-                    }\n-                }\n-            }\n-            self.bump();\n-        }\n-\n-        self.bump();\n-\n-        (token::ByteStrRaw(hash_count), self.name_from_to(content_start_bpos, content_end_bpos))\n-    }\n-\n     fn validate_char_escape(&self, start_with_quote: BytePos) {\n         self.with_str_from_to(start_with_quote + BytePos(1), self.pos - BytePos(1), |lit| {\n             if let Err((off, err)) = unescape::unescape_char(lit) {\n@@ -1424,6 +1361,23 @@ impl<'a> StringReader<'a> {\n         });\n     }\n \n+    fn validate_raw_byte_str_escape(&self, content_start: BytePos, content_end: BytePos) {\n+        self.with_str_from_to(content_start, content_end, |lit: &str| {\n+            unescape::unescape_raw_byte_str(lit, &mut |range, c| {\n+                if let Err(err) = c {\n+                    emit_unescape_error(\n+                        &self.sess.span_diagnostic,\n+                        lit,\n+                        self.mk_sp(content_start - BytePos(1), content_end + BytePos(1)),\n+                        unescape::Mode::ByteStr,\n+                        range,\n+                        err,\n+                    )\n+                }\n+            })\n+        });\n+    }\n+\n     fn validate_byte_str_escape(&self, start_with_quote: BytePos) {\n         self.with_str_from_to(start_with_quote + BytePos(1), self.pos - BytePos(1), |lit| {\n             unescape::unescape_byte_str(lit, &mut |range, c| {"}, {"sha": "819463b547250cf80580caeac14d7c3ca2f31a30", "filename": "src/libsyntax/parse/unescape.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/49d62e8d5a9df16e8ed6c703031fb72d264e3469/src%2Flibsyntax%2Fparse%2Funescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49d62e8d5a9df16e8ed6c703031fb72d264e3469/src%2Flibsyntax%2Fparse%2Funescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Funescape.rs?ref=49d62e8d5a9df16e8ed6c703031fb72d264e3469", "patch": "@@ -29,6 +29,7 @@ pub(crate) enum EscapeError {\n \n     UnicodeEscapeInByte,\n     NonAsciiCharInByte,\n+    NonAsciiCharInByteString,\n }\n \n /// Takes a contents of a char literal (without quotes), and returns an\n@@ -88,6 +89,29 @@ where\n     }\n }\n \n+/// Takes a contents of a string literal (without quotes) and produces a\n+/// sequence of characters or errors.\n+/// NOTE: Raw strings do not perform any explicit character escaping, here we\n+/// only translate CRLF to LF and produce errors on bare CR.\n+pub(crate) fn unescape_raw_byte_str<F>(literal_text: &str, callback: &mut F)\n+where\n+    F: FnMut(Range<usize>, Result<char, EscapeError>),\n+{\n+    let mut byte_offset: usize = 0;\n+\n+    let mut chars = literal_text.chars().peekable();\n+    while let Some(curr) = chars.next() {\n+        let result = match (curr, chars.peek()) {\n+            ('\\r', Some('\\n')) => Ok(curr),\n+            ('\\r', _) => Err(EscapeError::BareCarriageReturn),\n+            (c, _) if c > '\\x7F' => Err(EscapeError::NonAsciiCharInByteString),\n+            _ => Ok(curr),\n+        };\n+        callback(byte_offset..(byte_offset + curr.len_utf8()), result);\n+        byte_offset += curr.len_utf8();\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy)]\n pub(crate) enum Mode {\n     Char,"}, {"sha": "8f152974a6d3f9f626bc697878ced3bd70c31b19", "filename": "src/libsyntax/parse/unescape_error_reporting.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/49d62e8d5a9df16e8ed6c703031fb72d264e3469/src%2Flibsyntax%2Fparse%2Funescape_error_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49d62e8d5a9df16e8ed6c703031fb72d264e3469/src%2Flibsyntax%2Fparse%2Funescape_error_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Funescape_error_reporting.rs?ref=49d62e8d5a9df16e8ed6c703031fb72d264e3469", "patch": "@@ -124,6 +124,11 @@ pub(crate) fn emit_unescape_error(\n             handler.span_err(span, \"byte constant must be ASCII. \\\n                                     Use a \\\\xHH escape for a non-ASCII byte\")\n         }\n+        EscapeError::NonAsciiCharInByteString => {\n+            assert!(mode.is_bytes());\n+            let (_c, span) = last_char();\n+            handler.span_err(span, \"raw byte string must be ASCII\")\n+        }\n         EscapeError::OutOfRangeHexEscape => {\n             handler.span_err(span, \"this form of character escape may only be used \\\n                                     with characters in the range [\\\\x00-\\\\x7f]\")"}, {"sha": "87ecfb5c5445cddd4e1c70ab88fe2c01dc07e638", "filename": "src/test/ui/parser/raw-byte-string-literals.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/49d62e8d5a9df16e8ed6c703031fb72d264e3469/src%2Ftest%2Fui%2Fparser%2Fraw-byte-string-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49d62e8d5a9df16e8ed6c703031fb72d264e3469/src%2Ftest%2Fui%2Fparser%2Fraw-byte-string-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw-byte-string-literals.rs?ref=49d62e8d5a9df16e8ed6c703031fb72d264e3469", "patch": "@@ -1,4 +1,7 @@\n+// ignore-tidy-cr\n+// compile-flags: -Z continue-parse-after-error\n pub fn main() {\n+    br\"a\r\"; //~ ERROR bare CR not allowed in string\n     br\"\u00e9\";  //~ ERROR raw byte string must be ASCII\n     br##~\"a\"~##;  //~ ERROR only `#` is allowed in raw string delimitation\n }"}, {"sha": "03fe79722b844edd34654444b14ad8f615613bea", "filename": "src/test/ui/parser/raw-byte-string-literals.stderr", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/49d62e8d5a9df16e8ed6c703031fb72d264e3469/src%2Ftest%2Fui%2Fparser%2Fraw-byte-string-literals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/49d62e8d5a9df16e8ed6c703031fb72d264e3469/src%2Ftest%2Fui%2Fparser%2Fraw-byte-string-literals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fraw-byte-string-literals.stderr?ref=49d62e8d5a9df16e8ed6c703031fb72d264e3469", "patch": "@@ -1,14 +1,20 @@\n-error: raw byte string must be ASCII: \\u{e9}\n-  --> $DIR/raw-byte-string-literals.rs:2:8\n+error: bare CR not allowed in string, use \\r instead\n+  --> $DIR/raw-byte-string-literals.rs:4:9\n+   |\n+LL |     br\"a\r\";\n+   |         ^\n+\n+error: raw byte string must be ASCII\n+  --> $DIR/raw-byte-string-literals.rs:5:8\n    |\n LL |     br\"\u00e9\";\n    |        ^\n \n error: found invalid character; only `#` is allowed in raw string delimitation: ~\n-  --> $DIR/raw-byte-string-literals.rs:3:6\n+  --> $DIR/raw-byte-string-literals.rs:6:6\n    |\n LL |     br##~\"a\"~##;\n    |      ^^^\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 3 previous errors\n "}]}