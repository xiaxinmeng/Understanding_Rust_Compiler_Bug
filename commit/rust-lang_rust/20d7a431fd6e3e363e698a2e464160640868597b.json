{"sha": "20d7a431fd6e3e363e698a2e464160640868597b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwZDdhNDMxZmQ2ZTNlMzYzZTY5OGEyZTQ2NDE2MDY0MDg2ODU5N2I=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-26T12:11:47Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-26T13:28:04Z"}, "message": "refactor-fvs", "tree": {"sha": "b154835f03a0331aba6a5d6a2a6655fca10acd58", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b154835f03a0331aba6a5d6a2a6655fca10acd58"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20d7a431fd6e3e363e698a2e464160640868597b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20d7a431fd6e3e363e698a2e464160640868597b", "html_url": "https://github.com/rust-lang/rust/commit/20d7a431fd6e3e363e698a2e464160640868597b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20d7a431fd6e3e363e698a2e464160640868597b/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3feaf2a008be289dc4091f25e0925d0f427d6b65", "url": "https://api.github.com/repos/rust-lang/rust/commits/3feaf2a008be289dc4091f25e0925d0f427d6b65", "html_url": "https://github.com/rust-lang/rust/commit/3feaf2a008be289dc4091f25e0925d0f427d6b65"}], "stats": {"total": 575, "additions": 242, "deletions": 333}, "files": [{"sha": "669240488ad2820f3b61b067149f8b82a802f7f1", "filename": "crates/ra_vfs/src/io.rs", "status": "modified", "additions": 176, "deletions": 53, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/20d7a431fd6e3e363e698a2e464160640868597b/crates%2Fra_vfs%2Fsrc%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20d7a431fd6e3e363e698a2e464160640868597b/crates%2Fra_vfs%2Fsrc%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Fio.rs?ref=20d7a431fd6e3e363e698a2e464160640868597b", "patch": "@@ -1,19 +1,23 @@\n-use std::{fs, sync::Arc, thread};\n-\n-use crossbeam_channel::{Receiver, Sender};\n+use std::{\n+    fs,\n+    path::{Path, PathBuf},\n+    sync::{mpsc, Arc},\n+    thread,\n+    time::Duration,\n+};\n+use crossbeam_channel::{Receiver, Sender, SendError};\n use relative_path::RelativePathBuf;\n use thread_worker::WorkerHandle;\n use walkdir::WalkDir;\n+use parking_lot::Mutex;\n+use notify::{DebouncedEvent, RecommendedWatcher, RecursiveMode, Watcher as _Watcher};\n \n-mod watcher;\n-use watcher::Watcher;\n-\n-use crate::{RootFilter, Roots, VfsRoot};\n+use crate::{RootConfig, Roots, VfsRoot};\n \n pub(crate) enum Task {\n     AddRoot {\n         root: VfsRoot,\n-        filter: Arc<RootFilter>,\n+        config: Arc<RootConfig>,\n     },\n }\n \n@@ -39,6 +43,15 @@ pub enum TaskResult {\n     },\n }\n \n+#[derive(Debug)]\n+enum ChangeKind {\n+    Create,\n+    Write,\n+    Remove,\n+}\n+\n+const WATCHER_DELAY: Duration = Duration::from_millis(250);\n+\n pub(crate) struct Worker {\n     worker: thread_worker::Worker<Task, TaskResult>,\n     worker_handle: WorkerHandle,\n@@ -48,21 +61,36 @@ impl Worker {\n     pub(crate) fn start(roots: Arc<Roots>) -> Worker {\n         let (worker, worker_handle) =\n             thread_worker::spawn(\"vfs\", 128, move |input_receiver, output_sender| {\n-                let mut watcher = match Watcher::start(roots, output_sender.clone()) {\n-                    Ok(w) => Some(w),\n-                    Err(e) => {\n-                        log::error!(\"could not start watcher: {}\", e);\n-                        None\n-                    }\n+                let (notify_sender, notify_receiver) = mpsc::channel();\n+                let watcher = notify::watcher(notify_sender, WATCHER_DELAY)\n+                    .map_err(|e| log::error!(\"failed to spawn notify {}\", e))\n+                    .ok();\n+                let ctx = WatcherCtx {\n+                    roots,\n+                    watcher: Arc::new(Mutex::new(watcher)),\n+                    sender: output_sender,\n                 };\n-                let res = input_receiver\n-                    .into_iter()\n-                    .filter_map(|t| handle_task(t, &mut watcher))\n-                    .try_for_each(|it| output_sender.send(it));\n-                if let Some(watcher) = watcher {\n-                    let _ = watcher.shutdown();\n+                let thread = thread::spawn({\n+                    let ctx = ctx.clone();\n+                    move || {\n+                        let _ = notify_receiver\n+                            .into_iter()\n+                            // forward relevant events only\n+                            .try_for_each(|change| ctx.handle_debounced_event(change));\n+                    }\n+                });\n+                let res1 = input_receiver.into_iter().try_for_each(|t| match t {\n+                    Task::AddRoot { root, config } => watch_root(&ctx, root, Arc::clone(&config)),\n+                });\n+                drop(ctx.watcher.lock().take());\n+                drop(ctx);\n+                let res2 = thread.join();\n+                match &res2 {\n+                    Ok(()) => log::info!(\"... Watcher terminated with ok\"),\n+                    Err(_) => log::error!(\"... Watcher terminated with err\"),\n                 }\n-                res.unwrap()\n+                res1.unwrap();\n+                res2.unwrap();\n             });\n         Worker {\n             worker,\n@@ -84,46 +112,141 @@ impl Worker {\n     }\n }\n \n-fn handle_task(task: Task, watcher: &mut Option<Watcher>) -> Option<TaskResult> {\n-    match task {\n-        Task::AddRoot { root, filter } => {\n-            if let Some(watcher) = watcher {\n-                watcher.watch_root(&filter)\n+fn watch_root(\n+    woker: &WatcherCtx,\n+    root: VfsRoot,\n+    config: Arc<RootConfig>,\n+) -> Result<(), SendError<TaskResult>> {\n+    let mut guard = woker.watcher.lock();\n+    log::debug!(\"loading {} ...\", config.root.as_path().display());\n+    let files = watch_recursive(guard.as_mut(), config.root.as_path(), &*config)\n+        .into_iter()\n+        .filter_map(|path| {\n+            let abs_path = path.to_path(&config.root);\n+            let text = fs::read_to_string(abs_path)\n+                .map_err(|e| log::warn!(\"watcher error: {}\", e))\n+                .ok()?;\n+            Some((path, text))\n+        })\n+        .collect();\n+    woker\n+        .sender\n+        .send(TaskResult::BulkLoadRoot { root, files })?;\n+    log::debug!(\"... loaded {}\", config.root.as_path().display());\n+    Ok(())\n+}\n+\n+#[derive(Clone)]\n+struct WatcherCtx {\n+    roots: Arc<Roots>,\n+    watcher: Arc<Mutex<Option<RecommendedWatcher>>>,\n+    sender: Sender<TaskResult>,\n+}\n+\n+impl WatcherCtx {\n+    fn handle_debounced_event(&self, ev: DebouncedEvent) -> Result<(), SendError<TaskResult>> {\n+        match ev {\n+            DebouncedEvent::NoticeWrite(_)\n+            | DebouncedEvent::NoticeRemove(_)\n+            | DebouncedEvent::Chmod(_) => {\n+                // ignore\n+            }\n+            DebouncedEvent::Rescan => {\n+                // TODO rescan all roots\n+            }\n+            DebouncedEvent::Create(path) => {\n+                self.handle_change(path, ChangeKind::Create)?;\n+            }\n+            DebouncedEvent::Write(path) => {\n+                self.handle_change(path, ChangeKind::Write)?;\n             }\n-            log::debug!(\"loading {} ...\", filter.root.as_path().display());\n-            let files = load_root(filter.as_ref());\n-            log::debug!(\"... loaded {}\", filter.root.as_path().display());\n-            Some(TaskResult::BulkLoadRoot { root, files })\n+            DebouncedEvent::Remove(path) => {\n+                self.handle_change(path, ChangeKind::Remove)?;\n+            }\n+            DebouncedEvent::Rename(src, dst) => {\n+                self.handle_change(src, ChangeKind::Remove)?;\n+                self.handle_change(dst, ChangeKind::Create)?;\n+            }\n+            DebouncedEvent::Error(err, path) => {\n+                // TODO should we reload the file contents?\n+                log::warn!(\"watcher error \\\"{}\\\", {:?}\", err, path);\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    fn handle_change(&self, path: PathBuf, kind: ChangeKind) -> Result<(), SendError<TaskResult>> {\n+        let (root, rel_path) = match self.roots.find(&path) {\n+            None => return Ok(()),\n+            Some(it) => it,\n+        };\n+        let config = &self.roots[root];\n+        match kind {\n+            ChangeKind::Create => {\n+                let mut paths = Vec::new();\n+                if path.is_dir() {\n+                    let mut guard = self.watcher.lock();\n+                    paths.extend(watch_recursive(guard.as_mut(), &path, &config));\n+                } else {\n+                    paths.push(rel_path);\n+                }\n+                paths\n+                    .into_iter()\n+                    .filter_map(|rel_path| {\n+                        let abs_path = rel_path.to_path(&config.root);\n+                        let text = fs::read_to_string(&abs_path)\n+                            .map_err(|e| log::warn!(\"watcher failed {}\", e))\n+                            .ok()?;\n+                        Some((rel_path, text))\n+                    })\n+                    .try_for_each(|(path, text)| {\n+                        self.sender\n+                            .send(TaskResult::AddSingleFile { root, path, text })\n+                    })?\n+            }\n+            ChangeKind::Write => match fs::read_to_string(&path) {\n+                Err(e) => log::warn!(\"watcher failed {}\", e),\n+                Ok(text) => self.sender.send(TaskResult::ChangeSingleFile {\n+                    root,\n+                    path: rel_path,\n+                    text,\n+                })?,\n+            },\n+            ChangeKind::Remove => self.sender.send(TaskResult::RemoveSingleFile {\n+                root,\n+                path: rel_path,\n+            })?,\n         }\n+        Ok(())\n     }\n }\n \n-fn load_root(filter: &RootFilter) -> Vec<(RelativePathBuf, String)> {\n-    let mut res = Vec::new();\n-    for entry in WalkDir::new(&filter.root)\n+fn watch_recursive(\n+    mut watcher: Option<&mut RecommendedWatcher>,\n+    dir: &Path,\n+    config: &RootConfig,\n+) -> Vec<RelativePathBuf> {\n+    let mut files = Vec::new();\n+    for entry in WalkDir::new(dir)\n         .into_iter()\n-        .filter_entry(filter.entry_filter())\n+        .filter_entry(|it| config.contains(it.path()).is_some())\n+        .filter_map(|it| it.map_err(|e| log::warn!(\"watcher error: {}\", e)).ok())\n     {\n-        let entry = match entry {\n-            Ok(entry) => entry,\n-            Err(e) => {\n-                log::warn!(\"watcher error: {}\", e);\n-                continue;\n+        if entry.file_type().is_dir() {\n+            if let Some(watcher) = &mut watcher {\n+                watch_one(watcher, entry.path());\n             }\n-        };\n-        if !entry.file_type().is_file() {\n-            continue;\n+        } else {\n+            let path = config.contains(entry.path()).unwrap();\n+            files.push(path.to_owned());\n         }\n-        let path = entry.path();\n-        let text = match fs::read_to_string(path) {\n-            Ok(text) => text,\n-            Err(e) => {\n-                log::warn!(\"watcher error: {}\", e);\n-                continue;\n-            }\n-        };\n-        let path = RelativePathBuf::from_path(path.strip_prefix(&filter.root).unwrap()).unwrap();\n-        res.push((path.to_owned(), text))\n     }\n-    res\n+    files\n+}\n+\n+fn watch_one(watcher: &mut RecommendedWatcher, dir: &Path) {\n+    match watcher.watch(dir, RecursiveMode::NonRecursive) {\n+        Ok(()) => log::debug!(\"watching \\\"{}\\\"\", dir.display()),\n+        Err(e) => log::warn!(\"could not watch \\\"{}\\\": {}\", dir.display(), e),\n+    }\n }"}, {"sha": "ff6775f59402cf13c65bebf496d78109aed917f8", "filename": "crates/ra_vfs/src/io/watcher.rs", "status": "removed", "additions": 0, "deletions": 200, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/3feaf2a008be289dc4091f25e0925d0f427d6b65/crates%2Fra_vfs%2Fsrc%2Fio%2Fwatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3feaf2a008be289dc4091f25e0925d0f427d6b65/crates%2Fra_vfs%2Fsrc%2Fio%2Fwatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Fio%2Fwatcher.rs?ref=3feaf2a008be289dc4091f25e0925d0f427d6b65", "patch": "@@ -1,200 +0,0 @@\n-use crate::{io, RootFilter, Roots, VfsRoot};\n-use crossbeam_channel::Sender;\n-use drop_bomb::DropBomb;\n-use notify::{DebouncedEvent, RecommendedWatcher, RecursiveMode, Watcher as NotifyWatcher};\n-use parking_lot::Mutex;\n-use std::{\n-    fs,\n-    path::{Path, PathBuf},\n-    sync::{mpsc, Arc},\n-    thread,\n-    time::Duration,\n-};\n-use walkdir::WalkDir;\n-\n-#[derive(Debug)]\n-enum ChangeKind {\n-    Create,\n-    Write,\n-    Remove,\n-}\n-\n-const WATCHER_DELAY: Duration = Duration::from_millis(250);\n-\n-pub(crate) struct Watcher {\n-    thread: thread::JoinHandle<()>,\n-    bomb: DropBomb,\n-    watcher: Arc<Mutex<Option<RecommendedWatcher>>>,\n-}\n-\n-impl Watcher {\n-    pub(crate) fn start(\n-        roots: Arc<Roots>,\n-        output_sender: Sender<io::TaskResult>,\n-    ) -> Result<Watcher, Box<std::error::Error>> {\n-        let (input_sender, input_receiver) = mpsc::channel();\n-        let watcher = Arc::new(Mutex::new(Some(notify::watcher(\n-            input_sender,\n-            WATCHER_DELAY,\n-        )?)));\n-        let sender = output_sender.clone();\n-        let watcher_clone = watcher.clone();\n-        let thread = thread::spawn(move || {\n-            let worker = WatcherWorker {\n-                roots,\n-                watcher: watcher_clone,\n-                sender,\n-            };\n-            input_receiver\n-                .into_iter()\n-                // forward relevant events only\n-                .try_for_each(|change| worker.handle_debounced_event(change))\n-                .unwrap()\n-        });\n-        Ok(Watcher {\n-            thread,\n-            watcher,\n-            bomb: DropBomb::new(format!(\"Watcher was not shutdown\")),\n-        })\n-    }\n-\n-    pub fn watch_root(&mut self, filter: &RootFilter) {\n-        for res in WalkDir::new(&filter.root)\n-            .into_iter()\n-            .filter_entry(filter.entry_filter())\n-        {\n-            match res {\n-                Ok(entry) => {\n-                    if entry.file_type().is_dir() {\n-                        watch_one(self.watcher.as_ref(), entry.path());\n-                    }\n-                }\n-                Err(e) => log::warn!(\"watcher error: {}\", e),\n-            }\n-        }\n-    }\n-\n-    pub fn shutdown(mut self) -> thread::Result<()> {\n-        self.bomb.defuse();\n-        drop(self.watcher.lock().take());\n-        let res = self.thread.join();\n-        match &res {\n-            Ok(()) => log::info!(\"... Watcher terminated with ok\"),\n-            Err(_) => log::error!(\"... Watcher terminated with err\"),\n-        }\n-        res\n-    }\n-}\n-\n-struct WatcherWorker {\n-    watcher: Arc<Mutex<Option<RecommendedWatcher>>>,\n-    roots: Arc<Roots>,\n-    sender: Sender<io::TaskResult>,\n-}\n-\n-impl WatcherWorker {\n-    fn handle_debounced_event(&self, ev: DebouncedEvent) -> Result<(), Box<std::error::Error>> {\n-        match ev {\n-            DebouncedEvent::NoticeWrite(_)\n-            | DebouncedEvent::NoticeRemove(_)\n-            | DebouncedEvent::Chmod(_) => {\n-                // ignore\n-            }\n-            DebouncedEvent::Rescan => {\n-                // TODO rescan all roots\n-            }\n-            DebouncedEvent::Create(path) => {\n-                self.handle_change(path, ChangeKind::Create);\n-            }\n-            DebouncedEvent::Write(path) => {\n-                self.handle_change(path, ChangeKind::Write);\n-            }\n-            DebouncedEvent::Remove(path) => {\n-                self.handle_change(path, ChangeKind::Remove);\n-            }\n-            DebouncedEvent::Rename(src, dst) => {\n-                self.handle_change(src, ChangeKind::Remove);\n-                self.handle_change(dst, ChangeKind::Create);\n-            }\n-            DebouncedEvent::Error(err, path) => {\n-                // TODO should we reload the file contents?\n-                log::warn!(\"watcher error \\\"{}\\\", {:?}\", err, path);\n-            }\n-        }\n-        Ok(())\n-    }\n-\n-    fn handle_change(&self, path: PathBuf, kind: ChangeKind) {\n-        if let Err(e) = self.try_handle_change(path, kind) {\n-            log::warn!(\"watcher error: {}\", e)\n-        }\n-    }\n-\n-    fn try_handle_change(\n-        &self,\n-        path: PathBuf,\n-        kind: ChangeKind,\n-    ) -> Result<(), Box<std::error::Error>> {\n-        let (root, rel_path) = match self.roots.find(&path) {\n-            Some(x) => x,\n-            None => return Ok(()),\n-        };\n-        match kind {\n-            ChangeKind::Create => {\n-                if path.is_dir() {\n-                    self.watch_recursive(&path, root);\n-                } else {\n-                    let text = fs::read_to_string(&path)?;\n-                    self.sender.send(io::TaskResult::AddSingleFile {\n-                        root,\n-                        path: rel_path,\n-                        text,\n-                    })?\n-                }\n-            }\n-            ChangeKind::Write => {\n-                let text = fs::read_to_string(&path)?;\n-                self.sender.send(io::TaskResult::ChangeSingleFile {\n-                    root,\n-                    path: rel_path,\n-                    text,\n-                })?\n-            }\n-            ChangeKind::Remove => self.sender.send(io::TaskResult::RemoveSingleFile {\n-                root,\n-                path: rel_path,\n-            })?,\n-        }\n-        Ok(())\n-    }\n-\n-    fn watch_recursive(&self, dir: &Path, root: VfsRoot) {\n-        let filter = &self.roots[root];\n-        for res in WalkDir::new(dir)\n-            .into_iter()\n-            .filter_entry(filter.entry_filter())\n-        {\n-            match res {\n-                Ok(entry) => {\n-                    if entry.file_type().is_dir() {\n-                        watch_one(self.watcher.as_ref(), entry.path());\n-                    } else {\n-                        // emit only for files otherwise we will cause watch_recursive to be called again with a dir that we are already watching\n-                        // emit as create because we haven't seen it yet\n-                        self.handle_change(entry.path().to_path_buf(), ChangeKind::Create);\n-                    }\n-                }\n-                Err(e) => log::warn!(\"watcher error: {}\", e),\n-            }\n-        }\n-    }\n-}\n-\n-fn watch_one(watcher: &Mutex<Option<RecommendedWatcher>>, dir: &Path) {\n-    if let Some(watcher) = watcher.lock().as_mut() {\n-        match watcher.watch(dir, RecursiveMode::NonRecursive) {\n-            Ok(()) => log::debug!(\"watching \\\"{}\\\"\", dir.display()),\n-            Err(e) => log::warn!(\"could not watch \\\"{}\\\": {}\", dir.display(), e),\n-        }\n-    }\n-}"}, {"sha": "71a3f807d52b6e13d7d52c98a6b3ddac8077e3f1", "filename": "crates/ra_vfs/src/lib.rs", "status": "modified", "additions": 66, "deletions": 80, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/20d7a431fd6e3e363e698a2e464160640868597b/crates%2Fra_vfs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20d7a431fd6e3e363e698a2e464160640868597b/crates%2Fra_vfs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Flib.rs?ref=20d7a431fd6e3e363e698a2e464160640868597b", "patch": "@@ -18,94 +18,78 @@ mod io;\n use std::{\n     cmp::Reverse,\n     fmt, fs, mem,\n-    ops::{Deref, DerefMut},\n     path::{Path, PathBuf},\n     sync::Arc,\n     thread,\n };\n \n use crossbeam_channel::Receiver;\n-use ra_arena::{impl_arena_id, Arena, RawId};\n+use ra_arena::{impl_arena_id, Arena, RawId, map::ArenaMap};\n use relative_path::{Component, RelativePath, RelativePathBuf};\n use rustc_hash::{FxHashMap, FxHashSet};\n-use walkdir::DirEntry;\n \n pub use crate::io::TaskResult as VfsTask;\n use io::{TaskResult, Worker};\n \n-/// `RootFilter` is a predicate that checks if a file can belong to a root. If\n-/// several filters match a file (nested dirs), the most nested one wins.\n-pub(crate) struct RootFilter {\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct VfsRoot(pub RawId);\n+impl_arena_id!(VfsRoot);\n+\n+/// Describes the contents of a single source root.\n+///\n+/// `RootConfig` can be thought of as a glob pattern like `src/**.rs` whihc\n+/// specifes the source root or as a function whihc takes a `PathBuf` and\n+/// returns `true` iff path belongs to the source root\n+pub(crate) struct RootConfig {\n     root: PathBuf,\n-    filter: fn(&Path, &RelativePath) -> bool,\n     excluded_dirs: Vec<PathBuf>,\n }\n \n-impl RootFilter {\n-    fn new(root: PathBuf, excluded_dirs: Vec<PathBuf>) -> RootFilter {\n-        RootFilter {\n+pub(crate) struct Roots {\n+    roots: Arena<VfsRoot, Arc<RootConfig>>,\n+}\n+\n+impl std::ops::Deref for Roots {\n+    type Target = Arena<VfsRoot, Arc<RootConfig>>;\n+    fn deref(&self) -> &Self::Target {\n+        &self.roots\n+    }\n+}\n+\n+impl RootConfig {\n+    fn new(root: PathBuf, excluded_dirs: Vec<PathBuf>) -> RootConfig {\n+        RootConfig {\n             root,\n-            filter: default_filter,\n             excluded_dirs,\n         }\n     }\n-    /// Check if this root can contain `path`. NB: even if this returns\n-    /// true, the `path` might actually be conained in some nested root.\n-    pub(crate) fn can_contain(&self, path: &Path) -> Option<RelativePathBuf> {\n-        let rel_path = path.strip_prefix(&self.root).ok()?;\n-        let rel_path = RelativePathBuf::from_path(rel_path).ok()?;\n-        if !(self.filter)(path, rel_path.as_relative_path()) {\n+    /// Cheks if root contains a path and returns a root-relative path.\n+    pub(crate) fn contains(&self, path: &Path) -> Option<RelativePathBuf> {\n+        // First, check excluded dirs\n+        if self.excluded_dirs.iter().any(|it| path.starts_with(it)) {\n             return None;\n         }\n-        Some(rel_path)\n-    }\n-\n-    pub(crate) fn entry_filter<'a>(&'a self) -> impl FnMut(&DirEntry) -> bool + 'a {\n-        move |entry: &DirEntry| {\n-            if entry.file_type().is_dir() && self.excluded_dirs.iter().any(|it| it == entry.path())\n-            {\n-                // do not walk nested roots\n-                false\n-            } else {\n-                self.can_contain(entry.path()).is_some()\n-            }\n-        }\n-    }\n-}\n+        let rel_path = path.strip_prefix(&self.root).ok()?;\n+        let rel_path = RelativePathBuf::from_path(rel_path).ok()?;\n \n-pub(crate) fn default_filter(path: &Path, rel_path: &RelativePath) -> bool {\n-    if path.is_dir() {\n+        // Ignore some common directories.\n+        //\n+        // FIXME: don't hard-code, specify at source-root creation time using\n+        // gitignore\n         for (i, c) in rel_path.components().enumerate() {\n             if let Component::Normal(c) = c {\n-                // TODO hardcoded for now\n                 if (i == 0 && c == \"target\") || c == \".git\" || c == \"node_modules\" {\n-                    return false;\n+                    return None;\n                 }\n             }\n         }\n-        true\n-    } else {\n-        rel_path.extension() == Some(\"rs\")\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct VfsRoot(pub RawId);\n-impl_arena_id!(VfsRoot);\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct VfsFile(pub RawId);\n-impl_arena_id!(VfsFile);\n \n-struct VfsFileData {\n-    root: VfsRoot,\n-    path: RelativePathBuf,\n-    is_overlayed: bool,\n-    text: Arc<String>,\n-}\n+        if path.is_file() && rel_path.extension() != Some(\"rs\") {\n+            return None;\n+        }\n \n-pub(crate) struct Roots {\n-    roots: Arena<VfsRoot, Arc<RootFilter>>,\n+        Some(rel_path)\n+    }\n }\n \n impl Roots {\n@@ -120,59 +104,61 @@ impl Roots {\n                 .map(|it| it.clone())\n                 .collect::<Vec<_>>();\n \n-            let root_filter = Arc::new(RootFilter::new(path.clone(), nested_roots));\n+            let config = Arc::new(RootConfig::new(path.clone(), nested_roots));\n \n-            roots.alloc(root_filter.clone());\n+            roots.alloc(config.clone());\n         }\n         Roots { roots }\n     }\n     pub(crate) fn find(&self, path: &Path) -> Option<(VfsRoot, RelativePathBuf)> {\n         self.roots\n             .iter()\n-            .find_map(|(root, data)| data.can_contain(path).map(|it| (root, it)))\n+            .find_map(|(root, data)| data.contains(path).map(|it| (root, it)))\n     }\n }\n \n-impl Deref for Roots {\n-    type Target = Arena<VfsRoot, Arc<RootFilter>>;\n-    fn deref(&self) -> &Self::Target {\n-        &self.roots\n-    }\n-}\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct VfsFile(pub RawId);\n+impl_arena_id!(VfsFile);\n \n-impl DerefMut for Roots {\n-    fn deref_mut(&mut self) -> &mut Self::Target {\n-        &mut self.roots\n-    }\n+struct VfsFileData {\n+    root: VfsRoot,\n+    path: RelativePathBuf,\n+    is_overlayed: bool,\n+    text: Arc<String>,\n }\n \n pub struct Vfs {\n     roots: Arc<Roots>,\n     files: Arena<VfsFile, VfsFileData>,\n-    root2files: FxHashMap<VfsRoot, FxHashSet<VfsFile>>,\n+    root2files: ArenaMap<VfsRoot, FxHashSet<VfsFile>>,\n     pending_changes: Vec<VfsChange>,\n     worker: Worker,\n }\n \n impl fmt::Debug for Vfs {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.write_str(\"Vfs { ... }\")\n+        f.debug_struct(\"Vfs\")\n+            .field(\"n_roots\", &self.roots.len())\n+            .field(\"n_files\", &self.files.len())\n+            .field(\"n_pending_changes\", &self.pending_changes.len())\n+            .finish()\n     }\n }\n \n impl Vfs {\n     pub fn new(roots: Vec<PathBuf>) -> (Vfs, Vec<VfsRoot>) {\n         let roots = Arc::new(Roots::new(roots));\n-        let worker = io::Worker::start(roots.clone());\n-        let mut root2files = FxHashMap::default();\n+        let worker = io::Worker::start(Arc::clone(&roots));\n+        let mut root2files = ArenaMap::default();\n \n-        for (root, filter) in roots.iter() {\n+        for (root, config) in roots.iter() {\n             root2files.insert(root, Default::default());\n             worker\n                 .sender()\n                 .send(io::Task::AddRoot {\n                     root,\n-                    filter: filter.clone(),\n+                    config: Arc::clone(config),\n                 })\n                 .unwrap();\n         }\n@@ -242,7 +228,7 @@ impl Vfs {\n                 let mut cur_files = Vec::new();\n                 // While we were scanning the root in the backgound, a file might have\n                 // been open in the editor, so we need to account for that.\n-                let exising = self.root2files[&root]\n+                let exising = self.root2files[root]\n                     .iter()\n                     .map(|&file| (self.files[file].path.clone(), file))\n                     .collect::<FxHashMap<_, _>>();\n@@ -384,7 +370,7 @@ impl Vfs {\n             is_overlayed,\n         };\n         let file = self.files.alloc(data);\n-        self.root2files.get_mut(&root).unwrap().insert(file);\n+        self.root2files.get_mut(root).unwrap().insert(file);\n         file\n     }\n \n@@ -399,7 +385,7 @@ impl Vfs {\n         self.files[file].text = Default::default();\n         self.files[file].path = Default::default();\n         let root = self.files[file].root;\n-        let removed = self.root2files.get_mut(&root).unwrap().remove(&file);\n+        let removed = self.root2files.get_mut(root).unwrap().remove(&file);\n         assert!(removed);\n     }\n \n@@ -410,7 +396,7 @@ impl Vfs {\n     }\n \n     fn find_file(&self, root: VfsRoot, path: &RelativePath) -> Option<VfsFile> {\n-        self.root2files[&root]\n+        self.root2files[root]\n             .iter()\n             .map(|&it| it)\n             .find(|&file| self.files[file].path == path)"}]}