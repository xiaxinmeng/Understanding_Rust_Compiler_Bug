{"sha": "c1b5c4db8fdaec025f3ace3c69f046426d69d5db", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxYjVjNGRiOGZkYWVjMDI1ZjNhY2UzYzY5ZjA0NjQyNmQ2OWQ1ZGI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-05T00:42:05Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-10T09:37:10Z"}, "message": "Start migrating stream I/O away from ~fn()", "tree": {"sha": "691de9167b966bd74c4805f2bab0712d61393076", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/691de9167b966bd74c4805f2bab0712d61393076"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1b5c4db8fdaec025f3ace3c69f046426d69d5db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1b5c4db8fdaec025f3ace3c69f046426d69d5db", "html_url": "https://github.com/rust-lang/rust/commit/c1b5c4db8fdaec025f3ace3c69f046426d69d5db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1b5c4db8fdaec025f3ace3c69f046426d69d5db/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6690bcb10178b08c56ad56b111e4dcb7e0e06b36", "url": "https://api.github.com/repos/rust-lang/rust/commits/6690bcb10178b08c56ad56b111e4dcb7e0e06b36", "html_url": "https://github.com/rust-lang/rust/commit/6690bcb10178b08c56ad56b111e4dcb7e0e06b36"}], "stats": {"total": 820, "additions": 501, "deletions": 319}, "files": [{"sha": "1d6f2f0edb55e7aa510fe75894994ac9275ca71f", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1b5c4db8fdaec025f3ace3c69f046426d69d5db/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1b5c4db8fdaec025f3ace3c69f046426d69d5db/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=c1b5c4db8fdaec025f3ace3c69f046426d69d5db", "patch": "@@ -66,8 +66,9 @@ pub use self::idle::IdleWatcher;\n pub use self::timer::TimerWatcher;\n pub use self::async::AsyncWatcher;\n pub use self::process::Process;\n-pub use self::pipe::Pipe;\n+pub use self::pipe::PipeWatcher;\n pub use self::signal::SignalWatcher;\n+pub use self::tty::TtyWatcher;\n \n mod macros;\n \n@@ -87,6 +88,7 @@ pub mod process;\n pub mod pipe;\n pub mod tty;\n pub mod signal;\n+pub mod stream;\n \n /// XXX: Loop(*handle) is buggy with destructors. Normal structs\n /// with dtors may not be destructured, but tuple structs can,\n@@ -218,7 +220,6 @@ pub type ReadCallback = ~fn(StreamWatcher, int, Buf, Option<UvError>);\n pub type NullCallback = ~fn();\n pub type ConnectionCallback = ~fn(StreamWatcher, Option<UvError>);\n pub type FsCallback = ~fn(&mut FsRequest, Option<UvError>);\n-pub type AsyncCallback = ~fn(AsyncWatcher, Option<UvError>);\n pub type UdpReceiveCallback = ~fn(UdpWatcher, int, Buf, SocketAddr, uint, Option<UvError>);\n pub type UdpSendCallback = ~fn(UdpWatcher, Option<UvError>);\n \n@@ -231,7 +232,6 @@ struct WatcherData {\n     connect_cb: Option<ConnectionCallback>,\n     close_cb: Option<NullCallback>,\n     alloc_cb: Option<AllocCallback>,\n-    async_cb: Option<AsyncCallback>,\n     udp_recv_cb: Option<UdpReceiveCallback>,\n     udp_send_cb: Option<UdpSendCallback>,\n }"}, {"sha": "f1936635a1839fb8f7670377cc5f5dc470f174ce", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 196, "deletions": 53, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/c1b5c4db8fdaec025f3ace3c69f046426d69d5db/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1b5c4db8fdaec025f3ace3c69f046426d69d5db/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=c1b5c4db8fdaec025f3ace3c69f046426d69d5db", "patch": "@@ -8,91 +8,234 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::libc;\n use std::c_str::CString;\n+use std::cast;\n+use std::libc;\n+use std::rt::BlockedTask;\n+use std::rt::io::IoError;\n+use std::rt::local::Local;\n+use std::rt::rtio::{RtioPipe, RtioUnixListener, RtioUnixAcceptor};\n+use std::rt::sched::{Scheduler, SchedHandle};\n+use std::rt::tube::Tube;\n \n-use super::{Loop, UvError, Watcher, NativeHandle, status_to_maybe_uv_error};\n-use super::ConnectionCallback;\n-use net;\n+use stream::StreamWatcher;\n+use super::{Loop, UvError, NativeHandle, uv_error_to_io_error, UvHandle};\n+use uvio::HomingIO;\n use uvll;\n \n-pub struct Pipe(*uvll::uv_pipe_t);\n+pub struct PipeWatcher {\n+    stream: StreamWatcher,\n+    home: SchedHandle,\n+}\n+\n+pub struct PipeListener {\n+    home: SchedHandle,\n+    pipe: *uvll::uv_pipe_t,\n+    priv closing_task: Option<BlockedTask>,\n+    priv outgoing: Tube<Result<~RtioPipe, IoError>>,\n+}\n+\n+pub struct PipeAcceptor {\n+    listener: ~PipeListener,\n+    priv incoming: Tube<Result<~RtioPipe, IoError>>,\n+}\n \n-impl Watcher for Pipe {}\n+// PipeWatcher implementation and traits\n \n-impl Pipe {\n-    pub fn new(loop_: &Loop, ipc: bool) -> Pipe {\n+impl PipeWatcher {\n+    pub fn new(pipe: *uvll::uv_pipe_t) -> PipeWatcher {\n+        PipeWatcher {\n+            stream: StreamWatcher::new(pipe),\n+            home: get_handle_to_current_scheduler!(),\n+        }\n+    }\n+\n+    pub fn alloc(loop_: &Loop, ipc: bool) -> *uvll::uv_pipe_t {\n         unsafe {\n             let handle = uvll::malloc_handle(uvll::UV_NAMED_PIPE);\n-            assert!(handle.is_not_null());\n+            assert!(!handle.is_null());\n             let ipc = ipc as libc::c_int;\n             assert_eq!(uvll::uv_pipe_init(loop_.native_handle(), handle, ipc), 0);\n-            let mut ret: Pipe =\n-                    NativeHandle::from_native_handle(handle);\n-            ret.install_watcher_data();\n-            ret\n+            handle\n         }\n     }\n \n-    pub fn as_stream(&self) -> net::StreamWatcher {\n-        net::StreamWatcher(**self as *uvll::uv_stream_t)\n+    pub fn open(loop_: &Loop, file: libc::c_int) -> Result<PipeWatcher, UvError>\n+    {\n+        let handle = PipeWatcher::alloc(loop_, false);\n+        match unsafe { uvll::uv_pipe_open(handle, file) } {\n+            0 => Ok(PipeWatcher::new(handle)),\n+            n => {\n+                unsafe { uvll::uv_close(handle, pipe_close_cb) }\n+                Err(UvError(n))\n+            }\n+        }\n     }\n \n-    #[fixed_stack_segment] #[inline(never)]\n-    pub fn open(&mut self, file: libc::c_int) -> Result<(), UvError> {\n-        match unsafe { uvll::uv_pipe_open(self.native_handle(), file) } {\n-            0 => Ok(()),\n-            n => Err(UvError(n))\n+    pub fn connect(loop_: &Loop, name: &CString) -> Result<PipeWatcher, UvError>\n+    {\n+        struct Ctx {\n+            task: Option<BlockedTask>,\n+            result: Option<Result<PipeWatcher, UvError>>,\n         }\n+        let mut cx = Ctx { task: None, result: None };\n+        let req = unsafe { uvll::malloc_req(uvll::UV_CONNECT) };\n+        unsafe { uvll::set_data_for_req(req, &cx as *Ctx) }\n+\n+        let sched: ~Scheduler = Local::take();\n+        do sched.deschedule_running_task_and_then |_, task| {\n+            cx.task = Some(task);\n+            unsafe {\n+                uvll::uv_pipe_connect(req,\n+                                      PipeWatcher::alloc(loop_, false),\n+                                      name.with_ref(|p| p),\n+                                      connect_cb)\n+            }\n+        }\n+        assert!(cx.task.is_none());\n+        return cx.result.take().expect(\"pipe connect needs a result\");\n+\n+        extern fn connect_cb(req: *uvll::uv_connect_t, status: libc::c_int) {\n+            unsafe {\n+                let cx: &mut Ctx = cast::transmute(uvll::get_data_for_req(req));\n+                let stream = uvll::get_stream_handle_from_connect_req(req);\n+                cx.result = Some(match status {\n+                    0 => Ok(PipeWatcher::new(stream)),\n+                    n => {\n+                        uvll::free_handle(stream);\n+                        Err(UvError(n))\n+                    }\n+                });\n+                uvll::free_req(req);\n+\n+                let sched: ~Scheduler = Local::take();\n+                sched.resume_blocked_task_immediately(cx.task.take_unwrap());\n+            }\n+        }\n+    }\n+}\n+\n+impl RtioPipe for PipeWatcher {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+        let _m = self.fire_missiles();\n+        self.stream.read(buf).map_err(uv_error_to_io_error)\n+    }\n+\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+        let _m = self.fire_missiles();\n+        self.stream.write(buf).map_err(uv_error_to_io_error)\n+    }\n+}\n+\n+impl HomingIO for PipeWatcher {\n+    fn home<'a>(&'a mut self) -> &'a mut SchedHandle { &mut self.home }\n+}\n+\n+impl Drop for PipeWatcher {\n+    fn drop(&mut self) {\n+        let _m = self.fire_missiles();\n+        self.stream.close(true); // close synchronously\n     }\n+}\n+\n+extern fn pipe_close_cb(handle: *uvll::uv_handle_t) {\n+    unsafe { uvll::free_handle(handle) }\n+}\n \n-    #[fixed_stack_segment] #[inline(never)]\n-    pub fn bind(&mut self, name: &CString) -> Result<(), UvError> {\n-        do name.with_ref |name| {\n-            match unsafe { uvll::uv_pipe_bind(self.native_handle(), name) } {\n-                0 => Ok(()),\n-                n => Err(UvError(n))\n+// PipeListener implementation and traits\n+\n+impl PipeListener {\n+    pub fn bind(loop_: &Loop, name: &CString) -> Result<~PipeListener, UvError> {\n+        let pipe = PipeWatcher::alloc(loop_, false);\n+        match unsafe { uvll::uv_pipe_bind(pipe, name.with_ref(|p| p)) } {\n+            0 => {\n+                let p = ~PipeListener {\n+                    home: get_handle_to_current_scheduler!(),\n+                    pipe: pipe,\n+                    closing_task: None,\n+                    outgoing: Tube::new(),\n+                };\n+                Ok(p.install())\n+            }\n+            n => {\n+                unsafe { uvll::free_handle(pipe) }\n+                Err(UvError(n))\n             }\n         }\n     }\n+}\n \n-    #[fixed_stack_segment] #[inline(never)]\n-    pub fn connect(&mut self, name: &CString, cb: ConnectionCallback) {\n-        {\n-            let data = self.get_watcher_data();\n-            assert!(data.connect_cb.is_none());\n-            data.connect_cb = Some(cb);\n+impl RtioUnixListener for PipeListener {\n+    fn listen(mut ~self) -> Result<~RtioUnixAcceptor, IoError> {\n+        // create the acceptor object from ourselves\n+        let incoming = self.outgoing.clone();\n+        let mut acceptor = ~PipeAcceptor {\n+            listener: self,\n+            incoming: incoming,\n+        };\n+\n+        let _m = acceptor.fire_missiles();\n+        // XXX: the 128 backlog should be configurable\n+        match unsafe { uvll::uv_listen(acceptor.listener.pipe, 128, listen_cb) } {\n+            0 => Ok(acceptor as ~RtioUnixAcceptor),\n+            n => Err(uv_error_to_io_error(UvError(n))),\n         }\n+    }\n+}\n \n-        let connect = net::ConnectRequest::new();\n-        let name = do name.with_ref |p| { p };\n+impl HomingIO for PipeListener {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+}\n \n-        unsafe {\n-            uvll::uv_pipe_connect(connect.native_handle(),\n-                               self.native_handle(),\n-                               name,\n-                               connect_cb)\n+impl UvHandle<uvll::uv_pipe_t> for PipeListener {\n+    fn uv_handle(&self) -> *uvll::uv_pipe_t { self.pipe }\n+}\n+\n+extern fn listen_cb(server: *uvll::uv_stream_t, status: libc::c_int) {\n+    let msg = match status {\n+        0 => {\n+            let loop_ = NativeHandle::from_native_handle(unsafe {\n+                uvll::get_loop_for_uv_handle(server)\n+            });\n+            let client = PipeWatcher::alloc(&loop_, false);\n+            assert_eq!(unsafe { uvll::uv_accept(server, client) }, 0);\n+            Ok(~PipeWatcher::new(client) as ~RtioPipe)\n         }\n+        n => Err(uv_error_to_io_error(UvError(n)))\n+    };\n+\n+    let pipe: &mut PipeListener = unsafe { UvHandle::from_uv_handle(&server) };\n+    pipe.outgoing.send(msg);\n+}\n \n-        extern \"C\" fn connect_cb(req: *uvll::uv_connect_t, status: libc::c_int) {\n-            let connect_request: net::ConnectRequest =\n-                    NativeHandle::from_native_handle(req);\n-            let mut stream_watcher = connect_request.stream();\n-            connect_request.delete();\n+impl Drop for PipeListener {\n+    fn drop(&mut self) {\n+        let (_m, sched) = self.fire_missiles_sched();\n \n-            let cb = stream_watcher.get_watcher_data().connect_cb.take_unwrap();\n-            let status = status_to_maybe_uv_error(status);\n-            cb(stream_watcher, status);\n+        do sched.deschedule_running_task_and_then |_, task| {\n+            self.closing_task = Some(task);\n+            unsafe { uvll::uv_close(self.pipe, listener_close_cb) }\n         }\n     }\n+}\n+\n+extern fn listener_close_cb(handle: *uvll::uv_handle_t) {\n+    let pipe: &mut PipeListener = unsafe { UvHandle::from_uv_handle(&handle) };\n+    unsafe { uvll::free_handle(handle) }\n \n+    let sched: ~Scheduler = Local::take();\n+    sched.resume_blocked_task_immediately(pipe.closing_task.take_unwrap());\n }\n \n-impl NativeHandle<*uvll::uv_pipe_t> for Pipe {\n-    fn from_native_handle(handle: *uvll::uv_pipe_t) -> Pipe {\n-        Pipe(handle)\n-    }\n-    fn native_handle(&self) -> *uvll::uv_pipe_t {\n-        match self { &Pipe(ptr) => ptr }\n+// PipeAcceptor implementation and traits\n+\n+impl RtioUnixAcceptor for PipeAcceptor {\n+    fn accept(&mut self) -> Result<~RtioPipe, IoError> {\n+        let _m = self.fire_missiles();\n+        self.incoming.recv()\n     }\n }\n+\n+impl HomingIO for PipeAcceptor {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { self.listener.home() }\n+}"}, {"sha": "50964d7a84c63aff6546cacb948b492ae990d40f", "filename": "src/librustuv/process.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c1b5c4db8fdaec025f3ace3c69f046426d69d5db/src%2Flibrustuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1b5c4db8fdaec025f3ace3c69f046426d69d5db/src%2Flibrustuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fprocess.rs?ref=c1b5c4db8fdaec025f3ace3c69f046426d69d5db", "patch": "@@ -21,8 +21,9 @@ use std::rt::sched::{Scheduler, SchedHandle};\n use std::vec;\n \n use super::{Loop, NativeHandle, UvHandle, UvError, uv_error_to_io_error};\n-use uvio::{HomingIO, UvPipeStream, UvUnboundPipe};\n+use uvio::HomingIO;\n use uvll;\n+use pipe::PipeWatcher;\n \n pub struct Process {\n     handle: *uvll::uv_process_t,\n@@ -42,7 +43,7 @@ impl Process {\n     /// Returns either the corresponding process object or an error which\n     /// occurred.\n     pub fn spawn(loop_: &Loop, config: ProcessConfig)\n-                -> Result<(~Process, ~[Option<~UvPipeStream>]), UvError>\n+                -> Result<(~Process, ~[Option<PipeWatcher>]), UvError>\n     {\n         let cwd = config.cwd.map(|s| s.to_c_str());\n         let io = config.io;\n@@ -121,7 +122,7 @@ extern fn on_exit(handle: *uvll::uv_process_t,\n \n unsafe fn set_stdio(dst: *uvll::uv_stdio_container_t,\n                     io: &StdioContainer,\n-                    loop_: &Loop) -> Option<~UvPipeStream> {\n+                    loop_: &Loop) -> Option<PipeWatcher> {\n     match *io {\n         Ignored => {\n             uvll::set_stdio_container_flags(dst, uvll::STDIO_IGNORE);\n@@ -140,11 +141,10 @@ unsafe fn set_stdio(dst: *uvll::uv_stdio_container_t,\n             if writable {\n                 flags |= uvll::STDIO_WRITABLE_PIPE as libc::c_int;\n             }\n-            let pipe = UvUnboundPipe::new(loop_);\n-            let handle = pipe.pipe.as_stream().native_handle();\n+            let pipe_handle = PipeWatcher::alloc(loop_, false);\n             uvll::set_stdio_container_flags(dst, flags);\n-            uvll::set_stdio_container_stream(dst, handle);\n-            Some(~UvPipeStream::new(pipe))\n+            uvll::set_stdio_container_stream(dst, pipe_handle);\n+            Some(PipeWatcher::new(pipe_handle))\n         }\n     }\n }"}, {"sha": "ad0deebd45711abbc052cb00262ef35e4289a047", "filename": "src/librustuv/stream.rs", "status": "added", "additions": 216, "deletions": 0, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/c1b5c4db8fdaec025f3ace3c69f046426d69d5db/src%2Flibrustuv%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1b5c4db8fdaec025f3ace3c69f046426d69d5db/src%2Flibrustuv%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fstream.rs?ref=c1b5c4db8fdaec025f3ace3c69f046426d69d5db", "patch": "@@ -0,0 +1,216 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cast;\n+use std::libc::{c_int, size_t, ssize_t, c_void};\n+use std::ptr;\n+use std::rt::BlockedTask;\n+use std::rt::local::Local;\n+use std::rt::sched::Scheduler;\n+\n+use super::{UvError, Buf, slice_to_uv_buf};\n+use uvll;\n+\n+// This is a helper structure which is intended to get embedded into other\n+// Watcher structures. This structure will retain a handle to the underlying\n+// uv_stream_t instance, and all I/O operations assume that it's already located\n+// on the appropriate scheduler.\n+pub struct StreamWatcher {\n+    handle: *uvll::uv_stream_t,\n+\n+    // Cache the last used uv_write_t so we don't have to allocate a new one on\n+    // every call to uv_write(). Ideally this would be a stack-allocated\n+    // structure, but currently we don't have mappings for all the structures\n+    // defined in libuv, so we're foced to malloc this.\n+    priv last_write_req: Option<*uvll::uv_write_t>,\n+}\n+\n+struct ReadContext {\n+    buf: Option<Buf>,\n+    result: Option<Result<uint, UvError>>,\n+    task: Option<BlockedTask>,\n+}\n+\n+struct WriteContext {\n+    result: Option<Result<(), UvError>>,\n+    task: Option<BlockedTask>,\n+}\n+\n+impl StreamWatcher {\n+    // Creates a new helper structure which should be then embedded into another\n+    // watcher. This provides the generic read/write methods on streams.\n+    //\n+    // This structure will *not* close the stream when it is dropped. It is up\n+    // to the enclosure structure to be sure to call the close method (which\n+    // will block the task). Note that this is also required to prevent memory\n+    // leaks.\n+    //\n+    // It should also be noted that the `data` field of the underlying uv handle\n+    // will be manipulated on each of the methods called on this watcher.\n+    // Wrappers should ensure to always reset the field to an appropriate value\n+    // if they rely on the field to perform an action.\n+    pub fn new(stream: *uvll::uv_stream_t) -> StreamWatcher {\n+        StreamWatcher {\n+            handle: stream,\n+            last_write_req: None,\n+        }\n+    }\n+\n+    pub fn read(&mut self, buf: &mut [u8]) -> Result<uint, UvError> {\n+        // Send off the read request, but don't block until we're sure that the\n+        // read request is queued.\n+        match unsafe {\n+            uvll::uv_read_start(self.handle, alloc_cb, read_cb)\n+        } {\n+            0 => {\n+                let mut rcx = ReadContext {\n+                    buf: Some(slice_to_uv_buf(buf)),\n+                    result: None,\n+                    task: None,\n+                };\n+                unsafe {\n+                    uvll::set_data_for_uv_handle(self.handle, &rcx)\n+                }\n+                let scheduler: ~Scheduler = Local::take();\n+                do scheduler.deschedule_running_task_and_then |_sched, task| {\n+                    rcx.task = Some(task);\n+                }\n+                rcx.result.take().expect(\"no result in read stream?\")\n+            }\n+            n => Err(UvError(n))\n+        }\n+    }\n+\n+    pub fn write(&mut self, buf: &[u8]) -> Result<(), UvError> {\n+        // Prepare the write request, either using a cached one or allocating a\n+        // new one\n+        let req = match self.last_write_req {\n+            Some(req) => req,\n+            None => unsafe { uvll::malloc_req(uvll::UV_WRITE) },\n+        };\n+        self.last_write_req = Some(req);\n+        let mut wcx = WriteContext { result: None, task: None, };\n+        unsafe { uvll::set_data_for_req(req, &wcx as *WriteContext) }\n+\n+        // Send off the request, but be careful to not block until we're sure\n+        // that the write reqeust is queued. If the reqeust couldn't be queued,\n+        // then we should return immediately with an error.\n+        match unsafe {\n+            uvll::uv_write(req, self.handle, [slice_to_uv_buf(buf)], write_cb)\n+        } {\n+            0 => {\n+                let scheduler: ~Scheduler = Local::take();\n+                do scheduler.deschedule_running_task_and_then |_sched, task| {\n+                    wcx.task = Some(task);\n+                }\n+                assert!(wcx.task.is_none());\n+                wcx.result.take().expect(\"no result in write stream?\")\n+            }\n+            n => Err(UvError(n)),\n+        }\n+    }\n+\n+    // This will deallocate an internally used memory, along with closing the\n+    // handle (and freeing it).\n+    //\n+    // The `synchronous` flag dictates whether this handle is closed\n+    // synchronously (the task is blocked) or asynchronously (the task is not\n+    // block, but the handle is still deallocated).\n+    pub fn close(&mut self, synchronous: bool) {\n+        // clean up the cached write request if we have one\n+        match self.last_write_req {\n+            Some(req) => unsafe { uvll::free_req(req) },\n+            None => {}\n+        }\n+\n+        if synchronous {\n+            let mut closing_task = None;\n+            unsafe {\n+                uvll::set_data_for_uv_handle(self.handle, &closing_task);\n+            }\n+\n+            // Wait for this stream to close because it possibly represents a remote\n+            // connection which may have consequences if we close asynchronously.\n+            let sched: ~Scheduler = Local::take();\n+            do sched.deschedule_running_task_and_then |_, task| {\n+                closing_task = Some(task);\n+                unsafe { uvll::uv_close(self.handle, close_cb) }\n+            }\n+        } else {\n+            unsafe {\n+                uvll::set_data_for_uv_handle(self.handle, ptr::null::<u8>());\n+                uvll::uv_close(self.handle, close_cb)\n+            }\n+        }\n+\n+        extern fn close_cb(handle: *uvll::uv_handle_t) {\n+            let data: *c_void = unsafe { uvll::get_data_for_uv_handle(handle) };\n+            unsafe { uvll::free_handle(handle) }\n+            if data.is_null() { return }\n+\n+            let closing_task: &mut Option<BlockedTask> = unsafe {\n+                cast::transmute(data)\n+            };\n+            let task = closing_task.take_unwrap();\n+            let scheduler: ~Scheduler = Local::take();\n+            scheduler.resume_blocked_task_immediately(task);\n+        }\n+    }\n+}\n+\n+// This allocation callback expects to be invoked once and only once. It will\n+// unwrap the buffer in the ReadContext stored in the stream and return it. This\n+// will fail if it is called more than once.\n+extern fn alloc_cb(stream: *uvll::uv_stream_t, _hint: size_t) -> Buf {\n+    let rcx: &mut ReadContext = unsafe {\n+        cast::transmute(uvll::get_data_for_uv_handle(stream))\n+    };\n+    rcx.buf.take().expect(\"alloc_cb called more than once\")\n+}\n+\n+// When a stream has read some data, we will always forcibly stop reading and\n+// return all the data read (even if it didn't fill the whole buffer).\n+extern fn read_cb(handle: *uvll::uv_stream_t, nread: ssize_t, _buf: Buf) {\n+    let rcx: &mut ReadContext = unsafe {\n+        cast::transmute(uvll::get_data_for_uv_handle(handle))\n+    };\n+    // Stop reading so that no read callbacks are\n+    // triggered before the user calls `read` again.\n+    // XXX: Is there a performance impact to calling\n+    // stop here?\n+    unsafe { assert_eq!(uvll::uv_read_stop(handle), 0); }\n+\n+    assert!(rcx.result.is_none());\n+    rcx.result = Some(match nread {\n+        n if n < 0 => Err(UvError(n as c_int)),\n+        n => Ok(n as uint),\n+    });\n+\n+    let task = rcx.task.take().expect(\"read_cb needs a task\");\n+    let scheduler: ~Scheduler = Local::take();\n+    scheduler.resume_blocked_task_immediately(task);\n+}\n+\n+// Unlike reading, the WriteContext is stored in the uv_write_t request. Like\n+// reading, however, all this does is wake up the blocked task after squirreling\n+// away the error code as a result.\n+extern fn write_cb(req: *uvll::uv_write_t, status: c_int) {\n+    // Remember to not free the request because it is re-used between writes on\n+    // the same stream.\n+    unsafe {\n+        let wcx: &mut WriteContext = cast::transmute(uvll::get_data_for_req(req));\n+        wcx.result = Some(match status {\n+            0 => Ok(()),\n+            n => Err(UvError(n)),\n+        });\n+        let sched: ~Scheduler = Local::take();\n+        sched.resume_blocked_task_immediately(wcx.task.take_unwrap());\n+    }\n+}"}, {"sha": "316a817354db1a59f99f85d7d0a30908e5b13044", "filename": "src/librustuv/tty.rs", "status": "modified", "additions": 66, "deletions": 36, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/c1b5c4db8fdaec025f3ace3c69f046426d69d5db/src%2Flibrustuv%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1b5c4db8fdaec025f3ace3c69f046426d69d5db/src%2Flibrustuv%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftty.rs?ref=c1b5c4db8fdaec025f3ace3c69f046426d69d5db", "patch": "@@ -9,75 +9,105 @@\n // except according to those terms.\n \n use std::libc;\n+use std::rt::io::IoError;\n+use std::rt::local::Local;\n+use std::rt::rtio::RtioTTY;\n+use std::rt::sched::{Scheduler, SchedHandle};\n \n-use super::{Watcher, Loop, NativeHandle, UvError};\n-use net;\n+use stream::StreamWatcher;\n+use super::{Loop, UvError, UvHandle, uv_error_to_io_error};\n+use uvio::HomingIO;\n use uvll;\n \n-/// A process wraps the handle of the underlying uv_process_t.\n-pub struct TTY(*uvll::uv_tty_t);\n-\n-impl Watcher for TTY {}\n+pub struct TtyWatcher{\n+    tty: *uvll::uv_tty_t,\n+    stream: StreamWatcher,\n+    home: SchedHandle,\n+    fd: libc::c_int,\n+}\n \n-impl TTY {\n-    #[fixed_stack_segment] #[inline(never)]\n-    pub fn new(loop_: &Loop, fd: libc::c_int, readable: bool) ->\n-            Result<TTY, UvError>\n+impl TtyWatcher {\n+    pub fn new(loop_: &Loop, fd: libc::c_int, readable: bool)\n+        -> Result<TtyWatcher, UvError>\n     {\n-        let handle = unsafe { uvll::malloc_handle(uvll::UV_TTY) };\n-        assert!(handle.is_not_null());\n+        let handle = UvHandle::alloc(None::<TtyWatcher>, uvll::UV_TTY);\n \n-        let ret = unsafe {\n+        match unsafe {\n             uvll::uv_tty_init(loop_.native_handle(), handle, fd as libc::c_int,\n                               readable as libc::c_int)\n-        };\n-        match ret {\n+        } {\n             0 => {\n-                let mut ret: TTY = NativeHandle::from_native_handle(handle);\n-                ret.install_watcher_data();\n-                Ok(ret)\n+                Ok(TtyWatcher {\n+                    tty: handle,\n+                    stream: StreamWatcher::new(handle),\n+                    home: get_handle_to_current_scheduler!(),\n+                    fd: fd,\n+                })\n             }\n             n => {\n-                unsafe { uvll::free_handle(handle); }\n+                unsafe { uvll::free_handle(handle) }\n                 Err(UvError(n))\n             }\n         }\n     }\n+}\n \n-    pub fn as_stream(&self) -> net::StreamWatcher {\n-        net::StreamWatcher(**self as *uvll::uv_stream_t)\n+impl RtioTTY for TtyWatcher {\n+    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+        let _m = self.fire_missiles();\n+        self.stream.read(buf).map_err(uv_error_to_io_error)\n     }\n \n-    #[fixed_stack_segment] #[inline(never)]\n-    pub fn set_mode(&self, raw: bool) -> Result<(), UvError> {\n+    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+        let _m = self.fire_missiles();\n+        self.stream.write(buf).map_err(uv_error_to_io_error)\n+    }\n+\n+    fn set_raw(&mut self, raw: bool) -> Result<(), IoError> {\n         let raw = raw as libc::c_int;\n-        match unsafe { uvll::uv_tty_set_mode(self.native_handle(), raw) } {\n+        let _m = self.fire_missiles();\n+        match unsafe { uvll::uv_tty_set_mode(self.tty, raw) } {\n             0 => Ok(()),\n-            n => Err(UvError(n))\n+            n => Err(uv_error_to_io_error(UvError(n)))\n         }\n     }\n \n-    #[fixed_stack_segment] #[inline(never)] #[allow(unused_mut)]\n-    pub fn get_winsize(&self) -> Result<(int, int), UvError> {\n+    #[allow(unused_mut)]\n+    fn get_winsize(&mut self) -> Result<(int, int), IoError> {\n         let mut width: libc::c_int = 0;\n         let mut height: libc::c_int = 0;\n         let widthptr: *libc::c_int = &width;\n         let heightptr: *libc::c_int = &width;\n \n-        match unsafe { uvll::uv_tty_get_winsize(self.native_handle(),\n+        let _m = self.fire_missiles();\n+        match unsafe { uvll::uv_tty_get_winsize(self.tty,\n                                                 widthptr, heightptr) } {\n             0 => Ok((width as int, height as int)),\n-            n => Err(UvError(n))\n+            n => Err(uv_error_to_io_error(UvError(n)))\n         }\n     }\n-}\n \n-impl NativeHandle<*uvll::uv_tty_t> for TTY {\n-    fn from_native_handle(handle: *uvll::uv_tty_t) -> TTY {\n-        TTY(handle)\n-    }\n-    fn native_handle(&self) -> *uvll::uv_tty_t {\n-        match self { &TTY(ptr) => ptr }\n+    fn isatty(&self) -> bool {\n+        unsafe { uvll::uv_guess_handle(self.fd) == uvll::UV_TTY }\n     }\n }\n \n+impl UvHandle<uvll::uv_tty_t> for TtyWatcher {\n+    fn uv_handle(&self) -> *uvll::uv_tty_t { self.tty }\n+}\n+\n+impl HomingIO for TtyWatcher {\n+    fn home<'a>(&'a mut self) -> &'a mut SchedHandle { &mut self.home }\n+}\n+\n+impl Drop for TtyWatcher {\n+    // TTY handles are used for the logger in a task, so this destructor is run\n+    // when a task is destroyed. When a task is being destroyed, a local\n+    // scheduler isn't available, so we can't do the normal \"take the scheduler\n+    // and resume once close is done\". Instead close operations on a TTY are\n+    // asynchronous.\n+    fn drop(&mut self) {\n+        let _m = self.fire_missiles();\n+        self.stream.close(false);\n+    }\n+}"}, {"sha": "592a23297cc3a8dba632137e29541de8ff488fb4", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 13, "deletions": 218, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/c1b5c4db8fdaec025f3ace3c69f046426d69d5db/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1b5c4db8fdaec025f3ace3c69f046426d69d5db/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=c1b5c4db8fdaec025f3ace3c69f046426d69d5db", "patch": "@@ -49,6 +49,7 @@ use super::*;\n use idle::IdleWatcher;\n use net::{UvIpv4SocketAddr, UvIpv6SocketAddr};\n use addrinfo::{GetAddrInfoRequest, accum_addrinfo};\n+use pipe::PipeListener;\n \n // XXX we should not be calling uvll functions in here.\n \n@@ -616,67 +617,38 @@ impl IoFactory for UvIoFactory {\n         match Process::spawn(self.uv_loop(), config) {\n             Ok((p, io)) => {\n                 Ok((p as ~RtioProcess,\n-                    io.move_iter().map(|i| i.map(|p| p as ~RtioPipe)).collect()))\n+                    io.move_iter().map(|i| i.map(|p| ~p as ~RtioPipe)).collect()))\n             }\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }\n \n-    fn unix_bind(&mut self, path: &CString) ->\n-        Result<~RtioUnixListener, IoError> {\n-        let mut pipe = UvUnboundPipe::new(self.uv_loop());\n-        match pipe.pipe.bind(path) {\n-            Ok(()) => Ok(~UvUnixListener::new(pipe) as ~RtioUnixListener),\n+    fn unix_bind(&mut self, path: &CString) -> Result<~RtioUnixListener, IoError>\n+    {\n+        match PipeListener::bind(self.uv_loop(), path) {\n+            Ok(p) => Ok(p as ~RtioUnixListener),\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }\n \n     fn unix_connect(&mut self, path: &CString) -> Result<~RtioPipe, IoError> {\n-        let pipe = UvUnboundPipe::new(self.uv_loop());\n-        let mut rawpipe = pipe.pipe;\n-\n-        let result_cell = Cell::new_empty();\n-        let result_cell_ptr: *Cell<Result<~RtioPipe, IoError>> = &result_cell;\n-        let pipe_cell = Cell::new(pipe);\n-        let pipe_cell_ptr: *Cell<UvUnboundPipe> = &pipe_cell;\n-\n-        let scheduler: ~Scheduler = Local::take();\n-        do scheduler.deschedule_running_task_and_then |_, task| {\n-            let task_cell = Cell::new(task);\n-            do rawpipe.connect(path) |_stream, err| {\n-                let res = match err {\n-                    None => {\n-                        let pipe = unsafe { (*pipe_cell_ptr).take() };\n-                        Ok(~UvPipeStream::new(pipe) as ~RtioPipe)\n-                    }\n-                    Some(e) => Err(uv_error_to_io_error(e)),\n-                };\n-                unsafe { (*result_cell_ptr).put_back(res); }\n-                let scheduler: ~Scheduler = Local::take();\n-                scheduler.resume_blocked_task_immediately(task_cell.take());\n-            }\n+        match PipeWatcher::connect(self.uv_loop(), path) {\n+            Ok(p) => Ok(~p as ~RtioPipe),\n+            Err(e) => Err(uv_error_to_io_error(e)),\n         }\n-\n-        assert!(!result_cell.is_empty());\n-        return result_cell.take();\n     }\n \n     fn tty_open(&mut self, fd: c_int, readable: bool)\n             -> Result<~RtioTTY, IoError> {\n-        match tty::TTY::new(self.uv_loop(), fd, readable) {\n-            Ok(tty) => Ok(~UvTTY {\n-                home: get_handle_to_current_scheduler!(),\n-                tty: tty,\n-                fd: fd,\n-            } as ~RtioTTY),\n+        match TtyWatcher::new(self.uv_loop(), fd, readable) {\n+            Ok(tty) => Ok(~tty as ~RtioTTY),\n             Err(e) => Err(uv_error_to_io_error(e))\n         }\n     }\n \n     fn pipe_open(&mut self, fd: c_int) -> Result<~RtioPipe, IoError> {\n-        let mut pipe = UvUnboundPipe::new(self.uv_loop());\n-        match pipe.pipe.open(fd) {\n-            Ok(()) => Ok(~UvPipeStream::new(pipe) as ~RtioPipe),\n+        match PipeWatcher::open(self.uv_loop(), fd) {\n+            Ok(s) => Ok(~s as ~RtioPipe),\n             Err(e) => Err(uv_error_to_io_error(e))\n         }\n     }\n@@ -865,60 +837,6 @@ fn write_stream(mut watcher: StreamWatcher,\n     result_cell.take()\n }\n \n-pub struct UvUnboundPipe {\n-    pipe: Pipe,\n-    priv home: SchedHandle,\n-}\n-\n-impl UvUnboundPipe {\n-    /// Creates a new unbound pipe homed to the current scheduler, placed on the\n-    /// specified event loop\n-    pub fn new(loop_: &Loop) -> UvUnboundPipe {\n-        UvUnboundPipe {\n-            pipe: Pipe::new(loop_, false),\n-            home: get_handle_to_current_scheduler!(),\n-        }\n-    }\n-}\n-\n-impl HomingIO for UvUnboundPipe {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n-}\n-\n-impl Drop for UvUnboundPipe {\n-    fn drop(&mut self) {\n-        let (_m, sched) = self.fire_homing_missile_sched();\n-        do sched.deschedule_running_task_and_then |_, task| {\n-            let task_cell = Cell::new(task);\n-            do self.pipe.close {\n-                let scheduler: ~Scheduler = Local::take();\n-                scheduler.resume_blocked_task_immediately(task_cell.take());\n-            }\n-        }\n-    }\n-}\n-\n-pub struct UvPipeStream {\n-    priv inner: UvUnboundPipe,\n-}\n-\n-impl UvPipeStream {\n-    pub fn new(inner: UvUnboundPipe) -> UvPipeStream {\n-        UvPipeStream { inner: inner }\n-    }\n-}\n-\n-impl RtioPipe for UvPipeStream {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n-        let (_m, scheduler) = self.inner.fire_homing_missile_sched();\n-        read_stream(self.inner.pipe.as_stream(), scheduler, buf)\n-    }\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n-        let (_m, scheduler) = self.inner.fire_homing_missile_sched();\n-        write_stream(self.inner.pipe.as_stream(), scheduler, buf)\n-    }\n-}\n-\n pub struct UvTcpStream {\n     priv watcher: TcpWatcher,\n     priv home: SchedHandle,\n@@ -1307,129 +1225,6 @@ impl RtioFileStream for UvFileStream {\n     }\n }\n \n-pub struct UvUnixListener {\n-    priv inner: UvUnboundPipe\n-}\n-\n-impl HomingIO for UvUnixListener {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { self.inner.home() }\n-}\n-\n-impl UvUnixListener {\n-    fn new(pipe: UvUnboundPipe) -> UvUnixListener {\n-        UvUnixListener { inner: pipe }\n-    }\n-}\n-\n-impl RtioUnixListener for UvUnixListener {\n-    fn listen(mut ~self) -> Result<~RtioUnixAcceptor, IoError> {\n-        let _m = self.fire_homing_missile();\n-        let acceptor = ~UvUnixAcceptor::new(*self);\n-        let incoming = Cell::new(acceptor.incoming.clone());\n-        let mut stream = acceptor.listener.inner.pipe.as_stream();\n-        let res = do stream.listen |mut server, status| {\n-            do incoming.with_mut_ref |incoming| {\n-                let inc = match status {\n-                    Some(e) => Err(uv_error_to_io_error(e)),\n-                    None => {\n-                        let pipe = UvUnboundPipe::new(&server.event_loop());\n-                        server.accept(pipe.pipe.as_stream());\n-                        Ok(~UvPipeStream::new(pipe) as ~RtioPipe)\n-                    }\n-                };\n-                incoming.send(inc);\n-            }\n-        };\n-        match res {\n-            Ok(()) => Ok(acceptor as ~RtioUnixAcceptor),\n-            Err(e) => Err(uv_error_to_io_error(e)),\n-        }\n-    }\n-}\n-\n-pub struct UvTTY {\n-    tty: tty::TTY,\n-    home: SchedHandle,\n-    fd: c_int,\n-}\n-\n-impl HomingIO for UvTTY {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n-}\n-\n-impl Drop for UvTTY {\n-    fn drop(&mut self) {\n-        // TTY handles are used for the logger in a task, so this destructor is\n-        // run when a task is destroyed. When a task is being destroyed, a local\n-        // scheduler isn't available, so we can't do the normal \"take the\n-        // scheduler and resume once close is done\". Instead close operations on\n-        // a TTY are asynchronous.\n-        self.tty.close_async();\n-    }\n-}\n-\n-impl RtioTTY for UvTTY {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n-        let (_m, scheduler) = self.fire_homing_missile_sched();\n-        read_stream(self.tty.as_stream(), scheduler, buf)\n-    }\n-\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n-        let (_m, scheduler) = self.fire_homing_missile_sched();\n-        write_stream(self.tty.as_stream(), scheduler, buf)\n-    }\n-\n-    fn set_raw(&mut self, raw: bool) -> Result<(), IoError> {\n-        let _m = self.fire_homing_missile();\n-        match self.tty.set_mode(raw) {\n-            Ok(p) => Ok(p), Err(e) => Err(uv_error_to_io_error(e))\n-        }\n-    }\n-\n-    fn get_winsize(&mut self) -> Result<(int, int), IoError> {\n-        let _m = self.fire_homing_missile();\n-        match self.tty.get_winsize() {\n-            Ok(p) => Ok(p), Err(e) => Err(uv_error_to_io_error(e))\n-        }\n-    }\n-\n-    fn isatty(&self) -> bool {\n-        unsafe { uvll::uv_guess_handle(self.fd) == uvll::UV_TTY }\n-    }\n-}\n-\n-pub struct UvUnixAcceptor {\n-    listener: UvUnixListener,\n-    incoming: Tube<Result<~RtioPipe, IoError>>,\n-}\n-\n-impl HomingIO for UvUnixAcceptor {\n-    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { self.listener.home() }\n-}\n-\n-impl UvUnixAcceptor {\n-    fn new(listener: UvUnixListener) -> UvUnixAcceptor {\n-        UvUnixAcceptor { listener: listener, incoming: Tube::new() }\n-    }\n-}\n-\n-impl RtioUnixAcceptor for UvUnixAcceptor {\n-    fn accept(&mut self) -> Result<~RtioPipe, IoError> {\n-        let _m = self.fire_homing_missile();\n-        self.incoming.recv()\n-    }\n-\n-    fn accept_simultaneously(&mut self) -> Result<(), IoError> {\n-        let _m = self.fire_homing_missile();\n-        accept_simultaneously(self.listener.inner.pipe.as_stream(), 1)\n-    }\n-\n-    fn dont_accept_simultaneously(&mut self) -> Result<(), IoError> {\n-        let _m = self.fire_homing_missile();\n-        accept_simultaneously(self.listener.inner.pipe.as_stream(), 0)\n-    }\n-}\n-\n // this function is full of lies\n unsafe fn local_io() -> &'static mut IoFactory {\n     do Local::borrow |sched: &mut Scheduler| {"}, {"sha": "f8b87abb9f67700f33f9425dae88cf3c3ed37a24", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1b5c4db8fdaec025f3ace3c69f046426d69d5db/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1b5c4db8fdaec025f3ace3c69f046426d69d5db/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=c1b5c4db8fdaec025f3ace3c69f046426d69d5db", "patch": "@@ -213,8 +213,6 @@ pub trait RtioUnixListener {\n \n pub trait RtioUnixAcceptor {\n     fn accept(&mut self) -> Result<~RtioPipe, IoError>;\n-    fn accept_simultaneously(&mut self) -> Result<(), IoError>;\n-    fn dont_accept_simultaneously(&mut self) -> Result<(), IoError>;\n }\n \n pub trait RtioTTY {"}]}