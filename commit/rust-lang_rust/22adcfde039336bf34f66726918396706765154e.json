{"sha": "22adcfde039336bf34f66726918396706765154e", "node_id": "C_kwDOAAsO6NoAKDIyYWRjZmRlMDM5MzM2YmYzNGY2NjcyNjkxODM5NjcwNjc2NTE1NGU", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-12-21T15:22:51Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-12-21T15:22:51Z"}, "message": "Merge #11086\n\n11086: internal: Simplify completion rendering r=Veykril a=Veykril\n\nRemoves all the helper render structs in favor of simple functions, making things a lot easier to oversee(imho)\r\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "0bfed126b0a2e9ce30efe11c0b74a6acc0a9ea25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0bfed126b0a2e9ce30efe11c0b74a6acc0a9ea25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22adcfde039336bf34f66726918396706765154e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhwfFLCRBK7hj4Ov3rIwAAlRgIAE35Pj2kIC7oNzb8T5KEueI2\nDYKQhP96k80TTAb0lEwuR50cOgvhm+VR33WsJ2zphjlAmpBlJy60aiVO6AsYW1tj\nS18XyuMV6zntQjmSavkXXyZ1jmW4yS2oFhrdrPA5dHfrg9f0bhwyT6ud5KGZMUCC\nyDHK7Ii2AldS4GBGuMh34tykg94kKSZiorqUuL/KmpaXLCAxA5lXTLq2FExMJaC3\nwvsrx/seIhR2UbAL7K/za0f1KipN4RC9QZf4is1Oss3DvDFPZyohyrbBxswVXX2o\nJ5DuSnhTOvHiDeOTP2dBBHUppKzlxDAwyhaLDKCNI8GH/I5L3GzTWkmM0A65zP0=\n=fZqV\n-----END PGP SIGNATURE-----\n", "payload": "tree 0bfed126b0a2e9ce30efe11c0b74a6acc0a9ea25\nparent a406574ee871359d05b649356e5e5d2505f4ca26\nparent 929cae74b160a9a3567962d9f880bd60e0dc4e34\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1640100171 +0000\ncommitter GitHub <noreply@github.com> 1640100171 +0000\n\nMerge #11086\n\n11086: internal: Simplify completion rendering r=Veykril a=Veykril\n\nRemoves all the helper render structs in favor of simple functions, making things a lot easier to oversee(imho)\r\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22adcfde039336bf34f66726918396706765154e", "html_url": "https://github.com/rust-lang/rust/commit/22adcfde039336bf34f66726918396706765154e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22adcfde039336bf34f66726918396706765154e/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a406574ee871359d05b649356e5e5d2505f4ca26", "url": "https://api.github.com/repos/rust-lang/rust/commits/a406574ee871359d05b649356e5e5d2505f4ca26", "html_url": "https://github.com/rust-lang/rust/commit/a406574ee871359d05b649356e5e5d2505f4ca26"}, {"sha": "929cae74b160a9a3567962d9f880bd60e0dc4e34", "url": "https://api.github.com/repos/rust-lang/rust/commits/929cae74b160a9a3567962d9f880bd60e0dc4e34", "html_url": "https://github.com/rust-lang/rust/commit/929cae74b160a9a3567962d9f880bd60e0dc4e34"}], "stats": {"total": 848, "additions": 383, "deletions": 465}, "files": [{"sha": "526e90bd0b4f8f0df09398adab97f008ba2909ca", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22adcfde039336bf34f66726918396706765154e/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22adcfde039336bf34f66726918396706765154e/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=22adcfde039336bf34f66726918396706765154e", "patch": "@@ -3024,7 +3024,7 @@ impl Callable {\n }\n \n /// For IDE only\n-#[derive(Debug, PartialEq, Eq, Hash)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub enum ScopeDef {\n     ModuleDef(ModuleDef),\n     MacroDef(MacroDef),"}, {"sha": "974264c319bd65cfbc6fb3ef92fedf7e1f0609a1", "filename": "crates/ide_completion/src/completions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/22adcfde039336bf34f66726918396706765154e/crates%2Fide_completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22adcfde039336bf34f66726918396706765154e/crates%2Fide_completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions.rs?ref=22adcfde039336bf34f66726918396706765154e", "patch": "@@ -84,7 +84,7 @@ impl Completions {\n         &mut self,\n         ctx: &CompletionContext,\n         local_name: hir::Name,\n-        resolution: &hir::ScopeDef,\n+        resolution: hir::ScopeDef,\n     ) {\n         if ctx.is_scope_def_hidden(resolution) {\n             cov_mark::hit!(qualified_path_doc_hidden);\n@@ -115,7 +115,7 @@ impl Completions {\n         if !ctx.is_visible(&func) {\n             return;\n         }\n-        self.add_opt(render_fn(RenderContext::new(ctx), None, local_name, func));\n+        self.add(render_fn(RenderContext::new(ctx), None, local_name, func));\n     }\n \n     pub(crate) fn add_method(\n@@ -128,7 +128,7 @@ impl Completions {\n         if !ctx.is_visible(&func) {\n             return;\n         }\n-        self.add_opt(render_method(RenderContext::new(ctx), None, receiver, local_name, func));\n+        self.add(render_method(RenderContext::new(ctx), None, receiver, local_name, func));\n     }\n \n     pub(crate) fn add_const(&mut self, ctx: &CompletionContext, konst: hir::Const) {"}, {"sha": "4082414f029f2ecc456579ec40eb80035a8808a2", "filename": "crates/ide_completion/src/completions/lifetime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/22adcfde039336bf34f66726918396706765154e/crates%2Fide_completion%2Fsrc%2Fcompletions%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22adcfde039336bf34f66726918396706765154e/crates%2Fide_completion%2Fsrc%2Fcompletions%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Flifetime.rs?ref=22adcfde039336bf34f66726918396706765154e", "patch": "@@ -35,7 +35,7 @@ pub(crate) fn complete_lifetime(acc: &mut Completions, ctx: &CompletionContext)\n     ctx.scope.process_all_names(&mut |name, res| {\n         if let ScopeDef::GenericParam(hir::GenericParam::LifetimeParam(_)) = res {\n             if param_lifetime != Some(&*name.to_smol_str()) {\n-                acc.add_resolution(ctx, name, &res);\n+                acc.add_resolution(ctx, name, res);\n             }\n         }\n     });\n@@ -51,7 +51,7 @@ pub(crate) fn complete_label(acc: &mut Completions, ctx: &CompletionContext) {\n     }\n     ctx.scope.process_all_names(&mut |name, res| {\n         if let ScopeDef::Label(_) = res {\n-            acc.add_resolution(ctx, name, &res);\n+            acc.add_resolution(ctx, name, res);\n         }\n     });\n }"}, {"sha": "a140ca4239bfdeda63cbfd89eb7ce1c4b6650600", "filename": "crates/ide_completion/src/completions/pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22adcfde039336bf34f66726918396706765154e/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22adcfde039336bf34f66726918396706765154e/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs?ref=22adcfde039336bf34f66726918396706765154e", "patch": "@@ -59,7 +59,7 @@ pub(crate) fn complete_pattern(acc: &mut Completions, ctx: &CompletionContext) {\n             _ => false,\n         };\n         if add_resolution {\n-            acc.add_resolution(ctx, name, &res);\n+            acc.add_resolution(ctx, name, res);\n         }\n     });\n }"}, {"sha": "656d46b10bec04793c56a1efca065587c82ed695", "filename": "crates/ide_completion/src/completions/qualified_path.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/22adcfde039336bf34f66726918396706765154e/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22adcfde039336bf34f66726918396706765154e/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs?ref=22adcfde039336bf34f66726918396706765154e", "patch": "@@ -44,7 +44,7 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n                         }\n                     }\n                     if let ScopeDef::ModuleDef(hir::ModuleDef::Module(_)) = def {\n-                        acc.add_resolution(ctx, name, &def);\n+                        acc.add_resolution(ctx, name, def);\n                     }\n                 }\n             }\n@@ -64,7 +64,7 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n                         .next()\n                     {\n                         if let Some(name) = next.name(ctx.db) {\n-                            acc.add_resolution(ctx, name, &ScopeDef::ModuleDef(next.into()));\n+                            acc.add_resolution(ctx, name, ScopeDef::ModuleDef(next.into()));\n                         }\n                     }\n                 }\n@@ -80,7 +80,7 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n                         _ => false,\n                     };\n                     if add_resolution {\n-                        acc.add_resolution(ctx, name, &def);\n+                        acc.add_resolution(ctx, name, def);\n                     }\n                 }\n             }\n@@ -147,7 +147,7 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n                 };\n \n                 if add_resolution {\n-                    acc.add_resolution(ctx, name, &def);\n+                    acc.add_resolution(ctx, name, def);\n                 }\n             }\n         }"}, {"sha": "e7980c12d77dc4e530d1ae7ed81214871abb5285", "filename": "crates/ide_completion/src/completions/unqualified_path.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/22adcfde039336bf34f66726918396706765154e/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22adcfde039336bf34f66726918396706765154e/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs?ref=22adcfde039336bf34f66726918396706765154e", "patch": "@@ -24,7 +24,7 @@ pub(crate) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionC\n         cov_mark::hit!(unqualified_path_only_modules_in_import);\n         ctx.process_all_names(&mut |name, res| {\n             if let ScopeDef::ModuleDef(hir::ModuleDef::Module(_)) = res {\n-                acc.add_resolution(ctx, name, &res);\n+                acc.add_resolution(ctx, name, res);\n             }\n         });\n \n@@ -43,7 +43,7 @@ pub(crate) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionC\n                     _ => false,\n                 };\n                 if add_resolution {\n-                    acc.add_resolution(ctx, name, &res);\n+                    acc.add_resolution(ctx, name, res);\n                 }\n             });\n             return;\n@@ -61,7 +61,7 @@ pub(crate) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionC\n                     }\n                 }\n                 if let hir::ScopeDef::ModuleDef(hir::ModuleDef::Module(_)) = res {\n-                    acc.add_resolution(ctx, name, &res);\n+                    acc.add_resolution(ctx, name, res);\n                 }\n             });\n             return;\n@@ -76,7 +76,7 @@ pub(crate) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionC\n                     _ => false,\n                 };\n                 if add_resolution {\n-                    acc.add_resolution(ctx, name, &res);\n+                    acc.add_resolution(ctx, name, res);\n                 }\n             });\n             return;\n@@ -134,7 +134,7 @@ pub(crate) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionC\n             _ => true,\n         };\n         if add_resolution {\n-            acc.add_resolution(ctx, name, &res);\n+            acc.add_resolution(ctx, name, res);\n         }\n     });\n }"}, {"sha": "d0ed98898986cc59065acab67e088981662dfccc", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/22adcfde039336bf34f66726918396706765154e/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22adcfde039336bf34f66726918396706765154e/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=22adcfde039336bf34f66726918396706765154e", "patch": "@@ -278,7 +278,7 @@ impl<'a> CompletionContext<'a> {\n         self.is_visible_impl(&item.visibility(self.db), &item.attrs(self.db), item.krate(self.db))\n     }\n \n-    pub(crate) fn is_scope_def_hidden(&self, scope_def: &ScopeDef) -> bool {\n+    pub(crate) fn is_scope_def_hidden(&self, scope_def: ScopeDef) -> bool {\n         if let (Some(attrs), Some(krate)) = (scope_def.attrs(self.db), scope_def.krate(self.db)) {\n             return self.is_doc_hidden(&attrs, krate);\n         }\n@@ -303,7 +303,7 @@ impl<'a> CompletionContext<'a> {\n     /// A version of [`SemanticsScope::process_all_names`] that filters out `#[doc(hidden)]` items.\n     pub(crate) fn process_all_names(&self, f: &mut dyn FnMut(Name, ScopeDef)) {\n         self.scope.process_all_names(&mut |name, def| {\n-            if self.is_scope_def_hidden(&def) {\n+            if self.is_scope_def_hidden(def) {\n                 return;\n             }\n \n@@ -367,7 +367,7 @@ impl<'a> CompletionContext<'a> {\n             parse.reparse(&edit).tree()\n         };\n         let fake_ident_token =\n-            file_with_fake_ident.syntax().token_at_offset(offset).right_biased().unwrap();\n+            file_with_fake_ident.syntax().token_at_offset(offset).right_biased()?;\n \n         let original_token = original_file.syntax().token_at_offset(offset).left_biased()?;\n         let token = sema.descend_into_macros_single(original_token.clone());"}, {"sha": "404a2fa9d33ea0ed5ecf7e90607335275d47624b", "filename": "crates/ide_completion/src/render.rs", "status": "modified", "additions": 63, "deletions": 69, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/22adcfde039336bf34f66726918396706765154e/crates%2Fide_completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22adcfde039336bf34f66726918396706765154e/crates%2Fide_completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender.rs?ref=22adcfde039336bf34f66726918396706765154e", "patch": "@@ -11,7 +11,7 @@ pub(crate) mod struct_literal;\n \n mod builder_ext;\n \n-use hir::{AsAssocItem, HasAttrs, HirDisplay};\n+use hir::{AsAssocItem, HasAttrs, HirDisplay, ScopeDef};\n use ide_db::{\n     helpers::{item_name, SnippetCap},\n     RootDatabase, SymbolKind,\n@@ -47,8 +47,8 @@ impl<'a> RenderContext<'a> {\n         self.completion.source_range()\n     }\n \n-    fn is_deprecated(&self, node: impl HasAttrs) -> bool {\n-        let attrs = node.attrs(self.db());\n+    fn is_deprecated(&self, def: impl HasAttrs) -> bool {\n+        let attrs = def.attrs(self.db());\n         attrs.by_key(\"deprecated\").exists() || attrs.by_key(\"rustc_deprecated\").exists()\n     }\n \n@@ -71,8 +71,8 @@ impl<'a> RenderContext<'a> {\n                 .unwrap_or(false)\n     }\n \n-    fn docs(&self, node: impl HasAttrs) -> Option<hir::Documentation> {\n-        node.docs(self.db())\n+    fn docs(&self, def: impl HasAttrs) -> Option<hir::Documentation> {\n+        def.docs(self.db())\n     }\n }\n \n@@ -128,7 +128,7 @@ pub(crate) fn render_tuple_field(\n pub(crate) fn render_resolution(\n     ctx: RenderContext<'_>,\n     local_name: hir::Name,\n-    resolution: &hir::ScopeDef,\n+    resolution: ScopeDef,\n ) -> Option<CompletionItem> {\n     render_resolution_(ctx, local_name, None, resolution)\n }\n@@ -137,83 +137,77 @@ pub(crate) fn render_resolution_with_import(\n     ctx: RenderContext<'_>,\n     import_edit: ImportEdit,\n ) -> Option<CompletionItem> {\n-    let resolution = hir::ScopeDef::from(import_edit.import.original_item);\n+    let resolution = ScopeDef::from(import_edit.import.original_item);\n     let local_name = match resolution {\n-        hir::ScopeDef::ModuleDef(hir::ModuleDef::Function(f)) => f.name(ctx.completion.db),\n-        hir::ScopeDef::ModuleDef(hir::ModuleDef::Const(c)) => c.name(ctx.completion.db)?,\n-        hir::ScopeDef::ModuleDef(hir::ModuleDef::TypeAlias(t)) => t.name(ctx.completion.db),\n+        ScopeDef::ModuleDef(hir::ModuleDef::Function(f)) => f.name(ctx.completion.db),\n+        ScopeDef::ModuleDef(hir::ModuleDef::Const(c)) => c.name(ctx.completion.db)?,\n+        ScopeDef::ModuleDef(hir::ModuleDef::TypeAlias(t)) => t.name(ctx.completion.db),\n         _ => item_name(ctx.db(), import_edit.import.original_item)?,\n     };\n-    render_resolution_(ctx, local_name, Some(import_edit), &resolution)\n+    render_resolution_(ctx, local_name, Some(import_edit), resolution)\n }\n \n fn render_resolution_(\n     ctx: RenderContext<'_>,\n     local_name: hir::Name,\n     import_to_add: Option<ImportEdit>,\n-    resolution: &hir::ScopeDef,\n+    resolution: ScopeDef,\n ) -> Option<CompletionItem> {\n     let _p = profile::span(\"render_resolution\");\n     use hir::ModuleDef::*;\n \n+    let db = ctx.db();\n+\n     let kind = match resolution {\n-        hir::ScopeDef::ModuleDef(Function(func)) => {\n-            return render_fn(ctx, import_to_add, Some(local_name), *func);\n-        }\n-        hir::ScopeDef::ModuleDef(Variant(_)) if ctx.completion.pattern_ctx.is_some() => {\n-            CompletionItemKind::SymbolKind(SymbolKind::Variant)\n+        ScopeDef::ModuleDef(Function(func)) => {\n+            return Some(render_fn(ctx, import_to_add, Some(local_name), func));\n         }\n-        hir::ScopeDef::ModuleDef(Variant(var)) => {\n-            let item = render_variant(ctx, import_to_add, Some(local_name), *var, None);\n-            return Some(item);\n+        ScopeDef::ModuleDef(Variant(var)) if ctx.completion.pattern_ctx.is_none() => {\n+            return Some(render_variant(ctx, import_to_add, Some(local_name), var, None));\n         }\n-        hir::ScopeDef::MacroDef(mac) => {\n-            let item = render_macro(ctx, import_to_add, local_name, *mac);\n-            return item;\n+        ScopeDef::MacroDef(mac) => return render_macro(ctx, import_to_add, local_name, mac),\n+        ScopeDef::Unknown => {\n+            let mut item = CompletionItem::new(\n+                CompletionItemKind::UnresolvedReference,\n+                ctx.source_range(),\n+                local_name.to_smol_str(),\n+            );\n+            if let Some(import_to_add) = import_to_add {\n+                item.add_import(import_to_add);\n+            }\n+            return Some(item.build());\n         }\n \n-        hir::ScopeDef::ModuleDef(Module(..)) => CompletionItemKind::SymbolKind(SymbolKind::Module),\n-        hir::ScopeDef::ModuleDef(Adt(adt)) => CompletionItemKind::SymbolKind(match adt {\n+        ScopeDef::ModuleDef(Variant(_)) => CompletionItemKind::SymbolKind(SymbolKind::Variant),\n+        ScopeDef::ModuleDef(Module(..)) => CompletionItemKind::SymbolKind(SymbolKind::Module),\n+        ScopeDef::ModuleDef(Adt(adt)) => CompletionItemKind::SymbolKind(match adt {\n             hir::Adt::Struct(_) => SymbolKind::Struct,\n             hir::Adt::Union(_) => SymbolKind::Union,\n             hir::Adt::Enum(_) => SymbolKind::Enum,\n         }),\n-        hir::ScopeDef::ModuleDef(Const(..)) => CompletionItemKind::SymbolKind(SymbolKind::Const),\n-        hir::ScopeDef::ModuleDef(Static(..)) => CompletionItemKind::SymbolKind(SymbolKind::Static),\n-        hir::ScopeDef::ModuleDef(Trait(..)) => CompletionItemKind::SymbolKind(SymbolKind::Trait),\n-        hir::ScopeDef::ModuleDef(TypeAlias(..)) => {\n-            CompletionItemKind::SymbolKind(SymbolKind::TypeAlias)\n-        }\n-        hir::ScopeDef::ModuleDef(BuiltinType(..)) => CompletionItemKind::BuiltinType,\n-        hir::ScopeDef::GenericParam(param) => CompletionItemKind::SymbolKind(match param {\n+        ScopeDef::ModuleDef(Const(..)) => CompletionItemKind::SymbolKind(SymbolKind::Const),\n+        ScopeDef::ModuleDef(Static(..)) => CompletionItemKind::SymbolKind(SymbolKind::Static),\n+        ScopeDef::ModuleDef(Trait(..)) => CompletionItemKind::SymbolKind(SymbolKind::Trait),\n+        ScopeDef::ModuleDef(TypeAlias(..)) => CompletionItemKind::SymbolKind(SymbolKind::TypeAlias),\n+        ScopeDef::ModuleDef(BuiltinType(..)) => CompletionItemKind::BuiltinType,\n+        ScopeDef::GenericParam(param) => CompletionItemKind::SymbolKind(match param {\n             hir::GenericParam::TypeParam(_) => SymbolKind::TypeParam,\n             hir::GenericParam::LifetimeParam(_) => SymbolKind::LifetimeParam,\n             hir::GenericParam::ConstParam(_) => SymbolKind::ConstParam,\n         }),\n-        hir::ScopeDef::Local(..) => CompletionItemKind::SymbolKind(SymbolKind::Local),\n-        hir::ScopeDef::Label(..) => CompletionItemKind::SymbolKind(SymbolKind::Label),\n-        hir::ScopeDef::AdtSelfType(..) | hir::ScopeDef::ImplSelfType(..) => {\n+        ScopeDef::Local(..) => CompletionItemKind::SymbolKind(SymbolKind::Local),\n+        ScopeDef::Label(..) => CompletionItemKind::SymbolKind(SymbolKind::Label),\n+        ScopeDef::AdtSelfType(..) | ScopeDef::ImplSelfType(..) => {\n             CompletionItemKind::SymbolKind(SymbolKind::SelfParam)\n         }\n-        hir::ScopeDef::Unknown => {\n-            let mut item = CompletionItem::new(\n-                CompletionItemKind::UnresolvedReference,\n-                ctx.source_range(),\n-                local_name.to_smol_str(),\n-            );\n-            if let Some(import_to_add) = import_to_add {\n-                item.add_import(import_to_add);\n-            }\n-            return Some(item.build());\n-        }\n     };\n \n     let local_name = local_name.to_smol_str();\n     let mut item = CompletionItem::new(kind, ctx.source_range(), local_name.clone());\n-    if let hir::ScopeDef::Local(local) = resolution {\n-        let ty = local.ty(ctx.db());\n+    if let ScopeDef::Local(local) = resolution {\n+        let ty = local.ty(db);\n         if !ty.is_unknown() {\n-            item.detail(ty.display(ctx.db()).to_string());\n+            item.detail(ty.display(db).to_string());\n         }\n \n         item.set_relevance(CompletionRelevance {\n@@ -229,15 +223,15 @@ fn render_resolution_(\n     };\n \n     // Add `<>` for generic types\n-    if matches!(\n+    let type_path_no_ty_args = matches!(\n         ctx.completion.path_context,\n         Some(PathCompletionContext { kind: Some(PathKind::Type), has_type_args: false, .. })\n-    ) && ctx.completion.config.add_call_parenthesis\n-    {\n+    ) && ctx.completion.config.add_call_parenthesis;\n+    if type_path_no_ty_args {\n         if let Some(cap) = ctx.snippet_cap() {\n             let has_non_default_type_params = match resolution {\n-                hir::ScopeDef::ModuleDef(Adt(it)) => it.has_non_default_type_params(ctx.db()),\n-                hir::ScopeDef::ModuleDef(TypeAlias(it)) => it.has_non_default_type_params(ctx.db()),\n+                ScopeDef::ModuleDef(Adt(it)) => it.has_non_default_type_params(db),\n+                ScopeDef::ModuleDef(TypeAlias(it)) => it.has_non_default_type_params(db),\n                 _ => false,\n             };\n             if has_non_default_type_params {\n@@ -248,7 +242,7 @@ fn render_resolution_(\n             }\n         }\n     }\n-    item.set_documentation(scope_def_docs(ctx.db(), resolution))\n+    item.set_documentation(scope_def_docs(db, resolution))\n         .set_deprecated(scope_def_is_deprecated(&ctx, resolution));\n \n     if let Some(import_to_add) = import_to_add {\n@@ -257,26 +251,26 @@ fn render_resolution_(\n     Some(item.build())\n }\n \n-fn scope_def_docs(db: &RootDatabase, resolution: &hir::ScopeDef) -> Option<hir::Documentation> {\n+fn scope_def_docs(db: &RootDatabase, resolution: ScopeDef) -> Option<hir::Documentation> {\n     use hir::ModuleDef::*;\n     match resolution {\n-        hir::ScopeDef::ModuleDef(Module(it)) => it.docs(db),\n-        hir::ScopeDef::ModuleDef(Adt(it)) => it.docs(db),\n-        hir::ScopeDef::ModuleDef(Variant(it)) => it.docs(db),\n-        hir::ScopeDef::ModuleDef(Const(it)) => it.docs(db),\n-        hir::ScopeDef::ModuleDef(Static(it)) => it.docs(db),\n-        hir::ScopeDef::ModuleDef(Trait(it)) => it.docs(db),\n-        hir::ScopeDef::ModuleDef(TypeAlias(it)) => it.docs(db),\n+        ScopeDef::ModuleDef(Module(it)) => it.docs(db),\n+        ScopeDef::ModuleDef(Adt(it)) => it.docs(db),\n+        ScopeDef::ModuleDef(Variant(it)) => it.docs(db),\n+        ScopeDef::ModuleDef(Const(it)) => it.docs(db),\n+        ScopeDef::ModuleDef(Static(it)) => it.docs(db),\n+        ScopeDef::ModuleDef(Trait(it)) => it.docs(db),\n+        ScopeDef::ModuleDef(TypeAlias(it)) => it.docs(db),\n         _ => None,\n     }\n }\n \n-fn scope_def_is_deprecated(ctx: &RenderContext<'_>, resolution: &hir::ScopeDef) -> bool {\n+fn scope_def_is_deprecated(ctx: &RenderContext<'_>, resolution: ScopeDef) -> bool {\n     match resolution {\n-        hir::ScopeDef::ModuleDef(it) => ctx.is_deprecated_assoc_item(*it),\n-        hir::ScopeDef::MacroDef(it) => ctx.is_deprecated(*it),\n-        hir::ScopeDef::GenericParam(it) => ctx.is_deprecated(*it),\n-        hir::ScopeDef::AdtSelfType(it) => ctx.is_deprecated(*it),\n+        ScopeDef::ModuleDef(it) => ctx.is_deprecated_assoc_item(it),\n+        ScopeDef::MacroDef(it) => ctx.is_deprecated(it),\n+        ScopeDef::GenericParam(it) => ctx.is_deprecated(it),\n+        ScopeDef::AdtSelfType(it) => ctx.is_deprecated(it),\n         _ => false,\n     }\n }"}, {"sha": "65c9d1d63edeb35fcb060326443e3da10a79a710", "filename": "crates/ide_completion/src/render/const_.rs", "status": "modified", "additions": 18, "deletions": 39, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/22adcfde039336bf34f66726918396706765154e/crates%2Fide_completion%2Fsrc%2Frender%2Fconst_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22adcfde039336bf34f66726918396706765154e/crates%2Fide_completion%2Fsrc%2Frender%2Fconst_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Fconst_.rs?ref=22adcfde039336bf34f66726918396706765154e", "patch": "@@ -2,53 +2,32 @@\n \n use hir::{AsAssocItem, HasSource};\n use ide_db::SymbolKind;\n-use syntax::{ast::Const, display::const_label};\n+use syntax::display::const_label;\n \n use crate::{item::CompletionItem, render::RenderContext};\n \n pub(crate) fn render_const(ctx: RenderContext<'_>, const_: hir::Const) -> Option<CompletionItem> {\n     let _p = profile::span(\"render_const\");\n-    ConstRender::new(ctx, const_)?.render()\n+    render(ctx, const_)\n }\n \n-#[derive(Debug)]\n-struct ConstRender<'a> {\n-    ctx: RenderContext<'a>,\n-    const_: hir::Const,\n-    ast_node: Const,\n-}\n-\n-impl<'a> ConstRender<'a> {\n-    fn new(ctx: RenderContext<'a>, const_: hir::Const) -> Option<ConstRender<'a>> {\n-        let ast_node = const_.source(ctx.db())?.value;\n-        Some(ConstRender { ctx, const_, ast_node })\n-    }\n-\n-    fn render(self) -> Option<CompletionItem> {\n-        let name = self.const_.name(self.ctx.db())?.to_smol_str();\n-        let detail = self.detail();\n-\n-        let mut item =\n-            CompletionItem::new(SymbolKind::Const, self.ctx.source_range(), name.clone());\n-        item.set_documentation(self.ctx.docs(self.const_))\n-            .set_deprecated(\n-                self.ctx.is_deprecated(self.const_)\n-                    || self.ctx.is_deprecated_assoc_item(self.const_),\n-            )\n-            .detail(detail);\n-\n-        let db = self.ctx.db();\n-        if let Some(actm) = self.const_.as_assoc_item(db) {\n-            if let Some(trt) = actm.containing_trait_or_trait_impl(db) {\n-                item.trait_name(trt.name(db).to_smol_str());\n-                item.insert_text(name);\n-            }\n+fn render(ctx: RenderContext<'_>, const_: hir::Const) -> Option<CompletionItem> {\n+    let db = ctx.db();\n+    let name = const_.name(db)?.to_smol_str();\n+    // FIXME: This is parsing files!\n+    let detail = const_label(&const_.source(db)?.value);\n+\n+    let mut item = CompletionItem::new(SymbolKind::Const, ctx.source_range(), name.clone());\n+    item.set_documentation(ctx.docs(const_))\n+        .set_deprecated(ctx.is_deprecated(const_) || ctx.is_deprecated_assoc_item(const_))\n+        .detail(detail);\n+\n+    if let Some(actm) = const_.as_assoc_item(db) {\n+        if let Some(trt) = actm.containing_trait_or_trait_impl(db) {\n+            item.trait_name(trt.name(db).to_smol_str());\n+            item.insert_text(name);\n         }\n-\n-        Some(item.build())\n     }\n \n-    fn detail(&self) -> String {\n-        const_label(&self.ast_node)\n-    }\n+    Some(item.build())\n }"}, {"sha": "f613f0dfde2d2e42ac44755e260170dbd48f0da1", "filename": "crates/ide_completion/src/render/enum_variant.rs", "status": "modified", "additions": 71, "deletions": 101, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/22adcfde039336bf34f66726918396706765154e/crates%2Fide_completion%2Fsrc%2Frender%2Fenum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22adcfde039336bf34f66726918396706765154e/crates%2Fide_completion%2Fsrc%2Frender%2Fenum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Fenum_variant.rs?ref=22adcfde039336bf34f66726918396706765154e", "patch": "@@ -1,10 +1,10 @@\n //! Renderer for `enum` variants.\n \n-use std::{iter, mem};\n+use std::iter;\n \n-use hir::{HasAttrs, HirDisplay};\n+use hir::{db::HirDatabase, HasAttrs, HirDisplay, StructKind};\n use ide_db::SymbolKind;\n-use stdx::format_to;\n+use itertools::Itertools;\n \n use crate::{\n     item::{CompletionItem, ImportEdit},\n@@ -20,116 +20,86 @@ pub(crate) fn render_variant(\n     path: Option<hir::ModPath>,\n ) -> CompletionItem {\n     let _p = profile::span(\"render_enum_variant\");\n-    EnumRender::new(ctx, local_name, variant, path).render(import_to_add)\n+    render(ctx, local_name, variant, path, import_to_add)\n }\n \n-#[derive(Debug)]\n-struct EnumRender<'a> {\n-    ctx: RenderContext<'a>,\n+fn render(\n+    ctx @ RenderContext { completion }: RenderContext<'_>,\n+    local_name: Option<hir::Name>,\n     variant: hir::Variant,\n     path: Option<hir::ModPath>,\n-    qualified_name: hir::ModPath,\n-    short_qualified_name: hir::ModPath,\n-    variant_kind: hir::StructKind,\n-}\n-\n-impl<'a> EnumRender<'a> {\n-    fn new(\n-        ctx: RenderContext<'a>,\n-        local_name: Option<hir::Name>,\n-        variant: hir::Variant,\n-        path: Option<hir::ModPath>,\n-    ) -> EnumRender<'a> {\n-        let name = local_name.unwrap_or_else(|| variant.name(ctx.db()));\n-        let variant_kind = variant.kind(ctx.db());\n-\n-        let (qualified_name, short_qualified_name) = match &path {\n-            Some(path) => {\n-                let short = hir::ModPath::from_segments(\n-                    hir::PathKind::Plain,\n-                    path.segments().iter().skip(path.segments().len().saturating_sub(2)).cloned(),\n-                );\n-                (path.clone(), short)\n-            }\n-            None => (\n-                hir::ModPath::from_segments(hir::PathKind::Plain, iter::once(name.clone())),\n-                hir::ModPath::from_segments(hir::PathKind::Plain, iter::once(name)),\n-            ),\n-        };\n-\n-        EnumRender { ctx, variant, path, qualified_name, short_qualified_name, variant_kind }\n-    }\n-    fn render(self, import_to_add: Option<ImportEdit>) -> CompletionItem {\n-        let mut item = CompletionItem::new(\n-            SymbolKind::Variant,\n-            self.ctx.source_range(),\n-            self.qualified_name.to_string(),\n-        );\n-        item.set_documentation(self.variant.docs(self.ctx.db()))\n-            .set_deprecated(self.ctx.is_deprecated(self.variant))\n-            .detail(self.detail());\n-\n-        if let Some(import_to_add) = import_to_add {\n-            item.add_import(import_to_add);\n-        }\n-\n-        if self.variant_kind == hir::StructKind::Tuple {\n-            cov_mark::hit!(inserts_parens_for_tuple_enums);\n-            let params = Params::Anonymous(self.variant.fields(self.ctx.db()).len());\n-            item.add_call_parens(\n-                self.ctx.completion,\n-                self.short_qualified_name.to_string(),\n-                params,\n+    import_to_add: Option<ImportEdit>,\n+) -> CompletionItem {\n+    let db = completion.db;\n+    let name = local_name.unwrap_or_else(|| variant.name(db));\n+    let variant_kind = variant.kind(db);\n+\n+    let (qualified_name, short_qualified_name, qualified) = match path {\n+        Some(path) => {\n+            let short = hir::ModPath::from_segments(\n+                hir::PathKind::Plain,\n+                path.segments().iter().skip(path.segments().len().saturating_sub(2)).cloned(),\n             );\n-        } else if self.path.is_some() {\n-            item.lookup_by(self.short_qualified_name.to_string());\n+            (path, short, true)\n         }\n+        None => (\n+            hir::ModPath::from_segments(hir::PathKind::Plain, iter::once(name.clone())),\n+            hir::ModPath::from_segments(hir::PathKind::Plain, iter::once(name)),\n+            false,\n+        ),\n+    };\n+\n+    // FIXME: ModPath::to_smol_str()?\n+    let mut item =\n+        CompletionItem::new(SymbolKind::Variant, ctx.source_range(), qualified_name.to_string());\n+    item.set_documentation(variant.docs(db))\n+        .set_deprecated(ctx.is_deprecated(variant))\n+        .detail(detail(db, variant, variant_kind));\n+\n+    if let Some(import_to_add) = import_to_add {\n+        item.add_import(import_to_add);\n+    }\n \n-        let ty = self.variant.parent_enum(self.ctx.completion.db).ty(self.ctx.completion.db);\n-        item.set_relevance(CompletionRelevance {\n-            type_match: compute_type_match(self.ctx.completion, &ty),\n-            ..CompletionRelevance::default()\n-        });\n+    // FIXME: ModPath::to_smol_str()?\n+    let short_qualified_name = short_qualified_name.to_string();\n+    if variant_kind == hir::StructKind::Tuple {\n+        cov_mark::hit!(inserts_parens_for_tuple_enums);\n+        let params = Params::Anonymous(variant.fields(db).len());\n+        item.add_call_parens(ctx.completion, short_qualified_name, params);\n+    } else if qualified {\n+        item.lookup_by(short_qualified_name);\n+    }\n \n-        if let Some(ref_match) = compute_ref_match(self.ctx.completion, &ty) {\n-            item.ref_match(ref_match);\n-        }\n+    let ty = variant.parent_enum(ctx.completion.db).ty(ctx.completion.db);\n+    item.set_relevance(CompletionRelevance {\n+        type_match: compute_type_match(ctx.completion, &ty),\n+        ..CompletionRelevance::default()\n+    });\n \n-        item.build()\n+    if let Some(ref_match) = compute_ref_match(ctx.completion, &ty) {\n+        item.ref_match(ref_match);\n     }\n \n-    fn detail(&self) -> String {\n-        let detail_types = self\n-            .variant\n-            .fields(self.ctx.db())\n-            .into_iter()\n-            .map(|field| (field.name(self.ctx.db()), field.ty(self.ctx.db())));\n-\n-        let mut b = String::new();\n-        let mut first_run = true;\n-        match self.variant_kind {\n-            hir::StructKind::Tuple | hir::StructKind::Unit => {\n-                format_to!(b, \"(\");\n-                for (_, t) in detail_types {\n-                    if !mem::take(&mut first_run) {\n-                        format_to!(b, \", \");\n-                    }\n-                    format_to!(b, \"{}\", t.display(self.ctx.db()));\n-                }\n-                format_to!(b, \")\");\n-            }\n-            hir::StructKind::Record => {\n-                format_to!(b, \"{{\");\n-                for (n, t) in detail_types {\n-                    if !mem::take(&mut first_run) {\n-                        format_to!(b, \", \");\n-                    }\n-                    format_to!(b, \"{}: {}\", n, t.display(self.ctx.db()));\n-                }\n-                format_to!(b, \"}}\");\n-            }\n+    item.build()\n+}\n+\n+fn detail(db: &dyn HirDatabase, variant: hir::Variant, variant_kind: StructKind) -> String {\n+    let detail_types = variant.fields(db).into_iter().map(|field| (field.name(db), field.ty(db)));\n+\n+    match variant_kind {\n+        hir::StructKind::Tuple | hir::StructKind::Unit => {\n+            format!(\"({})\", detail_types.format_with(\", \", |(_, t), f| f(&t.display(db))))\n+        }\n+        hir::StructKind::Record => {\n+            format!(\n+                \"{{{}}}\",\n+                detail_types.format_with(\", \", |(n, t), f| {\n+                    f(&n)?;\n+                    f(&\": \")?;\n+                    f(&t.display(db))\n+                }),\n+            )\n         }\n-        b\n     }\n }\n "}, {"sha": "f166b87ab631c1b0a50732258910d8ad52083608", "filename": "crates/ide_completion/src/render/function.rs", "status": "modified", "additions": 105, "deletions": 114, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/22adcfde039336bf34f66726918396706765154e/crates%2Fide_completion%2Fsrc%2Frender%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22adcfde039336bf34f66726918396706765154e/crates%2Fide_completion%2Fsrc%2Frender%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Ffunction.rs?ref=22adcfde039336bf34f66726918396706765154e", "patch": "@@ -1,162 +1,153 @@\n //! Renderer for function calls.\n \n-use hir::{AsAssocItem, HirDisplay};\n+use hir::{db::HirDatabase, AsAssocItem, HirDisplay};\n use ide_db::SymbolKind;\n use itertools::Itertools;\n use stdx::format_to;\n \n use crate::{\n+    context::CompletionContext,\n     item::{CompletionItem, CompletionItemKind, CompletionRelevance, ImportEdit},\n     render::{\n         builder_ext::Params, compute_exact_name_match, compute_ref_match, compute_type_match,\n         RenderContext,\n     },\n };\n \n+enum FuncType {\n+    Function,\n+    Method(Option<hir::Name>),\n+}\n+\n pub(crate) fn render_fn(\n     ctx: RenderContext<'_>,\n     import_to_add: Option<ImportEdit>,\n     local_name: Option<hir::Name>,\n-    fn_: hir::Function,\n-) -> Option<CompletionItem> {\n+    func: hir::Function,\n+) -> CompletionItem {\n     let _p = profile::span(\"render_fn\");\n-    Some(FunctionRender::new(ctx, None, local_name, fn_, false)?.render(import_to_add))\n+    render(ctx, local_name, func, FuncType::Function, import_to_add)\n }\n \n pub(crate) fn render_method(\n     ctx: RenderContext<'_>,\n     import_to_add: Option<ImportEdit>,\n     receiver: Option<hir::Name>,\n     local_name: Option<hir::Name>,\n-    fn_: hir::Function,\n-) -> Option<CompletionItem> {\n+    func: hir::Function,\n+) -> CompletionItem {\n     let _p = profile::span(\"render_method\");\n-    Some(FunctionRender::new(ctx, receiver, local_name, fn_, true)?.render(import_to_add))\n+    render(ctx, local_name, func, FuncType::Method(receiver), import_to_add)\n }\n \n-#[derive(Debug)]\n-struct FunctionRender<'a> {\n-    ctx: RenderContext<'a>,\n-    name: hir::Name,\n-    receiver: Option<hir::Name>,\n+fn render(\n+    ctx @ RenderContext { completion }: RenderContext<'_>,\n+    local_name: Option<hir::Name>,\n     func: hir::Function,\n-    is_method: bool,\n-}\n-\n-impl<'a> FunctionRender<'a> {\n-    fn new(\n-        ctx: RenderContext<'a>,\n-        receiver: Option<hir::Name>,\n-        local_name: Option<hir::Name>,\n-        fn_: hir::Function,\n-        is_method: bool,\n-    ) -> Option<FunctionRender<'a>> {\n-        let name = local_name.unwrap_or_else(|| fn_.name(ctx.db()));\n-\n-        Some(FunctionRender { ctx, name, receiver, func: fn_, is_method })\n-    }\n+    func_type: FuncType,\n+    import_to_add: Option<ImportEdit>,\n+) -> CompletionItem {\n+    let db = completion.db;\n \n-    fn render(self, import_to_add: Option<ImportEdit>) -> CompletionItem {\n-        let params = self.params();\n-        let call = match &self.receiver {\n-            Some(receiver) => format!(\"{}.{}\", receiver, &self.name),\n-            None => self.name.to_string(),\n-        };\n-        let mut item = CompletionItem::new(self.kind(), self.ctx.source_range(), call.clone());\n-        item.set_documentation(self.ctx.docs(self.func))\n-            .set_deprecated(\n-                self.ctx.is_deprecated(self.func) || self.ctx.is_deprecated_assoc_item(self.func),\n-            )\n-            .detail(self.detail())\n-            .add_call_parens(self.ctx.completion, call.clone(), params);\n-\n-        if import_to_add.is_none() {\n-            let db = self.ctx.db();\n-            if let Some(actm) = self.func.as_assoc_item(db) {\n-                if let Some(trt) = actm.containing_trait_or_trait_impl(db) {\n-                    item.trait_name(trt.name(db).to_smol_str());\n-                }\n-            }\n-        }\n+    let name = local_name.unwrap_or_else(|| func.name(db));\n+    let params = params(completion, func, &func_type);\n \n-        if let Some(import_to_add) = import_to_add {\n-            item.add_import(import_to_add);\n-        }\n-        item.lookup_by(self.name.to_smol_str());\n-\n-        let ret_type = self.func.ret_type(self.ctx.db());\n-        item.set_relevance(CompletionRelevance {\n-            type_match: compute_type_match(self.ctx.completion, &ret_type),\n-            exact_name_match: compute_exact_name_match(self.ctx.completion, &call),\n-            ..CompletionRelevance::default()\n-        });\n-\n-        if let Some(ref_match) = compute_ref_match(self.ctx.completion, &ret_type) {\n-            // FIXME\n-            // For now we don't properly calculate the edits for ref match\n-            // completions on methods, so we've disabled them. See #8058.\n-            if !self.is_method {\n-                item.ref_match(ref_match);\n+    // FIXME: SmolStr?\n+    let call = match &func_type {\n+        FuncType::Method(Some(receiver)) => format!(\"{}.{}\", receiver, &name),\n+        _ => name.to_string(),\n+    };\n+    let mut item = CompletionItem::new(\n+        if func.self_param(db).is_some() {\n+            CompletionItemKind::Method\n+        } else {\n+            CompletionItemKind::SymbolKind(SymbolKind::Function)\n+        },\n+        ctx.source_range(),\n+        call.clone(),\n+    );\n+    item.set_documentation(ctx.docs(func))\n+        .set_deprecated(ctx.is_deprecated(func) || ctx.is_deprecated_assoc_item(func))\n+        .detail(detail(db, func))\n+        .add_call_parens(completion, call.clone(), params);\n+\n+    if import_to_add.is_none() {\n+        if let Some(actm) = func.as_assoc_item(db) {\n+            if let Some(trt) = actm.containing_trait_or_trait_impl(db) {\n+                item.trait_name(trt.name(db).to_smol_str());\n             }\n         }\n-\n-        item.build()\n     }\n \n-    fn detail(&self) -> String {\n-        let ret_ty = self.func.ret_type(self.ctx.db());\n-        let mut detail = format!(\"fn({})\", self.params_display());\n-        if !ret_ty.is_unit() {\n-            format_to!(detail, \" -> {}\", ret_ty.display(self.ctx.db()));\n+    if let Some(import_to_add) = import_to_add {\n+        item.add_import(import_to_add);\n+    }\n+    item.lookup_by(name.to_smol_str());\n+\n+    let ret_type = func.ret_type(db);\n+    item.set_relevance(CompletionRelevance {\n+        type_match: compute_type_match(completion, &ret_type),\n+        exact_name_match: compute_exact_name_match(completion, &call),\n+        ..CompletionRelevance::default()\n+    });\n+\n+    if let Some(ref_match) = compute_ref_match(completion, &ret_type) {\n+        // FIXME\n+        // For now we don't properly calculate the edits for ref match\n+        // completions on methods, so we've disabled them. See #8058.\n+        if matches!(func_type, FuncType::Function) {\n+            item.ref_match(ref_match);\n         }\n-        detail\n     }\n \n-    fn params_display(&self) -> String {\n-        if let Some(self_param) = self.func.self_param(self.ctx.db()) {\n-            let params = self\n-                .func\n-                .assoc_fn_params(self.ctx.db())\n-                .into_iter()\n-                .skip(1) // skip the self param because we are manually handling that\n-                .map(|p| p.ty().display(self.ctx.db()).to_string());\n+    item.build()\n+}\n \n-            std::iter::once(self_param.display(self.ctx.db()).to_owned()).chain(params).join(\", \")\n-        } else {\n-            let params = self\n-                .func\n-                .assoc_fn_params(self.ctx.db())\n-                .into_iter()\n-                .map(|p| p.ty().display(self.ctx.db()).to_string())\n-                .join(\", \");\n-            params\n-        }\n+fn detail(db: &dyn HirDatabase, func: hir::Function) -> String {\n+    let ret_ty = func.ret_type(db);\n+    let mut detail = format!(\"fn({})\", params_display(db, func));\n+    if !ret_ty.is_unit() {\n+        format_to!(detail, \" -> {}\", ret_ty.display(db));\n     }\n+    detail\n+}\n \n-    fn params(&self) -> Params {\n-        let (params, self_param) =\n-            if self.ctx.completion.has_dot_receiver() || self.receiver.is_some() {\n-                (self.func.method_params(self.ctx.db()).unwrap_or_default(), None)\n-            } else {\n-                let self_param = self.func.self_param(self.ctx.db());\n-\n-                let mut assoc_params = self.func.assoc_fn_params(self.ctx.db());\n-                if self_param.is_some() {\n-                    assoc_params.remove(0);\n-                }\n-                (assoc_params, self_param)\n-            };\n-\n-        Params::Named(self_param, params)\n+fn params_display(db: &dyn HirDatabase, func: hir::Function) -> String {\n+    if let Some(self_param) = func.self_param(db) {\n+        let assoc_fn_params = func.assoc_fn_params(db);\n+        let params = assoc_fn_params\n+            .iter()\n+            .skip(1) // skip the self param because we are manually handling that\n+            .map(|p| p.ty().display(db));\n+        format!(\n+            \"{}{}\",\n+            self_param.display(db),\n+            params.format_with(\"\", |display, f| {\n+                f(&\", \")?;\n+                f(&display)\n+            })\n+        )\n+    } else {\n+        let assoc_fn_params = func.assoc_fn_params(db);\n+        assoc_fn_params.iter().map(|p| p.ty().display(db)).join(\", \")\n     }\n+}\n \n-    fn kind(&self) -> CompletionItemKind {\n-        if self.func.self_param(self.ctx.db()).is_some() {\n-            CompletionItemKind::Method\n+fn params(ctx: &CompletionContext<'_>, func: hir::Function, func_type: &FuncType) -> Params {\n+    let (params, self_param) =\n+        if ctx.has_dot_receiver() || matches!(func_type, FuncType::Method(Some(_))) {\n+            (func.method_params(ctx.db).unwrap_or_default(), None)\n         } else {\n-            SymbolKind::Function.into()\n-        }\n-    }\n+            let self_param = func.self_param(ctx.db);\n+\n+            let mut assoc_params = func.assoc_fn_params(ctx.db);\n+            if self_param.is_some() {\n+                assoc_params.remove(0);\n+            }\n+            (assoc_params, self_param)\n+        };\n+\n+    Params::Named(self_param, params)\n }\n \n #[cfg(test)]"}, {"sha": "9c7b9a6db3ce3f0ba073452d778cabc69c083d2a", "filename": "crates/ide_completion/src/render/macro_.rs", "status": "modified", "additions": 76, "deletions": 74, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/22adcfde039336bf34f66726918396706765154e/crates%2Fide_completion%2Fsrc%2Frender%2Fmacro_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22adcfde039336bf34f66726918396706765154e/crates%2Fide_completion%2Fsrc%2Frender%2Fmacro_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Fmacro_.rs?ref=22adcfde039336bf34f66726918396706765154e", "patch": "@@ -1,7 +1,7 @@\n //! Renderer for macro invocations.\n \n use either::Either;\n-use hir::HasSource;\n+use hir::{db::HirDatabase, Documentation, HasSource};\n use ide_db::SymbolKind;\n use syntax::{\n     display::{fn_as_proc_macro_label, macro_label},\n@@ -21,94 +21,96 @@ pub(crate) fn render_macro(\n     macro_: hir::MacroDef,\n ) -> Option<CompletionItem> {\n     let _p = profile::span(\"render_macro\");\n-    MacroRender::new(ctx, name, macro_).render(import_to_add)\n+    render(ctx, name, macro_, import_to_add)\n }\n \n-#[derive(Debug)]\n-struct MacroRender<'a> {\n-    ctx: RenderContext<'a>,\n-    name: SmolStr,\n+fn render(\n+    ctx @ RenderContext { completion }: RenderContext<'_>,\n+    name: hir::Name,\n     macro_: hir::MacroDef,\n-    docs: Option<hir::Documentation>,\n-    bra: &'static str,\n-    ket: &'static str,\n-}\n+    import_to_add: Option<ImportEdit>,\n+) -> Option<CompletionItem> {\n+    let db = completion.db;\n \n-impl<'a> MacroRender<'a> {\n-    fn new(ctx: RenderContext<'a>, name: hir::Name, macro_: hir::MacroDef) -> MacroRender<'a> {\n-        let name = name.to_smol_str();\n-        let docs = ctx.docs(macro_);\n-        let docs_str = docs.as_ref().map_or(\"\", |s| s.as_str());\n-        let (bra, ket) =\n-            if macro_.is_fn_like() { guess_macro_braces(&name, docs_str) } else { (\"\", \"\") };\n+    let source_range = if completion.is_immediately_after_macro_bang() {\n+        cov_mark::hit!(completes_macro_call_if_cursor_at_bang_token);\n+        completion.token.parent().map(|it| it.text_range())\n+    } else {\n+        Some(ctx.source_range())\n+    }?;\n \n-        MacroRender { ctx, name, macro_, docs, bra, ket }\n-    }\n+    let name = name.to_smol_str();\n+    let docs = ctx.docs(macro_);\n+    let docs_str = docs.as_ref().map(Documentation::as_str).unwrap_or_default();\n+    let (bra, ket) =\n+        if macro_.is_fn_like() { guess_macro_braces(&name, docs_str) } else { (\"\", \"\") };\n \n-    fn render(self, import_to_add: Option<ImportEdit>) -> Option<CompletionItem> {\n-        let source_range = if self.ctx.completion.is_immediately_after_macro_bang() {\n-            cov_mark::hit!(completes_macro_call_if_cursor_at_bang_token);\n-            self.ctx.completion.token.parent().map(|it| it.text_range())\n-        } else {\n-            Some(self.ctx.source_range())\n-        }?;\n-        let mut item =\n-            CompletionItem::new(SymbolKind::from(self.macro_.kind()), source_range, self.label());\n-        item.set_deprecated(self.ctx.is_deprecated(self.macro_)).set_detail(self.detail());\n+    let needs_bang = macro_.is_fn_like()\n+        && !matches!(completion.path_kind(), Some(PathKind::Mac | PathKind::Use));\n \n-        if let Some(import_to_add) = import_to_add {\n-            item.add_import(import_to_add);\n-        }\n+    let mut item = CompletionItem::new(\n+        SymbolKind::from(macro_.kind()),\n+        source_range,\n+        label(&ctx, needs_bang, bra, ket, &name),\n+    );\n+    item.set_deprecated(ctx.is_deprecated(macro_))\n+        .set_detail(detail(db, macro_))\n+        .set_documentation(docs);\n \n-        let needs_bang = self.macro_.is_fn_like()\n-            && !matches!(self.ctx.completion.path_kind(), Some(PathKind::Mac | PathKind::Use));\n-        let has_parens = self.ctx.completion.path_is_call();\n+    if let Some(import_to_add) = import_to_add {\n+        item.add_import(import_to_add);\n+    }\n \n-        match self.ctx.snippet_cap() {\n-            Some(cap) if needs_bang && !has_parens => {\n-                let snippet = format!(\"{}!{}$0{}\", self.name, self.bra, self.ket);\n-                let lookup = self.banged_name();\n-                item.insert_snippet(cap, snippet).lookup_by(lookup);\n-            }\n-            _ if needs_bang => {\n-                let lookup = self.banged_name();\n-                item.insert_text(self.banged_name()).lookup_by(lookup);\n-            }\n-            _ => {\n-                cov_mark::hit!(dont_insert_macro_call_parens_unncessary);\n-                item.insert_text(&*self.name);\n-            }\n-        };\n+    let name = &*name;\n \n-        item.set_documentation(self.docs);\n-        Some(item.build())\n-    }\n+    match ctx.snippet_cap() {\n+        Some(cap) if needs_bang && !completion.path_is_call() => {\n+            let snippet = format!(\"{}!{}$0{}\", name, bra, ket);\n+            let lookup = banged_name(name);\n+            item.insert_snippet(cap, snippet).lookup_by(lookup);\n+        }\n+        _ if needs_bang => {\n+            let banged_name = banged_name(name);\n+            item.insert_text(banged_name.clone()).lookup_by(banged_name);\n+        }\n+        _ => {\n+            cov_mark::hit!(dont_insert_macro_call_parens_unncessary);\n+            item.insert_text(name);\n+        }\n+    };\n \n-    fn needs_bang(&self) -> bool {\n-        !matches!(self.ctx.completion.path_kind(), Some(PathKind::Mac | PathKind::Use))\n-    }\n+    Some(item.build())\n+}\n \n-    fn label(&self) -> SmolStr {\n-        if !self.macro_.is_fn_like() {\n-            self.name.clone()\n-        } else if self.needs_bang() && self.ctx.snippet_cap().is_some() {\n-            SmolStr::from_iter([&*self.name, \"!\", self.bra, \"\u2026\", self.ket])\n+fn label(\n+    ctx: &RenderContext<'_>,\n+    needs_bang: bool,\n+    bra: &str,\n+    ket: &str,\n+    name: &SmolStr,\n+) -> SmolStr {\n+    if needs_bang {\n+        if ctx.snippet_cap().is_some() {\n+            SmolStr::from_iter([&*name, \"!\", bra, \"\u2026\", ket])\n         } else {\n-            self.banged_name()\n+            banged_name(name)\n         }\n+    } else {\n+        name.clone()\n     }\n+}\n \n-    fn banged_name(&self) -> SmolStr {\n-        SmolStr::from_iter([&*self.name, \"!\"])\n-    }\n+fn banged_name(name: &str) -> SmolStr {\n+    SmolStr::from_iter([name, \"!\"])\n+}\n \n-    fn detail(&self) -> Option<String> {\n-        let detail = match self.macro_.source(self.ctx.db())?.value {\n-            Either::Left(node) => macro_label(&node),\n-            Either::Right(node) => fn_as_proc_macro_label(&node),\n-        };\n-        Some(detail)\n-    }\n+fn detail(db: &dyn HirDatabase, macro_: hir::MacroDef) -> Option<String> {\n+    // FIXME: This is parsing the file!\n+    let detail = match macro_.source(db)?.value {\n+        Either::Left(node) => macro_label(&node),\n+        Either::Right(node) => fn_as_proc_macro_label(&node),\n+    };\n+    Some(detail)\n }\n \n fn guess_macro_braces(macro_name: &str, docs: &str) -> (&'static str, &'static str) {\n@@ -147,7 +149,7 @@ mod tests {\n     fn dont_insert_macro_call_parens_unncessary() {\n         cov_mark::check!(dont_insert_macro_call_parens_unncessary);\n         check_edit(\n-            \"frobnicate!\",\n+            \"frobnicate\",\n             r#\"\n //- /main.rs crate:main deps:foo\n use foo::$0;\n@@ -161,7 +163,7 @@ use foo::frobnicate;\n         );\n \n         check_edit(\n-            \"frobnicate!\",\n+            \"frobnicate\",\n             r#\"\n macro_rules! frobnicate { () => () }\n fn main() { frob$0!(); }"}, {"sha": "5df21fb36cddea4b842ebeeff18fb2c1d0290924", "filename": "crates/ide_completion/src/render/type_alias.rs", "status": "modified", "additions": 30, "deletions": 48, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/22adcfde039336bf34f66726918396706765154e/crates%2Fide_completion%2Fsrc%2Frender%2Ftype_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22adcfde039336bf34f66726918396706765154e/crates%2Fide_completion%2Fsrc%2Frender%2Ftype_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Ftype_alias.rs?ref=22adcfde039336bf34f66726918396706765154e", "patch": "@@ -2,10 +2,7 @@\n \n use hir::{AsAssocItem, HasSource};\n use ide_db::SymbolKind;\n-use syntax::{\n-    ast::{HasName, TypeAlias},\n-    display::type_label,\n-};\n+use syntax::{ast::HasName, display::type_label};\n \n use crate::{item::CompletionItem, render::RenderContext};\n \n@@ -14,61 +11,46 @@ pub(crate) fn render_type_alias(\n     type_alias: hir::TypeAlias,\n ) -> Option<CompletionItem> {\n     let _p = profile::span(\"render_type_alias\");\n-    TypeAliasRender::new(ctx, type_alias)?.render(false)\n+    render(ctx, type_alias, false)\n }\n \n pub(crate) fn render_type_alias_with_eq(\n     ctx: RenderContext<'_>,\n     type_alias: hir::TypeAlias,\n ) -> Option<CompletionItem> {\n     let _p = profile::span(\"render_type_alias_with_eq\");\n-    TypeAliasRender::new(ctx, type_alias)?.render(true)\n+    render(ctx, type_alias, true)\n }\n \n-#[derive(Debug)]\n-struct TypeAliasRender<'a> {\n-    ctx: RenderContext<'a>,\n+fn render(\n+    ctx: RenderContext<'_>,\n     type_alias: hir::TypeAlias,\n-    ast_node: TypeAlias,\n-}\n-\n-impl<'a> TypeAliasRender<'a> {\n-    fn new(ctx: RenderContext<'a>, type_alias: hir::TypeAlias) -> Option<TypeAliasRender<'a>> {\n-        let ast_node = type_alias.source(ctx.db())?.value;\n-        Some(TypeAliasRender { ctx, type_alias, ast_node })\n-    }\n-\n-    fn render(self, with_eq: bool) -> Option<CompletionItem> {\n-        let name = self.ast_node.name().map(|name| {\n-            if with_eq {\n-                format!(\"{} = \", name.text())\n-            } else {\n-                name.text().to_string()\n-            }\n-        })?;\n-        let detail = self.detail();\n-\n-        let mut item =\n-            CompletionItem::new(SymbolKind::TypeAlias, self.ctx.source_range(), name.clone());\n-        item.set_documentation(self.ctx.docs(self.type_alias))\n-            .set_deprecated(\n-                self.ctx.is_deprecated(self.type_alias)\n-                    || self.ctx.is_deprecated_assoc_item(self.type_alias),\n-            )\n-            .detail(detail);\n-\n-        let db = self.ctx.db();\n-        if let Some(actm) = self.type_alias.as_assoc_item(db) {\n-            if let Some(trt) = actm.containing_trait_or_trait_impl(db) {\n-                item.trait_name(trt.name(db).to_smol_str());\n-                item.insert_text(name);\n-            }\n+    with_eq: bool,\n+) -> Option<CompletionItem> {\n+    let db = ctx.db();\n+\n+    // FIXME: This parses the file!\n+    let ast_node = type_alias.source(db)?.value;\n+    let name = ast_node.name().map(|name| {\n+        if with_eq {\n+            format!(\"{} = \", name.text())\n+        } else {\n+            name.text().to_string()\n+        }\n+    })?;\n+    let detail = type_label(&ast_node);\n+\n+    let mut item = CompletionItem::new(SymbolKind::TypeAlias, ctx.source_range(), name.clone());\n+    item.set_documentation(ctx.docs(type_alias))\n+        .set_deprecated(ctx.is_deprecated(type_alias) || ctx.is_deprecated_assoc_item(type_alias))\n+        .detail(detail);\n+\n+    if let Some(actm) = type_alias.as_assoc_item(db) {\n+        if let Some(trt) = actm.containing_trait_or_trait_impl(db) {\n+            item.trait_name(trt.name(db).to_smol_str());\n+            item.insert_text(name);\n         }\n-\n-        Some(item.build())\n     }\n \n-    fn detail(&self) -> String {\n-        type_label(&self.ast_node)\n-    }\n+    Some(item.build())\n }"}, {"sha": "5f20e342e02d53903f5fa768915b26ac91abaf56", "filename": "crates/ide_completion/src/tests/use_tree.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22adcfde039336bf34f66726918396706765154e/crates%2Fide_completion%2Fsrc%2Ftests%2Fuse_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22adcfde039336bf34f66726918396706765154e/crates%2Fide_completion%2Fsrc%2Ftests%2Fuse_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fuse_tree.rs?ref=22adcfde039336bf34f66726918396706765154e", "patch": "@@ -129,7 +129,7 @@ struct Bar;\n \"#,\n         expect![[r#\"\n             st Foo\n-            ma foo! macro_rules! foo_\n+            ma foo macro_rules! foo_\n         \"#]],\n     );\n }"}]}