{"sha": "c189565edc5c9fc516170885b3a3061b936205fb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxODk1NjVlZGM1YzlmYzUxNjE3MDg4NWIzYTMwNjFiOTM2MjA1ZmI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-08T07:35:34Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-16T08:59:53Z"}, "message": "syntax: reduce visibilities", "tree": {"sha": "9b7deb9d35aa293c01251707bb915143551aec71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b7deb9d35aa293c01251707bb915143551aec71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c189565edc5c9fc516170885b3a3061b936205fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c189565edc5c9fc516170885b3a3061b936205fb", "html_url": "https://github.com/rust-lang/rust/commit/c189565edc5c9fc516170885b3a3061b936205fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c189565edc5c9fc516170885b3a3061b936205fb/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98017ca53a0c3ac6a10f60b47462bd3546baaaa1", "url": "https://api.github.com/repos/rust-lang/rust/commits/98017ca53a0c3ac6a10f60b47462bd3546baaaa1", "html_url": "https://github.com/rust-lang/rust/commit/98017ca53a0c3ac6a10f60b47462bd3546baaaa1"}], "stats": {"total": 202, "additions": 101, "deletions": 101}, "files": [{"sha": "65257c7e9855ebfa59f37c75a9de3854f9970d4d", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c189565edc5c9fc516170885b3a3061b936205fb/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c189565edc5c9fc516170885b3a3061b936205fb/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=c189565edc5c9fc516170885b3a3061b936205fb", "patch": "@@ -280,7 +280,7 @@ impl Attribute {\n         self.item.meta(self.span)\n     }\n \n-    pub fn parse<'a, T, F>(&self, sess: &'a ParseSess, mut f: F) -> PResult<'a, T>\n+    crate fn parse<'a, T, F>(&self, sess: &'a ParseSess, mut f: F) -> PResult<'a, T>\n         where F: FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n     {\n         let mut parser = Parser::new(\n@@ -298,14 +298,14 @@ impl Attribute {\n         Ok(result)\n     }\n \n-    pub fn parse_derive_paths<'a>(&self, sess: &'a ParseSess) -> PResult<'a, Vec<Path>> {\n+    crate fn parse_derive_paths<'a>(&self, sess: &'a ParseSess) -> PResult<'a, Vec<Path>> {\n         if self.tokens.is_empty() {\n             return Ok(Vec::new());\n         }\n         self.parse(sess, |p| p.parse_derive_paths())\n     }\n \n-    pub fn parse_meta<'a>(&self, sess: &'a ParseSess) -> PResult<'a, MetaItem> {\n+    crate fn parse_meta<'a>(&self, sess: &'a ParseSess) -> PResult<'a, MetaItem> {\n         Ok(MetaItem {\n             path: self.path.clone(),\n             kind: self.parse(sess, |parser| parser.parse_meta_item_kind())?,"}, {"sha": "44a51a01710453312928b7d110fd9934682303e4", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c189565edc5c9fc516170885b3a3061b936205fb/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c189565edc5c9fc516170885b3a3061b936205fb/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=c189565edc5c9fc516170885b3a3061b936205fb", "patch": "@@ -838,7 +838,7 @@ impl<'a> Parser<'a> {\n                               self.this_token_to_string());\n             // Avoid emitting backtrace info twice.\n             let def_site_span = self.token.span.with_ctxt(SyntaxContext::root());\n-            let mut err = self.diagnostic().struct_span_err(def_site_span, &msg);\n+            let mut err = self.struct_span_err(def_site_span, &msg);\n             err.span_label(span, \"caused by the macro expansion here\");\n             let msg = format!(\n                 \"the usage of `{}!` is likely invalid in {} context\","}, {"sha": "54e523430e454f34f7cdda61584321a9ddebce24", "filename": "src/libsyntax/parse/literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c189565edc5c9fc516170885b3a3061b936205fb/src%2Flibsyntax%2Fparse%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c189565edc5c9fc516170885b3a3061b936205fb/src%2Flibsyntax%2Fparse%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fliteral.rs?ref=c189565edc5c9fc516170885b3a3061b936205fb", "patch": "@@ -212,7 +212,7 @@ impl Lit {\n     /// Attempts to recover an AST literal from semantic literal.\n     /// This function is used when the original token doesn't exist (e.g. the literal is created\n     /// by an AST-based macro) or unavailable (e.g. from HIR pretty-printing).\n-    pub fn from_lit_kind(kind: LitKind, span: Span) -> Lit {\n+    crate fn from_lit_kind(kind: LitKind, span: Span) -> Lit {\n         Lit { token: kind.to_lit_token(), kind, span }\n     }\n "}, {"sha": "7914fdbf9788324731f3bdb5f11228d211e049e1", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 29, "deletions": 31, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/c189565edc5c9fc516170885b3a3061b936205fb/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c189565edc5c9fc516170885b3a3061b936205fb/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=c189565edc5c9fc516170885b3a3061b936205fb", "patch": "@@ -2,12 +2,10 @@ mod attr;\n mod expr;\n mod pat;\n mod item;\n-pub use item::AliasKind;\n mod module;\n-pub use module::{ModulePath, ModulePathSuccess};\n mod ty;\n mod path;\n-pub use path::PathStyle;\n+crate use path::PathStyle;\n mod stmt;\n mod generics;\n mod diagnostics;\n@@ -46,14 +44,14 @@ bitflags::bitflags! {\n }\n \n #[derive(Clone, Copy, PartialEq, Debug)]\n-crate enum SemiColonMode {\n+enum SemiColonMode {\n     Break,\n     Ignore,\n     Comma,\n }\n \n #[derive(Clone, Copy, PartialEq, Debug)]\n-crate enum BlockMode {\n+enum BlockMode {\n     Break,\n     Ignore,\n }\n@@ -126,33 +124,33 @@ pub struct Parser<'a> {\n     prev_token_kind: PrevTokenKind,\n     restrictions: Restrictions,\n     /// Used to determine the path to externally loaded source files.\n-    crate directory: Directory<'a>,\n+    pub(super) directory: Directory<'a>,\n     /// `true` to parse sub-modules in other files.\n-    pub recurse_into_file_modules: bool,\n+    pub(super) recurse_into_file_modules: bool,\n     /// Name of the root module this parser originated from. If `None`, then the\n     /// name is not known. This does not change while the parser is descending\n     /// into modules, and sub-parsers have new values for this name.\n-    pub root_module_name: Option<String>,\n-    crate expected_tokens: Vec<TokenType>,\n+    crate root_module_name: Option<String>,\n+    expected_tokens: Vec<TokenType>,\n     token_cursor: TokenCursor,\n     desugar_doc_comments: bool,\n     /// `true` we should configure out of line modules as we parse.\n-    pub cfg_mods: bool,\n+    cfg_mods: bool,\n     /// This field is used to keep track of how many left angle brackets we have seen. This is\n     /// required in order to detect extra leading left angle brackets (`<` characters) and error\n     /// appropriately.\n     ///\n     /// See the comments in the `parse_path_segment` function for more details.\n-    crate unmatched_angle_bracket_count: u32,\n-    crate max_angle_bracket_count: u32,\n+    unmatched_angle_bracket_count: u32,\n+    max_angle_bracket_count: u32,\n     /// A list of all unclosed delimiters found by the lexer. If an entry is used for error recovery\n     /// it gets removed from here. Every entry left at the end gets emitted as an independent\n     /// error.\n-    crate unclosed_delims: Vec<UnmatchedBrace>,\n-    crate last_unexpected_token_span: Option<Span>,\n+    pub(super) unclosed_delims: Vec<UnmatchedBrace>,\n+    last_unexpected_token_span: Option<Span>,\n     crate last_type_ascription: Option<(Span, bool /* likely path typo */)>,\n     /// If present, this `Parser` is not parsing Rust code but rather a macro call.\n-    crate subparser_name: Option<&'static str>,\n+    subparser_name: Option<&'static str>,\n }\n \n impl<'a> Drop for Parser<'a> {\n@@ -196,7 +194,7 @@ struct TokenCursorFrame {\n /// You can find some more example usage of this in the `collect_tokens` method\n /// on the parser.\n #[derive(Clone)]\n-crate enum LastToken {\n+enum LastToken {\n     Collecting(Vec<TreeAndJoint>),\n     Was(Option<TreeAndJoint>),\n }\n@@ -299,7 +297,7 @@ impl TokenCursor {\n }\n \n #[derive(Clone, PartialEq)]\n-crate enum TokenType {\n+enum TokenType {\n     Token(TokenKind),\n     Keyword(Symbol),\n     Operator,\n@@ -311,7 +309,7 @@ crate enum TokenType {\n }\n \n impl TokenType {\n-    crate fn to_string(&self) -> String {\n+    fn to_string(&self) -> String {\n         match *self {\n             TokenType::Token(ref t) => format!(\"`{}`\", pprust::token_kind_to_string(t)),\n             TokenType::Keyword(kw) => format!(\"`{}`\", kw),\n@@ -326,13 +324,13 @@ impl TokenType {\n }\n \n #[derive(Copy, Clone, Debug)]\n-crate enum TokenExpectType {\n+enum TokenExpectType {\n     Expect,\n     NoExpect,\n }\n \n impl<'a> Parser<'a> {\n-    pub fn new(\n+    crate fn new(\n         sess: &'a ParseSess,\n         tokens: TokenStream,\n         directory: Option<Directory<'a>>,\n@@ -407,7 +405,7 @@ impl<'a> Parser<'a> {\n         pprust::token_to_string(&self.token)\n     }\n \n-    crate fn token_descr(&self) -> Option<&'static str> {\n+    fn token_descr(&self) -> Option<&'static str> {\n         Some(match &self.token.kind {\n             _ if self.token.is_special_ident() => \"reserved identifier\",\n             _ if self.token.is_used_keyword() => \"keyword\",\n@@ -417,7 +415,7 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    crate fn this_token_descr(&self) -> String {\n+    pub(super) fn this_token_descr(&self) -> String {\n         if let Some(prefix) = self.token_descr() {\n             format!(\"{} `{}`\", prefix, self.this_token_to_string())\n         } else {\n@@ -467,7 +465,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub fn parse_ident(&mut self) -> PResult<'a, ast::Ident> {\n+    fn parse_ident(&mut self) -> PResult<'a, ast::Ident> {\n         self.parse_ident_common(true)\n     }\n \n@@ -500,7 +498,7 @@ impl<'a> Parser<'a> {\n     ///\n     /// This method will automatically add `tok` to `expected_tokens` if `tok` is not\n     /// encountered.\n-    crate fn check(&mut self, tok: &TokenKind) -> bool {\n+    fn check(&mut self, tok: &TokenKind) -> bool {\n         let is_present = self.token == *tok;\n         if !is_present { self.expected_tokens.push(TokenType::Token(tok.clone())); }\n         is_present\n@@ -522,7 +520,7 @@ impl<'a> Parser<'a> {\n \n     /// If the next token is the given keyword, eats it and returns `true`.\n     /// Otherwise, returns `false`. An expectation is also added for diagnostics purposes.\n-    pub fn eat_keyword(&mut self, kw: Symbol) -> bool {\n+    fn eat_keyword(&mut self, kw: Symbol) -> bool {\n         if self.check_keyword(kw) {\n             self.bump();\n             true\n@@ -560,7 +558,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    crate fn check_ident(&mut self) -> bool {\n+    fn check_ident(&mut self) -> bool {\n         self.check_or_expected(self.token.is_ident(), TokenType::Ident)\n     }\n \n@@ -725,7 +723,7 @@ impl<'a> Parser<'a> {\n     /// Parses a sequence, including the closing delimiter. The function\n     /// `f` must consume tokens until reaching the next separator or\n     /// closing bracket.\n-    pub fn parse_seq_to_end<T>(\n+    fn parse_seq_to_end<T>(\n         &mut self,\n         ket: &TokenKind,\n         sep: SeqSep,\n@@ -741,7 +739,7 @@ impl<'a> Parser<'a> {\n     /// Parses a sequence, not including the closing delimiter. The function\n     /// `f` must consume tokens until reaching the next separator or\n     /// closing bracket.\n-    pub fn parse_seq_to_before_end<T>(\n+    fn parse_seq_to_before_end<T>(\n         &mut self,\n         ket: &TokenKind,\n         sep: SeqSep,\n@@ -759,7 +757,7 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    crate fn parse_seq_to_before_tokens<T>(\n+    fn parse_seq_to_before_tokens<T>(\n         &mut self,\n         kets: &[&TokenKind],\n         sep: SeqSep,\n@@ -1101,7 +1099,7 @@ impl<'a> Parser<'a> {\n     /// If the following element can't be a tuple (i.e., it's a function definition), then\n     /// it's not a tuple struct field), and the contents within the parentheses isn't valid,\n     /// so emit a proper diagnostic.\n-    pub fn parse_visibility(&mut self, can_take_tuple: bool) -> PResult<'a, Visibility> {\n+    crate fn parse_visibility(&mut self, can_take_tuple: bool) -> PResult<'a, Visibility> {\n         maybe_whole!(self, NtVis, |x| x);\n \n         self.expected_tokens.push(TokenType::Keyword(kw::Crate));\n@@ -1325,7 +1323,7 @@ impl<'a> Parser<'a> {\n                                    *t == token::BinOp(token::Star))\n     }\n \n-    pub fn parse_optional_str(&mut self) -> Option<(Symbol, ast::StrStyle, Option<ast::Name>)> {\n+    fn parse_optional_str(&mut self) -> Option<(Symbol, ast::StrStyle, Option<ast::Name>)> {\n         let ret = match self.token.kind {\n             token::Literal(token::Lit { kind: token::Str, symbol, suffix }) =>\n                 (symbol, ast::StrStyle::Cooked, suffix),"}, {"sha": "cfd10e443e969764e3043c092130f5c60393242b", "filename": "src/libsyntax/parse/parser/attr.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c189565edc5c9fc516170885b3a3061b936205fb/src%2Flibsyntax%2Fparse%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c189565edc5c9fc516170885b3a3061b936205fb/src%2Flibsyntax%2Fparse%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fattr.rs?ref=c189565edc5c9fc516170885b3a3061b936205fb", "patch": "@@ -20,7 +20,7 @@ const DEFAULT_UNEXPECTED_INNER_ATTR_ERR_MSG: &str = \"an inner attribute is not \\\n \n impl<'a> Parser<'a> {\n     /// Parses attributes that appear before an item.\n-    crate fn parse_outer_attributes(&mut self) -> PResult<'a, Vec<ast::Attribute>> {\n+    pub(super) fn parse_outer_attributes(&mut self) -> PResult<'a, Vec<ast::Attribute>> {\n         let mut attrs: Vec<ast::Attribute> = Vec::new();\n         let mut just_parsed_doc_comment = false;\n         loop {\n@@ -66,7 +66,7 @@ impl<'a> Parser<'a> {\n     ///\n     /// If `permit_inner` is `true`, then a leading `!` indicates an inner\n     /// attribute.\n-    pub fn parse_attribute(&mut self, permit_inner: bool) -> PResult<'a, ast::Attribute> {\n+    fn parse_attribute(&mut self, permit_inner: bool) -> PResult<'a, ast::Attribute> {\n         debug!(\"parse_attribute: permit_inner={:?} self.token={:?}\",\n                permit_inner,\n                self.token);\n@@ -84,9 +84,10 @@ impl<'a> Parser<'a> {\n \n     /// The same as `parse_attribute`, except it takes in an `InnerAttributeParsePolicy`\n     /// that prescribes how to handle inner attributes.\n-    fn parse_attribute_with_inner_parse_policy(&mut self,\n-                                               inner_parse_policy: InnerAttributeParsePolicy<'_>)\n-                                               -> PResult<'a, ast::Attribute> {\n+    fn parse_attribute_with_inner_parse_policy(\n+        &mut self,\n+        inner_parse_policy: InnerAttributeParsePolicy<'_>\n+    ) -> PResult<'a, ast::Attribute> {\n         debug!(\"parse_attribute_with_inner_parse_policy: inner_parse_policy={:?} self.token={:?}\",\n                inner_parse_policy,\n                self.token);"}, {"sha": "a6884ec2c722482b841c15da8d9dafbe236f220e", "filename": "src/libsyntax/parse/parser/diagnostics.rs", "status": "modified", "additions": 39, "deletions": 38, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/c189565edc5c9fc516170885b3a3061b936205fb/src%2Flibsyntax%2Fparse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c189565edc5c9fc516170885b3a3061b936205fb/src%2Flibsyntax%2Fparse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fdiagnostics.rs?ref=c189565edc5c9fc516170885b3a3061b936205fb", "patch": "@@ -17,8 +17,9 @@ use log::{debug, trace};\n use std::mem;\n \n const TURBOFISH: &'static str = \"use `::<...>` instead of `<...>` to specify type arguments\";\n+\n /// Creates a placeholder argument.\n-crate fn dummy_arg(ident: Ident) -> Param {\n+pub(super) fn dummy_arg(ident: Ident) -> Param {\n     let pat = P(Pat {\n         id: ast::DUMMY_NODE_ID,\n         kind: PatKind::Ident(BindingMode::ByValue(Mutability::Immutable), ident, None),\n@@ -121,7 +122,7 @@ impl Error {\n     }\n }\n \n-pub trait RecoverQPath: Sized + 'static {\n+pub(super) trait RecoverQPath: Sized + 'static {\n     const PATH_STYLE: PathStyle = PathStyle::Expr;\n     fn to_ty(&self) -> Option<P<Ty>>;\n     fn recovered(qself: Option<QSelf>, path: ast::Path) -> Self;\n@@ -169,23 +170,23 @@ impl RecoverQPath for Expr {\n }\n \n impl<'a> Parser<'a> {\n-    pub fn fatal(&self, m: &str) -> DiagnosticBuilder<'a> {\n+    crate fn fatal(&self, m: &str) -> DiagnosticBuilder<'a> {\n         self.span_fatal(self.token.span, m)\n     }\n \n-    pub fn span_fatal<S: Into<MultiSpan>>(&self, sp: S, m: &str) -> DiagnosticBuilder<'a> {\n+    crate fn span_fatal<S: Into<MultiSpan>>(&self, sp: S, m: &str) -> DiagnosticBuilder<'a> {\n         self.sess.span_diagnostic.struct_span_fatal(sp, m)\n     }\n \n-    pub fn span_fatal_err<S: Into<MultiSpan>>(&self, sp: S, err: Error) -> DiagnosticBuilder<'a> {\n+    pub(super) fn span_fatal_err<S: Into<MultiSpan>>(&self, sp: S, err: Error) -> DiagnosticBuilder<'a> {\n         err.span_err(sp, self.diagnostic())\n     }\n \n-    pub fn bug(&self, m: &str) -> ! {\n+    pub(super) fn bug(&self, m: &str) -> ! {\n         self.sess.span_diagnostic.span_bug(self.token.span, m)\n     }\n \n-    pub fn span_err<S: Into<MultiSpan>>(&self, sp: S, m: &str) {\n+    pub(super) fn span_err<S: Into<MultiSpan>>(&self, sp: S, m: &str) {\n         self.sess.span_diagnostic.span_err(sp, m)\n     }\n \n@@ -197,15 +198,15 @@ impl<'a> Parser<'a> {\n         self.sess.span_diagnostic.span_bug(sp, m)\n     }\n \n-    crate fn diagnostic(&self) -> &'a errors::Handler {\n+    pub(super) fn diagnostic(&self) -> &'a errors::Handler {\n         &self.sess.span_diagnostic\n     }\n \n-    crate fn span_to_snippet(&self, span: Span) -> Result<String, SpanSnippetError> {\n+    pub(super) fn span_to_snippet(&self, span: Span) -> Result<String, SpanSnippetError> {\n         self.sess.source_map().span_to_snippet(span)\n     }\n \n-    crate fn expected_ident_found(&self) -> DiagnosticBuilder<'a> {\n+    pub(super) fn expected_ident_found(&self) -> DiagnosticBuilder<'a> {\n         let mut err = self.struct_span_err(\n             self.token.span,\n             &format!(\"expected identifier, found {}\", self.this_token_descr()),\n@@ -236,7 +237,7 @@ impl<'a> Parser<'a> {\n         err\n     }\n \n-    pub fn expected_one_of_not_found(\n+    pub(super) fn expected_one_of_not_found(\n         &mut self,\n         edible: &[TokenKind],\n         inedible: &[TokenKind],\n@@ -423,7 +424,7 @@ impl<'a> Parser<'a> {\n \n     /// Eats and discards tokens until one of `kets` is encountered. Respects token trees,\n     /// passes through any errors encountered. Used for error recovery.\n-    crate fn eat_to_tokens(&mut self, kets: &[&TokenKind]) {\n+    pub(super) fn eat_to_tokens(&mut self, kets: &[&TokenKind]) {\n         if let Err(ref mut err) = self.parse_seq_to_before_tokens(\n             kets,\n             SeqSep::none(),\n@@ -441,7 +442,7 @@ impl<'a> Parser<'a> {\n     /// let _ = vec![1, 2, 3].into_iter().collect::<Vec<usize>>>>();\n     ///                                                        ^^ help: remove extra angle brackets\n     /// ```\n-    crate fn check_trailing_angle_brackets(&mut self, segment: &PathSegment, end: TokenKind) {\n+    pub(super) fn check_trailing_angle_brackets(&mut self, segment: &PathSegment, end: TokenKind) {\n         // This function is intended to be invoked after parsing a path segment where there are two\n         // cases:\n         //\n@@ -560,7 +561,7 @@ impl<'a> Parser<'a> {\n     ///     inner_op   r2\n     ///        /  \\\n     ///     l1    r1\n-    crate fn check_no_chained_comparison(\n+    pub(super) fn check_no_chained_comparison(\n         &mut self,\n         lhs: &Expr,\n         outer_op: &AssocOp,\n@@ -695,7 +696,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    crate fn maybe_report_ambiguous_plus(\n+    pub(super) fn maybe_report_ambiguous_plus(\n         &mut self,\n         allow_plus: bool,\n         impl_dyn_multi: bool,\n@@ -768,7 +769,7 @@ impl<'a> Parser<'a> {\n     /// Tries to recover from associated item paths like `[T]::AssocItem` / `(T, U)::AssocItem`.\n     /// Attempts to convert the base expression/pattern/type into a type, parses the `::AssocItem`\n     /// tail, and combines them into a `<Ty>::AssocItem` expression/pattern/type.\n-    crate fn maybe_recover_from_bad_qpath<T: RecoverQPath>(\n+    pub(super) fn maybe_recover_from_bad_qpath<T: RecoverQPath>(\n         &mut self,\n         base: P<T>,\n         allow_recovery: bool,\n@@ -784,7 +785,7 @@ impl<'a> Parser<'a> {\n \n     /// Given an already parsed `Ty`, parses the `::AssocItem` tail and\n     /// combines them into a `<Ty>::AssocItem` expression/pattern/type.\n-    crate fn maybe_recover_from_bad_qpath_stage_2<T: RecoverQPath>(\n+    pub(super) fn maybe_recover_from_bad_qpath_stage_2<T: RecoverQPath>(\n         &mut self,\n         ty_span: Span,\n         ty: P<Ty>,\n@@ -823,7 +824,7 @@ impl<'a> Parser<'a> {\n         )))\n     }\n \n-    crate fn maybe_consume_incorrect_semicolon(&mut self, items: &[P<Item>]) -> bool {\n+    pub(super) fn maybe_consume_incorrect_semicolon(&mut self, items: &[P<Item>]) -> bool {\n         if self.eat(&token::Semi) {\n             let mut err = self.struct_span_err(self.prev_span, \"expected item, found `;`\");\n             err.span_suggestion_short(\n@@ -859,7 +860,7 @@ impl<'a> Parser<'a> {\n \n     /// Creates a `DiagnosticBuilder` for an unexpected token `t` and tries to recover if it is a\n     /// closing delimiter.\n-    pub fn unexpected_try_recover(\n+    pub(super) fn unexpected_try_recover(\n         &mut self,\n         t: &TokenKind,\n     ) -> PResult<'a, bool /* recovered */> {\n@@ -909,7 +910,7 @@ impl<'a> Parser<'a> {\n         Err(err)\n     }\n \n-    crate fn parse_semi_or_incorrect_foreign_fn_body(\n+    pub(super) fn parse_semi_or_incorrect_foreign_fn_body(\n         &mut self,\n         ident: &Ident,\n         extern_sp: Span,\n@@ -947,7 +948,7 @@ impl<'a> Parser<'a> {\n \n     /// Consumes alternative await syntaxes like `await!(<expr>)`, `await <expr>`,\n     /// `await? <expr>`, `await(<expr>)`, and `await { <expr> }`.\n-    crate fn parse_incorrect_await_syntax(\n+    pub(super) fn parse_incorrect_await_syntax(\n         &mut self,\n         lo: Span,\n         await_sp: Span,\n@@ -999,7 +1000,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// If encountering `future.await()`, consumes and emits an error.\n-    crate fn recover_from_await_method_call(&mut self) {\n+    pub(super) fn recover_from_await_method_call(&mut self) {\n         if self.token == token::OpenDelim(token::Paren) &&\n             self.look_ahead(1, |t| t == &token::CloseDelim(token::Paren))\n         {\n@@ -1022,7 +1023,7 @@ impl<'a> Parser<'a> {\n     /// and suggest writing `for $pat in $expr` instead.\n     ///\n     /// This should be called before parsing the `$block`.\n-    crate fn recover_parens_around_for_head(\n+    pub(super) fn recover_parens_around_for_head(\n         &mut self,\n         pat: P<Pat>,\n         expr: &Expr,\n@@ -1060,7 +1061,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    crate fn could_ascription_be_path(&self, node: &ast::ExprKind) -> bool {\n+    pub(super) fn could_ascription_be_path(&self, node: &ast::ExprKind) -> bool {\n         self.token.is_ident() &&\n             if let ast::ExprKind::Path(..) = node { true } else { false } &&\n             !self.token.is_reserved_ident() &&           // v `foo:bar(baz)`\n@@ -1074,7 +1075,7 @@ impl<'a> Parser<'a> {\n              self.look_ahead(2, |t| t == &token::Lt))  // `foo:bar::<baz>`\n     }\n \n-    crate fn recover_seq_parse_error(\n+    pub(super) fn recover_seq_parse_error(\n         &mut self,\n         delim: token::DelimToken,\n         lo: Span,\n@@ -1091,7 +1092,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    crate fn recover_closing_delimiter(\n+    pub(super) fn recover_closing_delimiter(\n         &mut self,\n         tokens: &[TokenKind],\n         mut err: DiagnosticBuilder<'a>,\n@@ -1142,7 +1143,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Recovers from `pub` keyword in places where it seems _reasonable_ but isn't valid.\n-    crate fn eat_bad_pub(&mut self) {\n+    pub(super) fn eat_bad_pub(&mut self) {\n         if self.token.is_keyword(kw::Pub) {\n             match self.parse_visibility(false) {\n                 Ok(vis) => {\n@@ -1160,7 +1161,7 @@ impl<'a> Parser<'a> {\n     /// statement. This is something of a best-effort heuristic.\n     ///\n     /// We terminate when we find an unmatched `}` (without consuming it).\n-    crate fn recover_stmt(&mut self) {\n+    pub(super) fn recover_stmt(&mut self) {\n         self.recover_stmt_(SemiColonMode::Ignore, BlockMode::Ignore)\n     }\n \n@@ -1171,7 +1172,7 @@ impl<'a> Parser<'a> {\n     ///\n     /// If `break_on_block` is `Break`, then we will stop consuming tokens\n     /// after finding (and consuming) a brace-delimited block.\n-    crate fn recover_stmt_(&mut self, break_on_semi: SemiColonMode, break_on_block: BlockMode) {\n+    pub(super) fn recover_stmt_(&mut self, break_on_semi: SemiColonMode, break_on_block: BlockMode) {\n         let mut brace_depth = 0;\n         let mut bracket_depth = 0;\n         let mut in_block = false;\n@@ -1239,7 +1240,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    crate fn check_for_for_in_in_typo(&mut self, in_span: Span) {\n+    pub(super) fn check_for_for_in_in_typo(&mut self, in_span: Span) {\n         if self.eat_keyword(kw::In) {\n             // a common typo: `for _ in in bar {}`\n             self.struct_span_err(self.prev_span, \"expected iterable, found keyword `in`\")\n@@ -1253,14 +1254,14 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    crate fn expected_semi_or_open_brace<T>(&mut self) -> PResult<'a, T> {\n+    pub(super) fn expected_semi_or_open_brace<T>(&mut self) -> PResult<'a, T> {\n         let token_str = self.this_token_descr();\n         let mut err = self.fatal(&format!(\"expected `;` or `{{`, found {}\", token_str));\n         err.span_label(self.token.span, \"expected `;` or `{`\");\n         Err(err)\n     }\n \n-    crate fn eat_incorrect_doc_comment_for_param_type(&mut self) {\n+    pub(super) fn eat_incorrect_doc_comment_for_param_type(&mut self) {\n         if let token::DocComment(_) = self.token.kind {\n             self.struct_span_err(\n                 self.token.span,\n@@ -1288,7 +1289,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    crate fn parameter_without_type(\n+    pub(super) fn parameter_without_type(\n         &mut self,\n         err: &mut DiagnosticBuilder<'_>,\n         pat: P<ast::Pat>,\n@@ -1351,7 +1352,7 @@ impl<'a> Parser<'a> {\n         None\n     }\n \n-    crate fn recover_arg_parse(&mut self) -> PResult<'a, (P<ast::Pat>, P<ast::Ty>)> {\n+    pub(super) fn recover_arg_parse(&mut self) -> PResult<'a, (P<ast::Pat>, P<ast::Ty>)> {\n         let pat = self.parse_pat(Some(\"argument name\"))?;\n         self.expect(&token::Colon)?;\n         let ty = self.parse_ty()?;\n@@ -1379,7 +1380,7 @@ impl<'a> Parser<'a> {\n         Ok((pat, ty))\n     }\n \n-    crate fn recover_bad_self_param(\n+    pub(super) fn recover_bad_self_param(\n         &mut self,\n         mut param: ast::Param,\n         is_trait_item: bool,\n@@ -1397,7 +1398,7 @@ impl<'a> Parser<'a> {\n         Ok(param)\n     }\n \n-    crate fn consume_block(&mut self, delim: token::DelimToken) {\n+    pub(super) fn consume_block(&mut self, delim: token::DelimToken) {\n         let mut brace_depth = 0;\n         loop {\n             if self.eat(&token::OpenDelim(delim)) {\n@@ -1417,7 +1418,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    crate fn expected_expression_found(&self) -> DiagnosticBuilder<'a> {\n+    pub(super) fn expected_expression_found(&self) -> DiagnosticBuilder<'a> {\n         let (span, msg) = match (&self.token.kind, self.subparser_name) {\n             (&token::Eof, Some(origin)) => {\n                 let sp = self.sess.source_map().next_point(self.token.span);\n@@ -1462,7 +1463,7 @@ impl<'a> Parser<'a> {\n     /// the parameters are *names* (so we don't emit errors about not being able to find `b` in\n     /// the local scope), but if we find the same name multiple times, like in `fn foo(i8, i8)`,\n     /// we deduplicate them to not complain about duplicated parameter names.\n-    crate fn deduplicate_recovered_params_names(&self, fn_inputs: &mut Vec<Param>) {\n+    pub(super) fn deduplicate_recovered_params_names(&self, fn_inputs: &mut Vec<Param>) {\n         let mut seen_inputs = FxHashSet::default();\n         for input in fn_inputs.iter_mut() {\n             let opt_ident = if let (PatKind::Ident(_, ident, _), TyKind::Err) = ("}, {"sha": "2e6b9de7693d34f7cc9b80038b5806f9665afbcd", "filename": "src/libsyntax/parse/parser/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c189565edc5c9fc516170885b3a3061b936205fb/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c189565edc5c9fc516170885b3a3061b936205fb/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs?ref=c189565edc5c9fc516170885b3a3061b936205fb", "patch": "@@ -1074,7 +1074,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Matches `lit = true | false | token_lit`.\n-    crate fn parse_lit(&mut self) -> PResult<'a, Lit> {\n+    pub(super) fn parse_lit(&mut self) -> PResult<'a, Lit> {\n         let mut recovered = None;\n         if self.token == token::Dot {\n             // Attempt to recover `.4` as `0.4`.\n@@ -1253,7 +1253,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a block or unsafe block.\n-    crate fn parse_block_expr(\n+    pub(super) fn parse_block_expr(\n         &mut self,\n         opt_label: Option<Label>,\n         lo: Span,\n@@ -1558,7 +1558,7 @@ impl<'a> Parser<'a> {\n         return Ok(self.mk_expr(lo.to(hi), ExprKind::Match(discriminant, arms), attrs));\n     }\n \n-    crate fn parse_arm(&mut self) -> PResult<'a, Arm> {\n+    pub(super) fn parse_arm(&mut self) -> PResult<'a, Arm> {\n         let attrs = self.parse_outer_attributes()?;\n         let lo = self.token.span;\n         let pat = self.parse_top_pat(GateOr::No)?;\n@@ -1666,7 +1666,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses an `async move? {...}` expression.\n-    pub fn parse_async_block(&mut self, mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n+    fn parse_async_block(&mut self, mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         let span_lo = self.token.span;\n         self.expect_keyword(kw::Async)?;\n         let capture_clause = self.parse_capture_clause();"}, {"sha": "bfcb0042a75a351dadf91eeb1757861efd7c24a4", "filename": "src/libsyntax/parse/parser/generics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c189565edc5c9fc516170885b3a3061b936205fb/src%2Flibsyntax%2Fparse%2Fparser%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c189565edc5c9fc516170885b3a3061b936205fb/src%2Flibsyntax%2Fparse%2Fparser%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fgenerics.rs?ref=c189565edc5c9fc516170885b3a3061b936205fb", "patch": "@@ -74,7 +74,7 @@ impl<'a> Parser<'a> {\n \n     /// Parses a (possibly empty) list of lifetime and type parameters, possibly including\n     /// a trailing comma and erroneous trailing attributes.\n-    crate fn parse_generic_params(&mut self) -> PResult<'a, Vec<ast::GenericParam>> {\n+    pub(super) fn parse_generic_params(&mut self) -> PResult<'a, Vec<ast::GenericParam>> {\n         let mut params = Vec::new();\n         loop {\n             let attrs = self.parse_outer_attributes()?;"}, {"sha": "4f161a481ca3923b8c43f2d5b9a6f3fe99ca8db9", "filename": "src/libsyntax/parse/parser/item.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c189565edc5c9fc516170885b3a3061b936205fb/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c189565edc5c9fc516170885b3a3061b936205fb/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs?ref=c189565edc5c9fc516170885b3a3061b936205fb", "patch": "@@ -24,7 +24,7 @@ use errors::{Applicability, DiagnosticBuilder, DiagnosticId, StashKey};\n \n /// Whether the type alias or associated type is a concrete type or an opaque type.\n #[derive(Debug)]\n-pub enum AliasKind {\n+pub(super) enum AliasKind {\n     /// Just a new name for the same type.\n     Weak(P<Ty>),\n     /// Only trait impls of the type will be usable, not the actual type itself.\n@@ -675,7 +675,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses an impl item.\n-    pub fn parse_impl_item(&mut self, at_end: &mut bool) -> PResult<'a, ImplItem> {\n+    crate fn parse_impl_item(&mut self, at_end: &mut bool) -> PResult<'a, ImplItem> {\n         maybe_whole!(self, NtImplItem, |x| x);\n         let attrs = self.parse_outer_attributes()?;\n         let mut unclosed_delims = vec![];\n@@ -851,7 +851,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses the items in a trait declaration.\n-    pub fn parse_trait_item(&mut self, at_end: &mut bool) -> PResult<'a, TraitItem> {\n+    crate fn parse_trait_item(&mut self, at_end: &mut bool) -> PResult<'a, TraitItem> {\n         maybe_whole!(self, NtTraitItem, |x| x);\n         let attrs = self.parse_outer_attributes()?;\n         let mut unclosed_delims = vec![];"}, {"sha": "1a8178f0bec598e8b6bb3095f6b54d7f7b2ad42e", "filename": "src/libsyntax/parse/parser/module.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c189565edc5c9fc516170885b3a3061b936205fb/src%2Flibsyntax%2Fparse%2Fparser%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c189565edc5c9fc516170885b3a3061b936205fb/src%2Flibsyntax%2Fparse%2Fparser%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fmodule.rs?ref=c189565edc5c9fc516170885b3a3061b936205fb", "patch": "@@ -12,21 +12,21 @@ use crate::symbol::sym;\n use std::path::{self, Path, PathBuf};\n \n /// Information about the path to a module.\n-pub struct ModulePath {\n+pub(super) struct ModulePath {\n     name: String,\n     path_exists: bool,\n     pub result: Result<ModulePathSuccess, Error>,\n }\n \n-pub struct ModulePathSuccess {\n+pub(super) struct ModulePathSuccess {\n     pub path: PathBuf,\n     pub directory_ownership: DirectoryOwnership,\n     warn: bool,\n }\n \n impl<'a> Parser<'a> {\n     /// Parses a source module as a crate. This is the main entry point for the parser.\n-    pub fn parse_crate_mod(&mut self) -> PResult<'a, Crate> {\n+    crate fn parse_crate_mod(&mut self) -> PResult<'a, Crate> {\n         let lo = self.token.span;\n         let krate = Ok(ast::Crate {\n             attrs: self.parse_inner_attributes()?,\n@@ -198,7 +198,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub fn submod_path_from_attr(attrs: &[Attribute], dir_path: &Path) -> Option<PathBuf> {\n+    pub(super) fn submod_path_from_attr(attrs: &[Attribute], dir_path: &Path) -> Option<PathBuf> {\n         if let Some(s) = attr::first_attr_value_str_by_name(attrs, sym::path) {\n             let s = s.as_str();\n \n@@ -215,7 +215,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Returns a path to a module.\n-    pub fn default_submod_path(\n+    pub(super) fn default_submod_path(\n         id: ast::Ident,\n         relative: Option<ast::Ident>,\n         dir_path: &Path,"}, {"sha": "b30e0636bb1687485340e919ff6016c7b1166b93", "filename": "src/libsyntax/parse/parser/pat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c189565edc5c9fc516170885b3a3061b936205fb/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c189565edc5c9fc516170885b3a3061b936205fb/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs?ref=c189565edc5c9fc516170885b3a3061b936205fb", "patch": "@@ -22,7 +22,7 @@ const WHILE_PARSING_OR_MSG: &str = \"while parsing this or-pattern starting here\"\n \n /// Whether or not an or-pattern should be gated when occurring in the current context.\n #[derive(PartialEq)]\n-pub enum GateOr { Yes, No }\n+pub(super) enum GateOr { Yes, No }\n \n /// Whether or not to recover a `,` when parsing or-patterns.\n #[derive(PartialEq, Copy, Clone)]\n@@ -34,7 +34,7 @@ impl<'a> Parser<'a> {\n     /// Corresponds to `pat<no_top_alt>` in RFC 2535 and does not admit or-patterns\n     /// at the top level. Used when parsing the parameters of lambda expressions,\n     /// functions, function pointers, and `pat` macro fragments.\n-    pub fn parse_pat(&mut self, expected: Expected) -> PResult<'a, P<Pat>> {\n+    crate fn parse_pat(&mut self, expected: Expected) -> PResult<'a, P<Pat>> {\n         self.parse_pat_with_range_pat(true, expected)\n     }\n "}, {"sha": "0f28fb11cde4356fab268e1556336523adfbe9c3", "filename": "src/libsyntax/parse/parser/path.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c189565edc5c9fc516170885b3a3061b936205fb/src%2Flibsyntax%2Fparse%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c189565edc5c9fc516170885b3a3061b936205fb/src%2Flibsyntax%2Fparse%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fpath.rs?ref=c189565edc5c9fc516170885b3a3061b936205fb", "patch": "@@ -13,7 +13,7 @@ use errors::{Applicability, pluralise};\n \n /// Specifies how to parse a path.\n #[derive(Copy, Clone, PartialEq)]\n-pub enum PathStyle {\n+crate enum PathStyle {\n     /// In some contexts, notably in expressions, paths with generic arguments are ambiguous\n     /// with something else. For example, in expressions `segment < ....` can be interpreted\n     /// as a comparison and `segment ( ....` can be interpreted as a function call.\n@@ -88,7 +88,7 @@ impl<'a> Parser<'a> {\n     /// `a::b::C::<D>` (with disambiguator)\n     /// `Fn(Args)` (without disambiguator)\n     /// `Fn::(Args)` (with disambiguator)\n-    pub fn parse_path(&mut self, style: PathStyle) -> PResult<'a, Path> {\n+    crate fn parse_path(&mut self, style: PathStyle) -> PResult<'a, Path> {\n         maybe_whole!(self, NtPath, |path| {\n             if style == PathStyle::Mod &&\n                path.segments.iter().any(|segment| segment.args.is_some()) {\n@@ -144,7 +144,7 @@ impl<'a> Parser<'a> {\n         Ok(list)\n     }\n \n-    crate fn parse_path_segments(\n+    pub(super) fn parse_path_segments(\n         &mut self,\n         segments: &mut Vec<PathSegment>,\n         style: PathStyle,"}, {"sha": "a6625e127337fcbbb85c3868976fee1857142936", "filename": "src/libsyntax/parse/parser/stmt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c189565edc5c9fc516170885b3a3061b936205fb/src%2Flibsyntax%2Fparse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c189565edc5c9fc516170885b3a3061b936205fb/src%2Flibsyntax%2Fparse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fstmt.rs?ref=c189565edc5c9fc516170885b3a3061b936205fb", "patch": "@@ -20,7 +20,7 @@ use errors::Applicability;\n impl<'a> Parser<'a> {\n     /// Parses a statement. This stops just before trailing semicolons on everything but items.\n     /// e.g., a `StmtKind::Semi` parses to a `StmtKind::Expr`, leaving the trailing `;` unconsumed.\n-    pub fn parse_stmt(&mut self) -> PResult<'a, Option<Stmt>> {\n+    crate fn parse_stmt(&mut self) -> PResult<'a, Option<Stmt>> {\n         Ok(self.parse_stmt_(true))\n     }\n \n@@ -300,7 +300,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a block. No inner attributes are allowed.\n-    pub fn parse_block(&mut self) -> PResult<'a, P<Block>> {\n+    crate fn parse_block(&mut self) -> PResult<'a, P<Block>> {\n         maybe_whole!(self, NtBlock, |x| x);\n \n         let lo = self.token.span;\n@@ -373,7 +373,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a block. Inner attributes are allowed.\n-    crate fn parse_inner_attrs_and_block(&mut self) -> PResult<'a, (Vec<Attribute>, P<Block>)> {\n+    pub(super) fn parse_inner_attrs_and_block(&mut self) -> PResult<'a, (Vec<Attribute>, P<Block>)> {\n         maybe_whole!(self, NtBlock, |x| (Vec::new(), x));\n \n         let lo = self.token.span;"}, {"sha": "fe18a08ae1e50c6aa09e5c6ce449fce6b92f2b0b", "filename": "src/libsyntax/parse/parser/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c189565edc5c9fc516170885b3a3061b936205fb/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c189565edc5c9fc516170885b3a3061b936205fb/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fty.rs?ref=c189565edc5c9fc516170885b3a3061b936205fb", "patch": "@@ -296,7 +296,7 @@ impl<'a> Parser<'a> {\n         })))\n     }\n \n-    crate fn parse_generic_bounds(&mut self,\n+    pub(super) fn parse_generic_bounds(&mut self,\n                                   colon_span: Option<Span>) -> PResult<'a, GenericBounds> {\n         self.parse_generic_bounds_common(true, colon_span)\n     }"}]}