{"sha": "bb561dac996d13174ac5286cd94ec8ab49dd97eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiNTYxZGFjOTk2ZDEzMTc0YWM1Mjg2Y2Q5NGVjOGFiNDlkZDk3ZWI=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-04-05T11:13:21Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-04-05T11:13:21Z"}, "message": "Rollup merge of #32678 - mitaa:rdoc-stripped, r=alexcrichton\n\nrustdoc: make rustdoc less pass-aware\n\nInstead of hardcoding knowledge about the strip-private pass into the\nrendering process we represent (some) stripped items as `ItemEnum::StrippedItem`.\n\nRustdoc will, for example, generate redirect pages for public items\ncontained in private modules which have been re-exported to somewhere\nexternally reachable - this will now not only work for the `strip-private`\npass, but for other passes as well, such as the `strip-hidden` pass.\n\nr? @alexcrichton", "tree": {"sha": "9b074e01611864838413b73ce9ff4a45731ad066", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b074e01611864838413b73ce9ff4a45731ad066"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb561dac996d13174ac5286cd94ec8ab49dd97eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb561dac996d13174ac5286cd94ec8ab49dd97eb", "html_url": "https://github.com/rust-lang/rust/commit/bb561dac996d13174ac5286cd94ec8ab49dd97eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb561dac996d13174ac5286cd94ec8ab49dd97eb/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c4d5f92281eefecba5885d09e4981691bbb8e0b", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c4d5f92281eefecba5885d09e4981691bbb8e0b", "html_url": "https://github.com/rust-lang/rust/commit/3c4d5f92281eefecba5885d09e4981691bbb8e0b"}, {"sha": "95eb8a68aa38ebeaadcca337d6005efabcf4a05e", "url": "https://api.github.com/repos/rust-lang/rust/commits/95eb8a68aa38ebeaadcca337d6005efabcf4a05e", "html_url": "https://github.com/rust-lang/rust/commit/95eb8a68aa38ebeaadcca337d6005efabcf4a05e"}], "stats": {"total": 603, "additions": 364, "deletions": 239}, "files": [{"sha": "7437d6087718acbb1bc1b4b0d55faded67f7c441", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 31, "deletions": 24, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/bb561dac996d13174ac5286cd94ec8ab49dd97eb/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb561dac996d13174ac5286cd94ec8ab49dd97eb/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=bb561dac996d13174ac5286cd94ec8ab49dd97eb", "patch": "@@ -14,7 +14,6 @@\n pub use self::Type::*;\n pub use self::PrimitiveType::*;\n pub use self::TypeKind::*;\n-pub use self::StructField::*;\n pub use self::VariantKind::*;\n pub use self::Mutability::*;\n pub use self::Import::*;\n@@ -53,6 +52,7 @@ use std::env::current_dir;\n use core::DocContext;\n use doctree;\n use visit_ast;\n+use html::item_type::ItemType;\n \n /// A stable identifier to the particular version of JSON output.\n /// Increment this when the `Crate` and related structures change.\n@@ -273,36 +273,49 @@ impl Item {\n     }\n     pub fn is_crate(&self) -> bool {\n         match self.inner {\n-            ModuleItem(Module { items: _, is_crate: true }) => true,\n-            _ => false\n+            StrippedItem(box ModuleItem(Module { is_crate: true, ..})) |\n+            ModuleItem(Module { is_crate: true, ..}) => true,\n+            _ => false,\n         }\n     }\n     pub fn is_mod(&self) -> bool {\n-        match self.inner { ModuleItem(..) => true, _ => false }\n+        ItemType::from_item(self) == ItemType::Module\n     }\n     pub fn is_trait(&self) -> bool {\n-        match self.inner { TraitItem(..) => true, _ => false }\n+        ItemType::from_item(self) == ItemType::Trait\n     }\n     pub fn is_struct(&self) -> bool {\n-        match self.inner { StructItem(..) => true, _ => false }\n+        ItemType::from_item(self) == ItemType::Struct\n     }\n     pub fn is_enum(&self) -> bool {\n-        match self.inner { EnumItem(..) => true, _ => false }\n+        ItemType::from_item(self) == ItemType::Module\n     }\n     pub fn is_fn(&self) -> bool {\n-        match self.inner { FunctionItem(..) => true, _ => false }\n+        ItemType::from_item(self) == ItemType::Function\n     }\n     pub fn is_associated_type(&self) -> bool {\n-        match self.inner { AssociatedTypeItem(..) => true, _ => false }\n+        ItemType::from_item(self) == ItemType::AssociatedType\n     }\n     pub fn is_associated_const(&self) -> bool {\n-        match self.inner { AssociatedConstItem(..) => true, _ => false }\n+        ItemType::from_item(self) == ItemType::AssociatedConst\n     }\n     pub fn is_method(&self) -> bool {\n-        match self.inner { MethodItem(..) => true, _ => false }\n+        ItemType::from_item(self) == ItemType::Method\n     }\n     pub fn is_ty_method(&self) -> bool {\n-        match self.inner { TyMethodItem(..) => true, _ => false }\n+        ItemType::from_item(self) == ItemType::TyMethod\n+    }\n+    pub fn is_stripped(&self) -> bool {\n+        match self.inner { StrippedItem(..) => true, _ => false }\n+    }\n+    pub fn has_stripped_fields(&self) -> Option<bool> {\n+        match self.inner {\n+            StructItem(ref _struct) => Some(_struct.fields_stripped),\n+            VariantItem(Variant { kind: StructVariant(ref vstruct)} ) => {\n+                Some(vstruct.fields_stripped)\n+            },\n+            _ => None,\n+        }\n     }\n \n     pub fn stability_class(&self) -> String {\n@@ -341,7 +354,7 @@ pub enum ItemEnum {\n     TyMethodItem(TyMethod),\n     /// A method with a body.\n     MethodItem(Method),\n-    StructFieldItem(StructField),\n+    StructFieldItem(Type),\n     VariantItem(Variant),\n     /// `fn`s from an extern block\n     ForeignFunctionItem(Function),\n@@ -352,6 +365,8 @@ pub enum ItemEnum {\n     AssociatedConstItem(Type, Option<String>),\n     AssociatedTypeItem(Vec<TyParamBound>, Option<Type>),\n     DefaultImplItem(DefaultImpl),\n+    /// An item that has been stripped by a rustdoc pass\n+    StrippedItem(Box<ItemEnum>),\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n@@ -1733,12 +1748,6 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub enum StructField {\n-    HiddenStructField, // inserted later by strip passes\n-    TypedStructField(Type),\n-}\n-\n impl Clean<Item> for hir::StructField {\n     fn clean(&self, cx: &DocContext) -> Item {\n         Item {\n@@ -1749,7 +1758,7 @@ impl Clean<Item> for hir::StructField {\n             stability: get_stability(cx, cx.map.local_def_id(self.id)),\n             deprecation: get_deprecation(cx, cx.map.local_def_id(self.id)),\n             def_id: cx.map.local_def_id(self.id),\n-            inner: StructFieldItem(TypedStructField(self.ty.clean(cx))),\n+            inner: StructFieldItem(self.ty.clean(cx)),\n         }\n     }\n }\n@@ -1766,7 +1775,7 @@ impl<'tcx> Clean<Item> for ty::FieldDefData<'tcx, 'static> {\n             stability: get_stability(cx, self.did),\n             deprecation: get_deprecation(cx, self.did),\n             def_id: self.did,\n-            inner: StructFieldItem(TypedStructField(self.unsubst_ty().clean(cx))),\n+            inner: StructFieldItem(self.unsubst_ty().clean(cx)),\n         }\n     }\n }\n@@ -1897,9 +1906,7 @@ impl<'tcx> Clean<Item> for ty::VariantDefData<'tcx, 'static> {\n                             def_id: field.did,\n                             stability: get_stability(cx, field.did),\n                             deprecation: get_deprecation(cx, field.did),\n-                            inner: StructFieldItem(\n-                                TypedStructField(field.unsubst_ty().clean(cx))\n-                            )\n+                            inner: StructFieldItem(field.unsubst_ty().clean(cx))\n                         }\n                     }).collect()\n                 })"}, {"sha": "5595c749256dfc7971a46edbd2b42c3b36806b7d", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 44, "deletions": 12, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/bb561dac996d13174ac5286cd94ec8ab49dd97eb/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb561dac996d13174ac5286cd94ec8ab49dd97eb/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=bb561dac996d13174ac5286cd94ec8ab49dd97eb", "patch": "@@ -10,28 +10,50 @@\n \n use clean::*;\n \n+pub enum FoldItem {\n+    Retain(Item),\n+    Strip(Item),\n+    Erase,\n+}\n+\n+impl FoldItem {\n+    pub fn fold(self) -> Option<Item> {\n+        match self {\n+            FoldItem::Erase => None,\n+            FoldItem::Retain(i) => Some(i),\n+            FoldItem::Strip(item@ Item { inner: StrippedItem(..), .. } ) => Some(item),\n+            FoldItem::Strip(mut i) => {\n+                i.inner = StrippedItem(box i.inner);\n+                Some(i)\n+            }\n+        }\n+    }\n+}\n+\n pub trait DocFolder : Sized {\n     fn fold_item(&mut self, item: Item) -> Option<Item> {\n         self.fold_item_recur(item)\n     }\n \n     /// don't override!\n-    fn fold_item_recur(&mut self, item: Item) -> Option<Item> {\n-        let Item { attrs, name, source, visibility, def_id, inner, stability, deprecation } = item;\n-        let inner = match inner {\n+    fn fold_inner_recur(&mut self, inner: ItemEnum) -> ItemEnum {\n+        match inner {\n+            StrippedItem(..) => unreachable!(),\n+            ModuleItem(i) => {\n+                ModuleItem(self.fold_mod(i))\n+            },\n             StructItem(mut i) => {\n                 let num_fields = i.fields.len();\n                 i.fields = i.fields.into_iter().filter_map(|x| self.fold_item(x)).collect();\n-                i.fields_stripped |= num_fields != i.fields.len();\n+                i.fields_stripped |= num_fields != i.fields.len() ||\n+                                     i.fields.iter().any(|f| f.is_stripped());\n                 StructItem(i)\n             },\n-            ModuleItem(i) => {\n-                ModuleItem(self.fold_mod(i))\n-            },\n             EnumItem(mut i) => {\n                 let num_variants = i.variants.len();\n                 i.variants = i.variants.into_iter().filter_map(|x| self.fold_item(x)).collect();\n-                i.variants_stripped |= num_variants != i.variants.len();\n+                i.variants_stripped |= num_variants != i.variants.len() ||\n+                                       i.variants.iter().any(|f| f.is_stripped());\n                 EnumItem(i)\n             },\n             TraitItem(mut i) => {\n@@ -48,13 +70,24 @@ pub trait DocFolder : Sized {\n                     StructVariant(mut j) => {\n                         let num_fields = j.fields.len();\n                         j.fields = j.fields.into_iter().filter_map(|x| self.fold_item(x)).collect();\n-                        j.fields_stripped |= num_fields != j.fields.len();\n+                        j.fields_stripped |= num_fields != j.fields.len() ||\n+                                             j.fields.iter().any(|f| f.is_stripped());\n                         VariantItem(Variant {kind: StructVariant(j), ..i2})\n                     },\n                     _ => VariantItem(i2)\n                 }\n             },\n             x => x\n+        }\n+    }\n+\n+    /// don't override!\n+    fn fold_item_recur(&mut self, item: Item) -> Option<Item> {\n+        let Item { attrs, name, source, visibility, def_id, inner, stability, deprecation } = item;\n+\n+        let inner = match inner {\n+            StrippedItem(box i) => StrippedItem(box self.fold_inner_recur(i)),\n+            _ => self.fold_inner_recur(inner),\n         };\n \n         Some(Item { attrs: attrs, name: name, source: source, inner: inner,\n@@ -70,9 +103,8 @@ pub trait DocFolder : Sized {\n     }\n \n     fn fold_crate(&mut self, mut c: Crate) -> Crate {\n-        c.module = c.module.and_then(|module| {\n-            self.fold_item(module)\n-        });\n+        c.module = c.module.and_then(|module| self.fold_item(module));\n+\n         c.external_traits = c.external_traits.into_iter().map(|(k, mut v)| {\n             v.items = v.items.into_iter().filter_map(|i| self.fold_item(i)).collect();\n             (k, v)"}, {"sha": "74f7b099044f16b3700faf88061e6567ae82cb87", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bb561dac996d13174ac5286cd94ec8ab49dd97eb/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb561dac996d13174ac5286cd94ec8ab49dd97eb/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=bb561dac996d13174ac5286cd94ec8ab49dd97eb", "patch": "@@ -44,7 +44,12 @@ pub enum ItemType {\n \n impl ItemType {\n     pub fn from_item(item: &clean::Item) -> ItemType {\n-        match item.inner {\n+        let inner = match item.inner {\n+            clean::StrippedItem(box ref item) => item,\n+            ref inner@_ => inner,\n+        };\n+\n+        match *inner {\n             clean::ModuleItem(..)          => ItemType::Module,\n             clean::ExternCrateItem(..)     => ItemType::ExternCrate,\n             clean::ImportItem(..)          => ItemType::Import,\n@@ -67,6 +72,7 @@ impl ItemType {\n             clean::AssociatedConstItem(..) => ItemType::AssociatedConst,\n             clean::AssociatedTypeItem(..)  => ItemType::AssociatedType,\n             clean::DefaultImplItem(..)     => ItemType::Impl,\n+            clean::StrippedItem(..)        => unreachable!(),\n         }\n     }\n "}, {"sha": "78dd14766e7422e9144f349ee085ba24c4859a9b", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 143, "deletions": 164, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/bb561dac996d13174ac5286cd94ec8ab49dd97eb/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb561dac996d13174ac5286cd94ec8ab49dd97eb/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=bb561dac996d13174ac5286cd94ec8ab49dd97eb", "patch": "@@ -91,12 +91,20 @@ pub struct Context {\n     /// String representation of how to get back to the root path of the 'doc/'\n     /// folder in terms of a relative URL.\n     pub root_path: String,\n-    /// The path to the crate root source minus the file name.\n-    /// Used for simplifying paths to the highlighted source code files.\n-    pub src_root: PathBuf,\n     /// The current destination folder of where HTML artifacts should be placed.\n     /// This changes as the context descends into the module hierarchy.\n     pub dst: PathBuf,\n+    /// A flag, which when `true`, will render pages which redirect to the\n+    /// real location of an item. This is used to allow external links to\n+    /// publicly reused items to redirect to the right location.\n+    pub render_redirect_pages: bool,\n+    pub shared: Arc<SharedContext>,\n+}\n+\n+pub struct SharedContext {\n+    /// The path to the crate root source minus the file name.\n+    /// Used for simplifying paths to the highlighted source code files.\n+    pub src_root: PathBuf,\n     /// This describes the layout of each page, and is not modified after\n     /// creation of the context (contains info like the favicon and added html).\n     pub layout: layout::Layout,\n@@ -106,10 +114,6 @@ pub struct Context {\n     pub include_sources: bool,\n     /// The local file sources we've emitted and their respective url-paths.\n     pub local_sources: HashMap<PathBuf, String>,\n-    /// A flag, which when turned off, will render pages which redirect to the\n-    /// real location of an item. This is used to allow external links to\n-    /// publicly reused items to redirect to the right location.\n-    pub render_redirect_pages: bool,\n     /// All the passes that were run on this crate.\n     pub passes: HashSet<String>,\n     /// The base-URL of the issue tracker for when an item has been tagged with\n@@ -245,8 +249,7 @@ pub struct Cache {\n     parent_stack: Vec<DefId>,\n     parent_is_trait_impl: bool,\n     search_index: Vec<IndexItem>,\n-    privmod: bool,\n-    remove_priv: bool,\n+    stripped_mod: bool,\n     access_levels: AccessLevels<DefId>,\n     deref_trait_did: Option<DefId>,\n \n@@ -260,7 +263,7 @@ pub struct Cache {\n \n /// Helper struct to render all source code to HTML pages\n struct SourceCollector<'a> {\n-    cx: &'a mut Context,\n+    scx: &'a mut SharedContext,\n \n     /// Root destination to place all HTML output into\n     dst: PathBuf,\n@@ -413,43 +416,37 @@ pub fn run(mut krate: clean::Crate,\n         Some(p) => p.to_path_buf(),\n         None => PathBuf::new(),\n     };\n-    let mut cx = Context {\n-        dst: dst,\n+    let mut scx = SharedContext {\n         src_root: src_root,\n         passes: passes,\n-        current: Vec::new(),\n-        root_path: String::new(),\n+        include_sources: true,\n+        local_sources: HashMap::new(),\n+        issue_tracker_base_url: None,\n         layout: layout::Layout {\n             logo: \"\".to_string(),\n             favicon: \"\".to_string(),\n             external_html: external_html.clone(),\n             krate: krate.name.clone(),\n             playground_url: \"\".to_string(),\n         },\n-        include_sources: true,\n-        local_sources: HashMap::new(),\n-        render_redirect_pages: false,\n-        issue_tracker_base_url: None,\n     };\n \n-    try_err!(mkdir(&cx.dst), &cx.dst);\n-\n     // Crawl the crate attributes looking for attributes which control how we're\n     // going to emit HTML\n     if let Some(attrs) = krate.module.as_ref().map(|m| m.attrs.list(\"doc\")) {\n         for attr in attrs {\n             match *attr {\n                 clean::NameValue(ref x, ref s)\n                         if \"html_favicon_url\" == *x => {\n-                    cx.layout.favicon = s.to_string();\n+                    scx.layout.favicon = s.to_string();\n                 }\n                 clean::NameValue(ref x, ref s)\n                         if \"html_logo_url\" == *x => {\n-                    cx.layout.logo = s.to_string();\n+                    scx.layout.logo = s.to_string();\n                 }\n                 clean::NameValue(ref x, ref s)\n                         if \"html_playground_url\" == *x => {\n-                    cx.layout.playground_url = s.to_string();\n+                    scx.layout.playground_url = s.to_string();\n                     markdown::PLAYGROUND_KRATE.with(|slot| {\n                         if slot.borrow().is_none() {\n                             let name = krate.name.clone();\n@@ -459,16 +456,25 @@ pub fn run(mut krate: clean::Crate,\n                 }\n                 clean::NameValue(ref x, ref s)\n                         if \"issue_tracker_base_url\" == *x => {\n-                    cx.issue_tracker_base_url = Some(s.to_string());\n+                    scx.issue_tracker_base_url = Some(s.to_string());\n                 }\n                 clean::Word(ref x)\n                         if \"html_no_source\" == *x => {\n-                    cx.include_sources = false;\n+                    scx.include_sources = false;\n                 }\n                 _ => {}\n             }\n         }\n     }\n+    try_err!(mkdir(&dst), &dst);\n+    krate = render_sources(&dst, &mut scx, krate)?;\n+    let cx = Context {\n+        current: Vec::new(),\n+        root_path: String::new(),\n+        dst: dst,\n+        render_redirect_pages: false,\n+        shared: Arc::new(scx),\n+    };\n \n     // Crawl the crate to build various caches used for the output\n     let analysis = ::ANALYSISKEY.with(|a| a.clone());\n@@ -492,8 +498,7 @@ pub fn run(mut krate: clean::Crate,\n         parent_is_trait_impl: false,\n         extern_locations: HashMap::new(),\n         primitive_locations: HashMap::new(),\n-        remove_priv: cx.passes.contains(\"strip-private\"),\n-        privmod: false,\n+        stripped_mod: false,\n         access_levels: access_levels,\n         orphan_methods: Vec::new(),\n         traits: mem::replace(&mut krate.external_traits, HashMap::new()),\n@@ -540,7 +545,6 @@ pub fn run(mut krate: clean::Crate,\n     CURRENT_LOCATION_KEY.with(|s| s.borrow_mut().clear());\n \n     write_shared(&cx, &krate, &*cache, index)?;\n-    let krate = render_sources(&mut cx, krate)?;\n \n     // And finally render the whole crate's documentation\n     cx.krate(krate)\n@@ -762,16 +766,16 @@ fn write_shared(cx: &Context,\n     Ok(())\n }\n \n-fn render_sources(cx: &mut Context,\n+fn render_sources(dst: &Path, scx: &mut SharedContext,\n                   krate: clean::Crate) -> Result<clean::Crate, Error> {\n     info!(\"emitting source files\");\n-    let dst = cx.dst.join(\"src\");\n+    let dst = dst.join(\"src\");\n     try_err!(mkdir(&dst), &dst);\n     let dst = dst.join(&krate.name);\n     try_err!(mkdir(&dst), &dst);\n     let mut folder = SourceCollector {\n         dst: dst,\n-        cx: cx,\n+        scx: scx,\n     };\n     Ok(folder.fold_crate(krate))\n }\n@@ -849,7 +853,7 @@ impl<'a> DocFolder for SourceCollector<'a> {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n         // If we're including source files, and we haven't seen this file yet,\n         // then we need to render it out to the filesystem\n-        if self.cx.include_sources\n+        if self.scx.include_sources\n             // skip all invalid spans\n             && item.source.filename != \"\"\n             // macros from other libraries get special filenames which we can\n@@ -862,7 +866,7 @@ impl<'a> DocFolder for SourceCollector<'a> {\n             // something like that), so just don't include sources for the\n             // entire crate. The other option is maintaining this mapping on a\n             // per-file basis, but that's probably not worth it...\n-            self.cx\n+            self.scx\n                 .include_sources = match self.emit_source(&item.source.filename) {\n                 Ok(()) => true,\n                 Err(e) => {\n@@ -874,7 +878,6 @@ impl<'a> DocFolder for SourceCollector<'a> {\n                 }\n             };\n         }\n-\n         self.fold_item_recur(item)\n     }\n }\n@@ -883,7 +886,7 @@ impl<'a> SourceCollector<'a> {\n     /// Renders the given filename into its corresponding HTML source file.\n     fn emit_source(&mut self, filename: &str) -> io::Result<()> {\n         let p = PathBuf::from(filename);\n-        if self.cx.local_sources.contains_key(&p) {\n+        if self.scx.local_sources.contains_key(&p) {\n             // We've already emitted this source\n             return Ok(());\n         }\n@@ -904,7 +907,7 @@ impl<'a> SourceCollector<'a> {\n         let mut cur = self.dst.clone();\n         let mut root_path = String::from(\"../../\");\n         let mut href = String::new();\n-        clean_srcpath(&self.cx.src_root, &p, false, |component| {\n+        clean_srcpath(&self.scx.src_root, &p, false, |component| {\n             cur.push(component);\n             mkdir(&cur).unwrap();\n             root_path.push_str(\"../\");\n@@ -928,24 +931,25 @@ impl<'a> SourceCollector<'a> {\n             description: &desc,\n             keywords: BASIC_KEYWORDS,\n         };\n-        layout::render(&mut w, &self.cx.layout,\n+        layout::render(&mut w, &self.scx.layout,\n                        &page, &(\"\"), &Source(contents))?;\n         w.flush()?;\n-        self.cx.local_sources.insert(p, href);\n+        self.scx.local_sources.insert(p, href);\n         Ok(())\n     }\n }\n \n impl DocFolder for Cache {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n-        // If this is a private module, we don't want it in the search index.\n-        let orig_privmod = match item.inner {\n-            clean::ModuleItem(..) => {\n-                let prev = self.privmod;\n-                self.privmod = prev || (self.remove_priv && item.visibility != Some(hir::Public));\n+        // If this is a stripped module,\n+        // we don't want it or its children in the search index.\n+        let orig_stripped_mod = match item.inner {\n+            clean::StrippedItem(box clean::ModuleItem(..)) => {\n+                let prev = self.stripped_mod;\n+                self.stripped_mod = true;\n                 prev\n             }\n-            _ => self.privmod,\n+            _ => self.stripped_mod,\n         };\n \n         // Register any generics to their corresponding string. This is used\n@@ -983,6 +987,7 @@ impl DocFolder for Cache {\n         // Index this method for searching later on\n         if let Some(ref s) = item.name {\n             let (parent, is_method) = match item.inner {\n+                clean::StrippedItem(..) => ((None, None), false),\n                 clean::AssociatedConstItem(..) |\n                 clean::TypedefItem(_, true) if self.parent_is_trait_impl => {\n                     // skip associated items in trait impls\n@@ -1021,20 +1026,17 @@ impl DocFolder for Cache {\n                 }\n                 _ => ((None, Some(&*self.stack)), false)\n             };\n-            let hidden_field = match item.inner {\n-                clean::StructFieldItem(clean::HiddenStructField) => true,\n-                _ => false\n-            };\n \n             match parent {\n-                (parent, Some(path)) if is_method || (!self.privmod && !hidden_field) => {\n+                (parent, Some(path)) if is_method || (!self.stripped_mod) => {\n                     // Needed to determine `self` type.\n                     let parent_basename = self.parent_stack.first().and_then(|parent| {\n                         match self.paths.get(parent) {\n                             Some(&(ref fqp, _)) => Some(fqp[fqp.len() - 1].clone()),\n                             _ => None\n                         }\n                     });\n+                    debug_assert!(!item.is_stripped());\n \n                     // A crate has a module at its root, containing all items,\n                     // which should not be indexed. The crate-item itself is\n@@ -1051,7 +1053,7 @@ impl DocFolder for Cache {\n                         });\n                     }\n                 }\n-                (Some(parent), None) if is_method || (!self.privmod && !hidden_field)=> {\n+                (Some(parent), None) if is_method || (!self.stripped_mod)=> {\n                     if parent.is_local() {\n                         // We have a parent, but we don't know where they're\n                         // defined yet. Wait for later to index this item.\n@@ -1075,7 +1077,7 @@ impl DocFolder for Cache {\n             clean::StructItem(..) | clean::EnumItem(..) |\n             clean::TypedefItem(..) | clean::TraitItem(..) |\n             clean::FunctionItem(..) | clean::ModuleItem(..) |\n-            clean::ForeignFunctionItem(..) if !self.privmod => {\n+            clean::ForeignFunctionItem(..) if !self.stripped_mod => {\n                 // Reexported items mean that the same id can show up twice\n                 // in the rustdoc ast that we're looking at. We know,\n                 // however, that a reexported item doesn't show up in the\n@@ -1093,7 +1095,7 @@ impl DocFolder for Cache {\n             }\n             // link variants to their parent enum because pages aren't emitted\n             // for each variant\n-            clean::VariantItem(..) if !self.privmod => {\n+            clean::VariantItem(..) if !self.stripped_mod => {\n                 let mut stack = self.stack.clone();\n                 stack.pop();\n                 self.paths.insert(item.def_id, (stack, ItemType::Enum));\n@@ -1176,7 +1178,7 @@ impl DocFolder for Cache {\n \n         if pushed { self.stack.pop().unwrap(); }\n         if parent_pushed { self.parent_stack.pop().unwrap(); }\n-        self.privmod = orig_privmod;\n+        self.stripped_mod = orig_stripped_mod;\n         self.parent_is_trait_impl = orig_parent_is_trait_impl;\n         return ret;\n     }\n@@ -1233,15 +1235,12 @@ impl Context {\n \n         // render the crate documentation\n         let mut work = vec!((self, item));\n-        loop {\n-            match work.pop() {\n-                Some((mut cx, item)) => cx.item(item, |cx, item| {\n-                    work.push((cx.clone(), item));\n-                })?,\n-                None => break,\n-            }\n-        }\n \n+        while let Some((mut cx, item)) = work.pop() {\n+            cx.item(item, |cx, item| {\n+                work.push((cx.clone(), item))\n+            })?\n+        }\n         Ok(())\n     }\n \n@@ -1272,10 +1271,10 @@ impl Context {\n             let tyname = shortty(it).to_static_str();\n             let desc = if it.is_crate() {\n                 format!(\"API documentation for the Rust `{}` crate.\",\n-                        cx.layout.krate)\n+                        cx.shared.layout.krate)\n             } else {\n                 format!(\"API documentation for the Rust `{}` {} in crate `{}`.\",\n-                        it.name.as_ref().unwrap(), tyname, cx.layout.krate)\n+                        it.name.as_ref().unwrap(), tyname, cx.shared.layout.krate)\n             };\n             let keywords = make_item_keywords(it);\n             let page = layout::Page {\n@@ -1293,90 +1292,83 @@ impl Context {\n             // write syscall all the time.\n             let mut writer = BufWriter::new(w);\n             if !cx.render_redirect_pages {\n-                layout::render(&mut writer, &cx.layout, &page,\n+                layout::render(&mut writer, &cx.shared.layout, &page,\n                                &Sidebar{ cx: cx, item: it },\n                                &Item{ cx: cx, item: it })?;\n+\n             } else {\n                 let mut url = repeat(\"../\").take(cx.current.len())\n                                            .collect::<String>();\n-                match cache().paths.get(&it.def_id) {\n-                    Some(&(ref names, _)) => {\n-                        for name in &names[..names.len() - 1] {\n-                            url.push_str(name);\n-                            url.push_str(\"/\");\n-                        }\n-                        url.push_str(&item_path(it));\n-                        layout::redirect(&mut writer, &url)?;\n+                if let Some(&(ref names, _)) = cache().paths.get(&it.def_id) {\n+                    for name in &names[..names.len() - 1] {\n+                        url.push_str(name);\n+                        url.push_str(\"/\");\n                     }\n-                    None => {}\n+                    url.push_str(&item_path(it));\n+                    layout::redirect(&mut writer, &url)?;\n                 }\n             }\n             writer.flush()\n         }\n \n-        // Private modules may survive the strip-private pass if they\n-        // contain impls for public types. These modules can also\n+        // Stripped modules survive the rustdoc passes (i.e. `strip-private`)\n+        // if they contain impls for public types. These modules can also\n         // contain items such as publicly reexported structures.\n         //\n         // External crates will provide links to these structures, so\n-        // these modules are recursed into, but not rendered normally (a\n-        // flag on the context).\n+        // these modules are recursed into, but not rendered normally\n+        // (a flag on the context).\n         if !self.render_redirect_pages {\n-            self.render_redirect_pages = self.ignore_private_item(&item);\n+            self.render_redirect_pages = self.maybe_ignore_item(&item);\n         }\n \n-        match item.inner {\n+        if item.is_mod() {\n             // modules are special because they add a namespace. We also need to\n             // recurse into the items of the module as well.\n-            clean::ModuleItem(..) => {\n-                let name = item.name.as_ref().unwrap().to_string();\n-                let mut item = Some(item);\n-                self.recurse(name, |this| {\n-                    let item = item.take().unwrap();\n-                    let joint_dst = this.dst.join(\"index.html\");\n-                    let dst = try_err!(File::create(&joint_dst), &joint_dst);\n-                    try_err!(render(dst, this, &item, false), &joint_dst);\n-\n-                    let m = match item.inner {\n-                        clean::ModuleItem(m) => m,\n-                        _ => unreachable!()\n-                    };\n-\n-                    // render sidebar-items.js used throughout this module\n-                    {\n-                        let items = this.build_sidebar_items(&m);\n-                        let js_dst = this.dst.join(\"sidebar-items.js\");\n-                        let mut js_out = BufWriter::new(try_err!(File::create(&js_dst), &js_dst));\n-                        try_err!(write!(&mut js_out, \"initSidebarItems({});\",\n-                                    as_json(&items)), &js_dst);\n-                    }\n+            let name = item.name.as_ref().unwrap().to_string();\n+            let mut item = Some(item);\n+            self.recurse(name, |this| {\n+                let item = item.take().unwrap();\n+                let joint_dst = this.dst.join(\"index.html\");\n+                let dst = try_err!(File::create(&joint_dst), &joint_dst);\n+                try_err!(render(dst, this, &item, false), &joint_dst);\n \n-                    for item in m.items {\n-                        f(this,item);\n-                    }\n-                    Ok(())\n-                })\n-            }\n+                let m = match item.inner {\n+                    clean::StrippedItem(box clean::ModuleItem(m)) |\n+                    clean::ModuleItem(m) => m,\n+                    _ => unreachable!()\n+                };\n \n-            // Things which don't have names (like impls) don't get special\n-            // pages dedicated to them.\n-            _ if item.name.is_some() => {\n-                let joint_dst = self.dst.join(&item_path(&item));\n+                // render sidebar-items.js used throughout this module\n+                {\n+                    let items = this.build_sidebar_items(&m);\n+                    let js_dst = this.dst.join(\"sidebar-items.js\");\n+                    let mut js_out = BufWriter::new(try_err!(File::create(&js_dst), &js_dst));\n+                    try_err!(write!(&mut js_out, \"initSidebarItems({});\",\n+                                    as_json(&items)), &js_dst);\n+                }\n \n-                let dst = try_err!(File::create(&joint_dst), &joint_dst);\n-                try_err!(render(dst, self, &item, true), &joint_dst);\n+                for item in m.items {\n+                    f(this,item);\n+                }\n                 Ok(())\n-            }\n+            })\n+        } else if item.name.is_some() {\n+            let joint_dst = self.dst.join(&item_path(&item));\n \n-            _ => Ok(())\n+            let dst = try_err!(File::create(&joint_dst), &joint_dst);\n+            try_err!(render(dst, self, &item, true), &joint_dst);\n+            Ok(())\n+        } else {\n+            Ok(())\n         }\n     }\n \n     fn build_sidebar_items(&self, m: &clean::Module) -> BTreeMap<String, Vec<NameDoc>> {\n         // BTreeMap instead of HashMap to get a sorted output\n         let mut map = BTreeMap::new();\n         for item in &m.items {\n-            if self.ignore_private_item(item) { continue }\n+            if self.maybe_ignore_item(item) { continue }\n \n             let short = shortty(item).to_static_str();\n             let myname = match item.name {\n@@ -1394,27 +1386,18 @@ impl Context {\n         return map;\n     }\n \n-    fn ignore_private_item(&self, it: &clean::Item) -> bool {\n+    fn maybe_ignore_item(&self, it: &clean::Item) -> bool {\n         match it.inner {\n+            clean::StrippedItem(..) => true,\n             clean::ModuleItem(ref m) => {\n-                (m.items.is_empty() &&\n-                 it.doc_value().is_none() &&\n-                 it.visibility != Some(hir::Public)) ||\n-                (self.passes.contains(\"strip-private\") && it.visibility != Some(hir::Public))\n-            }\n-            clean::PrimitiveItem(..) => it.visibility != Some(hir::Public),\n+                it.doc_value().is_none() && m.items.is_empty() && it.visibility != Some(hir::Public)\n+            },\n             _ => false,\n         }\n     }\n }\n \n impl<'a> Item<'a> {\n-    fn ismodule(&self) -> bool {\n-        match self.item.inner {\n-            clean::ModuleItem(..) => true, _ => false\n-        }\n-    }\n-\n     /// Generate a url appropriate for an `href` attribute back to the source of\n     /// this item.\n     ///\n@@ -1457,10 +1440,11 @@ impl<'a> Item<'a> {\n         // know the span, so we plow forward and generate a proper url. The url\n         // has anchors for the line numbers that we're linking to.\n         } else if self.item.def_id.is_local() {\n-            self.cx.local_sources.get(&PathBuf::from(&self.item.source.filename)).map(|path| {\n+            let path = PathBuf::from(&self.item.source.filename);\n+            self.cx.shared.local_sources.get(&path).map(|path| {\n                 format!(\"{root}src/{krate}/{path}#{href}\",\n                         root = self.cx.root_path,\n-                        krate = self.cx.layout.krate,\n+                        krate = self.cx.shared.layout.krate,\n                         path = path,\n                         href = href)\n             })\n@@ -1495,6 +1479,7 @@ impl<'a> Item<'a> {\n \n impl<'a> fmt::Display for Item<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        debug_assert!(!self.item.is_stripped());\n         // Write the breadcrumb trail header for the top\n         write!(fmt, \"\\n<h1 class='fqn'><span class='in-band'>\")?;\n         match self.item.inner {\n@@ -1516,7 +1501,7 @@ impl<'a> fmt::Display for Item<'a> {\n         };\n         if !is_primitive {\n             let cur = &self.cx.current;\n-            let amt = if self.ismodule() { cur.len() - 1 } else { cur.len() };\n+            let amt = if self.item.is_mod() { cur.len() - 1 } else { cur.len() };\n             for (i, component) in cur.iter().enumerate().take(amt) {\n                 write!(fmt, \"<a href='{}index.html'>{}</a>::<wbr>\",\n                        repeat(\"../\").take(cur.len() - i - 1)\n@@ -1542,7 +1527,7 @@ impl<'a> fmt::Display for Item<'a> {\n         // [src] link in the downstream documentation will actually come back to\n         // this page, and this link will be auto-clicked. The `id` attribute is\n         // used to find the link to auto-click.\n-        if self.cx.include_sources && !is_primitive {\n+        if self.cx.shared.include_sources && !is_primitive {\n             if let Some(l) = self.href() {\n                 write!(fmt, \"<a id='src-{}' class='srclink' \\\n                               href='{}' title='{}'>[src]</a>\",\n@@ -1575,15 +1560,12 @@ impl<'a> fmt::Display for Item<'a> {\n }\n \n fn item_path(item: &clean::Item) -> String {\n-    match item.inner {\n-        clean::ModuleItem(..) => {\n-            format!(\"{}/index.html\", item.name.as_ref().unwrap())\n-        }\n-        _ => {\n-            format!(\"{}.{}.html\",\n-                    shortty(item).to_static_str(),\n-                    *item.name.as_ref().unwrap())\n-        }\n+    if item.is_mod() {\n+        format!(\"{}/index.html\", item.name.as_ref().unwrap())\n+    } else {\n+        format!(\"{}.{}.html\",\n+                shortty(item).to_static_str(),\n+                *item.name.as_ref().unwrap())\n     }\n }\n \n@@ -1626,7 +1608,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n     document(w, cx, item)?;\n \n     let mut indices = (0..items.len()).filter(|i| {\n-        !cx.ignore_private_item(&items[*i])\n+        !cx.maybe_ignore_item(&items[*i])\n     }).collect::<Vec<usize>>();\n \n     // the order of item types in the listing\n@@ -1670,6 +1652,9 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n     let mut curty = None;\n     for &idx in &indices {\n         let myitem = &items[idx];\n+        if myitem.is_stripped() {\n+            continue;\n+        }\n \n         let myty = Some(shortty(myitem));\n         if curty == Some(ItemType::ExternCrate) && myty == Some(ItemType::Import) {\n@@ -1774,7 +1759,7 @@ fn short_stability(item: &clean::Item, cx: &Context, show_reason: bool) -> Optio\n             format!(\"Deprecated{}{}\", since, Markdown(&reason))\n         } else if stab.level == stability::Unstable {\n             let unstable_extra = if show_reason {\n-                match (!stab.feature.is_empty(), &cx.issue_tracker_base_url, stab.issue) {\n+                match (!stab.feature.is_empty(), &cx.shared.issue_tracker_base_url, stab.issue) {\n                     (true, &Some(ref tracker_url), Some(issue_no)) if issue_no > 0 =>\n                         format!(\" (<code>{}</code> <a href=\\\"{}{}\\\">#{}</a>)\",\n                                 Escape(&stab.feature), tracker_url, issue_no, issue_no),\n@@ -2146,6 +2131,7 @@ fn render_assoc_item(w: &mut fmt::Formatter,\n                where_clause = WhereClause(g))\n     }\n     match item.inner {\n+        clean::StrippedItem(..) => Ok(()),\n         clean::TyMethodItem(ref m) => {\n             method(w, item, m.unsafety, hir::Constness::NotConst,\n                    m.abi, &m.generics, &m.self_, &m.decl, link)\n@@ -2182,8 +2168,7 @@ fn item_struct(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     document(w, cx, it)?;\n     let mut fields = s.fields.iter().filter(|f| {\n         match f.inner {\n-            clean::StructFieldItem(clean::HiddenStructField) => false,\n-            clean::StructFieldItem(clean::TypedStructField(..)) => true,\n+            clean::StructFieldItem(..) => true,\n             _ => false,\n         }\n     }).peekable();\n@@ -2273,7 +2258,7 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n             if let clean::VariantItem( Variant { kind: StructVariant(ref s) } ) = variant.inner {\n                 let fields = s.fields.iter().filter(|f| {\n                     match f.inner {\n-                        clean::StructFieldItem(clean::TypedStructField(..)) => true,\n+                        clean::StructFieldItem(..) => true,\n                         _ => false,\n                     }\n                 });\n@@ -2332,24 +2317,17 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n     match ty {\n         doctree::Plain => {\n             write!(w, \" {{\\n{}\", tab)?;\n-            let mut fields_stripped = false;\n             for field in fields {\n-                match field.inner {\n-                    clean::StructFieldItem(clean::HiddenStructField) => {\n-                        fields_stripped = true;\n-                    }\n-                    clean::StructFieldItem(clean::TypedStructField(ref ty)) => {\n-                        write!(w, \"    {}{}: {},\\n{}\",\n-                               VisSpace(field.visibility),\n-                               field.name.as_ref().unwrap(),\n-                               *ty,\n-                               tab)?;\n-                    }\n-                    _ => unreachable!(),\n-                };\n+                if let clean::StructFieldItem(ref ty) = field.inner {\n+                    write!(w, \"    {}{}: {},\\n{}\",\n+                           VisSpace(field.visibility),\n+                           field.name.as_ref().unwrap(),\n+                           *ty,\n+                           tab)?;\n+                }\n             }\n \n-            if fields_stripped {\n+            if it.has_stripped_fields().unwrap() {\n                 write!(w, \"    // some fields omitted\\n{}\", tab)?;\n             }\n             write!(w, \"}}\")?;\n@@ -2361,10 +2339,10 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n                     write!(w, \", \")?;\n                 }\n                 match field.inner {\n-                    clean::StructFieldItem(clean::HiddenStructField) => {\n+                    clean::StrippedItem(box clean::StructFieldItem(..)) => {\n                         write!(w, \"_\")?\n                     }\n-                    clean::StructFieldItem(clean::TypedStructField(ref ty)) => {\n+                    clean::StructFieldItem(ref ty) => {\n                         write!(w, \"{}{}\", VisSpace(field.visibility), *ty)?\n                     }\n                     _ => unreachable!()\n@@ -2540,6 +2518,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n                 assoc_type(w, item, bounds, default.as_ref(), link)?;\n                 write!(w, \"</code></h4>\\n\")?;\n             }\n+            clean::StrippedItem(..) => return Ok(()),\n             _ => panic!(\"can't make docs for trait item with name {:?}\", item.name)\n         }\n "}, {"sha": "f93ecb46228c2b4baca320809f6378321e0c5a19", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 24, "deletions": 36, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/bb561dac996d13174ac5286cd94ec8ab49dd97eb/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb561dac996d13174ac5286cd94ec8ab49dd97eb/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=bb561dac996d13174ac5286cd94ec8ab49dd97eb", "patch": "@@ -21,6 +21,7 @@ use clean::Item;\n use plugins;\n use fold;\n use fold::DocFolder;\n+use fold::FoldItem::Strip;\n \n /// Strip items marked `#[doc(hidden)]`\n pub fn strip_hidden(krate: clean::Crate) -> plugins::PluginResult {\n@@ -39,18 +40,12 @@ pub fn strip_hidden(krate: clean::Crate) -> plugins::PluginResult {\n \n                     // use a dedicated hidden item for given item type if any\n                     match i.inner {\n-                        clean::StructFieldItem(..) => {\n-                            return Some(clean::Item {\n-                                inner: clean::StructFieldItem(clean::HiddenStructField),\n-                                ..i\n-                            });\n-                        }\n-                        _ => {\n-                            return None;\n+                        clean::StructFieldItem(..) | clean::ModuleItem(..) => {\n+                            return Strip(i).fold()\n                         }\n+                        _ => return None,\n                     }\n                 }\n-\n                 self.fold_item_recur(i)\n             }\n         }\n@@ -125,36 +120,32 @@ struct Stripper<'a> {\n impl<'a> fold::DocFolder for Stripper<'a> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         match i.inner {\n+            clean::StrippedItem(..) => return Some(i),\n             // These items can all get re-exported\n             clean::TypedefItem(..) | clean::StaticItem(..) |\n             clean::StructItem(..) | clean::EnumItem(..) |\n             clean::TraitItem(..) | clean::FunctionItem(..) |\n             clean::VariantItem(..) | clean::MethodItem(..) |\n-            clean::ForeignFunctionItem(..) | clean::ForeignStaticItem(..) => {\n+            clean::ForeignFunctionItem(..) | clean::ForeignStaticItem(..) |\n+            clean::ConstantItem(..) => {\n                 if i.def_id.is_local() {\n                     if !self.access_levels.is_exported(i.def_id) {\n                         return None;\n                     }\n                 }\n             }\n \n-            clean::ConstantItem(..) => {\n-                if i.def_id.is_local() && !self.access_levels.is_exported(i.def_id) {\n-                    return None;\n-                }\n-            }\n-\n             clean::StructFieldItem(..) => {\n                 if i.visibility != Some(hir::Public) {\n-                    return Some(clean::Item {\n-                        inner: clean::StructFieldItem(clean::HiddenStructField),\n-                        ..i\n-                    })\n+                    return Strip(i).fold();\n                 }\n             }\n \n-            // handled below\n-            clean::ModuleItem(..) => {}\n+            clean::ModuleItem(..) => {\n+                if i.def_id.is_local() && i.visibility != Some(hir::Public) {\n+                    return Strip(self.fold_item_recur(i).unwrap()).fold()\n+                }\n+            }\n \n             // trait impls for private items should be stripped\n             clean::ImplItem(clean::Impl{\n@@ -165,7 +156,7 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n                 }\n             }\n             // handled in the `strip-priv-imports` pass\n-            clean::ExternCrateItem(..) | clean::ImportItem(_) => {}\n+            clean::ExternCrateItem(..) | clean::ImportItem(..) => {}\n \n             clean::DefaultImplItem(..) | clean::ImplItem(..) => {}\n \n@@ -187,7 +178,6 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n \n             // implementations of traits are always public.\n             clean::ImplItem(ref imp) if imp.trait_.is_some() => true,\n-\n             // Struct variant fields have inherited visibility\n             clean::VariantItem(clean::Variant {\n                 kind: clean::StructVariant(..)\n@@ -202,19 +192,17 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n             self.fold_item_recur(i)\n         };\n \n-        i.and_then(|i| {\n-            match i.inner {\n-                // emptied modules/impls have no need to exist\n-                clean::ModuleItem(ref m)\n-                    if m.items.is_empty() &&\n-                       i.doc_value().is_none() => None,\n-                clean::ImplItem(ref i) if i.items.is_empty() => None,\n-                _ => {\n-                    self.retained.insert(i.def_id);\n-                    Some(i)\n-                }\n+        i.and_then(|i| { match i.inner {\n+            // emptied modules/impls have no need to exist\n+            clean::ModuleItem(ref m)\n+                if m.items.is_empty() &&\n+                   i.doc_value().is_none() => None,\n+            clean::ImplItem(ref i) if i.items.is_empty() => None,\n+            _ => {\n+                self.retained.insert(i.def_id);\n+                Some(i)\n             }\n-        })\n+        }})\n     }\n }\n "}, {"sha": "5bd3b9c4f59e706448321db39f9bc58d32ec38e9", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb561dac996d13174ac5286cd94ec8ab49dd97eb/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb561dac996d13174ac5286cd94ec8ab49dd97eb/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=bb561dac996d13174ac5286cd94ec8ab49dd97eb", "patch": "@@ -431,7 +431,7 @@ impl Collector {\n                 // compiler failures are test failures\n                 should_panic: testing::ShouldPanic::No,\n             },\n-            testfn: testing::DynTestFn(Box::new(move|| {\n+            testfn: testing::DynTestFn(box move|| {\n                 runtest(&test,\n                         &cratename,\n                         cfgs,\n@@ -442,7 +442,7 @@ impl Collector {\n                         as_test_harness,\n                         compile_fail,\n                         &opts);\n-            }))\n+            })\n         });\n     }\n "}, {"sha": "2b061e3997d844b99bb4458e52fdf685da49739c", "filename": "src/test/auxiliary/reexp_stripped.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bb561dac996d13174ac5286cd94ec8ab49dd97eb/src%2Ftest%2Fauxiliary%2Freexp_stripped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb561dac996d13174ac5286cd94ec8ab49dd97eb/src%2Ftest%2Fauxiliary%2Freexp_stripped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Freexp_stripped.rs?ref=bb561dac996d13174ac5286cd94ec8ab49dd97eb", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use private::Quz;\n+pub use hidden::Bar;\n+\n+mod private {\n+    pub struct Quz;\n+}\n+\n+#[doc(hidden)]\n+pub mod hidden {\n+    pub struct Bar;\n+}"}, {"sha": "98e66e8c024bd3a49d48e574aa265db506cdba6b", "filename": "src/test/rustdoc/redirect.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/bb561dac996d13174ac5286cd94ec8ab49dd97eb/src%2Ftest%2Frustdoc%2Fredirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb561dac996d13174ac5286cd94ec8ab49dd97eb/src%2Ftest%2Frustdoc%2Fredirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fredirect.rs?ref=bb561dac996d13174ac5286cd94ec8ab49dd97eb", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:reexp_stripped.rs\n+// build-aux-docs\n+// ignore-cross-compile\n+\n+extern crate reexp_stripped;\n+\n+pub trait Foo {}\n+\n+// @has redirect/index.html\n+// @has - '//code' 'pub use reexp_stripped::Bar'\n+// @has - '//code/a' 'Bar'\n+// @has reexp_stripped/hidden/struct.Bar.html\n+// @has - '//p/a' '../../reexp_stripped/struct.Bar.html'\n+// @has 'reexp_stripped/struct.Bar.html'\n+#[doc(no_inline)]\n+pub use reexp_stripped::Bar;\n+impl Foo for Bar {}\n+\n+// @has redirect/index.html\n+// @has - '//code' 'pub use reexp_stripped::Quz'\n+// @has - '//code/a' 'Quz'\n+// @has reexp_stripped/private/struct.Quz.html\n+// @has - '//p/a' '../../reexp_stripped/struct.Quz.html'\n+// @has 'reexp_stripped/struct.Quz.html'\n+#[doc(no_inline)]\n+pub use reexp_stripped::Quz;\n+impl Foo for Quz {}\n+\n+mod private_no_inline {\n+    pub struct Qux;\n+    impl ::Foo for Qux {}\n+}\n+\n+// @has redirect/index.html\n+// @has - '//code' 'pub use private_no_inline::Qux'\n+// @!has - '//code/a' 'Qux'\n+#[doc(no_inline)]\n+pub use private_no_inline::Qux;"}, {"sha": "c4327f70728cb138d7d660b7f903c34f272d40e5", "filename": "src/test/rustdoc/structfields.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/bb561dac996d13174ac5286cd94ec8ab49dd97eb/src%2Ftest%2Frustdoc%2Fstructfields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb561dac996d13174ac5286cd94ec8ab49dd97eb/src%2Ftest%2Frustdoc%2Fstructfields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fstructfields.rs?ref=bb561dac996d13174ac5286cd94ec8ab49dd97eb", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// @has structfields/struct.Foo.html\n+pub struct Foo {\n+    // @has - //pre \"pub a: ()\"\n+    pub a: (),\n+    // @has - //pre \"// some fields omitted\"\n+    // @!has - //pre \"b: ()\"\n+    b: (),\n+    // @!has - //pre \"c: usize\"\n+    #[doc(hidden)]\n+    c: usize,\n+    // @has - //pre \"pub d: usize\"\n+    pub d: usize,\n+}\n+\n+// @has structfields/struct.Bar.html\n+pub struct Bar {\n+    // @has - //pre \"pub a: ()\"\n+    pub a: (),\n+    // @!has - //pre \"// some fields omitted\"\n+}\n+\n+// @has structfields/enum.Qux.html\n+pub enum Qux {\n+    Quz {\n+        // @has - //pre \"a: ()\"\n+        a: (),\n+        // @!has - //pre \"b: ()\"\n+        #[doc(hidden)]\n+        b: (),\n+        // @has - //pre \"c: usize\"\n+        c: usize,\n+        // @has - //pre \"// some fields omitted\"\n+    },\n+}"}]}