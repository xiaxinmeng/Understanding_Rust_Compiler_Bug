{"sha": "aa578de018ef29d6caac4bd4b71f5d3ffd61608b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhNTc4ZGUwMThlZjI5ZDZjYWFjNGJkNGI3MWY1ZDNmZmQ2MTYwOGI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-09-13T10:27:13Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-09-13T12:37:31Z"}, "message": "identify write locks by lvalues, not regions\n\nThis makes a new compile-fail test pass.", "tree": {"sha": "12061c539ab712779840791d642d84a1267857f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12061c539ab712779840791d642d84a1267857f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa578de018ef29d6caac4bd4b71f5d3ffd61608b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa578de018ef29d6caac4bd4b71f5d3ffd61608b", "html_url": "https://github.com/rust-lang/rust/commit/aa578de018ef29d6caac4bd4b71f5d3ffd61608b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa578de018ef29d6caac4bd4b71f5d3ffd61608b/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02a943b3fb5966aa326b1ec9986d568ec422c668", "url": "https://api.github.com/repos/rust-lang/rust/commits/02a943b3fb5966aa326b1ec9986d568ec422c668", "html_url": "https://github.com/rust-lang/rust/commit/02a943b3fb5966aa326b1ec9986d568ec422c668"}], "stats": {"total": 330, "additions": 234, "deletions": 96}, "files": [{"sha": "190e3018c7f415656c9a2b044e2519a8cecd1567", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa578de018ef29d6caac4bd4b71f5d3ffd61608b/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa578de018ef29d6caac4bd4b71f5d3ffd61608b/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=aa578de018ef29d6caac4bd4b71f5d3ffd61608b", "patch": "@@ -618,7 +618,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         }\n         for (field_index, operand) in operands.iter().enumerate() {\n             let value = self.eval_operand(operand)?;\n-            let field_dest = self.lvalue_field(dest, field_index, dest_ty, value.ty)?;\n+            let field_dest = self.lvalue_field(dest, mir::Field::new(field_index), dest_ty, value.ty)?;\n             self.write_value(value, field_dest)?;\n         }\n         Ok(())\n@@ -1466,7 +1466,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n     /// ensures this Value is not a ByRef\n     pub(super) fn follow_by_ref_value(\n-        &mut self,\n+        &self,\n         value: Value,\n         ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, Value> {\n@@ -1479,7 +1479,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     }\n \n     pub fn value_to_primval(\n-        &mut self,\n+        &self,\n         ValTy { value, ty } : ValTy<'tcx>,\n     ) -> EvalResult<'tcx, PrimVal> {\n         match self.follow_by_ref_value(value, ty)? {"}, {"sha": "7fb6ac4209f179c6099579b7d41d22d7a56c92b4", "filename": "src/librustc_mir/interpret/lvalue.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa578de018ef29d6caac4bd4b71f5d3ffd61608b/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa578de018ef29d6caac4bd4b71f5d3ffd61608b/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs?ref=aa578de018ef29d6caac4bd4b71f5d3ffd61608b", "patch": "@@ -218,12 +218,14 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     pub fn lvalue_field(\n         &mut self,\n         base: Lvalue,\n-        field_index: usize,\n+        field: mir::Field,\n         base_ty: Ty<'tcx>,\n         field_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, Lvalue> {\n-        let base_layout = self.type_layout(base_ty)?;\n         use rustc::ty::layout::Layout::*;\n+\n+        let base_layout = self.type_layout(base_ty)?;\n+        let field_index = field.index();\n         let (offset, packed) = match *base_layout {\n             Univariant { ref variant, .. } => (variant.offsets[field_index], variant.packed),\n \n@@ -405,7 +407,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         use rustc::mir::ProjectionElem::*;\n         let (ptr, extra) = match *proj_elem {\n             Field(field, field_ty) => {\n-                return self.lvalue_field(base, field.index(), base_ty, field_ty);\n+                return self.lvalue_field(base, field, base_ty, field_ty);\n             }\n \n             Downcast(_, variant) => {"}, {"sha": "bde79294adda50781d83abf8db995c44224352ae", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 86, "deletions": 53, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/aa578de018ef29d6caac4bd4b71f5d3ffd61608b/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa578de018ef29d6caac4bd4b71f5d3ffd61608b/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=aa578de018ef29d6caac4bd4b71f5d3ffd61608b", "patch": "@@ -9,7 +9,7 @@ use syntax::ast::Mutability;\n use rustc::middle::region;\n \n use super::{EvalResult, EvalErrorKind, PrimVal, Pointer, EvalContext, DynamicLifetime, Machine,\n-            RangeMap};\n+            RangeMap, AbsLvalue};\n \n ////////////////////////////////////////////////////////////////////////////////\n // Locks\n@@ -23,14 +23,29 @@ pub enum AccessKind {\n \n /// Information about a lock that is currently held.\n #[derive(Clone, Debug)]\n-struct LockInfo {\n+struct LockInfo<'tcx> {\n     /// Stores for which lifetimes (of the original write lock) we got\n     /// which suspensions.\n-    suspended: HashMap<DynamicLifetime, Vec<region::Scope>>,\n+    suspended: HashMap<WriteLockId<'tcx>, Vec<region::Scope>>,\n     /// The current state of the lock that's actually effective.\n     active: Lock,\n }\n \n+/// Write locks are identified by a stack frame and an \"abstract\" (untyped) lvalue.\n+/// It may be tempting to use the lifetime as identifier, but that does not work\n+/// for two reasons:\n+/// * First of all, due to subtyping, the same lock may be referred to with different\n+///   lifetimes.\n+/// * Secondly, different write locks may actually have the same lifetime.  See `test2`\n+///   in `run-pass/many_shr_bor.rs`.\n+/// The Id is \"captured\" when the lock is first suspended; at that point, the borrow checker\n+/// considers the path frozen and hence the Id remains stable.\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+struct WriteLockId<'tcx> {\n+    frame: usize,\n+    path: AbsLvalue<'tcx>,\n+}\n+\n #[derive(Clone, Debug, PartialEq)]\n pub enum Lock {\n     NoLock,\n@@ -39,14 +54,14 @@ pub enum Lock {\n }\n use self::Lock::*;\n \n-impl Default for LockInfo {\n+impl<'tcx> Default for LockInfo<'tcx> {\n     fn default() -> Self {\n         LockInfo::new(NoLock)\n     }\n }\n \n-impl LockInfo {\n-    fn new(lock: Lock) -> LockInfo {\n+impl<'tcx> LockInfo<'tcx> {\n+    fn new(lock: Lock) -> LockInfo<'tcx> {\n         LockInfo {\n             suspended: HashMap::new(),\n             active: lock,\n@@ -128,7 +143,7 @@ impl fmt::Debug for AllocId {\n }\n \n #[derive(Debug)]\n-pub struct Allocation<M> {\n+pub struct Allocation<'tcx, M> {\n     /// The actual bytes of the allocation.\n     /// Note that the bytes of a pointer represent the offset of the pointer\n     pub bytes: Vec<u8>,\n@@ -146,17 +161,17 @@ pub struct Allocation<M> {\n     /// Helps guarantee that stack allocations aren't deallocated via `rust_deallocate`\n     pub kind: MemoryKind<M>,\n     /// Memory regions that are locked by some function\n-    locks: RangeMap<LockInfo>,\n+    locks: RangeMap<LockInfo<'tcx>>,\n }\n \n-impl<M> Allocation<M> {\n-    fn check_locks<'tcx>(\n+impl<'tcx, M> Allocation<'tcx, M> {\n+    fn check_locks(\n         &self,\n         frame: Option<usize>,\n         offset: u64,\n         len: u64,\n         access: AccessKind,\n-    ) -> Result<(), LockInfo> {\n+    ) -> Result<(), LockInfo<'tcx>> {\n         if len == 0 {\n             return Ok(());\n         }\n@@ -237,7 +252,7 @@ pub struct Memory<'a, 'tcx, M: Machine<'tcx>> {\n     pub data: M::MemoryData,\n \n     /// Actual memory allocations (arbitrary bytes, may contain pointers into other allocations).\n-    alloc_map: HashMap<u64, Allocation<M::MemoryKinds>>,\n+    alloc_map: HashMap<u64, Allocation<'tcx, M::MemoryKinds>>,\n \n     /// The AllocId to assign to the next new regular allocation. Always incremented, never gets smaller.\n     next_alloc_id: u64,\n@@ -610,62 +625,72 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n \n     /// Release or suspend a write lock of the given lifetime prematurely.\n     /// When releasing, if there is a read lock or someone else's write lock, that's an error.\n-    /// We *do* accept relasing a NoLock, as this can happen when a local is first acquired and later force_allocate'd.\n+    /// If no lock is held, that's fine.  This can happen when e.g. a local is initialized\n+    /// from a constant, and then suspended.\n     /// When suspending, the same cases are fine; we just register an additional suspension.\n     pub(crate) fn suspend_write_lock(\n         &mut self,\n         ptr: MemoryPointer,\n         len: u64,\n-        lock_region: Option<region::Scope>,\n+        lock_path: &AbsLvalue<'tcx>,\n         suspend: Option<region::Scope>,\n     ) -> EvalResult<'tcx> {\n         assert!(len > 0);\n         let cur_frame = self.cur_frame;\n-        let lock_lft = DynamicLifetime {\n-            frame: cur_frame,\n-            region: lock_region,\n-        };\n         let alloc = self.get_mut_unchecked(ptr.alloc_id)?;\n \n         'locks: for lock in alloc.locks.iter_mut(ptr.offset, len) {\n             let is_our_lock = match lock.active {\n-                WriteLock(lft) => lft == lock_lft,\n+                WriteLock(lft) =>\n+                    // Double-check that we are holding the lock.\n+                    // (Due to subtyping, checking the region would not make any sense.)\n+                    lft.frame == cur_frame,\n                 ReadLock(_) | NoLock => false,\n             };\n             if is_our_lock {\n-                trace!(\"Releasing {:?} at {:?}\", lock.active, lock_lft);\n+                trace!(\"Releasing {:?}\", lock.active);\n                 // Disable the lock\n                 lock.active = NoLock;\n             } else {\n                 trace!(\n-                    \"Not touching {:?} at {:?} as its not our lock\",\n+                    \"Not touching {:?} as it is not our lock\",\n                     lock.active,\n-                    lock_lft\n                 );\n             }\n-            match suspend {\n-                Some(suspend_region) => {\n-                    trace!(\"Adding suspension to {:?} at {:?}\", lock.active, lock_lft);\n-                    // We just released this lock, so add a new suspension.\n-                    // FIXME: Really, if there ever already is a suspension when is_our_lock, or if there is no suspension when !is_our_lock, something is amiss.\n-                    // But this model is not good enough yet to prevent that.\n-                    lock.suspended\n-                        .entry(lock_lft)\n-                        .or_insert_with(|| Vec::new())\n-                        .push(suspend_region);\n+            // Check if we want to register a suspension\n+            if let Some(suspend_region) = suspend {\n+                let lock_id = WriteLockId {\n+                    frame: cur_frame,\n+                    path: lock_path.clone(),\n+                };\n+                trace!(\"Adding suspension to {:?}\", lock_id);\n+                let mut new_suspension = false;\n+                lock.suspended\n+                    .entry(lock_id)\n+                    // Remember whether we added a new suspension or not\n+                    .or_insert_with(|| { new_suspension = true; Vec::new() })\n+                    .push(suspend_region);\n+                // If the suspension is new, we should have owned this.\n+                // If there already was a suspension, we should NOT have owned this.\n+                if new_suspension == is_our_lock {\n+                    // All is well\n+                    continue 'locks;\n                 }\n-                None => {\n-                    // Make sure we did not try to release someone else's lock.\n-                    if !is_our_lock && lock.active != NoLock {\n-                        return err!(InvalidMemoryLockRelease {\n-                            ptr,\n-                            len,\n-                            frame: cur_frame,\n-                            lock: lock.active.clone(),\n-                        });\n-                    }\n+            } else {\n+                if !is_our_lock {\n+                    // All is well.\n+                    continue 'locks;\n                 }\n             }\n+            // If we get here, releasing this is an error except for NoLock.\n+            if lock.active != NoLock {\n+                return err!(InvalidMemoryLockRelease {\n+                    ptr,\n+                    len,\n+                    frame: cur_frame,\n+                    lock: lock.active.clone(),\n+                });\n+            }\n         }\n \n         Ok(())\n@@ -676,26 +701,27 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         &mut self,\n         ptr: MemoryPointer,\n         len: u64,\n+        lock_path: &AbsLvalue<'tcx>,\n         lock_region: Option<region::Scope>,\n         suspended_region: region::Scope,\n     ) -> EvalResult<'tcx> {\n         assert!(len > 0);\n         let cur_frame = self.cur_frame;\n-        let lock_lft = DynamicLifetime {\n+        let lock_id = WriteLockId {\n             frame: cur_frame,\n-            region: lock_region,\n+            path: lock_path.clone(),\n         };\n         let alloc = self.get_mut_unchecked(ptr.alloc_id)?;\n \n         for lock in alloc.locks.iter_mut(ptr.offset, len) {\n             // Check if we have a suspension here\n-            let (got_the_lock, remove_suspension) = match lock.suspended.get_mut(&lock_lft) {\n+            let (got_the_lock, remove_suspension) = match lock.suspended.get_mut(&lock_id) {\n                 None => {\n                     trace!(\"No suspension around, we can just acquire\");\n                     (true, false)\n                 }\n                 Some(suspensions) => {\n-                    trace!(\"Found suspension of {:?}, removing it\", lock_lft);\n+                    trace!(\"Found suspension of {:?}, removing it\", lock_id);\n                     // That's us!  Remove suspension (it should be in there).  The same suspension can\n                     // occur multiple times (when there are multiple shared borrows of this that have the same\n                     // lifetime); only remove one of them.\n@@ -715,12 +741,17 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             if remove_suspension {\n                 // with NLL, we could do that up in the match above...\n                 assert!(got_the_lock);\n-                lock.suspended.remove(&lock_lft);\n+                lock.suspended.remove(&lock_id);\n             }\n             if got_the_lock {\n                 match lock.active {\n                     ref mut active @ NoLock => {\n-                        *active = WriteLock(lock_lft);\n+                        *active = WriteLock(\n+                            DynamicLifetime {\n+                                frame: cur_frame,\n+                                region: lock_region,\n+                            }\n+                        );\n                     }\n                     _ => {\n                         return err!(MemoryAcquireConflict {\n@@ -770,8 +801,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n                 if lock_ended {\n                     lock.active = NoLock;\n                 }\n-                // Also clean up suspended write locks\n-                lock.suspended.retain(|lft, _suspensions| !has_ended(lft));\n+                // Also clean up suspended write locks when the function returns\n+                if ending_region.is_none() {\n+                    lock.suspended.retain(|id, _suspensions| id.frame != cur_frame);\n+                }\n             }\n             // Clean up the map\n             alloc.locks.retain(|lock| match lock.active {\n@@ -784,7 +817,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n \n /// Allocation accessors\n impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n-    pub fn get(&self, id: AllocId) -> EvalResult<'tcx, &Allocation<M::MemoryKinds>> {\n+    pub fn get(&self, id: AllocId) -> EvalResult<'tcx, &Allocation<'tcx, M::MemoryKinds>> {\n         match id.into_alloc_id_kind() {\n             AllocIdKind::Function(_) => err!(DerefFunctionPointer),\n             AllocIdKind::Runtime(id) => {\n@@ -799,7 +832,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     fn get_mut_unchecked(\n         &mut self,\n         id: AllocId,\n-    ) -> EvalResult<'tcx, &mut Allocation<M::MemoryKinds>> {\n+    ) -> EvalResult<'tcx, &mut Allocation<'tcx, M::MemoryKinds>> {\n         match id.into_alloc_id_kind() {\n             AllocIdKind::Function(_) => err!(DerefFunctionPointer),\n             AllocIdKind::Runtime(id) => {\n@@ -811,7 +844,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         }\n     }\n \n-    fn get_mut(&mut self, id: AllocId) -> EvalResult<'tcx, &mut Allocation<M::MemoryKinds>> {\n+    fn get_mut(&mut self, id: AllocId) -> EvalResult<'tcx, &mut Allocation<'tcx, M::MemoryKinds>> {\n         let alloc = self.get_mut_unchecked(id)?;\n         if alloc.mutable == Mutability::Mutable {\n             Ok(alloc)"}, {"sha": "08837c4fb6d7805abab6ebb03141285421e0d749", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa578de018ef29d6caac4bd4b71f5d3ffd61608b/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa578de018ef29d6caac4bd4b71f5d3ffd61608b/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=aa578de018ef29d6caac4bd4b71f5d3ffd61608b", "patch": "@@ -39,4 +39,4 @@ pub use self::const_eval::{eval_body_as_integer, eval_body_as_primval};\n \n pub use self::machine::Machine;\n \n-pub use self::validation::ValidationQuery;\n+pub use self::validation::{ValidationQuery, AbsLvalue};"}, {"sha": "b379fa735c9db40691fb91a3fbbfdf10c7a77b41", "filename": "src/librustc_mir/interpret/validation.rs", "status": "modified", "additions": 113, "deletions": 34, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/aa578de018ef29d6caac4bd4b71f5d3ffd61608b/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa578de018ef29d6caac4bd4b71f5d3ffd61608b/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs?ref=aa578de018ef29d6caac4bd4b71f5d3ffd61608b", "patch": "@@ -1,4 +1,4 @@\n-use rustc::hir::Mutability;\n+use rustc::hir::{self, Mutability};\n use rustc::hir::Mutability::*;\n use rustc::mir::{self, ValidationOp, ValidationOperand};\n use rustc::ty::{self, Ty, TypeFoldable, TyCtxt};\n@@ -7,11 +7,12 @@ use rustc::traits;\n use rustc::infer::InferCtxt;\n use rustc::traits::Reveal;\n use rustc::middle::region;\n+use rustc_data_structures::indexed_vec::Idx;\n \n use super::{EvalError, EvalResult, EvalErrorKind, EvalContext, DynamicLifetime, AccessKind, Value,\n-            Lvalue, LvalueExtra, Machine};\n+            Lvalue, LvalueExtra, Machine, ValTy};\n \n-pub type ValidationQuery<'tcx> = ValidationOperand<'tcx, Lvalue>;\n+pub type ValidationQuery<'tcx> = ValidationOperand<'tcx, (AbsLvalue<'tcx>, Lvalue)>;\n \n #[derive(Copy, Clone, Debug, PartialEq)]\n enum ValidationMode {\n@@ -31,8 +32,77 @@ impl ValidationMode {\n     }\n }\n \n-// Validity checks\n+// Abstract lvalues\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum AbsLvalue<'tcx> {\n+    Local(mir::Local),\n+    Static(hir::def_id::DefId),\n+    Projection(Box<AbsLvalueProjection<'tcx>>),\n+}\n+\n+type AbsLvalueProjection<'tcx> = mir::Projection<'tcx, AbsLvalue<'tcx>, u64, ()>;\n+type AbsLvalueElem<'tcx> = mir::ProjectionElem<'tcx, u64, ()>;\n+\n+impl<'tcx> AbsLvalue<'tcx> {\n+    pub fn field(self, f: mir::Field) -> AbsLvalue<'tcx> {\n+        self.elem(mir::ProjectionElem::Field(f, ()))\n+    }\n+\n+    pub fn deref(self) -> AbsLvalue<'tcx> {\n+        self.elem(mir::ProjectionElem::Deref)\n+    }\n+\n+    pub fn downcast(self, adt_def: &'tcx ty::AdtDef, variant_index: usize) -> AbsLvalue<'tcx> {\n+        self.elem(mir::ProjectionElem::Downcast(adt_def, variant_index))\n+    }\n+\n+    pub fn index(self, index: u64) -> AbsLvalue<'tcx> {\n+        self.elem(mir::ProjectionElem::Index(index))\n+    }\n+\n+    fn elem(self, elem: AbsLvalueElem<'tcx>) -> AbsLvalue<'tcx> {\n+        AbsLvalue::Projection(Box::new(AbsLvalueProjection {\n+            base: self,\n+            elem,\n+        }))\n+    }\n+}\n+\n impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n+    fn abstract_lvalue_projection(&self, proj: &mir::LvalueProjection<'tcx>) -> EvalResult<'tcx, AbsLvalueProjection<'tcx>> {\n+        use self::mir::ProjectionElem::*;\n+\n+        let elem = match proj.elem {\n+            Deref => Deref,\n+            Field(f, _) => Field(f, ()),\n+            Index(v) => {\n+                let value = self.frame().get_local(v)?;\n+                let ty = self.tcx.types.usize;\n+                let n = self.value_to_primval(ValTy { value, ty })?.to_u64()?;\n+                Index(n)\n+            },\n+            ConstantIndex { offset, min_length, from_end } =>\n+                ConstantIndex { offset, min_length, from_end },\n+            Subslice { from, to } =>\n+                Subslice { from, to },\n+            Downcast(adt, sz) => Downcast(adt, sz),\n+        };\n+        Ok(AbsLvalueProjection {\n+            base: self.abstract_lvalue(&proj.base)?,\n+            elem\n+        })\n+    }\n+\n+    fn abstract_lvalue(&self, lval: &mir::Lvalue<'tcx>) -> EvalResult<'tcx, AbsLvalue<'tcx>> {\n+        Ok(match lval {\n+            &mir::Lvalue::Local(l) => AbsLvalue::Local(l),\n+            &mir::Lvalue::Static(ref s) => AbsLvalue::Static(s.def_id),\n+            &mir::Lvalue::Projection(ref p) =>\n+                AbsLvalue::Projection(Box::new(self.abstract_lvalue_projection(&*p)?)),\n+        })\n+    }\n+\n+    // Validity checks\n     pub(crate) fn validation_op(\n         &mut self,\n         op: ValidationOp,\n@@ -79,8 +149,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         // We need to monomorphize ty *without* erasing lifetimes\n         let ty = operand.ty.subst(self.tcx, self.substs());\n         let lval = self.eval_lvalue(&operand.lval)?;\n+        let abs_lval = self.abstract_lvalue(&operand.lval)?;\n         let query = ValidationQuery {\n-            lval,\n+            lval: (abs_lval, lval),\n             ty,\n             re: operand.re,\n             mutbl: operand.mutbl,\n@@ -264,12 +335,13 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         mode: ValidationMode,\n     ) -> EvalResult<'tcx> {\n         // TODO: Maybe take visibility/privacy into account.\n-        for (idx, field) in variant.fields.iter().enumerate() {\n-            let field_ty = field.ty(self.tcx, subst);\n-            let field_lvalue = self.lvalue_field(query.lval, idx, query.ty, field_ty)?;\n+        for (idx, field_def) in variant.fields.iter().enumerate() {\n+            let field_ty = field_def.ty(self.tcx, subst);\n+            let field = mir::Field::new(idx);\n+            let field_lvalue = self.lvalue_field(query.lval.1, field, query.ty, field_ty)?;\n             self.validate(\n                 ValidationQuery {\n-                    lval: field_lvalue,\n+                    lval: (query.lval.0.clone().field(field), field_lvalue),\n                     ty: field_ty,\n                     ..query\n                 },\n@@ -282,6 +354,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n     fn validate_ptr(\n         &mut self,\n         val: Value,\n+        abs_lval: AbsLvalue<'tcx>,\n         pointee_ty: Ty<'tcx>,\n         re: Option<region::Scope>,\n         mutbl: Mutability,\n@@ -296,7 +369,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         let pointee_lvalue = self.val_to_lvalue(val, pointee_ty)?;\n         self.validate(\n             ValidationQuery {\n-                lval: pointee_lvalue,\n+                lval: (abs_lval.deref(), pointee_lvalue),\n                 ty: pointee_ty,\n                 re,\n                 mutbl,\n@@ -345,7 +418,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         // HACK: For now, bail out if we hit a dead local during recovery (can happen because sometimes we have\n         // StorageDead before EndRegion due to https://github.com/rust-lang/rust/issues/43481).\n         // TODO: We should rather fix the MIR.\n-        match query.lval {\n+        match query.lval.1 {\n             Lvalue::Local { frame, local } => {\n                 let res = self.stack[frame].get_local(local);\n                 match (res, mode) {\n@@ -380,7 +453,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             // Tracking the same state for locals not backed by memory would just duplicate too\n             // much machinery.\n             // FIXME: We ignore alignment.\n-            let (ptr, extra) = self.force_allocation(query.lval)?.to_ptr_extra_aligned();\n+            let (ptr, extra) = self.force_allocation(query.lval.1)?.to_ptr_extra_aligned();\n             // Determine the size\n             // FIXME: Can we reuse size_and_align_of_dst for Lvalues?\n             let len = match self.type_size(query.ty)? {\n@@ -431,6 +504,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                                 self.memory.recover_write_lock(\n                                     ptr,\n                                     len,\n+                                    &query.lval.0,\n                                     query.re,\n                                     ending_ce,\n                                 )?\n@@ -439,7 +513,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                                 self.memory.suspend_write_lock(\n                                     ptr,\n                                     len,\n-                                    query.re,\n+                                    &query.lval.0,\n                                     suspended_ce,\n                                 )?\n                             }\n@@ -465,7 +539,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                       ty: pointee_ty,\n                       mutbl,\n                   }) => {\n-                let val = self.read_lvalue(query.lval)?;\n+                let val = self.read_lvalue(query.lval.1)?;\n                 // Sharing restricts our context\n                 if mutbl == MutImmutable {\n                     query.mutbl = MutImmutable;\n@@ -480,14 +554,14 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                         _ => {}\n                     }\n                 }\n-                self.validate_ptr(val, pointee_ty, query.re, query.mutbl, mode)\n+                self.validate_ptr(val, query.lval.0, pointee_ty, query.re, query.mutbl, mode)\n             }\n             TyAdt(adt, _) if adt.is_box() => {\n-                let val = self.read_lvalue(query.lval)?;\n-                self.validate_ptr(val, query.ty.boxed_ty(), query.re, query.mutbl, mode)\n+                let val = self.read_lvalue(query.lval.1)?;\n+                self.validate_ptr(val, query.lval.0, query.ty.boxed_ty(), query.re, query.mutbl, mode)\n             }\n             TyFnPtr(_sig) => {\n-                let ptr = self.read_lvalue(query.lval)?\n+                let ptr = self.read_lvalue(query.lval.1)?\n                     .into_ptr(&self.memory)?\n                     .to_ptr()?;\n                 self.memory.get_fn(ptr)?;\n@@ -502,7 +576,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n \n             // Compound types\n             TySlice(elem_ty) => {\n-                let len = match query.lval {\n+                let len = match query.lval.1 {\n                     Lvalue::Ptr { extra: LvalueExtra::Length(len), .. } => len,\n                     _ => {\n                         bug!(\n@@ -512,10 +586,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                     }\n                 };\n                 for i in 0..len {\n-                    let inner_lvalue = self.lvalue_index(query.lval, query.ty, i)?;\n+                    let inner_lvalue = self.lvalue_index(query.lval.1, query.ty, i)?;\n                     self.validate(\n                         ValidationQuery {\n-                            lval: inner_lvalue,\n+                            lval: (query.lval.0.clone().index(i), inner_lvalue),\n                             ty: elem_ty,\n                             ..query\n                         },\n@@ -527,10 +601,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             TyArray(elem_ty, len) => {\n                 let len = len.val.to_const_int().unwrap().to_u64().unwrap();\n                 for i in 0..len {\n-                    let inner_lvalue = self.lvalue_index(query.lval, query.ty, i as u64)?;\n+                    let inner_lvalue = self.lvalue_index(query.lval.1, query.ty, i as u64)?;\n                     self.validate(\n                         ValidationQuery {\n-                            lval: inner_lvalue,\n+                            lval: (query.lval.0.clone().index(i as u64), inner_lvalue),\n                             ty: elem_ty,\n                             ..query\n                         },\n@@ -541,7 +615,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             }\n             TyDynamic(_data, _region) => {\n                 // Check that this is a valid vtable\n-                let vtable = match query.lval {\n+                let vtable = match query.lval.1 {\n                     Lvalue::Ptr { extra: LvalueExtra::Vtable(vtable), .. } => vtable,\n                     _ => {\n                         bug!(\n@@ -569,7 +643,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                 match adt.adt_kind() {\n                     AdtKind::Enum => {\n                         // TODO: Can we get the discriminant without forcing an allocation?\n-                        let ptr = self.force_allocation(query.lval)?.to_ptr()?;\n+                        let ptr = self.force_allocation(query.lval.1)?.to_ptr()?;\n                         let discr = self.read_discriminant_value(ptr, query.ty)?;\n \n                         // Get variant index for discriminant\n@@ -585,11 +659,14 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n                         if variant.fields.len() > 0 {\n                             // Downcast to this variant, if needed\n                             let lval = if adt.variants.len() > 1 {\n-                                self.eval_lvalue_projection(\n-                                    query.lval,\n-                                    query.ty,\n-                                    &mir::ProjectionElem::Downcast(adt, variant_idx),\n-                                )?\n+                                (\n+                                    query.lval.0.downcast(adt, variant_idx),\n+                                    self.eval_lvalue_projection(\n+                                        query.lval.1,\n+                                        query.ty,\n+                                        &mir::ProjectionElem::Downcast(adt, variant_idx),\n+                                    )?,\n+                                )\n                             } else {\n                                 query.lval\n                             };\n@@ -618,10 +695,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             }\n             TyTuple(ref types, _) => {\n                 for (idx, field_ty) in types.iter().enumerate() {\n-                    let field_lvalue = self.lvalue_field(query.lval, idx, query.ty, field_ty)?;\n+                    let field = mir::Field::new(idx);\n+                    let field_lvalue = self.lvalue_field(query.lval.1, field, query.ty, field_ty)?;\n                     self.validate(\n                         ValidationQuery {\n-                            lval: field_lvalue,\n+                            lval: (query.lval.0.clone().field(field), field_lvalue),\n                             ty: field_ty,\n                             ..query\n                         },\n@@ -632,10 +710,11 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n             }\n             TyClosure(def_id, ref closure_substs) => {\n                 for (idx, field_ty) in closure_substs.upvar_tys(def_id, self.tcx).enumerate() {\n-                    let field_lvalue = self.lvalue_field(query.lval, idx, query.ty, field_ty)?;\n+                    let field = mir::Field::new(idx);\n+                    let field_lvalue = self.lvalue_field(query.lval.1, field, query.ty, field_ty)?;\n                     self.validate(\n                         ValidationQuery {\n-                            lval: field_lvalue,\n+                            lval: (query.lval.0.clone().field(field), field_lvalue),\n                             ty: field_ty,\n                             ..query\n                         },"}, {"sha": "b352346114d7f2943bbc305431c168280007f68e", "filename": "tests/compile-fail/validation_lock_confusion.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/aa578de018ef29d6caac4bd4b71f5d3ffd61608b/tests%2Fcompile-fail%2Fvalidation_lock_confusion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa578de018ef29d6caac4bd4b71f5d3ffd61608b/tests%2Fcompile-fail%2Fvalidation_lock_confusion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidation_lock_confusion.rs?ref=aa578de018ef29d6caac4bd4b71f5d3ffd61608b", "patch": "@@ -0,0 +1,24 @@\n+// Make sure validation can handle many overlapping shared borrows for different parts of a data structure\n+#![allow(unused_variables)]\n+use std::cell::RefCell;\n+\n+fn evil(x: *mut i32) {\n+    unsafe { *x = 0; } //~ ERROR: in conflict with lock WriteLock\n+}\n+\n+fn test(r: &mut RefCell<i32>) {\n+    let x = &*r; // releasing write lock, first suspension recorded\n+    let mut x_ref = x.borrow_mut();\n+    let x_inner : &mut i32 = &mut *x_ref; // new inner write lock, with same lifetime as outer lock\n+    {\n+        let x_inner_shr = &*x_inner; // releasing inner write lock, recording suspension\n+        let y = &*r; // second suspension for the outer write lock\n+        let x_inner_shr2 = &*x_inner; // 2nd suspension for inner write lock\n+    }\n+    // If the two locks are mixed up, here we should have a write lock, but we do not.\n+    evil(x_inner as *mut _);\n+}\n+\n+fn main() {\n+    test(&mut RefCell::new(0));\n+}"}, {"sha": "393bafebfe4d6cde0fb5bc832358d05fe208fdeb", "filename": "tests/run-pass/many_shr_bor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa578de018ef29d6caac4bd4b71f5d3ffd61608b/tests%2Frun-pass%2Fmany_shr_bor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa578de018ef29d6caac4bd4b71f5d3ffd61608b/tests%2Frun-pass%2Fmany_shr_bor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fmany_shr_bor.rs?ref=aa578de018ef29d6caac4bd4b71f5d3ffd61608b", "patch": "@@ -1,4 +1,4 @@\n-// Make sure validation can handle many overlapping shared borrows for difference parts of a data structure\n+// Make sure validation can handle many overlapping shared borrows for different parts of a data structure\n #![allow(unused_variables)]\n use std::cell::RefCell;\n \n@@ -24,7 +24,7 @@ fn test1() {\n fn test2(r: &mut RefCell<i32>) {\n     let x = &*r; // releasing write lock, first suspension recorded\n     let mut x_ref = x.borrow_mut();\n-    let x_inner : &mut i32 = &mut *x_ref;\n+    let x_inner : &mut i32 = &mut *x_ref; // new inner write lock, with same lifetime as outer lock\n     let x_inner_shr = &*x_inner; // releasing inner write lock, recording suspension\n     let y = &*r; // second suspension for the outer write lock\n     let x_inner_shr2 = &*x_inner; // 2nd suspension for inner write lock"}]}