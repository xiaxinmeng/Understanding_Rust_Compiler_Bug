{"sha": "a950c37394cf45428c4852359c803e5a3c194ee6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5NTBjMzczOTRjZjQ1NDI4YzQ4NTIzNTljODAzZTVhM2MxOTRlZTY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-05-02T19:03:34Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-05-11T18:52:25Z"}, "message": "replace the type generalizer with one based on variance", "tree": {"sha": "a09b276ee3111dabeddd395152d014d05b983b3f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a09b276ee3111dabeddd395152d014d05b983b3f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a950c37394cf45428c4852359c803e5a3c194ee6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a950c37394cf45428c4852359c803e5a3c194ee6", "html_url": "https://github.com/rust-lang/rust/commit/a950c37394cf45428c4852359c803e5a3c194ee6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a950c37394cf45428c4852359c803e5a3c194ee6/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24ea08e9b7c206ee7a0de76b68072e46fc230cbd", "url": "https://api.github.com/repos/rust-lang/rust/commits/24ea08e9b7c206ee7a0de76b68072e46fc230cbd", "html_url": "https://github.com/rust-lang/rust/commit/24ea08e9b7c206ee7a0de76b68072e46fc230cbd"}], "stats": {"total": 211, "additions": 146, "deletions": 65}, "files": [{"sha": "ac78d53c02c50006c37f99d013b32acaeda88bc2", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 86, "deletions": 35, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/a950c37394cf45428c4852359c803e5a3c194ee6/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a950c37394cf45428c4852359c803e5a3c194ee6/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=a950c37394cf45428c4852359c803e5a3c194ee6", "patch": "@@ -42,8 +42,7 @@ use super::{MiscVariable, TypeTrace};\n use ty::{IntType, UintType};\n use ty::{self, Ty, TyCtxt};\n use ty::error::TypeError;\n-use ty::fold::TypeFoldable;\n-use ty::relate::{RelateResult, TypeRelation};\n+use ty::relate::{self, Relate, RelateResult, TypeRelation};\n use traits::PredicateObligations;\n \n use syntax::ast;\n@@ -207,7 +206,7 @@ impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n         // `'?2` and `?3` are fresh region/type inference\n         // variables. (Down below, we will relate `a_ty <: b_ty`,\n         // adding constraints like `'x: '?2` and `?1 <: ?3`.)\n-        let b_ty = self.generalize(a_ty, b_vid, dir == EqTo)?;\n+        let b_ty = self.generalize(a_ty, b_vid, dir)?;\n         debug!(\"instantiate(a_ty={:?}, dir={:?}, b_vid={:?}, generalized b_ty={:?})\",\n                a_ty, dir, b_vid, b_ty);\n         self.infcx.type_variables.borrow_mut().instantiate(b_vid, b_ty);\n@@ -241,39 +240,77 @@ impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n     fn generalize(&self,\n                   ty: Ty<'tcx>,\n                   for_vid: ty::TyVid,\n-                  is_eq_relation: bool)\n+                  dir: RelationDir)\n                   -> RelateResult<'tcx, Ty<'tcx>>\n     {\n+        // Determine the ambient variance within which `ty` appears.\n+        // The surrounding equation is:\n+        //\n+        //     ty [op] ty2\n+        //\n+        // where `op` is either `==`, `<:`, or `:>`. This maps quite\n+        // naturally.\n+        let ambient_variance = match dir {\n+            RelationDir::EqTo => ty::Invariant,\n+            RelationDir::SubtypeOf => ty::Covariant,\n+            RelationDir::SupertypeOf => ty::Contravariant,\n+        };\n+\n         let mut generalize = Generalizer {\n             infcx: self.infcx,\n             span: self.trace.cause.span,\n             for_vid_sub_root: self.infcx.type_variables.borrow_mut().sub_root_var(for_vid),\n-            is_eq_relation: is_eq_relation,\n-            cycle_detected: false\n+            ambient_variance: ambient_variance,\n         };\n-        let u = ty.fold_with(&mut generalize);\n-        if generalize.cycle_detected {\n-            Err(TypeError::CyclicTy)\n-        } else {\n-            Ok(u)\n-        }\n+\n+        generalize.relate(&ty, &ty)\n     }\n }\n \n struct Generalizer<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n     span: Span,\n     for_vid_sub_root: ty::TyVid,\n-    is_eq_relation: bool,\n-    cycle_detected: bool,\n+    ambient_variance: ty::Variance,\n }\n \n-impl<'cx, 'gcx, 'tcx> ty::fold::TypeFolder<'gcx, 'tcx> for Generalizer<'cx, 'gcx, 'tcx> {\n-    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'gcx, 'tcx> {\n+impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'cx, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+    fn tag(&self) -> &'static str {\n+        \"Generalizer\"\n+    }\n+\n+    fn a_is_expected(&self) -> bool {\n+        true\n+    }\n+\n+    fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n+                  -> RelateResult<'tcx, ty::Binder<T>>\n+        where T: Relate<'tcx>\n+    {\n+        Ok(ty::Binder(self.relate(a.skip_binder(), b.skip_binder())?))\n+    }\n+\n+    fn relate_with_variance<T: Relate<'tcx>>(&mut self,\n+                                             variance: ty::Variance,\n+                                             a: &T,\n+                                             b: &T)\n+                                             -> RelateResult<'tcx, T>\n+    {\n+        let old_ambient_variance = self.ambient_variance;\n+        self.ambient_variance = self.ambient_variance.xform(variance);\n+\n+        let result = self.relate(a, b);\n+        self.ambient_variance = old_ambient_variance;\n+        result\n+    }\n+\n+    fn tys(&mut self, t: Ty<'tcx>, t2: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        assert_eq!(t, t2); // we are abusing TypeRelation here; both LHS and RHS ought to be ==\n+\n         // Check to see whether the type we are genealizing references\n         // any other type variable related to `vid` via\n         // subtyping. This is basically our \"occurs check\", preventing\n@@ -286,41 +323,54 @@ impl<'cx, 'gcx, 'tcx> ty::fold::TypeFolder<'gcx, 'tcx> for Generalizer<'cx, 'gcx\n                 if sub_vid == self.for_vid_sub_root {\n                     // If sub-roots are equal, then `for_vid` and\n                     // `vid` are related via subtyping.\n-                    self.cycle_detected = true;\n-                    self.tcx().types.err\n+                    return Err(TypeError::CyclicTy);\n                 } else {\n                     match variables.probe_root(vid) {\n                         Some(u) => {\n                             drop(variables);\n-                            self.fold_ty(u)\n+                            self.relate(&u, &u)\n                         }\n                         None => {\n-                            if !self.is_eq_relation {\n-                                let origin = variables.origin(vid);\n-                                let new_var_id = variables.new_var(false, origin, None);\n-                                let u = self.tcx().mk_var(new_var_id);\n-                                debug!(\"generalize: replacing original vid={:?} with new={:?}\",\n-                                       vid, u);\n-                                u\n-                            } else {\n-                                t\n+                            match self.ambient_variance {\n+                                ty::Invariant => Ok(t),\n+\n+                                ty::Bivariant | ty::Covariant | ty::Contravariant => {\n+                                    let origin = variables.origin(vid);\n+                                    let new_var_id = variables.new_var(false, origin, None);\n+                                    let u = self.tcx().mk_var(new_var_id);\n+                                    debug!(\"generalize: replacing original vid={:?} with new={:?}\",\n+                                           vid, u);\n+                                    Ok(u)\n+                                }\n                             }\n                         }\n                     }\n                 }\n             }\n+            ty::TyInfer(ty::IntVar(_)) |\n+            ty::TyInfer(ty::FloatVar(_)) => {\n+                // No matter what mode we are in,\n+                // integer/floating-point types must be equal to be\n+                // relatable.\n+                Ok(t)\n+            }\n             _ => {\n-                t.super_fold_with(self)\n+                relate::super_relate_tys(self, t, t)\n             }\n         }\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+    fn regions(&mut self, r: ty::Region<'tcx>, r2: ty::Region<'tcx>)\n+               -> RelateResult<'tcx, ty::Region<'tcx>> {\n+        assert_eq!(r, r2); // we are abusing TypeRelation here; both LHS and RHS ought to be ==\n+\n         match *r {\n             // Never make variables for regions bound within the type itself,\n             // nor for erased regions.\n             ty::ReLateBound(..) |\n-            ty::ReErased => { return r; }\n+            ty::ReErased => {\n+                return Ok(r);\n+            }\n \n             // Early-bound regions should really have been substituted away before\n             // we get to this point.\n@@ -342,15 +392,16 @@ impl<'cx, 'gcx, 'tcx> ty::fold::TypeFolder<'gcx, 'tcx> for Generalizer<'cx, 'gcx\n             ty::ReScope(..) |\n             ty::ReVar(..) |\n             ty::ReFree(..) => {\n-                if self.is_eq_relation {\n-                    return r;\n+                match self.ambient_variance {\n+                    ty::Invariant => return Ok(r),\n+                    ty::Bivariant | ty::Covariant | ty::Contravariant => (),\n                 }\n             }\n         }\n \n         // FIXME: This is non-ideal because we don't give a\n         // very descriptive origin for this region variable.\n-        self.infcx.next_region_var(MiscVariable(self.span))\n+        Ok(self.infcx.next_region_var(MiscVariable(self.span)))\n     }\n }\n "}, {"sha": "f5d510c11ae9dd64d1f48b4c3d021b7f29c6e334", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a950c37394cf45428c4852359c803e5a3c194ee6/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a950c37394cf45428c4852359c803e5a3c194ee6/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=a950c37394cf45428c4852359c803e5a3c194ee6", "patch": "@@ -330,6 +330,66 @@ pub struct CrateVariancesMap {\n     pub empty_variance: Rc<Vec<ty::Variance>>,\n }\n \n+impl Variance {\n+    /// `a.xform(b)` combines the variance of a context with the\n+    /// variance of a type with the following meaning.  If we are in a\n+    /// context with variance `a`, and we encounter a type argument in\n+    /// a position with variance `b`, then `a.xform(b)` is the new\n+    /// variance with which the argument appears.\n+    ///\n+    /// Example 1:\n+    ///\n+    ///     *mut Vec<i32>\n+    ///\n+    /// Here, the \"ambient\" variance starts as covariant. `*mut T` is\n+    /// invariant with respect to `T`, so the variance in which the\n+    /// `Vec<i32>` appears is `Covariant.xform(Invariant)`, which\n+    /// yields `Invariant`. Now, the type `Vec<T>` is covariant with\n+    /// respect to its type argument `T`, and hence the variance of\n+    /// the `i32` here is `Invariant.xform(Covariant)`, which results\n+    /// (again) in `Invariant`.\n+    ///\n+    /// Example 2:\n+    ///\n+    ///     fn(*const Vec<i32>, *mut Vec<i32)\n+    ///\n+    /// The ambient variance is covariant. A `fn` type is\n+    /// contravariant with respect to its parameters, so the variance\n+    /// within which both pointer types appear is\n+    /// `Covariant.xform(Contravariant)`, or `Contravariant`.  `*const\n+    /// T` is covariant with respect to `T`, so the variance within\n+    /// which the first `Vec<i32>` appears is\n+    /// `Contravariant.xform(Covariant)` or `Contravariant`.  The same\n+    /// is true for its `i32` argument. In the `*mut T` case, the\n+    /// variance of `Vec<i32>` is `Contravariant.xform(Invariant)`,\n+    /// and hence the outermost type is `Invariant` with respect to\n+    /// `Vec<i32>` (and its `i32` argument).\n+    ///\n+    /// Source: Figure 1 of \"Taming the Wildcards:\n+    /// Combining Definition- and Use-Site Variance\" published in PLDI'11.\n+    pub fn xform(self, v: ty::Variance) -> ty::Variance {\n+        match (self, v) {\n+            // Figure 1, column 1.\n+            (ty::Covariant, ty::Covariant) => ty::Covariant,\n+            (ty::Covariant, ty::Contravariant) => ty::Contravariant,\n+            (ty::Covariant, ty::Invariant) => ty::Invariant,\n+            (ty::Covariant, ty::Bivariant) => ty::Bivariant,\n+\n+            // Figure 1, column 2.\n+            (ty::Contravariant, ty::Covariant) => ty::Contravariant,\n+            (ty::Contravariant, ty::Contravariant) => ty::Covariant,\n+            (ty::Contravariant, ty::Invariant) => ty::Invariant,\n+            (ty::Contravariant, ty::Bivariant) => ty::Bivariant,\n+\n+            // Figure 1, column 3.\n+            (ty::Invariant, _) => ty::Invariant,\n+\n+            // Figure 1, column 4.\n+            (ty::Bivariant, _) => ty::Bivariant,\n+        }\n+    }\n+}\n+\n #[derive(Clone, Copy, Debug, RustcDecodable, RustcEncodable)]\n pub struct MethodCallee<'tcx> {\n     /// Impl method ID, for inherent methods, or trait method ID, otherwise."}, {"sha": "cb2ee7dd1bcda5c7b89bcc4fda7a95e6d543f81c", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a950c37394cf45428c4852359c803e5a3c194ee6/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a950c37394cf45428c4852359c803e5a3c194ee6/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=a950c37394cf45428c4852359c803e5a3c194ee6", "patch": "@@ -27,7 +27,6 @@ use rustc_data_structures::transitive_relation::TransitiveRelation;\n \n use super::terms::*;\n use super::terms::VarianceTerm::*;\n-use super::xform::*;\n \n pub struct ConstraintContext<'a, 'tcx: 'a> {\n     pub terms_cx: TermsContext<'a, 'tcx>,"}, {"sha": "7106ca4d420a86100bebc22a21d4e64a8f98dd81", "filename": "src/librustc_typeck/variance/xform.rs", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a950c37394cf45428c4852359c803e5a3c194ee6/src%2Flibrustc_typeck%2Fvariance%2Fxform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a950c37394cf45428c4852359c803e5a3c194ee6/src%2Flibrustc_typeck%2Fvariance%2Fxform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fxform.rs?ref=a950c37394cf45428c4852359c803e5a3c194ee6", "patch": "@@ -10,35 +10,6 @@\n \n use rustc::ty;\n \n-pub trait Xform {\n-    fn xform(self, v: Self) -> Self;\n-}\n-\n-impl Xform for ty::Variance {\n-    fn xform(self, v: ty::Variance) -> ty::Variance {\n-        // \"Variance transformation\", Figure 1 of The Paper\n-        match (self, v) {\n-            // Figure 1, column 1.\n-            (ty::Covariant, ty::Covariant) => ty::Covariant,\n-            (ty::Covariant, ty::Contravariant) => ty::Contravariant,\n-            (ty::Covariant, ty::Invariant) => ty::Invariant,\n-            (ty::Covariant, ty::Bivariant) => ty::Bivariant,\n-\n-            // Figure 1, column 2.\n-            (ty::Contravariant, ty::Covariant) => ty::Contravariant,\n-            (ty::Contravariant, ty::Contravariant) => ty::Covariant,\n-            (ty::Contravariant, ty::Invariant) => ty::Invariant,\n-            (ty::Contravariant, ty::Bivariant) => ty::Bivariant,\n-\n-            // Figure 1, column 3.\n-            (ty::Invariant, _) => ty::Invariant,\n-\n-            // Figure 1, column 4.\n-            (ty::Bivariant, _) => ty::Bivariant,\n-        }\n-    }\n-}\n-\n pub fn glb(v1: ty::Variance, v2: ty::Variance) -> ty::Variance {\n     // Greatest lower bound of the variance lattice as\n     // defined in The Paper:"}]}