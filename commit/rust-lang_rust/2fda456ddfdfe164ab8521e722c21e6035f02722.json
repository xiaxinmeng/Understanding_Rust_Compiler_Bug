{"sha": "2fda456ddfdfe164ab8521e722c21e6035f02722", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmZGE0NTZkZGZkZmUxNjRhYjg1MjFlNzIyYzIxZTYwMzVmMDI3MjI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-07-23T19:14:56Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-07-25T03:38:21Z"}, "message": "extract `region_value_str` helper", "tree": {"sha": "7ead95f205a4babdd852b04a6f3935d3ede6e586", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ead95f205a4babdd852b04a6f3935d3ede6e586"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2fda456ddfdfe164ab8521e722c21e6035f02722", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2fda456ddfdfe164ab8521e722c21e6035f02722", "html_url": "https://github.com/rust-lang/rust/commit/2fda456ddfdfe164ab8521e722c21e6035f02722", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2fda456ddfdfe164ab8521e722c21e6035f02722/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f277b394af03284bea7fad45838f7dbc570cf634", "url": "https://api.github.com/repos/rust-lang/rust/commits/f277b394af03284bea7fad45838f7dbc570cf634", "html_url": "https://github.com/rust-lang/rust/commit/f277b394af03284bea7fad45838f7dbc570cf634"}], "stats": {"total": 150, "additions": 73, "deletions": 77}, "files": [{"sha": "01e1dfe05fe03ff472107c013253b82d42705c40", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2fda456ddfdfe164ab8521e722c21e6035f02722/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fda456ddfdfe164ab8521e722c21e6035f02722/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=2fda456ddfdfe164ab8521e722c21e6035f02722", "patch": "@@ -12,7 +12,7 @@ use borrow_check::borrow_set::BorrowSet;\n use borrow_check::location::LocationTable;\n use borrow_check::nll::ToRegionVid;\n use borrow_check::nll::facts::AllFacts;\n-use borrow_check::nll::region_infer::values::{RegionValueElements, RegionValues};\n+use borrow_check::nll::region_infer::values::RegionValues;\n use rustc::infer::InferCtxt;\n use rustc::mir::visit::TyContext;\n use rustc::mir::visit::Visitor;\n@@ -24,7 +24,6 @@ use rustc::ty::{self, CanonicalTy, ClosureSubsts, GeneratorSubsts, RegionVid};\n \n pub(super) fn generate_constraints<'cx, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n-    elements: &RegionValueElements,\n     liveness_constraints: &mut RegionValues<RegionVid>,\n     all_facts: &mut Option<AllFacts>,\n     location_table: &LocationTable,\n@@ -37,7 +36,6 @@ pub(super) fn generate_constraints<'cx, 'gcx, 'tcx>(\n         liveness_constraints,\n         location_table,\n         all_facts,\n-        elements,\n     };\n \n     for (bb, data) in mir.basic_blocks().iter_enumerated() {\n@@ -52,7 +50,6 @@ struct ConstraintGeneration<'cg, 'cx: 'cg, 'gcx: 'tcx, 'tcx: 'cx> {\n     location_table: &'cg LocationTable,\n     liveness_constraints: &'cg mut RegionValues<RegionVid>,\n     borrow_set: &'cg BorrowSet<'tcx>,\n-    elements: &'cg RegionValueElements,\n }\n \n impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx, 'tcx> {\n@@ -205,7 +202,7 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n             .tcx\n             .for_each_free_region(&live_ty, |live_region| {\n                 let vid = live_region.to_region_vid();\n-                self.liveness_constraints.add_element(&self.elements, vid, location);\n+                self.liveness_constraints.add_element(vid, location);\n             });\n     }\n }"}, {"sha": "acf6f671a7f8d7dbb981b5b7dd766ab32dffcc53", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2fda456ddfdfe164ab8521e722c21e6035f02722/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fda456ddfdfe164ab8521e722c21e6035f02722/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=2fda456ddfdfe164ab8521e722c21e6035f02722", "patch": "@@ -143,7 +143,6 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n \n     constraint_generation::generate_constraints(\n         infcx,\n-        &elements,\n         &mut liveness_constraints,\n         &mut all_facts,\n         location_table,"}, {"sha": "b1bcccdf1a047173dd27aad091c1fe9696954263", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 71, "deletions": 71, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/2fda456ddfdfe164ab8521e722c21e6035f02722/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fda456ddfdfe164ab8521e722c21e6035f02722/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=2fda456ddfdfe164ab8521e722c21e6035f02722", "patch": "@@ -192,11 +192,7 @@ impl<N: Idx> RegionValues<N> {\n \n     /// True if `sup_region` contains all the CFG points that\n     /// `sub_region` contains. Ignores universal regions.\n-    crate fn contains_points(\n-        &self,\n-        sup_region: N,\n-        sub_region: N,\n-    ) -> bool {\n+    crate fn contains_points(&self, sup_region: N, sub_region: N) -> bool {\n         // This could be done faster by comparing the bitsets. But I\n         // am lazy.\n         if let Some(sub_row) = self.points.row(sub_region) {\n@@ -252,72 +248,7 @@ impl<N: Idx> RegionValues<N> {\n \n     /// Returns a \"pretty\" string value of the region. Meant for debugging.\n     crate fn region_value_str(&self, r: N) -> String {\n-        let mut result = String::new();\n-        result.push_str(\"{\");\n-\n-        // Set to Some(l1, l2) when we have observed all the locations\n-        // from l1..=l2 (inclusive) but not yet printed them. This\n-        // gets extended if we then see l3 where l3 is the successor\n-        // to l2.\n-        let mut open_location: Option<(Location, Location)> = None;\n-\n-        let mut sep = \"\";\n-        let mut push_sep = |s: &mut String| {\n-            s.push_str(sep);\n-            sep = \", \";\n-        };\n-\n-        for element in self.elements_contained_in(r) {\n-            match element {\n-                RegionElement::Location(l) => {\n-                    if let Some((location1, location2)) = open_location {\n-                        if location2.block == l.block\n-                            && location2.statement_index == l.statement_index - 1\n-                        {\n-                            open_location = Some((location1, l));\n-                            continue;\n-                        }\n-\n-                        push_sep(&mut result);\n-                        Self::push_location_range(&mut result, location1, location2);\n-                    }\n-\n-                    open_location = Some((l, l));\n-                }\n-\n-                RegionElement::RootUniversalRegion(fr) => {\n-                    if let Some((location1, location2)) = open_location {\n-                        push_sep(&mut result);\n-                        Self::push_location_range(&mut result, location1, location2);\n-                        open_location = None;\n-                    }\n-\n-                    push_sep(&mut result);\n-                    result.push_str(&format!(\"{:?}\", fr));\n-                }\n-            }\n-        }\n-\n-        if let Some((location1, location2)) = open_location {\n-            push_sep(&mut result);\n-            Self::push_location_range(&mut result, location1, location2);\n-        }\n-\n-        result.push_str(\"}\");\n-\n-        result\n-    }\n-\n-    fn push_location_range(str: &mut String, location1: Location, location2: Location) {\n-        if location1 == location2 {\n-            str.push_str(&format!(\"{:?}\", location1));\n-        } else {\n-            assert_eq!(location1.block, location2.block);\n-            str.push_str(&format!(\n-                \"{:?}[{}..={}]\",\n-                location1.block, location1.statement_index, location2.statement_index\n-            ));\n-        }\n+        region_value_str(self.elements_contained_in(r))\n     }\n }\n \n@@ -372,3 +303,72 @@ impl ToElementIndex for RegionVid {\n         values.free_regions.contains(row, self)\n     }\n }\n+\n+crate fn region_value_str(elements: impl IntoIterator<Item = RegionElement>) -> String {\n+    let mut result = String::new();\n+    result.push_str(\"{\");\n+\n+    // Set to Some(l1, l2) when we have observed all the locations\n+    // from l1..=l2 (inclusive) but not yet printed them. This\n+    // gets extended if we then see l3 where l3 is the successor\n+    // to l2.\n+    let mut open_location: Option<(Location, Location)> = None;\n+\n+    let mut sep = \"\";\n+    let mut push_sep = |s: &mut String| {\n+        s.push_str(sep);\n+        sep = \", \";\n+    };\n+\n+    for element in elements {\n+        match element {\n+            RegionElement::Location(l) => {\n+                if let Some((location1, location2)) = open_location {\n+                    if location2.block == l.block\n+                        && location2.statement_index == l.statement_index - 1\n+                    {\n+                        open_location = Some((location1, l));\n+                        continue;\n+                    }\n+\n+                    push_sep(&mut result);\n+                    push_location_range(&mut result, location1, location2);\n+                }\n+\n+                open_location = Some((l, l));\n+            }\n+\n+            RegionElement::RootUniversalRegion(fr) => {\n+                if let Some((location1, location2)) = open_location {\n+                    push_sep(&mut result);\n+                    push_location_range(&mut result, location1, location2);\n+                    open_location = None;\n+                }\n+\n+                push_sep(&mut result);\n+                result.push_str(&format!(\"{:?}\", fr));\n+            }\n+        }\n+    }\n+\n+    if let Some((location1, location2)) = open_location {\n+        push_sep(&mut result);\n+        push_location_range(&mut result, location1, location2);\n+    }\n+\n+    result.push_str(\"}\");\n+\n+    return result;\n+\n+    fn push_location_range(str: &mut String, location1: Location, location2: Location) {\n+        if location1 == location2 {\n+            str.push_str(&format!(\"{:?}\", location1));\n+        } else {\n+            assert_eq!(location1.block, location2.block);\n+            str.push_str(&format!(\n+                \"{:?}[{}..={}]\",\n+                location1.block, location1.statement_index, location2.statement_index\n+            ));\n+        }\n+    }\n+}"}]}