{"sha": "d6ec0ae77742713800613685cbb5a28fd75e8662", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2ZWMwYWU3Nzc0MjcxMzgwMDYxMzY4NWNiYjVhMjhmZDc1ZTg2NjI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-06-03T20:31:44Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-07-02T16:15:19Z"}, "message": "enforce and report pick-constraint errors\n\nThe error message here is not great.", "tree": {"sha": "5ec5aab48268aebe106085dc7275cc5d157936a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ec5aab48268aebe106085dc7275cc5d157936a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6ec0ae77742713800613685cbb5a28fd75e8662", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6ec0ae77742713800613685cbb5a28fd75e8662", "html_url": "https://github.com/rust-lang/rust/commit/d6ec0ae77742713800613685cbb5a28fd75e8662", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6ec0ae77742713800613685cbb5a28fd75e8662/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0eebcd02f1dd123c0ff4e8ddf04a520cc1cf2a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0eebcd02f1dd123c0ff4e8ddf04a520cc1cf2a4", "html_url": "https://github.com/rust-lang/rust/commit/f0eebcd02f1dd123c0ff4e8ddf04a520cc1cf2a4"}], "stats": {"total": 388, "additions": 323, "deletions": 65}, "files": [{"sha": "ead75dcd7980e34cd409cf98a49fcffdc53de8f8", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d6ec0ae77742713800613685cbb5a28fd75e8662/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6ec0ae77742713800613685cbb5a28fd75e8662/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=d6ec0ae77742713800613685cbb5a28fd75e8662", "patch": "@@ -53,6 +53,7 @@ use crate::infer::{self, SuppressRegionErrors};\n use crate::hir;\n use crate::hir::def_id::DefId;\n use crate::hir::Node;\n+use crate::infer::opaque_types;\n use crate::middle::region;\n use crate::traits::{ObligationCause, ObligationCauseCode};\n use crate::ty::error::TypeError;\n@@ -375,6 +376,23 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                             );\n                         }\n                     }\n+\n+                    RegionResolutionError::PickConstraintFailure {\n+                        opaque_type_def_id,\n+                        hidden_ty,\n+                        pick_region,\n+                        span: _,\n+                        option_regions: _,\n+                    } => {\n+                        let hidden_ty = self.resolve_vars_if_possible(&hidden_ty);\n+                        opaque_types::report_unexpected_hidden_region(\n+                            self.tcx,\n+                            Some(region_scope_tree),\n+                            opaque_type_def_id,\n+                            hidden_ty,\n+                            pick_region,\n+                        );\n+                    }\n                 }\n             }\n         }\n@@ -411,7 +429,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let is_bound_failure = |e: &RegionResolutionError<'tcx>| match *e {\n             RegionResolutionError::GenericBoundFailure(..) => true,\n             RegionResolutionError::ConcreteFailure(..)\n-            | RegionResolutionError::SubSupConflict(..) => false,\n+                | RegionResolutionError::SubSupConflict(..)\n+                | RegionResolutionError::PickConstraintFailure { .. } => false,\n         };\n \n         let mut errors = if errors.iter().all(|e| is_bound_failure(e)) {\n@@ -429,6 +448,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             RegionResolutionError::ConcreteFailure(ref sro, _, _) => sro.span(),\n             RegionResolutionError::GenericBoundFailure(ref sro, _, _) => sro.span(),\n             RegionResolutionError::SubSupConflict(_, ref rvo, _, _, _, _) => rvo.span(),\n+            RegionResolutionError::PickConstraintFailure { span, .. } => span,\n         });\n         errors\n     }"}, {"sha": "ac8db3c43365ad69de76146783d94cbc87b94e4e", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d6ec0ae77742713800613685cbb5a28fd75e8662/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6ec0ae77742713800613685cbb5a28fd75e8662/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=d6ec0ae77742713800613685cbb5a28fd75e8662", "patch": "@@ -1,5 +1,6 @@\n //! Lexical region resolution.\n \n+use crate::hir::def_id::DefId;\n use crate::infer::region_constraints::Constraint;\n use crate::infer::region_constraints::GenericKind;\n use crate::infer::region_constraints::PickConstraint;\n@@ -22,6 +23,7 @@ use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use smallvec::SmallVec;\n use std::fmt;\n use std::u32;\n+use syntax_pos::Span;\n \n mod graphviz;\n \n@@ -81,6 +83,17 @@ pub enum RegionResolutionError<'tcx> {\n         SubregionOrigin<'tcx>,\n         Region<'tcx>,\n     ),\n+\n+    /// Indicates a failure of a `PickConstraint`. These arise during\n+    /// impl trait processing explicitly -- basically, the impl trait's hidden type\n+    /// included some region that it was not supposed to.\n+    PickConstraintFailure {\n+        span: Span,\n+        opaque_type_def_id: DefId,\n+        hidden_ty: Ty<'tcx>,\n+        pick_region: Region<'tcx>,\n+        option_regions: Vec<Region<'tcx>>,\n+    },\n }\n \n struct RegionAndOrigin<'tcx> {\n@@ -550,6 +563,24 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             }\n         }\n \n+        for pick_constraint in &self.data.pick_constraints {\n+            let pick_region = var_data.normalize(self.tcx(), pick_constraint.pick_region);\n+            let option_regions = pick_constraint\n+                .option_regions\n+                .iter()\n+                .map(|&option_region| var_data.normalize(self.tcx(), option_region));\n+            if !option_regions.clone().any(|option_region| pick_region == option_region) {\n+                let span = self.tcx().def_span(pick_constraint.opaque_type_def_id);\n+                errors.push(RegionResolutionError::PickConstraintFailure {\n+                    span,\n+                    opaque_type_def_id: pick_constraint.opaque_type_def_id,\n+                    hidden_ty: pick_constraint.hidden_ty,\n+                    pick_region,\n+                    option_regions: option_regions.collect(),\n+                });\n+            }\n+        }\n+\n         for verify in &self.data.verifys {\n             debug!(\"collect_errors: verify={:?}\", verify);\n             let sub = var_data.normalize(self.tcx(), verify.region);"}, {"sha": "f6c6b5e93a7917fb5a155b0bbbffebf280908ac2", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d6ec0ae77742713800613685cbb5a28fd75e8662/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6ec0ae77742713800613685cbb5a28fd75e8662/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=d6ec0ae77742713800613685cbb5a28fd75e8662", "patch": "@@ -909,13 +909,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// the set `regions`.\n     pub fn pick_constraint(\n         &self,\n-        origin: SubregionOrigin<'tcx>,\n+        opaque_type_def_id: DefId,\n+        hidden_ty: Ty<'tcx>,\n         region: ty::Region<'tcx>,\n         in_regions: &Rc<Vec<ty::Region<'tcx>>>,\n     ) {\n         debug!(\"sub_regions({:?} <: {:?})\", region, in_regions);\n         self.borrow_region_constraints()\n-            .pick_constraint(origin, region, in_regions);\n+            .pick_constraint(opaque_type_def_id, hidden_ty, region, in_regions);\n     }\n \n     pub fn subtype_predicate("}, {"sha": "ca859045c6bbce91bf7a56c115e32f1b9df2b7a8", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 98, "deletions": 46, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/d6ec0ae77742713800613685cbb5a28fd75e8662/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6ec0ae77742713800613685cbb5a28fd75e8662/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=d6ec0ae77742713800613685cbb5a28fd75e8662", "patch": "@@ -3,14 +3,14 @@ use crate::hir::def_id::DefId;\n use crate::hir::Node;\n use crate::infer::outlives::free_region_map::FreeRegionRelations;\n use crate::infer::{self, InferCtxt, InferOk, TypeVariableOrigin, TypeVariableOriginKind};\n+use crate::middle::region;\n use crate::traits::{self, PredicateObligation};\n use crate::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder, TypeVisitor};\n use crate::ty::subst::{InternalSubsts, Kind, SubstsRef, UnpackedKind};\n use crate::ty::{self, GenericParamDefKind, Ty, TyCtxt};\n use crate::util::nodemap::DefIdMap;\n use rustc_data_structures::fx::FxHashMap;\n use std::rc::Rc;\n-use syntax::source_map::Span;\n \n pub type OpaqueTypeMap<'tcx> = DefIdMap<OpaqueTypeDecl<'tcx>>;\n \n@@ -374,11 +374,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         // we will create a \"in bound\" like `'r in\n                         // ['a, 'b, 'c]`, where `'a..'c` are the\n                         // regions that appear in the impl trait.\n-                        return self.generate_in_constraint(\n-                            span,\n+                        return self.generate_pick_constraint(\n                             concrete_ty,\n                             abstract_type_generics,\n                             opaque_defn,\n+                            def_id,\n                         );\n                     }\n                 }\n@@ -399,14 +399,17 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// related, we would generate a constraint `'r in ['a, 'b,\n     /// 'static]` for each region `'r` that appears in the hidden type\n     /// (i.e., it must be equal to `'a`, `'b`, or `'static`).\n-    fn generate_in_constraint(\n+    fn generate_pick_constraint(\n         &self,\n-        span: Span,\n         concrete_ty: Ty<'tcx>,\n         abstract_type_generics: &ty::Generics,\n         opaque_defn: &OpaqueTypeDecl<'tcx>,\n+        opaque_type_def_id: DefId,\n     ) {\n-        let in_regions: Rc<Vec<ty::Region<'tcx>>> = Rc::new(\n+        // Create the set of option regions: each region in the hidden\n+        // type can be equal to any of the region parameters of the\n+        // opaque type definition.\n+        let option_regions: Rc<Vec<ty::Region<'tcx>>> = Rc::new(\n             abstract_type_generics\n                 .params\n                 .iter()\n@@ -421,7 +424,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         concrete_ty.visit_with(&mut ConstrainOpaqueTypeRegionVisitor {\n             tcx: self.tcx,\n-            op: |r| self.pick_constraint(infer::CallReturn(span), r, &in_regions),\n+            op: |r| self.pick_constraint(\n+                opaque_type_def_id,\n+                concrete_ty,\n+                r,\n+                &option_regions,\n+            ),\n         });\n     }\n \n@@ -445,7 +453,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// # Parameters\n     ///\n     /// - `def_id`, the `impl Trait` type\n-\n     /// - `opaque_defn`, the opaque definition created in `instantiate_opaque_types`\n     /// - `instantiated_ty`, the inferred type C1 -- fully resolved, lifted version of\n     ///   `opaque_defn.concrete_ty`\n@@ -492,6 +499,83 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n }\n \n+pub fn report_unexpected_hidden_region(\n+    tcx: TyCtxt<'_, '_, 'tcx>,\n+    region_scope_tree: Option<&region::ScopeTree>,\n+    opaque_type_def_id: DefId,\n+    hidden_ty: Ty<'tcx>,\n+    hidden_region: ty::Region<'tcx>,\n+) {\n+    let span = tcx.def_span(opaque_type_def_id);\n+    let mut err = struct_span_err!(\n+        tcx.sess,\n+        span,\n+        E0700,\n+        \"hidden type for `impl Trait` captures lifetime that does not appear in bounds\",\n+    );\n+\n+    // Explain the region we are capturing.\n+    if let ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReStatic | ty::ReEmpty = hidden_region {\n+        // Assuming regionck succeeded (*), we ought to always be\n+        // capturing *some* region from the fn header, and hence it\n+        // ought to be free. So under normal circumstances, we will go\n+        // down this path which gives a decent human readable\n+        // explanation.\n+        //\n+        // (*) if not, the `tainted_by_errors` flag would be set to\n+        // true in any case, so we wouldn't be here at all.\n+        tcx.note_and_explain_free_region(\n+            &mut err,\n+            &format!(\"hidden type `{}` captures \", hidden_ty),\n+            hidden_region,\n+            \"\",\n+        );\n+    } else {\n+        // Ugh. This is a painful case: the hidden region is not one\n+        // that we can easily summarize or explain. This can happens\n+        // in a case like\n+        // `src/test/ui/multiple-lifetimes/ordinary-bounds-unsuited.rs`:\n+        //\n+        // ```\n+        // fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b> {\n+        //   if condition() { a } else { b }\n+        // }\n+        // ```\n+        //\n+        // Here the captured lifetime is the intersection of `'a` and\n+        // `'b`, which we can't quite express. This prticulararticular\n+        // is kind of an unfortunate error anyway.\n+\n+        if let Some(region_scope_tree) = region_scope_tree {\n+            // If the `region_scope_tree` is available, this is being\n+            // invoked from the \"region inferencer error\". We can at\n+            // least report a really cryptic error for now.\n+            tcx.note_and_explain_region(\n+                region_scope_tree,\n+                &mut err,\n+                &format!(\"hidden type `{}` captures \", hidden_ty),\n+                hidden_region,\n+                \"\",\n+            );\n+        } else {\n+            // If the `region_scope_tree` is *unavailable*, this is\n+            // being invoked by the code that comes *after* region\n+            // inferencing. This is a bug, as the region inferencer\n+            // ought to have noticed the failed constraint and invoked\n+            // error reporting, which in turn should have prevented us\n+            // from getting trying to infer the hidden type\n+            // completely.\n+            span_bug!(\n+                span,\n+                \"hidden type captures unexpected lifetime `{:?}` but no region inference failure\",\n+                hidden_region,\n+            );\n+        }\n+    }\n+\n+    err.emit();\n+}\n+\n // Visitor that requires that (almost) all regions in the type visited outlive\n // `least_region`. We cannot use `push_outlives_components` because regions in\n // closure signatures are not included in their outlives components. We need to\n@@ -640,45 +724,13 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n             None => {\n                 if !self.map_missing_regions_to_empty && !self.tainted_by_errors {\n                     if let Some(hidden_ty) = self.hidden_ty.take() {\n-                        let span = self.tcx.def_span(self.opaque_type_def_id);\n-                        let mut err = struct_span_err!(\n-                            self.tcx.sess,\n-                            span,\n-                            E0700,\n-                            \"hidden type for `impl Trait` captures lifetime that \\\n-                             does not appear in bounds\",\n+                        report_unexpected_hidden_region(\n+                            self.tcx,\n+                            None,\n+                            self.opaque_type_def_id,\n+                            hidden_ty,\n+                            r,\n                         );\n-\n-                        // Explain the region we are capturing.\n-                        match r {\n-                            ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReStatic | ty::ReEmpty => {\n-                                // Assuming regionck succeeded (*), we\n-                                // ought to always be capturing *some* region\n-                                // from the fn header, and hence it ought to\n-                                // be free. So under normal circumstances, we will\n-                                // go down this path which gives a decent human readable\n-                                // explanation.\n-                                //\n-                                // (*) if not, the `tainted_by_errors`\n-                                // flag would be set to true in any\n-                                // case, so we wouldn't be here at\n-                                // all.\n-                                self.tcx.note_and_explain_free_region(\n-                                    &mut err,\n-                                    &format!(\"hidden type `{}` captures \", hidden_ty),\n-                                    r,\n-                                    \"\",\n-                                );\n-                            }\n-                            _ => {\n-                                // This case should not happen: it indicates that regionck\n-                                // failed to enforce an \"in constraint\".\n-                                err.note(&format!(\"hidden type `{}` captures `{:?}`\", hidden_ty, r));\n-                                err.note(&format!(\"this is likely a bug in the compiler, please file an issue on github\"));\n-                            }\n-                        }\n-\n-                        err.emit();\n                     }\n                 }\n                 self.tcx.lifetimes.re_empty"}, {"sha": "1340fb807ee2a7083ef45b92c245798da0cdf581", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d6ec0ae77742713800613685cbb5a28fd75e8662/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6ec0ae77742713800613685cbb5a28fd75e8662/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=d6ec0ae77742713800613685cbb5a28fd75e8662", "patch": "@@ -9,6 +9,7 @@ use super::{MiscVariable, RegionVariableOrigin, SubregionOrigin};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::unify as ut;\n+use crate::hir::def_id::DefId;\n use crate::ty::ReStatic;\n use crate::ty::{self, Ty, TyCtxt};\n use crate::ty::{ReLateBound, ReVar};\n@@ -151,8 +152,16 @@ impl Constraint<'_> {\n /// ```\n #[derive(Debug, Clone)]\n pub struct PickConstraint<'tcx> {\n-    pub origin: SubregionOrigin<'tcx>,\n+    /// the def-id of the opaque type causing this constraint: used for error reporting\n+    pub opaque_type_def_id: DefId,\n+\n+    /// the hidden type in which `pick_region` appears: used for error reporting\n+    pub hidden_ty: Ty<'tcx>,\n+\n+    /// the region R0\n     pub pick_region: Region<'tcx>,\n+\n+    /// the options O1..On\n     pub option_regions: Rc<Vec<Region<'tcx>>>,\n }\n \n@@ -664,7 +673,8 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n \n     pub fn pick_constraint(\n         &mut self,\n-        origin: SubregionOrigin<'tcx>,\n+        opaque_type_def_id: DefId,\n+        hidden_ty: Ty<'tcx>,\n         pick_region: ty::Region<'tcx>,\n         option_regions: &Rc<Vec<ty::Region<'tcx>>>,\n     ) {\n@@ -675,7 +685,10 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n         }\n \n         self.data.pick_constraints.push(PickConstraint {\n-            origin, pick_region, option_regions: option_regions.clone()\n+            opaque_type_def_id,\n+            hidden_ty,\n+            pick_region,\n+            option_regions: option_regions.clone()\n         });\n \n     }"}, {"sha": "13fb6f5d73e02ef484e5acae83e9bd8a8cd51ab5", "filename": "src/test/ui/impl-trait/multiple-lifetimes/inverse-bounds.stderr", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d6ec0ae77742713800613685cbb5a28fd75e8662/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Finverse-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d6ec0ae77742713800613685cbb5a28fd75e8662/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Finverse-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Finverse-bounds.stderr?ref=d6ec0ae77742713800613685cbb5a28fd75e8662", "patch": "@@ -1,15 +1,25 @@\n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+error: impl Trait captures unexpected lifetime\n   --> $DIR/inverse-bounds.rs:15:70\n    |\n LL | fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Invert<'a>, b: Invert<'b>) -> impl Trait<'d, 'e>\n-   |                                                                      ^^^^^^^^^^^^^^^^^^\n+   |                                                                      ^^^^^^^^^^^^^^^^^^ only lifetimes that appear in the impl Trait bounds may be captured\n    |\n-note: hidden type `Invert<'c>` captures the lifetime 'c as defined on the function body at 15:25\n-  --> $DIR/inverse-bounds.rs:15:25\n+note: hidden type captures the lifetime 'd as defined on the function body at 15:29\n+  --> $DIR/inverse-bounds.rs:15:29\n    |\n LL | fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Invert<'a>, b: Invert<'b>) -> impl Trait<'d, 'e>\n-   |                         ^^\n+   |                             ^^\n+note: hidden type would be allowed to capture the lifetime 'd as defined on the function body at 15:29\n+  --> $DIR/inverse-bounds.rs:15:29\n+   |\n+LL | fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Invert<'a>, b: Invert<'b>) -> impl Trait<'d, 'e>\n+   |                             ^^\n+note: hidden type would be allowed to capture the lifetime 'e as defined on the function body at 15:33\n+  --> $DIR/inverse-bounds.rs:15:33\n+   |\n+LL | fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Invert<'a>, b: Invert<'b>) -> impl Trait<'d, 'e>\n+   |                                 ^^\n+   = note: hidden type would be allowed to capture the static lifetime\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0700`."}, {"sha": "43e92ac68272b2ddb2f96274c88a06d83b53be2d", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-pick-original.stderr", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/d6ec0ae77742713800613685cbb5a28fd75e8662/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-original.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d6ec0ae77742713800613685cbb5a28fd75e8662/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-original.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-original.stderr?ref=d6ec0ae77742713800613685cbb5a28fd75e8662", "patch": "@@ -0,0 +1,48 @@\n+error: impl Trait captures unexpected lifetime\n+  --> $DIR/ordinary-bounds-pick-original.rs:11:50\n+   |\n+LL | fn upper_bounds<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a, 'b> {\n+   |                                                  ^^^^^^^^^^^^^^^^^^ only lifetimes that appear in the impl Trait bounds may be captured\n+   |\n+note: hidden type captures the lifetime 'a as defined on the function body at 11:17\n+  --> $DIR/ordinary-bounds-pick-original.rs:11:17\n+   |\n+LL | fn upper_bounds<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a, 'b> {\n+   |                 ^^\n+note: hidden type would be allowed to capture the lifetime 'a as defined on the function body at 11:17\n+  --> $DIR/ordinary-bounds-pick-original.rs:11:17\n+   |\n+LL | fn upper_bounds<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a, 'b> {\n+   |                 ^^\n+note: hidden type would be allowed to capture the lifetime 'b as defined on the function body at 11:21\n+  --> $DIR/ordinary-bounds-pick-original.rs:11:21\n+   |\n+LL | fn upper_bounds<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a, 'b> {\n+   |                     ^^\n+   = note: hidden type would be allowed to capture the static lifetime\n+\n+error: impl Trait captures unexpected lifetime\n+  --> $DIR/ordinary-bounds-pick-original.rs:11:50\n+   |\n+LL | fn upper_bounds<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a, 'b> {\n+   |                                                  ^^^^^^^^^^^^^^^^^^ only lifetimes that appear in the impl Trait bounds may be captured\n+   |\n+note: hidden type captures the lifetime 'b as defined on the function body at 11:21\n+  --> $DIR/ordinary-bounds-pick-original.rs:11:21\n+   |\n+LL | fn upper_bounds<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a, 'b> {\n+   |                     ^^\n+note: hidden type would be allowed to capture the lifetime 'a as defined on the function body at 11:17\n+  --> $DIR/ordinary-bounds-pick-original.rs:11:17\n+   |\n+LL | fn upper_bounds<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a, 'b> {\n+   |                 ^^\n+note: hidden type would be allowed to capture the lifetime 'b as defined on the function body at 11:21\n+  --> $DIR/ordinary-bounds-pick-original.rs:11:21\n+   |\n+LL | fn upper_bounds<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a, 'b> {\n+   |                     ^^\n+   = note: hidden type would be allowed to capture the static lifetime\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "ff09f9471079fe12d7c715a87e294b04d911ecf4", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-pick-other.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d6ec0ae77742713800613685cbb5a28fd75e8662/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-other.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d6ec0ae77742713800613685cbb5a28fd75e8662/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-other.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-pick-other.stderr?ref=d6ec0ae77742713800613685cbb5a28fd75e8662", "patch": "@@ -0,0 +1,25 @@\n+error: impl Trait captures unexpected lifetime\n+  --> $DIR/ordinary-bounds-pick-other.rs:18:74\n+   |\n+LL | fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'d, 'e>\n+   |                                                                          ^^^^^^^^^^^^^^^^^^ only lifetimes that appear in the impl Trait bounds may be captured\n+   |\n+note: hidden type captures the lifetime 'e as defined on the function body at 18:33\n+  --> $DIR/ordinary-bounds-pick-other.rs:18:33\n+   |\n+LL | fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'d, 'e>\n+   |                                 ^^\n+note: hidden type would be allowed to capture the lifetime 'd as defined on the function body at 18:29\n+  --> $DIR/ordinary-bounds-pick-other.rs:18:29\n+   |\n+LL | fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'d, 'e>\n+   |                             ^^\n+note: hidden type would be allowed to capture the lifetime 'e as defined on the function body at 18:33\n+  --> $DIR/ordinary-bounds-pick-other.rs:18:33\n+   |\n+LL | fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'d, 'e>\n+   |                                 ^^\n+   = note: hidden type would be allowed to capture the static lifetime\n+\n+error: aborting due to previous error\n+"}, {"sha": "cd2d46ac182180e4a05021595d36dd0164ef603c", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unrelated.stderr", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d6ec0ae77742713800613685cbb5a28fd75e8662/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d6ec0ae77742713800613685cbb5a28fd75e8662/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.stderr?ref=d6ec0ae77742713800613685cbb5a28fd75e8662", "patch": "@@ -4,8 +4,17 @@ error[E0700]: hidden type for `impl Trait` captures lifetime that does not appea\n LL | fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'d, 'e>\n    |                                                                          ^^^^^^^^^^^^^^^^^^\n    |\n-   = note: hidden type `Ordinary<'_>` captures `ReScope(CallSite(24))`\n-   = note: this is likely a bug in the compiler, please file an issue on github\n+note: hidden type `Ordinary<'_>` captures the scope of call-site for function at 23:1\n+  --> $DIR/ordinary-bounds-unrelated.rs:23:1\n+   |\n+LL | / {\n+LL | |     // Hidden type `Ordinary<'0>` with constraints:\n+LL | |     //\n+LL | |     // ```\n+...  |\n+LL | |     if condition() { a } else { b }\n+LL | | }\n+   | |_^\n \n error: aborting due to previous error\n "}, {"sha": "59ce93fa78b6b3754c151c15dc393c84fe9fe16e", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unsuited.stderr", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d6ec0ae77742713800613685cbb5a28fd75e8662/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d6ec0ae77742713800613685cbb5a28fd75e8662/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.stderr?ref=d6ec0ae77742713800613685cbb5a28fd75e8662", "patch": "@@ -4,8 +4,17 @@ error[E0700]: hidden type for `impl Trait` captures lifetime that does not appea\n LL | fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b>\n    |                                                              ^^^^^^^^^^^^^^^^^^\n    |\n-   = note: hidden type `Ordinary<'_>` captures `ReScope(CallSite(24))`\n-   = note: this is likely a bug in the compiler, please file an issue on github\n+note: hidden type `Ordinary<'_>` captures the scope of call-site for function at 22:1\n+  --> $DIR/ordinary-bounds-unsuited.rs:22:1\n+   |\n+LL | / {\n+LL | |     // We return a value:\n+LL | |     //\n+LL | |     // ```\n+...  |\n+LL | |     if condition() { a } else { b }\n+LL | | }\n+   | |_^\n \n error: aborting due to previous error\n "}, {"sha": "9b9196a213da87d09ad5834fd90e0c934e0d29ed", "filename": "src/test/ui/impl-trait/needs_least_region_or_bound.stderr", "status": "modified", "additions": 43, "deletions": 3, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/d6ec0ae77742713800613685cbb5a28fd75e8662/src%2Ftest%2Fui%2Fimpl-trait%2Fneeds_least_region_or_bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d6ec0ae77742713800613685cbb5a28fd75e8662/src%2Ftest%2Fui%2Fimpl-trait%2Fneeds_least_region_or_bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fneeds_least_region_or_bound.stderr?ref=d6ec0ae77742713800613685cbb5a28fd75e8662", "patch": "@@ -1,8 +1,48 @@\n-error: ambiguous lifetime bound in `impl Trait`\n+error: impl Trait captures unexpected lifetime\n   --> $DIR/needs_least_region_or_bound.rs:6:55\n    |\n LL | fn no_least_region<'a, 'b>(x: &'a u32, y: &'b u32) -> impl MultiRegionTrait<'a, 'b> {\n-   |                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ neither `'a` nor `'b` outlives the other\n+   |                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ only lifetimes that appear in the impl Trait bounds may be captured\n+   |\n+note: hidden type captures the lifetime 'a as defined on the function body at 6:20\n+  --> $DIR/needs_least_region_or_bound.rs:6:20\n+   |\n+LL | fn no_least_region<'a, 'b>(x: &'a u32, y: &'b u32) -> impl MultiRegionTrait<'a, 'b> {\n+   |                    ^^\n+note: hidden type would be allowed to capture the lifetime 'a as defined on the function body at 6:20\n+  --> $DIR/needs_least_region_or_bound.rs:6:20\n+   |\n+LL | fn no_least_region<'a, 'b>(x: &'a u32, y: &'b u32) -> impl MultiRegionTrait<'a, 'b> {\n+   |                    ^^\n+note: hidden type would be allowed to capture the lifetime 'b as defined on the function body at 6:24\n+  --> $DIR/needs_least_region_or_bound.rs:6:24\n+   |\n+LL | fn no_least_region<'a, 'b>(x: &'a u32, y: &'b u32) -> impl MultiRegionTrait<'a, 'b> {\n+   |                        ^^\n+   = note: hidden type would be allowed to capture the static lifetime\n+\n+error: impl Trait captures unexpected lifetime\n+  --> $DIR/needs_least_region_or_bound.rs:6:55\n+   |\n+LL | fn no_least_region<'a, 'b>(x: &'a u32, y: &'b u32) -> impl MultiRegionTrait<'a, 'b> {\n+   |                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ only lifetimes that appear in the impl Trait bounds may be captured\n+   |\n+note: hidden type captures the lifetime 'b as defined on the function body at 6:24\n+  --> $DIR/needs_least_region_or_bound.rs:6:24\n+   |\n+LL | fn no_least_region<'a, 'b>(x: &'a u32, y: &'b u32) -> impl MultiRegionTrait<'a, 'b> {\n+   |                        ^^\n+note: hidden type would be allowed to capture the lifetime 'a as defined on the function body at 6:20\n+  --> $DIR/needs_least_region_or_bound.rs:6:20\n+   |\n+LL | fn no_least_region<'a, 'b>(x: &'a u32, y: &'b u32) -> impl MultiRegionTrait<'a, 'b> {\n+   |                    ^^\n+note: hidden type would be allowed to capture the lifetime 'b as defined on the function body at 6:24\n+  --> $DIR/needs_least_region_or_bound.rs:6:24\n+   |\n+LL | fn no_least_region<'a, 'b>(x: &'a u32, y: &'b u32) -> impl MultiRegionTrait<'a, 'b> {\n+   |                        ^^\n+   = note: hidden type would be allowed to capture the static lifetime\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n "}]}