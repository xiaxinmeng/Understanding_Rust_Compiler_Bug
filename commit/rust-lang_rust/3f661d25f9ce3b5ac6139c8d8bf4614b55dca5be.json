{"sha": "3f661d25f9ce3b5ac6139c8d8bf4614b55dca5be", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmNjYxZDI1ZjljZTNiNWFjNjEzOWM4ZDhiZjQ2MTRiNTVkY2E1YmU=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-05-11T08:29:05Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-05-11T08:29:26Z"}, "message": "borrowck `DefId` -> `LocalDefId`", "tree": {"sha": "a95b80a0edfc8ab243d5d5daae9c3228e7a232e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a95b80a0edfc8ab243d5d5daae9c3228e7a232e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f661d25f9ce3b5ac6139c8d8bf4614b55dca5be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f661d25f9ce3b5ac6139c8d8bf4614b55dca5be", "html_url": "https://github.com/rust-lang/rust/commit/3f661d25f9ce3b5ac6139c8d8bf4614b55dca5be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f661d25f9ce3b5ac6139c8d8bf4614b55dca5be/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bad3bf622bded50a97c0a54e29350eada2a3a169", "url": "https://api.github.com/repos/rust-lang/rust/commits/bad3bf622bded50a97c0a54e29350eada2a3a169", "html_url": "https://github.com/rust-lang/rust/commit/bad3bf622bded50a97c0a54e29350eada2a3a169"}], "stats": {"total": 126, "additions": 59, "deletions": 67}, "files": [{"sha": "d0050f801fc6bbdd72ddbba27e8b018b255e247c", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 42, "deletions": 47, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/3f661d25f9ce3b5ac6139c8d8bf4614b55dca5be/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f661d25f9ce3b5ac6139c8d8bf4614b55dca5be/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=3f661d25f9ce3b5ac6139c8d8bf4614b55dca5be", "patch": "@@ -214,7 +214,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     let generics = tcx.generics_of(self.mir_def_id);\n                     let param = generics.type_param(&param_ty, tcx);\n                     if let Some(generics) =\n-                        tcx.hir().get_generics(tcx.closure_base_def_id(self.mir_def_id))\n+                        tcx.hir().get_generics(tcx.closure_base_def_id(self.mir_def_id.to_def_id()))\n                     {\n                         suggest_constraining_type_param(\n                             tcx,\n@@ -865,49 +865,42 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 format!(\"`{}` would have to be valid for `{}`...\", name, region_name),\n             );\n \n-            if let Some(def_id) = self.mir_def_id.as_local() {\n-                let fn_hir_id = self.infcx.tcx.hir().as_local_hir_id(def_id);\n-                err.span_label(\n-                    drop_span,\n-                    format!(\n-                        \"...but `{}` will be dropped here, when the {} returns\",\n-                        name,\n-                        self.infcx\n-                            .tcx\n-                            .hir()\n-                            .opt_name(fn_hir_id)\n-                            .map(|name| format!(\"function `{}`\", name))\n-                            .unwrap_or_else(|| {\n-                                match &self\n-                                    .infcx\n-                                    .tcx\n-                                    .typeck_tables_of(def_id)\n-                                    .node_type(fn_hir_id)\n-                                    .kind\n-                                {\n-                                    ty::Closure(..) => \"enclosing closure\",\n-                                    ty::Generator(..) => \"enclosing generator\",\n-                                    kind => bug!(\"expected closure or generator, found {:?}\", kind),\n-                                }\n-                                .to_string()\n-                            })\n-                    ),\n-                );\n+            let fn_hir_id = self.infcx.tcx.hir().as_local_hir_id(self.mir_def_id);\n+            err.span_label(\n+                drop_span,\n+                format!(\n+                    \"...but `{}` will be dropped here, when the {} returns\",\n+                    name,\n+                    self.infcx\n+                        .tcx\n+                        .hir()\n+                        .opt_name(fn_hir_id)\n+                        .map(|name| format!(\"function `{}`\", name))\n+                        .unwrap_or_else(|| {\n+                            match &self\n+                                .infcx\n+                                .tcx\n+                                .typeck_tables_of(self.mir_def_id)\n+                                .node_type(fn_hir_id)\n+                                .kind\n+                            {\n+                                ty::Closure(..) => \"enclosing closure\",\n+                                ty::Generator(..) => \"enclosing generator\",\n+                                kind => bug!(\"expected closure or generator, found {:?}\", kind),\n+                            }\n+                            .to_string()\n+                        })\n+                ),\n+            );\n \n-                err.note(\n-                    \"functions cannot return a borrow to data owned within the function's scope, \\\n-                     functions can only return borrows to data passed as arguments\",\n-                );\n-                err.note(\n-                    \"to learn more, visit <https://doc.rust-lang.org/book/ch04-02-\\\n-                     references-and-borrowing.html#dangling-references>\",\n-                );\n-            } else {\n-                err.span_label(\n-                    drop_span,\n-                    format!(\"...but `{}` dropped here while still borrowed\", name),\n-                );\n-            }\n+            err.note(\n+                \"functions cannot return a borrow to data owned within the function's scope, \\\n+                    functions can only return borrows to data passed as arguments\",\n+            );\n+            err.note(\n+                \"to learn more, visit <https://doc.rust-lang.org/book/ch04-02-\\\n+                    references-and-borrowing.html#dangling-references>\",\n+            );\n \n             if let BorrowExplanation::MustBeValidFor { .. } = explanation {\n             } else {\n@@ -1237,7 +1230,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ) -> DiagnosticBuilder<'cx> {\n         let tcx = self.infcx.tcx;\n \n-        let (_, escapes_from) = tcx.article_and_description(self.mir_def_id);\n+        let (_, escapes_from) = tcx.article_and_description(self.mir_def_id.to_def_id());\n \n         let mut err =\n             borrowck_errors::borrowed_data_escapes_closure(tcx, escape_span, escapes_from);\n@@ -1572,14 +1565,16 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ) -> Option<AnnotatedBorrowFnSignature<'tcx>> {\n         // Define a fallback for when we can't match a closure.\n         let fallback = || {\n-            let is_closure = self.infcx.tcx.is_closure(self.mir_def_id);\n+            let is_closure = self.infcx.tcx.is_closure(self.mir_def_id.to_def_id());\n             if is_closure {\n                 None\n             } else {\n                 let ty = self.infcx.tcx.type_of(self.mir_def_id);\n                 match ty.kind {\n-                    ty::FnDef(_, _) | ty::FnPtr(_) => self\n-                        .annotate_fn_sig(self.mir_def_id, self.infcx.tcx.fn_sig(self.mir_def_id)),\n+                    ty::FnDef(_, _) | ty::FnPtr(_) => self.annotate_fn_sig(\n+                        self.mir_def_id.to_def_id(),\n+                        self.infcx.tcx.fn_sig(self.mir_def_id),\n+                    ),\n                     _ => None,\n                 }\n             }"}, {"sha": "b49e4187fb81070124337a95064b142081274184", "filename": "src/librustc_mir/borrow_check/diagnostics/move_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f661d25f9ce3b5ac6139c8d8bf4614b55dca5be/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f661d25f9ce3b5ac6139c8d8bf4614b55dca5be/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs?ref=3f661d25f9ce3b5ac6139c8d8bf4614b55dca5be", "patch": "@@ -331,7 +331,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 self.cannot_move_out_of_interior_noncopy(span, ty, None)\n             }\n             ty::Closure(def_id, closure_substs)\n-                if def_id == self.mir_def_id && upvar_field.is_some() =>\n+                if def_id.as_local() == Some(self.mir_def_id) && upvar_field.is_some() =>\n             {\n                 let closure_kind_ty = closure_substs.as_closure().kind_ty();\n                 let closure_kind = closure_kind_ty.to_opt_closure_kind();"}, {"sha": "e04ed8b83debd94509c692098c517f03abb96de4", "filename": "src/librustc_mir/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f661d25f9ce3b5ac6139c8d8bf4614b55dca5be/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f661d25f9ce3b5ac6139c8d8bf4614b55dca5be/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=3f661d25f9ce3b5ac6139c8d8bf4614b55dca5be", "patch": "@@ -492,7 +492,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         err.span_label(sp, format!(\"cannot {}\", act));\n \n         let hir = self.infcx.tcx.hir();\n-        let closure_id = hir.as_local_hir_id(self.mir_def_id.expect_local());\n+        let closure_id = hir.as_local_hir_id(self.mir_def_id);\n         let fn_call_id = hir.get_parent_node(closure_id);\n         let node = hir.get(fn_call_id);\n         let item_id = hir.get_parent_item(fn_call_id);"}, {"sha": "f24d668739949eb0b5dc382aaf6929a3d7332c9b", "filename": "src/librustc_mir/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f661d25f9ce3b5ac6139c8d8bf4614b55dca5be/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f661d25f9ce3b5ac6139c8d8bf4614b55dca5be/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=3f661d25f9ce3b5ac6139c8d8bf4614b55dca5be", "patch": "@@ -502,7 +502,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         let mut diag =\n             self.infcx.tcx.sess.struct_span_err(*span, \"lifetime may not live long enough\");\n \n-        let (_, mir_def_name) = self.infcx.tcx.article_and_description(self.mir_def_id);\n+        let (_, mir_def_name) = self.infcx.tcx.article_and_description(self.mir_def_id.to_def_id());\n \n         let fr_name = self.give_region_a_name(*fr).unwrap();\n         fr_name.highlight_region_name(&mut diag);"}, {"sha": "aee825a811380eb91964ea469c970c369b24a602", "filename": "src/librustc_mir/borrow_check/diagnostics/region_name.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3f661d25f9ce3b5ac6139c8d8bf4614b55dca5be/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f661d25f9ce3b5ac6139c8d8bf4614b55dca5be/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs?ref=3f661d25f9ce3b5ac6139c8d8bf4614b55dca5be", "patch": "@@ -237,8 +237,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                 }\n \n                 ty::BoundRegion::BrEnv => {\n-                    let mir_hir_id =\n-                        self.infcx.tcx.hir().as_local_hir_id(self.mir_def_id.expect_local());\n+                    let mir_hir_id = self.infcx.tcx.hir().as_local_hir_id(self.mir_def_id);\n                     let def_ty = self.regioncx.universal_regions().defining_ty;\n \n                     if let DefiningTy::Closure(_, substs) = def_ty {\n@@ -324,7 +323,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         argument_ty: Ty<'tcx>,\n         argument_index: usize,\n     ) -> Option<RegionName> {\n-        let mir_hir_id = self.infcx.tcx.hir().as_local_hir_id(self.mir_def_id.as_local()?);\n+        let mir_hir_id = self.infcx.tcx.hir().as_local_hir_id(self.mir_def_id);\n         let fn_decl = self.infcx.tcx.hir().fn_decl_by_hir_id(mir_hir_id)?;\n         let argument_hir_ty: &hir::Ty<'_> = fn_decl.inputs.get(argument_index)?;\n         match argument_hir_ty.kind {\n@@ -635,7 +634,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         highlight.highlighting_region_vid(fr, *self.next_region_name.try_borrow().unwrap());\n         let type_name = self.infcx.extract_type_name(&return_ty, Some(highlight)).0;\n \n-        let mir_hir_id = tcx.hir().as_local_hir_id(self.mir_def_id.expect_local());\n+        let mir_hir_id = tcx.hir().as_local_hir_id(self.mir_def_id);\n \n         let (return_span, mir_description) = match tcx.hir().get(mir_hir_id) {\n             hir::Node::Expr(hir::Expr {\n@@ -687,7 +686,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         highlight.highlighting_region_vid(fr, *self.next_region_name.try_borrow().unwrap());\n         let type_name = self.infcx.extract_type_name(&yield_ty, Some(highlight)).0;\n \n-        let mir_hir_id = tcx.hir().as_local_hir_id(self.mir_def_id.expect_local());\n+        let mir_hir_id = tcx.hir().as_local_hir_id(self.mir_def_id);\n \n         let yield_span = match tcx.hir().get(mir_hir_id) {\n             hir::Node::Expr(hir::Expr {"}, {"sha": "baba3cb1babcc5bbffc83d6f73b4864d33fa8eee", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3f661d25f9ce3b5ac6139c8d8bf4614b55dca5be/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f661d25f9ce3b5ac6139c8d8bf4614b55dca5be/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=3f661d25f9ce3b5ac6139c8d8bf4614b55dca5be", "patch": "@@ -4,10 +4,8 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorReported};\n use rustc_hir as hir;\n-use rustc_hir::{\n-    def_id::{DefId, LocalDefId},\n-    HirId, Node,\n-};\n+use rustc_hir::def_id::LocalDefId;\n+use rustc_hir::{HirId, Node};\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n@@ -174,7 +172,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n     let mut body = input_body.clone();\n     let mut promoted = input_promoted.clone();\n     let free_regions =\n-        nll::replace_regions_in_mir(infcx, def_id.to_def_id(), param_env, &mut body, &mut promoted);\n+        nll::replace_regions_in_mir(infcx, def_id, param_env, &mut body, &mut promoted);\n     let body = &body; // no further changes\n \n     let location_table = &LocationTable::new(&body);\n@@ -275,7 +273,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n             let mut promoted_mbcx = MirBorrowckCtxt {\n                 infcx,\n                 body: promoted_body,\n-                mir_def_id: def_id.to_def_id(),\n+                mir_def_id: def_id,\n                 move_data: &move_data,\n                 location_table: &LocationTable::new(promoted_body),\n                 movable_generator,\n@@ -307,7 +305,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n     let mut mbcx = MirBorrowckCtxt {\n         infcx,\n         body,\n-        mir_def_id: def_id.to_def_id(),\n+        mir_def_id: def_id,\n         move_data: &mdpe.move_data,\n         location_table,\n         movable_generator,\n@@ -459,7 +457,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n crate struct MirBorrowckCtxt<'cx, 'tcx> {\n     crate infcx: &'cx InferCtxt<'cx, 'tcx>,\n     body: &'cx Body<'tcx>,\n-    mir_def_id: DefId,\n+    mir_def_id: LocalDefId,\n     move_data: &'cx MoveData<'tcx>,\n \n     /// Map from MIR `Location` to `LocationIndex`; created"}, {"sha": "eb453c4bb7b3b1d68c190fa34c12443ca7bb86f1", "filename": "src/librustc_mir/borrow_check/nll.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3f661d25f9ce3b5ac6139c8d8bf4614b55dca5be/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f661d25f9ce3b5ac6139c8d8bf4614b55dca5be/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs?ref=3f661d25f9ce3b5ac6139c8d8bf4614b55dca5be", "patch": "@@ -2,7 +2,7 @@\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Diagnostic;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::mir::{\n@@ -58,20 +58,20 @@ crate struct NllOutput<'tcx> {\n /// `compute_regions`.\n pub(in crate::borrow_check) fn replace_regions_in_mir<'cx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'tcx>,\n-    def_id: DefId,\n+    def_id: LocalDefId,\n     param_env: ty::ParamEnv<'tcx>,\n     body: &mut Body<'tcx>,\n     promoted: &mut IndexVec<Promoted, Body<'tcx>>,\n ) -> UniversalRegions<'tcx> {\n     debug!(\"replace_regions_in_mir(def_id={:?})\", def_id);\n \n     // Compute named region information. This also renumbers the inputs/outputs.\n-    let universal_regions = UniversalRegions::new(infcx, def_id.expect_local(), param_env);\n+    let universal_regions = UniversalRegions::new(infcx, def_id, param_env);\n \n     // Replace all remaining regions with fresh inference variables.\n     renumber::renumber_mir(infcx, body, promoted);\n \n-    let source = MirSource::item(def_id);\n+    let source = MirSource::item(def_id.to_def_id());\n     mir_util::dump_mir(infcx.tcx, None, \"renumber\", &0, source, body, |_, _| Ok(()));\n \n     universal_regions"}]}