{"sha": "2841bf3bc79bb866980c5aea55a96a3d1cdea2f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4NDFiZjNiYzc5YmI4NjY5ODBjNWFlYTU1YTk2YTNkMWNkZWEyZjY=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2016-12-16T07:13:00Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2016-12-16T07:13:00Z"}, "message": "Rustdoc: disambiguate Implementors when the type name is not unique", "tree": {"sha": "aa830cd0cb522bd43a2aae0feea5ea7ade2f53ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa830cd0cb522bd43a2aae0feea5ea7ade2f53ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2841bf3bc79bb866980c5aea55a96a3d1cdea2f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2841bf3bc79bb866980c5aea55a96a3d1cdea2f6", "html_url": "https://github.com/rust-lang/rust/commit/2841bf3bc79bb866980c5aea55a96a3d1cdea2f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2841bf3bc79bb866980c5aea55a96a3d1cdea2f6/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6483bdd860fd89fc68846d4cc94c7ae3307a84c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/6483bdd860fd89fc68846d4cc94c7ae3307a84c1", "html_url": "https://github.com/rust-lang/rust/commit/6483bdd860fd89fc68846d4cc94c7ae3307a84c1"}], "stats": {"total": 362, "additions": 196, "deletions": 166}, "files": [{"sha": "6808752b1fe05aa3436a6bb013bd302e96c17639", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 180, "deletions": 164, "changes": 344, "blob_url": "https://github.com/rust-lang/rust/blob/2841bf3bc79bb866980c5aea55a96a3d1cdea2f6/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2841bf3bc79bb866980c5aea55a96a3d1cdea2f6/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=2841bf3bc79bb866980c5aea55a96a3d1cdea2f6", "patch": "@@ -433,7 +433,7 @@ pub fn href(did: DefId) -> Option<(String, ItemType, Vec<String>)> {\n /// Used when rendering a `ResolvedPath` structure. This invokes the `path`\n /// rendering function with the necessary arguments for linking to a local path.\n fn resolved_path(w: &mut fmt::Formatter, did: DefId, path: &clean::Path,\n-                 print_all: bool) -> fmt::Result {\n+                 print_all: bool, use_absolute: bool) -> fmt::Result {\n     let last = path.segments.last().unwrap();\n     let rel_root = match &*path.segments[0].name {\n         \"self\" => Some(\"./\".to_string()),\n@@ -467,7 +467,17 @@ fn resolved_path(w: &mut fmt::Formatter, did: DefId, path: &clean::Path,\n     if w.alternate() {\n         write!(w, \"{:#}{:#}\", HRef::new(did, &last.name), last.params)?;\n     } else {\n-        write!(w, \"{}{}\", HRef::new(did, &last.name), last.params)?;\n+        let path = if use_absolute {\n+            match href(did) {\n+                Some((_, _, fqp)) => format!(\"{}::{}\",\n+                                             fqp[..fqp.len()-1].join(\"::\"),\n+                                             HRef::new(did, fqp.last().unwrap())),\n+                None => format!(\"{}\", HRef::new(did, &last.name)),\n+            }\n+        } else {\n+            format!(\"{}\", HRef::new(did, &last.name))\n+        };\n+        write!(w, \"{}{}\", path, last.params)?;\n     }\n     Ok(())\n }\n@@ -551,194 +561,198 @@ impl<'a> fmt::Display for HRef<'a> {\n     }\n }\n \n-impl fmt::Display for clean::Type {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            clean::Generic(ref name) => {\n-                f.write_str(name)\n-            }\n-            clean::ResolvedPath{ did, ref typarams, ref path, is_generic } => {\n-                // Paths like T::Output and Self::Output should be rendered with all segments\n-                resolved_path(f, did, path, is_generic)?;\n-                tybounds(f, typarams)\n+fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, full_path: bool) -> fmt::Result {\n+    match *t {\n+        clean::Generic(ref name) => {\n+            f.write_str(name)\n+        }\n+        clean::ResolvedPath{ did, ref typarams, ref path, is_generic } => {\n+            // Paths like T::Output and Self::Output should be rendered with all segments\n+            resolved_path(f, did, path, is_generic, full_path)?;\n+            tybounds(f, typarams)\n+        }\n+        clean::Infer => write!(f, \"_\"),\n+        clean::Primitive(prim) => primitive_link(f, prim, prim.as_str()),\n+        clean::BareFunction(ref decl) => {\n+            if f.alternate() {\n+                write!(f, \"{}{}fn{:#}{:#}\",\n+                       UnsafetySpace(decl.unsafety),\n+                       AbiSpace(decl.abi),\n+                       decl.generics,\n+                       decl.decl)\n+            } else {\n+                write!(f, \"{}{}fn{}{}\",\n+                       UnsafetySpace(decl.unsafety),\n+                       AbiSpace(decl.abi),\n+                       decl.generics,\n+                       decl.decl)\n             }\n-            clean::Infer => write!(f, \"_\"),\n-            clean::Primitive(prim) => primitive_link(f, prim, prim.as_str()),\n-            clean::BareFunction(ref decl) => {\n-                if f.alternate() {\n-                    write!(f, \"{}{}fn{:#}{:#}\",\n-                           UnsafetySpace(decl.unsafety),\n-                           AbiSpace(decl.abi),\n-                           decl.generics,\n-                           decl.decl)\n-                } else {\n-                    write!(f, \"{}{}fn{}{}\",\n-                           UnsafetySpace(decl.unsafety),\n-                           AbiSpace(decl.abi),\n-                           decl.generics,\n-                           decl.decl)\n+        }\n+        clean::Tuple(ref typs) => {\n+            match &typs[..] {\n+                &[] => primitive_link(f, PrimitiveType::Tuple, \"()\"),\n+                &[ref one] => {\n+                    primitive_link(f, PrimitiveType::Tuple, \"(\")?;\n+                    //carry f.alternate() into this display w/o branching manually\n+                    fmt::Display::fmt(one, f)?;\n+                    primitive_link(f, PrimitiveType::Tuple, \",)\")\n                 }\n-            }\n-            clean::Tuple(ref typs) => {\n-                match &typs[..] {\n-                    &[] => primitive_link(f, PrimitiveType::Tuple, \"()\"),\n-                    &[ref one] => {\n-                        primitive_link(f, PrimitiveType::Tuple, \"(\")?;\n-                        //carry f.alternate() into this display w/o branching manually\n-                        fmt::Display::fmt(one, f)?;\n-                        primitive_link(f, PrimitiveType::Tuple, \",)\")\n-                    }\n-                    many => {\n-                        primitive_link(f, PrimitiveType::Tuple, \"(\")?;\n-                        fmt::Display::fmt(&CommaSep(&many), f)?;\n-                        primitive_link(f, PrimitiveType::Tuple, \")\")\n-                    }\n+                many => {\n+                    primitive_link(f, PrimitiveType::Tuple, \"(\")?;\n+                    fmt::Display::fmt(&CommaSep(&many), f)?;\n+                    primitive_link(f, PrimitiveType::Tuple, \")\")\n                 }\n             }\n-            clean::Vector(ref t) => {\n-                primitive_link(f, PrimitiveType::Slice, &format!(\"[\"))?;\n-                fmt::Display::fmt(t, f)?;\n-                primitive_link(f, PrimitiveType::Slice, &format!(\"]\"))\n-            }\n-            clean::FixedVector(ref t, ref s) => {\n-                primitive_link(f, PrimitiveType::Array, \"[\")?;\n-                fmt::Display::fmt(t, f)?;\n-                if f.alternate() {\n-                    primitive_link(f, PrimitiveType::Array,\n-                                   &format!(\"; {}]\", s))\n-                } else {\n-                    primitive_link(f, PrimitiveType::Array,\n-                                   &format!(\"; {}]\", Escape(s)))\n-                }\n+        }\n+        clean::Vector(ref t) => {\n+            primitive_link(f, PrimitiveType::Slice, &format!(\"[\"))?;\n+            fmt::Display::fmt(t, f)?;\n+            primitive_link(f, PrimitiveType::Slice, &format!(\"]\"))\n+        }\n+        clean::FixedVector(ref t, ref s) => {\n+            primitive_link(f, PrimitiveType::Array, \"[\")?;\n+            fmt::Display::fmt(t, f)?;\n+            if f.alternate() {\n+                primitive_link(f, PrimitiveType::Array,\n+                               &format!(\"; {}]\", s))\n+            } else {\n+                primitive_link(f, PrimitiveType::Array,\n+                               &format!(\"; {}]\", Escape(s)))\n             }\n-            clean::Never => f.write_str(\"!\"),\n-            clean::RawPointer(m, ref t) => {\n-                match **t {\n-                    clean::Generic(_) | clean::ResolvedPath {is_generic: true, ..} => {\n-                        if f.alternate() {\n-                            primitive_link(f, clean::PrimitiveType::RawPointer,\n-                                           &format!(\"*{}{:#}\", RawMutableSpace(m), t))\n-                        } else {\n-                            primitive_link(f, clean::PrimitiveType::RawPointer,\n-                                           &format!(\"*{}{}\", RawMutableSpace(m), t))\n-                        }\n-                    }\n-                    _ => {\n+        }\n+        clean::Never => f.write_str(\"!\"),\n+        clean::RawPointer(m, ref t) => {\n+            match **t {\n+                clean::Generic(_) | clean::ResolvedPath {is_generic: true, ..} => {\n+                    if f.alternate() {\n                         primitive_link(f, clean::PrimitiveType::RawPointer,\n-                                       &format!(\"*{}\", RawMutableSpace(m)))?;\n-                        fmt::Display::fmt(t, f)\n+                                       &format!(\"*{}{:#}\", RawMutableSpace(m), t))\n+                    } else {\n+                        primitive_link(f, clean::PrimitiveType::RawPointer,\n+                                       &format!(\"*{}{}\", RawMutableSpace(m), t))\n                     }\n                 }\n+                _ => {\n+                    primitive_link(f, clean::PrimitiveType::RawPointer,\n+                                   &format!(\"*{}\", RawMutableSpace(m)))?;\n+                    fmt::Display::fmt(t, f)\n+                }\n             }\n-            clean::BorrowedRef{ lifetime: ref l, mutability, type_: ref ty} => {\n-                let lt = match *l {\n-                    Some(ref l) => format!(\"{} \", *l),\n-                    _ => \"\".to_string(),\n-                };\n-                let m = MutableSpace(mutability);\n-                match **ty {\n-                    clean::Vector(ref bt) => { // BorrowedRef{ ... Vector(T) } is &[T]\n-                        match **bt {\n-                            clean::Generic(_) =>\n-                                if f.alternate() {\n-                                    primitive_link(f, PrimitiveType::Slice,\n-                                        &format!(\"&{}{}[{:#}]\", lt, m, **bt))\n-                                } else {\n-                                    primitive_link(f, PrimitiveType::Slice,\n-                                        &format!(\"&amp;{}{}[{}]\", lt, m, **bt))\n-                                },\n-                            _ => {\n-                                if f.alternate() {\n-                                    primitive_link(f, PrimitiveType::Slice,\n-                                                   &format!(\"&{}{}[\", lt, m))?;\n-                                    write!(f, \"{:#}\", **bt)?;\n-                                } else {\n-                                    primitive_link(f, PrimitiveType::Slice,\n-                                                   &format!(\"&amp;{}{}[\", lt, m))?;\n-                                    write!(f, \"{}\", **bt)?;\n-                                }\n-                                primitive_link(f, PrimitiveType::Slice, \"]\")\n+        }\n+        clean::BorrowedRef{ lifetime: ref l, mutability, type_: ref ty} => {\n+            let lt = match *l {\n+                Some(ref l) => format!(\"{} \", *l),\n+                _ => \"\".to_string(),\n+            };\n+            let m = MutableSpace(mutability);\n+            match **ty {\n+                clean::Vector(ref bt) => { // BorrowedRef{ ... Vector(T) } is &[T]\n+                    match **bt {\n+                        clean::Generic(_) =>\n+                            if f.alternate() {\n+                                primitive_link(f, PrimitiveType::Slice,\n+                                    &format!(\"&{}{}[{:#}]\", lt, m, **bt))\n+                            } else {\n+                                primitive_link(f, PrimitiveType::Slice,\n+                                    &format!(\"&amp;{}{}[{}]\", lt, m, **bt))\n+                            },\n+                        _ => {\n+                            if f.alternate() {\n+                                primitive_link(f, PrimitiveType::Slice,\n+                                               &format!(\"&{}{}[\", lt, m))?;\n+                                write!(f, \"{:#}\", **bt)?;\n+                            } else {\n+                                primitive_link(f, PrimitiveType::Slice,\n+                                               &format!(\"&amp;{}{}[\", lt, m))?;\n+                                write!(f, \"{}\", **bt)?;\n                             }\n-                        }\n-                    }\n-                    _ => {\n-                        if f.alternate() {\n-                            write!(f, \"&{}{}{:#}\", lt, m, **ty)\n-                        } else {\n-                            write!(f, \"&amp;{}{}{}\", lt, m, **ty)\n+                            primitive_link(f, PrimitiveType::Slice, \"]\")\n                         }\n                     }\n                 }\n-            }\n-            clean::PolyTraitRef(ref bounds) => {\n-                for (i, bound) in bounds.iter().enumerate() {\n-                    if i != 0 {\n-                        write!(f, \" + \")?;\n-                    }\n+                _ => {\n                     if f.alternate() {\n-                        write!(f, \"{:#}\", *bound)?;\n+                        write!(f, \"&{}{}{:#}\", lt, m, **ty)\n                     } else {\n-                        write!(f, \"{}\", *bound)?;\n+                        write!(f, \"&amp;{}{}{}\", lt, m, **ty)\n                     }\n                 }\n-                Ok(())\n             }\n-            clean::ImplTrait(ref bounds) => {\n-                write!(f, \"impl \")?;\n-                for (i, bound) in bounds.iter().enumerate() {\n-                    if i != 0 {\n-                        write!(f, \" + \")?;\n-                    }\n-                    if f.alternate() {\n-                        write!(f, \"{:#}\", *bound)?;\n-                    } else {\n-                        write!(f, \"{}\", *bound)?;\n-                    }\n+        }\n+        clean::PolyTraitRef(ref bounds) => {\n+            for (i, bound) in bounds.iter().enumerate() {\n+                if i != 0 {\n+                    write!(f, \" + \")?;\n                 }\n-                Ok(())\n-            }\n-            // It's pretty unsightly to look at `<A as B>::C` in output, and\n-            // we've got hyperlinking on our side, so try to avoid longer\n-            // notation as much as possible by making `C` a hyperlink to trait\n-            // `B` to disambiguate.\n-            //\n-            // FIXME: this is still a lossy conversion and there should probably\n-            //        be a better way of representing this in general? Most of\n-            //        the ugliness comes from inlining across crates where\n-            //        everything comes in as a fully resolved QPath (hard to\n-            //        look at).\n-            clean::QPath {\n-                ref name,\n-                ref self_type,\n-                trait_: box clean::ResolvedPath { did, ref typarams, .. },\n-            } => {\n                 if f.alternate() {\n-                    write!(f, \"{:#}::\", self_type)?;\n+                    write!(f, \"{:#}\", *bound)?;\n                 } else {\n-                    write!(f, \"{}::\", self_type)?;\n+                    write!(f, \"{}\", *bound)?;\n                 }\n-                let path = clean::Path::singleton(name.clone());\n-                resolved_path(f, did, &path, false)?;\n-\n-                // FIXME: `typarams` are not rendered, and this seems bad?\n-                drop(typarams);\n-                Ok(())\n             }\n-            clean::QPath { ref name, ref self_type, ref trait_ } => {\n+            Ok(())\n+        }\n+        clean::ImplTrait(ref bounds) => {\n+            write!(f, \"impl \")?;\n+            for (i, bound) in bounds.iter().enumerate() {\n+                if i != 0 {\n+                    write!(f, \" + \")?;\n+                }\n                 if f.alternate() {\n-                    write!(f, \"<{:#} as {:#}>::{}\", self_type, trait_, name)\n+                    write!(f, \"{:#}\", *bound)?;\n                 } else {\n-                    write!(f, \"&lt;{} as {}&gt;::{}\", self_type, trait_, name)\n+                    write!(f, \"{}\", *bound)?;\n                 }\n             }\n-            clean::Unique(..) => {\n-                panic!(\"should have been cleaned\")\n+            Ok(())\n+        }\n+        // It's pretty unsightly to look at `<A as B>::C` in output, and\n+        // we've got hyperlinking on our side, so try to avoid longer\n+        // notation as much as possible by making `C` a hyperlink to trait\n+        // `B` to disambiguate.\n+        //\n+        // FIXME: this is still a lossy conversion and there should probably\n+        //        be a better way of representing this in general? Most of\n+        //        the ugliness comes from inlining across crates where\n+        //        everything comes in as a fully resolved QPath (hard to\n+        //        look at).\n+        clean::QPath {\n+            ref name,\n+            ref self_type,\n+            trait_: box clean::ResolvedPath { did, ref typarams, .. },\n+        } => {\n+            if f.alternate() {\n+                write!(f, \"{:#}::\", self_type)?;\n+            } else {\n+                write!(f, \"{}::\", self_type)?;\n+            }\n+            let path = clean::Path::singleton(name.clone());\n+            resolved_path(f, did, &path, true, full_path)?;\n+\n+            // FIXME: `typarams` are not rendered, and this seems bad?\n+            drop(typarams);\n+            Ok(())\n+        }\n+        clean::QPath { ref name, ref self_type, ref trait_ } => {\n+            if f.alternate() {\n+                write!(f, \"<{:#} as {:#}>::{}\", self_type, trait_, name)\n+            } else {\n+                write!(f, \"&lt;{} as {}&gt;::{}\", self_type, trait_, name)\n             }\n         }\n+        clean::Unique(..) => {\n+            panic!(\"should have been cleaned\")\n+        }\n+    }\n+}\n+\n+impl fmt::Display for clean::Type {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt_type(self, f, false)\n     }\n }\n \n-fn fmt_impl(i: &clean::Impl, f: &mut fmt::Formatter, link_trait: bool) -> fmt::Result {\n+fn fmt_impl(i: &clean::Impl, f: &mut fmt::Formatter, link_trait: bool, full: bool) -> fmt::Result {\n     let mut plain = String::new();\n \n     if f.alternate() {\n@@ -759,7 +773,7 @@ fn fmt_impl(i: &clean::Impl, f: &mut fmt::Formatter, link_trait: bool) -> fmt::R\n             plain.push_str(&format!(\"{:#}\", ty));\n         } else {\n             match *ty {\n-                clean::ResolvedPath{ typarams: None, ref path, is_generic: false, .. } => {\n+                clean::ResolvedPath { typarams: None, ref path, is_generic: false, .. } => {\n                     let last = path.segments.last().unwrap();\n                     fmt::Display::fmt(&last.name, f)?;\n                     fmt::Display::fmt(&last.params, f)?;\n@@ -772,7 +786,7 @@ fn fmt_impl(i: &clean::Impl, f: &mut fmt::Formatter, link_trait: bool) -> fmt::R\n         plain.push_str(\" for \");\n     }\n \n-    fmt::Display::fmt(&i.for_, f)?;\n+    fmt_type(&i.for_, f, full)?;\n     plain.push_str(&format!(\"{:#}\", i.for_));\n \n     fmt::Display::fmt(&WhereClause(&i.generics, plain.len() + 1), f)?;\n@@ -781,13 +795,15 @@ fn fmt_impl(i: &clean::Impl, f: &mut fmt::Formatter, link_trait: bool) -> fmt::R\n \n impl fmt::Display for clean::Impl {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt_impl(self, f, true)\n+        fmt_impl(self, f, true, false)\n     }\n }\n \n // The difference from above is that trait is not hyperlinked.\n-pub fn fmt_impl_for_trait_page(i: &clean::Impl, f: &mut fmt::Formatter) -> fmt::Result {\n-    fmt_impl(i, f, false)\n+pub fn fmt_impl_for_trait_page(i: &clean::Impl,\n+                               f: &mut fmt::Formatter,\n+                               disambiguate: bool) -> fmt::Result {\n+    fmt_impl(i, f, false, disambiguate)\n }\n \n impl fmt::Display for clean::Arguments {\n@@ -978,7 +994,7 @@ impl fmt::Display for clean::Import {\n impl fmt::Display for clean::ImportSource {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.did {\n-            Some(did) => resolved_path(f, did, &self.path, true),\n+            Some(did) => resolved_path(f, did, &self.path, true, false),\n             _ => {\n                 for (i, seg) in self.path.segments.iter().enumerate() {\n                     if i > 0 {"}, {"sha": "c7a25814553777f785d664492b2ef504d8e4a92b", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2841bf3bc79bb866980c5aea55a96a3d1cdea2f6/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2841bf3bc79bb866980c5aea55a96a3d1cdea2f6/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=2841bf3bc79bb866980c5aea55a96a3d1cdea2f6", "patch": "@@ -2111,9 +2111,23 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         <ul class='item-list' id='implementors-list'>\n     \")?;\n     if let Some(implementors) = cache.implementors.get(&it.def_id) {\n-        for i in implementors {\n+        for k in implementors.iter() {\n             write!(w, \"<li><code>\")?;\n-            fmt_impl_for_trait_page(&i.impl_, w)?;\n+            // If there's already another implementor that has the same abbridged name, use the\n+            // full path, for example in `std::iter::ExactSizeIterator`\n+            let mut dissambiguate = false;\n+            for l in implementors.iter() {\n+                match (k.impl_.for_.clone(), l.impl_.for_.clone()) {\n+                    (clean::Type::ResolvedPath {path: path_a, ..},\n+                     clean::Type::ResolvedPath {path: path_b, ..}) => {\n+                        if k.def_id != l.def_id && path_a.last_name() == path_b.last_name() {\n+                            dissambiguate = true;\n+                        }\n+                    }\n+                    _ => (),\n+                }\n+            }\n+            fmt_impl_for_trait_page(&k.impl_, w, dissambiguate)?;\n             writeln!(w, \"</code></li>\")?;\n         }\n     }"}]}