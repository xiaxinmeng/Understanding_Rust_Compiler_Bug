{"sha": "cecd7a9ae69689a884b4baf0a0c871a5b9eb1bb4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlY2Q3YTlhZTY5Njg5YTg4NGI0YmFmMGEwYzg3MWE1YjllYjFiYjQ=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-03-06T17:45:04Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-03-06T17:45:04Z"}, "message": "Add clif comments when in release mode\n\nFixes #1130", "tree": {"sha": "90d4573ed8b862249bafcfb531f80279f437af14", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90d4573ed8b862249bafcfb531f80279f437af14"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cecd7a9ae69689a884b4baf0a0c871a5b9eb1bb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cecd7a9ae69689a884b4baf0a0c871a5b9eb1bb4", "html_url": "https://github.com/rust-lang/rust/commit/cecd7a9ae69689a884b4baf0a0c871a5b9eb1bb4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cecd7a9ae69689a884b4baf0a0c871a5b9eb1bb4/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ca3384db63fcc938b2ed58b9c6f42ef93442e47", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ca3384db63fcc938b2ed58b9c6f42ef93442e47", "html_url": "https://github.com/rust-lang/rust/commit/4ca3384db63fcc938b2ed58b9c6f42ef93442e47"}], "stats": {"total": 219, "additions": 117, "deletions": 102}, "files": [{"sha": "5fbaed7283a6781400a2ca0628cc731ae49edb8e", "filename": "src/abi/comments.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cecd7a9ae69689a884b4baf0a0c871a5b9eb1bb4/src%2Fabi%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cecd7a9ae69689a884b4baf0a0c871a5b9eb1bb4/src%2Fabi%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fcomments.rs?ref=cecd7a9ae69689a884b4baf0a0c871a5b9eb1bb4", "patch": "@@ -11,9 +11,11 @@ use cranelift_codegen::entity::EntityRef;\n use crate::prelude::*;\n \n pub(super) fn add_args_header_comment(fx: &mut FunctionCx<'_, '_, '_>) {\n-    fx.add_global_comment(\n-        \"kind  loc.idx   param    pass mode                            ty\".to_string(),\n-    );\n+    if fx.clif_comments.enabled() {\n+        fx.add_global_comment(\n+            \"kind  loc.idx   param    pass mode                            ty\".to_string(),\n+        );\n+    }\n }\n \n pub(super) fn add_arg_comment<'tcx>(\n@@ -25,6 +27,10 @@ pub(super) fn add_arg_comment<'tcx>(\n     arg_abi_mode: PassMode,\n     arg_layout: TyAndLayout<'tcx>,\n ) {\n+    if !fx.clif_comments.enabled() {\n+        return;\n+    }\n+\n     let local = if let Some(local) = local {\n         Cow::Owned(format!(\"{:?}\", local))\n     } else {\n@@ -59,17 +65,22 @@ pub(super) fn add_arg_comment<'tcx>(\n }\n \n pub(super) fn add_locals_header_comment(fx: &mut FunctionCx<'_, '_, '_>) {\n-    fx.add_global_comment(String::new());\n-    fx.add_global_comment(\n-        \"kind  local ty                              size align (abi,pref)\".to_string(),\n-    );\n+    if fx.clif_comments.enabled() {\n+        fx.add_global_comment(String::new());\n+        fx.add_global_comment(\n+            \"kind  local ty                              size align (abi,pref)\".to_string(),\n+        );\n+    }\n }\n \n pub(super) fn add_local_place_comments<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     place: CPlace<'tcx>,\n     local: Local,\n ) {\n+    if !fx.clif_comments.enabled() {\n+        return;\n+    }\n     let TyAndLayout { ty, layout } = place.layout();\n     let rustc_target::abi::Layout { size, align, abi: _, variants: _, fields: _, largest_niche: _ } =\n         layout;\n@@ -90,7 +101,7 @@ pub(super) fn add_local_place_comments<'tcx>(\n             } else {\n                 Cow::Borrowed(\"\")\n             };\n-            match ptr.base_and_offset() {\n+            match ptr.debug_base_and_offset() {\n                 (crate::pointer::PointerBase::Addr(addr), offset) => {\n                     (\"reuse\", format!(\"storage={}{}{}\", addr, offset, meta).into())\n                 }"}, {"sha": "2328d40111a3df26362093e33c29ae99f7974274", "filename": "src/abi/mod.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cecd7a9ae69689a884b4baf0a0c871a5b9eb1bb4/src%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cecd7a9ae69689a884b4baf0a0c871a5b9eb1bb4/src%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fmod.rs?ref=cecd7a9ae69689a884b4baf0a0c871a5b9eb1bb4", "patch": "@@ -1,6 +1,5 @@\n //! Handling of everything related to the calling convention. Also fills `fx.local_map`.\n \n-#[cfg(debug_assertions)]\n mod comments;\n mod pass_mode;\n mod returning;\n@@ -75,8 +74,9 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n         let func_id = import_function(self.tcx, self.cx.module, inst);\n         let func_ref = self.cx.module.declare_func_in_func(func_id, &mut self.bcx.func);\n \n-        #[cfg(debug_assertions)]\n-        self.add_comment(func_ref, format!(\"{:?}\", inst));\n+        if self.clif_comments.enabled() {\n+            self.add_comment(func_ref, format!(\"{:?}\", inst));\n+        }\n \n         func_ref\n     }\n@@ -92,8 +92,7 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n         let func_id = self.cx.module.declare_function(&name, Linkage::Import, &sig).unwrap();\n         let func_ref = self.cx.module.declare_func_in_func(func_id, &mut self.bcx.func);\n         let call_inst = self.bcx.ins().call(func_ref, args);\n-        #[cfg(debug_assertions)]\n-        {\n+        if self.clif_comments.enabled() {\n             self.add_comment(call_inst, format!(\"easy_call {}\", name));\n         }\n         let results = self.bcx.inst_results(call_inst);\n@@ -149,7 +148,6 @@ fn make_local_place<'tcx>(\n         CPlace::new_stack_slot(fx, layout)\n     };\n \n-    #[cfg(debug_assertions)]\n     self::comments::add_local_place_comments(fx, place, local);\n \n     place\n@@ -163,7 +161,6 @@ pub(crate) fn codegen_fn_prelude<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, start_\n \n     let ssa_analyzed = crate::analyze::analyze(fx);\n \n-    #[cfg(debug_assertions)]\n     self::comments::add_args_header_comment(fx);\n \n     let mut block_params_iter = fx.bcx.func.dfg.block_params(start_block).to_vec().into_iter();\n@@ -228,7 +225,6 @@ pub(crate) fn codegen_fn_prelude<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, start_\n     fx.fn_abi = Some(fn_abi);\n     assert!(block_params_iter.next().is_none(), \"arg_value left behind\");\n \n-    #[cfg(debug_assertions)]\n     self::comments::add_locals_header_comment(fx);\n \n     for (local, arg_kind, ty) in func_params {\n@@ -256,7 +252,6 @@ pub(crate) fn codegen_fn_prelude<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, start_\n                         CPlace::for_ptr(addr, val.layout())\n                     };\n \n-                    #[cfg(debug_assertions)]\n                     self::comments::add_local_place_comments(fx, place, local);\n \n                     assert_eq!(fx.local_map.push(place), local);\n@@ -392,8 +387,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n     let (func_ref, first_arg) = match instance {\n         // Trait object call\n         Some(Instance { def: InstanceDef::Virtual(_, idx), .. }) => {\n-            #[cfg(debug_assertions)]\n-            {\n+            if fx.clif_comments.enabled() {\n                 let nop_inst = fx.bcx.ins().nop();\n                 fx.add_comment(\n                     nop_inst,\n@@ -414,8 +408,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n \n         // Indirect call\n         None => {\n-            #[cfg(debug_assertions)]\n-            {\n+            if fx.clif_comments.enabled() {\n                 let nop_inst = fx.bcx.ins().nop();\n                 fx.add_comment(nop_inst, \"indirect call\");\n             }"}, {"sha": "06b52168e65334c06340d53ef3ab1c84cff1f525", "filename": "src/abi/pass_mode.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cecd7a9ae69689a884b4baf0a0c871a5b9eb1bb4/src%2Fabi%2Fpass_mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cecd7a9ae69689a884b4baf0a0c871a5b9eb1bb4/src%2Fabi%2Fpass_mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fpass_mode.rs?ref=cecd7a9ae69689a884b4baf0a0c871a5b9eb1bb4", "patch": "@@ -248,8 +248,8 @@ pub(super) fn adjust_arg_for_abi<'tcx>(\n /// as necessary.\n pub(super) fn cvalue_for_param<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n-    #[cfg_attr(not(debug_assertions), allow(unused_variables))] local: Option<mir::Local>,\n-    #[cfg_attr(not(debug_assertions), allow(unused_variables))] local_field: Option<usize>,\n+    local: Option<mir::Local>,\n+    local_field: Option<usize>,\n     arg_abi: &ArgAbi<'tcx, Ty<'tcx>>,\n     block_params_iter: &mut impl Iterator<Item = Value>,\n ) -> Option<CValue<'tcx>> {\n@@ -263,7 +263,6 @@ pub(super) fn cvalue_for_param<'tcx>(\n         })\n         .collect::<SmallVec<[_; 2]>>();\n \n-    #[cfg(debug_assertions)]\n     crate::abi::comments::add_arg_comment(\n         fx,\n         \"arg\","}, {"sha": "b68c3a053b3923bc4f6170cb3ec74c2fdfe7921a", "filename": "src/abi/returning.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cecd7a9ae69689a884b4baf0a0c871a5b9eb1bb4/src%2Fabi%2Freturning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cecd7a9ae69689a884b4baf0a0c871a5b9eb1bb4/src%2Fabi%2Freturning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Freturning.rs?ref=cecd7a9ae69689a884b4baf0a0c871a5b9eb1bb4", "patch": "@@ -84,10 +84,6 @@ pub(super) fn codegen_return_param<'tcx>(\n         }\n     };\n \n-    #[cfg(not(debug_assertions))]\n-    let _ = ret_param;\n-\n-    #[cfg(debug_assertions)]\n     crate::abi::comments::add_arg_comment(\n         fx,\n         \"ret\","}, {"sha": "76425309ed5f9719d1f92b6f4680b999c38763dc", "filename": "src/base.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cecd7a9ae69689a884b4baf0a0c871a5b9eb1bb4/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cecd7a9ae69689a884b4baf0a0c871a5b9eb1bb4/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=cecd7a9ae69689a884b4baf0a0c871a5b9eb1bb4", "patch": "@@ -219,8 +219,7 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, '_>) {\n             codegen_stmt(fx, block, stmt);\n         }\n \n-        #[cfg(debug_assertions)]\n-        {\n+        if fx.clif_comments.enabled() {\n             let mut terminator_head = \"\\n\".to_string();\n             bb_data.terminator().kind.fmt_head(&mut terminator_head).unwrap();\n             let inst = fx.bcx.func.layout.last_inst(block).unwrap();\n@@ -433,12 +432,14 @@ fn codegen_stmt<'tcx>(\n \n     fx.set_debug_loc(stmt.source_info);\n \n-    #[cfg(false_debug_assertions)]\n+    #[cfg(disabled)]\n     match &stmt.kind {\n         StatementKind::StorageLive(..) | StatementKind::StorageDead(..) => {} // Those are not very useful\n         _ => {\n-            let inst = fx.bcx.func.layout.last_inst(cur_block).unwrap();\n-            fx.add_comment(inst, format!(\"{:?}\", stmt));\n+            if fx.clif_comments.enabled() {\n+                let inst = fx.bcx.func.layout.last_inst(cur_block).unwrap();\n+                fx.add_comment(inst, format!(\"{:?}\", stmt));\n+            }\n         }\n     }\n "}, {"sha": "b5874f62535cab275ff566754c398196b32b36e0", "filename": "src/common.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cecd7a9ae69689a884b4baf0a0c871a5b9eb1bb4/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cecd7a9ae69689a884b4baf0a0c871a5b9eb1bb4/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=cecd7a9ae69689a884b4baf0a0c871a5b9eb1bb4", "patch": "@@ -361,8 +361,7 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n         let _ = self.cx.module.define_data(msg_id, &data_ctx);\n \n         let local_msg_id = self.cx.module.declare_data_in_func(msg_id, self.bcx.func);\n-        #[cfg(debug_assertions)]\n-        {\n+        if self.clif_comments.enabled() {\n             self.add_comment(local_msg_id, msg);\n         }\n         self.bcx.ins().global_value(self.pointer_type, local_msg_id)"}, {"sha": "2f0687b0364db20cf786f15a0ff93be679e2e9bb", "filename": "src/constant.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cecd7a9ae69689a884b4baf0a0c871a5b9eb1bb4/src%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cecd7a9ae69689a884b4baf0a0c871a5b9eb1bb4/src%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconstant.rs?ref=cecd7a9ae69689a884b4baf0a0c871a5b9eb1bb4", "patch": "@@ -82,8 +82,9 @@ pub(crate) fn codegen_tls_ref<'tcx>(\n ) -> CValue<'tcx> {\n     let data_id = data_id_for_static(fx.tcx, fx.cx.module, def_id, false);\n     let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n-    #[cfg(debug_assertions)]\n-    fx.add_comment(local_data_id, format!(\"tls {:?}\", def_id));\n+    if fx.clif_comments.enabled() {\n+        fx.add_comment(local_data_id, format!(\"tls {:?}\", def_id));\n+    }\n     let tls_ptr = fx.bcx.ins().tls_value(fx.pointer_type, local_data_id);\n     CValue::by_val(tls_ptr, layout)\n }\n@@ -95,8 +96,9 @@ fn codegen_static_ref<'tcx>(\n ) -> CPlace<'tcx> {\n     let data_id = data_id_for_static(fx.tcx, fx.cx.module, def_id, false);\n     let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n-    #[cfg(debug_assertions)]\n-    fx.add_comment(local_data_id, format!(\"{:?}\", def_id));\n+    if fx.clif_comments.enabled() {\n+        fx.add_comment(local_data_id, format!(\"{:?}\", def_id));\n+    }\n     let global_ptr = fx.bcx.ins().global_value(fx.pointer_type, local_data_id);\n     assert!(!layout.is_unsized(), \"unsized statics aren't supported\");\n     assert!(\n@@ -182,8 +184,9 @@ pub(crate) fn codegen_const_value<'tcx>(\n                                 data_id_for_alloc_id(fx.cx.module, ptr.alloc_id, alloc.mutability);\n                             let local_data_id =\n                                 fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n-                            #[cfg(debug_assertions)]\n-                            fx.add_comment(local_data_id, format!(\"{:?}\", ptr.alloc_id));\n+                            if fx.clif_comments.enabled() {\n+                                fx.add_comment(local_data_id, format!(\"{:?}\", ptr.alloc_id));\n+                            }\n                             fx.bcx.ins().global_value(fx.pointer_type, local_data_id)\n                         }\n                         Some(GlobalAlloc::Function(instance)) => {\n@@ -198,8 +201,9 @@ pub(crate) fn codegen_const_value<'tcx>(\n                             let data_id = data_id_for_static(fx.tcx, fx.cx.module, def_id, false);\n                             let local_data_id =\n                                 fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n-                            #[cfg(debug_assertions)]\n-                            fx.add_comment(local_data_id, format!(\"{:?}\", def_id));\n+                            if fx.clif_comments.enabled() {\n+                                fx.add_comment(local_data_id, format!(\"{:?}\", def_id));\n+                            }\n                             fx.bcx.ins().global_value(fx.pointer_type, local_data_id)\n                         }\n                         None => bug!(\"missing allocation {:?}\", ptr.alloc_id),\n@@ -240,8 +244,9 @@ fn pointer_for_allocation<'tcx>(\n     let data_id = data_id_for_alloc_id(fx.cx.module, alloc_id, alloc.mutability);\n \n     let local_data_id = fx.cx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n-    #[cfg(debug_assertions)]\n-    fx.add_comment(local_data_id, format!(\"{:?}\", alloc_id));\n+    if fx.clif_comments.enabled() {\n+        fx.add_comment(local_data_id, format!(\"{:?}\", alloc_id));\n+    }\n     let global_ptr = fx.bcx.ins().global_value(fx.pointer_type, local_data_id);\n     crate::pointer::Pointer::new(global_ptr)\n }"}, {"sha": "1fb5e86aed7df4d74400ede3062e23cd6c7265d4", "filename": "src/inline_asm.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cecd7a9ae69689a884b4baf0a0c871a5b9eb1bb4/src%2Finline_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cecd7a9ae69689a884b4baf0a0c871a5b9eb1bb4/src%2Finline_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finline_asm.rs?ref=cecd7a9ae69689a884b4baf0a0c871a5b9eb1bb4", "patch": "@@ -197,8 +197,9 @@ fn call_inline_asm<'tcx>(\n         offset: None,\n         size: u32::try_from(slot_size.bytes()).unwrap(),\n     });\n-    #[cfg(debug_assertions)]\n-    fx.add_comment(stack_slot, \"inline asm scratch slot\");\n+    if fx.clif_comments.enabled() {\n+        fx.add_comment(stack_slot, \"inline asm scratch slot\");\n+    }\n \n     let inline_asm_func = fx\n         .cx\n@@ -214,8 +215,9 @@ fn call_inline_asm<'tcx>(\n         )\n         .unwrap();\n     let inline_asm_func = fx.cx.module.declare_func_in_func(inline_asm_func, &mut fx.bcx.func);\n-    #[cfg(debug_assertions)]\n-    fx.add_comment(inline_asm_func, asm_name);\n+    if fx.clif_comments.enabled() {\n+        fx.add_comment(inline_asm_func, asm_name);\n+    }\n \n     for (_reg, offset, value) in inputs {\n         fx.bcx.ins().stack_store(value, stack_slot, i32::try_from(offset.bytes()).unwrap());"}, {"sha": "8bb02a3e5585482b4e88a0135524f494a74ff184", "filename": "src/optimize/stack2reg.rs", "status": "modified", "additions": 47, "deletions": 42, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/cecd7a9ae69689a884b4baf0a0c871a5b9eb1bb4/src%2Foptimize%2Fstack2reg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cecd7a9ae69689a884b4baf0a0c871a5b9eb1bb4/src%2Foptimize%2Fstack2reg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foptimize%2Fstack2reg.rs?ref=cecd7a9ae69689a884b4baf0a0c871a5b9eb1bb4", "patch": "@@ -181,7 +181,6 @@ impl<'a> OptimizeContext<'a> {\n \n pub(super) fn optimize_function(\n     ctx: &mut Context,\n-    #[cfg_attr(not(debug_assertions), allow(unused_variables))]\n     clif_comments: &mut crate::pretty_clif::CommentWriter,\n ) {\n     combine_stack_addr_with_load_store(&mut ctx.func);\n@@ -192,8 +191,7 @@ pub(super) fn optimize_function(\n \n     remove_unused_stack_addr_and_stack_load(&mut opt_ctx);\n \n-    #[cfg(debug_assertions)]\n-    {\n+    if clif_comments.enabled() {\n         for (&OrdStackSlot(stack_slot), usage) in &opt_ctx.stack_slot_usage_map {\n             clif_comments.add_comment(stack_slot, format!(\"used by: {:?}\", usage));\n         }\n@@ -209,25 +207,27 @@ pub(super) fn optimize_function(\n         for load in users.stack_load.clone().into_iter() {\n             let potential_stores = users.potential_stores_for_load(&opt_ctx.ctx, load);\n \n-            #[cfg(debug_assertions)]\n-            for &store in &potential_stores {\n-                clif_comments.add_comment(\n-                    load,\n-                    format!(\n-                        \"Potential store -> load forwarding {} -> {} ({:?}, {:?})\",\n-                        opt_ctx.ctx.func.dfg.display_inst(store, None),\n-                        opt_ctx.ctx.func.dfg.display_inst(load, None),\n-                        spatial_overlap(&opt_ctx.ctx.func, store, load),\n-                        temporal_order(&opt_ctx.ctx, store, load),\n-                    ),\n-                );\n+            if clif_comments.enabled() {\n+                for &store in &potential_stores {\n+                    clif_comments.add_comment(\n+                        load,\n+                        format!(\n+                            \"Potential store -> load forwarding {} -> {} ({:?}, {:?})\",\n+                            opt_ctx.ctx.func.dfg.display_inst(store, None),\n+                            opt_ctx.ctx.func.dfg.display_inst(load, None),\n+                            spatial_overlap(&opt_ctx.ctx.func, store, load),\n+                            temporal_order(&opt_ctx.ctx, store, load),\n+                        ),\n+                    );\n+                }\n             }\n \n             match *potential_stores {\n                 [] => {\n-                    #[cfg(debug_assertions)]\n-                    clif_comments\n-                        .add_comment(load, \"[BUG?] Reading uninitialized memory\".to_string());\n+                    if clif_comments.enabled() {\n+                        clif_comments\n+                            .add_comment(load, \"[BUG?] Reading uninitialized memory\".to_string());\n+                    }\n                 }\n                 [store]\n                     if spatial_overlap(&opt_ctx.ctx.func, store, load) == SpatialOverlap::Full\n@@ -237,9 +237,12 @@ pub(super) fn optimize_function(\n                     // Only one store could have been the origin of the value.\n                     let stored_value = opt_ctx.ctx.func.dfg.inst_args(store)[0];\n \n-                    #[cfg(debug_assertions)]\n-                    clif_comments\n-                        .add_comment(load, format!(\"Store to load forward {} -> {}\", store, load));\n+                    if clif_comments.enabled() {\n+                        clif_comments.add_comment(\n+                            load,\n+                            format!(\"Store to load forward {} -> {}\", store, load),\n+                        );\n+                    }\n \n                     users.change_load_to_alias(&mut opt_ctx.ctx.func, load, stored_value);\n                 }\n@@ -250,33 +253,35 @@ pub(super) fn optimize_function(\n         for store in users.stack_store.clone().into_iter() {\n             let potential_loads = users.potential_loads_of_store(&opt_ctx.ctx, store);\n \n-            #[cfg(debug_assertions)]\n-            for &load in &potential_loads {\n-                clif_comments.add_comment(\n-                    store,\n-                    format!(\n-                        \"Potential load from store {} <- {} ({:?}, {:?})\",\n-                        opt_ctx.ctx.func.dfg.display_inst(load, None),\n-                        opt_ctx.ctx.func.dfg.display_inst(store, None),\n-                        spatial_overlap(&opt_ctx.ctx.func, store, load),\n-                        temporal_order(&opt_ctx.ctx, store, load),\n-                    ),\n-                );\n+            if clif_comments.enabled() {\n+                for &load in &potential_loads {\n+                    clif_comments.add_comment(\n+                        store,\n+                        format!(\n+                            \"Potential load from store {} <- {} ({:?}, {:?})\",\n+                            opt_ctx.ctx.func.dfg.display_inst(load, None),\n+                            opt_ctx.ctx.func.dfg.display_inst(store, None),\n+                            spatial_overlap(&opt_ctx.ctx.func, store, load),\n+                            temporal_order(&opt_ctx.ctx, store, load),\n+                        ),\n+                    );\n+                }\n             }\n \n             if potential_loads.is_empty() {\n                 // Never loaded; can safely remove all stores and the stack slot.\n                 // FIXME also remove stores when there is always a next store before a load.\n \n-                #[cfg(debug_assertions)]\n-                clif_comments.add_comment(\n-                    store,\n-                    format!(\n-                        \"Remove dead stack store {} of {}\",\n-                        opt_ctx.ctx.func.dfg.display_inst(store, None),\n-                        stack_slot.0\n-                    ),\n-                );\n+                if clif_comments.enabled() {\n+                    clif_comments.add_comment(\n+                        store,\n+                        format!(\n+                            \"Remove dead stack store {} of {}\",\n+                            opt_ctx.ctx.func.dfg.display_inst(store, None),\n+                            stack_slot.0\n+                        ),\n+                    );\n+                }\n \n                 users.remove_dead_store(&mut opt_ctx.ctx.func, store);\n             }"}, {"sha": "31d827f83bfab94543e32a1ffbe0f3918b6d62fd", "filename": "src/pointer.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cecd7a9ae69689a884b4baf0a0c871a5b9eb1bb4/src%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cecd7a9ae69689a884b4baf0a0c871a5b9eb1bb4/src%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpointer.rs?ref=cecd7a9ae69689a884b4baf0a0c871a5b9eb1bb4", "patch": "@@ -39,8 +39,7 @@ impl Pointer {\n         Pointer { base: PointerBase::Dangling(align), offset: Offset32::new(0) }\n     }\n \n-    #[cfg(debug_assertions)]\n-    pub(crate) fn base_and_offset(self) -> (PointerBase, Offset32) {\n+    pub(crate) fn debug_base_and_offset(self) -> (PointerBase, Offset32) {\n         (self.base, self.offset)\n     }\n "}, {"sha": "87f0e0c3738d7e3121042e88c0b33ec0da0cef57", "filename": "src/pretty_clif.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cecd7a9ae69689a884b4baf0a0c871a5b9eb1bb4/src%2Fpretty_clif.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cecd7a9ae69689a884b4baf0a0c871a5b9eb1bb4/src%2Fpretty_clif.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpretty_clif.rs?ref=cecd7a9ae69689a884b4baf0a0c871a5b9eb1bb4", "patch": "@@ -69,13 +69,15 @@ use crate::prelude::*;\n \n #[derive(Debug)]\n pub(crate) struct CommentWriter {\n+    enabled: bool,\n     global_comments: Vec<String>,\n     entity_comments: FxHashMap<AnyEntity, String>,\n }\n \n impl CommentWriter {\n     pub(crate) fn new<'tcx>(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> Self {\n-        let global_comments = if cfg!(debug_assertions) {\n+        let enabled = should_write_ir(tcx);\n+        let global_comments = if enabled {\n             vec![\n                 format!(\"symbol {}\", tcx.symbol_name(instance).name),\n                 format!(\"instance {:?}\", instance),\n@@ -86,13 +88,17 @@ impl CommentWriter {\n             vec![]\n         };\n \n-        CommentWriter { global_comments, entity_comments: FxHashMap::default() }\n+        CommentWriter { enabled, global_comments, entity_comments: FxHashMap::default() }\n     }\n }\n \n-#[cfg(debug_assertions)]\n impl CommentWriter {\n+    pub(crate) fn enabled(&self) -> bool {\n+        self.enabled\n+    }\n+\n     pub(crate) fn add_global_comment<S: Into<String>>(&mut self, comment: S) {\n+        debug_assert!(self.enabled);\n         self.global_comments.push(comment.into());\n     }\n \n@@ -101,6 +107,8 @@ impl CommentWriter {\n         entity: E,\n         comment: S,\n     ) {\n+        debug_assert!(self.enabled);\n+\n         use std::collections::hash_map::Entry;\n         match self.entity_comments.entry(entity.into()) {\n             Entry::Occupied(mut occ) => {\n@@ -179,7 +187,6 @@ impl FuncWriter for &'_ CommentWriter {\n     }\n }\n \n-#[cfg(debug_assertions)]\n impl FunctionCx<'_, '_, '_> {\n     pub(crate) fn add_global_comment<S: Into<String>>(&mut self, comment: S) {\n         self.clif_comments.add_global_comment(comment);"}, {"sha": "1ab0703e981e73f7f5724b5e5e085696474cc8a4", "filename": "src/trap.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cecd7a9ae69689a884b4baf0a0c871a5b9eb1bb4/src%2Ftrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cecd7a9ae69689a884b4baf0a0c871a5b9eb1bb4/src%2Ftrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftrap.rs?ref=cecd7a9ae69689a884b4baf0a0c871a5b9eb1bb4", "patch": "@@ -17,8 +17,7 @@ fn codegen_print(fx: &mut FunctionCx<'_, '_, '_>, msg: &str) {\n         )\n         .unwrap();\n     let puts = fx.cx.module.declare_func_in_func(puts, &mut fx.bcx.func);\n-    #[cfg(debug_assertions)]\n-    {\n+    if fx.clif_comments.enabled() {\n         fx.add_comment(puts, \"puts\");\n     }\n "}, {"sha": "1a6a301a45bbd0e313067a95748a21c410d17a2d", "filename": "src/value_and_place.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cecd7a9ae69689a884b4baf0a0c871a5b9eb1bb4/src%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cecd7a9ae69689a884b4baf0a0c871a5b9eb1bb4/src%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue_and_place.rs?ref=cecd7a9ae69689a884b4baf0a0c871a5b9eb1bb4", "patch": "@@ -413,7 +413,7 @@ impl<'tcx> CPlace<'tcx> {\n         self,\n         fx: &mut FunctionCx<'_, '_, 'tcx>,\n         from: CValue<'tcx>,\n-        #[cfg_attr(not(debug_assertions), allow(unused_variables))] method: &'static str,\n+        method: &'static str,\n     ) {\n         fn transmute_value<'tcx>(\n             fx: &mut FunctionCx<'_, '_, 'tcx>,\n@@ -461,8 +461,7 @@ impl<'tcx> CPlace<'tcx> {\n \n         assert_eq!(self.layout().size, from.layout().size);\n \n-        #[cfg(debug_assertions)]\n-        {\n+        if fx.clif_comments.enabled() {\n             use cranelift_codegen::cursor::{Cursor, CursorPosition};\n             let cur_block = match fx.bcx.cursor().position() {\n                 CursorPosition::After(block) => block,"}]}