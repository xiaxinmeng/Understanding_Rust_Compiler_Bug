{"sha": "65dd942fa1199361f2f7327bee71ae7ac5f4239d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1ZGQ5NDJmYTExOTkzNjFmMmY3MzI3YmVlNzFhZTdhYzVmNDIzOWQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-04-19T11:32:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-19T11:32:22Z"}, "message": "Merge #8565\n\n8565: Fill match arms assist: add remaining arms for tuple of enums r=iDawer a=iDawer\n\nFix for #8493\r\n\r\nHowever, the assist is still flaky and does not use `hir_ty::diagnostics::match_check`\n\nCo-authored-by: Dawer <7803845+iDawer@users.noreply.github.com>", "tree": {"sha": "78de2810cf35e5096aa715a1bc23abfc6696c2e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/78de2810cf35e5096aa715a1bc23abfc6696c2e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65dd942fa1199361f2f7327bee71ae7ac5f4239d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgfWpGCRBK7hj4Ov3rIwAAp4AIAIoJ5fEcJOI1fBzpBCSTUsOL\nCfov5EK9qTXd14x03ZF+Y/KUBJUA1MWnmZYSRDbJ2/NXATpq3Qzb1DzKubJG2iBk\nHktrDYrOqMpj3nEv82zNZkHunNO5+bjfiLL/441jFckq/wgLJZZGweKUx+3tMyf/\nXkUkLcIBv9WKNqWqtfp+OR1Zhjp6SrmDhMT3+DucSwtU3DkXuz3S9v2XFQGFBVc8\nuS/uIT3JCyG3u2hLMzckQUwJ/CMWY7Gdc+UBwwGSYqNV10VptU8ncebZnS2cEdYS\n2GpF8LqVNOVTHQuzKTIqRGN4SeH64JbhGqwN47kV3a7k1ZRFsdY2KogSLaDuJoA=\n=T2mh\n-----END PGP SIGNATURE-----\n", "payload": "tree 78de2810cf35e5096aa715a1bc23abfc6696c2e0\nparent 75bf8328994e0966d381061647ac7dbbce374b39\nparent 9222d3b0fb815f2fce871ee919c4f1efaf9fe177\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1618831942 +0000\ncommitter GitHub <noreply@github.com> 1618831942 +0000\n\nMerge #8565\n\n8565: Fill match arms assist: add remaining arms for tuple of enums r=iDawer a=iDawer\n\nFix for #8493\r\n\r\nHowever, the assist is still flaky and does not use `hir_ty::diagnostics::match_check`\n\nCo-authored-by: Dawer <7803845+iDawer@users.noreply.github.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65dd942fa1199361f2f7327bee71ae7ac5f4239d", "html_url": "https://github.com/rust-lang/rust/commit/65dd942fa1199361f2f7327bee71ae7ac5f4239d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65dd942fa1199361f2f7327bee71ae7ac5f4239d/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75bf8328994e0966d381061647ac7dbbce374b39", "url": "https://api.github.com/repos/rust-lang/rust/commits/75bf8328994e0966d381061647ac7dbbce374b39", "html_url": "https://github.com/rust-lang/rust/commit/75bf8328994e0966d381061647ac7dbbce374b39"}, {"sha": "9222d3b0fb815f2fce871ee919c4f1efaf9fe177", "url": "https://api.github.com/repos/rust-lang/rust/commits/9222d3b0fb815f2fce871ee919c4f1efaf9fe177", "html_url": "https://github.com/rust-lang/rust/commit/9222d3b0fb815f2fce871ee919c4f1efaf9fe177"}], "stats": {"total": 128, "additions": 100, "deletions": 28}, "files": [{"sha": "a30c4d04ee5b09cb74d2618ca34ad2ffccc2e1e0", "filename": "crates/ide_assists/src/handlers/fill_match_arms.rs", "status": "modified", "additions": 100, "deletions": 28, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/65dd942fa1199361f2f7327bee71ae7ac5f4239d/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65dd942fa1199361f2f7327bee71ae7ac5f4239d/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs?ref=65dd942fa1199361f2f7327bee71ae7ac5f4239d", "patch": "@@ -1,13 +1,14 @@\n use std::iter;\n \n+use either::Either;\n use hir::{Adt, HasSource, ModuleDef, Semantics};\n use ide_db::helpers::{mod_path_to_ast, FamousDefs};\n use ide_db::RootDatabase;\n use itertools::Itertools;\n use syntax::ast::{self, make, AstNode, MatchArm, NameOwner, Pat};\n \n use crate::{\n-    utils::{does_pat_match_variant, render_snippet, Cursor},\n+    utils::{self, render_snippet, Cursor},\n     AssistContext, AssistId, AssistKind, Assists,\n };\n \n@@ -48,6 +49,18 @@ pub(crate) fn fill_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option<\n         }\n     }\n \n+    let top_lvl_pats: Vec<_> = arms\n+        .iter()\n+        .filter_map(ast::MatchArm::pat)\n+        .flat_map(|pat| match pat {\n+            // Special casee OrPat as separate top-level pats\n+            Pat::OrPat(or_pat) => Either::Left(or_pat.pats()),\n+            _ => Either::Right(iter::once(pat)),\n+        })\n+        // Exclude top level wildcards so that they are expanded by this assist, retains status quo in #8129.\n+        .filter(|pat| !matches!(pat, Pat::WildcardPat(_)))\n+        .collect();\n+\n     let module = ctx.sema.scope(expr.syntax()).module()?;\n \n     let missing_arms: Vec<MatchArm> = if let Some(enum_def) = resolve_enum_def(&ctx.sema, &expr) {\n@@ -56,7 +69,7 @@ pub(crate) fn fill_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option<\n         let mut variants = variants\n             .into_iter()\n             .filter_map(|variant| build_pat(ctx.db(), module, variant))\n-            .filter(|variant_pat| is_variant_missing(&mut arms, variant_pat))\n+            .filter(|variant_pat| is_variant_missing(&top_lvl_pats, variant_pat))\n             .map(|pat| make::match_arm(iter::once(pat), make::expr_empty_block()))\n             .collect::<Vec<_>>();\n         if Some(enum_def) == FamousDefs(&ctx.sema, Some(module.krate())).core_option_Option() {\n@@ -66,11 +79,6 @@ pub(crate) fn fill_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option<\n         }\n         variants\n     } else if let Some(enum_defs) = resolve_tuple_of_enum_def(&ctx.sema, &expr) {\n-        // Partial fill not currently supported for tuple of enums.\n-        if !arms.is_empty() {\n-            return None;\n-        }\n-\n         // When calculating the match arms for a tuple of enums, we want\n         // to create a match arm for each possible combination of enum\n         // values. The `multi_cartesian_product` method transforms\n@@ -85,7 +93,7 @@ pub(crate) fn fill_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option<\n                     variants.into_iter().filter_map(|variant| build_pat(ctx.db(), module, variant));\n                 ast::Pat::from(make::tuple_pat(patterns))\n             })\n-            .filter(|variant_pat| is_variant_missing(&mut arms, variant_pat))\n+            .filter(|variant_pat| is_variant_missing(&top_lvl_pats, variant_pat))\n             .map(|pat| make::match_arm(iter::once(pat), make::expr_empty_block()))\n             .collect()\n     } else {\n@@ -128,16 +136,19 @@ pub(crate) fn fill_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option<\n     )\n }\n \n-fn is_variant_missing(existing_arms: &mut Vec<MatchArm>, var: &Pat) -> bool {\n-    existing_arms.iter().filter_map(|arm| arm.pat()).all(|pat| {\n-        // Special casee OrPat as separate top-level pats\n-        let top_level_pats: Vec<Pat> = match pat {\n-            Pat::OrPat(pats) => pats.pats().collect::<Vec<_>>(),\n-            _ => vec![pat],\n-        };\n+fn is_variant_missing(existing_pats: &[Pat], var: &Pat) -> bool {\n+    !existing_pats.iter().any(|pat| does_pat_match_variant(pat, var))\n+}\n \n-        !top_level_pats.iter().any(|pat| does_pat_match_variant(pat, var))\n-    })\n+// Fixme: this is still somewhat limited, use hir_ty::diagnostics::match_check?\n+fn does_pat_match_variant(pat: &Pat, var: &Pat) -> bool {\n+    match (pat, var) {\n+        (Pat::WildcardPat(_), _) => true,\n+        (Pat::TuplePat(tpat), Pat::TuplePat(tvar)) => {\n+            tpat.fields().zip(tvar.fields()).all(|(p, v)| does_pat_match_variant(&p, &v))\n+        }\n+        _ => utils::does_pat_match_variant(pat, var),\n+    }\n }\n \n fn resolve_enum_def(sema: &Semantics<RootDatabase>, expr: &ast::Expr) -> Option<hir::Enum> {\n@@ -467,20 +478,81 @@ fn main() {\n \n     #[test]\n     fn fill_match_arms_tuple_of_enum_partial() {\n-        check_assist_not_applicable(\n+        check_assist(\n             fill_match_arms,\n             r#\"\n-            enum A { One, Two }\n-            enum B { One, Two }\n+enum A { One, Two }\n+enum B { One, Two }\n \n-            fn main() {\n-                let a = A::One;\n-                let b = B::One;\n-                match (a$0, b) {\n-                    (A::Two, B::One) => {}\n-                }\n-            }\n-            \"#,\n+fn main() {\n+    let a = A::One;\n+    let b = B::One;\n+    match (a$0, b) {\n+        (A::Two, B::One) => {}\n+    }\n+}\n+\"#,\n+            r#\"\n+enum A { One, Two }\n+enum B { One, Two }\n+\n+fn main() {\n+    let a = A::One;\n+    let b = B::One;\n+    match (a, b) {\n+        (A::Two, B::One) => {}\n+        $0(A::One, B::One) => {}\n+        (A::One, B::Two) => {}\n+        (A::Two, B::Two) => {}\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn fill_match_arms_tuple_of_enum_partial_with_wildcards() {\n+        let ra_fixture = r#\"\n+fn main() {\n+    let a = Some(1);\n+    let b = Some(());\n+    match (a$0, b) {\n+        (Some(_), _) => {}\n+        (None, Some(_)) => {}\n+    }\n+}\n+\"#;\n+        check_assist(\n+            fill_match_arms,\n+            &format!(\"//- /main.rs crate:main deps:core{}{}\", ra_fixture, FamousDefs::FIXTURE),\n+            r#\"\n+fn main() {\n+    let a = Some(1);\n+    let b = Some(());\n+    match (a, b) {\n+        (Some(_), _) => {}\n+        (None, Some(_)) => {}\n+        $0(None, None) => {}\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn fill_match_arms_partial_with_deep_pattern() {\n+        // Fixme: cannot handle deep patterns\n+        let ra_fixture = r#\"\n+fn main() {\n+    match $0Some(true) {\n+        Some(true) => {}\n+        None => {}\n+    }\n+}\n+\"#;\n+        check_assist_not_applicable(\n+            fill_match_arms,\n+            &format!(\"//- /main.rs crate:main deps:core{}{}\", ra_fixture, FamousDefs::FIXTURE),\n         );\n     }\n "}]}