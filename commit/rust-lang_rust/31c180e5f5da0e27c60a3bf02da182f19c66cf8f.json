{"sha": "31c180e5f5da0e27c60a3bf02da182f19c66cf8f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxYzE4MGU1ZjVkYTBlMjdjNjBhM2JmMDJkYTE4MmYxOWM2NmNmOGY=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2013-07-18T04:12:36Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2013-07-23T22:23:02Z"}, "message": "extra: clean up workcache to use & in place of @ most places.", "tree": {"sha": "8d901b850652b02677a0fe3fbe1fc997ae1811e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d901b850652b02677a0fe3fbe1fc997ae1811e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31c180e5f5da0e27c60a3bf02da182f19c66cf8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31c180e5f5da0e27c60a3bf02da182f19c66cf8f", "html_url": "https://github.com/rust-lang/rust/commit/31c180e5f5da0e27c60a3bf02da182f19c66cf8f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31c180e5f5da0e27c60a3bf02da182f19c66cf8f/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d9181bd760cb89171e892204338bb64275eb4e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d9181bd760cb89171e892204338bb64275eb4e5", "html_url": "https://github.com/rust-lang/rust/commit/1d9181bd760cb89171e892204338bb64275eb4e5"}], "stats": {"total": 129, "additions": 71, "deletions": 58}, "files": [{"sha": "f7585ca03ba56c83b8301f7174ca03de9eb62982", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 71, "deletions": 58, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/31c180e5f5da0e27c60a3bf02da182f19c66cf8f/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31c180e5f5da0e27c60a3bf02da182f19c66cf8f/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=31c180e5f5da0e27c60a3bf02da182f19c66cf8f", "patch": "@@ -124,6 +124,15 @@ struct Database {\n }\n \n impl Database {\n+\n+    pub fn new(p: Path) -> Database {\n+        Database {\n+            db_filename: p,\n+            db_cache: TreeMap::new(),\n+            db_dirty: false\n+        }\n+    }\n+\n     pub fn prepare(&self,\n                    fn_name: &str,\n                    declared_inputs: &WorkMap)\n@@ -156,22 +165,26 @@ struct Logger {\n }\n \n impl Logger {\n+\n+    pub fn new() -> Logger {\n+        Logger { a: () }\n+    }\n+\n     pub fn info(&self, i: &str) {\n         io::println(~\"workcache: \" + i);\n     }\n }\n \n struct Context {\n     db: RWARC<Database>,\n-    logger: @mut Logger,\n+    logger: Logger,\n     cfg: json::Object,\n     freshness: TreeMap<~str,@fn(&str,&str)->bool>\n }\n \n-#[deriving(Clone)]\n-struct Prep {\n-    ctxt: @Context,\n-    fn_name: ~str,\n+struct Prep<'self> {\n+    ctxt: &'self Context,\n+    fn_name: &'self str,\n     declared_inputs: WorkMap,\n }\n \n@@ -180,8 +193,8 @@ struct Exec {\n     discovered_outputs: WorkMap\n }\n \n-struct Work<T> {\n-    prep: @mut Prep,\n+struct Work<'self, T> {\n+    prep: &'self Prep<'self>,\n     res: Option<Either<T,PortOne<(Exec,T)>>>\n }\n \n@@ -215,8 +228,8 @@ fn digest_file(path: &Path) -> ~str {\n }\n \n impl Context {\n-    pub fn new(db: RWARC<Database>, lg: @mut Logger, cfg: json::Object)\n-               -> Context {\n+\n+    pub fn new(db: RWARC<Database>, lg: Logger, cfg: json::Object) -> Context {\n         Context {\n             db: db,\n             logger: lg,\n@@ -225,33 +238,28 @@ impl Context {\n         }\n     }\n \n-    pub fn prep<T:Send +\n-                  Encodable<json::Encoder> +\n-                  Decodable<json::Decoder>>(@self, // FIXME(#5121)\n-                                            fn_name:&str,\n-                                            blk: &fn(@mut Prep)->Work<T>)\n-                                            -> Work<T> {\n-        let p = @mut Prep {\n-            ctxt: self,\n-            fn_name: fn_name.to_owned(),\n-            declared_inputs: WorkMap::new()\n-        };\n-        blk(p)\n+    pub fn prep<'a>(&'a self, fn_name: &'a str) -> Prep<'a> {\n+        Prep::new(self, fn_name)\n     }\n-}\n \n+    pub fn with_prep<'a, T>(&'a self, fn_name: &'a str, blk: &fn(p: &mut Prep) -> T) -> T {\n+        let mut p = self.prep(fn_name);\n+        blk(&mut p)\n+    }\n \n-trait TPrep {\n-    fn declare_input(&mut self, kind:&str, name:&str, val:&str);\n-    fn is_fresh(&self, cat:&str, kind:&str, name:&str, val:&str) -> bool;\n-    fn all_fresh(&self, cat:&str, map:&WorkMap) -> bool;\n-    fn exec<T:Send +\n-              Encodable<json::Encoder> +\n-              Decodable<json::Decoder>>( // FIXME(#5121)\n-        &self, blk: ~fn(&Exec) -> T) -> Work<T>;\n }\n \n-impl TPrep for Prep {\n+impl<'self> Prep<'self> {\n+    fn new(ctxt: &'self Context, fn_name: &'self str) -> Prep<'self> {\n+        Prep {\n+            ctxt: ctxt,\n+            fn_name: fn_name,\n+            declared_inputs: WorkMap::new()\n+        }\n+    }\n+}\n+\n+impl<'self> Prep<'self> {\n     fn declare_input(&mut self, kind:&str, name:&str, val:&str) {\n         self.declared_inputs.insert(WorkKey::new(kind, name),\n                                  val.to_owned());\n@@ -286,22 +294,28 @@ impl TPrep for Prep {\n     }\n \n     fn exec<T:Send +\n-              Encodable<json::Encoder> +\n-              Decodable<json::Decoder>>( // FIXME(#5121)\n-            &self, blk: ~fn(&Exec) -> T) -> Work<T> {\n+        Encodable<json::Encoder> +\n+        Decodable<json::Decoder>>(\n+            &'self self, blk: ~fn(&Exec) -> T) -> T {\n+        self.exec_work(blk).unwrap()\n+    }\n+\n+    fn exec_work<T:Send +\n+        Encodable<json::Encoder> +\n+        Decodable<json::Decoder>>( // FIXME(#5121)\n+            &'self self, blk: ~fn(&Exec) -> T) -> Work<'self, T> {\n         let mut bo = Some(blk);\n \n         let cached = do self.ctxt.db.read |db| {\n             db.prepare(self.fn_name, &self.declared_inputs)\n         };\n \n-        match cached {\n+        let res = match cached {\n             Some((ref disc_in, ref disc_out, ref res))\n-            if self.all_fresh(\"declared input\",\n-                              &self.declared_inputs) &&\n-            self.all_fresh(\"discovered input\", disc_in) &&\n-            self.all_fresh(\"discovered output\", disc_out) => {\n-                Work::new(@mut (*self).clone(), Left(json_decode(*res)))\n+            if self.all_fresh(\"declared input\",&self.declared_inputs) &&\n+               self.all_fresh(\"discovered input\", disc_in) &&\n+               self.all_fresh(\"discovered output\", disc_out) => {\n+                Left(json_decode(*res))\n             }\n \n             _ => {\n@@ -318,16 +332,19 @@ impl TPrep for Prep {\n                     let v = blk(&exe);\n                     send_one(chan, (exe, v));\n                 }\n-                Work::new(@mut (*self).clone(), Right(port))\n+                Right(port)\n             }\n-        }\n+        };\n+        Work::new(self, res)\n     }\n }\n \n-impl<T:Send +\n+impl<'self, T:Send +\n        Encodable<json::Encoder> +\n-       Decodable<json::Decoder>> Work<T> { // FIXME(#5121)\n-    pub fn new(p: @mut Prep, e: Either<T,PortOne<(Exec,T)>>) -> Work<T> {\n+       Decodable<json::Decoder>>\n+    Work<'self, T> { // FIXME(#5121)\n+\n+    pub fn new(p: &'self Prep<'self>, e: Either<T,PortOne<(Exec,T)>>) -> Work<'self, T> {\n         Work { prep: p, res: Some(e) }\n     }\n \n@@ -357,26 +374,22 @@ impl<T:Send +\n fn test() {\n     use std::io::WriterUtil;\n \n-    let db = RWARC(Database { db_filename: Path(\"db.json\"),\n-                              db_cache: TreeMap::new(),\n-                              db_dirty: false });\n-    let lg = @mut Logger { a: () };\n-    let cfg = HashMap::new();\n-    let cx = @Context::new(db, lg, cfg);\n-    let w:Work<~str> = do cx.prep(\"test1\") |prep| {\n-        let pth = Path(\"foo.c\");\n-        {\n-            let file = io::file_writer(&pth, [io::Create]).unwrap();\n-            file.write_str(\"int main() { return 0; }\");\n-        }\n+    let pth = Path(\"foo.c\");\n+    {\n+        let r = io::file_writer(&pth, [io::Create]);\n+        r.get_ref().write_str(\"int main() { return 0; }\");\n+    }\n+\n+    let cx = Context::new(RWARC(Database::new(Path(\"db.json\"))),\n+                          Logger::new(), HashMap::new());\n \n+    let s = do cx.with_prep(\"test1\") |prep| {\n         prep.declare_input(\"file\", pth.to_str(), digest_file(&pth));\n         do prep.exec |_exe| {\n             let out = Path(\"foo.o\");\n             run::process_status(\"gcc\", [~\"foo.c\", ~\"-o\", out.to_str()]);\n             out.to_str()\n         }\n     };\n-    let s = w.unwrap();\n     io::println(s);\n }"}]}