{"sha": "7552af2f6f66e4a41b9590def5865f5a79b2910e", "node_id": "C_kwDOAAsO6NoAKDc1NTJhZjJmNmY2NmU0YTQxYjk1OTBkZWY1ODY1ZjVhNzliMjkxMGU", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2021-10-21T13:09:24Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2021-10-21T13:09:24Z"}, "message": "Revert \"Auto merge of #89100 - petrochenkov:localbind, r=cjgillot\"\n\nThis reverts commit 6162529a01473bbb2427fa27354cbafc3c514eee.", "tree": {"sha": "3b976951036ab8800a943f555edba2872057a35c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b976951036ab8800a943f555edba2872057a35c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7552af2f6f66e4a41b9590def5865f5a79b2910e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7552af2f6f66e4a41b9590def5865f5a79b2910e", "html_url": "https://github.com/rust-lang/rust/commit/7552af2f6f66e4a41b9590def5865f5a79b2910e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7552af2f6f66e4a41b9590def5865f5a79b2910e/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "efd0483949496b067cd5f7569d1b28cd3d5d3c72", "url": "https://api.github.com/repos/rust-lang/rust/commits/efd0483949496b067cd5f7569d1b28cd3d5d3c72", "html_url": "https://github.com/rust-lang/rust/commit/efd0483949496b067cd5f7569d1b28cd3d5d3c72"}], "stats": {"total": 358, "additions": 213, "deletions": 145}, "files": [{"sha": "0a24e00ee4bf5137b88eadef81b20a09266b4ebb", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 74, "deletions": 87, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/7552af2f6f66e4a41b9590def5865f5a79b2910e/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7552af2f6f66e4a41b9590def5865f5a79b2910e/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=7552af2f6f66e4a41b9590def5865f5a79b2910e", "patch": "@@ -7,7 +7,7 @@\n \n use RibKind::*;\n \n-use crate::{path_names_to_string, BindingError, CrateLint, NameBinding, ToNameBinding};\n+use crate::{path_names_to_string, BindingError, CrateLint, LexicalScopeBinding};\n use crate::{Module, ModuleOrUniformRoot, ParentScope, PathResult};\n use crate::{ResolutionError, Resolver, Segment, UseError};\n \n@@ -21,22 +21,27 @@ use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorKind, DefKind, PartialRes, PerNS};\n use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc_hir::{PrimTy, TraitCandidate};\n-use rustc_middle::{bug, span_bug, ty};\n+use rustc_middle::{bug, span_bug};\n use rustc_session::lint;\n-use rustc_span::source_map::{respan, Spanned};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n-use rustc_span::{Span, DUMMY_SP};\n+use rustc_span::Span;\n use smallvec::{smallvec, SmallVec};\n-use tracing::debug;\n \n+use rustc_span::source_map::{respan, Spanned};\n use std::collections::{hash_map::Entry, BTreeSet};\n use std::mem::{replace, take};\n+use tracing::debug;\n \n mod diagnostics;\n crate mod lifetimes;\n \n type Res = def::Res<NodeId>;\n \n+type IdentMap<T> = FxHashMap<Ident, T>;\n+\n+/// Map from the name in a pattern to its binding mode.\n+type BindingMap = IdentMap<BindingInfo>;\n+\n #[derive(Copy, Clone, Debug)]\n struct BindingInfo {\n     span: Span,\n@@ -167,8 +172,8 @@ impl RibKind<'_> {\n /// The resolution keeps a separate stack of ribs as it traverses the AST for each namespace. When\n /// resolving, the name is looked up from inside out.\n #[derive(Debug)]\n-crate struct Rib<'a, R = &'a NameBinding<'a>> {\n-    pub bindings: FxHashMap<Ident, R>,\n+crate struct Rib<'a, R = Res> {\n+    pub bindings: IdentMap<R>,\n     pub kind: RibKind<'a>,\n }\n \n@@ -562,12 +567,12 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                 GenericParamKind::Type { .. } => {\n                     forward_ty_ban_rib\n                         .bindings\n-                        .insert(Ident::with_dummy_span(param.ident.name), self.r.dummy_binding);\n+                        .insert(Ident::with_dummy_span(param.ident.name), Res::Err);\n                 }\n                 GenericParamKind::Const { .. } => {\n                     forward_const_ban_rib\n                         .bindings\n-                        .insert(Ident::with_dummy_span(param.ident.name), self.r.dummy_binding);\n+                        .insert(Ident::with_dummy_span(param.ident.name), Res::Err);\n                 }\n                 GenericParamKind::Lifetime => {}\n             }\n@@ -584,9 +589,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n         // such as in the case of `trait Add<Rhs = Self>`.)\n         if self.diagnostic_metadata.current_self_item.is_some() {\n             // (`Some` if + only if we are in ADT's generics.)\n-            forward_ty_ban_rib\n-                .bindings\n-                .insert(Ident::with_dummy_span(kw::SelfUpper), self.r.dummy_binding);\n+            forward_ty_ban_rib.bindings.insert(Ident::with_dummy_span(kw::SelfUpper), Res::Err);\n         }\n \n         for param in &generics.params {\n@@ -734,17 +737,15 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         ns: Namespace,\n         record_used_id: Option<NodeId>,\n         path_span: Span,\n-    ) -> Option<&'a NameBinding<'a>> {\n-        self.r\n-            .resolve_ident_in_lexical_scope(\n-                ident,\n-                ns,\n-                &self.parent_scope,\n-                record_used_id,\n-                path_span,\n-                &self.ribs[ns],\n-            )\n-            .ok()\n+    ) -> Option<LexicalScopeBinding<'a>> {\n+        self.r.resolve_ident_in_lexical_scope(\n+            ident,\n+            ns,\n+            &self.parent_scope,\n+            record_used_id,\n+            path_span,\n+            &self.ribs[ns],\n+        )\n     }\n \n     fn resolve_path(\n@@ -902,10 +903,6 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     }\n \n     fn future_proof_import(&mut self, use_tree: &UseTree) {\n-        if !self.should_report_errs() {\n-            return;\n-        }\n-\n         let segments = &use_tree.prefix.segments;\n         if !segments.is_empty() {\n             let ident = segments[0].ident;\n@@ -917,42 +914,31 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 UseTreeKind::Simple(..) if segments.len() == 1 => &[TypeNS, ValueNS][..],\n                 _ => &[TypeNS],\n             };\n-\n-            let from_ribs = |binding: &NameBinding<'_>| {\n-                matches!(\n-                    binding.res(),\n-                    Res::Local(..)\n-                        | Res::SelfTy(..)\n-                        | Res::Def(DefKind::TyParam | DefKind::ConstParam, ..)\n-                )\n-            };\n             let report_error = |this: &Self, ns| {\n                 let what = if ns == TypeNS { \"type parameters\" } else { \"local variables\" };\n-                let msg = format!(\"imports cannot refer to {what}\");\n-                this.r.session.span_err(ident.span, &msg);\n+                if this.should_report_errs() {\n+                    this.r\n+                        .session\n+                        .span_err(ident.span, &format!(\"imports cannot refer to {}\", what));\n+                }\n             };\n \n             for &ns in nss {\n-                if let Some(binding) =\n-                    self.resolve_ident_in_lexical_scope(ident, ns, None, use_tree.prefix.span)\n-                {\n-                    if from_ribs(binding) {\n+                match self.resolve_ident_in_lexical_scope(ident, ns, None, use_tree.prefix.span) {\n+                    Some(LexicalScopeBinding::Res(..)) => {\n                         report_error(self, ns);\n-                    } else {\n+                    }\n+                    Some(LexicalScopeBinding::Item(binding)) => {\n                         let orig_unusable_binding =\n                             replace(&mut self.r.unusable_binding, Some(binding));\n-                        if let Some(binding) = self.resolve_ident_in_lexical_scope(\n-                            ident,\n-                            ns,\n-                            None,\n-                            use_tree.prefix.span,\n-                        ) {\n-                            if from_ribs(binding) {\n-                                report_error(self, ns);\n-                            }\n+                        if let Some(LexicalScopeBinding::Res(..)) = self\n+                            .resolve_ident_in_lexical_scope(ident, ns, None, use_tree.prefix.span)\n+                        {\n+                            report_error(self, ns);\n                         }\n                         self.r.unusable_binding = orig_unusable_binding;\n                     }\n+                    None => {}\n                 }\n             }\n         } else if let UseTreeKind::Nested(use_trees) = &use_tree.kind {\n@@ -1149,12 +1135,8 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 _ => unreachable!(),\n             };\n             let res = Res::Def(def_kind, self.r.local_def_id(param.id).to_def_id());\n-            let binding =\n-                (res, ty::Visibility::Invisible, param.ident.span, self.parent_scope.expansion)\n-                    .to_name_binding(self.r.arenas);\n-\n             self.r.record_partial_res(param.id, PartialRes::new(res));\n-            rib.bindings.insert(ident, binding);\n+            rib.bindings.insert(ident, res);\n         }\n \n         self.ribs[ValueNS].push(function_value_rib);\n@@ -1274,12 +1256,10 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     }\n \n     fn with_self_rib_ns(&mut self, ns: Namespace, self_res: Res, f: impl FnOnce(&mut Self)) {\n-        let binding = (self_res, ty::Visibility::Invisible, DUMMY_SP, self.parent_scope.expansion)\n-            .to_name_binding(self.r.arenas);\n         let mut self_type_rib = Rib::new(NormalRibKind);\n \n         // Plain insert (no renaming, since types are not currently hygienic)\n-        self_type_rib.bindings.insert(Ident::with_dummy_span(kw::SelfUpper), binding);\n+        self_type_rib.bindings.insert(Ident::with_dummy_span(kw::SelfUpper), self_res);\n         self.ribs[ns].push(self_type_rib);\n         f(self);\n         self.ribs[ns].pop();\n@@ -1490,7 +1470,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     /// this is done hygienically. This could arise for a macro\n     /// that expands into an or-pattern where one 'x' was from the\n     /// user and one 'x' came from the macro.\n-    fn binding_mode_map(&mut self, pat: &Pat) -> FxHashMap<Ident, BindingInfo> {\n+    fn binding_mode_map(&mut self, pat: &Pat) -> BindingMap {\n         let mut binding_map = FxHashMap::default();\n \n         pat.walk(&mut |pat| {\n@@ -1523,7 +1503,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n \n     /// Checks that all of the arms in an or-pattern have exactly the\n     /// same set of bindings, with the same binding modes for each.\n-    fn check_consistent_bindings(&mut self, pats: &[P<Pat>]) -> Vec<FxHashMap<Ident, BindingInfo>> {\n+    fn check_consistent_bindings(&mut self, pats: &[P<Pat>]) -> Vec<BindingMap> {\n         let mut missing_vars = FxHashMap::default();\n         let mut inconsistent_vars = FxHashMap::default();\n \n@@ -1665,6 +1645,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                         .try_resolve_as_non_binding(pat_src, pat, bmode, ident, has_sub)\n                         .unwrap_or_else(|| self.fresh_binding(ident, pat.id, pat_src, bindings));\n                     self.r.record_partial_res(pat.id, PartialRes::new(res));\n+                    self.r.record_pat_span(pat.id, pat.span);\n                 }\n                 PatKind::TupleStruct(ref qself, ref path, ref sub_patterns) => {\n                     self.smart_resolve_path(\n@@ -1754,24 +1735,18 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         if already_bound_or {\n             // `Variant1(a) | Variant2(a)`, ok\n             // Reuse definition from the first `a`.\n-            self.innermost_rib_bindings(ValueNS)[&ident].res()\n+            self.innermost_rib_bindings(ValueNS)[&ident]\n         } else {\n             let res = Res::Local(pat_id);\n             if ident_valid {\n                 // A completely fresh binding add to the set if it's valid.\n-                let binding =\n-                    (res, ty::Visibility::Invisible, ident.span, self.parent_scope.expansion)\n-                        .to_name_binding(self.r.arenas);\n-                self.innermost_rib_bindings(ValueNS).insert(ident, binding);\n+                self.innermost_rib_bindings(ValueNS).insert(ident, res);\n             }\n             res\n         }\n     }\n \n-    fn innermost_rib_bindings(\n-        &mut self,\n-        ns: Namespace,\n-    ) -> &mut FxHashMap<Ident, &'a NameBinding<'a>> {\n+    fn innermost_rib_bindings(&mut self, ns: Namespace) -> &mut IdentMap<Res> {\n         &mut self.ribs[ns].last_mut().unwrap().bindings\n     }\n \n@@ -1788,25 +1763,32 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         // also be interpreted as a path to e.g. a constant, variant, etc.\n         let is_syntactic_ambiguity = !has_sub && bm == BindingMode::ByValue(Mutability::Not);\n \n-        let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, None, pat.span)?;\n-        if is_syntactic_ambiguity && binding.is_ambiguity() {\n-            // For ambiguous bindings we don't know all their definitions and cannot check\n-            // whether they can be shadowed by fresh bindings or not, so force an error.\n-            // issues/33118#issuecomment-233962221 (see below) still applies here,\n-            // but we have to ignore it for backward compatibility.\n-            self.r.record_use(ident, binding, false);\n-            return None;\n-        }\n+        let ls_binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, None, pat.span)?;\n+        let (res, binding) = match ls_binding {\n+            LexicalScopeBinding::Item(binding)\n+                if is_syntactic_ambiguity && binding.is_ambiguity() =>\n+            {\n+                // For ambiguous bindings we don't know all their definitions and cannot check\n+                // whether they can be shadowed by fresh bindings or not, so force an error.\n+                // issues/33118#issuecomment-233962221 (see below) still applies here,\n+                // but we have to ignore it for backward compatibility.\n+                self.r.record_use(ident, binding, false);\n+                return None;\n+            }\n+            LexicalScopeBinding::Item(binding) => (binding.res(), Some(binding)),\n+            LexicalScopeBinding::Res(res) => (res, None),\n+        };\n \n-        let res = binding.res();\n         match res {\n             Res::SelfCtor(_) // See #70549.\n             | Res::Def(\n                 DefKind::Ctor(_, CtorKind::Const) | DefKind::Const | DefKind::ConstParam,\n                 _,\n             ) if is_syntactic_ambiguity => {\n                 // Disambiguate in favor of a unit struct/variant or constant pattern.\n-                self.r.record_use(ident, binding, false);\n+                if let Some(binding) = binding {\n+                    self.r.record_use(ident, binding, false);\n+                }\n                 Some(res)\n             }\n             Res::Def(DefKind::Ctor(..) | DefKind::Const | DefKind::Static, _) => {\n@@ -1815,6 +1797,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 // to something unusable as a pattern (e.g., constructor function),\n                 // but we still conservatively report an error, see\n                 // issues/33118#issuecomment-233962221 for one reason why.\n+                let binding = binding.expect(\"no binding for a ctor or static\");\n                 self.report_error(\n                     ident.span,\n                     ResolutionError::BindingShadowsSomethingUnacceptable {\n@@ -2054,15 +2037,19 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     }\n \n     fn self_type_is_available(&mut self, span: Span) -> bool {\n-        let ident = Ident::with_dummy_span(kw::SelfUpper);\n-        self.resolve_ident_in_lexical_scope(ident, TypeNS, None, span)\n-            .map_or(false, |binding| binding.res() != Res::Err)\n+        let binding = self.resolve_ident_in_lexical_scope(\n+            Ident::with_dummy_span(kw::SelfUpper),\n+            TypeNS,\n+            None,\n+            span,\n+        );\n+        if let Some(LexicalScopeBinding::Res(res)) = binding { res != Res::Err } else { false }\n     }\n \n     fn self_value_is_available(&mut self, self_span: Span, path_span: Span) -> bool {\n         let ident = Ident::new(kw::SelfLower, self_span);\n-        self.resolve_ident_in_lexical_scope(ident, ValueNS, None, path_span)\n-            .map_or(false, |binding| binding.res() != Res::Err)\n+        let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, None, path_span);\n+        if let Some(LexicalScopeBinding::Res(res)) = binding { res != Res::Err } else { false }\n     }\n \n     /// A wrapper around [`Resolver::report_error`]."}, {"sha": "1748a9be8e13e80cd0194e76ceafc14e2cb405b5", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7552af2f6f66e4a41b9590def5865f5a79b2910e/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7552af2f6f66e4a41b9590def5865f5a79b2910e/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=7552af2f6f66e4a41b9590def5865f5a79b2910e", "patch": "@@ -1294,8 +1294,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n             // Walk backwards up the ribs in scope and collect candidates.\n             for rib in self.ribs[ns].iter().rev() {\n                 // Locals and type parameters\n-                for (ident, binding) in &rib.bindings {\n-                    let res = binding.res();\n+                for (ident, &res) in &rib.bindings {\n                     if filter_fn(res) {\n                         names.push(TypoSuggestion::typo_from_res(ident.name, res));\n                     }"}, {"sha": "98c1355d05b25a16317b0f5b815e0ecd7131a28d", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 138, "deletions": 56, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/7552af2f6f66e4a41b9590def5865f5a79b2910e/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7552af2f6f66e4a41b9590def5865f5a79b2910e/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=7552af2f6f66e4a41b9590def5865f5a79b2910e", "patch": "@@ -373,6 +373,26 @@ impl<'tcx> Visitor<'tcx> for UsePlacementFinder {\n     }\n }\n \n+/// An intermediate resolution result.\n+///\n+/// This refers to the thing referred by a name. The difference between `Res` and `Item` is that\n+/// items are visible in their whole block, while `Res`es only from the place they are defined\n+/// forward.\n+#[derive(Debug)]\n+enum LexicalScopeBinding<'a> {\n+    Item(&'a NameBinding<'a>),\n+    Res(Res),\n+}\n+\n+impl<'a> LexicalScopeBinding<'a> {\n+    fn res(self) -> Res {\n+        match self {\n+            LexicalScopeBinding::Item(binding) => binding.res(),\n+            LexicalScopeBinding::Res(res) => res,\n+        }\n+    }\n+}\n+\n #[derive(Copy, Clone, Debug)]\n enum ModuleOrUniformRoot<'a> {\n     /// Regular module.\n@@ -898,6 +918,10 @@ pub struct Resolver<'a> {\n     /// \"self-confirming\" import resolutions during import validation.\n     unusable_binding: Option<&'a NameBinding<'a>>,\n \n+    // Spans for local variables found during pattern resolution.\n+    // Used for suggestions during error reporting.\n+    pat_span_map: NodeMap<Span>,\n+\n     /// Resolutions for nodes that have a single resolution.\n     partial_res_map: NodeMap<PartialRes>,\n     /// Resolutions for import nodes, which have multiple resolutions in different namespaces.\n@@ -1308,6 +1332,7 @@ impl<'a> Resolver<'a> {\n             last_import_segment: false,\n             unusable_binding: None,\n \n+            pat_span_map: Default::default(),\n             partial_res_map: Default::default(),\n             import_res_map: Default::default(),\n             label_res_map: Default::default(),\n@@ -1333,8 +1358,13 @@ impl<'a> Resolver<'a> {\n             macro_expanded_macro_export_errors: BTreeSet::new(),\n \n             arenas,\n-            dummy_binding: (Res::Err, ty::Visibility::Public, DUMMY_SP, LocalExpnId::ROOT)\n-                .to_name_binding(arenas),\n+            dummy_binding: arenas.alloc_name_binding(NameBinding {\n+                kind: NameBindingKind::Res(Res::Err, false),\n+                ambiguity: None,\n+                expansion: LocalExpnId::ROOT,\n+                span: DUMMY_SP,\n+                vis: ty::Visibility::Public,\n+            }),\n \n             crate_loader: CrateLoader::new(session, metadata_loader, crate_name),\n             macro_names: FxHashSet::default(),\n@@ -1891,11 +1921,11 @@ impl<'a> Resolver<'a> {\n         record_used_id: Option<NodeId>,\n         path_span: Span,\n         ribs: &[Rib<'a>],\n-    ) -> Result<&'a NameBinding<'a>, Determinacy> {\n+    ) -> Option<LexicalScopeBinding<'a>> {\n         assert!(ns == TypeNS || ns == ValueNS);\n         let orig_ident = ident;\n         if ident.name == kw::Empty {\n-            return Ok(self.dummy_binding);\n+            return Some(LexicalScopeBinding::Res(Res::Err));\n         }\n         let (general_span, normalized_span) = if ident.name == kw::SelfUpper {\n             // FIXME(jseyfried) improve `Self` hygiene\n@@ -1918,30 +1948,18 @@ impl<'a> Resolver<'a> {\n             // Use the rib kind to determine whether we are resolving parameters\n             // (macro 2.0 hygiene) or local variables (`macro_rules` hygiene).\n             let rib_ident = if ribs[i].kind.contains_params() { normalized_ident } else { ident };\n-            if let Some((&original_rib_ident_def, &binding)) =\n-                ribs[i].bindings.get_key_value(&rib_ident)\n+            if let Some((original_rib_ident_def, res)) = ribs[i].bindings.get_key_value(&rib_ident)\n             {\n                 // The ident resolves to a type parameter or local variable.\n-                let res = self.validate_res_from_ribs(\n+                return Some(LexicalScopeBinding::Res(self.validate_res_from_ribs(\n                     i,\n                     rib_ident,\n-                    binding.res(),\n+                    *res,\n                     record_used,\n                     path_span,\n-                    original_rib_ident_def,\n+                    *original_rib_ident_def,\n                     ribs,\n-                );\n-\n-                // We have to create a new binding in case of validation errors,\n-                // or in case of const generic hack changing the resolution.\n-                return Ok(if res != binding.res() {\n-                    self.arenas.alloc_name_binding(NameBinding {\n-                        kind: NameBindingKind::Res(res, false),\n-                        ..binding.clone()\n-                    })\n-                } else {\n-                    binding\n-                });\n+                )));\n             }\n \n             module = match ribs[i].kind {\n@@ -1960,17 +1978,17 @@ impl<'a> Resolver<'a> {\n                 _ => break,\n             }\n \n-            let binding = self.resolve_ident_in_module_unadjusted(\n+            let item = self.resolve_ident_in_module_unadjusted(\n                 ModuleOrUniformRoot::Module(module),\n                 ident,\n                 ns,\n                 parent_scope,\n                 record_used,\n                 path_span,\n             );\n-            if binding.is_ok() {\n+            if let Ok(binding) = item {\n                 // The ident resolves to an item.\n-                return binding;\n+                return Some(LexicalScopeBinding::Item(binding));\n             }\n         }\n         self.early_resolve_ident_in_lexical_scope(\n@@ -1981,6 +1999,8 @@ impl<'a> Resolver<'a> {\n             record_used,\n             path_span,\n         )\n+        .ok()\n+        .map(LexicalScopeBinding::Item)\n     }\n \n     fn hygienic_lexical_parent(\n@@ -2205,6 +2225,16 @@ impl<'a> Resolver<'a> {\n \n         for (i, &Segment { ident, id, has_generic_args: _ }) in path.iter().enumerate() {\n             debug!(\"resolve_path ident {} {:?} {:?}\", i, ident, id);\n+            let record_segment_res = |this: &mut Self, res| {\n+                if record_used {\n+                    if let Some(id) = id {\n+                        if !this.partial_res_map.contains_key(&id) {\n+                            assert!(id != ast::DUMMY_NODE_ID, \"Trying to resolve dummy id\");\n+                            this.record_partial_res(id, PartialRes::new(res));\n+                        }\n+                    }\n+                }\n+            };\n \n             let is_last = i == path.len() - 1;\n             let ns = if is_last { opt_ns.unwrap_or(TypeNS) } else { TypeNS };\n@@ -2283,8 +2313,12 @@ impl<'a> Resolver<'a> {\n                 };\n             }\n \n+            enum FindBindingResult<'a> {\n+                Binding(Result<&'a NameBinding<'a>, Determinacy>),\n+                PathResult(PathResult<'a>),\n+            }\n             let find_binding_in_ns = |this: &mut Self, ns| {\n-                if let Some(module) = module {\n+                let binding = if let Some(module) = module {\n                     this.resolve_ident_in_module(\n                         module,\n                         ident,\n@@ -2309,34 +2343,44 @@ impl<'a> Resolver<'a> {\n                     } else {\n                         None\n                     };\n-                    this.resolve_ident_in_lexical_scope(\n+                    match this.resolve_ident_in_lexical_scope(\n                         ident,\n                         ns,\n                         parent_scope,\n                         record_used_id,\n                         path_span,\n                         &ribs.unwrap()[ns],\n-                    )\n-                }\n+                    ) {\n+                        // we found a locally-imported or available item/module\n+                        Some(LexicalScopeBinding::Item(binding)) => Ok(binding),\n+                        // we found a local variable or type param\n+                        Some(LexicalScopeBinding::Res(res))\n+                            if opt_ns == Some(TypeNS) || opt_ns == Some(ValueNS) =>\n+                        {\n+                            record_segment_res(this, res);\n+                            return FindBindingResult::PathResult(PathResult::NonModule(\n+                                PartialRes::with_unresolved_segments(res, path.len() - 1),\n+                            ));\n+                        }\n+                        _ => Err(Determinacy::determined(record_used)),\n+                    }\n+                };\n+                FindBindingResult::Binding(binding)\n             };\n-\n-            match find_binding_in_ns(self, ns) {\n+            let binding = match find_binding_in_ns(self, ns) {\n+                FindBindingResult::PathResult(x) => return x,\n+                FindBindingResult::Binding(binding) => binding,\n+            };\n+            match binding {\n                 Ok(binding) => {\n                     if i == 1 {\n                         second_binding = Some(binding);\n                     }\n                     let res = binding.res();\n-                    if record_used {\n-                        if let Some(id) = id {\n-                            if !self.partial_res_map.contains_key(&id) {\n-                                assert!(id != ast::DUMMY_NODE_ID, \"Trying to resolve dummy id\");\n-                                self.record_partial_res(id, PartialRes::new(res));\n-                            }\n-                        }\n-                    }\n                     let maybe_assoc = opt_ns != Some(MacroNS) && PathSource::Type.is_expected(res);\n                     if let Some(next_module) = binding.module() {\n                         module = Some(ModuleOrUniformRoot::Module(next_module));\n+                        record_segment_res(self, res);\n                     } else if res == Res::ToolMod && i + 1 != path.len() {\n                         if binding.is_import() {\n                             self.session\n@@ -2426,25 +2470,56 @@ impl<'a> Resolver<'a> {\n                             .map_or(false, |c| c.is_ascii_uppercase())\n                         {\n                             // Check whether the name refers to an item in the value namespace.\n-                            let suggestion = ribs\n-                                .and_then(|ribs| {\n-                                    self.resolve_ident_in_lexical_scope(\n-                                        ident,\n-                                        ValueNS,\n-                                        parent_scope,\n-                                        None,\n-                                        path_span,\n-                                        &ribs[ValueNS],\n-                                    )\n-                                    .ok()\n-                                })\n-                                .map(|binding| {\n-                                    (\n-                                        vec![(binding.span, String::from(\"\"))],\n+                            let suggestion = if ribs.is_some() {\n+                                let match_span = match self.resolve_ident_in_lexical_scope(\n+                                    ident,\n+                                    ValueNS,\n+                                    parent_scope,\n+                                    None,\n+                                    path_span,\n+                                    &ribs.unwrap()[ValueNS],\n+                                ) {\n+                                    // Name matches a local variable. For example:\n+                                    // ```\n+                                    // fn f() {\n+                                    //     let Foo: &str = \"\";\n+                                    //     println!(\"{}\", Foo::Bar); // Name refers to local\n+                                    //                               // variable `Foo`.\n+                                    // }\n+                                    // ```\n+                                    Some(LexicalScopeBinding::Res(Res::Local(id))) => {\n+                                        Some(*self.pat_span_map.get(&id).unwrap())\n+                                    }\n+\n+                                    // Name matches item from a local name binding\n+                                    // created by `use` declaration. For example:\n+                                    // ```\n+                                    // pub Foo: &str = \"\";\n+                                    //\n+                                    // mod submod {\n+                                    //     use super::Foo;\n+                                    //     println!(\"{}\", Foo::Bar); // Name refers to local\n+                                    //                               // binding `Foo`.\n+                                    // }\n+                                    // ```\n+                                    Some(LexicalScopeBinding::Item(name_binding)) => {\n+                                        Some(name_binding.span)\n+                                    }\n+                                    _ => None,\n+                                };\n+\n+                                if let Some(span) = match_span {\n+                                    Some((\n+                                        vec![(span, String::from(\"\"))],\n                                         format!(\"`{}` is defined here, but is not a type\", ident),\n                                         Applicability::MaybeIncorrect,\n-                                    )\n-                                });\n+                                    ))\n+                                } else {\n+                                    None\n+                                }\n+                            } else {\n+                                None\n+                            };\n \n                             (format!(\"use of undeclared type `{}`\", ident), suggestion)\n                         } else {\n@@ -2482,7 +2557,9 @@ impl<'a> Resolver<'a> {\n                         let mut msg = format!(\"could not find `{}` in {}\", ident, parent);\n                         if ns == TypeNS || ns == ValueNS {\n                             let ns_to_try = if ns == TypeNS { ValueNS } else { TypeNS };\n-                            if let Ok(binding) = find_binding_in_ns(self, ns_to_try) {\n+                            if let FindBindingResult::Binding(Ok(binding)) =\n+                                find_binding_in_ns(self, ns_to_try)\n+                            {\n                                 let mut found = |what| {\n                                     msg = format!(\n                                         \"expected {}, found {} `{}` in {}\",\n@@ -2824,6 +2901,11 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n+    fn record_pat_span(&mut self, node: NodeId, span: Span) {\n+        debug!(\"(recording pat) recording {:?} for {:?}\", node, span);\n+        self.pat_span_map.insert(node, span);\n+    }\n+\n     fn is_accessible_from(&self, vis: ty::Visibility, module: Module<'a>) -> bool {\n         vis.is_accessible_from(module.nearest_parent_mod(), self)\n     }"}]}