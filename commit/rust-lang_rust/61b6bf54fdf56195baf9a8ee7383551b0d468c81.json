{"sha": "61b6bf54fdf56195baf9a8ee7383551b0d468c81", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxYjZiZjU0ZmRmNTYxOTViYWY5YThlZTczODM1NTFiMGQ0NjhjODE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-17T11:39:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-17T11:39:38Z"}, "message": "Auto merge of #49106 - kennytm:rollup, r=kennytm\n\nRollup of 8 pull requests\n\n- Successful merges: #48943, #48960, #48983, #49055, #49057, #49077, #49082, #49083\n- Failed merges:", "tree": {"sha": "8068fa31dd1f5c073cc0487d25a49f93a5c45b20", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8068fa31dd1f5c073cc0487d25a49f93a5c45b20"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61b6bf54fdf56195baf9a8ee7383551b0d468c81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61b6bf54fdf56195baf9a8ee7383551b0d468c81", "html_url": "https://github.com/rust-lang/rust/commit/61b6bf54fdf56195baf9a8ee7383551b0d468c81", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61b6bf54fdf56195baf9a8ee7383551b0d468c81/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3fd5d0ddead5b14ce5321b06bc5bed60d0cdf2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3fd5d0ddead5b14ce5321b06bc5bed60d0cdf2f", "html_url": "https://github.com/rust-lang/rust/commit/c3fd5d0ddead5b14ce5321b06bc5bed60d0cdf2f"}, {"sha": "ef9581e757babc175cfabe1c01fb543d7c70a31f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef9581e757babc175cfabe1c01fb543d7c70a31f", "html_url": "https://github.com/rust-lang/rust/commit/ef9581e757babc175cfabe1c01fb543d7c70a31f"}], "stats": {"total": 971, "additions": 923, "deletions": 48}, "files": [{"sha": "aec5e5a0e2c800220da705d7101a96de198d8491", "filename": "config.toml.example", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61b6bf54fdf56195baf9a8ee7383551b0d468c81/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/61b6bf54fdf56195baf9a8ee7383551b0d468c81/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=61b6bf54fdf56195baf9a8ee7383551b0d468c81", "patch": "@@ -118,6 +118,10 @@\n # Indicate whether submodules are managed and updated automatically.\n #submodules = true\n \n+# Update submodules only when the checked out commit in the submodules differs\n+# from what is committed in the main rustc repo.\n+#fast-submodules = true\n+\n # The path to (or name of) the GDB executable to use. This is only used for\n # executing the debuginfo test suite.\n #gdb = \"gdb\""}, {"sha": "b55a133501d8eefc126966df971bd848c830179b", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 55, "deletions": 20, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/61b6bf54fdf56195baf9a8ee7383551b0d468c81/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/61b6bf54fdf56195baf9a8ee7383551b0d468c81/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=61b6bf54fdf56195baf9a8ee7383551b0d468c81", "patch": "@@ -597,10 +597,8 @@ def build_bootstrap(self):\n                 self.cargo()))\n         args = [self.cargo(), \"build\", \"--manifest-path\",\n                 os.path.join(self.rust_root, \"src/bootstrap/Cargo.toml\")]\n-        if self.verbose:\n+        for _ in range(1, self.verbose):\n             args.append(\"--verbose\")\n-            if self.verbose > 1:\n-                args.append(\"--verbose\")\n         if self.use_locked_deps:\n             args.append(\"--locked\")\n         if self.use_vendored_sources:\n@@ -614,20 +612,55 @@ def build_triple(self):\n             return config\n         return default_build_triple()\n \n+    def check_submodule(self, module, slow_submodules):\n+        if not slow_submodules:\n+            checked_out = subprocess.Popen([\"git\", \"rev-parse\", \"HEAD\"],\n+                                           cwd=os.path.join(self.rust_root, module),\n+                                           stdout=subprocess.PIPE)\n+            return checked_out\n+        else:\n+            return None\n+\n+    def update_submodule(self, module, checked_out, recorded_submodules):\n+        module_path = os.path.join(self.rust_root, module)\n+\n+        if checked_out != None:\n+            default_encoding = sys.getdefaultencoding()\n+            checked_out = checked_out.communicate()[0].decode(default_encoding).strip()\n+            if recorded_submodules[module] == checked_out:\n+                return\n+\n+        print(\"Updating submodule\", module)\n+\n+        run([\"git\", \"submodule\", \"-q\", \"sync\", module],\n+            cwd=self.rust_root, verbose=self.verbose)\n+        run([\"git\", \"submodule\", \"update\",\n+            \"--init\", \"--recursive\", module],\n+            cwd=self.rust_root, verbose=self.verbose)\n+        run([\"git\", \"reset\", \"-q\", \"--hard\"],\n+            cwd=module_path, verbose=self.verbose)\n+        run([\"git\", \"clean\", \"-qdfx\"],\n+            cwd=module_path, verbose=self.verbose)\n+\n     def update_submodules(self):\n         \"\"\"Update submodules\"\"\"\n         if (not os.path.exists(os.path.join(self.rust_root, \".git\"))) or \\\n                 self.get_toml('submodules') == \"false\":\n             return\n-        print('Updating submodules')\n+        slow_submodules = self.get_toml('fast-submodule') == \"false\"\n+        start_time = time()\n+        if slow_submodules:\n+            print('Unconditionally updating all submodules')\n+        else:\n+            print('Updating only changed submodules')\n         default_encoding = sys.getdefaultencoding()\n-        run([\"git\", \"submodule\", \"-q\", \"sync\"], cwd=self.rust_root, verbose=self.verbose)\n         submodules = [s.split(' ', 1)[1] for s in subprocess.check_output(\n             [\"git\", \"config\", \"--file\",\n              os.path.join(self.rust_root, \".gitmodules\"),\n              \"--get-regexp\", \"path\"]\n         ).decode(default_encoding).splitlines()]\n         filtered_submodules = []\n+        submodules_names = []\n         for module in submodules:\n             if module.endswith(\"llvm\"):\n                 if self.get_toml('llvm-config'):\n@@ -645,16 +678,19 @@ def update_submodules(self):\n                 config = self.get_toml('lld')\n                 if config is None or config == 'false':\n                     continue\n-            filtered_submodules.append(module)\n-        run([\"git\", \"submodule\", \"update\",\n-             \"--init\", \"--recursive\"] + filtered_submodules,\n-            cwd=self.rust_root, verbose=self.verbose)\n-        run([\"git\", \"submodule\", \"-q\", \"foreach\", \"git\",\n-             \"reset\", \"-q\", \"--hard\"],\n-            cwd=self.rust_root, verbose=self.verbose)\n-        run([\"git\", \"submodule\", \"-q\", \"foreach\", \"git\",\n-             \"clean\", \"-qdfx\"],\n-            cwd=self.rust_root, verbose=self.verbose)\n+            check = self.check_submodule(module, slow_submodules)\n+            filtered_submodules.append((module, check))\n+            submodules_names.append(module)\n+        recorded = subprocess.Popen([\"git\", \"ls-tree\", \"HEAD\"] + submodules_names,\n+                                    cwd=self.rust_root, stdout=subprocess.PIPE)\n+        recorded = recorded.communicate()[0].decode(default_encoding).strip().splitlines()\n+        recorded_submodules = {}\n+        for data in recorded:\n+            data = data.split()\n+            recorded_submodules[data[3]] = data[2]\n+        for module in filtered_submodules:\n+            self.update_submodule(module[0], module[1], recorded_submodules)\n+        print(\"Submodules updated in %.2f seconds\" % (time() - start_time))\n \n     def set_dev_environment(self):\n         \"\"\"Set download URL for development environment\"\"\"\n@@ -675,7 +711,7 @@ def bootstrap(help_triggered):\n     parser.add_argument('--config')\n     parser.add_argument('--build')\n     parser.add_argument('--clean', action='store_true')\n-    parser.add_argument('-v', '--verbose', action='store_true')\n+    parser.add_argument('-v', '--verbose', action='count', default=0)\n \n     args = [a for a in sys.argv if a != '-h' and a != '--help']\n     args, _ = parser.parse_known_args(args)\n@@ -691,10 +727,9 @@ def bootstrap(help_triggered):\n     except (OSError, IOError):\n         pass\n \n-    if '\\nverbose = 2' in build.config_toml:\n-        build.verbose = 2\n-    elif '\\nverbose = 1' in build.config_toml:\n-        build.verbose = 1\n+    match = re.search(r'\\nverbose = (\\d+)', build.config_toml)\n+    if match is not None:\n+        build.verbose = max(build.verbose, int(match.group(1)))\n \n     build.use_vendored_sources = '\\nvendor = true' in build.config_toml\n "}, {"sha": "675d3dd437eef9deb3cc60d7956b038628c81e05", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61b6bf54fdf56195baf9a8ee7383551b0d468c81/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61b6bf54fdf56195baf9a8ee7383551b0d468c81/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=61b6bf54fdf56195baf9a8ee7383551b0d468c81", "patch": "@@ -763,7 +763,7 @@ impl<'a> Builder<'a> {\n             cargo.env(\"WINAPI_NO_BUNDLED_LIBRARIES\", \"1\");\n         }\n \n-        if self.is_very_verbose() {\n+        for _ in 1..self.verbosity {\n             cargo.arg(\"-v\");\n         }\n "}, {"sha": "dcb572416594ebcd1857b4da268dd14eb56520f5", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/61b6bf54fdf56195baf9a8ee7383551b0d468c81/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61b6bf54fdf56195baf9a8ee7383551b0d468c81/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=61b6bf54fdf56195baf9a8ee7383551b0d468c81", "patch": "@@ -203,18 +203,22 @@ fn make_win_dist(\n         \"libbcrypt.a\",\n         \"libcomctl32.a\",\n         \"libcomdlg32.a\",\n+        \"libcredui.a\",\n         \"libcrypt32.a\",\n+        \"libdbghelp.a\",\n         \"libgdi32.a\",\n         \"libimagehlp.a\",\n         \"libiphlpapi.a\",\n         \"libkernel32.a\",\n+        \"libmsimg32.a\",\n         \"libmsvcrt.a\",\n         \"libodbc32.a\",\n         \"libole32.a\",\n         \"liboleaut32.a\",\n         \"libopengl32.a\",\n         \"libpsapi.a\",\n         \"librpcrt4.a\",\n+        \"libsecur32.a\",\n         \"libsetupapi.a\",\n         \"libshell32.a\",\n         \"libuser32.a\",\n@@ -225,8 +229,6 @@ fn make_win_dist(\n         \"libwinspool.a\",\n         \"libws2_32.a\",\n         \"libwsock32.a\",\n-        \"libdbghelp.a\",\n-        \"libmsimg32.a\",\n     ];\n \n     //Find mingw artifacts we want to bundle"}, {"sha": "c5af0f8e2e15331cc45fbf779b471731cde82149", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61b6bf54fdf56195baf9a8ee7383551b0d468c81/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61b6bf54fdf56195baf9a8ee7383551b0d468c81/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=61b6bf54fdf56195baf9a8ee7383551b0d468c81", "patch": "@@ -29,7 +29,7 @@ use cache::{Interned, INTERNER};\n \n /// Deserialized version of all flags for this compile.\n pub struct Flags {\n-    pub verbose: usize, // verbosity level: 0 == not verbose, 1 == verbose, 2 == very verbose\n+    pub verbose: usize, // number of -v args; each extra -v after the first is passed to Cargo\n     pub on_fail: Option<String>,\n     pub stage: Option<u32>,\n     pub keep_stage: Option<u32>,"}, {"sha": "b778ba33d89ccfd06e71d372596400c509ffd1b4", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61b6bf54fdf56195baf9a8ee7383551b0d468c81/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61b6bf54fdf56195baf9a8ee7383551b0d468c81/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=61b6bf54fdf56195baf9a8ee7383551b0d468c81", "patch": "@@ -606,10 +606,6 @@ impl Build {\n         self.verbosity > 0\n     }\n \n-    pub fn is_very_verbose(&self) -> bool {\n-        self.verbosity > 1\n-    }\n-\n     /// Prints a message if this build is configured in verbose mode.\n     fn verbose(&self, msg: &str) {\n         if self.is_verbose() {"}, {"sha": "c13ad39e5e1d598a8f9b40f15ff572a271417a4d", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/61b6bf54fdf56195baf9a8ee7383551b0d468c81/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61b6bf54fdf56195baf9a8ee7383551b0d468c81/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=61b6bf54fdf56195baf9a8ee7383551b0d468c81", "patch": "@@ -228,14 +228,6 @@ unsafe impl Alloc for Heap {\n     }\n }\n \n-/// An arbitrary non-null address to represent zero-size allocations.\n-///\n-/// This preserves the non-null invariant for types like `Box<T>`. The address\n-/// may overlap with non-zero-size memory allocations.\n-#[rustc_deprecated(since = \"1.19.0\", reason = \"Use Unique/NonNull::empty() instead\")]\n-#[unstable(feature = \"heap_api\", issue = \"27700\")]\n-pub const EMPTY: *mut () = 1 as *mut ();\n-\n /// The allocator for unique pointers.\n // This function must not unwind. If it does, MIR trans will fail.\n #[cfg(not(test))]"}, {"sha": "0aa750aba066057b50db4eca855e2472a535362f", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/61b6bf54fdf56195baf9a8ee7383551b0d468c81/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61b6bf54fdf56195baf9a8ee7383551b0d468c81/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=61b6bf54fdf56195baf9a8ee7383551b0d468c81", "patch": "@@ -19,6 +19,7 @@ use hir::map::Map;\n use hir::def::Def;\n use hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use hir::ItemLocalId;\n+use hir::LifetimeName;\n use ty::{self, TyCtxt};\n \n use std::cell::Cell;\n@@ -569,10 +570,26 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 for bound in bounds {\n                     self.visit_poly_trait_ref(bound, hir::TraitBoundModifier::None);\n                 }\n-                if lifetime.is_elided() {\n-                    self.resolve_object_lifetime_default(lifetime)\n-                } else {\n-                    self.visit_lifetime(lifetime);\n+                match lifetime.name {\n+                    LifetimeName::Implicit => {\n+                        // If the user does not write *anything*, we\n+                        // use the object lifetime defaulting\n+                        // rules. So e.g. `Box<dyn Debug>` becomes\n+                        // `Box<dyn Debug + 'static>`.\n+                        self.resolve_object_lifetime_default(lifetime)\n+                    }\n+                    LifetimeName::Underscore => {\n+                        // If the user writes `'_`, we use the *ordinary* elision\n+                        // rules. So the `'_` in e.g. `Box<dyn Debug + '_>` will be\n+                        // resolved the same as the `'_` in `&'_ Foo`.\n+                        //\n+                        // cc #48468\n+                        self.resolve_elided_lifetimes(slice::from_ref(lifetime), false)\n+                    }\n+                    LifetimeName::Static | LifetimeName::Name(_) => {\n+                        // If the user wrote an explicit name, use that.\n+                        self.visit_lifetime(lifetime);\n+                    }\n                 }\n             }\n             hir::TyRptr(ref lifetime_ref, ref mt) => {"}, {"sha": "9e69990f22c0d0c20af457727493daf481e919be", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61b6bf54fdf56195baf9a8ee7383551b0d468c81/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61b6bf54fdf56195baf9a8ee7383551b0d468c81/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=61b6bf54fdf56195baf9a8ee7383551b0d468c81", "patch": "@@ -20,7 +20,7 @@ pub struct EvalError<'tcx> {\n \n impl<'tcx> From<EvalErrorKind<'tcx>> for EvalError<'tcx> {\n     fn from(kind: EvalErrorKind<'tcx>) -> Self {\n-        let backtrace = match env::var(\"RUST_BACKTRACE\") {\n+        let backtrace = match env::var(\"MIRI_BACKTRACE\") {\n             Ok(ref val) if !val.is_empty() => Some(Backtrace::new_unresolved()),\n             _ => None\n         };"}, {"sha": "b5e31bdf6686afb0dfb6c6bc84e443ef4099ba62", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/61b6bf54fdf56195baf9a8ee7383551b0d468c81/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61b6bf54fdf56195baf9a8ee7383551b0d468c81/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=61b6bf54fdf56195baf9a8ee7383551b0d468c81", "patch": "@@ -877,10 +877,6 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n         Ok(())\n     })?;\n \n-    if resolver.found_unresolved_macro {\n-        sess.parse_sess.span_diagnostic.abort_if_errors();\n-    }\n-\n     // Needs to go *after* expansion to be able to check the results of macro expansion.\n     time(sess, \"complete gated feature checking\", || {\n         sess.track_errors(|| {\n@@ -892,6 +888,12 @@ pub fn phase_2_configure_and_expand_inner<'a, F>(sess: &'a Session,\n         })\n     })?;\n \n+    // Unresolved macros might be due to mistyped `#[macro_use]`,\n+    // so abort after checking for unknown attributes. (#49074)\n+    if resolver.found_unresolved_macro {\n+        sess.parse_sess.span_diagnostic.abort_if_errors();\n+    }\n+\n     // Lower ast -> hir.\n     // First, we need to collect the dep_graph.\n     let dep_graph = match future_dep_graph {"}, {"sha": "c0cdd212770623bf6ff827776db7ff55b0d84e68", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/61b6bf54fdf56195baf9a8ee7383551b0d468c81/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61b6bf54fdf56195baf9a8ee7383551b0d468c81/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=61b6bf54fdf56195baf9a8ee7383551b0d468c81", "patch": "@@ -621,6 +621,7 @@ extern \"C\" {\n     pub fn LLVMConstIntGetSExtValue(ConstantVal: ValueRef) -> c_longlong;\n     pub fn LLVMRustConstInt128Get(ConstantVal: ValueRef, SExt: bool,\n                                   high: *mut u64, low: *mut u64) -> bool;\n+    pub fn LLVMConstRealGetDouble (ConstantVal: ValueRef, losesInfo: *mut Bool) -> f64;\n \n \n     // Operations on composite constants\n@@ -1201,6 +1202,46 @@ extern \"C\" {\n                                 Name: *const c_char)\n                                 -> ValueRef;\n \n+    pub fn LLVMRustBuildVectorReduceFAdd(B: BuilderRef,\n+                                         Acc: ValueRef,\n+                                         Src: ValueRef)\n+                                         -> ValueRef;\n+    pub fn LLVMRustBuildVectorReduceFMul(B: BuilderRef,\n+                                         Acc: ValueRef,\n+                                         Src: ValueRef)\n+                                         -> ValueRef;\n+    pub fn LLVMRustBuildVectorReduceAdd(B: BuilderRef,\n+                                        Src: ValueRef)\n+                                        -> ValueRef;\n+    pub fn LLVMRustBuildVectorReduceMul(B: BuilderRef,\n+                                        Src: ValueRef)\n+                                        -> ValueRef;\n+    pub fn LLVMRustBuildVectorReduceAnd(B: BuilderRef,\n+                                        Src: ValueRef)\n+                                        -> ValueRef;\n+    pub fn LLVMRustBuildVectorReduceOr(B: BuilderRef,\n+                                       Src: ValueRef)\n+                                       -> ValueRef;\n+    pub fn LLVMRustBuildVectorReduceXor(B: BuilderRef,\n+                                        Src: ValueRef)\n+                                        -> ValueRef;\n+    pub fn LLVMRustBuildVectorReduceMin(B: BuilderRef,\n+                                        Src: ValueRef,\n+                                        IsSigned: bool)\n+                                        -> ValueRef;\n+    pub fn LLVMRustBuildVectorReduceMax(B: BuilderRef,\n+                                        Src: ValueRef,\n+                                        IsSigned: bool)\n+                                        -> ValueRef;\n+    pub fn LLVMRustBuildVectorReduceFMin(B: BuilderRef,\n+                                         Src: ValueRef,\n+                                         IsNaN: bool)\n+                                         -> ValueRef;\n+    pub fn LLVMRustBuildVectorReduceFMax(B: BuilderRef,\n+                                         Src: ValueRef,\n+                                         IsNaN: bool)\n+                                         -> ValueRef;\n+\n     pub fn LLVMBuildIsNull(B: BuilderRef, Val: ValueRef, Name: *const c_char) -> ValueRef;\n     pub fn LLVMBuildIsNotNull(B: BuilderRef, Val: ValueRef, Name: *const c_char) -> ValueRef;\n     pub fn LLVMBuildPtrDiff(B: BuilderRef,\n@@ -1567,6 +1608,7 @@ extern \"C\" {\n     pub fn LLVMRustWriteValueToString(value_ref: ValueRef, s: RustStringRef);\n \n     pub fn LLVMIsAConstantInt(value_ref: ValueRef) -> ValueRef;\n+    pub fn LLVMIsAConstantFP(value_ref: ValueRef) -> ValueRef;\n \n     pub fn LLVMRustPassKind(Pass: PassRef) -> PassKind;\n     pub fn LLVMRustFindAndCreatePass(Pass: *const c_char) -> PassRef;"}, {"sha": "3f5a9a54ff1eacfab2bd485672b2091e50d4635a", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/61b6bf54fdf56195baf9a8ee7383551b0d468c81/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61b6bf54fdf56195baf9a8ee7383551b0d468c81/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=61b6bf54fdf56195baf9a8ee7383551b0d468c81", "patch": "@@ -955,6 +955,147 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n+    pub fn vector_reduce_fadd_fast(&self, acc: ValueRef, src: ValueRef) -> ValueRef {\n+        self.count_insn(\"vector.reduce.fadd_fast\");\n+        unsafe {\n+            // FIXME: add a non-fast math version once\n+            // https://bugs.llvm.org/show_bug.cgi?id=36732\n+            // is fixed.\n+            let instr = llvm::LLVMRustBuildVectorReduceFAdd(self.llbuilder, acc, src);\n+            if instr.is_null() {\n+                bug!(\"LLVMRustBuildVectorReduceFAdd is not available in LLVM version < 5.0\");\n+            }\n+            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            instr\n+        }\n+    }\n+    pub fn vector_reduce_fmul_fast(&self, acc: ValueRef, src: ValueRef) -> ValueRef {\n+        self.count_insn(\"vector.reduce.fmul_fast\");\n+        unsafe {\n+            // FIXME: add a non-fast math version once\n+            // https://bugs.llvm.org/show_bug.cgi?id=36732\n+            // is fixed.\n+            let instr = llvm::LLVMRustBuildVectorReduceFMul(self.llbuilder, acc, src);\n+            if instr.is_null() {\n+                bug!(\"LLVMRustBuildVectorReduceFMul is not available in LLVM version < 5.0\");\n+            }\n+            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            instr\n+        }\n+    }\n+    pub fn vector_reduce_add(&self, src: ValueRef) -> ValueRef {\n+        self.count_insn(\"vector.reduce.add\");\n+        unsafe {\n+            let instr = llvm::LLVMRustBuildVectorReduceAdd(self.llbuilder, src);\n+            if instr.is_null() {\n+                bug!(\"LLVMRustBuildVectorReduceAdd is not available in LLVM version < 5.0\");\n+            }\n+            instr\n+        }\n+    }\n+    pub fn vector_reduce_mul(&self, src: ValueRef) -> ValueRef {\n+        self.count_insn(\"vector.reduce.mul\");\n+        unsafe {\n+            let instr = llvm::LLVMRustBuildVectorReduceMul(self.llbuilder, src);\n+            if instr.is_null() {\n+                bug!(\"LLVMRustBuildVectorReduceMul is not available in LLVM version < 5.0\");\n+            }\n+            instr\n+        }\n+    }\n+    pub fn vector_reduce_and(&self, src: ValueRef) -> ValueRef {\n+        self.count_insn(\"vector.reduce.and\");\n+        unsafe {\n+            let instr = llvm::LLVMRustBuildVectorReduceAnd(self.llbuilder, src);\n+            if instr.is_null() {\n+                bug!(\"LLVMRustBuildVectorReduceAnd is not available in LLVM version < 5.0\");\n+            }\n+            instr\n+        }\n+    }\n+    pub fn vector_reduce_or(&self, src: ValueRef) -> ValueRef {\n+        self.count_insn(\"vector.reduce.or\");\n+        unsafe {\n+            let instr = llvm::LLVMRustBuildVectorReduceOr(self.llbuilder, src);\n+            if instr.is_null() {\n+                bug!(\"LLVMRustBuildVectorReduceOr is not available in LLVM version < 5.0\");\n+            }\n+            instr\n+        }\n+    }\n+    pub fn vector_reduce_xor(&self, src: ValueRef) -> ValueRef {\n+        self.count_insn(\"vector.reduce.xor\");\n+        unsafe {\n+            let instr = llvm::LLVMRustBuildVectorReduceXor(self.llbuilder, src);\n+            if instr.is_null() {\n+                bug!(\"LLVMRustBuildVectorReduceXor is not available in LLVM version < 5.0\");\n+            }\n+            instr\n+        }\n+    }\n+    pub fn vector_reduce_fmin(&self, src: ValueRef) -> ValueRef {\n+        self.count_insn(\"vector.reduce.fmin\");\n+        unsafe {\n+            let instr = llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, true);\n+            if instr.is_null() {\n+                bug!(\"LLVMRustBuildVectorReduceFMin is not available in LLVM version < 5.0\");\n+            }\n+            instr\n+        }\n+    }\n+    pub fn vector_reduce_fmax(&self, src: ValueRef) -> ValueRef {\n+        self.count_insn(\"vector.reduce.fmax\");\n+        unsafe {\n+            let instr = llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, true);\n+            if instr.is_null() {\n+                bug!(\"LLVMRustBuildVectorReduceFMax is not available in LLVM version < 5.0\");\n+            }\n+            instr\n+        }\n+    }\n+    pub fn vector_reduce_fmin_fast(&self, src: ValueRef) -> ValueRef {\n+        self.count_insn(\"vector.reduce.fmin_fast\");\n+        unsafe {\n+            let instr = llvm::LLVMRustBuildVectorReduceFMin(self.llbuilder, src, false);\n+            if instr.is_null() {\n+                bug!(\"LLVMRustBuildVectorReduceFMin is not available in LLVM version < 5.0\");\n+            }\n+            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            instr\n+        }\n+    }\n+    pub fn vector_reduce_fmax_fast(&self, src: ValueRef) -> ValueRef {\n+        self.count_insn(\"vector.reduce.fmax_fast\");\n+        unsafe {\n+            let instr = llvm::LLVMRustBuildVectorReduceFMax(self.llbuilder, src, false);\n+            if instr.is_null() {\n+                bug!(\"LLVMRustBuildVectorReduceFMax is not available in LLVM version < 5.0\");\n+            }\n+            llvm::LLVMRustSetHasUnsafeAlgebra(instr);\n+            instr\n+        }\n+    }\n+    pub fn vector_reduce_min(&self, src: ValueRef, is_signed: bool) -> ValueRef {\n+        self.count_insn(\"vector.reduce.min\");\n+        unsafe {\n+            let instr = llvm::LLVMRustBuildVectorReduceMin(self.llbuilder, src, is_signed);\n+            if instr.is_null() {\n+                bug!(\"LLVMRustBuildVectorReduceMin is not available in LLVM version < 5.0\");\n+            }\n+            instr\n+        }\n+    }\n+    pub fn vector_reduce_max(&self, src: ValueRef, is_signed: bool) -> ValueRef {\n+        self.count_insn(\"vector.reduce.max\");\n+        unsafe {\n+            let instr = llvm::LLVMRustBuildVectorReduceMax(self.llbuilder, src, is_signed);\n+            if instr.is_null() {\n+                bug!(\"LLVMRustBuildVectorReduceMax is not available in LLVM version < 5.0\");\n+            }\n+            instr\n+        }\n+    }\n+\n     pub fn extract_value(&self, agg_val: ValueRef, idx: u64) -> ValueRef {\n         self.count_insn(\"extractvalue\");\n         assert_eq!(idx as c_uint as u64, idx);"}, {"sha": "e83e73c8ae7578d33fdc61b71a767e32aba262cc", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/61b6bf54fdf56195baf9a8ee7383551b0d468c81/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61b6bf54fdf56195baf9a8ee7383551b0d468c81/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=61b6bf54fdf56195baf9a8ee7383551b0d468c81", "patch": "@@ -269,6 +269,19 @@ pub fn const_get_elt(v: ValueRef, idx: u64) -> ValueRef {\n     }\n }\n \n+pub fn const_get_real(v: ValueRef) -> Option<(f64, bool)> {\n+    unsafe {\n+        if is_const_real(v) {\n+            let mut loses_info: llvm::Bool = ::std::mem::uninitialized();\n+            let r = llvm::LLVMConstRealGetDouble(v, &mut loses_info as *mut llvm::Bool);\n+            let loses_info = if loses_info == 1 { true } else { false };\n+            Some((r, loses_info))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n pub fn const_to_uint(v: ValueRef) -> u64 {\n     unsafe {\n         llvm::LLVMConstIntGetZExtValue(v)\n@@ -281,6 +294,13 @@ pub fn is_const_integral(v: ValueRef) -> bool {\n     }\n }\n \n+pub fn is_const_real(v: ValueRef) -> bool {\n+    unsafe {\n+        !llvm::LLVMIsAConstantFP(v).is_null()\n+    }\n+}\n+\n+\n #[inline]\n fn hi_lo_to_u128(lo: u64, hi: u64) -> u128 {\n     ((hi as u128) << 64) | (lo as u128)"}, {"sha": "c3de9e0ffcce226bc11ce5c1b3232bf6f931f982", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 166, "deletions": 3, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/61b6bf54fdf56195baf9a8ee7383551b0d468c81/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61b6bf54fdf56195baf9a8ee7383551b0d468c81/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=61b6bf54fdf56195baf9a8ee7383551b0d468c81", "patch": "@@ -1018,14 +1018,22 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n                          name, $($fmt)*));\n         }\n     }\n-    macro_rules! require {\n-        ($cond: expr, $($fmt: tt)*) => {\n-            if !$cond {\n+    macro_rules! return_error {\n+        ($($fmt: tt)*) => {\n+            {\n                 emit_error!($($fmt)*);\n                 return Err(());\n             }\n         }\n     }\n+\n+    macro_rules! require {\n+        ($cond: expr, $($fmt: tt)*) => {\n+            if !$cond {\n+                return_error!($($fmt)*);\n+            }\n+        };\n+    }\n     macro_rules! require_simd {\n         ($ty: expr, $position: expr) => {\n             require!($ty.is_simd(), \"expected SIMD {} type, found non-SIMD `{}`\", $position, $ty)\n@@ -1145,6 +1153,161 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n         return Ok(bx.extract_element(args[0].immediate(), args[1].immediate()))\n     }\n \n+    macro_rules! arith_red {\n+        ($name:tt : $integer_reduce:ident, $float_reduce:ident, $ordered:expr) => {\n+            if name == $name {\n+                require!(ret_ty == in_elem,\n+                         \"expected return type `{}` (element of input `{}`), found `{}`\",\n+                         in_elem, in_ty, ret_ty);\n+                return match in_elem.sty {\n+                    ty::TyInt(_) | ty::TyUint(_) => {\n+                        let r = bx.$integer_reduce(args[0].immediate());\n+                        if $ordered {\n+                            // if overflow occurs, the result is the\n+                            // mathematical result modulo 2^n:\n+                            if name.contains(\"mul\") {\n+                                Ok(bx.mul(args[1].immediate(), r))\n+                            } else {\n+                                Ok(bx.add(args[1].immediate(), r))\n+                            }\n+                        } else {\n+                            Ok(bx.$integer_reduce(args[0].immediate()))\n+                        }\n+                    },\n+                    ty::TyFloat(f) => {\n+                        // ordered arithmetic reductions take an accumulator\n+                        let acc = if $ordered {\n+                            let acc = args[1].immediate();\n+                            // FIXME: https://bugs.llvm.org/show_bug.cgi?id=36734\n+                            // * if the accumulator of the fadd isn't 0, incorrect\n+                            //   code is generated\n+                            // * if the accumulator of the fmul isn't 1, incorrect\n+                            //   code is generated\n+                            match const_get_real(acc) {\n+                                None => return_error!(\"accumulator of {} is not a constant\", $name),\n+                                Some((v, loses_info)) => {\n+                                    if $name.contains(\"mul\") && v != 1.0_f64 {\n+                                        return_error!(\"accumulator of {} is not 1.0\", $name);\n+                                    } else if $name.contains(\"add\") && v != 0.0_f64 {\n+                                        return_error!(\"accumulator of {} is not 0.0\", $name);\n+                                    } else if loses_info {\n+                                        return_error!(\"accumulator of {} loses information\", $name);\n+                                    }\n+                                }\n+                            }\n+                            acc\n+                        } else {\n+                            // unordered arithmetic reductions do not:\n+                            match f.bit_width() {\n+                                32 => C_undef(Type::f32(bx.cx)),\n+                                64 => C_undef(Type::f64(bx.cx)),\n+                                v => {\n+                                    return_error!(r#\"\n+unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n+                                        $name, in_ty, in_elem, v, ret_ty\n+                                    )\n+                                }\n+                            }\n+\n+                        };\n+                        Ok(bx.$float_reduce(acc, args[0].immediate()))\n+                    }\n+                    _ => {\n+                        return_error!(\n+                            \"unsupported {} from `{}` with element `{}` to `{}`\",\n+                            $name, in_ty, in_elem, ret_ty\n+                        )\n+                    },\n+                }\n+            }\n+        }\n+    }\n+\n+    arith_red!(\"simd_reduce_add_ordered\": vector_reduce_add, vector_reduce_fadd_fast, true);\n+    arith_red!(\"simd_reduce_mul_ordered\": vector_reduce_mul, vector_reduce_fmul_fast, true);\n+    arith_red!(\"simd_reduce_add_unordered\": vector_reduce_add, vector_reduce_fadd_fast, false);\n+    arith_red!(\"simd_reduce_mul_unordered\": vector_reduce_mul, vector_reduce_fmul_fast, false);\n+\n+    macro_rules! minmax_red {\n+        ($name:tt: $int_red:ident, $float_red:ident) => {\n+            if name == $name {\n+                require!(ret_ty == in_elem,\n+                         \"expected return type `{}` (element of input `{}`), found `{}`\",\n+                         in_elem, in_ty, ret_ty);\n+                return match in_elem.sty {\n+                    ty::TyInt(_i) => {\n+                        Ok(bx.$int_red(args[0].immediate(), true))\n+                    },\n+                    ty::TyUint(_u) => {\n+                        Ok(bx.$int_red(args[0].immediate(), false))\n+                    },\n+                    ty::TyFloat(_f) => {\n+                        Ok(bx.$float_red(args[0].immediate()))\n+                    }\n+                    _ => {\n+                        return_error!(\"unsupported {} from `{}` with element `{}` to `{}`\",\n+                                      $name, in_ty, in_elem, ret_ty)\n+                    },\n+                }\n+            }\n+\n+        }\n+    }\n+\n+    minmax_red!(\"simd_reduce_min\": vector_reduce_min, vector_reduce_fmin);\n+    minmax_red!(\"simd_reduce_max\": vector_reduce_max, vector_reduce_fmax);\n+\n+    minmax_red!(\"simd_reduce_min_nanless\": vector_reduce_min, vector_reduce_fmin_fast);\n+    minmax_red!(\"simd_reduce_max_nanless\": vector_reduce_max, vector_reduce_fmax_fast);\n+\n+    macro_rules! bitwise_red {\n+        ($name:tt : $red:ident, $boolean:expr) => {\n+            if name == $name {\n+                let input = if !$boolean {\n+                    require!(ret_ty == in_elem,\n+                             \"expected return type `{}` (element of input `{}`), found `{}`\",\n+                             in_elem, in_ty, ret_ty);\n+                    args[0].immediate()\n+                } else {\n+                    match in_elem.sty {\n+                        ty::TyInt(_) | ty::TyUint(_) => {},\n+                        _ => {\n+                            return_error!(\"unsupported {} from `{}` with element `{}` to `{}`\",\n+                                          $name, in_ty, in_elem, ret_ty)\n+                        }\n+                    }\n+\n+                    // boolean reductions operate on vectors of i1s:\n+                    let i1 = Type::i1(bx.cx);\n+                    let i1xn = Type::vector(&i1, in_len as u64);\n+                    bx.trunc(args[0].immediate(), i1xn)\n+                };\n+                return match in_elem.sty {\n+                    ty::TyInt(_) | ty::TyUint(_) => {\n+                        let r = bx.$red(input);\n+                        Ok(\n+                            if !$boolean {\n+                                r\n+                            } else {\n+                                bx.zext(r, Type::bool(bx.cx))\n+                            }\n+                        )\n+                    },\n+                    _ => {\n+                        return_error!(\"unsupported {} from `{}` with element `{}` to `{}`\",\n+                                      $name, in_ty, in_elem, ret_ty)\n+                    },\n+                }\n+            }\n+        }\n+    }\n+\n+    bitwise_red!(\"simd_reduce_and\": vector_reduce_and, false);\n+    bitwise_red!(\"simd_reduce_or\": vector_reduce_or, false);\n+    bitwise_red!(\"simd_reduce_xor\": vector_reduce_xor, false);\n+    bitwise_red!(\"simd_reduce_all\": vector_reduce_and, true);\n+    bitwise_red!(\"simd_reduce_any\": vector_reduce_or, true);\n+\n     if name == \"simd_cast\" {\n         require_simd!(ret_ty, \"return\");\n         let out_len = ret_ty.simd_size(tcx);"}, {"sha": "99707a4a3c0e59618e9fc36fd15e274adf16533d", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/61b6bf54fdf56195baf9a8ee7383551b0d468c81/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61b6bf54fdf56195baf9a8ee7383551b0d468c81/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=61b6bf54fdf56195baf9a8ee7383551b0d468c81", "patch": "@@ -361,6 +361,14 @@ pub fn check_platform_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         \"simd_insert\" => (2, vec![param(0), tcx.types.u32, param(1)], param(0)),\n         \"simd_extract\" => (2, vec![param(0), tcx.types.u32], param(1)),\n         \"simd_cast\" => (2, vec![param(0)], param(1)),\n+        \"simd_reduce_all\" | \"simd_reduce_any\" => (1, vec![param(0)], tcx.types.bool),\n+        \"simd_reduce_add_ordered\" | \"simd_reduce_mul_ordered\"\n+            => (2, vec![param(0), param(1)], param(1)),\n+        \"simd_reduce_add_unordered\" | \"simd_reduce_mul_unordered\" |\n+        \"simd_reduce_and\" | \"simd_reduce_or\"  | \"simd_reduce_xor\" |\n+        \"simd_reduce_min\" | \"simd_reduce_max\" |\n+        \"simd_reduce_min_nanless\" | \"simd_reduce_max_nanless\"\n+            => (2, vec![param(0)], param(1)),\n         name if name.starts_with(\"simd_shuffle\") => {\n             match name[\"simd_shuffle\".len()..].parse() {\n                 Ok(n) => {"}, {"sha": "a5644d6f9e2e1fab9edd6278eb8110ef8dae8d15", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/61b6bf54fdf56195baf9a8ee7383551b0d468c81/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/61b6bf54fdf56195baf9a8ee7383551b0d468c81/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=61b6bf54fdf56195baf9a8ee7383551b0d468c81", "patch": "@@ -21,6 +21,8 @@\n \n #if LLVM_VERSION_GE(5, 0)\n #include \"llvm/ADT/Optional.h\"\n+#else\n+#include <cstdlib>\n #endif\n \n //===----------------------------------------------------------------------===\n@@ -1395,3 +1397,98 @@ LLVMRustModuleCost(LLVMModuleRef M) {\n   auto f = unwrap(M)->functions();\n   return std::distance(std::begin(f), std::end(f));\n }\n+\n+// Vector reductions:\n+#if LLVM_VERSION_GE(5, 0)\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceFAdd(LLVMBuilderRef B, LLVMValueRef Acc, LLVMValueRef Src) {\n+    return wrap(unwrap(B)->CreateFAddReduce(unwrap(Acc),unwrap(Src)));\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceFMul(LLVMBuilderRef B, LLVMValueRef Acc, LLVMValueRef Src) {\n+    return wrap(unwrap(B)->CreateFMulReduce(unwrap(Acc),unwrap(Src)));\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceAdd(LLVMBuilderRef B, LLVMValueRef Src) {\n+    return wrap(unwrap(B)->CreateAddReduce(unwrap(Src)));\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceMul(LLVMBuilderRef B, LLVMValueRef Src) {\n+    return wrap(unwrap(B)->CreateMulReduce(unwrap(Src)));\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceAnd(LLVMBuilderRef B, LLVMValueRef Src) {\n+    return wrap(unwrap(B)->CreateAndReduce(unwrap(Src)));\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceOr(LLVMBuilderRef B, LLVMValueRef Src) {\n+    return wrap(unwrap(B)->CreateOrReduce(unwrap(Src)));\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceXor(LLVMBuilderRef B, LLVMValueRef Src) {\n+    return wrap(unwrap(B)->CreateXorReduce(unwrap(Src)));\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceMin(LLVMBuilderRef B, LLVMValueRef Src, bool IsSigned) {\n+    return wrap(unwrap(B)->CreateIntMinReduce(unwrap(Src), IsSigned));\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceMax(LLVMBuilderRef B, LLVMValueRef Src, bool IsSigned) {\n+    return wrap(unwrap(B)->CreateIntMaxReduce(unwrap(Src), IsSigned));\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceFMin(LLVMBuilderRef B, LLVMValueRef Src, bool NoNaN) {\n+   return wrap(unwrap(B)->CreateFPMinReduce(unwrap(Src), NoNaN));\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceFMax(LLVMBuilderRef B, LLVMValueRef Src, bool NoNaN) {\n+  return wrap(unwrap(B)->CreateFPMaxReduce(unwrap(Src), NoNaN));\n+}\n+\n+#else\n+\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceFAdd(LLVMBuilderRef, LLVMValueRef, LLVMValueRef) {\n+  return nullptr;\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceFMul(LLVMBuilderRef, LLVMValueRef, LLVMValueRef) {\n+  return nullptr;\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceAdd(LLVMBuilderRef, LLVMValueRef) {\n+  return nullptr;\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceMul(LLVMBuilderRef, LLVMValueRef) {\n+  return nullptr;\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceAnd(LLVMBuilderRef, LLVMValueRef) {\n+  return nullptr;\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceOr(LLVMBuilderRef, LLVMValueRef) {\n+  return nullptr;\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceXor(LLVMBuilderRef, LLVMValueRef) {\n+  return nullptr;\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceMin(LLVMBuilderRef, LLVMValueRef, bool) {\n+  return nullptr;\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceMax(LLVMBuilderRef, LLVMValueRef, bool) {\n+  return nullptr;\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceFMin(LLVMBuilderRef, LLVMValueRef, bool) {\n+  return nullptr;\n+}\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildVectorReduceFMax(LLVMBuilderRef, LLVMValueRef, bool) {\n+  return nullptr;\n+}\n+#endif"}, {"sha": "57e4bb76a6ce8272678833bd3c98483e6639ef32", "filename": "src/test/compile-fail/simd-intrinsic-generic-reduction.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/61b6bf54fdf56195baf9a8ee7383551b0d468c81/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61b6bf54fdf56195baf9a8ee7383551b0d468c81/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsimd-intrinsic-generic-reduction.rs?ref=61b6bf54fdf56195baf9a8ee7383551b0d468c81", "patch": "@@ -0,0 +1,82 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// min-llvm-version 5.0\n+// ignore-emscripten\n+\n+// Test that the simd_reduce_{op} intrinsics produce ok-ish error\n+// messages when misused.\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+#![allow(non_camel_case_types)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+pub struct u32x4(pub u32, pub u32, pub u32, pub u32);\n+\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_reduce_add_ordered<T, U>(x: T, y: U) -> U;\n+    fn simd_reduce_mul_ordered<T, U>(x: T, y: U) -> U;\n+    fn simd_reduce_and<T, U>(x: T) -> U;\n+    fn simd_reduce_or<T, U>(x: T) -> U;\n+    fn simd_reduce_xor<T, U>(x: T) -> U;\n+    fn simd_reduce_all<T>(x: T) -> bool;\n+    fn simd_reduce_any<T>(x: T) -> bool;\n+}\n+\n+fn main() {\n+    let x = u32x4(0, 0, 0, 0);\n+    let z = f32x4(0.0, 0.0, 0.0, 0.0);\n+\n+    unsafe {\n+        simd_reduce_add_ordered(z, 0_f32);\n+        simd_reduce_mul_ordered(z, 1_f32);\n+\n+        simd_reduce_add_ordered(z, 2_f32);\n+        //~^ ERROR accumulator of simd_reduce_add_ordered is not 0.0\n+        simd_reduce_mul_ordered(z, 3_f32);\n+        //~^ ERROR accumulator of simd_reduce_mul_ordered is not 1.0\n+\n+        let _: f32 = simd_reduce_and(x);\n+        //~^ ERROR expected return type `u32` (element of input `u32x4`), found `f32`\n+        let _: f32 = simd_reduce_or(x);\n+        //~^ ERROR expected return type `u32` (element of input `u32x4`), found `f32`\n+        let _: f32 = simd_reduce_xor(x);\n+        //~^ ERROR expected return type `u32` (element of input `u32x4`), found `f32`\n+\n+        let _: f32 = simd_reduce_and(z);\n+        //~^ ERROR unsupported simd_reduce_and from `f32x4` with element `f32` to `f32`\n+        let _: f32 = simd_reduce_or(z);\n+        //~^ ERROR unsupported simd_reduce_or from `f32x4` with element `f32` to `f32`\n+        let _: f32 = simd_reduce_xor(z);\n+        //~^ ERROR unsupported simd_reduce_xor from `f32x4` with element `f32` to `f32`\n+\n+        let _: bool = simd_reduce_all(z);\n+        //~^ ERROR unsupported simd_reduce_all from `f32x4` with element `f32` to `bool`\n+        let _: bool = simd_reduce_any(z);\n+        //~^ ERROR unsupported simd_reduce_any from `f32x4` with element `f32` to `bool`\n+\n+        foo(0_f32);\n+    }\n+}\n+\n+#[inline(never)]\n+unsafe fn foo(x: f32) {\n+    let z = f32x4(0.0, 0.0, 0.0, 0.0);\n+    simd_reduce_add_ordered(z, x);\n+    //~^ ERROR accumulator of simd_reduce_add_ordered is not a constant\n+    simd_reduce_mul_ordered(z, x);\n+    //~^ ERROR accumulator of simd_reduce_mul_ordered is not a constant\n+}"}, {"sha": "9a1214d3b35e5b7ac4ac2e2b022f961a739bc34b", "filename": "src/test/run-pass/simd-intrinsic-generic-reduction.rs", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/61b6bf54fdf56195baf9a8ee7383551b0d468c81/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61b6bf54fdf56195baf9a8ee7383551b0d468c81/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimd-intrinsic-generic-reduction.rs?ref=61b6bf54fdf56195baf9a8ee7383551b0d468c81", "patch": "@@ -0,0 +1,172 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// min-llvm-version 5.0\n+// ignore-emscripten\n+\n+// Test that the simd_reduce_{op} intrinsics produce the correct results.\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+#[allow(non_camel_case_types)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+struct i32x4(pub i32, pub i32, pub i32, pub i32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+struct u32x4(pub u32, pub u32, pub u32, pub u32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+struct f32x4(pub f32, pub f32, pub f32, pub f32);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+struct b8x4(pub i8, pub i8, pub i8, pub i8);\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+struct b8x16(\n+    pub i8, pub i8, pub i8, pub i8,\n+    pub i8, pub i8, pub i8, pub i8,\n+    pub i8, pub i8, pub i8, pub i8,\n+    pub i8, pub i8, pub i8, pub i8\n+);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_reduce_add_unordered<T, U>(x: T) -> U;\n+    fn simd_reduce_mul_unordered<T, U>(x: T) -> U;\n+    fn simd_reduce_add_ordered<T, U>(x: T, acc: U) -> U;\n+    fn simd_reduce_mul_ordered<T, U>(x: T, acc: U) -> U;\n+    fn simd_reduce_min<T, U>(x: T) -> U;\n+    fn simd_reduce_max<T, U>(x: T) -> U;\n+    fn simd_reduce_min_nanless<T, U>(x: T) -> U;\n+    fn simd_reduce_max_nanless<T, U>(x: T) -> U;\n+    fn simd_reduce_and<T, U>(x: T) -> U;\n+    fn simd_reduce_or<T, U>(x: T) -> U;\n+    fn simd_reduce_xor<T, U>(x: T) -> U;\n+    fn simd_reduce_all<T>(x: T) -> bool;\n+    fn simd_reduce_any<T>(x: T) -> bool;\n+}\n+\n+fn main() {\n+    unsafe {\n+        let x = i32x4(1, -2, 3, 4);\n+        let r: i32 = simd_reduce_add_unordered(x);\n+        assert_eq!(r, 6_i32);\n+        let r: i32 = simd_reduce_mul_unordered(x);\n+        assert_eq!(r, -24_i32);\n+        let r: i32 = simd_reduce_add_ordered(x, -1);\n+        assert_eq!(r, 5_i32);\n+        let r: i32 = simd_reduce_mul_ordered(x, -1);\n+        assert_eq!(r, 24_i32);\n+\n+        let r: i32 = simd_reduce_min(x);\n+        assert_eq!(r, -2_i32);\n+        let r: i32 = simd_reduce_max(x);\n+        assert_eq!(r, 4_i32);\n+\n+        let x = i32x4(-1, -1, -1, -1);\n+        let r: i32 = simd_reduce_and(x);\n+        assert_eq!(r, -1_i32);\n+        let r: i32 = simd_reduce_or(x);\n+        assert_eq!(r, -1_i32);\n+        let r: i32 = simd_reduce_xor(x);\n+        assert_eq!(r, 0_i32);\n+\n+        let x = i32x4(-1, -1, 0, -1);\n+        let r: i32 = simd_reduce_and(x);\n+        assert_eq!(r, 0_i32);\n+        let r: i32 = simd_reduce_or(x);\n+        assert_eq!(r, -1_i32);\n+        let r: i32 = simd_reduce_xor(x);\n+        assert_eq!(r, -1_i32);\n+    }\n+\n+    unsafe {\n+        let x = u32x4(1, 2, 3, 4);\n+        let r: u32 = simd_reduce_add_unordered(x);\n+        assert_eq!(r, 10_u32);\n+        let r: u32 = simd_reduce_mul_unordered(x);\n+        assert_eq!(r, 24_u32);\n+        let r: u32 = simd_reduce_add_ordered(x, 1);\n+        assert_eq!(r, 11_u32);\n+        let r: u32 = simd_reduce_mul_ordered(x, 2);\n+        assert_eq!(r, 48_u32);\n+\n+        let r: u32 = simd_reduce_min(x);\n+        assert_eq!(r, 1_u32);\n+        let r: u32 = simd_reduce_max(x);\n+        assert_eq!(r, 4_u32);\n+\n+        let t = u32::max_value();\n+        let x = u32x4(t, t, t, t);\n+        let r: u32 = simd_reduce_and(x);\n+        assert_eq!(r, t);\n+        let r: u32 = simd_reduce_or(x);\n+        assert_eq!(r, t);\n+        let r: u32 = simd_reduce_xor(x);\n+        assert_eq!(r, 0_u32);\n+\n+        let x = u32x4(t, t, 0, t);\n+        let r: u32 = simd_reduce_and(x);\n+        assert_eq!(r, 0_u32);\n+        let r: u32 = simd_reduce_or(x);\n+        assert_eq!(r, t);\n+        let r: u32 = simd_reduce_xor(x);\n+        assert_eq!(r, t);\n+    }\n+\n+    unsafe {\n+        let x = f32x4(1., -2., 3., 4.);\n+        let r: f32 = simd_reduce_add_unordered(x);\n+        assert_eq!(r, 6_f32);\n+        let r: f32 = simd_reduce_mul_unordered(x);\n+        assert_eq!(r, -24_f32);\n+        // FIXME: only works correctly for accumulator, 0:\n+        // https://bugs.llvm.org/show_bug.cgi?id=36734\n+        let r: f32 = simd_reduce_add_ordered(x, 0.);\n+        assert_eq!(r, 6_f32);\n+        // FIXME: only works correctly for accumulator, 1:\n+        // https://bugs.llvm.org/show_bug.cgi?id=36734\n+        let r: f32 = simd_reduce_mul_ordered(x, 1.);\n+        assert_eq!(r, -24_f32);\n+\n+        let r: f32 = simd_reduce_min(x);\n+        assert_eq!(r, -2_f32);\n+        let r: f32 = simd_reduce_max(x);\n+        assert_eq!(r, 4_f32);\n+        let r: f32 = simd_reduce_min_nanless(x);\n+        assert_eq!(r, -2_f32);\n+        let r: f32 = simd_reduce_max_nanless(x);\n+        assert_eq!(r, 4_f32);\n+    }\n+\n+    unsafe {\n+        let x = b8x4(!0, !0, !0, !0);\n+        let r: bool = simd_reduce_all(x);\n+        assert_eq!(r, true);\n+        let r: bool = simd_reduce_any(x);\n+        assert_eq!(r, true);\n+\n+        let x = b8x4(!0, !0, 0, !0);\n+        let r: bool = simd_reduce_all(x);\n+        assert_eq!(r, false);\n+        let r: bool = simd_reduce_any(x);\n+        assert_eq!(r, true);\n+\n+        let x = b8x4(0, 0, 0, 0);\n+        let r: bool = simd_reduce_all(x);\n+        assert_eq!(r, false);\n+        let r: bool = simd_reduce_any(x);\n+        assert_eq!(r, false);\n+    }\n+}"}, {"sha": "2e7e118441090216da438c646ddf3661413fdb72", "filename": "src/test/ui/issue-49074.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/61b6bf54fdf56195baf9a8ee7383551b0d468c81/src%2Ftest%2Fui%2Fissue-49074.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61b6bf54fdf56195baf9a8ee7383551b0d468c81/src%2Ftest%2Fui%2Fissue-49074.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-49074.rs?ref=61b6bf54fdf56195baf9a8ee7383551b0d468c81", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that unknown attribute error is shown even if there are unresolved macros.\n+\n+#[marco_use] // typo\n+//~^ ERROR The attribute `marco_use` is currently unknown to the compiler\n+mod foo {\n+    macro_rules! bar {\n+        () => ();\n+    }\n+}\n+\n+fn main() {\n+   bar!();\n+   //~^ ERROR cannot find macro `bar!`\n+}"}, {"sha": "c9984ea2e9a8a97e14487cb23032ba9d645fa0e4", "filename": "src/test/ui/issue-49074.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/61b6bf54fdf56195baf9a8ee7383551b0d468c81/src%2Ftest%2Fui%2Fissue-49074.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/61b6bf54fdf56195baf9a8ee7383551b0d468c81/src%2Ftest%2Fui%2Fissue-49074.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-49074.stderr?ref=61b6bf54fdf56195baf9a8ee7383551b0d468c81", "patch": "@@ -0,0 +1,19 @@\n+error: cannot find macro `bar!` in this scope\n+  --> $DIR/issue-49074.rs:22:4\n+   |\n+LL |    bar!();\n+   |    ^^^\n+   |\n+   = help: have you added the `#[macro_use]` on the module/import?\n+\n+error[E0658]: The attribute `marco_use` is currently unknown to the compiler and may have meaning added to it in the future (see issue #29642)\n+  --> $DIR/issue-49074.rs:13:1\n+   |\n+LL | #[marco_use] // typo\n+   | ^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(custom_attribute)] to the crate attributes to enable\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "c24762201004b4bbe9b90d2ed1d14e0e406af069", "filename": "src/test/ui/underscore-lifetime/dyn-trait-underscore.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/61b6bf54fdf56195baf9a8ee7383551b0d468c81/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61b6bf54fdf56195baf9a8ee7383551b0d468c81/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.rs?ref=61b6bf54fdf56195baf9a8ee7383551b0d468c81", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that the `'_` in `dyn Trait + '_` acts like ordinary elision,\n+// and not like an object lifetime default.\n+//\n+// cc #48468\n+\n+#![feature(dyn_trait)]\n+#![feature(underscore_lifetimes)]\n+\n+fn a<T>(items: &[T]) -> Box<dyn Iterator<Item=&T>> {\n+    //                      ^^^^^^^^^^^^^^^^^^^^^ bound *here* defaults to `'static`\n+    Box::new(items.iter()) //~ ERROR cannot infer an appropriate lifetime\n+}\n+\n+fn b<T>(items: &[T]) -> Box<dyn Iterator<Item=&T> + '_> {\n+    Box::new(items.iter()) // OK, equivalent to c\n+}\n+\n+fn c<'a, T>(items: &'a [T]) -> Box<dyn Iterator<Item=&'a T> + 'a> {\n+    Box::new(items.iter()) // OK, equivalent to b\n+}\n+\n+fn main() { }"}, {"sha": "cb3035f42a04a1256cbade9a68eef0b67b594ab6", "filename": "src/test/ui/underscore-lifetime/dyn-trait-underscore.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/61b6bf54fdf56195baf9a8ee7383551b0d468c81/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/61b6bf54fdf56195baf9a8ee7383551b0d468c81/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.stderr?ref=61b6bf54fdf56195baf9a8ee7383551b0d468c81", "patch": "@@ -0,0 +1,27 @@\n+error[E0495]: cannot infer an appropriate lifetime for autoref due to conflicting requirements\n+  --> $DIR/dyn-trait-underscore.rs:21:20\n+   |\n+LL |     Box::new(items.iter()) //~ ERROR cannot infer an appropriate lifetime\n+   |                    ^^^^\n+   |\n+note: first, the lifetime cannot outlive the anonymous lifetime #1 defined on the function body at 19:1...\n+  --> $DIR/dyn-trait-underscore.rs:19:1\n+   |\n+LL | / fn a<T>(items: &[T]) -> Box<dyn Iterator<Item=&T>> {\n+LL | |     //                      ^^^^^^^^^^^^^^^^^^^^^ bound *here* defaults to `'static`\n+LL | |     Box::new(items.iter()) //~ ERROR cannot infer an appropriate lifetime\n+LL | | }\n+   | |_^\n+note: ...so that reference does not outlive borrowed content\n+  --> $DIR/dyn-trait-underscore.rs:21:14\n+   |\n+LL |     Box::new(items.iter()) //~ ERROR cannot infer an appropriate lifetime\n+   |              ^^^^^\n+   = note: but, the lifetime must be valid for the static lifetime...\n+   = note: ...so that the expression is assignable:\n+           expected std::boxed::Box<std::iter::Iterator<Item=&T> + 'static>\n+              found std::boxed::Box<std::iter::Iterator<Item=&T>>\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0495`."}]}