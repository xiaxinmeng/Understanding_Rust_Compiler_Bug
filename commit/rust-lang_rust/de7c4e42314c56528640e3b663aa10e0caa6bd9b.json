{"sha": "de7c4e42314c56528640e3b663aa10e0caa6bd9b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlN2M0ZTQyMzE0YzU2NTI4NjQwZTNiNjYzYWExMGUwY2FhNmJkOWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-23T20:05:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-23T20:05:01Z"}, "message": "Auto merge of #62037 - Mark-Simulacrum:tidy-fast, r=eddyb\n\nSpeed up tidy\n\nmaster:\n  Time (mean \u00b1 \u03c3):      3.478 s \u00b1  0.033 s    [User: 3.298 s, System: 0.178 s]\n  Range (min \u2026 max):    3.425 s \u2026  3.525 s    10 runs\n\nThis PR:\n  Time (mean \u00b1 \u03c3):      1.098 s \u00b1  0.006 s    [User: 783.7 ms, System: 310.2 ms]\n  Range (min \u2026 max):    1.092 s \u2026  1.113 s    10 runs\n\nAlleviates https://github.com/rust-lang/rust/issues/59884. For the most part each commit stands on its own. Timings are on warm filesystem cache.\n\nr? @eddyb", "tree": {"sha": "a29a945214a1bddc1a9d05b1d9c0f6fe65ca0497", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a29a945214a1bddc1a9d05b1d9c0f6fe65ca0497"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de7c4e42314c56528640e3b663aa10e0caa6bd9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de7c4e42314c56528640e3b663aa10e0caa6bd9b", "html_url": "https://github.com/rust-lang/rust/commit/de7c4e42314c56528640e3b663aa10e0caa6bd9b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de7c4e42314c56528640e3b663aa10e0caa6bd9b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2cd5ed495ceb6224a091c2310ff90c91dd9afbd9", "url": "https://api.github.com/repos/rust-lang/rust/commits/2cd5ed495ceb6224a091c2310ff90c91dd9afbd9", "html_url": "https://github.com/rust-lang/rust/commit/2cd5ed495ceb6224a091c2310ff90c91dd9afbd9"}, {"sha": "777951c926820cc20f0047d49091c37e0fbff14e", "url": "https://api.github.com/repos/rust-lang/rust/commits/777951c926820cc20f0047d49091c37e0fbff14e", "html_url": "https://github.com/rust-lang/rust/commit/777951c926820cc20f0047d49091c37e0fbff14e"}], "stats": {"total": 319, "additions": 173, "deletions": 146}, "files": [{"sha": "657831be894f89861b2c509a9d0ad04e78d6465a", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de7c4e42314c56528640e3b663aa10e0caa6bd9b/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/de7c4e42314c56528640e3b663aa10e0caa6bd9b/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=de7c4e42314c56528640e3b663aa10e0caa6bd9b", "patch": "@@ -3801,9 +3801,11 @@ dependencies = [\n name = \"tidy\"\n version = \"0.1.0\"\n dependencies = [\n+ \"lazy_static 1.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 1.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.92 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"walkdir 2.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]"}, {"sha": "2f9bd067c3115dee4a11de378206611fe4879d83", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de7c4e42314c56528640e3b663aa10e0caa6bd9b/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de7c4e42314c56528640e3b663aa10e0caa6bd9b/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=de7c4e42314c56528640e3b663aa10e0caa6bd9b", "patch": "@@ -709,8 +709,8 @@ impl Step for Tidy {\n         if !builder.config.vendor {\n             cmd.arg(\"--no-vendor\");\n         }\n-        if !builder.config.verbose_tests {\n-            cmd.arg(\"--quiet\");\n+        if builder.is_verbose() {\n+            cmd.arg(\"--verbose\");\n         }\n \n         let _folder = builder.fold_output(|| \"tidy\");"}, {"sha": "43cae31f33f1faf76f29f762861446f67f4ea422", "filename": "src/tools/tidy/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de7c4e42314c56528640e3b663aa10e0caa6bd9b/src%2Ftools%2Ftidy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/de7c4e42314c56528640e3b663aa10e0caa6bd9b/src%2Ftools%2Ftidy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2FCargo.toml?ref=de7c4e42314c56528640e3b663aa10e0caa6bd9b", "patch": "@@ -8,3 +8,5 @@ edition = \"2018\"\n regex = \"1\"\n serde = { version = \"1.0.8\", features = [\"derive\"] }\n serde_json = \"1.0.2\"\n+lazy_static = \"1\"\n+walkdir = \"2\""}, {"sha": "680585a6e04a72e73837299b2931ce9bbbe00a53", "filename": "src/tools/tidy/src/bins.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/de7c4e42314c56528640e3b663aa10e0caa6bd9b/src%2Ftools%2Ftidy%2Fsrc%2Fbins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de7c4e42314c56528640e3b663aa10e0caa6bd9b/src%2Ftools%2Ftidy%2Fsrc%2Fbins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fbins.rs?ref=de7c4e42314c56528640e3b663aa10e0caa6bd9b", "patch": "@@ -25,16 +25,17 @@ pub fn check(path: &Path, bad: &mut bool) {\n         }\n     }\n \n-    super::walk(path,\n+    super::walk_no_read(path,\n                 &mut |path| super::filter_dirs(path) || path.ends_with(\"src/etc\"),\n-                &mut |file| {\n+                &mut |entry| {\n+        let file = entry.path();\n         let filename = file.file_name().unwrap().to_string_lossy();\n         let extensions = [\".py\", \".sh\"];\n         if extensions.iter().any(|e| filename.ends_with(e)) {\n             return;\n         }\n \n-        let metadata = t!(fs::symlink_metadata(&file), &file);\n+        let metadata = t!(entry.metadata(), file);\n         if metadata.mode() & 0o111 != 0 {\n             let rel_path = file.strip_prefix(path).unwrap();\n             let git_friendly_path = rel_path.to_str().unwrap().replace(\"\\\\\", \"/\");"}, {"sha": "1bc27745376cc0e0c65d1f4e984aa6c6276215a2", "filename": "src/tools/tidy/src/errors.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/de7c4e42314c56528640e3b663aa10e0caa6bd9b/src%2Ftools%2Ftidy%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de7c4e42314c56528640e3b663aa10e0caa6bd9b/src%2Ftools%2Ftidy%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ferrors.rs?ref=de7c4e42314c56528640e3b663aa10e0caa6bd9b", "patch": "@@ -4,24 +4,19 @@\n //! statistics about the error codes.\n \n use std::collections::HashMap;\n-use std::fs::File;\n-use std::io::prelude::*;\n use std::path::Path;\n \n pub fn check(path: &Path, bad: &mut bool) {\n-    let mut contents = String::new();\n     let mut map: HashMap<_, Vec<_>> = HashMap::new();\n     super::walk(path,\n                 &mut |path| super::filter_dirs(path) || path.ends_with(\"src/test\"),\n-                &mut |file| {\n+                &mut |entry, contents| {\n+        let file = entry.path();\n         let filename = file.file_name().unwrap().to_string_lossy();\n         if filename != \"error_codes.rs\" {\n             return\n         }\n \n-        contents.truncate(0);\n-        t!(t!(File::open(file)).read_to_string(&mut contents));\n-\n         // In the `register_long_diagnostics!` macro, entries look like this:\n         //\n         // ```"}, {"sha": "1841beb1fd1168211db2e40592b520fbf639755a", "filename": "src/tools/tidy/src/features.rs", "status": "modified", "additions": 75, "deletions": 57, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/de7c4e42314c56528640e3b663aa10e0caa6bd9b/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de7c4e42314c56528640e3b663aa10e0caa6bd9b/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs?ref=de7c4e42314c56528640e3b663aa10e0caa6bd9b", "patch": "@@ -11,11 +11,10 @@\n \n use std::collections::HashMap;\n use std::fmt;\n-use std::fs::{self, File};\n-use std::io::prelude::*;\n+use std::fs;\n use std::path::Path;\n \n-use regex::{Regex, escape};\n+use regex::Regex;\n \n mod version;\n use version::Version;\n@@ -51,20 +50,48 @@ pub struct Feature {\n \n pub type Features = HashMap<String, Feature>;\n \n-pub fn check(path: &Path, bad: &mut bool, quiet: bool) {\n+pub struct CollectedFeatures {\n+    pub lib: Features,\n+    pub lang: Features,\n+}\n+\n+// Currently only used for unstable book generation\n+pub fn collect_lib_features(base_src_path: &Path) -> Features {\n+    let mut lib_features = Features::new();\n+\n+    // This library feature is defined in the `compiler_builtins` crate, which\n+    // has been moved out-of-tree. Now it can no longer be auto-discovered by\n+    // `tidy`, because we need to filter out its (submodule) directory. Manually\n+    // add it to the set of known library features so we can still generate docs.\n+    lib_features.insert(\"compiler_builtins_lib\".to_owned(), Feature {\n+        level: Status::Unstable,\n+        since: None,\n+        has_gate_test: false,\n+        tracking_issue: None,\n+    });\n+\n+    map_lib_features(base_src_path,\n+                     &mut |res, _, _| {\n+        if let Ok((name, feature)) = res {\n+            lib_features.insert(name.to_owned(), feature);\n+        }\n+    });\n+   lib_features\n+}\n+\n+pub fn check(path: &Path, bad: &mut bool, verbose: bool) -> CollectedFeatures {\n     let mut features = collect_lang_features(path, bad);\n     assert!(!features.is_empty());\n \n     let lib_features = get_and_check_lib_features(path, bad, &features);\n     assert!(!lib_features.is_empty());\n \n-    let mut contents = String::new();\n-\n     super::walk_many(&[&path.join(\"test/ui\"),\n                        &path.join(\"test/ui-fulldeps\"),\n                        &path.join(\"test/compile-fail\")],\n                      &mut |path| super::filter_dirs(path),\n-                     &mut |file| {\n+                     &mut |entry, contents| {\n+        let file = entry.path();\n         let filename = file.file_name().unwrap().to_string_lossy();\n         if !filename.ends_with(\".rs\") || filename == \"features.rs\" ||\n            filename == \"diagnostic_list.rs\" {\n@@ -74,9 +101,6 @@ pub fn check(path: &Path, bad: &mut bool, quiet: bool) {\n         let filen_underscore = filename.replace('-',\"_\").replace(\".rs\",\"\");\n         let filename_is_gate_test = test_filen_gate(&filen_underscore, &mut features);\n \n-        contents.truncate(0);\n-        t!(t!(File::open(&file), &file).read_to_string(&mut contents));\n-\n         for (i, line) in contents.lines().enumerate() {\n             let mut err = |msg: &str| {\n                 tidy_error!(bad, \"{}:{}: {}\", file.display(), i + 1, msg);\n@@ -130,21 +154,23 @@ pub fn check(path: &Path, bad: &mut bool, quiet: bool) {\n     }\n \n     if *bad {\n-        return;\n-    }\n-    if quiet {\n-        println!(\"* {} features\", features.len());\n-        return;\n+        return CollectedFeatures { lib: lib_features, lang: features };\n     }\n \n-    let mut lines = Vec::new();\n-    lines.extend(format_features(&features, \"lang\"));\n-    lines.extend(format_features(&lib_features, \"lib\"));\n+    if verbose {\n+        let mut lines = Vec::new();\n+        lines.extend(format_features(&features, \"lang\"));\n+        lines.extend(format_features(&lib_features, \"lib\"));\n \n-    lines.sort();\n-    for line in lines {\n-        println!(\"* {}\", line);\n+        lines.sort();\n+        for line in lines {\n+            println!(\"* {}\", line);\n+        }\n+    } else {\n+        println!(\"* {} features\", features.len());\n     }\n+\n+    CollectedFeatures { lib: lib_features, lang: features }\n }\n \n fn format_features<'a>(features: &'a Features, family: &'a str) -> impl Iterator<Item = String> + 'a {\n@@ -159,8 +185,19 @@ fn format_features<'a>(features: &'a Features, family: &'a str) -> impl Iterator\n }\n \n fn find_attr_val<'a>(line: &'a str, attr: &str) -> Option<&'a str> {\n-    let r = Regex::new(&format!(r#\"{}\\s*=\\s*\"([^\"]*)\"\"#, escape(attr)))\n-        .expect(\"malformed regex for find_attr_val\");\n+    lazy_static::lazy_static! {\n+        static ref ISSUE: Regex = Regex::new(r#\"issue\\s*=\\s*\"([^\"]*)\"\"#).unwrap();\n+        static ref FEATURE: Regex = Regex::new(r#\"feature\\s*=\\s*\"([^\"]*)\"\"#).unwrap();\n+        static ref SINCE: Regex = Regex::new(r#\"since\\s*=\\s*\"([^\"]*)\"\"#).unwrap();\n+    }\n+\n+    let r = match attr {\n+        \"issue\" => &*ISSUE,\n+        \"feature\" => &*FEATURE,\n+        \"since\" => &*SINCE,\n+        _ => unimplemented!(\"{} not handled\", attr),\n+    };\n+\n     r.captures(line)\n         .and_then(|c| c.get(1))\n         .map(|m| m.as_str())\n@@ -175,9 +212,11 @@ fn test_find_attr_val() {\n }\n \n fn test_filen_gate(filen_underscore: &str, features: &mut Features) -> bool {\n-    if filen_underscore.starts_with(\"feature_gate\") {\n+    let prefix = \"feature_gate_\";\n+    if filen_underscore.starts_with(prefix) {\n         for (n, f) in features.iter_mut() {\n-            if filen_underscore == format!(\"feature_gate_{}\", n) {\n+            // Equivalent to filen_underscore == format!(\"feature_gate_{}\", n)\n+            if &filen_underscore[prefix.len()..] == n {\n                 f.has_gate_test = true;\n                 return true;\n             }\n@@ -295,32 +334,6 @@ pub fn collect_lang_features(base_src_path: &Path, bad: &mut bool) -> Features {\n         .collect()\n }\n \n-pub fn collect_lib_features(base_src_path: &Path) -> Features {\n-    let mut lib_features = Features::new();\n-\n-    // This library feature is defined in the `compiler_builtins` crate, which\n-    // has been moved out-of-tree. Now it can no longer be auto-discovered by\n-    // `tidy`, because we need to filter out its (submodule) directory. Manually\n-    // add it to the set of known library features so we can still generate docs.\n-    lib_features.insert(\"compiler_builtins_lib\".to_owned(), Feature {\n-        level: Status::Unstable,\n-        since: None,\n-        has_gate_test: false,\n-        tracking_issue: None,\n-    });\n-\n-    map_lib_features(base_src_path,\n-                     &mut |res, _, _| {\n-        if let Ok((name, feature)) = res {\n-            if lib_features.contains_key(name) {\n-                return;\n-            }\n-            lib_features.insert(name.to_owned(), feature);\n-        }\n-    });\n-   lib_features\n-}\n-\n fn get_and_check_lib_features(base_src_path: &Path,\n                               bad: &mut bool,\n                               lang_features: &Features) -> Features {\n@@ -355,20 +368,25 @@ fn get_and_check_lib_features(base_src_path: &Path,\n \n fn map_lib_features(base_src_path: &Path,\n                     mf: &mut dyn FnMut(Result<(&str, Feature), &str>, &Path, usize)) {\n-    let mut contents = String::new();\n     super::walk(base_src_path,\n                 &mut |path| super::filter_dirs(path) || path.ends_with(\"src/test\"),\n-                &mut |file| {\n+                &mut |entry, contents| {\n+        let file = entry.path();\n         let filename = file.file_name().unwrap().to_string_lossy();\n         if !filename.ends_with(\".rs\") || filename == \"features.rs\" ||\n            filename == \"diagnostic_list.rs\" {\n             return;\n         }\n \n-        contents.truncate(0);\n-        t!(t!(File::open(&file), &file).read_to_string(&mut contents));\n+        // This is an early exit -- all the attributes we're concerned with must contain this:\n+        // * rustc_const_unstable(\n+        // * unstable(\n+        // * stable(\n+        if !contents.contains(\"stable(\") {\n+            return;\n+        }\n \n-        let mut becoming_feature: Option<(String, Feature)> = None;\n+        let mut becoming_feature: Option<(&str, Feature)> = None;\n         for (i, line) in contents.lines().enumerate() {\n             macro_rules! err {\n                 ($msg:expr) => {{\n@@ -447,7 +465,7 @@ fn map_lib_features(base_src_path: &Path,\n             if line.contains(']') {\n                 mf(Ok((feature_name, feature)), file, i + 1);\n             } else {\n-                becoming_feature = Some((feature_name.to_owned(), feature));\n+                becoming_feature = Some((feature_name, feature));\n             }\n         }\n     });"}, {"sha": "a0bf0b073541807caecd000775fe90733d079d67", "filename": "src/tools/tidy/src/lib.rs", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/de7c4e42314c56528640e3b663aa10e0caa6bd9b/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de7c4e42314c56528640e3b663aa10e0caa6bd9b/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs?ref=de7c4e42314c56528640e3b663aa10e0caa6bd9b", "patch": "@@ -3,7 +3,9 @@\n //! This library contains the tidy lints and exposes it\n //! to be used by tools.\n \n-use std::fs;\n+use walkdir::{DirEntry, WalkDir};\n+use std::fs::File;\n+use std::io::Read;\n \n use std::path::Path;\n \n@@ -65,25 +67,35 @@ fn filter_dirs(path: &Path) -> bool {\n     skip.iter().any(|p| path.ends_with(p))\n }\n \n-fn walk_many(paths: &[&Path], skip: &mut dyn FnMut(&Path) -> bool, f: &mut dyn FnMut(&Path)) {\n+\n+fn walk_many(\n+    paths: &[&Path], skip: &mut dyn FnMut(&Path) -> bool, f: &mut dyn FnMut(&DirEntry, &str)\n+) {\n     for path in paths {\n         walk(path, skip, f);\n     }\n }\n \n-fn walk(path: &Path, skip: &mut dyn FnMut(&Path) -> bool, f: &mut dyn FnMut(&Path)) {\n-    if let Ok(dir) = fs::read_dir(path) {\n-        for entry in dir {\n-            let entry = t!(entry);\n-            let kind = t!(entry.file_type());\n-            let path = entry.path();\n-            if kind.is_dir() {\n-                if !skip(&path) {\n-                    walk(&path, skip, f);\n-                }\n-            } else {\n-                f(&path);\n+fn walk(path: &Path, skip: &mut dyn FnMut(&Path) -> bool, f: &mut dyn FnMut(&DirEntry, &str)) {\n+    let mut contents = String::new();\n+    walk_no_read(path, skip, &mut |entry| {\n+        contents.clear();\n+        if t!(File::open(entry.path()), entry.path()).read_to_string(&mut contents).is_err() {\n+            contents.clear();\n+        }\n+        f(&entry, &contents);\n+    });\n+}\n+\n+fn walk_no_read(path: &Path, skip: &mut dyn FnMut(&Path) -> bool, f: &mut dyn FnMut(&DirEntry)) {\n+    let walker = WalkDir::new(path).into_iter()\n+        .filter_entry(|e| !skip(e.path()));\n+    for entry in walker {\n+        if let Ok(entry) = entry {\n+            if entry.file_type().is_dir() {\n+                continue;\n             }\n+            f(&entry);\n         }\n     }\n }"}, {"sha": "ea92f989ada7d8c4c7d07993ca3520b307969c5e", "filename": "src/tools/tidy/src/libcoretest.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/de7c4e42314c56528640e3b663aa10e0caa6bd9b/src%2Ftools%2Ftidy%2Fsrc%2Flibcoretest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de7c4e42314c56528640e3b663aa10e0caa6bd9b/src%2Ftools%2Ftidy%2Fsrc%2Flibcoretest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flibcoretest.rs?ref=de7c4e42314c56528640e3b663aa10e0caa6bd9b", "patch": "@@ -4,29 +4,22 @@\n //! item. All tests must be written externally in `libcore/tests`.\n \n use std::path::Path;\n-use std::fs::read_to_string;\n \n pub fn check(path: &Path, bad: &mut bool) {\n     let libcore_path = path.join(\"libcore\");\n     super::walk(\n         &libcore_path,\n         &mut |subpath| t!(subpath.strip_prefix(&libcore_path)).starts_with(\"tests\"),\n-        &mut |subpath| {\n+        &mut |entry, contents| {\n+            let subpath = entry.path();\n             if let Some(\"rs\") = subpath.extension().and_then(|e| e.to_str()) {\n-                match read_to_string(subpath) {\n-                    Ok(contents) => {\n-                        if contents.contains(\"#[test]\") {\n-                            tidy_error!(\n-                                bad,\n-                                \"{} contains #[test]; libcore tests must be placed inside \\\n-                                `src/libcore/tests/`\",\n-                                subpath.display()\n-                            );\n-                        }\n-                    }\n-                    Err(err) => {\n-                        panic!(\"failed to read file {:?}: {}\", subpath, err);\n-                    }\n+                if contents.contains(\"#[test]\") {\n+                    tidy_error!(\n+                        bad,\n+                        \"{} contains #[test]; libcore tests must be placed inside \\\n+                        `src/libcore/tests/`\",\n+                        subpath.display()\n+                    );\n                 }\n             }\n         },"}, {"sha": "918762ed6e69a20217fdaae89681d4cc388980ae", "filename": "src/tools/tidy/src/main.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/de7c4e42314c56528640e3b663aa10e0caa6bd9b/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de7c4e42314c56528640e3b663aa10e0caa6bd9b/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs?ref=de7c4e42314c56528640e3b663aa10e0caa6bd9b", "patch": "@@ -19,14 +19,14 @@ fn main() {\n     let args: Vec<String> = env::args().skip(1).collect();\n \n     let mut bad = false;\n-    let quiet = args.iter().any(|s| *s == \"--quiet\");\n+    let verbose = args.iter().any(|s| *s == \"--verbose\");\n     bins::check(&path, &mut bad);\n     style::check(&path, &mut bad);\n     errors::check(&path, &mut bad);\n     cargo::check(&path, &mut bad);\n-    features::check(&path, &mut bad, quiet);\n+    let collected = features::check(&path, &mut bad, verbose);\n     pal::check(&path, &mut bad);\n-    unstable_book::check(&path, &mut bad);\n+    unstable_book::check(&path, collected, &mut bad);\n     libcoretest::check(&path, &mut bad);\n     if !args.iter().any(|s| *s == \"--no-vendor\") {\n         deps::check(&path, &mut bad);"}, {"sha": "c6bb16318b6ee124b5207056b8277de456446eeb", "filename": "src/tools/tidy/src/pal.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/de7c4e42314c56528640e3b663aa10e0caa6bd9b/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de7c4e42314c56528640e3b663aa10e0caa6bd9b/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs?ref=de7c4e42314c56528640e3b663aa10e0caa6bd9b", "patch": "@@ -31,8 +31,6 @@\n //! platform-specific cfgs are allowed. Not sure yet how to deal with\n //! this in the long term.\n \n-use std::fs::File;\n-use std::io::Read;\n use std::path::Path;\n use std::iter::Iterator;\n \n@@ -87,29 +85,26 @@ const EXCEPTION_PATHS: &[&str] = &[\n ];\n \n pub fn check(path: &Path, bad: &mut bool) {\n-    let mut contents = String::new();\n     // Sanity check that the complex parsing here works.\n     let mut saw_target_arch = false;\n     let mut saw_cfg_bang = false;\n-    super::walk(path, &mut super::filter_dirs, &mut |file| {\n+    super::walk(path, &mut super::filter_dirs, &mut |entry, contents| {\n+        let file = entry.path();\n         let filestr = file.to_string_lossy().replace(\"\\\\\", \"/\");\n         if !filestr.ends_with(\".rs\") { return }\n \n         let is_exception_path = EXCEPTION_PATHS.iter().any(|s| filestr.contains(&**s));\n         if is_exception_path { return }\n \n-        check_cfgs(&mut contents, &file, bad, &mut saw_target_arch, &mut saw_cfg_bang);\n+        check_cfgs(contents, &file, bad, &mut saw_target_arch, &mut saw_cfg_bang);\n     });\n \n     assert!(saw_target_arch);\n     assert!(saw_cfg_bang);\n }\n \n-fn check_cfgs(contents: &mut String, file: &Path,\n+fn check_cfgs(contents: &str, file: &Path,\n               bad: &mut bool, saw_target_arch: &mut bool, saw_cfg_bang: &mut bool) {\n-    contents.truncate(0);\n-    t!(t!(File::open(file), file).read_to_string(contents));\n-\n     // For now it's ok to have platform-specific code after 'mod tests'.\n     let mod_tests_idx = find_test_mod(contents);\n     let contents = &contents[..mod_tests_idx];"}, {"sha": "4a159d926b7cc009c49f678badfd6cffb6023b10", "filename": "src/tools/tidy/src/style.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/de7c4e42314c56528640e3b663aa10e0caa6bd9b/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de7c4e42314c56528640e3b663aa10e0caa6bd9b/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs?ref=de7c4e42314c56528640e3b663aa10e0caa6bd9b", "patch": "@@ -13,8 +13,6 @@\n //! A number of these checks can be opted-out of with various directives of the form:\n //! `// ignore-tidy-CHECK-NAME`.\n \n-use std::fs::File;\n-use std::io::prelude::*;\n use std::path::Path;\n \n const COLS: usize = 100;\n@@ -109,7 +107,11 @@ enum Directive {\n     Ignore(bool),\n }\n \n-fn contains_ignore_directive(contents: &String, check: &str) -> Directive {\n+fn contains_ignore_directive(can_contain: bool, contents: &str, check: &str) -> Directive {\n+    if !can_contain {\n+        return Directive::Deny;\n+    }\n+    // Update `can_contain` when changing this\n     if contents.contains(&format!(\"// ignore-tidy-{}\", check)) ||\n         contents.contains(&format!(\"# ignore-tidy-{}\", check)) {\n         Directive::Ignore(false)\n@@ -129,28 +131,28 @@ macro_rules! suppressible_tidy_err {\n }\n \n pub fn check(path: &Path, bad: &mut bool) {\n-    let mut contents = String::new();\n-    super::walk(path, &mut super::filter_dirs, &mut |file| {\n+    super::walk(path, &mut super::filter_dirs, &mut |entry, contents| {\n+        let file = entry.path();\n         let filename = file.file_name().unwrap().to_string_lossy();\n         let extensions = [\".rs\", \".py\", \".js\", \".sh\", \".c\", \".cpp\", \".h\"];\n         if extensions.iter().all(|e| !filename.ends_with(e)) ||\n            filename.starts_with(\".#\") {\n             return\n         }\n \n-        contents.truncate(0);\n-        t!(t!(File::open(file), file).read_to_string(&mut contents));\n-\n         if contents.is_empty() {\n             tidy_error!(bad, \"{}: empty file\", file.display());\n         }\n \n-        let mut skip_cr = contains_ignore_directive(&contents, \"cr\");\n-        let mut skip_tab = contains_ignore_directive(&contents, \"tab\");\n-        let mut skip_line_length = contains_ignore_directive(&contents, \"linelength\");\n-        let mut skip_file_length = contains_ignore_directive(&contents, \"filelength\");\n-        let mut skip_end_whitespace = contains_ignore_directive(&contents, \"end-whitespace\");\n-        let mut skip_copyright = contains_ignore_directive(&contents, \"copyright\");\n+        let can_contain = contents.contains(\"// ignore-tidy-\") ||\n+            contents.contains(\"# ignore-tidy-\");\n+        let mut skip_cr = contains_ignore_directive(can_contain, &contents, \"cr\");\n+        let mut skip_tab = contains_ignore_directive(can_contain, &contents, \"tab\");\n+        let mut skip_line_length = contains_ignore_directive(can_contain, &contents, \"linelength\");\n+        let mut skip_file_length = contains_ignore_directive(can_contain, &contents, \"filelength\");\n+        let mut skip_end_whitespace =\n+            contains_ignore_directive(can_contain, &contents, \"end-whitespace\");\n+        let mut skip_copyright = contains_ignore_directive(can_contain, &contents, \"copyright\");\n         let mut leading_new_lines = false;\n         let mut trailing_new_lines = 0;\n         let mut lines = 0;"}, {"sha": "2c52cecccb5dfc563daa57049a5d1e82067b617f", "filename": "src/tools/tidy/src/ui_tests.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/de7c4e42314c56528640e3b663aa10e0caa6bd9b/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de7c4e42314c56528640e3b663aa10e0caa6bd9b/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs?ref=de7c4e42314c56528640e3b663aa10e0caa6bd9b", "patch": "@@ -4,10 +4,9 @@ use std::fs;\n use std::path::Path;\n \n pub fn check(path: &Path, bad: &mut bool) {\n-    super::walk_many(\n-        &[&path.join(\"test/ui\"), &path.join(\"test/ui-fulldeps\")],\n-        &mut |_| false,\n-        &mut |file_path| {\n+    for path in &[&path.join(\"test/ui\"), &path.join(\"test/ui-fulldeps\")] {\n+        super::walk_no_read(path, &mut |_| false, &mut |entry| {\n+            let file_path = entry.path();\n             if let Some(ext) = file_path.extension() {\n                 if ext == \"stderr\" || ext == \"stdout\" {\n                     // Test output filenames have one of the formats:\n@@ -45,6 +44,6 @@ pub fn check(path: &Path, bad: &mut bool) {\n                     }\n                 }\n             }\n-        },\n-    );\n+        });\n+    }\n }"}, {"sha": "fb63520f0684a09e308204795896f1698729edc5", "filename": "src/tools/tidy/src/unstable_book.rs", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/de7c4e42314c56528640e3b663aa10e0caa6bd9b/src%2Ftools%2Ftidy%2Fsrc%2Funstable_book.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de7c4e42314c56528640e3b663aa10e0caa6bd9b/src%2Ftools%2Ftidy%2Fsrc%2Funstable_book.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Funstable_book.rs?ref=de7c4e42314c56528640e3b663aa10e0caa6bd9b", "patch": "@@ -1,7 +1,7 @@\n use std::collections::BTreeSet;\n use std::fs;\n-use std::path;\n-use crate::features::{collect_lang_features, collect_lib_features, Features, Status};\n+use std::path::{PathBuf, Path};\n+use crate::features::{CollectedFeatures, Features, Feature, Status};\n \n pub const PATH_STR: &str = \"doc/unstable-book\";\n \n@@ -12,19 +12,19 @@ pub const LANG_FEATURES_DIR: &str = \"src/language-features\";\n pub const LIB_FEATURES_DIR: &str = \"src/library-features\";\n \n /// Builds the path to the Unstable Book source directory from the Rust 'src' directory.\n-pub fn unstable_book_path(base_src_path: &path::Path) -> path::PathBuf {\n+pub fn unstable_book_path(base_src_path: &Path) -> PathBuf {\n     base_src_path.join(PATH_STR)\n }\n \n /// Builds the path to the directory where the features are documented within the Unstable Book\n /// source directory.\n-pub fn unstable_book_lang_features_path(base_src_path: &path::Path) -> path::PathBuf {\n+pub fn unstable_book_lang_features_path(base_src_path: &Path) -> PathBuf {\n     unstable_book_path(base_src_path).join(LANG_FEATURES_DIR)\n }\n \n /// Builds the path to the directory where the features are documented within the Unstable Book\n /// source directory.\n-pub fn unstable_book_lib_features_path(base_src_path: &path::Path) -> path::PathBuf {\n+pub fn unstable_book_lib_features_path(base_src_path: &Path) -> PathBuf {\n     unstable_book_path(base_src_path).join(LIB_FEATURES_DIR)\n }\n \n@@ -45,7 +45,7 @@ pub fn collect_unstable_feature_names(features: &Features) -> BTreeSet<String> {\n         .collect()\n }\n \n-pub fn collect_unstable_book_section_file_names(dir: &path::Path) -> BTreeSet<String> {\n+pub fn collect_unstable_book_section_file_names(dir: &Path) -> BTreeSet<String> {\n     fs::read_dir(dir)\n         .expect(\"could not read directory\")\n         .map(|entry| entry.expect(\"could not read directory entry\"))\n@@ -60,7 +60,7 @@ pub fn collect_unstable_book_section_file_names(dir: &path::Path) -> BTreeSet<St\n ///\n /// * hyphens replaced by underscores,\n /// * the markdown suffix ('.md') removed.\n-fn collect_unstable_book_lang_features_section_file_names(base_src_path: &path::Path)\n+fn collect_unstable_book_lang_features_section_file_names(base_src_path: &Path)\n                                                           -> BTreeSet<String> {\n     collect_unstable_book_section_file_names(&unstable_book_lang_features_path(base_src_path))\n }\n@@ -69,18 +69,26 @@ fn collect_unstable_book_lang_features_section_file_names(base_src_path: &path::\n ///\n /// * hyphens replaced by underscores,\n /// * the markdown suffix ('.md') removed.\n-fn collect_unstable_book_lib_features_section_file_names(base_src_path: &path::Path)\n-                                                         -> BTreeSet<String> {\n+fn collect_unstable_book_lib_features_section_file_names(base_src_path: &Path) -> BTreeSet<String> {\n     collect_unstable_book_section_file_names(&unstable_book_lib_features_path(base_src_path))\n }\n \n-pub fn check(path: &path::Path, bad: &mut bool) {\n-    // Library features\n-\n-    let lang_features = collect_lang_features(path, bad);\n-    let lib_features = collect_lib_features(path).into_iter().filter(|&(ref name, _)| {\n+pub fn check(path: &Path, features: CollectedFeatures, bad: &mut bool) {\n+    let lang_features = features.lang;\n+    let mut lib_features = features.lib.into_iter().filter(|&(ref name, _)| {\n         !lang_features.contains_key(name)\n-    }).collect();\n+    }).collect::<Features>();\n+\n+    // This library feature is defined in the `compiler_builtins` crate, which\n+    // has been moved out-of-tree. Now it can no longer be auto-discovered by\n+    // `tidy`, because we need to filter out its (submodule) directory. Manually\n+    // add it to the set of known library features so we can still generate docs.\n+    lib_features.insert(\"compiler_builtins_lib\".to_owned(), Feature {\n+        level: Status::Unstable,\n+        since: None,\n+        has_gate_test: false,\n+        tracking_issue: None,\n+    });\n \n     // Library features\n     let unstable_lib_feature_names = collect_unstable_feature_names(&lib_features);"}]}