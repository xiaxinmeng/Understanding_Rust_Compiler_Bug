{"sha": "c00bda539d79e4411e086d505c697662942ee00b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwMGJkYTUzOWQ3OWU0NDExZTA4NmQ1MDVjNjk3NjYyOTQyZWUwMGI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-11-03T23:43:12Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-11-20T01:50:45Z"}, "message": "rustc: First stab at a typechecker", "tree": {"sha": "ac121a5bf1275b57770add6e443434fa13eb6915", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac121a5bf1275b57770add6e443434fa13eb6915"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c00bda539d79e4411e086d505c697662942ee00b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c00bda539d79e4411e086d505c697662942ee00b", "html_url": "https://github.com/rust-lang/rust/commit/c00bda539d79e4411e086d505c697662942ee00b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c00bda539d79e4411e086d505c697662942ee00b/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c410d685294e73a944f3e7cfe403f415a0cff849", "url": "https://api.github.com/repos/rust-lang/rust/commits/c410d685294e73a944f3e7cfe403f415a0cff849", "html_url": "https://github.com/rust-lang/rust/commit/c410d685294e73a944f3e7cfe403f415a0cff849"}], "stats": {"total": 961, "additions": 912, "deletions": 49}, "files": [{"sha": "baf00780da9d2e60b090aa4653be9787c9b2aaa4", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c00bda539d79e4411e086d505c697662942ee00b/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c00bda539d79e4411e086d505c697662942ee00b/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=c00bda539d79e4411e086d505c697662942ee00b", "patch": "@@ -4,6 +4,7 @@ import front.parser;\n import front.token;\n import middle.trans;\n import middle.resolve;\n+import middle.typeck;\n \n import std.option;\n import std.option.some;\n@@ -15,6 +16,7 @@ impure fn compile_input(session.session sess, str input, str output) {\n           auto p = parser.new_parser(sess, 0, input);\n           auto crate = parser.parse_crate(p);\n           crate = resolve.resolve_crate(sess, crate);\n+          crate = typeck.check_crate(sess, crate);\n           trans.trans_crate(sess, crate, output);\n }\n "}, {"sha": "3a67d2f273c0afdf8c1ad0e8e252929e16c66393", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c00bda539d79e4411e086d505c697662942ee00b/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c00bda539d79e4411e086d505c697662942ee00b/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=c00bda539d79e4411e086d505c697662942ee00b", "patch": "@@ -1,6 +1,7 @@\n \n import std.map.hashmap;\n import std.option;\n+import middle.typeck;\n import util.common.span;\n import util.common.spanned;\n \n@@ -17,7 +18,7 @@ type def_id = tup(crate_num, def_num);\n // Annotations added during successive passes.\n tag ann {\n     ann_none;\n-    ann_type(@ty);\n+    ann_type(@typeck.ty);\n }\n \n tag def {\n@@ -119,6 +120,8 @@ tag lit_ {\n     lit_bool(bool);\n }\n \n+// NB: If you change this, you'll probably want to change the corresponding\n+// type structure in middle/typeck.rs as well.\n type ty = spanned[ty_];\n tag ty_ {\n     ty_nil;"}, {"sha": "d2199faed217c14234ac88d5beb20d1a76a939f5", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/c00bda539d79e4411e086d505c697662942ee00b/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c00bda539d79e4411e086d505c697662942ee00b/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=c00bda539d79e4411e086d505c697662942ee00b", "patch": "@@ -9,6 +9,7 @@ import std.option.none;\n \n import front.ast;\n import driver.session;\n+import middle.typeck;\n import back.x86;\n import back.abi;\n \n@@ -237,13 +238,13 @@ fn T_taskptr() -> TypeRef {\n     ret T_ptr(T_task());\n }\n \n-fn type_of(@trans_ctxt cx, @ast.ty t) -> TypeRef {\n-    alt (t.node) {\n-        case (ast.ty_nil) { ret T_nil(); }\n-        case (ast.ty_bool) { ret T_bool(); }\n-        case (ast.ty_int) { ret T_int(); }\n-        case (ast.ty_uint) { ret T_int(); }\n-        case (ast.ty_machine(?tm)) {\n+fn type_of(@trans_ctxt cx, @typeck.ty t) -> TypeRef {\n+    alt (t.struct) {\n+        case (typeck.ty_nil) { ret T_nil(); }\n+        case (typeck.ty_bool) { ret T_bool(); }\n+        case (typeck.ty_int) { ret T_int(); }\n+        case (typeck.ty_uint) { ret T_int(); }\n+        case (typeck.ty_machine(?tm)) {\n             alt (tm) {\n                 case (common.ty_i8) { ret T_i8(); }\n                 case (common.ty_u8) { ret T_i8(); }\n@@ -257,24 +258,25 @@ fn type_of(@trans_ctxt cx, @ast.ty t) -> TypeRef {\n                 case (common.ty_f64) { ret T_f64(); }\n             }\n         }\n-        case (ast.ty_char) { ret T_char(); }\n-        case (ast.ty_str) { ret T_str(0u); }\n-        case (ast.ty_box(?t)) {\n+        case (typeck.ty_char) { ret T_char(); }\n+        case (typeck.ty_str) { ret T_str(0u); }\n+        case (typeck.ty_box(?t)) {\n             ret T_ptr(T_box(type_of(cx, t)));\n         }\n-        case (ast.ty_vec(?t)) {\n+        case (typeck.ty_vec(?t)) {\n             ret T_ptr(T_vec(type_of(cx, t), 0u));\n         }\n-        case (ast.ty_tup(?elts)) {\n+        case (typeck.ty_tup(?elts)) {\n             let vec[TypeRef] tys = vec();\n-            for (tup(bool, @ast.ty) elt in elts) {\n+            for (tup(bool, @typeck.ty) elt in elts) {\n                 tys += type_of(cx, elt._1);\n             }\n             ret T_struct(tys);\n         }\n-        case (ast.ty_path(?pth,  ?def)) {\n+        case (typeck.ty_var(_)) {\n             // FIXME: implement.\n-            cx.sess.unimpl(\"ty_path in trans.type_of\");\n+            log \"ty_var in trans.type_of\";\n+            ret T_i8();\n         }\n     }\n     fail;\n@@ -340,27 +342,23 @@ fn C_tydesc(TypeRef t) -> ValueRef {\n                      C_null(T_opaque())));      // is_stateful\n }\n \n-fn decl_fn(ModuleRef llmod, str name,\n-           uint cc, vec[TypeRef] inputs, TypeRef output) -> ValueRef {\n-    let TypeRef llty = T_fn(inputs, output);\n+fn decl_fn(ModuleRef llmod, str name, uint cc, TypeRef llty) -> ValueRef {\n     let ValueRef llfn =\n         llvm.LLVMAddFunction(llmod, _str.buf(name), llty);\n     llvm.LLVMSetFunctionCallConv(llfn, cc);\n     ret llfn;\n }\n \n-fn decl_cdecl_fn(ModuleRef llmod, str name,\n-                 vec[TypeRef] inputs, TypeRef output) -> ValueRef {\n-    ret decl_fn(llmod, name, lib.llvm.LLVMCCallConv, inputs, output);\n+fn decl_cdecl_fn(ModuleRef llmod, str name, TypeRef llty) -> ValueRef {\n+    ret decl_fn(llmod, name, lib.llvm.LLVMCCallConv, llty);\n }\n \n-fn decl_fastcall_fn(ModuleRef llmod, str name,\n-                    vec[TypeRef] inputs, TypeRef output) -> ValueRef {\n-    ret decl_fn(llmod, name, lib.llvm.LLVMFastCallConv, inputs, output);\n+fn decl_fastcall_fn(ModuleRef llmod, str name, TypeRef llty) -> ValueRef {\n+    ret decl_fn(llmod, name, lib.llvm.LLVMFastCallConv, llty);\n }\n \n fn decl_glue(ModuleRef llmod, str s) -> ValueRef {\n-    ret decl_cdecl_fn(llmod, s, vec(T_taskptr()), T_void());\n+    ret decl_cdecl_fn(llmod, s, T_fn(vec(T_taskptr()), T_void()));\n }\n \n fn decl_upcall(ModuleRef llmod, uint _n) -> ValueRef {\n@@ -375,7 +373,7 @@ fn decl_upcall(ModuleRef llmod, uint _n) -> ValueRef {\n             T_int())     // callee\n         + _vec.init_elt[TypeRef](T_int(), n as uint);\n \n-    ret decl_fastcall_fn(llmod, s, args, T_int());\n+    ret decl_fastcall_fn(llmod, s, T_fn(args, T_int()));\n }\n \n fn get_upcall(@trans_ctxt cx, str name, int n_args) -> ValueRef {\n@@ -385,7 +383,7 @@ fn get_upcall(@trans_ctxt cx, str name, int n_args) -> ValueRef {\n     auto inputs = vec(T_taskptr());\n     inputs += _vec.init_elt[TypeRef](T_int(), n_args as uint);\n     auto output = T_int();\n-    auto f = decl_cdecl_fn(cx.llmod, name, inputs, output);\n+    auto f = decl_cdecl_fn(cx.llmod, name, T_fn(inputs, output));\n     cx.upcalls.insert(name, f);\n     ret f;\n }\n@@ -937,6 +935,7 @@ impure fn trans_expr(@block_ctxt cx, &ast.expr e) -> result {\n         case (ast.expr_call(?f, ?args, _)) {\n             auto f_res = trans_lval(cx, *f);\n             check (! f_res._1);\n+\n             auto args_res = trans_exprs(f_res._0.bcx, args);\n             auto llargs = vec(cx.fcx.lltaskptr);\n             llargs += args_res._1;\n@@ -1141,15 +1140,7 @@ impure fn trans_block(@block_ctxt cx, &ast.block b) -> result {\n     auto bcx = cx;\n \n     for each (@ast.local local in block_locals(b)) {\n-        auto ty = T_nil();\n-        alt (local.ty) {\n-            case (some[@ast.ty](?t)) {\n-                ty = type_of(cx.fcx.tcx, t);\n-            }\n-            case (none[@ast.ty]) {\n-                cx.fcx.tcx.sess.err(\"missing type for local \" + local.ident);\n-            }\n-        }\n+        auto ty = node_type(cx.fcx.tcx, local.ann);\n         auto val = bcx.build.Alloca(ty);\n         cx.fcx.lllocals.insert(local.id, val);\n     }\n@@ -1236,15 +1227,24 @@ impure fn trans_mod(@trans_ctxt cx, &ast._mod m) {\n \n fn collect_item(&@trans_ctxt cx, @ast.item i) -> @trans_ctxt {\n     alt (i.node) {\n-        case (ast.item_fn(?name, ?f, ?fid, _)) {\n-            cx.items.insert(fid, i);\n-            let TypeRef out = type_of(cx, f.output);\n-            auto args = vec(T_taskptr());\n-            for (ast.arg arg in f.inputs) {\n-                args += type_of(cx, arg.ty);\n+        case (ast.item_fn(?name, ?f, ?fid, ?ann)) {\n+            auto fn_inputs;\n+            auto fn_output;\n+            alt (typeck.ann_to_type(ann).struct) {\n+                case (typeck.ty_fn(?ins, ?out)) {\n+                    fn_inputs = ins;\n+                    fn_output = out;\n+                }\n+                case (_) {\n+                    log \"trans: fn item doesn't have function type!\";\n+                    fail;\n+                }\n             }\n+\n+            cx.items.insert(fid, i);\n+            auto llty = node_type(cx, ann);\n             let str s = cx.names.next(\"_rust_fn\") + \".\" + name;\n-            let ValueRef llfn = decl_fastcall_fn(cx.llmod, s, args, out);\n+            let ValueRef llfn = decl_fastcall_fn(cx.llmod, s, llty);\n             cx.fn_ids.insert(fid, llfn);\n         }\n \n@@ -1338,10 +1338,10 @@ fn trans_main_fn(@trans_ctxt cx, ValueRef llcrate) {\n     }\n \n     auto llmain =\n-        decl_cdecl_fn(cx.llmod, main_name, T_main_args, T_int());\n+        decl_cdecl_fn(cx.llmod, main_name, T_fn(T_main_args, T_int()));\n \n-    auto llrust_start =\n-        decl_cdecl_fn(cx.llmod, \"rust_start\", T_rust_start_args, T_int());\n+    auto llrust_start = decl_cdecl_fn(cx.llmod, \"rust_start\",\n+                                      T_fn(T_rust_start_args, T_int()));\n \n     auto llargc = llvm.LLVMGetParam(llmain, 0u);\n     auto llargv = llvm.LLVMGetParam(llmain, 1u);\n@@ -1367,7 +1367,7 @@ fn trans_main_fn(@trans_ctxt cx, ValueRef llcrate) {\n \n fn declare_intrinsics(ModuleRef llmod) {\n     let vec[TypeRef] T_trap_args = vec();\n-    decl_cdecl_fn(llmod, \"llvm.trap\", T_trap_args, T_void());\n+    decl_cdecl_fn(llmod, \"llvm.trap\", T_fn(T_trap_args, T_void()));\n }\n \n fn trans_crate(session.session sess, @ast.crate crate, str output) {\n@@ -1396,7 +1396,7 @@ fn trans_crate(session.session sess, @ast.crate crate, str output) {\n                        */\n                       exit_task_glue =\n                       decl_cdecl_fn(llmod, abi.exit_task_glue_name(),\n-                                    vec(T_taskptr()), T_void()),\n+                                    T_fn(vec(T_taskptr()), T_void())),\n \n                       upcall_glues =\n                       _vec.init_fn[ValueRef](bind decl_upcall(llmod, _),"}, {"sha": "8ef75ffa003f42c792e44f20396f331404a213e9", "filename": "src/comp/middle/typeck.rs", "status": "added", "additions": 857, "deletions": 0, "changes": 857, "blob_url": "https://github.com/rust-lang/rust/blob/c00bda539d79e4411e086d505c697662942ee00b/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c00bda539d79e4411e086d505c697662942ee00b/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=c00bda539d79e4411e086d505c697662942ee00b", "patch": "@@ -0,0 +1,857 @@\n+//\n+// comp/middle/typeck.rs\n+//\n+\n+import front.ast;\n+import front.ast.ann;\n+import middle.fold;\n+import driver.session;\n+import util.common;\n+import util.common.span;\n+\n+import std._str;\n+import std._uint;\n+import std._vec;\n+import std.map;\n+import std.map.hashmap;\n+import std.option;\n+import std.option.none;\n+import std.option.some;\n+\n+type ty_table = hashmap[ast.def_id, @ty];\n+type env = rec(session.session sess,\n+               @ty_table item_types,\n+               mutable int next_var_id);\n+\n+type arg = rec(ast.mode mode, @ty ty);\n+\n+// NB: If you change this, you'll probably want to change the corresponding\n+// AST structure in front/ast.rs as well.\n+type ty = rec(sty struct, option.t[str] cname);\n+tag sty {\n+    ty_nil;\n+    ty_bool;\n+    ty_int;\n+    ty_uint;\n+    ty_machine(util.common.ty_mach);\n+    ty_char;\n+    ty_str;\n+    ty_box(@ty);\n+    ty_vec(@ty);\n+    ty_tup(vec[tup(bool /* mutability */, @ty)]);\n+    ty_fn(vec[arg], @ty);                           // TODO: effect\n+    ty_var(int);\n+}\n+\n+tag type_err {\n+    terr_mismatch;\n+    terr_tuple_size(uint, uint);\n+    terr_tuple_mutability;\n+    terr_arg_count;\n+}\n+\n+tag unify_result {\n+    ures_ok(@ty);\n+    ures_err(type_err, @ty, @ty);\n+}\n+\n+// Used for ast_ty_to_ty() below.\n+type ty_getter = fn(ast.def_id) -> @ty;\n+\n+// Error-reporting utility functions\n+\n+fn ast_ty_to_str(&@ast.ty ty) -> str {\n+    fn ast_tup_elem_to_str(&tup(bool, @ast.ty) elem) -> str {\n+        auto s;\n+        if (elem._0) {\n+            s = \"mutable \";\n+        } else {\n+            s = \"\";\n+        }\n+\n+        ret s + ast_ty_to_str(elem._1);\n+    }\n+\n+    fn ast_fn_input_to_str(&rec(ast.mode mode, @ast.ty ty) input) -> str {\n+        auto s;\n+        if (mode_is_alias(input.mode)) {\n+            s = \"&\";\n+        } else {\n+            s = \"\";\n+        }\n+\n+        ret s + ast_ty_to_str(input.ty);\n+    }\n+\n+    auto s;\n+    alt (ty.node) {\n+        case (ast.ty_nil)          { s = \"()\";                            }\n+        case (ast.ty_bool)         { s = \"bool\";                          }\n+        case (ast.ty_int)          { s = \"int\";                           }\n+        case (ast.ty_uint)         { s = \"uint\";                          }\n+        case (ast.ty_machine(?tm)) { s = common.ty_mach_to_str(tm);       }\n+        case (ast.ty_char)         { s = \"char\";                          }\n+        case (ast.ty_str)          { s = \"str\";                           }\n+        case (ast.ty_box(?t))      { s = \"@\" + ast_ty_to_str(t);          }\n+        case (ast.ty_vec(?t))      { s = \"vec[\" + ast_ty_to_str(t) + \"]\"; }\n+\n+        case (ast.ty_tup(?elems)) {\n+            auto f = ast_tup_elem_to_str;\n+            s = \"tup(\";\n+            s += _str.connect(_vec.map[tup(bool,@ast.ty),str](f, elems), \",\");\n+            s += \")\";\n+        }\n+\n+        case (ast.ty_fn(?inputs, ?output)) {\n+            auto f = ast_fn_input_to_str;\n+            s = \"fn(\";\n+            auto is = _vec.map[rec(ast.mode mode, @ast.ty ty),str](f, inputs);\n+            s += _str.connect(is, \", \");\n+            s += \")\";\n+\n+            if (output.node != ast.ty_nil) {\n+                s += \" -> \" + ast_ty_to_str(output);\n+            }\n+        }\n+\n+        case (ast.ty_path(?path, _)) {\n+            s = path_to_str(path);\n+        }\n+\n+        case (_) {\n+            fail;   // FIXME: typestate bug\n+        }\n+    }\n+\n+    ret s;\n+}\n+\n+fn name_to_str(&ast.name nm) -> str {\n+    auto result = nm.node.ident;\n+    if (_vec.len[@ast.ty](nm.node.types) > 0u) {\n+        auto f = ast_ty_to_str;\n+        result += \"[\";\n+        result += _str.connect(_vec.map[@ast.ty,str](f, nm.node.types), \",\");\n+        result += \"]\";\n+    }\n+    ret result;\n+}\n+\n+fn path_to_str(&ast.path path) -> str {\n+    auto f = name_to_str;\n+    ret _str.connect(_vec.map[ast.name,str](f, path), \".\");\n+}\n+\n+fn ty_to_str(@ty typ) -> str {\n+    fn tup_elem_to_str(&tup(bool, @ty) elem) -> str {\n+        auto s;\n+        if (elem._0) {\n+            s = \"mutable \";\n+        } else {\n+            s = \"\";\n+        }\n+\n+        ret s + ty_to_str(elem._1);\n+    }\n+\n+    fn fn_input_to_str(&rec(ast.mode mode, @ty ty) input) -> str {\n+        auto s;\n+        if (mode_is_alias(input.mode)) {\n+            s = \"&\";\n+        } else {\n+            s = \"\";\n+        }\n+\n+        ret s + ty_to_str(input.ty);\n+    }\n+\n+    auto s;\n+    alt (typ.struct) {\n+        case (ty_nil)          { s = \"()\";                        }\n+        case (ty_bool)         { s = \"bool\";                      }\n+        case (ty_int)          { s = \"int\";                       }\n+        case (ty_uint)         { s = \"uint\";                      }\n+        case (ty_machine(?tm)) { s = common.ty_mach_to_str(tm);   }\n+        case (ty_char)         { s = \"char\";                      }\n+        case (ty_str)          { s = \"str\";                       }\n+        case (ty_box(?t))      { s = \"@\" + ty_to_str(t);          }\n+        case (ty_vec(?t))      { s = \"vec[\" + ty_to_str(t) + \"]\"; }\n+\n+        case (ty_tup(?elems)) {\n+            auto f = tup_elem_to_str;\n+            auto strs = _vec.map[tup(bool,@ty),str](f, elems);\n+            s = \"tup(\" + _str.connect(strs, \",\") + \")\";\n+        }\n+\n+        case (ty_fn(?inputs, ?output)) {\n+            auto f = fn_input_to_str;\n+            s = \"fn(\" + _str.connect(_vec.map[arg,str](f, inputs), \", \") + \")\";\n+            if (output.struct != ty_nil) {\n+                s += \" -> \" + ty_to_str(output);\n+            }\n+        }\n+\n+        case (ty_var(?v)) {\n+            // FIXME: wrap around in the case of many variables\n+            auto ch = ('T' as u8) + (v as u8);\n+            s = _str.from_bytes(vec(ch));\n+        }\n+    }\n+\n+    ret s;\n+}\n+\n+// Parses the programmer's textual representation of a type into our internal\n+// notion of a type. `getter` is a function that returns the type\n+// corresponding to a definition ID.\n+fn ast_ty_to_ty(ty_getter getter, &@ast.ty ast_ty) -> @ty {\n+    fn ast_arg_to_arg(ty_getter getter, &rec(ast.mode mode, @ast.ty ty) arg)\n+            -> rec(ast.mode mode, @ty ty) {\n+        ret rec(mode=arg.mode, ty=ast_ty_to_ty(getter, arg.ty));\n+    }\n+\n+    auto sty;\n+    auto cname = none[str];\n+    alt (ast_ty.node) {\n+        case (ast.ty_nil)          { sty = ty_nil; }\n+        case (ast.ty_bool)         { sty = ty_bool; }\n+        case (ast.ty_int)          { sty = ty_int; }\n+        case (ast.ty_uint)         { sty = ty_uint; }\n+        case (ast.ty_machine(?tm)) { sty = ty_machine(tm); }\n+        case (ast.ty_char)         { sty = ty_char; }\n+        case (ast.ty_str)          { sty = ty_str; }\n+        case (ast.ty_box(?t))      { sty = ty_box(ast_ty_to_ty(getter, t)); }\n+        case (ast.ty_vec(?t))      { sty = ty_vec(ast_ty_to_ty(getter, t)); }\n+\n+        case (ast.ty_fn(?inputs, ?output)) {\n+            auto f = bind ast_arg_to_arg(getter, _);\n+            auto i = _vec.map[rec(ast.mode mode, @ast.ty ty),arg](f, inputs);\n+            sty = ty_fn(i, ast_ty_to_ty(getter, output));\n+        }\n+\n+        case (ast.ty_path(?path, ?def)) {\n+            auto def_id;\n+            alt (option.get[ast.def](def)) {\n+                case (ast.def_ty(?id)) { def_id = id; }\n+                case (_) { fail; }\n+            }\n+\n+            // TODO: maybe record cname chains so we can do \"foo = int\" like\n+            // OCaml?\n+            sty = getter(def_id).struct;\n+            cname = some(path_to_str(path));\n+        }\n+    }\n+\n+    ret @rec(struct=sty, cname=cname);\n+}\n+\n+// A convenience function to use an environment to resolve names for\n+// ast_ty_to_ty.\n+fn ast_ty_to_ty_env(@env e, &@ast.ty ast_ty) -> @ty {\n+    fn getter(@env e, ast.def_id id) -> @ty {\n+        ret e.item_types.get(id);\n+    }\n+    auto f = bind getter(e, _);\n+    ret ast_ty_to_ty(f, ast_ty);\n+}\n+\n+fn type_err_to_str(&type_err err) -> str {\n+    alt (err) {\n+        case (terr_mismatch) {\n+            ret \"types differ\";\n+        }\n+        case (terr_tuple_size(?e_sz, ?a_sz)) {\n+            ret \"expected a tuple with \" + _uint.to_str(e_sz, 10u) +\n+                \" elements but found one with \" + _uint.to_str(a_sz, 10u) +\n+                \" elements\";\n+        }\n+        case (terr_tuple_mutability) {\n+            ret \"tuple elements differ in mutability\";\n+        }\n+        case (terr_arg_count) {\n+            ret \"incorrect number of function parameters\";\n+        }\n+    }\n+}\n+\n+// Item collection - a pair of bootstrap passes:\n+//\n+// 1. Collect the IDs of all type items (typedefs) and store them in a table.\n+//\n+// 2. Translate the AST fragments that describe types to determine a type for\n+//    each item. When we encounter a named type, we consult the table built in\n+//    pass 1 to find its item, and recursively translate it.\n+//\n+// We then annotate the AST with the resulting types and return the annotated\n+// AST, along with a table mapping item IDs to their types.\n+\n+fn collect_item_types(@ast.crate crate) -> tup(@ast.crate, @ty_table) {\n+    fn trans_ty_item_id_to_ty(@hashmap[ast.def_id,@ast.item] id_to_ty_item,\n+                              @ty_table item_to_ty,\n+                              ast.def_id id) -> @ty {\n+        auto item = id_to_ty_item.get(id);\n+        ret trans_ty_item_to_ty(id_to_ty_item, item_to_ty, item);\n+    }\n+\n+    fn trans_fn_arg_to_ty(@hashmap[ast.def_id,@ast.item] id_to_ty_item,\n+                          @ty_table item_to_ty,\n+                          &ast.arg a) -> arg {\n+        auto f = bind trans_ty_item_id_to_ty(id_to_ty_item, item_to_ty, _);\n+        ret rec(mode=a.mode, ty=ast_ty_to_ty(f, a.ty));\n+    }\n+\n+    fn trans_ty_item_to_ty(@hashmap[ast.def_id,@ast.item] id_to_ty_item,\n+                           @ty_table item_to_ty,\n+                           @ast.item it) -> @ty {\n+        alt (it.node) {\n+            case (ast.item_fn(?ident, ?fn_info, ?def_id, _)) {\n+                auto f = bind trans_fn_arg_to_ty(id_to_ty_item, item_to_ty,\n+                                                 _);\n+                auto input_tys = _vec.map[ast.arg,arg](f, fn_info.inputs);\n+\n+                auto g = bind trans_ty_item_id_to_ty(id_to_ty_item,\n+                                                     item_to_ty, _);\n+                auto output_ty = ast_ty_to_ty(g, fn_info.output);\n+\n+                auto t_fn = plain_ty(ty_fn(input_tys, output_ty));\n+                item_to_ty.insert(def_id, t_fn);\n+                ret t_fn;\n+            }\n+\n+            case (ast.item_ty(?ident, ?referent_ty, ?def_id, _)) {\n+                if (item_to_ty.contains_key(def_id)) {\n+                    // Avoid repeating work.\n+                    ret item_to_ty.get(def_id);\n+                }\n+\n+                // Tell ast_ty_to_ty() that we want to perform a recursive\n+                // call to resolve any named types.\n+                auto f = bind trans_ty_item_id_to_ty(id_to_ty_item,\n+                                                     item_to_ty, _);\n+                auto ty = ast_ty_to_ty(f, referent_ty);\n+                item_to_ty.insert(def_id, ty);\n+                ret ty;\n+            }\n+\n+            case (ast.item_mod(_, _, _)) { fail; }\n+        }\n+    }\n+\n+    // First pass: collect all type item IDs.\n+    auto module = crate.node.module;\n+    auto id_to_ty_item = @common.new_def_hash[@ast.item]();\n+    for (@ast.item item in module.items) {\n+        alt (item.node) {\n+            case (ast.item_ty(_, _, ?def_id, _)) {\n+                id_to_ty_item.insert(def_id, item);\n+            }\n+            case (_) { /* empty */ }\n+        }\n+    }\n+\n+    // Second pass: translate the types of all items.\n+    auto item_to_ty = @common.new_def_hash[@ty]();\n+    let vec[@ast.item] items_t = vec();\n+    for (@ast.item it in module.items) {\n+        let ast.item_ result;\n+        alt (it.node) {\n+            case (ast.item_fn(?ident, ?fn_info, ?def_id, _)) {\n+                auto t = trans_ty_item_to_ty(id_to_ty_item, item_to_ty, it);\n+                result = ast.item_fn(ident, fn_info, def_id, ast.ann_type(t));\n+            }\n+            case (ast.item_ty(?ident, ?referent_ty, ?def_id, _)) {\n+                auto t = trans_ty_item_to_ty(id_to_ty_item, item_to_ty, it);\n+                auto ann = ast.ann_type(t);\n+                result = ast.item_ty(ident, referent_ty, def_id, ann);\n+            }\n+            case (ast.item_mod(_, _, _)) {\n+                result = it.node;\n+            }\n+        }\n+        items_t += vec(@fold.respan[ast.item_](it.span, result));\n+    }\n+\n+    auto module_t = rec(items=items_t, index=module.index);\n+    ret tup(@fold.respan[ast.crate_](crate.span, rec(module=module_t)),\n+            item_to_ty);\n+}\n+\n+// Type utilities\n+\n+// FIXME: remove me when == works on these tags.\n+fn mode_is_alias(ast.mode m) -> bool {\n+    alt (m) {\n+        case (ast.val) { ret false; }\n+        case (ast.alias) { ret true; }\n+    }\n+}\n+\n+fn plain_ty(&sty st) -> @ty {\n+    ret @rec(struct=st, cname=none[str]);\n+}\n+\n+fn ann_to_type(&ast.ann ann) -> @ty {\n+    alt (ann) {\n+        case (ast.ann_none) {\n+            // shouldn't happen, but can until the typechecker is complete\n+            ret plain_ty(ty_var(0));    // FIXME: broken, broken, broken\n+        }\n+        case (ast.ann_type(?ty)) {\n+            ret ty;\n+        }\n+    }\n+}\n+\n+fn type_of(@ast.expr expr) -> @ty {\n+    alt (expr.node) {\n+        case (ast.expr_vec(_, ?ann))          { ret ann_to_type(ann); }\n+        case (ast.expr_tup(_, ?ann))          { ret ann_to_type(ann); }\n+        case (ast.expr_rec(_, ?ann))          { ret ann_to_type(ann); }\n+        case (ast.expr_call(_, _, ?ann))      { ret ann_to_type(ann); }\n+        case (ast.expr_binary(_, _, _, ?ann)) { ret ann_to_type(ann); }\n+        case (ast.expr_unary(_, _, ?ann))     { ret ann_to_type(ann); }\n+        case (ast.expr_lit(_, ?ann))          { ret ann_to_type(ann); }\n+        case (ast.expr_cast(_, _, ?ann))      { ret ann_to_type(ann); }\n+        case (ast.expr_if(_, _, _, ?ann))     { ret ann_to_type(ann); }\n+        case (ast.expr_while(_, _, ?ann))     { ret ann_to_type(ann); }\n+        case (ast.expr_do_while(_, _, ?ann))  { ret ann_to_type(ann); }\n+        case (ast.expr_block(_, ?ann))        { ret ann_to_type(ann); }\n+        case (ast.expr_assign(_, _, ?ann))    { ret ann_to_type(ann); }\n+        case (ast.expr_field(_, _, ?ann))     { ret ann_to_type(ann); }\n+        case (ast.expr_index(_, _, ?ann))     { ret ann_to_type(ann); }\n+        case (ast.expr_name(_, _, ?ann))      { ret ann_to_type(ann); }\n+    }\n+\n+    fail;\n+}\n+\n+// Type unification\n+\n+fn unify(@ty expected, @ty actual) -> unify_result {\n+    // Wraps the given type in an appropriate cname.\n+    //\n+    // TODO: This doesn't do anything yet. We should carry the cname up from\n+    // the expected and/or actual types when unification results in a type\n+    // identical to one or both of the two. The precise algorithm for this is\n+    // something we'll probably need to develop over time.\n+\n+    // Simple structural type comparison.\n+    fn struct_cmp(@ty expected, @ty actual) -> unify_result {\n+        if (expected == actual) {\n+            ret ures_ok(expected);\n+        }\n+\n+        ret ures_err(terr_mismatch, expected, actual);\n+    }\n+\n+    fn unify_step(@ty expected, @ty actual, &hashmap[int,@ty] bindings)\n+            -> unify_result {\n+        // TODO: rewrite this using tuple pattern matching when available, to\n+        // avoid all this rightward drift and spikiness.\n+        alt (expected.struct) {\n+            case (ty_nil)        { ret struct_cmp(expected, actual); }\n+            case (ty_bool)       { ret struct_cmp(expected, actual); }\n+            case (ty_int)        { ret struct_cmp(expected, actual); }\n+            case (ty_uint)       { ret struct_cmp(expected, actual); }\n+            case (ty_machine(_)) { ret struct_cmp(expected, actual); }\n+            case (ty_char)       { ret struct_cmp(expected, actual); }\n+            case (ty_str)        { ret struct_cmp(expected, actual); }\n+\n+            case (ty_box(?expected_sub)) {\n+                alt (actual.struct) {\n+                    case (ty_box(?actual_sub)) {\n+                        auto result = unify_step(expected_sub, actual_sub,\n+                                                 bindings);\n+                        alt (result) {\n+                            case (ures_ok(?result_sub)) {\n+                                ret ures_ok(plain_ty(ty_box(result_sub)));\n+                            } \n+                            case (_) {\n+                                ret result;\n+                            }\n+                        }\n+                    }\n+\n+                    // TODO: ty_var\n+\n+                    case (_) {\n+                        ret ures_err(terr_mismatch, expected, actual);\n+                    }\n+                }\n+            }\n+\n+            case (ty_vec(?expected_sub)) {\n+                alt (actual.struct) {\n+                    case (ty_vec(?actual_sub)) {\n+                        auto result = unify_step(expected_sub, actual_sub,\n+                                                 bindings);\n+                        alt (result) {\n+                            case (ures_ok(?result_sub)) {\n+                                ret ures_ok(plain_ty(ty_vec(result_sub)));\n+                            }\n+                            case (_) {\n+                                ret result;\n+                            }\n+                        }\n+                    }\n+\n+                    // TODO: ty_var\n+\n+                    case (_) {\n+                        ret ures_err(terr_mismatch, expected, actual);\n+                   }\n+                }\n+            }\n+\n+            case (ty_tup(?expected_elems)) {\n+                alt (actual.struct) {\n+                    case (ty_tup(?actual_elems)) {\n+                        auto expected_len =\n+                            _vec.len[tup(bool,@ty)](expected_elems);\n+                        auto actual_len =\n+                            _vec.len[tup(bool,@ty)](actual_elems);\n+                        if (expected_len != actual_len) {\n+                            auto err = terr_tuple_size(expected_len,\n+                                                       actual_len);\n+                            ret ures_err(err, expected, actual);\n+                        }\n+\n+                        // TODO: implement an iterator that can iterate over\n+                        // two arrays simultaneously.\n+                        let vec[tup(bool, @ty)] result_elems = vec();\n+                        auto i = 0u;\n+                        while (i < expected_len) {\n+                            auto expected_elem = expected_elems.(i);\n+                            auto actual_elem = actual_elems.(i);\n+                            if (expected_elem._0 != actual_elem._0) {\n+                                auto err = terr_tuple_mutability;\n+                                ret ures_err(err, expected, actual);\n+                            }\n+\n+                            auto result = unify_step(expected_elem._1,\n+                                                     actual_elem._1,\n+                                                     bindings);\n+                            alt (result) {\n+                                case (ures_ok(?rty)) {\n+                                    result_elems += vec(tup(expected_elem._0,\n+                                                            rty));\n+                                }\n+                                case (_) {\n+                                    ret result;\n+                                }\n+                            }\n+\n+                            i += 1u;\n+                        }\n+\n+                        ret ures_ok(plain_ty(ty_tup(result_elems)));\n+                    }\n+\n+                    // TODO: ty_var\n+\n+                    case (_) {\n+                        ret ures_err(terr_mismatch, expected, actual);\n+                    }\n+                }\n+            }\n+\n+            case (ty_fn(?expected_inputs, ?expected_output)) {\n+                alt (actual.struct) {\n+                    case (ty_fn(?actual_inputs, ?actual_output)) {\n+                        auto expected_len = _vec.len[arg](expected_inputs);\n+                        auto actual_len = _vec.len[arg](actual_inputs);\n+                        if (expected_len != actual_len) {\n+                            ret ures_err(terr_arg_count, expected, actual);\n+                        }\n+\n+                        // TODO: as above, we should have an iter2 iterator.\n+                        let vec[arg] result_ins = vec();\n+                        auto i = 0u;\n+                        while (i < expected_len) {\n+                            auto expected_input = expected_inputs.(i);\n+                            auto actual_input = actual_inputs.(i);\n+\n+                            // This should be safe, I think?\n+                            auto result_mode;\n+                            if (mode_is_alias(expected_input.mode) ||\n+                                    mode_is_alias(actual_input.mode)) {\n+                                result_mode = ast.alias;\n+                            } else {\n+                                result_mode = ast.val;\n+                            }\n+\n+                            auto result = unify_step(expected_input.ty,\n+                                                     actual_input.ty,\n+                                                     bindings);\n+\n+                            alt (result) {\n+                                case (ures_ok(?rty)) {\n+                                    result_ins += vec(rec(mode=result_mode,\n+                                                          ty=rty));\n+                                }\n+\n+                                case (_) {\n+                                    ret result;\n+                                }\n+                            }\n+\n+                            i += 1u;\n+                        }\n+\n+                        // Check the output.\n+                        auto result_out;\n+                        auto result = unify_step(expected_output,\n+                                                 actual_output, bindings);\n+                        alt (result) {\n+                            case (ures_ok(?rty)) {  \n+                                result_out = rty;\n+                            }\n+\n+                            case (_) {\n+                                ret result;\n+                            }\n+                        }\n+\n+                        ret ures_ok(plain_ty(ty_fn(result_ins, result_out)));\n+                    }\n+\n+                    case (_) {\n+                        ret ures_err(terr_mismatch, expected, actual);\n+                    }\n+                }\n+            }\n+\n+            case (ty_var(?expected_id)) {\n+                if (bindings.contains_key(expected_id)) {\n+                     auto binding = bindings.get(expected_id);\n+                     ret unify_step(binding, actual, bindings);\n+                }\n+\n+                bindings.insert(expected_id, actual);\n+                ret ures_ok(actual);\n+            }\n+        }\n+\n+        // TODO: remove me once match-exhaustiveness checking works\n+        fail;\n+    }\n+\n+    fn hash_int(&int x) -> uint { ret x as uint; }\n+    fn eq_int(&int a, &int b) -> bool { ret a == b; }\n+    auto hasher = hash_int;\n+    auto eqer = eq_int;\n+    auto bindings = map.mk_hashmap[int,@ty](hasher, eqer);\n+\n+    ret unify_step(expected, actual, bindings);\n+}\n+\n+// Requires that the two types unify, and prints an error message if they\n+// don't. Returns the unified type.\n+fn demand(&@env e, &span sp, @ty expected, @ty actual) -> @ty {\n+    alt (unify(expected, actual)) {\n+        case (ures_ok(?ty)) {\n+            ret ty;\n+        }\n+\n+        case (ures_err(?err, ?expected, ?actual)) {\n+            e.sess.err(\"mismatched types: expected \" + ty_to_str(expected) +\n+                       \" but found \" + ty_to_str(actual) + \" (\" +\n+                       type_err_to_str(err) + \")\");\n+\n+            // TODO: In the future, try returning \"expected\", reporting the\n+            // error, and continue.\n+            fail;\n+        }\n+    }\n+}\n+\n+// Unifies the supplied type with the type of the local `id`, and stores the\n+// unified type in the local table. Emits an error if the type is incompatible\n+// with the previously-stored type for this local.\n+fn demand_local(&@env e, &span sp, &@ty_table locals, ast.def_id local_id,\n+                @ty t) {\n+    auto prev_ty = locals.get(local_id);\n+    auto unified_ty = demand(e, sp, prev_ty, t);\n+    locals.insert(local_id, unified_ty);\n+}\n+\n+// Returns true if the two types unify and false if they don't.\n+fn are_compatible(@ty expected, @ty actual) -> bool {\n+    alt (unify(expected, actual)) {\n+        case (ures_ok(_))        { ret true;  }\n+        case (ures_err(_, _, _)) { ret false; }\n+    }\n+}\n+\n+// Writeback: the phase that writes inferred types back into the AST.\n+\n+fn writeback_local(&@ty_table locals, &span sp, @ast.local local)\n+        -> @ast.decl {\n+    auto local_wb = @rec(ann=ast.ann_type(locals.get(local.id)) with *local);\n+    ret @fold.respan[ast.decl_](sp, ast.decl_local(local_wb));\n+}\n+\n+fn writeback(&@env e, &@ty_table locals, &ast.block block) -> ast.block {\n+    auto fld = fold.new_identity_fold[@ty_table]();\n+    auto f = writeback_local;   // FIXME: trans_const_lval bug\n+    fld = @rec(fold_decl_local = f with *fld);\n+    ret fold.fold_block[@ty_table](locals, fld, block);\n+}\n+\n+// AST fragment checking\n+\n+fn check_lit(&@env e, @ast.lit lit) -> @ty {\n+    auto sty;\n+    alt (lit.node) {\n+        case (ast.lit_str(_))   { sty = ty_str;  }\n+        case (ast.lit_char(_))  { sty = ty_char; }\n+        case (ast.lit_int(_))   { sty = ty_int;  }\n+        case (ast.lit_uint(_))  { sty = ty_uint; }\n+        case (ast.lit_nil)      { sty = ty_nil;  }\n+        case (ast.lit_bool(_))  { sty = ty_bool; }\n+    }\n+\n+    ret plain_ty(sty);\n+}\n+\n+fn check_expr(&@env e, &@ty_table locals, @ast.expr expr) -> @ast.expr {\n+    alt (expr.node) {\n+        case (ast.expr_lit(?lit, _)) {\n+            auto ty = check_lit(e, lit);\n+            ret @fold.respan[ast.expr_](expr.span,\n+                                        ast.expr_lit(lit, ast.ann_type(ty)));\n+        }\n+        \n+        case (_) {\n+            // TODO\n+            ret expr;\n+        }\n+    }\n+}\n+\n+fn check_stmt(@env e, @ty_table locals, @ty ret_ty, &@ast.stmt stmt)\n+        -> @ast.stmt {\n+    alt (stmt.node) {\n+        case (ast.stmt_decl(?decl)) {\n+            alt (decl.node) {\n+                case (ast.decl_local(?local)) {\n+                    alt (local.init) {\n+                        case (none[@ast.expr]) {\n+                            // empty\n+                        }\n+\n+                        case (some[@ast.expr](?expr)) {\n+                            auto expr_t = check_expr(e, locals, expr);\n+                            locals.insert(local.id, type_of(expr_t));\n+\n+                            alt (local.ty) {\n+                                case (none[@ast.ty]) {\n+                                    // Nothing to do. We'll figure out the\n+                                    // type later.\n+                                }\n+\n+                                case (some[@ast.ty](?ast_ty)) {\n+                                    auto ty = ast_ty_to_ty_env(e, ast_ty);\n+                                    demand_local(e, decl.span, locals,\n+                                                 local.id, ty);\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                case (ast.decl_item(_)) {\n+                    // Ignore for now. We'll return later.\n+                }\n+            }\n+\n+            ret stmt;\n+        }\n+\n+        case (ast.stmt_ret(?expr_opt)) {\n+            alt (expr_opt) {\n+                case (none[@ast.expr]) {\n+                    if (!are_compatible(ret_ty, plain_ty(ty_nil))) {\n+                        e.sess.err(\"ret; in function returning non-void\");\n+                    }\n+\n+                    ret stmt;\n+                }\n+\n+                case (some[@ast.expr](?expr)) {\n+                    auto expr_t = check_expr(e, locals, expr);\n+                    demand(e, expr.span, ret_ty, type_of(expr_t));\n+                    ret @fold.respan[ast.stmt_](stmt.span,\n+                                                ast.stmt_ret(some(expr_t)));\n+                }\n+            }\n+        }\n+\n+        case (ast.stmt_log(?expr)) {\n+            auto expr_t = check_expr(e, locals, expr);\n+            ret @fold.respan[ast.stmt_](stmt.span, ast.stmt_log(expr_t));\n+        }\n+\n+        case (ast.stmt_check_expr(?expr)) {\n+            auto expr_t = check_expr(e, locals, expr);\n+            demand(e, expr.span, plain_ty(ty_bool), type_of(expr_t));\n+            ret @fold.respan[ast.stmt_](stmt.span,\n+                                        ast.stmt_check_expr(expr_t));\n+        }\n+\n+        case (ast.stmt_expr(?expr)) {\n+            auto expr_t = check_expr(e, locals, expr);\n+            if (!are_compatible(type_of(expr_t), plain_ty(ty_nil))) {\n+                // TODO: real warning function\n+                log \"warning: expression used as statement should have \" +\n+                    \"void type\";\n+            }\n+\n+            ret @fold.respan[ast.stmt_](stmt.span, ast.stmt_expr(expr_t));\n+        }\n+    }\n+\n+    fail;\n+}\n+\n+fn check_block(&@env e, &@ty_table locals, @ty ret_ty, &ast.block block)\n+        -> ast.block {\n+    auto f = bind check_stmt(e, locals, ret_ty, _);\n+    auto stmts_t = _vec.map[@ast.stmt,@ast.stmt](f, block.node.stmts);\n+    ret fold.respan[ast.block_](block.span,\n+                                rec(stmts=stmts_t, index=block.node.index));\n+}\n+\n+fn check_fn(&@env e, &span sp, ast.ident ident, &ast._fn f, ast.def_id id,\n+            ast.ann ann) -> @ast.item {\n+    auto local_ty_table = @common.new_def_hash[@ty]();\n+\n+    // Store the type of each argument in the table.\n+    let vec[arg] inputs = vec();\n+    for (ast.arg arg in f.inputs) {\n+        auto input_ty = ast_ty_to_ty_env(e, arg.ty);\n+        inputs += vec(rec(mode=arg.mode, ty=input_ty));\n+        local_ty_table.insert(arg.id, input_ty);\n+    }\n+\n+    auto output_ty = ast_ty_to_ty_env(e, f.output);\n+    auto fn_sty = ty_fn(inputs, output_ty);\n+    auto fn_ann = ast.ann_type(plain_ty(fn_sty));\n+\n+    auto block_t = check_block(e, local_ty_table, output_ty, f.body);\n+    auto block_wb = writeback(e, local_ty_table, block_t);\n+    auto fn_t = rec(inputs=f.inputs, output=f.output, body=block_wb);\n+    ret @fold.respan[ast.item_](sp, ast.item_fn(ident, fn_t, id, fn_ann));\n+}\n+\n+fn check_crate(session.session sess, @ast.crate crate) -> @ast.crate {\n+    auto result = collect_item_types(crate);\n+    auto e = @rec(sess=sess, item_types=result._1, mutable next_var_id=0);\n+\n+    auto fld = fold.new_identity_fold[@env]();\n+    auto f = check_fn;  // FIXME: trans_const_lval bug\n+    fld = @rec(fold_item_fn = f with *fld);\n+    ret fold.fold_crate[@env](e, fld, result._0);\n+}\n+"}, {"sha": "ef9be0535852c8b0e86f5667130c79ec374c5e72", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c00bda539d79e4411e086d505c697662942ee00b/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/c00bda539d79e4411e086d505c697662942ee00b/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=c00bda539d79e4411e086d505c697662942ee00b", "patch": "@@ -14,6 +14,7 @@ mod middle {\n     mod fold;\n     mod resolve;\n     mod trans;\n+    mod typeck;\n }\n \n mod back {"}]}