{"sha": "9fdec67a6761ae43d8fae80e10b5a7a1e0ca7c0d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmZGVjNjdhNjc2MWFlNDNkOGZhZTgwZTEwYjVhN2ExZTBjYTdjMGQ=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-07-11T00:33:11Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-07-23T23:56:22Z"}, "message": "std: move str::as_buf into StrSlice", "tree": {"sha": "de36b46760ab668828e9262d0816b994ba929fe1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de36b46760ab668828e9262d0816b994ba929fe1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9fdec67a6761ae43d8fae80e10b5a7a1e0ca7c0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9fdec67a6761ae43d8fae80e10b5a7a1e0ca7c0d", "html_url": "https://github.com/rust-lang/rust/commit/9fdec67a6761ae43d8fae80e10b5a7a1e0ca7c0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9fdec67a6761ae43d8fae80e10b5a7a1e0ca7c0d/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cfd89c407598673bf55ea11525b1398c53cd3725", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfd89c407598673bf55ea11525b1398c53cd3725", "html_url": "https://github.com/rust-lang/rust/commit/cfd89c407598673bf55ea11525b1398c53cd3725"}], "stats": {"total": 124, "additions": 62, "deletions": 62}, "files": [{"sha": "9fe590e28eef2a9adb0102c35b655fb24a4fef2b", "filename": "src/libstd/option.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9fdec67a6761ae43d8fae80e10b5a7a1e0ca7c0d/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fdec67a6761ae43d8fae80e10b5a7a1e0ca7c0d/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=9fdec67a6761ae43d8fae80e10b5a7a1e0ca7c0d", "patch": "@@ -50,7 +50,6 @@ use iterator::Iterator;\n use str::StrSlice;\n use clone::DeepClone;\n \n-#[cfg(test)] use str;\n #[cfg(test)] use iterator::IteratorUtil;\n \n /// The option type\n@@ -446,10 +445,10 @@ fn test_unwrap_ptr() {\n #[test]\n fn test_unwrap_str() {\n     let x = ~\"test\";\n-    let addr_x = str::as_buf(x, |buf, _len| buf);\n+    let addr_x = x.as_buf(|buf, _len| buf);\n     let opt = Some(x);\n     let y = opt.unwrap();\n-    let addr_y = str::as_buf(y, |buf, _len| buf);\n+    let addr_y = y.as_buf(|buf, _len| buf);\n     assert_eq!(addr_x, addr_y);\n }\n "}, {"sha": "42e545ce1a9711527eb58e345f2a2ffd5e30786e", "filename": "src/libstd/rt/borrowck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9fdec67a6761ae43d8fae80e10b5a7a1e0ca7c0d/src%2Flibstd%2Frt%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fdec67a6761ae43d8fae80e10b5a7a1e0ca7c0d/src%2Flibstd%2Frt%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fborrowck.rs?ref=9fdec67a6761ae43d8fae80e10b5a7a1e0ca7c0d", "patch": "@@ -16,7 +16,7 @@ use managed::raw::BoxRepr;\n use option::{Option, None, Some};\n use uint;\n use str;\n-use str::OwnedStr;\n+use str::{OwnedStr, StrSlice};\n use sys;\n use vec::ImmutableVector;\n \n@@ -76,7 +76,7 @@ unsafe fn fail_borrowed(box: *mut BoxRepr, file: *c_char, line: size_t) {\n     match try_take_task_borrow_list() {\n         None => { // not recording borrows\n             let msg = \"borrowed\";\n-            do str::as_buf(msg) |msg_p, _| {\n+            do msg.as_buf |msg_p, _| {\n                 sys::begin_unwind_(msg_p as *c_char, file, line);\n             }\n         }\n@@ -92,7 +92,7 @@ unsafe fn fail_borrowed(box: *mut BoxRepr, file: *c_char, line: size_t) {\n                     sep = \" and at \";\n                 }\n             }\n-            do str::as_buf(msg) |msg_p, _| {\n+            do msg.as_buf |msg_p, _| {\n                 sys::begin_unwind_(msg_p as *c_char, file, line)\n             }\n         }\n@@ -231,7 +231,7 @@ pub unsafe fn unrecord_borrow(a: *u8, old_ref_count: uint,\n             let br = borrow_list.pop();\n             if br.box != a || br.file != file || br.line != line {\n                 let err = fmt!(\"wrong borrow found, br=%?\", br);\n-                do str::as_buf(err) |msg_p, _| {\n+                do err.as_buf |msg_p, _| {\n                     sys::begin_unwind_(msg_p as *c_char, file, line)\n                 }\n             }"}, {"sha": "c16e87000f5152d588e7fb38446f6b7a6b25189a", "filename": "src/libstd/str.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/9fdec67a6761ae43d8fae80e10b5a7a1e0ca7c0d/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fdec67a6761ae43d8fae80e10b5a7a1e0ca7c0d/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=9fdec67a6761ae43d8fae80e10b5a7a1e0ca7c0d", "patch": "@@ -17,7 +17,6 @@\n  */\n \n use at_vec;\n-use cast::transmute;\n use cast;\n use char;\n use char::Char;\n@@ -192,10 +191,10 @@ impl<'self, S: Str> StrVector for &'self [S] {\n         s.reserve(len);\n \n         unsafe {\n-            do as_buf(s) |buf, _| {\n+            do s.as_buf |buf, _| {\n                 let mut buf = ::cast::transmute_mut_unsafe(buf);\n                 for self.iter().advance |ss| {\n-                    do as_buf(ss.as_slice()) |ssbuf, sslen| {\n+                    do ss.as_slice().as_buf |ssbuf, sslen| {\n                         let sslen = sslen - 1;\n                         ptr::copy_memory(buf, ssbuf, sslen);\n                         buf = buf.offset(sslen);\n@@ -223,12 +222,12 @@ impl<'self, S: Str> StrVector for &'self [S] {\n         s.reserve(len);\n \n         unsafe {\n-            do as_buf(s) |buf, _| {\n-                do as_buf(sep) |sepbuf, seplen| {\n+            do s.as_buf |buf, _| {\n+                do sep.as_buf |sepbuf, seplen| {\n                     let seplen = seplen - 1;\n                     let mut buf = ::cast::transmute_mut_unsafe(buf);\n                     for self.iter().advance |ss| {\n-                        do as_buf(ss.as_slice()) |ssbuf, sslen| {\n+                        do ss.as_slice().as_buf |ssbuf, sslen| {\n                             let sslen = sslen - 1;\n                             if first {\n                                 first = false;\n@@ -534,8 +533,8 @@ Section: Comparing strings\n #[lang=\"str_eq\"]\n #[inline]\n pub fn eq_slice(a: &str, b: &str) -> bool {\n-    do as_buf(a) |ap, alen| {\n-        do as_buf(b) |bp, blen| {\n+    do a.as_buf |ap, alen| {\n+        do b.as_buf |bp, blen| {\n             if (alen != blen) { false }\n             else {\n                 unsafe {\n@@ -551,8 +550,8 @@ pub fn eq_slice(a: &str, b: &str) -> bool {\n #[cfg(test)]\n #[inline]\n pub fn eq_slice(a: &str, b: &str) -> bool {\n-    do as_buf(a) |ap, alen| {\n-        do as_buf(b) |bp, blen| {\n+    do a.as_buf |ap, alen| {\n+        do b.as_buf |bp, blen| {\n             if (alen != blen) { false }\n             else {\n                 unsafe {\n@@ -799,7 +798,7 @@ pub trait StrUtil {\n impl<'self> StrUtil for &'self str {\n     #[inline]\n     fn as_c_str<T>(self, f: &fn(*libc::c_char) -> T) -> T {\n-        do as_buf(self) |buf, len| {\n+        do self.as_buf |buf, len| {\n             // NB: len includes the trailing null.\n             assert!(len > 0);\n             if unsafe { *(ptr::offset(buf,len-1)) != 0 } {\n@@ -819,30 +818,13 @@ pub fn as_c_str<T>(s: &str, f: &fn(*libc::c_char) -> T) -> T {\n     s.as_c_str(f)\n }\n \n-/**\n- * Work with the byte buffer and length of a slice.\n- *\n- * The given length is one byte longer than the 'official' indexable\n- * length of the string. This is to permit probing the byte past the\n- * indexable area for a null byte, as is the case in slices pointing\n- * to full strings, or suffixes of them.\n- */\n-#[inline]\n-pub fn as_buf<T>(s: &str, f: &fn(*u8, uint) -> T) -> T {\n-    unsafe {\n-        let v : *(*u8,uint) = transmute(&s);\n-        let (buf,len) = *v;\n-        f(buf, len)\n-    }\n-}\n-\n /// Unsafe operations\n pub mod raw {\n     use cast;\n     use libc;\n     use ptr;\n     use str::raw;\n-    use str::{as_buf, is_utf8};\n+    use str::{is_utf8};\n     use vec;\n     use vec::MutableVector;\n \n@@ -931,7 +913,7 @@ pub mod raw {\n      * If end is greater than the length of the string.\n      */\n     pub unsafe fn slice_bytes_owned(s: &str, begin: uint, end: uint) -> ~str {\n-        do as_buf(s) |sbuf, n| {\n+        do s.as_buf |sbuf, n| {\n             assert!((begin <= end));\n             assert!((end <= n));\n \n@@ -959,7 +941,7 @@ pub mod raw {\n      */\n     #[inline]\n     pub unsafe fn slice_bytes(s: &str, begin: uint, end: uint) -> &str {\n-        do as_buf(s) |sbuf, n| {\n+        do s.as_buf |sbuf, n| {\n              assert!((begin <= end));\n              assert!((end <= n));\n \n@@ -972,7 +954,7 @@ pub mod raw {\n     pub unsafe fn push_byte(s: &mut ~str, b: u8) {\n         let new_len = s.len() + 1;\n         s.reserve_at_least(new_len);\n-        do as_buf(*s) |buf, len| {\n+        do s.as_buf |buf, len| {\n             let buf: *mut u8 = ::cast::transmute(buf);\n             *ptr::mut_offset(buf, len) = b;\n         }\n@@ -1193,7 +1175,7 @@ impl<'self> Str for @str {\n impl<'self> Container for &'self str {\n     #[inline]\n     fn len(&self) -> uint {\n-        do as_buf(*self) |_p, n| { n - 1u }\n+        do self.as_buf |_p, n| { n - 1u }\n     }\n     #[inline]\n     fn is_empty(&self) -> bool {\n@@ -1287,6 +1269,8 @@ pub trait StrSlice<'self> {\n     fn lev_distance(&self, t: &str) -> uint;\n \n     fn subslice_offset(&self, inner: &str) -> uint;\n+\n+    fn as_buf<T>(&self, f: &fn(*u8, uint) -> T) -> T;\n }\n \n /// Extension methods for strings\n@@ -1909,14 +1893,14 @@ impl<'self> StrSlice<'self> for &'self str {\n \n     /// Given a string, make a new string with repeated copies of it.\n     fn repeat(&self, nn: uint) -> ~str {\n-        do as_buf(*self) |buf, len| {\n+        do self.as_buf |buf, len| {\n             let mut ret = ~\"\";\n             // ignore the NULL terminator\n             let len = len - 1;\n             ret.reserve(nn * len);\n \n             unsafe {\n-                do as_buf(ret) |rbuf, _len| {\n+                do ret.as_buf |rbuf, _len| {\n                     let mut rbuf = ::cast::transmute_mut_unsafe(rbuf);\n \n                     for nn.times {\n@@ -2010,8 +1994,8 @@ impl<'self> StrSlice<'self> for &'self str {\n      */\n     #[inline]\n     fn subslice_offset(&self, inner: &str) -> uint {\n-        do as_buf(*self) |a, a_len| {\n-            do as_buf(inner) |b, b_len| {\n+        do self.as_buf |a, a_len| {\n+            do inner.as_buf |b, b_len| {\n                 let a_start: uint;\n                 let a_end: uint;\n                 let b_start: uint;\n@@ -2027,6 +2011,22 @@ impl<'self> StrSlice<'self> for &'self str {\n         }\n     }\n \n+    /**\n+     * Work with the byte buffer and length of a slice.\n+     *\n+     * The given length is one byte longer than the 'official' indexable\n+     * length of the string. This is to permit probing the byte past the\n+     * indexable area for a null byte, as is the case in slices pointing\n+     * to full strings, or suffixes of them.\n+     */\n+    #[inline]\n+    fn as_buf<T>(&self, f: &fn(*u8, uint) -> T) -> T {\n+        unsafe {\n+            let v: *(*u8, uint) = cast::transmute(self);\n+            let (buf, len) = *v;\n+            f(buf, len)\n+        }\n+    }\n }\n \n #[allow(missing_doc)]\n@@ -2084,8 +2084,8 @@ impl OwnedStr for ~str {\n             let llen = self.len();\n             let rlen = rhs.len();\n             self.reserve(llen + rlen);\n-            do as_buf(*self) |lbuf, _llen| {\n-                do as_buf(rhs) |rbuf, _rlen| {\n+            do self.as_buf |lbuf, _llen| {\n+                do rhs.as_buf |rbuf, _rlen| {\n                     let dst = ptr::offset(lbuf, llen);\n                     let dst = ::cast::transmute_mut_unsafe(dst);\n                     ptr::copy_memory(dst, rbuf, rlen);\n@@ -2102,8 +2102,8 @@ impl OwnedStr for ~str {\n             let llen = self.len();\n             let rlen = rhs.len();\n             self.reserve_at_least(llen + rlen);\n-            do as_buf(*self) |lbuf, _llen| {\n-                do as_buf(rhs) |rbuf, _rlen| {\n+            do self.as_buf |lbuf, _llen| {\n+                do rhs.as_buf |rbuf, _rlen| {\n                     let dst = ptr::offset(lbuf, llen);\n                     let dst = ::cast::transmute_mut_unsafe(dst);\n                     ptr::copy_memory(dst, rbuf, rlen);\n@@ -2126,7 +2126,7 @@ impl OwnedStr for ~str {\n             let new_len = len + nb;\n             self.reserve_at_least(new_len);\n             let off = len;\n-            do as_buf(*self) |buf, _len| {\n+            do self.as_buf |buf, _len| {\n                 let buf: *mut u8 = ::cast::transmute(buf);\n                 match nb {\n                     1u => {\n@@ -3091,28 +3091,28 @@ mod tests {\n     #[test]\n     fn test_as_buf() {\n         let a = \"Abcdefg\";\n-        let b = as_buf(a, |buf, _l| {\n+        let b = do a.as_buf |buf, _l| {\n             assert_eq!(unsafe { *buf }, 65u8);\n             100\n-        });\n+        };\n         assert_eq!(b, 100);\n     }\n \n     #[test]\n     fn test_as_buf_small() {\n         let a = \"A\";\n-        let b = as_buf(a, |buf, _l| {\n+        let b = do a.as_buf |buf, _l| {\n             assert_eq!(unsafe { *buf }, 65u8);\n             100\n-        });\n+        };\n         assert_eq!(b, 100);\n     }\n \n     #[test]\n     fn test_as_buf2() {\n         unsafe {\n             let s = ~\"hello\";\n-            let sb = as_buf(s, |b, _l| b);\n+            let sb = s.as_buf(|b, _l| b);\n             let s_cstr = raw::from_buf(sb);\n             assert_eq!(s_cstr, s);\n         }\n@@ -3121,7 +3121,7 @@ mod tests {\n     #[test]\n     fn test_as_buf_3() {\n         let a = ~\"hello\";\n-        do as_buf(a) |buf, len| {\n+        do a.as_buf |buf, len| {\n             unsafe {\n                 assert_eq!(a[0], 'h' as u8);\n                 assert_eq!(*buf, 'h' as u8);"}, {"sha": "0c497ecef271d55be20e0066e7e27cdd65f0a742", "filename": "src/libstd/sys.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9fdec67a6761ae43d8fae80e10b5a7a1e0ca7c0d/src%2Flibstd%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fdec67a6761ae43d8fae80e10b5a7a1e0ca7c0d/src%2Flibstd%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys.rs?ref=9fdec67a6761ae43d8fae80e10b5a7a1e0ca7c0d", "patch": "@@ -18,6 +18,7 @@ use io;\n use libc;\n use libc::{c_char, size_t};\n use repr;\n+use str::StrSlice;\n use str;\n use unstable::intrinsics;\n \n@@ -122,8 +123,8 @@ pub trait FailWithCause {\n \n impl FailWithCause for ~str {\n     fn fail_with(cause: ~str, file: &'static str, line: uint) -> ! {\n-        do str::as_buf(cause) |msg_buf, _msg_len| {\n-            do str::as_buf(file) |file_buf, _file_len| {\n+        do cause.as_buf |msg_buf, _msg_len| {\n+            do file.as_buf |file_buf, _file_len| {\n                 unsafe {\n                     let msg_buf = cast::transmute(msg_buf);\n                     let file_buf = cast::transmute(file_buf);\n@@ -136,8 +137,8 @@ impl FailWithCause for ~str {\n \n impl FailWithCause for &'static str {\n     fn fail_with(cause: &'static str, file: &'static str, line: uint) -> ! {\n-        do str::as_buf(cause) |msg_buf, _msg_len| {\n-            do str::as_buf(file) |file_buf, _file_len| {\n+        do cause.as_buf |msg_buf, _msg_len| {\n+            do file.as_buf |file_buf, _file_len| {\n                 unsafe {\n                     let msg_buf = cast::transmute(msg_buf);\n                     let file_buf = cast::transmute(file_buf);"}, {"sha": "f8cd08b4bf6144096fceb9c8b1a3dcd8a1468b76", "filename": "src/libstd/unstable/lang.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9fdec67a6761ae43d8fae80e10b5a7a1e0ca7c0d/src%2Flibstd%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fdec67a6761ae43d8fae80e10b5a7a1e0ca7c0d/src%2Flibstd%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Flang.rs?ref=9fdec67a6761ae43d8fae80e10b5a7a1e0ca7c0d", "patch": "@@ -56,7 +56,7 @@ pub fn fail_bounds_check(file: *c_char, line: size_t,\n                          index: size_t, len: size_t) {\n     let msg = fmt!(\"index out of bounds: the len is %d but the index is %d\",\n                     len as int, index as int);\n-    do str::as_buf(msg) |p, _len| {\n+    do msg.as_buf |p, _len| {\n         fail_(p as *c_char, file, line);\n     }\n }"}, {"sha": "12fa8066686d5b8fb9df2828ad3698bc625349fe", "filename": "src/test/run-pass/c-stack-returning-int64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9fdec67a6761ae43d8fae80e10b5a7a1e0ca7c0d/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fdec67a6761ae43d8fae80e10b5a7a1e0ca7c0d/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs?ref=9fdec67a6761ae43d8fae80e10b5a7a1e0ca7c0d", "patch": "@@ -20,11 +20,11 @@ mod libc {\n }\n \n fn atol(s: ~str) -> int {\n-    return str::as_buf(s, { |x, _len| unsafe { libc::atol(x) } });\n+    s.as_buf(|x, _len| unsafe { libc::atol(x) })\n }\n \n fn atoll(s: ~str) -> i64 {\n-    return str::as_buf(s, { |x, _len| unsafe { libc::atoll(x) } });\n+    s.as_buf(|x, _len| unsafe { libc::atoll(x) })\n }\n \n pub fn main() {"}]}