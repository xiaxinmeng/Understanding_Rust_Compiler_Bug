{"sha": "f9c06abc211f76004f3f558753d5d992ab32d223", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5YzA2YWJjMjExZjc2MDA0ZjNmNTU4NzUzZDVkOTkyYWIzMmQyMjM=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-06T12:29:31Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-17T19:51:53Z"}, "message": "trans: Simplify \"try\" intrinsic.", "tree": {"sha": "5be351b96a1357773ebc779e23d90beb7975b53b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5be351b96a1357773ebc779e23d90beb7975b53b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9c06abc211f76004f3f558753d5d992ab32d223", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9c06abc211f76004f3f558753d5d992ab32d223", "html_url": "https://github.com/rust-lang/rust/commit/f9c06abc211f76004f3f558753d5d992ab32d223", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9c06abc211f76004f3f558753d5d992ab32d223/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bffb0decc870ee76783c5da956acc980e73939bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/bffb0decc870ee76783c5da956acc980e73939bf", "html_url": "https://github.com/rust-lang/rust/commit/bffb0decc870ee76783c5da956acc980e73939bf"}], "stats": {"total": 42, "additions": 5, "deletions": 37}, "files": [{"sha": "37eb2aa4c58c1698edd740c429feab59f733f3fe", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 5, "deletions": 37, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f9c06abc211f76004f3f558753d5d992ab32d223/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9c06abc211f76004f3f558753d5d992ab32d223/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=f9c06abc211f76004f3f558753d5d992ab32d223", "patch": "@@ -350,43 +350,6 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n     }\n \n-    // For `try` we need some custom control flow\n-    if &name[..] == \"try\" {\n-        if let callee::ArgExprs(ref exprs) = args {\n-            let (func, data, local_ptr) = if exprs.len() != 3 {\n-                ccx.sess().bug(\"expected three exprs as arguments for \\\n-                                `try` intrinsic\");\n-            } else {\n-                (&exprs[0], &exprs[1], &exprs[2])\n-            };\n-\n-            // translate arguments\n-            let func = unpack_datum!(bcx, expr::trans(bcx, func));\n-            let func = unpack_datum!(bcx, func.to_rvalue_datum(bcx, \"func\"));\n-            let data = unpack_datum!(bcx, expr::trans(bcx, data));\n-            let data = unpack_datum!(bcx, data.to_rvalue_datum(bcx, \"data\"));\n-            let local_ptr = unpack_datum!(bcx, expr::trans(bcx, local_ptr));\n-            let local_ptr = local_ptr.to_rvalue_datum(bcx, \"local_ptr\");\n-            let local_ptr = unpack_datum!(bcx, local_ptr);\n-\n-            let dest = match dest {\n-                expr::SaveIn(d) => d,\n-                expr::Ignore => alloc_ty(bcx, tcx.mk_mut_ptr(tcx.types.i8),\n-                                         \"try_result\"),\n-            };\n-\n-            // do the invoke\n-            bcx = try_intrinsic(bcx, func.val, data.val, local_ptr.val, dest,\n-                                call_debug_location);\n-\n-            fcx.pop_and_trans_custom_cleanup_scope(bcx, cleanup_scope);\n-            return Result::new(bcx, dest);\n-        } else {\n-            ccx.sess().bug(\"expected two exprs as arguments for \\\n-                            `try` intrinsic\");\n-        }\n-    }\n-\n     // save the actual AST arguments for later (some places need to do\n     // const-evaluation on them)\n     let expr_arguments = match args {\n@@ -446,6 +409,11 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         (Some(llfn), _) => {\n             Call(bcx, llfn, &llargs, call_debug_location)\n         }\n+        (_, \"try\") => {\n+            bcx = try_intrinsic(bcx, llargs[0], llargs[1], llargs[2], llresult,\n+                                call_debug_location);\n+            C_nil(ccx)\n+        }\n         (_, \"breakpoint\") => {\n             let llfn = ccx.get_intrinsic(&(\"llvm.debugtrap\"));\n             Call(bcx, llfn, &[], call_debug_location)"}]}