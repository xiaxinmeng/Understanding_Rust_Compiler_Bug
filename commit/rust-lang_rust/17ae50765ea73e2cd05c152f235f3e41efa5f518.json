{"sha": "17ae50765ea73e2cd05c152f235f3e41efa5f518", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3YWU1MDc2NWVhNzNlMmNkMDVjMTUyZjIzNWYzZTQxZWZhNWY1MTg=", "commit": {"author": {"name": "Pietro Albini", "email": "pietro@pietroalbini.org", "date": "2018-11-10T23:21:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-11-10T23:21:25Z"}, "message": "Rollup merge of #55844 - waywardmonkeys:typo-fixes, r=varkor\n\nFix documentation typos.", "tree": {"sha": "53e2d491158e0b4b39d7f5395feb5f1c8c39d690", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53e2d491158e0b4b39d7f5395feb5f1c8c39d690"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/17ae50765ea73e2cd05c152f235f3e41efa5f518", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJb52f2CRBK7hj4Ov3rIwAAdHIIAEqs3qcXC+HvUiffFj7yt5bg\nHNvRjZz2GNkN4bWz2rnKcDVbdVu+kK5xio7qQ7XjK4GY6Yi6TBwwgsSHJxp1QLkE\n1TDH8Jwe8ck0rk6bZuom+haY6j1qc8S+b/orwrWXNaDxc0+Vh2X5HhnIB67lSGC4\n8y4hU9wMAVQ7SjzPBWqZbLSYfT1G29D2UCD+Sqi23ZqfWWw0HEFxQX/M7D5GmZVX\nFwAhInrpVe/WXPydS33lXVO2UvEDZweIXsXSaxIPeZK8FFXWqhtfxl/VkV3bs/15\ngkCYrXuv5BFx2zXDbAH/AFWLasi+8hCMINGkV6zv9DfP7xaTECzaYL1EIKIBsdM=\n=CPqV\n-----END PGP SIGNATURE-----\n", "payload": "tree 53e2d491158e0b4b39d7f5395feb5f1c8c39d690\nparent 417b10a0e3dd1ee8f677007763f830f34d320644\nparent 9b4d68e53bd0eaa1ef3e402d0227f2d9ef1970dd\nauthor Pietro Albini <pietro@pietroalbini.org> 1541892085 +0100\ncommitter GitHub <noreply@github.com> 1541892085 +0100\n\nRollup merge of #55844 - waywardmonkeys:typo-fixes, r=varkor\n\nFix documentation typos.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/17ae50765ea73e2cd05c152f235f3e41efa5f518", "html_url": "https://github.com/rust-lang/rust/commit/17ae50765ea73e2cd05c152f235f3e41efa5f518", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/17ae50765ea73e2cd05c152f235f3e41efa5f518/comments", "author": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "417b10a0e3dd1ee8f677007763f830f34d320644", "url": "https://api.github.com/repos/rust-lang/rust/commits/417b10a0e3dd1ee8f677007763f830f34d320644", "html_url": "https://github.com/rust-lang/rust/commit/417b10a0e3dd1ee8f677007763f830f34d320644"}, {"sha": "9b4d68e53bd0eaa1ef3e402d0227f2d9ef1970dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b4d68e53bd0eaa1ef3e402d0227f2d9ef1970dd", "html_url": "https://github.com/rust-lang/rust/commit/9b4d68e53bd0eaa1ef3e402d0227f2d9ef1970dd"}], "stats": {"total": 28, "additions": 14, "deletions": 14}, "files": [{"sha": "58639808faedbfc5c3e28fe2e73ad1b0d8cb6838", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/17ae50765ea73e2cd05c152f235f3e41efa5f518/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ae50765ea73e2cd05c152f235f3e41efa5f518/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=17ae50765ea73e2cd05c152f235f3e41efa5f518", "patch": "@@ -523,7 +523,7 @@ pub unsafe trait GlobalAlloc {\n         ptr\n     }\n \n-    /// Shink or grow a block of memory to the given `new_size`.\n+    /// Shrink or grow a block of memory to the given `new_size`.\n     /// The block is described by the given `ptr` pointer and `layout`.\n     ///\n     /// If this returns a non-null pointer, then ownership of the memory block\n@@ -774,7 +774,7 @@ pub unsafe trait Alloc {\n     // realloc. alloc_excess, realloc_excess\n \n     /// Returns a pointer suitable for holding data described by\n-    /// a new layout with `layout`\u2019s alginment and a size given\n+    /// a new layout with `layout`\u2019s alignment and a size given\n     /// by `new_size`. To\n     /// accomplish this, this may extend or shrink the allocation\n     /// referenced by `ptr` to fit the new layout."}, {"sha": "0c870f9e404a26ca59147ea840bb30760bb16a67", "filename": "src/libcore/future/future.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/17ae50765ea73e2cd05c152f235f3e41efa5f518/src%2Flibcore%2Ffuture%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ae50765ea73e2cd05c152f235f3e41efa5f518/src%2Flibcore%2Ffuture%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Ffuture.rs?ref=17ae50765ea73e2cd05c152f235f3e41efa5f518", "patch": "@@ -17,7 +17,7 @@ use ops;\n use pin::Pin;\n use task::{Poll, LocalWaker};\n \n-/// A future represents an asychronous computation.\n+/// A future represents an asynchronous computation.\n ///\n /// A future is a value that may not have finished computing yet. This kind of\n /// \"asynchronous value\" makes it possible for a thread to continue doing useful"}, {"sha": "c69d4441121ce9d9f6ad72e6403bec7e2929be4a", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/17ae50765ea73e2cd05c152f235f3e41efa5f518/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ae50765ea73e2cd05c152f235f3e41efa5f518/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=17ae50765ea73e2cd05c152f235f3e41efa5f518", "patch": "@@ -228,7 +228,7 @@ mod nonzero;\n mod tuple;\n mod unit;\n \n-// Pull in the the `coresimd` crate directly into libcore. This is where all the\n+// Pull in the `coresimd` crate directly into libcore. This is where all the\n // architecture-specific (and vendor-specific) intrinsics are defined. AKA\n // things like SIMD and such. Note that the actual source for all this lies in a\n // different repository, rust-lang-nursery/stdsimd. That's why the setup here is"}, {"sha": "8c4ff02aa140f65afec7d23c05edfee71287d46f", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/17ae50765ea73e2cd05c152f235f3e41efa5f518/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ae50765ea73e2cd05c152f235f3e41efa5f518/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=17ae50765ea73e2cd05c152f235f3e41efa5f518", "patch": "@@ -202,7 +202,7 @@ pub fn forget<T>(t: T) {\n ///\n /// ## Size of Enums\n ///\n-/// Enums that carry no data other than the descriminant have the same size as C enums\n+/// Enums that carry no data other than the discriminant have the same size as C enums\n /// on the platform they are compiled for.\n ///\n /// ## Size of Unions\n@@ -1081,7 +1081,7 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// # Unsafety\n     ///\n-    /// It is up to the caller to guarantee that the the `MaybeUninit` really is in an initialized\n+    /// It is up to the caller to guarantee that the `MaybeUninit` really is in an initialized\n     /// state, otherwise this will immediately cause undefined behavior.\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     pub unsafe fn into_inner(self) -> T {\n@@ -1092,7 +1092,7 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// # Unsafety\n     ///\n-    /// It is up to the caller to guarantee that the the `MaybeUninit` really is in an initialized\n+    /// It is up to the caller to guarantee that the `MaybeUninit` really is in an initialized\n     /// state, otherwise this will immediately cause undefined behavior.\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     pub unsafe fn get_ref(&self) -> &T {\n@@ -1103,7 +1103,7 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// # Unsafety\n     ///\n-    /// It is up to the caller to guarantee that the the `MaybeUninit` really is in an initialized\n+    /// It is up to the caller to guarantee that the `MaybeUninit` really is in an initialized\n     /// state, otherwise this will immediately cause undefined behavior.\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     pub unsafe fn get_mut(&mut self) -> &mut T {"}, {"sha": "827e297c84d1f427918508b885a71395a50884f9", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/17ae50765ea73e2cd05c152f235f3e41efa5f518/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ae50765ea73e2cd05c152f235f3e41efa5f518/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=17ae50765ea73e2cd05c152f235f3e41efa5f518", "patch": "@@ -120,7 +120,7 @@ pub use intrinsics::write_bytes;\n ///\n /// Additionally, if `T` is not [`Copy`], using the pointed-to value after\n /// calling `drop_in_place` can cause undefined behavior. Note that `*to_drop =\n-/// foo` counts as a use because it will cause the the value to be dropped\n+/// foo` counts as a use because it will cause the value to be dropped\n /// again. [`write`] can be used to overwrite data without causing it to be\n /// dropped.\n ///\n@@ -371,7 +371,7 @@ pub(crate) unsafe fn swap_nonoverlapping_one<T>(x: *mut T, y: *mut T) {\n #[inline]\n unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n     // The approach here is to utilize simd to swap x & y efficiently. Testing reveals\n-    // that swapping either 32 bytes or 64 bytes at a time is most efficient for intel\n+    // that swapping either 32 bytes or 64 bytes at a time is most efficient for Intel\n     // Haswell E processors. LLVM is more able to optimize if we give a struct a\n     // #[repr(simd)], even if we don't actually use this struct directly.\n     //\n@@ -1005,7 +1005,7 @@ impl<T: ?Sized> *const T {\n     /// # Null-unchecked version\n     ///\n     /// If you are sure the pointer can never be null and are looking for some kind of\n-    /// `as_ref_unchecked` that returns the `&T` instead of `Option<&T>, know that you can\n+    /// `as_ref_unchecked` that returns the `&T` instead of `Option<&T>`, know that you can\n     /// dereference the pointer directly.\n     ///\n     /// ```\n@@ -1625,7 +1625,7 @@ impl<T: ?Sized> *mut T {\n     /// # Null-unchecked version\n     ///\n     /// If you are sure the pointer can never be null and are looking for some kind of\n-    /// `as_ref_unchecked` that returns the `&T` instead of `Option<&T>, know that you can\n+    /// `as_ref_unchecked` that returns the `&T` instead of `Option<&T>`, know that you can\n     /// dereference the pointer directly.\n     ///\n     /// ```"}, {"sha": "87ffe0f15e45461032f31da6de9159016b7795c6", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/17ae50765ea73e2cd05c152f235f3e41efa5f518/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ae50765ea73e2cd05c152f235f3e41efa5f518/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=17ae50765ea73e2cd05c152f235f3e41efa5f518", "patch": "@@ -1178,7 +1178,7 @@ impl CStr {\n     ///\n     /// If the contents of the `CStr` are valid UTF-8 data, this\n     /// function will return a [`Cow`]`::`[`Borrowed`]`(`[`&str`]`)`\n-    /// with the the corresponding [`&str`] slice. Otherwise, it will\n+    /// with the corresponding [`&str`] slice. Otherwise, it will\n     /// replace any invalid UTF-8 sequences with\n     /// [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD] and return a\n     /// [`Cow`]`::`[`Owned`]`(`[`String`]`)` with the result."}, {"sha": "0829593505d69e5b8060132d992b922f33d29da4", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/17ae50765ea73e2cd05c152f235f3e41efa5f518/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ae50765ea73e2cd05c152f235f3e41efa5f518/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=17ae50765ea73e2cd05c152f235f3e41efa5f518", "patch": "@@ -495,7 +495,7 @@ mod memchr;\n // compiler\n pub mod rt;\n \n-// Pull in the the `stdsimd` crate directly into libstd. This is the same as\n+// Pull in the `stdsimd` crate directly into libstd. This is the same as\n // libcore's arch/simd modules where the source of truth here is in a different\n // repository, but we pull things in here manually to get it into libstd.\n //"}]}