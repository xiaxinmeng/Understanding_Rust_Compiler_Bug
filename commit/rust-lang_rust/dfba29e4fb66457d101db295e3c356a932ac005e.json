{"sha": "dfba29e4fb66457d101db295e3c356a932ac005e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmYmEyOWU0ZmI2NjQ1N2QxMDFkYjI5NWUzYzM1NmE5MzJhYzAwNWU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-10-31T19:34:31Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-10-31T19:35:01Z"}, "message": "Add MockAnalysis to make testing easier", "tree": {"sha": "57907040a40ce65a6ed2377469204a6c79bb645e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/57907040a40ce65a6ed2377469204a6c79bb645e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dfba29e4fb66457d101db295e3c356a932ac005e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dfba29e4fb66457d101db295e3c356a932ac005e", "html_url": "https://github.com/rust-lang/rust/commit/dfba29e4fb66457d101db295e3c356a932ac005e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dfba29e4fb66457d101db295e3c356a932ac005e/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41adf1bc4f8b88139afd550209c0be612c10ffa8", "url": "https://api.github.com/repos/rust-lang/rust/commits/41adf1bc4f8b88139afd550209c0be612c10ffa8", "html_url": "https://github.com/rust-lang/rust/commit/41adf1bc4f8b88139afd550209c0be612c10ffa8"}], "stats": {"total": 243, "additions": 167, "deletions": 76}, "files": [{"sha": "deddf41f0122c1d7192f521d90e38fdda8679c07", "filename": "crates/ra_analysis/Cargo.toml", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dfba29e4fb66457d101db295e3c356a932ac005e/crates%2Fra_analysis%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/dfba29e4fb66457d101db295e3c356a932ac005e/crates%2Fra_analysis%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2FCargo.toml?ref=dfba29e4fb66457d101db295e3c356a932ac005e", "patch": "@@ -9,10 +9,8 @@ log = \"0.4.5\"\n relative-path = \"0.4.0\"\n rayon = \"1.0.2\"\n fst = \"0.3.1\"\n-ra_syntax = { path = \"../ra_syntax\" }\n-ra_editor = { path = \"../ra_editor\" }\n salsa = \"0.7.0\"\n rustc-hash = \"1.0\"\n-\n-[dev-dependencies]\n+ra_syntax = { path = \"../ra_syntax\" }\n+ra_editor = { path = \"../ra_editor\" }\n test_utils = { path = \"../test_utils\" }"}, {"sha": "286b6c3761c7ddab3749e2e82755d34fe3cec750", "filename": "crates/ra_analysis/src/completion.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/dfba29e4fb66457d101db295e3c356a932ac005e/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfba29e4fb66457d101db295e3c356a932ac005e/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs?ref=dfba29e4fb66457d101db295e3c356a932ac005e", "patch": "@@ -368,18 +368,15 @@ fn complete_fn(name_ref: ast::NameRef, scopes: &FnScopes, acc: &mut Vec<Completi\n \n #[cfg(test)]\n mod tests {\n-    use test_utils::{assert_eq_dbg, extract_offset};\n+    use test_utils::{assert_eq_dbg};\n \n-    use crate::FileId;\n-    use crate::mock_analysis::MockAnalysis;\n+    use crate::mock_analysis::{single_file_with_position};\n \n     use super::*;\n \n     fn check_scope_completion(code: &str, expected_completions: &str) {\n-        let (off, code) = extract_offset(&code);\n-        let analysis = MockAnalysis::with_files(&[(\"/main.rs\", &code)]).analysis();\n-        let file_id = FileId(1);\n-        let completions = scope_completion(&analysis.imp.db, file_id, off)\n+        let (analysis, position) = single_file_with_position(code);\n+        let completions = scope_completion(&analysis.imp.db, position.file_id, position.offset)\n             .unwrap()\n             .into_iter()\n             .filter(|c| c.snippet.is_none())\n@@ -388,10 +385,8 @@ mod tests {\n     }\n \n     fn check_snippet_completion(code: &str, expected_completions: &str) {\n-        let (off, code) = extract_offset(&code);\n-        let analysis = MockAnalysis::with_files(&[(\"/main.rs\", &code)]).analysis();\n-        let file_id = FileId(1);\n-        let completions = scope_completion(&analysis.imp.db, file_id, off)\n+        let (analysis, position) = single_file_with_position(code);\n+        let completions = scope_completion(&analysis.imp.db, position.file_id, position.offset)\n             .unwrap()\n             .into_iter()\n             .filter(|c| c.snippet.is_some())"}, {"sha": "b89b45133886a84cd0db833b8bbc7184a1343a1d", "filename": "crates/ra_analysis/src/input.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfba29e4fb66457d101db295e3c356a932ac005e/crates%2Fra_analysis%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfba29e4fb66457d101db295e3c356a932ac005e/crates%2Fra_analysis%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Finput.rs?ref=dfba29e4fb66457d101db295e3c356a932ac005e", "patch": "@@ -25,7 +25,7 @@ impl CrateGraph {\n     pub fn new() -> CrateGraph {\n         CrateGraph::default()\n     }\n-    pub fn add_crate_root(&mut self, file_id: FileId) -> CrateId{\n+    pub fn add_crate_root(&mut self, file_id: FileId) -> CrateId {\n         let crate_id = CrateId(self.crate_roots.len() as u32);\n         let prev = self.crate_roots.insert(crate_id, file_id);\n         assert!(prev.is_none());"}, {"sha": "e75411ec95220e70397714138c2f0fd40c744366", "filename": "crates/ra_analysis/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dfba29e4fb66457d101db295e3c356a932ac005e/crates%2Fra_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfba29e4fb66457d101db295e3c356a932ac005e/crates%2Fra_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Flib.rs?ref=dfba29e4fb66457d101db295e3c356a932ac005e", "patch": "@@ -13,7 +13,7 @@ mod imp;\n mod symbol_index;\n mod completion;\n mod syntax_ptr;\n-mod mock_analysis;\n+pub mod mock_analysis;\n \n use std::{\n     fmt,\n@@ -33,7 +33,6 @@ pub use crate::{\n     descriptors::function::FnDescriptor,\n     completion::CompletionItem,\n     input::{FileId, FileResolver, CrateGraph, CrateId},\n-    mock_analysis::MockAnalysis,\n };\n pub use ra_editor::{\n     FileSymbol, Fold, FoldKind, HighlightedRange, LineIndex, Runnable,"}, {"sha": "f72911192183eeb745f45a096fd35e5c9bf51c3b", "filename": "crates/ra_analysis/src/mock_analysis.rs", "status": "modified", "additions": 79, "deletions": 5, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/dfba29e4fb66457d101db295e3c356a932ac005e/crates%2Fra_analysis%2Fsrc%2Fmock_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfba29e4fb66457d101db295e3c356a932ac005e/crates%2Fra_analysis%2Fsrc%2Fmock_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fmock_analysis.rs?ref=dfba29e4fb66457d101db295e3c356a932ac005e", "patch": "@@ -2,11 +2,19 @@\n use std::sync::Arc;\n \n use relative_path::{RelativePath, RelativePathBuf};\n+use ra_syntax::TextUnit;\n+use test_utils::{extract_offset, parse_fixture, CURSOR_MARKER};\n \n use crate::{\n     AnalysisChange, Analysis, AnalysisHost, FileId, FileResolver,\n };\n \n+#[derive(Debug)]\n+pub struct FilePosition {\n+    pub file_id: FileId,\n+    pub offset: TextUnit,\n+}\n+\n /// Mock analysis is used in test to bootstrap an AnalysisHost/Analysis\n /// from a set of in-memory files.\n #[derive(Debug, Default)]\n@@ -18,11 +26,57 @@ impl MockAnalysis {\n     pub fn new() -> MockAnalysis {\n         MockAnalysis::default()\n     }\n-    pub fn with_files(files: &[(&str, &str)]) -> MockAnalysis {\n-        let files = files.iter()\n-            .map(|it| (it.0.to_string(), it.1.to_string()))\n-            .collect();\n-        MockAnalysis { files }\n+    /// Creates `MockAnalysis` using a fixture data in the following format:\n+    ///\n+    /// ```notrust\n+    /// //- /main.rs\n+    /// mod foo;\n+    /// fn main() {}\n+    ///\n+    /// //- /foo.rs\n+    /// struct Baz;\n+    /// ```\n+    pub fn with_files(fixture: &str) -> MockAnalysis {\n+        let mut res = MockAnalysis::new();\n+        for entry in parse_fixture(fixture) {\n+            res.add_file(&entry.meta, &entry.text);\n+        }\n+        res\n+    }\n+\n+    /// Same as `with_files`, but requires that a single file contains a `<|>` marker,\n+    /// whose position is also returned.\n+    pub fn with_files_and_position(fixture: &str) -> (MockAnalysis, FilePosition) {\n+        let mut position = None;\n+        let mut res = MockAnalysis::new();\n+        for entry in parse_fixture(fixture) {\n+            if entry.text.contains(CURSOR_MARKER) {\n+                assert!(position.is_none(), \"only one marker (<|>) per fixture is allowed\");\n+                position = Some(res.add_file_with_position(&entry.meta, &entry.text));\n+            } else {\n+                res.add_file(&entry.meta, &entry.text);\n+            }\n+        }\n+        let position = position.expect(\"expected a marker (<|>)\");\n+        (res, position)\n+    }\n+\n+    pub fn add_file(&mut self, path: &str, text: &str) -> FileId {\n+        let file_id = FileId((self.files.len() + 1) as u32);\n+        self.files.push((path.to_string(), text.to_string()));\n+        file_id\n+    }\n+    pub fn add_file_with_position(&mut self, path: &str, text: &str) -> FilePosition {\n+        let (offset, text) = extract_offset(text);\n+        let file_id = FileId((self.files.len() + 1) as u32);\n+        self.files.push((path.to_string(), text.to_string()));\n+        FilePosition { file_id, offset }\n+    }\n+    pub fn id_of(&self, path: &str) -> FileId {\n+        let (idx, _) = self.files.iter().enumerate()\n+            .find(|(_, (p, _text))| path == p)\n+            .expect(\"no file in this mock\");\n+        FileId(idx as u32 + 1)\n     }\n     pub fn analysis_host(self) -> AnalysisHost {\n         let mut host = AnalysisHost::new();\n@@ -44,6 +98,26 @@ impl MockAnalysis {\n     }\n }\n \n+/// Creates analysis from a multi-file fixture, returns positions marked with <|>.\n+pub fn analysis_and_position(fixture: &str) -> (Analysis, FilePosition) {\n+    let (mock, position) = MockAnalysis::with_files_and_position(fixture);\n+    (mock.analysis(), position)\n+}\n+\n+/// Creates analysis for a single file.\n+pub fn single_file(code: &str) -> (Analysis, FileId) {\n+    let mut mock = MockAnalysis::new();\n+    let file_id = mock.add_file(\"/main.rs\", code);\n+    (mock.analysis(), file_id)\n+}\n+\n+/// Creates analysis for a single file, returns position marked with <|>.\n+pub fn single_file_with_position(code: &str) -> (Analysis, FilePosition) {\n+    let mut mock = MockAnalysis::new();\n+    let pos = mock.add_file_with_position(\"/main.rs\", code);\n+    (mock.analysis(), pos)\n+}\n+\n #[derive(Debug)]\n struct FileMap(Vec<(FileId, RelativePathBuf)>);\n "}, {"sha": "94e0256771b00a34c0f6157c2b27fbebdebbaca5", "filename": "crates/ra_analysis/tests/tests.rs", "status": "modified", "additions": 57, "deletions": 48, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/dfba29e4fb66457d101db295e3c356a932ac005e/crates%2Fra_analysis%2Ftests%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfba29e4fb66457d101db295e3c356a932ac005e/crates%2Fra_analysis%2Ftests%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Ftests%2Ftests.rs?ref=dfba29e4fb66457d101db295e3c356a932ac005e", "patch": "@@ -5,38 +5,42 @@ extern crate relative_path;\n extern crate rustc_hash;\n extern crate test_utils;\n \n-use ra_syntax::TextRange;\n-use test_utils::{assert_eq_dbg, extract_offset};\n+use ra_syntax::{TextRange};\n+use test_utils::{assert_eq_dbg};\n \n use ra_analysis::{\n-    MockAnalysis,\n-    AnalysisChange, Analysis, CrateGraph, CrateId, FileId, FnDescriptor,\n+    AnalysisChange, CrateGraph, FileId, FnDescriptor,\n+    mock_analysis::{MockAnalysis, single_file, single_file_with_position, analysis_and_position},\n };\n \n-fn analysis(files: &[(&str, &str)]) -> Analysis {\n-    MockAnalysis::with_files(files).analysis()\n-}\n-\n fn get_signature(text: &str) -> (FnDescriptor, Option<usize>) {\n-    let (offset, code) = extract_offset(text);\n-    let code = code.as_str();\n-\n-    let snap = analysis(&[(\"/lib.rs\", code)]);\n-\n-    snap.resolve_callable(FileId(1), offset).unwrap().unwrap()\n+    let (analysis, position) = single_file_with_position(text);\n+    analysis.resolve_callable(position.file_id, position.offset).unwrap().unwrap()\n }\n \n #[test]\n fn test_resolve_module() {\n-    let snap = analysis(&[(\"/lib.rs\", \"mod foo;\"), (\"/foo.rs\", \"\")]);\n-    let symbols = snap.approximately_resolve_symbol(FileId(1), 4.into()).unwrap();\n+    let (analysis, pos) = analysis_and_position(\"\n+        //- /lib.rs\n+        mod <|>foo;\n+        //- /foo.rs\n+        // empty\n+    \");\n+\n+    let symbols = analysis.approximately_resolve_symbol(pos.file_id, pos.offset).unwrap();\n     assert_eq_dbg(\n         r#\"[(FileId(2), FileSymbol { name: \"foo\", node_range: [0; 0), kind: MODULE })]\"#,\n         &symbols,\n     );\n \n-    let snap = analysis(&[(\"/lib.rs\", \"mod foo;\"), (\"/foo/mod.rs\", \"\")]);\n-    let symbols = snap.approximately_resolve_symbol(FileId(1), 4.into()).unwrap();\n+    let (analysis, pos) = analysis_and_position(\"\n+        //- /lib.rs\n+        mod <|>foo;\n+        //- /foo/mod.rs\n+        // empty\n+    \");\n+\n+    let symbols = analysis.approximately_resolve_symbol(pos.file_id, pos.offset).unwrap();\n     assert_eq_dbg(\n         r#\"[(FileId(2), FileSymbol { name: \"foo\", node_range: [0; 0), kind: MODULE })]\"#,\n         &symbols,\n@@ -45,8 +49,8 @@ fn test_resolve_module() {\n \n #[test]\n fn test_unresolved_module_diagnostic() {\n-    let snap = analysis(&[(\"/lib.rs\", \"mod foo;\")]);\n-    let diagnostics = snap.diagnostics(FileId(1)).unwrap();\n+    let (analysis, file_id) = single_file(\"mod foo;\");\n+    let diagnostics = analysis.diagnostics(file_id).unwrap();\n     assert_eq_dbg(\n         r#\"[Diagnostic {\n             message: \"unresolved module\",\n@@ -62,15 +66,20 @@ fn test_unresolved_module_diagnostic() {\n \n #[test]\n fn test_unresolved_module_diagnostic_no_diag_for_inline_mode() {\n-    let snap = analysis(&[(\"/lib.rs\", \"mod foo {}\")]);\n-    let diagnostics = snap.diagnostics(FileId(1)).unwrap();\n+    let (analysis, file_id) = single_file(\"mod foo {}\");\n+    let diagnostics = analysis.diagnostics(file_id).unwrap();\n     assert_eq_dbg(r#\"[]\"#, &diagnostics);\n }\n \n #[test]\n fn test_resolve_parent_module() {\n-    let snap = analysis(&[(\"/lib.rs\", \"mod foo;\"), (\"/foo.rs\", \"\")]);\n-    let symbols = snap.parent_module(FileId(2)).unwrap();\n+    let (analysis, pos) = analysis_and_position(\"\n+        //- /lib.rs\n+        mod foo;\n+        //- /foo.rs\n+        <|>// empty\n+    \");\n+    let symbols = analysis.parent_module(pos.file_id).unwrap();\n     assert_eq_dbg(\n         r#\"[(FileId(1), FileSymbol { name: \"foo\", node_range: [0; 8), kind: MODULE })]\"#,\n         &symbols,\n@@ -79,23 +88,24 @@ fn test_resolve_parent_module() {\n \n #[test]\n fn test_resolve_crate_root() {\n-    let mut host = MockAnalysis::with_files(\n-        &[(\"/lib.rs\", \"mod foo;\"), (\"/foo.rs\", \"\")]\n-    ).analysis_host();\n-    let snap = host.analysis();\n-    assert!(snap.crate_for(FileId(2)).unwrap().is_empty());\n-\n-    let crate_graph = {\n-        let mut g = CrateGraph::new();\n-        g.add_crate_root(FileId(1));\n-        g\n-    };\n+    let mock = MockAnalysis::with_files(\"\n+        //- /lib.rs\n+        mod foo;\n+        //- /foo.rs\n+        // emtpy <|>\n+    \");\n+    let root_file = mock.id_of(\"/lib.rs\");\n+    let mod_file = mock.id_of(\"/foo.rs\");\n+    let mut host = mock.analysis_host();\n+    assert!(host.analysis().crate_for(mod_file).unwrap().is_empty());\n+\n+    let mut crate_graph = CrateGraph::new();\n+    let crate_id = crate_graph.add_crate_root(root_file);\n     let mut change = AnalysisChange::new();\n     change.set_crate_graph(crate_graph);\n     host.apply_change(change);\n-    let snap = host.analysis();\n \n-    assert_eq!(snap.crate_for(FileId(2)).unwrap(), vec![CrateId(0)],);\n+    assert_eq!(host.analysis().crate_for(mod_file).unwrap(), vec![crate_id]);\n }\n \n #[test]\n@@ -186,12 +196,8 @@ fn bar() {\n }\n \n fn get_all_refs(text: &str) -> Vec<(FileId, TextRange)> {\n-    let (offset, code) = extract_offset(text);\n-    let code = code.as_str();\n-\n-    let snap = analysis(&[(\"/lib.rs\", code)]);\n-\n-    snap.find_all_refs(FileId(1), offset).unwrap()\n+    let (analysis, position) = single_file_with_position(text);\n+    analysis.find_all_refs(position.file_id, position.offset).unwrap()\n }\n \n #[test]\n@@ -226,11 +232,14 @@ fn test_find_all_refs_for_param_inside() {\n \n #[test]\n fn test_complete_crate_path() {\n-    let snap = analysis(&[\n-        (\"/lib.rs\", \"mod foo; struct Spam;\"),\n-        (\"/foo.rs\", \"use crate::Sp\"),\n-    ]);\n-    let completions = snap.completions(FileId(2), 13.into()).unwrap().unwrap();\n+    let (analysis, position) = analysis_and_position(\"\n+        //- /lib.rs\n+        mod foo;\n+        struct Spam;\n+        //- /foo.rs\n+        use crate::Sp<|>\n+    \");\n+    let completions = analysis.completions(position.file_id, position.offset).unwrap().unwrap();\n     assert_eq_dbg(\n         r#\"[CompletionItem { label: \"foo\", lookup: None, snippet: None },\n             CompletionItem { label: \"Spam\", lookup: None, snippet: None }]\"#,"}, {"sha": "8980f077f516db06105769228ace9f3d8bd9b909", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/dfba29e4fb66457d101db295e3c356a932ac005e/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfba29e4fb66457d101db295e3c356a932ac005e/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=dfba29e4fb66457d101db295e3c356a932ac005e", "patch": "@@ -8,6 +8,8 @@ use text_unit::{TextRange, TextUnit};\n \n pub use self::difference::Changeset as __Changeset;\n \n+pub const CURSOR_MARKER: &str = \"<|>\";\n+\n #[macro_export]\n macro_rules! assert_eq_text {\n     ($expected:expr, $actual:expr) => {{\n@@ -45,11 +47,10 @@ pub fn extract_offset(text: &str) -> (TextUnit, String) {\n }\n \n pub fn try_extract_offset(text: &str) -> Option<(TextUnit, String)> {\n-    let cursor = \"<|>\";\n-    let cursor_pos = text.find(cursor)?;\n-    let mut new_text = String::with_capacity(text.len() - cursor.len());\n+    let cursor_pos = text.find(CURSOR_MARKER)?;\n+    let mut new_text = String::with_capacity(text.len() - CURSOR_MARKER.len());\n     new_text.push_str(&text[..cursor_pos]);\n-    new_text.push_str(&text[cursor_pos + cursor.len()..]);\n+    new_text.push_str(&text[cursor_pos + CURSOR_MARKER.len()..]);\n     let cursor_pos = TextUnit::from(cursor_pos as u32);\n     Some((cursor_pos, new_text))\n }\n@@ -116,7 +117,22 @@ pub fn parse_fixture(fixture: &str) -> Vec<FixtureEntry> {\n             }\n         };\n     };\n-    for line in fixture.lines() {\n+    let margin = fixture.lines()\n+        .filter(|it| it.trim_start().starts_with(\"//-\"))\n+        .map(|it| it.len() - it.trim_start().len())\n+        .next().expect(\"empty fixture\");\n+    let lines = fixture.lines()\n+        .filter_map(|line| {\n+            if line.len() >= margin {\n+                assert!(line[..margin].trim().is_empty());\n+                Some(&line[margin..])\n+            } else {\n+                assert!(line.trim().is_empty());\n+                None\n+            }\n+        });\n+\n+    for line in lines {\n         if line.starts_with(\"//-\") {\n             flush!();\n             buf.clear();"}]}