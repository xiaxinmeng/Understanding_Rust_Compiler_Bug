{"sha": "39011f8590b69d5ee9037c4ac9b863a516ae2e1e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5MDExZjg1OTBiNjlkNWVlOTAzN2M0YWM5Yjg2M2E1MTZhZTJlMWU=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-03-26T22:35:50Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-03-26T22:37:46Z"}, "message": "fix handling of `self`", "tree": {"sha": "2487608312412d27c187d63c0b38b5f9b301feab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2487608312412d27c187d63c0b38b5f9b301feab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39011f8590b69d5ee9037c4ac9b863a516ae2e1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39011f8590b69d5ee9037c4ac9b863a516ae2e1e", "html_url": "https://github.com/rust-lang/rust/commit/39011f8590b69d5ee9037c4ac9b863a516ae2e1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39011f8590b69d5ee9037c4ac9b863a516ae2e1e/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50728e52455804143e5cc601004381e395a1e2f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/50728e52455804143e5cc601004381e395a1e2f7", "html_url": "https://github.com/rust-lang/rust/commit/50728e52455804143e5cc601004381e395a1e2f7"}], "stats": {"total": 181, "additions": 143, "deletions": 38}, "files": [{"sha": "726c305e903044442f583205ed80bde372d60507", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/39011f8590b69d5ee9037c4ac9b863a516ae2e1e/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39011f8590b69d5ee9037c4ac9b863a516ae2e1e/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=39011f8590b69d5ee9037c4ac9b863a516ae2e1e", "patch": "@@ -907,6 +907,13 @@ impl<'a> LoweringContext<'a> {\n                 FunctionRetTy::Default(span) => hir::DefaultReturn(span),\n             },\n             variadic: decl.variadic,\n+            has_implicit_self: decl.inputs.get(0).map_or(false, |arg| {\n+                match arg.ty.node {\n+                    TyKind::ImplicitSelf => true,\n+                    TyKind::Rptr(_, ref mt) => mt.ty.node == TyKind::ImplicitSelf,\n+                    _ => false\n+                }\n+            })\n         })\n     }\n "}, {"sha": "43b7deb5b90e39fd9178520c1fc77b491a339f7c", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/39011f8590b69d5ee9037c4ac9b863a516ae2e1e/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39011f8590b69d5ee9037c4ac9b863a516ae2e1e/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=39011f8590b69d5ee9037c4ac9b863a516ae2e1e", "patch": "@@ -1379,6 +1379,9 @@ pub struct FnDecl {\n     pub inputs: HirVec<P<Ty>>,\n     pub output: FunctionRetTy,\n     pub variadic: bool,\n+    /// True if this function has an `self`, `&self` or `&mut self` receiver\n+    /// (but not a `self: Xxx` one).\n+    pub has_implicit_self: bool,\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]"}, {"sha": "558a835be188462070f8e145ed6444ecf9d4cbc6", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 31, "deletions": 29, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/39011f8590b69d5ee9037c4ac9b863a516ae2e1e/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39011f8590b69d5ee9037c4ac9b863a516ae2e1e/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=39011f8590b69d5ee9037c4ac9b863a516ae2e1e", "patch": "@@ -42,7 +42,6 @@ use std::fmt;\n use std::rc::Rc;\n use std::hash::{Hash, Hasher};\n use syntax::ast;\n-use syntax::symbol::keywords;\n use syntax_pos::{MultiSpan, Span};\n use errors::DiagnosticBuilder;\n \n@@ -809,32 +808,33 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     }\n \n     /// Given a type, if it is an immutable reference, return a suggestion to make it mutable\n-    fn suggest_mut_for_immutable(&self, pty: &hir::Ty) -> Option<String> {\n+    fn suggest_mut_for_immutable(&self, pty: &hir::Ty, is_implicit_self: bool) -> Option<String> {\n         // Check wether the argument is an immutable reference\n+        debug!(\"suggest_mut_for_immutable({:?}, {:?})\", pty, is_implicit_self);\n         if let hir::TyRptr(lifetime, hir::MutTy {\n             mutbl: hir::Mutability::MutImmutable,\n             ref ty\n         }) = pty.node {\n             // Account for existing lifetimes when generating the message\n-            if !lifetime.is_elided() {\n-                if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(ty.span) {\n-                    if let Ok(lifetime_snippet) = self.tcx.sess.codemap()\n-                        .span_to_snippet(lifetime.span) {\n-                            return Some(format!(\"use `&{} mut {}` here to make mutable\",\n-                                                lifetime_snippet,\n-                                                snippet));\n-                    }\n-                }\n-            } else if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(pty.span) {\n-                if snippet.starts_with(\"&\") {\n-                    return Some(format!(\"use `{}` here to make mutable\",\n-                                        snippet.replace(\"&\", \"&mut \")));\n-                }\n+            let pointee_snippet = match self.tcx.sess.codemap().span_to_snippet(ty.span) {\n+                Ok(snippet) => snippet,\n+                _ => return None\n+            };\n+\n+            let lifetime_snippet = if !lifetime.is_elided() {\n+                format!(\"{} \", match self.tcx.sess.codemap().span_to_snippet(lifetime.span) {\n+                    Ok(lifetime_snippet) => lifetime_snippet,\n+                    _ => return None\n+                })\n             } else {\n-                bug!(\"couldn't find a snippet for span: {:?}\", pty.span);\n-            }\n+                String::new()\n+            };\n+            Some(format!(\"use `&{}mut {}` here to make mutable\",\n+                         lifetime_snippet,\n+                         if is_implicit_self { \"self\" } else { &*pointee_snippet }))\n+        } else {\n+            None\n         }\n-        None\n     }\n \n     fn local_binding_mode(&self, node_id: ast::NodeId) -> hir::BindingMode {\n@@ -849,24 +849,25 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn local_ty(&self, node_id: ast::NodeId) -> Option<&hir::Ty> {\n+    fn local_ty(&self, node_id: ast::NodeId) -> (Option<&hir::Ty>, bool) {\n         let parent = self.tcx.hir.get_parent_node(node_id);\n         let parent_node = self.tcx.hir.get(parent);\n \n         // The parent node is like a fn\n         if let Some(fn_like) = FnLikeNode::from_node(parent_node) {\n             // `nid`'s parent's `Body`\n             let fn_body = self.tcx.hir.body(fn_like.body());\n-            // Get the position of `nid` in the arguments list\n+            // Get the position of `node_id` in the arguments list\n             let arg_pos = fn_body.arguments.iter().position(|arg| arg.pat.id == node_id);\n             if let Some(i) = arg_pos {\n                 // The argument's `Ty`\n-                Some(&fn_like.decl().inputs[i])\n+                (Some(&fn_like.decl().inputs[i]),\n+                 i == 0 && fn_like.decl().has_implicit_self)\n             } else {\n-                None\n+                (None, false)\n             }\n         } else {\n-            None\n+            (None, false)\n         }\n     }\n \n@@ -880,8 +881,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 let let_span = self.tcx.hir.span(node_id);\n                 if let hir::BindingMode::BindByValue(..) = self.local_binding_mode(node_id) {\n                     if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(let_span) {\n-                        if self.tcx.hir.name(node_id) == keywords::SelfValue.name() &&\n-                            snippet != \"self\" {\n+                        let (_, is_implicit_self) = self.local_ty(node_id);\n+                        if is_implicit_self && snippet != \"self\" {\n                             // avoid suggesting `mut &self`.\n                             return\n                         }\n@@ -906,8 +907,9 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         }\n                     }\n                     hir::BindingMode::BindByValue(..) => {\n-                        if let Some(local_ty) = self.local_ty(node_id) {\n-                            if let Some(msg) = self.suggest_mut_for_immutable(local_ty) {\n+                        if let (Some(local_ty), is_implicit_self) = self.local_ty(node_id) {\n+                            if let Some(msg) =\n+                                 self.suggest_mut_for_immutable(local_ty, is_implicit_self) {\n                                 db.span_label(local_ty.span, &msg);\n                             }\n                         }\n@@ -921,7 +923,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 };\n \n                 if let hir_map::Node::NodeField(ref field) = self.tcx.hir.get(node_id) {\n-                    if let Some(msg) = self.suggest_mut_for_immutable(&field.ty) {\n+                    if let Some(msg) = self.suggest_mut_for_immutable(&field.ty, false) {\n                         db.span_label(field.ty.span, &msg);\n                     }\n                 }"}, {"sha": "6331fc5771fcbb218694944e4034efe72e3cdad3", "filename": "src/test/ui/did_you_mean/issue-39544.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/39011f8590b69d5ee9037c4ac9b863a516ae2e1e/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39544.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39011f8590b69d5ee9037c4ac9b863a516ae2e1e/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39544.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39544.rs?ref=39011f8590b69d5ee9037c4ac9b863a516ae2e1e", "patch": "@@ -16,11 +16,37 @@ pub struct Z {\n     x: X\n }\n \n-pub fn main() {\n+fn main() {\n     let z = Z { x: X::Y };\n     let _ = &mut z.x;\n }\n \n+impl Z {\n+    fn foo<'z>(&'z self) {\n+        let _ = &mut self.x;\n+    }\n+\n+    fn foo1(&self, other: &Z) {\n+        let _ = &mut self.x;\n+        let _ = &mut other.x;\n+    }\n+\n+    fn foo2<'a>(&'a self, other: &Z) {\n+        let _ = &mut self.x;\n+        let _ = &mut other.x;\n+    }\n+\n+    fn foo3<'a>(self: &'a Self, other: &Z) {\n+        let _ = &mut self.x;\n+        let _ = &mut other.x;\n+    }\n+\n+    fn foo4(other: &Z) {\n+        let _ = &mut other.x;\n+    }\n+\n+}\n+\n pub fn with_arg(z: Z, w: &Z) {\n     let _ = &mut z.x;\n     let _ = &mut w.x;"}, {"sha": "e1e229a8b05725acb48415d4dc01a566cc60fab4", "filename": "src/test/ui/did_you_mean/issue-39544.stderr", "status": "modified", "additions": 75, "deletions": 8, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/39011f8590b69d5ee9037c4ac9b863a516ae2e1e/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39544.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/39011f8590b69d5ee9037c4ac9b863a516ae2e1e/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39544.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39544.stderr?ref=39011f8590b69d5ee9037c4ac9b863a516ae2e1e", "patch": "@@ -6,22 +6,89 @@ error: cannot borrow immutable field `z.x` as mutable\n 21 |     let _ = &mut z.x;\n    |                  ^^^ cannot mutably borrow immutable field\n \n+error: cannot borrow immutable field `self.x` as mutable\n+  --> $DIR/issue-39544.rs:26:22\n+   |\n+25 |     fn foo<'z>(&'z self) {\n+   |                -------- use `&'z mut self` here to make mutable\n+26 |         let _ = &mut self.x;\n+   |                      ^^^^^^ cannot mutably borrow immutable field\n+\n+error: cannot borrow immutable field `self.x` as mutable\n+  --> $DIR/issue-39544.rs:30:22\n+   |\n+29 |     fn foo1(&self, other: &Z) {\n+   |             ----- use `&mut self` here to make mutable\n+30 |         let _ = &mut self.x;\n+   |                      ^^^^^^ cannot mutably borrow immutable field\n+\n+error: cannot borrow immutable field `other.x` as mutable\n+  --> $DIR/issue-39544.rs:31:22\n+   |\n+29 |     fn foo1(&self, other: &Z) {\n+   |                           -- use `&mut Z` here to make mutable\n+30 |         let _ = &mut self.x;\n+31 |         let _ = &mut other.x;\n+   |                      ^^^^^^^ cannot mutably borrow immutable field\n+\n+error: cannot borrow immutable field `self.x` as mutable\n+  --> $DIR/issue-39544.rs:35:22\n+   |\n+34 |     fn foo2<'a>(&'a self, other: &Z) {\n+   |                 -------- use `&'a mut self` here to make mutable\n+35 |         let _ = &mut self.x;\n+   |                      ^^^^^^ cannot mutably borrow immutable field\n+\n+error: cannot borrow immutable field `other.x` as mutable\n+  --> $DIR/issue-39544.rs:36:22\n+   |\n+34 |     fn foo2<'a>(&'a self, other: &Z) {\n+   |                                  -- use `&mut Z` here to make mutable\n+35 |         let _ = &mut self.x;\n+36 |         let _ = &mut other.x;\n+   |                      ^^^^^^^ cannot mutably borrow immutable field\n+\n+error: cannot borrow immutable field `self.x` as mutable\n+  --> $DIR/issue-39544.rs:40:22\n+   |\n+39 |     fn foo3<'a>(self: &'a Self, other: &Z) {\n+   |                       -------- use `&'a mut Self` here to make mutable\n+40 |         let _ = &mut self.x;\n+   |                      ^^^^^^ cannot mutably borrow immutable field\n+\n+error: cannot borrow immutable field `other.x` as mutable\n+  --> $DIR/issue-39544.rs:41:22\n+   |\n+39 |     fn foo3<'a>(self: &'a Self, other: &Z) {\n+   |                                        -- use `&mut Z` here to make mutable\n+40 |         let _ = &mut self.x;\n+41 |         let _ = &mut other.x;\n+   |                      ^^^^^^^ cannot mutably borrow immutable field\n+\n+error: cannot borrow immutable field `other.x` as mutable\n+  --> $DIR/issue-39544.rs:45:22\n+   |\n+44 |     fn foo4(other: &Z) {\n+   |                    -- use `&mut Z` here to make mutable\n+45 |         let _ = &mut other.x;\n+   |                      ^^^^^^^ cannot mutably borrow immutable field\n+\n error: cannot borrow immutable field `z.x` as mutable\n-  --> $DIR/issue-39544.rs:25:18\n+  --> $DIR/issue-39544.rs:51:18\n    |\n-24 | pub fn with_arg(z: Z, w: &Z) {\n+50 | pub fn with_arg(z: Z, w: &Z) {\n    |                 - consider changing this to `mut z`\n-25 |     let _ = &mut z.x;\n+51 |     let _ = &mut z.x;\n    |                  ^^^ cannot mutably borrow immutable field\n \n error: cannot borrow immutable field `w.x` as mutable\n-  --> $DIR/issue-39544.rs:26:18\n+  --> $DIR/issue-39544.rs:52:18\n    |\n-24 | pub fn with_arg(z: Z, w: &Z) {\n+50 | pub fn with_arg(z: Z, w: &Z) {\n    |                          -- use `&mut Z` here to make mutable\n-25 |     let _ = &mut z.x;\n-26 |     let _ = &mut w.x;\n+51 |     let _ = &mut z.x;\n+52 |     let _ = &mut w.x;\n    |                  ^^^ cannot mutably borrow immutable field\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 11 previous errors\n "}]}