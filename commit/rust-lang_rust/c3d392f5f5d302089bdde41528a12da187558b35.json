{"sha": "c3d392f5f5d302089bdde41528a12da187558b35", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzZDM5MmY1ZjVkMzAyMDg5YmRkZTQxNTI4YTEyZGExODc1NThiMzU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-19T10:03:58Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-22T11:08:39Z"}, "message": "fix validating fat raw pointers", "tree": {"sha": "438bdec5f485a41841da6b85eeefc1398fec8553", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/438bdec5f485a41841da6b85eeefc1398fec8553"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3d392f5f5d302089bdde41528a12da187558b35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3d392f5f5d302089bdde41528a12da187558b35", "html_url": "https://github.com/rust-lang/rust/commit/c3d392f5f5d302089bdde41528a12da187558b35", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3d392f5f5d302089bdde41528a12da187558b35/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49999e9b1d816e1ca7365887fd42422702bc46cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/49999e9b1d816e1ca7365887fd42422702bc46cb", "html_url": "https://github.com/rust-lang/rust/commit/49999e9b1d816e1ca7365887fd42422702bc46cb"}], "stats": {"total": 43, "additions": 25, "deletions": 18}, "files": [{"sha": "1f6e10913aad1d2a6e555afd27797eb8202e905e", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 25, "deletions": 18, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/c3d392f5f5d302089bdde41528a12da187558b35/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3d392f5f5d302089bdde41528a12da187558b35/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=c3d392f5f5d302089bdde41528a12da187558b35", "patch": "@@ -226,6 +226,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         // Validate all fields\n         match dest.layout.fields {\n             // primitives are unions with zero fields\n+            // FIXME: Use some other indicator instead, like `layout.abi`.\n             layout::FieldPlacement::Union(0) => {\n                 match dest.layout.abi {\n                     // nothing to do, whatever the pointer points to, it is never going to be read\n@@ -277,41 +278,47 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 }\n             },\n             layout::FieldPlacement::Arbitrary { ref offsets, .. } => {\n-                // fat pointers need special treatment\n-                match dest.layout.ty.builtin_deref(false).map(|tam| &tam.ty.sty) {\n+                // Fat pointers need special treatment.\n+                match dest.layout.ty.builtin_deref(true).map(|tam| &tam.ty.sty) {\n                     | Some(ty::TyStr)\n                     | Some(ty::TySlice(_)) => {\n-                        // check the length (for nicer error messages)\n+                        // check the length (for nicer error messages); must be valid even\n+                        // for a raw pointer.\n                         let len_mplace = self.mplace_field(dest, 1)?;\n                         let len = self.read_scalar(len_mplace.into())?;\n                         let len = match len.to_bits(len_mplace.layout.size) {\n                             Err(_) => return validation_failure!(\"length is not a valid integer\", path),\n                             Ok(len) => len as u64,\n                         };\n-                        // get the fat ptr, and recursively check it\n-                        let ptr = self.ref_to_mplace(self.read_value(dest.into())?)?;\n-                        assert_eq!(ptr.extra, PlaceExtra::Length(len));\n-                        let unpacked_ptr = self.unpack_unsized_mplace(ptr)?;\n-                        if seen.insert(unpacked_ptr) {\n-                            todo.push((unpacked_ptr, path_clone_and_deref(path)));\n+                        // for safe ptrs, get the fat ptr, and recursively check it\n+                        if !dest.layout.ty.is_unsafe_ptr() {\n+                            let ptr = self.ref_to_mplace(self.read_value(dest.into())?)?;\n+                            assert_eq!(ptr.extra, PlaceExtra::Length(len));\n+                            let unpacked_ptr = self.unpack_unsized_mplace(ptr)?;\n+                            if seen.insert(unpacked_ptr) {\n+                                todo.push((unpacked_ptr, path_clone_and_deref(path)));\n+                            }\n                         }\n                     },\n                     Some(ty::TyDynamic(..)) => {\n-                        // check the vtable (for nicer error messages)\n+                        // check the vtable (for nicer error messages); must be valid even for a\n+                        // raw ptr.\n                         let vtable = self.read_scalar(self.mplace_field(dest, 1)?.into())?;\n                         let vtable = match vtable.to_ptr() {\n                             Err(_) => return validation_failure!(\"vtable address is not a pointer\", path),\n                             Ok(vtable) => vtable,\n                         };\n-                        // get the fat ptr, and recursively check it\n-                        let ptr = self.ref_to_mplace(self.read_value(dest.into())?)?;\n-                        assert_eq!(ptr.extra, PlaceExtra::Vtable(vtable));\n-                        let unpacked_ptr = self.unpack_unsized_mplace(ptr)?;\n-                        if seen.insert(unpacked_ptr) {\n-                            todo.push((unpacked_ptr, path_clone_and_deref(path)));\n+                        // for safe ptrs, get the fat ptr, and recursively check it\n+                        if !dest.layout.ty.is_unsafe_ptr() {\n+                            let ptr = self.ref_to_mplace(self.read_value(dest.into())?)?;\n+                            assert_eq!(ptr.extra, PlaceExtra::Vtable(vtable));\n+                            let unpacked_ptr = self.unpack_unsized_mplace(ptr)?;\n+                            if seen.insert(unpacked_ptr) {\n+                                todo.push((unpacked_ptr, path_clone_and_deref(path)));\n+                            }\n+                            // FIXME: More checks for the vtable... making sure it is exactly\n+                            // the one one would expect for this type.\n                         }\n-                        // FIXME: More checks for the vtable... making sure it is exactly\n-                        // the one one would expect for this type.\n                     },\n                     Some(ty) =>\n                         bug!(\"Unexpected fat pointer target type {:?}\", ty),"}]}