{"sha": "2f1bfd6399cfe439fbf2e446beafa5c55d1bb843", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmMWJmZDYzOTljZmU0MzlmYmYyZTQ0NmJlYWZhNWM1NWQxYmI4NDM=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-09-17T04:03:00Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-09-17T04:28:31Z"}, "message": "Preserve doc-comments when generating queries\n\nThis also changes some comments into doc-comments.", "tree": {"sha": "b8eea50b6d6c036ea0df583f76d127aa3807ed49", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8eea50b6d6c036ea0df583f76d127aa3807ed49"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f1bfd6399cfe439fbf2e446beafa5c55d1bb843", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f1bfd6399cfe439fbf2e446beafa5c55d1bb843", "html_url": "https://github.com/rust-lang/rust/commit/2f1bfd6399cfe439fbf2e446beafa5c55d1bb843", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f1bfd6399cfe439fbf2e446beafa5c55d1bb843/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5fae56971d8487088c0099c82c0a5ce1638b5f62", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fae56971d8487088c0099c82c0a5ce1638b5f62", "html_url": "https://github.com/rust-lang/rust/commit/5fae56971d8487088c0099c82c0a5ce1638b5f62"}], "stats": {"total": 77, "additions": 43, "deletions": 34}, "files": [{"sha": "204e8e800cd48299a8dc9b975bafbdfe95fee740", "filename": "compiler/rustc_macros/src/query.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bfd6399cfe439fbf2e446beafa5c55d1bb843/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bfd6399cfe439fbf2e446beafa5c55d1bb843/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fquery.rs?ref=2f1bfd6399cfe439fbf2e446beafa5c55d1bb843", "patch": "@@ -5,8 +5,8 @@ use syn::parse::{Parse, ParseStream, Result};\n use syn::punctuated::Punctuated;\n use syn::spanned::Spanned;\n use syn::{\n-    braced, parenthesized, parse_macro_input, Attribute, Block, Error, Expr, Ident, ReturnType,\n-    Token, Type,\n+    braced, parenthesized, parse_macro_input, AttrStyle, Attribute, Block, Error, Expr, Ident,\n+    ReturnType, Token, Type,\n };\n \n #[allow(non_camel_case_types)]\n@@ -128,17 +128,25 @@ impl Parse for QueryModifier {\n }\n \n /// Ensures only doc comment attributes are used\n-fn check_attributes(attrs: Vec<Attribute>) -> Result<()> {\n-    for attr in attrs {\n+fn check_attributes(attrs: Vec<Attribute>) -> Result<Vec<Attribute>> {\n+    let inner = |attr: Attribute| {\n         if !attr.path.is_ident(\"doc\") {\n-            return Err(Error::new(attr.span(), \"attributes not supported on queries\"));\n+            Err(Error::new(attr.span(), \"attributes not supported on queries\"))\n+        } else if attr.style != AttrStyle::Outer {\n+            Err(Error::new(\n+                attr.span(),\n+                \"attributes must be outer attributes (`///`), not inner attributes\",\n+            ))\n+        } else {\n+            Ok(attr)\n         }\n-    }\n-    Ok(())\n+    };\n+    attrs.into_iter().map(inner).collect()\n }\n \n /// A compiler query. `query ... { ... }`\n struct Query {\n+    doc_comments: Vec<Attribute>,\n     modifiers: List<QueryModifier>,\n     name: Ident,\n     key: IdentOrWild,\n@@ -148,7 +156,7 @@ struct Query {\n \n impl Parse for Query {\n     fn parse(input: ParseStream<'_>) -> Result<Self> {\n-        check_attributes(input.call(Attribute::parse_outer)?)?;\n+        let doc_comments = check_attributes(input.call(Attribute::parse_outer)?)?;\n \n         // Parse the query declaration. Like `query type_of(key: DefId) -> Ty<'tcx>`\n         input.parse::<kw::query>()?;\n@@ -165,7 +173,7 @@ impl Parse for Query {\n         braced!(content in input);\n         let modifiers = content.parse()?;\n \n-        Ok(Query { modifiers, name, key, arg, result })\n+        Ok(Query { doc_comments, modifiers, name, key, arg, result })\n     }\n }\n \n@@ -476,9 +484,10 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n             };\n \n             let attribute_stream = quote! {#(#attributes),*};\n-\n+            let doc_comments = query.doc_comments.iter();\n             // Add the query to the group\n             group_stream.extend(quote! {\n+                #(#doc_comments)*\n                 [#attribute_stream] fn #name: #name(#arg) #result,\n             });\n "}, {"sha": "6a54d917694605eaaf668e82896013a6710ef83c", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bfd6399cfe439fbf2e446beafa5c55d1bb843/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bfd6399cfe439fbf2e446beafa5c55d1bb843/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=2f1bfd6399cfe439fbf2e446beafa5c55d1bb843", "patch": "@@ -42,48 +42,48 @@ rustc_queries! {\n     }\n \n     Other {\n-        // Represents crate as a whole (as distinct from the top-level crate module).\n-        // If you call `hir_crate` (e.g., indirectly by calling `tcx.hir().krate()`),\n-        // we will have to assume that any change means that you need to be recompiled.\n-        // This is because the `hir_crate` query gives you access to all other items.\n-        // To avoid this fate, do not call `tcx.hir().krate()`; instead,\n-        // prefer wrappers like `tcx.visit_all_items_in_krate()`.\n+        /// Represents crate as a whole (as distinct from the top-level crate module).\n+        /// If you call `hir_crate` (e.g., indirectly by calling `tcx.hir().krate()`),\n+        /// we will have to assume that any change means that you need to be recompiled.\n+        /// This is because the `hir_crate` query gives you access to all other items.\n+        /// To avoid this fate, do not call `tcx.hir().krate()`; instead,\n+        /// prefer wrappers like `tcx.visit_all_items_in_krate()`.\n         query hir_crate(key: CrateNum) -> &'tcx Crate<'tcx> {\n             eval_always\n             no_hash\n             desc { \"get the crate HIR\" }\n         }\n \n-        // The indexed HIR. This can be conveniently accessed by `tcx.hir()`.\n-        // Avoid calling this query directly.\n+        /// The indexed HIR. This can be conveniently accessed by `tcx.hir()`.\n+        /// Avoid calling this query directly.\n         query index_hir(_: CrateNum) -> &'tcx map::IndexedHir<'tcx> {\n             eval_always\n             no_hash\n             desc { \"index HIR\" }\n         }\n \n-        // The items in a module.\n-        //\n-        // This can be conveniently accessed by `tcx.hir().visit_item_likes_in_module`.\n-        // Avoid calling this query directly.\n+        /// The items in a module.\n+        ///\n+        /// This can be conveniently accessed by `tcx.hir().visit_item_likes_in_module`.\n+        /// Avoid calling this query directly.\n         query hir_module_items(key: LocalDefId) -> &'tcx hir::ModuleItems {\n             eval_always\n             desc { |tcx| \"HIR module items in `{}`\", tcx.def_path_str(key.to_def_id()) }\n         }\n \n-        // Gives access to the HIR node for the HIR owner `key`.\n-        //\n-        // This can be conveniently accessed by methods on `tcx.hir()`.\n-        // Avoid calling this query directly.\n+        /// Gives access to the HIR node for the HIR owner `key`.\n+        ///\n+        /// This can be conveniently accessed by methods on `tcx.hir()`.\n+        /// Avoid calling this query directly.\n         query hir_owner(key: LocalDefId) -> Option<&'tcx crate::hir::Owner<'tcx>> {\n             eval_always\n             desc { |tcx| \"HIR owner of `{}`\", tcx.def_path_str(key.to_def_id()) }\n         }\n \n-        // Gives access to the HIR nodes and bodies inside the HIR owner `key`.\n-        //\n-        // This can be conveniently accessed by methods on `tcx.hir()`.\n-        // Avoid calling this query directly.\n+        /// Gives access to the HIR nodes and bodies inside the HIR owner `key`.\n+        ///\n+        /// This can be conveniently accessed by methods on `tcx.hir()`.\n+        /// Avoid calling this query directly.\n         query hir_owner_nodes(key: LocalDefId) -> Option<&'tcx crate::hir::OwnerNodes<'tcx>> {\n             eval_always\n             desc { |tcx| \"HIR owner items in `{}`\", tcx.def_path_str(key.to_def_id()) }\n@@ -305,9 +305,9 @@ rustc_queries! {\n     }\n \n     TypeChecking {\n-        // Erases regions from `ty` to yield a new type.\n-        // Normally you would just use `tcx.erase_regions(&value)`,\n-        // however, which uses this query as a kind of cache.\n+        /// Erases regions from `ty` to yield a new type.\n+        /// Normally you would just use `tcx.erase_regions(&value)`,\n+        /// however, which uses this query as a kind of cache.\n         query erase_regions_ty(ty: Ty<'tcx>) -> Ty<'tcx> {\n             // This query is not expected to have input -- as a result, it\n             // is not a good candidates for \"replay\" because it is essentially a\n@@ -1514,7 +1514,7 @@ rustc_queries! {\n             desc { \"looking up supported target features\" }\n         }\n \n-        // Get an estimate of the size of an InstanceDef based on its MIR for CGU partitioning.\n+        /// Get an estimate of the size of an InstanceDef based on its MIR for CGU partitioning.\n         query instance_def_size_estimate(def: ty::InstanceDef<'tcx>)\n             -> usize {\n             desc { |tcx| \"estimating size for `{}`\", tcx.def_path_str(def.def_id()) }"}]}