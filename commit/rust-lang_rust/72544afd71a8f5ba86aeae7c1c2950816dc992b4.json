{"sha": "72544afd71a8f5ba86aeae7c1c2950816dc992b4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyNTQ0YWZkNzFhOGY1YmE4NmFlYWU3YzFjMjk1MDgxNmRjOTkyYjQ=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-10-02T04:21:34Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-10-02T06:07:49Z"}, "message": "Record macro import site spans.", "tree": {"sha": "fe9b7f97bb182928ded8df5fa79756241d091779", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe9b7f97bb182928ded8df5fa79756241d091779"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/72544afd71a8f5ba86aeae7c1c2950816dc992b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/72544afd71a8f5ba86aeae7c1c2950816dc992b4", "html_url": "https://github.com/rust-lang/rust/commit/72544afd71a8f5ba86aeae7c1c2950816dc992b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/72544afd71a8f5ba86aeae7c1c2950816dc992b4/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1817ca46865a4aa53fa74b139bfb941581029ff8", "url": "https://api.github.com/repos/rust-lang/rust/commits/1817ca46865a4aa53fa74b139bfb941581029ff8", "html_url": "https://github.com/rust-lang/rust/commit/1817ca46865a4aa53fa74b139bfb941581029ff8"}], "stats": {"total": 65, "additions": 40, "deletions": 25}, "files": [{"sha": "be91b86dbcc95738b5479d5339371dc535819870", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/72544afd71a8f5ba86aeae7c1c2950816dc992b4/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72544afd71a8f5ba86aeae7c1c2950816dc992b4/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=72544afd71a8f5ba86aeae7c1c2950816dc992b4", "patch": "@@ -423,7 +423,12 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn metadata_encoding_version(&self) -> &[u8] { bug!(\"metadata_encoding_version\") }\n }\n \n-pub enum LoadedMacro {\n+pub struct LoadedMacro {\n+    pub import_site: Span,\n+    pub kind: LoadedMacroKind,\n+}\n+\n+pub enum LoadedMacroKind {\n     Def(ast::MacroDef),\n     CustomDerive(String, Rc<MultiItemModifier>),\n }"}, {"sha": "385f582e2d36b84f0d0b1da715e8a55163415d5a", "filename": "src/librustc_metadata/macro_import.rs", "status": "modified", "additions": 30, "deletions": 20, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/72544afd71a8f5ba86aeae7c1c2950816dc992b4/src%2Flibrustc_metadata%2Fmacro_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72544afd71a8f5ba86aeae7c1c2950816dc992b4/src%2Flibrustc_metadata%2Fmacro_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fmacro_import.rs?ref=72544afd71a8f5ba86aeae7c1c2950816dc992b4", "patch": "@@ -18,7 +18,7 @@ use std::mem;\n use creader::{CrateLoader, Macros};\n \n use rustc::hir::def_id::DefIndex;\n-use rustc::middle::cstore::LoadedMacro;\n+use rustc::middle::cstore::{LoadedMacro, LoadedMacroKind};\n use rustc::session::Session;\n use rustc::util::nodemap::FnvHashMap;\n use rustc_back::dynamic_lib::DynamicLibrary;\n@@ -28,14 +28,19 @@ use syntax::ast;\n use syntax::attr;\n use syntax::parse::token;\n use syntax_ext::deriving::custom::CustomDerive;\n-use syntax_pos::Span;\n+use syntax_pos::{Span, DUMMY_SP};\n \n pub fn call_bad_macro_reexport(a: &Session, b: Span) {\n     span_err!(a, b, E0467, \"bad macro reexport\");\n }\n \n pub type MacroSelection = FnvHashMap<token::InternedString, Span>;\n \n+enum ImportSelection {\n+    All(Span),\n+    Some(MacroSelection),\n+}\n+\n pub fn load_macros(loader: &mut CrateLoader, extern_crate: &ast::Item, allows_macros: bool)\n                    -> Vec<LoadedMacro> {\n     loader.load_crate(extern_crate, allows_macros)\n@@ -46,7 +51,7 @@ impl<'a> CrateLoader<'a> {\n                   extern_crate: &ast::Item,\n                   allows_macros: bool) -> Vec<LoadedMacro> {\n         // Parse the attributes relating to macros.\n-        let mut import = Some(FnvHashMap());  // None => load all\n+        let mut import = ImportSelection::Some(FnvHashMap());\n         let mut reexport = FnvHashMap();\n \n         for attr in &extern_crate.attrs {\n@@ -55,11 +60,9 @@ impl<'a> CrateLoader<'a> {\n                 \"macro_use\" => {\n                     let names = attr.meta_item_list();\n                     if names.is_none() {\n-                        // no names => load all\n-                        import = None;\n-                    }\n-                    if let (Some(sel), Some(names)) = (import.as_mut(), names) {\n-                        for attr in names {\n+                        import = ImportSelection::All(attr.span);\n+                    } else if let ImportSelection::Some(ref mut sel) = import {\n+                        for attr in names.unwrap() {\n                             if let Some(word) = attr.word() {\n                                 sel.insert(word.name().clone(), attr.span());\n                             } else {\n@@ -98,10 +101,10 @@ impl<'a> CrateLoader<'a> {\n     fn load_macros<'b>(&mut self,\n                        vi: &ast::Item,\n                        allows_macros: bool,\n-                       import: Option<MacroSelection>,\n+                       import: ImportSelection,\n                        reexport: MacroSelection)\n                        -> Vec<LoadedMacro> {\n-        if let Some(sel) = import.as_ref() {\n+        if let ImportSelection::Some(ref sel) = import {\n             if sel.is_empty() && reexport.is_empty() {\n                 return Vec::new();\n             }\n@@ -120,15 +123,19 @@ impl<'a> CrateLoader<'a> {\n         for mut def in macros.macro_rules.drain(..) {\n             let name = def.ident.name.as_str();\n \n-            def.use_locally = match import.as_ref() {\n-                None => true,\n-                Some(sel) => sel.contains_key(&name),\n+            let import_site = match import {\n+                ImportSelection::All(span) => Some(span),\n+                ImportSelection::Some(ref sel) => sel.get(&name).cloned()\n             };\n+            def.use_locally = import_site.is_some();\n             def.export = reexport.contains_key(&name);\n             def.allow_internal_unstable = attr::contains_name(&def.attrs,\n                                                               \"allow_internal_unstable\");\n             debug!(\"load_macros: loaded: {:?}\", def);\n-            ret.push(LoadedMacro::Def(def));\n+            ret.push(LoadedMacro {\n+                kind: LoadedMacroKind::Def(def),\n+                import_site: import_site.unwrap_or(DUMMY_SP),\n+            });\n             seen.insert(name);\n         }\n \n@@ -137,7 +144,7 @@ impl<'a> CrateLoader<'a> {\n             // exported macros, enforced elsewhere\n             assert_eq!(ret.len(), 0);\n \n-            if import.is_some() {\n+            if let ImportSelection::Some(..) = import {\n                 self.sess.span_err(vi.span, \"`rustc-macro` crates cannot be \\\n                                              selectively imported from, must \\\n                                              use `#[macro_use]`\");\n@@ -151,10 +158,10 @@ impl<'a> CrateLoader<'a> {\n             self.load_derive_macros(vi.span, &macros, index, &mut ret);\n         }\n \n-        if let Some(sel) = import.as_ref() {\n+        if let ImportSelection::Some(sel) = import {\n             for (name, span) in sel {\n                 if !seen.contains(&name) {\n-                    span_err!(self.sess, *span, E0469,\n+                    span_err!(self.sess, span, E0469,\n                               \"imported macro not found\");\n                 }\n             }\n@@ -199,18 +206,21 @@ impl<'a> CrateLoader<'a> {\n             mem::transmute::<*mut u8, fn(&mut Registry)>(sym)\n         };\n \n-        struct MyRegistrar<'a>(&'a mut Vec<LoadedMacro>);\n+        struct MyRegistrar<'a>(&'a mut Vec<LoadedMacro>, Span);\n \n         impl<'a> Registry for MyRegistrar<'a> {\n             fn register_custom_derive(&mut self,\n                                       trait_name: &str,\n                                       expand: fn(TokenStream) -> TokenStream) {\n                 let derive = Rc::new(CustomDerive::new(expand));\n-                self.0.push(LoadedMacro::CustomDerive(trait_name.to_string(), derive));\n+                self.0.push(LoadedMacro {\n+                    kind: LoadedMacroKind::CustomDerive(trait_name.to_string(), derive),\n+                    import_site: self.1,\n+                });\n             }\n         }\n \n-        registrar(&mut MyRegistrar(ret));\n+        registrar(&mut MyRegistrar(ret, span));\n \n         // Intentionally leak the dynamic library. We can't ever unload it\n         // since the library can make things that will live arbitrarily long."}, {"sha": "daf6a280ac0a6f765016ce968b092d8fbb464701", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/72544afd71a8f5ba86aeae7c1c2950816dc992b4/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72544afd71a8f5ba86aeae7c1c2950816dc992b4/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=72544afd71a8f5ba86aeae7c1c2950816dc992b4", "patch": "@@ -20,7 +20,7 @@ use {NameBinding, NameBindingKind, ToNameBinding};\n use Resolver;\n use {resolve_error, resolve_struct_error, ResolutionError};\n \n-use rustc::middle::cstore::LoadedMacro;\n+use rustc::middle::cstore::LoadedMacroKind;\n use rustc::hir::def::*;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::hir::map::DefPathData;\n@@ -189,9 +189,9 @@ impl<'b> Resolver<'b> {\n                 // crate root, because `$crate` won't work properly.\n                 let is_crate_root = self.current_module.parent.is_none();\n                 for def in self.crate_loader.load_macros(item, is_crate_root) {\n-                    match def {\n-                        LoadedMacro::Def(def) => self.add_macro(Mark::root(), def),\n-                        LoadedMacro::CustomDerive(name, ext) => {\n+                    match def.kind {\n+                        LoadedMacroKind::Def(def) => self.add_macro(Mark::root(), def),\n+                        LoadedMacroKind::CustomDerive(name, ext) => {\n                             self.insert_custom_derive(&name, ext, item.span);\n                         }\n                     }"}]}