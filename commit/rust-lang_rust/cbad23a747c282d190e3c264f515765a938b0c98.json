{"sha": "cbad23a747c282d190e3c264f515765a938b0c98", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiYWQyM2E3NDdjMjgyZDE5MGUzYzI2NGY1MTU3NjVhOTM4YjBjOTg=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-27T08:16:40Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-27T22:54:46Z"}, "message": "Convert pretty-printer to istrs. Issue #855", "tree": {"sha": "46d099b26e2a3865e8c53afc345bfc37a63f22ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46d099b26e2a3865e8c53afc345bfc37a63f22ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cbad23a747c282d190e3c264f515765a938b0c98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cbad23a747c282d190e3c264f515765a938b0c98", "html_url": "https://github.com/rust-lang/rust/commit/cbad23a747c282d190e3c264f515765a938b0c98", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cbad23a747c282d190e3c264f515765a938b0c98/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "675073c26615896350034c1e07fa39b6b99cf58d", "url": "https://api.github.com/repos/rust-lang/rust/commits/675073c26615896350034c1e07fa39b6b99cf58d", "html_url": "https://github.com/rust-lang/rust/commit/675073c26615896350034c1e07fa39b6b99cf58d"}], "stats": {"total": 765, "additions": 395, "deletions": 370}, "files": [{"sha": "09b4bbe69c367a0738172e00e32acaf352d15e1b", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbad23a747c282d190e3c264f515765a938b0c98/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbad23a747c282d190e3c264f515765a938b0c98/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=cbad23a747c282d190e3c264f515765a938b0c98", "patch": "@@ -347,7 +347,7 @@ fn build_link_meta(sess: &session::session, c: &ast::crate, output: &istr,\n         }\n \n         fn len_and_str_lit(l: &ast::lit) -> istr {\n-            ret len_and_str(istr::from_estr(pprust::lit_to_str(@l)));\n+            ret len_and_str(pprust::lit_to_str(@l));\n         }\n \n         let cmh_items = attr::sort_meta_items(metas.cmh_items);"}, {"sha": "eb6c63fd295a2aedb3b299c33ae1f5e255283b13", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cbad23a747c282d190e3c264f515765a938b0c98/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbad23a747c282d190e3c264f515765a938b0c98/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=cbad23a747c282d190e3c264f515765a938b0c98", "patch": "@@ -185,11 +185,11 @@ fn pretty_print_input(sess: session::session, cfg: ast::crate_cfg, input: str,\n         alt node {\n           pprust::node_expr(s, expr) {\n             pp::space(s.s);\n-            pp::word(s.s, \"as\");\n+            pp::word(s.s, ~\"as\");\n             pp::space(s.s);\n             pp::word(\n                 s.s,\n-                istr::to_estr(ppaux::ty_to_str(tcx, ty::expr_ty(tcx, expr))));\n+                ppaux::ty_to_str(tcx, ty::expr_ty(tcx, expr)));\n             pprust::pclose(s);\n           }\n           _ { }\n@@ -200,17 +200,17 @@ fn pretty_print_input(sess: session::session, cfg: ast::crate_cfg, input: str,\n           pprust::node_item(s, item) {\n             pp::space(s.s);\n             pprust::synth_comment(\n-                s, istr::to_estr(int::to_str(item.id, 10u)));\n+                s, int::to_str(item.id, 10u));\n           }\n           pprust::node_block(s, blk) {\n             pp::space(s.s);\n             pprust::synth_comment(\n-                s, istr::to_estr(~\"block \" + int::to_str(blk.node.id, 10u)));\n+                s, ~\"block \" + int::to_str(blk.node.id, 10u));\n           }\n           pprust::node_expr(s, expr) {\n             pp::space(s.s);\n             pprust::synth_comment(\n-                s, istr::to_estr(int::to_str(expr.id, 10u)));\n+                s, int::to_str(expr.id, 10u));\n             pprust::pclose(s);\n           }\n           _ { }\n@@ -246,7 +246,8 @@ fn pretty_print_input(sess: session::session, cfg: ast::crate_cfg, input: str,\n       }\n       ppm_normal. { ann = pprust::no_ann(); }\n     }\n-    pprust::print_crate(sess.get_codemap(), crate, input,\n+    pprust::print_crate(sess.get_codemap(), crate,\n+                        istr::from_estr(input),\n                         io::string_reader(istr::from_estr(src)),\n                         io::stdout(), ann);\n }"}, {"sha": "cb7a196f75b61fa62b4afdb6016d0069fc005b3c", "filename": "src/comp/front/attr.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cbad23a747c282d190e3c264f515765a938b0c98/src%2Fcomp%2Ffront%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbad23a747c282d190e3c264f515765a938b0c98/src%2Fcomp%2Ffront%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fattr.rs?ref=cbad23a747c282d190e3c264f515765a938b0c98", "patch": "@@ -125,10 +125,12 @@ fn eq(a: @ast::meta_item, b: @ast::meta_item) -> bool {\n \n fn contains(haystack: &[@ast::meta_item], needle: @ast::meta_item) -> bool {\n     log #fmt[\"looking for %s\",\n-             syntax::print::pprust::meta_item_to_str(*needle)];\n+             istr::to_estr(\n+                 syntax::print::pprust::meta_item_to_str(*needle))];\n     for item: @ast::meta_item in haystack {\n         log #fmt[\"looking in %s\",\n-                 syntax::print::pprust::meta_item_to_str(*item)];\n+                 istr::to_estr(\n+                     syntax::print::pprust::meta_item_to_str(*item))];\n         if eq(item, needle) { log \"found it!\"; ret true; }\n     }\n     log \"found it not :(\";"}, {"sha": "b2c7b200babea3c9f44813138df6db030db66737", "filename": "src/comp/front/test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cbad23a747c282d190e3c264f515765a938b0c98/src%2Fcomp%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbad23a747c282d190e3c264f515765a938b0c98/src%2Fcomp%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftest.rs?ref=cbad23a747c282d190e3c264f515765a938b0c98", "patch": "@@ -167,7 +167,8 @@ fn mk_test_module(cx: &test_ctxt) -> @ast::item {\n          node: item_,\n          span: dummy_sp()};\n \n-    log #fmt[\"Synthetic test module:\\n%s\\n\", pprust::item_to_str(@item)];\n+    log #fmt[\"Synthetic test module:\\n%s\\n\",\n+             istr::to_estr(pprust::item_to_str(@item))];\n \n     ret @item;\n }"}, {"sha": "5f8923692f553f28cb6df7c873034d840bcd0971", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cbad23a747c282d190e3c264f515765a938b0c98/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbad23a747c282d190e3c264f515765a938b0c98/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=cbad23a747c282d190e3c264f515765a938b0c98", "patch": "@@ -105,7 +105,8 @@ fn metadata_matches(crate_data: &@[u8], metas: &[@ast::meta_item]) -> bool {\n \n     for needed: @ast::meta_item in metas {\n         if !attr::contains(linkage_metas, needed) {\n-            log #fmt[\"missing %s\", pprust::meta_item_to_str(*needed)];\n+            log #fmt[\"missing %s\",\n+                     istr::to_estr(pprust::meta_item_to_str(*needed))];\n             ret false;\n         }\n     }"}, {"sha": "a1ab2a521c4bd541a18a6eaf0b77bc711a252974", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cbad23a747c282d190e3c264f515765a938b0c98/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbad23a747c282d190e3c264f515765a938b0c98/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=cbad23a747c282d190e3c264f515765a938b0c98", "patch": "@@ -349,7 +349,9 @@ fn get_attributes(md: &ebml::doc) -> [ast::attribute] {\n fn list_meta_items(meta_items: &ebml::doc, out: io::writer) {\n     for mi: @ast::meta_item in get_meta_items(meta_items) {\n         out.write_str(\n-            istr::from_estr(#fmt[\"%s\\n\", pprust::meta_item_to_str(*mi)]));\n+            istr::from_estr(\n+                #fmt[\"%s\\n\",\n+                     istr::to_estr(pprust::meta_item_to_str(*mi))]));\n     }\n }\n \n@@ -358,7 +360,9 @@ fn list_crate_attributes(md: &ebml::doc, out: io::writer) {\n \n     for attr: ast::attribute in get_attributes(md) {\n         out.write_str(\n-            istr::from_estr(#fmt[\"%s\\n\", pprust::attribute_to_str(attr)]));\n+            istr::from_estr(\n+                #fmt[\"%s\\n\",\n+                     istr::to_estr(pprust::attribute_to_str(attr))]));\n     }\n \n     out.write_str(~\"\\n\\n\");"}, {"sha": "fe010f589bf46a4e182890050b80e0ed2cb785c1", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cbad23a747c282d190e3c264f515765a938b0c98/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbad23a747c282d190e3c264f515765a938b0c98/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=cbad23a747c282d190e3c264f515765a938b0c98", "patch": "@@ -235,7 +235,7 @@ fn enc_ty_fn(w: &io::writer, cx: &@ctxt, args: &[ty::arg], out: ty::t,\n \n // FIXME less copy-and-paste\n fn enc_constr(w: &io::writer, cx: &@ctxt, c: &@ty::constr) {\n-    w.write_str(istr::from_estr(path_to_str(c.node.path)));\n+    w.write_str(path_to_str(c.node.path));\n     w.write_char('(');\n     w.write_str(cx.ds(c.node.id));\n     w.write_char('|');\n@@ -246,15 +246,15 @@ fn enc_constr(w: &io::writer, cx: &@ctxt, c: &@ty::constr) {\n           carg_base. { w.write_char('*'); }\n           carg_ident(i) { w.write_uint(i); }\n           carg_lit(l) {\n-            w.write_str(istr::from_estr(lit_to_str(l)));\n+            w.write_str(lit_to_str(l));\n           }\n         }\n     }\n     w.write_char(')');\n }\n \n fn enc_ty_constr(w: &io::writer, cx: &@ctxt, c: &@ty::type_constr) {\n-    w.write_str(istr::from_estr(path_to_str(c.node.path)));\n+    w.write_str(path_to_str(c.node.path));\n     w.write_char('(');\n     w.write_str(cx.ds(c.node.id));\n     w.write_char('|');\n@@ -264,9 +264,9 @@ fn enc_ty_constr(w: &io::writer, cx: &@ctxt, c: &@ty::type_constr) {\n         alt a.node {\n           carg_base. { w.write_char('*'); }\n           carg_ident(p) {\n-            w.write_str(istr::from_estr(path_to_str(p))); }\n+            w.write_str(path_to_str(p)); }\n           carg_lit(l) {\n-            w.write_str(istr::from_estr(lit_to_str(l))); }\n+            w.write_str(lit_to_str(l)); }\n         }\n     }\n     w.write_char(')');"}, {"sha": "879a1f15dcc251642985dc7ad094b0f4f4284fe5", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbad23a747c282d190e3c264f515765a938b0c98/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbad23a747c282d190e3c264f515765a938b0c98/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=cbad23a747c282d190e3c264f515765a938b0c98", "patch": "@@ -451,7 +451,7 @@ fn resolve_constr(e: @env, c: &@ast::constr, sc: &scopes, _v: &vt<scopes>) {\n           _ {\n             e.sess.span_err(c.span,\n                             \"Non-predicate in constraint: \" +\n-                                path_to_str(c.node.path));\n+                            istr::to_estr(path_to_str(c.node.path)));\n           }\n         }\n     }"}, {"sha": "fa5b25e37550739c15d78a9ef7f17eea0e2c67f2", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbad23a747c282d190e3c264f515765a938b0c98/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbad23a747c282d190e3c264f515765a938b0c98/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=cbad23a747c282d190e3c264f515765a938b0c98", "patch": "@@ -4602,7 +4602,7 @@ fn trans_log(lvl: int, cx: &@block_ctxt, e: &@ast::expr) -> result {\n \n fn trans_check_expr(cx: &@block_ctxt, e: &@ast::expr, s: &istr) -> result {\n     let cond_res = trans_expr(cx, e);\n-    let expr_str = s + ~\" \" + istr::from_estr(expr_to_str(e)) + ~\" failed\";\n+    let expr_str = s + ~\" \" + expr_to_str(e) + ~\" failed\";\n     let fail_cx = new_sub_block_ctxt(cx, ~\"fail\");\n     trans_fail(fail_cx, some::<span>(e.span), expr_str);\n     let next_cx = new_sub_block_ctxt(cx, ~\"next\");"}, {"sha": "ecf775524e354e61e2f783c841e2731ae7b11c2a", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cbad23a747c282d190e3c264f515765a938b0c98/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbad23a747c282d190e3c264f515765a938b0c98/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=cbad23a747c282d190e3c264f515765a938b0c98", "patch": "@@ -68,7 +68,7 @@ fn comma_str(args: &[@constr_arg_use]) -> istr {\n         alt a.node {\n           carg_base. { rslt += ~\"*\"; }\n           carg_ident(i) { rslt += i.ident; }\n-          carg_lit(l) { rslt += istr::from_estr(lit_to_str(l)); }\n+          carg_lit(l) { rslt += lit_to_str(l); }\n         }\n     }\n     ret rslt;\n@@ -81,7 +81,7 @@ fn constraint_to_str(tcx: &ty::ctxt, c: &sp_constr) -> istr {\n             istr::from_estr(tcx.sess.span_str(c.span)) + ~\"])\";\n       }\n       npred(p, _, args) {\n-        ret istr::from_estr(path_to_str(p)) + ~\"(\" +\n+        ret path_to_str(p) + ~\"(\" +\n             comma_str(args) + ~\")\" + ~\"[\" +\n                 istr::from_estr(tcx.sess.span_str(c.span)) + ~\"]\";\n       }\n@@ -593,9 +593,9 @@ fn constraints(fcx: &fn_ctxt) -> [norm_constraint] {\n // should freeze it at some earlier point.\n fn match_args(fcx: &fn_ctxt, occs: &@mutable [pred_args],\n               occ: &[@constr_arg_use]) -> uint {\n-    log \"match_args: looking at \" +\n-            constr_args_to_str(fn (i: &inst) -> str {\n-                ret istr::to_estr(i.ident);\n+    log ~\"match_args: looking at \" +\n+            constr_args_to_str(fn (i: &inst) -> istr {\n+                ret i.ident;\n             }, occ);\n     for pd: pred_args in *occs {\n         log ~\"match_args: candidate \" + pred_args_to_str(pd);\n@@ -687,11 +687,11 @@ fn expr_to_constr(tcx: ty::ctxt, e: &@expr) -> sp_constr {\n }\n \n fn pred_args_to_str(p: &pred_args) -> istr {\n-    istr::from_estr(\"<\" + istr::to_estr(uint::str(p.node.bit_num)) + \", \" +\n-                  constr_args_to_str(fn (i: &inst) -> str {\n-                      ret istr::to_estr(i.ident);\n-                  }, p.node.args)\n-                  + \">\")\n+    ~\"<\" + uint::str(p.node.bit_num) + ~\", \" +\n+        constr_args_to_str(fn (i: &inst) -> istr {\n+            ret i.ident;\n+        }, p.node.args)\n+        + ~\">\"\n }\n \n fn substitute_constr_args(cx: &ty::ctxt, actuals: &[@expr], c: &@ty::constr)"}, {"sha": "17fd27c3014e95bd25c5eb9aba2220016582d292", "filename": "src/comp/middle/tstate/ck.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cbad23a747c282d190e3c264f515765a938b0c98/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbad23a747c282d190e3c264f515765a938b0c98/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=cbad23a747c282d190e3c264f515765a938b0c98", "patch": "@@ -87,7 +87,7 @@ fn check_states_expr(e: &@expr, fcx: &fn_ctxt, v: &visit::vt<fn_ctxt>) {\n         s +=\n             ~\"Unsatisfied precondition constraint (for example, \" + diff +\n                 ~\") for expression:\\n\";\n-        s += istr::from_estr(syntax::print::pprust::expr_to_str(e));\n+        s += syntax::print::pprust::expr_to_str(e);\n         s += ~\"\\nPrecondition:\\n\";\n         s += tritv_to_str(fcx, prec);\n         s += ~\"\\nPrestate:\\n\";\n@@ -119,7 +119,7 @@ fn check_states_stmt(s: &@stmt, fcx: &fn_ctxt, v: &visit::vt<fn_ctxt>) {\n         ss +=\n             ~\"Unsatisfied precondition constraint (for example, \" + diff +\n                 ~\") for statement:\\n\";\n-        ss += istr::from_estr(syntax::print::pprust::stmt_to_str(*s));\n+        ss += syntax::print::pprust::stmt_to_str(*s);\n         ss += ~\"\\nPrecondition:\\n\";\n         ss += tritv_to_str(fcx, prec);\n         ss += ~\"\\nPrestate: \\n\";\n@@ -154,9 +154,10 @@ fn check_states_against_conditions(fcx: &fn_ctxt, f: &_fn,\n                                   istr::to_estr(fcx.name) +\n                                       \", not all control paths \\\n                                         return a value\");\n-        fcx.ccx.tcx.sess.span_fatal(f.decl.output.span,\n-                                    \"see declared return type of '\" +\n-                                        ty_to_str(f.decl.output) + \"'\");\n+        fcx.ccx.tcx.sess.span_fatal(\n+            f.decl.output.span,\n+            \"see declared return type of '\" +\n+            istr::to_estr(ty_to_str(f.decl.output)) + \"'\");\n     } else if f.decl.cf == noreturn {\n \n         // check that this really always fails"}, {"sha": "1caa48033c3960694602e0484d223989b659efad", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cbad23a747c282d190e3c264f515765a938b0c98/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbad23a747c282d190e3c264f515765a938b0c98/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=cbad23a747c282d190e3c264f515765a938b0c98", "patch": "@@ -2900,7 +2900,8 @@ fn ast_constr_to_constr<T>(tcx: ty::ctxt, c: &@ast::constr_general<T>) ->\n       }\n       _ {\n         tcx.sess.span_fatal(c.span,\n-                            \"Predicate \" + path_to_str(c.node.path) +\n+                            \"Predicate \" +\n+                            istr::to_estr(path_to_str(c.node.path)) +\n                             \" is unbound or bound to a non-function or an \\\n                              impure function\");\n       }"}, {"sha": "a76626356655dd74e2188114b1ea22bd8124770e", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cbad23a747c282d190e3c264f515765a938b0c98/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbad23a747c282d190e3c264f515765a938b0c98/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=cbad23a747c282d190e3c264f515765a938b0c98", "patch": "@@ -315,7 +315,7 @@ fn ast_ty_to_ty(tcx: &ty::ctxt, getter: &ty_getter, ast_ty: &@ast::ty) ->\n         ret typ;\n     }\n     let typ;\n-    let cname = none::<str>;\n+    let cname = none::<istr>;\n     alt ast_ty.node {\n       ast::ty_nil. { typ = ty::mk_nil(tcx); }\n       ast::ty_bot. { typ = ty::mk_bot(tcx); }\n@@ -415,7 +415,9 @@ fn ast_ty_to_ty(tcx: &ty::ctxt, getter: &ty_getter, ast_ty: &@ast::ty) ->\n     }\n     alt cname {\n       none. {/* no-op */ }\n-      some(cname_str) { typ = ty::rename(tcx, typ, cname_str); }\n+      some(cname_str) {\n+        typ = ty::rename(tcx, typ, istr::to_estr(cname_str));\n+      }\n     }\n     tcx.ast_ty_to_ty_cache.insert(ast_ty, some(typ));\n     ret typ;\n@@ -2402,7 +2404,8 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n                         // The user is trying to extend a non-object.\n                         tcx.sess.span_fatal(\n                             e.span,\n-                            syntax::print::pprust::expr_to_str(e)\n+                            istr::to_estr(\n+                                syntax::print::pprust::expr_to_str(e))\n                             +\n                             \" does not have object type\");\n                       }"}, {"sha": "5acad14fbb2679567eb1de68cab3dc56d2427498", "filename": "src/comp/syntax/ext/log_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cbad23a747c282d190e3c264f515765a938b0c98/src%2Fcomp%2Fsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbad23a747c282d190e3c264f515765a938b0c98/src%2Fcomp%2Fsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Flog_syntax.rs?ref=cbad23a747c282d190e3c264f515765a938b0c98", "patch": "@@ -8,7 +8,7 @@ fn expand_syntax_ext(cx: &ext_ctxt, sp: codemap::span, arg: @ast::expr,\n \n     cx.print_backtrace();\n     std::io::stdout().write_line(\n-        istr::from_estr(print::pprust::expr_to_str(arg)));\n+        print::pprust::expr_to_str(arg));\n \n     //trivial expression\n     ret @{id: cx.next_id(), node: ast::expr_rec([], option::none), span: sp};"}, {"sha": "d5d7a7125ff78c0e0b77017b25342dfc6d6bf518", "filename": "src/comp/syntax/print/pp.rs", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/cbad23a747c282d190e3c264f515765a938b0c98/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbad23a747c282d190e3c264f515765a938b0c98/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs?ref=cbad23a747c282d190e3c264f515765a938b0c98", "patch": "@@ -62,33 +62,37 @@ type break_t = {offset: int, blank_space: int};\n \n type begin_t = {offset: int, breaks: breaks};\n \n-tag token { STRING(str, int); BREAK(break_t); BEGIN(begin_t); END; EOF; }\n+tag token { STRING(istr, int); BREAK(break_t); BEGIN(begin_t); END; EOF; }\n \n-fn tok_str(t: token) -> str {\n+fn tok_str(t: token) -> istr {\n     alt t {\n-      STRING(s, len) { ret #fmt[\"STR(%s,%d)\", s, len]; }\n-      BREAK(_) { ret \"BREAK\"; }\n-      BEGIN(_) { ret \"BEGIN\"; }\n-      END. { ret \"END\"; }\n-      EOF. { ret \"EOF\"; }\n+      STRING(s, len) {\n+        ret istr::from_estr(\n+            #fmt[\"STR(%s,%d)\", istr::to_estr(s), len]);\n+      }\n+      BREAK(_) { ret ~\"BREAK\"; }\n+      BEGIN(_) { ret ~\"BEGIN\"; }\n+      END. { ret ~\"END\"; }\n+      EOF. { ret ~\"EOF\"; }\n     }\n }\n \n fn buf_str(toks: &[mutable token], szs: &[mutable int], left: uint,\n-           right: uint, lim: uint) -> str {\n+           right: uint, lim: uint) -> istr {\n     let n = vec::len(toks);\n     assert (n == vec::len(szs));\n     let i = left;\n     let L = lim;\n-    let s = \"[\";\n+    let s = ~\"[\";\n     while i != right && L != 0u {\n         L -= 1u;\n-        if i != left { s += \", \"; }\n-        s += #fmt[\"%d=%s\", szs[i], tok_str(toks[i])];\n+        if i != left { s += ~\", \"; }\n+        s += istr::from_estr(\n+            #fmt[\"%d=%s\", szs[i], istr::to_estr(tok_str(toks[i]))]);\n         i += 1u;\n         i %= n;\n     }\n-    s += \"]\";\n+    s += ~\"]\";\n     ret s;\n }\n \n@@ -405,15 +409,16 @@ obj printer(out: io::writer,\n         if n != 0u { top = print_stack[n - 1u]; }\n         ret top;\n     }\n-    fn write_str(s: str) {\n+    fn write_str(s: &istr) {\n         while pending_indentation > 0 {\n             out.write_str(~\" \");\n             pending_indentation -= 1;\n         }\n-        out.write_str(istr::from_estr(s));\n+        out.write_str(s);\n     }\n     fn print(x: token, L: int) {\n-        log #fmt[\"print %s %d (remaining line space=%d)\", tok_str(x), L,\n+        log #fmt[\"print %s %d (remaining line space=%d)\",\n+                 istr::to_estr(tok_str(x)), L,\n                  space];\n         log buf_str(token, size, left, right, 6u);\n         alt x {\n@@ -493,15 +498,15 @@ fn end(p: printer) { p.pretty_print(END); }\n \n fn eof(p: printer) { p.pretty_print(EOF); }\n \n-fn word(p: printer, wrd: str) {\n-    p.pretty_print(STRING(wrd, str::char_len(wrd) as int));\n+fn word(p: printer, wrd: &istr) {\n+    p.pretty_print(STRING(wrd, istr::char_len(wrd) as int));\n }\n \n-fn huge_word(p: printer, wrd: str) {\n+fn huge_word(p: printer, wrd: &istr) {\n     p.pretty_print(STRING(wrd, size_infinity));\n }\n \n-fn zero_word(p: printer, wrd: str) { p.pretty_print(STRING(wrd, 0)); }\n+fn zero_word(p: printer, wrd: &istr) { p.pretty_print(STRING(wrd, 0)); }\n \n fn spaces(p: printer, n: uint) { break_offset(p, n, 0); }\n "}, {"sha": "d98f1476b6bbaede2b688763d838356f2f467b12", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 304, "deletions": 299, "changes": 603, "blob_url": "https://github.com/rust-lang/rust/blob/cbad23a747c282d190e3c264f515765a938b0c98/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbad23a747c282d190e3c264f515765a938b0c98/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=cbad23a747c282d190e3c264f515765a938b0c98", "patch": "@@ -75,11 +75,11 @@ const default_columns: uint = 78u;\n // Requires you to pass an input filename and reader so that\n // it can scan the input text for comments and literals to\n // copy forward.\n-fn print_crate(cm: &codemap, crate: @ast::crate, filename: str,\n+fn print_crate(cm: &codemap, crate: @ast::crate, filename: &istr,\n                in: io::reader, out: io::writer, ann: &pp_ann) {\n     let boxes: [pp::breaks] = [];\n     let r = lexer::gather_comments_and_literals(\n-        cm, istr::from_estr(filename), in);\n+        cm, filename, in);\n     let s =\n         @{s: pp::mk_printer(out, default_columns),\n           cm: some(cm),\n@@ -94,30 +94,30 @@ fn print_crate(cm: &codemap, crate: @ast::crate, filename: str,\n     eof(s.s);\n }\n \n-fn ty_to_str(ty: &@ast::ty) -> str { be to_str(ty, print_type); }\n+fn ty_to_str(ty: &@ast::ty) -> istr { be to_str(ty, print_type); }\n \n-fn pat_to_str(pat: &@ast::pat) -> str { be to_str(pat, print_pat); }\n+fn pat_to_str(pat: &@ast::pat) -> istr { be to_str(pat, print_pat); }\n \n-fn expr_to_str(e: &@ast::expr) -> str { be to_str(e, print_expr); }\n+fn expr_to_str(e: &@ast::expr) -> istr { be to_str(e, print_expr); }\n \n-fn stmt_to_str(s: &ast::stmt) -> str { be to_str(s, print_stmt); }\n+fn stmt_to_str(s: &ast::stmt) -> istr { be to_str(s, print_stmt); }\n \n-fn item_to_str(i: &@ast::item) -> str { be to_str(i, print_item); }\n+fn item_to_str(i: &@ast::item) -> istr { be to_str(i, print_item); }\n \n-fn path_to_str(p: &ast::path) -> str {\n+fn path_to_str(p: &ast::path) -> istr {\n     be to_str(p, bind print_path(_, _, false));\n }\n \n fn fun_to_str(f: &ast::_fn, name: &ast::ident,\n-              params: &[ast::ty_param]) -> str {\n+              params: &[ast::ty_param]) -> istr {\n     let writer = io::string_writer();\n     let s = rust_printer(writer.get_writer());\n     print_fn(s, f.decl, f.proto, name, params, f.decl.constraints);\n     eof(s.s);\n-    ret istr::to_estr(writer.get_str());\n+    ret writer.get_str();\n }\n \n-fn block_to_str(blk: &ast::blk) -> str {\n+fn block_to_str(blk: &ast::blk) -> istr {\n     let writer = io::string_writer();\n     let s = rust_printer(writer.get_writer());\n     // containing cbox, will be closed by print-block at }\n@@ -128,49 +128,49 @@ fn block_to_str(blk: &ast::blk) -> str {\n     ibox(s, 0u);\n     print_block(s, blk);\n     eof(s.s);\n-    ret istr::to_estr(writer.get_str());\n+    ret writer.get_str();\n }\n \n-fn meta_item_to_str(mi: &ast::meta_item) -> str {\n+fn meta_item_to_str(mi: &ast::meta_item) -> istr {\n     ret to_str(@mi, print_meta_item);\n }\n \n-fn attribute_to_str(attr: &ast::attribute) -> str {\n+fn attribute_to_str(attr: &ast::attribute) -> istr {\n     be to_str(attr, print_attribute);\n }\n \n fn cbox(s: &ps, u: uint) { s.boxes += [pp::consistent]; pp::cbox(s.s, u); }\n \n fn box(s: &ps, u: uint, b: pp::breaks) { s.boxes += [b]; pp::box(s.s, u, b); }\n \n-fn nbsp(s: &ps) { word(s.s, \" \"); }\n+fn nbsp(s: &ps) { word(s.s, ~\" \"); }\n \n-fn word_nbsp(s: &ps, w: str) { word(s.s, w); nbsp(s); }\n+fn word_nbsp(s: &ps, w: &istr) { word(s.s, w); nbsp(s); }\n \n-fn word_space(s: &ps, w: str) { word(s.s, w); space(s.s); }\n+fn word_space(s: &ps, w: &istr) { word(s.s, w); space(s.s); }\n \n-fn popen(s: &ps) { word(s.s, \"(\"); }\n+fn popen(s: &ps) { word(s.s, ~\"(\"); }\n \n-fn pclose(s: &ps) { word(s.s, \")\"); }\n+fn pclose(s: &ps) { word(s.s, ~\")\"); }\n \n-fn head(s: &ps, w: str) {\n+fn head(s: &ps, w: &istr) {\n     // outer-box is consistent\n     cbox(s, indent_unit);\n     // head-box is inconsistent\n-    ibox(s, str::char_len(w) + 1u);\n+    ibox(s, istr::char_len(w) + 1u);\n     // keyword that starts the head\n     word_nbsp(s, w);\n }\n \n fn bopen(s: &ps) {\n-    word(s.s, \"{\");\n+    word(s.s, ~\"{\");\n     end(s); // close the head-box\n }\n \n fn bclose_(s: &ps, span: codemap::span, indented: uint) {\n     maybe_print_comment(s, span.hi);\n     break_offset_if_not_bol(s, 1u, -(indented as int));\n-    word(s.s, \"}\");\n+    word(s.s, ~\"}\");\n     end(s); // close the outer-box\n }\n fn bclose(s: &ps, span: codemap::span) { bclose_(s, span, indent_unit); }\n@@ -205,19 +205,19 @@ fn break_offset_if_not_bol(s: &ps, n: uint, off: int) {\n \n // Synthesizes a comment that was not textually present in the original source\n // file.\n-fn synth_comment(s: &ps, text: str) {\n-    word(s.s, \"/*\");\n+fn synth_comment(s: &ps, text: &istr) {\n+    word(s.s, ~\"/*\");\n     space(s.s);\n     word(s.s, text);\n     space(s.s);\n-    word(s.s, \"*/\");\n+    word(s.s, ~\"*/\");\n }\n \n fn commasep<IN>(s: &ps, b: breaks, elts: &[IN], op: fn(&ps, &IN)) {\n     box(s, 0u, b);\n     let first = true;\n     for elt: IN in elts {\n-        if first { first = false; } else { word_space(s, \",\"); }\n+        if first { first = false; } else { word_space(s, ~\",\"); }\n         op(s, elt);\n     }\n     end(s);\n@@ -234,7 +234,7 @@ fn commasep_cmnt<IN>(s: &ps, b: breaks, elts: &[IN], op: fn(&ps, &IN),\n         op(s, elt);\n         i += 1u;\n         if i < len {\n-            word(s.s, \",\");\n+            word(s.s, ~\",\");\n             maybe_print_trailing_comment(s, get_span(elt),\n                                          some(get_span(elts[i]).hi));\n             space_if_not_bol(s);\n@@ -269,52 +269,54 @@ fn print_type(s: &ps, ty: &@ast::ty) {\n     maybe_print_comment(s, ty.span.lo);\n     ibox(s, 0u);\n     alt ty.node {\n-      ast::ty_nil. { word(s.s, \"()\"); }\n-      ast::ty_bool. { word(s.s, \"bool\"); }\n-      ast::ty_bot. { word(s.s, \"!\"); }\n-      ast::ty_int. { word(s.s, \"int\"); }\n-      ast::ty_uint. { word(s.s, \"uint\"); }\n-      ast::ty_float. { word(s.s, \"float\"); }\n-      ast::ty_machine(tm) { word(s.s, ast_util::ty_mach_to_str(tm)); }\n-      ast::ty_char. { word(s.s, \"char\"); }\n-      ast::ty_str. { word(s.s, \"str\"); }\n-      ast::ty_istr. { word(s.s, \"istr\"); }\n-      ast::ty_box(mt) { word(s.s, \"@\"); print_mt(s, mt); }\n+      ast::ty_nil. { word(s.s, ~\"()\"); }\n+      ast::ty_bool. { word(s.s, ~\"bool\"); }\n+      ast::ty_bot. { word(s.s, ~\"!\"); }\n+      ast::ty_int. { word(s.s, ~\"int\"); }\n+      ast::ty_uint. { word(s.s, ~\"uint\"); }\n+      ast::ty_float. { word(s.s, ~\"float\"); }\n+      ast::ty_machine(tm) {\n+        word(s.s, istr::from_estr(ast_util::ty_mach_to_str(tm)));\n+      }\n+      ast::ty_char. { word(s.s, ~\"char\"); }\n+      ast::ty_str. { word(s.s, ~\"str\"); }\n+      ast::ty_istr. { word(s.s, ~\"istr\"); }\n+      ast::ty_box(mt) { word(s.s, ~\"@\"); print_mt(s, mt); }\n       ast::ty_vec(mt) {\n-        word(s.s, \"[\");\n+        word(s.s, ~\"[\");\n         alt mt.mut {\n-          ast::mut. { word_space(s, \"mutable\"); }\n-          ast::maybe_mut. { word_space(s, \"mutable?\"); }\n+          ast::mut. { word_space(s, ~\"mutable\"); }\n+          ast::maybe_mut. { word_space(s, ~\"mutable?\"); }\n           ast::imm. { }\n         }\n         print_type(s, mt.ty);\n-        word(s.s, \"]\");\n+        word(s.s, ~\"]\");\n       }\n-      ast::ty_ptr(mt) { word(s.s, \"*\"); print_mt(s, mt); }\n-      ast::ty_task. { word(s.s, \"task\"); }\n+      ast::ty_ptr(mt) { word(s.s, ~\"*\"); print_mt(s, mt); }\n+      ast::ty_task. { word(s.s, ~\"task\"); }\n       ast::ty_port(t) {\n-        word(s.s, \"port<\");\n+        word(s.s, ~\"port<\");\n         print_type(s, t);\n-        word(s.s, \">\");\n+        word(s.s, ~\">\");\n       }\n       ast::ty_chan(t) {\n-        word(s.s, \"chan<\");\n+        word(s.s, ~\"chan<\");\n         print_type(s, t);\n-        word(s.s, \">\");\n+        word(s.s, ~\">\");\n       }\n       ast::ty_rec(fields) {\n-        word(s.s, \"{\");\n+        word(s.s, ~\"{\");\n         fn print_field(s: &ps, f: &ast::ty_field) {\n             cbox(s, indent_unit);\n             print_mutability(s, f.node.mt.mut);\n-            word(s.s, istr::to_estr(f.node.ident));\n-            word_space(s, \":\");\n+            word(s.s, f.node.ident);\n+            word_space(s, ~\":\");\n             print_type(s, f.node.mt.ty);\n             end(s);\n         }\n         fn get_span(f: &ast::ty_field) -> codemap::span { ret f.span; }\n         commasep_cmnt(s, consistent, fields, print_field, get_span);\n-        word(s.s, \"}\");\n+        word(s.s, ~\"}\");\n       }\n       ast::ty_tup(elts) {\n         popen(s);\n@@ -325,21 +327,21 @@ fn print_type(s: &ps, ty: &@ast::ty) {\n         print_ty_fn(s, proto, none::<istr>, inputs, output, cf, constrs);\n       }\n       ast::ty_obj(methods) {\n-        head(s, \"obj\");\n+        head(s, ~\"obj\");\n         bopen(s);\n         for m: ast::ty_method in methods {\n             hardbreak_if_not_bol(s);\n             cbox(s, indent_unit);\n             maybe_print_comment(s, m.span.lo);\n             print_ty_fn(s, m.node.proto, some(m.node.ident), m.node.inputs,\n                         m.node.output, m.node.cf, m.node.constrs);\n-            word(s.s, \";\");\n+            word(s.s, ~\";\");\n             end(s);\n         }\n         bclose(s, ty.span);\n       }\n       ast::ty_path(path, _) { print_path(s, path, false); }\n-      ast::ty_type. { word(s.s, \"type\"); }\n+      ast::ty_type. { word(s.s, ~\"type\"); }\n       ast::ty_constr(t, cs) {\n         print_type(s, t);\n         space(s.s);\n@@ -357,10 +359,10 @@ fn print_native_item(s: &ps, item: &@ast::native_item) {\n       ast::native_item_ty. {\n         ibox(s, indent_unit);\n         ibox(s, 0u);\n-        word_nbsp(s, \"type\");\n-        word(s.s, istr::to_estr(item.ident));\n+        word_nbsp(s, ~\"type\");\n+        word(s.s, item.ident);\n         end(s); // end the inner ibox\n-        word(s.s, \";\");\n+        word(s.s, ~\";\");\n         end(s); // end the outer ibox\n \n       }\n@@ -374,12 +376,12 @@ fn print_native_item(s: &ps, item: &@ast::native_item) {\n           none. { }\n           some(ss) {\n             space(s.s);\n-            word_space(s, \"=\");\n-            print_string(s, istr::to_estr(ss));\n+            word_space(s, ~\"=\");\n+            print_string(s, ss);\n           }\n         }\n         end(s); // end head-ibox\n-        word(s.s, \";\");\n+        word(s.s, ~\";\");\n         end(s); // end the outer fn box\n       }\n     }\n@@ -393,47 +395,47 @@ fn print_item(s: &ps, item: &@ast::item) {\n     s.ann.pre(ann_node);\n     alt item.node {\n       ast::item_const(ty, expr) {\n-        head(s, \"const\");\n-        word_space(s, istr::to_estr(item.ident) + \":\");\n+        head(s, ~\"const\");\n+        word_space(s, item.ident + ~\":\");\n         print_type(s, ty);\n         space(s.s);\n         end(s); // end the head-ibox\n \n-        word_space(s, \"=\");\n+        word_space(s, ~\"=\");\n         print_expr(s, expr);\n-        word(s.s, \";\");\n+        word(s.s, ~\";\");\n         end(s); // end the outer cbox\n \n       }\n       ast::item_fn(_fn, typarams) {\n         print_fn(s, _fn.decl, _fn.proto, item.ident, typarams,\n                  _fn.decl.constraints);\n-        word(s.s, \" \");\n+        word(s.s, ~\" \");\n         print_block(s, _fn.body);\n       }\n       ast::item_mod(_mod) {\n-        head(s, \"mod\");\n-        word_nbsp(s, istr::to_estr(item.ident));\n+        head(s, ~\"mod\");\n+        word_nbsp(s, item.ident);\n         bopen(s);\n         print_mod(s, _mod, item.attrs);\n         bclose(s, item.span);\n       }\n       ast::item_native_mod(nmod) {\n-        head(s, \"native\");\n+        head(s, ~\"native\");\n         alt nmod.abi {\n-          ast::native_abi_llvm. { word_nbsp(s, \"\\\"llvm\\\"\"); }\n-          ast::native_abi_rust. { word_nbsp(s, \"\\\"rust\\\"\"); }\n-          ast::native_abi_cdecl. { word_nbsp(s, \"\\\"cdecl\\\"\"); }\n+          ast::native_abi_llvm. { word_nbsp(s, ~\"\\\"llvm\\\"\"); }\n+          ast::native_abi_rust. { word_nbsp(s, ~\"\\\"rust\\\"\"); }\n+          ast::native_abi_cdecl. { word_nbsp(s, ~\"\\\"cdecl\\\"\"); }\n           ast::native_abi_rust_intrinsic. {\n-            word_nbsp(s, \"\\\"rust-intrinsic\\\"\");\n+            word_nbsp(s, ~\"\\\"rust-intrinsic\\\"\");\n           }\n-          ast::native_abi_x86stdcall. { word_nbsp(s, \"\\\"x86stdcall\\\"\"); }\n+          ast::native_abi_x86stdcall. { word_nbsp(s, ~\"\\\"x86stdcall\\\"\"); }\n         }\n-        word_nbsp(s, \"mod\");\n-        word_nbsp(s, istr::to_estr(item.ident));\n+        word_nbsp(s, ~\"mod\");\n+        word_nbsp(s, item.ident);\n         if !istr::eq(nmod.native_name, item.ident) {\n-            word_space(s, \"=\");\n-            print_string(s, istr::to_estr(nmod.native_name));\n+            word_space(s, ~\"=\");\n+            print_string(s, nmod.native_name);\n             nbsp(s);\n         }\n         bopen(s);\n@@ -443,15 +445,15 @@ fn print_item(s: &ps, item: &@ast::item) {\n       ast::item_ty(ty, params) {\n         ibox(s, indent_unit);\n         ibox(s, 0u);\n-        word_nbsp(s, \"type\");\n-        word(s.s, istr::to_estr(item.ident));\n+        word_nbsp(s, ~\"type\");\n+        word(s.s, item.ident);\n         print_type_params(s, params);\n         end(s); // end the inner ibox\n \n         space(s.s);\n-        word_space(s, \"=\");\n+        word_space(s, ~\"=\");\n         print_type(s, ty);\n-        word(s.s, \";\");\n+        word(s.s, ~\";\");\n         end(s); // end the outer ibox\n       }\n       ast::item_tag(variants, params) {\n@@ -461,22 +463,22 @@ fn print_item(s: &ps, item: &@ast::item) {\n                 vec::len(variants[0].node.args) == 1u;\n         if newtype {\n             ibox(s, indent_unit);\n-            word_space(s, \"tag\");\n-        } else { head(s, \"tag\"); }\n-        word(s.s, istr::to_estr(item.ident));\n+            word_space(s, ~\"tag\");\n+        } else { head(s, ~\"tag\"); }\n+        word(s.s, item.ident);\n         print_type_params(s, params);\n         space(s.s);\n         if newtype {\n-            word_space(s, \"=\");\n+            word_space(s, ~\"=\");\n             print_type(s, variants[0].node.args[0].ty);\n-            word(s.s, \";\");\n+            word(s.s, ~\";\");\n             end(s);\n         } else {\n             bopen(s);\n             for v: ast::variant in variants {\n                 space_if_not_bol(s);\n                 maybe_print_comment(s, v.span.lo);\n-                word(s.s, istr::to_estr(v.node.name));\n+                word(s.s, v.node.name);\n                 if vec::len(v.node.args) > 0u {\n                     popen(s);\n                     fn print_variant_arg(s: &ps, arg: &ast::variant_arg) {\n@@ -485,21 +487,21 @@ fn print_item(s: &ps, item: &@ast::item) {\n                     commasep(s, consistent, v.node.args, print_variant_arg);\n                     pclose(s);\n                 }\n-                word(s.s, \";\");\n+                word(s.s, ~\";\");\n                 maybe_print_trailing_comment(s, v.span, none::<uint>);\n             }\n             bclose(s, item.span);\n         }\n       }\n       ast::item_obj(_obj, params, _) {\n-        head(s, \"obj\");\n-        word(s.s, istr::to_estr(item.ident));\n+        head(s, ~\"obj\");\n+        word(s.s, item.ident);\n         print_type_params(s, params);\n         popen(s);\n         fn print_field(s: &ps, field: &ast::obj_field) {\n             ibox(s, indent_unit);\n             print_mutability(s, field.mut);\n-            word_space(s, istr::to_estr(field.ident) + \":\");\n+            word_space(s, field.ident + ~\":\");\n             print_type(s, field.ty);\n             end(s);\n         }\n@@ -514,17 +516,17 @@ fn print_item(s: &ps, item: &@ast::item) {\n             maybe_print_comment(s, meth.span.lo);\n             print_fn(s, meth.node.meth.decl, meth.node.meth.proto,\n                      meth.node.ident, typarams, []);\n-            word(s.s, \" \");\n+            word(s.s, ~\" \");\n             print_block(s, meth.node.meth.body);\n         }\n         bclose(s, item.span);\n       }\n       ast::item_res(dt, dt_id, tps, ct_id) {\n-        head(s, \"resource\");\n-        word(s.s, istr::to_estr(item.ident));\n+        head(s, ~\"resource\");\n+        word(s.s, item.ident);\n         print_type_params(s, tps);\n         popen(s);\n-        word_space(s, istr::to_estr(dt.decl.inputs[0].ident) + \":\");\n+        word_space(s, dt.decl.inputs[0].ident + ~\":\");\n         print_type(s, dt.decl.inputs[0].ty);\n         pclose(s);\n         space(s.s);\n@@ -551,7 +553,7 @@ fn print_inner_attributes(s: &ps, attrs: &[ast::attribute]) {\n         alt attr.node.style {\n           ast::attr_inner. {\n             print_attribute(s, attr);\n-            word(s.s, \";\");\n+            word(s.s, ~\";\");\n             count += 1;\n           }\n           _ {/* fallthrough */ }\n@@ -563,9 +565,9 @@ fn print_inner_attributes(s: &ps, attrs: &[ast::attribute]) {\n fn print_attribute(s: &ps, attr: &ast::attribute) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, attr.span.lo);\n-    word(s.s, \"#[\");\n+    word(s.s, ~\"#[\");\n     print_meta_item(s, @attr.node.value);\n-    word(s.s, \"]\");\n+    word(s.s, ~\"]\");\n }\n \n fn print_stmt(s: &ps, st: &ast::stmt) {\n@@ -574,7 +576,7 @@ fn print_stmt(s: &ps, st: &ast::stmt) {\n       ast::stmt_decl(decl, _) { print_decl(s, decl); }\n       ast::stmt_expr(expr, _) { space_if_not_bol(s); print_expr(s, expr); }\n     }\n-    if parse::parser::stmt_ends_with_semi(st) { word(s.s, \";\"); }\n+    if parse::parser::stmt_ends_with_semi(st) { word(s.s, ~\";\"); }\n     maybe_print_trailing_comment(s, st.span, none::<uint>);\n }\n \n@@ -587,15 +589,15 @@ tag embed_type { block_macro; block_block_fn; block_normal; }\n fn print_possibly_embedded_block(s: &ps, blk: &ast::blk, embedded: embed_type,\n                                  indented: uint) {\n     alt blk.node.rules {\n-      ast::unchecked. { word(s.s, \"unchecked\"); }\n+      ast::unchecked. { word(s.s, ~\"unchecked\"); }\n       _ {}\n     }\n \n     maybe_print_comment(s, blk.span.lo);\n     let ann_node = node_block(s, blk);\n     s.ann.pre(ann_node);\n     alt embedded {\n-      block_macro. { word(s.s, \"#{\"); end(s); }\n+      block_macro. { word(s.s, ~\"#{\"); end(s); }\n       block_block_fn. { end(s); }\n       block_normal. { bopen(s); }\n     }\n@@ -649,7 +651,7 @@ fn print_possibly_embedded_block(s: &ps, blk: &ast::blk, embedded: embed_type,\n               _ { false }\n             };\n \n-        if last_expr_is_block && next_expr_is_ambig { word(s.s, \";\"); }\n+        if last_expr_is_block && next_expr_is_ambig { word(s.s, ~\";\"); }\n \n         fn expr_is_ambig(ex: @ast::expr) -> bool {\n             // We're going to walk the expression to the 'left' looking for\n@@ -712,8 +714,8 @@ fn print_maybe_parens_discrim(s: &ps, e: &@ast::expr) {\n \n fn print_if(s: &ps, test: &@ast::expr, blk: &ast::blk,\n             elseopt: &option::t<@ast::expr>, chk: bool) {\n-    head(s, \"if\");\n-    if chk { word_nbsp(s, \"check\"); }\n+    head(s, ~\"if\");\n+    if chk { word_nbsp(s, ~\"check\"); }\n     print_maybe_parens_discrim(s, test);\n     space(s.s);\n     print_block(s, blk);\n@@ -727,7 +729,7 @@ fn print_if(s: &ps, test: &@ast::expr, blk: &ast::blk,\n               ast::expr_if(i, t, e) {\n                 cbox(s, indent_unit - 1u);\n                 ibox(s, 0u);\n-                word(s.s, \" else if \");\n+                word(s.s, ~\" else if \");\n                 print_expr(s, i);\n                 space(s.s);\n                 print_block(s, t);\n@@ -739,7 +741,7 @@ fn print_if(s: &ps, test: &@ast::expr, blk: &ast::blk,\n               ast::expr_block(b) {\n                 cbox(s, indent_unit - 1u);\n                 ibox(s, 0u);\n-                word(s.s, \" else \");\n+                word(s.s, ~\" else \");\n                 print_block(s, b);\n               }\n             }\n@@ -753,21 +755,21 @@ fn print_if(s: &ps, test: &@ast::expr, blk: &ast::blk,\n fn print_mac(s: &ps, m: &ast::mac) {\n     alt m.node {\n       ast::mac_invoc(path, arg, body) {\n-        word(s.s, \"#\");\n+        word(s.s, ~\"#\");\n         print_path(s, path, false);\n-        alt arg.node { ast::expr_vec(_, _) { } _ { word(s.s, \" \"); } }\n+        alt arg.node { ast::expr_vec(_, _) { } _ { word(s.s, ~\" \"); } }\n         print_expr(s, arg);\n         // FIXME: extension 'body'\n       }\n       ast::mac_embed_type(ty) {\n-        word(s.s, \"#<\");\n+        word(s.s, ~\"#<\");\n         print_type(s, ty);\n-        word(s.s, \">\");\n+        word(s.s, ~\">\");\n       }\n       ast::mac_embed_block(blk) {\n         print_possibly_embedded_block(s, blk, block_normal, indent_unit);\n       }\n-      ast::mac_ellipsis. { word(s.s, \"...\"); }\n+      ast::mac_ellipsis. { word(s.s, ~\"...\"); }\n     }\n }\n \n@@ -779,38 +781,38 @@ fn print_expr(s: &ps, expr: &@ast::expr) {\n     alt expr.node {\n       ast::expr_vec(exprs, mut) {\n         ibox(s, indent_unit);\n-        word(s.s, \"[\");\n+        word(s.s, ~\"[\");\n         if mut == ast::mut {\n-            word(s.s, \"mutable\");\n+            word(s.s, ~\"mutable\");\n             if vec::len(exprs) > 0u { nbsp(s); }\n         }\n         commasep_exprs(s, inconsistent, exprs);\n-        word(s.s, \"]\");\n+        word(s.s, ~\"]\");\n         end(s);\n       }\n       ast::expr_rec(fields, wth) {\n         fn print_field(s: &ps, field: &ast::field) {\n             ibox(s, indent_unit);\n-            if field.node.mut == ast::mut { word_nbsp(s, \"mutable\"); }\n-            word(s.s, istr::to_estr(field.node.ident));\n-            word_space(s, \":\");\n+            if field.node.mut == ast::mut { word_nbsp(s, ~\"mutable\"); }\n+            word(s.s, field.node.ident);\n+            word_space(s, ~\":\");\n             print_expr(s, field.node.expr);\n             end(s);\n         }\n         fn get_span(field: &ast::field) -> codemap::span { ret field.span; }\n-        word(s.s, \"{\");\n+        word(s.s, ~\"{\");\n         commasep_cmnt(s, consistent, fields, print_field, get_span);\n         alt wth {\n           some(expr) {\n             if vec::len(fields) > 0u { space(s.s); }\n             ibox(s, indent_unit);\n-            word_space(s, \"with\");\n+            word_space(s, ~\"with\");\n             print_expr(s, expr);\n             end(s);\n           }\n           _ { }\n         }\n-        word(s.s, \"}\");\n+        word(s.s, ~\"}\");\n       }\n       ast::expr_tup(exprs) {\n         popen(s);\n@@ -824,17 +826,17 @@ fn print_expr(s: &ps, expr: &@ast::expr) {\n         pclose(s);\n       }\n       ast::expr_self_method(ident) {\n-        word(s.s, \"self.\");\n+        word(s.s, ~\"self.\");\n         print_ident(s, ident);\n       }\n       ast::expr_bind(func, args) {\n         fn print_opt(s: &ps, expr: &option::t<@ast::expr>) {\n             alt expr {\n               some(expr) { print_expr(s, expr); }\n-              _ { word(s.s, \"_\"); }\n+              _ { word(s.s, ~\"_\"); }\n             }\n         }\n-        word_nbsp(s, \"bind\");\n+        word_nbsp(s, ~\"bind\");\n         print_expr(s, func);\n         popen(s);\n         commasep(s, inconsistent, args, print_opt);\n@@ -844,18 +846,18 @@ fn print_expr(s: &ps, expr: &@ast::expr) {\n         let prec = operator_prec(op);\n         print_maybe_parens(s, lhs, prec);\n         space(s.s);\n-        word_space(s, ast_util::binop_to_str(op));\n+        word_space(s, istr::from_estr(ast_util::binop_to_str(op)));\n         print_maybe_parens(s, rhs, prec + 1);\n       }\n       ast::expr_unary(op, expr) {\n-        word(s.s, ast_util::unop_to_str(op));\n+        word(s.s, istr::from_estr(ast_util::unop_to_str(op)));\n         print_maybe_parens(s, expr, parse::parser::unop_prec);\n       }\n       ast::expr_lit(lit) { print_literal(s, lit); }\n       ast::expr_cast(expr, ty) {\n         print_maybe_parens(s, expr, parse::parser::as_prec);\n         space(s.s);\n-        word_space(s, \"as\");\n+        word_space(s, ~\"as\");\n         print_type(s, ty);\n       }\n       ast::expr_if(test, blk, elseopt) {\n@@ -867,42 +869,42 @@ fn print_expr(s: &ps, expr: &@ast::expr) {\n       ast::expr_ternary(test, then, els) {\n         print_expr(s, test);\n         space(s.s);\n-        word_space(s, \"?\");\n+        word_space(s, ~\"?\");\n         print_expr(s, then);\n         space(s.s);\n-        word_space(s, \":\");\n+        word_space(s, ~\":\");\n         print_expr(s, els);\n       }\n       ast::expr_while(test, blk) {\n-        head(s, \"while\");\n+        head(s, ~\"while\");\n         print_maybe_parens_discrim(s, test);\n         space(s.s);\n         print_block(s, blk);\n       }\n       ast::expr_for(decl, expr, blk) {\n-        head(s, \"for\");\n+        head(s, ~\"for\");\n         print_for_decl(s, decl, expr);\n         space(s.s);\n         print_block(s, blk);\n       }\n       ast::expr_for_each(decl, expr, blk) {\n-        head(s, \"for each\");\n+        head(s, ~\"for each\");\n         print_for_decl(s, decl, expr);\n         space(s.s);\n         print_block(s, blk);\n       }\n       ast::expr_do_while(blk, expr) {\n-        head(s, \"do\");\n+        head(s, ~\"do\");\n         space(s.s);\n         print_block(s, blk);\n         space(s.s);\n-        word_space(s, \"while\");\n+        word_space(s, ~\"while\");\n         print_expr(s, expr);\n       }\n       ast::expr_alt(expr, arms) {\n         cbox(s, alt_indent_unit);\n         ibox(s, 4u);\n-        word_nbsp(s, \"alt\");\n+        word_nbsp(s, ~\"alt\");\n         print_maybe_parens_discrim(s, expr);\n         space(s.s);\n         bopen(s);\n@@ -914,13 +916,13 @@ fn print_expr(s: &ps, expr: &@ast::expr) {\n             for p: @ast::pat in arm.pats {\n                 if first {\n                     first = false;\n-                } else { space(s.s); word_space(s, \"|\"); }\n+                } else { space(s.s); word_space(s, ~\"|\"); }\n                 print_pat(s, p);\n             }\n             space(s.s);\n             alt arm.guard {\n               some(e) {\n-                word_space(s, \"when\");\n+                word_space(s, ~\"when\");\n                 print_expr(s, e);\n                 space(s.s);\n               }\n@@ -940,7 +942,7 @@ fn print_expr(s: &ps, expr: &@ast::expr) {\n             cbox(s, indent_unit);\n             // head-box, will be closed by print-block at start\n             ibox(s, 0u);\n-            word(s.s, \"{\");\n+            word(s.s, ~\"{\");\n             print_fn_block_args(s, f.decl);\n             print_possibly_embedded_block(s, f.body, block_block_fn,\n                                           indent_unit);\n@@ -958,100 +960,102 @@ fn print_expr(s: &ps, expr: &@ast::expr) {\n         ibox(s, 0u);\n         print_block(s, blk);\n       }\n-      ast::expr_copy(e) { word_space(s, \"copy\"); print_expr(s, e); }\n+      ast::expr_copy(e) { word_space(s, ~\"copy\"); print_expr(s, e); }\n       ast::expr_move(lhs, rhs) {\n         print_expr(s, lhs);\n         space(s.s);\n-        word_space(s, \"<-\");\n+        word_space(s, ~\"<-\");\n         print_expr(s, rhs);\n       }\n       ast::expr_assign(lhs, rhs) {\n         print_expr(s, lhs);\n         space(s.s);\n-        word_space(s, \"=\");\n+        word_space(s, ~\"=\");\n         print_expr(s, rhs);\n       }\n       ast::expr_swap(lhs, rhs) {\n         print_expr(s, lhs);\n         space(s.s);\n-        word_space(s, \"<->\");\n+        word_space(s, ~\"<->\");\n         print_expr(s, rhs);\n       }\n       ast::expr_assign_op(op, lhs, rhs) {\n         print_expr(s, lhs);\n         space(s.s);\n-        word(s.s, ast_util::binop_to_str(op));\n-        word_space(s, \"=\");\n+        word(s.s, istr::from_estr(ast_util::binop_to_str(op)));\n+        word_space(s, ~\"=\");\n         print_expr(s, rhs);\n       }\n       ast::expr_field(expr, id) {\n         print_expr_parens_if_unary(s, expr);\n-        word(s.s, \".\");\n-        word(s.s, istr::to_estr(id));\n+        word(s.s, ~\".\");\n+        word(s.s, id);\n       }\n       ast::expr_index(expr, index) {\n         print_expr_parens_if_unary(s, expr);\n-        word(s.s, \"[\");\n+        word(s.s, ~\"[\");\n         print_expr(s, index);\n-        word(s.s, \"]\");\n+        word(s.s, ~\"]\");\n       }\n       ast::expr_path(path) { print_path(s, path, true); }\n       ast::expr_fail(maybe_fail_val) {\n-        word(s.s, \"fail\");\n+        word(s.s, ~\"fail\");\n         alt maybe_fail_val {\n-          some(expr) { word(s.s, \" \"); print_expr(s, expr); }\n+          some(expr) { word(s.s, ~\" \"); print_expr(s, expr); }\n           _ { }\n         }\n       }\n-      ast::expr_break. { word(s.s, \"break\"); }\n-      ast::expr_cont. { word(s.s, \"cont\"); }\n+      ast::expr_break. { word(s.s, ~\"break\"); }\n+      ast::expr_cont. { word(s.s, ~\"cont\"); }\n       ast::expr_ret(result) {\n-        word(s.s, \"ret\");\n+        word(s.s, ~\"ret\");\n         alt result {\n-          some(expr) { word(s.s, \" \"); print_expr(s, expr); }\n+          some(expr) { word(s.s, ~\" \"); print_expr(s, expr); }\n           _ { }\n         }\n       }\n       ast::expr_put(result) {\n-        word(s.s, \"put\");\n+        word(s.s, ~\"put\");\n         alt result {\n-          some(expr) { word(s.s, \" \"); print_expr(s, expr); }\n+          some(expr) { word(s.s, ~\" \"); print_expr(s, expr); }\n           _ { }\n         }\n       }\n-      ast::expr_be(result) { word_nbsp(s, \"be\"); print_expr(s, result); }\n+      ast::expr_be(result) { word_nbsp(s, ~\"be\"); print_expr(s, result); }\n       ast::expr_log(lvl, expr) {\n-        alt lvl { 1 { word_nbsp(s, \"log\"); } 0 { word_nbsp(s, \"log_err\"); } }\n+        alt lvl {\n+          1 { word_nbsp(s, ~\"log\"); } 0 { word_nbsp(s, ~\"log_err\"); }\n+        }\n         print_expr(s, expr);\n       }\n       ast::expr_check(m, expr) {\n         alt m {\n-          ast::unchecked. { word_nbsp(s, \"claim\"); }\n-          ast::checked. { word_nbsp(s, \"check\"); }\n+          ast::unchecked. { word_nbsp(s, ~\"claim\"); }\n+          ast::checked. { word_nbsp(s, ~\"check\"); }\n         }\n         popen(s);\n         print_expr(s, expr);\n         pclose(s);\n       }\n       ast::expr_assert(expr) {\n-        word_nbsp(s, \"assert\");\n+        word_nbsp(s, ~\"assert\");\n         popen(s);\n         print_expr(s, expr);\n         pclose(s);\n       }\n       ast::expr_mac(m) { print_mac(s, m); }\n       ast::expr_anon_obj(anon_obj) {\n-        head(s, \"obj\");\n+        head(s, ~\"obj\");\n \n         // Fields\n         popen(s);\n         fn print_field(s: &ps, field: &ast::anon_obj_field) {\n             ibox(s, indent_unit);\n             print_mutability(s, field.mut);\n-            word_space(s, istr::to_estr(field.ident) + \":\");\n+            word_space(s, field.ident + ~\":\");\n             print_type(s, field.ty);\n             space(s.s);\n-            word_space(s, \"=\");\n+            word_space(s, ~\"=\");\n             print_expr(s, field.expr);\n             end(s);\n         }\n@@ -1075,18 +1079,18 @@ fn print_expr(s: &ps, expr: &@ast::expr) {\n             maybe_print_comment(s, meth.span.lo);\n             print_fn(s, meth.node.meth.decl, meth.node.meth.proto,\n                      meth.node.ident, typarams, []);\n-            word(s.s, \" \");\n+            word(s.s, ~\" \");\n             print_block(s, meth.node.meth.body);\n         }\n \n         // With object\n         alt anon_obj.inner_obj {\n           none. { }\n-          some(e) { space(s.s); word_space(s, \"with\"); print_expr(s, e); }\n+          some(e) { space(s.s); word_space(s, ~\"with\"); print_expr(s, e); }\n         }\n         bclose(s, expr.span);\n       }\n-      ast::expr_uniq(expr) { word(s.s, \"~\"); print_expr(s, expr); }\n+      ast::expr_uniq(expr) { word(s.s, ~\"~\"); print_expr(s, expr); }\n     }\n     s.ann.post(ann_node);\n     end(s);\n@@ -1103,7 +1107,7 @@ fn print_local_decl(s: &ps, loc: &@ast::local) {\n     print_pat(s, loc.node.pat);\n     alt loc.node.ty.node {\n       ast::ty_infer. { }\n-      _ { word_space(s, \":\"); print_type(s, loc.node.ty); }\n+      _ { word_space(s, ~\":\"); print_type(s, loc.node.ty); }\n     }\n }\n \n@@ -1113,7 +1117,7 @@ fn print_decl(s: &ps, decl: &@ast::decl) {\n       ast::decl_local(locs) {\n         space_if_not_bol(s);\n         ibox(s, indent_unit);\n-        word_nbsp(s, \"let\");\n+        word_nbsp(s, ~\"let\");\n         fn print_local(s: &ps, loc: &@ast::local) {\n             ibox(s, indent_unit);\n             print_local_decl(s, loc);\n@@ -1122,8 +1126,8 @@ fn print_decl(s: &ps, decl: &@ast::decl) {\n               some(init) {\n                 nbsp(s);\n                 alt init.op {\n-                  ast::init_assign. { word_space(s, \"=\"); }\n-                  ast::init_move. { word_space(s, \"<-\"); }\n+                  ast::init_assign. { word_space(s, ~\"=\"); }\n+                  ast::init_move. { word_space(s, ~\"<-\"); }\n                 }\n                 print_expr(s, init.expr);\n               }\n@@ -1138,29 +1142,29 @@ fn print_decl(s: &ps, decl: &@ast::decl) {\n }\n \n fn print_ident(s: &ps, ident: &ast::ident) {\n-    word(s.s, istr::to_estr(ident));\n+    word(s.s, ident);\n }\n \n fn print_for_decl(s: &ps, loc: &@ast::local, coll: &@ast::expr) {\n     print_local_decl(s, loc);\n     space(s.s);\n-    word_space(s, \"in\");\n+    word_space(s, ~\"in\");\n     print_expr(s, coll);\n }\n \n fn print_path(s: &ps, path: &ast::path, colons_before_params: bool) {\n     maybe_print_comment(s, path.span.lo);\n-    if path.node.global { word(s.s, \"::\"); }\n+    if path.node.global { word(s.s, ~\"::\"); }\n     let first = true;\n     for id: ast::ident in path.node.idents {\n-        if first { first = false; } else { word(s.s, \"::\"); }\n-        word(s.s, istr::to_estr(id));\n+        if first { first = false; } else { word(s.s, ~\"::\"); }\n+        word(s.s, id);\n     }\n     if vec::len(path.node.types) > 0u {\n-        if colons_before_params { word(s.s, \"::\"); }\n-        word(s.s, \"<\");\n+        if colons_before_params { word(s.s, ~\"::\"); }\n+        word(s.s, ~\"<\");\n         commasep(s, inconsistent, path.node.types, print_type);\n-        word(s.s, \">\");\n+        word(s.s, ~\">\");\n     }\n }\n \n@@ -1169,40 +1173,40 @@ fn print_pat(s: &ps, pat: &@ast::pat) {\n     let ann_node = node_pat(s, pat);\n     s.ann.pre(ann_node);\n     alt pat.node {\n-      ast::pat_wild. { word(s.s, \"_\"); }\n-      ast::pat_bind(id) { word(s.s, istr::to_estr(id)); }\n+      ast::pat_wild. { word(s.s, ~\"_\"); }\n+      ast::pat_bind(id) { word(s.s, id); }\n       ast::pat_lit(lit) { print_literal(s, lit); }\n       ast::pat_tag(path, args) {\n         print_path(s, path, true);\n         if vec::len(args) > 0u {\n             popen(s);\n             commasep(s, inconsistent, args, print_pat);\n             pclose(s);\n-        } else { word(s.s, \".\"); }\n+        } else { word(s.s, ~\".\"); }\n       }\n       ast::pat_rec(fields, etc) {\n-        word(s.s, \"{\");\n+        word(s.s, ~\"{\");\n         fn print_field(s: &ps, f: &ast::field_pat) {\n             cbox(s, indent_unit);\n-            word(s.s, istr::to_estr(f.ident));\n-            word_space(s, \":\");\n+            word(s.s, f.ident);\n+            word_space(s, ~\":\");\n             print_pat(s, f.pat);\n             end(s);\n         }\n         fn get_span(f: &ast::field_pat) -> codemap::span { ret f.pat.span; }\n         commasep_cmnt(s, consistent, fields, print_field, get_span);\n         if etc {\n-            if vec::len(fields) != 0u { word_space(s, \",\"); }\n-            word(s.s, \"_\");\n+            if vec::len(fields) != 0u { word_space(s, ~\",\"); }\n+            word(s.s, ~\"_\");\n         }\n-        word(s.s, \"}\");\n+        word(s.s, ~\"}\");\n       }\n       ast::pat_tup(elts) {\n         popen(s);\n         commasep(s, inconsistent, elts, print_pat);\n         pclose(s);\n       }\n-      ast::pat_box(inner) { word(s.s, \"@\"); print_pat(s, inner); }\n+      ast::pat_box(inner) { word(s.s, ~\"@\"); print_pat(s, inner); }\n     }\n     s.ann.post(ann_node);\n }\n@@ -1211,9 +1215,9 @@ fn print_fn(s: &ps, decl: ast::fn_decl, proto: ast::proto, name: &ast::ident,\n             typarams: &[ast::ty_param], constrs: [@ast::constr]) {\n     alt decl.purity {\n       ast::impure_fn. { head(s, proto_to_str(proto)); }\n-      _ { head(s, \"pure fn\"); }\n+      _ { head(s, ~\"pure fn\"); }\n     }\n-    word(s.s, istr::to_estr(name));\n+    word(s.s, name);\n     print_type_params(s, typarams);\n     print_fn_args_and_ret(s, decl, constrs);\n }\n@@ -1223,7 +1227,7 @@ fn print_fn_args_and_ret(s: &ps, decl: &ast::fn_decl,\n     popen(s);\n     fn print_arg(s: &ps, x: &ast::arg) {\n         ibox(s, indent_unit);\n-        word_space(s, istr::to_estr(x.ident) + \":\");\n+        word_space(s, x.ident + ~\":\");\n         print_alias(s, x.mode);\n         print_type(s, x.ty);\n         end(s);\n@@ -1234,64 +1238,64 @@ fn print_fn_args_and_ret(s: &ps, decl: &ast::fn_decl,\n     maybe_print_comment(s, decl.output.span.lo);\n     if decl.output.node != ast::ty_nil {\n         space_if_not_bol(s);\n-        word_space(s, \"->\");\n+        word_space(s, ~\"->\");\n         print_type(s, decl.output);\n     }\n }\n \n fn print_fn_block_args(s: &ps, decl: &ast::fn_decl) {\n-    word(s.s, \"|\");\n+    word(s.s, ~\"|\");\n     fn print_arg(s: &ps, x: &ast::arg) {\n         ibox(s, indent_unit);\n         print_alias(s, x.mode);\n-        word(s.s, istr::to_estr(x.ident));\n+        word(s.s, x.ident);\n         end(s);\n     }\n     commasep(s, inconsistent, decl.inputs, print_arg);\n-    word(s.s, \"|\");\n+    word(s.s, ~\"|\");\n     maybe_print_comment(s, decl.output.span.lo);\n }\n \n fn print_alias(s: &ps, m: ast::mode) {\n     alt m {\n-      ast::alias(true) { word_space(s, \"&mutable\"); }\n-      ast::alias(false) { word(s.s, \"&\"); }\n-      ast::move. { word(s.s, \"-\"); }\n+      ast::alias(true) { word_space(s, ~\"&mutable\"); }\n+      ast::alias(false) { word(s.s, ~\"&\"); }\n+      ast::move. { word(s.s, ~\"-\"); }\n       ast::val. { }\n     }\n }\n \n fn print_kind(s: &ps, kind: ast::kind) {\n     alt kind {\n-      ast::kind_unique. { word(s.s, \"~\"); }\n-      ast::kind_shared. { word(s.s, \"@\"); }\n+      ast::kind_unique. { word(s.s, ~\"~\"); }\n+      ast::kind_shared. { word(s.s, ~\"@\"); }\n       _ {/* fallthrough */ }\n     }\n }\n \n fn print_type_params(s: &ps, params: &[ast::ty_param]) {\n     if vec::len(params) > 0u {\n-        word(s.s, \"<\");\n+        word(s.s, ~\"<\");\n         fn printParam(s: &ps, param: &ast::ty_param) {\n             print_kind(s, param.kind);\n-            word(s.s, istr::to_estr(param.ident));\n+            word(s.s, param.ident);\n         }\n         commasep(s, inconsistent, params, printParam);\n-        word(s.s, \">\");\n+        word(s.s, ~\">\");\n     }\n }\n \n fn print_meta_item(s: &ps, item: &@ast::meta_item) {\n     ibox(s, indent_unit);\n     alt item.node {\n-      ast::meta_word(name) { word(s.s, istr::to_estr(name)); }\n+      ast::meta_word(name) { word(s.s, name); }\n       ast::meta_name_value(name, value) {\n-        word_space(s, istr::to_estr(name));\n-        word_space(s, \"=\");\n+        word_space(s, name);\n+        word_space(s, ~\"=\");\n         print_literal(s, @value);\n       }\n       ast::meta_list(name, items) {\n-        word(s.s, istr::to_estr(name));\n+        word(s.s, name);\n         popen(s);\n         commasep(s, consistent, items, print_meta_item);\n         pclose(s);\n@@ -1305,56 +1309,56 @@ fn print_view_item(s: &ps, item: &@ast::view_item) {\n     maybe_print_comment(s, item.span.lo);\n     alt item.node {\n       ast::view_item_use(id, mta, _) {\n-        head(s, \"use\");\n-        word(s.s, istr::to_estr(id));\n+        head(s, ~\"use\");\n+        word(s.s, id);\n         if vec::len(mta) > 0u {\n             popen(s);\n             commasep(s, consistent, mta, print_meta_item);\n             pclose(s);\n         }\n       }\n       ast::view_item_import(id, ids, _) {\n-        head(s, \"import\");\n+        head(s, ~\"import\");\n         if !istr::eq(id, ids[vec::len(ids) - 1u]) {\n-            word_space(s, istr::to_estr(id));\n-            word_space(s, \"=\");\n+            word_space(s, id);\n+            word_space(s, ~\"=\");\n         }\n         let first = true;\n         for elt: ast::ident in ids {\n-            if first { first = false; } else { word(s.s, \"::\"); }\n-            word(s.s, istr::to_estr(elt));\n+            if first { first = false; } else { word(s.s, ~\"::\"); }\n+            word(s.s, elt);\n         }\n       }\n       ast::view_item_import_from(mod_path, idents, _) {\n-        head(s, \"import\");\n+        head(s, ~\"import\");\n         for elt: ast::ident in mod_path {\n-            word(s.s, istr::to_estr(elt)); word(s.s, \"::\");\n+            word(s.s, elt); word(s.s, ~\"::\");\n         }\n-        word(s.s, \"{\");\n+        word(s.s, ~\"{\");\n         commasep(s, inconsistent, idents,\n                  fn (s: &ps, w: &ast::import_ident) {\n-                     word(s.s, istr::to_estr(w.node.name))\n+                     word(s.s, w.node.name)\n                  });\n-        word(s.s, \"}\");\n+        word(s.s, ~\"}\");\n       }\n       ast::view_item_import_glob(ids, _) {\n-        head(s, \"import\");\n+        head(s, ~\"import\");\n         let first = true;\n         for elt: ast::ident in ids {\n-            if first { first = false; } else { word(s.s, \"::\"); }\n-            word(s.s, istr::to_estr(elt));\n+            if first { first = false; } else { word(s.s, ~\"::\"); }\n+            word(s.s, elt);\n         }\n-        word(s.s, \"::*\");\n+        word(s.s, ~\"::*\");\n       }\n       ast::view_item_export(ids, _) {\n-        head(s, \"export\");\n+        head(s, ~\"export\");\n         commasep(s, inconsistent, ids,\n                  fn (s: &ps, w: &ast::ident) {\n-                     word(s.s, istr::to_estr(w))\n+                     word(s.s, w)\n                  });\n       }\n     }\n-    word(s.s, \";\");\n+    word(s.s, ~\";\");\n     end(s); // end inner head-block\n \n     end(s); // end outer head-block\n@@ -1404,8 +1408,8 @@ fn print_maybe_parens(s: &ps, expr: &@ast::expr, outer_prec: int) {\n \n fn print_mutability(s: &ps, mut: &ast::mutability) {\n     alt mut {\n-      ast::mut. { word_nbsp(s, \"mutable\"); }\n-      ast::maybe_mut. { word_nbsp(s, \"mutable?\"); }\n+      ast::mut. { word_nbsp(s, ~\"mutable\"); }\n+      ast::maybe_mut. { word_nbsp(s, ~\"mutable?\"); }\n       ast::imm. {/* nothing */ }\n     }\n }\n@@ -1422,8 +1426,8 @@ fn print_ty_fn(s: &ps, proto: &ast::proto, id: &option::t<ast::ident>,\n     word(s.s, proto_to_str(proto));\n     alt id {\n       some(id) {\n-        word(s.s, \" \");\n-        word(s.s, istr::to_estr(id));\n+        word(s.s, ~\" \");\n+        word(s.s, id);\n       }\n       _ { }\n     }\n@@ -1439,10 +1443,10 @@ fn print_ty_fn(s: &ps, proto: &ast::proto, id: &option::t<ast::ident>,\n     if output.node != ast::ty_nil {\n         space_if_not_bol(s);\n         ibox(s, indent_unit);\n-        word_space(s, \"->\");\n+        word_space(s, ~\"->\");\n         alt cf {\n           ast::return. { print_type(s, output); }\n-          ast::noreturn. { word_nbsp(s, \"!\"); }\n+          ast::noreturn. { word_nbsp(s, ~\"!\"); }\n         }\n         end(s);\n     }\n@@ -1497,10 +1501,10 @@ fn print_literal(s: &ps, lit: &@ast::lit) {\n             // FIXME: This is a hack until istrs replace strings, since\n             // istrs are prefixed with a token that is not part of the literal\n             alt lit.node {\n-              ast::lit_str(_, ast::sk_unique.) { word(s.s, \"~\"); }\n+              ast::lit_str(_, ast::sk_unique.) { word(s.s, ~\"~\"); }\n               _ { }\n             }\n-            word(s.s, istr::to_estr(lt.lit));\n+            word(s.s, lt.lit);\n             s.cur_lit += 1u;\n             ret;\n         }\n@@ -1509,34 +1513,34 @@ fn print_literal(s: &ps, lit: &@ast::lit) {\n     }\n     alt lit.node {\n       ast::lit_str(st, kind) {\n-        if kind == ast::sk_unique { word(s.s, \"~\"); }\n-        print_string(s, istr::to_estr(st));\n+        if kind == ast::sk_unique { word(s.s, ~\"~\"); }\n+        print_string(s, st);\n       }\n       ast::lit_char(ch) {\n         word(s.s,\n-             \"'\" + escape_str(str::unsafe_from_bytes([ch as u8]), '\\'') +\n-                 \"'\");\n+             ~\"'\" + escape_str(istr::unsafe_from_bytes([ch as u8]), '\\'') +\n+                 ~\"'\");\n       }\n-      ast::lit_int(val) { word(s.s, istr::to_estr(int::str(val))); }\n-      ast::lit_uint(val) { word(s.s, istr::to_estr(uint::str(val)) + \"u\"); }\n-      ast::lit_float(fstr) { word(s.s, istr::to_estr(fstr)); }\n+      ast::lit_int(val) { word(s.s, int::str(val)); }\n+      ast::lit_uint(val) { word(s.s, uint::str(val) + ~\"u\"); }\n+      ast::lit_float(fstr) { word(s.s, fstr); }\n       ast::lit_mach_int(mach, val) {\n-        word(s.s, istr::to_estr(int::str(val as int)));\n-        word(s.s, ast_util::ty_mach_to_str(mach));\n+        word(s.s, int::str(val as int));\n+        word(s.s, istr::from_estr(ast_util::ty_mach_to_str(mach)));\n       }\n       ast::lit_mach_float(mach, val) {\n         // val is already a str\n-        word(s.s, istr::to_estr(val));\n-        word(s.s, ast_util::ty_mach_to_str(mach));\n+        word(s.s, val);\n+        word(s.s, istr::from_estr(ast_util::ty_mach_to_str(mach)));\n       }\n-      ast::lit_nil. { word(s.s, \"()\"); }\n+      ast::lit_nil. { word(s.s, ~\"()\"); }\n       ast::lit_bool(val) {\n-        if val { word(s.s, \"true\"); } else { word(s.s, \"false\"); }\n+        if val { word(s.s, ~\"true\"); } else { word(s.s, ~\"false\"); }\n       }\n     }\n }\n \n-fn lit_to_str(l: &@ast::lit) -> str { be to_str(l, print_literal); }\n+fn lit_to_str(l: &@ast::lit) -> istr { be to_str(l, print_literal); }\n \n fn next_lit(s: &ps) -> option::t<lexer::lit> {\n     alt s.literals {\n@@ -1568,7 +1572,7 @@ fn print_comment(s: &ps, cmnt: lexer::cmnt) {\n       lexer::mixed. {\n         assert (vec::len(cmnt.lines) == 1u);\n         zerobreak(s.s);\n-        word(s.s, istr::to_estr(cmnt.lines[0]));\n+        word(s.s, cmnt.lines[0]);\n         zerobreak(s.s);\n       }\n       lexer::isolated. {\n@@ -1577,21 +1581,21 @@ fn print_comment(s: &ps, cmnt: lexer::cmnt) {\n             // Don't print empty lines because they will end up as trailing\n             // whitespace\n             if istr::is_not_empty(line) {\n-                word(s.s, istr::to_estr(line));\n+                word(s.s, line);\n             }\n             hardbreak(s.s);\n         }\n       }\n       lexer::trailing. {\n-        word(s.s, \" \");\n+        word(s.s, ~\" \");\n         if vec::len(cmnt.lines) == 1u {\n-            word(s.s, istr::to_estr(cmnt.lines[0]));\n+            word(s.s, cmnt.lines[0]);\n             hardbreak(s.s);\n         } else {\n             ibox(s, 0u);\n             for line: istr in cmnt.lines {\n                 if istr::is_not_empty(line) {\n-                    word(s.s, istr::to_estr(line));\n+                    word(s.s, line);\n                 }\n                 hardbreak(s.s);\n             }\n@@ -1602,7 +1606,7 @@ fn print_comment(s: &ps, cmnt: lexer::cmnt) {\n         // We need to do at least one, possibly two hardbreaks.\n         let is_semi =\n             alt s.s.last_token() {\n-              pp::STRING(s, _) { s == \";\" }\n+              pp::STRING(s, _) { s == ~\";\" }\n               _ { false }\n             };\n         if is_semi || is_begin(s) || is_end(s) { hardbreak(s.s) }\n@@ -1611,40 +1615,40 @@ fn print_comment(s: &ps, cmnt: lexer::cmnt) {\n     }\n }\n \n-fn print_string(s: &ps, st: &str) {\n-    word(s.s, \"\\\"\");\n+fn print_string(s: &ps, st: &istr) {\n+    word(s.s, ~\"\\\"\");\n     word(s.s, escape_str(st, '\"'));\n-    word(s.s, \"\\\"\");\n+    word(s.s, ~\"\\\"\");\n }\n \n-fn escape_str(st: str, to_escape: char) -> str {\n-    let out: str = \"\";\n-    let len = str::byte_len(st);\n+fn escape_str(st: &istr, to_escape: char) -> istr {\n+    let out: istr = ~\"\";\n+    let len = istr::byte_len(st);\n     let i = 0u;\n     while i < len {\n         alt st[i] as char {\n-          '\\n' { out += \"\\\\n\"; }\n-          '\\t' { out += \"\\\\t\"; }\n-          '\\r' { out += \"\\\\r\"; }\n-          '\\\\' { out += \"\\\\\\\\\"; }\n+          '\\n' { out += ~\"\\\\n\"; }\n+          '\\t' { out += ~\"\\\\t\"; }\n+          '\\r' { out += ~\"\\\\r\"; }\n+          '\\\\' { out += ~\"\\\\\\\\\"; }\n           cur {\n-            if cur == to_escape { out += \"\\\\\"; }\n+            if cur == to_escape { out += ~\"\\\\\"; }\n             // FIXME some (or all?) non-ascii things should be escaped\n \n-            str::push_char(out, cur);\n+            istr::push_char(out, cur);\n           }\n         }\n         i += 1u;\n     }\n     ret out;\n }\n \n-fn to_str<T>(t: &T, f: fn(&ps, &T)) -> str {\n+fn to_str<T>(t: &T, f: fn(&ps, &T)) -> istr {\n     let writer = io::string_writer();\n     let s = rust_printer(writer.get_writer());\n     f(s, t);\n     eof(s.s);\n-    ret istr::to_estr(writer.get_str());\n+    ret writer.get_str();\n }\n \n fn next_comment(s: &ps) -> option::t<lexer::cmnt> {\n@@ -1660,22 +1664,23 @@ fn next_comment(s: &ps) -> option::t<lexer::cmnt> {\n \n // Removing the aliases from the type of f in the next two functions\n // triggers memory corruption, but I haven't isolated the bug yet. FIXME\n-fn constr_args_to_str<T>(f: &fn(&T) -> str, args: &[@ast::sp_constr_arg<T>])\n-   -> str {\n+fn constr_args_to_str<T>(f: &fn(&T) -> istr, args: &[@ast::sp_constr_arg<T>])\n+   -> istr {\n     let comma = false;\n-    let s = \"(\";\n+    let s = ~\"(\";\n     for a: @ast::sp_constr_arg<T> in args {\n-        if comma { s += \", \"; } else { comma = true; }\n+        if comma { s += ~\", \"; } else { comma = true; }\n         s += constr_arg_to_str::<T>(f, a.node);\n     }\n-    s += \")\";\n+    s += ~\")\";\n     ret s;\n }\n \n-fn constr_arg_to_str<T>(f: &fn(&T) -> str, c: &ast::constr_arg_general_<T>) ->\n-   str {\n+fn constr_arg_to_str<T>(f: &fn(&T) -> istr,\n+                        c: &ast::constr_arg_general_<T>) ->\n+   istr {\n     alt c {\n-      ast::carg_base. { ret \"*\"; }\n+      ast::carg_base. { ret ~\"*\"; }\n       ast::carg_ident(i) { ret f(i); }\n       ast::carg_lit(l) { ret lit_to_str(l); }\n     }\n@@ -1684,68 +1689,68 @@ fn constr_arg_to_str<T>(f: &fn(&T) -> str, c: &ast::constr_arg_general_<T>) ->\n // needed b/c constr_args_to_str needs\n // something that takes an alias\n // (argh)\n-fn uint_to_str(i: &uint) -> str { ret istr::to_estr(uint::str(i)); }\n+fn uint_to_str(i: &uint) -> istr { ret uint::str(i); }\n \n-fn ast_ty_fn_constr_to_str(c: &@ast::constr) -> str {\n+fn ast_ty_fn_constr_to_str(c: &@ast::constr) -> istr {\n     ret path_to_str(c.node.path) +\n             constr_args_to_str(uint_to_str, c.node.args);\n }\n \n // FIXME: fix repeated code\n-fn ast_ty_fn_constrs_str(constrs: &[@ast::constr]) -> str {\n-    let s = \"\";\n+fn ast_ty_fn_constrs_str(constrs: &[@ast::constr]) -> istr {\n+    let s = ~\"\";\n     let colon = true;\n     for c: @ast::constr in constrs {\n-        if colon { s += \" : \"; colon = false; } else { s += \", \"; }\n+        if colon { s += ~\" : \"; colon = false; } else { s += ~\", \"; }\n         s += ast_ty_fn_constr_to_str(c);\n     }\n     ret s;\n }\n \n-fn fn_arg_idx_to_str(decl: &ast::fn_decl, idx: &uint) -> str {\n-    istr::to_estr(decl.inputs[idx].ident)\n+fn fn_arg_idx_to_str(decl: &ast::fn_decl, idx: &uint) -> istr {\n+    decl.inputs[idx].ident\n }\n \n-fn ast_fn_constr_to_str(decl: &ast::fn_decl, c: &@ast::constr) -> str {\n+fn ast_fn_constr_to_str(decl: &ast::fn_decl, c: &@ast::constr) -> istr {\n     let arg_to_str = bind fn_arg_idx_to_str(decl, _);\n     ret path_to_str(c.node.path) +\n             constr_args_to_str(arg_to_str, c.node.args);\n }\n \n // FIXME: fix repeated code\n-fn ast_fn_constrs_str(decl: &ast::fn_decl, constrs: &[@ast::constr]) -> str {\n-    let s = \"\";\n+fn ast_fn_constrs_str(decl: &ast::fn_decl, constrs: &[@ast::constr]) -> istr {\n+    let s = ~\"\";\n     let colon = true;\n     for c: @ast::constr in constrs {\n-        if colon { s += \" : \"; colon = false; } else { s += \", \"; }\n+        if colon { s += ~\" : \"; colon = false; } else { s += ~\", \"; }\n         s += ast_fn_constr_to_str(decl, c);\n     }\n     ret s;\n }\n \n-fn proto_to_str(p: &ast::proto) -> str {\n+fn proto_to_str(p: &ast::proto) -> istr {\n     ret alt p {\n-          ast::proto_fn. { \"fn\" }\n-          ast::proto_iter. { \"iter\" }\n-          ast::proto_block. { \"block\" }\n-          ast::proto_closure. { \"lambda\" }\n+          ast::proto_fn. { ~\"fn\" }\n+          ast::proto_iter. { ~\"iter\" }\n+          ast::proto_block. { ~\"block\" }\n+          ast::proto_closure. { ~\"lambda\" }\n         };\n }\n \n-fn ty_constr_to_str(c: &@ast::ty_constr) -> str {\n-    fn ty_constr_path_to_str(p: &ast::path) -> str { \"*.\" + path_to_str(p) }\n+fn ty_constr_to_str(c: &@ast::ty_constr) -> istr {\n+    fn ty_constr_path_to_str(p: &ast::path) -> istr { ~\"*.\" + path_to_str(p) }\n \n     ret path_to_str(c.node.path) +\n             constr_args_to_str::<ast::path>(ty_constr_path_to_str,\n                                             c.node.args);\n }\n \n \n-fn ast_ty_constrs_str(constrs: &[@ast::ty_constr]) -> str {\n-    let s = \"\";\n+fn ast_ty_constrs_str(constrs: &[@ast::ty_constr]) -> istr {\n+    let s = ~\"\";\n     let colon = true;\n     for c: @ast::ty_constr in constrs {\n-        if colon { s += \" : \"; colon = false; } else { s += \", \"; }\n+        if colon { s += ~\" : \"; colon = false; } else { s += ~\", \"; }\n         s += ty_constr_to_str(c);\n     }\n     ret s;"}, {"sha": "55dacf073a119b2472cf171abc2c849b468f892e", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cbad23a747c282d190e3c264f515765a938b0c98/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbad23a747c282d190e3c264f515765a938b0c98/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=cbad23a747c282d190e3c264f515765a938b0c98", "patch": "@@ -62,7 +62,7 @@ fn ty_to_str(cx: &ctxt, typ: &t) -> istr {\n     fn fn_to_str(cx: &ctxt, proto: ast::proto, ident: option::t<ast::ident>,\n                  inputs: &[arg], output: t, cf: ast::controlflow,\n                  constrs: &[@constr]) -> istr {\n-        let s = istr::from_estr(proto_to_str(proto));\n+        let s = proto_to_str(proto);\n         alt ident {\n           some(i) {\n             s += ~\" \";\n@@ -169,9 +169,8 @@ fn ty_to_short_str(cx: &ctxt, typ: t) -> istr {\n }\n \n fn constr_to_str(c: &@constr) -> istr {\n-    ret istr::from_estr(path_to_str(c.node.path)) +\n-        istr::from_estr(\n-            pprust::constr_args_to_str(pprust::uint_to_str, c.node.args));\n+    ret path_to_str(c.node.path) +\n+        pprust::constr_args_to_str(pprust::uint_to_str, c.node.args);\n }\n \n fn constrs_str(constrs: &[@constr]) -> istr {\n@@ -186,9 +185,8 @@ fn constrs_str(constrs: &[@constr]) -> istr {\n \n fn ty_constr_to_str<Q>(c: &@ast::spanned<ast::constr_general_<ast::path, Q>>)\n    -> istr {\n-    ret istr::from_estr(path_to_str(c.node.path)) +\n-        istr::from_estr(\n-            constr_args_to_str::<ast::path>(path_to_str, c.node.args));\n+    ret path_to_str(c.node.path) +\n+        constr_args_to_str::<ast::path>(path_to_str, c.node.args);\n }\n \n // Local Variables:"}, {"sha": "cc422556012a6ed62759dfc1317dfa04b92171a1", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cbad23a747c282d190e3c264f515765a938b0c98/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbad23a747c282d190e3c264f515765a938b0c98/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=cbad23a747c282d190e3c264f515765a938b0c98", "patch": "@@ -163,14 +163,15 @@ fn check_variants_of_ast(crate: &ast::crate, codemap: &codemap::codemap,\n     let exprsL = vec::len(exprs);\n     if exprsL < 100u {\n         for each i: uint in under(uint::min(exprsL, 20u)) {\n-            log_err \"Replacing... \" + pprust::expr_to_str(@exprs[i]);\n+            log_err ~\"Replacing... \" + pprust::expr_to_str(@exprs[i]);\n             for each j: uint in under(uint::min(exprsL, 5u)) {\n-                log_err \"With... \" + pprust::expr_to_str(@exprs[j]);\n+                log_err ~\"With... \" + pprust::expr_to_str(@exprs[j]);\n                 let crate2 = @replace_expr_in_crate(crate, i, exprs[j].node);\n                 // It would be best to test the *crate* for stability, but testing the\n                 // string for stability is easier and ok for now.\n                 let str3 =\n-                    as_str(bind pprust::print_crate(codemap, crate2, filename,\n+                    as_str(bind pprust::print_crate(codemap, crate2,\n+                                                    istr::from_estr(filename),\n                                                     io::string_reader(~\"\"), _,\n                                                     pprust::no_ann()));\n                 // 1u would be sane here, but the pretty-printer currently has lots of whitespace and paren issues,\n@@ -254,7 +255,8 @@ fn parse_and_print(code: &str) -> str {\n     //write_file(filename, code);\n     let crate = parser::parse_crate_from_source_str(\n         istr::from_estr(filename), istr::from_estr(code), [], sess);\n-    ret as_str(bind pprust::print_crate(sess.cm, crate, filename,\n+    ret as_str(bind pprust::print_crate(sess.cm, crate,\n+                                        istr::from_estr(filename),\n                                         io::string_reader(istr::from_estr(code)), _,\n                                         pprust::no_ann()));\n }\n@@ -364,7 +366,8 @@ fn check_variants(files: &[str]) {\n                 parser::parse_crate_from_source_str(\n                     istr::from_estr(file),\n                     istr::from_estr(s), [], sess);\n-            log_err as_str(bind pprust::print_crate(sess.cm, crate, file,\n+            log_err as_str(bind pprust::print_crate(sess.cm, crate,\n+                                                    istr::from_estr(file),\n                                                     io::string_reader(istr::from_estr(s)), _,\n                                                     pprust::no_ann()));\n             check_variants_of_ast(*crate, sess.cm, file);"}]}