{"sha": "d8c2956906eae34516f3d215cda16dc16656766a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4YzI5NTY5MDZlYWUzNDUxNmYzZDIxNWNkYTE2ZGMxNjY1Njc2NmE=", "commit": {"author": {"name": "BO41", "email": "botbob@disroot.org", "date": "2019-10-06T13:59:49Z"}, "committer": {"name": "BO41", "email": "botbob@disroot.org", "date": "2019-10-12T13:06:20Z"}, "message": "Improve docs on some char boolean methods", "tree": {"sha": "5c5c3ac9d61bea13737a191d06fbf07e6fa44d5d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c5c3ac9d61bea13737a191d06fbf07e6fa44d5d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d8c2956906eae34516f3d215cda16dc16656766a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d8c2956906eae34516f3d215cda16dc16656766a", "html_url": "https://github.com/rust-lang/rust/commit/d8c2956906eae34516f3d215cda16dc16656766a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d8c2956906eae34516f3d215cda16dc16656766a/comments", "author": null, "committer": null, "parents": [{"sha": "0358617e3f77e033c86139104c5c48a777824b08", "url": "https://api.github.com/repos/rust-lang/rust/commits/0358617e3f77e033c86139104c5c48a777824b08", "html_url": "https://github.com/rust-lang/rust/commit/0358617e3f77e033c86139104c5c48a777824b08"}], "stats": {"total": 172, "additions": 109, "deletions": 63}, "files": [{"sha": "971d89e004446e306a1ad424c43375e36f6d07b4", "filename": "src/libcore/char/methods.rs", "status": "modified", "additions": 109, "deletions": 63, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/d8c2956906eae34516f3d215cda16dc16656766a/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8c2956906eae34516f3d215cda16dc16656766a/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=d8c2956906eae34516f3d215cda16dc16656766a", "patch": "@@ -116,9 +116,9 @@ impl char {\n \n         // the code is split up here to improve execution speed for cases where\n         // the `radix` is constant and 10 or smaller\n-        let val = if radix <= 10  {\n+        let val = if radix <= 10 {\n             match self {\n-                '0' ..= '9' => self as u32 - '0' as u32,\n+                '0'..='9' => self as u32 - '0' as u32,\n                 _ => return None,\n             }\n         } else {\n@@ -130,8 +130,11 @@ impl char {\n             }\n         };\n \n-        if val < radix { Some(val) }\n-        else { None }\n+        if val < radix {\n+            Some(val)\n+        } else {\n+            None\n+        }\n     }\n \n     /// Returns an iterator that yields the hexadecimal Unicode escape of a\n@@ -303,8 +306,8 @@ impl char {\n             '\\r' => EscapeDefaultState::Backslash('r'),\n             '\\n' => EscapeDefaultState::Backslash('n'),\n             '\\\\' | '\\'' | '\"' => EscapeDefaultState::Backslash(self),\n-            '\\x20' ..= '\\x7e' => EscapeDefaultState::Char(self),\n-            _ => EscapeDefaultState::Unicode(self.escape_unicode())\n+            '\\x20'..='\\x7e' => EscapeDefaultState::Char(self),\n+            _ => EscapeDefaultState::Unicode(self.escape_unicode()),\n         };\n         EscapeDefault { state: init_state }\n     }\n@@ -436,30 +439,31 @@ impl char {\n     pub fn encode_utf8(self, dst: &mut [u8]) -> &mut str {\n         let code = self as u32;\n         unsafe {\n-            let len =\n-            if code < MAX_ONE_B && !dst.is_empty() {\n+            let len = if code < MAX_ONE_B && !dst.is_empty() {\n                 *dst.get_unchecked_mut(0) = code as u8;\n                 1\n             } else if code < MAX_TWO_B && dst.len() >= 2 {\n                 *dst.get_unchecked_mut(0) = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;\n                 *dst.get_unchecked_mut(1) = (code & 0x3F) as u8 | TAG_CONT;\n                 2\n-            } else if code < MAX_THREE_B && dst.len() >= 3  {\n+            } else if code < MAX_THREE_B && dst.len() >= 3 {\n                 *dst.get_unchecked_mut(0) = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;\n-                *dst.get_unchecked_mut(1) = (code >>  6 & 0x3F) as u8 | TAG_CONT;\n+                *dst.get_unchecked_mut(1) = (code >> 6 & 0x3F) as u8 | TAG_CONT;\n                 *dst.get_unchecked_mut(2) = (code & 0x3F) as u8 | TAG_CONT;\n                 3\n             } else if dst.len() >= 4 {\n                 *dst.get_unchecked_mut(0) = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;\n                 *dst.get_unchecked_mut(1) = (code >> 12 & 0x3F) as u8 | TAG_CONT;\n-                *dst.get_unchecked_mut(2) = (code >>  6 & 0x3F) as u8 | TAG_CONT;\n+                *dst.get_unchecked_mut(2) = (code >> 6 & 0x3F) as u8 | TAG_CONT;\n                 *dst.get_unchecked_mut(3) = (code & 0x3F) as u8 | TAG_CONT;\n                 4\n             } else {\n-                panic!(\"encode_utf8: need {} bytes to encode U+{:X}, but the buffer has {}\",\n+                panic!(\n+                    \"encode_utf8: need {} bytes to encode U+{:X}, but the buffer has {}\",\n                     from_u32_unchecked(code).len_utf8(),\n                     code,\n-                    dst.len())\n+                    dst.len(),\n+                )\n             };\n             from_utf8_unchecked_mut(dst.get_unchecked_mut(..len))\n         }\n@@ -515,15 +519,24 @@ impl char {\n                 *dst.get_unchecked_mut(1) = 0xDC00 | ((code as u16) & 0x3FF);\n                 slice::from_raw_parts_mut(dst.as_mut_ptr(), 2)\n             } else {\n-                panic!(\"encode_utf16: need {} units to encode U+{:X}, but the buffer has {}\",\n+                panic!(\n+                    \"encode_utf16: need {} units to encode U+{:X}, but the buffer has {}\",\n                     from_u32_unchecked(code).len_utf16(),\n                     code,\n-                    dst.len())\n+                    dst.len(),\n+                )\n             }\n         }\n     }\n \n-    /// Returns `true` if this `char` is an alphabetic code point, and false if not.\n+    /// Returns `true` if this `char` has the `Alphabetic` property.\n+    ///\n+    /// `Alphabetic` is described in Chapter 4 (Character Properties) of the [Unicode Standard] and\n+    /// specified in the [Unicode Character Database][ucd] [`DerivedCoreProperties.txt`].\n+    ///\n+    /// [Unicode Standard]: https://www.unicode.org/versions/latest/\n+    /// [ucd]: https://www.unicode.org/reports/tr44/\n+    /// [`DerivedCoreProperties.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/DerivedCoreProperties.txt\n     ///\n     /// # Examples\n     ///\n@@ -547,10 +560,14 @@ impl char {\n         }\n     }\n \n-    /// Returns `true` if this `char` is lowercase.\n+    /// Returns `true` if this `char` has the `Lowercase` property.\n     ///\n-    /// 'Lowercase' is defined according to the terms of the Unicode Derived Core\n-    /// Property `Lowercase`.\n+    /// `Lowercase` is described in Chapter 4 (Character Properties) of the [Unicode Standard] and\n+    /// specified in the [Unicode Character Database][ucd] [`DerivedCoreProperties.txt`].\n+    ///\n+    /// [Unicode Standard]: https://www.unicode.org/versions/latest/\n+    /// [ucd]: https://www.unicode.org/reports/tr44/\n+    /// [`DerivedCoreProperties.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/DerivedCoreProperties.txt\n     ///\n     /// # Examples\n     ///\n@@ -575,10 +592,14 @@ impl char {\n         }\n     }\n \n-    /// Returns `true` if this `char` is uppercase.\n+    /// Returns `true` if this `char` has the `Uppercase` property.\n+    ///\n+    /// `Uppercase` is described in Chapter 4 (Character Properties) of the [Unicode Standard] and\n+    /// specified in the [Unicode Character Database][ucd] [`DerivedCoreProperties.txt`].\n     ///\n-    /// 'Uppercase' is defined according to the terms of the Unicode Derived Core\n-    /// Property `Uppercase`.\n+    /// [Unicode Standard]: https://www.unicode.org/versions/latest/\n+    /// [ucd]: https://www.unicode.org/reports/tr44/\n+    /// [`DerivedCoreProperties.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/DerivedCoreProperties.txt\n     ///\n     /// # Examples\n     ///\n@@ -603,10 +624,12 @@ impl char {\n         }\n     }\n \n-    /// Returns `true` if this `char` is whitespace.\n+    /// Returns `true` if this `char` has the `White_Space` property.\n     ///\n-    /// 'Whitespace' is defined according to the terms of the Unicode Derived Core\n-    /// Property `White_Space`.\n+    /// `White_Space` is specified in the [Unicode Character Database][ucd] [`PropList.txt`].\n+    ///\n+    /// [ucd]: https://www.unicode.org/reports/tr44/\n+    /// [`PropList.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt\n     ///\n     /// # Examples\n     ///\n@@ -630,10 +653,10 @@ impl char {\n         }\n     }\n \n-    /// Returns `true` if this `char` is alphanumeric.\n+    /// Returns `true` if this `char` satisfies either [`is_alphabetic()`] or [`is_numeric()`].\n     ///\n-    /// 'Alphanumeric'-ness is defined in terms of the Unicode General Categories\n-    /// `Nd`, `Nl`, `No` and the Derived Core Property `Alphabetic`.\n+    /// [`is_alphabetic()`]: #method.is_alphabetic\n+    /// [`is_numeric()`]: #method.is_numeric\n     ///\n     /// # Examples\n     ///\n@@ -655,10 +678,15 @@ impl char {\n         self.is_alphabetic() || self.is_numeric()\n     }\n \n-    /// Returns `true` if this `char` is a control code point.\n+    /// Returns `true` if this `char` has the general category for control codes.\n+    ///\n+    /// Control codes (code points with the general category of `Cc`) are described in Chapter 4\n+    /// (Character Properties) of the [Unicode Standard] and specified in the [Unicode Character\n+    /// Database][ucd] [`UnicodeData.txt`].\n     ///\n-    /// 'Control code point' is defined in terms of the Unicode General\n-    /// Category `Cc`.\n+    /// [Unicode Standard]: https://www.unicode.org/versions/latest/\n+    /// [ucd]: https://www.unicode.org/reports/tr44/\n+    /// [`UnicodeData.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt\n     ///\n     /// # Examples\n     ///\n@@ -675,19 +703,29 @@ impl char {\n         general_category::Cc(self)\n     }\n \n-    /// Returns `true` if this `char` is an extended grapheme character.\n+    /// Returns `true` if this `char` has the `Grapheme_Extend` property.\n     ///\n-    /// 'Extended grapheme character' is defined in terms of the Unicode Shaping and Rendering\n-    /// Category `Grapheme_Extend`.\n+    /// `Grapheme_Extend` is described in [Unicode Standard Annex #29 (Unicode Text\n+    /// Segmentation)][uax29] and specified in the [Unicode Character Database][ucd]\n+    /// [`DerivedCoreProperties.txt`].\n+    ///\n+    /// [uax29]: https://www.unicode.org/reports/tr29/\n+    /// [ucd]: https://www.unicode.org/reports/tr44/\n+    /// [`DerivedCoreProperties.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/DerivedCoreProperties.txt\n     #[inline]\n     pub(crate) fn is_grapheme_extended(self) -> bool {\n         derived_property::Grapheme_Extend(self)\n     }\n \n-    /// Returns `true` if this `char` is numeric.\n+    /// Returns `true` if this `char` has one of the general categories for numbers.\n+    ///\n+    /// The general categories for numbers (`Nd` for decimal digits, `Nl` for letter-like numeric\n+    /// characters, and `No` for other numeric characters) are specified in the [Unicode Character\n+    /// Database][ucd] [`UnicodeData.txt`].\n     ///\n-    /// 'Numeric'-ness is defined in terms of the Unicode General Categories\n-    /// `Nd`, `Nl`, `No`.\n+    /// [Unicode Standard]: https://www.unicode.org/versions/latest/\n+    /// [ucd]: https://www.unicode.org/reports/tr44/\n+    /// [`UnicodeData.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt\n     ///\n     /// # Examples\n     ///\n@@ -713,25 +751,29 @@ impl char {\n         }\n     }\n \n-    /// Returns an iterator that yields the lowercase equivalent of a `char`\n-    /// as one or more `char`s.\n+    /// Returns an iterator that yields the lowercase mapping of this `char` as one or more\n+    /// `char`s.\n     ///\n-    /// If a character does not have a lowercase equivalent, the same character\n-    /// will be returned back by the iterator.\n+    /// If this `char` does not have a lowercase mapping, the iterator yields the same `char`.\n     ///\n-    /// This performs complex unconditional mappings with no tailoring: it maps\n-    /// one Unicode character to its lowercase equivalent according to the\n-    /// [Unicode database] and the additional complex mappings\n-    /// [`SpecialCasing.txt`]. Conditional mappings (based on context or\n-    /// language) are not considered here.\n+    /// If this `char` has a one-to-one lowercase mapping given by the [Unicode Character\n+    /// Database][ucd] [`UnicodeData.txt`], the iterator yields that `char`.\n     ///\n-    /// For a full reference, see [here][reference].\n+    /// [ucd]: https://www.unicode.org/reports/tr44/\n+    /// [`UnicodeData.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt\n     ///\n-    /// [Unicode database]: ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt\n+    /// If this `char` requires special considerations (e.g. multiple `char`s) the iterator yields\n+    /// the `char`(s) given by [`SpecialCasing.txt`].\n     ///\n-    /// [`SpecialCasing.txt`]: ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt\n+    /// [`SpecialCasing.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt\n     ///\n-    /// [reference]: http://www.unicode.org/versions/Unicode7.0.0/ch03.pdf#G33992\n+    /// This operation performs an unconditional mapping without tailoring. That is, the conversion\n+    /// is independent of context and language.\n+    ///\n+    /// In the [Unicode Standard], Chapter 4 (Character Properties) discusses case mapping in\n+    /// general and Chapter 3 (Conformance) discusses the default algorithm for case conversion.\n+    ///\n+    /// [Unicode Standard]: https://www.unicode.org/versions/latest/\n     ///\n     /// # Examples\n     ///\n@@ -774,25 +816,29 @@ impl char {\n         ToLowercase(CaseMappingIter::new(conversions::to_lower(self)))\n     }\n \n-    /// Returns an iterator that yields the uppercase equivalent of a `char`\n-    /// as one or more `char`s.\n+    /// Returns an iterator that yields the uppercase mapping of this `char` as one or more\n+    /// `char`s.\n+    ///\n+    /// If this `char` does not have a uppercase mapping, the iterator yields the same `char`.\n+    ///\n+    /// If this `char` has a one-to-one uppercase mapping given by the [Unicode Character\n+    /// Database][ucd] [`UnicodeData.txt`], the iterator yields that `char`.\n     ///\n-    /// If a character does not have an uppercase equivalent, the same character\n-    /// will be returned back by the iterator.\n+    /// [ucd]: https://www.unicode.org/reports/tr44/\n+    /// [`UnicodeData.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/UnicodeData.txt\n     ///\n-    /// This performs complex unconditional mappings with no tailoring: it maps\n-    /// one Unicode character to its uppercase equivalent according to the\n-    /// [Unicode database] and the additional complex mappings\n-    /// [`SpecialCasing.txt`]. Conditional mappings (based on context or\n-    /// language) are not considered here.\n+    /// If this `char` requires special considerations (e.g. multiple `char`s) the iterator yields\n+    /// the `char`(s) given by [`SpecialCasing.txt`].\n     ///\n-    /// For a full reference, see [here][reference].\n+    /// [`SpecialCasing.txt`]: https://www.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt\n     ///\n-    /// [Unicode database]: ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt\n+    /// This operation performs an unconditional mapping without tailoring. That is, the conversion\n+    /// is independent of context and language.\n     ///\n-    /// [`SpecialCasing.txt`]: ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt\n+    /// In the [Unicode Standard], Chapter 4 (Character Properties) discusses case mapping in\n+    /// general and Chapter 3 (Conformance) discusses the default algorithm for case conversion.\n     ///\n-    /// [reference]: http://www.unicode.org/versions/Unicode7.0.0/ch03.pdf#G33992\n+    /// [Unicode Standard]: https://www.unicode.org/versions/latest/\n     ///\n     /// # Examples\n     ///"}]}