{"sha": "38db483af750535774616810f1f8a4e6bdc17260", "node_id": "C_kwDOAAsO6NoAKDM4ZGI0ODNhZjc1MDUzNTc3NDYxNjgxMGYxZjhhNGU2YmRjMTcyNjA", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2022-10-09T15:09:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-10-09T15:09:40Z"}, "message": "Rollup merge of #102072 - scottmcm:ptr-alignment-type, r=thomcc\n\nAdd `ptr::Alignment` type\n\nEssentially no new code here, just exposing the previously-`pub(crate)` `ValidAlign` type under the name from the ACP.\n\nACP: https://github.com/rust-lang/libs-team/issues/108\nTracking Issue: https://github.com/rust-lang/rust/issues/102070\n\nr? ``@ghost``", "tree": {"sha": "b8fc769bd043f51b4aa34c4d53e90da181141b16", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8fc769bd043f51b4aa34c4d53e90da181141b16"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38db483af750535774616810f1f8a4e6bdc17260", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjQuQ0CRBK7hj4Ov3rIwAA+7kIAGZ8aJkPc4IemDdjs53GAoQ6\nYNW/z820imLm74aZ+o+3+9uPf7WNhtWvj475oKVUuMWKB9uZTiK5hTi2lTgrNhI/\nfwas6U2zochbOrJ/PtwKDsqmJd6G9kXwbpb1+JDiBropWNQ4Gch2VoiOH/ZhbWn1\ntwahjnn7gDlsS6NPSTo+2QXWFX1ZreSDBfVVuqL8X+td8vexuaNYS7mdIPA1WxVT\nZ5aSGW0Z84DWQ80c7qPM6wDXJEZ+zg8JyXe1qD0s01ITANv9NhPLpM5+51JIFgxp\n1dAcV9Tk9LXq6lYAAZvnaxx9uKuBggs8IEwrno0mk590Jv+uMl8lcAvvNSI9urY=\n=4Phj\n-----END PGP SIGNATURE-----\n", "payload": "tree b8fc769bd043f51b4aa34c4d53e90da181141b16\nparent d0f1cf5de77a3ffe584de17658fa501e4aea5770\nparent c158b7b7d03039027774b2aabcdb066c371b5d36\nauthor Yuki Okushi <jtitor@2k36.org> 1665328180 +0900\ncommitter GitHub <noreply@github.com> 1665328180 +0900\n\nRollup merge of #102072 - scottmcm:ptr-alignment-type, r=thomcc\n\nAdd `ptr::Alignment` type\n\nEssentially no new code here, just exposing the previously-`pub(crate)` `ValidAlign` type under the name from the ACP.\n\nACP: https://github.com/rust-lang/libs-team/issues/108\nTracking Issue: https://github.com/rust-lang/rust/issues/102070\n\nr? ``@ghost``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38db483af750535774616810f1f8a4e6bdc17260", "html_url": "https://github.com/rust-lang/rust/commit/38db483af750535774616810f1f8a4e6bdc17260", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38db483af750535774616810f1f8a4e6bdc17260/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0f1cf5de77a3ffe584de17658fa501e4aea5770", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0f1cf5de77a3ffe584de17658fa501e4aea5770", "html_url": "https://github.com/rust-lang/rust/commit/d0f1cf5de77a3ffe584de17658fa501e4aea5770"}, {"sha": "c158b7b7d03039027774b2aabcdb066c371b5d36", "url": "https://api.github.com/repos/rust-lang/rust/commits/c158b7b7d03039027774b2aabcdb066c371b5d36", "html_url": "https://github.com/rust-lang/rust/commit/c158b7b7d03039027774b2aabcdb066c371b5d36"}], "stats": {"total": 179, "additions": 115, "deletions": 64}, "files": [{"sha": "920e559cc4aa39e8d7eafed71a225b94b657e588", "filename": "library/core/src/alloc/layout.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/38db483af750535774616810f1f8a4e6bdc17260/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38db483af750535774616810f1f8a4e6bdc17260/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs?ref=38db483af750535774616810f1f8a4e6bdc17260", "patch": "@@ -64,6 +64,7 @@ impl Layout {\n     #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n     #[rustc_const_stable(feature = \"const_alloc_layout_size_align\", since = \"1.50.0\")]\n     #[inline]\n+    #[rustc_allow_const_fn_unstable(ptr_alignment_type)]\n     pub const fn from_size_align(size: usize, align: usize) -> Result<Self, LayoutError> {\n         if !align.is_power_of_two() {\n             return Err(LayoutError);\n@@ -113,6 +114,7 @@ impl Layout {\n     #[rustc_const_stable(feature = \"const_alloc_layout_unchecked\", since = \"1.36.0\")]\n     #[must_use]\n     #[inline]\n+    #[rustc_allow_const_fn_unstable(ptr_alignment_type)]\n     pub const unsafe fn from_size_align_unchecked(size: usize, align: usize) -> Self {\n         // SAFETY: the caller is required to uphold the preconditions.\n         unsafe { Layout { size, align: ValidAlign::new_unchecked(align) } }\n@@ -133,6 +135,7 @@ impl Layout {\n     #[must_use = \"this returns the minimum alignment, \\\n                   without modifying the layout\"]\n     #[inline]\n+    #[rustc_allow_const_fn_unstable(ptr_alignment_type)]\n     pub const fn align(&self) -> usize {\n         self.align.as_usize()\n     }"}, {"sha": "7d893ca4aa16a54996ba86b0ff87094fce7eb074", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/38db483af750535774616810f1f8a4e6bdc17260/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38db483af750535774616810f1f8a4e6bdc17260/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=38db483af750535774616810f1f8a4e6bdc17260", "patch": "@@ -152,6 +152,7 @@\n #![feature(core_panic)]\n #![feature(duration_consts_float)]\n #![feature(maybe_uninit_uninit_array)]\n+#![feature(ptr_alignment_type)]\n #![feature(ptr_metadata)]\n #![feature(slice_ptr_get)]\n #![feature(slice_split_at_unchecked)]"}, {"sha": "1a78efaf4ffad51778fd97238be30c8ad223ca54", "filename": "library/core/src/mem/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/38db483af750535774616810f1f8a4e6bdc17260/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38db483af750535774616810f1f8a4e6bdc17260/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs?ref=38db483af750535774616810f1f8a4e6bdc17260", "patch": "@@ -21,11 +21,10 @@ mod maybe_uninit;\n #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n pub use maybe_uninit::MaybeUninit;\n \n-mod valid_align;\n-// For now this type is left crate-local.  It could potentially make sense to expose\n-// it publicly, as it would be a nice parameter type for methods which need to take\n-// alignment as a parameter, such as `Layout::padding_needed_for`.\n-pub(crate) use valid_align::ValidAlign;\n+// FIXME: This is left here for now to avoid complications around pending reverts.\n+// Once <https://github.com/rust-lang/rust/issues/101899> is fully resolved,\n+// this should be removed and the references in `alloc::Layout` updated.\n+pub(crate) use ptr::Alignment as ValidAlign;\n \n mod transmutability;\n #[unstable(feature = \"transmutability\", issue = \"99571\")]"}, {"sha": "bdebf8baabe489c2ba834e11b7ca874c3eac4871", "filename": "library/core/src/ptr/alignment.rs", "status": "renamed", "additions": 103, "deletions": 59, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/38db483af750535774616810f1f8a4e6bdc17260/library%2Fcore%2Fsrc%2Fptr%2Falignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38db483af750535774616810f1f8a4e6bdc17260/library%2Fcore%2Fsrc%2Fptr%2Falignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Falignment.rs?ref=38db483af750535774616810f1f8a4e6bdc17260", "patch": "@@ -1,4 +1,4 @@\n-use crate::convert::TryFrom;\n+use crate::convert::{TryFrom, TryInto};\n use crate::intrinsics::assert_unsafe_precondition;\n use crate::num::NonZeroUsize;\n use crate::{cmp, fmt, hash, mem, num};\n@@ -8,134 +8,178 @@ use crate::{cmp, fmt, hash, mem, num};\n ///\n /// Note that particularly large alignments, while representable in this type,\n /// are likely not to be supported by actual allocators and linkers.\n-#[derive(Copy, Clone)]\n+#[unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n+#[derive(Copy, Clone, Eq, PartialEq)]\n #[repr(transparent)]\n-pub(crate) struct ValidAlign(ValidAlignEnum);\n+pub struct Alignment(AlignmentEnum);\n \n-// ValidAlign is `repr(usize)`, but via extra steps.\n-const _: () = assert!(mem::size_of::<ValidAlign>() == mem::size_of::<usize>());\n-const _: () = assert!(mem::align_of::<ValidAlign>() == mem::align_of::<usize>());\n+// Alignment is `repr(usize)`, but via extra steps.\n+const _: () = assert!(mem::size_of::<Alignment>() == mem::size_of::<usize>());\n+const _: () = assert!(mem::align_of::<Alignment>() == mem::align_of::<usize>());\n \n-impl ValidAlign {\n-    /// Creates a `ValidAlign` from a power-of-two `usize`.\n+fn _alignment_can_be_structurally_matched(a: Alignment) -> bool {\n+    matches!(a, Alignment::MIN)\n+}\n+\n+impl Alignment {\n+    /// The smallest possible alignment, 1.\n+    ///\n+    /// All addresses are always aligned at least this much.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ptr_alignment_type)]\n+    /// use std::ptr::Alignment;\n+    ///\n+    /// assert_eq!(Alignment::MIN.as_usize(), 1);\n+    /// ```\n+    #[unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n+    pub const MIN: Self = Self(AlignmentEnum::_Align1Shl0);\n+\n+    /// Returns the alignment for a type.\n+    ///\n+    /// This provides the same numerical value as [`mem::align_of`],\n+    /// but in an `Alignment` instead of a `usize.\n+    #[unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n+    #[inline]\n+    pub const fn of<T>() -> Self {\n+        // SAFETY: rustc ensures that type alignment is always a power of two.\n+        unsafe { Alignment::new_unchecked(mem::align_of::<T>()) }\n+    }\n+\n+    /// Creates an `Alignment` from a `usize`, or returns `None` if it's\n+    /// not a power of two.\n+    ///\n+    /// Note that `0` is not a power of two, nor a valid alignment.\n+    #[unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n+    #[inline]\n+    pub const fn new(align: usize) -> Option<Self> {\n+        if align.is_power_of_two() {\n+            // SAFETY: Just checked it only has one bit set\n+            Some(unsafe { Self::new_unchecked(align) })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Creates an `Alignment` from a power-of-two `usize`.\n     ///\n     /// # Safety\n     ///\n     /// `align` must be a power of two.\n     ///\n     /// Equivalently, it must be `1 << exp` for some `exp` in `0..usize::BITS`.\n     /// It must *not* be zero.\n+    #[unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n+    #[rustc_const_unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n     #[inline]\n-    pub(crate) const unsafe fn new_unchecked(align: usize) -> Self {\n+    pub const unsafe fn new_unchecked(align: usize) -> Self {\n         // SAFETY: Precondition passed to the caller.\n         unsafe { assert_unsafe_precondition!((align: usize) => align.is_power_of_two()) };\n \n         // SAFETY: By precondition, this must be a power of two, and\n         // our variants encompass all possible powers of two.\n-        unsafe { mem::transmute::<usize, ValidAlign>(align) }\n+        unsafe { mem::transmute::<usize, Alignment>(align) }\n     }\n \n+    /// Returns the alignment as a [`NonZeroUsize`]\n+    #[unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n+    #[rustc_const_unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n     #[inline]\n-    pub(crate) const fn as_usize(self) -> usize {\n+    pub const fn as_usize(self) -> usize {\n         self.0 as usize\n     }\n \n+    /// Returns the alignment as a [`usize`]\n+    #[unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n     #[inline]\n-    pub(crate) const fn as_nonzero(self) -> NonZeroUsize {\n+    pub const fn as_nonzero(self) -> NonZeroUsize {\n         // SAFETY: All the discriminants are non-zero.\n         unsafe { NonZeroUsize::new_unchecked(self.as_usize()) }\n     }\n \n-    /// Returns the base 2 logarithm of the alignment.\n+    /// Returns the base-2 logarithm of the alignment.\n     ///\n     /// This is always exact, as `self` represents a power of two.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(ptr_alignment_type)]\n+    /// use std::ptr::Alignment;\n+    ///\n+    /// assert_eq!(Alignment::of::<u8>().log2(), 0);\n+    /// assert_eq!(Alignment::new(1024).unwrap().log2(), 10);\n+    /// ```\n+    #[unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n     #[inline]\n-    pub(crate) fn log2(self) -> u32 {\n+    pub fn log2(self) -> u32 {\n         self.as_nonzero().trailing_zeros()\n     }\n-\n-    /// Returns the alignment for a type.\n-    #[inline]\n-    pub(crate) fn of<T>() -> Self {\n-        // SAFETY: rustc ensures that type alignment is always a power of two.\n-        unsafe { ValidAlign::new_unchecked(mem::align_of::<T>()) }\n-    }\n }\n \n-impl fmt::Debug for ValidAlign {\n+#[unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n+impl fmt::Debug for Alignment {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"{:?} (1 << {:?})\", self.as_nonzero(), self.log2())\n     }\n }\n \n-impl TryFrom<NonZeroUsize> for ValidAlign {\n+#[unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n+impl TryFrom<NonZeroUsize> for Alignment {\n     type Error = num::TryFromIntError;\n \n     #[inline]\n-    fn try_from(align: NonZeroUsize) -> Result<ValidAlign, Self::Error> {\n-        if align.is_power_of_two() {\n-            // SAFETY: Just checked for power-of-two\n-            unsafe { Ok(ValidAlign::new_unchecked(align.get())) }\n-        } else {\n-            Err(num::TryFromIntError(()))\n-        }\n+    fn try_from(align: NonZeroUsize) -> Result<Alignment, Self::Error> {\n+        align.get().try_into()\n     }\n }\n \n-impl TryFrom<usize> for ValidAlign {\n+#[unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n+impl TryFrom<usize> for Alignment {\n     type Error = num::TryFromIntError;\n \n     #[inline]\n-    fn try_from(align: usize) -> Result<ValidAlign, Self::Error> {\n-        if align.is_power_of_two() {\n-            // SAFETY: Just checked for power-of-two\n-            unsafe { Ok(ValidAlign::new_unchecked(align)) }\n-        } else {\n-            Err(num::TryFromIntError(()))\n-        }\n-    }\n-}\n-\n-impl cmp::Eq for ValidAlign {}\n-\n-impl cmp::PartialEq for ValidAlign {\n-    #[inline]\n-    fn eq(&self, other: &Self) -> bool {\n-        self.as_nonzero() == other.as_nonzero()\n+    fn try_from(align: usize) -> Result<Alignment, Self::Error> {\n+        Self::new(align).ok_or(num::TryFromIntError(()))\n     }\n }\n \n-impl cmp::Ord for ValidAlign {\n+#[unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n+impl cmp::Ord for Alignment {\n     #[inline]\n     fn cmp(&self, other: &Self) -> cmp::Ordering {\n         self.as_nonzero().cmp(&other.as_nonzero())\n     }\n }\n \n-impl cmp::PartialOrd for ValidAlign {\n+#[unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n+impl cmp::PartialOrd for Alignment {\n     #[inline]\n     fn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering> {\n         Some(self.cmp(other))\n     }\n }\n \n-impl hash::Hash for ValidAlign {\n+#[unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n+impl hash::Hash for Alignment {\n     #[inline]\n     fn hash<H: hash::Hasher>(&self, state: &mut H) {\n         self.as_nonzero().hash(state)\n     }\n }\n \n #[cfg(target_pointer_width = \"16\")]\n-type ValidAlignEnum = ValidAlignEnum16;\n+type AlignmentEnum = AlignmentEnum16;\n #[cfg(target_pointer_width = \"32\")]\n-type ValidAlignEnum = ValidAlignEnum32;\n+type AlignmentEnum = AlignmentEnum32;\n #[cfg(target_pointer_width = \"64\")]\n-type ValidAlignEnum = ValidAlignEnum64;\n+type AlignmentEnum = AlignmentEnum64;\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Eq, PartialEq)]\n #[repr(u16)]\n-enum ValidAlignEnum16 {\n+enum AlignmentEnum16 {\n     _Align1Shl0 = 1 << 0,\n     _Align1Shl1 = 1 << 1,\n     _Align1Shl2 = 1 << 2,\n@@ -154,9 +198,9 @@ enum ValidAlignEnum16 {\n     _Align1Shl15 = 1 << 15,\n }\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Eq, PartialEq)]\n #[repr(u32)]\n-enum ValidAlignEnum32 {\n+enum AlignmentEnum32 {\n     _Align1Shl0 = 1 << 0,\n     _Align1Shl1 = 1 << 1,\n     _Align1Shl2 = 1 << 2,\n@@ -191,9 +235,9 @@ enum ValidAlignEnum32 {\n     _Align1Shl31 = 1 << 31,\n }\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Eq, PartialEq)]\n #[repr(u64)]\n-enum ValidAlignEnum64 {\n+enum AlignmentEnum64 {\n     _Align1Shl0 = 1 << 0,\n     _Align1Shl1 = 1 << 1,\n     _Align1Shl2 = 1 << 2,", "previous_filename": "library/core/src/mem/valid_align.rs"}, {"sha": "1f7cf6e5d052ca6f1e33b1f5a0580f811f4bcd4e", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38db483af750535774616810f1f8a4e6bdc17260/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38db483af750535774616810f1f8a4e6bdc17260/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=38db483af750535774616810f1f8a4e6bdc17260", "patch": "@@ -377,6 +377,10 @@ use crate::intrinsics::{\n \n use crate::mem::{self, MaybeUninit};\n \n+mod alignment;\n+#[unstable(feature = \"ptr_alignment_type\", issue = \"102070\")]\n+pub use alignment::Alignment;\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(inline)]\n pub use crate::intrinsics::copy_nonoverlapping;"}]}