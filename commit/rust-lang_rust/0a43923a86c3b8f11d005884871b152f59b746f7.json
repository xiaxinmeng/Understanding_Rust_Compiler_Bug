{"sha": "0a43923a86c3b8f11d005884871b152f59b746f7", "node_id": "C_kwDOAAsO6NoAKDBhNDM5MjNhODZjM2I4ZjExZDAwNTg4NDg3MWIxNTJmNTliNzQ2Zjc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-31T14:55:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-31T14:55:33Z"}, "message": "Auto merge of #97419 - WaffleLapkin:const_from_ptr_range, r=oli-obk\n\nMake `from{,_mut}_ptr_range` const\n\nThis PR makes the following APIs `const`:\n```rust\n// core::slice\n\npub const unsafe fn from_ptr_range<'a, T>(range: Range<*const T>) -> &'a [T];\npub const unsafe fn from_mut_ptr_range<'a, T>(range: Range<*mut T>) -> &'a mut [T];\n```\n\nTracking issue: #89792.\nFeature for `from_ptr_range` as a `const fn`: `slice_from_ptr_range_const`.\nFeature for `from_mut_ptr_range` as a `const fn`: `slice_from_mut_ptr_range_const`.\n\nr? `@oli-obk`", "tree": {"sha": "fff7b234e4c977228aba495c311308de7036e7f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fff7b234e4c977228aba495c311308de7036e7f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a43923a86c3b8f11d005884871b152f59b746f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a43923a86c3b8f11d005884871b152f59b746f7", "html_url": "https://github.com/rust-lang/rust/commit/0a43923a86c3b8f11d005884871b152f59b746f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a43923a86c3b8f11d005884871b152f59b746f7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16a0d03698bfc9f93250490797f9a1a870f8bcfe", "url": "https://api.github.com/repos/rust-lang/rust/commits/16a0d03698bfc9f93250490797f9a1a870f8bcfe", "html_url": "https://github.com/rust-lang/rust/commit/16a0d03698bfc9f93250490797f9a1a870f8bcfe"}, {"sha": "3a2bb782289a9cc34d4b4f7ed8e0b7a5c3bbf486", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a2bb782289a9cc34d4b4f7ed8e0b7a5c3bbf486", "html_url": "https://github.com/rust-lang/rust/commit/3a2bb782289a9cc34d4b4f7ed8e0b7a5c3bbf486"}], "stats": {"total": 774, "additions": 772, "deletions": 2}, "files": [{"sha": "35b8b386dceff21008885576aede37c0f9478511", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a43923a86c3b8f11d005884871b152f59b746f7/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a43923a86c3b8f11d005884871b152f59b746f7/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=0a43923a86c3b8f11d005884871b152f59b746f7", "patch": "@@ -130,6 +130,7 @@\n #![feature(ptr_sub_ptr)]\n #![feature(receiver_trait)]\n #![feature(set_ptr_value)]\n+#![feature(slice_from_ptr_range)]\n #![feature(slice_group_by)]\n #![feature(slice_ptr_get)]\n #![feature(slice_ptr_len)]"}, {"sha": "4a9cecd9b4e1a3f3cf1297d1dbdbdf8f96962c9a", "filename": "library/alloc/src/slice.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a43923a86c3b8f11d005884871b152f59b746f7/library%2Falloc%2Fsrc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a43923a86c3b8f11d005884871b152f59b746f7/library%2Falloc%2Fsrc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fslice.rs?ref=0a43923a86c3b8f11d005884871b152f59b746f7", "patch": "@@ -114,6 +114,8 @@ pub use core::slice::EscapeAscii;\n pub use core::slice::SliceIndex;\n #[stable(feature = \"from_ref\", since = \"1.28.0\")]\n pub use core::slice::{from_mut, from_ref};\n+#[unstable(feature = \"slice_from_ptr_range\", issue = \"89792\")]\n+pub use core::slice::{from_mut_ptr_range, from_ptr_range};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::slice::{from_raw_parts, from_raw_parts_mut};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "8ce1d18caaeb9fd3c6dda5003c44a7cb184b514c", "filename": "library/core/src/slice/raw.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a43923a86c3b8f11d005884871b152f59b746f7/library%2Fcore%2Fsrc%2Fslice%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a43923a86c3b8f11d005884871b152f59b746f7/library%2Fcore%2Fsrc%2Fslice%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fraw.rs?ref=0a43923a86c3b8f11d005884871b152f59b746f7", "patch": "@@ -213,7 +213,8 @@ pub const fn from_mut<T>(s: &mut T) -> &mut [T] {\n ///\n /// [valid]: ptr#safety\n #[unstable(feature = \"slice_from_ptr_range\", issue = \"89792\")]\n-pub unsafe fn from_ptr_range<'a, T>(range: Range<*const T>) -> &'a [T] {\n+#[rustc_const_unstable(feature = \"const_slice_from_ptr_range\", issue = \"89792\")]\n+pub const unsafe fn from_ptr_range<'a, T>(range: Range<*const T>) -> &'a [T] {\n     // SAFETY: the caller must uphold the safety contract for `from_ptr_range`.\n     unsafe { from_raw_parts(range.start, range.end.sub_ptr(range.start)) }\n }\n@@ -263,7 +264,8 @@ pub unsafe fn from_ptr_range<'a, T>(range: Range<*const T>) -> &'a [T] {\n ///\n /// [valid]: ptr#safety\n #[unstable(feature = \"slice_from_ptr_range\", issue = \"89792\")]\n-pub unsafe fn from_mut_ptr_range<'a, T>(range: Range<*mut T>) -> &'a mut [T] {\n+#[rustc_const_unstable(feature = \"slice_from_mut_ptr_range_const\", issue = \"89792\")]\n+pub const unsafe fn from_mut_ptr_range<'a, T>(range: Range<*mut T>) -> &'a mut [T] {\n     // SAFETY: the caller must uphold the safety contract for `from_mut_ptr_range`.\n     unsafe { from_raw_parts_mut(range.start, range.end.sub_ptr(range.start)) }\n }"}, {"sha": "645283d8fe5ac2248072952210579daa0f5b5398", "filename": "src/test/ui/const-ptr/allowed_slices.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/0a43923a86c3b8f11d005884871b152f59b746f7/src%2Ftest%2Fui%2Fconst-ptr%2Fallowed_slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a43923a86c3b8f11d005884871b152f59b746f7/src%2Ftest%2Fui%2Fconst-ptr%2Fallowed_slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-ptr%2Fallowed_slices.rs?ref=0a43923a86c3b8f11d005884871b152f59b746f7", "patch": "@@ -0,0 +1,106 @@\n+// run-pass\n+#![feature(\n+    const_slice_from_raw_parts,\n+    slice_from_ptr_range,\n+    const_slice_from_ptr_range,\n+    pointer_byte_offsets,\n+    const_pointer_byte_offsets\n+)]\n+use std::{\n+    mem::MaybeUninit,\n+    ptr,\n+    slice::{from_ptr_range, from_raw_parts},\n+};\n+\n+// Dangling is ok, as long as it's either for ZST reads or for no reads\n+pub static S0: &[u32] = unsafe { from_raw_parts(dangling(), 0) };\n+pub static S1: &[()] = unsafe { from_raw_parts(dangling(), 3) };\n+\n+// References are always valid of reads of a single element (basically `slice::from_ref`)\n+pub static S2: &[u32] = unsafe { from_raw_parts(&D0, 1) };\n+pub static S3: &[MaybeUninit<&u32>] = unsafe { from_raw_parts(&D1, 1) };\n+\n+// Reinterpreting data is fine, as long as layouts match\n+pub static S4: &[u8] = unsafe { from_raw_parts((&D0) as *const _ as _, 3) };\n+// This is only valid because D1 has uninitialized bytes, if it was an initialized pointer,\n+// that would reinterpret pointers as integers which is UB in CTFE.\n+pub static S5: &[MaybeUninit<u8>] = unsafe { from_raw_parts((&D1) as *const _ as _, 2) };\n+// Even though u32 and [bool; 4] have different layouts, D0 has a value that\n+// is valid as [bool; 4], so this is not UB (it's basically a transmute)\n+pub static S6: &[bool] = unsafe { from_raw_parts((&D0) as *const _ as _, 4) };\n+\n+// Structs are considered single allocated objects,\n+// as long as you don't reinterpret padding as initialized\n+// data everything is ok.\n+pub static S7: &[u16] = unsafe {\n+    let ptr = (&D2 as *const Struct as *const u16).byte_add(4);\n+\n+    from_raw_parts(ptr, 3)\n+};\n+pub static S8: &[MaybeUninit<u16>] = unsafe {\n+    let ptr = &D2 as *const Struct as *const MaybeUninit<u16>;\n+\n+    from_raw_parts(ptr, 6)\n+};\n+\n+pub static R0: &[u32] = unsafe { from_ptr_range(dangling()..dangling()) };\n+// from_ptr_range panics on zst\n+//pub static R1: &[()] = unsafe { from_ptr_range(dangling(), dangling().byte_add(3)) };\n+pub static R2: &[u32] = unsafe {\n+    let ptr = &D0 as *const u32;\n+    from_ptr_range(ptr..ptr.add(1))\n+};\n+pub static R3: &[MaybeUninit<&u32>] = unsafe {\n+    let ptr = &D1 as *const MaybeUninit<&u32>;\n+    from_ptr_range(ptr..ptr.add(1))\n+};\n+pub static R4: &[u8] = unsafe {\n+    let ptr = &D0 as *const u32 as *const u8;\n+    from_ptr_range(ptr..ptr.add(3))\n+};\n+pub static R5: &[MaybeUninit<u8>] = unsafe {\n+    let ptr = &D1 as *const MaybeUninit<&u32> as *const MaybeUninit<u8>;\n+    from_ptr_range(ptr..ptr.add(2))\n+};\n+pub static R6: &[bool] = unsafe {\n+    let ptr = &D0 as *const u32 as *const bool;\n+    from_ptr_range(ptr..ptr.add(4))\n+};\n+pub static R7: &[u16] = unsafe {\n+    let d2 = &D2;\n+    let l = &d2.b as *const u32 as *const u16;\n+    let r = &d2.d as *const u8 as *const u16;\n+\n+    from_ptr_range(l..r)\n+};\n+pub static R8: &[MaybeUninit<u16>] = unsafe {\n+    let d2 = &D2;\n+    let l = d2 as *const Struct as *const MaybeUninit<u16>;\n+    let r = &d2.d as *const u8 as *const MaybeUninit<u16>;\n+\n+    from_ptr_range(l..r)\n+};\n+\n+// Using valid slice is always valid\n+pub static R9: &[u32] = unsafe { from_ptr_range(R0.as_ptr_range()) };\n+pub static R10: &[u32] = unsafe { from_ptr_range(R2.as_ptr_range()) };\n+\n+const D0: u32 = (1 << 16) | 1;\n+const D1: MaybeUninit<&u32> = MaybeUninit::uninit();\n+const D2: Struct = Struct { a: 1, b: 2, c: 3, d: 4 };\n+\n+const fn dangling<T>() -> *const T {\n+    ptr::NonNull::dangling().as_ptr() as _\n+}\n+\n+#[repr(C)]\n+struct Struct {\n+    a: u8,\n+    // _pad: [MaybeUninit<u8>; 3]\n+    b: u32,\n+    c: u16,\n+    d: u8,\n+    // _pad: [MaybeUninit<u8>; 1]\n+}\n+\n+fn main() {}"}, {"sha": "5b0b9aa9666e52417163fd4d38479200e9662bff", "filename": "src/test/ui/const-ptr/forbidden_slices.32bit.stderr", "status": "added", "additions": 280, "deletions": 0, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/0a43923a86c3b8f11d005884871b152f59b746f7/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0a43923a86c3b8f11d005884871b152f59b746f7/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.32bit.stderr?ref=0a43923a86c3b8f11d005884871b152f59b746f7", "patch": "@@ -0,0 +1,280 @@\n+error[E0080]: could not evaluate static initializer\n+  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+   |\n+LL |         &*ptr::slice_from_raw_parts(data, len)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         dereferencing pointer failed: null pointer is not a valid pointer\n+   |         inside `std::slice::from_raw_parts::<u32>` at $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+   |\n+  ::: $DIR/forbidden_slices.rs:19:34\n+   |\n+LL | pub static S0: &[u32] = unsafe { from_raw_parts(ptr::null(), 0) };\n+   |                                  ------------------------------ inside `S0` at $DIR/forbidden_slices.rs:19:34\n+\n+error[E0080]: could not evaluate static initializer\n+  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+   |\n+LL |         &*ptr::slice_from_raw_parts(data, len)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         dereferencing pointer failed: null pointer is not a valid pointer\n+   |         inside `std::slice::from_raw_parts::<()>` at $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+   |\n+  ::: $DIR/forbidden_slices.rs:20:33\n+   |\n+LL | pub static S1: &[()] = unsafe { from_raw_parts(ptr::null(), 0) };\n+   |                                 ------------------------------ inside `S1` at $DIR/forbidden_slices.rs:20:33\n+\n+error[E0080]: could not evaluate static initializer\n+  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+   |\n+LL |         &*ptr::slice_from_raw_parts(data, len)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         dereferencing pointer failed: ALLOC_ID has size 4, so pointer to 8 bytes starting at offset 0 is out-of-bounds\n+   |         inside `std::slice::from_raw_parts::<u32>` at $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+   |\n+  ::: $DIR/forbidden_slices.rs:23:34\n+   |\n+LL | pub static S2: &[u32] = unsafe { from_raw_parts(&D0, 2) };\n+   |                                  ---------------------- inside `S2` at $DIR/forbidden_slices.rs:23:34\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/forbidden_slices.rs:26:1\n+   |\n+LL | pub static S4: &[u8] = unsafe { from_raw_parts((&D1) as *const _ as _, 1) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .<deref>[0]: encountered uninitialized bytes\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257e\u2500ALLOC_ID\u2500\u257c 01 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/forbidden_slices.rs:28:1\n+   |\n+LL | pub static S5: &[u8] = unsafe { from_raw_parts((&D3) as *const _ as _, size_of::<&u32>()) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .<deref>: encountered a pointer, but expected plain (non-pointer) bytes\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257e\u2500ALLOC_ID\u2500\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/forbidden_slices.rs:30:1\n+   |\n+LL | pub static S6: &[bool] = unsafe { from_raw_parts((&D0) as *const _ as _, 4) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .<deref>[0]: encountered 0x11, but expected a boolean\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257e\u2500ALLOC_ID\u2500\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/forbidden_slices.rs:33:1\n+   |\n+LL | / pub static S7: &[u16] = unsafe {\n+LL | |\n+LL | |     let ptr = (&D2 as *const Struct as *const u16).byte_add(1);\n+LL | |\n+LL | |     from_raw_parts(ptr, 4)\n+LL | | };\n+   | |__^ type validation failed: encountered an unaligned reference (required 2 byte alignment but found 1)\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257e\u2500A_ID+0x1\u2500\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error[E0080]: could not evaluate static initializer\n+  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+   |\n+LL |         &*ptr::slice_from_raw_parts(data, len)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         dereferencing pointer failed: ALLOC_ID has size 8, so pointer to 8 bytes starting at offset 1 is out-of-bounds\n+   |         inside `std::slice::from_raw_parts::<u64>` at $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+   |\n+  ::: $DIR/forbidden_slices.rs:44:5\n+   |\n+LL |     from_raw_parts(ptr, 1)\n+   |     ---------------------- inside `S8` at $DIR/forbidden_slices.rs:44:5\n+\n+error[E0080]: could not evaluate static initializer\n+  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  |\n+   |                  out-of-bounds offset_from: null pointer is not a valid pointer\n+   |                  inside `ptr::const_ptr::<impl *const u32>::sub_ptr` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |\n+  ::: $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+   |\n+LL |     unsafe { from_raw_parts(range.start, range.end.sub_ptr(range.start)) }\n+   |                                          ------------------------------ inside `from_ptr_range::<u32>` at $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+   |\n+  ::: $DIR/forbidden_slices.rs:47:34\n+   |\n+LL | pub static R0: &[u32] = unsafe { from_ptr_range(ptr::null()..ptr::null()) };\n+   |                                  ---------------------------------------- inside `R0` at $DIR/forbidden_slices.rs:47:34\n+\n+error[E0080]: could not evaluate static initializer\n+  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         assert!(0 < pointee_size && pointee_size <= isize::MAX as usize);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         the evaluated program panicked at 'assertion failed: 0 < pointee_size && pointee_size <= isize::MAX as usize', $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |         inside `ptr::const_ptr::<impl *const ()>::sub_ptr` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |\n+  ::: $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+   |\n+LL |     unsafe { from_raw_parts(range.start, range.end.sub_ptr(range.start)) }\n+   |                                          ------------------------------ inside `from_ptr_range::<()>` at $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+   |\n+  ::: $DIR/forbidden_slices.rs:48:33\n+   |\n+LL | pub static R1: &[()] = unsafe { from_ptr_range(ptr::null()..ptr::null()) };\n+   |                                 ---------------------------------------- inside `R1` at $DIR/forbidden_slices.rs:48:33\n+   |\n+   = note: this error originates in the macro `assert` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0080]: could not evaluate static initializer\n+  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         unsafe { intrinsics::offset(self, count) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  |\n+   |                  pointer arithmetic failed: ALLOC_ID has size 4, so pointer to 8 bytes starting at offset 0 is out-of-bounds\n+   |                  inside `ptr::const_ptr::<impl *const u32>::offset` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+...\n+LL |         unsafe { self.offset(count as isize) }\n+   |                  --------------------------- inside `ptr::const_ptr::<impl *const u32>::add` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |\n+  ::: $DIR/forbidden_slices.rs:51:25\n+   |\n+LL |     from_ptr_range(ptr..ptr.add(2))\n+   |                         ---------- inside `R2` at $DIR/forbidden_slices.rs:51:25\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/forbidden_slices.rs:53:1\n+   |\n+LL | / pub static R4: &[u8] = unsafe {\n+LL | |\n+LL | |     let ptr = (&D1) as *const MaybeUninit<&u32> as *const u8;\n+LL | |     from_ptr_range(ptr..ptr.add(1))\n+LL | | };\n+   | |__^ type validation failed at .<deref>[0]: encountered uninitialized bytes\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u2500\u257c 01 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/forbidden_slices.rs:58:1\n+   |\n+LL | / pub static R5: &[u8] = unsafe {\n+LL | |\n+LL | |     let ptr = &D3 as *const &u32;\n+LL | |     from_ptr_range(ptr.cast()..ptr.add(1).cast())\n+LL | | };\n+   | |__^ type validation failed at .<deref>: encountered a pointer, but expected plain (non-pointer) bytes\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u2500\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/forbidden_slices.rs:63:1\n+   |\n+LL | / pub static R6: &[bool] = unsafe {\n+LL | |\n+LL | |     let ptr = &D0 as *const u32 as *const bool;\n+LL | |     from_ptr_range(ptr..ptr.add(4))\n+LL | | };\n+   | |__^ type validation failed at .<deref>[0]: encountered 0x11, but expected a boolean\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eALLOC_ID\u2500\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/forbidden_slices.rs:68:1\n+   |\n+LL | / pub static R7: &[u16] = unsafe {\n+LL | |\n+LL | |     let ptr = (&D2 as *const Struct as *const u16).byte_add(1);\n+LL | |     from_ptr_range(ptr..ptr.add(4))\n+LL | | };\n+   | |__^ type validation failed: encountered an unaligned reference (required 2 byte alignment but found 1)\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 8, align: 4) {\n+               \u257eA_ID+0x1\u2500\u257c 04 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+           }\n+\n+error[E0080]: could not evaluate static initializer\n+  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         unsafe { intrinsics::offset(self, count) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  |\n+   |                  pointer arithmetic failed: ALLOC_ID has size 8, so pointer to 8 bytes starting at offset 1 is out-of-bounds\n+   |                  inside `ptr::const_ptr::<impl *const u64>::offset` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+...\n+LL |         unsafe { self.offset(count as isize) }\n+   |                  --------------------------- inside `ptr::const_ptr::<impl *const u64>::add` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |\n+  ::: $DIR/forbidden_slices.rs:75:25\n+   |\n+LL |     from_ptr_range(ptr..ptr.add(1))\n+   |                         ---------- inside `R8` at $DIR/forbidden_slices.rs:75:25\n+\n+error[E0080]: could not evaluate static initializer\n+  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  |\n+   |                  ptr_offset_from_unsigned cannot compute offset of pointers into different allocations.\n+   |                  inside `ptr::const_ptr::<impl *const u32>::sub_ptr` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |\n+  ::: $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+   |\n+LL |     unsafe { from_raw_parts(range.start, range.end.sub_ptr(range.start)) }\n+   |                                          ------------------------------ inside `from_ptr_range::<u32>` at $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+   |\n+  ::: $DIR/forbidden_slices.rs:80:34\n+   |\n+LL | pub static R9: &[u32] = unsafe { from_ptr_range(&D0..(&D0 as *const u32).add(1)) };\n+   |                                  ----------------------------------------------- inside `R9` at $DIR/forbidden_slices.rs:80:34\n+\n+error[E0080]: could not evaluate static initializer\n+  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  |\n+   |                  ptr_offset_from_unsigned cannot compute offset of pointers into different allocations.\n+   |                  inside `ptr::const_ptr::<impl *const u32>::sub_ptr` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |\n+  ::: $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+   |\n+LL |     unsafe { from_raw_parts(range.start, range.end.sub_ptr(range.start)) }\n+   |                                          ------------------------------ inside `from_ptr_range::<u32>` at $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+   |\n+  ::: $DIR/forbidden_slices.rs:81:35\n+   |\n+LL | pub static R10: &[u32] = unsafe { from_ptr_range(&D0..&D0) };\n+   |                                   ------------------------ inside `R10` at $DIR/forbidden_slices.rs:81:35\n+\n+error: aborting due to 18 previous errors\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "b75e6c5024667f1d02c75508d894193a3596b32b", "filename": "src/test/ui/const-ptr/forbidden_slices.64bit.stderr", "status": "added", "additions": 280, "deletions": 0, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/0a43923a86c3b8f11d005884871b152f59b746f7/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0a43923a86c3b8f11d005884871b152f59b746f7/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.64bit.stderr?ref=0a43923a86c3b8f11d005884871b152f59b746f7", "patch": "@@ -0,0 +1,280 @@\n+error[E0080]: could not evaluate static initializer\n+  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+   |\n+LL |         &*ptr::slice_from_raw_parts(data, len)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         dereferencing pointer failed: null pointer is not a valid pointer\n+   |         inside `std::slice::from_raw_parts::<u32>` at $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+   |\n+  ::: $DIR/forbidden_slices.rs:19:34\n+   |\n+LL | pub static S0: &[u32] = unsafe { from_raw_parts(ptr::null(), 0) };\n+   |                                  ------------------------------ inside `S0` at $DIR/forbidden_slices.rs:19:34\n+\n+error[E0080]: could not evaluate static initializer\n+  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+   |\n+LL |         &*ptr::slice_from_raw_parts(data, len)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         dereferencing pointer failed: null pointer is not a valid pointer\n+   |         inside `std::slice::from_raw_parts::<()>` at $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+   |\n+  ::: $DIR/forbidden_slices.rs:20:33\n+   |\n+LL | pub static S1: &[()] = unsafe { from_raw_parts(ptr::null(), 0) };\n+   |                                 ------------------------------ inside `S1` at $DIR/forbidden_slices.rs:20:33\n+\n+error[E0080]: could not evaluate static initializer\n+  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+   |\n+LL |         &*ptr::slice_from_raw_parts(data, len)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         dereferencing pointer failed: ALLOC_ID has size 4, so pointer to 8 bytes starting at offset 0 is out-of-bounds\n+   |         inside `std::slice::from_raw_parts::<u32>` at $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+   |\n+  ::: $DIR/forbidden_slices.rs:23:34\n+   |\n+LL | pub static S2: &[u32] = unsafe { from_raw_parts(&D0, 2) };\n+   |                                  ---------------------- inside `S2` at $DIR/forbidden_slices.rs:23:34\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/forbidden_slices.rs:26:1\n+   |\n+LL | pub static S4: &[u8] = unsafe { from_raw_parts((&D1) as *const _ as _, 1) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .<deref>[0]: encountered uninitialized bytes\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500ALLOC_ID\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 01 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/forbidden_slices.rs:28:1\n+   |\n+LL | pub static S5: &[u8] = unsafe { from_raw_parts((&D3) as *const _ as _, size_of::<&u32>()) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .<deref>: encountered a pointer, but expected plain (non-pointer) bytes\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500ALLOC_ID\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 08 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/forbidden_slices.rs:30:1\n+   |\n+LL | pub static S6: &[bool] = unsafe { from_raw_parts((&D0) as *const _ as _, 4) };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed at .<deref>[0]: encountered 0x11, but expected a boolean\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500ALLOC_ID\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 04 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/forbidden_slices.rs:33:1\n+   |\n+LL | / pub static S7: &[u16] = unsafe {\n+LL | |\n+LL | |     let ptr = (&D2 as *const Struct as *const u16).byte_add(1);\n+LL | |\n+LL | |     from_raw_parts(ptr, 4)\n+LL | | };\n+   | |__^ type validation failed: encountered an unaligned reference (required 2 byte alignment but found 1)\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257e\u2500\u2500\u2500\u2500\u2500ALLOC_ID+0x1\u2500\u2500\u2500\u2500\u2500\u257c 04 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error[E0080]: could not evaluate static initializer\n+  --> $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+   |\n+LL |         &*ptr::slice_from_raw_parts(data, len)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         dereferencing pointer failed: ALLOC_ID has size 8, so pointer to 8 bytes starting at offset 1 is out-of-bounds\n+   |         inside `std::slice::from_raw_parts::<u64>` at $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+   |\n+  ::: $DIR/forbidden_slices.rs:44:5\n+   |\n+LL |     from_raw_parts(ptr, 1)\n+   |     ---------------------- inside `S8` at $DIR/forbidden_slices.rs:44:5\n+\n+error[E0080]: could not evaluate static initializer\n+  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  |\n+   |                  out-of-bounds offset_from: null pointer is not a valid pointer\n+   |                  inside `ptr::const_ptr::<impl *const u32>::sub_ptr` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |\n+  ::: $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+   |\n+LL |     unsafe { from_raw_parts(range.start, range.end.sub_ptr(range.start)) }\n+   |                                          ------------------------------ inside `from_ptr_range::<u32>` at $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+   |\n+  ::: $DIR/forbidden_slices.rs:47:34\n+   |\n+LL | pub static R0: &[u32] = unsafe { from_ptr_range(ptr::null()..ptr::null()) };\n+   |                                  ---------------------------------------- inside `R0` at $DIR/forbidden_slices.rs:47:34\n+\n+error[E0080]: could not evaluate static initializer\n+  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         assert!(0 < pointee_size && pointee_size <= isize::MAX as usize);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         the evaluated program panicked at 'assertion failed: 0 < pointee_size && pointee_size <= isize::MAX as usize', $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |         inside `ptr::const_ptr::<impl *const ()>::sub_ptr` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |\n+  ::: $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+   |\n+LL |     unsafe { from_raw_parts(range.start, range.end.sub_ptr(range.start)) }\n+   |                                          ------------------------------ inside `from_ptr_range::<()>` at $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+   |\n+  ::: $DIR/forbidden_slices.rs:48:33\n+   |\n+LL | pub static R1: &[()] = unsafe { from_ptr_range(ptr::null()..ptr::null()) };\n+   |                                 ---------------------------------------- inside `R1` at $DIR/forbidden_slices.rs:48:33\n+   |\n+   = note: this error originates in the macro `assert` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error[E0080]: could not evaluate static initializer\n+  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         unsafe { intrinsics::offset(self, count) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  |\n+   |                  pointer arithmetic failed: ALLOC_ID has size 4, so pointer to 8 bytes starting at offset 0 is out-of-bounds\n+   |                  inside `ptr::const_ptr::<impl *const u32>::offset` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+...\n+LL |         unsafe { self.offset(count as isize) }\n+   |                  --------------------------- inside `ptr::const_ptr::<impl *const u32>::add` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |\n+  ::: $DIR/forbidden_slices.rs:51:25\n+   |\n+LL |     from_ptr_range(ptr..ptr.add(2))\n+   |                         ---------- inside `R2` at $DIR/forbidden_slices.rs:51:25\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/forbidden_slices.rs:53:1\n+   |\n+LL | / pub static R4: &[u8] = unsafe {\n+LL | |\n+LL | |     let ptr = (&D1) as *const MaybeUninit<&u32> as *const u8;\n+LL | |     from_ptr_range(ptr..ptr.add(1))\n+LL | | };\n+   | |__^ type validation failed at .<deref>[0]: encountered uninitialized bytes\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500ALLOC_ID\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 01 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/forbidden_slices.rs:58:1\n+   |\n+LL | / pub static R5: &[u8] = unsafe {\n+LL | |\n+LL | |     let ptr = &D3 as *const &u32;\n+LL | |     from_ptr_range(ptr.cast()..ptr.add(1).cast())\n+LL | | };\n+   | |__^ type validation failed at .<deref>: encountered a pointer, but expected plain (non-pointer) bytes\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500ALLOC_ID\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 08 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/forbidden_slices.rs:63:1\n+   |\n+LL | / pub static R6: &[bool] = unsafe {\n+LL | |\n+LL | |     let ptr = &D0 as *const u32 as *const bool;\n+LL | |     from_ptr_range(ptr..ptr.add(4))\n+LL | | };\n+   | |__^ type validation failed at .<deref>[0]: encountered 0x11, but expected a boolean\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257e\u2500\u2500\u2500\u2500\u2500\u2500ALLOC_ID\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 04 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/forbidden_slices.rs:68:1\n+   |\n+LL | / pub static R7: &[u16] = unsafe {\n+LL | |\n+LL | |     let ptr = (&D2 as *const Struct as *const u16).byte_add(1);\n+LL | |     from_ptr_range(ptr..ptr.add(4))\n+LL | | };\n+   | |__^ type validation failed: encountered an unaligned reference (required 2 byte alignment but found 1)\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+   = note: the raw bytes of the constant (size: 16, align: 8) {\n+               \u257e\u2500\u2500\u2500\u2500ALLOC_ID+0x1\u2500\u2500\u2500\u2500\u2500\u257c 04 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+           }\n+\n+error[E0080]: could not evaluate static initializer\n+  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         unsafe { intrinsics::offset(self, count) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  |\n+   |                  pointer arithmetic failed: ALLOC_ID has size 8, so pointer to 8 bytes starting at offset 1 is out-of-bounds\n+   |                  inside `ptr::const_ptr::<impl *const u64>::offset` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+...\n+LL |         unsafe { self.offset(count as isize) }\n+   |                  --------------------------- inside `ptr::const_ptr::<impl *const u64>::add` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |\n+  ::: $DIR/forbidden_slices.rs:75:25\n+   |\n+LL |     from_ptr_range(ptr..ptr.add(1))\n+   |                         ---------- inside `R8` at $DIR/forbidden_slices.rs:75:25\n+\n+error[E0080]: could not evaluate static initializer\n+  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  |\n+   |                  ptr_offset_from_unsigned cannot compute offset of pointers into different allocations.\n+   |                  inside `ptr::const_ptr::<impl *const u32>::sub_ptr` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |\n+  ::: $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+   |\n+LL |     unsafe { from_raw_parts(range.start, range.end.sub_ptr(range.start)) }\n+   |                                          ------------------------------ inside `from_ptr_range::<u32>` at $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+   |\n+  ::: $DIR/forbidden_slices.rs:80:34\n+   |\n+LL | pub static R9: &[u32] = unsafe { from_ptr_range(&D0..(&D0 as *const u32).add(1)) };\n+   |                                  ----------------------------------------------- inside `R9` at $DIR/forbidden_slices.rs:80:34\n+\n+error[E0080]: could not evaluate static initializer\n+  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  |\n+   |                  ptr_offset_from_unsigned cannot compute offset of pointers into different allocations.\n+   |                  inside `ptr::const_ptr::<impl *const u32>::sub_ptr` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |\n+  ::: $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+   |\n+LL |     unsafe { from_raw_parts(range.start, range.end.sub_ptr(range.start)) }\n+   |                                          ------------------------------ inside `from_ptr_range::<u32>` at $SRC_DIR/core/src/slice/raw.rs:LL:COL\n+   |\n+  ::: $DIR/forbidden_slices.rs:81:35\n+   |\n+LL | pub static R10: &[u32] = unsafe { from_ptr_range(&D0..&D0) };\n+   |                                   ------------------------ inside `R10` at $DIR/forbidden_slices.rs:81:35\n+\n+error: aborting due to 18 previous errors\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "4465da454687fa398589aa2d296ba1a70a823e2d", "filename": "src/test/ui/const-ptr/forbidden_slices.rs", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/0a43923a86c3b8f11d005884871b152f59b746f7/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a43923a86c3b8f11d005884871b152f59b746f7/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.rs?ref=0a43923a86c3b8f11d005884871b152f59b746f7", "patch": "@@ -0,0 +1,99 @@\n+// stderr-per-bitwidth\n+// normalize-stderr-test \"alloc[0-9]+\" -> \"ALLOC_ID\"\n+// normalize-stderr-test \"a[0-9]+\\+0x\" -> \"A_ID+0x\"\n+// error-pattern: could not evaluate static initializer\n+#![feature(\n+    const_slice_from_raw_parts,\n+    slice_from_ptr_range,\n+    const_slice_from_ptr_range,\n+    pointer_byte_offsets,\n+    const_pointer_byte_offsets\n+)]\n+use std::{\n+    mem::{size_of, MaybeUninit},\n+    ptr,\n+    slice::{from_ptr_range, from_raw_parts},\n+};\n+\n+// Null is never valid for reads\n+pub static S0: &[u32] = unsafe { from_raw_parts(ptr::null(), 0) };\n+pub static S1: &[()] = unsafe { from_raw_parts(ptr::null(), 0) };\n+\n+// Out of bounds\n+pub static S2: &[u32] = unsafe { from_raw_parts(&D0, 2) };\n+\n+// Reading uninitialized  data\n+pub static S4: &[u8] = unsafe { from_raw_parts((&D1) as *const _ as _, 1) }; //~ ERROR: it is undefined behavior to use this value\n+// Reinterpret pointers as integers (UB in CTFE.)\n+pub static S5: &[u8] = unsafe { from_raw_parts((&D3) as *const _ as _, size_of::<&u32>()) }; //~ ERROR: it is undefined behavior to use this value\n+// Layout mismatch\n+pub static S6: &[bool] = unsafe { from_raw_parts((&D0) as *const _ as _, 4) }; //~ ERROR: it is undefined behavior to use this value\n+\n+// Reading padding is not ok\n+pub static S7: &[u16] = unsafe {\n+    //~^ ERROR: it is undefined behavior to use this value\n+    let ptr = (&D2 as *const Struct as *const u16).byte_add(1);\n+\n+    from_raw_parts(ptr, 4)\n+};\n+\n+// Unaligned read\n+pub static S8: &[u64] = unsafe {\n+    let ptr = (&D4 as *const [u32; 2] as *const u32).byte_add(1).cast::<u64>();\n+\n+    from_raw_parts(ptr, 1)\n+};\n+\n+pub static R0: &[u32] = unsafe { from_ptr_range(ptr::null()..ptr::null()) };\n+pub static R1: &[()] = unsafe { from_ptr_range(ptr::null()..ptr::null()) };\n+pub static R2: &[u32] = unsafe {\n+    let ptr = &D0 as *const u32;\n+    from_ptr_range(ptr..ptr.add(2))\n+};\n+pub static R4: &[u8] = unsafe {\n+    //~^ ERROR: it is undefined behavior to use this value\n+    let ptr = (&D1) as *const MaybeUninit<&u32> as *const u8;\n+    from_ptr_range(ptr..ptr.add(1))\n+};\n+pub static R5: &[u8] = unsafe {\n+    //~^ ERROR: it is undefined behavior to use this value\n+    let ptr = &D3 as *const &u32;\n+    from_ptr_range(ptr.cast()..ptr.add(1).cast())\n+};\n+pub static R6: &[bool] = unsafe {\n+    //~^ ERROR: it is undefined behavior to use this value\n+    let ptr = &D0 as *const u32 as *const bool;\n+    from_ptr_range(ptr..ptr.add(4))\n+};\n+pub static R7: &[u16] = unsafe {\n+    //~^ ERROR: it is undefined behavior to use this value\n+    let ptr = (&D2 as *const Struct as *const u16).byte_add(1);\n+    from_ptr_range(ptr..ptr.add(4))\n+};\n+pub static R8: &[u64] = unsafe {\n+    let ptr = (&D4 as *const [u32; 2] as *const u32).byte_add(1).cast::<u64>();\n+    from_ptr_range(ptr..ptr.add(1))\n+};\n+\n+// This is sneaky: &D0 and &D0 point to different objects\n+// (even if at runtime they have the same address)\n+pub static R9: &[u32] = unsafe { from_ptr_range(&D0..(&D0 as *const u32).add(1)) };\n+pub static R10: &[u32] = unsafe { from_ptr_range(&D0..&D0) };\n+\n+const D0: u32 = 0x11;\n+const D1: MaybeUninit<&u32> = MaybeUninit::uninit();\n+const D2: Struct = Struct { a: 1, b: 2, c: 3, d: 4 };\n+const D3: &u32 = &42;\n+const D4: [u32; 2] = [17, 42];\n+\n+#[repr(C)]\n+struct Struct {\n+    a: u8,\n+    // _pad: [MaybeUninit<u8>; 3]\n+    b: u32,\n+    c: u16,\n+    d: u8,\n+    // _pad: [MaybeUninit<u8>; 1]\n+}\n+\n+fn main() {}"}]}