{"sha": "6896ed383dbd3a847ef39b713449fc0393292828", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4OTZlZDM4M2RiZDNhODQ3ZWYzOWI3MTM0NDlmYzAzOTMyOTI4Mjg=", "commit": {"author": {"name": "newpavlov", "email": "newpavlov@gmail.com", "date": "2019-08-19T06:47:58Z"}, "committer": {"name": "newpavlov", "email": "newpavlov@gmail.com", "date": "2019-08-19T06:47:58Z"}, "message": "use wasi crate", "tree": {"sha": "afc76cda2bff6c793094c8240548e2570e7a0417", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/afc76cda2bff6c793094c8240548e2570e7a0417"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6896ed383dbd3a847ef39b713449fc0393292828", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6896ed383dbd3a847ef39b713449fc0393292828", "html_url": "https://github.com/rust-lang/rust/commit/6896ed383dbd3a847ef39b713449fc0393292828", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6896ed383dbd3a847ef39b713449fc0393292828/comments", "author": {"login": "newpavlov", "id": 329626, "node_id": "MDQ6VXNlcjMyOTYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/329626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/newpavlov", "html_url": "https://github.com/newpavlov", "followers_url": "https://api.github.com/users/newpavlov/followers", "following_url": "https://api.github.com/users/newpavlov/following{/other_user}", "gists_url": "https://api.github.com/users/newpavlov/gists{/gist_id}", "starred_url": "https://api.github.com/users/newpavlov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/newpavlov/subscriptions", "organizations_url": "https://api.github.com/users/newpavlov/orgs", "repos_url": "https://api.github.com/users/newpavlov/repos", "events_url": "https://api.github.com/users/newpavlov/events{/privacy}", "received_events_url": "https://api.github.com/users/newpavlov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "newpavlov", "id": 329626, "node_id": "MDQ6VXNlcjMyOTYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/329626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/newpavlov", "html_url": "https://github.com/newpavlov", "followers_url": "https://api.github.com/users/newpavlov/followers", "following_url": "https://api.github.com/users/newpavlov/following{/other_user}", "gists_url": "https://api.github.com/users/newpavlov/gists{/gist_id}", "starred_url": "https://api.github.com/users/newpavlov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/newpavlov/subscriptions", "organizations_url": "https://api.github.com/users/newpavlov/orgs", "repos_url": "https://api.github.com/users/newpavlov/repos", "events_url": "https://api.github.com/users/newpavlov/events{/privacy}", "received_events_url": "https://api.github.com/users/newpavlov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd1da18b04afba5dfc09ad1b56df3285f1d039c3", "html_url": "https://github.com/rust-lang/rust/commit/bd1da18b04afba5dfc09ad1b56df3285f1d039c3"}], "stats": {"total": 625, "additions": 249, "deletions": 376}, "files": [{"sha": "679bb1b2cbe3075c8506b9d3b3a8062f0197b702", "filename": "src/libstd/sys/wasi/args.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6896ed383dbd3a847ef39b713449fc0393292828/src%2Flibstd%2Fsys%2Fwasi%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6896ed383dbd3a847ef39b713449fc0393292828/src%2Flibstd%2Fsys%2Fwasi%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fargs.rs?ref=6896ed383dbd3a847ef39b713449fc0393292828", "patch": "@@ -27,14 +27,24 @@ pub fn args() -> Args {\n     })\n }\n \n+fn cvt_wasi(r: u16) -> crate::io::Result<()> {\n+    if r != 0 {\n+        Err(Error::from_raw_os_error(r as i32))\n+    } else {\n+        Ok(())\n+    }\n+}\n+\n fn maybe_args() -> io::Result<Args> {\n+    // FIXME: replace with safe functions\n+    use wasi::wasi_unstable::raw::{__wasi_args_sizes_get, __wasi_args_get};\n     unsafe {\n         let (mut argc, mut argv_buf_size) = (0, 0);\n-        cvt_wasi(libc::__wasi_args_sizes_get(&mut argc, &mut argv_buf_size))?;\n+        cvt_wasi(__wasi_args_sizes_get(&mut argc, &mut argv_buf_size))?;\n \n-        let mut argc = vec![core::ptr::null_mut::<libc::c_char>(); argc];\n+        let mut argc = vec![core::ptr::null_mut::<u8>(); argc];\n         let mut argv_buf = vec![0; argv_buf_size];\n-        cvt_wasi(libc::__wasi_args_get(argc.as_mut_ptr(), argv_buf.as_mut_ptr()))?;\n+        cvt_wasi(__wasi_args_get(argc.as_mut_ptr(), argv_buf.as_mut_ptr()))?;\n \n         let args = argc.into_iter()\n             .map(|ptr| CStr::from_ptr(ptr).to_bytes().to_vec())"}, {"sha": "ecd509f01dabd62bb5f753b8bea1c57f7fffe5a5", "filename": "src/libstd/sys/wasi/ext/fs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6896ed383dbd3a847ef39b713449fc0393292828/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6896ed383dbd3a847ef39b713449fc0393292828/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Ffs.rs?ref=6896ed383dbd3a847ef39b713449fc0393292828", "patch": "@@ -336,16 +336,16 @@ pub trait FileTypeExt {\n \n impl FileTypeExt for fs::FileType {\n     fn is_block_device(&self) -> bool {\n-        self.as_inner().bits() == libc::__WASI_FILETYPE_BLOCK_DEVICE\n+        self.as_inner().bits() == wasi::FILETYPE_BLOCK_DEVICE\n     }\n     fn is_character_device(&self) -> bool {\n-        self.as_inner().bits() == libc::__WASI_FILETYPE_CHARACTER_DEVICE\n+        self.as_inner().bits() == wasi::FILETYPE_CHARACTER_DEVICE\n     }\n     fn is_socket_dgram(&self) -> bool {\n-        self.as_inner().bits() == libc::__WASI_FILETYPE_SOCKET_DGRAM\n+        self.as_inner().bits() == wasi::FILETYPE_SOCKET_DGRAM\n     }\n     fn is_socket_stream(&self) -> bool {\n-        self.as_inner().bits() == libc::__WASI_FILETYPE_SOCKET_STREAM\n+        self.as_inner().bits() == wasi::FILETYPE_SOCKET_STREAM\n     }\n }\n "}, {"sha": "c843144f0c406d49de07889edb4bc17dfe235b4b", "filename": "src/libstd/sys/wasi/ext/io.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6896ed383dbd3a847ef39b713449fc0393292828/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6896ed383dbd3a847ef39b713449fc0393292828/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fext%2Fio.rs?ref=6896ed383dbd3a847ef39b713449fc0393292828", "patch": "@@ -8,6 +8,8 @@ use crate::sys;\n use crate::net;\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n \n+use wasi::wasi_unstable as wasi;\n+\n /// Raw file descriptors.\n pub type RawFd = u32;\n \n@@ -125,18 +127,18 @@ impl IntoRawFd for fs::File {\n \n impl AsRawFd for io::Stdin {\n     fn as_raw_fd(&self) -> RawFd {\n-        libc::STDIN_FILENO as u32\n+        wasi::STDIN_FD\n     }\n }\n \n impl AsRawFd for io::Stdout {\n     fn as_raw_fd(&self) -> RawFd {\n-        libc::STDOUT_FILENO as u32\n+        wasi::STDOUT_FD\n     }\n }\n \n impl AsRawFd for io::Stderr {\n     fn as_raw_fd(&self) -> RawFd {\n-        libc::STDERR_FILENO as u32\n+        wasi::STDERR_FD\n     }\n }"}, {"sha": "93fe8add326c8f1c49b8b52a643bf1db615ea19b", "filename": "src/libstd/sys/wasi/fd.rs", "status": "modified", "additions": 97, "deletions": 205, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/6896ed383dbd3a847ef39b713449fc0393292828/src%2Flibstd%2Fsys%2Fwasi%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6896ed383dbd3a847ef39b713449fc0393292828/src%2Flibstd%2Fsys%2Fwasi%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Ffd.rs?ref=6896ed383dbd3a847ef39b713449fc0393292828", "patch": "@@ -3,348 +3,240 @@\n use crate::io::{self, IoSlice, IoSliceMut, SeekFrom};\n use crate::mem;\n use crate::net::Shutdown;\n-use crate::sys::cvt_wasi;\n-use libc::{self, c_char, c_void};\n+use wasi::wasi_unstable as wasi;\n \n #[derive(Debug)]\n pub struct WasiFd {\n-    fd: libc::__wasi_fd_t,\n+    fd: wasi::Fd,\n }\n \n-// FIXME: these should probably all be fancier structs, builders, enums, etc\n-pub type LookupFlags = u32;\n-pub type FdFlags = u16;\n-pub type Advice = u8;\n-pub type Rights = u64;\n-pub type Oflags = u16;\n-pub type DirCookie = u64;\n-pub type Timestamp = u64;\n-pub type FstFlags = u16;\n-pub type RiFlags = u16;\n-pub type RoFlags = u16;\n-pub type SiFlags = u16;\n-\n-fn iovec(a: &mut [IoSliceMut<'_>]) -> (*const libc::__wasi_iovec_t, usize) {\n+fn iovec(a: &mut [IoSliceMut<'_>]) -> &[wasi::IoVec] {\n     assert_eq!(\n         mem::size_of::<IoSliceMut<'_>>(),\n-        mem::size_of::<libc::__wasi_iovec_t>()\n+        mem::size_of::<wasi::IoVec>()\n     );\n     assert_eq!(\n         mem::align_of::<IoSliceMut<'_>>(),\n-        mem::align_of::<libc::__wasi_iovec_t>()\n+        mem::align_of::<wasi::IoVec>()\n     );\n-    (a.as_ptr() as *const libc::__wasi_iovec_t, a.len())\n+    /// SAFETY: `IoSliceMut` and `IoVec` have exactly the same memory layout\n+    unsafe { mem::transmute(a) }\n }\n \n-fn ciovec(a: &[IoSlice<'_>]) -> (*const libc::__wasi_ciovec_t, usize) {\n+fn ciovec(a: &[IoSlice<'_>]) -> &[wasi::CIoVec] {\n     assert_eq!(\n         mem::size_of::<IoSlice<'_>>(),\n-        mem::size_of::<libc::__wasi_ciovec_t>()\n+        mem::size_of::<wasi::CIoVec>()\n     );\n     assert_eq!(\n         mem::align_of::<IoSlice<'_>>(),\n-        mem::align_of::<libc::__wasi_ciovec_t>()\n+        mem::align_of::<wasi::CIoVec>()\n     );\n-    (a.as_ptr() as *const libc::__wasi_ciovec_t, a.len())\n+    /// SAFETY: `IoSlice` and `CIoVec` have exactly the same memory layout\n+    unsafe { mem::transmute(a) }\n }\n \n impl WasiFd {\n-    pub unsafe fn from_raw(fd: libc::__wasi_fd_t) -> WasiFd {\n+    pub unsafe fn from_raw(fd: wasi::Fd) -> WasiFd {\n         WasiFd { fd }\n     }\n \n-    pub fn into_raw(self) -> libc::__wasi_fd_t {\n+    pub fn into_raw(self) -> wasi::Fd {\n         let ret = self.fd;\n         mem::forget(self);\n         ret\n     }\n \n-    pub fn as_raw(&self) -> libc::__wasi_fd_t {\n+    pub fn as_raw(&self) -> wasi::Fd {\n         self.fd\n     }\n \n     pub fn datasync(&self) -> io::Result<()> {\n-        cvt_wasi(unsafe { libc::__wasi_fd_datasync(self.fd) })\n+        wasi::fd_datasync(self.fd).map_err(From::from)\n     }\n \n     pub fn pread(&self, bufs: &mut [IoSliceMut<'_>], offset: u64) -> io::Result<usize> {\n-        let mut read = 0;\n-        let (ptr, len) = iovec(bufs);\n-        cvt_wasi(unsafe { libc::__wasi_fd_pread(self.fd, ptr, len, offset, &mut read) })?;\n-        Ok(read)\n+        wasi::fd_pread(self.fd, iovec(bufs), offset).map_err(From::from)\n     }\n \n     pub fn pwrite(&self, bufs: &[IoSlice<'_>], offset: u64) -> io::Result<usize> {\n-        let mut read = 0;\n-        let (ptr, len) = ciovec(bufs);\n-        cvt_wasi(unsafe { libc::__wasi_fd_pwrite(self.fd, ptr, len, offset, &mut read) })?;\n-        Ok(read)\n+        wasi::fd_pwrite(self.fd, ciovec(bufs), offset).map_err(From::from)\n     }\n \n     pub fn read(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        let mut read = 0;\n-        let (ptr, len) = iovec(bufs);\n-        cvt_wasi(unsafe { libc::__wasi_fd_read(self.fd, ptr, len, &mut read) })?;\n-        Ok(read)\n+        wasi::fd_read(self.fd, iovec(bufs)).map_err(From::from)\n     }\n \n     pub fn write(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        let mut read = 0;\n-        let (ptr, len) = ciovec(bufs);\n-        cvt_wasi(unsafe { libc::__wasi_fd_write(self.fd, ptr, len, &mut read) })?;\n-        Ok(read)\n+        wasi::fd_write(self.fd, ciovec(bufs)).map_err(From::from)\n     }\n \n     pub fn seek(&self, pos: SeekFrom) -> io::Result<u64> {\n         let (whence, offset) = match pos {\n-            SeekFrom::Start(pos) => (libc::__WASI_WHENCE_SET, pos as i64),\n-            SeekFrom::End(pos) => (libc::__WASI_WHENCE_END, pos),\n-            SeekFrom::Current(pos) => (libc::__WASI_WHENCE_CUR, pos),\n+            SeekFrom::Start(pos) => (wasi::WHENCE_SET, pos as i64),\n+            SeekFrom::End(pos) => (wasi::WHENCE_END, pos),\n+            SeekFrom::Current(pos) => (wasi::WHENCE_CUR, pos),\n         };\n-        let mut pos = 0;\n-        cvt_wasi(unsafe { libc::__wasi_fd_seek(self.fd, offset, whence, &mut pos) })?;\n-        Ok(pos)\n+        wasi::fd_seek(self.fd, offset, whence).map_err(From::from)\n     }\n \n     pub fn tell(&self) -> io::Result<u64> {\n-        let mut pos = 0;\n-        cvt_wasi(unsafe { libc::__wasi_fd_tell(self.fd, &mut pos) })?;\n-        Ok(pos)\n+        wasi::fd_tell(self.fd).map_err(From::from)\n     }\n \n     // FIXME: __wasi_fd_fdstat_get\n \n-    pub fn set_flags(&self, flags: FdFlags) -> io::Result<()> {\n-        cvt_wasi(unsafe { libc::__wasi_fd_fdstat_set_flags(self.fd, flags) })\n+    pub fn set_flags(&self, flags: wasi::FdFlags) -> io::Result<()> {\n+        wasi::fd_fdstat_set_flags(self.fd, flags).map_err(From::from)\n     }\n \n-    pub fn set_rights(&self, base: Rights, inheriting: Rights) -> io::Result<()> {\n-        cvt_wasi(unsafe { libc::__wasi_fd_fdstat_set_rights(self.fd, base, inheriting) })\n+    pub fn set_rights(&self, base: wasi::Rights, inheriting: wasi::Rights) -> io::Result<()> {\n+        wasi::fd_fdstat_set_rights(self.fd, base, inheriting).map_err(From::from)\n     }\n \n     pub fn sync(&self) -> io::Result<()> {\n-        cvt_wasi(unsafe { libc::__wasi_fd_sync(self.fd) })\n+        wasi::fd_sync(self.fd).map_err(From::from)\n     }\n \n-    pub fn advise(&self, offset: u64, len: u64, advice: Advice) -> io::Result<()> {\n-        cvt_wasi(unsafe { libc::__wasi_fd_advise(self.fd, offset, len, advice as u8) })\n+    pub fn advise(&self, offset: u64, len: u64, advice: wasi::Advice) -> io::Result<()> {\n+        wasi::fd_advise(self.fd, offset, len, advice).map_err(From::from)\n     }\n \n     pub fn allocate(&self, offset: u64, len: u64) -> io::Result<()> {\n-        cvt_wasi(unsafe { libc::__wasi_fd_allocate(self.fd, offset, len) })\n+        wasi::fd_allocate(self.fd, offset, len).map_err(From::from)\n     }\n \n     pub fn create_directory(&self, path: &[u8]) -> io::Result<()> {\n-        cvt_wasi(unsafe {\n-            libc::__wasi_path_create_directory(self.fd, path.as_ptr() as *const c_char, path.len())\n-        })\n+        wasi::path_create_directory(self.fd, path).map_err(From::from)\n     }\n \n     pub fn link(\n         &self,\n-        old_flags: LookupFlags,\n+        old_flags: wasi::LookupFlags,\n         old_path: &[u8],\n         new_fd: &WasiFd,\n         new_path: &[u8],\n     ) -> io::Result<()> {\n-        cvt_wasi(unsafe {\n-            libc::__wasi_path_link(\n-                self.fd,\n-                old_flags,\n-                old_path.as_ptr() as *const c_char,\n-                old_path.len(),\n-                new_fd.fd,\n-                new_path.as_ptr() as *const c_char,\n-                new_path.len(),\n-            )\n-        })\n+        wasi::path_link(self.fd, old_flags, old_path, new_fd.fd, new_path)\n+            .map_err(From::from)\n     }\n \n     pub fn open(\n         &self,\n-        dirflags: LookupFlags,\n+        dirflags: wasi::LookupFlags,\n         path: &[u8],\n-        oflags: Oflags,\n-        fs_rights_base: Rights,\n-        fs_rights_inheriting: Rights,\n-        fs_flags: FdFlags,\n+        oflags: wasi::OFlags,\n+        fs_rights_base: wasi::Rights,\n+        fs_rights_inheriting: wasi::Rights,\n+        fs_flags: wasi::FdFlags,\n     ) -> io::Result<WasiFd> {\n-        unsafe {\n-            let mut fd = 0;\n-            cvt_wasi(libc::__wasi_path_open(\n-                self.fd,\n-                dirflags,\n-                path.as_ptr() as *const c_char,\n-                path.len(),\n-                oflags,\n-                fs_rights_base,\n-                fs_rights_inheriting,\n-                fs_flags,\n-                &mut fd,\n-            ))?;\n-            Ok(WasiFd::from_raw(fd))\n-        }\n-    }\n-\n-    pub fn readdir(&self, buf: &mut [u8], cookie: DirCookie) -> io::Result<usize> {\n-        let mut used = 0;\n-        cvt_wasi(unsafe {\n-            libc::__wasi_fd_readdir(\n-                self.fd,\n-                buf.as_mut_ptr() as *mut c_void,\n-                buf.len(),\n-                cookie,\n-                &mut used,\n-            )\n-        })?;\n-        Ok(used)\n+        let fd = wasi_path_open(\n+            self.fd,\n+            dirflags,\n+            path,\n+            oflags,\n+            fs_rights_base,\n+            fs_rights_inheriting,\n+            fs_flags,\n+        )?;\n+        Ok(WasiFd::from_raw(fd))\n+    }\n+\n+    pub fn readdir(&self, buf: &mut [u8], cookie: wasi::DirCookie) -> io::Result<usize> {\n+        wasi::fd_readdir(self.fd, buf, cookie).map_err(From::from)\n     }\n \n     pub fn readlink(&self, path: &[u8], buf: &mut [u8]) -> io::Result<usize> {\n-        let mut used = 0;\n-        cvt_wasi(unsafe {\n-            libc::__wasi_path_readlink(\n-                self.fd,\n-                path.as_ptr() as *const c_char,\n-                path.len(),\n-                buf.as_mut_ptr() as *mut c_char,\n-                buf.len(),\n-                &mut used,\n-            )\n-        })?;\n-        Ok(used)\n+        wasi::path_readlink(self.fd, path, buf).map_err(From::from)\n     }\n \n     pub fn rename(&self, old_path: &[u8], new_fd: &WasiFd, new_path: &[u8]) -> io::Result<()> {\n-        cvt_wasi(unsafe {\n-            libc::__wasi_path_rename(\n-                self.fd,\n-                old_path.as_ptr() as *const c_char,\n-                old_path.len(),\n-                new_fd.fd,\n-                new_path.as_ptr() as *const c_char,\n-                new_path.len(),\n-            )\n-        })\n+        wasi::path_rename(self.fd, old_path, new_fd.fd, new_path)\n+            .map_err(From::from)\n     }\n \n-    pub fn filestat_get(&self, buf: *mut libc::__wasi_filestat_t) -> io::Result<()> {\n-        cvt_wasi(unsafe { libc::__wasi_fd_filestat_get(self.fd, buf) })\n+    pub fn filestat_get(&self) -> io::Result<wasi::Filestat> {\n+        wasi::fd_filestat_get(self.fd, buf).map_err(From::from)\n     }\n \n     pub fn filestat_set_times(\n         &self,\n-        atim: Timestamp,\n-        mtim: Timestamp,\n-        fstflags: FstFlags,\n+        atim: wasi::Timestamp,\n+        mtim: wasi::Timestamp,\n+        fstflags: wasi::FstFlags,\n     ) -> io::Result<()> {\n-        cvt_wasi(unsafe { libc::__wasi_fd_filestat_set_times(self.fd, atim, mtim, fstflags) })\n+        wasi::fd_filestat_set_times(self.fd, atim, mtim, fstflags)\n+            .map_err(From::from)\n     }\n \n     pub fn filestat_set_size(&self, size: u64) -> io::Result<()> {\n-        cvt_wasi(unsafe { libc::__wasi_fd_filestat_set_size(self.fd, size) })\n+        wasi::fd_filestat_set_size(self.fd, size).map_err(From::from)\n     }\n \n     pub fn path_filestat_get(\n         &self,\n-        flags: LookupFlags,\n+        flags: wasi::LookupFlags,\n         path: &[u8],\n-        buf: *mut libc::__wasi_filestat_t,\n-    ) -> io::Result<()> {\n-        cvt_wasi(unsafe {\n-            libc::__wasi_path_filestat_get(\n-                self.fd,\n-                flags,\n-                path.as_ptr() as *const c_char,\n-                path.len(),\n-                buf,\n-            )\n-        })\n+    ) -> io::Result<wasi::FileStat> {\n+        wasi::path_filestat_get(self.fd, flags, path).map_err(From::from)\n     }\n \n     pub fn path_filestat_set_times(\n         &self,\n-        flags: LookupFlags,\n+        flags: wasi::LookupFlags,\n         path: &[u8],\n-        atim: Timestamp,\n-        mtim: Timestamp,\n-        fstflags: FstFlags,\n+        atim: wasi::Timestamp,\n+        mtim: wasi::Timestamp,\n+        fstflags: wasi::FstFlags,\n     ) -> io::Result<()> {\n-        cvt_wasi(unsafe {\n-            libc::__wasi_path_filestat_set_times(\n-                self.fd,\n-                flags,\n-                path.as_ptr() as *const c_char,\n-                path.len(),\n-                atim,\n-                mtim,\n-                fstflags,\n-            )\n-        })\n+        wasi::path_filestat_set_times(\n+            self.fd,\n+            flags,\n+            path,\n+            atim,\n+            mtim,\n+            fstflags,\n+        ).map_err(From::from)\n     }\n \n     pub fn symlink(&self, old_path: &[u8], new_path: &[u8]) -> io::Result<()> {\n-        cvt_wasi(unsafe {\n-            libc::__wasi_path_symlink(\n-                old_path.as_ptr() as *const c_char,\n-                old_path.len(),\n-                self.fd,\n-                new_path.as_ptr() as *const c_char,\n-                new_path.len(),\n-            )\n-        })\n+        wasi::path_symlink(old_path, self.fd, new_path).map_err(From::from)\n     }\n \n     pub fn unlink_file(&self, path: &[u8]) -> io::Result<()> {\n-        cvt_wasi(unsafe {\n-            libc::__wasi_path_unlink_file(self.fd, path.as_ptr() as *const c_char, path.len())\n-        })\n+        wasi::path_unlink_file(self.fd, path).map_err(From::from)\n     }\n \n     pub fn remove_directory(&self, path: &[u8]) -> io::Result<()> {\n-        cvt_wasi(unsafe {\n-            libc::__wasi_path_remove_directory(self.fd, path.as_ptr() as *const c_char, path.len())\n-        })\n+        wasi::path_remove_directory(self.fd, path).map_err(From::from)\n     }\n \n     pub fn sock_recv(\n         &self,\n         ri_data: &mut [IoSliceMut<'_>],\n-        ri_flags: RiFlags,\n-    ) -> io::Result<(usize, RoFlags)> {\n-        let mut ro_datalen = 0;\n-        let mut ro_flags = 0;\n-        let (ptr, len) = iovec(ri_data);\n-        cvt_wasi(unsafe {\n-            libc::__wasi_sock_recv(self.fd, ptr, len, ri_flags, &mut ro_datalen, &mut ro_flags)\n-        })?;\n-        Ok((ro_datalen, ro_flags))\n+        ri_flags: wasi::RiFlags,\n+    ) -> io::Result<(usize, wasi::RoFlags)> {\n+        wasi::sock_recv(self.fd, iovec(ri_data), ri_flags).map_err(From::from)\n     }\n \n-    pub fn sock_send(&self, si_data: &[IoSlice<'_>], si_flags: SiFlags) -> io::Result<usize> {\n-        let mut so_datalen = 0;\n-        let (ptr, len) = ciovec(si_data);\n-        cvt_wasi(unsafe { libc::__wasi_sock_send(self.fd, ptr, len, si_flags, &mut so_datalen) })?;\n-        Ok(so_datalen)\n+    pub fn sock_send(&self, si_data: &[IoSlice<'_>], si_flags: wasi::SiFlags) -> io::Result<usize> {\n+        wasi::sock_send(self.fd, ciovec(si_data), si_flags).map_err(From::from)\n     }\n \n     pub fn sock_shutdown(&self, how: Shutdown) -> io::Result<()> {\n         let how = match how {\n-            Shutdown::Read => libc::__WASI_SHUT_RD,\n-            Shutdown::Write => libc::__WASI_SHUT_WR,\n-            Shutdown::Both => libc::__WASI_SHUT_WR | libc::__WASI_SHUT_RD,\n+            Shutdown::Read => WASI::SHUT_RD,\n+            Shutdown::Write => WASI::SHUT_WR,\n+            Shutdown::Both => WASI::SHUT_WR | WASI::SHUT_RD,\n         };\n-        cvt_wasi(unsafe { libc::__wasi_sock_shutdown(self.fd, how) })?;\n-        Ok(())\n+        wasi::sock_shutdown(self.fd, how).map_err(From::from)\n     }\n }\n \n impl Drop for WasiFd {\n     fn drop(&mut self) {\n-        unsafe {\n-            // FIXME: can we handle the return code here even though we can't on\n-            // unix?\n-            libc::__wasi_fd_close(self.fd);\n-        }\n+        // FIXME: can we handle the return code here even though we can't on\n+        // unix?\n+        let _ = wasi::fd_close(self.fd);\n     }\n }"}, {"sha": "f23ecfc2bcd22338cba46b4129edfbde3ecd2ea3", "filename": "src/libstd/sys/wasi/fs.rs", "status": "modified", "additions": 82, "deletions": 94, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/6896ed383dbd3a847ef39b713449fc0393292828/src%2Flibstd%2Fsys%2Fwasi%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6896ed383dbd3a847ef39b713449fc0393292828/src%2Flibstd%2Fsys%2Fwasi%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Ffs.rs?ref=6896ed383dbd3a847ef39b713449fc0393292828", "patch": "@@ -15,13 +15,15 @@ use crate::sys_common::FromInner;\n pub use crate::sys_common::fs::copy;\n pub use crate::sys_common::fs::remove_dir_all;\n \n+use wasi::wasi_unstable as wasi;\n+\n pub struct File {\n     fd: WasiFd,\n }\n \n #[derive(Clone)]\n pub struct FileAttr {\n-    meta: libc::__wasi_filestat_t,\n+    meta: wasi::FileStat,\n }\n \n pub struct ReadDir {\n@@ -38,7 +40,7 @@ struct ReadDirInner {\n }\n \n pub struct DirEntry {\n-    meta: libc::__wasi_dirent_t,\n+    meta: wasi::Dirent,\n     name: Vec<u8>,\n     inner: Arc<ReadDirInner>,\n }\n@@ -47,11 +49,11 @@ pub struct DirEntry {\n pub struct OpenOptions {\n     read: bool,\n     write: bool,\n-    dirflags: libc::__wasi_lookupflags_t,\n-    fdflags: libc::__wasi_fdflags_t,\n-    oflags: libc::__wasi_oflags_t,\n-    rights_base: Option<libc::__wasi_rights_t>,\n-    rights_inheriting: Option<libc::__wasi_rights_t>,\n+    dirflags: wasi::LookupFlags,\n+    fdflags: wasi::FdFlags,\n+    oflags: wasi::OFlags,\n+    rights_base: Option<wasi::Rights>,\n+    rights_inheriting: Option<wasi::Rights>,\n }\n \n #[derive(Clone, PartialEq, Eq, Debug)]\n@@ -61,7 +63,7 @@ pub struct FilePermissions {\n \n #[derive(PartialEq, Eq, Hash, Debug, Copy, Clone)]\n pub struct FileType {\n-    bits: libc::__wasi_filetype_t,\n+    bits: wasi::FileType,\n }\n \n #[derive(Debug)]\n@@ -101,7 +103,7 @@ impl FileAttr {\n         Ok(SystemTime::from_wasi_timestamp(self.meta.st_ctim))\n     }\n \n-    pub fn as_wasi(&self) -> &libc::__wasi_filestat_t {\n+    pub fn as_wasi(&self) -> &wasi::FileStat {\n         &self.meta\n     }\n }\n@@ -118,18 +120,18 @@ impl FilePermissions {\n \n impl FileType {\n     pub fn is_dir(&self) -> bool {\n-        self.bits == libc::__WASI_FILETYPE_DIRECTORY\n+        self.bits == wasi::FILETYPE_DIRECTORY\n     }\n \n     pub fn is_file(&self) -> bool {\n-        self.bits == libc::__WASI_FILETYPE_REGULAR_FILE\n+        self.bits == wasi::FILETYPE_REGULAR_FILE\n     }\n \n     pub fn is_symlink(&self) -> bool {\n-        self.bits == libc::__WASI_FILETYPE_SYMBOLIC_LINK\n+        self.bits == wasi::FILETYPE_SYMBOLIC_LINK\n     }\n \n-    pub fn bits(&self) -> libc::__wasi_filetype_t {\n+    pub fn bits(&self) -> wasi::FileType {\n         self.bits\n     }\n }\n@@ -173,7 +175,7 @@ impl Iterator for ReadDir {\n             // must have been truncated at the end of the buffer, so reset our\n             // offset so we can go back and reread into the buffer, picking up\n             // where we last left off.\n-            let dirent_size = mem::size_of::<libc::__wasi_dirent_t>();\n+            let dirent_size = mem::size_of::<wasi::Dirent>();\n             if data.len() < dirent_size {\n                 assert!(self.cookie.is_some());\n                 assert!(self.buf.len() >= dirent_size);\n@@ -182,7 +184,7 @@ impl Iterator for ReadDir {\n             }\n             let (dirent, data) = data.split_at(dirent_size);\n             let dirent =\n-                unsafe { ptr::read_unaligned(dirent.as_ptr() as *const libc::__wasi_dirent_t) };\n+                unsafe { ptr::read_unaligned(dirent.as_ptr() as *const wasi::Dirent) };\n \n             // If the file name was truncated, then we need to reinvoke\n             // `readdir` so we truncate our buffer to start over and reread this\n@@ -241,15 +243,15 @@ impl DirEntry {\n         })\n     }\n \n-    pub fn ino(&self) -> libc::__wasi_inode_t {\n+    pub fn ino(&self) -> wasi::Inode {\n         self.meta.d_ino\n     }\n }\n \n impl OpenOptions {\n     pub fn new() -> OpenOptions {\n         let mut base = OpenOptions::default();\n-        base.dirflags = libc::__WASI_LOOKUP_SYMLINK_FOLLOW;\n+        base.dirflags = wasi::LOOKUP_SYMLINK_FOLLOW;\n         return base;\n     }\n \n@@ -262,23 +264,23 @@ impl OpenOptions {\n     }\n \n     pub fn truncate(&mut self, truncate: bool) {\n-        self.oflag(libc::__WASI_O_TRUNC, truncate);\n+        self.oflag(wasi::O_TRUNC, truncate);\n     }\n \n     pub fn create(&mut self, create: bool) {\n-        self.oflag(libc::__WASI_O_CREAT, create);\n+        self.oflag(wasi::O_CREAT, create);\n     }\n \n     pub fn create_new(&mut self, create_new: bool) {\n-        self.oflag(libc::__WASI_O_EXCL, create_new);\n-        self.oflag(libc::__WASI_O_CREAT, create_new);\n+        self.oflag(wasi::O_EXCL, create_new);\n+        self.oflag(wasi::O_CREAT, create_new);\n     }\n \n     pub fn directory(&mut self, directory: bool) {\n-        self.oflag(libc::__WASI_O_DIRECTORY, directory);\n+        self.oflag(wasi::O_DIRECTORY, directory);\n     }\n \n-    fn oflag(&mut self, bit: libc::__wasi_oflags_t, set: bool) {\n+    fn oflag(&mut self, bit: wasi::OFlags, set: bool) {\n         if set {\n             self.oflags |= bit;\n         } else {\n@@ -287,42 +289,42 @@ impl OpenOptions {\n     }\n \n     pub fn append(&mut self, set: bool) {\n-        self.fdflag(libc::__WASI_FDFLAG_APPEND, set);\n+        self.fdflag(wasi::FDFLAG_APPEND, set);\n     }\n \n     pub fn dsync(&mut self, set: bool) {\n-        self.fdflag(libc::__WASI_FDFLAG_DSYNC, set);\n+        self.fdflag(wasi::FDFLAG_DSYNC, set);\n     }\n \n     pub fn nonblock(&mut self, set: bool) {\n-        self.fdflag(libc::__WASI_FDFLAG_NONBLOCK, set);\n+        self.fdflag(wasi::FDFLAG_NONBLOCK, set);\n     }\n \n     pub fn rsync(&mut self, set: bool) {\n-        self.fdflag(libc::__WASI_FDFLAG_RSYNC, set);\n+        self.fdflag(wasi::FDFLAG_RSYNC, set);\n     }\n \n     pub fn sync(&mut self, set: bool) {\n-        self.fdflag(libc::__WASI_FDFLAG_SYNC, set);\n+        self.fdflag(wasi::FDFLAG_SYNC, set);\n     }\n \n-    fn fdflag(&mut self, bit: libc::__wasi_fdflags_t, set: bool) {\n+    fn fdflag(&mut self, bit: wasi::FdFlags, set: bool) {\n         if set {\n             self.fdflags |= bit;\n         } else {\n             self.fdflags &= !bit;\n         }\n     }\n \n-    pub fn fs_rights_base(&mut self, rights: libc::__wasi_rights_t) {\n+    pub fn fs_rights_base(&mut self, rights: wasi::Rights) {\n         self.rights_base = Some(rights);\n     }\n \n-    pub fn fs_rights_inheriting(&mut self, rights: libc::__wasi_rights_t) {\n+    pub fn fs_rights_inheriting(&mut self, rights: wasi::Rights) {\n         self.rights_inheriting = Some(rights);\n     }\n \n-    fn rights_base(&self) -> libc::__wasi_rights_t {\n+    fn rights_base(&self) -> wasi::Rights {\n         if let Some(rights) = self.rights_base {\n             return rights;\n         }\n@@ -334,52 +336,52 @@ impl OpenOptions {\n         // based on that.\n         let mut base = 0;\n         if self.read {\n-            base |= libc::__WASI_RIGHT_FD_READ;\n-            base |= libc::__WASI_RIGHT_FD_READDIR;\n+            base |= wasi::RIGHT_FD_READ;\n+            base |= wasi::RIGHT_FD_READDIR;\n         }\n         if self.write {\n-            base |= libc::__WASI_RIGHT_FD_WRITE;\n-            base |= libc::__WASI_RIGHT_FD_DATASYNC;\n-            base |= libc::__WASI_RIGHT_FD_ALLOCATE;\n-            base |= libc::__WASI_RIGHT_FD_FILESTAT_SET_SIZE;\n+            base |= wasi::RIGHT_FD_WRITE;\n+            base |= wasi::RIGHT_FD_DATASYNC;\n+            base |= wasi::RIGHT_FD_ALLOCATE;\n+            base |= wasi::RIGHT_FD_FILESTAT_SET_SIZE;\n         }\n \n         // FIXME: some of these should probably be read-only or write-only...\n-        base |= libc::__WASI_RIGHT_FD_ADVISE;\n-        base |= libc::__WASI_RIGHT_FD_FDSTAT_SET_FLAGS;\n-        base |= libc::__WASI_RIGHT_FD_FILESTAT_SET_TIMES;\n-        base |= libc::__WASI_RIGHT_FD_SEEK;\n-        base |= libc::__WASI_RIGHT_FD_SYNC;\n-        base |= libc::__WASI_RIGHT_FD_TELL;\n-        base |= libc::__WASI_RIGHT_PATH_CREATE_DIRECTORY;\n-        base |= libc::__WASI_RIGHT_PATH_CREATE_FILE;\n-        base |= libc::__WASI_RIGHT_PATH_FILESTAT_GET;\n-        base |= libc::__WASI_RIGHT_PATH_LINK_SOURCE;\n-        base |= libc::__WASI_RIGHT_PATH_LINK_TARGET;\n-        base |= libc::__WASI_RIGHT_PATH_OPEN;\n-        base |= libc::__WASI_RIGHT_PATH_READLINK;\n-        base |= libc::__WASI_RIGHT_PATH_REMOVE_DIRECTORY;\n-        base |= libc::__WASI_RIGHT_PATH_RENAME_SOURCE;\n-        base |= libc::__WASI_RIGHT_PATH_RENAME_TARGET;\n-        base |= libc::__WASI_RIGHT_PATH_SYMLINK;\n-        base |= libc::__WASI_RIGHT_PATH_UNLINK_FILE;\n-        base |= libc::__WASI_RIGHT_POLL_FD_READWRITE;\n+        base |= wasi::RIGHT_FD_ADVISE;\n+        base |= wasi::RIGHT_FD_FDSTAT_SET_FLAGS;\n+        base |= wasi::RIGHT_FD_FILESTAT_SET_TIMES;\n+        base |= wasi::RIGHT_FD_SEEK;\n+        base |= wasi::RIGHT_FD_SYNC;\n+        base |= wasi::RIGHT_FD_TELL;\n+        base |= wasi::RIGHT_PATH_CREATE_DIRECTORY;\n+        base |= wasi::RIGHT_PATH_CREATE_FILE;\n+        base |= wasi::RIGHT_PATH_FILESTAT_GET;\n+        base |= wasi::RIGHT_PATH_LINK_SOURCE;\n+        base |= wasi::RIGHT_PATH_LINK_TARGET;\n+        base |= wasi::RIGHT_PATH_OPEN;\n+        base |= wasi::RIGHT_PATH_READLINK;\n+        base |= wasi::RIGHT_PATH_REMOVE_DIRECTORY;\n+        base |= wasi::RIGHT_PATH_RENAME_SOURCE;\n+        base |= wasi::RIGHT_PATH_RENAME_TARGET;\n+        base |= wasi::RIGHT_PATH_SYMLINK;\n+        base |= wasi::RIGHT_PATH_UNLINK_FILE;\n+        base |= wasi::RIGHT_POLL_FD_READWRITE;\n \n         return base;\n     }\n \n-    fn rights_inheriting(&self) -> libc::__wasi_rights_t {\n+    fn rights_inheriting(&self) -> wasi::Rights {\n         self.rights_inheriting.unwrap_or_else(|| self.rights_base())\n     }\n \n-    pub fn lookup_flags(&mut self, flags: libc::__wasi_lookupflags_t) {\n+    pub fn lookup_flags(&mut self, flags: wasi::LookupFlags) {\n         self.dirflags = flags;\n     }\n }\n \n impl File {\n     pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {\n-        let (dir, file) = open_parent(path, libc::__WASI_RIGHT_PATH_OPEN)?;\n+        let (dir, file) = open_parent(path, wasi::RIGHT_PATH_OPEN)?;\n         open_at(&dir, &file, opts)\n     }\n \n@@ -388,14 +390,12 @@ impl File {\n     }\n \n     pub fn file_attr(&self) -> io::Result<FileAttr> {\n-        let mut ret = FileAttr::zero();\n-        self.fd.filestat_get(&mut ret.meta)?;\n-        Ok(ret)\n+        self.fd.filestat_get().map_ok(|meta| FileAttr { meta })\n     }\n \n     pub fn metadata_at(\n         &self,\n-        flags: libc::__wasi_lookupflags_t,\n+        flags: wasi::LookupFlags,\n         path: &Path,\n     ) -> io::Result<FileAttr> {\n         metadata_at(&self.fd, flags, path)\n@@ -477,7 +477,7 @@ impl DirBuilder {\n     }\n \n     pub fn mkdir(&self, p: &Path) -> io::Result<()> {\n-        let (dir, file) = open_parent(p, libc::__WASI_RIGHT_PATH_CREATE_DIRECTORY)?;\n+        let (dir, file) = open_parent(p, wasi::RIGHT_PATH_CREATE_DIRECTORY)?;\n         dir.create_directory(file.as_os_str().as_bytes())\n     }\n }\n@@ -508,13 +508,13 @@ pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n }\n \n pub fn unlink(p: &Path) -> io::Result<()> {\n-    let (dir, file) = open_parent(p, libc::__WASI_RIGHT_PATH_UNLINK_FILE)?;\n+    let (dir, file) = open_parent(p, wasi::RIGHT_PATH_UNLINK_FILE)?;\n     dir.unlink_file(file.as_os_str().as_bytes())\n }\n \n pub fn rename(old: &Path, new: &Path) -> io::Result<()> {\n-    let (old, old_file) = open_parent(old, libc::__WASI_RIGHT_PATH_RENAME_SOURCE)?;\n-    let (new, new_file) = open_parent(new, libc::__WASI_RIGHT_PATH_RENAME_TARGET)?;\n+    let (old, old_file) = open_parent(old, wasi::RIGHT_PATH_RENAME_SOURCE)?;\n+    let (new, new_file) = open_parent(new, wasi::RIGHT_PATH_RENAME_TARGET)?;\n     old.rename(\n         old_file.as_os_str().as_bytes(),\n         &new,\n@@ -529,12 +529,12 @@ pub fn set_perm(_p: &Path, _perm: FilePermissions) -> io::Result<()> {\n }\n \n pub fn rmdir(p: &Path) -> io::Result<()> {\n-    let (dir, file) = open_parent(p, libc::__WASI_RIGHT_PATH_REMOVE_DIRECTORY)?;\n+    let (dir, file) = open_parent(p, wasi::RIGHT_PATH_REMOVE_DIRECTORY)?;\n     dir.remove_directory(file.as_os_str().as_bytes())\n }\n \n pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n-    let (dir, file) = open_parent(p, libc::__WASI_RIGHT_PATH_READLINK)?;\n+    let (dir, file) = open_parent(p, wasi::RIGHT_PATH_READLINK)?;\n     read_link(&dir, &file)\n }\n \n@@ -570,39 +570,38 @@ fn read_link(fd: &WasiFd, file: &Path) -> io::Result<PathBuf> {\n }\n \n pub fn symlink(src: &Path, dst: &Path) -> io::Result<()> {\n-    let (dst, dst_file) = open_parent(dst, libc::__WASI_RIGHT_PATH_SYMLINK)?;\n+    let (dst, dst_file) = open_parent(dst, wasi::RIGHT_PATH_SYMLINK)?;\n     dst.symlink(src.as_os_str().as_bytes(), dst_file.as_os_str().as_bytes())\n }\n \n pub fn link(src: &Path, dst: &Path) -> io::Result<()> {\n-    let (src, src_file) = open_parent(src, libc::__WASI_RIGHT_PATH_LINK_SOURCE)?;\n-    let (dst, dst_file) = open_parent(dst, libc::__WASI_RIGHT_PATH_LINK_TARGET)?;\n+    let (src, src_file) = open_parent(src, wasi::RIGHT_PATH_LINK_SOURCE)?;\n+    let (dst, dst_file) = open_parent(dst, wasi::RIGHT_PATH_LINK_TARGET)?;\n     src.link(\n-        libc::__WASI_LOOKUP_SYMLINK_FOLLOW,\n+        wasi::LOOKUP_SYMLINK_FOLLOW,\n         src_file.as_os_str().as_bytes(),\n         &dst,\n         dst_file.as_os_str().as_bytes(),\n     )\n }\n \n pub fn stat(p: &Path) -> io::Result<FileAttr> {\n-    let (dir, file) = open_parent(p, libc::__WASI_RIGHT_PATH_FILESTAT_GET)?;\n-    metadata_at(&dir, libc::__WASI_LOOKUP_SYMLINK_FOLLOW, &file)\n+    let (dir, file) = open_parent(p, wasi::RIGHT_PATH_FILESTAT_GET)?;\n+    metadata_at(&dir, wasi::LOOKUP_SYMLINK_FOLLOW, &file)\n }\n \n pub fn lstat(p: &Path) -> io::Result<FileAttr> {\n-    let (dir, file) = open_parent(p, libc::__WASI_RIGHT_PATH_FILESTAT_GET)?;\n+    let (dir, file) = open_parent(p, wasi::RIGHT_PATH_FILESTAT_GET)?;\n     metadata_at(&dir, 0, &file)\n }\n \n fn metadata_at(\n     fd: &WasiFd,\n-    flags: libc::__wasi_lookupflags_t,\n+    flags: wasi::LookupFlags,\n     path: &Path,\n ) -> io::Result<FileAttr> {\n-    let mut ret = FileAttr::zero();\n-    fd.path_filestat_get(flags, path.as_os_str().as_bytes(), &mut ret.meta)?;\n-    Ok(ret)\n+    fd.path_filestat_get(flags, path.as_os_str().as_bytes())\n+        .map_ok(|meta| FileAttr { meta })\n }\n \n pub fn canonicalize(_p: &Path) -> io::Result<PathBuf> {\n@@ -652,12 +651,12 @@ fn open_at(fd: &WasiFd, path: &Path, opts: &OpenOptions) -> io::Result<File> {\n /// to any preopened file descriptor.\n fn open_parent(\n     p: &Path,\n-    rights: libc::__wasi_rights_t,\n+    rights: wasi::Rights,\n ) -> io::Result<(ManuallyDrop<WasiFd>, PathBuf)> {\n     let p = CString::new(p.as_os_str().as_bytes())?;\n     unsafe {\n         let mut ret = ptr::null();\n-        let fd = __wasilibc_find_relpath(p.as_ptr(), rights, 0, &mut ret);\n+        let fd = libc::__wasilibc_find_relpath(p.as_ptr(), rights, 0, &mut ret);\n         if fd == -1 {\n             let msg = format!(\n                 \"failed to find a preopened file descriptor \\\n@@ -677,15 +676,4 @@ fn open_parent(\n \n         return Ok((ManuallyDrop::new(WasiFd::from_raw(fd as u32)), path));\n     }\n-\n-    // FIXME(rust-lang/libc#1314) use the `libc` crate for this when the API\n-    // there is published\n-    extern \"C\" {\n-        pub fn __wasilibc_find_relpath(\n-            path: *const libc::c_char,\n-            rights_base: libc::__wasi_rights_t,\n-            rights_inheriting: libc::__wasi_rights_t,\n-            relative_path: *mut *const libc::c_char,\n-        ) -> libc::c_int;\n-    }\n }"}, {"sha": "ebea3a03e439f3875485df3596d4b7a40c4d8ae5", "filename": "src/libstd/sys/wasi/io.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6896ed383dbd3a847ef39b713449fc0393292828/src%2Flibstd%2Fsys%2Fwasi%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6896ed383dbd3a847ef39b713449fc0393292828/src%2Flibstd%2Fsys%2Fwasi%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fio.rs?ref=6896ed383dbd3a847ef39b713449fc0393292828", "patch": "@@ -1,19 +1,20 @@\n use crate::marker::PhantomData;\n use crate::slice;\n \n-use libc::{__wasi_ciovec_t, __wasi_iovec_t, c_void};\n+use wasi::wasi_unstable as wasi;\n+use core::ffi::c_void;\n \n #[repr(transparent)]\n pub struct IoSlice<'a> {\n-    vec: __wasi_ciovec_t,\n+    vec: wasi::CIoVec,\n     _p: PhantomData<&'a [u8]>,\n }\n \n impl<'a> IoSlice<'a> {\n     #[inline]\n     pub fn new(buf: &'a [u8]) -> IoSlice<'a> {\n         IoSlice {\n-            vec: __wasi_ciovec_t {\n+            vec: wasi::CIoVec {\n                 buf: buf.as_ptr() as *const c_void,\n                 buf_len: buf.len(),\n             },\n@@ -43,15 +44,15 @@ impl<'a> IoSlice<'a> {\n \n #[repr(transparent)]\n pub struct IoSliceMut<'a> {\n-    vec: __wasi_iovec_t,\n+    vec: wasi::IoVec,\n     _p: PhantomData<&'a mut [u8]>,\n }\n \n impl<'a> IoSliceMut<'a> {\n     #[inline]\n     pub fn new(buf: &'a mut [u8]) -> IoSliceMut<'a> {\n         IoSliceMut {\n-            vec: __wasi_iovec_t {\n+            vec: wasi::IoVec {\n                 buf: buf.as_mut_ptr() as *mut c_void,\n                 buf_len: buf.len()\n             },"}, {"sha": "0a16c29e5af53f4ed39aa3921afe4e7bec65dc6e", "filename": "src/libstd/sys/wasi/mod.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6896ed383dbd3a847ef39b713449fc0393292828/src%2Flibstd%2Fsys%2Fwasi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6896ed383dbd3a847ef39b713449fc0393292828/src%2Flibstd%2Fsys%2Fwasi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fmod.rs?ref=6896ed383dbd3a847ef39b713449fc0393292828", "patch": "@@ -14,10 +14,10 @@\n //! compiling for wasm. That way it's a compile time error for something that's\n //! guaranteed to be a runtime error!\n \n-use libc;\n-use crate::io::{Error, ErrorKind};\n+use crate::io;\n use crate::mem;\n use crate::os::raw::c_char;\n+use wasi::wasi_unstable as wasi;\n \n pub mod alloc;\n pub mod args;\n@@ -60,12 +60,12 @@ pub fn unsupported<T>() -> crate::io::Result<T> {\n     Err(unsupported_err())\n }\n \n-pub fn unsupported_err() -> Error {\n-    Error::new(ErrorKind::Other, \"operation not supported on wasm yet\")\n+pub fn unsupported_err() -> io::Error {\n+    io::Error::new(io::ErrorKind::Other, \"operation not supported on wasm yet\")\n }\n \n-pub fn decode_error_kind(_code: i32) -> ErrorKind {\n-    ErrorKind::Other\n+pub fn decode_error_kind(_code: i32) -> io::ErrorKind {\n+    io::ErrorKind::Other\n }\n \n // This enum is used as the storage for a bunch of types which can't actually\n@@ -83,15 +83,18 @@ pub unsafe fn strlen(mut s: *const c_char) -> usize {\n }\n \n pub unsafe fn abort_internal() -> ! {\n-    libc::abort()\n+    wasi::proc_exit(127)\n }\n \n pub fn hashmap_random_keys() -> (u64, u64) {\n     let mut ret = (0u64, 0u64);\n     unsafe {\n-        let base = &mut ret as *mut (u64, u64) as *mut libc::c_void;\n+        let base = &mut ret as *mut (u64, u64) as *mut core::ffi::c_void;\n         let len = mem::size_of_val(&ret);\n-        cvt_wasi(libc::__wasi_random_get(base, len)).unwrap();\n+        let ret = wasi::raw::__wasi_random_get(base, len);\n+        if ret != 0 {\n+            panic!(\"__wasi_random_get failure\")\n+        }\n     }\n     return ret\n }\n@@ -113,16 +116,14 @@ impl_is_minus_one! { i8 i16 i32 i64 isize }\n \n pub fn cvt<T: IsMinusOne>(t: T) -> crate::io::Result<T> {\n     if t.is_minus_one() {\n-        Err(Error::last_os_error())\n+        Err(io::Error::last_os_error())\n     } else {\n         Ok(t)\n     }\n }\n \n-pub fn cvt_wasi(r: u16) -> crate::io::Result<()> {\n-    if r != libc::__WASI_ESUCCESS {\n-        Err(Error::from_raw_os_error(r as i32))\n-    } else {\n-        Ok(())\n+impl From<wasi::Error> for io::Error {\n+    fn from(err: wasi::Error) -> Self {\n+        Self::from_raw_os_error(err as i32)\n     }\n }"}, {"sha": "026ff71de345b77b3fbccc48dea5becb12277353", "filename": "src/libstd/sys/wasi/os.rs", "status": "modified", "additions": 6, "deletions": 23, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6896ed383dbd3a847ef39b713449fc0393292828/src%2Flibstd%2Fsys%2Fwasi%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6896ed383dbd3a847ef39b713449fc0393292828/src%2Flibstd%2Fsys%2Fwasi%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fos.rs?ref=6896ed383dbd3a847ef39b713449fc0393292828", "patch": "@@ -12,36 +12,20 @@ use crate::sys::memchr;\n use crate::sys::{cvt, unsupported, Void};\n use crate::vec;\n \n+use wasi::wasi_unstable as wasi;\n+\n #[cfg(not(target_feature = \"atomics\"))]\n pub unsafe fn env_lock() -> impl Any {\n     // No need for a lock if we're single-threaded, but this function will need\n     // to get implemented for multi-threaded scenarios\n }\n \n pub fn errno() -> i32 {\n-    extern {\n-        #[thread_local]\n-        static errno: libc::c_int;\n-    }\n-\n-    unsafe { errno as i32 }\n+    panic!(\"unsupported\")\n }\n \n pub fn error_string(errno: i32) -> String {\n-    extern {\n-        fn strerror_r(errnum: libc::c_int, buf: *mut libc::c_char,\n-                      buflen: libc::size_t) -> libc::c_int;\n-    }\n-\n-    let mut buf = [0 as libc::c_char; 1024];\n-\n-    let p = buf.as_mut_ptr();\n-    unsafe {\n-        if strerror_r(errno as libc::c_int, p, buf.len()) < 0 {\n-            panic!(\"strerror_r failure\");\n-        }\n-        str::from_utf8(CStr::from_ptr(p).to_bytes()).unwrap().to_owned()\n-    }\n+    wasi::error_string(errno).to_string()\n }\n \n pub fn getcwd() -> io::Result<PathBuf> {\n@@ -105,6 +89,7 @@ impl Iterator for Env {\n pub fn env() -> Env {\n     unsafe {\n         let _guard = env_lock();\n+        // FIXME: replace with wasi::environ_get\n         let mut environ = libc::environ;\n         let mut result = Vec::new();\n         while environ != ptr::null_mut() && *environ != ptr::null_mut() {\n@@ -174,9 +159,7 @@ pub fn home_dir() -> Option<PathBuf> {\n }\n \n pub fn exit(code: i32) -> ! {\n-    unsafe {\n-        libc::exit(code)\n-    }\n+    unsafe { wasi::proc_exit(code as u32) }\n }\n \n pub fn getpid() -> u32 {"}, {"sha": "dc6a6ef375a1c68d5aae35ce5b71660afdc8b128", "filename": "src/libstd/sys/wasi/stdio.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6896ed383dbd3a847ef39b713449fc0393292828/src%2Flibstd%2Fsys%2Fwasi%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6896ed383dbd3a847ef39b713449fc0393292828/src%2Flibstd%2Fsys%2Fwasi%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fstdio.rs?ref=6896ed383dbd3a847ef39b713449fc0393292828", "patch": "@@ -1,8 +1,9 @@\n use crate::io::{self, IoSlice, IoSliceMut};\n-use crate::libc;\n use crate::mem::ManuallyDrop;\n use crate::sys::fd::WasiFd;\n \n+use wasi::wasi_unstable as wasi;\n+\n pub struct Stdin;\n pub struct Stdout;\n pub struct Stderr;\n@@ -17,7 +18,7 @@ impl Stdin {\n     }\n \n     pub fn read_vectored(&self, data: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        ManuallyDrop::new(unsafe { WasiFd::from_raw(libc::STDIN_FILENO as u32) })\n+        ManuallyDrop::new(unsafe { WasiFd::from_raw(wasi::STDIN_FD) })\n             .read(data)\n     }\n }\n@@ -32,7 +33,7 @@ impl Stdout {\n     }\n \n     pub fn write_vectored(&self, data: &[IoSlice<'_>]) -> io::Result<usize> {\n-        ManuallyDrop::new(unsafe { WasiFd::from_raw(libc::STDOUT_FILENO as u32) })\n+        ManuallyDrop::new(unsafe { WasiFd::from_raw(wasi::STDOUT_FD) })\n             .write(data)\n     }\n \n@@ -51,7 +52,7 @@ impl Stderr {\n     }\n \n     pub fn write_vectored(&self, data: &[IoSlice<'_>]) -> io::Result<usize> {\n-        ManuallyDrop::new(unsafe { WasiFd::from_raw(libc::STDERR_FILENO as u32) })\n+        ManuallyDrop::new(unsafe { WasiFd::from_raw(wasi::STDERR_FD) })\n             .write(data)\n     }\n \n@@ -73,7 +74,7 @@ impl io::Write for Stderr {\n pub const STDIN_BUF_SIZE: usize = crate::sys_common::io::DEFAULT_BUF_SIZE;\n \n pub fn is_ebadf(err: &io::Error) -> bool {\n-    err.raw_os_error() == Some(libc::__WASI_EBADF as i32)\n+    err.raw_os_error() == Some(wasi::EBADF as i32)\n }\n \n pub fn panic_output() -> Option<impl io::Write> {"}, {"sha": "9e0726432d9c49424fc7f5e56c32c5193b958843", "filename": "src/libstd/sys/wasi/thread.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6896ed383dbd3a847ef39b713449fc0393292828/src%2Flibstd%2Fsys%2Fwasi%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6896ed383dbd3a847ef39b713449fc0393292828/src%2Flibstd%2Fsys%2Fwasi%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Fthread.rs?ref=6896ed383dbd3a847ef39b713449fc0393292828", "patch": "@@ -19,8 +19,8 @@ impl Thread {\n     }\n \n     pub fn yield_now() {\n-        let ret = unsafe { libc::__wasi_sched_yield() };\n-        debug_assert_eq!(ret, 0);\n+        let ret = wasi::sched_yield();\n+        debug_assert_eq!(ret, Ok(()));\n     }\n \n     pub fn set_name(_name: &CStr) {"}, {"sha": "4c89a1781b9ef0da3803e30c1d8b00844dc468a3", "filename": "src/libstd/sys/wasi/time.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6896ed383dbd3a847ef39b713449fc0393292828/src%2Flibstd%2Fsys%2Fwasi%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6896ed383dbd3a847ef39b713449fc0393292828/src%2Flibstd%2Fsys%2Fwasi%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasi%2Ftime.rs?ref=6896ed383dbd3a847ef39b713449fc0393292828", "patch": "@@ -1,7 +1,6 @@\n use crate::time::Duration;\n use crate::mem;\n-use crate::sys::cvt_wasi;\n-use libc;\n+use wasi::wasi_unstable as wasi;\n \n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n pub struct Instant(Duration);\n@@ -12,23 +11,19 @@ pub struct SystemTime(Duration);\n pub const UNIX_EPOCH: SystemTime = SystemTime(Duration::from_secs(0));\n \n fn current_time(clock: u32) -> Duration {\n-    unsafe {\n-        let mut ts = mem::zeroed();\n-        cvt_wasi(libc::__wasi_clock_time_get(\n-            clock,\n-            1, // precision... seems ignored though?\n-            &mut ts,\n-        )).unwrap();\n-        Duration::new(\n-            (ts / 1_000_000_000) as u64,\n-            (ts % 1_000_000_000) as u32,\n-        )\n-    }\n+    let ts = wasi::clock_time_get(\n+        clock,\n+        1, // precision... seems ignored though?\n+    ).unwrap();\n+    Duration::new(\n+        (ts / 1_000_000_000) as u64,\n+        (ts % 1_000_000_000) as u32,\n+    )\n }\n \n impl Instant {\n     pub fn now() -> Instant {\n-        Instant(current_time(libc::__WASI_CLOCK_MONOTONIC))\n+        Instant(current_time(wasi::CLOCK_MONOTONIC))\n     }\n \n     pub const fn zero() -> Instant {\n@@ -54,10 +49,10 @@ impl Instant {\n \n impl SystemTime {\n     pub fn now() -> SystemTime {\n-        SystemTime(current_time(libc::__WASI_CLOCK_REALTIME))\n+        SystemTime(current_time(wasi::CLOCK_REALTIME))\n     }\n \n-    pub fn from_wasi_timestamp(ts: libc::__wasi_timestamp_t) -> SystemTime {\n+    pub fn from_wasi_timestamp(ts: wasi::Timestamp) -> SystemTime {\n         SystemTime(Duration::from_nanos(ts))\n     }\n "}]}