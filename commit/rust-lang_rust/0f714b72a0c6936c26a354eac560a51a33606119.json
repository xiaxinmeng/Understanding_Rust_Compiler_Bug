{"sha": "0f714b72a0c6936c26a354eac560a51a33606119", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmNzE0YjcyYTBjNjkzNmMyNmEzNTRlYWM1NjBhNTFhMzM2MDYxMTk=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2017-02-10T21:35:45Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2017-02-10T21:35:45Z"}, "message": "Formatting.", "tree": {"sha": "28ed5d493292c011862e4e9b74360dfcf23847d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/28ed5d493292c011862e4e9b74360dfcf23847d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f714b72a0c6936c26a354eac560a51a33606119", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f714b72a0c6936c26a354eac560a51a33606119", "html_url": "https://github.com/rust-lang/rust/commit/0f714b72a0c6936c26a354eac560a51a33606119", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f714b72a0c6936c26a354eac560a51a33606119/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ffd7005c150dac4a99eea73eeb72189e0f5f694", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ffd7005c150dac4a99eea73eeb72189e0f5f694", "html_url": "https://github.com/rust-lang/rust/commit/6ffd7005c150dac4a99eea73eeb72189e0f5f694"}], "stats": {"total": 56, "additions": 34, "deletions": 22}, "files": [{"sha": "2dd6662e63086e3defa5fda7b3d7a7428634a661", "filename": "src/eval_context.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0f714b72a0c6936c26a354eac560a51a33606119/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f714b72a0c6936c26a354eac560a51a33606119/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=0f714b72a0c6936c26a354eac560a51a33606119", "patch": "@@ -24,24 +24,24 @@ pub type MirRef<'tcx> = Ref<'tcx, mir::Mir<'tcx>>;\n \n pub struct EvalContext<'a, 'tcx: 'a> {\n     /// The results of the type checker, from rustc.\n-    pub(super) tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub(crate) tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     /// The virtual memory system.\n-    pub(super) memory: Memory<'a, 'tcx>,\n+    pub(crate) memory: Memory<'a, 'tcx>,\n \n     /// Precomputed statics, constants and promoteds.\n-    pub(super) globals: HashMap<GlobalId<'tcx>, Global<'tcx>>,\n+    pub(crate) globals: HashMap<GlobalId<'tcx>, Global<'tcx>>,\n \n     /// The virtual call stack.\n-    pub(super) stack: Vec<Frame<'tcx>>,\n+    pub(crate) stack: Vec<Frame<'tcx>>,\n \n     /// The maximum number of stack frames allowed\n-    pub(super) stack_limit: usize,\n+    pub(crate) stack_limit: usize,\n \n     /// The maximum number of operations that may be executed.\n     /// This prevents infinite loops and huge computations from freezing up const eval.\n     /// Remove once halting problem is solved.\n-    pub(super) steps_remaining: u64,\n+    pub(crate) steps_remaining: u64,\n }\n \n /// A stack frame."}, {"sha": "0c7b4971e1df7e974f4e81cf97987f4b6cf3a465", "filename": "src/memory.rs", "status": "modified", "additions": 28, "deletions": 16, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/0f714b72a0c6936c26a354eac560a51a33606119/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f714b72a0c6936c26a354eac560a51a33606119/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=0f714b72a0c6936c26a354eac560a51a33606119", "patch": "@@ -152,33 +152,45 @@ impl<'tcx> Function<'tcx> {\n ////////////////////////////////////////////////////////////////////////////////\n \n pub struct Memory<'a, 'tcx> {\n-    /// Actual memory allocations (arbitrary bytes, may contain pointers into other allocations)\n+    /// Actual memory allocations (arbitrary bytes, may contain pointers into other allocations).\n     alloc_map: HashMap<AllocId, Allocation>,\n-    /// Set of statics, constants, promoteds, vtables, ... to prevent `mark_static_initalized` from stepping\n-    /// out of its own allocations.\n-    /// This set only contains statics backed by an allocation. If they are ByVal or ByValPair they\n-    /// are not here, but will be inserted once they become ByRef.\n+\n+    /// The AllocId to assign to the next new allocation. Always incremented, never gets smaller.\n+    next_id: AllocId,\n+\n+    /// Set of statics, constants, promoteds, vtables, ... to prevent `mark_static_initalized` from\n+    /// stepping out of its own allocations. This set only contains statics backed by an\n+    /// allocation. If they are ByVal or ByValPair they are not here, but will be inserted once\n+    /// they become ByRef.\n     static_alloc: HashSet<AllocId>,\n-    /// Number of virtual bytes allocated\n+\n+    /// Number of virtual bytes allocated.\n     memory_usage: u64,\n-    /// Maximum number of virtual bytes that may be allocated\n+\n+    /// Maximum number of virtual bytes that may be allocated.\n     memory_size: u64,\n+\n     /// Function \"allocations\". They exist solely so pointers have something to point to, and\n     /// we can figure out what they point to.\n     functions: HashMap<AllocId, Function<'tcx>>,\n+\n     /// Inverse map of `functions` so we don't allocate a new pointer every time we need one\n     function_alloc_cache: HashMap<Function<'tcx>, AllocId>,\n-    next_id: AllocId,\n+\n+    /// Target machine data layout to emulate.\n     pub layout: &'a TargetDataLayout,\n-    /// List of memory regions containing packed structures\n-    /// We mark memory as \"packed\" or \"unaligned\" for a single statement, and clear the marking afterwards.\n-    /// In the case where no packed structs are present, it's just a single emptyness check of a set\n-    /// instead of heavily influencing all memory access code as other solutions would.\n+\n+    /// List of memory regions containing packed structures.\n+    ///\n+    /// We mark memory as \"packed\" or \"unaligned\" for a single statement, and clear the marking\n+    /// afterwards. In the case where no packed structs are present, it's just a single emptyness\n+    /// check of a set instead of heavily influencing all memory access code as other solutions\n+    /// would.\n     ///\n-    /// One disadvantage of this solution is the fact that you can cast a pointer to a packed struct\n-    /// to a pointer to a normal struct and if you access a field of both in the same MIR statement,\n-    /// the normal struct access will succeed even though it shouldn't.\n-    /// But even with mir optimizations, that situation is hard/impossible to produce.\n+    /// One disadvantage of this solution is the fact that you can cast a pointer to a packed\n+    /// struct to a pointer to a normal struct and if you access a field of both in the same MIR\n+    /// statement, the normal struct access will succeed even though it shouldn't. But even with\n+    /// mir optimizations, that situation is hard/impossible to produce.\n     packed: BTreeSet<Entry>,\n \n     /// A cache for basic byte allocations keyed by their contents. This is used to deduplicate"}]}