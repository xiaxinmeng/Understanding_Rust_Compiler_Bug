{"sha": "d2028340921658424c9ffbf4305c82e2394f46bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyMDI4MzQwOTIxNjU4NDI0YzlmZmJmNDMwNWM4MmUyMzk0ZjQ2YmQ=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-08-24T03:15:08Z"}, "committer": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-10-16T03:10:10Z"}, "message": "Initial sketching out of the new path module\n\nDefine the basic types, and the GenericPath trait.\n\nThis module is currently called path2. It will be renamed later.", "tree": {"sha": "9d695b9d17093ee1b6c2da400e5d32c9509e8e5a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d695b9d17093ee1b6c2da400e5d32c9509e8e5a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2028340921658424c9ffbf4305c82e2394f46bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2028340921658424c9ffbf4305c82e2394f46bd", "html_url": "https://github.com/rust-lang/rust/commit/d2028340921658424c9ffbf4305c82e2394f46bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2028340921658424c9ffbf4305c82e2394f46bd/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1252ad409258c2d3a2595f8a77dc7b84491cca77", "url": "https://api.github.com/repos/rust-lang/rust/commits/1252ad409258c2d3a2595f8a77dc7b84491cca77", "html_url": "https://github.com/rust-lang/rust/commit/1252ad409258c2d3a2595f8a77dc7b84491cca77"}], "stats": {"total": 286, "additions": 286, "deletions": 0}, "files": [{"sha": "b9f252098344cc552f54e9dc99afdf6b480dc07b", "filename": "src/libstd/path2.rs", "status": "added", "additions": 285, "deletions": 0, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/d2028340921658424c9ffbf4305c82e2394f46bd/src%2Flibstd%2Fpath2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2028340921658424c9ffbf4305c82e2394f46bd/src%2Flibstd%2Fpath2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath2.rs?ref=d2028340921658424c9ffbf4305c82e2394f46bd", "patch": "@@ -0,0 +1,285 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Cross-platform file path handling (re-write)\n+\n+use c_str::{CString, ToCStr};\n+use clone::Clone;\n+use cmp::Eq;\n+use from_str::FromStr;\n+use option::{Option, None, Some};\n+use str;\n+use str::{OwnedStr, Str, StrSlice};\n+use to_str::ToStr;\n+\n+/// Typedef for the platform-native path type\n+#[cfg(unix)]\n+pub type Path = PosixPath;\n+// /// Typedef for the platform-native path type\n+//#[cfg(windows)]\n+//pub type Path = WindowsPath;\n+\n+/// Represents a POSIX file path\n+#[deriving(Clone, DeepClone)]\n+pub struct PosixPath {\n+    priv repr: ~str, // assumed to never be empty\n+    priv sepidx: Option<uint> // index of the final separator in repr\n+}\n+\n+impl Eq for PosixPath {\n+    fn eq(&self, other: &PosixPath) -> bool {\n+        self.repr == other.repr\n+    }\n+}\n+\n+impl FromStr for PosixPath {\n+    fn from_str(s: &str) -> Option<PosixPath> {\n+        Some(PosixPath::new(s))\n+    }\n+}\n+\n+/// A trait that represents the generic operations available on paths\n+pub trait GenericPath: Clone {\n+    /// Creates a new Path from a string.\n+    /// The resulting path will always be normalized.\n+    fn from_str(path: &str) -> Self;\n+\n+    /// Returns the path as a string\n+    fn as_str<'a>(&'a self) -> &'a str;\n+\n+    /// Returns the directory component of `self`, as a string (with no trailing separator).\n+    /// If `self` has no directory component, returns \".\".\n+    fn dirname<'a>(&'a self) -> &'a str;\n+    /// Returns the file component of `self`, as a string.\n+    /// If `self` represents the root of the file hierarchy, returns the empty string.\n+    /// If `self` is \".\", returns the empty string.\n+    fn filename<'a>(&'a self) -> &'a str;\n+    /// Returns the stem of the filename of `self`, as a string.\n+    /// The stem is the portion of the filename just before the last '.'.\n+    /// If there is no '.', the entire filename is returned.\n+    fn filestem<'a>(&'a self) -> &'a str {\n+        let name = self.filename();\n+        match name.rfind('.') {\n+            None | Some(0) => name,\n+            Some(1) if name == \"..\" => name,\n+            Some(pos) => name.slice_to(pos)\n+        }\n+    }\n+    /// Returns the extension of the filename of `self`, as a string option.\n+    /// The extension is the portion of the filename just after the last '.'.\n+    /// If there is no extension, None is returned.\n+    /// If the filename ends in '.', the empty string is returned.\n+    fn extension<'a>(&'a self) -> Option<&'a str> {\n+        let name = self.filename();\n+        match name.rfind('.') {\n+            None | Some(0) => None,\n+            Some(1) if name == \"..\" => None,\n+            Some(pos) => Some(name.slice_from(pos+1))\n+        }\n+    }\n+\n+    /// Replaces the directory portion of the path with the given string.\n+    /// If `self` represents the root of the filesystem hierarchy, the last path component\n+    /// of the given string becomes the filename.\n+    fn set_dirname(&mut self, dirname: &str);\n+    /// Replaces the filename portion of the path with the given string.\n+    /// If the replacement name is \"\", this is equivalent to popping the path.\n+    fn set_filename(&mut self, filename: &str);\n+    /// Replaces the filestem with the given string.\n+    /// If there is no extension in `self` (or `self` has no filename), this is equivalent\n+    /// to `set_filename`. Otherwise, if the given string is \"\", the extension (including\n+    /// the preceding \".\") becomes the new filename.\n+    fn set_filestem(&mut self, filestem: &str) {\n+        // borrowck is being a pain here\n+        let val = {\n+            let name = self.filename();\n+            if !name.is_empty() {\n+                match name.rfind('.') {\n+                    None | Some(0) => None,\n+                    Some(idx) => {\n+                        let mut s = str::with_capacity(filestem.len() + name.len() - idx);\n+                        s.push_str(filestem);\n+                        s.push_str(name.slice_from(idx));\n+                        Some(s)\n+                    }\n+                }\n+            } else { None }\n+        };\n+        match val {\n+            None => self.set_filename(filestem),\n+            Some(s) => self.set_filename(s)\n+        }\n+    }\n+    /// Replaces the extension with the given string.\n+    /// If there is no extension in `self`, this adds one.\n+    /// If the given string is \"\", this removes the extension.\n+    /// If `self` has no filename, this is a no-op.\n+    fn set_extension(&mut self, extension: &str) {\n+        // borrowck causes problems here too\n+        let val = {\n+            let name = self.filename();\n+            if !name.is_empty() {\n+                match name.rfind('.') {\n+                    None | Some(0) => {\n+                        if extension.is_empty() {\n+                            None\n+                        } else {\n+                            let mut s = str::with_capacity(name.len() + extension.len() + 1);\n+                            s.push_str(name);\n+                            s.push_char('.');\n+                            s.push_str(extension);\n+                            Some(s)\n+                        }\n+                    }\n+                    Some(idx) => {\n+                        if extension.is_empty() {\n+                            Some(name.slice_to(idx).to_owned())\n+                        } else {\n+                            let mut s = str::with_capacity(idx + extension.len() + 1);\n+                            s.push_str(name.slice_to(idx+1));\n+                            s.push_str(extension);\n+                            Some(s)\n+                        }\n+                    }\n+                }\n+            } else { None }\n+        };\n+        match val {\n+            None => (),\n+            Some(s) => self.set_filename(s)\n+        }\n+    }\n+\n+    /// Returns a new Path constructed by replacing the dirname with the given string.\n+    /// See `set_dirname` for details.\n+    fn with_dirname(&self, dirname: &str) -> Self {\n+        let mut p = self.clone();\n+        p.set_dirname(dirname);\n+        p\n+    }\n+    /// Returns a new Path constructed by replacing the filename with the given string.\n+    /// See `set_filename` for details.\n+    fn with_filename(&self, filename: &str) -> Self {\n+        let mut p = self.clone();\n+        p.set_filename(filename);\n+        p\n+    }\n+    /// Returns a new Path constructed by setting the filestem to the given string.\n+    /// See `set_filestem` for details.\n+    fn with_filestem(&self, filestem: &str) -> Self {\n+        let mut p = self.clone();\n+        p.set_filestem(filestem);\n+        p\n+    }\n+    /// Returns a new Path constructed by setting the extension to the given string.\n+    /// See `set_extension` for details.\n+    fn with_extension(&self, extension: &str) -> Self {\n+        let mut p = self.clone();\n+        p.set_extension(extension);\n+        p\n+    }\n+\n+\n+    /// Returns the directory component of `self`, as a Path.\n+    /// If `self` represents the root of the filesystem hierarchy, returns `self`.\n+    fn dir_path(&self) -> Self {\n+        GenericPath::from_str(self.dirname())\n+    }\n+    /// Returns the file component of `self`, as a relative Path.\n+    /// If `self` represents the root of the filesystem hierarchy, returns None.\n+    fn file_path(&self) -> Option<Self> {\n+        match self.filename() {\n+            \"\" => None,\n+            s => Some(GenericPath::from_str(s))\n+        }\n+    }\n+\n+    /// Pushes a path (as a string) onto `self`.\n+    /// If the argument represents an absolute path, it replaces `self`.\n+    fn push(&mut self, path: &str);\n+    /// Pushes a Path onto `self`.\n+    /// If the argument represents an absolute path, it replaces `self`.\n+    fn push_path(&mut self, path: &Self);\n+    /// Pops the last path component off of `self` and returns it.\n+    /// If `self` represents the root of the file hierarchy, None is returned.\n+    fn pop_opt(&mut self) -> Option<~str>;\n+\n+    /// Returns a new Path constructed by joining `self` with the given path (as a string).\n+    /// If the given path is absolute, the new Path will represent just that.\n+    fn join(&self, path: &str) -> Self {\n+        let mut p = self.clone();\n+        p.push(path);\n+        p\n+    }\n+    /// Returns a new Path constructed by joining `self` with the given path.\n+    /// If the given path is absolute, the new Path will represent just that.\n+    fn join_path(&self, path: &Self) -> Self {\n+        let mut p = self.clone();\n+        p.push_path(path);\n+        p\n+    }\n+\n+    /// Returns whether `self` represents an absolute path.\n+    fn is_absolute(&self) -> bool;\n+\n+    /// Returns whether `self` is equal to, or is an ancestor of, the given path.\n+    /// If both paths are relative, they are compared as though they are relative\n+    /// to the same parent path.\n+    fn is_ancestor_of(&self, other: &Self) -> bool;\n+\n+    /// Returns the Path that, were it joined to `base`, would yield `self`.\n+    /// If no such path exists, None is returned.\n+    /// If `self` is absolute and `base` is relative, or on Windows if both\n+    /// paths refer to separate drives, an absolute path is returned.\n+    fn path_relative_from(&self, base: &Self) -> Option<Self>;\n+}\n+\n+impl ToStr for PosixPath {\n+    #[inline]\n+    fn to_str(&self) -> ~str {\n+        self.as_str().to_owned()\n+    }\n+}\n+\n+impl ToCStr for PosixPath {\n+    #[inline]\n+    fn to_c_str(&self) -> CString {\n+        self.as_str().to_c_str()\n+    }\n+\n+    #[inline]\n+    unsafe fn to_c_str_unchecked(&self) -> CString {\n+        self.as_str().to_c_str_unchecked()\n+    }\n+}\n+\n+/// Various POSIX helpers\n+pub mod posix {\n+    /// The standard path separator character\n+    pub static sep: char = '/';\n+\n+    /// Returns whether the given char is a path separator\n+    #[inline]\n+    pub fn is_sep(u: char) -> bool {\n+        u == sep\n+    }\n+}\n+\n+/// Various Windows helpers\n+pub mod windows {\n+    /// The standard path separator character\n+    pub static sep: char = '\\\\';\n+\n+    /// Returns whether the given char is a path separator (both / and \\)\n+    #[inline]\n+    pub fn is_sep(u: char) -> bool {\n+        u == sep || u == '/'\n+    }\n+}"}, {"sha": "e8109124e57a0e07a4790be4407fa3d6fea40fb6", "filename": "src/libstd/std.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d2028340921658424c9ffbf4305c82e2394f46bd/src%2Flibstd%2Fstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2028340921658424c9ffbf4305c82e2394f46bd/src%2Flibstd%2Fstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rs?ref=d2028340921658424c9ffbf4305c82e2394f46bd", "patch": "@@ -177,6 +177,7 @@ pub mod libc;\n pub mod c_str;\n pub mod os;\n pub mod path;\n+pub mod path2;\n pub mod rand;\n pub mod run;\n pub mod sys;"}]}