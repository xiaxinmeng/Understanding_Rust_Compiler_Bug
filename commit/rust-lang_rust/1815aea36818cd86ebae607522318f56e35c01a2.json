{"sha": "1815aea36818cd86ebae607522318f56e35c01a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4MTVhZWEzNjgxOGNkODZlYmFlNjA3NTIyMzE4ZjU2ZTM1YzAxYTI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-13T01:20:03Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-24T22:41:59Z"}, "message": "std: Introduce an unstable::stack module\n\nThis module will be used to manage the OS-specific TLS registers used to specify\nthe bounds of the current rust stack (useful in 1:1 and M:N)", "tree": {"sha": "a126b63bf3467662963a00330746183e2580d4eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a126b63bf3467662963a00330746183e2580d4eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1815aea36818cd86ebae607522318f56e35c01a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1815aea36818cd86ebae607522318f56e35c01a2", "html_url": "https://github.com/rust-lang/rust/commit/1815aea36818cd86ebae607522318f56e35c01a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1815aea36818cd86ebae607522318f56e35c01a2/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cab44fb076b4bc56a5877304a7b7617325cb8573", "url": "https://api.github.com/repos/rust-lang/rust/commits/cab44fb076b4bc56a5877304a7b7617325cb8573", "html_url": "https://github.com/rust-lang/rust/commit/cab44fb076b4bc56a5877304a7b7617325cb8573"}], "stats": {"total": 278, "additions": 276, "deletions": 2}, "files": [{"sha": "c72ec3161cd6e18d22b3aef106ea8f91992a198e", "filename": "src/libstd/rt/thread.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1815aea36818cd86ebae607522318f56e35c01a2/src%2Flibstd%2Frt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1815aea36818cd86ebae607522318f56e35c01a2/src%2Flibstd%2Frt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread.rs?ref=1815aea36818cd86ebae607522318f56e35c01a2", "patch": "@@ -41,9 +41,9 @@ static DEFAULT_STACK_SIZE: libc::size_t = 1024 * 1024;\n // and invoke it.\n #[no_split_stack]\n extern fn thread_start(main: *libc::c_void) -> imp::rust_thread_return {\n-    use rt::context;\n+    use unstable::stack;\n     unsafe {\n-        context::record_stack_bounds(0, uint::max_value);\n+        stack::record_stack_bounds(0, uint::max_value);\n         let f: ~proc() = cast::transmute(main);\n         (*f)();\n         cast::transmute(0 as imp::rust_thread_return)"}, {"sha": "46a3a80be25799e99aeca855f65eeb8a19bff2c9", "filename": "src/libstd/unstable/stack.rs", "status": "added", "additions": 274, "deletions": 0, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/1815aea36818cd86ebae607522318f56e35c01a2/src%2Flibstd%2Funstable%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1815aea36818cd86ebae607522318f56e35c01a2/src%2Flibstd%2Funstable%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fstack.rs?ref=1815aea36818cd86ebae607522318f56e35c01a2", "patch": "@@ -0,0 +1,274 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Rust stack-limit management\n+//!\n+//! Currently Rust uses a segmented-stack-like scheme in order to detect stack\n+//! overflow for rust tasks. In this scheme, the prologue of all functions are\n+//! preceded with a check to see whether the current stack limits are being\n+//! exceeded.\n+//!\n+//! This module provides the functionality necessary in order to manage these\n+//! stack limits (which are stored in platform-specific locations). The\n+//! functions here are used at the borders of the task lifetime in order to\n+//! manage these limits.\n+//!\n+//! This function is an unstable module because this scheme for stack overflow\n+//! detection is not guaranteed to continue in the future. Usage of this module\n+//! is discouraged unless absolutely necessary.\n+\n+use rt::task::Task;\n+use option::None;\n+use rt::local::Local;\n+use unstable::intrinsics;\n+\n+static RED_ZONE: uint = 20 * 1024;\n+\n+/// This function is invoked from rust's current __morestack function. Segmented\n+/// stacks are currently not enabled as segmented stacks, but rather one giant\n+/// stack segment. This means that whenever we run out of stack, we want to\n+/// truly consider it to be stack overflow rather than allocating a new stack.\n+#[no_mangle]      // - this is called from C code\n+#[no_split_stack] // - it would be sad for this function to trigger __morestack\n+#[doc(hidden)]    // - Function must be `pub` to get exported, but it's\n+                  //   irrelevant for documentation purposes.\n+#[cfg(not(test))] // in testing, use the original libstd's version\n+pub extern \"C\" fn rust_stack_exhausted() {\n+\n+    unsafe {\n+        // We're calling this function because the stack just ran out. We need\n+        // to call some other rust functions, but if we invoke the functions\n+        // right now it'll just trigger this handler being called again. In\n+        // order to alleviate this, we move the stack limit to be inside of the\n+        // red zone that was allocated for exactly this reason.\n+        let limit = get_sp_limit();\n+        record_sp_limit(limit - RED_ZONE / 2);\n+\n+        // This probably isn't the best course of action. Ideally one would want\n+        // to unwind the stack here instead of just aborting the entire process.\n+        // This is a tricky problem, however. There's a few things which need to\n+        // be considered:\n+        //\n+        //  1. We're here because of a stack overflow, yet unwinding will run\n+        //     destructors and hence arbitrary code. What if that code overflows\n+        //     the stack? One possibility is to use the above allocation of an\n+        //     extra 10k to hope that we don't hit the limit, and if we do then\n+        //     abort the whole program. Not the best, but kind of hard to deal\n+        //     with unless we want to switch stacks.\n+        //\n+        //  2. LLVM will optimize functions based on whether they can unwind or\n+        //     not. It will flag functions with 'nounwind' if it believes that\n+        //     the function cannot trigger unwinding, but if we do unwind on\n+        //     stack overflow then it means that we could unwind in any function\n+        //     anywhere. We would have to make sure that LLVM only places the\n+        //     nounwind flag on functions which don't call any other functions.\n+        //\n+        //  3. The function that overflowed may have owned arguments. These\n+        //     arguments need to have their destructors run, but we haven't even\n+        //     begun executing the function yet, so unwinding will not run the\n+        //     any landing pads for these functions. If this is ignored, then\n+        //     the arguments will just be leaked.\n+        //\n+        // Exactly what to do here is a very delicate topic, and is possibly\n+        // still up in the air for what exactly to do. Some relevant issues:\n+        //\n+        //  #3555 - out-of-stack failure leaks arguments\n+        //  #3695 - should there be a stack limit?\n+        //  #9855 - possible strategies which could be taken\n+        //  #9854 - unwinding on windows through __morestack has never worked\n+        //  #2361 - possible implementation of not using landing pads\n+\n+        let mut task = Local::borrow(None::<Task>);\n+        let n = task.get().name.as_ref()\n+                    .map(|n| n.as_slice()).unwrap_or(\"<unnamed>\");\n+\n+        // See the message below for why this is not emitted to the\n+        // task's logger. This has the additional conundrum of the\n+        // logger may not be initialized just yet, meaning that an FFI\n+        // call would happen to initialized it (calling out to libuv),\n+        // and the FFI call needs 2MB of stack when we just ran out.\n+        println!(\"task '{}' has overflowed its stack\", n);\n+\n+        intrinsics::abort();\n+    }\n+}\n+\n+#[inline(always)]\n+pub unsafe fn record_stack_bounds(stack_lo: uint, stack_hi: uint) {\n+    // When the old runtime had segmented stacks, it used a calculation that was\n+    // \"limit + RED_ZONE + FUDGE\". The red zone was for things like dynamic\n+    // symbol resolution, llvm function calls, etc. In theory this red zone\n+    // value is 0, but it matters far less when we have gigantic stacks because\n+    // we don't need to be so exact about our stack budget. The \"fudge factor\"\n+    // was because LLVM doesn't emit a stack check for functions < 256 bytes in\n+    // size. Again though, we have giant stacks, so we round all these\n+    // calculations up to the nice round number of 20k.\n+    record_sp_limit(stack_lo + RED_ZONE);\n+\n+    return target_record_stack_bounds(stack_lo, stack_hi);\n+\n+    #[cfg(not(windows))] #[cfg(not(target_arch = \"x86_64\"))] #[inline(always)]\n+    unsafe fn target_record_stack_bounds(_stack_lo: uint, _stack_hi: uint) {}\n+    #[cfg(windows, target_arch = \"x86_64\")] #[inline(always)]\n+    unsafe fn target_record_stack_bounds(stack_lo: uint, stack_hi: uint) {\n+        // Windows compiles C functions which may check the stack bounds. This\n+        // means that if we want to perform valid FFI on windows, then we need\n+        // to ensure that the stack bounds are what they truly are for this\n+        // task. More info can be found at:\n+        //   https://github.com/mozilla/rust/issues/3445#issuecomment-26114839\n+        //\n+        // stack range is at TIB: %gs:0x08 (top) and %gs:0x10 (bottom)\n+        asm!(\"mov $0, %gs:0x08\" :: \"r\"(stack_hi) :: \"volatile\");\n+        asm!(\"mov $0, %gs:0x10\" :: \"r\"(stack_lo) :: \"volatile\");\n+    }\n+}\n+\n+/// Records the current limit of the stack as specified by `end`.\n+///\n+/// This is stored in an OS-dependent location, likely inside of the thread\n+/// local storage. The location that the limit is stored is a pre-ordained\n+/// location because it's where LLVM has emitted code to check.\n+///\n+/// Note that this cannot be called under normal circumstances. This function is\n+/// changing the stack limit, so upon returning any further function calls will\n+/// possibly be triggering the morestack logic if you're not careful.\n+///\n+/// Also note that this and all of the inside functions are all flagged as\n+/// \"inline(always)\" because they're messing around with the stack limits.  This\n+/// would be unfortunate for the functions themselves to trigger a morestack\n+/// invocation (if they were an actual function call).\n+#[inline(always)]\n+pub unsafe fn record_sp_limit(limit: uint) {\n+    return target_record_sp_limit(limit);\n+\n+    // x86-64\n+    #[cfg(target_arch = \"x86_64\", target_os = \"macos\")] #[inline(always)]\n+    unsafe fn target_record_sp_limit(limit: uint) {\n+        asm!(\"movq $$0x60+90*8, %rsi\n+              movq $0, %gs:(%rsi)\" :: \"r\"(limit) : \"rsi\" : \"volatile\")\n+    }\n+    #[cfg(target_arch = \"x86_64\", target_os = \"linux\")] #[inline(always)]\n+    unsafe fn target_record_sp_limit(limit: uint) {\n+        asm!(\"movq $0, %fs:112\" :: \"r\"(limit) :: \"volatile\")\n+    }\n+    #[cfg(target_arch = \"x86_64\", target_os = \"win32\")] #[inline(always)]\n+    unsafe fn target_record_sp_limit(limit: uint) {\n+        // see: http://en.wikipedia.org/wiki/Win32_Thread_Information_Block\n+        // store this inside of the \"arbitrary data slot\", but double the size\n+        // because this is 64 bit instead of 32 bit\n+        asm!(\"movq $0, %gs:0x28\" :: \"r\"(limit) :: \"volatile\")\n+    }\n+    #[cfg(target_arch = \"x86_64\", target_os = \"freebsd\")] #[inline(always)]\n+    unsafe fn target_record_sp_limit(limit: uint) {\n+        asm!(\"movq $0, %fs:24\" :: \"r\"(limit) :: \"volatile\")\n+    }\n+\n+    // x86\n+    #[cfg(target_arch = \"x86\", target_os = \"macos\")] #[inline(always)]\n+    unsafe fn target_record_sp_limit(limit: uint) {\n+        asm!(\"movl $$0x48+90*4, %eax\n+              movl $0, %gs:(%eax)\" :: \"r\"(limit) : \"eax\" : \"volatile\")\n+    }\n+    #[cfg(target_arch = \"x86\", target_os = \"linux\")]\n+    #[cfg(target_arch = \"x86\", target_os = \"freebsd\")] #[inline(always)]\n+    unsafe fn target_record_sp_limit(limit: uint) {\n+        asm!(\"movl $0, %gs:48\" :: \"r\"(limit) :: \"volatile\")\n+    }\n+    #[cfg(target_arch = \"x86\", target_os = \"win32\")] #[inline(always)]\n+    unsafe fn target_record_sp_limit(limit: uint) {\n+        // see: http://en.wikipedia.org/wiki/Win32_Thread_Information_Block\n+        // store this inside of the \"arbitrary data slot\"\n+        asm!(\"movl $0, %fs:0x14\" :: \"r\"(limit) :: \"volatile\")\n+    }\n+\n+    // mips, arm - Some brave soul can port these to inline asm, but it's over\n+    //             my head personally\n+    #[cfg(target_arch = \"mips\")]\n+    #[cfg(target_arch = \"arm\")] #[inline(always)]\n+    unsafe fn target_record_sp_limit(limit: uint) {\n+        return record_sp_limit(limit as *c_void);\n+        extern {\n+            fn record_sp_limit(limit: *c_void);\n+        }\n+    }\n+}\n+\n+/// The counterpart of the function above, this function will fetch the current\n+/// stack limit stored in TLS.\n+///\n+/// Note that all of these functions are meant to be exact counterparts of their\n+/// brethren above, except that the operands are reversed.\n+///\n+/// As with the setter, this function does not have a __morestack header and can\n+/// therefore be called in a \"we're out of stack\" situation.\n+#[inline(always)]\n+pub unsafe fn get_sp_limit() -> uint {\n+    return target_get_sp_limit();\n+\n+    // x86-64\n+    #[cfg(target_arch = \"x86_64\", target_os = \"macos\")] #[inline(always)]\n+    unsafe fn target_get_sp_limit() -> uint {\n+        let limit;\n+        asm!(\"movq $$0x60+90*8, %rsi\n+              movq %gs:(%rsi), $0\" : \"=r\"(limit) :: \"rsi\" : \"volatile\");\n+        return limit;\n+    }\n+    #[cfg(target_arch = \"x86_64\", target_os = \"linux\")] #[inline(always)]\n+    unsafe fn target_get_sp_limit() -> uint {\n+        let limit;\n+        asm!(\"movq %fs:112, $0\" : \"=r\"(limit) ::: \"volatile\");\n+        return limit;\n+    }\n+    #[cfg(target_arch = \"x86_64\", target_os = \"win32\")] #[inline(always)]\n+    unsafe fn target_get_sp_limit() -> uint {\n+        let limit;\n+        asm!(\"movq %gs:0x28, $0\" : \"=r\"(limit) ::: \"volatile\");\n+        return limit;\n+    }\n+    #[cfg(target_arch = \"x86_64\", target_os = \"freebsd\")] #[inline(always)]\n+    unsafe fn target_get_sp_limit() -> uint {\n+        let limit;\n+        asm!(\"movq %fs:24, $0\" : \"=r\"(limit) ::: \"volatile\");\n+        return limit;\n+    }\n+\n+    // x86\n+    #[cfg(target_arch = \"x86\", target_os = \"macos\")] #[inline(always)]\n+    unsafe fn target_get_sp_limit() -> uint {\n+        let limit;\n+        asm!(\"movl $$0x48+90*4, %eax\n+              movl %gs:(%eax), $0\" : \"=r\"(limit) :: \"eax\" : \"volatile\");\n+        return limit;\n+    }\n+    #[cfg(target_arch = \"x86\", target_os = \"linux\")]\n+    #[cfg(target_arch = \"x86\", target_os = \"freebsd\")] #[inline(always)]\n+    unsafe fn target_get_sp_limit() -> uint {\n+        let limit;\n+        asm!(\"movl %gs:48, $0\" : \"=r\"(limit) ::: \"volatile\");\n+        return limit;\n+    }\n+    #[cfg(target_arch = \"x86\", target_os = \"win32\")] #[inline(always)]\n+    unsafe fn target_get_sp_limit() -> uint {\n+        let limit;\n+        asm!(\"movl %fs:0x14, $0\" : \"=r\"(limit) ::: \"volatile\");\n+        return limit;\n+    }\n+\n+    // mips, arm - Some brave soul can port these to inline asm, but it's over\n+    //             my head personally\n+    #[cfg(target_arch = \"mips\")]\n+    #[cfg(target_arch = \"arm\")] #[inline(always)]\n+    unsafe fn target_get_sp_limit() -> uint {\n+        return get_sp_limit() as uint;\n+        extern {\n+            fn get_sp_limit() -> *c_void;\n+        }\n+    }\n+}"}]}