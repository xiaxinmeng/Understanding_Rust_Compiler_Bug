{"sha": "91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxZmI3MmE4YTlmNTNkZTJiY2M1NjM4YzEzNThmY2I1NTJkYmE4Y2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-30T07:56:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-30T07:56:05Z"}, "message": "Auto merge of #72768 - JohnTitor:rollup-6kwokh6, r=JohnTitor\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #72033 (Update RELEASES.md for 1.44.0)\n - #72162 (Add Extend::{extend_one,extend_reserve})\n - #72419 (Miri read_discriminant: return a scalar instead of raw underlying bytes)\n - #72621 (Don't bail out of trait selection when predicate references an error)\n - #72677 (Fix diagnostics for `@ ..` binding pattern in tuples and tuple structs)\n - #72710 (Add test to make sure -Wunused-crate-dependencies works with tests)\n - #72724 (Revert recursive `TokenKind::Interpolated` expansion for now)\n - #72741 (Remove unused mut from long-linker-command-lines test)\n - #72750 (Remove remaining calls to `as_local_node_id`)\n - #72752 (remove mk_bool)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "6bd52d61abaa0eab87137167ee3d8e8556670858", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6bd52d61abaa0eab87137167ee3d8e8556670858"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "html_url": "https://github.com/rust-lang/rust/commit/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "html_url": "https://github.com/rust-lang/rust/commit/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9"}, {"sha": "025058f2aa5bcc890d1db8cc71ff63f690b8df0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/025058f2aa5bcc890d1db8cc71ff63f690b8df0f", "html_url": "https://github.com/rust-lang/rust/commit/025058f2aa5bcc890d1db8cc71ff63f690b8df0f"}], "stats": {"total": 1328, "additions": 922, "deletions": 406}, "files": [{"sha": "b2f5d058f5cf117db1a123a04d3cb5744cc6367d", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -4144,7 +4144,6 @@ dependencies = [\n  \"rustc_lexer\",\n  \"rustc_session\",\n  \"rustc_span\",\n- \"smallvec 1.4.0\",\n  \"unicode-normalization\",\n ]\n "}, {"sha": "7cba27e134a7848cc7274baaecd02156f6388a3c", "filename": "RELEASES.md", "status": "modified", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -1,3 +1,163 @@\n+Version 1.44.0 (2020-06-04)\n+==========================\n+\n+Language\n+--------\n+- [You can now use `async/.await` with `#[no_std]` enabled.][69033]\n+- [Added the `unused_braces` lint.][70081]\n+\n+**Syntax-only changes**\n+\n+- [Expansion-driven outline module parsing][69838]\n+```rust\n+#[cfg(FALSE)]\n+mod foo {\n+    mod bar {\n+        mod baz; // `foo/bar/baz.rs` doesn't exist, but no error!\n+    }\n+}\n+```\n+\n+These are still rejected semantically, so you will likely receive an error but\n+these changes can be seen and parsed by macros and conditional compilation.\n+\n+Compiler\n+--------\n+- [Rustc now respects the `-C codegen-units` flag in incremental mode.][70156]\n+  Additionally when in incremental mode rustc defaults to 256 codegen units.\n+- [Refactored `catch_unwind`, to have zero-cost unless unwinding is enabled and\n+  a panic is thrown.][67502]\n+- [Added tier 3\\* support for the `aarch64-unknown-none` and\n+  `aarch64-unknown-none-softfloat` targets.][68334]\n+- [Added tier 3 support for `arm64-apple-tvos` and\n+  `x86_64-apple-tvos` targets.][68191]\n+\n+\n+Libraries\n+---------\n+- [Special cased `vec![]` to map directly to `Vec::new()`.][70632] This allows\n+  `vec![]` to be able to be used in `const` contexts.\n+- [`convert::Infallible` now implements `Hash`.][70281]\n+- [`OsString` now implements `DerefMut` and `IndexMut` returning\n+  a `&mut OsStr`.][70048]\n+- [Unicode 13 is now supported.][69929]\n+- [`String` now implements `From<&mut str>`.][69661]\n+- [`IoSlice` now implements `Copy`.][69403]\n+- [`Vec<T>` now implements `From<[T; N]>`.][68692] Where `N` is less than 32.\n+- [`proc_macro::LexError` now implements `fmt::Display` and `Error`.][68899]\n+- [`from_le_bytes`, `to_le_bytes`, `from_be_bytes`, `to_be_bytes`,\n+  `from_ne_bytes`, and `to_ne_bytes` methods are now `const` for all\n+  integer types.][69373]\n+\n+Stabilized APIs\n+---------------\n+- [`PathBuf::with_capacity`]\n+- [`PathBuf::capacity`]\n+- [`PathBuf::clear`]\n+- [`PathBuf::reserve`]\n+- [`PathBuf::reserve_exact`]\n+- [`PathBuf::shrink_to_fit`]\n+- [`f32::to_int_unchecked`]\n+- [`f64::to_int_unchecked`]\n+- [`Layout::align_to`]\n+- [`Layout::pad_to_align`]\n+- [`Layout::array`]\n+- [`Layout::extend`]\n+\n+Cargo\n+-----\n+- [Added the `cargo tree` command which will print a tree graph of\n+  your dependencies.][cargo/8062] E.g.\n+  ```\n+    mdbook v0.3.2 (/Users/src/rust/mdbook)\n+  \u251c\u2500\u2500 ammonia v3.0.0\n+  \u2502   \u251c\u2500\u2500 html5ever v0.24.0\n+  \u2502   \u2502   \u251c\u2500\u2500 log v0.4.8\n+  \u2502   \u2502   \u2502   \u2514\u2500\u2500 cfg-if v0.1.9\n+  \u2502   \u2502   \u251c\u2500\u2500 mac v0.1.1\n+  \u2502   \u2502   \u2514\u2500\u2500 markup5ever v0.9.0\n+  \u2502   \u2502       \u251c\u2500\u2500 log v0.4.8 (*)\n+  \u2502   \u2502       \u251c\u2500\u2500 phf v0.7.24\n+  \u2502   \u2502       \u2502   \u2514\u2500\u2500 phf_shared v0.7.24\n+  \u2502   \u2502       \u2502       \u251c\u2500\u2500 siphasher v0.2.3\n+  \u2502   \u2502       \u2502       \u2514\u2500\u2500 unicase v1.4.2\n+  \u2502   \u2502       \u2502           [build-dependencies]\n+  \u2502   \u2502       \u2502           \u2514\u2500\u2500 version_check v0.1.5\n+  ...\n+  ```\n+\n+Misc\n+----\n+- [Rustdoc now allows you to specify `--crate-version` to have rustdoc include\n+  the version in the sidebar.][69494]\n+\n+Compatibility Notes\n+-------------------\n+- [Rustc now correctly generates static libraries on Windows GNU targets with\n+  the `.a` extension, rather than the previous `.lib`.][70937]\n+- [Removed the `-C no_integrated_as` flag from rustc.][70345]\n+- [The `file_name` property in JSON output of macro errors now points the actual\n+  source file rather than the previous format of `<NAME macros>`.][70969]\n+  **Note:** this may not point a file that actually exists on the user's system.\n+- [The minimum required external LLVM version has been bumped to LLVM 8.][71147]\n+- [`mem::{zeroed, uninitialised, MaybeUninit}` will now panic when used with types\n+  that do not allow zero initialization such as `NonZeroU8`.][66059] This was\n+  previously a warning.\n+- [In 1.45.0 (the next release) converting a `f64` to `u32` using the `as`\n+  operator has been defined as a saturating operation.][71269] This was previously\n+  undefined behaviour, you can use the `{f64, f32}::to_int_unchecked` methods to\n+  continue using the current behaviour which may desirable in rare performance\n+  sensitive situations.\n+\n+Internal Only\n+-------------\n+These changes provide no direct user facing benefits, but represent significant\n+improvements to the internals and overall performance of rustc and\n+related tools.\n+\n+- [dep_graph Avoid allocating a set on when the number reads are small.][69778]\n+- [Replace big JS dict with JSON parsing.][71250]\n+\n+[69373]: https://github.com/rust-lang/rust/pull/69373/\n+[66059]: https://github.com/rust-lang/rust/pull/66059/\n+[68191]: https://github.com/rust-lang/rust/pull/68191/\n+[68899]: https://github.com/rust-lang/rust/pull/68899/\n+[71147]: https://github.com/rust-lang/rust/pull/71147/\n+[71250]: https://github.com/rust-lang/rust/pull/71250/\n+[70937]: https://github.com/rust-lang/rust/pull/70937/\n+[70969]: https://github.com/rust-lang/rust/pull/70969/\n+[70632]: https://github.com/rust-lang/rust/pull/70632/\n+[70281]: https://github.com/rust-lang/rust/pull/70281/\n+[70345]: https://github.com/rust-lang/rust/pull/70345/\n+[70048]: https://github.com/rust-lang/rust/pull/70048/\n+[70081]: https://github.com/rust-lang/rust/pull/70081/\n+[70156]: https://github.com/rust-lang/rust/pull/70156/\n+[71269]: https://github.com/rust-lang/rust/pull/71269/\n+[69838]: https://github.com/rust-lang/rust/pull/69838/\n+[69929]: https://github.com/rust-lang/rust/pull/69929/\n+[69661]: https://github.com/rust-lang/rust/pull/69661/\n+[69778]: https://github.com/rust-lang/rust/pull/69778/\n+[69494]: https://github.com/rust-lang/rust/pull/69494/\n+[69403]: https://github.com/rust-lang/rust/pull/69403/\n+[69033]: https://github.com/rust-lang/rust/pull/69033/\n+[68692]: https://github.com/rust-lang/rust/pull/68692/\n+[68334]: https://github.com/rust-lang/rust/pull/68334/\n+[67502]: https://github.com/rust-lang/rust/pull/67502/\n+[cargo/8062]: https://github.com/rust-lang/cargo/pull/8062/\n+[`PathBuf::with_capacity`]: https://doc.rust-lang.org/std/path/struct.PathBuf.html#method.with_capacity\n+[`PathBuf::capacity`]: https://doc.rust-lang.org/std/path/struct.PathBuf.html#method.capacity\n+[`PathBuf::clear`]: https://doc.rust-lang.org/std/path/struct.PathBuf.html#method.clear\n+[`PathBuf::reserve`]: https://doc.rust-lang.org/std/path/struct.PathBuf.html#method.reserve\n+[`PathBuf::reserve_exact`]: https://doc.rust-lang.org/std/path/struct.PathBuf.html#method.reserve_exact\n+[`PathBuf::shrink_to_fit`]: https://doc.rust-lang.org/std/path/struct.PathBuf.html#method.shrink_to_fit\n+[`f32::to_int_unchecked`]: https://doc.rust-lang.org/std/primitive.f32.html#method.to_int_unchecked\n+[`f64::to_int_unchecked`]: https://doc.rust-lang.org/std/primitive.f64.html#method.to_int_unchecked\n+[`Layout::align_to`]: https://doc.rust-lang.org/std/alloc/struct.Layout.html#method.align_to\n+[`Layout::pad_to_align`]: https://doc.rust-lang.org/std/alloc/struct.Layout.html#method.pad_to_align\n+[`Layout::array`]: https://doc.rust-lang.org/std/alloc/struct.Layout.html#method.array\n+[`Layout::extend`]: https://doc.rust-lang.org/std/alloc/struct.Layout.html#method.extend\n+\n+\n Version 1.43.1 (2020-05-07)\n ===========================\n "}, {"sha": "c2fe4691b34c098f689b7d27a42e81ae1829fd0e", "filename": "src/liballoc/collections/binary_heap.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -1376,6 +1376,16 @@ impl<T: Ord> Extend<T> for BinaryHeap<T> {\n     fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n         <Self as SpecExtend<I>>::spec_extend(self, iter);\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, item: T) {\n+        self.push(item);\n+    }\n+\n+    #[inline]\n+    fn extend_reserve(&mut self, additional: usize) {\n+        self.reserve(additional);\n+    }\n }\n \n impl<T: Ord, I: IntoIterator<Item = T>> SpecExtend<I> for BinaryHeap<T> {\n@@ -1406,4 +1416,14 @@ impl<'a, T: 'a + Ord + Copy> Extend<&'a T> for BinaryHeap<T> {\n     fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().cloned());\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, &item: &'a T) {\n+        self.push(item);\n+    }\n+\n+    #[inline]\n+    fn extend_reserve(&mut self, additional: usize) {\n+        self.reserve(additional);\n+    }\n }"}, {"sha": "fa1c09d9ece87141bd839841e27cade56d3570c8", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -1901,13 +1901,23 @@ impl<K: Ord, V> Extend<(K, V)> for BTreeMap<K, V> {\n             self.insert(k, v);\n         });\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, (k, v): (K, V)) {\n+        self.insert(k, v);\n+    }\n }\n \n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n impl<'a, K: Ord + Copy, V: Copy> Extend<(&'a K, &'a V)> for BTreeMap<K, V> {\n     fn extend<I: IntoIterator<Item = (&'a K, &'a V)>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().map(|(&key, &value)| (key, value)));\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, (&k, &v): (&'a K, &'a V)) {\n+        self.insert(k, v);\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "525ef38c32fa269f2e31fefbbb3074a85bc9548a", "filename": "src/liballoc/collections/btree/set.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -1152,13 +1152,23 @@ impl<T: Ord> Extend<T> for BTreeSet<T> {\n             self.insert(elem);\n         });\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, elem: T) {\n+        self.insert(elem);\n+    }\n }\n \n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n impl<'a, T: 'a + Ord + Copy> Extend<&'a T> for BTreeSet<T> {\n     fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().cloned());\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, &elem: &'a T) {\n+        self.insert(elem);\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "85f2505f756aa256ea6d3077e1bbe9299ed443fe", "filename": "src/liballoc/collections/linked_list.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -1748,6 +1748,11 @@ impl<T> Extend<T> for LinkedList<T> {\n     fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n         <Self as SpecExtend<I>>::spec_extend(self, iter);\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, elem: T) {\n+        self.push_back(elem);\n+    }\n }\n \n impl<I: IntoIterator> SpecExtend<I> for LinkedList<I::Item> {\n@@ -1767,6 +1772,11 @@ impl<'a, T: 'a + Copy> Extend<&'a T> for LinkedList<T> {\n     fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().cloned());\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, &elem: &'a T) {\n+        self.push_back(elem);\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "ae54d3971baac42ee57703b401ced2808ce1fabd", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -2881,13 +2881,33 @@ impl<A> Extend<A> for VecDeque<A> {\n             }\n         }\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, elem: A) {\n+        self.push_back(elem);\n+    }\n+\n+    #[inline]\n+    fn extend_reserve(&mut self, additional: usize) {\n+        self.reserve(additional);\n+    }\n }\n \n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n impl<'a, T: 'a + Copy> Extend<&'a T> for VecDeque<T> {\n     fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().cloned());\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, &elem: &T) {\n+        self.push_back(elem);\n+    }\n+\n+    #[inline]\n+    fn extend_reserve(&mut self, additional: usize) {\n+        self.reserve(additional);\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "9bcfc9457f50eeeddb839efdfeb8e94a02dcf5a1", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -93,6 +93,7 @@\n #![feature(container_error_extra)]\n #![feature(dropck_eyepatch)]\n #![feature(exact_size_is_empty)]\n+#![feature(extend_one)]\n #![feature(fmt_internals)]\n #![feature(fn_traits)]\n #![feature(fundamental)]"}, {"sha": "0378ff5362a8b9b0af6e2036e6d0ae1d128030f7", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -1799,34 +1799,69 @@ impl Extend<char> for String {\n         self.reserve(lower_bound);\n         iterator.for_each(move |c| self.push(c));\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, c: char) {\n+        self.push(c);\n+    }\n+\n+    #[inline]\n+    fn extend_reserve(&mut self, additional: usize) {\n+        self.reserve(additional);\n+    }\n }\n \n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n impl<'a> Extend<&'a char> for String {\n     fn extend<I: IntoIterator<Item = &'a char>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().cloned());\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, &c: &'a char) {\n+        self.push(c);\n+    }\n+\n+    #[inline]\n+    fn extend_reserve(&mut self, additional: usize) {\n+        self.reserve(additional);\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Extend<&'a str> for String {\n     fn extend<I: IntoIterator<Item = &'a str>>(&mut self, iter: I) {\n         iter.into_iter().for_each(move |s| self.push_str(s));\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, s: &'a str) {\n+        self.push_str(s);\n+    }\n }\n \n #[stable(feature = \"extend_string\", since = \"1.4.0\")]\n impl Extend<String> for String {\n     fn extend<I: IntoIterator<Item = String>>(&mut self, iter: I) {\n         iter.into_iter().for_each(move |s| self.push_str(&s));\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, s: String) {\n+        self.push_str(&s);\n+    }\n }\n \n #[stable(feature = \"herd_cows\", since = \"1.19.0\")]\n impl<'a> Extend<Cow<'a, str>> for String {\n     fn extend<I: IntoIterator<Item = Cow<'a, str>>>(&mut self, iter: I) {\n         iter.into_iter().for_each(move |s| self.push_str(&s));\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, s: Cow<'a, str>) {\n+        self.push_str(&s);\n+    }\n }\n \n /// A convenience impl that delegates to the impl for `&str`."}, {"sha": "42fb1f8c737b3fe92ba099e7dbd4169dd49e7176", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -2045,6 +2045,16 @@ impl<T> Extend<T> for Vec<T> {\n     fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n         <Self as SpecExtend<T, I::IntoIter>>::spec_extend(self, iter.into_iter())\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, item: T) {\n+        self.push(item);\n+    }\n+\n+    #[inline]\n+    fn extend_reserve(&mut self, additional: usize) {\n+        self.reserve(additional);\n+    }\n }\n \n // Specialization trait used for Vec::from_iter and Vec::extend\n@@ -2316,6 +2326,16 @@ impl<'a, T: 'a + Copy> Extend<&'a T> for Vec<T> {\n     fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n         self.spec_extend(iter.into_iter())\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, &item: &'a T) {\n+        self.push(item);\n+    }\n+\n+    #[inline]\n+    fn extend_reserve(&mut self, additional: usize) {\n+        self.reserve(additional);\n+    }\n }\n \n macro_rules! __impl_slice_eq1 {"}, {"sha": "9d20022b6ed6db75bd787773d4b4cc7e6ba7e772", "filename": "src/libcore/iter/traits/collect.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -322,7 +322,7 @@ impl<I: Iterator> IntoIterator for I {\n pub trait Extend<A> {\n     /// Extends a collection with the contents of an iterator.\n     ///\n-    /// As this is the only method for this trait, the [trait-level] docs\n+    /// As this is the only required method for this trait, the [trait-level] docs\n     /// contain more details.\n     ///\n     /// [trait-level]: trait.Extend.html\n@@ -341,11 +341,26 @@ pub trait Extend<A> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn extend<T: IntoIterator<Item = A>>(&mut self, iter: T);\n+\n+    /// Extends a collection with exactly one element.\n+    #[unstable(feature = \"extend_one\", issue = \"72631\")]\n+    fn extend_one(&mut self, item: A) {\n+        self.extend(Some(item));\n+    }\n+\n+    /// Reserves capacity in a collection for the given number of additional elements.\n+    ///\n+    /// The default implementation does nothing.\n+    #[unstable(feature = \"extend_one\", issue = \"72631\")]\n+    fn extend_reserve(&mut self, additional: usize) {\n+        let _ = additional;\n+    }\n }\n \n #[stable(feature = \"extend_for_unit\", since = \"1.28.0\")]\n impl Extend<()> for () {\n     fn extend<T: IntoIterator<Item = ()>>(&mut self, iter: T) {\n         iter.into_iter().for_each(drop)\n     }\n+    fn extend_one(&mut self, _item: ()) {}\n }"}, {"sha": "a10b34d931d10a9080d90db05fcb6ab67a03204d", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -1711,9 +1711,9 @@ pub trait Iterator {\n         ) -> impl FnMut((), T) + 'a {\n             move |(), x| {\n                 if f(&x) {\n-                    left.extend(Some(x));\n+                    left.extend_one(x);\n                 } else {\n-                    right.extend(Some(x));\n+                    right.extend_one(x);\n                 }\n             }\n         }\n@@ -2686,14 +2686,20 @@ pub trait Iterator {\n             us: &'a mut impl Extend<B>,\n         ) -> impl FnMut((), (A, B)) + 'a {\n             move |(), (t, u)| {\n-                ts.extend(Some(t));\n-                us.extend(Some(u));\n+                ts.extend_one(t);\n+                us.extend_one(u);\n             }\n         }\n \n         let mut ts: FromA = Default::default();\n         let mut us: FromB = Default::default();\n \n+        let (lower_bound, _) = self.size_hint();\n+        if lower_bound > 0 {\n+            ts.extend_reserve(lower_bound);\n+            us.extend_reserve(lower_bound);\n+        }\n+\n         self.fold((), extend(&mut ts, &mut us));\n \n         (ts, us)"}, {"sha": "a5b9c2a95bbea14074f4fbf7d03257bf65432cde", "filename": "src/librustc_ast/token.rs", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_ast%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_ast%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Ftoken.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -673,6 +673,62 @@ impl Token {\n \n         Some(Token::new(kind, self.span.to(joint.span)))\n     }\n+\n+    // See comments in `Nonterminal::to_tokenstream` for why we care about\n+    // *probably* equal here rather than actual equality\n+    crate fn probably_equal_for_proc_macro(&self, other: &Token) -> bool {\n+        if mem::discriminant(&self.kind) != mem::discriminant(&other.kind) {\n+            return false;\n+        }\n+        match (&self.kind, &other.kind) {\n+            (&Eq, &Eq)\n+            | (&Lt, &Lt)\n+            | (&Le, &Le)\n+            | (&EqEq, &EqEq)\n+            | (&Ne, &Ne)\n+            | (&Ge, &Ge)\n+            | (&Gt, &Gt)\n+            | (&AndAnd, &AndAnd)\n+            | (&OrOr, &OrOr)\n+            | (&Not, &Not)\n+            | (&Tilde, &Tilde)\n+            | (&At, &At)\n+            | (&Dot, &Dot)\n+            | (&DotDot, &DotDot)\n+            | (&DotDotDot, &DotDotDot)\n+            | (&DotDotEq, &DotDotEq)\n+            | (&Comma, &Comma)\n+            | (&Semi, &Semi)\n+            | (&Colon, &Colon)\n+            | (&ModSep, &ModSep)\n+            | (&RArrow, &RArrow)\n+            | (&LArrow, &LArrow)\n+            | (&FatArrow, &FatArrow)\n+            | (&Pound, &Pound)\n+            | (&Dollar, &Dollar)\n+            | (&Question, &Question)\n+            | (&Whitespace, &Whitespace)\n+            | (&Comment, &Comment)\n+            | (&Eof, &Eof) => true,\n+\n+            (&BinOp(a), &BinOp(b)) | (&BinOpEq(a), &BinOpEq(b)) => a == b,\n+\n+            (&OpenDelim(a), &OpenDelim(b)) | (&CloseDelim(a), &CloseDelim(b)) => a == b,\n+\n+            (&DocComment(a), &DocComment(b)) | (&Shebang(a), &Shebang(b)) => a == b,\n+\n+            (&Literal(a), &Literal(b)) => a == b,\n+\n+            (&Lifetime(a), &Lifetime(b)) => a == b,\n+            (&Ident(a, b), &Ident(c, d)) => {\n+                b == d && (a == c || a == kw::DollarCrate || c == kw::DollarCrate)\n+            }\n+\n+            (&Interpolated(_), &Interpolated(_)) => false,\n+\n+            _ => panic!(\"forgot to add a token?\"),\n+        }\n+    }\n }\n \n impl PartialEq<TokenKind> for Token {"}, {"sha": "075aaa7e5bc013dd5b0d9744d6ec73efda73de18", "filename": "src/librustc_ast/tokenstream.rs", "status": "modified", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_ast%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_ast%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Ftokenstream.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -21,6 +21,8 @@ use rustc_macros::HashStable_Generic;\n use rustc_span::{Span, DUMMY_SP};\n use smallvec::{smallvec, SmallVec};\n \n+use log::debug;\n+\n use std::{iter, mem};\n \n /// When the main rust parser encounters a syntax-extension invocation, it\n@@ -66,6 +68,23 @@ impl TokenTree {\n         }\n     }\n \n+    // See comments in `Nonterminal::to_tokenstream` for why we care about\n+    // *probably* equal here rather than actual equality\n+    //\n+    // This is otherwise the same as `eq_unspanned`, only recursing with a\n+    // different method.\n+    pub fn probably_equal_for_proc_macro(&self, other: &TokenTree) -> bool {\n+        match (self, other) {\n+            (TokenTree::Token(token), TokenTree::Token(token2)) => {\n+                token.probably_equal_for_proc_macro(token2)\n+            }\n+            (TokenTree::Delimited(_, delim, tts), TokenTree::Delimited(_, delim2, tts2)) => {\n+                delim == delim2 && tts.probably_equal_for_proc_macro(&tts2)\n+            }\n+            _ => false,\n+        }\n+    }\n+\n     /// Retrieves the TokenTree's span.\n     pub fn span(&self) -> Span {\n         match self {\n@@ -288,6 +307,112 @@ impl TokenStream {\n         t1.next().is_none() && t2.next().is_none()\n     }\n \n+    // See comments in `Nonterminal::to_tokenstream` for why we care about\n+    // *probably* equal here rather than actual equality\n+    //\n+    // This is otherwise the same as `eq_unspanned`, only recursing with a\n+    // different method.\n+    pub fn probably_equal_for_proc_macro(&self, other: &TokenStream) -> bool {\n+        // When checking for `probably_eq`, we ignore certain tokens that aren't\n+        // preserved in the AST. Because they are not preserved, the pretty\n+        // printer arbitrarily adds or removes them when printing as token\n+        // streams, making a comparison between a token stream generated from an\n+        // AST and a token stream which was parsed into an AST more reliable.\n+        fn semantic_tree(tree: &TokenTree) -> bool {\n+            if let TokenTree::Token(token) = tree {\n+                if let\n+                    // The pretty printer tends to add trailing commas to\n+                    // everything, and in particular, after struct fields.\n+                    | token::Comma\n+                    // The pretty printer emits `NoDelim` as whitespace.\n+                    | token::OpenDelim(DelimToken::NoDelim)\n+                    | token::CloseDelim(DelimToken::NoDelim)\n+                    // The pretty printer collapses many semicolons into one.\n+                    | token::Semi\n+                    // The pretty printer collapses whitespace arbitrarily and can\n+                    // introduce whitespace from `NoDelim`.\n+                    | token::Whitespace\n+                    // The pretty printer can turn `$crate` into `::crate_name`\n+                    | token::ModSep = token.kind {\n+                    return false;\n+                }\n+            }\n+            true\n+        }\n+\n+        // When comparing two `TokenStream`s, we ignore the `IsJoint` information.\n+        //\n+        // However, `rustc_parse::lexer::tokentrees::TokenStreamBuilder` will\n+        // use `Token.glue` on adjacent tokens with the proper `IsJoint`.\n+        // Since we are ignoreing `IsJoint`, a 'glued' token (e.g. `BinOp(Shr)`)\n+        // and its 'split'/'unglued' compoenents (e.g. `Gt, Gt`) are equivalent\n+        // when determining if two `TokenStream`s are 'probably equal'.\n+        //\n+        // Therefore, we use `break_two_token_op` to convert all tokens\n+        // to the 'unglued' form (if it exists). This ensures that two\n+        // `TokenStream`s which differ only in how their tokens are glued\n+        // will be considered 'probably equal', which allows us to keep spans.\n+        //\n+        // This is important when the original `TokenStream` contained\n+        // extra spaces (e.g. `f :: < Vec < _ > > ( ) ;'). These extra spaces\n+        // will be omitted when we pretty-print, which can cause the original\n+        // and reparsed `TokenStream`s to differ in the assignment of `IsJoint`,\n+        // leading to some tokens being 'glued' together in one stream but not\n+        // the other. See #68489 for more details.\n+        fn break_tokens(tree: TokenTree) -> impl Iterator<Item = TokenTree> {\n+            // In almost all cases, we should have either zero or one levels\n+            // of 'unglueing'. However, in some unusual cases, we may need\n+            // to iterate breaking tokens mutliple times. For example:\n+            // '[BinOpEq(Shr)] => [Gt, Ge] -> [Gt, Gt, Eq]'\n+            let mut token_trees: SmallVec<[_; 2]>;\n+            if let TokenTree::Token(token) = &tree {\n+                let mut out = SmallVec::<[_; 2]>::new();\n+                out.push(token.clone());\n+                // Iterate to fixpoint:\n+                // * We start off with 'out' containing our initial token, and `temp` empty\n+                // * If we are able to break any tokens in `out`, then `out` will have\n+                //   at least one more element than 'temp', so we will try to break tokens\n+                //   again.\n+                // * If we cannot break any tokens in 'out', we are done\n+                loop {\n+                    let mut temp = SmallVec::<[_; 2]>::new();\n+                    let mut changed = false;\n+\n+                    for token in out.into_iter() {\n+                        if let Some((first, second)) = token.kind.break_two_token_op() {\n+                            temp.push(Token::new(first, DUMMY_SP));\n+                            temp.push(Token::new(second, DUMMY_SP));\n+                            changed = true;\n+                        } else {\n+                            temp.push(token);\n+                        }\n+                    }\n+                    out = temp;\n+                    if !changed {\n+                        break;\n+                    }\n+                }\n+                token_trees = out.into_iter().map(|t| TokenTree::Token(t)).collect();\n+                if token_trees.len() != 1 {\n+                    debug!(\"break_tokens: broke {:?} to {:?}\", tree, token_trees);\n+                }\n+            } else {\n+                token_trees = SmallVec::new();\n+                token_trees.push(tree);\n+            }\n+            token_trees.into_iter()\n+        }\n+\n+        let mut t1 = self.trees().filter(semantic_tree).flat_map(break_tokens);\n+        let mut t2 = other.trees().filter(semantic_tree).flat_map(break_tokens);\n+        for (t1, t2) in t1.by_ref().zip(t2.by_ref()) {\n+            if !t1.probably_equal_for_proc_macro(&t2) {\n+                return false;\n+            }\n+        }\n+        t1.next().is_none() && t2.next().is_none()\n+    }\n+\n     pub fn map_enumerated<F: FnMut(usize, TokenTree) -> TokenTree>(self, mut f: F) -> TokenStream {\n         TokenStream(Lrc::new(\n             self.0"}, {"sha": "47d10f86d03e27550d2a33e89bcce69c55d9c22c", "filename": "src/librustc_ast_lowering/item.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_ast_lowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_ast_lowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fitem.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -1321,12 +1321,15 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                                     .get_partial_res(bound_pred.bounded_ty.id)\n                                     .map(|d| d.base_res())\n                                 {\n-                                    if let Some(node_id) =\n-                                        self.resolver.definitions().as_local_node_id(def_id)\n-                                    {\n+                                    if let Some(def_id) = def_id.as_local() {\n                                         for param in &generics.params {\n                                             if let GenericParamKind::Type { .. } = param.kind {\n-                                                if node_id == param.id {\n+                                                if def_id\n+                                                    == self\n+                                                        .resolver\n+                                                        .definitions()\n+                                                        .local_def_id(param.id)\n+                                                {\n                                                     add_bounds\n                                                         .entry(param.id)\n                                                         .or_default()"}, {"sha": "55c1f8026633702acdff8688200a5d4793cf0c7d", "filename": "src/librustc_ast_lowering/pat.rs", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_ast_lowering%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_ast_lowering%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fpat.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -3,6 +3,7 @@ use super::{ImplTraitContext, LoweringContext, ParamMode};\n use rustc_ast::ast::*;\n use rustc_ast::ptr::P;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n+use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_span::symbol::Ident;\n@@ -102,10 +103,36 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             // Note that unlike for slice patterns,\n             // where `xs @ ..` is a legal sub-slice pattern,\n             // it is not a legal sub-tuple pattern.\n-            if pat.is_rest() {\n-                rest = Some((idx, pat.span));\n-                break;\n+            match pat.kind {\n+                // Found a sub-tuple rest pattern\n+                PatKind::Rest => {\n+                    rest = Some((idx, pat.span));\n+                    break;\n+                }\n+                // Found a sub-tuple pattern `$binding_mode $ident @ ..`.\n+                // This is not allowed as a sub-tuple pattern\n+                PatKind::Ident(ref _bm, ident, Some(ref sub)) if sub.is_rest() => {\n+                    rest = Some((idx, pat.span));\n+                    let sp = pat.span;\n+                    self.diagnostic()\n+                        .struct_span_err(\n+                            sp,\n+                            &format!(\"`{} @` is not allowed in a {}\", ident.name, ctx),\n+                        )\n+                        .span_label(sp, \"this is only allowed in slice patterns\")\n+                        .help(\"remove this and bind each tuple field independently\")\n+                        .span_suggestion_verbose(\n+                            sp,\n+                            &format!(\"if you don't need to use the contents of {}, discard the tuple's remaining fields\", ident),\n+                            \"..\".to_string(),\n+                            Applicability::MaybeIncorrect,\n+                        )\n+                        .emit();\n+                    break;\n+                }\n+                _ => {}\n             }\n+\n             // It was not a sub-tuple pattern so lower it normally.\n             elems.push(self.lower_pat(pat));\n         }"}, {"sha": "0b2e7cda1b4ccdc774ab014e26852f58ca4ea849", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -22,6 +22,7 @@\n #![feature(test)]\n #![feature(associated_type_bounds)]\n #![feature(thread_id_value)]\n+#![feature(extend_one)]\n #![allow(rustc::default_hash_types)]\n \n #[macro_use]"}, {"sha": "43002178eb9717478e23ca88a3ffad7647adda14", "filename": "src/librustc_data_structures/thin_vec.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_data_structures%2Fthin_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_data_structures%2Fthin_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fthin_vec.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -53,6 +53,20 @@ impl<T> Extend<T> for ThinVec<T> {\n             ThinVec(None) => *self = iter.into_iter().collect::<Vec<_>>().into(),\n         }\n     }\n+\n+    fn extend_one(&mut self, item: T) {\n+        match *self {\n+            ThinVec(Some(ref mut vec)) => vec.push(item),\n+            ThinVec(None) => *self = vec![item].into(),\n+        }\n+    }\n+\n+    fn extend_reserve(&mut self, additional: usize) {\n+        match *self {\n+            ThinVec(Some(ref mut vec)) => vec.reserve(additional),\n+            ThinVec(None) => *self = Vec::with_capacity(additional).into(),\n+        }\n+    }\n }\n \n impl<T: HashStable<CTX>, CTX> HashStable<CTX> for ThinVec<T> {"}, {"sha": "c8971c2f9adbd465f6e53395574f1c9c14dcb98b", "filename": "src/librustc_hir/definitions.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_hir%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_hir%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fdefinitions.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -332,17 +332,6 @@ impl Definitions {\n         })\n     }\n \n-    #[inline]\n-    pub fn as_local_node_id(&self, def_id: DefId) -> Option<ast::NodeId> {\n-        if let Some(def_id) = def_id.as_local() {\n-            let node_id = self.def_id_to_node_id[def_id];\n-            if node_id != ast::DUMMY_NODE_ID {\n-                return Some(node_id);\n-            }\n-        }\n-        None\n-    }\n-\n     #[inline]\n     pub fn as_local_hir_id(&self, def_id: LocalDefId) -> hir::HirId {\n         self.local_def_id_to_hir_id(def_id)"}, {"sha": "3effc4164501155007c3006929201b2e9042d0d9", "filename": "src/librustc_index/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_index%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_index%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_index%2Flib.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -2,6 +2,7 @@\n #![feature(const_if_match)]\n #![feature(const_fn)]\n #![feature(const_panic)]\n+#![feature(extend_one)]\n #![feature(unboxed_closures)]\n #![feature(test)]\n #![feature(fn_traits)]"}, {"sha": "4dde33283f575bab63edc8ec1b077798de874052", "filename": "src/librustc_index/vec.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_index%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_index%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_index%2Fvec.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -736,6 +736,16 @@ impl<I: Idx, T> Extend<T> for IndexVec<I, T> {\n     fn extend<J: IntoIterator<Item = T>>(&mut self, iter: J) {\n         self.raw.extend(iter);\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, item: T) {\n+        self.raw.push(item);\n+    }\n+\n+    #[inline]\n+    fn extend_reserve(&mut self, additional: usize) {\n+        self.raw.reserve(additional);\n+    }\n }\n \n impl<I: Idx, T> FromIterator<T> for IndexVec<I, T> {"}, {"sha": "ed04ee02b7203c6028ec3329d4401e4250873867", "filename": "src/librustc_infer/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_infer%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_infer%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Flib.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -16,6 +16,7 @@\n #![feature(bool_to_option)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n+#![feature(extend_one)]\n #![feature(never_type)]\n #![feature(or_patterns)]\n #![feature(range_is_empty)]"}, {"sha": "8081cac0067f172821c84a07cf6d4a4c22ff8d3d", "filename": "src/librustc_infer/traits/util.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Futil.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -81,6 +81,14 @@ impl Extend<ty::Predicate<'tcx>> for PredicateSet<'tcx> {\n             self.insert(pred);\n         }\n     }\n+\n+    fn extend_one(&mut self, pred: ty::Predicate<'tcx>) {\n+        self.insert(pred);\n+    }\n+\n+    fn extend_reserve(&mut self, additional: usize) {\n+        Extend::<ty::Predicate<'tcx>>::extend_reserve(&mut self.set, additional);\n+    }\n }\n \n ///////////////////////////////////////////////////////////////////////////"}, {"sha": "fc588e049d7d8b9da719d8ff096f5ff40ed4d53d", "filename": "src/librustc_middle/mir/interpret/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -1,4 +1,4 @@\n-use super::{AllocId, Pointer, RawConst, ScalarMaybeUninit};\n+use super::{AllocId, Pointer, RawConst, Scalar};\n \n use crate::mir::interpret::ConstValue;\n use crate::ty::layout::LayoutError;\n@@ -391,7 +391,7 @@ pub enum UndefinedBehaviorInfo<'tcx> {\n     /// Using a non-character `u32` as character.\n     InvalidChar(u32),\n     /// An enum discriminant was set to a value which was outside the range of valid values.\n-    InvalidDiscriminant(ScalarMaybeUninit),\n+    InvalidDiscriminant(Scalar),\n     /// Using a pointer-not-to-a-function as function pointer.\n     InvalidFunctionPointer(Pointer),\n     /// Using a string that is not valid UTF-8,"}, {"sha": "4059bfedc6da47ab8bdf591ba048b72d2461fd35", "filename": "src/librustc_middle/mir/tcx.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_middle%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_middle%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Ftcx.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -5,7 +5,6 @@\n \n use crate::mir::*;\n use crate::ty::subst::Subst;\n-use crate::ty::util::IntTypeExt;\n use crate::ty::{self, Ty, TyCtxt};\n use rustc_hir as hir;\n use rustc_target::abi::VariantIdx;\n@@ -174,17 +173,7 @@ impl<'tcx> Rvalue<'tcx> {\n                 tcx.intern_tup(&[ty, tcx.types.bool])\n             }\n             Rvalue::UnaryOp(UnOp::Not | UnOp::Neg, ref operand) => operand.ty(local_decls, tcx),\n-            Rvalue::Discriminant(ref place) => {\n-                let ty = place.ty(local_decls, tcx).ty;\n-                match ty.kind {\n-                    ty::Adt(adt_def, _) => adt_def.repr.discr_type().to_ty(tcx),\n-                    ty::Generator(_, substs, _) => substs.as_generator().discr_ty(tcx),\n-                    _ => {\n-                        // This can only be `0`, for now, so `u8` will suffice.\n-                        tcx.types.u8\n-                    }\n-                }\n-            }\n+            Rvalue::Discriminant(ref place) => place.ty(local_decls, tcx).ty.discriminant_ty(tcx),\n             Rvalue::NullaryOp(NullOp::Box, t) => tcx.mk_box(t),\n             Rvalue::NullaryOp(NullOp::SizeOf, _) => tcx.types.usize,\n             Rvalue::Aggregate(ref ak, ref ops) => match **ak {"}, {"sha": "3a08d202ea385bdefe2f30cd6c2acbc95111c6ea", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -2251,11 +2251,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         if self.features().never_type_fallback { self.types.never } else { self.types.unit }\n     }\n \n-    #[inline]\n-    pub fn mk_bool(self) -> Ty<'tcx> {\n-        self.mk_ty(Bool)\n-    }\n-\n     #[inline]\n     pub fn mk_fn_def(self, def_id: DefId, substs: SubstsRef<'tcx>) -> Ty<'tcx> {\n         self.mk_ty(FnDef(def_id, substs))"}, {"sha": "4cd3be932def004bfe7ffac53343770fc596d78e", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -2037,6 +2037,8 @@ impl ReprOptions {\n         self.flags.contains(ReprFlags::HIDE_NICHE)\n     }\n \n+    /// Returns the discriminant type, given these `repr` options.\n+    /// This must only be called on enums!\n     pub fn discr_type(&self) -> attr::IntType {\n         self.int.unwrap_or(attr::SignedInt(ast::IntTy::Isize))\n     }\n@@ -2269,6 +2271,7 @@ impl<'tcx> AdtDef {\n \n     #[inline]\n     pub fn eval_explicit_discr(&self, tcx: TyCtxt<'tcx>, expr_did: DefId) -> Option<Discr<'tcx>> {\n+        assert!(self.is_enum());\n         let param_env = tcx.param_env(expr_did);\n         let repr_type = self.repr.discr_type();\n         match tcx.const_eval_poly(expr_did) {\n@@ -2305,6 +2308,7 @@ impl<'tcx> AdtDef {\n         &'tcx self,\n         tcx: TyCtxt<'tcx>,\n     ) -> impl Iterator<Item = (VariantIdx, Discr<'tcx>)> + Captures<'tcx> {\n+        assert!(self.is_enum());\n         let repr_type = self.repr.discr_type();\n         let initial = repr_type.initial_discriminant(tcx);\n         let mut prev_discr = None::<Discr<'tcx>>;\n@@ -2337,6 +2341,7 @@ impl<'tcx> AdtDef {\n         tcx: TyCtxt<'tcx>,\n         variant_index: VariantIdx,\n     ) -> Discr<'tcx> {\n+        assert!(self.is_enum());\n         let (val, offset) = self.discriminant_def_for_variant(variant_index);\n         let explicit_value = val\n             .and_then(|expr_did| self.eval_explicit_discr(tcx, expr_did))"}, {"sha": "f4962ced6c03a83e613e80ca8be838520cdc30cf", "filename": "src/librustc_middle/ty/sty.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_middle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_middle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsty.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -29,6 +29,7 @@ use std::borrow::Cow;\n use std::cmp::Ordering;\n use std::marker::PhantomData;\n use std::ops::Range;\n+use ty::util::IntTypeExt;\n \n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n #[derive(HashStable, TypeFoldable, Lift)]\n@@ -2096,14 +2097,28 @@ impl<'tcx> TyS<'tcx> {\n         variant_index: VariantIdx,\n     ) -> Option<Discr<'tcx>> {\n         match self.kind {\n-            TyKind::Adt(adt, _) => Some(adt.discriminant_for_variant(tcx, variant_index)),\n+            TyKind::Adt(adt, _) if adt.is_enum() => {\n+                Some(adt.discriminant_for_variant(tcx, variant_index))\n+            }\n             TyKind::Generator(def_id, substs, _) => {\n                 Some(substs.as_generator().discriminant_for_variant(def_id, tcx, variant_index))\n             }\n             _ => None,\n         }\n     }\n \n+    /// Returns the type of the discriminant of this type.\n+    pub fn discriminant_ty(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n+        match self.kind {\n+            ty::Adt(adt, _) if adt.is_enum() => adt.repr.discr_type().to_ty(tcx),\n+            ty::Generator(_, substs, _) => substs.as_generator().discr_ty(tcx),\n+            _ => {\n+                // This can only be `0`, for now, so `u8` will suffice.\n+                tcx.types.u8\n+            }\n+        }\n+    }\n+\n     /// When we create a closure, we record its kind (i.e., what trait\n     /// it implements) into its `ClosureSubsts` using a type\n     /// parameter. This is kind of a phantom type, except that the"}, {"sha": "115a472cabe5ea89b6b0ad2926cc6142b0602628", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -220,15 +220,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             sym::discriminant_value => {\n                 let place = self.deref_operand(args[0])?;\n                 let discr_val = self.read_discriminant(place.into())?.0;\n-                let scalar = match dest.layout.ty.kind {\n-                    ty::Int(_) => Scalar::from_int(\n-                        self.sign_extend(discr_val, dest.layout) as i128,\n-                        dest.layout.size,\n-                    ),\n-                    ty::Uint(_) => Scalar::from_uint(discr_val, dest.layout.size),\n-                    _ => bug!(\"invalid `discriminant_value` return layout: {:?}\", dest.layout),\n-                };\n-                self.write_scalar(scalar, dest)?;\n+                self.write_scalar(discr_val, dest)?;\n             }\n             sym::unchecked_shl\n             | sym::unchecked_shr"}, {"sha": "db4473154c471af4a9c42f53e1e129afa8a9bbf2", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 95, "deletions": 68, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -7,15 +7,15 @@ use std::fmt::Write;\n use rustc_errors::ErrorReported;\n use rustc_hir::def::Namespace;\n use rustc_macros::HashStable;\n-use rustc_middle::ty::layout::{IntegerExt, PrimitiveExt, TyAndLayout};\n+use rustc_middle::ty::layout::{PrimitiveExt, TyAndLayout};\n use rustc_middle::ty::print::{FmtPrinter, PrettyPrinter, Printer};\n use rustc_middle::ty::Ty;\n use rustc_middle::{mir, ty};\n-use rustc_target::abi::{Abi, DiscriminantKind, HasDataLayout, Integer, LayoutOf, Size};\n+use rustc_target::abi::{Abi, DiscriminantKind, HasDataLayout, LayoutOf, Size};\n use rustc_target::abi::{VariantIdx, Variants};\n \n use super::{\n-    from_known_layout, sign_extend, truncate, ConstValue, GlobalId, InterpCx, InterpResult,\n+    from_known_layout, mir_assign_valid_types, ConstValue, GlobalId, InterpCx, InterpResult,\n     MPlaceTy, Machine, MemPlace, Place, PlaceTy, Pointer, Scalar, ScalarMaybeUninit,\n };\n \n@@ -469,6 +469,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             .try_fold(base_op, |op, elem| self.operand_projection(op, elem))?;\n \n         trace!(\"eval_place_to_op: got {:?}\", *op);\n+        // Sanity-check the type we ended up with.\n+        debug_assert!(mir_assign_valid_types(\n+            *self.tcx,\n+            self.layout_of(self.subst_from_current_frame_and_normalize_erasing_regions(\n+                place.ty(&self.frame().body.local_decls, *self.tcx).ty\n+            ))?,\n+            op.layout,\n+        ));\n         Ok(op)\n     }\n \n@@ -576,98 +584,113 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Read discriminant, return the runtime value as well as the variant index.\n     pub fn read_discriminant(\n         &self,\n-        rval: OpTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx, (u128, VariantIdx)> {\n-        trace!(\"read_discriminant_value {:#?}\", rval.layout);\n-\n-        let (discr_layout, discr_kind, discr_index) = match rval.layout.variants {\n+        op: OpTy<'tcx, M::PointerTag>,\n+    ) -> InterpResult<'tcx, (Scalar<M::PointerTag>, VariantIdx)> {\n+        trace!(\"read_discriminant_value {:#?}\", op.layout);\n+\n+        // Get type and layout of the discriminant.\n+        let discr_layout = self.layout_of(op.layout.ty.discriminant_ty(*self.tcx))?;\n+        trace!(\"discriminant type: {:?}\", discr_layout.ty);\n+\n+        // We use \"discriminant\" to refer to the value associated with a particular enum variant.\n+        // This is not to be confused with its \"variant index\", which is just determining its position in the\n+        // declared list of variants -- they can differ with explicitly assigned discriminants.\n+        // We use \"tag\" to refer to how the discriminant is encoded in memory, which can be either\n+        // straight-forward (`DiscriminantKind::Tag`) or with a niche (`DiscriminantKind::Niche`).\n+        // Unfortunately, the rest of the compiler calls the latter \"discriminant\", too, which makes things\n+        // rather confusing.\n+        let (tag_scalar_layout, tag_kind, tag_index) = match op.layout.variants {\n             Variants::Single { index } => {\n-                let discr_val = rval\n-                    .layout\n-                    .ty\n-                    .discriminant_for_variant(*self.tcx, index)\n-                    .map_or(u128::from(index.as_u32()), |discr| discr.val);\n-                return Ok((discr_val, index));\n+                let discr = match op.layout.ty.discriminant_for_variant(*self.tcx, index) {\n+                    Some(discr) => {\n+                        // This type actually has discriminants.\n+                        assert_eq!(discr.ty, discr_layout.ty);\n+                        Scalar::from_uint(discr.val, discr_layout.size)\n+                    }\n+                    None => {\n+                        // On a type without actual discriminants, variant is 0.\n+                        assert_eq!(index.as_u32(), 0);\n+                        Scalar::from_uint(index.as_u32(), discr_layout.size)\n+                    }\n+                };\n+                return Ok((discr, index));\n             }\n-            Variants::Multiple { discr: ref discr_layout, ref discr_kind, discr_index, .. } => {\n-                (discr_layout, discr_kind, discr_index)\n+            Variants::Multiple { ref discr, ref discr_kind, discr_index, .. } => {\n+                (discr, discr_kind, discr_index)\n             }\n         };\n \n-        // read raw discriminant value\n-        let discr_op = self.operand_field(rval, discr_index)?;\n-        let discr_val = self.read_immediate(discr_op)?;\n-        let raw_discr = discr_val.to_scalar_or_undef();\n-        trace!(\"discr value: {:?}\", raw_discr);\n-        // post-process\n-        Ok(match *discr_kind {\n+        // There are *three* layouts that come into play here:\n+        // - The discriminant has a type for typechecking. This is `discr_layout`, and is used for\n+        //   the `Scalar` we return.\n+        // - The tag (encoded discriminant) has layout `tag_layout`. This is always an integer type,\n+        //   and used to interpret the value we read from the tag field.\n+        //   For the return value, a cast to `discr_layout` is performed.\n+        // - The field storing the tag has a layout, which is very similar to `tag_layout` but\n+        //   may be a pointer. This is `tag_val.layout`; we just use it for sanity checks.\n+\n+        // Get layout for tag.\n+        let tag_layout = self.layout_of(tag_scalar_layout.value.to_int_ty(*self.tcx))?;\n+\n+        // Read tag and sanity-check `tag_layout`.\n+        let tag_val = self.read_immediate(self.operand_field(op, tag_index)?)?;\n+        assert_eq!(tag_layout.size, tag_val.layout.size);\n+        assert_eq!(tag_layout.abi.is_signed(), tag_val.layout.abi.is_signed());\n+        let tag_val = tag_val.to_scalar()?;\n+        trace!(\"tag value: {:?}\", tag_val);\n+\n+        // Figure out which discriminant and variant this corresponds to.\n+        Ok(match *tag_kind {\n             DiscriminantKind::Tag => {\n-                let bits_discr = raw_discr\n-                    .not_undef()\n-                    .and_then(|raw_discr| self.force_bits(raw_discr, discr_val.layout.size))\n-                    .map_err(|_| err_ub!(InvalidDiscriminant(raw_discr.erase_tag())))?;\n-                let real_discr = if discr_val.layout.abi.is_signed() {\n-                    // going from layout tag type to typeck discriminant type\n-                    // requires first sign extending with the discriminant layout\n-                    let sexted = sign_extend(bits_discr, discr_val.layout.size);\n-                    // and then zeroing with the typeck discriminant type\n-                    let discr_ty = rval\n-                        .layout\n-                        .ty\n-                        .ty_adt_def()\n-                        .expect(\"tagged layout corresponds to adt\")\n-                        .repr\n-                        .discr_type();\n-                    let size = Integer::from_attr(self, discr_ty).size();\n-                    truncate(sexted, size)\n-                } else {\n-                    bits_discr\n-                };\n-                // Make sure we catch invalid discriminants\n-                let index = match rval.layout.ty.kind {\n+                let tag_bits = self\n+                    .force_bits(tag_val, tag_layout.size)\n+                    .map_err(|_| err_ub!(InvalidDiscriminant(tag_val.erase_tag())))?;\n+                // Cast bits from tag layout to discriminant layout.\n+                let discr_val_cast = self.cast_from_scalar(tag_bits, tag_layout, discr_layout.ty);\n+                let discr_bits = discr_val_cast.assert_bits(discr_layout.size);\n+                // Convert discriminant to variant index, and catch invalid discriminants.\n+                let index = match op.layout.ty.kind {\n                     ty::Adt(adt, _) => {\n-                        adt.discriminants(self.tcx.tcx).find(|(_, var)| var.val == real_discr)\n+                        adt.discriminants(self.tcx.tcx).find(|(_, var)| var.val == discr_bits)\n                     }\n                     ty::Generator(def_id, substs, _) => {\n                         let substs = substs.as_generator();\n                         substs\n                             .discriminants(def_id, self.tcx.tcx)\n-                            .find(|(_, var)| var.val == real_discr)\n+                            .find(|(_, var)| var.val == discr_bits)\n                     }\n                     _ => bug!(\"tagged layout for non-adt non-generator\"),\n                 }\n-                .ok_or_else(|| err_ub!(InvalidDiscriminant(raw_discr.erase_tag())))?;\n-                (real_discr, index.0)\n+                .ok_or_else(|| err_ub!(InvalidDiscriminant(tag_val.erase_tag())))?;\n+                // Return the cast value, and the index.\n+                (discr_val_cast, index.0)\n             }\n             DiscriminantKind::Niche { dataful_variant, ref niche_variants, niche_start } => {\n+                // Compute the variant this niche value/\"tag\" corresponds to. With niche layout,\n+                // discriminant (encoded in niche/tag) and variant index are the same.\n                 let variants_start = niche_variants.start().as_u32();\n                 let variants_end = niche_variants.end().as_u32();\n-                let raw_discr = raw_discr\n-                    .not_undef()\n-                    .map_err(|_| err_ub!(InvalidDiscriminant(ScalarMaybeUninit::Uninit)))?;\n-                match raw_discr.to_bits_or_ptr(discr_val.layout.size, self) {\n+                let variant = match tag_val.to_bits_or_ptr(tag_layout.size, self) {\n                     Err(ptr) => {\n                         // The niche must be just 0 (which an inbounds pointer value never is)\n                         let ptr_valid = niche_start == 0\n                             && variants_start == variants_end\n                             && !self.memory.ptr_may_be_null(ptr);\n                         if !ptr_valid {\n-                            throw_ub!(InvalidDiscriminant(raw_discr.erase_tag().into()))\n+                            throw_ub!(InvalidDiscriminant(tag_val.erase_tag()))\n                         }\n-                        (u128::from(dataful_variant.as_u32()), dataful_variant)\n+                        dataful_variant\n                     }\n-                    Ok(raw_discr) => {\n+                    Ok(tag_bits) => {\n                         // We need to use machine arithmetic to get the relative variant idx:\n-                        // variant_index_relative = discr_val - niche_start_val\n-                        let discr_layout =\n-                            self.layout_of(discr_layout.value.to_int_ty(*self.tcx))?;\n-                        let discr_val = ImmTy::from_uint(raw_discr, discr_layout);\n-                        let niche_start_val = ImmTy::from_uint(niche_start, discr_layout);\n+                        // variant_index_relative = tag_val - niche_start_val\n+                        let tag_val = ImmTy::from_uint(tag_bits, tag_layout);\n+                        let niche_start_val = ImmTy::from_uint(niche_start, tag_layout);\n                         let variant_index_relative_val =\n-                            self.binary_op(mir::BinOp::Sub, discr_val, niche_start_val)?;\n+                            self.binary_op(mir::BinOp::Sub, tag_val, niche_start_val)?;\n                         let variant_index_relative = variant_index_relative_val\n                             .to_scalar()?\n-                            .assert_bits(discr_val.layout.size);\n+                            .assert_bits(tag_val.layout.size);\n                         // Check if this is in the range that indicates an actual discriminant.\n                         if variant_index_relative <= u128::from(variants_end - variants_start) {\n                             let variant_index_relative = u32::try_from(variant_index_relative)\n@@ -676,20 +699,24 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             let variant_index = variants_start\n                                 .checked_add(variant_index_relative)\n                                 .expect(\"overflow computing absolute variant idx\");\n-                            let variants_len = rval\n+                            let variants_len = op\n                                 .layout\n                                 .ty\n                                 .ty_adt_def()\n                                 .expect(\"tagged layout for non adt\")\n                                 .variants\n                                 .len();\n                             assert!(usize::try_from(variant_index).unwrap() < variants_len);\n-                            (u128::from(variant_index), VariantIdx::from_u32(variant_index))\n+                            VariantIdx::from_u32(variant_index)\n                         } else {\n-                            (u128::from(dataful_variant.as_u32()), dataful_variant)\n+                            dataful_variant\n                         }\n                     }\n-                }\n+                };\n+                // Compute the size of the scalar we need to return.\n+                // No need to cast, because the variant index directly serves as discriminant and is\n+                // encoded in the tag.\n+                (Scalar::from_uint(variant.as_u32(), discr_layout.size), variant)\n             }\n         })\n     }"}, {"sha": "3f0800b12b5498a56e2e10fb1d129051d247a5ec", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -638,6 +638,14 @@ where\n         }\n \n         self.dump_place(place_ty.place);\n+        // Sanity-check the type we ended up with.\n+        debug_assert!(mir_assign_valid_types(\n+            *self.tcx,\n+            self.layout_of(self.subst_from_current_frame_and_normalize_erasing_regions(\n+                place.ty(&self.frame().body.local_decls, *self.tcx).ty\n+            ))?,\n+            place_ty.layout,\n+        ));\n         Ok(place_ty)\n     }\n "}, {"sha": "bd4df788057e248939d2fa49d1425e7c149aa722", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -262,8 +262,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Discriminant(place) => {\n                 let op = self.eval_place_to_op(place, None)?;\n                 let discr_val = self.read_discriminant(op)?.0;\n-                let size = dest.layout.size;\n-                self.write_scalar(Scalar::from_uint(discr_val, size), dest)?;\n+                self.write_scalar(discr_val, dest)?;\n             }\n         }\n "}, {"sha": "7164c6788086398bf2535dc58807afc714b48af6", "filename": "src/librustc_parse/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_parse%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_parse%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2FCargo.toml?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -12,7 +12,6 @@ doctest = false\n [dependencies]\n bitflags = \"1.0\"\n log = \"0.4\"\n-smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n rustc_ast_pretty = { path = \"../librustc_ast_pretty\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_feature = { path = \"../librustc_feature\" }"}, {"sha": "be86b4b7c7720ed9e7d4b716a70d4ca69e4a10f1", "filename": "src/librustc_parse/lib.rs", "status": "modified", "additions": 4, "deletions": 208, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_parse%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_parse%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flib.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -7,18 +7,14 @@\n #![feature(or_patterns)]\n \n use rustc_ast::ast;\n-use rustc_ast::token::{self, DelimToken, Nonterminal, Token, TokenKind};\n-use rustc_ast::tokenstream::{self, IsJoint, TokenStream, TokenTree};\n+use rustc_ast::token::{self, Nonterminal};\n+use rustc_ast::tokenstream::{self, TokenStream, TokenTree};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Diagnostic, FatalError, Level, PResult};\n use rustc_session::parse::ParseSess;\n-use rustc_span::symbol::kw;\n-use rustc_span::{FileName, SourceFile, Span, DUMMY_SP};\n+use rustc_span::{FileName, SourceFile, Span};\n \n-use smallvec::SmallVec;\n-\n-use std::mem;\n use std::path::Path;\n use std::str;\n \n@@ -310,7 +306,7 @@ pub fn nt_to_tokenstream(nt: &Nonterminal, sess: &ParseSess, span: Span) -> Toke\n     // modifications, including adding/removing typically non-semantic\n     // tokens such as extra braces and commas, don't happen.\n     if let Some(tokens) = tokens {\n-        if tokenstream_probably_equal_for_proc_macro(&tokens, &tokens_for_real, sess) {\n+        if tokens.probably_equal_for_proc_macro(&tokens_for_real) {\n             return tokens;\n         }\n         info!(\n@@ -385,203 +381,3 @@ fn prepend_attrs(\n     builder.push(tokens.clone());\n     Some(builder.build())\n }\n-\n-// See comments in `Nonterminal::to_tokenstream` for why we care about\n-// *probably* equal here rather than actual equality\n-//\n-// This is otherwise the same as `eq_unspanned`, only recursing with a\n-// different method.\n-pub fn tokenstream_probably_equal_for_proc_macro(\n-    first: &TokenStream,\n-    other: &TokenStream,\n-    sess: &ParseSess,\n-) -> bool {\n-    // When checking for `probably_eq`, we ignore certain tokens that aren't\n-    // preserved in the AST. Because they are not preserved, the pretty\n-    // printer arbitrarily adds or removes them when printing as token\n-    // streams, making a comparison between a token stream generated from an\n-    // AST and a token stream which was parsed into an AST more reliable.\n-    fn semantic_tree(tree: &TokenTree) -> bool {\n-        if let TokenTree::Token(token) = tree {\n-            if let\n-                // The pretty printer tends to add trailing commas to\n-                // everything, and in particular, after struct fields.\n-                | token::Comma\n-                // The pretty printer emits `NoDelim` as whitespace.\n-                | token::OpenDelim(DelimToken::NoDelim)\n-                | token::CloseDelim(DelimToken::NoDelim)\n-                // The pretty printer collapses many semicolons into one.\n-                | token::Semi\n-                // The pretty printer collapses whitespace arbitrarily and can\n-                // introduce whitespace from `NoDelim`.\n-                | token::Whitespace\n-                // The pretty printer can turn `$crate` into `::crate_name`\n-                | token::ModSep = token.kind {\n-                return false;\n-            }\n-        }\n-        true\n-    }\n-\n-    // When comparing two `TokenStream`s, we ignore the `IsJoint` information.\n-    //\n-    // However, `rustc_parse::lexer::tokentrees::TokenStreamBuilder` will\n-    // use `Token.glue` on adjacent tokens with the proper `IsJoint`.\n-    // Since we are ignoreing `IsJoint`, a 'glued' token (e.g. `BinOp(Shr)`)\n-    // and its 'split'/'unglued' compoenents (e.g. `Gt, Gt`) are equivalent\n-    // when determining if two `TokenStream`s are 'probably equal'.\n-    //\n-    // Therefore, we use `break_two_token_op` to convert all tokens\n-    // to the 'unglued' form (if it exists). This ensures that two\n-    // `TokenStream`s which differ only in how their tokens are glued\n-    // will be considered 'probably equal', which allows us to keep spans.\n-    //\n-    // This is important when the original `TokenStream` contained\n-    // extra spaces (e.g. `f :: < Vec < _ > > ( ) ;'). These extra spaces\n-    // will be omitted when we pretty-print, which can cause the original\n-    // and reparsed `TokenStream`s to differ in the assignment of `IsJoint`,\n-    // leading to some tokens being 'glued' together in one stream but not\n-    // the other. See #68489 for more details.\n-    fn break_tokens(tree: TokenTree) -> impl Iterator<Item = TokenTree> {\n-        // In almost all cases, we should have either zero or one levels\n-        // of 'unglueing'. However, in some unusual cases, we may need\n-        // to iterate breaking tokens mutliple times. For example:\n-        // '[BinOpEq(Shr)] => [Gt, Ge] -> [Gt, Gt, Eq]'\n-        let mut token_trees: SmallVec<[_; 2]>;\n-        if let TokenTree::Token(token) = &tree {\n-            let mut out = SmallVec::<[_; 2]>::new();\n-            out.push(token.clone());\n-            // Iterate to fixpoint:\n-            // * We start off with 'out' containing our initial token, and `temp` empty\n-            // * If we are able to break any tokens in `out`, then `out` will have\n-            //   at least one more element than 'temp', so we will try to break tokens\n-            //   again.\n-            // * If we cannot break any tokens in 'out', we are done\n-            loop {\n-                let mut temp = SmallVec::<[_; 2]>::new();\n-                let mut changed = false;\n-\n-                for token in out.into_iter() {\n-                    if let Some((first, second)) = token.kind.break_two_token_op() {\n-                        temp.push(Token::new(first, DUMMY_SP));\n-                        temp.push(Token::new(second, DUMMY_SP));\n-                        changed = true;\n-                    } else {\n-                        temp.push(token);\n-                    }\n-                }\n-                out = temp;\n-                if !changed {\n-                    break;\n-                }\n-            }\n-            token_trees = out.into_iter().map(|t| TokenTree::Token(t)).collect();\n-            if token_trees.len() != 1 {\n-                debug!(\"break_tokens: broke {:?} to {:?}\", tree, token_trees);\n-            }\n-        } else {\n-            token_trees = SmallVec::new();\n-            token_trees.push(tree);\n-        }\n-        token_trees.into_iter()\n-    }\n-\n-    let expand_nt = |tree: TokenTree| {\n-        if let TokenTree::Token(Token { kind: TokenKind::Interpolated(nt), span }) = &tree {\n-            nt_to_tokenstream(nt, sess, *span).into_trees()\n-        } else {\n-            TokenStream::new(vec![(tree, IsJoint::NonJoint)]).into_trees()\n-        }\n-    };\n-\n-    // Break tokens after we expand any nonterminals, so that we break tokens\n-    // that are produced as a result of nonterminal expansion.\n-    let mut t1 = first.trees().filter(semantic_tree).flat_map(expand_nt).flat_map(break_tokens);\n-    let mut t2 = other.trees().filter(semantic_tree).flat_map(expand_nt).flat_map(break_tokens);\n-    for (t1, t2) in t1.by_ref().zip(t2.by_ref()) {\n-        if !tokentree_probably_equal_for_proc_macro(&t1, &t2, sess) {\n-            return false;\n-        }\n-    }\n-    t1.next().is_none() && t2.next().is_none()\n-}\n-\n-// See comments in `Nonterminal::to_tokenstream` for why we care about\n-// *probably* equal here rather than actual equality\n-crate fn token_probably_equal_for_proc_macro(first: &Token, other: &Token) -> bool {\n-    use TokenKind::*;\n-\n-    if mem::discriminant(&first.kind) != mem::discriminant(&other.kind) {\n-        return false;\n-    }\n-    match (&first.kind, &other.kind) {\n-        (&Eq, &Eq)\n-        | (&Lt, &Lt)\n-        | (&Le, &Le)\n-        | (&EqEq, &EqEq)\n-        | (&Ne, &Ne)\n-        | (&Ge, &Ge)\n-        | (&Gt, &Gt)\n-        | (&AndAnd, &AndAnd)\n-        | (&OrOr, &OrOr)\n-        | (&Not, &Not)\n-        | (&Tilde, &Tilde)\n-        | (&At, &At)\n-        | (&Dot, &Dot)\n-        | (&DotDot, &DotDot)\n-        | (&DotDotDot, &DotDotDot)\n-        | (&DotDotEq, &DotDotEq)\n-        | (&Comma, &Comma)\n-        | (&Semi, &Semi)\n-        | (&Colon, &Colon)\n-        | (&ModSep, &ModSep)\n-        | (&RArrow, &RArrow)\n-        | (&LArrow, &LArrow)\n-        | (&FatArrow, &FatArrow)\n-        | (&Pound, &Pound)\n-        | (&Dollar, &Dollar)\n-        | (&Question, &Question)\n-        | (&Whitespace, &Whitespace)\n-        | (&Comment, &Comment)\n-        | (&Eof, &Eof) => true,\n-\n-        (&BinOp(a), &BinOp(b)) | (&BinOpEq(a), &BinOpEq(b)) => a == b,\n-\n-        (&OpenDelim(a), &OpenDelim(b)) | (&CloseDelim(a), &CloseDelim(b)) => a == b,\n-\n-        (&DocComment(a), &DocComment(b)) | (&Shebang(a), &Shebang(b)) => a == b,\n-\n-        (&Literal(a), &Literal(b)) => a == b,\n-\n-        (&Lifetime(a), &Lifetime(b)) => a == b,\n-        (&Ident(a, b), &Ident(c, d)) => {\n-            b == d && (a == c || a == kw::DollarCrate || c == kw::DollarCrate)\n-        }\n-\n-        // Expanded by `tokenstream_probably_equal_for_proc_macro`\n-        (&Interpolated(_), &Interpolated(_)) => unreachable!(),\n-\n-        _ => panic!(\"forgot to add a token?\"),\n-    }\n-}\n-\n-// See comments in `Nonterminal::to_tokenstream` for why we care about\n-// *probably* equal here rather than actual equality\n-//\n-// This is otherwise the same as `eq_unspanned`, only recursing with a\n-// different method.\n-pub fn tokentree_probably_equal_for_proc_macro(\n-    first: &TokenTree,\n-    other: &TokenTree,\n-    sess: &ParseSess,\n-) -> bool {\n-    match (first, other) {\n-        (TokenTree::Token(token), TokenTree::Token(token2)) => {\n-            token_probably_equal_for_proc_macro(token, token2)\n-        }\n-        (TokenTree::Delimited(_, delim, tts), TokenTree::Delimited(_, delim2, tts2)) => {\n-            delim == delim2 && tokenstream_probably_equal_for_proc_macro(&tts, &tts2, sess)\n-        }\n-        _ => false,\n-    }\n-}"}, {"sha": "9ee3d989bf3f1e1275290c48cd7efde613672800", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -25,7 +25,7 @@ use rustc_errors::{struct_span_err, Applicability};\n use rustc_expand::base::SyntaxExtension;\n use rustc_expand::expand::AstFragment;\n use rustc_hir::def::{self, *};\n-use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX};\n+use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_INDEX};\n use rustc_metadata::creader::LoadedMacro;\n use rustc_middle::bug;\n use rustc_middle::hir::exports::Export;\n@@ -1150,31 +1150,37 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     // Mark the given macro as unused unless its name starts with `_`.\n     // Macro uses will remove items from this set, and the remaining\n     // items will be reported as `unused_macros`.\n-    fn insert_unused_macro(&mut self, ident: Ident, node_id: NodeId, span: Span) {\n+    fn insert_unused_macro(\n+        &mut self,\n+        ident: Ident,\n+        def_id: LocalDefId,\n+        node_id: NodeId,\n+        span: Span,\n+    ) {\n         if !ident.as_str().starts_with('_') {\n-            self.r.unused_macros.insert(node_id, span);\n+            self.r.unused_macros.insert(def_id, (node_id, span));\n         }\n     }\n \n     fn define_macro(&mut self, item: &ast::Item) -> MacroRulesScope<'a> {\n         let parent_scope = self.parent_scope;\n         let expansion = parent_scope.expansion;\n+        let def_id = self.r.definitions.local_def_id(item.id);\n         let (ext, ident, span, macro_rules) = match &item.kind {\n             ItemKind::MacroDef(def) => {\n                 let ext = Lrc::new(self.r.compile_macro(item, self.r.session.edition()));\n                 (ext, item.ident, item.span, def.macro_rules)\n             }\n             ItemKind::Fn(..) => match Self::proc_macro_stub(item) {\n                 Some((macro_kind, ident, span)) => {\n-                    self.r.proc_macro_stubs.insert(item.id);\n+                    self.r.proc_macro_stubs.insert(def_id);\n                     (self.r.dummy_ext(macro_kind), ident, span, false)\n                 }\n                 None => return parent_scope.macro_rules,\n             },\n             _ => unreachable!(),\n         };\n \n-        let def_id = self.r.definitions.local_def_id(item.id);\n         let res = Res::Def(DefKind::Macro(ext.macro_kind()), def_id.to_def_id());\n         self.r.macro_map.insert(def_id.to_def_id(), ext);\n         self.r.local_macro_def_scopes.insert(def_id, parent_scope.module);\n@@ -1196,7 +1202,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 self.r.define(module, ident, MacroNS, (res, vis, span, expansion, IsMacroExport));\n             } else {\n                 self.r.check_reserved_macro_name(ident, res);\n-                self.insert_unused_macro(ident, item.id, span);\n+                self.insert_unused_macro(ident, def_id, item.id, span);\n             }\n             MacroRulesScope::Binding(self.r.arenas.alloc_macro_rules_binding(MacroRulesBinding {\n                 parent_macro_rules_scope: parent_scope.macro_rules,\n@@ -1214,7 +1220,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 _ => self.resolve_visibility(&item.vis),\n             };\n             if vis != ty::Visibility::Public {\n-                self.insert_unused_macro(ident, item.id, span);\n+                self.insert_unused_macro(ident, def_id, item.id, span);\n             }\n             self.r.define(module, ident, MacroNS, (res, vis, span, expansion));\n             self.parent_scope.macro_rules"}, {"sha": "3b49b3b6ff7d274274594292bfb568f56b99785f", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -1621,11 +1621,10 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         let report_errors = |this: &mut Self, res: Option<Res>| {\n             let (err, candidates) = this.smart_resolve_report_errors(path, span, source, res);\n             let def_id = this.parent_scope.module.normal_ancestor_id;\n-            let node_id = this.r.definitions.as_local_node_id(def_id).unwrap();\n             let better = res.is_some();\n             let suggestion =\n                 if res.is_none() { this.report_missing_type_error(path) } else { None };\n-            this.r.use_injections.push(UseError { err, candidates, node_id, better, suggestion });\n+            this.r.use_injections.push(UseError { err, candidates, def_id, better, suggestion });\n             PartialRes::new(Res::Err)\n         };\n "}, {"sha": "b50f9fe8e907dce0081dfcf549303471fa1670e1", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 25, "deletions": 15, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -23,7 +23,7 @@ use rustc_ast::ast::{self, FloatTy, IntTy, NodeId, UintTy};\n use rustc_ast::ast::{Crate, CRATE_NODE_ID};\n use rustc_ast::ast::{ItemKind, Path};\n use rustc_ast::attr;\n-use rustc_ast::node_id::{NodeMap, NodeSet};\n+use rustc_ast::node_id::NodeMap;\n use rustc_ast::unwrap_or;\n use rustc_ast::visit::{self, Visitor};\n use rustc_ast_pretty::pprust;\n@@ -253,21 +253,31 @@ impl<'a> From<&'a ast::PathSegment> for Segment {\n     }\n }\n \n-struct UsePlacementFinder {\n-    target_module: NodeId,\n+struct UsePlacementFinder<'d> {\n+    definitions: &'d Definitions,\n+    target_module: LocalDefId,\n     span: Option<Span>,\n     found_use: bool,\n }\n \n-impl UsePlacementFinder {\n-    fn check(krate: &Crate, target_module: NodeId) -> (Option<Span>, bool) {\n-        let mut finder = UsePlacementFinder { target_module, span: None, found_use: false };\n-        visit::walk_crate(&mut finder, krate);\n-        (finder.span, finder.found_use)\n+impl<'d> UsePlacementFinder<'d> {\n+    fn check(\n+        definitions: &'d Definitions,\n+        krate: &Crate,\n+        target_module: DefId,\n+    ) -> (Option<Span>, bool) {\n+        if let Some(target_module) = target_module.as_local() {\n+            let mut finder =\n+                UsePlacementFinder { definitions, target_module, span: None, found_use: false };\n+            visit::walk_crate(&mut finder, krate);\n+            (finder.span, finder.found_use)\n+        } else {\n+            (None, false)\n+        }\n     }\n }\n \n-impl<'tcx> Visitor<'tcx> for UsePlacementFinder {\n+impl<'tcx, 'd> Visitor<'tcx> for UsePlacementFinder<'d> {\n     fn visit_mod(\n         &mut self,\n         module: &'tcx ast::Mod,\n@@ -278,7 +288,7 @@ impl<'tcx> Visitor<'tcx> for UsePlacementFinder {\n         if self.span.is_some() {\n             return;\n         }\n-        if node_id != self.target_module {\n+        if self.definitions.local_def_id(node_id) != self.target_module {\n             visit::walk_mod(self, module);\n             return;\n         }\n@@ -611,7 +621,7 @@ struct UseError<'a> {\n     /// Attach `use` statements for these candidates.\n     candidates: Vec<ImportSuggestion>,\n     /// The `NodeId` of the module to place the use-statements in.\n-    node_id: NodeId,\n+    def_id: DefId,\n     /// Whether the diagnostic should state that it's \"better\".\n     better: bool,\n     /// Extra free form suggestion. Currently used to suggest new type parameter.\n@@ -926,8 +936,8 @@ pub struct Resolver<'a> {\n     non_macro_attrs: [Lrc<SyntaxExtension>; 2],\n     local_macro_def_scopes: FxHashMap<LocalDefId, Module<'a>>,\n     ast_transform_scopes: FxHashMap<ExpnId, Module<'a>>,\n-    unused_macros: NodeMap<Span>,\n-    proc_macro_stubs: NodeSet,\n+    unused_macros: FxHashMap<LocalDefId, (NodeId, Span)>,\n+    proc_macro_stubs: FxHashSet<LocalDefId>,\n     /// Traces collected during macro resolution and validated when it's complete.\n     single_segment_macro_resolutions:\n         Vec<(Ident, MacroKind, ParentScope<'a>, Option<&'a NameBinding<'a>>)>,\n@@ -2567,10 +2577,10 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn report_with_use_injections(&mut self, krate: &Crate) {\n-        for UseError { mut err, candidates, node_id, better, suggestion } in\n+        for UseError { mut err, candidates, def_id, better, suggestion } in\n             self.use_injections.drain(..)\n         {\n-            let (span, found_use) = UsePlacementFinder::check(krate, node_id);\n+            let (span, found_use) = UsePlacementFinder::check(&self.definitions, krate, def_id);\n             if !candidates.is_empty() {\n                 diagnostics::show_candidates(&mut err, span, &candidates, better, found_use);\n             } else if let Some((span, msg, sugg, appl)) = suggestion {"}, {"sha": "394d8dc4e1135ded2ba2984c11b9237823302792", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -333,7 +333,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n     }\n \n     fn check_unused_macros(&mut self) {\n-        for (&node_id, &span) in self.unused_macros.iter() {\n+        for (_, &(node_id, span)) in self.unused_macros.iter() {\n             self.lint_buffer.buffer_lint(UNUSED_MACROS, node_id, span, \"unused macro definition\");\n         }\n     }\n@@ -416,9 +416,9 @@ impl<'a> Resolver<'a> {\n \n         match res {\n             Res::Def(DefKind::Macro(_), def_id) => {\n-                if let Some(node_id) = self.definitions.as_local_node_id(def_id) {\n-                    self.unused_macros.remove(&node_id);\n-                    if self.proc_macro_stubs.contains(&node_id) {\n+                if let Some(def_id) = def_id.as_local() {\n+                    self.unused_macros.remove(&def_id);\n+                    if self.proc_macro_stubs.contains(&def_id) {\n                         self.session.span_err(\n                             path.span,\n                             \"can't use a procedural macro from the same crate that defines it\","}, {"sha": "efd4af650aeb19db112222d03b8bc76d96d2f082", "filename": "src/librustc_trait_selection/traits/select.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -1040,17 +1040,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         &mut self,\n         stack: &TraitObligationStack<'o, 'tcx>,\n     ) -> SelectionResult<'tcx, SelectionCandidate<'tcx>> {\n-        if stack.obligation.predicate.references_error() {\n-            // If we encounter a `Error`, we generally prefer the\n-            // most \"optimistic\" result in response -- that is, the\n-            // one least likely to report downstream errors. But\n-            // because this routine is shared by coherence and by\n-            // trait selection, there isn't an obvious \"right\" choice\n-            // here in that respect, so we opt to just return\n-            // ambiguity and let the upstream clients sort it out.\n-            return Ok(None);\n-        }\n-\n         if let Some(conflict) = self.is_knowable(stack) {\n             debug!(\"coherence stage: not knowable\");\n             if self.intercrate_ambiguity_causes.is_some() {"}, {"sha": "d89993e354768a652da53b9449b8147c8fc9f24a", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -121,9 +121,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let tcx = self.tcx;\n         match BinOpCategory::from(op) {\n             BinOpCategory::Shortcircuit => {\n-                self.demand_suptype(*lhs_span, tcx.mk_bool(), lhs_ty);\n-                self.demand_suptype(*rhs_span, tcx.mk_bool(), rhs_ty);\n-                tcx.mk_bool()\n+                self.demand_suptype(*lhs_span, tcx.types.bool, lhs_ty);\n+                self.demand_suptype(*rhs_span, tcx.types.bool, rhs_ty);\n+                tcx.types.bool\n             }\n \n             BinOpCategory::Shift => {\n@@ -140,7 +140,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             BinOpCategory::Comparison => {\n                 // both LHS and RHS and result will have the same type\n                 self.demand_suptype(*rhs_span, lhs_ty, rhs_ty);\n-                tcx.mk_bool()\n+                tcx.types.bool\n             }\n         }\n     }"}, {"sha": "5ba5eff44076b54318043a3547935cffb8e248f8", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -2426,6 +2426,24 @@ where\n     fn extend<T: IntoIterator<Item = (K, V)>>(&mut self, iter: T) {\n         self.base.extend(iter)\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, (k, v): (K, V)) {\n+        self.base.insert(k, v);\n+    }\n+\n+    #[inline]\n+    fn extend_reserve(&mut self, additional: usize) {\n+        // self.base.extend_reserve(additional);\n+        // FIXME: hashbrown should implement this method.\n+        // But until then, use the same reservation logic:\n+\n+        // Reserve the entire hint lower bound if the map is empty.\n+        // Otherwise reserve half the hint (rounded up), so the map\n+        // will only resize twice in the worst case.\n+        let reserve = if self.is_empty() { additional } else { (additional + 1) / 2 };\n+        self.base.reserve(reserve);\n+    }\n }\n \n #[stable(feature = \"hash_extend_copy\", since = \"1.4.0\")]\n@@ -2439,6 +2457,16 @@ where\n     fn extend<T: IntoIterator<Item = (&'a K, &'a V)>>(&mut self, iter: T) {\n         self.base.extend(iter)\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, (&k, &v): (&'a K, &'a V)) {\n+        self.base.insert(k, v);\n+    }\n+\n+    #[inline]\n+    fn extend_reserve(&mut self, additional: usize) {\n+        Extend::<(K, V)>::extend_reserve(self, additional)\n+    }\n }\n \n /// `RandomState` is the default state for [`HashMap`] types."}, {"sha": "cb2f829803b85e8b1d748a308300d3f72339cde3", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -970,6 +970,16 @@ where\n     fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n         self.map.extend(iter.into_iter().map(|k| (k, ())));\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, item: T) {\n+        self.map.insert(item, ());\n+    }\n+\n+    #[inline]\n+    fn extend_reserve(&mut self, additional: usize) {\n+        self.map.extend_reserve(additional);\n+    }\n }\n \n #[stable(feature = \"hash_extend_copy\", since = \"1.4.0\")]\n@@ -982,6 +992,16 @@ where\n     fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n         self.extend(iter.into_iter().cloned());\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, &item: &'a T) {\n+        self.map.insert(item, ());\n+    }\n+\n+    #[inline]\n+    fn extend_reserve(&mut self, additional: usize) {\n+        Extend::<T>::extend_reserve(self, additional)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "9ddaa100c0e9df520b0a2dd3d3e88c984efe7652", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -263,6 +263,7 @@\n #![feature(duration_constants)]\n #![feature(exact_size_is_empty)]\n #![feature(exhaustive_patterns)]\n+#![feature(extend_one)]\n #![feature(external_doc)]\n #![feature(fn_traits)]\n #![feature(format_args_nl)]"}, {"sha": "8ff7508ba6457b5042ca2e2a5f498cca2b56748c", "filename": "src/libstd/path.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -1534,6 +1534,11 @@ impl<P: AsRef<Path>> iter::Extend<P> for PathBuf {\n     fn extend<I: IntoIterator<Item = P>>(&mut self, iter: I) {\n         iter.into_iter().for_each(move |p| self.push(p.as_ref()));\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, p: P) {\n+        self.push(p.as_ref());\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "a5ba3daba3e87e89787c6096c3f2feac97a8dd5a", "filename": "src/libstd/sys_common/wtf8.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibstd%2Fsys_common%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Flibstd%2Fsys_common%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fwtf8.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -386,6 +386,17 @@ impl Extend<CodePoint> for Wtf8Buf {\n         self.bytes.reserve(low);\n         iterator.for_each(move |code_point| self.push(code_point));\n     }\n+\n+    #[inline]\n+    fn extend_one(&mut self, code_point: CodePoint) {\n+        self.push(code_point);\n+    }\n+\n+    #[inline]\n+    fn extend_reserve(&mut self, additional: usize) {\n+        // Lower bound of one byte per code point (ASCII only)\n+        self.bytes.reserve(additional);\n+    }\n }\n \n /// A borrowed slice of well-formed WTF-8 data."}, {"sha": "f313798de215b12632f1df7531bc1d6c7267aa40", "filename": "src/test/run-make-fulldeps/long-linker-command-lines/foo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Ftest%2Frun-make-fulldeps%2Flong-linker-command-lines%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Ftest%2Frun-make-fulldeps%2Flong-linker-command-lines%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Flong-linker-command-lines%2Ffoo.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -90,7 +90,7 @@ fn main() {\n         }\n \n         let linker_args = read_linker_args(&ok);\n-        for mut arg in linker_args.split('S') {\n+        for arg in linker_args.split('S') {\n             expected_libs.remove(arg);\n         }\n "}, {"sha": "00e098d43e073917e8a2a4e1062cf0ffb98d1050", "filename": "src/test/ui/async-await/issue-72590-type-error-sized.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Ftest%2Fui%2Fasync-await%2Fissue-72590-type-error-sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Ftest%2Fui%2Fasync-await%2Fissue-72590-type-error-sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-72590-type-error-sized.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -0,0 +1,22 @@\n+// Regression test for issue #72590\n+// Tests that we don't emit a spurious \"size cannot be statically determined\" error\n+// edition:2018\n+\n+struct Foo {\n+    foo: Nonexistent, //~ ERROR cannot find\n+    other: str\n+}\n+\n+struct Bar {\n+    test: Missing //~ ERROR cannot find\n+}\n+\n+impl Foo {\n+    async fn frob(self) {} //~ ERROR the size\n+}\n+\n+impl Bar {\n+    async fn myfn(self) {}\n+}\n+\n+fn main() {}"}, {"sha": "603895b598c168384671140c7527625290194e66", "filename": "src/test/ui/async-await/issue-72590-type-error-sized.stderr", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Ftest%2Fui%2Fasync-await%2Fissue-72590-type-error-sized.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Ftest%2Fui%2Fasync-await%2Fissue-72590-type-error-sized.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-72590-type-error-sized.stderr?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -0,0 +1,28 @@\n+error[E0412]: cannot find type `Nonexistent` in this scope\n+  --> $DIR/issue-72590-type-error-sized.rs:6:10\n+   |\n+LL |     foo: Nonexistent,\n+   |          ^^^^^^^^^^^ not found in this scope\n+\n+error[E0412]: cannot find type `Missing` in this scope\n+  --> $DIR/issue-72590-type-error-sized.rs:11:11\n+   |\n+LL |     test: Missing\n+   |           ^^^^^^^ not found in this scope\n+\n+error[E0277]: the size for values of type `str` cannot be known at compilation time\n+  --> $DIR/issue-72590-type-error-sized.rs:15:19\n+   |\n+LL |     async fn frob(self) {}\n+   |                   ^^^^ doesn't have a size known at compile-time\n+   |\n+   = help: within `Foo`, the trait `std::marker::Sized` is not implemented for `str`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+   = note: required because it appears within the type `Foo`\n+   = note: all local variables must have a statically known size\n+   = help: unsized locals are gated as an unstable feature\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors have detailed explanations: E0277, E0412.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "efbb0bfb1508f4c8c8355490bb28fe43e1fb7ed1", "filename": "src/test/ui/issues/issue-72574-1.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Ftest%2Fui%2Fissues%2Fissue-72574-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Ftest%2Fui%2Fissues%2Fissue-72574-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-72574-1.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -0,0 +1,8 @@\n+fn main() {\n+    let x = (1, 2, 3);\n+    match x {\n+        (_a, _x @ ..) => {}\n+        _ => {}\n+    }\n+}\n+//~^^^^ ERROR `_x @` is not allowed in a tuple"}, {"sha": "329f7d008d498e57a5e366f28fa6fb825f9b0c05", "filename": "src/test/ui/issues/issue-72574-1.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Ftest%2Fui%2Fissues%2Fissue-72574-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Ftest%2Fui%2Fissues%2Fissue-72574-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-72574-1.stderr?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -0,0 +1,14 @@\n+error: `_x @` is not allowed in a tuple\n+  --> $DIR/issue-72574-1.rs:4:14\n+   |\n+LL |         (_a, _x @ ..) => {}\n+   |              ^^^^^^^ this is only allowed in slice patterns\n+   |\n+   = help: remove this and bind each tuple field independently\n+help: if you don't need to use the contents of _x, discard the tuple's remaining fields\n+   |\n+LL |         (_a, ..) => {}\n+   |              ^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "0c8f6fcc5088909d3abaac72068f942d23597ef9", "filename": "src/test/ui/issues/issue-72574-2.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Ftest%2Fui%2Fissues%2Fissue-72574-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Ftest%2Fui%2Fissues%2Fissue-72574-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-72574-2.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -0,0 +1,10 @@\n+struct Binder(i32, i32, i32);\n+\n+fn main() {\n+    let x = Binder(1, 2, 3);\n+    match x {\n+        Binder(_a, _x @ ..) => {}\n+        _ => {}\n+    }\n+}\n+//~^^^^ ERROR `_x @` is not allowed in a tuple struct"}, {"sha": "6faa57bcca6b191b526b40196833b669c44d4930", "filename": "src/test/ui/issues/issue-72574-2.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Ftest%2Fui%2Fissues%2Fissue-72574-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Ftest%2Fui%2Fissues%2Fissue-72574-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-72574-2.stderr?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -0,0 +1,14 @@\n+error: `_x @` is not allowed in a tuple struct\n+  --> $DIR/issue-72574-2.rs:6:20\n+   |\n+LL |         Binder(_a, _x @ ..) => {}\n+   |                    ^^^^^^^ this is only allowed in slice patterns\n+   |\n+   = help: remove this and bind each tuple field independently\n+help: if you don't need to use the contents of _x, discard the tuple's remaining fields\n+   |\n+LL |         Binder(_a, ..) => {}\n+   |                    ^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "37436567d70f00996fd5201e0c277e823b37bda4", "filename": "src/test/ui/proc-macro/macro-rules-capture.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-rules-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-rules-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-rules-capture.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -1,18 +0,0 @@\n-// aux-build: test-macros.rs\n-\n-extern crate test_macros;\n-use test_macros::recollect_attr;\n-\n-macro_rules! reemit {\n-    ($name:ident => $($token:expr)*) => {\n-\n-        #[recollect_attr]\n-        pub fn $name() {\n-            $($token)*;\n-        }\n-    }\n-}\n-\n-reemit! { foo => 45u32.into() } //~ ERROR type annotations\n-\n-fn main() {}"}, {"sha": "6d512846ff7852d136090c55a5d96bed2429d9b2", "filename": "src/test/ui/proc-macro/macro-rules-capture.stderr", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-rules-capture.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-rules-capture.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-rules-capture.stderr?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -1,12 +0,0 @@\n-error[E0282]: type annotations needed\n-  --> $DIR/macro-rules-capture.rs:16:24\n-   |\n-LL | reemit! { foo => 45u32.into() }\n-   |                  ------^^^^--\n-   |                  |     |\n-   |                  |     cannot infer type for type parameter `T` declared on the trait `Into`\n-   |                  this method call resolves to `T`\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0282`."}, {"sha": "66d6440c9cb9fb9f332af2cdac0e14fdbffd3ecf", "filename": "src/test/ui/unused-crate-deps/test-use-ok.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Ftest%2Fui%2Funused-crate-deps%2Ftest-use-ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91fb72a8a9f53de2bcc5638c1358fcb552dba8ce/src%2Ftest%2Fui%2Funused-crate-deps%2Ftest-use-ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funused-crate-deps%2Ftest-use-ok.rs?ref=91fb72a8a9f53de2bcc5638c1358fcb552dba8ce", "patch": "@@ -0,0 +1,15 @@\n+// Test-only use OK\n+\n+// edition:2018\n+// check-pass\n+// aux-crate:bar=bar.rs\n+// compile-flags:--test\n+\n+#![deny(unused_crate_dependencies)]\n+\n+fn main() {}\n+\n+#[test]\n+fn test_bar() {\n+    assert_eq!(bar::BAR, \"bar\");\n+}"}]}