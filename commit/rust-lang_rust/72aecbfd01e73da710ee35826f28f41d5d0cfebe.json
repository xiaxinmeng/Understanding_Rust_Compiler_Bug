{"sha": "72aecbfd01e73da710ee35826f28f41d5d0cfebe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyYWVjYmZkMDFlNzNkYTcxMGVlMzU4MjZmMjhmNDFkNWQwY2ZlYmU=", "commit": {"author": {"name": "Tyson Nottingham", "email": "tgnottingham@gmail.com", "date": "2020-12-15T22:18:02Z"}, "committer": {"name": "Tyson Nottingham", "email": "tgnottingham@gmail.com", "date": "2021-04-13T16:48:58Z"}, "message": "BufWriter: handle possibility of overflow", "tree": {"sha": "9159f11256658e28b87e14ecdd3db99a246f4152", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9159f11256658e28b87e14ecdd3db99a246f4152"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/72aecbfd01e73da710ee35826f28f41d5d0cfebe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/72aecbfd01e73da710ee35826f28f41d5d0cfebe", "html_url": "https://github.com/rust-lang/rust/commit/72aecbfd01e73da710ee35826f28f41d5d0cfebe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/72aecbfd01e73da710ee35826f28f41d5d0cfebe/comments", "author": {"login": "tgnottingham", "id": 3668166, "node_id": "MDQ6VXNlcjM2NjgxNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3668166?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tgnottingham", "html_url": "https://github.com/tgnottingham", "followers_url": "https://api.github.com/users/tgnottingham/followers", "following_url": "https://api.github.com/users/tgnottingham/following{/other_user}", "gists_url": "https://api.github.com/users/tgnottingham/gists{/gist_id}", "starred_url": "https://api.github.com/users/tgnottingham/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tgnottingham/subscriptions", "organizations_url": "https://api.github.com/users/tgnottingham/orgs", "repos_url": "https://api.github.com/users/tgnottingham/repos", "events_url": "https://api.github.com/users/tgnottingham/events{/privacy}", "received_events_url": "https://api.github.com/users/tgnottingham/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tgnottingham", "id": 3668166, "node_id": "MDQ6VXNlcjM2NjgxNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3668166?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tgnottingham", "html_url": "https://github.com/tgnottingham", "followers_url": "https://api.github.com/users/tgnottingham/followers", "following_url": "https://api.github.com/users/tgnottingham/following{/other_user}", "gists_url": "https://api.github.com/users/tgnottingham/gists{/gist_id}", "starred_url": "https://api.github.com/users/tgnottingham/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tgnottingham/subscriptions", "organizations_url": "https://api.github.com/users/tgnottingham/orgs", "repos_url": "https://api.github.com/users/tgnottingham/repos", "events_url": "https://api.github.com/users/tgnottingham/events{/privacy}", "received_events_url": "https://api.github.com/users/tgnottingham/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5fd9372c1118b213b15a0e75bec7fab3b2e00260", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fd9372c1118b213b15a0e75bec7fab3b2e00260", "html_url": "https://github.com/rust-lang/rust/commit/5fd9372c1118b213b15a0e75bec7fab3b2e00260"}], "stats": {"total": 54, "additions": 39, "deletions": 15}, "files": [{"sha": "a9fc450de31824939b99d851eba4b14b4d99f6a3", "filename": "library/std/src/io/buffered/bufwriter.rs", "status": "modified", "additions": 39, "deletions": 15, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/72aecbfd01e73da710ee35826f28f41d5d0cfebe/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72aecbfd01e73da710ee35826f28f41d5d0cfebe/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufwriter.rs?ref=72aecbfd01e73da710ee35826f28f41d5d0cfebe", "patch": "@@ -190,7 +190,7 @@ impl<W: Write> BufWriter<W> {\n     /// data. Writes as much as possible without exceeding capacity. Returns\n     /// the number of bytes written.\n     pub(super) fn write_to_buf(&mut self, buf: &[u8]) -> usize {\n-        let available = self.buf.capacity() - self.buf.len();\n+        let available = self.spare_capacity();\n         let amt_to_buffer = available.min(buf.len());\n \n         // SAFETY: `amt_to_buffer` is <= buffer's spare capacity by construction.\n@@ -353,7 +353,7 @@ impl<W: Write> BufWriter<W> {\n     // or their write patterns are somewhat pathological.\n     #[inline(never)]\n     fn write_cold(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        if self.buf.len() + buf.len() > self.buf.capacity() {\n+        if buf.len() > self.spare_capacity() {\n             self.flush_buf()?;\n         }\n \n@@ -371,7 +371,7 @@ impl<W: Write> BufWriter<W> {\n \n             // SAFETY: We just called `self.flush_buf()`, so `self.buf.len()` is 0, and\n             // we entered this else block because `buf.len() < self.buf.capacity()`.\n-            // Therefore, `self.buf.len() + buf.len() <= self.buf.capacity()`.\n+            // Therefore, `buf.len() <= self.buf.capacity() - self.buf.len()`.\n             unsafe {\n                 self.write_to_buffer_unchecked(buf);\n             }\n@@ -391,7 +391,8 @@ impl<W: Write> BufWriter<W> {\n         // by calling `self.get_mut().write_all()` directly, which avoids\n         // round trips through the buffer in the event of a series of partial\n         // writes in some circumstances.\n-        if self.buf.len() + buf.len() > self.buf.capacity() {\n+\n+        if buf.len() > self.spare_capacity() {\n             self.flush_buf()?;\n         }\n \n@@ -409,7 +410,7 @@ impl<W: Write> BufWriter<W> {\n \n             // SAFETY: We just called `self.flush_buf()`, so `self.buf.len()` is 0, and\n             // we entered this else block because `buf.len() < self.buf.capacity()`.\n-            // Therefore, `self.buf.len() + buf.len() <= self.buf.capacity()`.\n+            // Therefore, `buf.len() <= self.buf.capacity() - self.buf.len()`.\n             unsafe {\n                 self.write_to_buffer_unchecked(buf);\n             }\n@@ -418,18 +419,23 @@ impl<W: Write> BufWriter<W> {\n         }\n     }\n \n-    // SAFETY: Requires `self.buf.len() + buf.len() <= self.buf.capacity()`,\n+    // SAFETY: Requires `buf.len() <= self.buf.capacity() - self.buf.len()`,\n     // i.e., that input buffer length is less than or equal to spare capacity.\n     #[inline(always)]\n     unsafe fn write_to_buffer_unchecked(&mut self, buf: &[u8]) {\n-        debug_assert!(self.buf.len() + buf.len() <= self.buf.capacity());\n+        debug_assert!(buf.len() <= self.spare_capacity());\n         let old_len = self.buf.len();\n         let buf_len = buf.len();\n         let src = buf.as_ptr();\n         let dst = self.buf.as_mut_ptr().add(old_len);\n         ptr::copy_nonoverlapping(src, dst, buf_len);\n         self.buf.set_len(old_len + buf_len);\n     }\n+\n+    #[inline]\n+    fn spare_capacity(&self) -> usize {\n+        self.buf.capacity() - self.buf.len()\n+    }\n }\n \n #[unstable(feature = \"bufwriter_into_raw_parts\", issue = \"80690\")]\n@@ -505,7 +511,7 @@ impl<W: Write> Write for BufWriter<W> {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         // Use < instead of <= to avoid a needless trip through the buffer in some cases.\n         // See `write_cold` for details.\n-        if self.buf.len() + buf.len() < self.buf.capacity() {\n+        if buf.len() < self.spare_capacity() {\n             // SAFETY: safe by above conditional.\n             unsafe {\n                 self.write_to_buffer_unchecked(buf);\n@@ -521,7 +527,7 @@ impl<W: Write> Write for BufWriter<W> {\n     fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n         // Use < instead of <= to avoid a needless trip through the buffer in some cases.\n         // See `write_all_cold` for details.\n-        if self.buf.len() + buf.len() < self.buf.capacity() {\n+        if buf.len() < self.spare_capacity() {\n             // SAFETY: safe by above conditional.\n             unsafe {\n                 self.write_to_buffer_unchecked(buf);\n@@ -537,31 +543,46 @@ impl<W: Write> Write for BufWriter<W> {\n         // FIXME: Consider applying `#[inline]` / `#[inline(never)]` optimizations already applied\n         // to `write` and `write_all`. The performance benefits can be significant. See #79930.\n         if self.get_ref().is_write_vectored() {\n-            let total_len = bufs.iter().map(|b| b.len()).sum::<usize>();\n-            if self.buf.len() + total_len > self.buf.capacity() {\n+            // We have to handle the possibility that the total length of the buffers overflows\n+            // `usize` (even though this can only happen if multiple `IoSlice`s reference the\n+            // same underlying buffer, as otherwise the buffers wouldn't fit in memory). If the\n+            // computation overflows, then surely the input cannot fit in our buffer, so we forward\n+            // to the inner writer's `write_vectored` method to let it handle it appropriately.\n+            let saturated_total_len =\n+                bufs.iter().fold(0usize, |acc, b| acc.saturating_add(b.len()));\n+\n+            if saturated_total_len > self.spare_capacity() {\n+                // Flush if the total length of the input exceeds our buffer's spare capacity.\n+                // If we would have overflowed, this condition also holds, and we need to flush.\n                 self.flush_buf()?;\n             }\n-            if total_len >= self.buf.capacity() {\n+\n+            if saturated_total_len >= self.buf.capacity() {\n+                // Forward to our inner writer if the total length of the input is greater than or\n+                // equal to our buffer capacity. If we would have overflowed, this condition also\n+                // holds, and we punt to the inner writer.\n                 self.panicked = true;\n                 let r = self.get_mut().write_vectored(bufs);\n                 self.panicked = false;\n                 r\n             } else {\n+                // `saturated_total_len < self.buf.capacity()` implies that we did not saturate.\n+\n                 // SAFETY: We checked whether or not the spare capacity was large enough above. If\n                 // it was, then we're safe already. If it wasn't, we flushed, making sufficient\n                 // room for any input <= the buffer size, which includes this input.\n                 unsafe {\n                     bufs.iter().for_each(|b| self.write_to_buffer_unchecked(b));\n                 };\n \n-                Ok(total_len)\n+                Ok(saturated_total_len)\n             }\n         } else {\n             let mut iter = bufs.iter();\n             let mut total_written = if let Some(buf) = iter.by_ref().find(|&buf| !buf.is_empty()) {\n                 // This is the first non-empty slice to write, so if it does\n                 // not fit in the buffer, we still get to flush and proceed.\n-                if self.buf.len() + buf.len() > self.buf.capacity() {\n+                if buf.len() > self.spare_capacity() {\n                     self.flush_buf()?;\n                 }\n                 if buf.len() >= self.buf.capacity() {\n@@ -586,12 +607,15 @@ impl<W: Write> Write for BufWriter<W> {\n             };\n             debug_assert!(total_written != 0);\n             for buf in iter {\n-                if self.buf.len() + buf.len() <= self.buf.capacity() {\n+                if buf.len() <= self.spare_capacity() {\n                     // SAFETY: safe by above conditional.\n                     unsafe {\n                         self.write_to_buffer_unchecked(buf);\n                     }\n \n+                    // This cannot overflow `usize`. If we are here, we've written all of the bytes\n+                    // so far to our buffer, and we've ensured that we never exceed the buffer's\n+                    // capacity. Therefore, `total_written` <= `self.buf.capacity()` <= `usize::MAX`.\n                     total_written += buf.len();\n                 } else {\n                     break;"}]}