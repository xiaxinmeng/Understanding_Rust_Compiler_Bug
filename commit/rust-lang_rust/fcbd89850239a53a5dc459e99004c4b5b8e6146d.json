{"sha": "fcbd89850239a53a5dc459e99004c4b5b8e6146d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjYmQ4OTg1MDIzOWE1M2E1ZGM0NTllOTkwMDRjNGI1YjhlNjE0NmQ=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2017-04-16T13:17:13Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2017-04-16T13:17:13Z"}, "message": "Compress ReprOptions a little bit", "tree": {"sha": "1588a16425d21196009f2c5c78688e5c495f0a4e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1588a16425d21196009f2c5c78688e5c495f0a4e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fcbd89850239a53a5dc459e99004c4b5b8e6146d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fcbd89850239a53a5dc459e99004c4b5b8e6146d", "html_url": "https://github.com/rust-lang/rust/commit/fcbd89850239a53a5dc459e99004c4b5b8e6146d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fcbd89850239a53a5dc459e99004c4b5b8e6146d/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "13fd5e93deb41045c4de88c257d2b02ada2b1730", "url": "https://api.github.com/repos/rust-lang/rust/commits/13fd5e93deb41045c4de88c257d2b02ada2b1730", "html_url": "https://github.com/rust-lang/rust/commit/13fd5e93deb41045c4de88c257d2b02ada2b1730"}], "stats": {"total": 100, "additions": 65, "deletions": 35}, "files": [{"sha": "342553593af339cddd14ff21f47074e620cf9ad2", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fcbd89850239a53a5dc459e99004c4b5b8e6146d/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcbd89850239a53a5dc459e99004c4b5b8e6146d/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=fcbd89850239a53a5dc459e99004c4b5b8e6146d", "patch": "@@ -162,7 +162,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                     hir::ItemStruct(..) | hir::ItemUnion(..) => {\n                         let def_id = self.tcx.hir.local_def_id(item.id);\n                         let def = self.tcx.lookup_adt_def(def_id);\n-                        self.struct_has_extern_repr = def.repr.c;\n+                        self.struct_has_extern_repr = def.repr.c();\n \n                         intravisit::walk_item(self, &item);\n                     }"}, {"sha": "942f8475eceddcbe1b3871bfd6790f9eacf2be36", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fcbd89850239a53a5dc459e99004c4b5b8e6146d/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcbd89850239a53a5dc459e99004c4b5b8e6146d/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=fcbd89850239a53a5dc459e99004c4b5b8e6146d", "patch": "@@ -46,7 +46,7 @@ fn unpack_option_like<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         _ => return ty\n     };\n \n-    if def.variants.len() == 2 && !def.repr.c && def.repr.int.is_none() {\n+    if def.variants.len() == 2 && !def.repr.c() && def.repr.int.is_none() {\n         let data_idx;\n \n         if def.variants[0].fields.is_empty() {"}, {"sha": "df60eee8c02431d761e1a11e762b2c5081c46a73", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fcbd89850239a53a5dc459e99004c4b5b8e6146d/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcbd89850239a53a5dc459e99004c4b5b8e6146d/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=fcbd89850239a53a5dc459e99004c4b5b8e6146d", "patch": "@@ -15,7 +15,7 @@ pub use self::Primitive::*;\n use infer::InferCtxt;\n use session::Session;\n use traits;\n-use ty::{self, Ty, TyCtxt, TypeFoldable, ReprOptions};\n+use ty::{self, Ty, TyCtxt, TypeFoldable, ReprOptions, ReprFlags};\n \n use syntax::ast::{FloatTy, IntTy, UintTy};\n use syntax::attr;\n@@ -479,7 +479,7 @@ impl Integer {\n             return (discr, ity.is_signed());\n         }\n \n-        if repr.c {\n+        if repr.c() {\n             match &tcx.sess.target.target.arch[..] {\n                 // WARNING: the ARM EABI has two variants; the one corresponding\n                 // to `at_least == I32` appears to be used on Linux and NetBSD,\n@@ -583,7 +583,7 @@ impl<'a, 'gcx, 'tcx> Struct {\n     fn new(dl: &TargetDataLayout, fields: &Vec<&'a Layout>,\n                   repr: &ReprOptions, kind: StructKind,\n                   scapegoat: Ty<'gcx>) -> Result<Struct, LayoutError<'gcx>> {\n-        let packed = repr.packed;\n+        let packed = repr.packed();\n         let mut ret = Struct {\n             align: if packed { dl.i8_align } else { dl.aggregate_align },\n             packed: packed,\n@@ -598,7 +598,7 @@ impl<'a, 'gcx, 'tcx> Struct {\n         // In addition, code in trans assume that 2-element structs can become pairs.\n         // It's easier to just short-circuit here.\n         let can_optimize = (fields.len() > 2 || StructKind::EnumVariant == kind)\n-            && !(repr.c || repr.packed || repr.linear || repr.simd);\n+            && (repr.flags & ReprFlags::IS_UNOPTIMISABLE).is_empty();\n \n         let (optimize, sort_ascending) = match kind {\n             StructKind::AlwaysSizedUnivariant => (can_optimize, false),\n@@ -1177,7 +1177,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n             }\n \n             // SIMD vector types.\n-            ty::TyAdt(def, ..) if def.repr.simd => {\n+            ty::TyAdt(def, ..) if def.repr.simd() => {\n                 let element = ty.simd_type(tcx);\n                 match *element.layout(infcx)? {\n                     Scalar { value, .. } => {\n@@ -1255,7 +1255,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                         field.ty(tcx, substs).layout(infcx)\n                     }).collect::<Result<Vec<_>, _>>()?;\n                     let layout = if def.is_union() {\n-                        let mut un = Union::new(dl, def.repr.packed);\n+                        let mut un = Union::new(dl, def.repr.packed());\n                         un.extend(dl, fields.iter().map(|&f| Ok(f)), ty)?;\n                         UntaggedUnion { variants: un }\n                     } else {\n@@ -1925,7 +1925,7 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n             ty::TyTuple(tys, _) => tys[i],\n \n             // SIMD vector types.\n-            ty::TyAdt(def, ..) if def.repr.simd => {\n+            ty::TyAdt(def, ..) if def.repr.simd() => {\n                 self.ty.simd_type(tcx)\n             }\n "}, {"sha": "b4f2deabd234ee0d41f4db00e4e6daf30a264e97", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 51, "deletions": 21, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/fcbd89850239a53a5dc459e99004c4b5b8e6146d/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcbd89850239a53a5dc459e99004c4b5b8e6146d/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=fcbd89850239a53a5dc459e99004c4b5b8e6146d", "patch": "@@ -1438,51 +1438,81 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a, 'tcx>> for AdtDef {\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub enum AdtKind { Struct, Union, Enum }\n \n+bitflags! {\n+    #[derive(RustcEncodable, RustcDecodable, Default)]\n+    flags ReprFlags: u8 {\n+        const IS_C               = 1 << 0,\n+        const IS_PACKED          = 1 << 1,\n+        const IS_SIMD            = 1 << 2,\n+        // Internal only for now. If true, don't reorder fields.\n+        const IS_LINEAR          = 1 << 3,\n+\n+        // Any of these flags being set prevent field reordering optimisation.\n+        const IS_UNOPTIMISABLE   = ReprFlags::IS_C.bits |\n+                                   ReprFlags::IS_PACKED.bits |\n+                                   ReprFlags::IS_SIMD.bits |\n+                                   ReprFlags::IS_LINEAR.bits,\n+    }\n+}\n+\n+impl_stable_hash_for!(struct ReprFlags {\n+    bits\n+});\n+\n+\n+\n /// Represents the repr options provided by the user,\n #[derive(Copy, Clone, Eq, PartialEq, RustcEncodable, RustcDecodable, Default)]\n pub struct ReprOptions {\n-    pub c: bool,\n-    pub packed: bool,\n-    pub simd: bool,\n     pub int: Option<attr::IntType>,\n-    // Internal only for now. If true, don't reorder fields.\n-    pub linear: bool,\n+    pub flags: ReprFlags,\n }\n \n impl_stable_hash_for!(struct ReprOptions {\n-    c,\n-    packed,\n-    simd,\n     int,\n-    linear\n+    flags\n });\n \n impl ReprOptions {\n     pub fn new(tcx: TyCtxt, did: DefId) -> ReprOptions {\n-        let mut ret = ReprOptions::default();\n+        let mut flags = ReprFlags::empty();\n+        let mut size = None;\n \n         for attr in tcx.get_attrs(did).iter() {\n             for r in attr::find_repr_attrs(tcx.sess.diagnostic(), attr) {\n-                match r {\n-                    attr::ReprExtern => ret.c = true,\n-                    attr::ReprPacked => ret.packed = true,\n-                    attr::ReprSimd => ret.simd = true,\n-                    attr::ReprInt(i) => ret.int = Some(i),\n-                }\n+                flags.insert(match r {\n+                    attr::ReprExtern => ReprFlags::IS_C,\n+                    attr::ReprPacked => ReprFlags::IS_PACKED,\n+                    attr::ReprSimd => ReprFlags::IS_SIMD,\n+                    attr::ReprInt(i) => {\n+                        size = Some(i);\n+                        ReprFlags::empty()\n+                    },\n+                });\n             }\n         }\n \n         // FIXME(eddyb) This is deprecated and should be removed.\n         if tcx.has_attr(did, \"simd\") {\n-            ret.simd = true;\n+            flags.insert(ReprFlags::IS_SIMD);\n         }\n \n         // This is here instead of layout because the choice must make it into metadata.\n-        ret.linear = !tcx.consider_optimizing(|| format!(\"Reorder fields of {:?}\",\n-            tcx.item_path_str(did)));\n-        ret\n+        if !tcx.consider_optimizing(|| format!(\"Reorder fields of {:?}\", tcx.item_path_str(did))) {\n+            flags.insert(ReprFlags::IS_LINEAR);\n+        }\n+        ReprOptions { int: size, flags: flags }\n     }\n \n+    #[inline]\n+    pub fn simd(&self) -> bool { self.flags.contains(ReprFlags::IS_SIMD) }\n+    #[inline]\n+    pub fn c(&self) -> bool { self.flags.contains(ReprFlags::IS_C) }\n+    #[inline]\n+    pub fn packed(&self) -> bool { self.flags.contains(ReprFlags::IS_PACKED) }\n+    #[inline]\n+    pub fn linear(&self) -> bool { self.flags.contains(ReprFlags::IS_LINEAR) }\n+\n     pub fn discr_type(&self) -> attr::IntType {\n         self.int.unwrap_or(attr::SignedInt(ast::IntTy::Is))\n     }\n@@ -1491,7 +1521,7 @@ impl ReprOptions {\n     /// layout\" optimizations, such as representing `Foo<&T>` as a\n     /// single pointer.\n     pub fn inhibit_enum_layout_opt(&self) -> bool {\n-        self.c || self.int.is_some()\n+        self.c() || self.int.is_some()\n     }\n }\n "}, {"sha": "d59248170344e50706a5b20561ed1c05a113b529", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fcbd89850239a53a5dc459e99004c4b5b8e6146d/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcbd89850239a53a5dc459e99004c4b5b8e6146d/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=fcbd89850239a53a5dc459e99004c4b5b8e6146d", "patch": "@@ -1095,7 +1095,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     #[inline]\n     pub fn is_simd(&self) -> bool {\n         match self.sty {\n-            TyAdt(def, _) => def.repr.simd,\n+            TyAdt(def, _) => def.repr.simd(),\n             _ => false,\n         }\n     }"}, {"sha": "3e60d8a5ada092133eca3510baa39b478ee06614", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fcbd89850239a53a5dc459e99004c4b5b8e6146d/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcbd89850239a53a5dc459e99004c4b5b8e6146d/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=fcbd89850239a53a5dc459e99004c4b5b8e6146d", "patch": "@@ -416,7 +416,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                 }\n                 match def.adt_kind() {\n                     AdtKind::Struct => {\n-                        if !def.repr.c {\n+                        if !def.repr.c() {\n                             return FfiUnsafe(\"found struct without foreign-function-safe \\\n                                               representation annotation in foreign module, \\\n                                               consider adding a #[repr(C)] attribute to the type\");\n@@ -450,7 +450,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                         if all_phantom { FfiPhantom } else { FfiSafe }\n                     }\n                     AdtKind::Union => {\n-                        if !def.repr.c {\n+                        if !def.repr.c() {\n                             return FfiUnsafe(\"found union without foreign-function-safe \\\n                                               representation annotation in foreign module, \\\n                                               consider adding a #[repr(C)] attribute to the type\");\n@@ -489,7 +489,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n                         // Check for a repr() attribute to specify the size of the\n                         // discriminant.\n-                        if !def.repr.c && def.repr.int.is_none() {\n+                        if !def.repr.c() && def.repr.int.is_none() {\n                             // Special-case types like `Option<extern fn()>`.\n                             if !is_repr_nullable_ptr(cx, def, substs) {\n                                 return FfiUnsafe(\"found enum without foreign-function-safe \\"}, {"sha": "daa18aaa556ab06e2efa3e6ec032a020527fd448", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fcbd89850239a53a5dc459e99004c4b5b8e6146d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcbd89850239a53a5dc459e99004c4b5b8e6146d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=fcbd89850239a53a5dc459e99004c4b5b8e6146d", "patch": "@@ -918,7 +918,7 @@ fn check_struct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     def.destructor(tcx); // force the destructor to be evaluated\n     check_representable(tcx, span, def_id);\n \n-    if def.repr.simd {\n+    if def.repr.simd() {\n         check_simd(tcx, span, def_id);\n     }\n }"}]}