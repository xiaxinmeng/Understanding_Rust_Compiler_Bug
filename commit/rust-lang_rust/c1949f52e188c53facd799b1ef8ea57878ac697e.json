{"sha": "c1949f52e188c53facd799b1ef8ea57878ac697e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxOTQ5ZjUyZTE4OGM1M2ZhY2Q3OTliMWVmOGVhNTc4NzhhYzY5N2U=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2016-05-12T23:07:42Z"}, "committer": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2016-05-12T23:07:42Z"}, "message": "Merge pull request #893 from marcusklaas/try-shorthand\n\nTry shorthand", "tree": {"sha": "4e3a16c07da80e9cf877d1bb38443b02b045c83a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e3a16c07da80e9cf877d1bb38443b02b045c83a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1949f52e188c53facd799b1ef8ea57878ac697e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1949f52e188c53facd799b1ef8ea57878ac697e", "html_url": "https://github.com/rust-lang/rust/commit/c1949f52e188c53facd799b1ef8ea57878ac697e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1949f52e188c53facd799b1ef8ea57878ac697e/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc2549b5769d044bf6b16b1ca833785969dc318b", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc2549b5769d044bf6b16b1ca833785969dc318b", "html_url": "https://github.com/rust-lang/rust/commit/fc2549b5769d044bf6b16b1ca833785969dc318b"}, {"sha": "eae2921e14d1cc71134ce9afcafd2cb3dc9543a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/eae2921e14d1cc71134ce9afcafd2cb3dc9543a2", "html_url": "https://github.com/rust-lang/rust/commit/eae2921e14d1cc71134ce9afcafd2cb3dc9543a2"}], "stats": {"total": 425, "additions": 270, "deletions": 155}, "files": [{"sha": "3f306abfdcab3d1752f2e536bba6575527667f96", "filename": "src/chains.rs", "status": "modified", "additions": 68, "deletions": 23, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/c1949f52e188c53facd799b1ef8ea57878ac697e/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1949f52e188c53facd799b1ef8ea57878ac697e/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=c1949f52e188c53facd799b1ef8ea57878ac697e", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n /// Formatting of chained expressions, i.e. expressions which are chained by\n-/// dots: struct and enum field access and method calls.\n+/// dots: struct and enum field access, method calls, and try shorthand (?).\n ///\n /// Instead of walking these subexpressions one-by-one, as is our usual strategy\n /// for expression formatting, we collect maximal sequences of these expressions\n@@ -81,24 +81,23 @@\n /// true, then we allow the last method call to spill over multiple lines without\n /// forcing the rest of the chain to be split.\n \n-\n use Indent;\n use rewrite::{Rewrite, RewriteContext};\n use utils::{wrap_str, first_line_width};\n use expr::rewrite_call;\n use config::BlockIndentStyle;\n+use macros::convert_try_mac;\n \n use syntax::{ast, ptr};\n use syntax::codemap::{mk_sp, Span};\n \n-\n pub fn rewrite_chain(expr: &ast::Expr,\n                      context: &RewriteContext,\n                      width: usize,\n                      offset: Indent)\n                      -> Option<String> {\n     let total_span = expr.span;\n-    let (parent, subexpr_list) = make_subexpr_list(expr);\n+    let (parent, subexpr_list) = make_subexpr_list(expr, context);\n \n     // Parent is the first item in the chain, e.g., `foo` in `foo.bar.baz()`.\n     let parent_block_indent = chain_base_indent(context, offset);\n@@ -107,11 +106,16 @@ pub fn rewrite_chain(expr: &ast::Expr,\n \n     // Decide how to layout the rest of the chain. `extend` is true if we can\n     // put the first non-parent item on the same line as the parent.\n-    let (indent, extend) = if !parent_rewrite.contains('\\n') && is_continuable(parent) ||\n+    let (indent, extend) = if !parent_rewrite.contains('\\n') && is_continuable(&parent) ||\n                               parent_rewrite.len() <= context.config.tab_spaces {\n-        // Try and put at least the first two items on the same line.\n-        (chain_indent(context, offset + Indent::new(0, parent_rewrite.len())), true)\n-    } else if is_block_expr(parent, &parent_rewrite) {\n+\n+        let indent = if let ast::ExprKind::Try(..) = subexpr_list.last().unwrap().node {\n+            parent_block_indent.block_indent(context.config)\n+        } else {\n+            chain_indent(context, offset + Indent::new(0, parent_rewrite.len()))\n+        };\n+        (indent, true)\n+    } else if is_block_expr(&parent, &parent_rewrite) {\n         // The parent is a block, so align the rest of the chain with the closing\n         // brace.\n         (parent_block_indent, false)\n@@ -184,12 +188,29 @@ pub fn rewrite_chain(expr: &ast::Expr,\n     wrap_str(format!(\"{}{}{}\",\n                      parent_rewrite,\n                      first_connector,\n-                     rewrites.join(&connector)),\n+                     join_rewrites(&rewrites, &subexpr_list, &connector)),\n              context.config.max_width,\n              width,\n              offset)\n }\n \n+fn join_rewrites(rewrites: &[String], subexps: &[ast::Expr], connector: &str) -> String {\n+    let mut rewrite_iter = rewrites.iter();\n+    let mut result = rewrite_iter.next().unwrap().clone();\n+    let mut subexpr_iter = subexps.iter().rev();\n+    subexpr_iter.next();\n+\n+    for (rewrite, expr) in rewrite_iter.zip(subexpr_iter) {\n+        match expr.node {\n+            ast::ExprKind::Try(_) => (),\n+            _ => result.push_str(connector),\n+        };\n+        result.push_str(&rewrite[..]);\n+    }\n+\n+    result\n+}\n+\n // States whether an expression's last line exclusively consists of closing\n // parens, braces, and brackets in its idiomatic formatting.\n fn is_block_expr(expr: &ast::Expr, repr: &str) -> bool {\n@@ -213,21 +234,11 @@ fn is_block_expr(expr: &ast::Expr, repr: &str) -> bool {\n \n // Returns the root of the chain and a Vec of the prefixes of the rest of the chain.\n // E.g., for input `a.b.c` we return (`a`, [`a.b.c`, `a.b`])\n-fn make_subexpr_list(mut expr: &ast::Expr) -> (&ast::Expr, Vec<&ast::Expr>) {\n-    fn pop_expr_chain(expr: &ast::Expr) -> Option<&ast::Expr> {\n-        match expr.node {\n-            ast::ExprKind::MethodCall(_, _, ref expressions) => Some(&expressions[0]),\n-            ast::ExprKind::TupField(ref subexpr, _) |\n-            ast::ExprKind::Field(ref subexpr, _) => Some(subexpr),\n-            _ => None,\n-        }\n-    }\n-\n-    let mut subexpr_list = vec![expr];\n+fn make_subexpr_list(expr: &ast::Expr, context: &RewriteContext) -> (ast::Expr, Vec<ast::Expr>) {\n+    let mut subexpr_list = vec![expr.clone()];\n \n-    while let Some(subexpr) = pop_expr_chain(expr) {\n-        subexpr_list.push(subexpr);\n-        expr = subexpr;\n+    while let Some(subexpr) = pop_expr_chain(subexpr_list.last().unwrap(), context) {\n+        subexpr_list.push(subexpr.clone());\n     }\n \n     let parent = subexpr_list.pop().unwrap();\n@@ -293,6 +304,33 @@ fn rewrite_method_call_with_overflow(expr_kind: &ast::ExprKind,\n     }\n }\n \n+// Returns the expression's subexpression, if it exists. When the subexpr\n+// is a try! macro, we'll convert it to shorthand when the option is set.\n+fn pop_expr_chain(expr: &ast::Expr, context: &RewriteContext) -> Option<ast::Expr> {\n+    match expr.node {\n+        ast::ExprKind::MethodCall(_, _, ref expressions) => {\n+            Some(convert_try(&expressions[0], context))\n+        }\n+        ast::ExprKind::TupField(ref subexpr, _) |\n+        ast::ExprKind::Field(ref subexpr, _) |\n+        ast::ExprKind::Try(ref subexpr) => Some(convert_try(subexpr, context)),\n+        _ => None,\n+    }\n+}\n+\n+fn convert_try(expr: &ast::Expr, context: &RewriteContext) -> ast::Expr {\n+    match expr.node {\n+        ast::ExprKind::Mac(ref mac) if context.config.use_try_shorthand => {\n+            if let Some(subexpr) = convert_try_mac(mac, context) {\n+                subexpr\n+            } else {\n+                expr.clone()\n+            }\n+        }\n+        _ => expr.clone(),\n+    }\n+}\n+\n // Rewrite the last element in the chain `expr`. E.g., given `a.b.c` we rewrite\n // `.c`.\n fn rewrite_chain_subexpr(expr: &ast::Expr,\n@@ -328,6 +366,13 @@ fn rewrite_chain_subexpr(expr: &ast::Expr,\n                 None\n             }\n         }\n+        ast::ExprKind::Try(_) => {\n+            if width >= 1 {\n+                Some(\"?\".into())\n+            } else {\n+                None\n+            }\n+        }\n         _ => unreachable!(),\n     }\n }"}, {"sha": "5e4dbefad45cad688293c245e897b3f010828298", "filename": "src/config.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c1949f52e188c53facd799b1ef8ea57878ac697e/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1949f52e188c53facd799b1ef8ea57878ac697e/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=c1949f52e188c53facd799b1ef8ea57878ac697e", "patch": "@@ -392,6 +392,7 @@ create_config! {\n     match_wildcard_trailing_comma: bool, true, \"Put a trailing comma after a wildcard arm\";\n     closure_block_indent_threshold: isize, 5, \"How many lines a closure must have before it is \\\n                                                block indented. -1 means never use block indent.\";\n+    use_try_shorthand: bool, false, \"Replace uses of the try! macro by the ? shorthand\";\n     write_mode: WriteMode, WriteMode::Replace,\n         \"What Write Mode to use when none is supplied: Replace, Overwrite, Display, Diff, Coverage\";\n }"}, {"sha": "ebe344000148d3ce750d70def908014a1dd857f0", "filename": "src/expr.rs", "status": "modified", "additions": 69, "deletions": 45, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/c1949f52e188c53facd799b1ef8ea57878ac697e/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1949f52e188c53facd799b1ef8ea57878ac697e/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=c1949f52e188c53facd799b1ef8ea57878ac697e", "patch": "@@ -136,18 +136,25 @@ impl Rewrite for ast::Expr {\n                     Some(ident) => format!(\" {}\", ident.node),\n                     None => String::new(),\n                 };\n-                wrap_str(format!(\"continue{}\", id_str), context.config.max_width, width, offset)\n+                wrap_str(format!(\"continue{}\", id_str),\n+                         context.config.max_width,\n+                         width,\n+                         offset)\n             }\n             ast::ExprKind::Break(ref opt_ident) => {\n                 let id_str = match *opt_ident {\n                     Some(ident) => format!(\" {}\", ident.node),\n                     None => String::new(),\n                 };\n-                wrap_str(format!(\"break{}\", id_str), context.config.max_width, width, offset)\n+                wrap_str(format!(\"break{}\", id_str),\n+                         context.config.max_width,\n+                         width,\n+                         offset)\n             }\n             ast::ExprKind::Closure(capture, ref fn_decl, ref body, _) => {\n                 rewrite_closure(capture, fn_decl, body, self.span, context, width, offset)\n             }\n+            ast::ExprKind::Try(..) |\n             ast::ExprKind::Field(..) |\n             ast::ExprKind::TupField(..) |\n             ast::ExprKind::MethodCall(..) => rewrite_chain(self, context, width, offset),\n@@ -199,21 +206,15 @@ impl Rewrite for ast::Expr {\n                         rewrite_unary_prefix(context, delim, &**rhs, width, offset)\n                     }\n                     (Some(ref lhs), None) => {\n-                        Some(format!(\"{}{}\",\n-                                     try_opt!(lhs.rewrite(context,\n-                                                          try_opt!(width.checked_sub(delim.len())),\n-                                                          offset)),\n-                                     delim))\n+                        rewrite_unary_suffix(context, delim, &**lhs, width, offset)\n                     }\n                     (None, None) => wrap_str(delim.into(), context.config.max_width, width, offset),\n                 }\n             }\n             // We do not format these expressions yet, but they should still\n             // satisfy our width restrictions.\n             ast::ExprKind::InPlace(..) |\n-            ast::ExprKind::InlineAsm(..) |\n-            // TODO(#867): Handle try shorthand\n-            ast::ExprKind::Try(_) => {\n+            ast::ExprKind::InlineAsm(..) => {\n                 wrap_str(context.snippet(self.span),\n                          context.config.max_width,\n                          width,\n@@ -689,11 +690,8 @@ fn extract_comment(span: Span,\n                    -> Option<String> {\n     let comment_str = context.snippet(span);\n     if contains_comment(&comment_str) {\n-        let comment = try_opt!(rewrite_comment(comment_str.trim(),\n-                                               false,\n-                                               width,\n-                                               offset,\n-                                               context.config));\n+        let comment =\n+            try_opt!(rewrite_comment(comment_str.trim(), false, width, offset, context.config));\n         Some(format!(\"\\n{indent}{}\\n{indent}\",\n                      comment,\n                      indent = offset.to_string(context.config)))\n@@ -793,14 +791,11 @@ fn rewrite_if_else(context: &RewriteContext,\n             }\n         };\n \n-        let between_if_else_block = mk_sp(if_block.span.hi,\n-                                          context.codemap.span_before(mk_sp(if_block.span.hi,\n-                                                                            else_block.span.lo),\n-                                                                      \"else\"));\n-        let between_if_else_block_comment = extract_comment(between_if_else_block,\n-                                                            &context,\n-                                                            offset,\n-                                                            width);\n+        let between_if_else_block =\n+            mk_sp(if_block.span.hi,\n+                  context.codemap.span_before(mk_sp(if_block.span.hi, else_block.span.lo), \"else\"));\n+        let between_if_else_block_comment =\n+            extract_comment(between_if_else_block, &context, offset, width);\n \n         let after_else = mk_sp(context.codemap\n                                    .span_after(mk_sp(if_block.span.hi, else_block.span.lo),\n@@ -927,11 +922,8 @@ fn rewrite_match_arm_comment(context: &RewriteContext,\n     }\n     let missed_str = missed_str[first..].trim();\n     if !missed_str.is_empty() {\n-        let comment = try_opt!(rewrite_comment(&missed_str,\n-                                               false,\n-                                               width,\n-                                               arm_indent,\n-                                               context.config));\n+        let comment =\n+            try_opt!(rewrite_comment(&missed_str, false, width, arm_indent, context.config));\n         result.push('\\n');\n         result.push_str(arm_indent_str);\n         result.push_str(&comment);\n@@ -1155,10 +1147,9 @@ impl Rewrite for ast::Arm {\n         let body_budget = try_opt!(width.checked_sub(context.config.tab_spaces));\n         let indent = context.block_indent.block_indent(context.config);\n         let inner_context = &RewriteContext { block_indent: indent, ..*context };\n-        let next_line_body = try_opt!(nop_block_collapse(body.rewrite(inner_context,\n-                                                                      body_budget,\n-                                                                      indent),\n-                                                         body_budget));\n+        let next_line_body =\n+            try_opt!(nop_block_collapse(body.rewrite(inner_context, body_budget, indent),\n+                                        body_budget));\n         let indent_str = offset.block_indent(context.config).to_string(context.config);\n         let (body_prefix, body_suffix) = if context.config.wrap_match_arms {\n             if context.config.match_block_trailing_comma {\n@@ -1762,6 +1753,21 @@ pub fn rewrite_unary_prefix<R: Rewrite>(context: &RewriteContext,\n         .map(|r| format!(\"{}{}\", prefix, r))\n }\n \n+// FIXME: this is probably not correct for multi-line Rewrites. we should\n+// subtract suffix.len() from the last line budget, not the first!\n+pub fn rewrite_unary_suffix<R: Rewrite>(context: &RewriteContext,\n+                                        suffix: &str,\n+                                        rewrite: &R,\n+                                        width: usize,\n+                                        offset: Indent)\n+                                        -> Option<String> {\n+    rewrite.rewrite(context, try_opt!(width.checked_sub(suffix.len())), offset)\n+        .map(|mut r| {\n+            r.push_str(suffix);\n+            r\n+        })\n+}\n+\n fn rewrite_unary_op(context: &RewriteContext,\n                     op: &ast::UnOp,\n                     expr: &ast::Expr,\n@@ -1817,24 +1823,42 @@ pub fn rewrite_assign_rhs<S: Into<String>>(context: &RewriteContext,\n     let max_width = try_opt!(width.checked_sub(last_line_width + 1));\n     let rhs = ex.rewrite(&context, max_width, offset + last_line_width + 1);\n \n+    fn count_line_breaks(src: &str) -> usize {\n+        src.chars().filter(|&x| x == '\\n').count()\n+    }\n+\n     match rhs {\n-        Some(new_str) => {\n+        Some(ref new_str) if count_line_breaks(new_str) < 2 => {\n             result.push(' ');\n-            result.push_str(&new_str)\n+            result.push_str(new_str);\n         }\n-        None => {\n-            // Expression did not fit on the same line as the identifier. Retry\n-            // on the next line.\n+        _ => {\n+            // Expression did not fit on the same line as the identifier or is\n+            // at least three lines big. Try splitting the line and see\n+            // if that works better.\n             let new_offset = offset.block_indent(context.config);\n-            result.push_str(&format!(\"\\n{}\", new_offset.to_string(context.config)));\n-\n-            // FIXME: we probably should related max_width to width instead of\n-            // config.max_width where is the 1 coming from anyway?\n-            let max_width = try_opt!(context.config.max_width.checked_sub(new_offset.width() + 1));\n+            let max_width = try_opt!((width + offset.width()).checked_sub(new_offset.width()));\n             let inner_context = context.nested_context();\n-            let rhs = ex.rewrite(&inner_context, max_width, new_offset);\n-\n-            result.push_str(&&try_opt!(rhs));\n+            let new_rhs = ex.rewrite(&inner_context, max_width, new_offset);\n+\n+            // FIXME: DRY!\n+            match (rhs, new_rhs) {\n+                (Some(ref orig_rhs), Some(ref replacement_rhs))\n+                    if count_line_breaks(orig_rhs) >\n+                       count_line_breaks(replacement_rhs) + 1 => {\n+                    result.push_str(&format!(\"\\n{}\", new_offset.to_string(context.config)));\n+                    result.push_str(replacement_rhs);\n+                }\n+                (None, Some(ref final_rhs)) => {\n+                    result.push_str(&format!(\"\\n{}\", new_offset.to_string(context.config)));\n+                    result.push_str(final_rhs);\n+                }\n+                (None, None) => return None,\n+                (Some(ref orig_rhs), _) => {\n+                    result.push(' ');\n+                    result.push_str(orig_rhs);\n+                }\n+            }\n         }\n     }\n "}, {"sha": "b4b200e8b051c70230cd04fc29919e032b82a3da", "filename": "src/items.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c1949f52e188c53facd799b1ef8ea57878ac697e/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1949f52e188c53facd799b1ef8ea57878ac697e/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=c1949f52e188c53facd799b1ef8ea57878ac697e", "patch": "@@ -66,11 +66,8 @@ impl Rewrite for ast::Local {\n             let budget = try_opt!(width.checked_sub(context.block_indent.width() + 1));\n \n             // 1 = trailing semicolon;\n-            result = try_opt!(rewrite_assign_rhs(&context,\n-                                                 result,\n-                                                 ex,\n-                                                 budget,\n-                                                 context.block_indent));\n+            result =\n+                try_opt!(rewrite_assign_rhs(&context, result, ex, budget, context.block_indent));\n         }\n \n         result.push(';');\n@@ -656,18 +653,17 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n \n         let has_body = !trait_items.is_empty();\n \n-        let where_density = if (context.config.where_density == Density::Compressed &&\n-                                (!result.contains('\\n') ||\n-                                 context.config.fn_args_layout == FnArgLayoutStyle::Block)) ||\n-                               (context.config.fn_args_layout == FnArgLayoutStyle::Block &&\n-                                result.is_empty()) ||\n-                               (context.config.where_density == Density::CompressedIfEmpty &&\n-                                !has_body &&\n-                                !result.contains('\\n')) {\n-            Density::Compressed\n-        } else {\n-            Density::Tall\n-        };\n+        let where_density =\n+            if (context.config.where_density == Density::Compressed &&\n+                (!result.contains('\\n') ||\n+                 context.config.fn_args_layout == FnArgLayoutStyle::Block)) ||\n+               (context.config.fn_args_layout == FnArgLayoutStyle::Block && result.is_empty()) ||\n+               (context.config.where_density == Density::CompressedIfEmpty && !has_body &&\n+                !result.contains('\\n')) {\n+                Density::Compressed\n+            } else {\n+                Density::Tall\n+            };\n \n         let where_budget = try_opt!(context.config\n             .max_width\n@@ -1134,9 +1130,8 @@ fn rewrite_explicit_self(explicit_self: &ast::ExplicitSelf,\n             let mut_str = format_mutability(m);\n             match lt {\n                 Some(ref l) => {\n-                    let lifetime_str = try_opt!(l.rewrite(context,\n-                                                          usize::max_value(),\n-                                                          Indent::empty()));\n+                    let lifetime_str =\n+                        try_opt!(l.rewrite(context, usize::max_value(), Indent::empty()));\n                     Some(format!(\"&{} {}self\", lifetime_str, mut_str))\n                 }\n                 None => Some(format!(\"&{}self\", mut_str)),"}, {"sha": "61ac2626e02e795c4551f3e2c94d2841ef34c8d2", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c1949f52e188c53facd799b1ef8ea57878ac697e/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1949f52e188c53facd799b1ef8ea57878ac697e/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=c1949f52e188c53facd799b1ef8ea57878ac697e", "patch": "@@ -403,11 +403,8 @@ pub fn format_input(input: Input, config: &Config) -> (Summary, FileMap, FormatR\n     let mut summary = Summary::new();\n     let codemap = Rc::new(CodeMap::new());\n \n-    let tty_handler = Handler::with_tty_emitter(ColorConfig::Auto,\n-                                                None,\n-                                                true,\n-                                                false,\n-                                                codemap.clone());\n+    let tty_handler =\n+        Handler::with_tty_emitter(ColorConfig::Auto, None, true, false, codemap.clone());\n     let mut parse_session = ParseSess::with_span_handler(tty_handler, codemap.clone());\n \n     let main_file = match input {"}, {"sha": "b35ccfe3d699a9597979d16192a0b94b494740bb", "filename": "src/lists.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c1949f52e188c53facd799b1ef8ea57878ac697e/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1949f52e188c53facd799b1ef8ea57878ac697e/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=c1949f52e188c53facd799b1ef8ea57878ac697e", "patch": "@@ -307,11 +307,8 @@ pub fn write_list<I, T>(items: I, formatting: &ListFormatting) -> Option<String>\n                               comment.trim().contains('\\n') ||\n                               comment.trim().len() > width;\n \n-            let formatted_comment = try_opt!(rewrite_comment(comment,\n-                                                             block_style,\n-                                                             width,\n-                                                             offset,\n-                                                             formatting.config));\n+            let formatted_comment =\n+                try_opt!(rewrite_comment(comment, block_style, width, offset, formatting.config));\n \n             result.push(' ');\n             result.push_str(&formatted_comment);"}, {"sha": "e9992fb0eb0134a76dfdc3e206ecba6fb096a0e9", "filename": "src/macros.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c1949f52e188c53facd799b1ef8ea57878ac697e/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1949f52e188c53facd799b1ef8ea57878ac697e/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=c1949f52e188c53facd799b1ef8ea57878ac697e", "patch": "@@ -25,7 +25,7 @@ use syntax::parse::tts_to_parser;\n use syntax::codemap::{mk_sp, BytePos};\n \n use Indent;\n-use rewrite::RewriteContext;\n+use rewrite::{Rewrite, RewriteContext};\n use expr::{rewrite_call, rewrite_array};\n use comment::{FindUncommented, contains_comment};\n use utils::{CodeMapSpanUtils, wrap_str};\n@@ -56,6 +56,12 @@ pub fn rewrite_macro(mac: &ast::Mac,\n                      width: usize,\n                      offset: Indent)\n                      -> Option<String> {\n+    if context.config.use_try_shorthand {\n+        if let Some(expr) = convert_try_mac(mac, context) {\n+            return expr.rewrite(context, width, offset);\n+        }\n+    }\n+\n     let original_style = macro_style(mac, context);\n     let macro_name = match extra_ident {\n         None |\n@@ -141,6 +147,24 @@ pub fn rewrite_macro(mac: &ast::Mac,\n     }\n }\n \n+/// Tries to convert a macro use into a short hand try expression. Returns None\n+/// when the macro is not an instance of try! (or parsing the inner expression\n+/// failed).\n+pub fn convert_try_mac(mac: &ast::Mac, context: &RewriteContext) -> Option<ast::Expr> {\n+    if &format!(\"{}\", mac.node.path)[..] == \"try\" {\n+        let mut parser = tts_to_parser(context.parse_session, mac.node.tts.clone(), Vec::new());\n+\n+        Some(ast::Expr {\n+            id: 0, // dummy value\n+            node: ast::ExprKind::Try(try_opt!(parser.parse_expr().ok())),\n+            span: mac.span, // incorrect span, but shouldn't matter too much\n+            attrs: None,\n+        })\n+    } else {\n+        None\n+    }\n+}\n+\n fn macro_style(mac: &ast::Mac, context: &RewriteContext) -> MacroStyle {\n     let snippet = context.snippet(mac.span);\n     let paren_pos = snippet.find_uncommented(\"(\").unwrap_or(usize::max_value());"}, {"sha": "4881ff76a995b97f1b01d9035daf0abcd631aa4b", "filename": "src/patterns.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1949f52e188c53facd799b1ef8ea57878ac697e/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1949f52e188c53facd799b1ef8ea57878ac697e/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=c1949f52e188c53facd799b1ef8ea57878ac697e", "patch": "@@ -144,10 +144,8 @@ impl Rewrite for Pat {\n                                          |f| f.node.rewrite(context, budget, offset),\n                                          context.codemap.span_after(self.span, \"{\"),\n                                          self.span.hi);\n-                let mut field_string = try_opt!(format_item_list(items,\n-                                                                 budget,\n-                                                                 offset,\n-                                                                 context.config));\n+                let mut field_string =\n+                    try_opt!(format_item_list(items, budget, offset, context.config));\n                 if elipses {\n                     if field_string.contains('\\n') {\n                         field_string.push_str(\",\\n\");"}, {"sha": "0ead12a9f984a026624faa623fe798a3f10c0021", "filename": "src/types.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c1949f52e188c53facd799b1ef8ea57878ac697e/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1949f52e188c53facd799b1ef8ea57878ac697e/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=c1949f52e188c53facd799b1ef8ea57878ac697e", "patch": "@@ -375,12 +375,8 @@ impl Rewrite for ast::WherePredicate {\n                 // 3 = \" = \".len()\n                 let used_width = 3 + ty_str.len();\n                 let budget = try_opt!(width.checked_sub(used_width));\n-                let path_str = try_opt!(rewrite_path(context,\n-                                                     false,\n-                                                     None,\n-                                                     path,\n-                                                     budget,\n-                                                     offset + used_width));\n+                let path_str =\n+                    try_opt!(rewrite_path(context, false, None, path, budget, offset + used_width));\n                 format!(\"{} = {}\", path_str, ty_str)\n             }\n         };\n@@ -538,9 +534,8 @@ impl Rewrite for ast::Ty {\n                 Some(match *lifetime {\n                     Some(ref lifetime) => {\n                         let lt_budget = try_opt!(width.checked_sub(2 + mut_len));\n-                        let lt_str = try_opt!(lifetime.rewrite(context,\n-                                                               lt_budget,\n-                                                               offset + 2 + mut_len));\n+                        let lt_str =\n+                            try_opt!(lifetime.rewrite(context, lt_budget, offset + 2 + mut_len));\n                         let lt_len = lt_str.len();\n                         let budget = try_opt!(width.checked_sub(2 + mut_len + lt_len));\n                         format!(\"&{} {}{}\","}, {"sha": "48de948865bc9e33a6b433becda813199c0ebe36", "filename": "tests/source/chains.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c1949f52e188c53facd799b1ef8ea57878ac697e/tests%2Fsource%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1949f52e188c53facd799b1ef8ea57878ac697e/tests%2Fsource%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fchains.rs?ref=c1949f52e188c53facd799b1ef8ea57878ac697e", "patch": "@@ -112,3 +112,16 @@ fn issue587() {\n \n     std::mem::transmute(dl.symbol::<()>(\"init\").unwrap())\n }\n+\n+fn try_shorthand() {\n+    let x = expr?;\n+    let y = expr.kaas()?.test();\n+    let loooooooooooooooooooooooooooooooooooooooooong = does_this?.look?.good?.should_we_break?.after_the_first_question_mark?;\n+    let yyyy = expr?.another?.another?.another?.another?.another?.another?.another?.another?.test();\n+    let zzzz = expr?.another?.another?.another?.another?;\n+    let aaa =  x ????????????  ?????????????? ???? ?????  ?????????????? ?????????  ?????????????? ??;\n+\n+    let y = a.very .loooooooooooooooooooooooooooooooooooooong()  .chain()\n+             .inside()          .weeeeeeeeeeeeeee()? .test()  .0\n+        .x;\n+}"}, {"sha": "40fd3309a4cbb10837630920965d26c4a8a04317", "filename": "tests/source/expr.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c1949f52e188c53facd799b1ef8ea57878ac697e/tests%2Fsource%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1949f52e188c53facd799b1ef8ea57878ac697e/tests%2Fsource%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fexpr.rs?ref=c1949f52e188c53facd799b1ef8ea57878ac697e", "patch": "@@ -249,7 +249,6 @@ fn ranges() {\n     let x = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa .. bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb;\n     let y = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa ... bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb;\n     let z = ... x ;\n-    let infi_range_2 = ... ;\n \n     a ... b\n "}, {"sha": "2f9c19086ff177a44c66b983d94f598254d0810d", "filename": "tests/source/single-line-if-else.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1949f52e188c53facd799b1ef8ea57878ac697e/tests%2Fsource%2Fsingle-line-if-else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1949f52e188c53facd799b1ef8ea57878ac697e/tests%2Fsource%2Fsingle-line-if-else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fsingle-line-if-else.rs?ref=c1949f52e188c53facd799b1ef8ea57878ac697e", "patch": "@@ -36,7 +36,7 @@ fn main() {\n         do_something()\n     }\n \n-    let x = if veeeeeeeeery_loooooong_condition() { aaaaaaaaaaaaaaaaaaaaaaaaaaa } else { bbbbbbbbbb };\n+    let x = if veeeeeeeeery_loooooong_condition() { aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa } else { bbbbbbbbbb };\n   \n     let x = if veeeeeeeeery_loooooong_condition()     {    aaaaaaaaaaaaaaaaaaaaaaaaa }   else  {\n         bbbbbbbbbb };"}, {"sha": "c19df093176dc07a54d8ee126978e29b5086b496", "filename": "tests/source/string-lit-2.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1949f52e188c53facd799b1ef8ea57878ac697e/tests%2Fsource%2Fstring-lit-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1949f52e188c53facd799b1ef8ea57878ac697e/tests%2Fsource%2Fstring-lit-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fstring-lit-2.rs?ref=c1949f52e188c53facd799b1ef8ea57878ac697e", "patch": "@@ -1,9 +1,5 @@\n fn main() -> &'static str {\n-    let too_many_lines = \"H\\\n-                          e\\\n-                          l\\\n-                          l\\\n-                          o\";\n+    let too_many_lines = \"Hello\";\n     let leave_me = \"sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss\\\n                     s\n                     jjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj\";"}, {"sha": "addf2f5d5e8fa1a31fe2d92635a21a038a7dc7ba", "filename": "tests/source/try-conversion.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c1949f52e188c53facd799b1ef8ea57878ac697e/tests%2Fsource%2Ftry-conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1949f52e188c53facd799b1ef8ea57878ac697e/tests%2Fsource%2Ftry-conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Ftry-conversion.rs?ref=c1949f52e188c53facd799b1ef8ea57878ac697e", "patch": "@@ -0,0 +1,11 @@\n+// rustfmt-use_try_shorthand: true\n+\n+fn main() {\n+    let x = try!(some_expr());\n+\n+    let y = try!(a.very.loooooooooooooooooooooooooooooooooooooong().chain().inside().weeeeeeeeeeeeeee()).test().0.x;\n+}\n+\n+fn test() {\n+    a?\n+}"}, {"sha": "7d25046279f61299e07abf456744b7aac37370ec", "filename": "tests/target/chains.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c1949f52e188c53facd799b1ef8ea57878ac697e/tests%2Ftarget%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1949f52e188c53facd799b1ef8ea57878ac697e/tests%2Ftarget%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fchains.rs?ref=c1949f52e188c53facd799b1ef8ea57878ac697e", "patch": "@@ -133,3 +133,22 @@ fn issue587() {\n \n     std::mem::transmute(dl.symbol::<()>(\"init\").unwrap())\n }\n+\n+fn try_shorthand() {\n+    let x = expr?;\n+    let y = expr.kaas()?.test();\n+    let loooooooooooooooooooooooooooooooooooooooooong =\n+        does_this?.look?.good?.should_we_break?.after_the_first_question_mark?;\n+    let yyyy = expr?.another?.another?.another?.another?.another?.another?.another?.another?.test();\n+    let zzzz = expr?.another?.another?.another?.another?;\n+    let aaa = x??????????????????????????????????????????????????????????????????????????;\n+\n+    let y = a.very\n+        .loooooooooooooooooooooooooooooooooooooong()\n+        .chain()\n+        .inside()\n+        .weeeeeeeeeeeeeee()?\n+        .test()\n+        .0\n+        .x;\n+}"}, {"sha": "8fe290b955a08d262502c26f7e7a469b903c6681", "filename": "tests/target/closure.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c1949f52e188c53facd799b1ef8ea57878ac697e/tests%2Ftarget%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1949f52e188c53facd799b1ef8ea57878ac697e/tests%2Ftarget%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fclosure.rs?ref=c1949f52e188c53facd799b1ef8ea57878ac697e", "patch": "@@ -46,23 +46,18 @@ fn main() {\n         do_something_else();\n     };\n \n-    let arg_test = |big_argument_name, test123| {\n-        looooooooooooooooooong_function_naaaaaaaaaaaaaaaaame()\n-    };\n+    let arg_test =\n+        |big_argument_name, test123| looooooooooooooooooong_function_naaaaaaaaaaaaaaaaame();\n \n-    let arg_test = |big_argument_name, test123| {\n-        looooooooooooooooooong_function_naaaaaaaaaaaaaaaaame()\n-    };\n+    let arg_test =\n+        |big_argument_name, test123| looooooooooooooooooong_function_naaaaaaaaaaaaaaaaame();\n \n     let simple_closure = move || -> () {};\n \n     let closure = |input: Ty| -> Option<String> { foo() };\n \n-    let closure_with_return_type = |aaaaaaaaaaaaaaaaaaaaaaarg1,\n-                                    aaaaaaaaaaaaaaaaaaaaaaarg2|\n-                                    -> Strong {\n-        \"sup\".to_owned()\n-    };\n+    let closure_with_return_type =\n+        |aaaaaaaaaaaaaaaaaaaaaaarg1, aaaaaaaaaaaaaaaaaaaaaaarg2| -> Strong { \"sup\".to_owned() };\n \n     |arg1, arg2, _, _, arg3, arg4| {\n         let temp = arg4 + arg3;"}, {"sha": "1378b4bf8f8da749bc1c7974f1c644f39f1a672d", "filename": "tests/target/expr.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c1949f52e188c53facd799b1ef8ea57878ac697e/tests%2Ftarget%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1949f52e188c53facd799b1ef8ea57878ac697e/tests%2Ftarget%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fexpr.rs?ref=c1949f52e188c53facd799b1ef8ea57878ac697e", "patch": "@@ -202,10 +202,8 @@ fn arrays() {\n                                           item: 3,\n                                       }]);\n \n-    let z = [xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,\n-             yyyyyyyyyyyyyyyyyyyyyyyyyyy,\n-             zzzzzzzzzzzzzzzzzz,\n-             q];\n+    let z =\n+        [xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, yyyyyyyyyyyyyyyyyyyyyyyyyyy, zzzzzzzzzzzzzzzzzz, q];\n \n     [1 + 3, 4, 5, 6, 7, 7, fncall::<Vec<_>>(3 - 1)]\n }\n@@ -273,7 +271,6 @@ fn ranges() {\n     let y =\n         aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb;\n     let z = ...x;\n-    let infi_range_2 = ...;\n \n     a...b\n "}, {"sha": "1e00559b3f342d7f7a8afe2465614c5172bcd13d", "filename": "tests/target/hard-tabs.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1949f52e188c53facd799b1ef8ea57878ac697e/tests%2Ftarget%2Fhard-tabs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1949f52e188c53facd799b1ef8ea57878ac697e/tests%2Ftarget%2Fhard-tabs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fhard-tabs.rs?ref=c1949f52e188c53facd799b1ef8ea57878ac697e", "patch": "@@ -55,10 +55,8 @@ fn main() {\n \t\t.go_to_next_line_with_tab()\n \t\t.go_to_next_line_with_tab();\n \n-\tlet z = [xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx,\n-\t         yyyyyyyyyyyyyyyyyyyyyyyyyyy,\n-\t         zzzzzzzzzzzzzzzzzz,\n-\t         q];\n+\tlet z =\n+\t\t[xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx, yyyyyyyyyyyyyyyyyyyyyyyyyyy, zzzzzzzzzzzzzzzzzz, q];\n \n \tfn generic<T>(arg: T) -> &SomeType\n \t\twhere T: Fn(// First arg"}, {"sha": "ec4daa727a61dbcbec1abe698a185213812493ed", "filename": "tests/target/single-line-if-else.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1949f52e188c53facd799b1ef8ea57878ac697e/tests%2Ftarget%2Fsingle-line-if-else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1949f52e188c53facd799b1ef8ea57878ac697e/tests%2Ftarget%2Fsingle-line-if-else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fsingle-line-if-else.rs?ref=c1949f52e188c53facd799b1ef8ea57878ac697e", "patch": "@@ -41,7 +41,7 @@ fn main() {\n     }\n \n     let x = if veeeeeeeeery_loooooong_condition() {\n-        aaaaaaaaaaaaaaaaaaaaaaaaaaa\n+        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n     } else {\n         bbbbbbbbbb\n     };"}, {"sha": "f2421c1444cdfd48a6d21fbc4b1b2d9d2113ede5", "filename": "tests/target/static.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c1949f52e188c53facd799b1ef8ea57878ac697e/tests%2Ftarget%2Fstatic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1949f52e188c53facd799b1ef8ea57878ac697e/tests%2Ftarget%2Fstatic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fstatic.rs?ref=c1949f52e188c53facd799b1ef8ea57878ac697e", "patch": "@@ -1,13 +1,11 @@\n const FILE_GENERIC_READ: DWORD = STANDARD_RIGHTS_READ | FILE_READ_DATA | FILE_READ_ATTRIBUTES |\n                                  FILE_READ_EA | SYNCHRONIZE;\n \n-static boolnames: &'static [&'static str] = &[\"bw\", \"am\", \"xsb\", \"xhp\", \"xenl\", \"eo\", \"gn\", \"hc\",\n-                                              \"km\", \"hs\", \"in\", \"db\", \"da\", \"mir\", \"msgr\", \"os\",\n-                                              \"eslok\", \"xt\", \"hz\", \"ul\", \"xon\", \"nxon\", \"mc5i\",\n-                                              \"chts\", \"nrrmc\", \"npc\", \"ndscr\", \"ccc\", \"bce\",\n-                                              \"hls\", \"xhpa\", \"crxm\", \"daisy\", \"xvpa\", \"sam\",\n-                                              \"cpix\", \"lpix\", \"OTbs\", \"OTns\", \"OTnc\", \"OTMT\",\n-                                              \"OTNL\", \"OTpt\", \"OTxr\"];\n+static boolnames: &'static [&'static str] =\n+    &[\"bw\", \"am\", \"xsb\", \"xhp\", \"xenl\", \"eo\", \"gn\", \"hc\", \"km\", \"hs\", \"in\", \"db\", \"da\", \"mir\",\n+      \"msgr\", \"os\", \"eslok\", \"xt\", \"hz\", \"ul\", \"xon\", \"nxon\", \"mc5i\", \"chts\", \"nrrmc\", \"npc\",\n+      \"ndscr\", \"ccc\", \"bce\", \"hls\", \"xhpa\", \"crxm\", \"daisy\", \"xvpa\", \"sam\", \"cpix\", \"lpix\",\n+      \"OTbs\", \"OTns\", \"OTnc\", \"OTMT\", \"OTNL\", \"OTpt\", \"OTxr\"];\n \n static mut name: SomeType =\n     aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa;"}, {"sha": "7deb4215d2e59b4720b9a50b55224795ede8c43a", "filename": "tests/target/string-lit-2.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1949f52e188c53facd799b1ef8ea57878ac697e/tests%2Ftarget%2Fstring-lit-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1949f52e188c53facd799b1ef8ea57878ac697e/tests%2Ftarget%2Fstring-lit-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fstring-lit-2.rs?ref=c1949f52e188c53facd799b1ef8ea57878ac697e", "patch": "@@ -1,9 +1,5 @@\n fn main() -> &'static str {\n-    let too_many_lines = \"H\\\n-                          e\\\n-                          l\\\n-                          l\\\n-                          o\";\n+    let too_many_lines = \"Hello\";\n     let leave_me = \"sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss\\\n                     s\n                     jjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj\";"}, {"sha": "d4422cf9621412e8b12de8096ad87607006723ae", "filename": "tests/target/try-conversion.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c1949f52e188c53facd799b1ef8ea57878ac697e/tests%2Ftarget%2Ftry-conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1949f52e188c53facd799b1ef8ea57878ac697e/tests%2Ftarget%2Ftry-conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Ftry-conversion.rs?ref=c1949f52e188c53facd799b1ef8ea57878ac697e", "patch": "@@ -0,0 +1,18 @@\n+// rustfmt-use_try_shorthand: true\n+\n+fn main() {\n+    let x = some_expr()?;\n+\n+    let y = a.very\n+        .loooooooooooooooooooooooooooooooooooooong()\n+        .chain()\n+        .inside()\n+        .weeeeeeeeeeeeeee()?\n+        .test()\n+        .0\n+        .x;\n+}\n+\n+fn test() {\n+    a?\n+}"}, {"sha": "de8d97d7b676aea7b9c35bacfd779bcbccfdc9e6", "filename": "tests/target/type-ascription.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c1949f52e188c53facd799b1ef8ea57878ac697e/tests%2Ftarget%2Ftype-ascription.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1949f52e188c53facd799b1ef8ea57878ac697e/tests%2Ftarget%2Ftype-ascription.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Ftype-ascription.rs?ref=c1949f52e188c53facd799b1ef8ea57878ac697e", "patch": "@@ -1,7 +1,6 @@\n fn main() {\n-    let xxxxxxxxxxx = yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy: SomeTrait<AA,\n-                                                                                              BB,\n-                                                                                              CC>;\n+    let xxxxxxxxxxx =\n+        yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy: SomeTrait<AA, BB, CC>;\n \n     let xxxxxxxxxxxxxxx =\n         yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;"}]}