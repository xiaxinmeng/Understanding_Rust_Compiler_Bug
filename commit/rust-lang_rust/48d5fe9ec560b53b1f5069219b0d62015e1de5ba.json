{"sha": "48d5fe9ec560b53b1f5069219b0d62015e1de5ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4ZDVmZTllYzU2MGI1M2IxZjUwNjkyMTliMGQ2MjAxNWUxZGU1YmE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-03-11T19:01:46Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-03-22T17:25:30Z"}, "message": "std: Change `encode_utf{8,16}` to return iterators\n\nCurrently these have non-traditional APIs which take a buffer and report how\nmuch was filled in, but they're not necessarily ergonomic to use. Returning an\niterator which *also* exposes an underlying slice shouldn't result in any\nperformance loss as it's just a lazy version of the same implementation, and\nit's also much more ergonomic!\n\ncc #27784", "tree": {"sha": "94f12e261a6d8513968aee2ad8cbb965fdecdf86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94f12e261a6d8513968aee2ad8cbb965fdecdf86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48d5fe9ec560b53b1f5069219b0d62015e1de5ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48d5fe9ec560b53b1f5069219b0d62015e1de5ba", "html_url": "https://github.com/rust-lang/rust/commit/48d5fe9ec560b53b1f5069219b0d62015e1de5ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48d5fe9ec560b53b1f5069219b0d62015e1de5ba/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7bdfd4442f0bde3412f08336f75b9eabff4a938", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7bdfd4442f0bde3412f08336f75b9eabff4a938", "html_url": "https://github.com/rust-lang/rust/commit/c7bdfd4442f0bde3412f08336f75b9eabff4a938"}], "stats": {"total": 396, "additions": 195, "deletions": 201}, "files": [{"sha": "d2432a4b032261a045c8bb587262af89a9e24fb6", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/48d5fe9ec560b53b1f5069219b0d62015e1de5ba/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d5fe9ec560b53b1f5069219b0d62015e1de5ba/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=48d5fe9ec560b53b1f5069219b0d62015e1de5ba", "patch": "@@ -61,7 +61,6 @@ use core::iter::FromIterator;\n use core::mem;\n use core::ops::{self, Add, Index, IndexMut};\n use core::ptr;\n-use core::slice;\n use core::str::pattern::Pattern;\n use rustc_unicode::char::{decode_utf16, REPLACEMENT_CHARACTER};\n use rustc_unicode::str as unicode_str;\n@@ -970,22 +969,7 @@ impl String {\n     pub fn push(&mut self, ch: char) {\n         match ch.len_utf8() {\n             1 => self.vec.push(ch as u8),\n-            ch_len => {\n-                let cur_len = self.len();\n-                // This may use up to 4 bytes.\n-                self.vec.reserve(ch_len);\n-\n-                unsafe {\n-                    // Attempt to not use an intermediate buffer by just pushing bytes\n-                    // directly onto this string.\n-                    let slice = slice::from_raw_parts_mut(self.vec\n-                                                              .as_mut_ptr()\n-                                                              .offset(cur_len as isize),\n-                                                          ch_len);\n-                    let used = ch.encode_utf8(slice).unwrap_or(0);\n-                    self.vec.set_len(cur_len + used);\n-                }\n-            }\n+            _ => self.vec.extend_from_slice(ch.encode_utf8().as_slice()),\n         }\n     }\n \n@@ -1136,9 +1120,10 @@ impl String {\n         let len = self.len();\n         assert!(idx <= len);\n         assert!(self.is_char_boundary(idx));\n-        self.vec.reserve(4);\n-        let mut bits = [0; 4];\n-        let amt = ch.encode_utf8(&mut bits).unwrap();\n+        let bits = ch.encode_utf8();\n+        let bits = bits.as_slice();\n+        let amt = bits.len();\n+        self.vec.reserve(amt);\n \n         unsafe {\n             ptr::copy(self.vec.as_ptr().offset(idx as isize),"}, {"sha": "1150035eb425545775063fb2b49ad7a24b1fa0e2", "filename": "src/libcollectionstest/str.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/48d5fe9ec560b53b1f5069219b0d62015e1de5ba/src%2Flibcollectionstest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d5fe9ec560b53b1f5069219b0d62015e1de5ba/src%2Flibcollectionstest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstr.rs?ref=48d5fe9ec560b53b1f5069219b0d62015e1de5ba", "patch": "@@ -794,10 +794,9 @@ fn test_rev_iterator() {\n \n #[test]\n fn test_chars_decoding() {\n-    let mut bytes = [0; 4];\n     for c in (0..0x110000).filter_map(::std::char::from_u32) {\n-        let len = c.encode_utf8(&mut bytes).unwrap_or(0);\n-        let s = ::std::str::from_utf8(&bytes[..len]).unwrap();\n+        let bytes = c.encode_utf8();\n+        let s = ::std::str::from_utf8(bytes.as_slice()).unwrap();\n         if Some(c) != s.chars().next() {\n             panic!(\"character {:x}={} does not decode correctly\", c as u32, c);\n         }\n@@ -806,10 +805,9 @@ fn test_chars_decoding() {\n \n #[test]\n fn test_chars_rev_decoding() {\n-    let mut bytes = [0; 4];\n     for c in (0..0x110000).filter_map(::std::char::from_u32) {\n-        let len = c.encode_utf8(&mut bytes).unwrap_or(0);\n-        let s = ::std::str::from_utf8(&bytes[..len]).unwrap();\n+        let bytes = c.encode_utf8();\n+        let s = ::std::str::from_utf8(bytes.as_slice()).unwrap();\n         if Some(c) != s.chars().rev().next() {\n             panic!(\"character {:x}={} does not decode correctly\", c as u32, c);\n         }"}, {"sha": "b2b1dc5178e2e1aa0b18cf014e72a8f3a44e0686", "filename": "src/libcore/char.rs", "status": "modified", "additions": 119, "deletions": 70, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/48d5fe9ec560b53b1f5069219b0d62015e1de5ba/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d5fe9ec560b53b1f5069219b0d62015e1de5ba/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=48d5fe9ec560b53b1f5069219b0d62015e1de5ba", "patch": "@@ -269,10 +269,10 @@ pub trait CharExt {\n     fn len_utf8(self) -> usize;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn len_utf16(self) -> usize;\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn encode_utf8(self, dst: &mut [u8]) -> Option<usize>;\n-    #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn encode_utf16(self, dst: &mut [u16]) -> Option<usize>;\n+    #[unstable(feature = \"unicode\", issue = \"27784\")]\n+    fn encode_utf8(self) -> EncodeUtf8;\n+    #[unstable(feature = \"unicode\", issue = \"27784\")]\n+    fn encode_utf16(self) -> EncodeUtf16;\n }\n \n #[stable(feature = \"core\", since = \"1.6.0\")]\n@@ -336,75 +336,47 @@ impl CharExt for char {\n     }\n \n     #[inline]\n-    fn encode_utf8(self, dst: &mut [u8]) -> Option<usize> {\n-        encode_utf8_raw(self as u32, dst)\n+    fn encode_utf8(self) -> EncodeUtf8 {\n+        let code = self as u32;\n+        let mut buf = [0; 4];\n+        let pos = if code < MAX_ONE_B {\n+            buf[3] = code as u8;\n+            3\n+        } else if code < MAX_TWO_B {\n+            buf[2] = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;\n+            buf[3] = (code & 0x3F) as u8 | TAG_CONT;\n+            2\n+        } else if code < MAX_THREE_B {\n+            buf[1] = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;\n+            buf[2] = (code >>  6 & 0x3F) as u8 | TAG_CONT;\n+            buf[3] = (code & 0x3F) as u8 | TAG_CONT;\n+            1\n+        } else {\n+            buf[0] = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;\n+            buf[1] = (code >> 12 & 0x3F) as u8 | TAG_CONT;\n+            buf[2] = (code >>  6 & 0x3F) as u8 | TAG_CONT;\n+            buf[3] = (code & 0x3F) as u8 | TAG_CONT;\n+            0\n+        };\n+        EncodeUtf8 { buf: buf, pos: pos }\n     }\n \n     #[inline]\n-    fn encode_utf16(self, dst: &mut [u16]) -> Option<usize> {\n-        encode_utf16_raw(self as u32, dst)\n-    }\n-}\n-\n-/// Encodes a raw u32 value as UTF-8 into the provided byte buffer,\n-/// and then returns the number of bytes written.\n-///\n-/// If the buffer is not large enough, nothing will be written into it\n-/// and a `None` will be returned.\n-#[inline]\n-#[unstable(feature = \"char_internals\",\n-           reason = \"this function should not be exposed publicly\",\n-           issue = \"0\")]\n-#[doc(hidden)]\n-pub fn encode_utf8_raw(code: u32, dst: &mut [u8]) -> Option<usize> {\n-    // Marked #[inline] to allow llvm optimizing it away\n-    if code < MAX_ONE_B && !dst.is_empty() {\n-        dst[0] = code as u8;\n-        Some(1)\n-    } else if code < MAX_TWO_B && dst.len() >= 2 {\n-        dst[0] = (code >> 6 & 0x1F) as u8 | TAG_TWO_B;\n-        dst[1] = (code & 0x3F) as u8 | TAG_CONT;\n-        Some(2)\n-    } else if code < MAX_THREE_B && dst.len() >= 3  {\n-        dst[0] = (code >> 12 & 0x0F) as u8 | TAG_THREE_B;\n-        dst[1] = (code >>  6 & 0x3F) as u8 | TAG_CONT;\n-        dst[2] = (code & 0x3F) as u8 | TAG_CONT;\n-        Some(3)\n-    } else if dst.len() >= 4 {\n-        dst[0] = (code >> 18 & 0x07) as u8 | TAG_FOUR_B;\n-        dst[1] = (code >> 12 & 0x3F) as u8 | TAG_CONT;\n-        dst[2] = (code >>  6 & 0x3F) as u8 | TAG_CONT;\n-        dst[3] = (code & 0x3F) as u8 | TAG_CONT;\n-        Some(4)\n-    } else {\n-        None\n-    }\n-}\n-\n-/// Encodes a raw u32 value as UTF-16 into the provided `u16` buffer,\n-/// and then returns the number of `u16`s written.\n-///\n-/// If the buffer is not large enough, nothing will be written into it\n-/// and a `None` will be returned.\n-#[inline]\n-#[unstable(feature = \"char_internals\",\n-           reason = \"this function should not be exposed publicly\",\n-           issue = \"0\")]\n-#[doc(hidden)]\n-pub fn encode_utf16_raw(mut ch: u32, dst: &mut [u16]) -> Option<usize> {\n-    // Marked #[inline] to allow llvm optimizing it away\n-    if (ch & 0xFFFF) == ch && !dst.is_empty() {\n-        // The BMP falls through (assuming non-surrogate, as it should)\n-        dst[0] = ch as u16;\n-        Some(1)\n-    } else if dst.len() >= 2 {\n-        // Supplementary planes break into surrogates.\n-        ch -= 0x1_0000;\n-        dst[0] = 0xD800 | ((ch >> 10) as u16);\n-        dst[1] = 0xDC00 | ((ch as u16) & 0x3FF);\n-        Some(2)\n-    } else {\n-        None\n+    fn encode_utf16(self) -> EncodeUtf16 {\n+        let mut buf = [0; 2];\n+        let mut code = self as u32;\n+        let pos = if (code & 0xFFFF) == code {\n+            // The BMP falls through (assuming non-surrogate, as it should)\n+            buf[1] = code as u16;\n+            1\n+        } else {\n+            // Supplementary planes break into surrogates.\n+            code -= 0x1_0000;\n+            buf[0] = 0xD800 | ((code >> 10) as u16);\n+            buf[1] = 0xDC00 | ((code as u16) & 0x3FF);\n+            0\n+        };\n+        EncodeUtf16 { buf: buf, pos: pos }\n     }\n }\n \n@@ -583,3 +555,80 @@ impl Iterator for EscapeDefault {\n         }\n     }\n }\n+\n+/// An iterator over `u8` entries represending the UTF-8 encoding of a `char`\n+/// value.\n+///\n+/// Constructed via the `.encode_utf8()` method on `char`.\n+#[unstable(feature = \"unicode\", issue = \"27784\")]\n+#[derive(Debug)]\n+pub struct EncodeUtf8 {\n+    buf: [u8; 4],\n+    pos: usize,\n+}\n+\n+impl EncodeUtf8 {\n+    /// Returns the remaining bytes of this iterator as a slice.\n+    #[unstable(feature = \"unicode\", issue = \"27784\")]\n+    pub fn as_slice(&self) -> &[u8] {\n+        &self.buf[self.pos..]\n+    }\n+}\n+\n+#[unstable(feature = \"unicode\", issue = \"27784\")]\n+impl Iterator for EncodeUtf8 {\n+    type Item = u8;\n+\n+    fn next(&mut self) -> Option<u8> {\n+        if self.pos == self.buf.len() {\n+            None\n+        } else {\n+            let ret = Some(self.buf[self.pos]);\n+            self.pos += 1;\n+            ret\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.as_slice().iter().size_hint()\n+    }\n+}\n+\n+/// An iterator over `u16` entries represending the UTF-16 encoding of a `char`\n+/// value.\n+///\n+/// Constructed via the `.encode_utf16()` method on `char`.\n+#[unstable(feature = \"unicode\", issue = \"27784\")]\n+#[derive(Debug)]\n+pub struct EncodeUtf16 {\n+    buf: [u16; 2],\n+    pos: usize,\n+}\n+\n+impl EncodeUtf16 {\n+    /// Returns the remaining bytes of this iterator as a slice.\n+    #[unstable(feature = \"unicode\", issue = \"27784\")]\n+    pub fn as_slice(&self) -> &[u16] {\n+        &self.buf[self.pos..]\n+    }\n+}\n+\n+\n+#[unstable(feature = \"unicode\", issue = \"27784\")]\n+impl Iterator for EncodeUtf16 {\n+    type Item = u16;\n+\n+    fn next(&mut self) -> Option<u16> {\n+        if self.pos == self.buf.len() {\n+            None\n+        } else {\n+            let ret = Some(self.buf[self.pos]);\n+            self.pos += 1;\n+            ret\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.as_slice().iter().size_hint()\n+    }\n+}"}, {"sha": "5617b6d63a7f995ad05d653cc122d61d1502d24e", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/48d5fe9ec560b53b1f5069219b0d62015e1de5ba/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d5fe9ec560b53b1f5069219b0d62015e1de5ba/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=48d5fe9ec560b53b1f5069219b0d62015e1de5ba", "patch": "@@ -99,9 +99,9 @@ pub trait Write {\n     /// This function will return an instance of `Error` on error.\n     #[stable(feature = \"fmt_write_char\", since = \"1.1.0\")]\n     fn write_char(&mut self, c: char) -> Result {\n-        let mut utf_8 = [0u8; 4];\n-        let bytes_written = c.encode_utf8(&mut utf_8).unwrap_or(0);\n-        self.write_str(unsafe { str::from_utf8_unchecked(&utf_8[..bytes_written]) })\n+        self.write_str(unsafe {\n+            str::from_utf8_unchecked(c.encode_utf8().as_slice())\n+        })\n     }\n \n     /// Glue for usage of the `write!` macro with implementors of this trait.\n@@ -897,10 +897,9 @@ impl<'a> Formatter<'a> {\n         // Writes the sign if it exists, and then the prefix if it was requested\n         let write_prefix = |f: &mut Formatter| {\n             if let Some(c) = sign {\n-                let mut b = [0; 4];\n-                let n = c.encode_utf8(&mut b).unwrap_or(0);\n-                let b = unsafe { str::from_utf8_unchecked(&b[..n]) };\n-                try!(f.buf.write_str(b));\n+                try!(f.buf.write_str(unsafe {\n+                    str::from_utf8_unchecked(c.encode_utf8().as_slice())\n+                }));\n             }\n             if prefixed { f.buf.write_str(prefix) }\n             else { Ok(()) }\n@@ -1003,9 +1002,10 @@ impl<'a> Formatter<'a> {\n             rt::v1::Alignment::Center => (padding / 2, (padding + 1) / 2),\n         };\n \n-        let mut fill = [0; 4];\n-        let len = self.fill.encode_utf8(&mut fill).unwrap_or(0);\n-        let fill = unsafe { str::from_utf8_unchecked(&fill[..len]) };\n+        let fill = self.fill.encode_utf8();\n+        let fill = unsafe {\n+            str::from_utf8_unchecked(fill.as_slice())\n+        };\n \n         for _ in 0..pre_pad {\n             try!(self.buf.write_str(fill));\n@@ -1391,10 +1391,9 @@ impl Display for char {\n         if f.width.is_none() && f.precision.is_none() {\n             f.write_char(*self)\n         } else {\n-            let mut utf8 = [0; 4];\n-            let amt = self.encode_utf8(&mut utf8).unwrap_or(0);\n-            let s: &str = unsafe { str::from_utf8_unchecked(&utf8[..amt]) };\n-            f.pad(s)\n+            f.pad(unsafe {\n+                str::from_utf8_unchecked(self.encode_utf8().as_slice())\n+            })\n         }\n     }\n }"}, {"sha": "ba8918fc6cb4528742e96e4534c4f2fb27d35c96", "filename": "src/libcoretest/char.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/48d5fe9ec560b53b1f5069219b0d62015e1de5ba/src%2Flibcoretest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d5fe9ec560b53b1f5069219b0d62015e1de5ba/src%2Flibcoretest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fchar.rs?ref=48d5fe9ec560b53b1f5069219b0d62015e1de5ba", "patch": "@@ -175,9 +175,10 @@ fn test_escape_unicode() {\n #[test]\n fn test_encode_utf8() {\n     fn check(input: char, expect: &[u8]) {\n-        let mut buf = [0; 4];\n-        let n = input.encode_utf8(&mut buf).unwrap_or(0);\n-        assert_eq!(&buf[..n], expect);\n+        assert_eq!(input.encode_utf8().as_slice(), expect);\n+        for (a, b) in input.encode_utf8().zip(expect) {\n+            assert_eq!(a, *b);\n+        }\n     }\n \n     check('x', &[0x78]);\n@@ -189,9 +190,10 @@ fn test_encode_utf8() {\n #[test]\n fn test_encode_utf16() {\n     fn check(input: char, expect: &[u16]) {\n-        let mut buf = [0; 2];\n-        let n = input.encode_utf16(&mut buf).unwrap_or(0);\n-        assert_eq!(&buf[..n], expect);\n+        assert_eq!(input.encode_utf16().as_slice(), expect);\n+        for (a, b) in input.encode_utf16().zip(expect) {\n+            assert_eq!(a, *b);\n+        }\n     }\n \n     check('x', &[0x0078]);"}, {"sha": "e2440227cf44bf59574f7fd3e48b95f9e6129803", "filename": "src/librustc_unicode/char.rs", "status": "modified", "additions": 25, "deletions": 57, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/48d5fe9ec560b53b1f5069219b0d62015e1de5ba/src%2Flibrustc_unicode%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d5fe9ec560b53b1f5069219b0d62015e1de5ba/src%2Flibrustc_unicode%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Fchar.rs?ref=48d5fe9ec560b53b1f5069219b0d62015e1de5ba", "patch": "@@ -35,7 +35,9 @@ use tables::{derived_property, property, general_category, conversions};\n \n // stable reexports\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::char::{MAX, from_u32, from_u32_unchecked, from_digit, EscapeUnicode, EscapeDefault};\n+pub use core::char::{MAX, from_u32, from_u32_unchecked, from_digit};\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core::char::{EscapeUnicode, EscapeDefault, EncodeUtf8, EncodeUtf16};\n \n // unstable reexports\n #[unstable(feature = \"unicode\", issue = \"27783\")]\n@@ -408,84 +410,50 @@ impl char {\n         C::len_utf16(self)\n     }\n \n-    /// Encodes this character as UTF-8 into the provided byte buffer, and then\n-    /// returns the number of bytes written.\n+    /// Returns an interator over the bytes of this character as UTF-8.\n     ///\n-    /// If the buffer is not large enough, nothing will be written into it and a\n-    /// `None` will be returned. A buffer of length four is large enough to\n-    /// encode any `char`.\n+    /// The returned iterator also has an `as_slice()` method to view the\n+    /// encoded bytes as a byte slice.\n     ///\n     /// # Examples\n     ///\n-    /// In both of these examples, '\u00df' takes two bytes to encode.\n-    ///\n     /// ```\n     /// #![feature(unicode)]\n     ///\n-    /// let mut b = [0; 2];\n+    /// let iterator = '\u00df'.encode_utf8();\n+    /// assert_eq!(iterator.as_slice(), [0xc3, 0x9f]);\n     ///\n-    /// let result = '\u00df'.encode_utf8(&mut b);\n-    ///\n-    /// assert_eq!(result, Some(2));\n-    /// ```\n-    ///\n-    /// A buffer that's too small:\n-    ///\n-    /// ```\n-    /// #![feature(unicode)]\n-    ///\n-    /// let mut b = [0; 1];\n-    ///\n-    /// let result = '\u00df'.encode_utf8(&mut b);\n-    ///\n-    /// assert_eq!(result, None);\n+    /// for (i, byte) in iterator.enumerate() {\n+    ///     println!(\"byte {}: {:x}\", i, byte);\n+    /// }\n     /// ```\n-    #[unstable(feature = \"unicode\",\n-               reason = \"pending decision about Iterator/Writer/Reader\",\n-               issue = \"27784\")]\n+    #[unstable(feature = \"unicode\", issue = \"27784\")]\n     #[inline]\n-    pub fn encode_utf8(self, dst: &mut [u8]) -> Option<usize> {\n-        C::encode_utf8(self, dst)\n+    pub fn encode_utf8(self) -> EncodeUtf8 {\n+        C::encode_utf8(self)\n     }\n \n-    /// Encodes this character as UTF-16 into the provided `u16` buffer, and\n-    /// then returns the number of `u16`s written.\n+    /// Returns an interator over the `u16` entries of this character as UTF-16.\n     ///\n-    /// If the buffer is not large enough, nothing will be written into it and a\n-    /// `None` will be returned. A buffer of length 2 is large enough to encode\n-    /// any `char`.\n+    /// The returned iterator also has an `as_slice()` method to view the\n+    /// encoded form as a slice.\n     ///\n     /// # Examples\n     ///\n-    /// In both of these examples, '\ud835\udd4a' takes two `u16`s to encode.\n-    ///\n-    /// ```\n-    /// #![feature(unicode)]\n-    ///\n-    /// let mut b = [0; 2];\n-    ///\n-    /// let result = '\ud835\udd4a'.encode_utf16(&mut b);\n-    ///\n-    /// assert_eq!(result, Some(2));\n-    /// ```\n-    ///\n-    /// A buffer that's too small:\n-    ///\n     /// ```\n     /// #![feature(unicode)]\n     ///\n-    /// let mut b = [0; 1];\n+    /// let iterator = '\ud835\udd4a'.encode_utf16();\n+    /// assert_eq!(iterator.as_slice(), [0xd835, 0xdd4a]);\n     ///\n-    /// let result = '\ud835\udd4a'.encode_utf16(&mut b);\n-    ///\n-    /// assert_eq!(result, None);\n+    /// for (i, val) in iterator.enumerate() {\n+    ///     println!(\"entry {}: {:x}\", i, val);\n+    /// }\n     /// ```\n-    #[unstable(feature = \"unicode\",\n-               reason = \"pending decision about Iterator/Writer/Reader\",\n-               issue = \"27784\")]\n+    #[unstable(feature = \"unicode\", issue = \"27784\")]\n     #[inline]\n-    pub fn encode_utf16(self, dst: &mut [u16]) -> Option<usize> {\n-        C::encode_utf16(self, dst)\n+    pub fn encode_utf16(self) -> EncodeUtf16 {\n+        C::encode_utf16(self)\n     }\n \n     /// Returns true if this `char` is an alphabetic code point, and false if not."}, {"sha": "2f7f724e6af8fcfe606630f7359829d384c00da1", "filename": "src/librustc_unicode/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/48d5fe9ec560b53b1f5069219b0d62015e1de5ba/src%2Flibrustc_unicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d5fe9ec560b53b1f5069219b0d62015e1de5ba/src%2Flibrustc_unicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Flib.rs?ref=48d5fe9ec560b53b1f5069219b0d62015e1de5ba", "patch": "@@ -35,6 +35,7 @@\n #![feature(core_char_ext)]\n #![feature(lang_items)]\n #![feature(staged_api)]\n+#![feature(unicode)]\n \n mod tables;\n mod u_str;"}, {"sha": "18734a66871f6fd4541cb35706057adc8d18710f", "filename": "src/librustc_unicode/u_str.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/48d5fe9ec560b53b1f5069219b0d62015e1de5ba/src%2Flibrustc_unicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d5fe9ec560b53b1f5069219b0d62015e1de5ba/src%2Flibrustc_unicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Fu_str.rs?ref=48d5fe9ec560b53b1f5069219b0d62015e1de5ba", "patch": "@@ -155,13 +155,13 @@ impl<I> Iterator for Utf16Encoder<I> where I: Iterator<Item=char> {\n             return Some(tmp);\n         }\n \n-        let mut buf = [0; 2];\n         self.chars.next().map(|ch| {\n-            let n = CharExt::encode_utf16(ch, &mut buf).unwrap_or(0);\n-            if n == 2 {\n-                self.extra = buf[1];\n+            let n = CharExt::encode_utf16(ch);\n+            let n = n.as_slice();\n+            if n.len() == 2 {\n+                self.extra = n[1];\n             }\n-            buf[0]\n+            n[0]\n         })\n     }\n "}, {"sha": "ab16ef23dd196153be5ab1b3e38e02b34546effe", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/48d5fe9ec560b53b1f5069219b0d62015e1de5ba/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d5fe9ec560b53b1f5069219b0d62015e1de5ba/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=48d5fe9ec560b53b1f5069219b0d62015e1de5ba", "patch": "@@ -433,10 +433,9 @@ fn escape_str(wr: &mut fmt::Write, v: &str) -> EncodeResult {\n }\n \n fn escape_char(writer: &mut fmt::Write, v: char) -> EncodeResult {\n-    let mut buf = [0; 4];\n-    let n = v.encode_utf8(&mut buf).unwrap();\n-    let buf = unsafe { str::from_utf8_unchecked(&buf[..n]) };\n-    escape_str(writer, buf)\n+    escape_str(writer, unsafe {\n+        str::from_utf8_unchecked(v.encode_utf8().as_slice())\n+    })\n }\n \n fn spaces(wr: &mut fmt::Write, mut n: usize) -> EncodeResult {"}, {"sha": "db3bc2ed7515f89915ae293c50eac393801908e1", "filename": "src/libstd/sys/common/wtf8.rs", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/48d5fe9ec560b53b1f5069219b0d62015e1de5ba/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d5fe9ec560b53b1f5069219b0d62015e1de5ba/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs?ref=48d5fe9ec560b53b1f5069219b0d62015e1de5ba", "patch": "@@ -25,7 +25,6 @@\n // unix (it's mostly used on windows), so don't worry about dead code here.\n #![allow(dead_code)]\n \n-use core::char::{encode_utf8_raw, encode_utf16_raw};\n use core::str::next_code_point;\n \n use ascii::*;\n@@ -206,19 +205,10 @@ impl Wtf8Buf {\n     /// Copied from String::push\n     /// This does **not** include the WTF-8 concatenation check.\n     fn push_code_point_unchecked(&mut self, code_point: CodePoint) {\n-        let cur_len = self.len();\n-        // This may use up to 4 bytes.\n-        self.reserve(4);\n-\n-        unsafe {\n-            // Attempt to not use an intermediate buffer by just pushing bytes\n-            // directly onto this string.\n-            let slice = slice::from_raw_parts_mut(\n-                self.bytes.as_mut_ptr().offset(cur_len as isize), 4\n-            );\n-            let used = encode_utf8_raw(code_point.value, slice).unwrap();\n-            self.bytes.set_len(cur_len + used);\n-        }\n+        let bytes = unsafe {\n+            char::from_u32_unchecked(code_point.value).encode_utf8()\n+        };\n+        self.bytes.extend_from_slice(bytes.as_slice());\n     }\n \n     #[inline]\n@@ -747,12 +737,15 @@ impl<'a> Iterator for EncodeWide<'a> {\n             return Some(tmp);\n         }\n \n-        let mut buf = [0; 2];\n         self.code_points.next().map(|code_point| {\n-            let n = encode_utf16_raw(code_point.value, &mut buf)\n-                .unwrap_or(0);\n-            if n == 2 { self.extra = buf[1]; }\n-            buf[0]\n+            let n = unsafe {\n+                char::from_u32_unchecked(code_point.value).encode_utf16()\n+            };\n+            let n = n.as_slice();\n+            if n.len() == 2 {\n+                self.extra = n[1];\n+            }\n+            n[0]\n         })\n     }\n "}]}