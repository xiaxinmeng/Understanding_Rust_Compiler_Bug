{"sha": "6ba8a1a657cf37e648166ee4b41f51768ea46c1e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiYThhMWE2NTdjZjM3ZTY0ODE2NmVlNGI0MWY1MTc2OGVhNDZjMWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-14T11:24:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-14T11:24:33Z"}, "message": "Auto merge of #33632 - Manishearth:rollup, r=Manishearth\n\nRollup of 9 pull requests\n\n- Successful merges: #33544, #33552, #33554, #33555, #33560, #33566, #33572, #33574, #33576\n- Failed merges:", "tree": {"sha": "1408f083385c17654e8cec516c8665a05f464a32", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1408f083385c17654e8cec516c8665a05f464a32"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ba8a1a657cf37e648166ee4b41f51768ea46c1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ba8a1a657cf37e648166ee4b41f51768ea46c1e", "html_url": "https://github.com/rust-lang/rust/commit/6ba8a1a657cf37e648166ee4b41f51768ea46c1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3ec9d43cf948813fa5aab3dfacf97035ee90d16", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3ec9d43cf948813fa5aab3dfacf97035ee90d16", "html_url": "https://github.com/rust-lang/rust/commit/d3ec9d43cf948813fa5aab3dfacf97035ee90d16"}, {"sha": "61d87f0825bc17b4e161e6f982b7aebd53594c5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/61d87f0825bc17b4e161e6f982b7aebd53594c5d", "html_url": "https://github.com/rust-lang/rust/commit/61d87f0825bc17b4e161e6f982b7aebd53594c5d"}], "stats": {"total": 2125, "additions": 1182, "deletions": 943}, "files": [{"sha": "65df056fd424b2ae71d1b213230758ca0068eb1f", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 38, "deletions": 10, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=6ba8a1a657cf37e648166ee4b41f51768ea46c1e", "patch": "@@ -239,7 +239,7 @@ pub enum Vtable<'tcx, N> {\n     VtableParam(Vec<N>),\n \n     /// Virtual calls through an object\n-    VtableObject(VtableObjectData<'tcx>),\n+    VtableObject(VtableObjectData<'tcx, N>),\n \n     /// Successful resolution for a builtin trait.\n     VtableBuiltin(VtableBuiltinData<N>),\n@@ -250,7 +250,7 @@ pub enum Vtable<'tcx, N> {\n     VtableClosure(VtableClosureData<'tcx, N>),\n \n     /// Same as above, but for a fn pointer type with the given signature.\n-    VtableFnPointer(ty::Ty<'tcx>),\n+    VtableFnPointer(VtableFnPointerData<'tcx, N>),\n }\n \n /// Identifies a particular impl in the source, along with a set of\n@@ -293,14 +293,22 @@ pub struct VtableBuiltinData<N> {\n /// A vtable for some object-safe trait `Foo` automatically derived\n /// for the object type `Foo`.\n #[derive(PartialEq,Eq,Clone)]\n-pub struct VtableObjectData<'tcx> {\n+pub struct VtableObjectData<'tcx, N> {\n     /// `Foo` upcast to the obligation trait. This will be some supertrait of `Foo`.\n     pub upcast_trait_ref: ty::PolyTraitRef<'tcx>,\n \n     /// The vtable is formed by concatenating together the method lists of\n     /// the base object trait and all supertraits; this is the start of\n     /// `upcast_trait_ref`'s methods in that vtable.\n-    pub vtable_base: usize\n+    pub vtable_base: usize,\n+\n+    pub nested: Vec<N>,\n+}\n+\n+#[derive(Clone, PartialEq, Eq)]\n+pub struct VtableFnPointerData<'tcx, N> {\n+    pub fn_ty: ty::Ty<'tcx>,\n+    pub nested: Vec<N>\n }\n \n /// Creates predicate obligations from the generic bounds.\n@@ -569,7 +577,20 @@ impl<'tcx, N> Vtable<'tcx, N> {\n             VtableBuiltin(i) => i.nested,\n             VtableDefaultImpl(d) => d.nested,\n             VtableClosure(c) => c.nested,\n-            VtableObject(_) | VtableFnPointer(..) => vec![]\n+            VtableObject(d) => d.nested,\n+            VtableFnPointer(d) => d.nested,\n+        }\n+    }\n+\n+    fn nested_obligations_mut(&mut self) -> &mut Vec<N> {\n+        match self {\n+            &mut VtableImpl(ref mut i) => &mut i.nested,\n+            &mut VtableParam(ref mut n) => n,\n+            &mut VtableBuiltin(ref mut i) => &mut i.nested,\n+            &mut VtableDefaultImpl(ref mut d) => &mut d.nested,\n+            &mut VtableClosure(ref mut c) => &mut c.nested,\n+            &mut VtableObject(ref mut d) => &mut d.nested,\n+            &mut VtableFnPointer(ref mut d) => &mut d.nested,\n         }\n     }\n \n@@ -578,18 +599,25 @@ impl<'tcx, N> Vtable<'tcx, N> {\n             VtableImpl(i) => VtableImpl(VtableImplData {\n                 impl_def_id: i.impl_def_id,\n                 substs: i.substs,\n-                nested: i.nested.into_iter().map(f).collect()\n+                nested: i.nested.into_iter().map(f).collect(),\n             }),\n             VtableParam(n) => VtableParam(n.into_iter().map(f).collect()),\n             VtableBuiltin(i) => VtableBuiltin(VtableBuiltinData {\n-                nested: i.nested.into_iter().map(f).collect()\n+                nested: i.nested.into_iter().map(f).collect(),\n+            }),\n+            VtableObject(o) => VtableObject(VtableObjectData {\n+                upcast_trait_ref: o.upcast_trait_ref,\n+                vtable_base: o.vtable_base,\n+                nested: o.nested.into_iter().map(f).collect(),\n             }),\n-            VtableObject(o) => VtableObject(o),\n             VtableDefaultImpl(d) => VtableDefaultImpl(VtableDefaultImplData {\n                 trait_def_id: d.trait_def_id,\n-                nested: d.nested.into_iter().map(f).collect()\n+                nested: d.nested.into_iter().map(f).collect(),\n+            }),\n+            VtableFnPointer(p) => VtableFnPointer(VtableFnPointerData {\n+                fn_ty: p.fn_ty,\n+                nested: p.nested.into_iter().map(f).collect(),\n             }),\n-            VtableFnPointer(f) => VtableFnPointer(f),\n             VtableClosure(c) => VtableClosure(VtableClosureData {\n                 closure_def_id: c.closure_def_id,\n                 substs: c.substs,"}, {"sha": "9abb179f288967bf448915d6302241988fa46680", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 12, "deletions": 64, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=6ba8a1a657cf37e648166ee4b41f51768ea46c1e", "patch": "@@ -19,6 +19,7 @@ use super::PredicateObligation;\n use super::SelectionContext;\n use super::SelectionError;\n use super::VtableClosureData;\n+use super::VtableFnPointerData;\n use super::VtableImplData;\n use super::util;\n \n@@ -158,7 +159,7 @@ enum ProjectionTyCandidate<'tcx> {\n     Closure(VtableClosureData<'tcx, PredicateObligation<'tcx>>),\n \n     // fn pointer return type\n-    FnPointer(Ty<'tcx>),\n+    FnPointer(VtableFnPointerData<'tcx, PredicateObligation<'tcx>>),\n }\n \n struct ProjectionTyCandidateSet<'tcx> {\n@@ -218,10 +219,7 @@ fn project_and_unify_type<'cx, 'gcx, 'tcx>(\n                                             obligation.cause.clone(),\n                                             obligation.recursion_depth) {\n             Some(n) => n,\n-            None => {\n-                consider_unification_despite_ambiguity(selcx, obligation);\n-                return Ok(None);\n-            }\n+            None => return Ok(None),\n         };\n \n     debug!(\"project_and_unify_type: normalized_ty={:?} obligations={:?}\",\n@@ -240,59 +238,6 @@ fn project_and_unify_type<'cx, 'gcx, 'tcx>(\n     }\n }\n \n-fn consider_unification_despite_ambiguity<'cx, 'gcx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n-    obligation: &ProjectionObligation<'tcx>)\n-{\n-    debug!(\"consider_unification_despite_ambiguity(obligation={:?})\",\n-           obligation);\n-\n-    let def_id = obligation.predicate.projection_ty.trait_ref.def_id;\n-    match selcx.tcx().lang_items.fn_trait_kind(def_id) {\n-        Some(_) => { }\n-        None => { return; }\n-    }\n-\n-    let infcx = selcx.infcx();\n-    let self_ty = obligation.predicate.projection_ty.trait_ref.self_ty();\n-    let self_ty = infcx.shallow_resolve(self_ty);\n-    debug!(\"consider_unification_despite_ambiguity: self_ty.sty={:?}\",\n-           self_ty.sty);\n-    match self_ty.sty {\n-        ty::TyClosure(closure_def_id, substs) => {\n-            let closure_typer = selcx.closure_typer();\n-            let closure_type = closure_typer.closure_type(closure_def_id, substs);\n-            let ty::Binder((_, ret_type)) =\n-                infcx.tcx.closure_trait_ref_and_return_type(def_id,\n-                                                            self_ty,\n-                                                            &closure_type.sig,\n-                                                            util::TupleArgumentsFlag::No);\n-            // We don't have to normalize the return type here - this is only\n-            // reached for TyClosure: Fn inputs where the closure kind is\n-            // still unknown, which should only occur in typeck where the\n-            // closure type is already normalized.\n-            let (ret_type, _) =\n-                infcx.replace_late_bound_regions_with_fresh_var(\n-                    obligation.cause.span,\n-                    infer::AssocTypeProjection(obligation.predicate.projection_ty.item_name),\n-                    &ty::Binder(ret_type));\n-\n-            debug!(\"consider_unification_despite_ambiguity: ret_type={:?}\",\n-                   ret_type);\n-            let origin = TypeOrigin::RelateOutputImplTypes(obligation.cause.span);\n-            let obligation_ty = obligation.predicate.ty;\n-            match infcx.eq_types(true, origin, obligation_ty, ret_type) {\n-                Ok(InferOk { obligations, .. }) => {\n-                    // FIXME(#32730) propagate obligations\n-                    assert!(obligations.is_empty());\n-                }\n-                Err(_) => { /* ignore errors */ }\n-            }\n-        }\n-        _ => { }\n-    }\n-}\n-\n /// Normalizes any associated type projections in `value`, replacing\n /// them with a fully resolved type where possible. The return value\n /// combines the normalized result and any additional obligations that\n@@ -929,9 +874,9 @@ fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n             candidate_set.vec.push(\n                 ProjectionTyCandidate::Closure(data));\n         }\n-        super::VtableFnPointer(fn_type) => {\n+        super::VtableFnPointer(data) => {\n             candidate_set.vec.push(\n-                ProjectionTyCandidate::FnPointer(fn_type));\n+                ProjectionTyCandidate::FnPointer(data));\n         }\n         super::VtableParam(..) => {\n             // This case tell us nothing about the value of an\n@@ -997,19 +942,22 @@ fn confirm_candidate<'cx, 'gcx, 'tcx>(\n             confirm_closure_candidate(selcx, obligation, closure_vtable)\n         }\n \n-        ProjectionTyCandidate::FnPointer(fn_type) => {\n-            confirm_fn_pointer_candidate(selcx, obligation, fn_type)\n+        ProjectionTyCandidate::FnPointer(fn_pointer_vtable) => {\n+            confirm_fn_pointer_candidate(selcx, obligation, fn_pointer_vtable)\n         }\n     }\n }\n \n fn confirm_fn_pointer_candidate<'cx, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    fn_type: Ty<'tcx>)\n+    fn_pointer_vtable: VtableFnPointerData<'tcx, PredicateObligation<'tcx>>)\n     -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n {\n-    let fn_type = selcx.infcx().shallow_resolve(fn_type);\n+    // FIXME(#32730) propagate obligations (fn pointer vtable nested obligations ONLY come from\n+    // unification in inference)\n+    assert!(fn_pointer_vtable.nested.is_empty());\n+    let fn_type = selcx.infcx().shallow_resolve(fn_pointer_vtable.fn_ty);\n     let sig = fn_type.fn_sig();\n     confirm_callable_candidate(selcx, obligation, sig, util::TupleArgumentsFlag::Yes)\n }"}, {"sha": "5307749b87b6adf3515bbc2a7f360f46809f49a0", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 129, "deletions": 72, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=6ba8a1a657cf37e648166ee4b41f51768ea46c1e", "patch": "@@ -30,7 +30,7 @@ use super::SelectionResult;\n use super::{VtableBuiltin, VtableImpl, VtableParam, VtableClosure,\n             VtableFnPointer, VtableObject, VtableDefaultImpl};\n use super::{VtableImplData, VtableObjectData, VtableBuiltinData,\n-            VtableClosureData, VtableDefaultImplData};\n+            VtableClosureData, VtableDefaultImplData, VtableFnPointerData};\n use super::util;\n \n use hir::def_id::DefId;\n@@ -42,13 +42,24 @@ use traits;\n use ty::fast_reject;\n use ty::relate::TypeRelation;\n \n+use rustc_data_structures::snapshot_vec::{SnapshotVecDelegate, SnapshotVec};\n use std::cell::RefCell;\n use std::fmt;\n+use std::marker::PhantomData;\n use std::rc::Rc;\n use syntax::abi::Abi;\n use hir;\n use util::nodemap::FnvHashMap;\n \n+struct InferredObligationsSnapshotVecDelegate<'tcx> {\n+    phantom: PhantomData<&'tcx i32>,\n+}\n+impl<'tcx> SnapshotVecDelegate for InferredObligationsSnapshotVecDelegate<'tcx> {\n+    type Value = PredicateObligation<'tcx>;\n+    type Undo = ();\n+    fn reverse(_: &mut Vec<Self::Value>, _: Self::Undo) {}\n+}\n+\n pub struct SelectionContext<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n \n@@ -74,6 +85,8 @@ pub struct SelectionContext<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     /// there is no type that the user could *actually name* that\n     /// would satisfy it. This avoids crippling inference, basically.\n     intercrate: bool,\n+\n+    inferred_obligations: SnapshotVec<InferredObligationsSnapshotVecDelegate<'tcx>>,\n }\n \n // A stack that walks back up the stack frame.\n@@ -300,6 +313,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             infcx: infcx,\n             freshener: infcx.freshener(),\n             intercrate: false,\n+            inferred_obligations: SnapshotVec::new(),\n         }\n     }\n \n@@ -308,6 +322,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             infcx: infcx,\n             freshener: infcx.freshener(),\n             intercrate: true,\n+            inferred_obligations: SnapshotVec::new(),\n         }\n     }\n \n@@ -331,6 +346,46 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         self.infcx.projection_mode()\n     }\n \n+    /// Wraps the inference context's in_snapshot s.t. snapshot handling is only from the selection\n+    /// context's self.\n+    fn in_snapshot<R, F>(&mut self, f: F) -> R\n+        where F: FnOnce(&mut Self, &infer::CombinedSnapshot) -> R\n+    {\n+        // The irrefutable nature of the operation means we don't need to snapshot the\n+        // inferred_obligations vector.\n+        self.infcx.in_snapshot(|snapshot| f(self, snapshot))\n+    }\n+\n+    /// Wraps a probe s.t. obligations collected during it are ignored and old obligations are\n+    /// retained.\n+    fn probe<R, F>(&mut self, f: F) -> R\n+        where F: FnOnce(&mut Self, &infer::CombinedSnapshot) -> R\n+    {\n+        let inferred_obligations_snapshot = self.inferred_obligations.start_snapshot();\n+        let result = self.infcx.probe(|snapshot| f(self, snapshot));\n+        self.inferred_obligations.rollback_to(inferred_obligations_snapshot);\n+        result\n+    }\n+\n+    /// Wraps a commit_if_ok s.t. obligations collected during it are not returned in selection if\n+    /// the transaction fails and s.t. old obligations are retained.\n+    fn commit_if_ok<T, E, F>(&mut self, f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self, &infer::CombinedSnapshot) -> Result<T, E>\n+    {\n+        let inferred_obligations_snapshot = self.inferred_obligations.start_snapshot();\n+        match self.infcx.commit_if_ok(|snapshot| f(self, snapshot)) {\n+            Ok(ok) => {\n+                self.inferred_obligations.commit(inferred_obligations_snapshot);\n+                Ok(ok)\n+            },\n+            Err(err) => {\n+                self.inferred_obligations.rollback_to(inferred_obligations_snapshot);\n+                Err(err)\n+            }\n+        }\n+    }\n+\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // Selection\n     //\n@@ -359,7 +414,15 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let stack = self.push_stack(TraitObligationStackList::empty(), obligation);\n         match self.candidate_from_obligation(&stack)? {\n             None => Ok(None),\n-            Some(candidate) => Ok(Some(self.confirm_candidate(obligation, candidate)?)),\n+            Some(candidate) => {\n+                let mut candidate = self.confirm_candidate(obligation, candidate)?;\n+                // FIXME(#32730) remove this assertion once inferred obligations are propagated\n+                // from inference\n+                assert!(self.inferred_obligations.len() == 0);\n+                let inferred_obligations = (*self.inferred_obligations).into_iter().cloned();\n+                candidate.nested_obligations_mut().extend(inferred_obligations);\n+                Ok(Some(candidate))\n+            },\n         }\n     }\n \n@@ -381,8 +444,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         debug!(\"evaluate_obligation({:?})\",\n                obligation);\n \n-        self.infcx.probe(|_| {\n-            self.evaluate_predicate_recursively(TraitObligationStackList::empty(), obligation)\n+        self.probe(|this, _| {\n+            this.evaluate_predicate_recursively(TraitObligationStackList::empty(), obligation)\n                 .may_apply()\n         })\n     }\n@@ -397,8 +460,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         debug!(\"evaluate_obligation_conservatively({:?})\",\n                obligation);\n \n-        self.infcx.probe(|_| {\n-            self.evaluate_predicate_recursively(TraitObligationStackList::empty(), obligation)\n+        self.probe(|this, _| {\n+            this.evaluate_predicate_recursively(TraitObligationStackList::empty(), obligation)\n                 == EvaluatedToOk\n         })\n     }\n@@ -460,8 +523,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 // does this code ever run?\n                 match self.infcx.equality_predicate(obligation.cause.span, p) {\n                     Ok(InferOk { obligations, .. }) => {\n-                        // FIXME(#32730) propagate obligations\n-                        assert!(obligations.is_empty());\n+                        self.inferred_obligations.extend(obligations);\n                         EvaluatedToOk\n                     },\n                     Err(_) => EvaluatedToErr\n@@ -643,11 +705,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     {\n         debug!(\"evaluate_candidate: depth={} candidate={:?}\",\n                stack.obligation.recursion_depth, candidate);\n-        let result = self.infcx.probe(|_| {\n+        let result = self.probe(|this, _| {\n             let candidate = (*candidate).clone();\n-            match self.confirm_candidate(stack.obligation, candidate) {\n+            match this.confirm_candidate(stack.obligation, candidate) {\n                 Ok(selection) => {\n-                    self.evaluate_predicates_recursively(\n+                    this.evaluate_predicates_recursively(\n                         stack.list(),\n                         selection.nested_obligations().iter())\n                 }\n@@ -1107,8 +1169,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         debug!(\"assemble_candidates_for_projected_tys: trait_def_id={:?}\",\n                trait_def_id);\n \n-        let result = self.infcx.probe(|snapshot| {\n-            self.match_projection_obligation_against_bounds_from_trait(obligation,\n+        let result = self.probe(|this, snapshot| {\n+            this.match_projection_obligation_against_bounds_from_trait(obligation,\n                                                                        snapshot)\n         });\n \n@@ -1156,12 +1218,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             util::elaborate_predicates(self.tcx(), bounds.predicates.into_vec())\n             .filter_to_traits()\n             .find(\n-                |bound| self.infcx.probe(\n-                    |_| self.match_projection(obligation,\n-                                              bound.clone(),\n-                                              skol_trait_predicate.trait_ref.clone(),\n-                                              &skol_map,\n-                                              snapshot)));\n+                |bound| self.probe(\n+                    |this, _| this.match_projection(obligation,\n+                                                    bound.clone(),\n+                                                    skol_trait_predicate.trait_ref.clone(),\n+                                                    &skol_map,\n+                                                    snapshot)));\n \n         debug!(\"match_projection_obligation_against_bounds_from_trait: \\\n                 matching_bound={:?}\",\n@@ -1196,8 +1258,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                              trait_bound.clone(),\n                                              ty::Binder(skol_trait_ref.clone())) {\n             Ok(InferOk { obligations, .. }) => {\n-                // FIXME(#32730) propagate obligations\n-                assert!(obligations.is_empty());\n+                self.inferred_obligations.extend(obligations);\n             }\n             Err(_) => { return false; }\n         }\n@@ -1239,10 +1300,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                  where_clause_trait_ref: ty::PolyTraitRef<'tcx>)\n                                  -> EvaluationResult\n     {\n-        self.infcx().probe(move |_| {\n-            match self.match_where_clause_trait_ref(stack.obligation, where_clause_trait_ref) {\n+        self.probe(move |this, _| {\n+            match this.match_where_clause_trait_ref(stack.obligation, where_clause_trait_ref) {\n                 Ok(obligations) => {\n-                    self.evaluate_predicates_recursively(stack.list(), obligations.iter())\n+                    this.evaluate_predicates_recursively(stack.list(), obligations.iter())\n                 }\n                 Err(()) => EvaluatedToErr\n             }\n@@ -1361,8 +1422,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             self.tcx(),\n             obligation.predicate.0.trait_ref.self_ty(),\n             |impl_def_id| {\n-                self.infcx.probe(|snapshot| {\n-                    if let Ok(_) = self.match_impl(impl_def_id, obligation, snapshot) {\n+                self.probe(|this, snapshot| {\n+                    if let Ok(_) = this.match_impl(impl_def_id, obligation, snapshot) {\n                         candidates.vec.push(ImplCandidate(impl_def_id));\n                     }\n                 });\n@@ -1448,12 +1509,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             return;\n         }\n \n-        self.infcx.in_snapshot(|snapshot| {\n+        self.probe(|this, snapshot| {\n             let (self_ty, _) =\n-                self.infcx().skolemize_late_bound_regions(&obligation.self_ty(), snapshot);\n+                this.infcx().skolemize_late_bound_regions(&obligation.self_ty(), snapshot);\n             let poly_trait_ref = match self_ty.sty {\n                 ty::TyTrait(ref data) => {\n-                    match self.tcx().lang_items.to_builtin_kind(obligation.predicate.def_id()) {\n+                    match this.tcx().lang_items.to_builtin_kind(obligation.predicate.def_id()) {\n                         Some(bound @ ty::BoundSend) | Some(bound @ ty::BoundSync) => {\n                             if data.bounds.builtin_bounds.contains(&bound) {\n                                 debug!(\"assemble_candidates_from_object_ty: matched builtin bound, \\\n@@ -1465,7 +1526,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         _ => {}\n                     }\n \n-                    data.principal_trait_ref_with_self_ty(self.tcx(), self_ty)\n+                    data.principal_trait_ref_with_self_ty(this.tcx(), self_ty)\n                 }\n                 ty::TyInfer(ty::TyVar(_)) => {\n                     debug!(\"assemble_candidates_from_object_ty: ambiguous\");\n@@ -1486,11 +1547,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             // For example, we may be trying to upcast `Foo` to `Bar<i32>`,\n             // but `Foo` is declared as `trait Foo : Bar<u32>`.\n             let upcast_trait_refs =\n-                util::supertraits(self.tcx(), poly_trait_ref)\n+                util::supertraits(this.tcx(), poly_trait_ref)\n                 .filter(|upcast_trait_ref| {\n-                    self.infcx.probe(|_| {\n+                    this.probe(|this, _| {\n                         let upcast_trait_ref = upcast_trait_ref.clone();\n-                        self.match_poly_trait_ref(obligation, upcast_trait_ref).is_ok()\n+                        this.match_poly_trait_ref(obligation, upcast_trait_ref).is_ok()\n                     })\n                 })\n                 .count();\n@@ -1894,23 +1955,23 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         types.skip_binder().into_iter().flat_map(|ty| { // binder moved -\\\n             let ty: ty::Binder<Ty<'tcx>> = ty::Binder(ty); // <----------/\n \n-            self.infcx.in_snapshot(|snapshot| {\n+            self.in_snapshot(|this, snapshot| {\n                 let (skol_ty, skol_map) =\n-                    self.infcx().skolemize_late_bound_regions(&ty, snapshot);\n+                    this.infcx().skolemize_late_bound_regions(&ty, snapshot);\n                 let Normalized { value: normalized_ty, mut obligations } =\n-                    project::normalize_with_depth(self,\n+                    project::normalize_with_depth(this,\n                                                   cause.clone(),\n                                                   recursion_depth,\n                                                   &skol_ty);\n                 let skol_obligation =\n-                    self.tcx().predicate_for_trait_def(\n+                    this.tcx().predicate_for_trait_def(\n                                                   cause.clone(),\n                                                   trait_def_id,\n                                                   recursion_depth,\n                                                   normalized_ty,\n                                                   vec![]);\n                 obligations.push(skol_obligation);\n-                self.infcx().plug_leaks(skol_map, snapshot, &obligations)\n+                this.infcx().plug_leaks(skol_map, snapshot, &obligations)\n             })\n         }).collect()\n     }\n@@ -1977,9 +2038,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             }\n \n             FnPointerCandidate => {\n-                let fn_type =\n+                let data =\n                     self.confirm_fn_pointer_candidate(obligation)?;\n-                Ok(VtableFnPointer(fn_type))\n+                Ok(VtableFnPointer(data))\n             }\n \n             ProjectionCandidate => {\n@@ -1997,9 +2058,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn confirm_projection_candidate(&mut self,\n                                     obligation: &TraitObligation<'tcx>)\n     {\n-        self.infcx.in_snapshot(|snapshot| {\n+        self.in_snapshot(|this, snapshot| {\n             let result =\n-                self.match_projection_obligation_against_bounds_from_trait(obligation,\n+                this.match_projection_obligation_against_bounds_from_trait(obligation,\n                                                                            snapshot);\n             assert!(result);\n         })\n@@ -2140,12 +2201,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             trait_def_id,\n             nested);\n \n-        let trait_obligations = self.infcx.in_snapshot(|snapshot| {\n+        let trait_obligations = self.in_snapshot(|this, snapshot| {\n             let poly_trait_ref = obligation.predicate.to_poly_trait_ref();\n             let (trait_ref, skol_map) =\n-                self.infcx().skolemize_late_bound_regions(&poly_trait_ref, snapshot);\n-            let cause = self.derived_cause(obligation, ImplDerivedObligation);\n-            self.impl_or_trait_obligations(cause,\n+                this.infcx().skolemize_late_bound_regions(&poly_trait_ref, snapshot);\n+            let cause = this.derived_cause(obligation, ImplDerivedObligation);\n+            this.impl_or_trait_obligations(cause,\n                                            obligation.recursion_depth + 1,\n                                            trait_def_id,\n                                            &trait_ref.substs,\n@@ -2174,13 +2235,13 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         // First, create the substitutions by matching the impl again,\n         // this time not in a probe.\n-        self.infcx.in_snapshot(|snapshot| {\n+        self.in_snapshot(|this, snapshot| {\n             let (substs, skol_map) =\n-                self.rematch_impl(impl_def_id, obligation,\n+                this.rematch_impl(impl_def_id, obligation,\n                                   snapshot);\n             debug!(\"confirm_impl_candidate substs={:?}\", substs);\n-            let cause = self.derived_cause(obligation, ImplDerivedObligation);\n-            self.vtable_impl(impl_def_id, substs, cause,\n+            let cause = this.derived_cause(obligation, ImplDerivedObligation);\n+            this.vtable_impl(impl_def_id, substs, cause,\n                              obligation.recursion_depth + 1,\n                              skol_map, snapshot)\n         })\n@@ -2227,7 +2288,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n     fn confirm_object_candidate(&mut self,\n                                 obligation: &TraitObligation<'tcx>)\n-                                -> VtableObjectData<'tcx>\n+                                -> VtableObjectData<'tcx, PredicateObligation<'tcx>>\n     {\n         debug!(\"confirm_object_candidate({:?})\",\n                obligation);\n@@ -2251,18 +2312,20 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let vtable_base;\n \n         {\n+            let tcx = self.tcx();\n+\n             // We want to find the first supertrait in the list of\n             // supertraits that we can unify with, and do that\n             // unification. We know that there is exactly one in the list\n             // where we can unify because otherwise select would have\n             // reported an ambiguity. (When we do find a match, also\n             // record it for later.)\n             let nonmatching =\n-                util::supertraits(self.tcx(), poly_trait_ref)\n+                util::supertraits(tcx, poly_trait_ref)\n                 .take_while(|&t| {\n                     match\n-                        self.infcx.commit_if_ok(\n-                            |_| self.match_poly_trait_ref(obligation, t))\n+                        self.commit_if_ok(\n+                            |this, _| this.match_poly_trait_ref(obligation, t))\n                     {\n                         Ok(_) => { upcast_trait_ref = Some(t); false }\n                         Err(_) => { true }\n@@ -2274,20 +2337,20 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             // entries, so that we can compute the offset for the selected\n             // trait.\n             vtable_base =\n-                nonmatching.map(|t| self.tcx().count_own_vtable_entries(t))\n+                nonmatching.map(|t| tcx.count_own_vtable_entries(t))\n                            .sum();\n \n         }\n \n         VtableObjectData {\n             upcast_trait_ref: upcast_trait_ref.unwrap(),\n             vtable_base: vtable_base,\n+            nested: vec![]\n         }\n     }\n \n-    fn confirm_fn_pointer_candidate(&mut self,\n-                                    obligation: &TraitObligation<'tcx>)\n-                                    -> Result<ty::Ty<'tcx>,SelectionError<'tcx>>\n+    fn confirm_fn_pointer_candidate(&mut self, obligation: &TraitObligation<'tcx>)\n+        -> Result<VtableFnPointerData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>>\n     {\n         debug!(\"confirm_fn_pointer_candidate({:?})\",\n                obligation);\n@@ -2305,7 +2368,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         self.confirm_poly_trait_refs(obligation.cause.clone(),\n                                      obligation.predicate.to_poly_trait_ref(),\n                                      trait_ref)?;\n-        Ok(self_ty)\n+        Ok(VtableFnPointerData { fn_ty: self_ty, nested: vec![] })\n     }\n \n     fn confirm_closure_candidate(&mut self,\n@@ -2384,8 +2447,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                        origin,\n                                        expected_trait_ref.clone(),\n                                        obligation_trait_ref.clone())\n-            // FIXME(#32730) propagate obligations\n-            .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n+            .map(|InferOk { obligations, .. }| self.inferred_obligations.extend(obligations))\n             .map_err(|e| OutputTypeParameterMismatch(expected_trait_ref, obligation_trait_ref, e))\n     }\n \n@@ -2420,8 +2482,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 let InferOk { obligations, .. } =\n                     self.infcx.sub_types(false, origin, new_trait, target)\n                     .map_err(|_| Unimplemented)?;\n-                // FIXME(#32730) propagate obligations\n-                assert!(obligations.is_empty());\n+                self.inferred_obligations.extend(obligations);\n \n                 // Register one obligation for 'a: 'b.\n                 let cause = ObligationCause::new(obligation.cause.span,\n@@ -2494,8 +2555,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 let InferOk { obligations, .. } =\n                     self.infcx.sub_types(false, origin, a, b)\n                     .map_err(|_| Unimplemented)?;\n-                // FIXME(#32730) propagate obligations\n-                assert!(obligations.is_empty());\n+                self.inferred_obligations.extend(obligations);\n             }\n \n             // Struct<T> -> Struct<U>.\n@@ -2554,8 +2614,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 let InferOk { obligations, .. } =\n                     self.infcx.sub_types(false, origin, new_struct, target)\n                     .map_err(|_| Unimplemented)?;\n-                // FIXME(#32730) propagate obligations\n-                assert!(obligations.is_empty());\n+                self.inferred_obligations.extend(obligations);\n \n                 // Construct the nested Field<T>: Unsize<Field<U>> predicate.\n                 nested.push(tcx.predicate_for_trait_def(\n@@ -2649,8 +2708,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 debug!(\"match_impl: failed eq_trait_refs due to `{}`\", e);\n                 ()\n             })?;\n-        // FIXME(#32730) propagate obligations\n-        assert!(obligations.is_empty());\n+        self.inferred_obligations.extend(obligations);\n \n         if let Err(e) = self.infcx.leak_check(false, &skol_map, snapshot) {\n             debug!(\"match_impl: failed leak check due to `{}`\", e);\n@@ -2703,7 +2761,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n     /// Returns `Ok` if `poly_trait_ref` being true implies that the\n     /// obligation is satisfied.\n-    fn match_poly_trait_ref(&self,\n+    fn match_poly_trait_ref(&mut self,\n                             obligation: &TraitObligation<'tcx>,\n                             poly_trait_ref: ty::PolyTraitRef<'tcx>)\n                             -> Result<(),()>\n@@ -2717,8 +2775,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                        origin,\n                                        poly_trait_ref,\n                                        obligation.predicate.to_poly_trait_ref())\n-            // FIXME(#32730) propagate obligations\n-            .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n+            .map(|InferOk { obligations, .. }| self.inferred_obligations.extend(obligations))\n             .map_err(|_| ())\n     }\n "}, {"sha": "e210d2da94cfd4db09435da2ae56025172f31c4b", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 40, "deletions": 10, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=6ba8a1a657cf37e648166ee4b41f51768ea46c1e", "patch": "@@ -99,11 +99,20 @@ impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableDefaultImplData<N> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for traits::VtableObjectData<'tcx> {\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableObjectData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"VtableObject(upcast={:?}, vtable_base={})\",\n+        write!(f, \"VtableObject(upcast={:?}, vtable_base={}, nested={:?})\",\n                self.upcast_trait_ref,\n-               self.vtable_base)\n+               self.vtable_base,\n+               self.nested)\n+    }\n+}\n+\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableFnPointerData<'tcx, N> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"VtableFnPointer(fn_ty={:?}, nested={:?})\",\n+               self.fn_ty,\n+               self.nested)\n     }\n }\n \n@@ -185,19 +194,26 @@ impl<'a, 'tcx> Lift<'tcx> for traits::Vtable<'a, ()> {\n                     })\n                 })\n             }\n-            traits::VtableFnPointer(ty) => {\n-                tcx.lift(&ty).map(traits::VtableFnPointer)\n+            traits::VtableFnPointer(traits::VtableFnPointerData { fn_ty, nested }) => {\n+                tcx.lift(&fn_ty).map(|fn_ty| {\n+                    traits::VtableFnPointer(traits::VtableFnPointerData {\n+                        fn_ty: fn_ty,\n+                        nested: nested,\n+                    })\n+                })\n             }\n             traits::VtableParam(n) => Some(traits::VtableParam(n)),\n             traits::VtableBuiltin(d) => Some(traits::VtableBuiltin(d)),\n             traits::VtableObject(traits::VtableObjectData {\n                 upcast_trait_ref,\n-                vtable_base\n+                vtable_base,\n+                nested\n             }) => {\n                 tcx.lift(&upcast_trait_ref).map(|trait_ref| {\n                     traits::VtableObject(traits::VtableObjectData {\n                         upcast_trait_ref: trait_ref,\n-                        vtable_base: vtable_base\n+                        vtable_base: vtable_base,\n+                        nested: nested\n                     })\n                 })\n             }\n@@ -276,16 +292,30 @@ impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableBuiltinDa\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for traits::VtableObjectData<'tcx> {\n+impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableObjectData<'tcx, N> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         traits::VtableObjectData {\n             upcast_trait_ref: self.upcast_trait_ref.fold_with(folder),\n-            vtable_base: self.vtable_base\n+            vtable_base: self.vtable_base,\n+            nested: self.nested.fold_with(folder),\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.upcast_trait_ref.visit_with(visitor) || self.nested.visit_with(visitor)\n+    }\n+}\n+\n+impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableFnPointerData<'tcx, N> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        traits::VtableFnPointerData {\n+            fn_ty: self.fn_ty.fold_with(folder),\n+            nested: self.nested.fold_with(folder),\n         }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.upcast_trait_ref.visit_with(visitor)\n+        self.fn_ty.visit_with(visitor) || self.nested.visit_with(visitor)\n     }\n }\n "}, {"sha": "f8149565aa66b64e50263236845c8bf53d53497f", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=6ba8a1a657cf37e648166ee4b41f51768ea46c1e", "patch": "@@ -473,9 +473,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Given an upcast trait object described by `object`, returns the\n     /// index of the method `method_def_id` (which should be part of\n     /// `object.upcast_trait_ref`) within the vtable for `object`.\n-    pub fn get_vtable_index_of_object_method(self,\n-                                             object: &super::VtableObjectData<'tcx>,\n-                                             method_def_id: DefId) -> usize {\n+    pub fn get_vtable_index_of_object_method<N>(self,\n+                                                object: &super::VtableObjectData<'tcx, N>,\n+                                                method_def_id: DefId) -> usize {\n         // Count number of methods preceding the one we are selecting and\n         // add them to the total offset.\n         // Skip over associated types and constants."}, {"sha": "114e81721ab28df812b170c3ddd1f3b348867252", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 20, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=6ba8a1a657cf37e648166ee4b41f51768ea46c1e", "patch": "@@ -1260,7 +1260,7 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n         match tcx.map.find(id) {\n             Some(ast_map::NodeImplItem(ref impl_item)) => {\n                 match impl_item.node {\n-                    hir::ImplItemKind::Type(_) => {\n+                    hir::ImplItemKind::Type(_) | hir::ImplItemKind::Const(_, _) => {\n                         // associated types don't have their own entry (for some reason),\n                         // so for now just grab environment for the impl\n                         let impl_id = tcx.map.get_parent(id);\n@@ -1272,15 +1272,6 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                                                             &predicates,\n                                                             tcx.region_maps.item_extent(id))\n                     }\n-                    hir::ImplItemKind::Const(_, _) => {\n-                        let def_id = tcx.map.local_def_id(id);\n-                        let scheme = tcx.lookup_item_type(def_id);\n-                        let predicates = tcx.lookup_predicates(def_id);\n-                        tcx.construct_parameter_environment(impl_item.span,\n-                                                            &scheme.generics,\n-                                                            &predicates,\n-                                                            tcx.region_maps.item_extent(id))\n-                    }\n                     hir::ImplItemKind::Method(_, ref body) => {\n                         let method_def_id = tcx.map.local_def_id(id);\n                         match tcx.impl_or_trait_item(method_def_id) {\n@@ -1303,7 +1294,7 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n             }\n             Some(ast_map::NodeTraitItem(trait_item)) => {\n                 match trait_item.node {\n-                    hir::TypeTraitItem(..) => {\n+                    hir::TypeTraitItem(..) | hir::ConstTraitItem(..) => {\n                         // associated types don't have their own entry (for some reason),\n                         // so for now just grab environment for the trait\n                         let trait_id = tcx.map.get_parent(id);\n@@ -1315,15 +1306,6 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                                                             &predicates,\n                                                             tcx.region_maps.item_extent(id))\n                     }\n-                    hir::ConstTraitItem(..) => {\n-                        let def_id = tcx.map.local_def_id(id);\n-                        let scheme = tcx.lookup_item_type(def_id);\n-                        let predicates = tcx.lookup_predicates(def_id);\n-                        tcx.construct_parameter_environment(trait_item.span,\n-                                                            &scheme.generics,\n-                                                            &predicates,\n-                                                            tcx.region_maps.item_extent(id))\n-                    }\n                     hir::MethodTraitItem(_, ref body) => {\n                         // Use call-site for extent (unless this is a\n                         // trait method with no default; then fallback"}, {"sha": "dac074ab91e1bfe11c67876f0d3dce2bc7bfc492", "filename": "src/librustc_data_structures/snapshot_vec.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc_data_structures%2Fsnapshot_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc_data_structures%2Fsnapshot_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsnapshot_vec.rs?ref=6ba8a1a657cf37e648166ee4b41f51768ea46c1e", "patch": "@@ -213,3 +213,11 @@ impl<D: SnapshotVecDelegate> ops::IndexMut<usize> for SnapshotVec<D> {\n         self.get_mut(index)\n     }\n }\n+\n+impl<D: SnapshotVecDelegate> Extend<D::Value> for SnapshotVec<D> {\n+    fn extend<T>(&mut self, iterable: T) where T: IntoIterator<Item=D::Value> {\n+        for item in iterable {\n+            self.push(item);\n+        }\n+    }\n+}"}, {"sha": "46356add8c682db1dee3ad011bd10d42e11cfcf1", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=6ba8a1a657cf37e648166ee4b41f51768ea46c1e", "patch": "@@ -1036,7 +1036,7 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         passes.push_pass(box mir::transform::no_landing_pads::NoLandingPads);\n         passes.push_pass(box mir::transform::remove_dead_blocks::RemoveDeadBlocks);\n         passes.push_pass(box mir::transform::erase_regions::EraseRegions);\n-        passes.push_pass(box mir::transform::break_critical_edges::BreakCriticalEdges);\n+        passes.push_pass(box mir::transform::break_cleanup_edges::BreakCleanupEdges);\n         passes.run_passes(tcx, &mut mir_map);\n     });\n "}, {"sha": "0eb6223a71e54af5d64aed9cf8b11fc7e1ffda1e", "filename": "src/librustc_mir/transform/break_cleanup_edges.rs", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc_mir%2Ftransform%2Fbreak_cleanup_edges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc_mir%2Ftransform%2Fbreak_cleanup_edges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fbreak_cleanup_edges.rs?ref=6ba8a1a657cf37e648166ee4b41f51768ea46c1e", "patch": "@@ -0,0 +1,111 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::ty::TyCtxt;\n+use rustc::mir::repr::*;\n+use rustc::mir::transform::{MirPass, MirSource, Pass};\n+\n+use rustc_data_structures::bitvec::BitVector;\n+\n+use pretty;\n+\n+use traversal;\n+\n+pub struct BreakCleanupEdges;\n+\n+/**\n+ * Breaks outgoing critical edges for call terminators in the MIR.\n+ *\n+ * Critical edges are edges that are neither the only edge leaving a\n+ * block, nor the only edge entering one.\n+ *\n+ * When you want something to happen \"along\" an edge, you can either\n+ * do at the end of the predecessor block, or at the start of the\n+ * successor block. Critical edges have to be broken in order to prevent\n+ * \"edge actions\" from affecting other edges. We need this for calls that are\n+ * translated to LLVM invoke instructions, because invoke is a block terminator\n+ * in LLVM so we can't insert any code to handle the call's result into the\n+ * block that performs the call.\n+ *\n+ * This function will break those edges by inserting new blocks along them.\n+ *\n+ * NOTE: Simplify CFG will happily undo most of the work this pass does.\n+ *\n+ */\n+\n+impl<'tcx> MirPass<'tcx> for BreakCleanupEdges {\n+    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>, src: MirSource, mir: &mut Mir<'tcx>) {\n+        let mut pred_count = vec![0u32; mir.basic_blocks.len()];\n+\n+        // Build the precedecessor map for the MIR\n+        for (_, data) in traversal::preorder(mir) {\n+            if let Some(ref term) = data.terminator {\n+                for &tgt in term.successors().iter() {\n+                    pred_count[tgt.index()] += 1;\n+                }\n+            }\n+        }\n+\n+        let cleanup_map : BitVector = mir.basic_blocks\n+            .iter().map(|bb| bb.is_cleanup).collect();\n+\n+        // We need a place to store the new blocks generated\n+        let mut new_blocks = Vec::new();\n+\n+        let bbs = mir.all_basic_blocks();\n+        let cur_len = mir.basic_blocks.len();\n+\n+        for &bb in &bbs {\n+            let data = mir.basic_block_data_mut(bb);\n+\n+            if let Some(ref mut term) = data.terminator {\n+                if term_is_invoke(term) {\n+                    let term_span = term.span;\n+                    let term_scope = term.scope;\n+                    let succs = term.successors_mut();\n+                    for tgt in succs {\n+                        let num_preds = pred_count[tgt.index()];\n+                        if num_preds > 1 {\n+                            // It's a critical edge, break it\n+                            let goto = Terminator {\n+                                span: term_span,\n+                                scope: term_scope,\n+                                kind: TerminatorKind::Goto { target: *tgt }\n+                            };\n+                            let mut data = BasicBlockData::new(Some(goto));\n+                            data.is_cleanup = cleanup_map.contains(tgt.index());\n+\n+                            // Get the index it will be when inserted into the MIR\n+                            let idx = cur_len + new_blocks.len();\n+                            new_blocks.push(data);\n+                            *tgt = BasicBlock::new(idx);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        pretty::dump_mir(tcx, \"break_cleanup_edges\", &0, src, mir, None);\n+        debug!(\"Broke {} N edges\", new_blocks.len());\n+\n+        mir.basic_blocks.extend_from_slice(&new_blocks);\n+    }\n+}\n+\n+impl Pass for BreakCleanupEdges {}\n+\n+// Returns true if the terminator is a call that would use an invoke in LLVM.\n+fn term_is_invoke(term: &Terminator) -> bool {\n+    match term.kind {\n+        TerminatorKind::Call { cleanup: Some(_), .. } |\n+        TerminatorKind::Drop { unwind: Some(_), .. } => true,\n+        _ => false\n+    }\n+}"}, {"sha": "a6af30b7eec08e6cb83a0f9e497d3572242ec682", "filename": "src/librustc_mir/transform/break_critical_edges.rs", "status": "removed", "additions": 0, "deletions": 117, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/d3ec9d43cf948813fa5aab3dfacf97035ee90d16/src%2Flibrustc_mir%2Ftransform%2Fbreak_critical_edges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ec9d43cf948813fa5aab3dfacf97035ee90d16/src%2Flibrustc_mir%2Ftransform%2Fbreak_critical_edges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fbreak_critical_edges.rs?ref=d3ec9d43cf948813fa5aab3dfacf97035ee90d16", "patch": "@@ -1,117 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use rustc::ty::TyCtxt;\n-use rustc::mir::repr::*;\n-use rustc::mir::transform::{MirPass, MirSource, Pass};\n-\n-use rustc_data_structures::bitvec::BitVector;\n-\n-use traversal;\n-\n-pub struct BreakCriticalEdges;\n-\n-/**\n- * Breaks critical edges in the MIR.\n- *\n- * Critical edges are edges that are neither the only edge leaving a\n- * block, nor the only edge entering one.\n- *\n- * When you want something to happen \"along\" an edge, you can either\n- * do at the end of the predecessor block, or at the start of the\n- * successor block. Critical edges have to be broken in order to prevent\n- * \"edge actions\" from affecting other edges.\n- *\n- * This function will break those edges by inserting new blocks along them.\n- *\n- * A special case is Drop and Call terminators with unwind/cleanup successors,\n- * They use `invoke` in LLVM, which terminates a block, meaning that code cannot\n- * be inserted after them, so even if an edge is the only edge leaving a block\n- * like that, we still insert blocks if the edge is one of many entering the\n- * target.\n- *\n- * NOTE: Simplify CFG will happily undo most of the work this pass does.\n- *\n- */\n-\n-impl<'tcx> MirPass<'tcx> for BreakCriticalEdges {\n-    fn run_pass<'a>(&mut self, _: TyCtxt<'a, 'tcx, 'tcx>,\n-                    _: MirSource, mir: &mut Mir<'tcx>) {\n-        break_critical_edges(mir);\n-    }\n-}\n-\n-impl Pass for BreakCriticalEdges {}\n-\n-fn break_critical_edges(mir: &mut Mir) {\n-    let mut pred_count = vec![0u32; mir.basic_blocks.len()];\n-\n-    // Build the precedecessor map for the MIR\n-    for (_, data) in traversal::preorder(mir) {\n-        if let Some(ref term) = data.terminator {\n-            for &tgt in term.successors().iter() {\n-                pred_count[tgt.index()] += 1;\n-            }\n-        }\n-    }\n-\n-    let cleanup_map : BitVector = mir.basic_blocks\n-        .iter().map(|bb| bb.is_cleanup).collect();\n-\n-    // We need a place to store the new blocks generated\n-    let mut new_blocks = Vec::new();\n-\n-    let bbs = mir.all_basic_blocks();\n-    let cur_len = mir.basic_blocks.len();\n-\n-    for &bb in &bbs {\n-        let data = mir.basic_block_data_mut(bb);\n-\n-        if let Some(ref mut term) = data.terminator {\n-            let is_invoke = term_is_invoke(term);\n-            let term_span = term.span;\n-            let term_scope = term.scope;\n-            let succs = term.successors_mut();\n-            if succs.len() > 1 || (succs.len() > 0 && is_invoke) {\n-                for tgt in succs {\n-                    let num_preds = pred_count[tgt.index()];\n-                    if num_preds > 1 {\n-                        // It's a critical edge, break it\n-                        let goto = Terminator {\n-                            span: term_span,\n-                            scope: term_scope,\n-                            kind: TerminatorKind::Goto { target: *tgt }\n-                        };\n-                        let mut data = BasicBlockData::new(Some(goto));\n-                        data.is_cleanup = cleanup_map.contains(tgt.index());\n-\n-                        // Get the index it will be when inserted into the MIR\n-                        let idx = cur_len + new_blocks.len();\n-                        new_blocks.push(data);\n-                        *tgt = BasicBlock::new(idx);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    debug!(\"Broke {} N edges\", new_blocks.len());\n-\n-    mir.basic_blocks.extend_from_slice(&new_blocks);\n-}\n-\n-// Returns true if the terminator would use an invoke in LLVM.\n-fn term_is_invoke(term: &Terminator) -> bool {\n-    match term.kind {\n-        TerminatorKind::Call { cleanup: Some(_), .. } |\n-        TerminatorKind::Drop { unwind: Some(_), .. } => true,\n-        _ => false\n-    }\n-}"}, {"sha": "0dcb7ef84d01df4bca25c8bf469c2589a93dc4f0", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=6ba8a1a657cf37e648166ee4b41f51768ea46c1e", "patch": "@@ -13,6 +13,6 @@ pub mod simplify_cfg;\n pub mod erase_regions;\n pub mod no_landing_pads;\n pub mod type_check;\n-pub mod break_critical_edges;\n+pub mod break_cleanup_edges;\n pub mod promote_consts;\n pub mod qualify_consts;"}, {"sha": "526157a49c734252cb1417605bb48d40056233e8", "filename": "src/librustc_mir/transform/simplify_cfg.rs", "status": "modified", "additions": 124, "deletions": 59, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_cfg.rs?ref=6ba8a1a657cf37e648166ee4b41f51768ea46c1e", "patch": "@@ -8,73 +8,155 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use rustc_data_structures::bitvec::BitVector;\n use rustc::middle::const_val::ConstVal;\n use rustc::ty::TyCtxt;\n use rustc::mir::repr::*;\n use rustc::mir::transform::{MirPass, MirSource, Pass};\n use pretty;\n+use std::mem;\n \n use super::remove_dead_blocks::RemoveDeadBlocks;\n \n+use traversal;\n+\n pub struct SimplifyCfg;\n \n impl SimplifyCfg {\n     pub fn new() -> SimplifyCfg {\n         SimplifyCfg\n     }\n+}\n+\n+impl<'tcx> MirPass<'tcx> for SimplifyCfg {\n+    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>, src: MirSource, mir: &mut Mir<'tcx>) {\n+        simplify_branches(mir);\n+        RemoveDeadBlocks.run_pass(tcx, src, mir);\n+        merge_consecutive_blocks(mir);\n+        RemoveDeadBlocks.run_pass(tcx, src, mir);\n+        pretty::dump_mir(tcx, \"simplify_cfg\", &0, src, mir, None);\n+\n+        // FIXME: Should probably be moved into some kind of pass manager\n+        mir.basic_blocks.shrink_to_fit();\n+    }\n+}\n+\n+impl Pass for SimplifyCfg {}\n+\n+fn merge_consecutive_blocks(mir: &mut Mir) {\n+    // Build the precedecessor map for the MIR\n+    let mut pred_count = vec![0u32; mir.basic_blocks.len()];\n+    for (_, data) in traversal::preorder(mir) {\n+        if let Some(ref term) = data.terminator {\n+            for &tgt in term.successors().iter() {\n+                pred_count[tgt.index()] += 1;\n+            }\n+        }\n+    }\n+\n+    loop {\n+        let mut changed = false;\n+        let mut seen = BitVector::new(mir.basic_blocks.len());\n+        let mut worklist = vec![START_BLOCK];\n+        while let Some(bb) = worklist.pop() {\n+            // Temporarily take ownership of the terminator we're modifying to keep borrowck happy\n+            let mut terminator = mir.basic_block_data_mut(bb).terminator.take()\n+                .expect(\"invalid terminator state\");\n+\n+            // See if we can merge the target block into this one\n+            loop {\n+                let mut inner_change = false;\n \n-    fn remove_goto_chains(&self, mir: &mut Mir) -> bool {\n-        // Find the target at the end of the jump chain, return None if there is a loop\n-        fn final_target(mir: &Mir, mut target: BasicBlock) -> Option<BasicBlock> {\n-            // Keep track of already seen blocks to detect loops\n-            let mut seen: Vec<BasicBlock> = Vec::with_capacity(8);\n-\n-            while mir.basic_block_data(target).statements.is_empty() {\n-                // NB -- terminator may have been swapped with `None`\n-                // below, in which case we have a cycle and just want\n-                // to stop\n-                if let Some(ref terminator) = mir.basic_block_data(target).terminator {\n-                    match terminator.kind {\n-                        TerminatorKind::Goto { target: next } => {\n-                            if seen.contains(&next) {\n-                                return None;\n+                if let TerminatorKind::Goto { target } = terminator.kind {\n+                    // Don't bother trying to merge a block into itself\n+                    if target == bb {\n+                        break;\n+                    }\n+\n+                    let num_insts = mir.basic_block_data(target).statements.len();\n+                    match mir.basic_block_data(target).terminator().kind {\n+                        TerminatorKind::Goto { target: new_target } if num_insts == 0 => {\n+                            inner_change = true;\n+                            terminator.kind = TerminatorKind::Goto { target: new_target };\n+                            pred_count[target.index()] -= 1;\n+                            pred_count[new_target.index()] += 1;\n+                        }\n+                        _ if pred_count[target.index()] == 1 => {\n+                            inner_change = true;\n+                            let mut stmts = Vec::new();\n+                            {\n+                                let target_data = mir.basic_block_data_mut(target);\n+                                mem::swap(&mut stmts, &mut target_data.statements);\n+                                mem::swap(&mut terminator, target_data.terminator_mut());\n                             }\n-                            seen.push(next);\n-                            target = next;\n+\n+                            mir.basic_block_data_mut(bb).statements.append(&mut stmts);\n                         }\n-                        _ => break\n+                        _ => {}\n+                    };\n+                }\n+\n+                for target in terminator.successors_mut() {\n+                    let new_target = match final_target(mir, *target) {\n+                        Some(new_target) => new_target,\n+                        None if mir.basic_block_data(bb).statements.is_empty() => bb,\n+                        None => continue\n+                    };\n+                    if *target != new_target {\n+                        inner_change = true;\n+                        pred_count[target.index()] -= 1;\n+                        pred_count[new_target.index()] += 1;\n+                        *target = new_target;\n                     }\n-                } else {\n-                    break\n+                }\n+\n+                changed |= inner_change;\n+                if !inner_change {\n+                    break;\n                 }\n             }\n \n-            Some(target)\n+            mir.basic_block_data_mut(bb).terminator = Some(terminator);\n+\n+            for succ in mir.basic_block_data(bb).terminator().successors().iter() {\n+                if seen.insert(succ.index()) {\n+                    worklist.push(*succ);\n+                }\n+            }\n         }\n \n-        let mut changed = false;\n-        for bb in mir.all_basic_blocks() {\n-            // Temporarily take ownership of the terminator we're modifying to keep borrowck happy\n-            let mut terminator = mir.basic_block_data_mut(bb).terminator.take()\n-                                    .expect(\"invalid terminator state\");\n-\n-            debug!(\"remove_goto_chains: bb={:?} terminator={:?}\", bb, terminator);\n-\n-            for target in terminator.successors_mut() {\n-                let new_target = match final_target(mir, *target) {\n-                    Some(new_target) => new_target,\n-                    None if mir.basic_block_data(bb).statements.is_empty() => bb,\n-                    None => continue\n-                };\n-                changed |= *target != new_target;\n-                *target = new_target;\n+        if !changed {\n+            break;\n+        }\n+    }\n+}\n+\n+// Find the target at the end of the jump chain, return None if there is a loop\n+fn final_target(mir: &Mir, mut target: BasicBlock) -> Option<BasicBlock> {\n+    // Keep track of already seen blocks to detect loops\n+    let mut seen: Vec<BasicBlock> = Vec::with_capacity(8);\n+\n+    while mir.basic_block_data(target).statements.is_empty() {\n+        // NB -- terminator may have been swapped with `None` in\n+        // merge_consecutive_blocks, in which case we have a cycle and just want\n+        // to stop\n+        match mir.basic_block_data(target).terminator {\n+            Some(Terminator { kind: TerminatorKind::Goto { target: next }, .. }) =>  {\n+                if seen.contains(&next) {\n+                    return None;\n+                }\n+                seen.push(next);\n+                target = next;\n             }\n-            mir.basic_block_data_mut(bb).terminator = Some(terminator);\n+            _ => break\n         }\n-        changed\n     }\n \n-    fn simplify_branches(&self, mir: &mut Mir) -> bool {\n+    Some(target)\n+}\n+\n+fn simplify_branches(mir: &mut Mir) {\n+    loop {\n         let mut changed = false;\n \n         for bb in mir.all_basic_blocks() {\n@@ -106,25 +188,8 @@ impl SimplifyCfg {\n             }\n         }\n \n-        changed\n-    }\n-}\n-\n-impl<'tcx> MirPass<'tcx> for SimplifyCfg {\n-    fn run_pass<'a>(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    src: MirSource, mir: &mut Mir<'tcx>) {\n-        let mut counter = 0;\n-        let mut changed = true;\n-        while changed {\n-            pretty::dump_mir(tcx, \"simplify_cfg\", &counter, src, mir, None);\n-            counter += 1;\n-            changed = self.simplify_branches(mir);\n-            changed |= self.remove_goto_chains(mir);\n-            RemoveDeadBlocks.run_pass(tcx, src, mir);\n+        if !changed {\n+            break;\n         }\n-        // FIXME: Should probably be moved into some kind of pass manager\n-        mir.basic_blocks.shrink_to_fit();\n     }\n }\n-\n-impl Pass for SimplifyCfg {}"}, {"sha": "a1a966ea65a151b52022b14877d41ccb457c85ab", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=6ba8a1a657cf37e648166ee4b41f51768ea46c1e", "patch": "@@ -1949,9 +1949,7 @@ impl<'a> Resolver<'a> {\n                                     this.check_trait_item(impl_item.ident.name,\n                                                           impl_item.span,\n                                         |n, s| ResolutionError::ConstNotMemberOfTrait(n, s));\n-                                    this.with_constant_rib(|this| {\n-                                        visit::walk_impl_item(this, impl_item);\n-                                    });\n+                                    visit::walk_impl_item(this, impl_item);\n                                 }\n                                 ImplItemKind::Method(ref sig, _) => {\n                                     // If this is a trait impl, ensure the method"}, {"sha": "65c3aa12ba6c895b61b09213ed4a9bb6d124f215", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=6ba8a1a657cf37e648166ee4b41f51768ea46c1e", "patch": "@@ -59,7 +59,7 @@ use callee::{Callee, CallArgs, ArgExprs, ArgVals};\n use cleanup::{self, CleanupMethods, DropHint};\n use closure;\n use common::{Block, C_bool, C_bytes_in_context, C_i32, C_int, C_uint, C_integral};\n-use collector::{self, TransItem, TransItemState, TransItemCollectionMode};\n+use collector::{self, TransItemState, TransItemCollectionMode};\n use common::{C_null, C_struct_in_context, C_u64, C_u8, C_undef};\n use common::{CrateContext, DropFlagHintsMap, Field, FunctionContext};\n use common::{Result, NodeIdAndSpan, VariantInfo};\n@@ -80,8 +80,9 @@ use machine::{llalign_of_min, llsize_of, llsize_of_real};\n use meth;\n use mir;\n use monomorphize::{self, Instance};\n-use partitioning::{self, PartitioningStrategy, InstantiationMode, CodegenUnit};\n+use partitioning::{self, PartitioningStrategy, CodegenUnit};\n use symbol_names_test;\n+use trans_item::TransItem;\n use tvec;\n use type_::Type;\n use type_of;\n@@ -2941,8 +2942,8 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n         None => TransItemCollectionMode::Lazy\n     };\n \n-    let (items, reference_map) = time(time_passes, \"translation item collection\", || {\n-        collector::collect_crate_translation_items(scx, collection_mode)\n+    let (items, inlining_map) = time(time_passes, \"translation item collection\", || {\n+        collector::collect_crate_translation_items(&scx, collection_mode)\n     });\n \n     let strategy = if scx.sess().opts.debugging_opts.incremental.is_some() {\n@@ -2955,7 +2956,7 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n         partitioning::partition(scx.tcx(),\n                                 items.iter().cloned(),\n                                 strategy,\n-                                &reference_map)\n+                                &inlining_map)\n     });\n \n     if scx.sess().opts.debugging_opts.print_trans_items.is_some() {\n@@ -2983,18 +2984,17 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n                     output.push_str(&cgu_name[..]);\n \n                     let linkage_abbrev = match linkage {\n-                        InstantiationMode::Def(llvm::ExternalLinkage) => \"External\",\n-                        InstantiationMode::Def(llvm::AvailableExternallyLinkage) => \"Available\",\n-                        InstantiationMode::Def(llvm::LinkOnceAnyLinkage) => \"OnceAny\",\n-                        InstantiationMode::Def(llvm::LinkOnceODRLinkage) => \"OnceODR\",\n-                        InstantiationMode::Def(llvm::WeakAnyLinkage) => \"WeakAny\",\n-                        InstantiationMode::Def(llvm::WeakODRLinkage) => \"WeakODR\",\n-                        InstantiationMode::Def(llvm::AppendingLinkage) => \"Appending\",\n-                        InstantiationMode::Def(llvm::InternalLinkage) => \"Internal\",\n-                        InstantiationMode::Def(llvm::PrivateLinkage) => \"Private\",\n-                        InstantiationMode::Def(llvm::ExternalWeakLinkage) => \"ExternalWeak\",\n-                        InstantiationMode::Def(llvm::CommonLinkage) => \"Common\",\n-                        InstantiationMode::Decl => \"Declaration\",\n+                        llvm::ExternalLinkage => \"External\",\n+                        llvm::AvailableExternallyLinkage => \"Available\",\n+                        llvm::LinkOnceAnyLinkage => \"OnceAny\",\n+                        llvm::LinkOnceODRLinkage => \"OnceODR\",\n+                        llvm::WeakAnyLinkage => \"WeakAny\",\n+                        llvm::WeakODRLinkage => \"WeakODR\",\n+                        llvm::AppendingLinkage => \"Appending\",\n+                        llvm::InternalLinkage => \"Internal\",\n+                        llvm::PrivateLinkage => \"Private\",\n+                        llvm::ExternalWeakLinkage => \"ExternalWeak\",\n+                        llvm::CommonLinkage => \"Common\",\n                     };\n \n                     output.push_str(\"[\");"}, {"sha": "c0c5ea818b2d726c241a5710c000b3be2b44ad85", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=6ba8a1a657cf37e648166ee4b41f51768ea46c1e", "patch": "@@ -188,9 +188,9 @@ impl<'tcx> Callee<'tcx> {\n                 };\n                 Callee::ptr(immediate_rvalue(llfn, fn_ptr_ty))\n             }\n-            traits::VtableFnPointer(fn_ty) => {\n+            traits::VtableFnPointer(vtable_fn_pointer) => {\n                 let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n-                let llfn = trans_fn_pointer_shim(ccx, trait_closure_kind, fn_ty);\n+                let llfn = trans_fn_pointer_shim(ccx, trait_closure_kind, vtable_fn_pointer.fn_ty);\n \n                 let method_ty = def_ty(tcx, def_id, substs);\n                 let fn_ptr_ty = match method_ty.sty {\n@@ -494,7 +494,7 @@ fn get_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         _ => bug!(\"expected fn item type, found {}\", ty)\n     };\n \n-    let instance = Instance::mono(ccx.tcx(), def_id);\n+    let instance = Instance::mono(ccx.shared(), def_id);\n     if let Some(&llfn) = ccx.instances().borrow().get(&instance) {\n         return immediate_rvalue(llfn, fn_ptr_ty);\n     }"}, {"sha": "d278c3c8320fdc243b383b2d36fd43dfd6b96242", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 111, "deletions": 423, "changes": 534, "blob_url": "https://github.com/rust-lang/rust/blob/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=6ba8a1a657cf37e648166ee4b41f51768ea46c1e", "patch": "@@ -188,8 +188,6 @@\n //! this is not implemented however: a translation item will be produced\n //! regardless of whether it is actually needed or not.\n \n-use rustc_data_structures::bitvec::BitVector;\n-\n use rustc::hir;\n use rustc::hir::intravisit as hir_visit;\n \n@@ -198,99 +196,60 @@ use rustc::hir::def_id::DefId;\n use rustc::middle::lang_items::{ExchangeFreeFnLangItem, ExchangeMallocFnLangItem};\n use rustc::traits;\n use rustc::ty::subst::{self, Substs, Subst};\n-use rustc::ty::{self, Ty, TypeFoldable, TyCtxt};\n+use rustc::ty::{self, TypeFoldable, TyCtxt};\n use rustc::ty::adjustment::CustomCoerceUnsized;\n use rustc::mir::repr as mir;\n use rustc::mir::visit as mir_visit;\n use rustc::mir::visit::Visitor as MirVisitor;\n \n-use syntax::ast::{self, NodeId};\n+use syntax::abi::Abi;\n use syntax::codemap::DUMMY_SP;\n-use syntax::{attr, errors};\n-use syntax::parse::token;\n-\n-use base::{custom_coerce_unsize_info, llvm_linkage_by_name};\n+use syntax::errors;\n+use base::custom_coerce_unsize_info;\n use context::SharedCrateContext;\n use common::{fulfill_obligation, normalize_and_test_predicates, type_is_sized};\n use glue::{self, DropGlueKind};\n-use llvm;\n use meth;\n use monomorphize::{self, Instance};\n use util::nodemap::{FnvHashSet, FnvHashMap, DefIdMap};\n \n-use std::hash::{Hash, Hasher};\n+use trans_item::{TransItem, type_to_string, def_id_to_string};\n \n #[derive(PartialEq, Eq, Hash, Clone, Copy, Debug)]\n pub enum TransItemCollectionMode {\n     Eager,\n     Lazy\n }\n \n-#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n-pub enum TransItem<'tcx> {\n-    DropGlue(DropGlueKind<'tcx>),\n-    Fn(Instance<'tcx>),\n-    Static(NodeId)\n-}\n-\n-impl<'tcx> Hash for TransItem<'tcx> {\n-    fn hash<H: Hasher>(&self, s: &mut H) {\n-        match *self {\n-            TransItem::DropGlue(t) => {\n-                0u8.hash(s);\n-                t.hash(s);\n-            },\n-            TransItem::Fn(instance) => {\n-                1u8.hash(s);\n-                instance.def.hash(s);\n-                (instance.substs as *const _ as usize).hash(s);\n-            }\n-            TransItem::Static(node_id) => {\n-                2u8.hash(s);\n-                node_id.hash(s);\n-            }\n-        };\n-    }\n-}\n-\n /// Maps every translation item to all translation items it references in its\n /// body.\n-pub struct ReferenceMap<'tcx> {\n-    // Maps a source translation item to a range of target translation items.\n+pub struct InliningMap<'tcx> {\n+    // Maps a source translation item to a range of target translation items\n+    // that are potentially inlined by LLVM into the source.\n     // The two numbers in the tuple are the start (inclusive) and\n-    // end index (exclusive) within the `targets` and the `inlined` vecs.\n+    // end index (exclusive) within the `targets` vecs.\n     index: FnvHashMap<TransItem<'tcx>, (usize, usize)>,\n     targets: Vec<TransItem<'tcx>>,\n-    inlined: BitVector\n }\n \n-impl<'tcx> ReferenceMap<'tcx> {\n+impl<'tcx> InliningMap<'tcx> {\n \n-    fn new() -> ReferenceMap<'tcx> {\n-        ReferenceMap {\n+    fn new() -> InliningMap<'tcx> {\n+        InliningMap {\n             index: FnvHashMap(),\n             targets: Vec::new(),\n-            inlined: BitVector::new(64 * 256),\n         }\n     }\n \n-    fn record_references<I>(&mut self, source: TransItem<'tcx>, targets: I)\n-        where I: Iterator<Item=(TransItem<'tcx>, bool)>\n+    fn record_inlining_canditates<I>(&mut self,\n+                                     source: TransItem<'tcx>,\n+                                     targets: I)\n+        where I: Iterator<Item=TransItem<'tcx>>\n     {\n         assert!(!self.index.contains_key(&source));\n \n         let start_index = self.targets.len();\n-\n-        for (target, inlined) in targets {\n-            let index = self.targets.len();\n-            self.targets.push(target);\n-            self.inlined.grow(index + 1);\n-\n-            if inlined {\n-                self.inlined.insert(index);\n-            }\n-        }\n-\n+        self.targets.extend(targets);\n         let end_index = self.targets.len();\n         self.index.insert(source, (start_index, end_index));\n     }\n@@ -301,28 +260,17 @@ impl<'tcx> ReferenceMap<'tcx> {\n         where F: FnMut(TransItem<'tcx>) {\n         if let Some(&(start_index, end_index)) = self.index.get(&source)\n         {\n-            for index in start_index .. end_index {\n-                if self.inlined.contains(index) {\n-                    f(self.targets[index])\n-                }\n+            for candidate in &self.targets[start_index .. end_index] {\n+                f(*candidate)\n             }\n         }\n     }\n-\n-    pub fn get_direct_references_from(&self, source: TransItem<'tcx>) -> &[TransItem<'tcx>]\n-    {\n-        if let Some(&(start_index, end_index)) = self.index.get(&source) {\n-            &self.targets[start_index .. end_index]\n-        } else {\n-            &self.targets[0 .. 0]\n-        }\n-    }\n }\n \n pub fn collect_crate_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                                                  mode: TransItemCollectionMode)\n                                                  -> (FnvHashSet<TransItem<'tcx>>,\n-                                                     ReferenceMap<'tcx>) {\n+                                                     InliningMap<'tcx>) {\n     // We are not tracking dependencies of this pass as it has to be re-executed\n     // every time no matter what.\n     scx.tcx().dep_graph.with_ignore(|| {\n@@ -331,17 +279,17 @@ pub fn collect_crate_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a, 't\n         debug!(\"Building translation item graph, beginning at roots\");\n         let mut visited = FnvHashSet();\n         let mut recursion_depths = DefIdMap();\n-        let mut reference_map = ReferenceMap::new();\n+        let mut inlining_map = InliningMap::new();\n \n         for root in roots {\n             collect_items_rec(scx,\n                               root,\n                               &mut visited,\n                               &mut recursion_depths,\n-                              &mut reference_map);\n+                              &mut inlining_map);\n         }\n \n-        (visited, reference_map)\n+        (visited, inlining_map)\n     })\n }\n \n@@ -372,7 +320,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n                                    starting_point: TransItem<'tcx>,\n                                    visited: &mut FnvHashSet<TransItem<'tcx>>,\n                                    recursion_depths: &mut DefIdMap<usize>,\n-                                   reference_map: &mut ReferenceMap<'tcx>) {\n+                                   inlining_map: &mut InliningMap<'tcx>) {\n     if !visited.insert(starting_point.clone()) {\n         // We've been here already, no need to search again.\n         return;\n@@ -392,7 +340,26 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n             let ty = scx.tcx().lookup_item_type(def_id).ty;\n             let ty = glue::get_drop_glue_type(scx.tcx(), ty);\n             neighbors.push(TransItem::DropGlue(DropGlueKind::Ty(ty)));\n+\n             recursion_depth_reset = None;\n+\n+            // Scan the MIR in order to find function calls, closures, and\n+            // drop-glue\n+            let mir = errors::expect(scx.sess().diagnostic(), scx.get_mir(def_id),\n+                || format!(\"Could not find MIR for static: {:?}\", def_id));\n+\n+            let empty_substs = scx.empty_substs_for_def_id(def_id);\n+            let mut visitor = MirNeighborCollector {\n+                scx: scx,\n+                mir: &mir,\n+                output: &mut neighbors,\n+                param_substs: empty_substs\n+            };\n+\n+            visitor.visit_mir(&mir);\n+            for promoted in &mir.promoted {\n+                visitor.visit_mir(promoted);\n+            }\n         }\n         TransItem::Fn(instance) => {\n             // Keep track of the monomorphization recursion depth\n@@ -419,10 +386,10 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n         }\n     }\n \n-    record_references(scx.tcx(), starting_point, &neighbors[..], reference_map);\n+    record_inlining_canditates(scx.tcx(), starting_point, &neighbors[..], inlining_map);\n \n     for neighbour in neighbors {\n-        collect_items_rec(scx, neighbour, visited, recursion_depths, reference_map);\n+        collect_items_rec(scx, neighbour, visited, recursion_depths, inlining_map);\n     }\n \n     if let Some((def_id, depth)) = recursion_depth_reset {\n@@ -432,17 +399,19 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n     debug!(\"END collect_items_rec({})\", starting_point.to_string(scx.tcx()));\n }\n \n-fn record_references<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                               caller: TransItem<'tcx>,\n-                               callees: &[TransItem<'tcx>],\n-                               reference_map: &mut ReferenceMap<'tcx>) {\n-    let iter = callees.into_iter()\n-                      .map(|callee| {\n-                        let is_inlining_candidate = callee.is_from_extern_crate() ||\n-                                                    callee.requests_inline(tcx);\n-                        (*callee, is_inlining_candidate)\n-                      });\n-    reference_map.record_references(caller, iter);\n+fn record_inlining_canditates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                        caller: TransItem<'tcx>,\n+                                        callees: &[TransItem<'tcx>],\n+                                        inlining_map: &mut InliningMap<'tcx>) {\n+    let is_inlining_candidate = |trans_item: &TransItem<'tcx>| {\n+        trans_item.is_from_extern_crate() || trans_item.requests_inline(tcx)\n+    };\n+\n+    let inlining_candidates = callees.into_iter()\n+                                     .map(|x| *x)\n+                                     .filter(is_inlining_candidate);\n+\n+    inlining_map.record_inlining_canditates(caller, inlining_candidates);\n }\n \n fn check_recursion_limit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -527,10 +496,11 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                         .unwrap_or_else(|e| self.scx.sess().fatal(&e));\n \n                 assert!(can_have_local_instance(self.scx.tcx(), exchange_malloc_fn_def_id));\n+                let empty_substs = self.scx.empty_substs_for_def_id(exchange_malloc_fn_def_id);\n                 let exchange_malloc_fn_trans_item =\n                     create_fn_trans_item(self.scx.tcx(),\n                                          exchange_malloc_fn_def_id,\n-                                         self.scx.tcx().mk_substs(Substs::empty()),\n+                                         empty_substs,\n                                          self.param_substs);\n \n                 self.output.push(exchange_malloc_fn_trans_item);\n@@ -633,6 +603,49 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             can_have_local_instance(tcx, def_id)\n         }\n     }\n+\n+    // This takes care of the \"drop_in_place\" intrinsic for which we otherwise\n+    // we would not register drop-glues.\n+    fn visit_terminator_kind(&mut self,\n+                             block: mir::BasicBlock,\n+                             kind: &mir::TerminatorKind<'tcx>) {\n+        let tcx = self.scx.tcx();\n+        match *kind {\n+            mir::TerminatorKind::Call {\n+                func: mir::Operand::Constant(ref constant),\n+                ref args,\n+                ..\n+            } => {\n+                match constant.ty.sty {\n+                    ty::TyFnDef(def_id, _, bare_fn_ty)\n+                        if is_drop_in_place_intrinsic(tcx, def_id, bare_fn_ty) => {\n+                        let operand_ty = self.mir.operand_ty(tcx, &args[0]);\n+                        if let ty::TyRawPtr(mt) = operand_ty.sty {\n+                            let operand_ty = monomorphize::apply_param_substs(tcx,\n+                                                                              self.param_substs,\n+                                                                              &mt.ty);\n+                            self.output.push(TransItem::DropGlue(DropGlueKind::Ty(operand_ty)));\n+                        } else {\n+                            bug!(\"Has the drop_in_place() intrinsic's signature changed?\")\n+                        }\n+                    }\n+                    _ => { /* Nothing to do. */ }\n+                }\n+            }\n+            _ => { /* Nothing to do. */ }\n+        }\n+\n+        self.super_terminator_kind(block, kind);\n+\n+        fn is_drop_in_place_intrinsic<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                                def_id: DefId,\n+                                                bare_fn_ty: &ty::BareFnTy<'tcx>)\n+                                                -> bool {\n+            (bare_fn_ty.abi == Abi::RustIntrinsic ||\n+             bare_fn_ty.abi == Abi::PlatformIntrinsic) &&\n+            tcx.item_name(def_id).as_str() == \"drop_in_place\"\n+        }\n+    }\n }\n \n fn can_have_local_instance<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -667,10 +680,11 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                                          .unwrap_or_else(|e| scx.sess().fatal(&e));\n \n         assert!(can_have_local_instance(scx.tcx(), exchange_free_fn_def_id));\n+        let fn_substs = scx.empty_substs_for_def_id(exchange_free_fn_def_id);\n         let exchange_free_fn_trans_item =\n             create_fn_trans_item(scx.tcx(),\n                                  exchange_free_fn_def_id,\n-                                 scx.tcx().mk_substs(Substs::empty()),\n+                                 fn_substs,\n                                  scx.tcx().mk_substs(Substs::empty()));\n \n         output.push(exchange_free_fn_trans_item);\n@@ -730,7 +744,6 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n         ty::TyRef(..)   |\n         ty::TyFnDef(..) |\n         ty::TyFnPtr(_)  |\n-        ty::TySlice(_)  |\n         ty::TyTrait(_)  => {\n             /* nothing to do */\n         }\n@@ -756,6 +769,7 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n             }\n         }\n         ty::TyBox(inner_type)      |\n+        ty::TySlice(inner_type)    |\n         ty::TyArray(inner_type, _) => {\n             let inner_type = glue::get_drop_glue_type(scx.tcx(), inner_type);\n             if glue::type_needs_drop(scx.tcx(), inner_type) {\n@@ -777,6 +791,8 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n             bug!(\"encountered unexpected type\");\n         }\n     }\n+\n+\n }\n \n fn do_static_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n@@ -1097,7 +1113,7 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n                     debug!(\"RootCollector: ItemFn({})\",\n                            def_id_to_string(self.scx.tcx(), def_id));\n \n-                    let instance = Instance::mono(self.scx.tcx(), def_id);\n+                    let instance = Instance::mono(self.scx, def_id);\n                     self.output.push(TransItem::Fn(instance));\n                 }\n             }\n@@ -1134,7 +1150,7 @@ impl<'b, 'a, 'v> hir_visit::Visitor<'v> for RootCollector<'b, 'a, 'v> {\n                     debug!(\"RootCollector: MethodImplItem({})\",\n                            def_id_to_string(self.scx.tcx(), def_id));\n \n-                    let instance = Instance::mono(self.scx.tcx(), def_id);\n+                    let instance = Instance::mono(self.scx, def_id);\n                     self.output.push(TransItem::Fn(instance));\n                 }\n             }\n@@ -1210,334 +1226,6 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-//=-----------------------------------------------------------------------------\n-// TransItem String Keys\n-//=-----------------------------------------------------------------------------\n-\n-// The code below allows for producing a unique string key for a trans item.\n-// These keys are used by the handwritten auto-tests, so they need to be\n-// predictable and human-readable.\n-//\n-// Note: A lot of this could looks very similar to what's already in the\n-//       ppaux module. It would be good to refactor things so we only have one\n-//       parameterizable implementation for printing types.\n-\n-/// Same as `unique_type_name()` but with the result pushed onto the given\n-/// `output` parameter.\n-pub fn push_unique_type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                       t: ty::Ty<'tcx>,\n-                                       output: &mut String) {\n-    match t.sty {\n-        ty::TyBool              => output.push_str(\"bool\"),\n-        ty::TyChar              => output.push_str(\"char\"),\n-        ty::TyStr               => output.push_str(\"str\"),\n-        ty::TyInt(ast::IntTy::Is)    => output.push_str(\"isize\"),\n-        ty::TyInt(ast::IntTy::I8)    => output.push_str(\"i8\"),\n-        ty::TyInt(ast::IntTy::I16)   => output.push_str(\"i16\"),\n-        ty::TyInt(ast::IntTy::I32)   => output.push_str(\"i32\"),\n-        ty::TyInt(ast::IntTy::I64)   => output.push_str(\"i64\"),\n-        ty::TyUint(ast::UintTy::Us)   => output.push_str(\"usize\"),\n-        ty::TyUint(ast::UintTy::U8)   => output.push_str(\"u8\"),\n-        ty::TyUint(ast::UintTy::U16)  => output.push_str(\"u16\"),\n-        ty::TyUint(ast::UintTy::U32)  => output.push_str(\"u32\"),\n-        ty::TyUint(ast::UintTy::U64)  => output.push_str(\"u64\"),\n-        ty::TyFloat(ast::FloatTy::F32) => output.push_str(\"f32\"),\n-        ty::TyFloat(ast::FloatTy::F64) => output.push_str(\"f64\"),\n-        ty::TyStruct(adt_def, substs) |\n-        ty::TyEnum(adt_def, substs) => {\n-            push_item_name(tcx, adt_def.did, output);\n-            push_type_params(tcx, &substs.types, &[], output);\n-        },\n-        ty::TyTuple(component_types) => {\n-            output.push('(');\n-            for &component_type in component_types {\n-                push_unique_type_name(tcx, component_type, output);\n-                output.push_str(\", \");\n-            }\n-            if !component_types.is_empty() {\n-                output.pop();\n-                output.pop();\n-            }\n-            output.push(')');\n-        },\n-        ty::TyBox(inner_type) => {\n-            output.push_str(\"Box<\");\n-            push_unique_type_name(tcx, inner_type, output);\n-            output.push('>');\n-        },\n-        ty::TyRawPtr(ty::TypeAndMut { ty: inner_type, mutbl } ) => {\n-            output.push('*');\n-            match mutbl {\n-                hir::MutImmutable => output.push_str(\"const \"),\n-                hir::MutMutable => output.push_str(\"mut \"),\n-            }\n-\n-            push_unique_type_name(tcx, inner_type, output);\n-        },\n-        ty::TyRef(_, ty::TypeAndMut { ty: inner_type, mutbl }) => {\n-            output.push('&');\n-            if mutbl == hir::MutMutable {\n-                output.push_str(\"mut \");\n-            }\n-\n-            push_unique_type_name(tcx, inner_type, output);\n-        },\n-        ty::TyArray(inner_type, len) => {\n-            output.push('[');\n-            push_unique_type_name(tcx, inner_type, output);\n-            output.push_str(&format!(\"; {}\", len));\n-            output.push(']');\n-        },\n-        ty::TySlice(inner_type) => {\n-            output.push('[');\n-            push_unique_type_name(tcx, inner_type, output);\n-            output.push(']');\n-        },\n-        ty::TyTrait(ref trait_data) => {\n-            push_item_name(tcx, trait_data.principal.skip_binder().def_id, output);\n-            push_type_params(tcx,\n-                             &trait_data.principal.skip_binder().substs.types,\n-                             &trait_data.bounds.projection_bounds,\n-                             output);\n-        },\n-        ty::TyFnDef(_, _, &ty::BareFnTy{ unsafety, abi, ref sig } ) |\n-        ty::TyFnPtr(&ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n-            if unsafety == hir::Unsafety::Unsafe {\n-                output.push_str(\"unsafe \");\n-            }\n-\n-            if abi != ::abi::Abi::Rust {\n-                output.push_str(\"extern \\\"\");\n-                output.push_str(abi.name());\n-                output.push_str(\"\\\" \");\n-            }\n-\n-            output.push_str(\"fn(\");\n-\n-            let sig = tcx.erase_late_bound_regions(sig);\n-            if !sig.inputs.is_empty() {\n-                for &parameter_type in &sig.inputs {\n-                    push_unique_type_name(tcx, parameter_type, output);\n-                    output.push_str(\", \");\n-                }\n-                output.pop();\n-                output.pop();\n-            }\n-\n-            if sig.variadic {\n-                if !sig.inputs.is_empty() {\n-                    output.push_str(\", ...\");\n-                } else {\n-                    output.push_str(\"...\");\n-                }\n-            }\n-\n-            output.push(')');\n-\n-            match sig.output {\n-                ty::FnConverging(result_type) if result_type.is_nil() => {}\n-                ty::FnConverging(result_type) => {\n-                    output.push_str(\" -> \");\n-                    push_unique_type_name(tcx, result_type, output);\n-                }\n-                ty::FnDiverging => {\n-                    output.push_str(\" -> !\");\n-                }\n-            }\n-        },\n-        ty::TyClosure(def_id, ref closure_substs) => {\n-            push_item_name(tcx, def_id, output);\n-            output.push_str(\"{\");\n-            output.push_str(&format!(\"{}:{}\", def_id.krate, def_id.index.as_usize()));\n-            output.push_str(\"}\");\n-            push_type_params(tcx, &closure_substs.func_substs.types, &[], output);\n-        }\n-        ty::TyError |\n-        ty::TyInfer(_) |\n-        ty::TyProjection(..) |\n-        ty::TyParam(_) => {\n-            bug!(\"debuginfo: Trying to create type name for \\\n-                  unexpected type: {:?}\", t);\n-        }\n-    }\n-}\n-\n-fn push_item_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            def_id: DefId,\n-                            output: &mut String) {\n-    let def_path = tcx.def_path(def_id);\n-\n-    // some_crate::\n-    output.push_str(&tcx.crate_name(def_path.krate));\n-    output.push_str(\"::\");\n-\n-    // foo::bar::ItemName::\n-    for part in tcx.def_path(def_id).data {\n-        output.push_str(&format!(\"{}[{}]::\",\n-                        part.data.as_interned_str(),\n-                        part.disambiguator));\n-    }\n-\n-    // remove final \"::\"\n-    output.pop();\n-    output.pop();\n-}\n-\n-fn push_type_params<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              types: &'tcx subst::VecPerParamSpace<Ty<'tcx>>,\n-                              projections: &[ty::PolyProjectionPredicate<'tcx>],\n-                              output: &mut String) {\n-    if types.is_empty() && projections.is_empty() {\n-        return;\n-    }\n-\n-    output.push('<');\n-\n-    for &type_parameter in types {\n-        push_unique_type_name(tcx, type_parameter, output);\n-        output.push_str(\", \");\n-    }\n-\n-    for projection in projections {\n-        let projection = projection.skip_binder();\n-        let name = token::get_ident_interner().get(projection.projection_ty.item_name);\n-        output.push_str(&name[..]);\n-        output.push_str(\"=\");\n-        push_unique_type_name(tcx, projection.ty, output);\n-        output.push_str(\", \");\n-    }\n-\n-    output.pop();\n-    output.pop();\n-\n-    output.push('>');\n-}\n-\n-fn push_instance_as_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                     instance: Instance<'tcx>,\n-                                     output: &mut String) {\n-    push_item_name(tcx, instance.def, output);\n-    push_type_params(tcx, &instance.substs.types, &[], output);\n-}\n-\n-pub fn def_id_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                  def_id: DefId) -> String {\n-    let mut output = String::new();\n-    push_item_name(tcx, def_id, &mut output);\n-    output\n-}\n-\n-fn type_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            ty: ty::Ty<'tcx>)\n-                            -> String {\n-    let mut output = String::new();\n-    push_unique_type_name(tcx, ty, &mut output);\n-    output\n-}\n-\n-impl<'a, 'tcx> TransItem<'tcx> {\n-    pub fn requests_inline(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n-        match *self {\n-            TransItem::Fn(ref instance) => {\n-                let attributes = tcx.get_attrs(instance.def);\n-                attr::requests_inline(&attributes[..])\n-            }\n-            TransItem::DropGlue(..) => true,\n-            TransItem::Static(..)   => false,\n-        }\n-    }\n-\n-    pub fn is_from_extern_crate(&self) -> bool {\n-        match *self {\n-            TransItem::Fn(ref instance) => !instance.def.is_local(),\n-            TransItem::DropGlue(..) |\n-            TransItem::Static(..)   => false,\n-        }\n-    }\n-\n-    pub fn is_lazily_instantiated(&self) -> bool {\n-        match *self {\n-            TransItem::Fn(ref instance) => !instance.substs.types.is_empty(),\n-            TransItem::DropGlue(..) => true,\n-            TransItem::Static(..)   => false,\n-        }\n-    }\n-\n-    pub fn explicit_linkage(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<llvm::Linkage> {\n-        let def_id = match *self {\n-            TransItem::Fn(ref instance) => instance.def,\n-            TransItem::Static(node_id) => tcx.map.local_def_id(node_id),\n-            TransItem::DropGlue(..) => return None,\n-        };\n-\n-        let attributes = tcx.get_attrs(def_id);\n-        if let Some(name) = attr::first_attr_value_str_by_name(&attributes, \"linkage\") {\n-            if let Some(linkage) = llvm_linkage_by_name(&name) {\n-                Some(linkage)\n-            } else {\n-                let span = tcx.map.span_if_local(def_id);\n-                if let Some(span) = span {\n-                    tcx.sess.span_fatal(span, \"invalid linkage specified\")\n-                } else {\n-                    tcx.sess.fatal(&format!(\"invalid linkage specified: {}\", name))\n-                }\n-            }\n-        } else {\n-            None\n-        }\n-    }\n-\n-    pub fn to_string(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> String {\n-        let hir_map = &tcx.map;\n-\n-        return match *self {\n-            TransItem::DropGlue(dg) => {\n-                let mut s = String::with_capacity(32);\n-                match dg {\n-                    DropGlueKind::Ty(_) => s.push_str(\"drop-glue \"),\n-                    DropGlueKind::TyContents(_) => s.push_str(\"drop-glue-contents \"),\n-                };\n-                push_unique_type_name(tcx, dg.ty(), &mut s);\n-                s\n-            }\n-            TransItem::Fn(instance) => {\n-                to_string_internal(tcx, \"fn \", instance)\n-            },\n-            TransItem::Static(node_id) => {\n-                let def_id = hir_map.local_def_id(node_id);\n-                let instance = Instance::mono(tcx, def_id);\n-                to_string_internal(tcx, \"static \", instance)\n-            },\n-        };\n-\n-        fn to_string_internal<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                        prefix: &str,\n-                                        instance: Instance<'tcx>)\n-                                        -> String {\n-            let mut result = String::with_capacity(32);\n-            result.push_str(prefix);\n-            push_instance_as_string(tcx, instance, &mut result);\n-            result\n-        }\n-    }\n-\n-    fn to_raw_string(&self) -> String {\n-        match *self {\n-            TransItem::DropGlue(dg) => {\n-                format!(\"DropGlue({})\", dg.ty() as *const _ as usize)\n-            }\n-            TransItem::Fn(instance) => {\n-                format!(\"Fn({:?}, {})\",\n-                         instance.def,\n-                         instance.substs as *const _ as usize)\n-            }\n-            TransItem::Static(id) => {\n-                format!(\"Static({:?})\", id)\n-            }\n-        }\n-    }\n-}\n-\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub enum TransItemState {\n     PredictedAndGenerated,\n@@ -1546,7 +1234,7 @@ pub enum TransItemState {\n }\n \n pub fn collecting_debug_information(scx: &SharedCrateContext) -> bool {\n-    return cfg!(debug_assertions) &&\n+    return scx.sess().opts.cg.debug_assertions == Some(true) &&\n            scx.sess().opts.debugging_opts.print_trans_items.is_some();\n }\n "}, {"sha": "3e876eb3d7de079fc53d08ddd73d72711ac611b9", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=6ba8a1a657cf37e648166ee4b41f51768ea46c1e", "patch": "@@ -21,7 +21,8 @@ use rustc::hir::map as hir_map;\n use {abi, adt, closure, debuginfo, expr, machine};\n use base::{self, exported_name, imported_name, push_ctxt};\n use callee::Callee;\n-use collector::{self, TransItem};\n+use collector;\n+use trans_item::TransItem;\n use common::{type_is_sized, C_nil, const_get_elt};\n use common::{CrateContext, C_integral, C_floating, C_bool, C_str_slice, C_bytes, val_ty};\n use common::{C_struct, C_undef, const_to_opt_int, const_to_opt_uint, VariantInfo, C_uint};\n@@ -1011,7 +1012,7 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n                             -> Datum<'tcx, Lvalue> {\n     let ty = ccx.tcx().lookup_item_type(def_id).ty;\n \n-    let instance = Instance::mono(ccx.tcx(), def_id);\n+    let instance = Instance::mono(ccx.shared(), def_id);\n     if let Some(&g) = ccx.instances().borrow().get(&instance) {\n         return Datum::new(g, ty, Lvalue::new(\"static\"));\n     }"}, {"sha": "60c6af84ebbb6ecf8f56d1d1776a4cc19787614d", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=6ba8a1a657cf37e648166ee4b41f51768ea46c1e", "patch": "@@ -27,8 +27,9 @@ use glue::DropGlueKind;\n use mir::CachedMir;\n use monomorphize::Instance;\n \n-use collector::{TransItem, TransItemState};\n use partitioning::CodegenUnit;\n+use collector::TransItemState;\n+use trans_item::TransItem;\n use type_::{Type, TypeNames};\n use rustc::ty::subst::{Substs, VecPerParamSpace};\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -487,6 +488,21 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n     pub fn translation_items(&self) -> &RefCell<FnvHashMap<TransItem<'tcx>, TransItemState>> {\n         &self.translation_items\n     }\n+\n+    /// Given the def-id of some item that has no type parameters, make\n+    /// a suitable \"empty substs\" for it.\n+    pub fn empty_substs_for_def_id(&self, item_def_id: DefId) -> &'tcx Substs<'tcx> {\n+        let scheme = self.tcx().lookup_item_type(item_def_id);\n+        self.empty_substs_for_scheme(&scheme)\n+    }\n+\n+    pub fn empty_substs_for_scheme(&self, scheme: &ty::TypeScheme<'tcx>)\n+                                   -> &'tcx Substs<'tcx> {\n+        assert!(scheme.generics.types.is_empty());\n+        self.tcx().mk_substs(\n+            Substs::new(VecPerParamSpace::empty(),\n+                        scheme.generics.regions.map(|_| ty::ReStatic)))\n+    }\n }\n \n impl<'tcx> LocalCrateContext<'tcx> {\n@@ -901,16 +917,12 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     /// Given the def-id of some item that has no type parameters, make\n     /// a suitable \"empty substs\" for it.\n     pub fn empty_substs_for_def_id(&self, item_def_id: DefId) -> &'tcx Substs<'tcx> {\n-        let scheme = self.tcx().lookup_item_type(item_def_id);\n-        self.empty_substs_for_scheme(&scheme)\n+        self.shared().empty_substs_for_def_id(item_def_id)\n     }\n \n     pub fn empty_substs_for_scheme(&self, scheme: &ty::TypeScheme<'tcx>)\n                                    -> &'tcx Substs<'tcx> {\n-        assert!(scheme.generics.types.is_empty());\n-        self.tcx().mk_substs(\n-            Substs::new(VecPerParamSpace::empty(),\n-                        scheme.generics.regions.map(|_| ty::ReStatic)))\n+        self.shared().empty_substs_for_scheme(scheme)\n     }\n }\n "}, {"sha": "10e33195305f616bfbf29975417b028ae413d9d4", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=6ba8a1a657cf37e648166ee4b41f51768ea46c1e", "patch": "@@ -29,13 +29,14 @@ use build::*;\n use callee::{Callee, ArgVals};\n use cleanup;\n use cleanup::CleanupMethods;\n-use collector::{self, TransItem};\n+use collector;\n use common::*;\n use debuginfo::DebugLoc;\n use declare;\n use expr;\n use machine::*;\n use monomorphize;\n+use trans_item::TransItem;\n use type_of::{type_of, sizing_type_of, align_of};\n use type_::Type;\n use value::Value;"}, {"sha": "bccb5aa050b511c60ffe7356efd6d3fd47b4d6c3", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=6ba8a1a657cf37e648166ee4b41f51768ea46c1e", "patch": "@@ -123,6 +123,7 @@ mod mir;\n mod monomorphize;\n mod partitioning;\n mod symbol_names_test;\n+mod trans_item;\n mod tvec;\n mod type_;\n mod type_of;"}, {"sha": "64ee18fccef37f32a1b63be1a47d4b945624fea2", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=6ba8a1a657cf37e648166ee4b41f51768ea46c1e", "patch": "@@ -176,7 +176,10 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                          trait_closure_kind);\n                 vec![llfn].into_iter()\n             }\n-            traits::VtableFnPointer(bare_fn_ty) => {\n+            traits::VtableFnPointer(\n+                traits::VtableFnPointerData {\n+                    fn_ty: bare_fn_ty,\n+                    nested: _ }) => {\n                 let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_ref.def_id()).unwrap();\n                 vec![trans_fn_pointer_shim(ccx, trait_closure_kind, bare_fn_ty)].into_iter()\n             }"}, {"sha": "4e3386bc736775440d22bb3f1fd6d015dbe9c392", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=6ba8a1a657cf37e648166ee4b41f51768ea46c1e", "patch": "@@ -24,6 +24,7 @@ use meth;\n use type_of;\n use glue;\n use type_::Type;\n+use rustc_data_structures::fnv::FnvHashMap;\n \n use super::{MirContext, TempRef, drop};\n use super::constant::Const;\n@@ -95,17 +96,32 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     adt::trans_get_discr(bcx, &repr, discr_lvalue.llval, None, true)\n                 );\n \n-                // The else branch of the Switch can't be hit, so branch to an unreachable\n-                // instruction so LLVM knows that\n-                let unreachable_blk = self.unreachable_block();\n-                let switch = bcx.switch(discr, unreachable_blk.llbb, targets.len());\n+                let mut bb_hist = FnvHashMap();\n+                for target in targets {\n+                    *bb_hist.entry(target).or_insert(0) += 1;\n+                }\n+                let (default_bb, default_blk) = match bb_hist.iter().max_by_key(|&(_, c)| c) {\n+                    // If a single target basic blocks is predominant, promote that to be the\n+                    // default case for the switch instruction to reduce the size of the generated\n+                    // code. This is especially helpful in cases like an if-let on a huge enum.\n+                    // Note: This optimization is only valid for exhaustive matches.\n+                    Some((&&bb, &c)) if c > targets.len() / 2 => {\n+                        (Some(bb), self.blocks[bb.index()])\n+                    }\n+                    // We're generating an exhaustive switch, so the else branch\n+                    // can't be hit.  Branching to an unreachable instruction\n+                    // lets LLVM know this\n+                    _ => (None, self.unreachable_block())\n+                };\n+                let switch = bcx.switch(discr, default_blk.llbb, targets.len());\n                 assert_eq!(adt_def.variants.len(), targets.len());\n-                for (adt_variant, target) in adt_def.variants.iter().zip(targets) {\n-                    let llval = bcx.with_block(|bcx|\n-                        adt::trans_case(bcx, &repr, Disr::from(adt_variant.disr_val))\n-                    );\n-                    let llbb = self.llblock(*target);\n-                    build::AddCase(switch, llval, llbb)\n+                for (adt_variant, &target) in adt_def.variants.iter().zip(targets) {\n+                    if default_bb != Some(target) {\n+                        let llbb = self.llblock(target);\n+                        let llval = bcx.with_block(|bcx| adt::trans_case(\n+                                bcx, &repr, Disr::from(adt_variant.disr_val)));\n+                        build::AddCase(switch, llval, llbb)\n+                    }\n                 }\n             }\n "}, {"sha": "0403c7b1f757b89fb166b9744c869af6fa67627b", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=6ba8a1a657cf37e648166ee4b41f51768ea46c1e", "patch": "@@ -854,6 +854,6 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n pub fn trans_static_initializer(ccx: &CrateContext, def_id: DefId)\n                                 -> Result<ValueRef, ConstEvalFailure> {\n-    let instance = Instance::mono(ccx.tcx(), def_id);\n+    let instance = Instance::mono(ccx.shared(), def_id);\n     MirConstContext::trans_def(ccx, instance, vec![]).map(|c| c.llval)\n }"}, {"sha": "dfaf84ecef02397faabed4ace6926b0140c51f97", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=6ba8a1a657cf37e648166ee4b41f51768ea46c1e", "patch": "@@ -183,8 +183,8 @@ impl<'tcx> Instance<'tcx> {\n         assert!(substs.regions.iter().all(|&r| r == ty::ReStatic));\n         Instance { def: def_id, substs: substs }\n     }\n-    pub fn mono<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Instance<'tcx> {\n-        Instance::new(def_id, tcx.mk_substs(Substs::empty()))\n+    pub fn mono<'a>(scx: &SharedCrateContext<'a, 'tcx>, def_id: DefId) -> Instance<'tcx> {\n+        Instance::new(def_id, scx.empty_substs_for_def_id(def_id))\n     }\n }\n "}, {"sha": "098ba759247be44d8a4b128cc290921f7e067994", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 17, "deletions": 59, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=6ba8a1a657cf37e648166ee4b41f51768ea46c1e", "patch": "@@ -116,30 +116,20 @@\n //! source-level module, functions from the same module will be available for\n //! inlining, even when they are not marked #[inline].\n \n-use collector::{TransItem, ReferenceMap};\n+use collector::InliningMap;\n+use llvm;\n use monomorphize;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::DefPathData;\n use rustc::ty::TyCtxt;\n use rustc::ty::item_path::characteristic_def_id_of_type;\n-use llvm;\n use syntax::parse::token::{self, InternedString};\n+use trans_item::TransItem;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n \n-#[derive(Clone, Copy, Eq, PartialEq, Debug)]\n-pub enum InstantiationMode {\n-    /// This variant indicates that a translation item should be placed in some\n-    /// codegen unit as a definition and with the given linkage.\n-    Def(llvm::Linkage),\n-\n-    /// This variant indicates that only a declaration of some translation item\n-    /// should be placed in a given codegen unit.\n-    Decl\n-}\n-\n pub struct CodegenUnit<'tcx> {\n     pub name: InternedString,\n-    pub items: FnvHashMap<TransItem<'tcx>, InstantiationMode>,\n+    pub items: FnvHashMap<TransItem<'tcx>, llvm::Linkage>,\n }\n \n pub enum PartitioningStrategy {\n@@ -156,7 +146,7 @@ const FALLBACK_CODEGEN_UNIT: &'static str = \"__rustc_fallback_codegen_unit\";\n pub fn partition<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               trans_items: I,\n                               strategy: PartitioningStrategy,\n-                              reference_map: &ReferenceMap<'tcx>)\n+                              inlining_map: &InliningMap<'tcx>)\n                               -> Vec<CodegenUnit<'tcx>>\n     where I: Iterator<Item = TransItem<'tcx>>\n {\n@@ -176,13 +166,8 @@ pub fn partition<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // translation items can be drop-glue, functions from external crates, and\n     // local functions the definition of which is marked with #[inline].\n     let post_inlining = place_inlined_translation_items(initial_partitioning,\n-                                                        reference_map);\n-\n-    // Now we know all *definitions* within all codegen units, thus we can\n-    // easily determine which declarations need to be placed within each one.\n-    let post_declarations = place_declarations(post_inlining, reference_map);\n-\n-    post_declarations.0\n+                                                        inlining_map);\n+    post_inlining.0\n }\n \n struct PreInliningPartitioning<'tcx> {\n@@ -191,7 +176,6 @@ struct PreInliningPartitioning<'tcx> {\n }\n \n struct PostInliningPartitioning<'tcx>(Vec<CodegenUnit<'tcx>>);\n-struct PostDeclarationsPartitioning<'tcx>(Vec<CodegenUnit<'tcx>>);\n \n fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                              trans_items: I)\n@@ -239,8 +223,7 @@ fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 }\n             };\n \n-            codegen_unit.items.insert(trans_item,\n-                                      InstantiationMode::Def(linkage));\n+            codegen_unit.items.insert(trans_item, linkage);\n             roots.insert(trans_item);\n         }\n     }\n@@ -294,15 +277,15 @@ fn merge_codegen_units<'tcx>(initial_partitioning: &mut PreInliningPartitioning<\n }\n \n fn place_inlined_translation_items<'tcx>(initial_partitioning: PreInliningPartitioning<'tcx>,\n-                                         reference_map: &ReferenceMap<'tcx>)\n+                                         inlining_map: &InliningMap<'tcx>)\n                                          -> PostInliningPartitioning<'tcx> {\n     let mut new_partitioning = Vec::new();\n \n     for codegen_unit in &initial_partitioning.codegen_units[..] {\n         // Collect all items that need to be available in this codegen unit\n         let mut reachable = FnvHashSet();\n         for root in codegen_unit.items.keys() {\n-            follow_inlining(*root, reference_map, &mut reachable);\n+            follow_inlining(*root, inlining_map, &mut reachable);\n         }\n \n         let mut new_codegen_unit = CodegenUnit {\n@@ -312,22 +295,22 @@ fn place_inlined_translation_items<'tcx>(initial_partitioning: PreInliningPartit\n \n         // Add all translation items that are not already there\n         for trans_item in reachable {\n-            if let Some(instantiation_mode) = codegen_unit.items.get(&trans_item) {\n+            if let Some(linkage) = codegen_unit.items.get(&trans_item) {\n                 // This is a root, just copy it over\n-                new_codegen_unit.items.insert(trans_item, *instantiation_mode);\n+                new_codegen_unit.items.insert(trans_item, *linkage);\n             } else {\n                 if initial_partitioning.roots.contains(&trans_item) {\n                     // This item will be instantiated in some other codegen unit,\n                     // so we just add it here with AvailableExternallyLinkage\n                     new_codegen_unit.items.insert(trans_item,\n-                        InstantiationMode::Def(llvm::AvailableExternallyLinkage));\n+                                                  llvm::AvailableExternallyLinkage);\n                 } else {\n                     // We can't be sure if this will also be instantiated\n                     // somewhere else, so we add an instance here with\n                     // LinkOnceODRLinkage. That way the item can be discarded if\n                     // it's not needed (inlined) after all.\n                     new_codegen_unit.items.insert(trans_item,\n-                        InstantiationMode::Def(llvm::LinkOnceODRLinkage));\n+                                                  llvm::LinkOnceODRLinkage);\n                 }\n             }\n         }\n@@ -338,43 +321,18 @@ fn place_inlined_translation_items<'tcx>(initial_partitioning: PreInliningPartit\n     return PostInliningPartitioning(new_partitioning);\n \n     fn follow_inlining<'tcx>(trans_item: TransItem<'tcx>,\n-                             reference_map: &ReferenceMap<'tcx>,\n+                             inlining_map: &InliningMap<'tcx>,\n                              visited: &mut FnvHashSet<TransItem<'tcx>>) {\n         if !visited.insert(trans_item) {\n             return;\n         }\n \n-        reference_map.with_inlining_candidates(trans_item, |target| {\n-            follow_inlining(target, reference_map, visited);\n+        inlining_map.with_inlining_candidates(trans_item, |target| {\n+            follow_inlining(target, inlining_map, visited);\n         });\n     }\n }\n \n-fn place_declarations<'tcx>(codegen_units: PostInliningPartitioning<'tcx>,\n-                            reference_map: &ReferenceMap<'tcx>)\n-                            -> PostDeclarationsPartitioning<'tcx> {\n-    let PostInliningPartitioning(mut codegen_units) = codegen_units;\n-\n-    for codegen_unit in codegen_units.iter_mut() {\n-        let mut declarations = FnvHashSet();\n-\n-        for (trans_item, _) in &codegen_unit.items {\n-            for referenced_item in reference_map.get_direct_references_from(*trans_item) {\n-                if !codegen_unit.items.contains_key(referenced_item) {\n-                    declarations.insert(*referenced_item);\n-                }\n-            }\n-        }\n-\n-        codegen_unit.items\n-                    .extend(declarations.iter()\n-                                        .map(|trans_item| (*trans_item,\n-                                                           InstantiationMode::Decl)));\n-    }\n-\n-    PostDeclarationsPartitioning(codegen_units)\n-}\n-\n fn characteristic_def_id_of_trans_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                  trans_item: TransItem<'tcx>)\n                                                  -> Option<DefId> {"}, {"sha": "284a227276dd0f2b2b1172bd169199b2f86e4f2b", "filename": "src/librustc_trans/symbol_names_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc_trans%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc_trans%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsymbol_names_test.rs?ref=6ba8a1a657cf37e648166ee4b41f51768ea46c1e", "patch": "@@ -52,7 +52,7 @@ impl<'a, 'tcx> SymbolNamesTest<'a, 'tcx> {\n         for attr in tcx.get_attrs(def_id).iter() {\n             if attr.check_name(SYMBOL_NAME) {\n                 // for now, can only use on monomorphic names\n-                let instance = Instance::mono(tcx, def_id);\n+                let instance = Instance::mono(self.ccx.shared(), def_id);\n                 let name = symbol_names::exported_name(self.ccx, &instance);\n                 tcx.sess.span_err(attr.span, &format!(\"symbol-name({})\", name));\n             } else if attr.check_name(ITEM_PATH) {"}, {"sha": "d7c5c41a156ba4c239780301a87881fc42087953", "filename": "src/librustc_trans/trans_item.rs", "status": "added", "additions": 384, "deletions": 0, "changes": 384, "blob_url": "https://github.com/rust-lang/rust/blob/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=6ba8a1a657cf37e648166ee4b41f51768ea46c1e", "patch": "@@ -0,0 +1,384 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Walks the crate looking for items/impl-items/trait-items that have\n+//! either a `rustc_symbol_name` or `rustc_item_path` attribute and\n+//! generates an error giving, respectively, the symbol name or\n+//! item-path. This is used for unit testing the code that generates\n+//! paths etc in all kinds of annoying scenarios.\n+\n+use base::llvm_linkage_by_name;\n+use glue::DropGlueKind;\n+use llvm;\n+use monomorphize::Instance;\n+use rustc::hir;\n+use rustc::hir::def_id::DefId;\n+use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::subst;\n+use std::hash::{Hash, Hasher};\n+use syntax::ast::{self, NodeId};\n+use syntax::attr;\n+use syntax::parse::token;\n+\n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n+pub enum TransItem<'tcx> {\n+    DropGlue(DropGlueKind<'tcx>),\n+    Fn(Instance<'tcx>),\n+    Static(NodeId)\n+}\n+\n+impl<'tcx> Hash for TransItem<'tcx> {\n+    fn hash<H: Hasher>(&self, s: &mut H) {\n+        match *self {\n+            TransItem::DropGlue(t) => {\n+                0u8.hash(s);\n+                t.hash(s);\n+            },\n+            TransItem::Fn(instance) => {\n+                1u8.hash(s);\n+                instance.def.hash(s);\n+                (instance.substs as *const _ as usize).hash(s);\n+            }\n+            TransItem::Static(node_id) => {\n+                2u8.hash(s);\n+                node_id.hash(s);\n+            }\n+        };\n+    }\n+}\n+\n+//=-----------------------------------------------------------------------------\n+// TransItem String Keys\n+//=-----------------------------------------------------------------------------\n+\n+// The code below allows for producing a unique string key for a trans item.\n+// These keys are used by the handwritten auto-tests, so they need to be\n+// predictable and human-readable.\n+//\n+// Note: A lot of this could looks very similar to what's already in the\n+//       ppaux module. It would be good to refactor things so we only have one\n+//       parameterizable implementation for printing types.\n+\n+/// Same as `unique_type_name()` but with the result pushed onto the given\n+/// `output` parameter.\n+pub fn push_unique_type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                       t: ty::Ty<'tcx>,\n+                                       output: &mut String) {\n+    match t.sty {\n+        ty::TyBool              => output.push_str(\"bool\"),\n+        ty::TyChar              => output.push_str(\"char\"),\n+        ty::TyStr               => output.push_str(\"str\"),\n+        ty::TyInt(ast::IntTy::Is)    => output.push_str(\"isize\"),\n+        ty::TyInt(ast::IntTy::I8)    => output.push_str(\"i8\"),\n+        ty::TyInt(ast::IntTy::I16)   => output.push_str(\"i16\"),\n+        ty::TyInt(ast::IntTy::I32)   => output.push_str(\"i32\"),\n+        ty::TyInt(ast::IntTy::I64)   => output.push_str(\"i64\"),\n+        ty::TyUint(ast::UintTy::Us)   => output.push_str(\"usize\"),\n+        ty::TyUint(ast::UintTy::U8)   => output.push_str(\"u8\"),\n+        ty::TyUint(ast::UintTy::U16)  => output.push_str(\"u16\"),\n+        ty::TyUint(ast::UintTy::U32)  => output.push_str(\"u32\"),\n+        ty::TyUint(ast::UintTy::U64)  => output.push_str(\"u64\"),\n+        ty::TyFloat(ast::FloatTy::F32) => output.push_str(\"f32\"),\n+        ty::TyFloat(ast::FloatTy::F64) => output.push_str(\"f64\"),\n+        ty::TyStruct(adt_def, substs) |\n+        ty::TyEnum(adt_def, substs) => {\n+            push_item_name(tcx, adt_def.did, output);\n+            push_type_params(tcx, &substs.types, &[], output);\n+        },\n+        ty::TyTuple(component_types) => {\n+            output.push('(');\n+            for &component_type in component_types {\n+                push_unique_type_name(tcx, component_type, output);\n+                output.push_str(\", \");\n+            }\n+            if !component_types.is_empty() {\n+                output.pop();\n+                output.pop();\n+            }\n+            output.push(')');\n+        },\n+        ty::TyBox(inner_type) => {\n+            output.push_str(\"Box<\");\n+            push_unique_type_name(tcx, inner_type, output);\n+            output.push('>');\n+        },\n+        ty::TyRawPtr(ty::TypeAndMut { ty: inner_type, mutbl } ) => {\n+            output.push('*');\n+            match mutbl {\n+                hir::MutImmutable => output.push_str(\"const \"),\n+                hir::MutMutable => output.push_str(\"mut \"),\n+            }\n+\n+            push_unique_type_name(tcx, inner_type, output);\n+        },\n+        ty::TyRef(_, ty::TypeAndMut { ty: inner_type, mutbl }) => {\n+            output.push('&');\n+            if mutbl == hir::MutMutable {\n+                output.push_str(\"mut \");\n+            }\n+\n+            push_unique_type_name(tcx, inner_type, output);\n+        },\n+        ty::TyArray(inner_type, len) => {\n+            output.push('[');\n+            push_unique_type_name(tcx, inner_type, output);\n+            output.push_str(&format!(\"; {}\", len));\n+            output.push(']');\n+        },\n+        ty::TySlice(inner_type) => {\n+            output.push('[');\n+            push_unique_type_name(tcx, inner_type, output);\n+            output.push(']');\n+        },\n+        ty::TyTrait(ref trait_data) => {\n+            push_item_name(tcx, trait_data.principal.skip_binder().def_id, output);\n+            push_type_params(tcx,\n+                             &trait_data.principal.skip_binder().substs.types,\n+                             &trait_data.bounds.projection_bounds,\n+                             output);\n+        },\n+        ty::TyFnDef(_, _, &ty::BareFnTy{ unsafety, abi, ref sig } ) |\n+        ty::TyFnPtr(&ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n+            if unsafety == hir::Unsafety::Unsafe {\n+                output.push_str(\"unsafe \");\n+            }\n+\n+            if abi != ::abi::Abi::Rust {\n+                output.push_str(\"extern \\\"\");\n+                output.push_str(abi.name());\n+                output.push_str(\"\\\" \");\n+            }\n+\n+            output.push_str(\"fn(\");\n+\n+            let sig = tcx.erase_late_bound_regions(sig);\n+            if !sig.inputs.is_empty() {\n+                for &parameter_type in &sig.inputs {\n+                    push_unique_type_name(tcx, parameter_type, output);\n+                    output.push_str(\", \");\n+                }\n+                output.pop();\n+                output.pop();\n+            }\n+\n+            if sig.variadic {\n+                if !sig.inputs.is_empty() {\n+                    output.push_str(\", ...\");\n+                } else {\n+                    output.push_str(\"...\");\n+                }\n+            }\n+\n+            output.push(')');\n+\n+            match sig.output {\n+                ty::FnConverging(result_type) if result_type.is_nil() => {}\n+                ty::FnConverging(result_type) => {\n+                    output.push_str(\" -> \");\n+                    push_unique_type_name(tcx, result_type, output);\n+                }\n+                ty::FnDiverging => {\n+                    output.push_str(\" -> !\");\n+                }\n+            }\n+        },\n+        ty::TyClosure(def_id, ref closure_substs) => {\n+            push_item_name(tcx, def_id, output);\n+            output.push_str(\"{\");\n+            output.push_str(&format!(\"{}:{}\", def_id.krate, def_id.index.as_usize()));\n+            output.push_str(\"}\");\n+            push_type_params(tcx, &closure_substs.func_substs.types, &[], output);\n+        }\n+        ty::TyError |\n+        ty::TyInfer(_) |\n+        ty::TyProjection(..) |\n+        ty::TyParam(_) => {\n+            bug!(\"debuginfo: Trying to create type name for \\\n+                  unexpected type: {:?}\", t);\n+        }\n+    }\n+}\n+\n+fn push_item_name(tcx: TyCtxt,\n+                  def_id: DefId,\n+                  output: &mut String) {\n+    let def_path = tcx.def_path(def_id);\n+\n+    // some_crate::\n+    output.push_str(&tcx.crate_name(def_path.krate));\n+    output.push_str(\"::\");\n+\n+    // foo::bar::ItemName::\n+    for part in tcx.def_path(def_id).data {\n+        output.push_str(&format!(\"{}[{}]::\",\n+                        part.data.as_interned_str(),\n+                        part.disambiguator));\n+    }\n+\n+    // remove final \"::\"\n+    output.pop();\n+    output.pop();\n+}\n+\n+fn push_type_params<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                              types: &'tcx subst::VecPerParamSpace<Ty<'tcx>>,\n+                              projections: &[ty::PolyProjectionPredicate<'tcx>],\n+                              output: &mut String) {\n+    if types.is_empty() && projections.is_empty() {\n+        return;\n+    }\n+\n+    output.push('<');\n+\n+    for &type_parameter in types {\n+        push_unique_type_name(tcx, type_parameter, output);\n+        output.push_str(\", \");\n+    }\n+\n+    for projection in projections {\n+        let projection = projection.skip_binder();\n+        let name = token::get_ident_interner().get(projection.projection_ty.item_name);\n+        output.push_str(&name[..]);\n+        output.push_str(\"=\");\n+        push_unique_type_name(tcx, projection.ty, output);\n+        output.push_str(\", \");\n+    }\n+\n+    output.pop();\n+    output.pop();\n+\n+    output.push('>');\n+}\n+\n+fn push_instance_as_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                     instance: Instance<'tcx>,\n+                                     output: &mut String) {\n+    push_item_name(tcx, instance.def, output);\n+    push_type_params(tcx, &instance.substs.types, &[], output);\n+}\n+\n+pub fn def_id_to_string(tcx: TyCtxt, def_id: DefId) -> String {\n+    let mut output = String::new();\n+    push_item_name(tcx, def_id, &mut output);\n+    output\n+}\n+\n+pub fn type_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                ty: ty::Ty<'tcx>)\n+                                -> String {\n+    let mut output = String::new();\n+    push_unique_type_name(tcx, ty, &mut output);\n+    output\n+}\n+\n+impl<'tcx> TransItem<'tcx> {\n+\n+    pub fn requests_inline<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n+        match *self {\n+            TransItem::Fn(ref instance) => {\n+                let attributes = tcx.get_attrs(instance.def);\n+                attr::requests_inline(&attributes[..])\n+            }\n+            TransItem::DropGlue(..) => true,\n+            TransItem::Static(..)   => false,\n+        }\n+    }\n+\n+    pub fn is_from_extern_crate(&self) -> bool {\n+        match *self {\n+            TransItem::Fn(ref instance) => !instance.def.is_local(),\n+            TransItem::DropGlue(..) |\n+            TransItem::Static(..)   => false,\n+        }\n+    }\n+\n+    pub fn is_lazily_instantiated(&self) -> bool {\n+        match *self {\n+            TransItem::Fn(ref instance) => !instance.substs.types.is_empty(),\n+            TransItem::DropGlue(..) => true,\n+            TransItem::Static(..)   => false,\n+        }\n+    }\n+\n+    pub fn explicit_linkage<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<llvm::Linkage> {\n+        let def_id = match *self {\n+            TransItem::Fn(ref instance) => instance.def,\n+            TransItem::Static(node_id) => tcx.map.local_def_id(node_id),\n+            TransItem::DropGlue(..) => return None,\n+        };\n+\n+        let attributes = tcx.get_attrs(def_id);\n+        if let Some(name) = attr::first_attr_value_str_by_name(&attributes, \"linkage\") {\n+            if let Some(linkage) = llvm_linkage_by_name(&name) {\n+                Some(linkage)\n+            } else {\n+                let span = tcx.map.span_if_local(def_id);\n+                if let Some(span) = span {\n+                    tcx.sess.span_fatal(span, \"invalid linkage specified\")\n+                } else {\n+                    tcx.sess.fatal(&format!(\"invalid linkage specified: {}\", name))\n+                }\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    pub fn to_string<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> String {\n+        let hir_map = &tcx.map;\n+\n+        return match *self {\n+            TransItem::DropGlue(dg) => {\n+                let mut s = String::with_capacity(32);\n+                match dg {\n+                    DropGlueKind::Ty(_) => s.push_str(\"drop-glue \"),\n+                    DropGlueKind::TyContents(_) => s.push_str(\"drop-glue-contents \"),\n+                };\n+                push_unique_type_name(tcx, dg.ty(), &mut s);\n+                s\n+            }\n+            TransItem::Fn(instance) => {\n+                to_string_internal(tcx, \"fn \", instance)\n+            },\n+            TransItem::Static(node_id) => {\n+                let def_id = hir_map.local_def_id(node_id);\n+                let empty_substs = tcx.mk_substs(subst::Substs::empty());\n+                let instance = Instance::new(def_id, empty_substs);\n+                to_string_internal(tcx, \"static \", instance)\n+            },\n+        };\n+\n+        fn to_string_internal<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                        prefix: &str,\n+                                        instance: Instance<'tcx>)\n+                                        -> String {\n+            let mut result = String::with_capacity(32);\n+            result.push_str(prefix);\n+            push_instance_as_string(tcx, instance, &mut result);\n+            result\n+        }\n+    }\n+\n+    pub fn to_raw_string(&self) -> String {\n+        match *self {\n+            TransItem::DropGlue(dg) => {\n+                format!(\"DropGlue({})\", dg.ty() as *const _ as usize)\n+            }\n+            TransItem::Fn(instance) => {\n+                format!(\"Fn({:?}, {})\",\n+                         instance.def,\n+                         instance.substs as *const _ as usize)\n+            }\n+            TransItem::Static(id) => {\n+                format!(\"Static({:?})\", id)\n+            }\n+        }\n+    }\n+}"}, {"sha": "8f9e44c1365a66963238f29bf88011a4a8cee880", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=6ba8a1a657cf37e648166ee4b41f51768ea46c1e", "patch": "@@ -1153,7 +1153,8 @@ fn check_const<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                         sp: Span,\n                         e: &'tcx hir::Expr,\n                         id: ast::NodeId) {\n-    ccx.inherited(None).enter(|inh| {\n+    let param_env = ParameterEnvironment::for_item(ccx.tcx, id);\n+    ccx.inherited(Some(param_env)).enter(|inh| {\n         let rty = ccx.tcx.node_id_to_type(id);\n         let fcx = FnCtxt::new(&inh, ty::FnConverging(rty), e.id);\n         let declty = fcx.tcx.lookup_item_type(ccx.tcx.map.local_def_id(id)).ty;"}, {"sha": "b5802afc109435ec1e5e2cf8dd1b71951780c592", "filename": "src/libstd/sys/common/gnu/libbacktrace.rs", "status": "modified", "additions": 12, "deletions": 37, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibstd%2Fsys%2Fcommon%2Fgnu%2Flibbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Flibstd%2Fsys%2Fcommon%2Fgnu%2Flibbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fgnu%2Flibbacktrace.rs?ref=6ba8a1a657cf37e648166ee4b41f51768ea46c1e", "patch": "@@ -15,7 +15,6 @@ use sys_common::backtrace::{output, output_fileline};\n \n pub fn print(w: &mut Write, idx: isize, addr: *mut libc::c_void,\n              symaddr: *mut libc::c_void) -> io::Result<()> {\n-    use env;\n     use ffi::CStr;\n     use ptr;\n \n@@ -110,46 +109,22 @@ pub fn print(w: &mut Write, idx: isize, addr: *mut libc::c_void,\n     // that is calculated the first time this is requested. Remember that\n     // backtracing all happens serially (one global lock).\n     //\n-    // An additionally oddity in this function is that we initialize the\n-    // filename via self_exe_name() to pass to libbacktrace. It turns out\n-    // that on Linux libbacktrace seamlessly gets the filename of the\n-    // current executable, but this fails on freebsd. by always providing\n-    // it, we make sure that libbacktrace never has a reason to not look up\n-    // the symbols. The libbacktrace API also states that the filename must\n-    // be in \"permanent memory\", so we copy it to a static and then use the\n-    // static as the pointer.\n+    // Things don't work so well on not-Linux since libbacktrace can't track\n+    // down that executable this is. We at one point used env::current_exe but\n+    // it turns out that there are some serious security issues with that\n+    // approach.\n     //\n-    // FIXME: We also call self_exe_name() on DragonFly BSD. I haven't\n-    //        tested if this is required or not.\n+    // Specifically, on certain platforms like BSDs, a malicious actor can cause\n+    // an arbitrary file to be placed at the path returned by current_exe.\n+    // libbacktrace does not behave defensively in the presence of ill-formed\n+    // DWARF information, and has been demonstrated to segfault in at least one\n+    // case. There is no evidence at the moment to suggest that a more carefully\n+    // constructed file can't cause arbitrary code execution. As a result of all\n+    // of this, we don't hint libbacktrace with the path to the current process.\n     unsafe fn init_state() -> *mut backtrace_state {\n         static mut STATE: *mut backtrace_state = ptr::null_mut();\n-        static mut LAST_FILENAME: [libc::c_char; 256] = [0; 256];\n         if !STATE.is_null() { return STATE }\n-        let selfname = if cfg!(target_os = \"freebsd\") ||\n-            cfg!(target_os = \"dragonfly\") ||\n-            cfg!(target_os = \"bitrig\") ||\n-            cfg!(target_os = \"openbsd\") ||\n-            cfg!(target_os = \"windows\") {\n-                env::current_exe().ok()\n-            } else {\n-                None\n-            };\n-        let filename = match selfname.as_ref().and_then(|s| s.to_str()) {\n-            Some(path) => {\n-                let bytes = path.as_bytes();\n-                if bytes.len() < LAST_FILENAME.len() {\n-                    let i = bytes.iter();\n-                    for (slot, val) in LAST_FILENAME.iter_mut().zip(i) {\n-                        *slot = *val as libc::c_char;\n-                    }\n-                    LAST_FILENAME.as_ptr()\n-                } else {\n-                    ptr::null()\n-                }\n-            }\n-            None => ptr::null(),\n-        };\n-        STATE = backtrace_create_state(filename, 0, error_cb,\n+        STATE = backtrace_create_state(ptr::null(), 0, error_cb,\n                                        ptr::null_mut());\n         STATE\n     }"}, {"sha": "db940b680473a46606685c898f2c1f3d8d953343", "filename": "src/test/codegen-units/item-collection/drop_in_place_intrinsic.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fdrop_in_place_intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fdrop_in_place_intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fdrop_in_place_intrinsic.rs?ref=6ba8a1a657cf37e648166ee4b41f51768ea46c1e", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags:-Zprint-trans-items=eager\n+\n+//~ TRANS_ITEM drop-glue drop_in_place_intrinsic::StructWithDtor[0]\n+//~ TRANS_ITEM drop-glue-contents drop_in_place_intrinsic::StructWithDtor[0]\n+struct StructWithDtor(u32);\n+\n+impl Drop for StructWithDtor {\n+    //~ TRANS_ITEM fn drop_in_place_intrinsic::{{impl}}[0]::drop[0]\n+    fn drop(&mut self) {}\n+}\n+\n+//~ TRANS_ITEM fn drop_in_place_intrinsic::main[0]\n+fn main() {\n+\n+    //~ TRANS_ITEM drop-glue [drop_in_place_intrinsic::StructWithDtor[0]; 2]\n+    let x = [StructWithDtor(0), StructWithDtor(1)];\n+\n+    drop_slice_in_place(&x);\n+}\n+\n+//~ TRANS_ITEM fn drop_in_place_intrinsic::drop_slice_in_place[0]\n+fn drop_slice_in_place(x: &[StructWithDtor]) {\n+    unsafe {\n+        // This is the interesting thing in this test case: Normally we would\n+        // not have drop-glue for the unsized [StructWithDtor]. This has to be\n+        // generated though when the drop_in_place() intrinsic is used.\n+        //~ TRANS_ITEM drop-glue [drop_in_place_intrinsic::StructWithDtor[0]]\n+        ::std::ptr::drop_in_place(x as *const _ as *mut [StructWithDtor]);\n+    }\n+}"}, {"sha": "41c0f46f80bfb2ad4c6e22c6e40b06aa93f10c95", "filename": "src/test/codegen-units/item-collection/static-init.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fstatic-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fstatic-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fstatic-init.rs?ref=6ba8a1a657cf37e648166ee4b41f51768ea46c1e", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-Zprint-trans-items=eager\n+\n+pub static FN : fn() = foo::<i32>;\n+\n+pub fn foo<T>() { }\n+\n+//~ TRANS_ITEM fn static_init::foo[0]<i32>\n+//~ TRANS_ITEM static static_init::FN[0]\n+\n+fn main() { }\n+\n+//~ TRANS_ITEM fn static_init::main[0]\n+//~ TRANS_ITEM drop-glue i8"}, {"sha": "04ebef645ec9836ec648b279ec1548f30128b070", "filename": "src/test/codegen-units/partitioning/local-drop-glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-drop-glue.rs?ref=6ba8a1a657cf37e648166ee4b41f51768ea46c1e", "patch": "@@ -23,7 +23,7 @@ struct Struct {\n }\n \n impl Drop for Struct {\n-    //~ TRANS_ITEM fn local_drop_glue::{{impl}}[0]::drop[0] @@ local_drop_glue[WeakODR] local_drop_glue-mod1[Declaration]\n+    //~ TRANS_ITEM fn local_drop_glue::{{impl}}[0]::drop[0] @@ local_drop_glue[WeakODR]\n     fn drop(&mut self) {}\n }\n "}, {"sha": "e38e676b95c617b9d4d18dd11346a9d70d91e324", "filename": "src/test/codegen-units/partitioning/local-generic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-generic.rs?ref=6ba8a1a657cf37e648166ee4b41f51768ea46c1e", "patch": "@@ -19,10 +19,10 @@\n // Used in different modules/codegen units but always instantiated in the same\n // codegen unit.\n \n-//~ TRANS_ITEM fn local_generic::generic[0]<u32> @@ local_generic.volatile[WeakODR] local_generic[Declaration]\n-//~ TRANS_ITEM fn local_generic::generic[0]<u64> @@ local_generic.volatile[WeakODR] local_generic-mod1[Declaration]\n-//~ TRANS_ITEM fn local_generic::generic[0]<char> @@ local_generic.volatile[WeakODR] local_generic-mod1-mod1[Declaration]\n-//~ TRANS_ITEM fn local_generic::generic[0]<&str> @@ local_generic.volatile[WeakODR] local_generic-mod2[Declaration]\n+//~ TRANS_ITEM fn local_generic::generic[0]<u32> @@ local_generic.volatile[WeakODR]\n+//~ TRANS_ITEM fn local_generic::generic[0]<u64> @@ local_generic.volatile[WeakODR]\n+//~ TRANS_ITEM fn local_generic::generic[0]<char> @@ local_generic.volatile[WeakODR]\n+//~ TRANS_ITEM fn local_generic::generic[0]<&str> @@ local_generic.volatile[WeakODR]\n pub fn generic<T>(x: T) -> T { x }\n \n //~ TRANS_ITEM fn local_generic::user[0] @@ local_generic[WeakODR]"}, {"sha": "99dda0e38bad7aeb63ac64262a91136f9f4b1fcf", "filename": "src/test/codegen-units/partitioning/methods-are-with-self-type.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fmethods-are-with-self-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fmethods-are-with-self-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fmethods-are-with-self-type.rs?ref=6ba8a1a657cf37e648166ee4b41f51768ea46c1e", "patch": "@@ -61,19 +61,19 @@ mod type2 {\n //~ TRANS_ITEM fn methods_are_with_self_type::main[0]\n fn main()\n {\n-    //~ TRANS_ITEM fn methods_are_with_self_type::mod1[0]::{{impl}}[1]::method[0]<u32, u64> @@ methods_are_with_self_type.volatile[WeakODR] methods_are_with_self_type[Declaration]\n+    //~ TRANS_ITEM fn methods_are_with_self_type::mod1[0]::{{impl}}[1]::method[0]<u32, u64> @@ methods_are_with_self_type.volatile[WeakODR]\n     SomeGenericType(0u32, 0u64).method();\n-    //~ TRANS_ITEM fn methods_are_with_self_type::mod1[0]::{{impl}}[1]::associated_fn[0]<char, &str> @@ methods_are_with_self_type.volatile[WeakODR] methods_are_with_self_type[Declaration]\n+    //~ TRANS_ITEM fn methods_are_with_self_type::mod1[0]::{{impl}}[1]::associated_fn[0]<char, &str> @@ methods_are_with_self_type.volatile[WeakODR]\n     SomeGenericType::associated_fn('c', \"&str\");\n \n-    //~ TRANS_ITEM fn methods_are_with_self_type::{{impl}}[0]::foo[0]<methods_are_with_self_type::type1[0]::Struct[0]> @@ methods_are_with_self_type-type1.volatile[WeakODR] methods_are_with_self_type[Declaration]\n+    //~ TRANS_ITEM fn methods_are_with_self_type::{{impl}}[0]::foo[0]<methods_are_with_self_type::type1[0]::Struct[0]> @@ methods_are_with_self_type-type1.volatile[WeakODR]\n     type1::Struct.foo();\n-    //~ TRANS_ITEM fn methods_are_with_self_type::{{impl}}[0]::foo[0]<methods_are_with_self_type::type2[0]::Struct[0]> @@ methods_are_with_self_type-type2.volatile[WeakODR] methods_are_with_self_type[Declaration]\n+    //~ TRANS_ITEM fn methods_are_with_self_type::{{impl}}[0]::foo[0]<methods_are_with_self_type::type2[0]::Struct[0]> @@ methods_are_with_self_type-type2.volatile[WeakODR]\n     type2::Struct.foo();\n \n-    //~ TRANS_ITEM fn methods_are_with_self_type::Trait[0]::default[0]<methods_are_with_self_type::type1[0]::Struct[0]> @@ methods_are_with_self_type-type1.volatile[WeakODR] methods_are_with_self_type[Declaration]\n+    //~ TRANS_ITEM fn methods_are_with_self_type::Trait[0]::default[0]<methods_are_with_self_type::type1[0]::Struct[0]> @@ methods_are_with_self_type-type1.volatile[WeakODR]\n     type1::Struct.default();\n-    //~ TRANS_ITEM fn methods_are_with_self_type::Trait[0]::default[0]<methods_are_with_self_type::type2[0]::Struct[0]> @@ methods_are_with_self_type-type2.volatile[WeakODR] methods_are_with_self_type[Declaration]\n+    //~ TRANS_ITEM fn methods_are_with_self_type::Trait[0]::default[0]<methods_are_with_self_type::type2[0]::Struct[0]> @@ methods_are_with_self_type-type2.volatile[WeakODR]\n     type2::Struct.default();\n }\n "}, {"sha": "a603b225132d45ecfade7dd0abf54f1141eaa5a6", "filename": "src/test/run-pass/associated-const-outer-ty-refs.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Ftest%2Frun-pass%2Fassociated-const-outer-ty-refs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Ftest%2Frun-pass%2Fassociated-const-outer-ty-refs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-const-outer-ty-refs.rs?ref=6ba8a1a657cf37e648166ee4b41f51768ea46c1e", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(associated_consts)]\n+\n+trait Lattice {\n+    const BOTTOM: Self;\n+}\n+\n+// FIXME(#33573): this should work without the 'static lifetime bound.\n+impl<T: 'static> Lattice for Option<T> {\n+    const BOTTOM: Option<T> = None;\n+}\n+\n+fn main(){}"}, {"sha": "f42a6ab162b707437134a231725c21505e172e28", "filename": "src/test/run-pass/backtrace-debuginfo.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace-debuginfo.rs?ref=6ba8a1a657cf37e648166ee4b41f51768ea46c1e", "patch": "@@ -32,11 +32,15 @@ macro_rules! dump_and_die {\n     ($($pos:expr),*) => ({\n         // FIXME(#18285): we cannot include the current position because\n         // the macro span takes over the last frame's file/line.\n-        if cfg!(target_os = \"macos\") ||\n-           cfg!(target_os = \"ios\") ||\n-           cfg!(target_os = \"android\") ||\n-           cfg!(all(target_os = \"linux\", target_arch = \"arm\")) ||\n-           cfg!(all(windows, target_env = \"gnu\")) {\n+        if cfg!(any(target_os = \"macos\",\n+                    target_os = \"ios\",\n+                    target_os = \"android\",\n+                    all(target_os = \"linux\", target_arch = \"arm\"),\n+                    target_os = \"windows\",\n+                    target_os = \"freebsd\",\n+                    target_os = \"dragonfly\",\n+                    target_os = \"bitrig\",\n+                    target_os = \"openbsd\")) {\n             // skip these platforms as this support isn't implemented yet.\n         } else {\n             dump_filelines(&[$($pos),*]);"}, {"sha": "ad38dc8f45252b2c2e56a11cefc3a7143e44c4af", "filename": "src/test/run-pass/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace.rs?ref=6ba8a1a657cf37e648166ee4b41f51768ea46c1e", "patch": "@@ -115,7 +115,7 @@ fn runtest(me: &str) {\n }\n \n fn main() {\n-    if cfg!(windows) && cfg!(target_arch = \"x86\") && cfg!(target_env = \"gnu\") {\n+    if cfg!(windows) && cfg!(target_env = \"gnu\") {\n         return\n     }\n "}, {"sha": "e91b8fb0967a82375043ae927362500b428f7cfe", "filename": "src/tools/tidy/src/bins.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Ftools%2Ftidy%2Fsrc%2Fbins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba8a1a657cf37e648166ee4b41f51768ea46c1e/src%2Ftools%2Ftidy%2Fsrc%2Fbins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fbins.rs?ref=6ba8a1a657cf37e648166ee4b41f51768ea46c1e", "patch": "@@ -35,7 +35,7 @@ pub fn check(path: &Path, bad: &mut bool) {\n             return\n         }\n \n-        let metadata = t!(fs::metadata(&file), &file);\n+        let metadata = t!(fs::symlink_metadata(&file), &file);\n         if metadata.mode() & 0o111 != 0 {\n             println!(\"binary checked into source: {}\", file.display());\n             *bad = true;"}]}