{"sha": "99d4886ead646da864cff7963f540a44acd4af05", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5ZDQ4ODZlYWQ2NDZkYTg2NGNmZjc5NjNmNTQwYTQ0YWNkNGFmMDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-13T10:33:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-13T10:33:51Z"}, "message": "Auto merge of #49669 - SimonSapin:global-alloc, r=alexcrichton\n\nAdd GlobalAlloc trait + tweaks for initial stabilization\n\nThis is the outcome of discussion at the Rust All Hands in Berlin. The high-level goal is stabilizing sooner rather than later the ability to [change the global allocator](https://github.com/rust-lang/rust/issues/27389), as well as allocating memory without abusing `Vec::with_capacity` + `mem::forget`.\n\nSince we\u2019re not ready to settle every detail of the `Alloc` trait for the purpose of collections that are generic over the allocator type (for example the possibility of a separate trait for deallocation only, and what that would look like exactly), we propose introducing separately **a new `GlobalAlloc` trait**, for use with the `#[global_allocator]` attribute.\n\nWe also propose a number of changes to existing APIs. They are batched in this one PR in order to minimize disruption to Nightly users.\n\nThe plan for initial stabilization is detailed in the tracking issue https://github.com/rust-lang/rust/issues/49668.\n\nCC @rust-lang/libs, @glandium\n\n## Immediate breaking changes to unstable features\n\n* For pointers to allocated memory, change the pointed type from `u8` to `Opaque`, a new public [extern type](https://github.com/rust-lang/rust/issues/43467). Since extern types are not `Sized`, `<*mut _>::offset` cannot be used without first casting to another pointer type. (We hope that extern types can also be stabilized soon.)\n* In the `Alloc` trait, change these pointers to `ptr::NonNull` and change the `AllocErr` type to a zero-size struct. This makes return types `Result<ptr::NonNull<Opaque>, AllocErr>` be pointer-sized.\n* Instead of a new `Layout`, `realloc` takes only a new size (in addition to the pointer and old `Layout`). Changing the alignment is not supported with `realloc`.\n* Change the return type of `Layout::from_size_align` from `Option<Self>` to `Result<Self, LayoutErr>`, with `LayoutErr` a new opaque struct.\n* A `static` item registered as the global allocator with the `#[global_allocator]` **must now implement the new `GlobalAlloc` trait** instead of `Alloc`.\n\n## Eventually-breaking changes to unstable features, with a deprecation period\n\n* Rename the respective `heap` modules to `alloc` in the `core`, `alloc`, and `std` crates. (Yes, this does mean that `::alloc::alloc::Alloc::alloc` is a valid path to a trait method if you have `exetrn crate alloc;`)\n* Rename the the `Heap` type to `Global`, since it is the entry point for what\u2019s registered with `#[global_allocator]`.\n\nOld names remain available for now, as deprecated `pub use` reexports.\n\n## Backward-compatible changes\n\n* Add a new [extern type](https://github.com/rust-lang/rust/issues/43467) `Opaque`, for use in pointers to allocated memory.\n* Add a new `GlobalAlloc` trait shown below. Unlike `Alloc`, it uses bare `*mut Opaque` without `NonNull` or `Result`. NULL in return values indicates an error (of unspecified nature). This is easier to implement on top of `malloc`-like APIs.\n* Add impls of `GlobalAlloc` for both the `Global` and `System` types, in addition to existing impls of `Alloc`. This enables calling `GlobalAlloc` methods on the stable channel before `Alloc` is stable. Implementing two traits with identical method names can make some calls ambiguous, but most code is expected to have no more than one of the two traits in scope. Erroneous code like `use std::alloc::Global; #[global_allocator] static A: Global = Global;` (where `Global` is defined to call itself, causing infinite recursion) is not statically prevented by the type system, but we count on it being hard enough to do accidentally and easy enough to diagnose.\n\n```rust\nextern {\n    pub type Opaque;\n}\n\npub unsafe trait GlobalAlloc {\n    unsafe fn alloc(&self, layout: Layout) -> *mut Opaque;\n    unsafe fn dealloc(&self, ptr: *mut Opaque, layout: Layout);\n\n    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut Opaque {\n        // Default impl: self.alloc() and ptr::write_bytes()\n    }\n    unsafe fn realloc(&self, ptr: *mut Opaque, old_layout: Layout, new_size: usize) -> *mut Opaque {\n        // Default impl: self.alloc() and ptr::copy_nonoverlapping() and self.dealloc()\n    }\n\n    fn oom(&self) -> ! {\n        // intrinsics::abort\n    }\n\n    // More methods with default impls may be added in the future\n}\n```\n\n## Bikeshed\n\nThe tracking issue https://github.com/rust-lang/rust/issues/49668 lists some open questions. If consensus is reached before this PR is merged, changes can be integrated.", "tree": {"sha": "8c17370e0f443b182d30bba73bbd48cc6a768001", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c17370e0f443b182d30bba73bbd48cc6a768001"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99d4886ead646da864cff7963f540a44acd4af05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99d4886ead646da864cff7963f540a44acd4af05", "html_url": "https://github.com/rust-lang/rust/commit/99d4886ead646da864cff7963f540a44acd4af05", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99d4886ead646da864cff7963f540a44acd4af05/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9f9050f507cd14839f868917b5b4fc370eed54b", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9f9050f507cd14839f868917b5b4fc370eed54b", "html_url": "https://github.com/rust-lang/rust/commit/f9f9050f507cd14839f868917b5b4fc370eed54b"}, {"sha": "c5ffdd787d134c06735a1dc4457515a63bbce5f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5ffdd787d134c06735a1dc4457515a63bbce5f5", "html_url": "https://github.com/rust-lang/rust/commit/c5ffdd787d134c06735a1dc4457515a63bbce5f5"}], "stats": {"total": 2534, "additions": 1038, "deletions": 1496}, "files": [{"sha": "e5297d1482e8b57b711e53f72ee33bf0d450f136", "filename": "src/Cargo.lock", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -19,7 +19,6 @@ dependencies = [\n name = \"alloc_jemalloc\"\n version = \"0.0.0\"\n dependencies = [\n- \"alloc 0.0.0\",\n  \"alloc_system 0.0.0\",\n  \"build_helper 0.1.0\",\n  \"cc 1.0.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -32,7 +31,6 @@ dependencies = [\n name = \"alloc_system\"\n version = \"0.0.0\"\n dependencies = [\n- \"alloc 0.0.0\",\n  \"compiler_builtins 0.0.0\",\n  \"core 0.0.0\",\n  \"dlmalloc 0.0.0\",\n@@ -542,7 +540,6 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n name = \"dlmalloc\"\n version = \"0.0.0\"\n dependencies = [\n- \"alloc 0.0.0\",\n  \"compiler_builtins 0.0.0\",\n  \"core 0.0.0\",\n ]"}, {"sha": "c99638dc2ecfc750cc1656f6edb2bd062c1e0981", "filename": "src/dlmalloc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdlmalloc?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -1 +1 @@\n-Subproject commit 9b2dcac06c3e23235f8997b3c5f2325a6d3382df\n+Subproject commit c99638dc2ecfc750cc1656f6edb2bd062c1e0981"}, {"sha": "3c56329d1bd9038e5341f1962bcd8d043312a712", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -1 +1 @@\n-Subproject commit 6a8f0a27e9a58c55c89d07bc43a176fdae5e051c\n+Subproject commit 3c56329d1bd9038e5341f1962bcd8d043312a712"}, {"sha": "031b6347445e2af92cc22ab75ca1cb16cad491f8", "filename": "src/doc/unstable-book/src/language-features/global-allocator.md", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fglobal-allocator.md", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fglobal-allocator.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fglobal-allocator.md?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -29,16 +29,17 @@ looks like:\n ```rust\n #![feature(global_allocator, allocator_api, heap_api)]\n \n-use std::heap::{Alloc, System, Layout, AllocErr};\n+use std::alloc::{GlobalAlloc, System, Layout, Opaque};\n+use std::ptr::NonNull;\n \n struct MyAllocator;\n \n-unsafe impl<'a> Alloc for &'a MyAllocator {\n-    unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n+unsafe impl GlobalAlloc for MyAllocator {\n+    unsafe fn alloc(&self, layout: Layout) -> *mut Opaque {\n         System.alloc(layout)\n     }\n \n-    unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout) {\n+    unsafe fn dealloc(&self, ptr: *mut Opaque, layout: Layout) {\n         System.dealloc(ptr, layout)\n     }\n }"}, {"sha": "68a617e0ffed4371e21570a16d975e2c964fc02f", "filename": "src/liballoc/alloc.rs", "status": "added", "additions": 215, "deletions": 0, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -0,0 +1,215 @@\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![unstable(feature = \"allocator_api\",\n+            reason = \"the precise API and guarantees it provides may be tweaked \\\n+                      slightly, especially to possibly take into account the \\\n+                      types being stored to make room for a future \\\n+                      tracing garbage collector\",\n+            issue = \"32838\")]\n+\n+use core::intrinsics::{min_align_of_val, size_of_val};\n+use core::ptr::NonNull;\n+use core::usize;\n+\n+#[doc(inline)]\n+pub use core::alloc::*;\n+\n+#[cfg(stage0)]\n+extern \"Rust\" {\n+    #[allocator]\n+    #[rustc_allocator_nounwind]\n+    fn __rust_alloc(size: usize, align: usize, err: *mut u8) -> *mut u8;\n+    #[cold]\n+    #[rustc_allocator_nounwind]\n+    fn __rust_oom(err: *const u8) -> !;\n+    #[rustc_allocator_nounwind]\n+    fn __rust_dealloc(ptr: *mut u8, size: usize, align: usize);\n+    #[rustc_allocator_nounwind]\n+    fn __rust_realloc(ptr: *mut u8,\n+                      old_size: usize,\n+                      old_align: usize,\n+                      new_size: usize,\n+                      new_align: usize,\n+                      err: *mut u8) -> *mut u8;\n+    #[rustc_allocator_nounwind]\n+    fn __rust_alloc_zeroed(size: usize, align: usize, err: *mut u8) -> *mut u8;\n+}\n+\n+#[cfg(not(stage0))]\n+extern \"Rust\" {\n+    #[allocator]\n+    #[rustc_allocator_nounwind]\n+    fn __rust_alloc(size: usize, align: usize) -> *mut u8;\n+    #[cold]\n+    #[rustc_allocator_nounwind]\n+    fn __rust_oom() -> !;\n+    #[rustc_allocator_nounwind]\n+    fn __rust_dealloc(ptr: *mut u8, size: usize, align: usize);\n+    #[rustc_allocator_nounwind]\n+    fn __rust_realloc(ptr: *mut u8,\n+                      old_size: usize,\n+                      align: usize,\n+                      new_size: usize) -> *mut u8;\n+    #[rustc_allocator_nounwind]\n+    fn __rust_alloc_zeroed(size: usize, align: usize) -> *mut u8;\n+}\n+\n+#[derive(Copy, Clone, Default, Debug)]\n+pub struct Global;\n+\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+#[rustc_deprecated(since = \"1.27.0\", reason = \"type renamed to `Global`\")]\n+pub type Heap = Global;\n+\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+#[rustc_deprecated(since = \"1.27.0\", reason = \"type renamed to `Global`\")]\n+#[allow(non_upper_case_globals)]\n+pub const Heap: Global = Global;\n+\n+unsafe impl GlobalAlloc for Global {\n+    #[inline]\n+    unsafe fn alloc(&self, layout: Layout) -> *mut Opaque {\n+        #[cfg(not(stage0))]\n+        let ptr = __rust_alloc(layout.size(), layout.align());\n+        #[cfg(stage0)]\n+        let ptr = __rust_alloc(layout.size(), layout.align(), &mut 0);\n+        ptr as *mut Opaque\n+    }\n+\n+    #[inline]\n+    unsafe fn dealloc(&self, ptr: *mut Opaque, layout: Layout) {\n+        __rust_dealloc(ptr as *mut u8, layout.size(), layout.align())\n+    }\n+\n+    #[inline]\n+    unsafe fn realloc(&self, ptr: *mut Opaque, layout: Layout, new_size: usize) -> *mut Opaque {\n+        #[cfg(not(stage0))]\n+        let ptr = __rust_realloc(ptr as *mut u8, layout.size(), layout.align(), new_size);\n+        #[cfg(stage0)]\n+        let ptr = __rust_realloc(ptr as *mut u8, layout.size(), layout.align(),\n+                                 new_size, layout.align(), &mut 0);\n+        ptr as *mut Opaque\n+    }\n+\n+    #[inline]\n+    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut Opaque {\n+        #[cfg(not(stage0))]\n+        let ptr = __rust_alloc_zeroed(layout.size(), layout.align());\n+        #[cfg(stage0)]\n+        let ptr = __rust_alloc_zeroed(layout.size(), layout.align(), &mut 0);\n+        ptr as *mut Opaque\n+    }\n+\n+    #[inline]\n+    fn oom(&self) -> ! {\n+        unsafe {\n+            #[cfg(not(stage0))]\n+            __rust_oom();\n+            #[cfg(stage0)]\n+            __rust_oom(&mut 0);\n+        }\n+    }\n+}\n+\n+unsafe impl Alloc for Global {\n+    #[inline]\n+    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<Opaque>, AllocErr> {\n+        NonNull::new(GlobalAlloc::alloc(self, layout)).ok_or(AllocErr)\n+    }\n+\n+    #[inline]\n+    unsafe fn dealloc(&mut self, ptr: NonNull<Opaque>, layout: Layout) {\n+        GlobalAlloc::dealloc(self, ptr.as_ptr(), layout)\n+    }\n+\n+    #[inline]\n+    unsafe fn realloc(&mut self,\n+                      ptr: NonNull<Opaque>,\n+                      layout: Layout,\n+                      new_size: usize)\n+                      -> Result<NonNull<Opaque>, AllocErr>\n+    {\n+        NonNull::new(GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size)).ok_or(AllocErr)\n+    }\n+\n+    #[inline]\n+    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<Opaque>, AllocErr> {\n+        NonNull::new(GlobalAlloc::alloc_zeroed(self, layout)).ok_or(AllocErr)\n+    }\n+\n+    #[inline]\n+    fn oom(&mut self) -> ! {\n+        GlobalAlloc::oom(self)\n+    }\n+}\n+\n+/// The allocator for unique pointers.\n+// This function must not unwind. If it does, MIR trans will fail.\n+#[cfg(not(test))]\n+#[lang = \"exchange_malloc\"]\n+#[inline]\n+unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n+    if size == 0 {\n+        align as *mut u8\n+    } else {\n+        let layout = Layout::from_size_align_unchecked(size, align);\n+        let ptr = Global.alloc(layout);\n+        if !ptr.is_null() {\n+            ptr as *mut u8\n+        } else {\n+            Global.oom()\n+        }\n+    }\n+}\n+\n+#[cfg_attr(not(test), lang = \"box_free\")]\n+#[inline]\n+pub(crate) unsafe fn box_free<T: ?Sized>(ptr: *mut T) {\n+    let size = size_of_val(&*ptr);\n+    let align = min_align_of_val(&*ptr);\n+    // We do not allocate for Box<T> when T is ZST, so deallocation is also not necessary.\n+    if size != 0 {\n+        let layout = Layout::from_size_align_unchecked(size, align);\n+        Global.dealloc(ptr as *mut Opaque, layout);\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    extern crate test;\n+    use self::test::Bencher;\n+    use boxed::Box;\n+    use alloc::{Global, Alloc, Layout};\n+\n+    #[test]\n+    fn allocate_zeroed() {\n+        unsafe {\n+            let layout = Layout::from_size_align(1024, 1).unwrap();\n+            let ptr = Global.alloc_zeroed(layout.clone())\n+                .unwrap_or_else(|_| Global.oom());\n+\n+            let mut i = ptr.cast::<u8>().as_ptr();\n+            let end = i.offset(layout.size() as isize);\n+            while i < end {\n+                assert_eq!(*i, 0);\n+                i = i.offset(1);\n+            }\n+            Global.dealloc(ptr, layout);\n+        }\n+    }\n+\n+    #[bench]\n+    fn alloc_owned_small(b: &mut Bencher) {\n+        b.iter(|| {\n+            let _: Box<_> = box 10;\n+        })\n+    }\n+}"}, {"sha": "225b055d8ee8296129faae4ddacef105172a1186", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -21,7 +21,6 @@ use core::sync::atomic::Ordering::{Acquire, Relaxed, Release, SeqCst};\n use core::borrow;\n use core::fmt;\n use core::cmp::Ordering;\n-use core::heap::{Alloc, Layout};\n use core::intrinsics::abort;\n use core::mem::{self, align_of_val, size_of_val, uninitialized};\n use core::ops::Deref;\n@@ -32,7 +31,7 @@ use core::hash::{Hash, Hasher};\n use core::{isize, usize};\n use core::convert::From;\n \n-use heap::{Heap, box_free};\n+use alloc::{Global, Alloc, Layout, box_free};\n use boxed::Box;\n use string::String;\n use vec::Vec;\n@@ -513,15 +512,13 @@ impl<T: ?Sized> Arc<T> {\n     // Non-inlined part of `drop`.\n     #[inline(never)]\n     unsafe fn drop_slow(&mut self) {\n-        let ptr = self.ptr.as_ptr();\n-\n         // Destroy the data at this time, even though we may not free the box\n         // allocation itself (there may still be weak pointers lying around).\n         ptr::drop_in_place(&mut self.ptr.as_mut().data);\n \n         if self.inner().weak.fetch_sub(1, Release) == 1 {\n             atomic::fence(Acquire);\n-            Heap.dealloc(ptr as *mut u8, Layout::for_value(&*ptr))\n+            Global.dealloc(self.ptr.as_opaque(), Layout::for_value(self.ptr.as_ref()))\n         }\n     }\n \n@@ -555,11 +552,11 @@ impl<T: ?Sized> Arc<T> {\n \n         let layout = Layout::for_value(&*fake_ptr);\n \n-        let mem = Heap.alloc(layout)\n-            .unwrap_or_else(|e| Heap.oom(e));\n+        let mem = Global.alloc(layout)\n+            .unwrap_or_else(|_| Global.oom());\n \n         // Initialize the real ArcInner\n-        let inner = set_data_ptr(ptr as *mut T, mem) as *mut ArcInner<T>;\n+        let inner = set_data_ptr(ptr as *mut T, mem.as_ptr() as *mut u8) as *mut ArcInner<T>;\n \n         ptr::write(&mut (*inner).strong, atomic::AtomicUsize::new(1));\n         ptr::write(&mut (*inner).weak, atomic::AtomicUsize::new(1));\n@@ -626,7 +623,7 @@ impl<T: Clone> ArcFromSlice<T> for Arc<[T]> {\n         // In the event of a panic, elements that have been written\n         // into the new ArcInner will be dropped, then the memory freed.\n         struct Guard<T> {\n-            mem: *mut u8,\n+            mem: NonNull<u8>,\n             elems: *mut T,\n             layout: Layout,\n             n_elems: usize,\n@@ -640,7 +637,7 @@ impl<T: Clone> ArcFromSlice<T> for Arc<[T]> {\n                     let slice = from_raw_parts_mut(self.elems, self.n_elems);\n                     ptr::drop_in_place(slice);\n \n-                    Heap.dealloc(self.mem, self.layout.clone());\n+                    Global.dealloc(self.mem.as_opaque(), self.layout.clone());\n                 }\n             }\n         }\n@@ -656,7 +653,7 @@ impl<T: Clone> ArcFromSlice<T> for Arc<[T]> {\n             let elems = &mut (*ptr).data as *mut [T] as *mut T;\n \n             let mut guard = Guard{\n-                mem: mem,\n+                mem: NonNull::new_unchecked(mem),\n                 elems: elems,\n                 layout: layout,\n                 n_elems: 0,\n@@ -1148,8 +1145,6 @@ impl<T: ?Sized> Drop for Weak<T> {\n     /// assert!(other_weak_foo.upgrade().is_none());\n     /// ```\n     fn drop(&mut self) {\n-        let ptr = self.ptr.as_ptr();\n-\n         // If we find out that we were the last weak pointer, then its time to\n         // deallocate the data entirely. See the discussion in Arc::drop() about\n         // the memory orderings\n@@ -1161,7 +1156,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n         if self.inner().weak.fetch_sub(1, Release) == 1 {\n             atomic::fence(Acquire);\n             unsafe {\n-                Heap.dealloc(ptr as *mut u8, Layout::for_value(&*ptr))\n+                Global.dealloc(self.ptr.as_opaque(), Layout::for_value(self.ptr.as_ref()))\n             }\n         }\n     }"}, {"sha": "d6346662314e65ae993a498ff4ffba1fb9579f30", "filename": "src/liballoc/btree/node.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Fliballoc%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Fliballoc%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fnode.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -41,14 +41,13 @@\n // - A node of length `n` has `n` keys, `n` values, and (in an internal node) `n + 1` edges.\n //   This implies that even an empty internal node has at least one edge.\n \n-use core::heap::{Alloc, Layout};\n use core::marker::PhantomData;\n use core::mem;\n use core::ptr::{self, Unique, NonNull};\n use core::slice;\n \n+use alloc::{Global, Alloc, Layout};\n use boxed::Box;\n-use heap::Heap;\n \n const B: usize = 6;\n pub const MIN_LEN: usize = B - 1;\n@@ -237,7 +236,7 @@ impl<K, V> Root<K, V> {\n     pub fn pop_level(&mut self) {\n         debug_assert!(self.height > 0);\n \n-        let top = self.node.ptr.as_ptr() as *mut u8;\n+        let top = self.node.ptr;\n \n         self.node = unsafe {\n             BoxedNode::from_ptr(self.as_mut()\n@@ -250,7 +249,7 @@ impl<K, V> Root<K, V> {\n         self.as_mut().as_leaf_mut().parent = ptr::null();\n \n         unsafe {\n-            Heap.dealloc(top, Layout::new::<InternalNode<K, V>>());\n+            Global.dealloc(NonNull::from(top).as_opaque(), Layout::new::<InternalNode<K, V>>());\n         }\n     }\n }\n@@ -434,9 +433,9 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::Leaf> {\n             marker::Edge\n         >\n     > {\n-        let ptr = self.as_leaf() as *const LeafNode<K, V> as *const u8 as *mut u8;\n+        let node = self.node;\n         let ret = self.ascend().ok();\n-        Heap.dealloc(ptr, Layout::new::<LeafNode<K, V>>());\n+        Global.dealloc(node.as_opaque(), Layout::new::<LeafNode<K, V>>());\n         ret\n     }\n }\n@@ -455,9 +454,9 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::Internal> {\n             marker::Edge\n         >\n     > {\n-        let ptr = self.as_internal() as *const InternalNode<K, V> as *const u8 as *mut u8;\n+        let node = self.node;\n         let ret = self.ascend().ok();\n-        Heap.dealloc(ptr, Layout::new::<InternalNode<K, V>>());\n+        Global.dealloc(node.as_opaque(), Layout::new::<InternalNode<K, V>>());\n         ret\n     }\n }\n@@ -1239,13 +1238,13 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                     ).correct_parent_link();\n                 }\n \n-                Heap.dealloc(\n-                    right_node.node.as_ptr() as *mut u8,\n+                Global.dealloc(\n+                    right_node.node.as_opaque(),\n                     Layout::new::<InternalNode<K, V>>(),\n                 );\n             } else {\n-                Heap.dealloc(\n-                    right_node.node.as_ptr() as *mut u8,\n+                Global.dealloc(\n+                    right_node.node.as_opaque(),\n                     Layout::new::<LeafNode<K, V>>(),\n                 );\n             }"}, {"sha": "faac38ca7ce15d5a35fe1e09f06f4b223b009fc7", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 53, "deletions": 232, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -8,282 +8,103 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![unstable(feature = \"allocator_api\",\n-            reason = \"the precise API and guarantees it provides may be tweaked \\\n-                      slightly, especially to possibly take into account the \\\n-                      types being stored to make room for a future \\\n-                      tracing garbage collector\",\n-            issue = \"32838\")]\n+#![allow(deprecated)]\n \n-use core::intrinsics::{min_align_of_val, size_of_val};\n-use core::mem::{self, ManuallyDrop};\n-use core::usize;\n+pub use alloc::{Layout, AllocErr, CannotReallocInPlace, Opaque};\n+use core::alloc::Alloc as CoreAlloc;\n+use core::ptr::NonNull;\n \n-pub use core::heap::*;\n #[doc(hidden)]\n pub mod __core {\n     pub use core::*;\n }\n \n-extern \"Rust\" {\n-    #[allocator]\n-    #[rustc_allocator_nounwind]\n-    fn __rust_alloc(size: usize, align: usize, err: *mut u8) -> *mut u8;\n-    #[cold]\n-    #[rustc_allocator_nounwind]\n-    fn __rust_oom(err: *const u8) -> !;\n-    #[rustc_allocator_nounwind]\n-    fn __rust_dealloc(ptr: *mut u8, size: usize, align: usize);\n-    #[rustc_allocator_nounwind]\n-    fn __rust_usable_size(layout: *const u8,\n-                          min: *mut usize,\n-                          max: *mut usize);\n-    #[rustc_allocator_nounwind]\n-    fn __rust_realloc(ptr: *mut u8,\n-                      old_size: usize,\n-                      old_align: usize,\n-                      new_size: usize,\n-                      new_align: usize,\n-                      err: *mut u8) -> *mut u8;\n-    #[rustc_allocator_nounwind]\n-    fn __rust_alloc_zeroed(size: usize, align: usize, err: *mut u8) -> *mut u8;\n-    #[rustc_allocator_nounwind]\n-    fn __rust_alloc_excess(size: usize,\n-                           align: usize,\n-                           excess: *mut usize,\n-                           err: *mut u8) -> *mut u8;\n-    #[rustc_allocator_nounwind]\n-    fn __rust_realloc_excess(ptr: *mut u8,\n-                             old_size: usize,\n-                             old_align: usize,\n-                             new_size: usize,\n-                             new_align: usize,\n-                             excess: *mut usize,\n-                             err: *mut u8) -> *mut u8;\n-    #[rustc_allocator_nounwind]\n-    fn __rust_grow_in_place(ptr: *mut u8,\n-                            old_size: usize,\n-                            old_align: usize,\n-                            new_size: usize,\n-                            new_align: usize) -> u8;\n-    #[rustc_allocator_nounwind]\n-    fn __rust_shrink_in_place(ptr: *mut u8,\n-                              old_size: usize,\n-                              old_align: usize,\n-                              new_size: usize,\n-                              new_align: usize) -> u8;\n-}\n+#[derive(Debug)]\n+pub struct Excess(pub *mut u8, pub usize);\n \n-#[derive(Copy, Clone, Default, Debug)]\n-pub struct Heap;\n+/// Compatibility with older versions of #[global_allocator] during bootstrap\n+pub unsafe trait Alloc {\n+    unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr>;\n+    unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout);\n+    fn oom(&mut self, err: AllocErr) -> !;\n+    fn usable_size(&self, layout: &Layout) -> (usize, usize);\n+    unsafe fn realloc(&mut self,\n+                      ptr: *mut u8,\n+                      layout: Layout,\n+                      new_layout: Layout) -> Result<*mut u8, AllocErr>;\n+    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<*mut u8, AllocErr>;\n+    unsafe fn alloc_excess(&mut self, layout: Layout) -> Result<Excess, AllocErr>;\n+    unsafe fn realloc_excess(&mut self,\n+                             ptr: *mut u8,\n+                             layout: Layout,\n+                             new_layout: Layout) -> Result<Excess, AllocErr>;\n+    unsafe fn grow_in_place(&mut self,\n+                            ptr: *mut u8,\n+                            layout: Layout,\n+                            new_layout: Layout) -> Result<(), CannotReallocInPlace>;\n+    unsafe fn shrink_in_place(&mut self,\n+                              ptr: *mut u8,\n+                              layout: Layout,\n+                              new_layout: Layout) -> Result<(), CannotReallocInPlace>;\n+}\n \n-unsafe impl Alloc for Heap {\n-    #[inline]\n+unsafe impl<T> Alloc for T where T: CoreAlloc {\n     unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n-        let mut err = ManuallyDrop::new(mem::uninitialized::<AllocErr>());\n-        let ptr = __rust_alloc(layout.size(),\n-                               layout.align(),\n-                               &mut *err as *mut AllocErr as *mut u8);\n-        if ptr.is_null() {\n-            Err(ManuallyDrop::into_inner(err))\n-        } else {\n-            Ok(ptr)\n-        }\n+        CoreAlloc::alloc(self, layout).map(|ptr| ptr.cast().as_ptr())\n     }\n \n-    #[inline]\n-    #[cold]\n-    fn oom(&mut self, err: AllocErr) -> ! {\n-        unsafe {\n-            __rust_oom(&err as *const AllocErr as *const u8)\n-        }\n+    unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout) {\n+        let ptr = NonNull::new_unchecked(ptr as *mut Opaque);\n+        CoreAlloc::dealloc(self, ptr, layout)\n     }\n \n-    #[inline]\n-    unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout) {\n-        __rust_dealloc(ptr, layout.size(), layout.align())\n+    fn oom(&mut self, _: AllocErr) -> ! {\n+        CoreAlloc::oom(self)\n     }\n \n-    #[inline]\n     fn usable_size(&self, layout: &Layout) -> (usize, usize) {\n-        let mut min = 0;\n-        let mut max = 0;\n-        unsafe {\n-            __rust_usable_size(layout as *const Layout as *const u8,\n-                               &mut min,\n-                               &mut max);\n-        }\n-        (min, max)\n+        CoreAlloc::usable_size(self, layout)\n     }\n \n-    #[inline]\n     unsafe fn realloc(&mut self,\n                       ptr: *mut u8,\n                       layout: Layout,\n-                      new_layout: Layout)\n-                      -> Result<*mut u8, AllocErr>\n-    {\n-        let mut err = ManuallyDrop::new(mem::uninitialized::<AllocErr>());\n-        let ptr = __rust_realloc(ptr,\n-                                 layout.size(),\n-                                 layout.align(),\n-                                 new_layout.size(),\n-                                 new_layout.align(),\n-                                 &mut *err as *mut AllocErr as *mut u8);\n-        if ptr.is_null() {\n-            Err(ManuallyDrop::into_inner(err))\n-        } else {\n-            mem::forget(err);\n-            Ok(ptr)\n-        }\n+                      new_layout: Layout) -> Result<*mut u8, AllocErr> {\n+        let ptr = NonNull::new_unchecked(ptr as *mut Opaque);\n+        CoreAlloc::realloc(self, ptr, layout, new_layout.size()).map(|ptr| ptr.cast().as_ptr())\n     }\n \n-    #[inline]\n     unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n-        let mut err = ManuallyDrop::new(mem::uninitialized::<AllocErr>());\n-        let ptr = __rust_alloc_zeroed(layout.size(),\n-                                      layout.align(),\n-                                      &mut *err as *mut AllocErr as *mut u8);\n-        if ptr.is_null() {\n-            Err(ManuallyDrop::into_inner(err))\n-        } else {\n-            Ok(ptr)\n-        }\n+        CoreAlloc::alloc_zeroed(self, layout).map(|ptr| ptr.cast().as_ptr())\n     }\n \n-    #[inline]\n     unsafe fn alloc_excess(&mut self, layout: Layout) -> Result<Excess, AllocErr> {\n-        let mut err = ManuallyDrop::new(mem::uninitialized::<AllocErr>());\n-        let mut size = 0;\n-        let ptr = __rust_alloc_excess(layout.size(),\n-                                      layout.align(),\n-                                      &mut size,\n-                                      &mut *err as *mut AllocErr as *mut u8);\n-        if ptr.is_null() {\n-            Err(ManuallyDrop::into_inner(err))\n-        } else {\n-            Ok(Excess(ptr, size))\n-        }\n+        CoreAlloc::alloc_excess(self, layout)\n+            .map(|e| Excess(e.0 .cast().as_ptr(), e.1))\n     }\n \n-    #[inline]\n     unsafe fn realloc_excess(&mut self,\n                              ptr: *mut u8,\n                              layout: Layout,\n                              new_layout: Layout) -> Result<Excess, AllocErr> {\n-        let mut err = ManuallyDrop::new(mem::uninitialized::<AllocErr>());\n-        let mut size = 0;\n-        let ptr = __rust_realloc_excess(ptr,\n-                                        layout.size(),\n-                                        layout.align(),\n-                                        new_layout.size(),\n-                                        new_layout.align(),\n-                                        &mut size,\n-                                        &mut *err as *mut AllocErr as *mut u8);\n-        if ptr.is_null() {\n-            Err(ManuallyDrop::into_inner(err))\n-        } else {\n-            Ok(Excess(ptr, size))\n-        }\n+        let ptr = NonNull::new_unchecked(ptr as *mut Opaque);\n+        CoreAlloc::realloc_excess(self, ptr, layout, new_layout.size())\n+            .map(|e| Excess(e.0 .cast().as_ptr(), e.1))\n     }\n \n-    #[inline]\n     unsafe fn grow_in_place(&mut self,\n                             ptr: *mut u8,\n                             layout: Layout,\n-                            new_layout: Layout)\n-                            -> Result<(), CannotReallocInPlace>\n-    {\n-        debug_assert!(new_layout.size() >= layout.size());\n-        debug_assert!(new_layout.align() == layout.align());\n-        let ret = __rust_grow_in_place(ptr,\n-                                       layout.size(),\n-                                       layout.align(),\n-                                       new_layout.size(),\n-                                       new_layout.align());\n-        if ret != 0 {\n-            Ok(())\n-        } else {\n-            Err(CannotReallocInPlace)\n-        }\n+                            new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n+        let ptr = NonNull::new_unchecked(ptr as *mut Opaque);\n+        CoreAlloc::grow_in_place(self, ptr, layout, new_layout.size())\n     }\n \n-    #[inline]\n     unsafe fn shrink_in_place(&mut self,\n                               ptr: *mut u8,\n                               layout: Layout,\n                               new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n-        debug_assert!(new_layout.size() <= layout.size());\n-        debug_assert!(new_layout.align() == layout.align());\n-        let ret = __rust_shrink_in_place(ptr,\n-                                         layout.size(),\n-                                         layout.align(),\n-                                         new_layout.size(),\n-                                         new_layout.align());\n-        if ret != 0 {\n-            Ok(())\n-        } else {\n-            Err(CannotReallocInPlace)\n-        }\n-    }\n-}\n-\n-/// The allocator for unique pointers.\n-// This function must not unwind. If it does, MIR trans will fail.\n-#[cfg(not(test))]\n-#[lang = \"exchange_malloc\"]\n-#[inline]\n-unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n-    if size == 0 {\n-        align as *mut u8\n-    } else {\n-        let layout = Layout::from_size_align_unchecked(size, align);\n-        Heap.alloc(layout).unwrap_or_else(|err| {\n-            Heap.oom(err)\n-        })\n-    }\n-}\n-\n-#[cfg_attr(not(test), lang = \"box_free\")]\n-#[inline]\n-pub(crate) unsafe fn box_free<T: ?Sized>(ptr: *mut T) {\n-    let size = size_of_val(&*ptr);\n-    let align = min_align_of_val(&*ptr);\n-    // We do not allocate for Box<T> when T is ZST, so deallocation is also not necessary.\n-    if size != 0 {\n-        let layout = Layout::from_size_align_unchecked(size, align);\n-        Heap.dealloc(ptr as *mut u8, layout);\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    extern crate test;\n-    use self::test::Bencher;\n-    use boxed::Box;\n-    use heap::{Heap, Alloc, Layout};\n-\n-    #[test]\n-    fn allocate_zeroed() {\n-        unsafe {\n-            let layout = Layout::from_size_align(1024, 1).unwrap();\n-            let ptr = Heap.alloc_zeroed(layout.clone())\n-                .unwrap_or_else(|e| Heap.oom(e));\n-\n-            let end = ptr.offset(layout.size() as isize);\n-            let mut i = ptr;\n-            while i < end {\n-                assert_eq!(*i, 0);\n-                i = i.offset(1);\n-            }\n-            Heap.dealloc(ptr, layout);\n-        }\n-    }\n-\n-    #[bench]\n-    fn alloc_owned_small(b: &mut Bencher) {\n-        b.iter(|| {\n-            let _: Box<_> = box 10;\n-        })\n+        let ptr = NonNull::new_unchecked(ptr as *mut Opaque);\n+        CoreAlloc::shrink_in_place(self, ptr, layout, new_layout.size())\n     }\n }"}, {"sha": "3a106a2ff5c3debd6e19205a2f49a6fbc7b5b600", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -57,7 +57,7 @@\n //!\n //! ## Heap interfaces\n //!\n-//! The [`heap`](heap/index.html) module defines the low-level interface to the\n+//! The [`alloc`](alloc/index.html) module defines the low-level interface to the\n //! default global allocator. It is not compatible with the libc allocator API.\n \n #![allow(unused_attributes)]\n@@ -97,7 +97,9 @@\n #![feature(from_ref)]\n #![feature(fundamental)]\n #![feature(lang_items)]\n+#![feature(libc)]\n #![feature(needs_allocator)]\n+#![feature(nonnull_cast)]\n #![feature(nonzero)]\n #![feature(optin_builtin_traits)]\n #![feature(pattern)]\n@@ -141,10 +143,26 @@ mod macros;\n \n #[rustc_deprecated(since = \"1.27.0\", reason = \"use the heap module in core, alloc, or std instead\")]\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-pub use core::heap as allocator;\n+/// Use the `alloc` module instead.\n+pub mod allocator {\n+    pub use alloc::*;\n+}\n \n // Heaps provided for low-level allocation strategies\n \n+pub mod alloc;\n+\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+#[rustc_deprecated(since = \"1.27.0\", reason = \"module renamed to `alloc`\")]\n+/// Use the `alloc` module instead.\n+#[cfg(not(stage0))]\n+pub mod heap {\n+    pub use alloc::*;\n+}\n+\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+#[rustc_deprecated(since = \"1.27.0\", reason = \"module renamed to `alloc`\")]\n+#[cfg(stage0)]\n pub mod heap;\n \n // Primitive types using the heaps above"}, {"sha": "214cc7d7d0cd96e6f8553f58f12a024deb5b62d4", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 43, "deletions": 47, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -8,13 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use alloc::{Alloc, Layout, Global};\n use core::cmp;\n-use core::heap::{Alloc, Layout};\n use core::mem;\n use core::ops::Drop;\n-use core::ptr::{self, Unique};\n+use core::ptr::{self, NonNull, Unique};\n use core::slice;\n-use heap::Heap;\n use super::boxed::Box;\n use super::allocator::CollectionAllocErr;\n use super::allocator::CollectionAllocErr::*;\n@@ -47,7 +46,7 @@ use super::allocator::CollectionAllocErr::*;\n /// field. This allows zero-sized types to not be special-cased by consumers of\n /// this type.\n #[allow(missing_debug_implementations)]\n-pub struct RawVec<T, A: Alloc = Heap> {\n+pub struct RawVec<T, A: Alloc = Global> {\n     ptr: Unique<T>,\n     cap: usize,\n     a: A,\n@@ -91,7 +90,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n \n             // handles ZSTs and `cap = 0` alike\n             let ptr = if alloc_size == 0 {\n-                mem::align_of::<T>() as *mut u8\n+                NonNull::<T>::dangling().as_opaque()\n             } else {\n                 let align = mem::align_of::<T>();\n                 let result = if zeroed {\n@@ -101,27 +100,27 @@ impl<T, A: Alloc> RawVec<T, A> {\n                 };\n                 match result {\n                     Ok(ptr) => ptr,\n-                    Err(err) => a.oom(err),\n+                    Err(_) => a.oom(),\n                 }\n             };\n \n             RawVec {\n-                ptr: Unique::new_unchecked(ptr as *mut _),\n+                ptr: ptr.cast().into(),\n                 cap,\n                 a,\n             }\n         }\n     }\n }\n \n-impl<T> RawVec<T, Heap> {\n+impl<T> RawVec<T, Global> {\n     /// Creates the biggest possible RawVec (on the system heap)\n     /// without allocating. If T has positive size, then this makes a\n     /// RawVec with capacity 0. If T has 0 size, then it makes a\n     /// RawVec with capacity `usize::MAX`. Useful for implementing\n     /// delayed allocation.\n     pub fn new() -> Self {\n-        Self::new_in(Heap)\n+        Self::new_in(Global)\n     }\n \n     /// Creates a RawVec (on the system heap) with exactly the\n@@ -141,13 +140,13 @@ impl<T> RawVec<T, Heap> {\n     /// Aborts on OOM\n     #[inline]\n     pub fn with_capacity(cap: usize) -> Self {\n-        RawVec::allocate_in(cap, false, Heap)\n+        RawVec::allocate_in(cap, false, Global)\n     }\n \n     /// Like `with_capacity` but guarantees the buffer is zeroed.\n     #[inline]\n     pub fn with_capacity_zeroed(cap: usize) -> Self {\n-        RawVec::allocate_in(cap, true, Heap)\n+        RawVec::allocate_in(cap, true, Global)\n     }\n }\n \n@@ -168,7 +167,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     }\n }\n \n-impl<T> RawVec<T, Heap> {\n+impl<T> RawVec<T, Global> {\n     /// Reconstitutes a RawVec from a pointer, capacity.\n     ///\n     /// # Undefined Behavior\n@@ -180,7 +179,7 @@ impl<T> RawVec<T, Heap> {\n         RawVec {\n             ptr: Unique::new_unchecked(ptr),\n             cap,\n-            a: Heap,\n+            a: Global,\n         }\n     }\n \n@@ -310,14 +309,13 @@ impl<T, A: Alloc> RawVec<T, A> {\n                     // `from_size_align_unchecked`.\n                     let new_cap = 2 * self.cap;\n                     let new_size = new_cap * elem_size;\n-                    let new_layout = Layout::from_size_align_unchecked(new_size, cur.align());\n                     alloc_guard(new_size).expect(\"capacity overflow\");\n-                    let ptr_res = self.a.realloc(self.ptr.as_ptr() as *mut u8,\n+                    let ptr_res = self.a.realloc(NonNull::from(self.ptr).as_opaque(),\n                                                  cur,\n-                                                 new_layout);\n+                                                 new_size);\n                     match ptr_res {\n-                        Ok(ptr) => (new_cap, Unique::new_unchecked(ptr as *mut T)),\n-                        Err(e) => self.a.oom(e),\n+                        Ok(ptr) => (new_cap, ptr.cast().into()),\n+                        Err(_) => self.a.oom(),\n                     }\n                 }\n                 None => {\n@@ -326,7 +324,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n                     let new_cap = if elem_size > (!0) / 8 { 1 } else { 4 };\n                     match self.a.alloc_array::<T>(new_cap) {\n                         Ok(ptr) => (new_cap, ptr.into()),\n-                        Err(e) => self.a.oom(e),\n+                        Err(_) => self.a.oom(),\n                     }\n                 }\n             };\n@@ -371,9 +369,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n             let new_cap = 2 * self.cap;\n             let new_size = new_cap * elem_size;\n             alloc_guard(new_size).expect(\"capacity overflow\");\n-            let ptr = self.ptr() as *mut _;\n-            let new_layout = Layout::from_size_align_unchecked(new_size, old_layout.align());\n-            match self.a.grow_in_place(ptr, old_layout, new_layout) {\n+            match self.a.grow_in_place(NonNull::from(self.ptr).as_opaque(), old_layout, new_size) {\n                 Ok(_) => {\n                     // We can't directly divide `size`.\n                     self.cap = new_cap;\n@@ -423,19 +419,19 @@ impl<T, A: Alloc> RawVec<T, A> {\n \n             // Nothing we can really do about these checks :(\n             let new_cap = used_cap.checked_add(needed_extra_cap).ok_or(CapacityOverflow)?;\n-            let new_layout = Layout::array::<T>(new_cap).ok_or(CapacityOverflow)?;\n+            let new_layout = Layout::array::<T>(new_cap).map_err(|_| CapacityOverflow)?;\n \n             alloc_guard(new_layout.size())?;\n \n             let res = match self.current_layout() {\n                 Some(layout) => {\n-                    let old_ptr = self.ptr.as_ptr() as *mut u8;\n-                    self.a.realloc(old_ptr, layout, new_layout)\n+                    debug_assert!(new_layout.align() == layout.align());\n+                    self.a.realloc(NonNull::from(self.ptr).as_opaque(), layout, new_layout.size())\n                 }\n                 None => self.a.alloc(new_layout),\n             };\n \n-            self.ptr = Unique::new_unchecked(res? as *mut T);\n+            self.ptr = res?.cast().into();\n             self.cap = new_cap;\n \n             Ok(())\n@@ -445,7 +441,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     pub fn reserve_exact(&mut self, used_cap: usize, needed_extra_cap: usize) {\n         match self.try_reserve_exact(used_cap, needed_extra_cap) {\n             Err(CapacityOverflow) => panic!(\"capacity overflow\"),\n-            Err(AllocErr(e)) => self.a.oom(e),\n+            Err(AllocErr) => self.a.oom(),\n             Ok(()) => { /* yay */ }\n          }\n      }\n@@ -531,20 +527,20 @@ impl<T, A: Alloc> RawVec<T, A> {\n             }\n \n             let new_cap = self.amortized_new_size(used_cap, needed_extra_cap)?;\n-            let new_layout = Layout::array::<T>(new_cap).ok_or(CapacityOverflow)?;\n+            let new_layout = Layout::array::<T>(new_cap).map_err(|_| CapacityOverflow)?;\n \n              // FIXME: may crash and burn on over-reserve\n             alloc_guard(new_layout.size())?;\n \n             let res = match self.current_layout() {\n                 Some(layout) => {\n-                    let old_ptr = self.ptr.as_ptr() as *mut u8;\n-                    self.a.realloc(old_ptr, layout, new_layout)\n+                    debug_assert!(new_layout.align() == layout.align());\n+                    self.a.realloc(NonNull::from(self.ptr).as_opaque(), layout, new_layout.size())\n                 }\n                 None => self.a.alloc(new_layout),\n             };\n \n-            self.ptr = Unique::new_unchecked(res? as *mut T);\n+            self.ptr = res?.cast().into();\n             self.cap = new_cap;\n \n             Ok(())\n@@ -555,7 +551,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     pub fn reserve(&mut self, used_cap: usize, needed_extra_cap: usize) {\n         match self.try_reserve(used_cap, needed_extra_cap) {\n             Err(CapacityOverflow) => panic!(\"capacity overflow\"),\n-            Err(AllocErr(e)) => self.a.oom(e),\n+            Err(AllocErr) => self.a.oom(),\n             Ok(()) => { /* yay */ }\n          }\n      }\n@@ -601,11 +597,12 @@ impl<T, A: Alloc> RawVec<T, A> {\n             // (regardless of whether `self.cap - used_cap` wrapped).\n             // Therefore we can safely call grow_in_place.\n \n-            let ptr = self.ptr() as *mut _;\n             let new_layout = Layout::new::<T>().repeat(new_cap).unwrap().0;\n             // FIXME: may crash and burn on over-reserve\n             alloc_guard(new_layout.size()).expect(\"capacity overflow\");\n-            match self.a.grow_in_place(ptr, old_layout, new_layout) {\n+            match self.a.grow_in_place(\n+                NonNull::from(self.ptr).as_opaque(), old_layout, new_layout.size(),\n+            ) {\n                 Ok(_) => {\n                     self.cap = new_cap;\n                     true\n@@ -665,20 +662,19 @@ impl<T, A: Alloc> RawVec<T, A> {\n                 let new_size = elem_size * amount;\n                 let align = mem::align_of::<T>();\n                 let old_layout = Layout::from_size_align_unchecked(old_size, align);\n-                let new_layout = Layout::from_size_align_unchecked(new_size, align);\n-                match self.a.realloc(self.ptr.as_ptr() as *mut u8,\n+                match self.a.realloc(NonNull::from(self.ptr).as_opaque(),\n                                      old_layout,\n-                                     new_layout) {\n-                    Ok(p) => self.ptr = Unique::new_unchecked(p as *mut T),\n-                    Err(err) => self.a.oom(err),\n+                                     new_size) {\n+                    Ok(p) => self.ptr = p.cast().into(),\n+                    Err(_) => self.a.oom(),\n                 }\n             }\n             self.cap = amount;\n         }\n     }\n }\n \n-impl<T> RawVec<T, Heap> {\n+impl<T> RawVec<T, Global> {\n     /// Converts the entire buffer into `Box<[T]>`.\n     ///\n     /// While it is not *strictly* Undefined Behavior to call\n@@ -702,8 +698,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n         let elem_size = mem::size_of::<T>();\n         if elem_size != 0 {\n             if let Some(layout) = self.current_layout() {\n-                let ptr = self.ptr() as *mut u8;\n-                self.a.dealloc(ptr, layout);\n+                self.a.dealloc(NonNull::from(self.ptr).as_opaque(), layout);\n             }\n         }\n     }\n@@ -739,6 +734,7 @@ fn alloc_guard(alloc_size: usize) -> Result<(), CollectionAllocErr> {\n #[cfg(test)]\n mod tests {\n     use super::*;\n+    use alloc::Opaque;\n \n     #[test]\n     fn allocator_param() {\n@@ -758,18 +754,18 @@ mod tests {\n         // before allocation attempts start failing.\n         struct BoundedAlloc { fuel: usize }\n         unsafe impl Alloc for BoundedAlloc {\n-            unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n+            unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<Opaque>, AllocErr> {\n                 let size = layout.size();\n                 if size > self.fuel {\n-                    return Err(AllocErr::Unsupported { details: \"fuel exhausted\" });\n+                    return Err(AllocErr);\n                 }\n-                match Heap.alloc(layout) {\n+                match Global.alloc(layout) {\n                     ok @ Ok(_) => { self.fuel -= size; ok }\n                     err @ Err(_) => err,\n                 }\n             }\n-            unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout) {\n-                Heap.dealloc(ptr, layout)\n+            unsafe fn dealloc(&mut self, ptr: NonNull<Opaque>, layout: Layout) {\n+                Global.dealloc(ptr, layout)\n             }\n         }\n "}, {"sha": "de0422d82bb76aaa77fce3a616e60e461b18a555", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -250,7 +250,6 @@ use core::cell::Cell;\n use core::cmp::Ordering;\n use core::fmt;\n use core::hash::{Hash, Hasher};\n-use core::heap::{Alloc, Layout};\n use core::intrinsics::abort;\n use core::marker;\n use core::marker::{Unsize, PhantomData};\n@@ -260,7 +259,7 @@ use core::ops::CoerceUnsized;\n use core::ptr::{self, NonNull};\n use core::convert::From;\n \n-use heap::{Heap, box_free};\n+use alloc::{Global, Alloc, Layout, Opaque, box_free};\n use string::String;\n use vec::Vec;\n \n@@ -668,11 +667,11 @@ impl<T: ?Sized> Rc<T> {\n \n         let layout = Layout::for_value(&*fake_ptr);\n \n-        let mem = Heap.alloc(layout)\n-            .unwrap_or_else(|e| Heap.oom(e));\n+        let mem = Global.alloc(layout)\n+            .unwrap_or_else(|_| Global.oom());\n \n         // Initialize the real RcBox\n-        let inner = set_data_ptr(ptr as *mut T, mem) as *mut RcBox<T>;\n+        let inner = set_data_ptr(ptr as *mut T, mem.as_ptr() as *mut u8) as *mut RcBox<T>;\n \n         ptr::write(&mut (*inner).strong, Cell::new(1));\n         ptr::write(&mut (*inner).weak, Cell::new(1));\n@@ -738,7 +737,7 @@ impl<T: Clone> RcFromSlice<T> for Rc<[T]> {\n         // In the event of a panic, elements that have been written\n         // into the new RcBox will be dropped, then the memory freed.\n         struct Guard<T> {\n-            mem: *mut u8,\n+            mem: NonNull<Opaque>,\n             elems: *mut T,\n             layout: Layout,\n             n_elems: usize,\n@@ -752,7 +751,7 @@ impl<T: Clone> RcFromSlice<T> for Rc<[T]> {\n                     let slice = from_raw_parts_mut(self.elems, self.n_elems);\n                     ptr::drop_in_place(slice);\n \n-                    Heap.dealloc(self.mem, self.layout.clone());\n+                    Global.dealloc(self.mem, self.layout.clone());\n                 }\n             }\n         }\n@@ -761,14 +760,14 @@ impl<T: Clone> RcFromSlice<T> for Rc<[T]> {\n             let v_ptr = v as *const [T];\n             let ptr = Self::allocate_for_ptr(v_ptr);\n \n-            let mem = ptr as *mut _ as *mut u8;\n+            let mem = ptr as *mut _ as *mut Opaque;\n             let layout = Layout::for_value(&*ptr);\n \n             // Pointer to first element\n             let elems = &mut (*ptr).value as *mut [T] as *mut T;\n \n             let mut guard = Guard{\n-                mem: mem,\n+                mem: NonNull::new_unchecked(mem),\n                 elems: elems,\n                 layout: layout,\n                 n_elems: 0,\n@@ -835,8 +834,6 @@ unsafe impl<#[may_dangle] T: ?Sized> Drop for Rc<T> {\n     /// ```\n     fn drop(&mut self) {\n         unsafe {\n-            let ptr = self.ptr.as_ptr();\n-\n             self.dec_strong();\n             if self.strong() == 0 {\n                 // destroy the contained object\n@@ -847,7 +844,7 @@ unsafe impl<#[may_dangle] T: ?Sized> Drop for Rc<T> {\n                 self.dec_weak();\n \n                 if self.weak() == 0 {\n-                    Heap.dealloc(ptr as *mut u8, Layout::for_value(&*ptr));\n+                    Global.dealloc(self.ptr.as_opaque(), Layout::for_value(self.ptr.as_ref()));\n                 }\n             }\n         }\n@@ -1267,13 +1264,11 @@ impl<T: ?Sized> Drop for Weak<T> {\n     /// ```\n     fn drop(&mut self) {\n         unsafe {\n-            let ptr = self.ptr.as_ptr();\n-\n             self.dec_weak();\n             // the weak count starts at 1, and will only go to zero if all\n             // the strong pointers have disappeared.\n             if self.weak() == 0 {\n-                Heap.dealloc(ptr as *mut u8, Layout::for_value(&*ptr));\n+                Global.dealloc(self.ptr.as_opaque(), Layout::for_value(self.ptr.as_ref()));\n             }\n         }\n     }"}, {"sha": "6fa88ce969a0e4866941b80337bd2c5841d31a06", "filename": "src/liballoc/tests/heap.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Fliballoc%2Ftests%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Fliballoc%2Ftests%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fheap.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use alloc_system::System;\n-use std::heap::{Heap, Alloc, Layout};\n+use std::alloc::{Global, Alloc, Layout};\n \n /// https://github.com/rust-lang/rust/issues/45955\n ///\n@@ -22,7 +22,7 @@ fn alloc_system_overaligned_request() {\n \n #[test]\n fn std_heap_overaligned_request() {\n-    check_overalign_requests(Heap)\n+    check_overalign_requests(Global)\n }\n \n fn check_overalign_requests<T: Alloc>(mut allocator: T) {\n@@ -34,7 +34,8 @@ fn check_overalign_requests<T: Alloc>(mut allocator: T) {\n             allocator.alloc(Layout::from_size_align(size, align).unwrap()).unwrap()\n         }).collect();\n         for &ptr in &pointers {\n-            assert_eq!((ptr as usize) % align, 0, \"Got a pointer less aligned than requested\")\n+            assert_eq!((ptr.as_ptr() as usize) % align, 0,\n+                       \"Got a pointer less aligned than requested\")\n         }\n \n         // Clean up"}, {"sha": "befb36baeef1ebc0c91f67f8c4aa9dba2213bcbf", "filename": "src/liballoc/tests/string.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Fliballoc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Fliballoc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstring.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -575,11 +575,11 @@ fn test_try_reserve() {\n             } else { panic!(\"usize::MAX should trigger an overflow!\") }\n         } else {\n             // Check isize::MAX + 1 is an OOM\n-            if let Err(AllocErr(_)) = empty_string.try_reserve(MAX_CAP + 1) {\n+            if let Err(AllocErr) = empty_string.try_reserve(MAX_CAP + 1) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n \n             // Check usize::MAX is an OOM\n-            if let Err(AllocErr(_)) = empty_string.try_reserve(MAX_USIZE) {\n+            if let Err(AllocErr) = empty_string.try_reserve(MAX_USIZE) {\n             } else { panic!(\"usize::MAX should trigger an OOM!\") }\n         }\n     }\n@@ -599,7 +599,7 @@ fn test_try_reserve() {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr(_)) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            if let Err(AllocErr) = ten_bytes.try_reserve(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         // Should always overflow in the add-to-len\n@@ -637,10 +637,10 @@ fn test_try_reserve_exact() {\n             if let Err(CapacityOverflow) = empty_string.try_reserve_exact(MAX_USIZE) {\n             } else { panic!(\"usize::MAX should trigger an overflow!\") }\n         } else {\n-            if let Err(AllocErr(_)) = empty_string.try_reserve_exact(MAX_CAP + 1) {\n+            if let Err(AllocErr) = empty_string.try_reserve_exact(MAX_CAP + 1) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n \n-            if let Err(AllocErr(_)) = empty_string.try_reserve_exact(MAX_USIZE) {\n+            if let Err(AllocErr) = empty_string.try_reserve_exact(MAX_USIZE) {\n             } else { panic!(\"usize::MAX should trigger an OOM!\") }\n         }\n     }\n@@ -659,7 +659,7 @@ fn test_try_reserve_exact() {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr(_)) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            if let Err(AllocErr) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE) {"}, {"sha": "e329b45a6175d8641532e4d71d6c1e0a7f05cc3a", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -1016,11 +1016,11 @@ fn test_try_reserve() {\n             } else { panic!(\"usize::MAX should trigger an overflow!\") }\n         } else {\n             // Check isize::MAX + 1 is an OOM\n-            if let Err(AllocErr(_)) = empty_bytes.try_reserve(MAX_CAP + 1) {\n+            if let Err(AllocErr) = empty_bytes.try_reserve(MAX_CAP + 1) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n \n             // Check usize::MAX is an OOM\n-            if let Err(AllocErr(_)) = empty_bytes.try_reserve(MAX_USIZE) {\n+            if let Err(AllocErr) = empty_bytes.try_reserve(MAX_USIZE) {\n             } else { panic!(\"usize::MAX should trigger an OOM!\") }\n         }\n     }\n@@ -1040,7 +1040,7 @@ fn test_try_reserve() {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr(_)) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            if let Err(AllocErr) = ten_bytes.try_reserve(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         // Should always overflow in the add-to-len\n@@ -1063,7 +1063,7 @@ fn test_try_reserve() {\n             if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr(_)) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n+            if let Err(AllocErr) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         // Should fail in the mul-by-size\n@@ -1103,10 +1103,10 @@ fn test_try_reserve_exact() {\n             if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_USIZE) {\n             } else { panic!(\"usize::MAX should trigger an overflow!\") }\n         } else {\n-            if let Err(AllocErr(_)) = empty_bytes.try_reserve_exact(MAX_CAP + 1) {\n+            if let Err(AllocErr) = empty_bytes.try_reserve_exact(MAX_CAP + 1) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n \n-            if let Err(AllocErr(_)) = empty_bytes.try_reserve_exact(MAX_USIZE) {\n+            if let Err(AllocErr) = empty_bytes.try_reserve_exact(MAX_USIZE) {\n             } else { panic!(\"usize::MAX should trigger an OOM!\") }\n         }\n     }\n@@ -1125,7 +1125,7 @@ fn test_try_reserve_exact() {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr(_)) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            if let Err(AllocErr) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE) {\n@@ -1146,7 +1146,7 @@ fn test_try_reserve_exact() {\n             if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr(_)) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n+            if let Err(AllocErr) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_USIZE - 20) {"}, {"sha": "4d55584e2f4df7d1f3234f8e7e5e8d5864ee16ad", "filename": "src/liballoc/tests/vec_deque.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec_deque.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -1073,7 +1073,7 @@ fn test_try_reserve() {\n             // VecDeque starts with capacity 7, always adds 1 to the capacity\n             // and also rounds the number to next power of 2 so this is the\n             // furthest we can go without triggering CapacityOverflow\n-            if let Err(AllocErr(_)) = empty_bytes.try_reserve(MAX_CAP) {\n+            if let Err(AllocErr) = empty_bytes.try_reserve(MAX_CAP) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n     }\n@@ -1093,7 +1093,7 @@ fn test_try_reserve() {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr(_)) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            if let Err(AllocErr) = ten_bytes.try_reserve(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         // Should always overflow in the add-to-len\n@@ -1116,7 +1116,7 @@ fn test_try_reserve() {\n             if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr(_)) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n+            if let Err(AllocErr) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         // Should fail in the mul-by-size\n@@ -1160,7 +1160,7 @@ fn test_try_reserve_exact() {\n             // VecDeque starts with capacity 7, always adds 1 to the capacity\n             // and also rounds the number to next power of 2 so this is the\n             // furthest we can go without triggering CapacityOverflow\n-            if let Err(AllocErr(_)) = empty_bytes.try_reserve_exact(MAX_CAP) {\n+            if let Err(AllocErr) = empty_bytes.try_reserve_exact(MAX_CAP) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n     }\n@@ -1179,7 +1179,7 @@ fn test_try_reserve_exact() {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr(_)) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            if let Err(AllocErr) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE) {\n@@ -1200,7 +1200,7 @@ fn test_try_reserve_exact() {\n             if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr(_)) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n+            if let Err(AllocErr) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_USIZE - 20) {"}, {"sha": "02435170374c503c81b7111974ebfc0266e2d3a1", "filename": "src/liballoc_jemalloc/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Fliballoc_jemalloc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Fliballoc_jemalloc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2FCargo.toml?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -12,7 +12,6 @@ test = false\n doc = false\n \n [dependencies]\n-alloc = { path = \"../liballoc\" }\n alloc_system = { path = \"../liballoc_system\" }\n core = { path = \"../libcore\" }\n libc = { path = \"../rustc/libc_shim\" }"}, {"sha": "2b66c293f21a025b16075103a640fa36c61b7d29", "filename": "src/liballoc_jemalloc/lib.rs", "status": "modified", "additions": 8, "deletions": 117, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Fliballoc_jemalloc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Fliballoc_jemalloc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Flib.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -30,9 +30,7 @@ extern crate libc;\n pub use contents::*;\n #[cfg(not(dummy_jemalloc))]\n mod contents {\n-    use core::ptr;\n-\n-    use core::heap::{Alloc, AllocErr, Layout};\n+    use core::alloc::GlobalAlloc;\n     use alloc_system::System;\n     use libc::{c_int, c_void, size_t};\n \n@@ -52,18 +50,10 @@ mod contents {\n                        target_os = \"dragonfly\", target_os = \"windows\", target_env = \"musl\"),\n                    link_name = \"je_rallocx\")]\n         fn rallocx(ptr: *mut c_void, size: size_t, flags: c_int) -> *mut c_void;\n-        #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\",\n-                       target_os = \"dragonfly\", target_os = \"windows\", target_env = \"musl\"),\n-                   link_name = \"je_xallocx\")]\n-        fn xallocx(ptr: *mut c_void, size: size_t, extra: size_t, flags: c_int) -> size_t;\n         #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\",\n                        target_os = \"dragonfly\", target_os = \"windows\", target_env = \"musl\"),\n                    link_name = \"je_sdallocx\")]\n         fn sdallocx(ptr: *mut c_void, size: size_t, flags: c_int);\n-        #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\",\n-                       target_os = \"dragonfly\", target_os = \"windows\", target_env = \"musl\"),\n-                   link_name = \"je_nallocx\")]\n-        fn nallocx(size: size_t, flags: c_int) -> size_t;\n     }\n \n     const MALLOCX_ZERO: c_int = 0x40;\n@@ -104,23 +94,16 @@ mod contents {\n \n     #[no_mangle]\n     #[rustc_std_internal_symbol]\n-    pub unsafe extern fn __rde_alloc(size: usize,\n-                                     align: usize,\n-                                     err: *mut u8) -> *mut u8 {\n+    pub unsafe extern fn __rde_alloc(size: usize, align: usize) -> *mut u8 {\n         let flags = align_to_flags(align, size);\n         let ptr = mallocx(size as size_t, flags) as *mut u8;\n-        if ptr.is_null() {\n-            let layout = Layout::from_size_align_unchecked(size, align);\n-            ptr::write(err as *mut AllocErr,\n-                       AllocErr::Exhausted { request: layout });\n-        }\n         ptr\n     }\n \n     #[no_mangle]\n     #[rustc_std_internal_symbol]\n-    pub unsafe extern fn __rde_oom(err: *const u8) -> ! {\n-        System.oom((*(err as *const AllocErr)).clone())\n+    pub unsafe extern fn __rde_oom() -> ! {\n+        System.oom()\n     }\n \n     #[no_mangle]\n@@ -132,118 +115,26 @@ mod contents {\n         sdallocx(ptr as *mut c_void, size, flags);\n     }\n \n-    #[no_mangle]\n-    #[rustc_std_internal_symbol]\n-    pub unsafe extern fn __rde_usable_size(layout: *const u8,\n-                                           min: *mut usize,\n-                                           max: *mut usize) {\n-        let layout = &*(layout as *const Layout);\n-        let flags = align_to_flags(layout.align(), layout.size());\n-        let size = nallocx(layout.size(), flags) as usize;\n-        *min = layout.size();\n-        if size > 0 {\n-            *max = size;\n-        } else {\n-            *max = layout.size();\n-        }\n-    }\n-\n     #[no_mangle]\n     #[rustc_std_internal_symbol]\n     pub unsafe extern fn __rde_realloc(ptr: *mut u8,\n                                        _old_size: usize,\n-                                       old_align: usize,\n-                                       new_size: usize,\n-                                       new_align: usize,\n-                                       err: *mut u8) -> *mut u8 {\n-        if new_align != old_align {\n-            ptr::write(err as *mut AllocErr,\n-                       AllocErr::Unsupported { details: \"can't change alignments\" });\n-            return 0 as *mut u8\n-        }\n-\n-        let flags = align_to_flags(new_align, new_size);\n+                                       align: usize,\n+                                       new_size: usize) -> *mut u8 {\n+        let flags = align_to_flags(align, new_size);\n         let ptr = rallocx(ptr as *mut c_void, new_size, flags) as *mut u8;\n-        if ptr.is_null() {\n-            let layout = Layout::from_size_align_unchecked(new_size, new_align);\n-            ptr::write(err as *mut AllocErr,\n-                       AllocErr::Exhausted { request: layout });\n-        }\n         ptr\n     }\n \n     #[no_mangle]\n     #[rustc_std_internal_symbol]\n-    pub unsafe extern fn __rde_alloc_zeroed(size: usize,\n-                                            align: usize,\n-                                            err: *mut u8) -> *mut u8 {\n+    pub unsafe extern fn __rde_alloc_zeroed(size: usize, align: usize) -> *mut u8 {\n         let ptr = if align <= MIN_ALIGN && align <= size {\n             calloc(size as size_t, 1) as *mut u8\n         } else {\n             let flags = align_to_flags(align, size) | MALLOCX_ZERO;\n             mallocx(size as size_t, flags) as *mut u8\n         };\n-        if ptr.is_null() {\n-            let layout = Layout::from_size_align_unchecked(size, align);\n-            ptr::write(err as *mut AllocErr,\n-                       AllocErr::Exhausted { request: layout });\n-        }\n         ptr\n     }\n-\n-    #[no_mangle]\n-    #[rustc_std_internal_symbol]\n-    pub unsafe extern fn __rde_alloc_excess(size: usize,\n-                                            align: usize,\n-                                            excess: *mut usize,\n-                                            err: *mut u8) -> *mut u8 {\n-        let p = __rde_alloc(size, align, err);\n-        if !p.is_null() {\n-            let flags = align_to_flags(align, size);\n-            *excess = nallocx(size, flags) as usize;\n-        }\n-        return p\n-    }\n-\n-    #[no_mangle]\n-    #[rustc_std_internal_symbol]\n-    pub unsafe extern fn __rde_realloc_excess(ptr: *mut u8,\n-                                              old_size: usize,\n-                                              old_align: usize,\n-                                              new_size: usize,\n-                                              new_align: usize,\n-                                              excess: *mut usize,\n-                                              err: *mut u8) -> *mut u8 {\n-        let p = __rde_realloc(ptr, old_size, old_align, new_size, new_align, err);\n-        if !p.is_null() {\n-            let flags = align_to_flags(new_align, new_size);\n-            *excess = nallocx(new_size, flags) as usize;\n-        }\n-        p\n-    }\n-\n-    #[no_mangle]\n-    #[rustc_std_internal_symbol]\n-    pub unsafe extern fn __rde_grow_in_place(ptr: *mut u8,\n-                                             old_size: usize,\n-                                             old_align: usize,\n-                                             new_size: usize,\n-                                             new_align: usize) -> u8 {\n-        __rde_shrink_in_place(ptr, old_size, old_align, new_size, new_align)\n-    }\n-\n-    #[no_mangle]\n-    #[rustc_std_internal_symbol]\n-    pub unsafe extern fn __rde_shrink_in_place(ptr: *mut u8,\n-                                               _old_size: usize,\n-                                               old_align: usize,\n-                                               new_size: usize,\n-                                               new_align: usize) -> u8 {\n-        if old_align == new_align {\n-            let flags = align_to_flags(new_align, new_size);\n-            (xallocx(ptr as *mut c_void, new_size, 0, flags) == new_size) as u8\n-        } else {\n-            0\n-        }\n-    }\n }"}, {"sha": "c34e2f203a8371267134c2cc1271fcb15e24f45f", "filename": "src/liballoc_system/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Fliballoc_system%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Fliballoc_system%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2FCargo.toml?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -10,7 +10,6 @@ test = false\n doc = false\n \n [dependencies]\n-alloc = { path = \"../liballoc\" }\n core = { path = \"../libcore\" }\n libc = { path = \"../rustc/libc_shim\" }\n compiler_builtins = { path = \"../rustc/compiler_builtins_shim\" }"}, {"sha": "fd8109e2a4aab3d72d280c6fbab55bb44d9f611a", "filename": "src/liballoc_system/lib.rs", "status": "modified", "additions": 160, "deletions": 295, "changes": 455, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Fliballoc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Fliballoc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Flib.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -41,207 +41,158 @@ const MIN_ALIGN: usize = 8;\n #[allow(dead_code)]\n const MIN_ALIGN: usize = 16;\n \n-use core::heap::{Alloc, AllocErr, Layout, Excess, CannotReallocInPlace};\n+use core::alloc::{Alloc, GlobalAlloc, AllocErr, Layout, Opaque};\n+use core::ptr::NonNull;\n \n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n pub struct System;\n \n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n unsafe impl Alloc for System {\n     #[inline]\n-    unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n-        (&*self).alloc(layout)\n+    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<Opaque>, AllocErr> {\n+        NonNull::new(GlobalAlloc::alloc(self, layout)).ok_or(AllocErr)\n     }\n \n     #[inline]\n-    unsafe fn alloc_zeroed(&mut self, layout: Layout)\n-        -> Result<*mut u8, AllocErr>\n-    {\n-        (&*self).alloc_zeroed(layout)\n+    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<Opaque>, AllocErr> {\n+        NonNull::new(GlobalAlloc::alloc_zeroed(self, layout)).ok_or(AllocErr)\n     }\n \n     #[inline]\n-    unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout) {\n-        (&*self).dealloc(ptr, layout)\n+    unsafe fn dealloc(&mut self, ptr: NonNull<Opaque>, layout: Layout) {\n+        GlobalAlloc::dealloc(self, ptr.as_ptr(), layout)\n     }\n \n     #[inline]\n     unsafe fn realloc(&mut self,\n-                      ptr: *mut u8,\n-                      old_layout: Layout,\n-                      new_layout: Layout) -> Result<*mut u8, AllocErr> {\n-        (&*self).realloc(ptr, old_layout, new_layout)\n+                      ptr: NonNull<Opaque>,\n+                      layout: Layout,\n+                      new_size: usize) -> Result<NonNull<Opaque>, AllocErr> {\n+        NonNull::new(GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size)).ok_or(AllocErr)\n     }\n \n-    fn oom(&mut self, err: AllocErr) -> ! {\n-        (&*self).oom(err)\n+    #[inline]\n+    fn oom(&mut self) -> ! {\n+        ::oom()\n     }\n+}\n \n+#[cfg(stage0)]\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+unsafe impl<'a> Alloc for &'a System {\n     #[inline]\n-    fn usable_size(&self, layout: &Layout) -> (usize, usize) {\n-        (&self).usable_size(layout)\n+    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<Opaque>, AllocErr> {\n+        NonNull::new(GlobalAlloc::alloc(*self, layout)).ok_or(AllocErr)\n     }\n \n     #[inline]\n-    unsafe fn alloc_excess(&mut self, layout: Layout) -> Result<Excess, AllocErr> {\n-        (&*self).alloc_excess(layout)\n+    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<Opaque>, AllocErr> {\n+        NonNull::new(GlobalAlloc::alloc_zeroed(*self, layout)).ok_or(AllocErr)\n     }\n \n     #[inline]\n-    unsafe fn realloc_excess(&mut self,\n-                             ptr: *mut u8,\n-                             layout: Layout,\n-                             new_layout: Layout) -> Result<Excess, AllocErr> {\n-        (&*self).realloc_excess(ptr, layout, new_layout)\n+    unsafe fn dealloc(&mut self, ptr: NonNull<Opaque>, layout: Layout) {\n+        GlobalAlloc::dealloc(*self, ptr.as_ptr(), layout)\n     }\n \n     #[inline]\n-    unsafe fn grow_in_place(&mut self,\n-                            ptr: *mut u8,\n-                            layout: Layout,\n-                            new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n-        (&*self).grow_in_place(ptr, layout, new_layout)\n+    unsafe fn realloc(&mut self,\n+                      ptr: NonNull<Opaque>,\n+                      layout: Layout,\n+                      new_size: usize) -> Result<NonNull<Opaque>, AllocErr> {\n+        NonNull::new(GlobalAlloc::realloc(*self, ptr.as_ptr(), layout, new_size)).ok_or(AllocErr)\n     }\n \n     #[inline]\n-    unsafe fn shrink_in_place(&mut self,\n-                              ptr: *mut u8,\n-                              layout: Layout,\n-                              new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n-        (&*self).shrink_in_place(ptr, layout, new_layout)\n+    fn oom(&mut self) -> ! {\n+        ::oom()\n+    }\n+}\n+\n+#[cfg(any(windows, unix, target_os = \"cloudabi\", target_os = \"redox\"))]\n+mod realloc_fallback {\n+    use core::alloc::{GlobalAlloc, Opaque, Layout};\n+    use core::cmp;\n+    use core::ptr;\n+\n+    impl super::System {\n+        pub(crate) unsafe fn realloc_fallback(&self, ptr: *mut Opaque, old_layout: Layout,\n+                                              new_size: usize) -> *mut Opaque {\n+            // Docs for GlobalAlloc::realloc require this to be valid:\n+            let new_layout = Layout::from_size_align_unchecked(new_size, old_layout.align());\n+\n+            let new_ptr = GlobalAlloc::alloc(self, new_layout);\n+            if !new_ptr.is_null() {\n+                let size = cmp::min(old_layout.size(), new_size);\n+                ptr::copy_nonoverlapping(ptr as *mut u8, new_ptr as *mut u8, size);\n+                GlobalAlloc::dealloc(self, ptr, old_layout);\n+            }\n+            new_ptr\n+        }\n     }\n }\n \n #[cfg(any(unix, target_os = \"cloudabi\", target_os = \"redox\"))]\n mod platform {\n     extern crate libc;\n \n-    use core::cmp;\n     use core::ptr;\n \n     use MIN_ALIGN;\n     use System;\n-    use core::heap::{Alloc, AllocErr, Layout};\n+    use core::alloc::{GlobalAlloc, Layout, Opaque};\n \n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-    unsafe impl<'a> Alloc for &'a System {\n+    unsafe impl GlobalAlloc for System {\n         #[inline]\n-        unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n-            let ptr = if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n-                libc::malloc(layout.size()) as *mut u8\n+        unsafe fn alloc(&self, layout: Layout) -> *mut Opaque {\n+            if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n+                libc::malloc(layout.size()) as *mut Opaque\n             } else {\n                 #[cfg(target_os = \"macos\")]\n                 {\n                     if layout.align() > (1 << 31) {\n-                        return Err(AllocErr::Unsupported {\n-                            details: \"requested alignment too large\"\n-                        })\n+                        // FIXME: use Opaque::null_mut\n+                        // https://github.com/rust-lang/rust/issues/49659\n+                        return 0 as *mut Opaque\n                     }\n                 }\n                 aligned_malloc(&layout)\n-            };\n-            if !ptr.is_null() {\n-                Ok(ptr)\n-            } else {\n-                Err(AllocErr::Exhausted { request: layout })\n             }\n         }\n \n         #[inline]\n-        unsafe fn alloc_zeroed(&mut self, layout: Layout)\n-            -> Result<*mut u8, AllocErr>\n-        {\n+        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut Opaque {\n             if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n-                let ptr = libc::calloc(layout.size(), 1) as *mut u8;\n-                if !ptr.is_null() {\n-                    Ok(ptr)\n-                } else {\n-                    Err(AllocErr::Exhausted { request: layout })\n-                }\n+                libc::calloc(layout.size(), 1) as *mut Opaque\n             } else {\n-                let ret = self.alloc(layout.clone());\n-                if let Ok(ptr) = ret {\n-                    ptr::write_bytes(ptr, 0, layout.size());\n+                let ptr = self.alloc(layout.clone());\n+                if !ptr.is_null() {\n+                    ptr::write_bytes(ptr as *mut u8, 0, layout.size());\n                 }\n-                ret\n+                ptr\n             }\n         }\n \n         #[inline]\n-        unsafe fn dealloc(&mut self, ptr: *mut u8, _layout: Layout) {\n+        unsafe fn dealloc(&self, ptr: *mut Opaque, _layout: Layout) {\n             libc::free(ptr as *mut libc::c_void)\n         }\n \n         #[inline]\n-        unsafe fn realloc(&mut self,\n-                          ptr: *mut u8,\n-                          old_layout: Layout,\n-                          new_layout: Layout) -> Result<*mut u8, AllocErr> {\n-            if old_layout.align() != new_layout.align() {\n-                return Err(AllocErr::Unsupported {\n-                    details: \"cannot change alignment on `realloc`\",\n-                })\n-            }\n-\n-            if new_layout.align() <= MIN_ALIGN  && new_layout.align() <= new_layout.size(){\n-                let ptr = libc::realloc(ptr as *mut libc::c_void, new_layout.size());\n-                if !ptr.is_null() {\n-                    Ok(ptr as *mut u8)\n-                } else {\n-                    Err(AllocErr::Exhausted { request: new_layout })\n-                }\n+        unsafe fn realloc(&self, ptr: *mut Opaque, layout: Layout, new_size: usize) -> *mut Opaque {\n+            if layout.align() <= MIN_ALIGN && layout.align() <= new_size {\n+                libc::realloc(ptr as *mut libc::c_void, new_size) as *mut Opaque\n             } else {\n-                let res = self.alloc(new_layout.clone());\n-                if let Ok(new_ptr) = res {\n-                    let size = cmp::min(old_layout.size(), new_layout.size());\n-                    ptr::copy_nonoverlapping(ptr, new_ptr, size);\n-                    self.dealloc(ptr, old_layout);\n-                }\n-                res\n-            }\n-        }\n-\n-        fn oom(&mut self, err: AllocErr) -> ! {\n-            use core::fmt::{self, Write};\n-\n-            // Print a message to stderr before aborting to assist with\n-            // debugging. It is critical that this code does not allocate any\n-            // memory since we are in an OOM situation. Any errors are ignored\n-            // while printing since there's nothing we can do about them and we\n-            // are about to exit anyways.\n-            drop(writeln!(Stderr, \"fatal runtime error: {}\", err));\n-            unsafe {\n-                ::core::intrinsics::abort();\n-            }\n-\n-            struct Stderr;\n-\n-            impl Write for Stderr {\n-                #[cfg(target_os = \"cloudabi\")]\n-                fn write_str(&mut self, _: &str) -> fmt::Result {\n-                    // CloudABI does not have any reserved file descriptor\n-                    // numbers. We should not attempt to write to file\n-                    // descriptor #2, as it may be associated with any kind of\n-                    // resource.\n-                    Ok(())\n-                }\n-\n-                #[cfg(not(target_os = \"cloudabi\"))]\n-                fn write_str(&mut self, s: &str) -> fmt::Result {\n-                    unsafe {\n-                        libc::write(libc::STDERR_FILENO,\n-                                    s.as_ptr() as *const libc::c_void,\n-                                    s.len());\n-                    }\n-                    Ok(())\n-                }\n+                self.realloc_fallback(ptr, layout, new_size)\n             }\n         }\n     }\n \n     #[cfg(any(target_os = \"android\", target_os = \"redox\", target_os = \"solaris\"))]\n     #[inline]\n-    unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n+    unsafe fn aligned_malloc(layout: &Layout) -> *mut Opaque {\n         // On android we currently target API level 9 which unfortunately\n         // doesn't have the `posix_memalign` API used below. Instead we use\n         // `memalign`, but this unfortunately has the property on some systems\n@@ -259,62 +210,48 @@ mod platform {\n         // [3]: https://bugs.chromium.org/p/chromium/issues/detail?id=138579\n         // [4]: https://chromium.googlesource.com/chromium/src/base/+/master/\n         //                                       /memory/aligned_memory.cc\n-        libc::memalign(layout.align(), layout.size()) as *mut u8\n+        libc::memalign(layout.align(), layout.size()) as *mut Opaque\n     }\n \n     #[cfg(not(any(target_os = \"android\", target_os = \"redox\", target_os = \"solaris\")))]\n     #[inline]\n-    unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n+    unsafe fn aligned_malloc(layout: &Layout) -> *mut Opaque {\n         let mut out = ptr::null_mut();\n         let ret = libc::posix_memalign(&mut out, layout.align(), layout.size());\n         if ret != 0 {\n-            ptr::null_mut()\n+            // FIXME: use Opaque::null_mut https://github.com/rust-lang/rust/issues/49659\n+            0 as *mut Opaque\n         } else {\n-            out as *mut u8\n+            out as *mut Opaque\n         }\n     }\n }\n \n #[cfg(windows)]\n #[allow(bad_style)]\n mod platform {\n-    use core::cmp;\n-    use core::ptr;\n-\n     use MIN_ALIGN;\n     use System;\n-    use core::heap::{Alloc, AllocErr, Layout, CannotReallocInPlace};\n+    use core::alloc::{GlobalAlloc, Opaque, Layout};\n \n     type LPVOID = *mut u8;\n     type HANDLE = LPVOID;\n     type SIZE_T = usize;\n     type DWORD = u32;\n     type BOOL = i32;\n-    type LPDWORD = *mut DWORD;\n-    type LPOVERLAPPED = *mut u8;\n-\n-    const STD_ERROR_HANDLE: DWORD = -12i32 as DWORD;\n \n     extern \"system\" {\n         fn GetProcessHeap() -> HANDLE;\n         fn HeapAlloc(hHeap: HANDLE, dwFlags: DWORD, dwBytes: SIZE_T) -> LPVOID;\n         fn HeapReAlloc(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID, dwBytes: SIZE_T) -> LPVOID;\n         fn HeapFree(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID) -> BOOL;\n         fn GetLastError() -> DWORD;\n-        fn WriteFile(hFile: HANDLE,\n-                     lpBuffer: LPVOID,\n-                     nNumberOfBytesToWrite: DWORD,\n-                     lpNumberOfBytesWritten: LPDWORD,\n-                     lpOverlapped: LPOVERLAPPED)\n-                     -> BOOL;\n-        fn GetStdHandle(which: DWORD) -> HANDLE;\n     }\n \n     #[repr(C)]\n     struct Header(*mut u8);\n \n     const HEAP_ZERO_MEMORY: DWORD = 0x00000008;\n-    const HEAP_REALLOC_IN_PLACE_ONLY: DWORD = 0x00000010;\n \n     unsafe fn get_header<'a>(ptr: *mut u8) -> &'a mut Header {\n         &mut *(ptr as *mut Header).offset(-1)\n@@ -327,9 +264,7 @@ mod platform {\n     }\n \n     #[inline]\n-    unsafe fn allocate_with_flags(layout: Layout, flags: DWORD)\n-        -> Result<*mut u8, AllocErr>\n-    {\n+    unsafe fn allocate_with_flags(layout: Layout, flags: DWORD) -> *mut Opaque {\n         let ptr = if layout.align() <= MIN_ALIGN {\n             HeapAlloc(GetProcessHeap(), flags, layout.size())\n         } else {\n@@ -341,134 +276,41 @@ mod platform {\n                 align_ptr(ptr, layout.align())\n             }\n         };\n-        if ptr.is_null() {\n-            Err(AllocErr::Exhausted { request: layout })\n-        } else {\n-            Ok(ptr as *mut u8)\n-        }\n+        ptr as *mut Opaque\n     }\n \n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-    unsafe impl<'a> Alloc for &'a System {\n+    unsafe impl GlobalAlloc for System {\n         #[inline]\n-        unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n+        unsafe fn alloc(&self, layout: Layout) -> *mut Opaque {\n             allocate_with_flags(layout, 0)\n         }\n \n         #[inline]\n-        unsafe fn alloc_zeroed(&mut self, layout: Layout)\n-            -> Result<*mut u8, AllocErr>\n-        {\n+        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut Opaque {\n             allocate_with_flags(layout, HEAP_ZERO_MEMORY)\n         }\n \n         #[inline]\n-        unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout) {\n+        unsafe fn dealloc(&self, ptr: *mut Opaque, layout: Layout) {\n             if layout.align() <= MIN_ALIGN {\n                 let err = HeapFree(GetProcessHeap(), 0, ptr as LPVOID);\n                 debug_assert!(err != 0, \"Failed to free heap memory: {}\",\n                               GetLastError());\n             } else {\n-                let header = get_header(ptr);\n+                let header = get_header(ptr as *mut u8);\n                 let err = HeapFree(GetProcessHeap(), 0, header.0 as LPVOID);\n                 debug_assert!(err != 0, \"Failed to free heap memory: {}\",\n                               GetLastError());\n             }\n         }\n \n         #[inline]\n-        unsafe fn realloc(&mut self,\n-                          ptr: *mut u8,\n-                          old_layout: Layout,\n-                          new_layout: Layout) -> Result<*mut u8, AllocErr> {\n-            if old_layout.align() != new_layout.align() {\n-                return Err(AllocErr::Unsupported {\n-                    details: \"cannot change alignment on `realloc`\",\n-                })\n-            }\n-\n-            if new_layout.align() <= MIN_ALIGN {\n-                let ptr = HeapReAlloc(GetProcessHeap(),\n-                                      0,\n-                                      ptr as LPVOID,\n-                                      new_layout.size());\n-                if !ptr.is_null() {\n-                    Ok(ptr as *mut u8)\n-                } else {\n-                    Err(AllocErr::Exhausted { request: new_layout })\n-                }\n-            } else {\n-                let res = self.alloc(new_layout.clone());\n-                if let Ok(new_ptr) = res {\n-                    let size = cmp::min(old_layout.size(), new_layout.size());\n-                    ptr::copy_nonoverlapping(ptr, new_ptr, size);\n-                    self.dealloc(ptr, old_layout);\n-                }\n-                res\n-            }\n-        }\n-\n-        #[inline]\n-        unsafe fn grow_in_place(&mut self,\n-                                ptr: *mut u8,\n-                                layout: Layout,\n-                                new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n-            self.shrink_in_place(ptr, layout, new_layout)\n-        }\n-\n-        #[inline]\n-        unsafe fn shrink_in_place(&mut self,\n-                                  ptr: *mut u8,\n-                                  old_layout: Layout,\n-                                  new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n-            if old_layout.align() != new_layout.align() {\n-                return Err(CannotReallocInPlace)\n-            }\n-\n-            let new = if new_layout.align() <= MIN_ALIGN {\n-                HeapReAlloc(GetProcessHeap(),\n-                            HEAP_REALLOC_IN_PLACE_ONLY,\n-                            ptr as LPVOID,\n-                            new_layout.size())\n-            } else {\n-                let header = get_header(ptr);\n-                HeapReAlloc(GetProcessHeap(),\n-                            HEAP_REALLOC_IN_PLACE_ONLY,\n-                            header.0 as LPVOID,\n-                            new_layout.size() + new_layout.align())\n-            };\n-            if new.is_null() {\n-                Err(CannotReallocInPlace)\n+        unsafe fn realloc(&self, ptr: *mut Opaque, layout: Layout, new_size: usize) -> *mut Opaque {\n+            if layout.align() <= MIN_ALIGN {\n+                HeapReAlloc(GetProcessHeap(), 0, ptr as LPVOID, new_size) as *mut Opaque\n             } else {\n-                Ok(())\n-            }\n-        }\n-\n-        fn oom(&mut self, err: AllocErr) -> ! {\n-            use core::fmt::{self, Write};\n-\n-            // Same as with unix we ignore all errors here\n-            drop(writeln!(Stderr, \"fatal runtime error: {}\", err));\n-            unsafe {\n-                ::core::intrinsics::abort();\n-            }\n-\n-            struct Stderr;\n-\n-            impl Write for Stderr {\n-                fn write_str(&mut self, s: &str) -> fmt::Result {\n-                    unsafe {\n-                        // WriteFile silently fails if it is passed an invalid\n-                        // handle, so there is no need to check the result of\n-                        // GetStdHandle.\n-                        WriteFile(GetStdHandle(STD_ERROR_HANDLE),\n-                                  s.as_ptr() as LPVOID,\n-                                  s.len() as DWORD,\n-                                  ptr::null_mut(),\n-                                  ptr::null_mut());\n-                    }\n-                    Ok(())\n-                }\n+                self.realloc_fallback(ptr, layout, new_size)\n             }\n         }\n     }\n@@ -495,69 +337,92 @@ mod platform {\n mod platform {\n     extern crate dlmalloc;\n \n-    use core::heap::{Alloc, AllocErr, Layout, Excess, CannotReallocInPlace};\n+    use core::alloc::{GlobalAlloc, Layout, Opaque};\n     use System;\n-    use self::dlmalloc::GlobalDlmalloc;\n+\n+    // No need for synchronization here as wasm is currently single-threaded\n+    static mut DLMALLOC: dlmalloc::Dlmalloc = dlmalloc::DLMALLOC_INIT;\n \n     #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-    unsafe impl<'a> Alloc for &'a System {\n+    unsafe impl GlobalAlloc for System {\n         #[inline]\n-        unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n-            GlobalDlmalloc.alloc(layout)\n+        unsafe fn alloc(&self, layout: Layout) -> *mut Opaque {\n+            DLMALLOC.malloc(layout.size(), layout.align()) as *mut Opaque\n         }\n \n         #[inline]\n-        unsafe fn alloc_zeroed(&mut self, layout: Layout)\n-            -> Result<*mut u8, AllocErr>\n-        {\n-            GlobalDlmalloc.alloc_zeroed(layout)\n+        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut Opaque {\n+            DLMALLOC.calloc(layout.size(), layout.align()) as *mut Opaque\n         }\n \n         #[inline]\n-        unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout) {\n-            GlobalDlmalloc.dealloc(ptr, layout)\n+        unsafe fn dealloc(&self, ptr: *mut Opaque, layout: Layout) {\n+            DLMALLOC.free(ptr as *mut u8, layout.size(), layout.align())\n         }\n \n         #[inline]\n-        unsafe fn realloc(&mut self,\n-                          ptr: *mut u8,\n-                          old_layout: Layout,\n-                          new_layout: Layout) -> Result<*mut u8, AllocErr> {\n-            GlobalDlmalloc.realloc(ptr, old_layout, new_layout)\n+        unsafe fn realloc(&self, ptr: *mut Opaque, layout: Layout, new_size: usize) -> *mut Opaque {\n+            DLMALLOC.realloc(ptr as *mut u8, layout.size(), layout.align(), new_size) as *mut Opaque\n         }\n+    }\n+}\n \n-        #[inline]\n-        fn usable_size(&self, layout: &Layout) -> (usize, usize) {\n-            GlobalDlmalloc.usable_size(layout)\n-        }\n+#[inline]\n+fn oom() -> ! {\n+    write_to_stderr(\"fatal runtime error: memory allocation failed\");\n+    unsafe {\n+        ::core::intrinsics::abort();\n+    }\n+}\n \n-        #[inline]\n-        unsafe fn alloc_excess(&mut self, layout: Layout) -> Result<Excess, AllocErr> {\n-            GlobalDlmalloc.alloc_excess(layout)\n-        }\n+#[cfg(any(unix, target_os = \"redox\"))]\n+#[inline]\n+fn write_to_stderr(s: &str) {\n+    extern crate libc;\n \n-        #[inline]\n-        unsafe fn realloc_excess(&mut self,\n-                                 ptr: *mut u8,\n-                                 layout: Layout,\n-                                 new_layout: Layout) -> Result<Excess, AllocErr> {\n-            GlobalDlmalloc.realloc_excess(ptr, layout, new_layout)\n-        }\n+    unsafe {\n+        libc::write(libc::STDERR_FILENO,\n+                    s.as_ptr() as *const libc::c_void,\n+                    s.len());\n+    }\n+}\n \n-        #[inline]\n-        unsafe fn grow_in_place(&mut self,\n-                                ptr: *mut u8,\n-                                layout: Layout,\n-                                new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n-            GlobalDlmalloc.grow_in_place(ptr, layout, new_layout)\n-        }\n+#[cfg(windows)]\n+#[inline]\n+fn write_to_stderr(s: &str) {\n+    use core::ptr;\n \n-        #[inline]\n-        unsafe fn shrink_in_place(&mut self,\n-                                  ptr: *mut u8,\n-                                  layout: Layout,\n-                                  new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n-            GlobalDlmalloc.shrink_in_place(ptr, layout, new_layout)\n-        }\n+    type LPVOID = *mut u8;\n+    type HANDLE = LPVOID;\n+    type DWORD = u32;\n+    type BOOL = i32;\n+    type LPDWORD = *mut DWORD;\n+    type LPOVERLAPPED = *mut u8;\n+\n+    const STD_ERROR_HANDLE: DWORD = -12i32 as DWORD;\n+\n+    extern \"system\" {\n+        fn WriteFile(hFile: HANDLE,\n+                     lpBuffer: LPVOID,\n+                     nNumberOfBytesToWrite: DWORD,\n+                     lpNumberOfBytesWritten: LPDWORD,\n+                     lpOverlapped: LPOVERLAPPED)\n+                     -> BOOL;\n+        fn GetStdHandle(which: DWORD) -> HANDLE;\n+    }\n+\n+    unsafe {\n+        // WriteFile silently fails if it is passed an invalid\n+        // handle, so there is no need to check the result of\n+        // GetStdHandle.\n+        WriteFile(GetStdHandle(STD_ERROR_HANDLE),\n+                  s.as_ptr() as LPVOID,\n+                  s.len() as DWORD,\n+                  ptr::null_mut(),\n+                  ptr::null_mut());\n     }\n }\n+\n+#[cfg(not(any(windows, unix, target_os = \"redox\")))]\n+#[inline]\n+fn write_to_stderr(_: &str) {}"}, {"sha": "8f8849e32e6cb6ef279bbcf66efc7687fa70722e", "filename": "src/libcore/alloc.rs", "status": "renamed", "additions": 198, "deletions": 148, "changes": 346, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -21,10 +21,30 @@ use mem;\n use usize;\n use ptr::{self, NonNull};\n \n+extern {\n+    /// An opaque, unsized type. Used for pointers to allocated memory.\n+    ///\n+    /// This type can only be used behind a pointer like `*mut Opaque` or `ptr::NonNull<Opaque>`.\n+    /// Such pointers are similar to C\u2019s `void*` type.\n+    pub type Opaque;\n+}\n+\n+impl Opaque {\n+    /// Similar to `std::ptr::null`, which requires `T: Sized`.\n+    pub fn null() -> *const Self {\n+        0 as _\n+    }\n+\n+    /// Similar to `std::ptr::null_mut`, which requires `T: Sized`.\n+    pub fn null_mut() -> *mut Self {\n+        0 as _\n+    }\n+}\n+\n /// Represents the combination of a starting address and\n /// a total capacity of the returned block.\n #[derive(Debug)]\n-pub struct Excess(pub *mut u8, pub usize);\n+pub struct Excess(pub NonNull<Opaque>, pub usize);\n \n fn size_align<T>() -> (usize, usize) {\n     (mem::size_of::<T>(), mem::align_of::<T>())\n@@ -74,9 +94,9 @@ impl Layout {\n     ///    must not overflow (i.e. the rounded value must be less than\n     ///    `usize::MAX`).\n     #[inline]\n-    pub fn from_size_align(size: usize, align: usize) -> Option<Layout> {\n+    pub fn from_size_align(size: usize, align: usize) -> Result<Self, LayoutErr> {\n         if !align.is_power_of_two() {\n-            return None;\n+            return Err(LayoutErr { private: () });\n         }\n \n         // (power-of-two implies align != 0.)\n@@ -94,11 +114,11 @@ impl Layout {\n         // Above implies that checking for summation overflow is both\n         // necessary and sufficient.\n         if size > usize::MAX - (align - 1) {\n-            return None;\n+            return Err(LayoutErr { private: () });\n         }\n \n         unsafe {\n-            Some(Layout::from_size_align_unchecked(size, align))\n+            Ok(Layout::from_size_align_unchecked(size, align))\n         }\n     }\n \n@@ -110,7 +130,7 @@ impl Layout {\n     /// a power-of-two nor `size` aligned to `align` fits within the\n     /// address space (i.e. the `Layout::from_size_align` preconditions).\n     #[inline]\n-    pub unsafe fn from_size_align_unchecked(size: usize, align: usize) -> Layout {\n+    pub unsafe fn from_size_align_unchecked(size: usize, align: usize) -> Self {\n         Layout { size: size, align: align }\n     }\n \n@@ -209,15 +229,17 @@ impl Layout {\n     ///\n     /// On arithmetic overflow, returns `None`.\n     #[inline]\n-    pub fn repeat(&self, n: usize) -> Option<(Self, usize)> {\n-        let padded_size = self.size.checked_add(self.padding_needed_for(self.align))?;\n-        let alloc_size = padded_size.checked_mul(n)?;\n+    pub fn repeat(&self, n: usize) -> Result<(Self, usize), LayoutErr> {\n+        let padded_size = self.size.checked_add(self.padding_needed_for(self.align))\n+            .ok_or(LayoutErr { private: () })?;\n+        let alloc_size = padded_size.checked_mul(n)\n+            .ok_or(LayoutErr { private: () })?;\n \n         // We can assume that `self.align` is a power-of-two.\n         // Furthermore, `alloc_size` has already been rounded up\n         // to a multiple of `self.align`; therefore, the call to\n         // `Layout::from_size_align` below should never panic.\n-        Some((Layout::from_size_align(alloc_size, self.align).unwrap(), padded_size))\n+        Ok((Layout::from_size_align(alloc_size, self.align).unwrap(), padded_size))\n     }\n \n     /// Creates a layout describing the record for `self` followed by\n@@ -231,17 +253,19 @@ impl Layout {\n     /// (assuming that the record itself starts at offset 0).\n     ///\n     /// On arithmetic overflow, returns `None`.\n-    pub fn extend(&self, next: Self) -> Option<(Self, usize)> {\n+    pub fn extend(&self, next: Self) -> Result<(Self, usize), LayoutErr> {\n         let new_align = cmp::max(self.align, next.align);\n         let realigned = Layout::from_size_align(self.size, new_align)?;\n \n         let pad = realigned.padding_needed_for(next.align);\n \n-        let offset = self.size.checked_add(pad)?;\n-        let new_size = offset.checked_add(next.size)?;\n+        let offset = self.size.checked_add(pad)\n+            .ok_or(LayoutErr { private: () })?;\n+        let new_size = offset.checked_add(next.size)\n+            .ok_or(LayoutErr { private: () })?;\n \n         let layout = Layout::from_size_align(new_size, new_align)?;\n-        Some((layout, offset))\n+        Ok((layout, offset))\n     }\n \n     /// Creates a layout describing the record for `n` instances of\n@@ -256,8 +280,8 @@ impl Layout {\n     /// aligned.\n     ///\n     /// On arithmetic overflow, returns `None`.\n-    pub fn repeat_packed(&self, n: usize) -> Option<Self> {\n-        let size = self.size().checked_mul(n)?;\n+    pub fn repeat_packed(&self, n: usize) -> Result<Self, LayoutErr> {\n+        let size = self.size().checked_mul(n).ok_or(LayoutErr { private: () })?;\n         Layout::from_size_align(size, self.align)\n     }\n \n@@ -276,16 +300,17 @@ impl Layout {\n     ///  `extend`.)\n     ///\n     /// On arithmetic overflow, returns `None`.\n-    pub fn extend_packed(&self, next: Self) -> Option<(Self, usize)> {\n-        let new_size = self.size().checked_add(next.size())?;\n+    pub fn extend_packed(&self, next: Self) -> Result<(Self, usize), LayoutErr> {\n+        let new_size = self.size().checked_add(next.size())\n+            .ok_or(LayoutErr { private: () })?;\n         let layout = Layout::from_size_align(new_size, self.align)?;\n-        Some((layout, self.size()))\n+        Ok((layout, self.size()))\n     }\n \n     /// Creates a layout describing the record for a `[T; n]`.\n     ///\n     /// On arithmetic overflow, returns `None`.\n-    pub fn array<T>(n: usize) -> Option<Self> {\n+    pub fn array<T>(n: usize) -> Result<Self, LayoutErr> {\n         Layout::new::<T>()\n             .repeat(n)\n             .map(|(k, offs)| {\n@@ -295,55 +320,31 @@ impl Layout {\n     }\n }\n \n-/// The `AllocErr` error specifies whether an allocation failure is\n-/// specifically due to resource exhaustion or if it is due to\n-/// something wrong when combining the given input arguments with this\n-/// allocator.\n+/// The parameters given to `Layout::from_size_align` do not satisfy\n+/// its documented constraints.\n #[derive(Clone, PartialEq, Eq, Debug)]\n-pub enum AllocErr {\n-    /// Error due to hitting some resource limit or otherwise running\n-    /// out of memory. This condition strongly implies that *some*\n-    /// series of deallocations would allow a subsequent reissuing of\n-    /// the original allocation request to succeed.\n-    Exhausted { request: Layout },\n-\n-    /// Error due to allocator being fundamentally incapable of\n-    /// satisfying the original request. This condition implies that\n-    /// such an allocation request will never succeed on the given\n-    /// allocator, regardless of environment, memory pressure, or\n-    /// other contextual conditions.\n-    ///\n-    /// For example, an allocator that does not support requests for\n-    /// large memory blocks might return this error variant.\n-    Unsupported { details: &'static str },\n+pub struct LayoutErr {\n+    private: ()\n }\n \n-impl AllocErr {\n-    #[inline]\n-    pub fn invalid_input(details: &'static str) -> Self {\n-        AllocErr::Unsupported { details: details }\n-    }\n-    #[inline]\n-    pub fn is_memory_exhausted(&self) -> bool {\n-        if let AllocErr::Exhausted { .. } = *self { true } else { false }\n-    }\n-    #[inline]\n-    pub fn is_request_unsupported(&self) -> bool {\n-        if let AllocErr::Unsupported { .. } = *self { true } else { false }\n-    }\n-    #[inline]\n-    pub fn description(&self) -> &str {\n-        match *self {\n-            AllocErr::Exhausted { .. } => \"allocator memory exhausted\",\n-            AllocErr::Unsupported { .. } => \"unsupported allocator request\",\n-        }\n+// (we need this for downstream impl of trait Error)\n+impl fmt::Display for LayoutErr {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.write_str(\"invalid parameters to Layout::from_size_align\")\n     }\n }\n \n+/// The `AllocErr` error specifies whether an allocation failure is\n+/// specifically due to resource exhaustion or if it is due to\n+/// something wrong when combining the given input arguments with this\n+/// allocator.\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct AllocErr;\n+\n // (we need this for downstream impl of trait Error)\n impl fmt::Display for AllocErr {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", self.description())\n+        f.write_str(\"memory allocation failed\")\n     }\n }\n \n@@ -374,13 +375,85 @@ pub enum CollectionAllocErr {\n     /// (usually `isize::MAX` bytes).\n     CapacityOverflow,\n     /// Error due to the allocator (see the `AllocErr` type's docs).\n-    AllocErr(AllocErr),\n+    AllocErr,\n }\n \n #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n impl From<AllocErr> for CollectionAllocErr {\n-    fn from(err: AllocErr) -> Self {\n-        CollectionAllocErr::AllocErr(err)\n+    fn from(AllocErr: AllocErr) -> Self {\n+        CollectionAllocErr::AllocErr\n+    }\n+}\n+\n+/// A memory allocator that can be registered to be the one backing `std::alloc::Global`\n+/// though the `#[global_allocator]` attributes.\n+pub unsafe trait GlobalAlloc {\n+    /// Allocate memory as described by the given `layout`.\n+    ///\n+    /// Returns a pointer to newly-allocated memory,\n+    /// or NULL to indicate allocation failure.\n+    ///\n+    /// # Safety\n+    ///\n+    /// **FIXME:** what are the exact requirements?\n+    unsafe fn alloc(&self, layout: Layout) -> *mut Opaque;\n+\n+    /// Deallocate the block of memory at the given `ptr` pointer with the given `layout`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// **FIXME:** what are the exact requirements?\n+    /// In particular around layout *fit*. (See docs for the `Alloc` trait.)\n+    unsafe fn dealloc(&self, ptr: *mut Opaque, layout: Layout);\n+\n+    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut Opaque {\n+        let size = layout.size();\n+        let ptr = self.alloc(layout);\n+        if !ptr.is_null() {\n+            ptr::write_bytes(ptr as *mut u8, 0, size);\n+        }\n+        ptr\n+    }\n+\n+    /// Shink or grow a block of memory to the given `new_size`.\n+    /// The block is described by the given `ptr` pointer and `layout`.\n+    ///\n+    /// Return a new pointer (which may or may not be the same as `ptr`),\n+    /// or NULL to indicate reallocation failure.\n+    ///\n+    /// If reallocation is successful, the old `ptr` pointer is considered\n+    /// to have been deallocated.\n+    ///\n+    /// # Safety\n+    ///\n+    /// `new_size`, when rounded up to the nearest multiple of `old_layout.align()`,\n+    /// must not overflow (i.e. the rounded value must be less than `usize::MAX`).\n+    ///\n+    /// **FIXME:** what are the exact requirements?\n+    /// In particular around layout *fit*. (See docs for the `Alloc` trait.)\n+    unsafe fn realloc(&self, ptr: *mut Opaque, layout: Layout, new_size: usize) -> *mut Opaque {\n+        let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n+        let new_ptr = self.alloc(new_layout);\n+        if !new_ptr.is_null() {\n+            ptr::copy_nonoverlapping(\n+                ptr as *const u8,\n+                new_ptr as *mut u8,\n+                cmp::min(layout.size(), new_size),\n+            );\n+            self.dealloc(ptr, layout);\n+        }\n+        new_ptr\n+    }\n+\n+    /// Aborts the thread or process, optionally performing\n+    /// cleanup or logging diagnostic information before panicking or\n+    /// aborting.\n+    ///\n+    /// `oom` is meant to be used by clients unable to cope with an\n+    /// unsatisfied allocation request, and wish to abandon\n+    /// computation rather than attempt to recover locally.\n+    fn oom(&self) -> ! {\n+        unsafe { ::intrinsics::abort() }\n     }\n }\n \n@@ -515,7 +588,7 @@ pub unsafe trait Alloc {\n     /// Clients wishing to abort computation in response to an\n     /// allocation error are encouraged to call the allocator's `oom`\n     /// method, rather than directly invoking `panic!` or similar.\n-    unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr>;\n+    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<Opaque>, AllocErr>;\n \n     /// Deallocate the memory referenced by `ptr`.\n     ///\n@@ -532,7 +605,7 @@ pub unsafe trait Alloc {\n     /// * In addition to fitting the block of memory `layout`, the\n     ///   alignment of the `layout` must match the alignment used\n     ///   to allocate that block of memory.\n-    unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout);\n+    unsafe fn dealloc(&mut self, ptr: NonNull<Opaque>, layout: Layout);\n \n     /// Allocator-specific method for signaling an out-of-memory\n     /// condition.\n@@ -542,12 +615,8 @@ pub unsafe trait Alloc {\n     /// aborting.\n     ///\n     /// `oom` is meant to be used by clients unable to cope with an\n-    /// unsatisfied allocation request (signaled by an error such as\n-    /// `AllocErr::Exhausted`), and wish to abandon computation rather\n-    /// than attempt to recover locally. Such clients should pass the\n-    /// signaling error value back into `oom`, where the allocator\n-    /// may incorporate that error value into its diagnostic report\n-    /// before aborting.\n+    /// unsatisfied allocation request, and wish to abandon\n+    /// computation rather than attempt to recover locally.\n     ///\n     /// Implementations of the `oom` method are discouraged from\n     /// infinitely regressing in nested calls to `oom`. In\n@@ -560,7 +629,7 @@ pub unsafe trait Alloc {\n     /// instead they should return an appropriate error from the\n     /// invoked method, and let the client decide whether to invoke\n     /// this `oom` method in response.\n-    fn oom(&mut self, _: AllocErr) -> ! {\n+    fn oom(&mut self) -> ! {\n         unsafe { ::intrinsics::abort() }\n     }\n \n@@ -602,9 +671,10 @@ pub unsafe trait Alloc {\n     // realloc. alloc_excess, realloc_excess\n \n     /// Returns a pointer suitable for holding data described by\n-    /// `new_layout`, meeting its size and alignment guarantees. To\n+    /// a new layout with `layout`\u2019s alginment and a size given\n+    /// by `new_size`. To\n     /// accomplish this, this may extend or shrink the allocation\n-    /// referenced by `ptr` to fit `new_layout`.\n+    /// referenced by `ptr` to fit the new layout.\n     ///\n     /// If this returns `Ok`, then ownership of the memory block\n     /// referenced by `ptr` has been transferred to this\n@@ -617,44 +687,32 @@ pub unsafe trait Alloc {\n     /// block has not been transferred to this allocator, and the\n     /// contents of the memory block are unaltered.\n     ///\n-    /// For best results, `new_layout` should not impose a different\n-    /// alignment constraint than `layout`. (In other words,\n-    /// `new_layout.align()` should equal `layout.align()`.) However,\n-    /// behavior is well-defined (though underspecified) when this\n-    /// constraint is violated; further discussion below.\n-    ///\n     /// # Safety\n     ///\n     /// This function is unsafe because undefined behavior can result\n     /// if the caller does not ensure all of the following:\n     ///\n     /// * `ptr` must be currently allocated via this allocator,\n     ///\n-    /// * `layout` must *fit* the `ptr` (see above). (The `new_layout`\n+    /// * `layout` must *fit* the `ptr` (see above). (The `new_size`\n     ///   argument need not fit it.)\n     ///\n-    /// * `new_layout` must have size greater than zero.\n+    /// * `new_size` must be greater than zero.\n     ///\n-    /// * the alignment of `new_layout` is non-zero.\n+    /// * `new_size`, when rounded up to the nearest multiple of `layout.align()`,\n+    ///   must not overflow (i.e. the rounded value must be less than `usize::MAX`).\n     ///\n     /// (Extension subtraits might provide more specific bounds on\n     /// behavior, e.g. guarantee a sentinel address or a null pointer\n     /// in response to a zero-size allocation request.)\n     ///\n     /// # Errors\n     ///\n-    /// Returns `Err` only if `new_layout` does not match the\n-    /// alignment of `layout`, or does not meet the allocator's size\n+    /// Returns `Err` only if the new layout\n+    /// does not meet the allocator's size\n     /// and alignment constraints of the allocator, or if reallocation\n     /// otherwise fails.\n     ///\n-    /// (Note the previous sentence did not say \"if and only if\" -- in\n-    /// particular, an implementation of this method *can* return `Ok`\n-    /// if `new_layout.align() != old_layout.align()`; or it can\n-    /// return `Err` in that scenario, depending on whether this\n-    /// allocator can dynamically adjust the alignment constraint for\n-    /// the block.)\n-    ///\n     /// Implementations are encouraged to return `Err` on memory\n     /// exhaustion rather than panicking or aborting, but this is not\n     /// a strict requirement. (Specifically: it is *legal* to\n@@ -665,27 +723,28 @@ pub unsafe trait Alloc {\n     /// reallocation error are encouraged to call the allocator's `oom`\n     /// method, rather than directly invoking `panic!` or similar.\n     unsafe fn realloc(&mut self,\n-                      ptr: *mut u8,\n+                      ptr: NonNull<Opaque>,\n                       layout: Layout,\n-                      new_layout: Layout) -> Result<*mut u8, AllocErr> {\n-        let new_size = new_layout.size();\n+                      new_size: usize) -> Result<NonNull<Opaque>, AllocErr> {\n         let old_size = layout.size();\n-        let aligns_match = layout.align == new_layout.align;\n \n-        if new_size >= old_size && aligns_match {\n-            if let Ok(()) = self.grow_in_place(ptr, layout.clone(), new_layout.clone()) {\n+        if new_size >= old_size {\n+            if let Ok(()) = self.grow_in_place(ptr, layout.clone(), new_size) {\n                 return Ok(ptr);\n             }\n-        } else if new_size < old_size && aligns_match {\n-            if let Ok(()) = self.shrink_in_place(ptr, layout.clone(), new_layout.clone()) {\n+        } else if new_size < old_size {\n+            if let Ok(()) = self.shrink_in_place(ptr, layout.clone(), new_size) {\n                 return Ok(ptr);\n             }\n         }\n \n         // otherwise, fall back on alloc + copy + dealloc.\n+        let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n         let result = self.alloc(new_layout);\n         if let Ok(new_ptr) = result {\n-            ptr::copy_nonoverlapping(ptr as *const u8, new_ptr, cmp::min(old_size, new_size));\n+            ptr::copy_nonoverlapping(ptr.as_ptr() as *const u8,\n+                                     new_ptr.as_ptr() as *mut u8,\n+                                     cmp::min(old_size, new_size));\n             self.dealloc(ptr, layout);\n         }\n         result\n@@ -707,11 +766,11 @@ pub unsafe trait Alloc {\n     /// Clients wishing to abort computation in response to an\n     /// allocation error are encouraged to call the allocator's `oom`\n     /// method, rather than directly invoking `panic!` or similar.\n-    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n+    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<Opaque>, AllocErr> {\n         let size = layout.size();\n         let p = self.alloc(layout);\n         if let Ok(p) = p {\n-            ptr::write_bytes(p, 0, size);\n+            ptr::write_bytes(p.as_ptr() as *mut u8, 0, size);\n         }\n         p\n     }\n@@ -756,19 +815,21 @@ pub unsafe trait Alloc {\n     /// reallocation error are encouraged to call the allocator's `oom`\n     /// method, rather than directly invoking `panic!` or similar.\n     unsafe fn realloc_excess(&mut self,\n-                             ptr: *mut u8,\n+                             ptr: NonNull<Opaque>,\n                              layout: Layout,\n-                             new_layout: Layout) -> Result<Excess, AllocErr> {\n+                             new_size: usize) -> Result<Excess, AllocErr> {\n+        let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n         let usable_size = self.usable_size(&new_layout);\n-        self.realloc(ptr, layout, new_layout)\n+        self.realloc(ptr, layout, new_size)\n             .map(|p| Excess(p, usable_size.1))\n     }\n \n-    /// Attempts to extend the allocation referenced by `ptr` to fit `new_layout`.\n+    /// Attempts to extend the allocation referenced by `ptr` to fit `new_size`.\n     ///\n     /// If this returns `Ok`, then the allocator has asserted that the\n-    /// memory block referenced by `ptr` now fits `new_layout`, and thus can\n-    /// be used to carry data of that layout. (The allocator is allowed to\n+    /// memory block referenced by `ptr` now fits `new_size`, and thus can\n+    /// be used to carry data of a layout of that size and same alignment as\n+    /// `layout`. (The allocator is allowed to\n     /// expend effort to accomplish this, such as extending the memory block to\n     /// include successor blocks, or virtual memory tricks.)\n     ///\n@@ -784,11 +845,9 @@ pub unsafe trait Alloc {\n     /// * `ptr` must be currently allocated via this allocator,\n     ///\n     /// * `layout` must *fit* the `ptr` (see above); note the\n-    ///   `new_layout` argument need not fit it,\n+    ///   `new_size` argument need not fit it,\n     ///\n-    /// * `new_layout.size()` must not be less than `layout.size()`,\n-    ///\n-    /// * `new_layout.align()` must equal `layout.align()`.\n+    /// * `new_size` must not be less than `layout.size()`,\n     ///\n     /// # Errors\n     ///\n@@ -801,26 +860,25 @@ pub unsafe trait Alloc {\n     /// `grow_in_place` failures without aborting, or to fall back on\n     /// another reallocation method before resorting to an abort.\n     unsafe fn grow_in_place(&mut self,\n-                            ptr: *mut u8,\n+                            ptr: NonNull<Opaque>,\n                             layout: Layout,\n-                            new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n+                            new_size: usize) -> Result<(), CannotReallocInPlace> {\n         let _ = ptr; // this default implementation doesn't care about the actual address.\n-        debug_assert!(new_layout.size >= layout.size);\n-        debug_assert!(new_layout.align == layout.align);\n+        debug_assert!(new_size >= layout.size);\n         let (_l, u) = self.usable_size(&layout);\n         // _l <= layout.size()                       [guaranteed by usable_size()]\n         //       layout.size() <= new_layout.size()  [required by this method]\n-        if new_layout.size <= u {\n+        if new_size <= u {\n             return Ok(());\n         } else {\n             return Err(CannotReallocInPlace);\n         }\n     }\n \n-    /// Attempts to shrink the allocation referenced by `ptr` to fit `new_layout`.\n+    /// Attempts to shrink the allocation referenced by `ptr` to fit `new_size`.\n     ///\n     /// If this returns `Ok`, then the allocator has asserted that the\n-    /// memory block referenced by `ptr` now fits `new_layout`, and\n+    /// memory block referenced by `ptr` now fits `new_size`, and\n     /// thus can only be used to carry data of that smaller\n     /// layout. (The allocator is allowed to take advantage of this,\n     /// carving off portions of the block for reuse elsewhere.) The\n@@ -841,13 +899,11 @@ pub unsafe trait Alloc {\n     /// * `ptr` must be currently allocated via this allocator,\n     ///\n     /// * `layout` must *fit* the `ptr` (see above); note the\n-    ///   `new_layout` argument need not fit it,\n+    ///   `new_size` argument need not fit it,\n     ///\n-    /// * `new_layout.size()` must not be greater than `layout.size()`\n+    /// * `new_size` must not be greater than `layout.size()`\n     ///   (and must be greater than zero),\n     ///\n-    /// * `new_layout.align()` must equal `layout.align()`.\n-    ///\n     /// # Errors\n     ///\n     /// Returns `Err(CannotReallocInPlace)` when the allocator is\n@@ -859,16 +915,15 @@ pub unsafe trait Alloc {\n     /// `shrink_in_place` failures without aborting, or to fall back\n     /// on another reallocation method before resorting to an abort.\n     unsafe fn shrink_in_place(&mut self,\n-                              ptr: *mut u8,\n+                              ptr: NonNull<Opaque>,\n                               layout: Layout,\n-                              new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n+                              new_size: usize) -> Result<(), CannotReallocInPlace> {\n         let _ = ptr; // this default implementation doesn't care about the actual address.\n-        debug_assert!(new_layout.size <= layout.size);\n-        debug_assert!(new_layout.align == layout.align);\n+        debug_assert!(new_size <= layout.size);\n         let (l, _u) = self.usable_size(&layout);\n         //                      layout.size() <= _u  [guaranteed by usable_size()]\n         // new_layout.size() <= layout.size()        [required by this method]\n-        if l <= new_layout.size {\n+        if l <= new_size {\n             return Ok(());\n         } else {\n             return Err(CannotReallocInPlace);\n@@ -911,9 +966,9 @@ pub unsafe trait Alloc {\n     {\n         let k = Layout::new::<T>();\n         if k.size() > 0 {\n-            unsafe { self.alloc(k).map(|p| NonNull::new_unchecked(p as *mut T)) }\n+            unsafe { self.alloc(k).map(|p| p.cast()) }\n         } else {\n-            Err(AllocErr::invalid_input(\"zero-sized type invalid for alloc_one\"))\n+            Err(AllocErr)\n         }\n     }\n \n@@ -937,10 +992,9 @@ pub unsafe trait Alloc {\n     unsafe fn dealloc_one<T>(&mut self, ptr: NonNull<T>)\n         where Self: Sized\n     {\n-        let raw_ptr = ptr.as_ptr() as *mut u8;\n         let k = Layout::new::<T>();\n         if k.size() > 0 {\n-            self.dealloc(raw_ptr, k);\n+            self.dealloc(ptr.as_opaque(), k);\n         }\n     }\n \n@@ -978,15 +1032,12 @@ pub unsafe trait Alloc {\n         where Self: Sized\n     {\n         match Layout::array::<T>(n) {\n-            Some(ref layout) if layout.size() > 0 => {\n+            Ok(ref layout) if layout.size() > 0 => {\n                 unsafe {\n-                    self.alloc(layout.clone())\n-                        .map(|p| {\n-                            NonNull::new_unchecked(p as *mut T)\n-                        })\n+                    self.alloc(layout.clone()).map(|p| p.cast())\n                 }\n             }\n-            _ => Err(AllocErr::invalid_input(\"invalid layout for alloc_array\")),\n+            _ => Err(AllocErr),\n         }\n     }\n \n@@ -1028,13 +1079,13 @@ pub unsafe trait Alloc {\n                                n_new: usize) -> Result<NonNull<T>, AllocErr>\n         where Self: Sized\n     {\n-        match (Layout::array::<T>(n_old), Layout::array::<T>(n_new), ptr.as_ptr()) {\n-            (Some(ref k_old), Some(ref k_new), ptr) if k_old.size() > 0 && k_new.size() > 0 => {\n-                self.realloc(ptr as *mut u8, k_old.clone(), k_new.clone())\n-                    .map(|p| NonNull::new_unchecked(p as *mut T))\n+        match (Layout::array::<T>(n_old), Layout::array::<T>(n_new)) {\n+            (Ok(ref k_old), Ok(ref k_new)) if k_old.size() > 0 && k_new.size() > 0 => {\n+                debug_assert!(k_old.align() == k_new.align());\n+                self.realloc(ptr.as_opaque(), k_old.clone(), k_new.size()).map(NonNull::cast)\n             }\n             _ => {\n-                Err(AllocErr::invalid_input(\"invalid layout for realloc_array\"))\n+                Err(AllocErr)\n             }\n         }\n     }\n@@ -1062,13 +1113,12 @@ pub unsafe trait Alloc {\n     unsafe fn dealloc_array<T>(&mut self, ptr: NonNull<T>, n: usize) -> Result<(), AllocErr>\n         where Self: Sized\n     {\n-        let raw_ptr = ptr.as_ptr() as *mut u8;\n         match Layout::array::<T>(n) {\n-            Some(ref k) if k.size() > 0 => {\n-                Ok(self.dealloc(raw_ptr, k.clone()))\n+            Ok(ref k) if k.size() > 0 => {\n+                Ok(self.dealloc(ptr.as_opaque(), k.clone()))\n             }\n             _ => {\n-                Err(AllocErr::invalid_input(\"invalid layout for dealloc_array\"))\n+                Err(AllocErr)\n             }\n         }\n     }", "previous_filename": "src/libcore/heap.rs"}, {"sha": "5ebd9e4334cd8ad000371ec0f857b4d3d55161e5", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -75,6 +75,7 @@\n #![feature(custom_attribute)]\n #![feature(doc_cfg)]\n #![feature(doc_spotlight)]\n+#![feature(extern_types)]\n #![feature(fn_must_use)]\n #![feature(fundamental)]\n #![feature(intrinsics)]\n@@ -184,7 +185,14 @@ pub mod unicode;\n \n /* Heap memory allocator trait */\n #[allow(missing_docs)]\n-pub mod heap;\n+pub mod alloc;\n+\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+#[rustc_deprecated(since = \"1.27.0\", reason = \"module renamed to `alloc`\")]\n+/// Use the `alloc` module instead.\n+pub mod heap {\n+    pub use alloc::*;\n+}\n \n // note: does not need to be public\n mod iter_private;"}, {"sha": "4a7d7c410eb16eebb850da3bd1cb9becb67af717", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -2750,6 +2750,14 @@ impl<T: ?Sized> NonNull<T> {\n             NonNull::new_unchecked(self.as_ptr() as *mut U)\n         }\n     }\n+\n+    /// Cast to an `Opaque` pointer\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    pub fn as_opaque(self) -> NonNull<::alloc::Opaque> {\n+        unsafe {\n+            NonNull::new_unchecked(self.as_ptr() as _)\n+        }\n+    }\n }\n \n #[stable(feature = \"nonnull\", since = \"1.25.0\")]"}, {"sha": "305502e7f063b562ac1d298925911ebcc325ce44", "filename": "src/librustc_allocator/expand.rs", "status": "modified", "additions": 31, "deletions": 247, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -11,7 +11,7 @@\n use rustc::middle::allocator::AllocatorKind;\n use rustc_errors;\n use syntax::abi::Abi;\n-use syntax::ast::{Crate, Attribute, LitKind, StrStyle, ExprKind};\n+use syntax::ast::{Crate, Attribute, LitKind, StrStyle};\n use syntax::ast::{Unsafety, Constness, Generics, Mutability, Ty, Mac, Arg};\n use syntax::ast::{self, Ident, Item, ItemKind, TyKind, VisibilityKind, Expr};\n use syntax::attr;\n@@ -88,15 +88,15 @@ impl<'a> Folder for ExpandAllocatorDirectives<'a> {\n             span,\n             kind: AllocatorKind::Global,\n             global: item.ident,\n-            alloc: Ident::from_str(\"alloc\"),\n+            core: Ident::from_str(\"core\"),\n             cx: ExtCtxt::new(self.sess, ecfg, self.resolver),\n         };\n         let super_path = f.cx.path(f.span, vec![\n             Ident::from_str(\"super\"),\n             f.global,\n         ]);\n         let mut items = vec![\n-            f.cx.item_extern_crate(f.span, f.alloc),\n+            f.cx.item_extern_crate(f.span, f.core),\n             f.cx.item_use_simple(\n                 f.span,\n                 respan(f.span.shrink_to_lo(), VisibilityKind::Inherited),\n@@ -126,7 +126,7 @@ struct AllocFnFactory<'a> {\n     span: Span,\n     kind: AllocatorKind,\n     global: Ident,\n-    alloc: Ident,\n+    core: Ident,\n     cx: ExtCtxt<'a>,\n }\n \n@@ -143,8 +143,7 @@ impl<'a> AllocFnFactory<'a> {\n             self.arg_ty(ty, &mut abi_args, mk)\n         }).collect();\n         let result = self.call_allocator(method.name, args);\n-        let (output_ty, output_expr) =\n-            self.ret_ty(&method.output, &mut abi_args, mk, result);\n+        let (output_ty, output_expr) = self.ret_ty(&method.output, result);\n         let kind = ItemKind::Fn(self.cx.fn_decl(abi_args, ast::FunctionRetTy::Ty(output_ty)),\n                                 Unsafety::Unsafe,\n                                 dummy_spanned(Constness::NotConst),\n@@ -159,16 +158,15 @@ impl<'a> AllocFnFactory<'a> {\n \n     fn call_allocator(&self, method: &str, mut args: Vec<P<Expr>>) -> P<Expr> {\n         let method = self.cx.path(self.span, vec![\n-            self.alloc,\n-            Ident::from_str(\"heap\"),\n-            Ident::from_str(\"Alloc\"),\n+            self.core,\n+            Ident::from_str(\"alloc\"),\n+            Ident::from_str(\"GlobalAlloc\"),\n             Ident::from_str(method),\n         ]);\n         let method = self.cx.expr_path(method);\n         let allocator = self.cx.path_ident(self.span, self.global);\n         let allocator = self.cx.expr_path(allocator);\n         let allocator = self.cx.expr_addr_of(self.span, allocator);\n-        let allocator = self.cx.expr_mut_addr_of(self.span, allocator);\n         args.insert(0, allocator);\n \n         self.cx.expr_call(self.span, method, args)\n@@ -205,8 +203,8 @@ impl<'a> AllocFnFactory<'a> {\n                 args.push(self.cx.arg(self.span, align, ty_usize));\n \n                 let layout_new = self.cx.path(self.span, vec![\n-                    self.alloc,\n-                    Ident::from_str(\"heap\"),\n+                    self.core,\n+                    Ident::from_str(\"alloc\"),\n                     Ident::from_str(\"Layout\"),\n                     Ident::from_str(\"from_size_align_unchecked\"),\n                 ]);\n@@ -219,240 +217,38 @@ impl<'a> AllocFnFactory<'a> {\n                 layout\n             }\n \n-            AllocatorTy::LayoutRef => {\n-                let ident = ident();\n-                args.push(self.cx.arg(self.span, ident, self.ptr_u8()));\n-\n-                // Convert our `arg: *const u8` via:\n-                //\n-                //      &*(arg as *const Layout)\n-                let expr = self.cx.expr_ident(self.span, ident);\n-                let expr = self.cx.expr_cast(self.span, expr, self.layout_ptr());\n-                let expr = self.cx.expr_deref(self.span, expr);\n-                self.cx.expr_addr_of(self.span, expr)\n-            }\n-\n-            AllocatorTy::AllocErr => {\n-                // We're creating:\n-                //\n-                //      (*(arg as *const AllocErr)).clone()\n+            AllocatorTy::Ptr => {\n                 let ident = ident();\n                 args.push(self.cx.arg(self.span, ident, self.ptr_u8()));\n-                let expr = self.cx.expr_ident(self.span, ident);\n-                let expr = self.cx.expr_cast(self.span, expr, self.alloc_err_ptr());\n-                let expr = self.cx.expr_deref(self.span, expr);\n-                self.cx.expr_method_call(\n-                    self.span,\n-                    expr,\n-                    Ident::from_str(\"clone\"),\n-                    Vec::new()\n-                )\n+                let arg = self.cx.expr_ident(self.span, ident);\n+                self.cx.expr_cast(self.span, arg, self.ptr_opaque())\n             }\n \n-            AllocatorTy::Ptr => {\n+            AllocatorTy::Usize => {\n                 let ident = ident();\n-                args.push(self.cx.arg(self.span, ident, self.ptr_u8()));\n+                args.push(self.cx.arg(self.span, ident, self.usize()));\n                 self.cx.expr_ident(self.span, ident)\n             }\n \n             AllocatorTy::ResultPtr |\n-            AllocatorTy::ResultExcess |\n-            AllocatorTy::ResultUnit |\n             AllocatorTy::Bang |\n-            AllocatorTy::UsizePair |\n             AllocatorTy::Unit => {\n                 panic!(\"can't convert AllocatorTy to an argument\")\n             }\n         }\n     }\n \n-    fn ret_ty(&self,\n-              ty: &AllocatorTy,\n-              args: &mut Vec<Arg>,\n-              ident: &mut FnMut() -> Ident,\n-              expr: P<Expr>) -> (P<Ty>, P<Expr>)\n-    {\n+    fn ret_ty(&self, ty: &AllocatorTy, expr: P<Expr>) -> (P<Ty>, P<Expr>) {\n         match *ty {\n-            AllocatorTy::UsizePair => {\n-                // We're creating:\n-                //\n-                //      let arg = #expr;\n-                //      *min = arg.0;\n-                //      *max = arg.1;\n-\n-                let min = ident();\n-                let max = ident();\n-\n-                args.push(self.cx.arg(self.span, min, self.ptr_usize()));\n-                args.push(self.cx.arg(self.span, max, self.ptr_usize()));\n-\n-                let ident = ident();\n-                let stmt = self.cx.stmt_let(self.span, false, ident, expr);\n-                let min = self.cx.expr_ident(self.span, min);\n-                let max = self.cx.expr_ident(self.span, max);\n-                let layout = self.cx.expr_ident(self.span, ident);\n-                let assign_min = self.cx.expr(self.span, ExprKind::Assign(\n-                    self.cx.expr_deref(self.span, min),\n-                    self.cx.expr_tup_field_access(self.span, layout.clone(), 0),\n-                ));\n-                let assign_min = self.cx.stmt_semi(assign_min);\n-                let assign_max = self.cx.expr(self.span, ExprKind::Assign(\n-                    self.cx.expr_deref(self.span, max),\n-                    self.cx.expr_tup_field_access(self.span, layout.clone(), 1),\n-                ));\n-                let assign_max = self.cx.stmt_semi(assign_max);\n-\n-                let stmts = vec![stmt, assign_min, assign_max];\n-                let block = self.cx.block(self.span, stmts);\n-                let ty_unit = self.cx.ty(self.span, TyKind::Tup(Vec::new()));\n-                (ty_unit, self.cx.expr_block(block))\n-            }\n-\n-            AllocatorTy::ResultExcess => {\n-                // We're creating:\n-                //\n-                //      match #expr {\n-                //          Ok(ptr) => {\n-                //              *excess = ptr.1;\n-                //              ptr.0\n-                //          }\n-                //          Err(e) => {\n-                //              ptr::write(err_ptr, e);\n-                //              0 as *mut u8\n-                //          }\n-                //      }\n-\n-                let excess_ptr = ident();\n-                args.push(self.cx.arg(self.span, excess_ptr, self.ptr_usize()));\n-                let excess_ptr = self.cx.expr_ident(self.span, excess_ptr);\n-\n-                let err_ptr = ident();\n-                args.push(self.cx.arg(self.span, err_ptr, self.ptr_u8()));\n-                let err_ptr = self.cx.expr_ident(self.span, err_ptr);\n-                let err_ptr = self.cx.expr_cast(self.span,\n-                                                err_ptr,\n-                                                self.alloc_err_ptr());\n-\n-                let name = ident();\n-                let ok_expr = {\n-                    let ptr = self.cx.expr_ident(self.span, name);\n-                    let write = self.cx.expr(self.span, ExprKind::Assign(\n-                        self.cx.expr_deref(self.span, excess_ptr),\n-                        self.cx.expr_tup_field_access(self.span, ptr.clone(), 1),\n-                    ));\n-                    let write = self.cx.stmt_semi(write);\n-                    let ret = self.cx.expr_tup_field_access(self.span,\n-                                                            ptr.clone(),\n-                                                            0);\n-                    let ret = self.cx.stmt_expr(ret);\n-                    let block = self.cx.block(self.span, vec![write, ret]);\n-                    self.cx.expr_block(block)\n-                };\n-                let pat = self.cx.pat_ident(self.span, name);\n-                let ok = self.cx.path_ident(self.span, Ident::from_str(\"Ok\"));\n-                let ok = self.cx.pat_tuple_struct(self.span, ok, vec![pat]);\n-                let ok = self.cx.arm(self.span, vec![ok], ok_expr);\n-\n-                let name = ident();\n-                let err_expr = {\n-                    let err = self.cx.expr_ident(self.span, name);\n-                    let write = self.cx.path(self.span, vec![\n-                        self.alloc,\n-                        Ident::from_str(\"heap\"),\n-                        Ident::from_str(\"__core\"),\n-                        Ident::from_str(\"ptr\"),\n-                        Ident::from_str(\"write\"),\n-                    ]);\n-                    let write = self.cx.expr_path(write);\n-                    let write = self.cx.expr_call(self.span, write,\n-                                                  vec![err_ptr, err]);\n-                    let write = self.cx.stmt_semi(write);\n-                    let null = self.cx.expr_usize(self.span, 0);\n-                    let null = self.cx.expr_cast(self.span, null, self.ptr_u8());\n-                    let null = self.cx.stmt_expr(null);\n-                    let block = self.cx.block(self.span, vec![write, null]);\n-                    self.cx.expr_block(block)\n-                };\n-                let pat = self.cx.pat_ident(self.span, name);\n-                let err = self.cx.path_ident(self.span, Ident::from_str(\"Err\"));\n-                let err = self.cx.pat_tuple_struct(self.span, err, vec![pat]);\n-                let err = self.cx.arm(self.span, vec![err], err_expr);\n-\n-                let expr = self.cx.expr_match(self.span, expr, vec![ok, err]);\n-                (self.ptr_u8(), expr)\n-            }\n-\n             AllocatorTy::ResultPtr => {\n                 // We're creating:\n                 //\n-                //      match #expr {\n-                //          Ok(ptr) => ptr,\n-                //          Err(e) => {\n-                //              ptr::write(err_ptr, e);\n-                //              0 as *mut u8\n-                //          }\n-                //      }\n-\n-                let err_ptr = ident();\n-                args.push(self.cx.arg(self.span, err_ptr, self.ptr_u8()));\n-                let err_ptr = self.cx.expr_ident(self.span, err_ptr);\n-                let err_ptr = self.cx.expr_cast(self.span,\n-                                                err_ptr,\n-                                                self.alloc_err_ptr());\n-\n-                let name = ident();\n-                let ok_expr = self.cx.expr_ident(self.span, name);\n-                let pat = self.cx.pat_ident(self.span, name);\n-                let ok = self.cx.path_ident(self.span, Ident::from_str(\"Ok\"));\n-                let ok = self.cx.pat_tuple_struct(self.span, ok, vec![pat]);\n-                let ok = self.cx.arm(self.span, vec![ok], ok_expr);\n+                //      #expr as *mut u8\n \n-                let name = ident();\n-                let err_expr = {\n-                    let err = self.cx.expr_ident(self.span, name);\n-                    let write = self.cx.path(self.span, vec![\n-                        self.alloc,\n-                        Ident::from_str(\"heap\"),\n-                        Ident::from_str(\"__core\"),\n-                        Ident::from_str(\"ptr\"),\n-                        Ident::from_str(\"write\"),\n-                    ]);\n-                    let write = self.cx.expr_path(write);\n-                    let write = self.cx.expr_call(self.span, write,\n-                                                  vec![err_ptr, err]);\n-                    let write = self.cx.stmt_semi(write);\n-                    let null = self.cx.expr_usize(self.span, 0);\n-                    let null = self.cx.expr_cast(self.span, null, self.ptr_u8());\n-                    let null = self.cx.stmt_expr(null);\n-                    let block = self.cx.block(self.span, vec![write, null]);\n-                    self.cx.expr_block(block)\n-                };\n-                let pat = self.cx.pat_ident(self.span, name);\n-                let err = self.cx.path_ident(self.span, Ident::from_str(\"Err\"));\n-                let err = self.cx.pat_tuple_struct(self.span, err, vec![pat]);\n-                let err = self.cx.arm(self.span, vec![err], err_expr);\n-\n-                let expr = self.cx.expr_match(self.span, expr, vec![ok, err]);\n+                let expr = self.cx.expr_cast(self.span, expr, self.ptr_u8());\n                 (self.ptr_u8(), expr)\n             }\n \n-            AllocatorTy::ResultUnit => {\n-                // We're creating:\n-                //\n-                //      #expr.is_ok() as u8\n-\n-                let cast = self.cx.expr_method_call(\n-                    self.span,\n-                    expr,\n-                    Ident::from_str(\"is_ok\"),\n-                    Vec::new()\n-                );\n-                let u8 = self.cx.path_ident(self.span, Ident::from_str(\"u8\"));\n-                let u8 = self.cx.ty_path(u8);\n-                let cast = self.cx.expr_cast(self.span, cast, u8.clone());\n-                (u8, cast)\n-            }\n-\n             AllocatorTy::Bang => {\n                 (self.cx.ty(self.span, TyKind::Never), expr)\n             }\n@@ -461,44 +257,32 @@ impl<'a> AllocFnFactory<'a> {\n                 (self.cx.ty(self.span, TyKind::Tup(Vec::new())), expr)\n             }\n \n-            AllocatorTy::AllocErr |\n             AllocatorTy::Layout |\n-            AllocatorTy::LayoutRef |\n+            AllocatorTy::Usize |\n             AllocatorTy::Ptr => {\n                 panic!(\"can't convert AllocatorTy to an output\")\n             }\n         }\n     }\n \n+    fn usize(&self) -> P<Ty> {\n+        let usize = self.cx.path_ident(self.span, Ident::from_str(\"usize\"));\n+        self.cx.ty_path(usize)\n+    }\n+\n     fn ptr_u8(&self) -> P<Ty> {\n         let u8 = self.cx.path_ident(self.span, Ident::from_str(\"u8\"));\n         let ty_u8 = self.cx.ty_path(u8);\n         self.cx.ty_ptr(self.span, ty_u8, Mutability::Mutable)\n     }\n \n-    fn ptr_usize(&self) -> P<Ty> {\n-        let usize = self.cx.path_ident(self.span, Ident::from_str(\"usize\"));\n-        let ty_usize = self.cx.ty_path(usize);\n-        self.cx.ty_ptr(self.span, ty_usize, Mutability::Mutable)\n-    }\n-\n-    fn layout_ptr(&self) -> P<Ty> {\n-        let layout = self.cx.path(self.span, vec![\n-            self.alloc,\n-            Ident::from_str(\"heap\"),\n-            Ident::from_str(\"Layout\"),\n-        ]);\n-        let layout = self.cx.ty_path(layout);\n-        self.cx.ty_ptr(self.span, layout, Mutability::Mutable)\n-    }\n-\n-    fn alloc_err_ptr(&self) -> P<Ty> {\n-        let err = self.cx.path(self.span, vec![\n-            self.alloc,\n-            Ident::from_str(\"heap\"),\n-            Ident::from_str(\"AllocErr\"),\n+    fn ptr_opaque(&self) -> P<Ty> {\n+        let opaque = self.cx.path(self.span, vec![\n+            self.core,\n+            Ident::from_str(\"alloc\"),\n+            Ident::from_str(\"Opaque\"),\n         ]);\n-        let err = self.cx.ty_path(err);\n-        self.cx.ty_ptr(self.span, err, Mutability::Mutable)\n+        let ty_opaque = self.cx.ty_path(opaque);\n+        self.cx.ty_ptr(self.span, ty_opaque, Mutability::Mutable)\n     }\n }"}, {"sha": "706eab72d44cc8af296a9fec233d3bf5babeb347", "filename": "src/librustc_allocator/lib.rs", "status": "modified", "additions": 3, "deletions": 32, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibrustc_allocator%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibrustc_allocator%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Flib.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -25,49 +25,24 @@ pub static ALLOCATOR_METHODS: &[AllocatorMethod] = &[\n     },\n     AllocatorMethod {\n         name: \"oom\",\n-        inputs: &[AllocatorTy::AllocErr],\n+        inputs: &[],\n         output: AllocatorTy::Bang,\n     },\n     AllocatorMethod {\n         name: \"dealloc\",\n         inputs: &[AllocatorTy::Ptr, AllocatorTy::Layout],\n         output: AllocatorTy::Unit,\n     },\n-    AllocatorMethod {\n-        name: \"usable_size\",\n-        inputs: &[AllocatorTy::LayoutRef],\n-        output: AllocatorTy::UsizePair,\n-    },\n     AllocatorMethod {\n         name: \"realloc\",\n-        inputs: &[AllocatorTy::Ptr, AllocatorTy::Layout, AllocatorTy::Layout],\n+        inputs: &[AllocatorTy::Ptr, AllocatorTy::Layout, AllocatorTy::Usize],\n         output: AllocatorTy::ResultPtr,\n     },\n     AllocatorMethod {\n         name: \"alloc_zeroed\",\n         inputs: &[AllocatorTy::Layout],\n         output: AllocatorTy::ResultPtr,\n     },\n-    AllocatorMethod {\n-        name: \"alloc_excess\",\n-        inputs: &[AllocatorTy::Layout],\n-        output: AllocatorTy::ResultExcess,\n-    },\n-    AllocatorMethod {\n-        name: \"realloc_excess\",\n-        inputs: &[AllocatorTy::Ptr, AllocatorTy::Layout, AllocatorTy::Layout],\n-        output: AllocatorTy::ResultExcess,\n-    },\n-    AllocatorMethod {\n-        name: \"grow_in_place\",\n-        inputs: &[AllocatorTy::Ptr, AllocatorTy::Layout, AllocatorTy::Layout],\n-        output: AllocatorTy::ResultUnit,\n-    },\n-    AllocatorMethod {\n-        name: \"shrink_in_place\",\n-        inputs: &[AllocatorTy::Ptr, AllocatorTy::Layout, AllocatorTy::Layout],\n-        output: AllocatorTy::ResultUnit,\n-    },\n ];\n \n pub struct AllocatorMethod {\n@@ -77,14 +52,10 @@ pub struct AllocatorMethod {\n }\n \n pub enum AllocatorTy {\n-    AllocErr,\n     Bang,\n     Layout,\n-    LayoutRef,\n     Ptr,\n-    ResultExcess,\n     ResultPtr,\n-    ResultUnit,\n     Unit,\n-    UsizePair,\n+    Usize,\n }"}, {"sha": "f2dd2ed8460ebbfa65d1776cae8d703d1a5c8d1b", "filename": "src/librustc_trans/allocator.rs", "status": "modified", "additions": 3, "deletions": 23, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibrustc_trans%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibrustc_trans%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fallocator.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -30,7 +30,6 @@ pub(crate) unsafe fn trans(tcx: TyCtxt, mods: &ModuleLlvm, kind: AllocatorKind)\n     };\n     let i8 = llvm::LLVMInt8TypeInContext(llcx);\n     let i8p = llvm::LLVMPointerType(i8, 0);\n-    let usizep = llvm::LLVMPointerType(usize, 0);\n     let void = llvm::LLVMVoidTypeInContext(llcx);\n \n     for method in ALLOCATOR_METHODS {\n@@ -41,40 +40,21 @@ pub(crate) unsafe fn trans(tcx: TyCtxt, mods: &ModuleLlvm, kind: AllocatorKind)\n                     args.push(usize); // size\n                     args.push(usize); // align\n                 }\n-                AllocatorTy::LayoutRef => args.push(i8p),\n                 AllocatorTy::Ptr => args.push(i8p),\n-                AllocatorTy::AllocErr => args.push(i8p),\n+                AllocatorTy::Usize => args.push(usize),\n \n                 AllocatorTy::Bang |\n-                AllocatorTy::ResultExcess |\n                 AllocatorTy::ResultPtr |\n-                AllocatorTy::ResultUnit |\n-                AllocatorTy::UsizePair |\n                 AllocatorTy::Unit => panic!(\"invalid allocator arg\"),\n             }\n         }\n         let output = match method.output {\n-            AllocatorTy::UsizePair => {\n-                args.push(usizep); // min\n-                args.push(usizep); // max\n-                None\n-            }\n             AllocatorTy::Bang => None,\n-            AllocatorTy::ResultExcess => {\n-                args.push(i8p); // excess_ptr\n-                args.push(i8p); // err_ptr\n-                Some(i8p)\n-            }\n-            AllocatorTy::ResultPtr => {\n-                args.push(i8p); // err_ptr\n-                Some(i8p)\n-            }\n-            AllocatorTy::ResultUnit => Some(i8),\n+            AllocatorTy::ResultPtr => Some(i8p),\n             AllocatorTy::Unit => None,\n \n-            AllocatorTy::AllocErr |\n             AllocatorTy::Layout |\n-            AllocatorTy::LayoutRef |\n+            AllocatorTy::Usize |\n             AllocatorTy::Ptr => panic!(\"invalid allocator output\"),\n         };\n         let ty = llvm::LLVMFunctionType(output.unwrap_or(void),"}, {"sha": "ff578ec42d23088ce2594175b24f3c4aeddce1b8", "filename": "src/libstd/alloc.rs", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibstd%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibstd%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Falloc.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -0,0 +1,121 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! dox\n+\n+#![unstable(issue = \"32838\", feature = \"allocator_api\")]\n+\n+#[doc(inline)] #[allow(deprecated)] pub use alloc_crate::alloc::Heap;\n+#[doc(inline)] pub use alloc_crate::alloc::Global;\n+#[doc(inline)] pub use alloc_system::System;\n+#[doc(inline)] pub use core::alloc::*;\n+\n+#[cfg(not(test))]\n+#[doc(hidden)]\n+#[allow(unused_attributes)]\n+pub mod __default_lib_allocator {\n+    use super::{System, Layout, GlobalAlloc, Opaque};\n+    // for symbol names src/librustc/middle/allocator.rs\n+    // for signatures src/librustc_allocator/lib.rs\n+\n+    // linkage directives are provided as part of the current compiler allocator\n+    // ABI\n+\n+    #[no_mangle]\n+    #[rustc_std_internal_symbol]\n+    pub unsafe extern fn __rdl_alloc(size: usize, align: usize) -> *mut u8 {\n+        let layout = Layout::from_size_align_unchecked(size, align);\n+        System.alloc(layout) as *mut u8\n+    }\n+\n+    #[no_mangle]\n+    #[rustc_std_internal_symbol]\n+    pub unsafe extern fn __rdl_oom() -> ! {\n+        System.oom()\n+    }\n+\n+    #[no_mangle]\n+    #[rustc_std_internal_symbol]\n+    pub unsafe extern fn __rdl_dealloc(ptr: *mut u8,\n+                                       size: usize,\n+                                       align: usize) {\n+        System.dealloc(ptr as *mut Opaque, Layout::from_size_align_unchecked(size, align))\n+    }\n+\n+    #[no_mangle]\n+    #[rustc_std_internal_symbol]\n+    pub unsafe extern fn __rdl_realloc(ptr: *mut u8,\n+                                       old_size: usize,\n+                                       align: usize,\n+                                       new_size: usize) -> *mut u8 {\n+        let old_layout = Layout::from_size_align_unchecked(old_size, align);\n+        System.realloc(ptr as *mut Opaque, old_layout, new_size) as *mut u8\n+    }\n+\n+    #[no_mangle]\n+    #[rustc_std_internal_symbol]\n+    pub unsafe extern fn __rdl_alloc_zeroed(size: usize, align: usize) -> *mut u8 {\n+        let layout = Layout::from_size_align_unchecked(size, align);\n+        System.alloc_zeroed(layout) as *mut u8\n+    }\n+\n+    #[cfg(stage0)]\n+    pub mod stage0 {\n+        #[no_mangle]\n+        #[rustc_std_internal_symbol]\n+        pub unsafe extern fn __rdl_usable_size(_layout: *const u8,\n+                                               _min: *mut usize,\n+                                               _max: *mut usize) {\n+            unimplemented!()\n+        }\n+\n+        #[no_mangle]\n+        #[rustc_std_internal_symbol]\n+        pub unsafe extern fn __rdl_alloc_excess(_size: usize,\n+                                                _align: usize,\n+                                                _excess: *mut usize,\n+                                                _err: *mut u8) -> *mut u8 {\n+            unimplemented!()\n+        }\n+\n+        #[no_mangle]\n+        #[rustc_std_internal_symbol]\n+        pub unsafe extern fn __rdl_realloc_excess(_ptr: *mut u8,\n+                                                  _old_size: usize,\n+                                                  _old_align: usize,\n+                                                  _new_size: usize,\n+                                                  _new_align: usize,\n+                                                  _excess: *mut usize,\n+                                                  _err: *mut u8) -> *mut u8 {\n+            unimplemented!()\n+        }\n+\n+        #[no_mangle]\n+        #[rustc_std_internal_symbol]\n+        pub unsafe extern fn __rdl_grow_in_place(_ptr: *mut u8,\n+                                                 _old_size: usize,\n+                                                 _old_align: usize,\n+                                                 _new_size: usize,\n+                                                 _new_align: usize) -> u8 {\n+            unimplemented!()\n+        }\n+\n+        #[no_mangle]\n+        #[rustc_std_internal_symbol]\n+        pub unsafe extern fn __rdl_shrink_in_place(_ptr: *mut u8,\n+                                                   _old_size: usize,\n+                                                   _old_align: usize,\n+                                                   _new_size: usize,\n+                                                   _new_align: usize) -> u8 {\n+            unimplemented!()\n+        }\n+\n+    }\n+}"}, {"sha": "20a4f9b508d240be95e285e97fdcbb45dcfc0952", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -11,10 +11,8 @@\n use self::Entry::*;\n use self::VacantEntryState::*;\n \n-use alloc::heap::Heap;\n-use alloc::allocator::CollectionAllocErr;\n+use alloc::{Global, Alloc, CollectionAllocErr};\n use cell::Cell;\n-use core::heap::Alloc;\n use borrow::Borrow;\n use cmp::max;\n use fmt::{self, Debug};\n@@ -786,7 +784,7 @@ impl<K, V, S> HashMap<K, V, S>\n     pub fn reserve(&mut self, additional: usize) {\n         match self.try_reserve(additional) {\n             Err(CollectionAllocErr::CapacityOverflow) => panic!(\"capacity overflow\"),\n-            Err(CollectionAllocErr::AllocErr(e)) => Heap.oom(e),\n+            Err(CollectionAllocErr::AllocErr) => Global.oom(),\n             Ok(()) => { /* yay */ }\n          }\n     }\n@@ -3636,7 +3634,7 @@ mod test_map {\n             if let Err(CapacityOverflow) = empty_bytes.try_reserve(max_no_ovf) {\n             } else { panic!(\"isize::MAX + 1 should trigger a CapacityOverflow!\") }\n         } else {\n-            if let Err(AllocErr(_)) = empty_bytes.try_reserve(max_no_ovf) {\n+            if let Err(AllocErr) = empty_bytes.try_reserve(max_no_ovf) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n     }"}, {"sha": "93f059076d794ea84074ceb11de91b24e43255f7", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -8,17 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use alloc::heap::Heap;\n-use core::heap::{Alloc, Layout};\n-\n+use alloc::{Global, Alloc, Layout, CollectionAllocErr};\n use cmp;\n use hash::{BuildHasher, Hash, Hasher};\n use marker;\n use mem::{align_of, size_of, needs_drop};\n use mem;\n use ops::{Deref, DerefMut};\n use ptr::{self, Unique, NonNull};\n-use alloc::allocator::CollectionAllocErr;\n \n use self::BucketState::*;\n \n@@ -757,15 +754,13 @@ impl<K, V> RawTable<K, V> {\n             return Err(CollectionAllocErr::CapacityOverflow);\n         }\n \n-        let buffer = Heap.alloc(Layout::from_size_align(size, alignment)\n-            .ok_or(CollectionAllocErr::CapacityOverflow)?)?;\n-\n-        let hashes = buffer as *mut HashUint;\n+        let buffer = Global.alloc(Layout::from_size_align(size, alignment)\n+            .map_err(|_| CollectionAllocErr::CapacityOverflow)?)?;\n \n         Ok(RawTable {\n             capacity_mask: capacity.wrapping_sub(1),\n             size: 0,\n-            hashes: TaggedHashUintPtr::new(hashes),\n+            hashes: TaggedHashUintPtr::new(buffer.cast().as_ptr()),\n             marker: marker::PhantomData,\n         })\n     }\n@@ -775,7 +770,7 @@ impl<K, V> RawTable<K, V> {\n     unsafe fn new_uninitialized(capacity: usize) -> RawTable<K, V> {\n         match Self::try_new_uninitialized(capacity) {\n             Err(CollectionAllocErr::CapacityOverflow) => panic!(\"capacity overflow\"),\n-            Err(CollectionAllocErr::AllocErr(e)) => Heap.oom(e),\n+            Err(CollectionAllocErr::AllocErr) => Global.oom(),\n             Ok(table) => { table }\n         }\n     }\n@@ -814,7 +809,7 @@ impl<K, V> RawTable<K, V> {\n     pub fn new(capacity: usize) -> RawTable<K, V> {\n         match Self::try_new(capacity) {\n             Err(CollectionAllocErr::CapacityOverflow) => panic!(\"capacity overflow\"),\n-            Err(CollectionAllocErr::AllocErr(e)) => Heap.oom(e),\n+            Err(CollectionAllocErr::AllocErr) => Global.oom(),\n             Ok(table) => { table }\n         }\n     }\n@@ -1188,8 +1183,8 @@ unsafe impl<#[may_dangle] K, #[may_dangle] V> Drop for RawTable<K, V> {\n         debug_assert!(!oflo, \"should be impossible\");\n \n         unsafe {\n-            Heap.dealloc(self.hashes.ptr() as *mut u8,\n-                         Layout::from_size_align(size, align).unwrap());\n+            Global.dealloc(NonNull::new_unchecked(self.hashes.ptr()).as_opaque(),\n+                           Layout::from_size_align(size, align).unwrap());\n             // Remember how everything was allocated out of one buffer\n             // during initialization? We only need one call to free here.\n         }"}, {"sha": "9cf73824deaaff70a8e1ea027ed21a5a73a31524", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -424,13 +424,13 @@\n #[doc(hidden)]\n pub use ops::Bound;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use alloc::{BinaryHeap, BTreeMap, BTreeSet};\n+pub use alloc_crate::{BinaryHeap, BTreeMap, BTreeSet};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use alloc::{LinkedList, VecDeque};\n+pub use alloc_crate::{LinkedList, VecDeque};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use alloc::{binary_heap, btree_map, btree_set};\n+pub use alloc_crate::{binary_heap, btree_map, btree_set};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use alloc::{linked_list, vec_deque};\n+pub use alloc_crate::{linked_list, vec_deque};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::hash_map::HashMap;\n@@ -446,7 +446,7 @@ pub mod range {\n }\n \n #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-pub use alloc::allocator::CollectionAllocErr;\n+pub use heap::CollectionAllocErr;\n \n mod hash;\n "}, {"sha": "3c209928d432aa38a9b5c92995b96cc13fbc4367", "filename": "src/libstd/error.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -51,13 +51,13 @@\n // coherence challenge (e.g., specialization, neg impls, etc) we can\n // reconsider what crate these items belong in.\n \n-use alloc::allocator;\n use any::TypeId;\n use borrow::Cow;\n use cell;\n use char;\n use core::array;\n use fmt::{self, Debug, Display};\n+use heap::{AllocErr, LayoutErr, CannotReallocInPlace};\n use mem::transmute;\n use num;\n use str;\n@@ -241,18 +241,27 @@ impl Error for ! {\n #[unstable(feature = \"allocator_api\",\n            reason = \"the precise API and guarantees it provides may be tweaked.\",\n            issue = \"32838\")]\n-impl Error for allocator::AllocErr {\n+impl Error for AllocErr {\n     fn description(&self) -> &str {\n-        allocator::AllocErr::description(self)\n+        \"memory allocation failed\"\n     }\n }\n \n #[unstable(feature = \"allocator_api\",\n            reason = \"the precise API and guarantees it provides may be tweaked.\",\n            issue = \"32838\")]\n-impl Error for allocator::CannotReallocInPlace {\n+impl Error for LayoutErr {\n     fn description(&self) -> &str {\n-        allocator::CannotReallocInPlace::description(self)\n+        \"invalid parameters to Layout::from_size_align\"\n+    }\n+}\n+\n+#[unstable(feature = \"allocator_api\",\n+           reason = \"the precise API and guarantees it provides may be tweaked.\",\n+           issue = \"32838\")]\n+impl Error for CannotReallocInPlace {\n+    fn description(&self) -> &str {\n+        CannotReallocInPlace::description(self)\n     }\n }\n "}, {"sha": "4a391372c3a1168bb3c2bc82014ba3b74d082fc6", "filename": "src/libstd/heap.rs", "status": "removed", "additions": 0, "deletions": 176, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/f9f9050f507cd14839f868917b5b4fc370eed54b/src%2Flibstd%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9f9050f507cd14839f868917b5b4fc370eed54b/src%2Flibstd%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fheap.rs?ref=f9f9050f507cd14839f868917b5b4fc370eed54b", "patch": "@@ -1,176 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! dox\n-\n-#![unstable(issue = \"32838\", feature = \"allocator_api\")]\n-\n-pub use alloc::heap::Heap;\n-pub use alloc_system::System;\n-pub use core::heap::*;\n-\n-#[cfg(not(test))]\n-#[doc(hidden)]\n-#[allow(unused_attributes)]\n-pub mod __default_lib_allocator {\n-    use super::{System, Layout, Alloc, AllocErr};\n-    use ptr;\n-\n-    // for symbol names src/librustc/middle/allocator.rs\n-    // for signatures src/librustc_allocator/lib.rs\n-\n-    // linkage directives are provided as part of the current compiler allocator\n-    // ABI\n-\n-    #[no_mangle]\n-    #[rustc_std_internal_symbol]\n-    pub unsafe extern fn __rdl_alloc(size: usize,\n-                                     align: usize,\n-                                     err: *mut u8) -> *mut u8 {\n-        let layout = Layout::from_size_align_unchecked(size, align);\n-        match System.alloc(layout) {\n-            Ok(p) => p,\n-            Err(e) => {\n-                ptr::write(err as *mut AllocErr, e);\n-                0 as *mut u8\n-            }\n-        }\n-    }\n-\n-    #[no_mangle]\n-    #[rustc_std_internal_symbol]\n-    pub unsafe extern fn __rdl_oom(err: *const u8) -> ! {\n-        System.oom((*(err as *const AllocErr)).clone())\n-    }\n-\n-    #[no_mangle]\n-    #[rustc_std_internal_symbol]\n-    pub unsafe extern fn __rdl_dealloc(ptr: *mut u8,\n-                                       size: usize,\n-                                       align: usize) {\n-        System.dealloc(ptr, Layout::from_size_align_unchecked(size, align))\n-    }\n-\n-    #[no_mangle]\n-    #[rustc_std_internal_symbol]\n-    pub unsafe extern fn __rdl_usable_size(layout: *const u8,\n-                                           min: *mut usize,\n-                                           max: *mut usize) {\n-        let pair = System.usable_size(&*(layout as *const Layout));\n-        *min = pair.0;\n-        *max = pair.1;\n-    }\n-\n-    #[no_mangle]\n-    #[rustc_std_internal_symbol]\n-    pub unsafe extern fn __rdl_realloc(ptr: *mut u8,\n-                                       old_size: usize,\n-                                       old_align: usize,\n-                                       new_size: usize,\n-                                       new_align: usize,\n-                                       err: *mut u8) -> *mut u8 {\n-        let old_layout = Layout::from_size_align_unchecked(old_size, old_align);\n-        let new_layout = Layout::from_size_align_unchecked(new_size, new_align);\n-        match System.realloc(ptr, old_layout, new_layout) {\n-            Ok(p) => p,\n-            Err(e) => {\n-                ptr::write(err as *mut AllocErr, e);\n-                0 as *mut u8\n-            }\n-        }\n-    }\n-\n-    #[no_mangle]\n-    #[rustc_std_internal_symbol]\n-    pub unsafe extern fn __rdl_alloc_zeroed(size: usize,\n-                                            align: usize,\n-                                            err: *mut u8) -> *mut u8 {\n-        let layout = Layout::from_size_align_unchecked(size, align);\n-        match System.alloc_zeroed(layout) {\n-            Ok(p) => p,\n-            Err(e) => {\n-                ptr::write(err as *mut AllocErr, e);\n-                0 as *mut u8\n-            }\n-        }\n-    }\n-\n-    #[no_mangle]\n-    #[rustc_std_internal_symbol]\n-    pub unsafe extern fn __rdl_alloc_excess(size: usize,\n-                                            align: usize,\n-                                            excess: *mut usize,\n-                                            err: *mut u8) -> *mut u8 {\n-        let layout = Layout::from_size_align_unchecked(size, align);\n-        match System.alloc_excess(layout) {\n-            Ok(p) => {\n-                *excess = p.1;\n-                p.0\n-            }\n-            Err(e) => {\n-                ptr::write(err as *mut AllocErr, e);\n-                0 as *mut u8\n-            }\n-        }\n-    }\n-\n-    #[no_mangle]\n-    #[rustc_std_internal_symbol]\n-    pub unsafe extern fn __rdl_realloc_excess(ptr: *mut u8,\n-                                              old_size: usize,\n-                                              old_align: usize,\n-                                              new_size: usize,\n-                                              new_align: usize,\n-                                              excess: *mut usize,\n-                                              err: *mut u8) -> *mut u8 {\n-        let old_layout = Layout::from_size_align_unchecked(old_size, old_align);\n-        let new_layout = Layout::from_size_align_unchecked(new_size, new_align);\n-        match System.realloc_excess(ptr, old_layout, new_layout) {\n-            Ok(p) => {\n-                *excess = p.1;\n-                p.0\n-            }\n-            Err(e) => {\n-                ptr::write(err as *mut AllocErr, e);\n-                0 as *mut u8\n-            }\n-        }\n-    }\n-\n-    #[no_mangle]\n-    #[rustc_std_internal_symbol]\n-    pub unsafe extern fn __rdl_grow_in_place(ptr: *mut u8,\n-                                             old_size: usize,\n-                                             old_align: usize,\n-                                             new_size: usize,\n-                                             new_align: usize) -> u8 {\n-        let old_layout = Layout::from_size_align_unchecked(old_size, old_align);\n-        let new_layout = Layout::from_size_align_unchecked(new_size, new_align);\n-        match System.grow_in_place(ptr, old_layout, new_layout) {\n-            Ok(()) => 1,\n-            Err(_) => 0,\n-        }\n-    }\n-\n-    #[no_mangle]\n-    #[rustc_std_internal_symbol]\n-    pub unsafe extern fn __rdl_shrink_in_place(ptr: *mut u8,\n-                                               old_size: usize,\n-                                               old_align: usize,\n-                                               new_size: usize,\n-                                               new_align: usize) -> u8 {\n-        let old_layout = Layout::from_size_align_unchecked(old_size, old_align);\n-        let new_layout = Layout::from_size_align_unchecked(new_size, new_align);\n-        match System.shrink_in_place(ptr, old_layout, new_layout) {\n-            Ok(()) => 1,\n-            Err(_) => 0,\n-        }\n-    }\n-}"}, {"sha": "a34fcb5a7f98b4221dbf37d44a9f5a49d3417511", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -275,6 +275,7 @@\n #![feature(macro_reexport)]\n #![feature(macro_vis_matcher)]\n #![feature(needs_panic_runtime)]\n+#![feature(nonnull_cast)]\n #![feature(exhaustive_patterns)]\n #![feature(nonzero)]\n #![feature(num_bits_bytes)]\n@@ -351,7 +352,7 @@ extern crate core as __core;\n \n #[macro_use]\n #[macro_reexport(vec, format)]\n-extern crate alloc;\n+extern crate alloc as alloc_crate;\n extern crate alloc_system;\n #[doc(masked)]\n extern crate libc;\n@@ -437,21 +438,21 @@ pub use core::u32;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::u64;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use alloc::boxed;\n+pub use alloc_crate::boxed;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use alloc::rc;\n+pub use alloc_crate::rc;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use alloc::borrow;\n+pub use alloc_crate::borrow;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use alloc::fmt;\n+pub use alloc_crate::fmt;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use alloc::slice;\n+pub use alloc_crate::slice;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use alloc::str;\n+pub use alloc_crate::str;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use alloc::string;\n+pub use alloc_crate::string;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use alloc::vec;\n+pub use alloc_crate::vec;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::char;\n #[stable(feature = \"i128\", since = \"1.26.0\")]\n@@ -477,7 +478,14 @@ pub mod path;\n pub mod process;\n pub mod sync;\n pub mod time;\n-pub mod heap;\n+pub mod alloc;\n+\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+#[rustc_deprecated(since = \"1.27.0\", reason = \"module renamed to `alloc`\")]\n+/// Use the `alloc` module instead.\n+pub mod heap {\n+    pub use alloc::*;\n+}\n \n // Platform-abstraction modules\n #[macro_use]"}, {"sha": "642b284c6c794bc4aa7216dffc039bac7f5729e9", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -18,7 +18,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use alloc::arc::{Arc, Weak};\n+pub use alloc_crate::arc::{Arc, Weak};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::sync::atomic;\n "}, {"sha": "df945ac3859f9c10765b275eb6e9c25327d95c74", "filename": "src/libstd/sync/mpsc/mpsc_queue.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -23,10 +23,9 @@\n \n pub use self::PopResult::*;\n \n-use alloc::boxed::Box;\n use core::ptr;\n use core::cell::UnsafeCell;\n-\n+use boxed::Box;\n use sync::atomic::{AtomicPtr, Ordering};\n \n /// A result of the `pop` function."}, {"sha": "9482f6958b311b8f45f5c6c75687f8eb8e2dc35a", "filename": "src/libstd/sync/mpsc/spsc_queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -16,7 +16,7 @@\n \n // http://www.1024cores.net/home/lock-free-algorithms/queues/unbounded-spsc-queue\n \n-use alloc::boxed::Box;\n+use boxed::Box;\n use core::ptr;\n use core::cell::UnsafeCell;\n "}, {"sha": "5d66936b2a4ff1753e5e735acc7dd9d3e3cf9f96", "filename": "src/libstd/sys/cloudabi/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibstd%2Fsys%2Fcloudabi%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibstd%2Fsys%2Fcloudabi%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcloudabi%2Fthread.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use alloc::boxed::FnBox;\n+use boxed::FnBox;\n use cmp;\n use ffi::CStr;\n use io;"}, {"sha": "110d46ca3ab0381387efe55e8d39ae97ab9c7631", "filename": "src/libstd/sys/redox/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibstd%2Fsys%2Fredox%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibstd%2Fsys%2Fredox%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fthread.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use alloc::boxed::FnBox;\n+use boxed::FnBox;\n use ffi::CStr;\n use io;\n use mem;"}, {"sha": "9e38880803026cc62abe7498c8d413997552ab2c", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use alloc::boxed::FnBox;\n+use boxed::FnBox;\n use cmp;\n use ffi::CStr;\n use io;"}, {"sha": "728e678a2e8c193c22b48270bd815a2a54f7c015", "filename": "src/libstd/sys/wasm/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use alloc::boxed::FnBox;\n+use boxed::FnBox;\n use ffi::CStr;\n use io;\n use sys::{unsupported, Void};"}, {"sha": "be442f413740a440deee9b7fd9c7db5196b8105a", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -31,7 +31,7 @@ use sys::stdio;\n use sys::cvt;\n use sys_common::{AsInner, FromInner, IntoInner};\n use sys_common::process::{CommandEnv, EnvKey};\n-use alloc::borrow::Borrow;\n+use borrow::Borrow;\n \n ////////////////////////////////////////////////////////////////////////////////\n // Command"}, {"sha": "b6f63303dc2f0af374d731305059f9c8a45008d5", "filename": "src/libstd/sys/windows/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use alloc::boxed::FnBox;\n+use boxed::FnBox;\n use io;\n use ffi::CStr;\n use mem;"}, {"sha": "26da51c9825fbe8a07e9afc1dbcb0328a1fed9b8", "filename": "src/libstd/sys_common/at_exit_imp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibstd%2Fsys_common%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibstd%2Fsys_common%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fat_exit_imp.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -12,7 +12,7 @@\n //!\n //! Documentation can be found on the `rt::at_exit` function.\n \n-use alloc::boxed::FnBox;\n+use boxed::FnBox;\n use ptr;\n use sys_common::mutex::Mutex;\n "}, {"sha": "ddf0ebe603e08887fcef06cf22ec71051a80a37d", "filename": "src/libstd/sys_common/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibstd%2Fsys_common%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibstd%2Fsys_common%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fprocess.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -14,7 +14,7 @@\n use ffi::{OsStr, OsString};\n use env;\n use collections::BTreeMap;\n-use alloc::borrow::Borrow;\n+use borrow::Borrow;\n \n pub trait EnvKey:\n     From<OsString> + Into<OsString> +"}, {"sha": "da6f58ef6bb7724952ef73162a75b6bec26491f0", "filename": "src/libstd/sys_common/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibstd%2Fsys_common%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Flibstd%2Fsys_common%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fthread.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use alloc::boxed::FnBox;\n+use boxed::FnBox;\n use env;\n use sync::atomic::{self, Ordering};\n use sys::stack_overflow;"}, {"sha": "7243155b1c3da0a980c868a87adebf00e0b33989", "filename": "src/llvm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -1 +1 @@\n-Subproject commit 6ceaaa4b0176a200e4bbd347d6a991ab6c776ede\n+Subproject commit 7243155b1c3da0a980c868a87adebf00e0b33989"}, {"sha": "b6f8550829fe0658726fe788f653bbf88dcbd0b8", "filename": "src/rustc/dlmalloc_shim/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Frustc%2Fdlmalloc_shim%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Frustc%2Fdlmalloc_shim%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdlmalloc_shim%2FCargo.toml?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -12,4 +12,3 @@ doc = false\n [dependencies]\n core = { path = \"../../libcore\" }\n compiler_builtins = { path = \"../../rustc/compiler_builtins_shim\" }\n-alloc = { path = \"../../liballoc\" }"}, {"sha": "c3fc3e5452c4f97d76f8b0542d8b0278a43ad819", "filename": "src/rustllvm/llvm-rebuild-trigger", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Frustllvm%2Fllvm-rebuild-trigger", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Frustllvm%2Fllvm-rebuild-trigger", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Fllvm-rebuild-trigger?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -1,4 +1,4 @@\n # If this file is modified, then llvm will be (optionally) cleaned and then rebuilt.\n # The actual contents of this file do not matter, but to trigger a change on the\n # build bots then the contents should be changed so git updates the mtime.\n-2018-03-10\n+2018-04-05"}, {"sha": "1479d0b62642a76cc8267994d270e196ce0eade0", "filename": "src/test/compile-fail/allocator/not-an-allocator.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Ftest%2Fcompile-fail%2Fallocator%2Fnot-an-allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Ftest%2Fcompile-fail%2Fallocator%2Fnot-an-allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fallocator%2Fnot-an-allocator.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -12,15 +12,10 @@\n \n #[global_allocator]\n static A: usize = 0;\n-//~^ the trait bound `&usize:\n-//~| the trait bound `&usize:\n-//~| the trait bound `&usize:\n-//~| the trait bound `&usize:\n-//~| the trait bound `&usize:\n-//~| the trait bound `&usize:\n-//~| the trait bound `&usize:\n-//~| the trait bound `&usize:\n-//~| the trait bound `&usize:\n-//~| the trait bound `&usize:\n+//~^ the trait bound `usize:\n+//~| the trait bound `usize:\n+//~| the trait bound `usize:\n+//~| the trait bound `usize:\n+//~| the trait bound `usize:\n \n fn main() {}"}, {"sha": "62fd2ade1ca5c597805d3c0852e0ea556332d8bc", "filename": "src/test/run-make-fulldeps/std-core-cycle/bar.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Ftest%2Frun-make-fulldeps%2Fstd-core-cycle%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Ftest%2Frun-make-fulldeps%2Fstd-core-cycle%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fstd-core-cycle%2Fbar.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -11,16 +11,16 @@\n #![feature(allocator_api)]\n #![crate_type = \"rlib\"]\n \n-use std::heap::*;\n+use std::alloc::*;\n \n pub struct A;\n \n-unsafe impl<'a> Alloc for &'a A {\n-    unsafe fn alloc(&mut self, _: Layout) -> Result<*mut u8, AllocErr> {\n+unsafe impl GlobalAlloc for A {\n+    unsafe fn alloc(&self, _: Layout) -> *mut Opaque {\n         loop {}\n     }\n \n-    unsafe fn dealloc(&mut self, _ptr: *mut u8, _: Layout) {\n+    unsafe fn dealloc(&self, _ptr: *mut Opaque, _: Layout) {\n         loop {}\n     }\n }"}, {"sha": "38b8ab50cc7130a45bea58d347da28c44cfa5164", "filename": "src/test/run-pass/allocator-alloc-one.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Ftest%2Frun-pass%2Fallocator-alloc-one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Ftest%2Frun-pass%2Fallocator-alloc-one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator-alloc-one.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -14,8 +14,8 @@ use std::heap::{Heap, Alloc};\n \n fn main() {\n     unsafe {\n-        let ptr = Heap.alloc_one::<i32>().unwrap_or_else(|e| {\n-            Heap.oom(e)\n+        let ptr = Heap.alloc_one::<i32>().unwrap_or_else(|_| {\n+            Heap.oom()\n         });\n         *ptr.as_ptr() = 4;\n         assert_eq!(*ptr.as_ptr(), 4);"}, {"sha": "e6a2e22983b25efd4af91bae5c7edea1f785d3e8", "filename": "src/test/run-pass/allocator/auxiliary/custom.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Ftest%2Frun-pass%2Fallocator%2Fauxiliary%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Ftest%2Frun-pass%2Fallocator%2Fauxiliary%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator%2Fauxiliary%2Fcustom.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -13,18 +13,18 @@\n #![feature(heap_api, allocator_api)]\n #![crate_type = \"rlib\"]\n \n-use std::heap::{Alloc, System, AllocErr, Layout};\n+use std::heap::{GlobalAlloc, System, Layout, Opaque};\n use std::sync::atomic::{AtomicUsize, Ordering};\n \n pub struct A(pub AtomicUsize);\n \n-unsafe impl<'a> Alloc for &'a A {\n-    unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n+unsafe impl GlobalAlloc for A {\n+    unsafe fn alloc(&self, layout: Layout) -> *mut Opaque {\n         self.0.fetch_add(1, Ordering::SeqCst);\n         System.alloc(layout)\n     }\n \n-    unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout) {\n+    unsafe fn dealloc(&self, ptr: *mut Opaque, layout: Layout) {\n         self.0.fetch_add(1, Ordering::SeqCst);\n         System.dealloc(ptr, layout)\n     }"}, {"sha": "415d39a593e16b6d0254690459d62a5c84689cfc", "filename": "src/test/run-pass/allocator/custom.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -15,20 +15,20 @@\n \n extern crate helper;\n \n-use std::heap::{Heap, Alloc, System, Layout, AllocErr};\n+use std::alloc::{self, Global, Alloc, System, Layout, Opaque};\n use std::sync::atomic::{AtomicUsize, Ordering, ATOMIC_USIZE_INIT};\n \n static HITS: AtomicUsize = ATOMIC_USIZE_INIT;\n \n struct A;\n \n-unsafe impl<'a> Alloc for &'a A {\n-    unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n+unsafe impl alloc::GlobalAlloc for A {\n+    unsafe fn alloc(&self, layout: Layout) -> *mut Opaque {\n         HITS.fetch_add(1, Ordering::SeqCst);\n         System.alloc(layout)\n     }\n \n-    unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout) {\n+    unsafe fn dealloc(&self, ptr: *mut Opaque, layout: Layout) {\n         HITS.fetch_add(1, Ordering::SeqCst);\n         System.dealloc(ptr, layout)\n     }\n@@ -45,10 +45,10 @@ fn main() {\n     unsafe {\n         let layout = Layout::from_size_align(4, 2).unwrap();\n \n-        let ptr = Heap.alloc(layout.clone()).unwrap();\n+        let ptr = Global.alloc(layout.clone()).unwrap();\n         helper::work_with(&ptr);\n         assert_eq!(HITS.load(Ordering::SeqCst), n + 1);\n-        Heap.dealloc(ptr, layout.clone());\n+        Global.dealloc(ptr, layout.clone());\n         assert_eq!(HITS.load(Ordering::SeqCst), n + 2);\n \n         let s = String::with_capacity(10);"}, {"sha": "78d604a710857370e55107997ab1851bf46d8ea2", "filename": "src/test/run-pass/allocator/xcrate-use.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Ftest%2Frun-pass%2Fallocator%2Fxcrate-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Ftest%2Frun-pass%2Fallocator%2Fxcrate-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator%2Fxcrate-use.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -17,7 +17,7 @@\n extern crate custom;\n extern crate helper;\n \n-use std::heap::{Heap, Alloc, System, Layout};\n+use std::alloc::{Global, Alloc, System, Layout};\n use std::sync::atomic::{Ordering, ATOMIC_USIZE_INIT};\n \n #[global_allocator]\n@@ -28,10 +28,10 @@ fn main() {\n         let n = GLOBAL.0.load(Ordering::SeqCst);\n         let layout = Layout::from_size_align(4, 2).unwrap();\n \n-        let ptr = Heap.alloc(layout.clone()).unwrap();\n+        let ptr = Global.alloc(layout.clone()).unwrap();\n         helper::work_with(&ptr);\n         assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 1);\n-        Heap.dealloc(ptr, layout.clone());\n+        Global.dealloc(ptr, layout.clone());\n         assert_eq!(GLOBAL.0.load(Ordering::SeqCst), n + 2);\n \n         let ptr = System.alloc(layout.clone()).unwrap();"}, {"sha": "b8e844522dc8bb5a458da95463ee457aec92b08a", "filename": "src/test/run-pass/allocator/xcrate-use2.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Ftest%2Frun-pass%2Fallocator%2Fxcrate-use2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Ftest%2Frun-pass%2Fallocator%2Fxcrate-use2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator%2Fxcrate-use2.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -19,7 +19,7 @@ extern crate custom;\n extern crate custom_as_global;\n extern crate helper;\n \n-use std::heap::{Heap, Alloc, System, Layout};\n+use std::alloc::{Global, Alloc, GlobalAlloc, System, Layout};\n use std::sync::atomic::{Ordering, ATOMIC_USIZE_INIT};\n \n static GLOBAL: custom::A = custom::A(ATOMIC_USIZE_INIT);\n@@ -30,25 +30,25 @@ fn main() {\n         let layout = Layout::from_size_align(4, 2).unwrap();\n \n         // Global allocator routes to the `custom_as_global` global\n-        let ptr = Heap.alloc(layout.clone()).unwrap();\n+        let ptr = Global.alloc(layout.clone());\n         helper::work_with(&ptr);\n         assert_eq!(custom_as_global::get(), n + 1);\n-        Heap.dealloc(ptr, layout.clone());\n+        Global.dealloc(ptr, layout.clone());\n         assert_eq!(custom_as_global::get(), n + 2);\n \n         // Usage of the system allocator avoids all globals\n-        let ptr = System.alloc(layout.clone()).unwrap();\n+        let ptr = System.alloc(layout.clone());\n         helper::work_with(&ptr);\n         assert_eq!(custom_as_global::get(), n + 2);\n         System.dealloc(ptr, layout.clone());\n         assert_eq!(custom_as_global::get(), n + 2);\n \n         // Usage of our personal allocator doesn't affect other instances\n-        let ptr = (&GLOBAL).alloc(layout.clone()).unwrap();\n+        let ptr = GLOBAL.alloc(layout.clone());\n         helper::work_with(&ptr);\n         assert_eq!(custom_as_global::get(), n + 2);\n         assert_eq!(GLOBAL.0.load(Ordering::SeqCst), 1);\n-        (&GLOBAL).dealloc(ptr, layout);\n+        GLOBAL.dealloc(ptr, layout);\n         assert_eq!(custom_as_global::get(), n + 2);\n         assert_eq!(GLOBAL.0.load(Ordering::SeqCst), 2);\n     }"}, {"sha": "38cc23c16a9766a39ba4e979c14c55531ce30771", "filename": "src/test/run-pass/realloc-16687.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Ftest%2Frun-pass%2Frealloc-16687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Ftest%2Frun-pass%2Frealloc-16687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frealloc-16687.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -13,10 +13,10 @@\n // Ideally this would be revised to use no_std, but for now it serves\n // well enough to reproduce (and illustrate) the bug from #16687.\n \n-#![feature(heap_api, allocator_api)]\n+#![feature(heap_api, allocator_api, nonnull_cast)]\n \n-use std::heap::{Heap, Alloc, Layout};\n-use std::ptr;\n+use std::alloc::{Global, Alloc, Layout};\n+use std::ptr::{self, NonNull};\n \n fn main() {\n     unsafe {\n@@ -50,36 +50,36 @@ unsafe fn test_triangle() -> bool {\n             println!(\"allocate({:?})\", layout);\n         }\n \n-        let ret = Heap.alloc(layout.clone()).unwrap_or_else(|e| Heap.oom(e));\n+        let ret = Global.alloc(layout.clone()).unwrap_or_else(|_| Global.oom());\n \n         if PRINT {\n             println!(\"allocate({:?}) = {:?}\", layout, ret);\n         }\n \n-        ret\n+        ret.cast().as_ptr()\n     }\n \n     unsafe fn deallocate(ptr: *mut u8, layout: Layout) {\n         if PRINT {\n             println!(\"deallocate({:?}, {:?}\", ptr, layout);\n         }\n \n-        Heap.dealloc(ptr, layout);\n+        Global.dealloc(NonNull::new_unchecked(ptr).as_opaque(), layout);\n     }\n \n     unsafe fn reallocate(ptr: *mut u8, old: Layout, new: Layout) -> *mut u8 {\n         if PRINT {\n             println!(\"reallocate({:?}, old={:?}, new={:?})\", ptr, old, new);\n         }\n \n-        let ret = Heap.realloc(ptr, old.clone(), new.clone())\n-            .unwrap_or_else(|e| Heap.oom(e));\n+        let ret = Global.realloc(NonNull::new_unchecked(ptr).as_opaque(), old.clone(), new.size())\n+            .unwrap_or_else(|_| Global.oom());\n \n         if PRINT {\n             println!(\"reallocate({:?}, old={:?}, new={:?}) = {:?}\",\n                      ptr, old, new, ret);\n         }\n-        ret\n+        ret.cast().as_ptr()\n     }\n \n     fn idx_to_size(i: usize) -> usize { (i+1) * 10 }"}, {"sha": "3c37243c8b938e4e69ab6c8d33253760e70703a9", "filename": "src/test/run-pass/regions-mock-trans.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/99d4886ead646da864cff7963f540a44acd4af05/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d4886ead646da864cff7963f540a44acd4af05/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs?ref=99d4886ead646da864cff7963f540a44acd4af05", "patch": "@@ -13,6 +13,7 @@\n #![feature(allocator_api)]\n \n use std::heap::{Alloc, Heap, Layout};\n+use std::ptr::NonNull;\n \n struct arena(());\n \n@@ -32,8 +33,8 @@ struct Ccx {\n fn alloc<'a>(_bcx : &'a arena) -> &'a Bcx<'a> {\n     unsafe {\n         let ptr = Heap.alloc(Layout::new::<Bcx>())\n-            .unwrap_or_else(|e| Heap.oom(e));\n-        &*(ptr as *const _)\n+            .unwrap_or_else(|_| Heap.oom());\n+        &*(ptr.as_ptr() as *const _)\n     }\n }\n \n@@ -45,7 +46,7 @@ fn g(fcx : &Fcx) {\n     let bcx = Bcx { fcx: fcx };\n     let bcx2 = h(&bcx);\n     unsafe {\n-        Heap.dealloc(bcx2 as *const _ as *mut _, Layout::new::<Bcx>());\n+        Heap.dealloc(NonNull::new_unchecked(bcx2 as *const _ as *mut _), Layout::new::<Bcx>());\n     }\n }\n "}]}