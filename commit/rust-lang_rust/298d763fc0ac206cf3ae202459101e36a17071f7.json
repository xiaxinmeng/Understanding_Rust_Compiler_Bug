{"sha": "298d763fc0ac206cf3ae202459101e36a17071f7", "node_id": "C_kwDOAAsO6NoAKDI5OGQ3NjNmYzBhYzIwNmNmM2FlMjAyNDU5MTAxZTM2YTE3MDcxZjc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-25T17:39:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-25T17:39:06Z"}, "message": "Auto merge of #106121 - RalfJung:miri, r=RalfJung\n\nupdate Miri\n\nNoteworthy PRs:\n- https://github.com/rust-lang/miri/pull/2357\n- https://github.com/rust-lang/miri/pull/2646\n- https://github.com/rust-lang/miri/pull/2718\n- https://github.com/rust-lang/miri/pull/2721\n- https://github.com/rust-lang/miri/pull/2725", "tree": {"sha": "5aceafd45d368a4bd47417fd4970bcb7d4350391", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5aceafd45d368a4bd47417fd4970bcb7d4350391"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/298d763fc0ac206cf3ae202459101e36a17071f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/298d763fc0ac206cf3ae202459101e36a17071f7", "html_url": "https://github.com/rust-lang/rust/commit/298d763fc0ac206cf3ae202459101e36a17071f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/298d763fc0ac206cf3ae202459101e36a17071f7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "300aa907a682dfa492f4eb394d27f5331fba0a64", "url": "https://api.github.com/repos/rust-lang/rust/commits/300aa907a682dfa492f4eb394d27f5331fba0a64", "html_url": "https://github.com/rust-lang/rust/commit/300aa907a682dfa492f4eb394d27f5331fba0a64"}, {"sha": "d8b48d450d2ca02bac2d475129400c569baff98a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8b48d450d2ca02bac2d475129400c569baff98a", "html_url": "https://github.com/rust-lang/rust/commit/d8b48d450d2ca02bac2d475129400c569baff98a"}], "stats": {"total": 2134, "additions": 1526, "deletions": 608}, "files": [{"sha": "5b538691de183471283ff68a1da19815877cfc7b", "filename": "src/tools/miri/CONTRIBUTING.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2FCONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2FCONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2FCONTRIBUTING.md?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -232,16 +232,16 @@ You can also directly run Miri on a Rust source file:\n \n ## Advanced topic: Syncing with the rustc repo\n \n-We use the [`josh` proxy](https://github.com/josh-project/josh) to transmit\n-changes between the rustc and Miri repositories. For now, the latest git version\n-of josh needs to be built from source. This downloads and runs josh:\n+We use the [`josh` proxy](https://github.com/josh-project/josh) to transmit changes between the\n+rustc and Miri repositories.\n \n ```sh\n-git clone https://github.com/josh-project/josh\n-cd josh\n-cargo run --release -p josh-proxy -- --local=local --remote=https://github.com --no-background\n+cargo +stable install josh-proxy --git https://github.com/josh-project/josh --tag r22.12.06\n+josh-proxy --local=$HOME/.cache/josh --remote=https://github.com --no-background\n ```\n \n+This uses a directory `$HOME/.cache/josh` as a cache, to speed up repeated pulling/pushing.\n+\n ### Importing changes from the rustc repo\n \n Josh needs to be running, as described above."}, {"sha": "48581f6bbff1a7e2753ef9a1a753cfa993e3f9a9", "filename": "src/tools/miri/README.md", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2FREADME.md?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -399,6 +399,8 @@ to Miri failing to detect cases of undefined behavior in a program.\n * `-Zmiri-track-weak-memory-loads` shows a backtrace when weak memory emulation returns an outdated\n   value from a load. This can help diagnose problems that disappear under\n   `-Zmiri-disable-weak-memory-emulation`.\n+* `-Zmiri-force-page-size=<num>` overrides the default page size for an architecture, in multiples of 1k.\n+  `4` is default for most targets. This value should always be a power of 2 and nonzero.\n \n [function ABI]: https://doc.rust-lang.org/reference/items/functions.html#extern-function-qualifier\n \n@@ -574,6 +576,21 @@ extern \"Rust\" {\n \n     /// Miri-provided extern function to deallocate memory.\n     fn miri_dealloc(ptr: *mut u8, size: usize, align: usize);\n+\n+    /// Convert a path from the host Miri runs on to the target Miri interprets.\n+    /// Performs conversion of path separators as needed.\n+    ///\n+    /// Usually Miri performs this kind of conversion automatically. However, manual conversion\n+    /// might be necessary when reading an environment variable that was set on the host\n+    /// (such as TMPDIR) and using it as a target path.\n+    ///\n+    /// Only works with isolation disabled.\n+    ///\n+    /// `in` must point to a null-terminated string, and will be read as the input host path.\n+    /// `out` must point to at least `out_size` many bytes, and the result will be stored there\n+    /// with a null terminator.\n+    /// Returns 0 if the `out` buffer was large enough, and the required size otherwise.\n+    fn miri_host_to_target_path(path: *const i8, out: *mut i8, out_size: usize) -> usize;\n }\n ```\n "}, {"sha": "0c0bbbc70208e686f920353f430a3d9aee49fc68", "filename": "src/tools/miri/miri", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fmiri", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fmiri", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fmiri?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -243,7 +243,7 @@ if [ -z \"$CARGO_PROFILE_DEV_OPT_LEVEL\" ]; then\n     export CARGO_PROFILE_DEV_OPT_LEVEL=2\n fi\n # Enable rustc-specific lints (ignored without `-Zunstable-options`).\n-export RUSTFLAGS=\"-Zunstable-options -Wrustc::internal $RUSTFLAGS\"\n+export RUSTFLAGS=\"-Zunstable-options -Wrustc::internal -Wrust_2018_idioms -Wunused_lifetimes -Wsemicolon_in_expressions_from_macros $RUSTFLAGS\"\n # We set the rpath so that Miri finds the private rustc libraries it needs.\n export RUSTFLAGS=\"-C link-args=-Wl,-rpath,$LIBDIR $RUSTFLAGS\"\n "}, {"sha": "ee75e7a29324b023d056b8ff23ac1ae4ebc9daa7", "filename": "src/tools/miri/rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Frust-version", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Frust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Frust-version?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -1 +1 @@\n-203c8765ea33c65d888febe0e8219c4bb11b0d89\n+4f4d0586ad20c66a16d547581ca379beafece93a"}, {"sha": "8c01748613cf8de723387ee7455487ef882b36df", "filename": "src/tools/miri/src/bin/miri.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -512,6 +512,18 @@ fn main() {\n             };\n \n             miri_config.num_cpus = num_cpus;\n+        } else if let Some(param) = arg.strip_prefix(\"-Zmiri-force-page-size=\") {\n+            let page_size = match param.parse::<u64>() {\n+                Ok(i) =>\n+                    if i.is_power_of_two() {\n+                        i * 1024\n+                    } else {\n+                        show_error!(\"-Zmiri-force-page-size requires a power of 2: {}\", i)\n+                    },\n+                Err(err) => show_error!(\"-Zmiri-force-page-size requires a `u64`: {}\", err),\n+            };\n+\n+            miri_config.page_size = Some(page_size);\n         } else {\n             // Forward to rustc.\n             rustc_args.push(arg);"}, {"sha": "9f6cbe7f3c72fff445dbc7c906f5d57add488c46", "filename": "src/tools/miri/src/borrow_tracker/mod.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fmod.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -264,15 +264,23 @@ impl GlobalStateInner {\n \n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n-    fn retag_ptr_value(&mut self, kind: RetagKind, val: &ImmTy<'tcx, Provenance>) -> InterpResult<'tcx, ImmTy<'tcx, Provenance>> {\n+    fn retag_ptr_value(\n+        &mut self,\n+        kind: RetagKind,\n+        val: &ImmTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, ImmTy<'tcx, Provenance>> {\n         let this = self.eval_context_mut();\n         let method = this.machine.borrow_tracker.as_ref().unwrap().borrow().borrow_tracker_method;\n         match method {\n             BorrowTrackerMethod::StackedBorrows => this.sb_retag_ptr_value(kind, val),\n         }\n     }\n \n-    fn retag_place_contents(&mut self, kind: RetagKind, place: &PlaceTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n+    fn retag_place_contents(\n+        &mut self,\n+        kind: RetagKind,\n+        place: &PlaceTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let method = this.machine.borrow_tracker.as_ref().unwrap().borrow().borrow_tracker_method;\n         match method {"}, {"sha": "5f132bf11a92ae5758f5443f33af30ee371a8a61", "filename": "src/tools/miri/src/borrow_tracker/stacked_borrows/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fdiagnostics.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -462,7 +462,9 @@ impl<'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'history, 'ecx, 'mir, 'tcx> {\n             Operation::Retag(RetagOp { orig_tag, permission, new_tag, .. }) => {\n                 let permission = permission\n                     .expect(\"start_grant should set the current permission before popping a tag\");\n-                format!(\" due to {permission:?} retag from {orig_tag:?} (that retag created {new_tag:?})\")\n+                format!(\n+                    \" due to {permission:?} retag from {orig_tag:?} (that retag created {new_tag:?})\"\n+                )\n             }\n         };\n "}, {"sha": "bcdf2e751790e5bfdb385c661e344a3deace216b", "filename": "src/tools/miri/src/borrow_tracker/stacked_borrows/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -14,6 +14,7 @@ use rustc_middle::mir::{Mutability, RetagKind};\n use rustc_middle::ty::{\n     self,\n     layout::{HasParamEnv, LayoutOf},\n+    Ty,\n };\n use rustc_target::abi::{Abi, Size};\n \n@@ -64,7 +65,7 @@ impl NewPermission {\n     /// A key function: determine the permissions to grant at a retag for the given kind of\n     /// reference/pointer.\n     fn from_ref_ty<'tcx>(\n-        ty: ty::Ty<'tcx>,\n+        ty: Ty<'tcx>,\n         kind: RetagKind,\n         cx: &crate::MiriInterpCx<'_, 'tcx>,\n     ) -> Self {\n@@ -864,7 +865,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             RetagKind::FnEntry => unreachable!(),\n             RetagKind::Raw | RetagKind::Default => RetagCause::Normal,\n         };\n-        this.sb_retag_reference(&val, new_perm, retag_cause)\n+        this.sb_retag_reference(val, new_perm, retag_cause)\n     }\n \n     fn sb_retag_place_contents("}, {"sha": "9646327966896a745ab6f4decad299aaf61df112", "filename": "src/tools/miri/src/concurrency/data_race.rs", "status": "modified", "additions": 104, "deletions": 71, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -50,8 +50,10 @@ use rustc_ast::Mutability;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::mir;\n+use rustc_span::Span;\n use rustc_target::abi::{Align, Size};\n \n+use crate::diagnostics::RacingOp;\n use crate::*;\n \n use super::{\n@@ -144,8 +146,8 @@ impl ThreadClockSet {\n     /// Increment the happens-before clock at a\n     /// known index.\n     #[inline]\n-    fn increment_clock(&mut self, index: VectorIdx) {\n-        self.clock.increment_index(index);\n+    fn increment_clock(&mut self, index: VectorIdx, current_span: Span) {\n+        self.clock.increment_index(index, current_span);\n     }\n \n     /// Join the happens-before clock with that of\n@@ -356,13 +358,9 @@ impl MemoryCellClocks {\n         index: VectorIdx,\n     ) -> Result<(), DataRace> {\n         log::trace!(\"Atomic read with vectors: {:#?} :: {:#?}\", self, clocks);\n-        if self.write <= clocks.clock[self.write_index] {\n-            let atomic = self.atomic_mut();\n-            atomic.read_vector.set_at_index(&clocks.clock, index);\n-            Ok(())\n-        } else {\n-            Err(DataRace)\n-        }\n+        let atomic = self.atomic_mut();\n+        atomic.read_vector.set_at_index(&clocks.clock, index);\n+        if self.write <= clocks.clock[self.write_index] { Ok(()) } else { Err(DataRace) }\n     }\n \n     /// Detect data-races with an atomic write, either with a non-atomic read or with\n@@ -373,9 +371,9 @@ impl MemoryCellClocks {\n         index: VectorIdx,\n     ) -> Result<(), DataRace> {\n         log::trace!(\"Atomic write with vectors: {:#?} :: {:#?}\", self, clocks);\n+        let atomic = self.atomic_mut();\n+        atomic.write_vector.set_at_index(&clocks.clock, index);\n         if self.write <= clocks.clock[self.write_index] && self.read <= clocks.clock {\n-            let atomic = self.atomic_mut();\n-            atomic.write_vector.set_at_index(&clocks.clock, index);\n             Ok(())\n         } else {\n             Err(DataRace)\n@@ -386,22 +384,22 @@ impl MemoryCellClocks {\n     /// returns true if a data-race is detected.\n     fn read_race_detect(\n         &mut self,\n-        clocks: &ThreadClockSet,\n+        clocks: &mut ThreadClockSet,\n         index: VectorIdx,\n+        current_span: Span,\n     ) -> Result<(), DataRace> {\n         log::trace!(\"Unsynchronized read with vectors: {:#?} :: {:#?}\", self, clocks);\n+        if !current_span.is_dummy() {\n+            clocks.clock[index].span = current_span;\n+        }\n         if self.write <= clocks.clock[self.write_index] {\n             let race_free = if let Some(atomic) = self.atomic() {\n                 atomic.write_vector <= clocks.clock\n             } else {\n                 true\n             };\n-            if race_free {\n-                self.read.set_at_index(&clocks.clock, index);\n-                Ok(())\n-            } else {\n-                Err(DataRace)\n-            }\n+            self.read.set_at_index(&clocks.clock, index);\n+            if race_free { Ok(()) } else { Err(DataRace) }\n         } else {\n             Err(DataRace)\n         }\n@@ -411,21 +409,25 @@ impl MemoryCellClocks {\n     /// returns true if a data-race is detected.\n     fn write_race_detect(\n         &mut self,\n-        clocks: &ThreadClockSet,\n+        clocks: &mut ThreadClockSet,\n         index: VectorIdx,\n         write_type: WriteType,\n+        current_span: Span,\n     ) -> Result<(), DataRace> {\n         log::trace!(\"Unsynchronized write with vectors: {:#?} :: {:#?}\", self, clocks);\n+        if !current_span.is_dummy() {\n+            clocks.clock[index].span = current_span;\n+        }\n         if self.write <= clocks.clock[self.write_index] && self.read <= clocks.clock {\n             let race_free = if let Some(atomic) = self.atomic() {\n                 atomic.write_vector <= clocks.clock && atomic.read_vector <= clocks.clock\n             } else {\n                 true\n             };\n+            self.write = clocks.clock[index];\n+            self.write_index = index;\n+            self.write_type = write_type;\n             if race_free {\n-                self.write = clocks.clock[index];\n-                self.write_index = index;\n-                self.write_type = write_type;\n                 self.read.set_zero_vector();\n                 Ok(())\n             } else {\n@@ -621,30 +623,35 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriInterpCxExt<'mir, 'tcx> {\n     /// Update the data-race detector for an atomic fence on the current thread.\n     fn atomic_fence(&mut self, atomic: AtomicFenceOrd) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n+        let current_span = this.machine.current_span();\n         if let Some(data_race) = &mut this.machine.data_race {\n-            data_race.maybe_perform_sync_operation(&this.machine.threads, |index, mut clocks| {\n-                log::trace!(\"Atomic fence on {:?} with ordering {:?}\", index, atomic);\n-\n-                // Apply data-race detection for the current fences\n-                // this treats AcqRel and SeqCst as the same as an acquire\n-                // and release fence applied in the same timestamp.\n-                if atomic != AtomicFenceOrd::Release {\n-                    // Either Acquire | AcqRel | SeqCst\n-                    clocks.apply_acquire_fence();\n-                }\n-                if atomic != AtomicFenceOrd::Acquire {\n-                    // Either Release | AcqRel | SeqCst\n-                    clocks.apply_release_fence();\n-                }\n-                if atomic == AtomicFenceOrd::SeqCst {\n-                    data_race.last_sc_fence.borrow_mut().set_at_index(&clocks.clock, index);\n-                    clocks.fence_seqcst.join(&data_race.last_sc_fence.borrow());\n-                    clocks.write_seqcst.join(&data_race.last_sc_write.borrow());\n-                }\n+            data_race.maybe_perform_sync_operation(\n+                &this.machine.threads,\n+                current_span,\n+                |index, mut clocks| {\n+                    log::trace!(\"Atomic fence on {:?} with ordering {:?}\", index, atomic);\n+\n+                    // Apply data-race detection for the current fences\n+                    // this treats AcqRel and SeqCst as the same as an acquire\n+                    // and release fence applied in the same timestamp.\n+                    if atomic != AtomicFenceOrd::Release {\n+                        // Either Acquire | AcqRel | SeqCst\n+                        clocks.apply_acquire_fence();\n+                    }\n+                    if atomic != AtomicFenceOrd::Acquire {\n+                        // Either Release | AcqRel | SeqCst\n+                        clocks.apply_release_fence();\n+                    }\n+                    if atomic == AtomicFenceOrd::SeqCst {\n+                        data_race.last_sc_fence.borrow_mut().set_at_index(&clocks.clock, index);\n+                        clocks.fence_seqcst.join(&data_race.last_sc_fence.borrow());\n+                        clocks.write_seqcst.join(&data_race.last_sc_write.borrow());\n+                    }\n \n-                // Increment timestamp in case of release semantics.\n-                Ok(atomic != AtomicFenceOrd::Acquire)\n-            })\n+                    // Increment timestamp in case of release semantics.\n+                    Ok(atomic != AtomicFenceOrd::Acquire)\n+                },\n+            )\n         } else {\n             Ok(())\n         }\n@@ -682,6 +689,7 @@ impl VClockAlloc {\n         thread_mgr: &ThreadManager<'_, '_>,\n         len: Size,\n         kind: MemoryKind<MiriMemoryKind>,\n+        current_span: Span,\n     ) -> VClockAlloc {\n         let (alloc_timestamp, alloc_index) = match kind {\n             // User allocated and stack memory should track allocation.\n@@ -693,7 +701,8 @@ impl VClockAlloc {\n             )\n             | MemoryKind::Stack => {\n                 let (alloc_index, clocks) = global.current_thread_state(thread_mgr);\n-                let alloc_timestamp = clocks.clock[alloc_index];\n+                let mut alloc_timestamp = clocks.clock[alloc_index];\n+                alloc_timestamp.span = current_span;\n                 (alloc_timestamp, alloc_index)\n             }\n             // Other global memory should trace races but be allocated at the 0 timestamp.\n@@ -704,7 +713,7 @@ impl VClockAlloc {\n                 | MiriMemoryKind::ExternStatic\n                 | MiriMemoryKind::Tls,\n             )\n-            | MemoryKind::CallerLocation => (0, VectorIdx::MAX_INDEX),\n+            | MemoryKind::CallerLocation => (VTimestamp::ZERO, VectorIdx::MAX_INDEX),\n         };\n         VClockAlloc {\n             alloc_ranges: RefCell::new(RangeMap::new(\n@@ -735,7 +744,7 @@ impl VClockAlloc {\n                     let idx = l_remainder_slice\n                         .iter()\n                         .enumerate()\n-                        .find_map(|(idx, &r)| if r == 0 { None } else { Some(idx) })\n+                        .find_map(|(idx, &r)| if r == VTimestamp::ZERO { None } else { Some(idx) })\n                         .expect(\"Invalid VClock Invariant\");\n                     Some(idx + r_slice.len())\n                 } else {\n@@ -762,7 +771,7 @@ impl VClockAlloc {\n     ) -> InterpResult<'tcx> {\n         let (current_index, current_clocks) = global.current_thread_state(thread_mgr);\n         let write_clock;\n-        let (other_action, other_thread, _other_clock) = if range.write\n+        let (other_action, other_thread, other_clock) = if range.write\n             > current_clocks.clock[range.write_index]\n         {\n             // Convert the write action into the vector clock it\n@@ -799,14 +808,19 @@ impl VClockAlloc {\n         let other_thread_info = global.print_thread_metadata(thread_mgr, other_thread);\n \n         // Throw the data-race detection.\n-        throw_ub_format!(\n-            \"Data race detected between {} on {} and {} on {} at {:?}\",\n-            action,\n-            current_thread_info,\n-            other_action,\n-            other_thread_info,\n-            ptr_dbg,\n-        )\n+        Err(err_machine_stop!(TerminationInfo::DataRace {\n+            ptr: ptr_dbg,\n+            op1: RacingOp {\n+                action: other_action.to_string(),\n+                thread_info: other_thread_info,\n+                span: other_clock.as_slice()[other_thread.index()].span_data(),\n+            },\n+            op2: RacingOp {\n+                action: action.to_string(),\n+                thread_info: current_thread_info,\n+                span: current_clocks.clock.as_slice()[current_index.index()].span_data(),\n+            },\n+        }))?\n     }\n \n     /// Detect racing atomic read and writes (not data races)\n@@ -840,12 +854,14 @@ impl VClockAlloc {\n         range: AllocRange,\n         machine: &MiriMachine<'_, '_>,\n     ) -> InterpResult<'tcx> {\n+        let current_span = machine.current_span();\n         let global = machine.data_race.as_ref().unwrap();\n         if global.race_detecting() {\n-            let (index, clocks) = global.current_thread_state(&machine.threads);\n+            let (index, mut clocks) = global.current_thread_state_mut(&machine.threads);\n             let mut alloc_ranges = self.alloc_ranges.borrow_mut();\n             for (offset, range) in alloc_ranges.iter_mut(range.start, range.size) {\n-                if let Err(DataRace) = range.read_race_detect(&clocks, index) {\n+                if let Err(DataRace) = range.read_race_detect(&mut clocks, index, current_span) {\n+                    drop(clocks);\n                     // Report data-race.\n                     return Self::report_data_race(\n                         global,\n@@ -871,11 +887,15 @@ impl VClockAlloc {\n         write_type: WriteType,\n         machine: &mut MiriMachine<'_, '_>,\n     ) -> InterpResult<'tcx> {\n+        let current_span = machine.current_span();\n         let global = machine.data_race.as_mut().unwrap();\n         if global.race_detecting() {\n-            let (index, clocks) = global.current_thread_state(&machine.threads);\n+            let (index, mut clocks) = global.current_thread_state_mut(&machine.threads);\n             for (offset, range) in self.alloc_ranges.get_mut().iter_mut(range.start, range.size) {\n-                if let Err(DataRace) = range.write_race_detect(&clocks, index, write_type) {\n+                if let Err(DataRace) =\n+                    range.write_race_detect(&mut clocks, index, write_type, current_span)\n+                {\n+                    drop(clocks);\n                     // Report data-race\n                     return Self::report_data_race(\n                         global,\n@@ -1100,9 +1120,11 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: MiriInterpCxExt<'mir, 'tcx> {\n                     size.bytes()\n                 );\n \n+                let current_span = this.machine.current_span();\n                 // Perform the atomic operation.\n                 data_race.maybe_perform_sync_operation(\n                     &this.machine.threads,\n+                    current_span,\n                     |index, mut clocks| {\n                         for (offset, range) in\n                             alloc_meta.alloc_ranges.borrow_mut().iter_mut(base_offset, size)\n@@ -1303,7 +1325,12 @@ impl GlobalState {\n     // Hook for thread creation, enabled multi-threaded execution and marks\n     // the current thread timestamp as happening-before the current thread.\n     #[inline]\n-    pub fn thread_created(&mut self, thread_mgr: &ThreadManager<'_, '_>, thread: ThreadId) {\n+    pub fn thread_created(\n+        &mut self,\n+        thread_mgr: &ThreadManager<'_, '_>,\n+        thread: ThreadId,\n+        current_span: Span,\n+    ) {\n         let current_index = self.current_index(thread_mgr);\n \n         // Enable multi-threaded execution, there are now at least two threads\n@@ -1320,7 +1347,7 @@ impl GlobalState {\n             // Now re-configure the re-use candidate, increment the clock\n             // for the new sync use of the vector.\n             let vector_clocks = self.vector_clocks.get_mut();\n-            vector_clocks[reuse_index].increment_clock(reuse_index);\n+            vector_clocks[reuse_index].increment_clock(reuse_index, current_span);\n \n             // Locate the old thread the vector was associated with and update\n             // it to represent the new thread instead.\n@@ -1360,8 +1387,8 @@ impl GlobalState {\n \n         // Advance both threads after the synchronized operation.\n         // Both operations are considered to have release semantics.\n-        current.increment_clock(current_index);\n-        created.increment_clock(created_index);\n+        current.increment_clock(current_index, current_span);\n+        created.increment_clock(created_index, current_span);\n     }\n \n     /// Hook on a thread join to update the implicit happens-before relation between the joined\n@@ -1427,13 +1454,13 @@ impl GlobalState {\n     /// This should be called strictly before any calls to\n     /// `thread_joined`.\n     #[inline]\n-    pub fn thread_terminated(&mut self, thread_mgr: &ThreadManager<'_, '_>) {\n+    pub fn thread_terminated(&mut self, thread_mgr: &ThreadManager<'_, '_>, current_span: Span) {\n         let current_index = self.current_index(thread_mgr);\n \n         // Increment the clock to a unique termination timestamp.\n         let vector_clocks = self.vector_clocks.get_mut();\n         let current_clocks = &mut vector_clocks[current_index];\n-        current_clocks.increment_clock(current_index);\n+        current_clocks.increment_clock(current_index, current_span);\n \n         // Load the current thread id for the executing vector.\n         let vector_info = self.vector_info.get_mut();\n@@ -1462,13 +1489,14 @@ impl GlobalState {\n     fn maybe_perform_sync_operation<'tcx>(\n         &self,\n         thread_mgr: &ThreadManager<'_, '_>,\n+        current_span: Span,\n         op: impl FnOnce(VectorIdx, RefMut<'_, ThreadClockSet>) -> InterpResult<'tcx, bool>,\n     ) -> InterpResult<'tcx> {\n         if self.multi_threaded.get() {\n             let (index, clocks) = self.current_thread_state_mut(thread_mgr);\n             if op(index, clocks)? {\n                 let (_, mut clocks) = self.current_thread_state_mut(thread_mgr);\n-                clocks.increment_clock(index);\n+                clocks.increment_clock(index, current_span);\n             }\n         }\n         Ok(())\n@@ -1501,10 +1529,10 @@ impl GlobalState {\n     /// since an acquire operation should have occurred before, however\n     /// for futex & condvar operations this is not the case and this\n     /// operation must be used.\n-    pub fn validate_lock_release(&self, lock: &mut VClock, thread: ThreadId) {\n+    pub fn validate_lock_release(&self, lock: &mut VClock, thread: ThreadId, current_span: Span) {\n         let (index, mut clocks) = self.load_thread_state_mut(thread);\n         lock.clone_from(&clocks.clock);\n-        clocks.increment_clock(index);\n+        clocks.increment_clock(index, current_span);\n     }\n \n     /// Release a lock handle, express that this happens-before\n@@ -1514,10 +1542,15 @@ impl GlobalState {\n     /// For normal locks this should be equivalent to `validate_lock_release`.\n     /// This function only exists for joining over the set of concurrent readers\n     /// in a read-write lock and should not be used for anything else.\n-    pub fn validate_lock_release_shared(&self, lock: &mut VClock, thread: ThreadId) {\n+    pub fn validate_lock_release_shared(\n+        &self,\n+        lock: &mut VClock,\n+        thread: ThreadId,\n+        current_span: Span,\n+    ) {\n         let (index, mut clocks) = self.load_thread_state_mut(thread);\n         lock.join(&clocks.clock);\n-        clocks.increment_clock(index);\n+        clocks.increment_clock(index, current_span);\n     }\n \n     /// Load the vector index used by the given thread as well as the set of vector clocks"}, {"sha": "867683d3552107d6f52db98d275e9c82c6df66f4", "filename": "src/tools/miri/src/concurrency/init_once.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Finit_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Finit_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Finit_once.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -160,6 +160,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn init_once_complete(&mut self, id: InitOnceId) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let current_thread = this.get_active_thread();\n+        let current_span = this.machine.current_span();\n         let init_once = &mut this.machine.threads.sync.init_onces[id];\n \n         assert_eq!(\n@@ -172,7 +173,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         // Each complete happens-before the end of the wait\n         if let Some(data_race) = &this.machine.data_race {\n-            data_race.validate_lock_release(&mut init_once.data_race, current_thread);\n+            data_race.validate_lock_release(&mut init_once.data_race, current_thread, current_span);\n         }\n \n         // Wake up everyone.\n@@ -188,6 +189,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn init_once_fail(&mut self, id: InitOnceId) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let current_thread = this.get_active_thread();\n+        let current_span = this.machine.current_span();\n         let init_once = &mut this.machine.threads.sync.init_onces[id];\n         assert_eq!(\n             init_once.status,\n@@ -197,7 +199,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         // Each complete happens-before the end of the wait\n         if let Some(data_race) = &this.machine.data_race {\n-            data_race.validate_lock_release(&mut init_once.data_race, current_thread);\n+            data_race.validate_lock_release(&mut init_once.data_race, current_thread, current_span);\n         }\n \n         // Wake up one waiting thread, so they can go ahead and try to init this."}, {"sha": "b962052397498b9869a81ae65e2b5ba9d3b0e802", "filename": "src/tools/miri/src/concurrency/sync.rs", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -359,6 +359,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     /// return `None`.\n     fn mutex_unlock(&mut self, id: MutexId, expected_owner: ThreadId) -> Option<usize> {\n         let this = self.eval_context_mut();\n+        let current_span = this.machine.current_span();\n         let mutex = &mut this.machine.threads.sync.mutexes[id];\n         if let Some(current_owner) = mutex.owner {\n             // Mutex is locked.\n@@ -375,7 +376,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 // The mutex is completely unlocked. Try transfering ownership\n                 // to another thread.\n                 if let Some(data_race) = &this.machine.data_race {\n-                    data_race.validate_lock_release(&mut mutex.data_race, current_owner);\n+                    data_race.validate_lock_release(\n+                        &mut mutex.data_race,\n+                        current_owner,\n+                        current_span,\n+                    );\n                 }\n                 this.mutex_dequeue_and_lock(id);\n             }\n@@ -454,6 +459,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     /// Returns `true` if succeeded, `false` if this `reader` did not hold the lock.\n     fn rwlock_reader_unlock(&mut self, id: RwLockId, reader: ThreadId) -> bool {\n         let this = self.eval_context_mut();\n+        let current_span = this.machine.current_span();\n         let rwlock = &mut this.machine.threads.sync.rwlocks[id];\n         match rwlock.readers.entry(reader) {\n             Entry::Occupied(mut entry) => {\n@@ -470,7 +476,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             Entry::Vacant(_) => return false, // we did not even own this lock\n         }\n         if let Some(data_race) = &this.machine.data_race {\n-            data_race.validate_lock_release_shared(&mut rwlock.data_race_reader, reader);\n+            data_race.validate_lock_release_shared(\n+                &mut rwlock.data_race_reader,\n+                reader,\n+                current_span,\n+            );\n         }\n \n         // The thread was a reader. If the lock is not held any more, give it to a writer.\n@@ -511,6 +521,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     #[inline]\n     fn rwlock_writer_unlock(&mut self, id: RwLockId, expected_writer: ThreadId) -> bool {\n         let this = self.eval_context_mut();\n+        let current_span = this.machine.current_span();\n         let rwlock = &mut this.machine.threads.sync.rwlocks[id];\n         if let Some(current_writer) = rwlock.writer {\n             if current_writer != expected_writer {\n@@ -523,8 +534,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             //  since this writer happens-before both the union of readers once they are finished\n             //  and the next writer\n             if let Some(data_race) = &this.machine.data_race {\n-                data_race.validate_lock_release(&mut rwlock.data_race, current_writer);\n-                data_race.validate_lock_release(&mut rwlock.data_race_reader, current_writer);\n+                data_race.validate_lock_release(\n+                    &mut rwlock.data_race,\n+                    current_writer,\n+                    current_span,\n+                );\n+                data_race.validate_lock_release(\n+                    &mut rwlock.data_race_reader,\n+                    current_writer,\n+                    current_span,\n+                );\n             }\n             // The thread was a writer.\n             //\n@@ -595,12 +614,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn condvar_signal(&mut self, id: CondvarId) -> Option<(ThreadId, CondvarLock)> {\n         let this = self.eval_context_mut();\n         let current_thread = this.get_active_thread();\n+        let current_span = this.machine.current_span();\n         let condvar = &mut this.machine.threads.sync.condvars[id];\n         let data_race = &this.machine.data_race;\n \n         // Each condvar signal happens-before the end of the condvar wake\n         if let Some(data_race) = data_race {\n-            data_race.validate_lock_release(&mut condvar.data_race, current_thread);\n+            data_race.validate_lock_release(&mut condvar.data_race, current_thread, current_span);\n         }\n         condvar.waiters.pop_front().map(|waiter| {\n             if let Some(data_race) = data_race {\n@@ -628,12 +648,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn futex_wake(&mut self, addr: u64, bitset: u32) -> Option<ThreadId> {\n         let this = self.eval_context_mut();\n         let current_thread = this.get_active_thread();\n+        let current_span = this.machine.current_span();\n         let futex = &mut this.machine.threads.sync.futexes.get_mut(&addr)?;\n         let data_race = &this.machine.data_race;\n \n         // Each futex-wake happens-before the end of the futex wait\n         if let Some(data_race) = data_race {\n-            data_race.validate_lock_release(&mut futex.data_race, current_thread);\n+            data_race.validate_lock_release(&mut futex.data_race, current_thread, current_span);\n         }\n \n         // Wake up the first thread in the queue that matches any of the bits in the bitset."}, {"sha": "9173eb3c4ee663f57e7527b3dccf4968d7240f84", "filename": "src/tools/miri/src/concurrency/thread.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -13,6 +13,7 @@ use rustc_hir::def_id::DefId;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::mir::Mutability;\n use rustc_middle::ty::layout::TyAndLayout;\n+use rustc_span::Span;\n use rustc_target::spec::abi::Abi;\n \n use crate::concurrency::data_race;\n@@ -617,6 +618,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     fn thread_terminated(\n         &mut self,\n         mut data_race: Option<&mut data_race::GlobalState>,\n+        current_span: Span,\n     ) -> Vec<Pointer<Provenance>> {\n         let mut free_tls_statics = Vec::new();\n         {\n@@ -634,7 +636,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n         }\n         // Set the thread into a terminated state in the data-race detector.\n         if let Some(ref mut data_race) = data_race {\n-            data_race.thread_terminated(self);\n+            data_race.thread_terminated(self, current_span);\n         }\n         // Check if we need to unblock any threads.\n         let mut joined_threads = vec![]; // store which threads joined, we'll need it\n@@ -813,8 +815,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             let mut state = tls::TlsDtorsState::default();\n             Box::new(move |m| state.on_stack_empty(m))\n         });\n+        let current_span = this.machine.current_span();\n         if let Some(data_race) = &mut this.machine.data_race {\n-            data_race.thread_created(&this.machine.threads, new_thread_id);\n+            data_race.thread_created(&this.machine.threads, new_thread_id, current_span);\n         }\n \n         // Write the current thread-id, switch to the next thread later\n@@ -1041,7 +1044,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         assert!(thread.stack.is_empty(), \"only threads with an empty stack can be terminated\");\n         thread.state = ThreadState::Terminated;\n \n-        for ptr in this.machine.threads.thread_terminated(this.machine.data_race.as_mut()) {\n+        let current_span = this.machine.current_span();\n+        for ptr in\n+            this.machine.threads.thread_terminated(this.machine.data_race.as_mut(), current_span)\n+        {\n             this.deallocate_ptr(ptr.into(), None, MiriMemoryKind::Tls.into())?;\n         }\n         Ok(())"}, {"sha": "ab4764dd1c87a84cf4df94d7a368c98e654b9227", "filename": "src/tools/miri/src/concurrency/vector_clock.rs", "status": "modified", "additions": 74, "deletions": 16, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fvector_clock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fvector_clock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fvector_clock.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -1,6 +1,11 @@\n use rustc_index::vec::Idx;\n+use rustc_span::{Span, SpanData, DUMMY_SP};\n use smallvec::SmallVec;\n-use std::{cmp::Ordering, fmt::Debug, ops::Index};\n+use std::{\n+    cmp::Ordering,\n+    fmt::Debug,\n+    ops::{Index, IndexMut},\n+};\n \n /// A vector clock index, this is associated with a thread id\n /// but in some cases one vector index may be shared with\n@@ -40,9 +45,42 @@ impl From<u32> for VectorIdx {\n /// clock vectors larger than this will be stored on the heap\n const SMALL_VECTOR: usize = 4;\n \n-/// The type of the time-stamps recorded in the data-race detector\n-/// set to a type of unsigned integer\n-pub type VTimestamp = u32;\n+/// The time-stamps recorded in the data-race detector consist of both\n+/// a 32-bit unsigned integer which is the actual timestamp, and a `Span`\n+/// so that diagnostics can report what code was responsible for an operation.\n+#[derive(Clone, Copy, Debug)]\n+pub struct VTimestamp {\n+    time: u32,\n+    pub span: Span,\n+}\n+\n+impl VTimestamp {\n+    pub const ZERO: VTimestamp = VTimestamp { time: 0, span: DUMMY_SP };\n+\n+    pub fn span_data(&self) -> SpanData {\n+        self.span.data()\n+    }\n+}\n+\n+impl PartialEq for VTimestamp {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.time == other.time\n+    }\n+}\n+\n+impl Eq for VTimestamp {}\n+\n+impl PartialOrd for VTimestamp {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+impl Ord for VTimestamp {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        self.time.cmp(&other.time)\n+    }\n+}\n \n /// A vector clock for detecting data-races, this is conceptually\n /// a map from a vector index (and thus a thread id) to a timestamp.\n@@ -62,7 +100,7 @@ impl VClock {\n     /// for a value at the given index\n     pub fn new_with_index(index: VectorIdx, timestamp: VTimestamp) -> VClock {\n         let len = index.index() + 1;\n-        let mut vec = smallvec::smallvec![0; len];\n+        let mut vec = smallvec::smallvec![VTimestamp::ZERO; len];\n         vec[index.index()] = timestamp;\n         VClock(vec)\n     }\n@@ -79,7 +117,7 @@ impl VClock {\n     #[inline]\n     fn get_mut_with_min_len(&mut self, min_len: usize) -> &mut [VTimestamp] {\n         if self.0.len() < min_len {\n-            self.0.resize(min_len, 0);\n+            self.0.resize(min_len, VTimestamp::ZERO);\n         }\n         assert!(self.0.len() >= min_len);\n         self.0.as_mut_slice()\n@@ -88,11 +126,14 @@ impl VClock {\n     /// Increment the vector clock at a known index\n     /// this will panic if the vector index overflows\n     #[inline]\n-    pub fn increment_index(&mut self, idx: VectorIdx) {\n+    pub fn increment_index(&mut self, idx: VectorIdx, current_span: Span) {\n         let idx = idx.index();\n         let mut_slice = self.get_mut_with_min_len(idx + 1);\n         let idx_ref = &mut mut_slice[idx];\n-        *idx_ref = idx_ref.checked_add(1).expect(\"Vector clock overflow\")\n+        idx_ref.time = idx_ref.time.checked_add(1).expect(\"Vector clock overflow\");\n+        if !current_span.is_dummy() {\n+            idx_ref.span = current_span;\n+        }\n     }\n \n     // Join the two vector-clocks together, this\n@@ -102,14 +143,23 @@ impl VClock {\n         let rhs_slice = other.as_slice();\n         let lhs_slice = self.get_mut_with_min_len(rhs_slice.len());\n         for (l, &r) in lhs_slice.iter_mut().zip(rhs_slice.iter()) {\n+            let l_span = l.span;\n+            let r_span = r.span;\n             *l = r.max(*l);\n+            l.span = l.span.substitute_dummy(r_span).substitute_dummy(l_span);\n         }\n     }\n \n     /// Set the element at the current index of the vector\n     pub fn set_at_index(&mut self, other: &Self, idx: VectorIdx) {\n         let mut_slice = self.get_mut_with_min_len(idx.index() + 1);\n+\n+        let prev_span = mut_slice[idx.index()].span;\n+\n         mut_slice[idx.index()] = other[idx];\n+\n+        let span = &mut mut_slice[idx.index()].span;\n+        *span = span.substitute_dummy(prev_span);\n     }\n \n     /// Set the vector to the all-zero vector\n@@ -313,7 +363,14 @@ impl Index<VectorIdx> for VClock {\n \n     #[inline]\n     fn index(&self, index: VectorIdx) -> &VTimestamp {\n-        self.as_slice().get(index.to_u32() as usize).unwrap_or(&0)\n+        self.as_slice().get(index.to_u32() as usize).unwrap_or(&VTimestamp::ZERO)\n+    }\n+}\n+\n+impl IndexMut<VectorIdx> for VClock {\n+    #[inline]\n+    fn index_mut(&mut self, index: VectorIdx) -> &mut VTimestamp {\n+        self.0.as_mut_slice().get_mut(index.to_u32() as usize).unwrap()\n     }\n }\n \n@@ -324,20 +381,21 @@ impl Index<VectorIdx> for VClock {\n mod tests {\n \n     use super::{VClock, VTimestamp, VectorIdx};\n+    use rustc_span::DUMMY_SP;\n     use std::cmp::Ordering;\n \n     #[test]\n     fn test_equal() {\n         let mut c1 = VClock::default();\n         let mut c2 = VClock::default();\n         assert_eq!(c1, c2);\n-        c1.increment_index(VectorIdx(5));\n+        c1.increment_index(VectorIdx(5), DUMMY_SP);\n         assert_ne!(c1, c2);\n-        c2.increment_index(VectorIdx(53));\n+        c2.increment_index(VectorIdx(53), DUMMY_SP);\n         assert_ne!(c1, c2);\n-        c1.increment_index(VectorIdx(53));\n+        c1.increment_index(VectorIdx(53), DUMMY_SP);\n         assert_ne!(c1, c2);\n-        c2.increment_index(VectorIdx(5));\n+        c2.increment_index(VectorIdx(5), DUMMY_SP);\n         assert_eq!(c1, c2);\n     }\n \n@@ -386,14 +444,14 @@ mod tests {\n         );\n     }\n \n-    fn from_slice(mut slice: &[VTimestamp]) -> VClock {\n+    fn from_slice(mut slice: &[u32]) -> VClock {\n         while let Some(0) = slice.last() {\n             slice = &slice[..slice.len() - 1]\n         }\n-        VClock(smallvec::SmallVec::from_slice(slice))\n+        VClock(slice.iter().copied().map(|time| VTimestamp { time, span: DUMMY_SP }).collect())\n     }\n \n-    fn assert_order(l: &[VTimestamp], r: &[VTimestamp], o: Option<Ordering>) {\n+    fn assert_order(l: &[u32], r: &[u32], o: Option<Ordering>) {\n         let l = from_slice(l);\n         let r = from_slice(r);\n "}, {"sha": "2a48c9e6cd0158e7bd09680a03baf448f3c8f097", "filename": "src/tools/miri/src/concurrency/weak_memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fweak_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fweak_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fweak_memory.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -258,7 +258,7 @@ impl<'mir, 'tcx: 'mir> StoreBuffer {\n             // The thread index and timestamp of the initialisation write\n             // are never meaningfully used, so it's fine to leave them as 0\n             store_index: VectorIdx::from(0),\n-            timestamp: 0,\n+            timestamp: VTimestamp::ZERO,\n             val: init,\n             is_seqcst: false,\n             load_info: RefCell::new(LoadInfo::default()),"}, {"sha": "035c0e6423381fb3f1a3c63ccb2b79add3a6152b", "filename": "src/tools/miri/src/diagnostics.rs", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -35,6 +35,17 @@ pub enum TerminationInfo {\n         link_name: Symbol,\n         span: SpanData,\n     },\n+    DataRace {\n+        op1: RacingOp,\n+        op2: RacingOp,\n+        ptr: Pointer,\n+    },\n+}\n+\n+pub struct RacingOp {\n+    pub action: String,\n+    pub thread_info: String,\n+    pub span: SpanData,\n }\n \n impl fmt::Display for TerminationInfo {\n@@ -55,6 +66,12 @@ impl fmt::Display for TerminationInfo {\n                 write!(f, \"multiple definitions of symbol `{link_name}`\"),\n             SymbolShimClashing { link_name, .. } =>\n                 write!(f, \"found `{link_name}` symbol definition that clashes with a built-in shim\",),\n+            DataRace { ptr, op1, op2 } =>\n+                write!(\n+                    f,\n+                    \"Data race detected between (1) {} on {} and (2) {} on {} at {ptr:?}. (2) just happened here\",\n+                    op1.action, op1.thread_info, op2.action, op2.thread_info\n+                ),\n         }\n     }\n }\n@@ -167,7 +184,7 @@ pub fn report_error<'tcx, 'mir>(\n             Abort(_) => Some(\"abnormal termination\"),\n             UnsupportedInIsolation(_) | Int2PtrWithStrictProvenance =>\n                 Some(\"unsupported operation\"),\n-            StackedBorrowsUb { .. } => Some(\"Undefined Behavior\"),\n+            StackedBorrowsUb { .. } | DataRace { .. } => Some(\"Undefined Behavior\"),\n             Deadlock => Some(\"deadlock\"),\n             MultipleSymbolDefinitions { .. } | SymbolShimClashing { .. } => None,\n         };\n@@ -205,6 +222,12 @@ pub fn report_error<'tcx, 'mir>(\n                 vec![(Some(*span), format!(\"the `{link_name}` symbol is defined here\"))],\n             Int2PtrWithStrictProvenance =>\n                 vec![(None, format!(\"use Strict Provenance APIs (https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance, https://crates.io/crates/sptr) instead\"))],\n+            DataRace { op1, .. } =>\n+                vec![\n+                    (Some(op1.span), format!(\"and (1) occurred earlier here\")),\n+                    (None, format!(\"this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\")),\n+                    (None, format!(\"see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\")),\n+                ],\n             _ => vec![],\n         };\n         (title, helps)\n@@ -339,23 +362,26 @@ fn report_msg<'tcx>(\n     }\n \n     // Show note and help messages.\n+    let mut extra_span = false;\n     for (span_data, note) in &notes {\n         if let Some(span_data) = span_data {\n             err.span_note(span_data.span(), note);\n+            extra_span = true;\n         } else {\n             err.note(note);\n         }\n     }\n     for (span_data, help) in &helps {\n         if let Some(span_data) = span_data {\n             err.span_help(span_data.span(), help);\n+            extra_span = true;\n         } else {\n             err.help(help);\n         }\n     }\n     if notes.len() + helps.len() > 0 {\n         // Add visual separator before backtrace.\n-        err.note(\"BACKTRACE:\");\n+        err.note(if extra_span { \"BACKTRACE (of the first span):\" } else { \"BACKTRACE:\" });\n     }\n     // Add backtrace\n     for (idx, frame_info) in stacktrace.iter().enumerate() {\n@@ -395,7 +421,8 @@ impl<'mir, 'tcx> MiriMachine<'mir, 'tcx> {\n \n         let msg = match &e {\n             CreatedPointerTag(tag, None, _) => format!(\"created base tag {tag:?}\"),\n-            CreatedPointerTag(tag, Some(perm), None) => format!(\"created {tag:?} with {perm} derived from unknown tag\"),\n+            CreatedPointerTag(tag, Some(perm), None) =>\n+                format!(\"created {tag:?} with {perm} derived from unknown tag\"),\n             CreatedPointerTag(tag, Some(perm), Some((alloc_id, range, orig_tag))) =>\n                 format!(\n                     \"created tag {tag:?} with {perm} at {alloc_id:?}{range:?} derived from {orig_tag:?}\""}, {"sha": "6c87dad1f1f4ab0a83e30a078854c13592a3c0dd", "filename": "src/tools/miri/src/eval.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -143,6 +143,8 @@ pub struct MiriConfig {\n     pub gc_interval: u32,\n     /// The number of CPUs to be reported by miri.\n     pub num_cpus: u32,\n+    /// Requires Miri to emulate pages of a certain size\n+    pub page_size: Option<u64>,\n }\n \n impl Default for MiriConfig {\n@@ -176,6 +178,7 @@ impl Default for MiriConfig {\n             external_so_file: None,\n             gc_interval: 10_000,\n             num_cpus: 1,\n+            page_size: None,\n         }\n     }\n }"}, {"sha": "c11c6104c2843474c4a253216daedc471d66ebb0", "filename": "src/tools/miri/src/helpers.rs", "status": "modified", "additions": 40, "deletions": 18, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -138,55 +138,77 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             .unwrap_or_else(|| panic!(\"failed to find required Rust item: {path:?}\"))\n     }\n \n-    /// Evaluates the scalar at the specified path. Returns Some(val)\n-    /// if the path could be resolved, and None otherwise\n-    fn eval_path_scalar(&self, path: &[&str]) -> InterpResult<'tcx, Scalar<Provenance>> {\n+    /// Evaluates the scalar at the specified path.\n+    fn eval_path_scalar(&self, path: &[&str]) -> Scalar<Provenance> {\n         let this = self.eval_context_ref();\n         let instance = this.resolve_path(path, Namespace::ValueNS);\n         let cid = GlobalId { instance, promoted: None };\n         // We don't give a span -- this isn't actually used directly by the program anyway.\n-        let const_val = this.eval_global(cid, None)?;\n+        let const_val = this\n+            .eval_global(cid, None)\n+            .unwrap_or_else(|err| panic!(\"failed to evaluate required Rust item: {path:?}\\n{err}\"));\n         this.read_scalar(&const_val.into())\n+            .unwrap_or_else(|err| panic!(\"failed to read required Rust item: {path:?}\\n{err}\"))\n     }\n \n     /// Helper function to get a `libc` constant as a `Scalar`.\n-    fn eval_libc(&self, name: &str) -> InterpResult<'tcx, Scalar<Provenance>> {\n+    fn eval_libc(&self, name: &str) -> Scalar<Provenance> {\n         self.eval_path_scalar(&[\"libc\", name])\n     }\n \n     /// Helper function to get a `libc` constant as an `i32`.\n-    fn eval_libc_i32(&self, name: &str) -> InterpResult<'tcx, i32> {\n+    fn eval_libc_i32(&self, name: &str) -> i32 {\n         // TODO: Cache the result.\n-        self.eval_libc(name)?.to_i32()\n+        self.eval_libc(name).to_i32().unwrap_or_else(|_err| {\n+            panic!(\"required libc item has unexpected type (not `i32`): {name}\")\n+        })\n+    }\n+\n+    /// Helper function to get a `libc` constant as an `u32`.\n+    fn eval_libc_u32(&self, name: &str) -> u32 {\n+        // TODO: Cache the result.\n+        self.eval_libc(name).to_u32().unwrap_or_else(|_err| {\n+            panic!(\"required libc item has unexpected type (not `u32`): {name}\")\n+        })\n     }\n \n     /// Helper function to get a `windows` constant as a `Scalar`.\n-    fn eval_windows(&self, module: &str, name: &str) -> InterpResult<'tcx, Scalar<Provenance>> {\n+    fn eval_windows(&self, module: &str, name: &str) -> Scalar<Provenance> {\n         self.eval_context_ref().eval_path_scalar(&[\"std\", \"sys\", \"windows\", module, name])\n     }\n \n+    /// Helper function to get a `windows` constant as a `u32`.\n+    fn eval_windows_u32(&self, module: &str, name: &str) -> u32 {\n+        // TODO: Cache the result.\n+        self.eval_windows(module, name).to_u32().unwrap_or_else(|_err| {\n+            panic!(\"required Windows item has unexpected type (not `u32`): {module}::{name}\")\n+        })\n+    }\n+\n     /// Helper function to get a `windows` constant as a `u64`.\n-    fn eval_windows_u64(&self, module: &str, name: &str) -> InterpResult<'tcx, u64> {\n+    fn eval_windows_u64(&self, module: &str, name: &str) -> u64 {\n         // TODO: Cache the result.\n-        self.eval_windows(module, name)?.to_u64()\n+        self.eval_windows(module, name).to_u64().unwrap_or_else(|_err| {\n+            panic!(\"required Windows item has unexpected type (not `u64`): {module}::{name}\")\n+        })\n     }\n \n     /// Helper function to get the `TyAndLayout` of a `libc` type\n-    fn libc_ty_layout(&self, name: &str) -> InterpResult<'tcx, TyAndLayout<'tcx>> {\n+    fn libc_ty_layout(&self, name: &str) -> TyAndLayout<'tcx> {\n         let this = self.eval_context_ref();\n         let ty = this\n             .resolve_path(&[\"libc\", name], Namespace::TypeNS)\n             .ty(*this.tcx, ty::ParamEnv::reveal_all());\n-        this.layout_of(ty)\n+        this.layout_of(ty).unwrap()\n     }\n \n     /// Helper function to get the `TyAndLayout` of a `windows` type\n-    fn windows_ty_layout(&self, name: &str) -> InterpResult<'tcx, TyAndLayout<'tcx>> {\n+    fn windows_ty_layout(&self, name: &str) -> TyAndLayout<'tcx> {\n         let this = self.eval_context_ref();\n         let ty = this\n             .resolve_path(&[\"std\", \"sys\", \"windows\", \"c\", name], Namespace::TypeNS)\n             .ty(*this.tcx, ty::ParamEnv::reveal_all());\n-        this.layout_of(ty)\n+        this.layout_of(ty).unwrap()\n     }\n \n     /// Project to the given *named* field of the mplace (which must be a struct or union type).\n@@ -609,14 +631,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         if target.families.iter().any(|f| f == \"unix\") {\n             for &(name, kind) in UNIX_IO_ERROR_TABLE {\n                 if err_kind == kind {\n-                    return this.eval_libc(name);\n+                    return Ok(this.eval_libc(name));\n                 }\n             }\n             throw_unsup_format!(\"io error {:?} cannot be translated into a raw os error\", err_kind)\n         } else if target.families.iter().any(|f| f == \"windows\") {\n             // FIXME: we have to finish implementing the Windows equivalent of this.\n             use std::io::ErrorKind::*;\n-            this.eval_windows(\n+            Ok(this.eval_windows(\n                 \"c\",\n                 match err_kind {\n                     NotFound => \"ERROR_FILE_NOT_FOUND\",\n@@ -627,7 +649,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                             err_kind\n                         ),\n                 },\n-            )\n+            ))\n         } else {\n             throw_unsup_format!(\n                 \"converting io::Error into errnum is unsupported for OS {}\",\n@@ -647,7 +669,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         if target.families.iter().any(|f| f == \"unix\") {\n             let errnum = errnum.to_i32()?;\n             for &(name, kind) in UNIX_IO_ERROR_TABLE {\n-                if errnum == this.eval_libc_i32(name)? {\n+                if errnum == this.eval_libc_i32(name) {\n                     return Ok(Some(kind));\n                 }\n             }"}, {"sha": "618cf9df7f3f0f54e9e28dc71046965d3e3fc5cb", "filename": "src/tools/miri/src/intptrcast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fintptrcast.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -51,12 +51,12 @@ impl VisitTags for GlobalStateInner {\n }\n \n impl GlobalStateInner {\n-    pub fn new(config: &MiriConfig) -> Self {\n+    pub fn new(config: &MiriConfig, stack_addr: u64) -> Self {\n         GlobalStateInner {\n             int_to_ptr_map: Vec::default(),\n             base_addr: FxHashMap::default(),\n             exposed: FxHashSet::default(),\n-            next_base_addr: STACK_ADDR,\n+            next_base_addr: stack_addr,\n             provenance_mode: config.provenance_mode,\n         }\n     }"}, {"sha": "97750cb78cdcb9ae19fea8ce13521c081aa3c519", "filename": "src/tools/miri/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -27,6 +27,7 @@\n     clippy::single_element_loop,\n     clippy::needless_return,\n     clippy::bool_to_int_with_if,\n+    clippy::box_default,\n     // We are not implementing queries here so it's fine\n     rustc::potential_query_instability\n )]\n@@ -107,7 +108,7 @@ pub use crate::helpers::EvalContextExt as _;\n pub use crate::intptrcast::ProvenanceMode;\n pub use crate::machine::{\n     AllocExtra, FrameExtra, MiriInterpCx, MiriInterpCxExt, MiriMachine, MiriMemoryKind,\n-    PrimitiveLayouts, Provenance, ProvenanceExtra, PAGE_SIZE, STACK_ADDR, STACK_SIZE,\n+    PrimitiveLayouts, Provenance, ProvenanceExtra,\n };\n pub use crate::mono_hash_map::MonoHashMap;\n pub use crate::operator::EvalContextExt as _;"}, {"sha": "01a3d7550e2e0c480b5bb545ef77782837471924", "filename": "src/tools/miri/src/machine.rs", "status": "modified", "additions": 39, "deletions": 10, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -9,6 +9,7 @@ use rand::rngs::StdRng;\n use rand::SeedableRng;\n \n use rustc_ast::ast::Mutability;\n+use rustc_const_eval::const_eval::CheckAlignment;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n #[allow(unused)]\n use rustc_data_structures::static_assert_size;\n@@ -22,20 +23,18 @@ use rustc_middle::{\n };\n use rustc_span::def_id::{CrateNum, DefId};\n use rustc_span::Symbol;\n-use rustc_target::abi::{Size, Align};\n+use rustc_target::abi::{Align, Size};\n use rustc_target::spec::abi::Abi;\n-use rustc_const_eval::const_eval::CheckAlignment;\n \n use crate::{\n     concurrency::{data_race, weak_memory},\n     shims::unix::FileHandler,\n     *,\n };\n \n-// Some global facts about the emulated machine.\n-pub const PAGE_SIZE: u64 = 4 * 1024; // FIXME: adjust to target architecture\n-pub const STACK_ADDR: u64 = 32 * PAGE_SIZE; // not really about the \"stack\", but where we start assigning integer addresses to allocations\n-pub const STACK_SIZE: u64 = 16 * PAGE_SIZE; // whatever\n+/// The number of the available real-time signal with the lowest priority.\n+/// Dummy constant related to epoll, must be between 32 and 64.\n+pub const SIGRTMAX: i32 = 42;\n \n /// Extra data stored with each stack frame\n pub struct FrameExtra<'tcx> {\n@@ -470,6 +469,10 @@ pub struct MiriMachine<'mir, 'tcx> {\n     pub(crate) since_gc: u32,\n     /// The number of CPUs to be reported by miri.\n     pub(crate) num_cpus: u32,\n+    /// Determines Miri's page size and associated values\n+    pub(crate) page_size: u64,\n+    pub(crate) stack_addr: u64,\n+    pub(crate) stack_size: u64,\n }\n \n impl<'mir, 'tcx> MiriMachine<'mir, 'tcx> {\n@@ -483,11 +486,31 @@ impl<'mir, 'tcx> MiriMachine<'mir, 'tcx> {\n         let rng = StdRng::seed_from_u64(config.seed.unwrap_or(0));\n         let borrow_tracker = config.borrow_tracker.map(|bt| bt.instanciate_global_state(config));\n         let data_race = config.data_race_detector.then(|| data_race::GlobalState::new(config));\n+        let page_size = if let Some(page_size) = config.page_size {\n+            page_size\n+        } else {\n+            let target = &layout_cx.tcx.sess.target;\n+            match target.arch.as_ref() {\n+                \"wasm32\" | \"wasm64\" => 64 * 1024, // https://webassembly.github.io/spec/core/exec/runtime.html#memory-instances\n+                \"aarch64\" =>\n+                    if target.options.vendor.as_ref() == \"apple\" {\n+                        // No \"definitive\" source, but see:\n+                        // https://www.wwdcnotes.com/notes/wwdc20/10214/\n+                        // https://github.com/ziglang/zig/issues/11308 etc.\n+                        16 * 1024\n+                    } else {\n+                        4 * 1024\n+                    },\n+                _ => 4 * 1024,\n+            }\n+        };\n+        let stack_addr = page_size * 32;\n+        let stack_size = page_size * 16;\n         MiriMachine {\n             tcx: layout_cx.tcx,\n             borrow_tracker,\n             data_race,\n-            intptrcast: RefCell::new(intptrcast::GlobalStateInner::new(config)),\n+            intptrcast: RefCell::new(intptrcast::GlobalStateInner::new(config, stack_addr)),\n             // `env_vars` depends on a full interpreter so we cannot properly initialize it yet.\n             env_vars: EnvVars::default(),\n             main_fn_ret_place: None,\n@@ -549,6 +572,9 @@ impl<'mir, 'tcx> MiriMachine<'mir, 'tcx> {\n             gc_interval: config.gc_interval,\n             since_gc: 0,\n             num_cpus: config.num_cpus,\n+            page_size,\n+            stack_addr,\n+            stack_size,\n         }\n     }\n \n@@ -693,6 +719,9 @@ impl VisitTags for MiriMachine<'_, '_> {\n             gc_interval: _,\n             since_gc: _,\n             num_cpus: _,\n+            page_size: _,\n+            stack_addr: _,\n+            stack_size: _,\n         } = self;\n \n         threads.visit_tags(visit);\n@@ -927,6 +956,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n                 &ecx.machine.threads,\n                 alloc.size(),\n                 kind,\n+                ecx.machine.current_span(),\n             )\n         });\n         let buffer_alloc = ecx.machine.weak_memory.then(weak_memory::AllocState::new_allocation);\n@@ -981,9 +1011,8 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n         ptr: Pointer<Self::Provenance>,\n     ) -> InterpResult<'tcx> {\n         match ptr.provenance {\n-            Provenance::Concrete { alloc_id, tag } => {\n-                intptrcast::GlobalStateInner::expose_ptr(ecx, alloc_id, tag)\n-            }\n+            Provenance::Concrete { alloc_id, tag } =>\n+                intptrcast::GlobalStateInner::expose_ptr(ecx, alloc_id, tag),\n             Provenance::Wildcard => {\n                 // No need to do anything for wildcard pointers as\n                 // their provenances have already been previously exposed."}, {"sha": "e049eec57a384bb6045cbef6f3a01c0fe82b4e8b", "filename": "src/tools/miri/src/shims/env.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fenv.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -170,7 +170,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 ))\n             }\n             None => {\n-                let envvar_not_found = this.eval_windows(\"c\", \"ERROR_ENVVAR_NOT_FOUND\")?;\n+                let envvar_not_found = this.eval_windows(\"c\", \"ERROR_ENVVAR_NOT_FOUND\");\n                 this.set_last_error(envvar_not_found)?;\n                 Scalar::from_u32(0) // return zero upon failure\n             }\n@@ -240,7 +240,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             Ok(0) // return zero on success\n         } else {\n             // name argument is a null pointer, points to an empty string, or points to a string containing an '=' character.\n-            let einval = this.eval_libc(\"EINVAL\")?;\n+            let einval = this.eval_libc(\"EINVAL\");\n             this.set_last_error(einval)?;\n             Ok(-1)\n         }\n@@ -274,15 +274,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 this.deallocate_ptr(var, None, MiriMemoryKind::Runtime.into())?;\n                 this.update_environ()?;\n             }\n-            Ok(this.eval_windows(\"c\", \"TRUE\")?)\n+            Ok(this.eval_windows(\"c\", \"TRUE\"))\n         } else {\n             let value = this.read_os_str_from_wide_str(value_ptr)?;\n             let var_ptr = alloc_env_var_as_wide_str(&name, &value, this)?;\n             if let Some(var) = this.machine.env_vars.map.insert(name, var_ptr) {\n                 this.deallocate_ptr(var, None, MiriMemoryKind::Runtime.into())?;\n             }\n             this.update_environ()?;\n-            Ok(this.eval_windows(\"c\", \"TRUE\")?)\n+            Ok(this.eval_windows(\"c\", \"TRUE\"))\n         }\n     }\n \n@@ -306,7 +306,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             Ok(0)\n         } else {\n             // name argument is a null pointer, points to an empty string, or points to a string containing an '=' character.\n-            let einval = this.eval_libc(\"EINVAL\")?;\n+            let einval = this.eval_libc(\"EINVAL\");\n             this.set_last_error(einval)?;\n             Ok(-1)\n         }\n@@ -335,7 +335,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 if this.write_path_to_c_str(&cwd, buf, size)?.0 {\n                     return Ok(buf);\n                 }\n-                let erange = this.eval_libc(\"ERANGE\")?;\n+                let erange = this.eval_libc(\"ERANGE\");\n                 this.set_last_error(erange)?;\n             }\n             Err(e) => this.set_last_error_from_io_error(e.kind())?,\n@@ -411,14 +411,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             this.reject_in_isolation(\"`SetCurrentDirectoryW`\", reject_with)?;\n             this.set_last_error_from_io_error(ErrorKind::PermissionDenied)?;\n \n-            return this.eval_windows(\"c\", \"FALSE\");\n+            return Ok(this.eval_windows(\"c\", \"FALSE\"));\n         }\n \n         match env::set_current_dir(path) {\n-            Ok(()) => this.eval_windows(\"c\", \"TRUE\"),\n+            Ok(()) => Ok(this.eval_windows(\"c\", \"TRUE\")),\n             Err(e) => {\n                 this.set_last_error_from_io_error(e.kind())?;\n-                this.eval_windows(\"c\", \"FALSE\")\n+                Ok(this.eval_windows(\"c\", \"FALSE\"))\n             }\n         }\n     }"}, {"sha": "4321bdf9aae67e5f18b4044d7f58e0a7acd797dd", "filename": "src/tools/miri/src/shims/foreign_items.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fforeign_items.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -1,4 +1,4 @@\n-use std::{collections::hash_map::Entry, io::Write, iter};\n+use std::{collections::hash_map::Entry, io::Write, iter, path::Path};\n \n use log::trace;\n \n@@ -442,6 +442,21 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 }\n                 this.machine.static_roots.push(alloc_id);\n             }\n+            \"miri_host_to_target_path\" => {\n+                let [ptr, out, out_size] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n+                let ptr = this.read_pointer(ptr)?;\n+                let out = this.read_pointer(out)?;\n+                let out_size = this.read_scalar(out_size)?.to_machine_usize(this)?;\n+\n+                // The host affects program behavior here, so this requires isolation to be disabled.\n+                this.check_no_isolation(\"`miri_host_to_target_path`\")?;\n+\n+                // We read this as a plain OsStr and write it as a path, which will convert it to the target.\n+                let path = this.read_os_str_from_c_str(ptr)?.to_owned();\n+                let (success, needed_size) = this.write_path_to_c_str(Path::new(&path), out, out_size)?;\n+                // Return value: 0 on success, otherwise the size it would have needed.\n+                this.write_int(if success { 0 } else { needed_size }, dest)?;\n+            }\n \n             // Obtains the size of a Miri backtrace. See the README for details.\n             \"miri_backtrace_size\" => {"}, {"sha": "0375a228a2148833b3153ed092169c64efb0aa83", "filename": "src/tools/miri/src/shims/os_str.rs", "status": "modified", "additions": 63, "deletions": 17, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fos_str.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -174,7 +174,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_ref();\n         let os_str = this.read_os_str_from_c_str(ptr)?;\n \n-        Ok(match this.convert_path_separator(Cow::Borrowed(os_str), PathConversion::TargetToHost) {\n+        Ok(match this.convert_path(Cow::Borrowed(os_str), PathConversion::TargetToHost) {\n             Cow::Borrowed(x) => Cow::Borrowed(Path::new(x)),\n             Cow::Owned(y) => Cow::Owned(PathBuf::from(y)),\n         })\n@@ -188,10 +188,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_ref();\n         let os_str = this.read_os_str_from_wide_str(ptr)?;\n \n-        Ok(this\n-            .convert_path_separator(Cow::Owned(os_str), PathConversion::TargetToHost)\n-            .into_owned()\n-            .into())\n+        Ok(this.convert_path(Cow::Owned(os_str), PathConversion::TargetToHost).into_owned().into())\n     }\n \n     /// Write a Path to the machine memory (as a null-terminated sequence of bytes),\n@@ -203,8 +200,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         size: u64,\n     ) -> InterpResult<'tcx, (bool, u64)> {\n         let this = self.eval_context_mut();\n-        let os_str = this\n-            .convert_path_separator(Cow::Borrowed(path.as_os_str()), PathConversion::HostToTarget);\n+        let os_str =\n+            this.convert_path(Cow::Borrowed(path.as_os_str()), PathConversion::HostToTarget);\n         this.write_os_str_to_c_str(&os_str, ptr, size)\n     }\n \n@@ -217,8 +214,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         size: u64,\n     ) -> InterpResult<'tcx, (bool, u64)> {\n         let this = self.eval_context_mut();\n-        let os_str = this\n-            .convert_path_separator(Cow::Borrowed(path.as_os_str()), PathConversion::HostToTarget);\n+        let os_str =\n+            this.convert_path(Cow::Borrowed(path.as_os_str()), PathConversion::HostToTarget);\n         this.write_os_str_to_wide_str(&os_str, ptr, size)\n     }\n \n@@ -230,18 +227,20 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         memkind: MemoryKind<MiriMemoryKind>,\n     ) -> InterpResult<'tcx, Pointer<Option<Provenance>>> {\n         let this = self.eval_context_mut();\n-        let os_str = this\n-            .convert_path_separator(Cow::Borrowed(path.as_os_str()), PathConversion::HostToTarget);\n+        let os_str =\n+            this.convert_path(Cow::Borrowed(path.as_os_str()), PathConversion::HostToTarget);\n         this.alloc_os_str_as_c_str(&os_str, memkind)\n     }\n \n-    fn convert_path_separator<'a>(\n+    #[allow(clippy::get_first)]\n+    fn convert_path<'a>(\n         &self,\n         os_str: Cow<'a, OsStr>,\n         direction: PathConversion,\n     ) -> Cow<'a, OsStr> {\n         let this = self.eval_context_ref();\n         let target_os = &this.tcx.sess.target.os;\n+\n         #[cfg(windows)]\n         return if target_os == \"windows\" {\n             // Windows-on-Windows, all fine.\n@@ -252,24 +251,71 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 PathConversion::HostToTarget => ('\\\\', '/'),\n                 PathConversion::TargetToHost => ('/', '\\\\'),\n             };\n-            let converted = os_str\n+            let mut converted = os_str\n                 .encode_wide()\n                 .map(|wchar| if wchar == from as u16 { to as u16 } else { wchar })\n                 .collect::<Vec<_>>();\n+            // We also have to ensure that absolute paths remain absolute.\n+            match direction {\n+                PathConversion::HostToTarget => {\n+                    // If this is an absolute Windows path that starts with a drive letter (`C:/...`\n+                    // after separator conversion), it would not be considered absolute by Unix\n+                    // target code.\n+                    if converted.get(1).copied() == Some(b':' as u16)\n+                        && converted.get(2).copied() == Some(b'/' as u16)\n+                    {\n+                        // We add a `/` at the beginning, to store the absolute Windows\n+                        // path in something that looks like an absolute Unix path.\n+                        converted.insert(0, b'/' as u16);\n+                    }\n+                }\n+                PathConversion::TargetToHost => {\n+                    // If the path is `\\C:\\`, the leading backslash was probably added by the above code\n+                    // and we should get rid of it again.\n+                    if converted.get(0).copied() == Some(b'\\\\' as u16)\n+                        && converted.get(2).copied() == Some(b':' as u16)\n+                        && converted.get(3).copied() == Some(b'\\\\' as u16)\n+                    {\n+                        converted.remove(0);\n+                    }\n+                }\n+            }\n             Cow::Owned(OsString::from_wide(&converted))\n         };\n         #[cfg(unix)]\n         return if target_os == \"windows\" {\n             // Windows target, Unix host.\n             let (from, to) = match direction {\n-                PathConversion::HostToTarget => ('/', '\\\\'),\n-                PathConversion::TargetToHost => ('\\\\', '/'),\n+                PathConversion::HostToTarget => (b'/', b'\\\\'),\n+                PathConversion::TargetToHost => (b'\\\\', b'/'),\n             };\n-            let converted = os_str\n+            let mut converted = os_str\n                 .as_bytes()\n                 .iter()\n-                .map(|&wchar| if wchar == from as u8 { to as u8 } else { wchar })\n+                .map(|&wchar| if wchar == from { to } else { wchar })\n                 .collect::<Vec<_>>();\n+            // We also have to ensure that absolute paths remain absolute.\n+            match direction {\n+                PathConversion::HostToTarget => {\n+                    // If this start withs a `\\`, we add `\\\\?` so it starts with `\\\\?\\` which is\n+                    // some magic path on Windos that *is* considered absolute.\n+                    if converted.get(0).copied() == Some(b'\\\\') {\n+                        converted.splice(0..0, b\"\\\\\\\\?\".iter().copied());\n+                    }\n+                }\n+                PathConversion::TargetToHost => {\n+                    // If this starts with `//?/`, it was probably produced by the above code and we\n+                    // remove the `//?` that got added to get the Unix path back out.\n+                    if converted.get(0).copied() == Some(b'/')\n+                        && converted.get(1).copied() == Some(b'/')\n+                        && converted.get(2).copied() == Some(b'?')\n+                        && converted.get(3).copied() == Some(b'/')\n+                    {\n+                        // Remove first 3 characters\n+                        converted.splice(0..3, std::iter::empty());\n+                    }\n+                }\n+            }\n             Cow::Owned(OsString::from_vec(converted))\n         } else {\n             // Unix-on-Unix, all is fine."}, {"sha": "ef411eb8aa7248bfe0c2028dcdac42b66e44b63b", "filename": "src/tools/miri/src/shims/time.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftime.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -36,26 +36,26 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 // Linux further distinguishes regular and \"coarse\" clocks, but the \"coarse\" version\n                 // is just specified to be \"faster and less precise\", so we implement both the same way.\n                 absolute_clocks = vec![\n-                    this.eval_libc_i32(\"CLOCK_REALTIME\")?,\n-                    this.eval_libc_i32(\"CLOCK_REALTIME_COARSE\")?,\n+                    this.eval_libc_i32(\"CLOCK_REALTIME\"),\n+                    this.eval_libc_i32(\"CLOCK_REALTIME_COARSE\"),\n                 ];\n                 // The second kind is MONOTONIC clocks for which 0 is an arbitrary time point, but they are\n                 // never allowed to go backwards. We don't need to do any additonal monotonicity\n                 // enforcement because std::time::Instant already guarantees that it is monotonic.\n                 relative_clocks = vec![\n-                    this.eval_libc_i32(\"CLOCK_MONOTONIC\")?,\n-                    this.eval_libc_i32(\"CLOCK_MONOTONIC_COARSE\")?,\n+                    this.eval_libc_i32(\"CLOCK_MONOTONIC\"),\n+                    this.eval_libc_i32(\"CLOCK_MONOTONIC_COARSE\"),\n                 ];\n             }\n             \"macos\" => {\n-                absolute_clocks = vec![this.eval_libc_i32(\"CLOCK_REALTIME\")?];\n-                relative_clocks = vec![this.eval_libc_i32(\"CLOCK_MONOTONIC\")?];\n+                absolute_clocks = vec![this.eval_libc_i32(\"CLOCK_REALTIME\")];\n+                relative_clocks = vec![this.eval_libc_i32(\"CLOCK_MONOTONIC\")];\n                 // Some clocks only seem to exist in the aarch64 version of the target.\n                 if this.tcx.sess.target.arch == \"aarch64\" {\n                     // `CLOCK_UPTIME_RAW` supposed to not increment while the system is asleep... but\n                     // that's not really something a program running inside Miri can tell, anyway.\n                     // We need to support it because std uses it.\n-                    relative_clocks.push(this.eval_libc_i32(\"CLOCK_UPTIME_RAW\")?);\n+                    relative_clocks.push(this.eval_libc_i32(\"CLOCK_UPTIME_RAW\"));\n                 }\n             }\n             target => throw_unsup_format!(\"`clock_gettime` is not supported on target OS {target}\"),\n@@ -68,7 +68,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             this.machine.clock.now().duration_since(this.machine.clock.anchor())\n         } else {\n             // Unsupported clock.\n-            let einval = this.eval_libc(\"EINVAL\")?;\n+            let einval = this.eval_libc(\"EINVAL\");\n             this.set_last_error(einval)?;\n             return Ok(Scalar::from_i32(-1));\n         };\n@@ -94,7 +94,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // Using tz is obsolete and should always be null\n         let tz = this.read_pointer(tz_op)?;\n         if !this.ptr_is_null(tz)? {\n-            let einval = this.eval_libc(\"EINVAL\")?;\n+            let einval = this.eval_libc(\"EINVAL\");\n             this.set_last_error(einval)?;\n             return Ok(-1);\n         }\n@@ -118,9 +118,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         this.assert_target_os(\"windows\", \"GetSystemTimeAsFileTime\");\n         this.check_no_isolation(\"`GetSystemTimeAsFileTime`\")?;\n \n-        let NANOS_PER_SEC = this.eval_windows_u64(\"time\", \"NANOS_PER_SEC\")?;\n-        let INTERVALS_PER_SEC = this.eval_windows_u64(\"time\", \"INTERVALS_PER_SEC\")?;\n-        let INTERVALS_TO_UNIX_EPOCH = this.eval_windows_u64(\"time\", \"INTERVALS_TO_UNIX_EPOCH\")?;\n+        let NANOS_PER_SEC = this.eval_windows_u64(\"time\", \"NANOS_PER_SEC\");\n+        let INTERVALS_PER_SEC = this.eval_windows_u64(\"time\", \"INTERVALS_PER_SEC\");\n+        let INTERVALS_TO_UNIX_EPOCH = this.eval_windows_u64(\"time\", \"INTERVALS_TO_UNIX_EPOCH\");\n         let NANOS_PER_INTERVAL = NANOS_PER_SEC / INTERVALS_PER_SEC;\n         let SECONDS_TO_UNIX_EPOCH = INTERVALS_TO_UNIX_EPOCH / INTERVALS_PER_SEC;\n \n@@ -226,7 +226,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let duration = match this.read_timespec(&this.deref_operand(req_op)?)? {\n             Some(duration) => duration,\n             None => {\n-                let einval = this.eval_libc(\"EINVAL\")?;\n+                let einval = this.eval_libc(\"EINVAL\");\n                 this.set_last_error(einval)?;\n                 return Ok(-1);\n             }"}, {"sha": "7768772338a777b73d709b1dbd68985435ee1643", "filename": "src/tools/miri/src/shims/tls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftls.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -303,12 +303,12 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             return Ok(());\n         }\n         let thread_callback =\n-            this.eval_windows(\"thread_local_key\", \"p_thread_callback\")?.to_pointer(this)?;\n+            this.eval_windows(\"thread_local_key\", \"p_thread_callback\").to_pointer(this)?;\n         let thread_callback = this.get_ptr_fn(thread_callback)?.as_instance()?;\n \n         // FIXME: Technically, the reason should be `DLL_PROCESS_DETACH` when the main thread exits\n         // but std treats both the same.\n-        let reason = this.eval_windows(\"c\", \"DLL_THREAD_DETACH\")?;\n+        let reason = this.eval_windows(\"c\", \"DLL_THREAD_DETACH\");\n \n         // The signature of this function is `unsafe extern \"system\" fn(h: c::LPVOID, dwReason: c::DWORD, pv: c::LPVOID)`.\n         // FIXME: `h` should be a handle to the current module and what `pv` should be is unknown"}, {"sha": "7f43afb7820b5858367962cb2f3d79ba461cb3f1", "filename": "src/tools/miri/src/shims/unix/foreign_items.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fforeign_items.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -196,7 +196,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 // Align must be power of 2, and also at least ptr-sized (POSIX rules).\n                 // But failure to adhere to this is not UB, it's an error condition.\n                 if !align.is_power_of_two() || align < this.pointer_size().bytes() {\n-                    let einval = this.eval_libc_i32(\"EINVAL\")?;\n+                    let einval = this.eval_libc_i32(\"EINVAL\");\n                     this.write_int(einval, dest)?;\n                 } else {\n                     if size == 0 {\n@@ -234,7 +234,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 // FIXME: Which of these are POSIX, and which are GNU/Linux?\n                 // At least the names seem to all also exist on macOS.\n                 let sysconfs: &[(&str, fn(&MiriInterpCx<'_, '_>) -> Scalar<Provenance>)] = &[\n-                    (\"_SC_PAGESIZE\", |this| Scalar::from_int(PAGE_SIZE, this.pointer_size())),\n+                    (\"_SC_PAGESIZE\", |this| Scalar::from_int(this.machine.page_size, this.pointer_size())),\n                     (\"_SC_NPROCESSORS_CONF\", |this| Scalar::from_int(this.machine.num_cpus, this.pointer_size())),\n                     (\"_SC_NPROCESSORS_ONLN\", |this| Scalar::from_int(this.machine.num_cpus, this.pointer_size())),\n                     // 512 seems to be a reasonable default. The value is not critical, in\n@@ -243,7 +243,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 ];\n                 let mut result = None;\n                 for &(sysconf_name, value) in sysconfs {\n-                    let sysconf_name = this.eval_libc_i32(sysconf_name)?;\n+                    let sysconf_name = this.eval_libc_i32(sysconf_name);\n                     if sysconf_name == name {\n                         result = Some(value(this));\n                         break;\n@@ -480,7 +480,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                     None => format!(\"<unknown errnum in strerror_r: {errnum}>\"),\n                 };\n                 let (complete, _) = this.write_os_str_to_c_str(OsStr::new(&formatted), buf, buflen)?;\n-                let ret = if complete { 0 } else { this.eval_libc_i32(\"ERANGE\")? };\n+                let ret = if complete { 0 } else { this.eval_libc_i32(\"ERANGE\") };\n                 this.write_int(ret, dest)?;\n             }\n             \"getpid\" => {\n@@ -495,8 +495,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             if this.frame_in_std() => {\n                 let [_attr, guard_size] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let guard_size = this.deref_operand(guard_size)?;\n-                let guard_size_layout = this.libc_ty_layout(\"size_t\")?;\n-                this.write_scalar(Scalar::from_uint(crate::PAGE_SIZE, guard_size_layout.size), &guard_size.into())?;\n+                let guard_size_layout = this.libc_ty_layout(\"size_t\");\n+                this.write_scalar(Scalar::from_uint(this.machine.page_size, guard_size_layout.size), &guard_size.into())?;\n \n                 // Return success (`0`).\n                 this.write_null(dest)?;\n@@ -525,11 +525,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let size_place = this.deref_operand(size_place)?;\n \n                 this.write_scalar(\n-                    Scalar::from_uint(STACK_ADDR, this.pointer_size()),\n+                    Scalar::from_uint(this.machine.stack_addr, this.pointer_size()),\n                     &addr_place.into(),\n                 )?;\n                 this.write_scalar(\n-                    Scalar::from_uint(STACK_SIZE, this.pointer_size()),\n+                    Scalar::from_uint(this.machine.stack_size, this.pointer_size()),\n                     &size_place.into(),\n                 )?;\n \n@@ -589,7 +589,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                     this.write_null(dest)?;\n                 } else {\n                     this.write_null(&result.into())?;\n-                    this.write_scalar(this.eval_libc(\"ERANGE\")?, dest)?;\n+                    this.write_scalar(this.eval_libc(\"ERANGE\"), dest)?;\n                 }\n             }\n "}, {"sha": "1b8f52f36657d84c9cf9c4cbfe82f87ca065318d", "filename": "src/tools/miri/src/shims/unix/fs.rs", "status": "modified", "additions": 97, "deletions": 83, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -17,20 +17,25 @@ use crate::shims::os_str::bytes_to_os_str;\n use crate::*;\n use shims::os_str::os_str_to_bytes;\n use shims::time::system_time_to_duration;\n+use shims::unix::linux::fd::epoll::Epoll;\n \n #[derive(Debug)]\n-struct FileHandle {\n+pub struct FileHandle {\n     file: File,\n     writable: bool,\n }\n \n-trait FileDescriptor: std::fmt::Debug {\n+pub trait FileDescriptor: std::fmt::Debug {\n     fn name(&self) -> &'static str;\n \n     fn as_file_handle<'tcx>(&self) -> InterpResult<'tcx, &FileHandle> {\n         throw_unsup_format!(\"{} cannot be used as FileHandle\", self.name());\n     }\n \n+    fn as_epoll_handle<'tcx>(&mut self) -> InterpResult<'tcx, &mut Epoll> {\n+        throw_unsup_format!(\"not an epoll file descriptor\");\n+    }\n+\n     fn read<'tcx>(\n         &mut self,\n         _communicate_allowed: bool,\n@@ -274,7 +279,7 @@ impl FileDescriptor for NullOutput {\n \n #[derive(Debug)]\n pub struct FileHandler {\n-    handles: BTreeMap<i32, Box<dyn FileDescriptor>>,\n+    pub handles: BTreeMap<i32, Box<dyn FileDescriptor>>,\n }\n \n impl VisitTags for FileHandler {\n@@ -297,7 +302,7 @@ impl FileHandler {\n         FileHandler { handles }\n     }\n \n-    fn insert_fd(&mut self, file_handle: Box<dyn FileDescriptor>) -> i32 {\n+    pub fn insert_fd(&mut self, file_handle: Box<dyn FileDescriptor>) -> i32 {\n         self.insert_fd_with_min_fd(file_handle, 0)\n     }\n \n@@ -376,17 +381,6 @@ trait EvalContextExtPrivate<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx\n         Ok(0)\n     }\n \n-    /// Function used when a handle is not found inside `FileHandler`. It returns `Ok(-1)`and sets\n-    /// the last OS error to `libc::EBADF` (invalid file descriptor). This function uses\n-    /// `T: From<i32>` instead of `i32` directly because some fs functions return different integer\n-    /// types (like `read`, that returns an `i64`).\n-    fn handle_not_found<T: From<i32>>(&mut self) -> InterpResult<'tcx, T> {\n-        let this = self.eval_context_mut();\n-        let ebadf = this.eval_libc(\"EBADF\")?;\n-        this.set_last_error(ebadf)?;\n-        Ok((-1).into())\n-    }\n-\n     fn file_type_to_d_type(\n         &mut self,\n         file_type: std::io::Result<FileType>,\n@@ -395,11 +389,11 @@ trait EvalContextExtPrivate<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx\n         match file_type {\n             Ok(file_type) => {\n                 if file_type.is_dir() {\n-                    Ok(this.eval_libc(\"DT_DIR\")?.to_u8()?.into())\n+                    Ok(this.eval_libc(\"DT_DIR\").to_u8()?.into())\n                 } else if file_type.is_file() {\n-                    Ok(this.eval_libc(\"DT_REG\")?.to_u8()?.into())\n+                    Ok(this.eval_libc(\"DT_REG\").to_u8()?.into())\n                 } else if file_type.is_symlink() {\n-                    Ok(this.eval_libc(\"DT_LNK\")?.to_u8()?.into())\n+                    Ok(this.eval_libc(\"DT_LNK\").to_u8()?.into())\n                 } else {\n                     // Certain file types are only supported when the host is a Unix system.\n                     // (i.e. devices and sockets) If it is, check those cases, if not, fall back to\n@@ -409,19 +403,19 @@ trait EvalContextExtPrivate<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx\n                     {\n                         use std::os::unix::fs::FileTypeExt;\n                         if file_type.is_block_device() {\n-                            Ok(this.eval_libc(\"DT_BLK\")?.to_u8()?.into())\n+                            Ok(this.eval_libc(\"DT_BLK\").to_u8()?.into())\n                         } else if file_type.is_char_device() {\n-                            Ok(this.eval_libc(\"DT_CHR\")?.to_u8()?.into())\n+                            Ok(this.eval_libc(\"DT_CHR\").to_u8()?.into())\n                         } else if file_type.is_fifo() {\n-                            Ok(this.eval_libc(\"DT_FIFO\")?.to_u8()?.into())\n+                            Ok(this.eval_libc(\"DT_FIFO\").to_u8()?.into())\n                         } else if file_type.is_socket() {\n-                            Ok(this.eval_libc(\"DT_SOCK\")?.to_u8()?.into())\n+                            Ok(this.eval_libc(\"DT_SOCK\").to_u8()?.into())\n                         } else {\n-                            Ok(this.eval_libc(\"DT_UNKNOWN\")?.to_u8()?.into())\n+                            Ok(this.eval_libc(\"DT_UNKNOWN\").to_u8()?.into())\n                         }\n                     }\n                     #[cfg(not(unix))]\n-                    Ok(this.eval_libc(\"DT_UNKNOWN\")?.to_u8()?.into())\n+                    Ok(this.eval_libc(\"DT_UNKNOWN\").to_u8()?.into())\n                 }\n             }\n             Err(e) =>\n@@ -532,9 +526,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         let mut options = OpenOptions::new();\n \n-        let o_rdonly = this.eval_libc_i32(\"O_RDONLY\")?;\n-        let o_wronly = this.eval_libc_i32(\"O_WRONLY\")?;\n-        let o_rdwr = this.eval_libc_i32(\"O_RDWR\")?;\n+        let o_rdonly = this.eval_libc_i32(\"O_RDONLY\");\n+        let o_wronly = this.eval_libc_i32(\"O_WRONLY\");\n+        let o_rdwr = this.eval_libc_i32(\"O_RDWR\");\n         // The first two bits of the flag correspond to the access mode in linux, macOS and\n         // windows. We need to check that in fact the access mode flags for the current target\n         // only use these two bits, otherwise we are in an unsupported target and should error.\n@@ -561,18 +555,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // options.\n         let mut mirror = access_mode;\n \n-        let o_append = this.eval_libc_i32(\"O_APPEND\")?;\n-        if flag & o_append != 0 {\n+        let o_append = this.eval_libc_i32(\"O_APPEND\");\n+        if flag & o_append == o_append {\n             options.append(true);\n             mirror |= o_append;\n         }\n-        let o_trunc = this.eval_libc_i32(\"O_TRUNC\")?;\n-        if flag & o_trunc != 0 {\n+        let o_trunc = this.eval_libc_i32(\"O_TRUNC\");\n+        if flag & o_trunc == o_trunc {\n             options.truncate(true);\n             mirror |= o_trunc;\n         }\n-        let o_creat = this.eval_libc_i32(\"O_CREAT\")?;\n-        if flag & o_creat != 0 {\n+        let o_creat = this.eval_libc_i32(\"O_CREAT\");\n+        if flag & o_creat == o_creat {\n             // Get the mode.  On macOS, the argument type `mode_t` is actually `u16`, but\n             // C integer promotion rules mean that on the ABI level, it gets passed as `u32`\n             // (see https://github.com/rust-lang/rust/issues/71915).\n@@ -591,20 +585,29 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n             mirror |= o_creat;\n \n-            let o_excl = this.eval_libc_i32(\"O_EXCL\")?;\n-            if flag & o_excl != 0 {\n+            let o_excl = this.eval_libc_i32(\"O_EXCL\");\n+            if flag & o_excl == o_excl {\n                 mirror |= o_excl;\n                 options.create_new(true);\n             } else {\n                 options.create(true);\n             }\n         }\n-        let o_cloexec = this.eval_libc_i32(\"O_CLOEXEC\")?;\n-        if flag & o_cloexec != 0 {\n+        let o_cloexec = this.eval_libc_i32(\"O_CLOEXEC\");\n+        if flag & o_cloexec == o_cloexec {\n             // We do not need to do anything for this flag because `std` already sets it.\n             // (Technically we do not support *not* setting this flag, but we ignore that.)\n             mirror |= o_cloexec;\n         }\n+        if this.tcx.sess.target.os == \"linux\" {\n+            let o_tmpfile = this.eval_libc_i32(\"O_TMPFILE\");\n+            if flag & o_tmpfile == o_tmpfile {\n+                // if the flag contains `O_TMPFILE` then we return a graceful error\n+                let eopnotsupp = this.eval_libc(\"EOPNOTSUPP\");\n+                this.set_last_error(eopnotsupp)?;\n+                return Ok(-1);\n+            }\n+        }\n         // If `flag` is not equal to `mirror`, there is an unsupported option enabled in `flag`,\n         // then we throw an error.\n         if flag != mirror {\n@@ -648,18 +651,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         }\n \n         // We only support getting the flags for a descriptor.\n-        if cmd == this.eval_libc_i32(\"F_GETFD\")? {\n+        if cmd == this.eval_libc_i32(\"F_GETFD\") {\n             // Currently this is the only flag that `F_GETFD` returns. It is OK to just return the\n             // `FD_CLOEXEC` value without checking if the flag is set for the file because `std`\n             // always sets this flag when opening a file. However we still need to check that the\n             // file itself is open.\n             if this.machine.file_handler.handles.contains_key(&fd) {\n-                Ok(this.eval_libc_i32(\"FD_CLOEXEC\")?)\n+                Ok(this.eval_libc_i32(\"FD_CLOEXEC\"))\n             } else {\n                 this.handle_not_found()\n             }\n-        } else if cmd == this.eval_libc_i32(\"F_DUPFD\")?\n-            || cmd == this.eval_libc_i32(\"F_DUPFD_CLOEXEC\")?\n+        } else if cmd == this.eval_libc_i32(\"F_DUPFD\")\n+            || cmd == this.eval_libc_i32(\"F_DUPFD_CLOEXEC\")\n         {\n             // Note that we always assume the FD_CLOEXEC flag is set for every open file, in part\n             // because exec() isn't supported. The F_DUPFD and F_DUPFD_CLOEXEC commands only\n@@ -688,7 +691,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 }\n                 None => this.handle_not_found(),\n             }\n-        } else if this.tcx.sess.target.os == \"macos\" && cmd == this.eval_libc_i32(\"F_FULLFSYNC\")? {\n+        } else if this.tcx.sess.target.os == \"macos\" && cmd == this.eval_libc_i32(\"F_FULLFSYNC\") {\n             if let Some(file_descriptor) = this.machine.file_handler.handles.get(&fd) {\n                 // FIXME: Support fullfsync for all FDs\n                 let FileHandle { file, writable } = file_descriptor.as_file_handle()?;\n@@ -717,6 +720,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         ))\n     }\n \n+    /// Function used when a handle is not found inside `FileHandler`. It returns `Ok(-1)`and sets\n+    /// the last OS error to `libc::EBADF` (invalid file descriptor). This function uses\n+    /// `T: From<i32>` instead of `i32` directly because some fs functions return different integer\n+    /// types (like `read`, that returns an `i64`).\n+    fn handle_not_found<T: From<i32>>(&mut self) -> InterpResult<'tcx, T> {\n+        let this = self.eval_context_mut();\n+        let ebadf = this.eval_libc(\"EBADF\");\n+        this.set_last_error(ebadf)?;\n+        Ok((-1).into())\n+    }\n+\n     fn read(\n         &mut self,\n         fd: i32,\n@@ -821,14 +835,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let offset = this.read_scalar(offset_op)?.to_i64()?;\n         let whence = this.read_scalar(whence_op)?.to_i32()?;\n \n-        let seek_from = if whence == this.eval_libc_i32(\"SEEK_SET\")? {\n+        let seek_from = if whence == this.eval_libc_i32(\"SEEK_SET\") {\n             SeekFrom::Start(u64::try_from(offset).unwrap())\n-        } else if whence == this.eval_libc_i32(\"SEEK_CUR\")? {\n+        } else if whence == this.eval_libc_i32(\"SEEK_CUR\") {\n             SeekFrom::Current(offset)\n-        } else if whence == this.eval_libc_i32(\"SEEK_END\")? {\n+        } else if whence == this.eval_libc_i32(\"SEEK_END\") {\n             SeekFrom::End(offset)\n         } else {\n-            let einval = this.eval_libc(\"EINVAL\")?;\n+            let einval = this.eval_libc(\"EINVAL\");\n             this.set_last_error(einval)?;\n             return Ok(Scalar::from_i64(-1));\n         };\n@@ -907,7 +921,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // Reject if isolation is enabled.\n         if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n             this.reject_in_isolation(\"`stat`\", reject_with)?;\n-            let eacc = this.eval_libc(\"EACCES\")?;\n+            let eacc = this.eval_libc(\"EACCES\");\n             this.set_last_error(eacc)?;\n             return Ok(Scalar::from_i32(-1));\n         }\n@@ -936,7 +950,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // Reject if isolation is enabled.\n         if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n             this.reject_in_isolation(\"`lstat`\", reject_with)?;\n-            let eacc = this.eval_libc(\"EACCES\")?;\n+            let eacc = this.eval_libc(\"EACCES\");\n             this.set_last_error(eacc)?;\n             return Ok(Scalar::from_i32(-1));\n         }\n@@ -994,7 +1008,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         // If the statxbuf or pathname pointers are null, the function fails with `EFAULT`.\n         if this.ptr_is_null(statxbuf_ptr)? || this.ptr_is_null(pathname_ptr)? {\n-            let efault = this.eval_libc(\"EFAULT\")?;\n+            let efault = this.eval_libc(\"EFAULT\");\n             this.set_last_error(efault)?;\n             return Ok(-1);\n         }\n@@ -1005,13 +1019,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // as `isize`s instead of having the proper types. Thus, we have to recover the layout of\n         // `statxbuf_op` by using the `libc::statx` struct type.\n         let statxbuf = {\n-            let statx_layout = this.libc_ty_layout(\"statx\")?;\n+            let statx_layout = this.libc_ty_layout(\"statx\");\n             MPlaceTy::from_aligned_ptr(statxbuf_ptr, statx_layout)\n         };\n \n         let path = this.read_path_from_c_str(pathname_ptr)?.into_owned();\n         // See <https://github.com/rust-lang/rust/pull/79196> for a discussion of argument sizes.\n-        let empty_path_flag = flags & this.eval_libc(\"AT_EMPTY_PATH\")?.to_i32()? != 0;\n+        let at_ampty_path = this.eval_libc_i32(\"AT_EMPTY_PATH\");\n+        let empty_path_flag = flags & at_ampty_path == at_ampty_path;\n         // We only support:\n         // * interpreting `path` as an absolute directory,\n         // * interpreting `path` as a path relative to `dirfd` when the latter is `AT_FDCWD`, or\n@@ -1020,7 +1035,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // Other behaviors cannot be tested from `libstd` and thus are not implemented. If you\n         // found this error, please open an issue reporting it.\n         if !(path.is_absolute()\n-            || dirfd == this.eval_libc_i32(\"AT_FDCWD\")?\n+            || dirfd == this.eval_libc_i32(\"AT_FDCWD\")\n             || (path.as_os_str().is_empty() && empty_path_flag))\n         {\n             throw_unsup_format!(\n@@ -1033,16 +1048,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // Reject if isolation is enabled.\n         if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n             this.reject_in_isolation(\"`statx`\", reject_with)?;\n-            let ecode = if path.is_absolute() || dirfd == this.eval_libc_i32(\"AT_FDCWD\")? {\n+            let ecode = if path.is_absolute() || dirfd == this.eval_libc_i32(\"AT_FDCWD\") {\n                 // since `path` is provided, either absolute or\n                 // relative to CWD, `EACCES` is the most relevant.\n-                this.eval_libc(\"EACCES\")?\n+                this.eval_libc(\"EACCES\")\n             } else {\n                 // `dirfd` is set to target file, and `path` is empty\n                 // (or we would have hit the `throw_unsup_format`\n                 // above). `EACCES` would violate the spec.\n                 assert!(empty_path_flag);\n-                this.eval_libc(\"EBADF\")?\n+                this.eval_libc(\"EBADF\")\n             };\n             this.set_last_error(ecode)?;\n             return Ok(-1);\n@@ -1052,12 +1067,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // However `statx` is allowed to return information that was not requested or to not\n         // return information that was requested. This `mask` represents the information we can\n         // actually provide for any target.\n-        let mut mask =\n-            this.eval_libc(\"STATX_TYPE\")?.to_u32()? | this.eval_libc(\"STATX_SIZE\")?.to_u32()?;\n+        let mut mask = this.eval_libc_u32(\"STATX_TYPE\") | this.eval_libc_u32(\"STATX_SIZE\");\n \n         // If the `AT_SYMLINK_NOFOLLOW` flag is set, we query the file's metadata without following\n         // symbolic links.\n-        let follow_symlink = flags & this.eval_libc(\"AT_SYMLINK_NOFOLLOW\")?.to_i32()? == 0;\n+        let follow_symlink = flags & this.eval_libc_i32(\"AT_SYMLINK_NOFOLLOW\") == 0;\n \n         // If the path is empty, and the AT_EMPTY_PATH flag is set, we query the open file\n         // represented by dirfd, whether it's a directory or otherwise.\n@@ -1086,23 +1100,23 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let (access_sec, access_nsec) = metadata\n             .accessed\n             .map(|tup| {\n-                mask |= this.eval_libc(\"STATX_ATIME\")?.to_u32()?;\n+                mask |= this.eval_libc_u32(\"STATX_ATIME\");\n                 InterpResult::Ok(tup)\n             })\n             .unwrap_or_else(|| Ok((0, 0)))?;\n \n         let (created_sec, created_nsec) = metadata\n             .created\n             .map(|tup| {\n-                mask |= this.eval_libc(\"STATX_BTIME\")?.to_u32()?;\n+                mask |= this.eval_libc_u32(\"STATX_BTIME\");\n                 InterpResult::Ok(tup)\n             })\n             .unwrap_or_else(|| Ok((0, 0)))?;\n \n         let (modified_sec, modified_nsec) = metadata\n             .modified\n             .map(|tup| {\n-                mask |= this.eval_libc(\"STATX_MTIME\")?.to_u32()?;\n+                mask |= this.eval_libc_u32(\"STATX_MTIME\");\n                 InterpResult::Ok(tup)\n             })\n             .unwrap_or_else(|| Ok((0, 0)))?;\n@@ -1175,7 +1189,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let newpath_ptr = this.read_pointer(newpath_op)?;\n \n         if this.ptr_is_null(oldpath_ptr)? || this.ptr_is_null(newpath_ptr)? {\n-            let efault = this.eval_libc(\"EFAULT\")?;\n+            let efault = this.eval_libc(\"EFAULT\");\n             this.set_last_error(efault)?;\n             return Ok(-1);\n         }\n@@ -1262,7 +1276,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // Reject if isolation is enabled.\n         if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n             this.reject_in_isolation(\"`opendir`\", reject_with)?;\n-            let eacc = this.eval_libc(\"EACCES\")?;\n+            let eacc = this.eval_libc(\"EACCES\");\n             this.set_last_error(eacc)?;\n             return Ok(Scalar::null_ptr(this));\n         }\n@@ -1298,7 +1312,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // Reject if isolation is enabled.\n         if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n             this.reject_in_isolation(\"`readdir`\", reject_with)?;\n-            let eacc = this.eval_libc(\"EBADF\")?;\n+            let eacc = this.eval_libc(\"EBADF\");\n             this.set_last_error(eacc)?;\n             return Ok(Scalar::null_ptr(this));\n         }\n@@ -1327,7 +1341,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let name_bytes = os_str_to_bytes(&name)?;\n                 let name_len = u64::try_from(name_bytes.len()).unwrap();\n \n-                let dirent64_layout = this.libc_ty_layout(\"dirent64\")?;\n+                let dirent64_layout = this.libc_ty_layout(\"dirent64\");\n                 let d_name_offset = dirent64_layout.fields.offset(4 /* d_name */).bytes();\n                 let size = d_name_offset.checked_add(name_len).unwrap();\n \n@@ -1522,13 +1536,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                         let result = file.set_len(length);\n                         this.try_unwrap_io_result(result.map(|_| 0i32))?\n                     } else {\n-                        let einval = this.eval_libc(\"EINVAL\")?;\n+                        let einval = this.eval_libc(\"EINVAL\");\n                         this.set_last_error(einval)?;\n                         -1\n                     }\n                 } else {\n                     // The file is not writable\n-                    let einval = this.eval_libc(\"EINVAL\")?;\n+                    let einval = this.eval_libc(\"EINVAL\");\n                     this.set_last_error(einval)?;\n                     -1\n                 }\n@@ -1602,15 +1616,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let flags = this.read_scalar(flags_op)?.to_i32()?;\n \n         if offset < 0 || nbytes < 0 {\n-            let einval = this.eval_libc(\"EINVAL\")?;\n+            let einval = this.eval_libc(\"EINVAL\");\n             this.set_last_error(einval)?;\n             return Ok(Scalar::from_i32(-1));\n         }\n-        let allowed_flags = this.eval_libc_i32(\"SYNC_FILE_RANGE_WAIT_BEFORE\")?\n-            | this.eval_libc_i32(\"SYNC_FILE_RANGE_WRITE\")?\n-            | this.eval_libc_i32(\"SYNC_FILE_RANGE_WAIT_AFTER\")?;\n+        let allowed_flags = this.eval_libc_i32(\"SYNC_FILE_RANGE_WAIT_BEFORE\")\n+            | this.eval_libc_i32(\"SYNC_FILE_RANGE_WRITE\")\n+            | this.eval_libc_i32(\"SYNC_FILE_RANGE_WAIT_AFTER\");\n         if flags & allowed_flags != flags {\n-            let einval = this.eval_libc(\"EINVAL\")?;\n+            let einval = this.eval_libc(\"EINVAL\");\n             this.set_last_error(einval)?;\n             return Ok(Scalar::from_i32(-1));\n         }\n@@ -1647,7 +1661,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // Reject if isolation is enabled.\n         if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n             this.reject_in_isolation(\"`readlink`\", reject_with)?;\n-            let eacc = this.eval_libc(\"EACCES\")?;\n+            let eacc = this.eval_libc(\"EACCES\");\n             this.set_last_error(eacc)?;\n             return Ok(-1);\n         }\n@@ -1658,7 +1672,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 // 'readlink' truncates the resolved path if the provided buffer is not large\n                 // enough, and does *not* add a null terminator. That means we cannot use the usual\n                 // `write_path_to_c_str` and have to re-implement parts of it ourselves.\n-                let resolved = this.convert_path_separator(\n+                let resolved = this.convert_path(\n                     Cow::Borrowed(resolved.as_ref()),\n                     crate::shims::os_str::PathConversion::HostToTarget,\n                 );\n@@ -1692,7 +1706,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             }\n         }\n         // Fallback when the FD was not found or isolation is enabled.\n-        let enotty = this.eval_libc(\"ENOTTY\")?;\n+        let enotty = this.eval_libc(\"ENOTTY\");\n         this.set_last_error(enotty)?;\n         Ok(Scalar::from_i32(0))\n     }\n@@ -1711,7 +1725,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // Reject if isolation is enabled.\n         if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n             this.reject_in_isolation(\"`realpath`\", reject_with)?;\n-            let eacc = this.eval_libc(\"EACCES\")?;\n+            let eacc = this.eval_libc(\"EACCES\");\n             this.set_last_error(eacc)?;\n             return Ok(Scalar::from_machine_usize(0, this));\n         }\n@@ -1720,7 +1734,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         match result {\n             Ok(resolved) => {\n                 let path_max = this\n-                    .eval_libc_i32(\"PATH_MAX\")?\n+                    .eval_libc_i32(\"PATH_MAX\")\n                     .try_into()\n                     .expect(\"PATH_MAX does not fit in u64\");\n                 let dest = if this.ptr_is_null(processed_ptr)? {\n@@ -1742,7 +1756,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                         // Note that we do not explicitly handle `FILENAME_MAX`\n                         // (different from `PATH_MAX` above) as it is Linux-specific and\n                         // seems like a bit of a mess anyway: <https://eklitzke.org/path-max-is-tricky>.\n-                        let enametoolong = this.eval_libc(\"ENAMETOOLONG\")?;\n+                        let enametoolong = this.eval_libc(\"ENAMETOOLONG\");\n                         this.set_last_error(enametoolong)?;\n                         return Ok(Scalar::from_machine_usize(0, this));\n                     }\n@@ -1775,7 +1789,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         //   * The value of `TMP_MAX` is at least 25.\n         //   * On XSI-conformant systems, the value of `TMP_MAX` is at least 10000.\n         // See <https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/stdio.h.html>.\n-        let max_attempts = this.eval_libc(\"TMP_MAX\")?.to_u32()?;\n+        let max_attempts = this.eval_libc_u32(\"TMP_MAX\");\n \n         // Get the raw bytes from the template -- as a byte slice, this is a string in the target\n         // (and the target is unix, so a byte slice is the right representation).\n@@ -1786,7 +1800,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // Reject if isolation is enabled.\n         if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n             this.reject_in_isolation(\"`mkstemp`\", reject_with)?;\n-            let eacc = this.eval_libc(\"EACCES\")?;\n+            let eacc = this.eval_libc(\"EACCES\");\n             this.set_last_error(eacc)?;\n             return Ok(-1);\n         }\n@@ -1804,7 +1818,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         // If we don't find the suffix, it is an error.\n         if last_six_char_bytes != suffix_bytes {\n-            let einval = this.eval_libc(\"EINVAL\")?;\n+            let einval = this.eval_libc(\"EINVAL\");\n             this.set_last_error(einval)?;\n             return Ok(-1);\n         }\n@@ -1880,7 +1894,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         }\n \n         // We ran out of attempts to create the file, return an error.\n-        let eexist = this.eval_libc(\"EEXIST\")?;\n+        let eexist = this.eval_libc(\"EEXIST\");\n         this.set_last_error(eexist)?;\n         Ok(-1)\n     }\n@@ -1958,7 +1972,7 @@ impl FileMetadata {\n             \"S_IFLNK\"\n         };\n \n-        let mode = ecx.eval_libc(mode_name)?;\n+        let mode = ecx.eval_libc(mode_name);\n \n         let size = metadata.len();\n "}, {"sha": "212b7936341a709e3808c170b16eac10e4d8257f", "filename": "src/tools/miri/src/shims/unix/linux/fd.rs", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Ffd.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -0,0 +1,191 @@\n+use rustc_middle::ty::ScalarInt;\n+\n+use crate::*;\n+use epoll::{Epoll, EpollEvent};\n+use event::Event;\n+use socketpair::SocketPair;\n+\n+use shims::unix::fs::EvalContextExt as _;\n+\n+pub mod epoll;\n+pub mod event;\n+pub mod socketpair;\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    /// This function returns a file descriptor referring to the new `Epoll` instance. This file\n+    /// descriptor is used for all subsequent calls to the epoll interface. If the `flags` argument\n+    /// is 0, then this function is the same as `epoll_create()`.\n+    ///\n+    /// <https://linux.die.net/man/2/epoll_create1>\n+    fn epoll_create1(\n+        &mut self,\n+        flags: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n+        let this = self.eval_context_mut();\n+\n+        let flags = this.read_scalar(flags)?.to_i32()?;\n+\n+        let epoll_cloexec = this.eval_libc_i32(\"EPOLL_CLOEXEC\");\n+        if flags == epoll_cloexec {\n+            // Miri does not support exec, so this flag has no effect.\n+        } else if flags != 0 {\n+            throw_unsup_format!(\"epoll_create1 flags {flags} are not implemented\");\n+        }\n+\n+        let fd = this.machine.file_handler.insert_fd(Box::new(Epoll::default()));\n+        Ok(Scalar::from_i32(fd))\n+    }\n+\n+    /// This function performs control operations on the `Epoll` instance referred to by the file\n+    /// descriptor `epfd`. It requests that the operation `op` be performed for the target file\n+    /// descriptor, `fd`.\n+    ///\n+    /// Valid values for the op argument are:\n+    /// `EPOLL_CTL_ADD` - Register the target file descriptor `fd` on the `Epoll` instance referred\n+    /// to by the file descriptor `epfd` and associate the event `event` with the internal file\n+    /// linked to `fd`.\n+    /// `EPOLL_CTL_MOD` - Change the event `event` associated with the target file descriptor `fd`.\n+    /// `EPOLL_CTL_DEL` - Deregister the target file descriptor `fd` from the `Epoll` instance\n+    /// referred to by `epfd`. The `event` is ignored and can be null.\n+    ///\n+    /// <https://linux.die.net/man/2/epoll_ctl>\n+    fn epoll_ctl(\n+        &mut self,\n+        epfd: &OpTy<'tcx, Provenance>,\n+        op: &OpTy<'tcx, Provenance>,\n+        fd: &OpTy<'tcx, Provenance>,\n+        event: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n+        let this = self.eval_context_mut();\n+\n+        let epfd = this.read_scalar(epfd)?.to_i32()?;\n+        let op = this.read_scalar(op)?.to_i32()?;\n+        let fd = this.read_scalar(fd)?.to_i32()?;\n+        let _event = this.read_scalar(event)?.to_pointer(this)?;\n+\n+        let epoll_ctl_add = this.eval_libc_i32(\"EPOLL_CTL_ADD\");\n+        let epoll_ctl_mod = this.eval_libc_i32(\"EPOLL_CTL_MOD\");\n+        let epoll_ctl_del = this.eval_libc_i32(\"EPOLL_CTL_DEL\");\n+\n+        if op == epoll_ctl_add || op == epoll_ctl_mod {\n+            let event = this.deref_operand(event)?;\n+\n+            let events = this.mplace_field(&event, 0)?;\n+            let events = this.read_scalar(&events.into())?.to_u32()?;\n+            let data = this.mplace_field(&event, 1)?;\n+            let data = this.read_scalar(&data.into())?;\n+            let event = EpollEvent { events, data };\n+\n+            if let Some(epfd) = this.machine.file_handler.handles.get_mut(&epfd) {\n+                let epfd = epfd.as_epoll_handle()?;\n+\n+                epfd.file_descriptors.insert(fd, event);\n+                Ok(Scalar::from_i32(0))\n+            } else {\n+                Ok(Scalar::from_i32(this.handle_not_found()?))\n+            }\n+        } else if op == epoll_ctl_del {\n+            if let Some(epfd) = this.machine.file_handler.handles.get_mut(&epfd) {\n+                let epfd = epfd.as_epoll_handle()?;\n+\n+                epfd.file_descriptors.remove(&fd);\n+                Ok(Scalar::from_i32(0))\n+            } else {\n+                Ok(Scalar::from_i32(this.handle_not_found()?))\n+            }\n+        } else {\n+            let einval = this.eval_libc(\"EINVAL\");\n+            this.set_last_error(einval)?;\n+            Ok(Scalar::from_i32(-1))\n+        }\n+    }\n+\n+    /// This function creates an `Event` that is used as an event wait/notify mechanism by\n+    /// user-space applications, and by the kernel to notify user-space applications of events.\n+    /// The `Event` contains an `u64` counter maintained by the kernel. The counter is initialized\n+    /// with the value specified in the `initval` argument.\n+    ///\n+    /// A new file descriptor referring to the `Event` is returned. The `read`, `write`, `poll`,\n+    /// `select`, and `close` operations can be performed on the file descriptor. For more\n+    /// information on these operations, see the man page linked below.\n+    ///\n+    /// The `flags` are not currently implemented for eventfd.\n+    /// The `flags` may be bitwise ORed to change the behavior of `eventfd`:\n+    /// `EFD_CLOEXEC` - Set the close-on-exec (`FD_CLOEXEC`) flag on the new file descriptor.\n+    /// `EFD_NONBLOCK` - Set the `O_NONBLOCK` file status flag on the new open file description.\n+    /// `EFD_SEMAPHORE` - miri does not support semaphore-like semantics.\n+    ///\n+    /// <https://linux.die.net/man/2/eventfd>\n+    fn eventfd(\n+        &mut self,\n+        val: &OpTy<'tcx, Provenance>,\n+        flags: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n+        let this = self.eval_context_mut();\n+\n+        let val = this.read_scalar(val)?.to_u32()?;\n+        let flags = this.read_scalar(flags)?.to_i32()?;\n+\n+        let efd_cloexec = this.eval_libc_i32(\"EFD_CLOEXEC\");\n+        let efd_nonblock = this.eval_libc_i32(\"EFD_NONBLOCK\");\n+        let efd_semaphore = this.eval_libc_i32(\"EFD_SEMAPHORE\");\n+\n+        if flags & (efd_cloexec | efd_nonblock | efd_semaphore) == 0 {\n+            throw_unsup_format!(\"{flags} is unsupported\");\n+        }\n+        // FIXME handle the cloexec and nonblock flags\n+        if flags & efd_cloexec == efd_cloexec {}\n+        if flags & efd_nonblock == efd_nonblock {}\n+        if flags & efd_semaphore == efd_semaphore {\n+            throw_unsup_format!(\"EFD_SEMAPHORE is unsupported\");\n+        }\n+\n+        let fh = &mut this.machine.file_handler;\n+        let fd = fh.insert_fd(Box::new(Event { val }));\n+        Ok(Scalar::from_i32(fd))\n+    }\n+\n+    /// Currently this function creates new `SocketPair`s without specifying the domain, type, or\n+    /// protocol of the new socket and these are stored in the socket values `sv` argument.\n+    ///\n+    /// This function creates an unnamed pair of connected sockets in the specified domain, of the\n+    /// specified type, and using the optionally specified protocol.\n+    ///\n+    /// The `domain` argument specified a communication domain; this selects the protocol family\n+    /// used for communication. The socket `type` specifies the communication semantics.\n+    /// The `protocol` specifies a particular protocol to use with the socket. Normally there's\n+    /// only a single protocol supported for a particular socket type within a given protocol\n+    /// family, in which case `protocol` can be specified as 0. It is possible that many protocols\n+    /// exist and in that case, a particular protocol must be specified.\n+    ///\n+    /// For more information on the arguments see the socket manpage:\n+    /// <https://linux.die.net/man/2/socket>\n+    ///\n+    /// <https://linux.die.net/man/2/socketpair>\n+    fn socketpair(\n+        &mut self,\n+        domain: &OpTy<'tcx, Provenance>,\n+        type_: &OpTy<'tcx, Provenance>,\n+        protocol: &OpTy<'tcx, Provenance>,\n+        sv: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n+        let this = self.eval_context_mut();\n+\n+        let _domain = this.read_scalar(domain)?.to_i32()?;\n+        let _type_ = this.read_scalar(type_)?.to_i32()?;\n+        let _protocol = this.read_scalar(protocol)?.to_i32()?;\n+        let sv = this.deref_operand(sv)?;\n+\n+        let fh = &mut this.machine.file_handler;\n+        let sv0 = fh.insert_fd(Box::new(SocketPair));\n+        let sv0 = ScalarInt::try_from_int(sv0, sv.layout.size).unwrap();\n+        let sv1 = fh.insert_fd(Box::new(SocketPair));\n+        let sv1 = ScalarInt::try_from_int(sv1, sv.layout.size).unwrap();\n+\n+        this.write_scalar(sv0, &sv.into())?;\n+        this.write_scalar(sv1, &sv.offset(sv.layout.size, sv.layout, this)?.into())?;\n+\n+        Ok(Scalar::from_i32(0))\n+    }\n+}"}, {"sha": "e33673fecf6f3234ea5a8e9d58bad898797909ff", "filename": "src/tools/miri/src/shims/unix/linux/fd/epoll.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Ffd%2Fepoll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Ffd%2Fepoll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Ffd%2Fepoll.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -0,0 +1,53 @@\n+use crate::*;\n+\n+use crate::shims::unix::fs::FileDescriptor;\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use std::io;\n+\n+/// An `Epoll` file descriptor connects file handles and epoll events\n+#[derive(Clone, Debug, Default)]\n+pub struct Epoll {\n+    /// The file descriptors we are watching, and what we are watching for.\n+    pub file_descriptors: FxHashMap<i32, EpollEvent>,\n+}\n+\n+/// Epoll Events associate events with data.\n+/// These fields are currently unused by miri.\n+/// This matches the `epoll_event` struct defined\n+/// by the epoll_ctl man page. For more information\n+/// see the man page:\n+///\n+/// <https://man7.org/linux/man-pages/man2/epoll_ctl.2.html>\n+#[derive(Clone, Debug)]\n+pub struct EpollEvent {\n+    pub events: u32,\n+    /// `Scalar<Provenance>` is used to represent the\n+    /// `epoll_data` type union.\n+    pub data: Scalar<Provenance>,\n+}\n+\n+impl FileDescriptor for Epoll {\n+    fn name(&self) -> &'static str {\n+        \"epoll\"\n+    }\n+\n+    fn as_epoll_handle<'tcx>(&mut self) -> InterpResult<'tcx, &mut Epoll> {\n+        Ok(self)\n+    }\n+\n+    fn dup(&mut self) -> io::Result<Box<dyn FileDescriptor>> {\n+        Ok(Box::new(self.clone()))\n+    }\n+\n+    fn is_tty(&self) -> bool {\n+        false\n+    }\n+\n+    fn close<'tcx>(\n+        self: Box<Self>,\n+        _communicate_allowed: bool,\n+    ) -> InterpResult<'tcx, io::Result<i32>> {\n+        Ok(Ok(0))\n+    }\n+}"}, {"sha": "239eb462a1d232e8385ce148fac53b6a1ead2e15", "filename": "src/tools/miri/src/shims/unix/linux/fd/event.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Ffd%2Fevent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Ffd%2Fevent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Ffd%2Fevent.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -0,0 +1,38 @@\n+use crate::shims::unix::fs::FileDescriptor;\n+\n+use rustc_const_eval::interpret::InterpResult;\n+\n+use std::io;\n+\n+/// A kind of file descriptor created by `eventfd`.\n+/// The `Event` type isn't currently written to by `eventfd`.\n+/// The interface is meant to keep track of objects associated\n+/// with a file descriptor. For more information see the man\n+/// page below:\n+///\n+/// <https://man.netbsd.org/eventfd.2>\n+#[derive(Debug)]\n+pub struct Event {\n+    pub val: u32,\n+}\n+\n+impl FileDescriptor for Event {\n+    fn name(&self) -> &'static str {\n+        \"event\"\n+    }\n+\n+    fn dup(&mut self) -> io::Result<Box<dyn FileDescriptor>> {\n+        Ok(Box::new(Event { val: self.val }))\n+    }\n+\n+    fn is_tty(&self) -> bool {\n+        false\n+    }\n+\n+    fn close<'tcx>(\n+        self: Box<Self>,\n+        _communicate_allowed: bool,\n+    ) -> InterpResult<'tcx, io::Result<i32>> {\n+        Ok(Ok(0))\n+    }\n+}"}, {"sha": "f9e56b4a2b40e2839201e587b4906a8f4530cd83", "filename": "src/tools/miri/src/shims/unix/linux/fd/socketpair.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Ffd%2Fsocketpair.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Ffd%2Fsocketpair.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Ffd%2Fsocketpair.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -0,0 +1,32 @@\n+use crate::*;\n+\n+use crate::shims::unix::fs::FileDescriptor;\n+\n+use std::io;\n+\n+/// Pair of connected sockets.\n+///\n+/// We currently don't allow sending any data through this pair, so this can be just a dummy.\n+#[derive(Debug)]\n+pub struct SocketPair;\n+\n+impl FileDescriptor for SocketPair {\n+    fn name(&self) -> &'static str {\n+        \"socketpair\"\n+    }\n+\n+    fn dup(&mut self) -> io::Result<Box<dyn FileDescriptor>> {\n+        Ok(Box::new(SocketPair))\n+    }\n+\n+    fn is_tty(&self) -> bool {\n+        false\n+    }\n+\n+    fn close<'tcx>(\n+        self: Box<Self>,\n+        _communicate_allowed: bool,\n+    ) -> InterpResult<'tcx, io::Result<i32>> {\n+        Ok(Ok(0))\n+    }\n+}"}, {"sha": "82cb21c124a2670be7a4e986555b0aa134cab0e9", "filename": "src/tools/miri/src/shims/unix/linux/foreign_items.rs", "status": "modified", "additions": 35, "deletions": 4, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fforeign_items.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -1,9 +1,11 @@\n use rustc_span::Symbol;\n use rustc_target::spec::abi::Abi;\n \n+use crate::machine::SIGRTMAX;\n use crate::*;\n use shims::foreign_items::EmulateByNameResult;\n use shims::unix::fs::EvalContextExt as _;\n+use shims::unix::linux::fd::EvalContextExt as _;\n use shims::unix::linux::sync::futex;\n use shims::unix::sync::EvalContextExt as _;\n use shims::unix::thread::EvalContextExt as _;\n@@ -42,6 +44,35 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let result = this.sync_file_range(fd, offset, nbytes, flags)?;\n                 this.write_scalar(result, dest)?;\n             }\n+            \"epoll_create1\" => {\n+                let [flag] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.epoll_create1(flag)?;\n+                this.write_scalar(result, dest)?;\n+            }\n+            \"epoll_ctl\" => {\n+                let [epfd, op, fd, event] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.epoll_ctl(epfd, op, fd, event)?;\n+                this.write_scalar(result, dest)?;\n+            }\n+            \"eventfd\" => {\n+                let [val, flag] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+                let result = this.eventfd(val, flag)?;\n+                this.write_scalar(result, dest)?;\n+            }\n+            \"socketpair\" => {\n+                let [domain, type_, protocol, sv] =\n+                    this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+\n+                let result = this.socketpair(domain, type_, protocol, sv)?;\n+                this.write_scalar(result, dest)?;\n+            }\n+            \"__libc_current_sigrtmax\" => {\n+                let [] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n+\n+                this.write_scalar(Scalar::from_i32(SIGRTMAX), dest)?;\n+            }\n \n             // Threading\n             \"pthread_condattr_setclock\" => {\n@@ -88,11 +119,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 // argument, we have to also check all arguments *before* it to ensure that they\n                 // have the right type.\n \n-                let sys_getrandom = this.eval_libc(\"SYS_getrandom\")?.to_machine_usize(this)?;\n+                let sys_getrandom = this.eval_libc(\"SYS_getrandom\").to_machine_usize(this)?;\n \n-                let sys_statx = this.eval_libc(\"SYS_statx\")?.to_machine_usize(this)?;\n+                let sys_statx = this.eval_libc(\"SYS_statx\").to_machine_usize(this)?;\n \n-                let sys_futex = this.eval_libc(\"SYS_futex\")?.to_machine_usize(this)?;\n+                let sys_futex = this.eval_libc(\"SYS_futex\").to_machine_usize(this)?;\n \n                 if args.is_empty() {\n                     throw_ub_format!(\n@@ -150,7 +181,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 this.read_machine_usize(cpusetsize)?;\n                 this.deref_operand(mask)?;\n                 // FIXME: we just return an error; `num_cpus` then falls back to `sysconf`.\n-                let einval = this.eval_libc(\"EINVAL\")?;\n+                let einval = this.eval_libc(\"EINVAL\");\n                 this.set_last_error(einval)?;\n                 this.write_scalar(Scalar::from_i32(-1), dest)?;\n             }"}, {"sha": "437764c3824eb00d18d880963756149ae908741a", "filename": "src/tools/miri/src/shims/unix/linux/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fmod.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -1,3 +1,4 @@\n pub mod dlsym;\n+pub mod fd;\n pub mod foreign_items;\n pub mod sync;"}, {"sha": "ef43c9b0ff438bca79b8e543d0f8fbfa05357407", "filename": "src/tools/miri/src/shims/unix/linux/sync.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fsync.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -37,12 +37,12 @@ pub fn futex<'tcx>(\n     let addr = MPlaceTy::from_aligned_ptr(addr, this.machine.layouts.i32);\n     let addr_usize = addr.ptr.addr().bytes();\n \n-    let futex_private = this.eval_libc_i32(\"FUTEX_PRIVATE_FLAG\")?;\n-    let futex_wait = this.eval_libc_i32(\"FUTEX_WAIT\")?;\n-    let futex_wait_bitset = this.eval_libc_i32(\"FUTEX_WAIT_BITSET\")?;\n-    let futex_wake = this.eval_libc_i32(\"FUTEX_WAKE\")?;\n-    let futex_wake_bitset = this.eval_libc_i32(\"FUTEX_WAKE_BITSET\")?;\n-    let futex_realtime = this.eval_libc_i32(\"FUTEX_CLOCK_REALTIME\")?;\n+    let futex_private = this.eval_libc_i32(\"FUTEX_PRIVATE_FLAG\");\n+    let futex_wait = this.eval_libc_i32(\"FUTEX_WAIT\");\n+    let futex_wait_bitset = this.eval_libc_i32(\"FUTEX_WAIT_BITSET\");\n+    let futex_wake = this.eval_libc_i32(\"FUTEX_WAKE\");\n+    let futex_wake_bitset = this.eval_libc_i32(\"FUTEX_WAKE_BITSET\");\n+    let futex_realtime = this.eval_libc_i32(\"FUTEX_CLOCK_REALTIME\");\n \n     // FUTEX_PRIVATE enables an optimization that stops it from working across processes.\n     // Miri doesn't support that anyway, so we ignore that flag.\n@@ -79,7 +79,7 @@ pub fn futex<'tcx>(\n             };\n \n             if bitset == 0 {\n-                let einval = this.eval_libc(\"EINVAL\")?;\n+                let einval = this.eval_libc(\"EINVAL\");\n                 this.set_last_error(einval)?;\n                 this.write_scalar(Scalar::from_machine_isize(-1, this), dest)?;\n                 return Ok(());\n@@ -90,30 +90,31 @@ pub fn futex<'tcx>(\n             let timeout_time = if this.ptr_is_null(timeout.ptr)? {\n                 None\n             } else {\n-                if op & futex_realtime != 0 {\n+                let realtime = op & futex_realtime == futex_realtime;\n+                if realtime {\n                     this.check_no_isolation(\n                         \"`futex` syscall with `op=FUTEX_WAIT` and non-null timeout with `FUTEX_CLOCK_REALTIME`\",\n                     )?;\n                 }\n                 let duration = match this.read_timespec(&timeout)? {\n                     Some(duration) => duration,\n                     None => {\n-                        let einval = this.eval_libc(\"EINVAL\")?;\n+                        let einval = this.eval_libc(\"EINVAL\");\n                         this.set_last_error(einval)?;\n                         this.write_scalar(Scalar::from_machine_isize(-1, this), dest)?;\n                         return Ok(());\n                     }\n                 };\n                 Some(if wait_bitset {\n                     // FUTEX_WAIT_BITSET uses an absolute timestamp.\n-                    if op & futex_realtime != 0 {\n+                    if realtime {\n                         Time::RealTime(SystemTime::UNIX_EPOCH.checked_add(duration).unwrap())\n                     } else {\n                         Time::Monotonic(this.machine.clock.anchor().checked_add(duration).unwrap())\n                     }\n                 } else {\n                     // FUTEX_WAIT uses a relative timestamp.\n-                    if op & futex_realtime != 0 {\n+                    if realtime {\n                         Time::RealTime(SystemTime::now().checked_add(duration).unwrap())\n                     } else {\n                         Time::Monotonic(this.machine.clock.now().checked_add(duration).unwrap())\n@@ -193,7 +194,7 @@ pub fn futex<'tcx>(\n                         fn call(&self, this: &mut MiriInterpCx<'mir, 'tcx>) -> InterpResult<'tcx> {\n                             this.unblock_thread(self.thread);\n                             this.futex_remove_waiter(self.addr_usize, self.thread);\n-                            let etimedout = this.eval_libc(\"ETIMEDOUT\")?;\n+                            let etimedout = this.eval_libc(\"ETIMEDOUT\");\n                             this.set_last_error(etimedout)?;\n                             this.write_scalar(Scalar::from_machine_isize(-1, this), &self.dest)?;\n \n@@ -210,7 +211,7 @@ pub fn futex<'tcx>(\n             } else {\n                 // The futex value doesn't match the expected value, so we return failure\n                 // right away without sleeping: -1 and errno set to EAGAIN.\n-                let eagain = this.eval_libc(\"EAGAIN\")?;\n+                let eagain = this.eval_libc(\"EAGAIN\");\n                 this.set_last_error(eagain)?;\n                 this.write_scalar(Scalar::from_machine_isize(-1, this), dest)?;\n             }\n@@ -236,7 +237,7 @@ pub fn futex<'tcx>(\n                 u32::MAX\n             };\n             if bitset == 0 {\n-                let einval = this.eval_libc(\"EINVAL\")?;\n+                let einval = this.eval_libc(\"EINVAL\");\n                 this.set_last_error(einval)?;\n                 this.write_scalar(Scalar::from_machine_isize(-1, this), dest)?;\n                 return Ok(());"}, {"sha": "a55b0ee523b0880b9c5a67ee9a4fa2bfba625aac", "filename": "src/tools/miri/src/shims/unix/macos/foreign_items.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fmacos%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fmacos%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fmacos%2Fforeign_items.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -162,21 +162,21 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             \"pthread_get_stackaddr_np\" => {\n                 let [thread] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.read_machine_usize(thread)?;\n-                let stack_addr = Scalar::from_uint(STACK_ADDR, this.pointer_size());\n+                let stack_addr = Scalar::from_uint(this.machine.stack_addr, this.pointer_size());\n                 this.write_scalar(stack_addr, dest)?;\n             }\n             \"pthread_get_stacksize_np\" => {\n                 let [thread] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 this.read_machine_usize(thread)?;\n-                let stack_size = Scalar::from_uint(STACK_SIZE, this.pointer_size());\n+                let stack_size = Scalar::from_uint(this.machine.stack_size, this.pointer_size());\n                 this.write_scalar(stack_size, dest)?;\n             }\n \n             // Threading\n             \"pthread_setname_np\" => {\n                 let [name] = this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;\n                 let thread = this.pthread_self()?;\n-                let max_len = this.eval_libc(\"MAXTHREADNAMESIZE\")?.to_machine_usize(this)?;\n+                let max_len = this.eval_libc(\"MAXTHREADNAMESIZE\").to_machine_usize(this)?;\n                 let res = this.pthread_setname_np(\n                     thread,\n                     this.read_scalar(name)?,"}, {"sha": "b3c474dd3c9f19ddcedac12142ebaa72a238126b", "filename": "src/tools/miri/src/shims/unix/sync.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -21,14 +21,14 @@ fn is_mutex_kind_default<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriInterpCx<'mir, 'tcx>,\n     kind: i32,\n ) -> InterpResult<'tcx, bool> {\n-    Ok(kind == ecx.eval_libc_i32(\"PTHREAD_MUTEX_DEFAULT\")?)\n+    Ok(kind == ecx.eval_libc_i32(\"PTHREAD_MUTEX_DEFAULT\"))\n }\n \n fn is_mutex_kind_normal<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriInterpCx<'mir, 'tcx>,\n     kind: i32,\n ) -> InterpResult<'tcx, bool> {\n-    let mutex_normal_kind = ecx.eval_libc_i32(\"PTHREAD_MUTEX_NORMAL\")?;\n+    let mutex_normal_kind = ecx.eval_libc_i32(\"PTHREAD_MUTEX_NORMAL\");\n     Ok(kind == (mutex_normal_kind | PTHREAD_MUTEX_NORMAL_FLAG))\n }\n \n@@ -217,7 +217,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let default_kind = this.eval_libc_i32(\"PTHREAD_MUTEX_DEFAULT\")?;\n+        let default_kind = this.eval_libc_i32(\"PTHREAD_MUTEX_DEFAULT\");\n         mutexattr_set_kind(this, attr_op, default_kind)?;\n \n         Ok(0)\n@@ -231,7 +231,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n \n         let kind = this.read_scalar(kind_op)?.to_i32()?;\n-        if kind == this.eval_libc_i32(\"PTHREAD_MUTEX_NORMAL\")? {\n+        if kind == this.eval_libc_i32(\"PTHREAD_MUTEX_NORMAL\") {\n             // In `glibc` implementation, the numeric values of\n             // `PTHREAD_MUTEX_NORMAL` and `PTHREAD_MUTEX_DEFAULT` are equal.\n             // However, a mutex created by explicitly passing\n@@ -247,17 +247,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             let normal_kind = kind | PTHREAD_MUTEX_NORMAL_FLAG;\n             // Check that after setting the flag, the kind is distinguishable\n             // from all other kinds.\n-            assert_ne!(normal_kind, this.eval_libc_i32(\"PTHREAD_MUTEX_DEFAULT\")?);\n-            assert_ne!(normal_kind, this.eval_libc_i32(\"PTHREAD_MUTEX_ERRORCHECK\")?);\n-            assert_ne!(normal_kind, this.eval_libc_i32(\"PTHREAD_MUTEX_RECURSIVE\")?);\n+            assert_ne!(normal_kind, this.eval_libc_i32(\"PTHREAD_MUTEX_DEFAULT\"));\n+            assert_ne!(normal_kind, this.eval_libc_i32(\"PTHREAD_MUTEX_ERRORCHECK\"));\n+            assert_ne!(normal_kind, this.eval_libc_i32(\"PTHREAD_MUTEX_RECURSIVE\"));\n             mutexattr_set_kind(this, attr_op, normal_kind)?;\n-        } else if kind == this.eval_libc_i32(\"PTHREAD_MUTEX_DEFAULT\")?\n-            || kind == this.eval_libc_i32(\"PTHREAD_MUTEX_ERRORCHECK\")?\n-            || kind == this.eval_libc_i32(\"PTHREAD_MUTEX_RECURSIVE\")?\n+        } else if kind == this.eval_libc_i32(\"PTHREAD_MUTEX_DEFAULT\")\n+            || kind == this.eval_libc_i32(\"PTHREAD_MUTEX_ERRORCHECK\")\n+            || kind == this.eval_libc_i32(\"PTHREAD_MUTEX_RECURSIVE\")\n         {\n             mutexattr_set_kind(this, attr_op, kind)?;\n         } else {\n-            let einval = this.eval_libc_i32(\"EINVAL\")?;\n+            let einval = this.eval_libc_i32(\"EINVAL\");\n             return Ok(einval);\n         }\n \n@@ -299,7 +299,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         let attr = this.read_pointer(attr_op)?;\n         let kind = if this.ptr_is_null(attr)? {\n-            this.eval_libc_i32(\"PTHREAD_MUTEX_DEFAULT\")?\n+            this.eval_libc_i32(\"PTHREAD_MUTEX_DEFAULT\")\n         } else {\n             mutexattr_get_kind(this, attr_op)?\n         };\n@@ -331,9 +331,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                     throw_ub_format!(\"trying to acquire already locked default mutex\");\n                 } else if is_mutex_kind_normal(this, kind)? {\n                     throw_machine_stop!(TerminationInfo::Deadlock);\n-                } else if kind == this.eval_libc_i32(\"PTHREAD_MUTEX_ERRORCHECK\")? {\n-                    this.eval_libc_i32(\"EDEADLK\")\n-                } else if kind == this.eval_libc_i32(\"PTHREAD_MUTEX_RECURSIVE\")? {\n+                } else if kind == this.eval_libc_i32(\"PTHREAD_MUTEX_ERRORCHECK\") {\n+                    Ok(this.eval_libc_i32(\"EDEADLK\"))\n+                } else if kind == this.eval_libc_i32(\"PTHREAD_MUTEX_RECURSIVE\") {\n                     this.mutex_lock(id, active_thread);\n                     Ok(0)\n                 } else {\n@@ -362,14 +362,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         if this.mutex_is_locked(id) {\n             let owner_thread = this.mutex_get_owner(id);\n             if owner_thread != active_thread {\n-                this.eval_libc_i32(\"EBUSY\")\n+                Ok(this.eval_libc_i32(\"EBUSY\"))\n             } else {\n                 if is_mutex_kind_default(this, kind)?\n                     || is_mutex_kind_normal(this, kind)?\n-                    || kind == this.eval_libc_i32(\"PTHREAD_MUTEX_ERRORCHECK\")?\n+                    || kind == this.eval_libc_i32(\"PTHREAD_MUTEX_ERRORCHECK\")\n                 {\n-                    this.eval_libc_i32(\"EBUSY\")\n-                } else if kind == this.eval_libc_i32(\"PTHREAD_MUTEX_RECURSIVE\")? {\n+                    Ok(this.eval_libc_i32(\"EBUSY\"))\n+                } else if kind == this.eval_libc_i32(\"PTHREAD_MUTEX_RECURSIVE\") {\n                     this.mutex_lock(id, active_thread);\n                     Ok(0)\n                 } else {\n@@ -410,10 +410,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 throw_ub_format!(\n                     \"unlocked a PTHREAD_MUTEX_NORMAL mutex that was not locked by the current thread\"\n                 );\n-            } else if kind == this.eval_libc_i32(\"PTHREAD_MUTEX_ERRORCHECK\")?\n-                || kind == this.eval_libc_i32(\"PTHREAD_MUTEX_RECURSIVE\")?\n+            } else if kind == this.eval_libc_i32(\"PTHREAD_MUTEX_ERRORCHECK\")\n+                || kind == this.eval_libc_i32(\"PTHREAD_MUTEX_RECURSIVE\")\n             {\n-                this.eval_libc_i32(\"EPERM\")\n+                Ok(this.eval_libc_i32(\"EPERM\"))\n             } else {\n                 throw_unsup_format!(\"called pthread_mutex_unlock on an unsupported type of mutex\");\n             }\n@@ -471,7 +471,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_write_locked(id) {\n-            this.eval_libc_i32(\"EBUSY\")\n+            Ok(this.eval_libc_i32(\"EBUSY\"))\n         } else {\n             this.rwlock_reader_lock(id, active_thread);\n             Ok(0)\n@@ -518,7 +518,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_locked(id) {\n-            this.eval_libc_i32(\"EBUSY\")\n+            Ok(this.eval_libc_i32(\"EBUSY\"))\n         } else {\n             this.rwlock_writer_lock(id, active_thread);\n             Ok(0)\n@@ -575,7 +575,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // The default value of the clock attribute shall refer to the system\n         // clock.\n         // https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_condattr_setclock.html\n-        let default_clock_id = this.eval_libc_i32(\"CLOCK_REALTIME\")?;\n+        let default_clock_id = this.eval_libc_i32(\"CLOCK_REALTIME\");\n         condattr_set_clock_id(this, attr_op, default_clock_id)?;\n \n         Ok(0)\n@@ -589,12 +589,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n \n         let clock_id = this.read_scalar(clock_id_op)?.to_i32()?;\n-        if clock_id == this.eval_libc_i32(\"CLOCK_REALTIME\")?\n-            || clock_id == this.eval_libc_i32(\"CLOCK_MONOTONIC\")?\n+        if clock_id == this.eval_libc_i32(\"CLOCK_REALTIME\")\n+            || clock_id == this.eval_libc_i32(\"CLOCK_MONOTONIC\")\n         {\n             condattr_set_clock_id(this, attr_op, clock_id)?;\n         } else {\n-            let einval = this.eval_libc_i32(\"EINVAL\")?;\n+            let einval = this.eval_libc_i32(\"EINVAL\");\n             return Ok(Scalar::from_i32(einval));\n         }\n \n@@ -638,7 +638,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         let attr = this.read_pointer(attr_op)?;\n         let clock_id = if this.ptr_is_null(attr)? {\n-            this.eval_libc_i32(\"CLOCK_REALTIME\")?\n+            this.eval_libc_i32(\"CLOCK_REALTIME\")\n         } else {\n             condattr_get_clock_id(this, attr_op)?\n         };\n@@ -718,16 +718,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let duration = match this.read_timespec(&this.deref_operand(abstime_op)?)? {\n             Some(duration) => duration,\n             None => {\n-                let einval = this.eval_libc(\"EINVAL\")?;\n+                let einval = this.eval_libc(\"EINVAL\");\n                 this.write_scalar(einval, dest)?;\n                 return Ok(());\n             }\n         };\n \n-        let timeout_time = if clock_id == this.eval_libc_i32(\"CLOCK_REALTIME\")? {\n+        let timeout_time = if clock_id == this.eval_libc_i32(\"CLOCK_REALTIME\") {\n             this.check_no_isolation(\"`pthread_cond_timedwait` with `CLOCK_REALTIME`\")?;\n             Time::RealTime(SystemTime::UNIX_EPOCH.checked_add(duration).unwrap())\n-        } else if clock_id == this.eval_libc_i32(\"CLOCK_MONOTONIC\")? {\n+        } else if clock_id == this.eval_libc_i32(\"CLOCK_MONOTONIC\") {\n             Time::Monotonic(this.machine.clock.anchor().checked_add(duration).unwrap())\n         } else {\n             throw_unsup_format!(\"unsupported clock id: {}\", clock_id);\n@@ -763,7 +763,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 ecx.condvar_remove_waiter(self.id, self.active_thread);\n \n                 // Set the return value: we timed out.\n-                let etimedout = ecx.eval_libc(\"ETIMEDOUT\")?;\n+                let etimedout = ecx.eval_libc(\"ETIMEDOUT\");\n                 ecx.write_scalar(etimedout, &self.dest)?;\n \n                 Ok(())"}, {"sha": "832628003d7709fee00221ccb59c49b88306053a", "filename": "src/tools/miri/src/shims/unix/thread.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fthread.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -84,7 +84,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         // Comparing with `>=` to account for null terminator.\n         if name.len() >= max_name_len {\n-            return this.eval_libc(\"ERANGE\");\n+            return Ok(this.eval_libc(\"ERANGE\"));\n         }\n \n         this.set_thread_name(thread, name);\n@@ -107,7 +107,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let name = this.get_thread_name(thread).to_owned();\n         let (success, _written) = this.write_c_str(&name, name_out, len)?;\n \n-        if success { Ok(Scalar::from_u32(0)) } else { this.eval_libc(\"ERANGE\") }\n+        Ok(if success { Scalar::from_u32(0) } else { this.eval_libc(\"ERANGE\") })\n     }\n \n     fn sched_yield(&mut self) -> InterpResult<'tcx, i32> {"}, {"sha": "1da8f7c0e3e433ff660ccd1172f6844d307b2bca", "filename": "src/tools/miri/src/shims/windows/foreign_items.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -76,7 +76,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 this.read_machine_isize(handle)?;\n                 let flags = this.read_scalar(flags)?.to_u32()?;\n                 let size = this.read_machine_usize(size)?;\n-                let zero_init = (flags & 0x00000008) != 0; // HEAP_ZERO_MEMORY\n+                let heap_zero_memory = 0x00000008; // HEAP_ZERO_MEMORY\n+                let zero_init = (flags & heap_zero_memory) == heap_zero_memory;\n                 let res = this.malloc(size, zero_init, MiriMemoryKind::WinHeap)?;\n                 this.write_pointer(res, dest)?;\n             }\n@@ -158,7 +159,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 // Set page size.\n                 let page_size = system_info.offset(field_offsets[2], dword_layout, &this.tcx)?;\n                 this.write_scalar(\n-                    Scalar::from_int(PAGE_SIZE, dword_layout.size),\n+                    Scalar::from_int(this.machine.page_size, dword_layout.size),\n                     &page_size.into(),\n                 )?;\n                 // Set number of processors."}, {"sha": "9177f1632f704e74982f552404e012a7efd77d03", "filename": "src/tools/miri/src/shims/windows/sync.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -170,7 +170,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         match this.init_once_status(id) {\n             InitOnceStatus::Uninitialized => {\n                 this.init_once_begin(id);\n-                this.write_scalar(this.eval_windows(\"c\", \"TRUE\")?, &pending_place)?;\n+                this.write_scalar(this.eval_windows(\"c\", \"TRUE\"), &pending_place)?;\n             }\n             InitOnceStatus::Begun => {\n                 // Someone else is already on it.\n@@ -195,8 +195,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                                 unreachable!(\n                                     \"status should have either been set to begun or complete\"\n                                 ),\n-                            InitOnceStatus::Begun => this.eval_windows(\"c\", \"TRUE\")?,\n-                            InitOnceStatus::Complete => this.eval_windows(\"c\", \"FALSE\")?,\n+                            InitOnceStatus::Begun => this.eval_windows(\"c\", \"TRUE\"),\n+                            InitOnceStatus::Complete => this.eval_windows(\"c\", \"FALSE\"),\n                         };\n \n                         this.write_scalar(pending, &self.pending_place)?;\n@@ -213,12 +213,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             }\n             InitOnceStatus::Complete => {\n                 this.init_once_observe_completed(id);\n-                this.write_scalar(this.eval_windows(\"c\", \"FALSE\")?, &pending_place)?;\n+                this.write_scalar(this.eval_windows(\"c\", \"FALSE\"), &pending_place)?;\n             }\n         }\n \n         // This always succeeds (even if the thread is blocked, we will succeed if we ever unblock).\n-        this.eval_windows(\"c\", \"TRUE\")\n+        Ok(this.eval_windows(\"c\", \"TRUE\"))\n     }\n \n     fn InitOnceComplete(\n@@ -235,7 +235,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         let success = if flags == 0 {\n             true\n-        } else if flags == this.eval_windows(\"c\", \"INIT_ONCE_INIT_FAILED\")?.to_u32()? {\n+        } else if flags == this.eval_windows_u32(\"c\", \"INIT_ONCE_INIT_FAILED\") {\n             false\n         } else {\n             throw_unsup_format!(\"unsupported `dwFlags` {flags} in `InitOnceBeginInitialize`\");\n@@ -258,7 +258,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             this.init_once_fail(id)?;\n         }\n \n-        this.eval_windows(\"c\", \"TRUE\")\n+        Ok(this.eval_windows(\"c\", \"TRUE\"))\n     }\n \n     fn WaitOnAddress(\n@@ -280,14 +280,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let addr = ptr.addr().bytes();\n \n         if size > 8 || !size.is_power_of_two() {\n-            let invalid_param = this.eval_windows(\"c\", \"ERROR_INVALID_PARAMETER\")?;\n+            let invalid_param = this.eval_windows(\"c\", \"ERROR_INVALID_PARAMETER\");\n             this.set_last_error(invalid_param)?;\n             this.write_scalar(Scalar::from_i32(0), dest)?;\n             return Ok(());\n         };\n         let size = Size::from_bytes(size);\n \n-        let timeout_time = if timeout_ms == this.eval_windows(\"c\", \"INFINITE\")?.to_u32()? {\n+        let timeout_time = if timeout_ms == this.eval_windows_u32(\"c\", \"INFINITE\") {\n             None\n         } else {\n             let duration = Duration::from_millis(timeout_ms.into());\n@@ -325,7 +325,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                     fn call(&self, this: &mut MiriInterpCx<'mir, 'tcx>) -> InterpResult<'tcx> {\n                         this.unblock_thread(self.thread);\n                         this.futex_remove_waiter(self.addr, self.thread);\n-                        let error_timeout = this.eval_windows(\"c\", \"ERROR_TIMEOUT\")?;\n+                        let error_timeout = this.eval_windows(\"c\", \"ERROR_TIMEOUT\");\n                         this.set_last_error(error_timeout)?;\n                         this.write_scalar(Scalar::from_i32(0), &self.dest)?;\n \n@@ -377,7 +377,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let timeout_ms = this.read_scalar(timeout_op)?.to_u32()?;\n         let flags = this.read_scalar(flags_op)?.to_u32()?;\n \n-        let timeout_time = if timeout_ms == this.eval_windows(\"c\", \"INFINITE\")?.to_u32()? {\n+        let timeout_time = if timeout_ms == this.eval_windows_u32(\"c\", \"INFINITE\") {\n             None\n         } else {\n             let duration = Duration::from_millis(timeout_ms.into());\n@@ -431,9 +431,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n                     this.condvar_remove_waiter(self.condvar_id, self.thread);\n \n-                    let error_timeout = this.eval_windows(\"c\", \"ERROR_TIMEOUT\")?;\n+                    let error_timeout = this.eval_windows(\"c\", \"ERROR_TIMEOUT\");\n                     this.set_last_error(error_timeout)?;\n-                    this.write_scalar(this.eval_windows(\"c\", \"FALSE\")?, &self.dest)?;\n+                    this.write_scalar(this.eval_windows(\"c\", \"FALSE\"), &self.dest)?;\n                     Ok(())\n                 }\n             }\n@@ -451,7 +451,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             );\n         }\n \n-        this.eval_windows(\"c\", \"TRUE\")\n+        Ok(this.eval_windows(\"c\", \"TRUE\"))\n     }\n \n     fn WakeConditionVariable(&mut self, condvar_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx> {"}, {"sha": "f5bf362ea1caf489fb26d5d3f2e48d1d41d235f2", "filename": "src/tools/miri/src/shims/windows/thread.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fthread.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -34,7 +34,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         };\n \n         let stack_size_param_is_a_reservation =\n-            this.eval_windows(\"c\", \"STACK_SIZE_PARAM_IS_A_RESERVATION\")?.to_u32()?;\n+            this.eval_windows_u32(\"c\", \"STACK_SIZE_PARAM_IS_A_RESERVATION\");\n \n         // We ignore the stack size, so we also ignore the\n         // `STACK_SIZE_PARAM_IS_A_RESERVATION` flag.\n@@ -73,7 +73,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             _ => this.invalid_handle(\"WaitForSingleObject\")?,\n         };\n \n-        if timeout != this.eval_windows(\"c\", \"INFINITE\")?.to_u32()? {\n+        if timeout != this.eval_windows_u32(\"c\", \"INFINITE\") {\n             throw_unsup_format!(\"`WaitForSingleObject` with non-infinite timeout\");\n         }\n "}, {"sha": "048dbbbaa0f06d9c6595376c5867f38f43580adc", "filename": "src/tools/miri/test-cargo-miri/src/main.rs", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fsrc%2Fmain.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -2,6 +2,7 @@ use byteorder::{BigEndian, ByteOrder};\n use std::env;\n #[cfg(unix)]\n use std::io::{self, BufRead};\n+use std::path::PathBuf;\n \n fn main() {\n     // Check env var set by `build.rs`.\n@@ -21,12 +22,30 @@ fn main() {\n     // If there were no arguments, access stdin and test working dir.\n     // (We rely on the test runner to always disable isolation when passing no arguments.)\n     if std::env::args().len() <= 1 {\n+        fn host_to_target_path(path: String) -> PathBuf {\n+            use std::ffi::{CStr, CString};\n+\n+            let path = CString::new(path).unwrap();\n+            let mut out = Vec::with_capacity(1024);\n+\n+            unsafe {\n+                extern \"Rust\" {\n+                    fn miri_host_to_target_path(\n+                        path: *const i8,\n+                        out: *mut i8,\n+                        out_size: usize,\n+                    ) -> usize;\n+                }\n+                let ret = miri_host_to_target_path(path.as_ptr(), out.as_mut_ptr(), out.capacity());\n+                assert_eq!(ret, 0);\n+                let out = CStr::from_ptr(out.as_ptr()).to_str().unwrap();\n+                PathBuf::from(out)\n+            }\n+        }\n+\n         // CWD should be crate root.\n-        // We have to normalize slashes, as the env var might be set for a different target's conventions.\n         let env_dir = env::current_dir().unwrap();\n-        let env_dir = env_dir.to_string_lossy().replace(\"\\\\\", \"/\");\n-        let crate_dir = env::var_os(\"CARGO_MANIFEST_DIR\").unwrap();\n-        let crate_dir = crate_dir.to_string_lossy().replace(\"\\\\\", \"/\");\n+        let crate_dir = host_to_target_path(env::var(\"CARGO_MANIFEST_DIR\").unwrap());\n         assert_eq!(env_dir, crate_dir);\n \n         #[cfg(unix)]"}, {"sha": "1cb8091f87750a1703e60f5d7f57919ecaadc61a", "filename": "src/tools/miri/test-cargo-miri/subcrate/main.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fsubcrate%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fsubcrate%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fsubcrate%2Fmain.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -4,13 +4,30 @@ use std::path::PathBuf;\n fn main() {\n     println!(\"subcrate running\");\n \n+    fn host_to_target_path(path: String) -> PathBuf {\n+        use std::ffi::{CStr, CString};\n+\n+        let path = CString::new(path).unwrap();\n+        let mut out = Vec::with_capacity(1024);\n+\n+        unsafe {\n+            extern \"Rust\" {\n+                fn miri_host_to_target_path(\n+                    path: *const i8,\n+                    out: *mut i8,\n+                    out_size: usize,\n+                ) -> usize;\n+            }\n+            let ret = miri_host_to_target_path(path.as_ptr(), out.as_mut_ptr(), out.capacity());\n+            assert_eq!(ret, 0);\n+            let out = CStr::from_ptr(out.as_ptr()).to_str().unwrap();\n+            PathBuf::from(out)\n+        }\n+    }\n+\n     // CWD should be workspace root, i.e., one level up from crate root.\n-    // We have to normalize slashes, as the env var might be set for a different target's conventions.\n     let env_dir = env::current_dir().unwrap();\n-    let env_dir = env_dir.to_string_lossy().replace(\"\\\\\", \"/\");\n-    let crate_dir = env::var_os(\"CARGO_MANIFEST_DIR\").unwrap();\n-    let crate_dir = crate_dir.to_string_lossy().replace(\"\\\\\", \"/\");\n-    let crate_dir = PathBuf::from(crate_dir);\n-    let crate_dir = crate_dir.parent().unwrap().to_string_lossy();\n+    let crate_dir = host_to_target_path(env::var(\"CARGO_MANIFEST_DIR\").unwrap());\n+    let crate_dir = crate_dir.parent().unwrap();\n     assert_eq!(env_dir, crate_dir);\n }"}, {"sha": "619d8c72fd0a7aae05a129bc720ac543f336b707", "filename": "src/tools/miri/test-cargo-miri/subcrate/test.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fsubcrate%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fsubcrate%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftest-cargo-miri%2Fsubcrate%2Ftest.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -1,16 +1,37 @@\n use std::env;\n \n+use std::path::PathBuf;\n+\n use byteorder::{ByteOrder, LittleEndian};\n \n fn main() {\n     println!(\"subcrate testing\");\n \n+    fn host_to_target_path(path: String) -> PathBuf {\n+        use std::ffi::{CStr, CString};\n+\n+        let path = CString::new(path).unwrap();\n+        let mut out = Vec::with_capacity(1024);\n+\n+        unsafe {\n+            extern \"Rust\" {\n+                fn miri_host_to_target_path(\n+                    path: *const i8,\n+                    out: *mut i8,\n+                    out_size: usize,\n+                ) -> usize;\n+            }\n+            let ret = miri_host_to_target_path(path.as_ptr(), out.as_mut_ptr(), out.capacity());\n+            assert_eq!(ret, 0);\n+            let out = CStr::from_ptr(out.as_ptr()).to_str().unwrap();\n+            PathBuf::from(out)\n+        }\n+    }\n+\n     // CWD should be crate root.\n     // We have to normalize slashes, as the env var might be set for a different target's conventions.\n     let env_dir = env::current_dir().unwrap();\n-    let env_dir = env_dir.to_string_lossy().replace(\"\\\\\", \"/\");\n-    let crate_dir = env::var_os(\"CARGO_MANIFEST_DIR\").unwrap();\n-    let crate_dir = crate_dir.to_string_lossy().replace(\"\\\\\", \"/\");\n+    let crate_dir = host_to_target_path(env::var(\"CARGO_MANIFEST_DIR\").unwrap());\n     assert_eq!(env_dir, crate_dir);\n \n     // Make sure we can call dev-dependencies."}, {"sha": "fc946d6d39b3ef58a6823138c1bf8a180e328944", "filename": "src/tools/miri/tests/fail/box-cell-alias.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fbox-cell-alias.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fbox-cell-alias.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fbox-cell-alias.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ help: <TAG> was later invalidated at offsets [0x0..0x1] by a Unique retag\n    |\n LL |     let res = helper(val, ptr);\n    |                      ^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `helper` at $DIR/box-cell-alias.rs:LL:CC\n note: inside `main`\n   --> $DIR/box-cell-alias.rs:LL:CC"}, {"sha": "7cb42c09a9677015c6dfab3772fdd0404dcfd1ca", "filename": "src/tools/miri/tests/fail/crates/tokio_mvp.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/300aa907a682dfa492f4eb394d27f5331fba0a64/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fcrates%2Ftokio_mvp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/300aa907a682dfa492f4eb394d27f5331fba0a64/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fcrates%2Ftokio_mvp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fcrates%2Ftokio_mvp.rs?ref=300aa907a682dfa492f4eb394d27f5331fba0a64", "patch": "@@ -1,7 +0,0 @@\n-//@compile-flags: -Zmiri-disable-isolation\n-//@error-pattern: can't call foreign function: epoll_create1\n-//@normalize-stderr-test: \"   = note: inside .*\\n\" -> \"\"\n-//@only-target-linux: the errors differ too much between platforms\n-\n-#[tokio::main]\n-async fn main() {}"}, {"sha": "1e7dfaa7499041851561a4da9b354f1b33b6dd95", "filename": "src/tools/miri/tests/fail/crates/tokio_mvp.stderr", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/300aa907a682dfa492f4eb394d27f5331fba0a64/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fcrates%2Ftokio_mvp.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/300aa907a682dfa492f4eb394d27f5331fba0a64/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fcrates%2Ftokio_mvp.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fcrates%2Ftokio_mvp.stderr?ref=300aa907a682dfa492f4eb394d27f5331fba0a64", "patch": "@@ -1,19 +0,0 @@\n-error: unsupported operation: can't call foreign function: epoll_create1\n-  --> CARGO_REGISTRY/.../epoll.rs:LL:CC\n-   |\n-LL |         let res = syscall!(epoll_create1(libc::EPOLL_CLOEXEC));\n-   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't call foreign function: epoll_create1\n-   |\n-   = help: this is likely not a bug in the program; it indicates that the program performed an operation that the interpreter does not support\n-   = note: BACKTRACE:\n-note: inside `main`\n-  --> $DIR/tokio_mvp.rs:LL:CC\n-   |\n-LL | #[tokio::main]\n-   | ^^^^^^^^^^^^^^\n-   = note: this error originates in the macro `syscall` which comes from the expansion of the attribute macro `tokio::main` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n-\n-error: aborting due to previous error\n-"}, {"sha": "2698c63a44563e000d4a1acea45e24e37f2309b8", "filename": "src/tools/miri/tests/fail/data_race/alloc_read_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_read_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_read_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_read_race.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -37,7 +37,7 @@ pub fn main() {\n             let pointer = &*ptr.0;\n \n             // Note: could also error due to reading uninitialized memory, but the data-race detector triggers first.\n-            *pointer.load(Ordering::Relaxed) //~ ERROR: Data race detected between Read on thread `<unnamed>` and Allocate on thread `<unnamed>`\n+            *pointer.load(Ordering::Relaxed) //~ ERROR: Data race detected between (1) Allocate on thread `<unnamed>` and (2) Read on thread `<unnamed>`\n         });\n \n         j1.join().unwrap();"}, {"sha": "5b809722c70952c3867301e0816bb4964395367b", "filename": "src/tools/miri/tests/fail/data_race/alloc_read_race.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_read_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_read_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_read_race.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -1,12 +1,17 @@\n-error: Undefined Behavior: Data race detected between Read on thread `<unnamed>` and Allocate on thread `<unnamed>` at ALLOC\n+error: Undefined Behavior: Data race detected between (1) Allocate on thread `<unnamed>` and (2) Read on thread `<unnamed>` at ALLOC. (2) just happened here\n   --> $DIR/alloc_read_race.rs:LL:CC\n    |\n LL |             *pointer.load(Ordering::Relaxed)\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Data race detected between Read on thread `<unnamed>` and Allocate on thread `<unnamed>` at ALLOC\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Data race detected between (1) Allocate on thread `<unnamed>` and (2) Read on thread `<unnamed>` at ALLOC. (2) just happened here\n    |\n+help: and (1) occurred earlier here\n+  --> $DIR/alloc_read_race.rs:LL:CC\n+   |\n+LL |             pointer.store(Box::into_raw(Box::new_uninit()), Ordering::Relaxed);\n+   |                                         ^^^^^^^^^^^^^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside closure at $DIR/alloc_read_race.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "b78d5ef27d39f1be20103156ae32e47dbbde2d2e", "filename": "src/tools/miri/tests/fail/data_race/alloc_write_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_write_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_write_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_write_race.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -35,7 +35,7 @@ pub fn main() {\n \n         let j2 = spawn(move || {\n             let pointer = &*ptr.0;\n-            *pointer.load(Ordering::Relaxed) = 2; //~ ERROR: Data race detected between Write on thread `<unnamed>` and Allocate on thread `<unnamed>`\n+            *pointer.load(Ordering::Relaxed) = 2; //~ ERROR: Data race detected between (1) Allocate on thread `<unnamed>` and (2) Write on thread `<unnamed>`\n         });\n \n         j1.join().unwrap();"}, {"sha": "8520bcf4e4ee1a0f0cbe2e4766ef57761462f118", "filename": "src/tools/miri/tests/fail/data_race/alloc_write_race.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_write_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_write_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Falloc_write_race.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -1,12 +1,17 @@\n-error: Undefined Behavior: Data race detected between Write on thread `<unnamed>` and Allocate on thread `<unnamed>` at ALLOC\n+error: Undefined Behavior: Data race detected between (1) Allocate on thread `<unnamed>` and (2) Write on thread `<unnamed>` at ALLOC. (2) just happened here\n   --> $DIR/alloc_write_race.rs:LL:CC\n    |\n LL |             *pointer.load(Ordering::Relaxed) = 2;\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Data race detected between Write on thread `<unnamed>` and Allocate on thread `<unnamed>` at ALLOC\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Data race detected between (1) Allocate on thread `<unnamed>` and (2) Write on thread `<unnamed>` at ALLOC. (2) just happened here\n    |\n+help: and (1) occurred earlier here\n+  --> $DIR/alloc_write_race.rs:LL:CC\n+   |\n+LL |                 .store(Box::into_raw(Box::<usize>::new_uninit()) as *mut usize, Ordering::Relaxed);\n+   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside closure at $DIR/alloc_write_race.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "3f811d0f64d0493a4acd898eab458bff8529ad88", "filename": "src/tools/miri/tests/fail/data_race/atomic_read_na_write_race1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race1.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -20,7 +20,7 @@ pub fn main() {\n         });\n \n         let j2 = spawn(move || {\n-            (&*c.0).load(Ordering::SeqCst) //~ ERROR: Data race detected between Atomic Load on thread `<unnamed>` and Write on thread `<unnamed>`\n+            (&*c.0).load(Ordering::SeqCst) //~ ERROR: Data race detected between (1) Write on thread `<unnamed>` and (2) Atomic Load on thread `<unnamed>`\n         });\n \n         j1.join().unwrap();"}, {"sha": "e25629e14eada40978753c0ad2b0571ac93c8d0d", "filename": "src/tools/miri/tests/fail/data_race/atomic_read_na_write_race1.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race1.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -1,12 +1,17 @@\n-error: Undefined Behavior: Data race detected between Atomic Load on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n+error: Undefined Behavior: Data race detected between (1) Write on thread `<unnamed>` and (2) Atomic Load on thread `<unnamed>` at ALLOC. (2) just happened here\n   --> $DIR/atomic_read_na_write_race1.rs:LL:CC\n    |\n LL |             (&*c.0).load(Ordering::SeqCst)\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Data race detected between Atomic Load on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Data race detected between (1) Write on thread `<unnamed>` and (2) Atomic Load on thread `<unnamed>` at ALLOC. (2) just happened here\n    |\n+help: and (1) occurred earlier here\n+  --> $DIR/atomic_read_na_write_race1.rs:LL:CC\n+   |\n+LL |             *(c.0 as *mut usize) = 32;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside closure at $DIR/atomic_read_na_write_race1.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "34fb3ac066f5fc30190b3f59b984833d3aa07280", "filename": "src/tools/miri/tests/fail/data_race/atomic_read_na_write_race2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race2.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -23,7 +23,7 @@ pub fn main() {\n \n         let j2 = spawn(move || {\n             let atomic_ref = &mut *c.0;\n-            *atomic_ref.get_mut() = 32; //~ ERROR: Data race detected between Write on thread `<unnamed>` and Atomic Load on thread `<unnamed>`\n+            *atomic_ref.get_mut() = 32; //~ ERROR: Data race detected between (1) Atomic Load on thread `<unnamed>` and (2) Write on thread `<unnamed>`\n         });\n \n         j1.join().unwrap();"}, {"sha": "6953b1403b4b5e87e8e838454edbc6e8a4f3af05", "filename": "src/tools/miri/tests/fail/data_race/atomic_read_na_write_race2.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_read_na_write_race2.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -1,12 +1,17 @@\n-error: Undefined Behavior: Data race detected between Write on thread `<unnamed>` and Atomic Load on thread `<unnamed>` at ALLOC\n+error: Undefined Behavior: Data race detected between (1) Atomic Load on thread `<unnamed>` and (2) Write on thread `<unnamed>` at ALLOC. (2) just happened here\n   --> $DIR/atomic_read_na_write_race2.rs:LL:CC\n    |\n LL |             *atomic_ref.get_mut() = 32;\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ Data race detected between Write on thread `<unnamed>` and Atomic Load on thread `<unnamed>` at ALLOC\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ Data race detected between (1) Atomic Load on thread `<unnamed>` and (2) Write on thread `<unnamed>` at ALLOC. (2) just happened here\n    |\n+help: and (1) occurred earlier here\n+  --> $DIR/atomic_read_na_write_race2.rs:LL:CC\n+   |\n+LL |             atomic_ref.load(Ordering::SeqCst)\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside closure at $DIR/atomic_read_na_write_race2.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "63b0806f3bb24fe145c00055b9c5701755710d5d", "filename": "src/tools/miri/tests/fail/data_race/atomic_write_na_read_race1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race1.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -23,7 +23,7 @@ pub fn main() {\n \n         let j2 = spawn(move || {\n             let atomic_ref = &mut *c.0;\n-            *atomic_ref.get_mut() //~ ERROR: Data race detected between Read on thread `<unnamed>` and Atomic Store on thread `<unnamed>`\n+            *atomic_ref.get_mut() //~ ERROR: Data race detected between (1) Atomic Store on thread `<unnamed>` and (2) Read on thread `<unnamed>`\n         });\n \n         j1.join().unwrap();"}, {"sha": "e52b8895a6af68b57d4dcfbc73c9a697fe8f2011", "filename": "src/tools/miri/tests/fail/data_race/atomic_write_na_read_race1.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race1.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -1,12 +1,17 @@\n-error: Undefined Behavior: Data race detected between Read on thread `<unnamed>` and Atomic Store on thread `<unnamed>` at ALLOC\n+error: Undefined Behavior: Data race detected between (1) Atomic Store on thread `<unnamed>` and (2) Read on thread `<unnamed>` at ALLOC. (2) just happened here\n   --> $DIR/atomic_write_na_read_race1.rs:LL:CC\n    |\n LL |             *atomic_ref.get_mut()\n-   |             ^^^^^^^^^^^^^^^^^^^^^ Data race detected between Read on thread `<unnamed>` and Atomic Store on thread `<unnamed>` at ALLOC\n+   |             ^^^^^^^^^^^^^^^^^^^^^ Data race detected between (1) Atomic Store on thread `<unnamed>` and (2) Read on thread `<unnamed>` at ALLOC. (2) just happened here\n    |\n+help: and (1) occurred earlier here\n+  --> $DIR/atomic_write_na_read_race1.rs:LL:CC\n+   |\n+LL |             atomic_ref.store(32, Ordering::SeqCst)\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside closure at $DIR/atomic_write_na_read_race1.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "9092254be2164411744cd45875e44e8bb94e0d13", "filename": "src/tools/miri/tests/fail/data_race/atomic_write_na_read_race2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race2.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -20,7 +20,7 @@ pub fn main() {\n         });\n \n         let j2 = spawn(move || {\n-            (&*c.0).store(32, Ordering::SeqCst); //~ ERROR: Data race detected between Atomic Store on thread `<unnamed>` and Read on thread `<unnamed>`\n+            (&*c.0).store(32, Ordering::SeqCst); //~ ERROR: Data race detected between (1) Read on thread `<unnamed>` and (2) Atomic Store on thread `<unnamed>`\n         });\n \n         j1.join().unwrap();"}, {"sha": "513d13b0349a0ca734430a650c70a56a054c489a", "filename": "src/tools/miri/tests/fail/data_race/atomic_write_na_read_race2.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_read_race2.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -1,12 +1,17 @@\n-error: Undefined Behavior: Data race detected between Atomic Store on thread `<unnamed>` and Read on thread `<unnamed>` at ALLOC\n+error: Undefined Behavior: Data race detected between (1) Read on thread `<unnamed>` and (2) Atomic Store on thread `<unnamed>` at ALLOC. (2) just happened here\n   --> $DIR/atomic_write_na_read_race2.rs:LL:CC\n    |\n LL |             (&*c.0).store(32, Ordering::SeqCst);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Data race detected between Atomic Store on thread `<unnamed>` and Read on thread `<unnamed>` at ALLOC\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Data race detected between (1) Read on thread `<unnamed>` and (2) Atomic Store on thread `<unnamed>` at ALLOC. (2) just happened here\n    |\n+help: and (1) occurred earlier here\n+  --> $DIR/atomic_write_na_read_race2.rs:LL:CC\n+   |\n+LL |             let _val = *(c.0 as *mut usize);\n+   |                        ^^^^^^^^^^^^^^^^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside closure at $DIR/atomic_write_na_read_race2.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "5a713905f4edc4c23c383dd9719aeb57d32a0a11", "filename": "src/tools/miri/tests/fail/data_race/atomic_write_na_write_race1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race1.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -20,7 +20,7 @@ pub fn main() {\n         });\n \n         let j2 = spawn(move || {\n-            (&*c.0).store(64, Ordering::SeqCst); //~ ERROR: Data race detected between Atomic Store on thread `<unnamed>` and Write on thread `<unnamed>`\n+            (&*c.0).store(64, Ordering::SeqCst); //~ ERROR: Data race detected between (1) Write on thread `<unnamed>` and (2) Atomic Store on thread `<unnamed>`\n         });\n \n         j1.join().unwrap();"}, {"sha": "2ff70ef1f6d73410a151ea23ed5675a0aa2ef5a0", "filename": "src/tools/miri/tests/fail/data_race/atomic_write_na_write_race1.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race1.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -1,12 +1,17 @@\n-error: Undefined Behavior: Data race detected between Atomic Store on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n+error: Undefined Behavior: Data race detected between (1) Write on thread `<unnamed>` and (2) Atomic Store on thread `<unnamed>` at ALLOC. (2) just happened here\n   --> $DIR/atomic_write_na_write_race1.rs:LL:CC\n    |\n LL |             (&*c.0).store(64, Ordering::SeqCst);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Data race detected between Atomic Store on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Data race detected between (1) Write on thread `<unnamed>` and (2) Atomic Store on thread `<unnamed>` at ALLOC. (2) just happened here\n    |\n+help: and (1) occurred earlier here\n+  --> $DIR/atomic_write_na_write_race1.rs:LL:CC\n+   |\n+LL |             *(c.0 as *mut usize) = 32;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside closure at $DIR/atomic_write_na_write_race1.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "5848aa262b3eb4cac2884cbf44da4014456221b8", "filename": "src/tools/miri/tests/fail/data_race/atomic_write_na_write_race2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race2.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -23,7 +23,7 @@ pub fn main() {\n \n         let j2 = spawn(move || {\n             let atomic_ref = &mut *c.0;\n-            *atomic_ref.get_mut() = 32; //~ ERROR: Data race detected between Write on thread `<unnamed>` and Atomic Store on thread `<unnamed>`\n+            *atomic_ref.get_mut() = 32; //~ ERROR: Data race detected between (1) Atomic Store on thread `<unnamed>` and (2) Write on thread `<unnamed>`\n         });\n \n         j1.join().unwrap();"}, {"sha": "166b4d2269a88d6fce10dcf9ab6ae33703a0d7be", "filename": "src/tools/miri/tests/fail/data_race/atomic_write_na_write_race2.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fatomic_write_na_write_race2.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -1,12 +1,17 @@\n-error: Undefined Behavior: Data race detected between Write on thread `<unnamed>` and Atomic Store on thread `<unnamed>` at ALLOC\n+error: Undefined Behavior: Data race detected between (1) Atomic Store on thread `<unnamed>` and (2) Write on thread `<unnamed>` at ALLOC. (2) just happened here\n   --> $DIR/atomic_write_na_write_race2.rs:LL:CC\n    |\n LL |             *atomic_ref.get_mut() = 32;\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ Data race detected between Write on thread `<unnamed>` and Atomic Store on thread `<unnamed>` at ALLOC\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ Data race detected between (1) Atomic Store on thread `<unnamed>` and (2) Write on thread `<unnamed>` at ALLOC. (2) just happened here\n    |\n+help: and (1) occurred earlier here\n+  --> $DIR/atomic_write_na_write_race2.rs:LL:CC\n+   |\n+LL |             atomic_ref.store(64, Ordering::SeqCst);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside closure at $DIR/atomic_write_na_write_race2.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "eecb980e90504ccc46a0e8d5d4227488c16f00a3", "filename": "src/tools/miri/tests/fail/data_race/dangling_thread_async_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_async_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_async_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_async_race.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -34,7 +34,7 @@ fn main() {\n \n     let join2 = unsafe {\n         spawn(move || {\n-            *c.0 = 64; //~ ERROR: Data race detected between Write on thread `<unnamed>` and Write on thread `<unnamed>`\n+            *c.0 = 64; //~ ERROR: Data race detected between (1) Write on thread `<unnamed>` and (2) Write on thread `<unnamed>`\n         })\n     };\n "}, {"sha": "a08b21ab0e4aba99fd34c60a8f553cb7824a7429", "filename": "src/tools/miri/tests/fail/data_race/dangling_thread_async_race.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_async_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_async_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_async_race.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -1,12 +1,17 @@\n-error: Undefined Behavior: Data race detected between Write on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n+error: Undefined Behavior: Data race detected between (1) Write on thread `<unnamed>` and (2) Write on thread `<unnamed>` at ALLOC. (2) just happened here\n   --> $DIR/dangling_thread_async_race.rs:LL:CC\n    |\n LL |             *c.0 = 64;\n-   |             ^^^^^^^^^ Data race detected between Write on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n+   |             ^^^^^^^^^ Data race detected between (1) Write on thread `<unnamed>` and (2) Write on thread `<unnamed>` at ALLOC. (2) just happened here\n    |\n+help: and (1) occurred earlier here\n+  --> $DIR/dangling_thread_async_race.rs:LL:CC\n+   |\n+LL |             *c.0 = 32;\n+   |             ^^^^^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside closure at $DIR/dangling_thread_async_race.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "4c7fbdd7fe6e1ef6c26210cc1a4cf6c6d5ebe6c4", "filename": "src/tools/miri/tests/fail/data_race/dangling_thread_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_race.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -33,6 +33,6 @@ fn main() {\n     spawn(|| ()).join().unwrap();\n \n     unsafe {\n-        *c.0 = 64; //~ ERROR: Data race detected between Write on thread `main` and Write on thread `<unnamed>`\n+        *c.0 = 64; //~ ERROR: Data race detected between (1) Write on thread `<unnamed>` and (2) Write on thread `main`\n     }\n }"}, {"sha": "aa2e6a6f7126576d6663eafa13d974a182291b8e", "filename": "src/tools/miri/tests/fail/data_race/dangling_thread_race.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdangling_thread_race.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -1,12 +1,17 @@\n-error: Undefined Behavior: Data race detected between Write on thread `main` and Write on thread `<unnamed>` at ALLOC\n+error: Undefined Behavior: Data race detected between (1) Write on thread `<unnamed>` and (2) Write on thread `main` at ALLOC. (2) just happened here\n   --> $DIR/dangling_thread_race.rs:LL:CC\n    |\n LL |         *c.0 = 64;\n-   |         ^^^^^^^^^ Data race detected between Write on thread `main` and Write on thread `<unnamed>` at ALLOC\n+   |         ^^^^^^^^^ Data race detected between (1) Write on thread `<unnamed>` and (2) Write on thread `main` at ALLOC. (2) just happened here\n    |\n+help: and (1) occurred earlier here\n+  --> $DIR/dangling_thread_race.rs:LL:CC\n+   |\n+LL |             *c.0 = 32;\n+   |             ^^^^^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/dangling_thread_race.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "18593cf56ae56dcfd064b72c54f379942b3a1b28", "filename": "src/tools/miri/tests/fail/data_race/dealloc_read_race1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race1.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -25,7 +25,7 @@ pub fn main() {\n \n         let j2 = spawn(move || {\n             __rust_dealloc(\n-                //~^ ERROR: Data race detected between Deallocate on thread `<unnamed>` and Read on thread `<unnamed>`\n+                //~^ ERROR: Data race detected between (1) Read on thread `<unnamed>` and (2) Deallocate on thread `<unnamed>`\n                 ptr.0 as *mut _,\n                 std::mem::size_of::<usize>(),\n                 std::mem::align_of::<usize>(),"}, {"sha": "5e546646479d214241e7df91da5753bd4c0c3a9f", "filename": "src/tools/miri/tests/fail/data_race/dealloc_read_race1.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race1.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -1,4 +1,4 @@\n-error: Undefined Behavior: Data race detected between Deallocate on thread `<unnamed>` and Read on thread `<unnamed>` at ALLOC\n+error: Undefined Behavior: Data race detected between (1) Read on thread `<unnamed>` and (2) Deallocate on thread `<unnamed>` at ALLOC. (2) just happened here\n   --> $DIR/dealloc_read_race1.rs:LL:CC\n    |\n LL | /             __rust_dealloc(\n@@ -7,11 +7,16 @@ LL | |                 ptr.0 as *mut _,\n LL | |                 std::mem::size_of::<usize>(),\n LL | |                 std::mem::align_of::<usize>(),\n LL | |             );\n-   | |_____________^ Data race detected between Deallocate on thread `<unnamed>` and Read on thread `<unnamed>` at ALLOC\n+   | |_____________^ Data race detected between (1) Read on thread `<unnamed>` and (2) Deallocate on thread `<unnamed>` at ALLOC. (2) just happened here\n    |\n+help: and (1) occurred earlier here\n+  --> $DIR/dealloc_read_race1.rs:LL:CC\n+   |\n+LL |             let _val = *ptr.0;\n+   |                        ^^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside closure at $DIR/dealloc_read_race1.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "a6f83d489e587c7072247cd10c2b84588f617e60", "filename": "src/tools/miri/tests/fail/data_race/dealloc_read_race2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race2.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -28,7 +28,7 @@ pub fn main() {\n         });\n \n         let j2 = spawn(move || {\n-            // Also an error of the form: Data race detected between Read on thread `<unnamed>` and Deallocate on thread `<unnamed>`\n+            // Also an error of the form: Data race detected between (1) Deallocate on thread `<unnamed>` and (2) Read on thread `<unnamed>`\n             // but the invalid allocation is detected first.\n             *ptr.0 //~ ERROR: dereferenced after this allocation got freed\n         });"}, {"sha": "c82bfed09ee51aca9c955802dfcb2734e3423599", "filename": "src/tools/miri/tests/fail/data_race/dealloc_read_race_stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -35,7 +35,7 @@ pub fn main() {\n                 sleep(Duration::from_millis(200));\n \n                 // Now `stack_var` gets deallocated.\n-            } //~ ERROR: Data race detected between Deallocate on thread `<unnamed>` and Read on thread `<unnamed>`\n+            } //~ ERROR: Data race detected between (1) Read on thread `<unnamed>` and (2) Deallocate on thread `<unnamed>`\n         });\n \n         let j2 = spawn(move || {"}, {"sha": "beb70c5a7fa820099e21eb84cd0990309bf38b59", "filename": "src/tools/miri/tests/fail/data_race/dealloc_read_race_stack.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_read_race_stack.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -1,12 +1,17 @@\n-error: Undefined Behavior: Data race detected between Deallocate on thread `<unnamed>` and Read on thread `<unnamed>` at ALLOC\n+error: Undefined Behavior: Data race detected between (1) Read on thread `<unnamed>` and (2) Deallocate on thread `<unnamed>` at ALLOC. (2) just happened here\n   --> $DIR/dealloc_read_race_stack.rs:LL:CC\n    |\n LL |             }\n-   |             ^ Data race detected between Deallocate on thread `<unnamed>` and Read on thread `<unnamed>` at ALLOC\n+   |             ^ Data race detected between (1) Read on thread `<unnamed>` and (2) Deallocate on thread `<unnamed>` at ALLOC. (2) just happened here\n    |\n+help: and (1) occurred earlier here\n+  --> $DIR/dealloc_read_race_stack.rs:LL:CC\n+   |\n+LL |             *pointer.load(Ordering::Acquire)\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside closure at $DIR/dealloc_read_race_stack.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "1e93a6cb0940d266347c231c237ab4c84a1a377d", "filename": "src/tools/miri/tests/fail/data_race/dealloc_write_race1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race1.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -24,7 +24,7 @@ pub fn main() {\n \n         let j2 = spawn(move || {\n             __rust_dealloc(\n-                //~^ ERROR: Data race detected between Deallocate on thread `<unnamed>` and Write on thread `<unnamed>`\n+                //~^ ERROR: Data race detected between (1) Write on thread `<unnamed>` and (2) Deallocate on thread `<unnamed>`\n                 ptr.0 as *mut _,\n                 std::mem::size_of::<usize>(),\n                 std::mem::align_of::<usize>(),"}, {"sha": "cc4c4524ba25d5a3c63a674b733189d7a0c14c24", "filename": "src/tools/miri/tests/fail/data_race/dealloc_write_race1.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race1.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -1,4 +1,4 @@\n-error: Undefined Behavior: Data race detected between Deallocate on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n+error: Undefined Behavior: Data race detected between (1) Write on thread `<unnamed>` and (2) Deallocate on thread `<unnamed>` at ALLOC. (2) just happened here\n   --> $DIR/dealloc_write_race1.rs:LL:CC\n    |\n LL | /             __rust_dealloc(\n@@ -7,11 +7,16 @@ LL | |                 ptr.0 as *mut _,\n LL | |                 std::mem::size_of::<usize>(),\n LL | |                 std::mem::align_of::<usize>(),\n LL | |             );\n-   | |_____________^ Data race detected between Deallocate on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n+   | |_____________^ Data race detected between (1) Write on thread `<unnamed>` and (2) Deallocate on thread `<unnamed>` at ALLOC. (2) just happened here\n    |\n+help: and (1) occurred earlier here\n+  --> $DIR/dealloc_write_race1.rs:LL:CC\n+   |\n+LL |             *ptr.0 = 2;\n+   |             ^^^^^^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside closure at $DIR/dealloc_write_race1.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "385584db27f927ef322bb7626b2e5164b9df4f7e", "filename": "src/tools/miri/tests/fail/data_race/dealloc_write_race2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race2.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -27,7 +27,7 @@ pub fn main() {\n         });\n \n         let j2 = spawn(move || {\n-            // Also an error of the form: Data race detected between Write on thread `<unnamed>` and Deallocate on thread `<unnamed>`\n+            // Also an error of the form: Data race detected between (1) Deallocate on thread `<unnamed>` and (2) Write on thread `<unnamed>`\n             // but the invalid allocation is detected first.\n             *ptr.0 = 2; //~ ERROR: dereferenced after this allocation got freed\n         });"}, {"sha": "259fbdc497a2c3541ec0fe9480fcbf2509fd7b63", "filename": "src/tools/miri/tests/fail/data_race/dealloc_write_race_stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -35,7 +35,7 @@ pub fn main() {\n                 sleep(Duration::from_millis(200));\n \n                 // Now `stack_var` gets deallocated.\n-            } //~ ERROR: Data race detected between Deallocate on thread `<unnamed>` and Write on thread `<unnamed>`\n+            } //~ ERROR: Data race detected between (1) Write on thread `<unnamed>` and (2) Deallocate on thread `<unnamed>`\n         });\n \n         let j2 = spawn(move || {"}, {"sha": "5f9f4f9bee42394486d2471e71875f35e3b2342b", "filename": "src/tools/miri/tests/fail/data_race/dealloc_write_race_stack.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fdealloc_write_race_stack.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -1,12 +1,17 @@\n-error: Undefined Behavior: Data race detected between Deallocate on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n+error: Undefined Behavior: Data race detected between (1) Write on thread `<unnamed>` and (2) Deallocate on thread `<unnamed>` at ALLOC. (2) just happened here\n   --> $DIR/dealloc_write_race_stack.rs:LL:CC\n    |\n LL |             }\n-   |             ^ Data race detected between Deallocate on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n+   |             ^ Data race detected between (1) Write on thread `<unnamed>` and (2) Deallocate on thread `<unnamed>` at ALLOC. (2) just happened here\n    |\n+help: and (1) occurred earlier here\n+  --> $DIR/dealloc_write_race_stack.rs:LL:CC\n+   |\n+LL |             *pointer.load(Ordering::Acquire) = 3;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside closure at $DIR/dealloc_write_race_stack.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "3d47b1accb31bee69a21a57062b6e3df05b74d47", "filename": "src/tools/miri/tests/fail/data_race/enable_after_join_to_main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fenable_after_join_to_main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fenable_after_join_to_main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fenable_after_join_to_main.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -30,7 +30,7 @@ pub fn main() {\n         });\n \n         let j2 = spawn(move || {\n-            *c.0 = 64; //~ ERROR: Data race detected between Write on thread `<unnamed>` and Write on thread `<unnamed>`\n+            *c.0 = 64; //~ ERROR: Data race detected between (1) Write on thread `<unnamed>` and (2) Write on thread `<unnamed>`\n         });\n \n         j1.join().unwrap();"}, {"sha": "84d1c0bf7e666dc9cc548aa38b59bdd0e77323bc", "filename": "src/tools/miri/tests/fail/data_race/enable_after_join_to_main.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fenable_after_join_to_main.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fenable_after_join_to_main.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fenable_after_join_to_main.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -1,12 +1,17 @@\n-error: Undefined Behavior: Data race detected between Write on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n+error: Undefined Behavior: Data race detected between (1) Write on thread `<unnamed>` and (2) Write on thread `<unnamed>` at ALLOC. (2) just happened here\n   --> $DIR/enable_after_join_to_main.rs:LL:CC\n    |\n LL |             *c.0 = 64;\n-   |             ^^^^^^^^^ Data race detected between Write on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n+   |             ^^^^^^^^^ Data race detected between (1) Write on thread `<unnamed>` and (2) Write on thread `<unnamed>` at ALLOC. (2) just happened here\n    |\n+help: and (1) occurred earlier here\n+  --> $DIR/enable_after_join_to_main.rs:LL:CC\n+   |\n+LL |             *c.0 = 32;\n+   |             ^^^^^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside closure at $DIR/enable_after_join_to_main.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "0648aa55f4aa4d44d8e25613b33cbe1935be7557", "filename": "src/tools/miri/tests/fail/data_race/fence_after_load.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Ffence_after_load.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Ffence_after_load.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Ffence_after_load.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -20,5 +20,5 @@ fn main() {\n     // The fence is useless, since it did not happen-after the `store` in the other thread.\n     // Hence this is a data race.\n     // Also see https://github.com/rust-lang/miri/issues/2192.\n-    unsafe { V = 2 } //~ERROR: Data race detected between Write on thread `main` and Write on thread `<unnamed>`\n+    unsafe { V = 2 } //~ERROR: Data race detected between (1) Write on thread `<unnamed>` and (2) Write on thread `main`\n }"}, {"sha": "c30d2354e768d6a4e084335485e06f4abcc01f86", "filename": "src/tools/miri/tests/fail/data_race/fence_after_load.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Ffence_after_load.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Ffence_after_load.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Ffence_after_load.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -1,12 +1,17 @@\n-error: Undefined Behavior: Data race detected between Write on thread `main` and Write on thread `<unnamed>` at ALLOC\n+error: Undefined Behavior: Data race detected between (1) Write on thread `<unnamed>` and (2) Write on thread `main` at ALLOC. (2) just happened here\n   --> $DIR/fence_after_load.rs:LL:CC\n    |\n LL |     unsafe { V = 2 }\n-   |              ^^^^^ Data race detected between Write on thread `main` and Write on thread `<unnamed>` at ALLOC\n+   |              ^^^^^ Data race detected between (1) Write on thread `<unnamed>` and (2) Write on thread `main` at ALLOC. (2) just happened here\n    |\n+help: and (1) occurred earlier here\n+  --> $DIR/fence_after_load.rs:LL:CC\n+   |\n+LL |         unsafe { V = 1 }\n+   |                  ^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/fence_after_load.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "d996141db3ef1c27a397994d0d3f7580c737e0e3", "filename": "src/tools/miri/tests/fail/data_race/read_write_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ pub fn main() {\n         });\n \n         let j2 = spawn(move || {\n-            *c.0 = 64; //~ ERROR: Data race detected between Write on thread `<unnamed>` and Read on thread `<unnamed>`\n+            *c.0 = 64; //~ ERROR: Data race detected between (1) Read on thread `<unnamed>` and (2) Write on thread `<unnamed>`\n         });\n \n         j1.join().unwrap();"}, {"sha": "13bc5c74ae33300f4c066c20da17ffebcc25cff1", "filename": "src/tools/miri/tests/fail/data_race/read_write_race.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -1,12 +1,17 @@\n-error: Undefined Behavior: Data race detected between Write on thread `<unnamed>` and Read on thread `<unnamed>` at ALLOC\n+error: Undefined Behavior: Data race detected between (1) Read on thread `<unnamed>` and (2) Write on thread `<unnamed>` at ALLOC. (2) just happened here\n   --> $DIR/read_write_race.rs:LL:CC\n    |\n LL |             *c.0 = 64;\n-   |             ^^^^^^^^^ Data race detected between Write on thread `<unnamed>` and Read on thread `<unnamed>` at ALLOC\n+   |             ^^^^^^^^^ Data race detected between (1) Read on thread `<unnamed>` and (2) Write on thread `<unnamed>` at ALLOC. (2) just happened here\n    |\n+help: and (1) occurred earlier here\n+  --> $DIR/read_write_race.rs:LL:CC\n+   |\n+LL |             let _val = *c.0;\n+   |                        ^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside closure at $DIR/read_write_race.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "b4e371f430d2e83736156c23182396cdb46c50a0", "filename": "src/tools/miri/tests/fail/data_race/read_write_race_stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race_stack.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -42,7 +42,7 @@ pub fn main() {\n \n             sleep(Duration::from_millis(200));\n \n-            stack_var //~ ERROR: Data race detected between Read on thread `<unnamed>` and Write on thread `<unnamed>`\n+            stack_var //~ ERROR: Data race detected between (1) Write on thread `<unnamed>` and (2) Read on thread `<unnamed>`\n         });\n \n         let j2 = spawn(move || {"}, {"sha": "96fcb494822257191272c5574dc6bb52e206c279", "filename": "src/tools/miri/tests/fail/data_race/read_write_race_stack.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race_stack.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race_stack.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fread_write_race_stack.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -1,12 +1,17 @@\n-error: Undefined Behavior: Data race detected between Read on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n+error: Undefined Behavior: Data race detected between (1) Write on thread `<unnamed>` and (2) Read on thread `<unnamed>` at ALLOC. (2) just happened here\n   --> $DIR/read_write_race_stack.rs:LL:CC\n    |\n LL |             stack_var\n-   |             ^^^^^^^^^ Data race detected between Read on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n+   |             ^^^^^^^^^ Data race detected between (1) Write on thread `<unnamed>` and (2) Read on thread `<unnamed>` at ALLOC. (2) just happened here\n    |\n+help: and (1) occurred earlier here\n+  --> $DIR/read_write_race_stack.rs:LL:CC\n+   |\n+LL |             *pointer.load(Ordering::Acquire) = 3;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside closure at $DIR/read_write_race_stack.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "b7226fa626fbfd4e2a08d267561fb1dc3cc00976", "filename": "src/tools/miri/tests/fail/data_race/relax_acquire_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelax_acquire_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelax_acquire_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelax_acquire_race.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -37,7 +37,7 @@ pub fn main() {\n \n         let j3 = spawn(move || {\n             if SYNC.load(Ordering::Acquire) == 2 {\n-                *c.0 //~ ERROR: Data race detected between Read on thread `<unnamed>` and Write on thread `<unnamed>`\n+                *c.0 //~ ERROR: Data race detected between (1) Write on thread `<unnamed>` and (2) Read on thread `<unnamed>`\n             } else {\n                 0\n             }"}, {"sha": "92755f5551d97be3314cc52868cae5e05f2b7e32", "filename": "src/tools/miri/tests/fail/data_race/relax_acquire_race.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelax_acquire_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelax_acquire_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelax_acquire_race.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -1,12 +1,17 @@\n-error: Undefined Behavior: Data race detected between Read on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n+error: Undefined Behavior: Data race detected between (1) Write on thread `<unnamed>` and (2) Read on thread `<unnamed>` at ALLOC. (2) just happened here\n   --> $DIR/relax_acquire_race.rs:LL:CC\n    |\n LL |                 *c.0\n-   |                 ^^^^ Data race detected between Read on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n+   |                 ^^^^ Data race detected between (1) Write on thread `<unnamed>` and (2) Read on thread `<unnamed>` at ALLOC. (2) just happened here\n    |\n+help: and (1) occurred earlier here\n+  --> $DIR/relax_acquire_race.rs:LL:CC\n+   |\n+LL |             *c.0 = 1;\n+   |             ^^^^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside closure at $DIR/relax_acquire_race.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "dff33a42a1c2b51ccfabd0a030eae918799db147", "filename": "src/tools/miri/tests/fail/data_race/release_seq_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelease_seq_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelease_seq_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelease_seq_race.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -41,7 +41,7 @@ pub fn main() {\n         let j3 = spawn(move || {\n             sleep(Duration::from_millis(500));\n             if SYNC.load(Ordering::Acquire) == 3 {\n-                *c.0 //~ ERROR: Data race detected between Read on thread `<unnamed>` and Write on thread `<unnamed>`\n+                *c.0 //~ ERROR: Data race detected between (1) Write on thread `<unnamed>` and (2) Read on thread `<unnamed>`\n             } else {\n                 0\n             }"}, {"sha": "880268730db1301ddfe8715acc64e62edebc22c4", "filename": "src/tools/miri/tests/fail/data_race/release_seq_race.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelease_seq_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelease_seq_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelease_seq_race.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -1,12 +1,17 @@\n-error: Undefined Behavior: Data race detected between Read on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n+error: Undefined Behavior: Data race detected between (1) Write on thread `<unnamed>` and (2) Read on thread `<unnamed>` at ALLOC. (2) just happened here\n   --> $DIR/release_seq_race.rs:LL:CC\n    |\n LL |                 *c.0\n-   |                 ^^^^ Data race detected between Read on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n+   |                 ^^^^ Data race detected between (1) Write on thread `<unnamed>` and (2) Read on thread `<unnamed>` at ALLOC. (2) just happened here\n    |\n+help: and (1) occurred earlier here\n+  --> $DIR/release_seq_race.rs:LL:CC\n+   |\n+LL |             *c.0 = 1;\n+   |             ^^^^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside closure at $DIR/release_seq_race.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "f7a523841b81210f5d52dce66f4c5474699ca5df", "filename": "src/tools/miri/tests/fail/data_race/release_seq_race_same_thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelease_seq_race_same_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelease_seq_race_same_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelease_seq_race_same_thread.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -37,7 +37,7 @@ pub fn main() {\n \n         let j2 = spawn(move || {\n             if SYNC.load(Ordering::Acquire) == 2 {\n-                *c.0 //~ ERROR: Data race detected between Read on thread `<unnamed>` and Write on thread `<unnamed>`\n+                *c.0 //~ ERROR: Data race detected between (1) Write on thread `<unnamed>` and (2) Read on thread `<unnamed>`\n             } else {\n                 0\n             }"}, {"sha": "386c012ba4e5e1c00fe9dfc35c26885587bc84f6", "filename": "src/tools/miri/tests/fail/data_race/release_seq_race_same_thread.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelease_seq_race_same_thread.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelease_seq_race_same_thread.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frelease_seq_race_same_thread.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -1,12 +1,17 @@\n-error: Undefined Behavior: Data race detected between Read on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n+error: Undefined Behavior: Data race detected between (1) Write on thread `<unnamed>` and (2) Read on thread `<unnamed>` at ALLOC. (2) just happened here\n   --> $DIR/release_seq_race_same_thread.rs:LL:CC\n    |\n LL |                 *c.0\n-   |                 ^^^^ Data race detected between Read on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n+   |                 ^^^^ Data race detected between (1) Write on thread `<unnamed>` and (2) Read on thread `<unnamed>` at ALLOC. (2) just happened here\n    |\n+help: and (1) occurred earlier here\n+  --> $DIR/release_seq_race_same_thread.rs:LL:CC\n+   |\n+LL |             *c.0 = 1;\n+   |             ^^^^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside closure at $DIR/release_seq_race_same_thread.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "2201362b167f75bf1f36122acdffaecbdfba7f05", "filename": "src/tools/miri/tests/fail/data_race/rmw_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frmw_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frmw_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frmw_race.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -38,7 +38,7 @@ pub fn main() {\n \n         let j3 = spawn(move || {\n             if SYNC.load(Ordering::Acquire) == 3 {\n-                *c.0 //~ ERROR: Data race detected between Read on thread `<unnamed>` and Write on thread `<unnamed>`\n+                *c.0 //~ ERROR: Data race detected between (1) Write on thread `<unnamed>` and (2) Read on thread `<unnamed>`\n             } else {\n                 0\n             }"}, {"sha": "82cb2c4ecbb4739d14dbad0f14ef7842f62b0a3f", "filename": "src/tools/miri/tests/fail/data_race/rmw_race.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frmw_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frmw_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Frmw_race.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -1,12 +1,17 @@\n-error: Undefined Behavior: Data race detected between Read on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n+error: Undefined Behavior: Data race detected between (1) Write on thread `<unnamed>` and (2) Read on thread `<unnamed>` at ALLOC. (2) just happened here\n   --> $DIR/rmw_race.rs:LL:CC\n    |\n LL |                 *c.0\n-   |                 ^^^^ Data race detected between Read on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n+   |                 ^^^^ Data race detected between (1) Write on thread `<unnamed>` and (2) Read on thread `<unnamed>` at ALLOC. (2) just happened here\n    |\n+help: and (1) occurred earlier here\n+  --> $DIR/rmw_race.rs:LL:CC\n+   |\n+LL |             *c.0 = 1;\n+   |             ^^^^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside closure at $DIR/rmw_race.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "dec5ff274ccf9f6baea491397fc69cee163484fa", "filename": "src/tools/miri/tests/fail/data_race/stack_pop_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fstack_pop_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fstack_pop_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fstack_pop_race.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -21,4 +21,4 @@ fn race(local: i32) {\n     // Deallocating the local (when `main` returns)\n     // races with the read in the other thread.\n     // Make sure the error points at this function's end, not just the call site.\n-} //~ERROR: Data race detected between Deallocate on thread `main` and Read on thread `<unnamed>`\n+} //~ERROR: Data race detected between (1) Read on thread `<unnamed>` and (2) Deallocate on thread `main`"}, {"sha": "71e38c2727e1a4d11dd142c4e051834fb33b83cc", "filename": "src/tools/miri/tests/fail/data_race/stack_pop_race.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fstack_pop_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fstack_pop_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fstack_pop_race.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -1,12 +1,17 @@\n-error: Undefined Behavior: Data race detected between Deallocate on thread `main` and Read on thread `<unnamed>` at ALLOC\n+error: Undefined Behavior: Data race detected between (1) Read on thread `<unnamed>` and (2) Deallocate on thread `main` at ALLOC. (2) just happened here\n   --> $DIR/stack_pop_race.rs:LL:CC\n    |\n LL | }\n-   |  ^ Data race detected between Deallocate on thread `main` and Read on thread `<unnamed>` at ALLOC\n+   |  ^ Data race detected between (1) Read on thread `<unnamed>` and (2) Deallocate on thread `main` at ALLOC. (2) just happened here\n    |\n+help: and (1) occurred earlier here\n+  --> $DIR/stack_pop_race.rs:LL:CC\n+   |\n+LL |         let _val = unsafe { *ptr.0 };\n+   |                             ^^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `race` at $DIR/stack_pop_race.rs:LL:CC\n note: inside `main`\n   --> $DIR/stack_pop_race.rs:LL:CC"}, {"sha": "fe02d02f9dce632f4bb30b3b66c498b459fb0b3a", "filename": "src/tools/miri/tests/fail/data_race/write_write_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fwrite_write_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fwrite_write_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fwrite_write_race.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ pub fn main() {\n         });\n \n         let j2 = spawn(move || {\n-            *c.0 = 64; //~ ERROR: Data race detected between Write on thread `<unnamed>` and Write on thread `<unnamed>`\n+            *c.0 = 64; //~ ERROR: Data race detected between (1) Write on thread `<unnamed>` and (2) Write on thread `<unnamed>`\n         });\n \n         j1.join().unwrap();"}, {"sha": "3b7eb2b8000179d49499314a9b00f352b4e5cff1", "filename": "src/tools/miri/tests/fail/data_race/write_write_race.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fwrite_write_race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fwrite_write_race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fwrite_write_race.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -1,12 +1,17 @@\n-error: Undefined Behavior: Data race detected between Write on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n+error: Undefined Behavior: Data race detected between (1) Write on thread `<unnamed>` and (2) Write on thread `<unnamed>` at ALLOC. (2) just happened here\n   --> $DIR/write_write_race.rs:LL:CC\n    |\n LL |             *c.0 = 64;\n-   |             ^^^^^^^^^ Data race detected between Write on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n+   |             ^^^^^^^^^ Data race detected between (1) Write on thread `<unnamed>` and (2) Write on thread `<unnamed>` at ALLOC. (2) just happened here\n    |\n+help: and (1) occurred earlier here\n+  --> $DIR/write_write_race.rs:LL:CC\n+   |\n+LL |             *c.0 = 32;\n+   |             ^^^^^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside closure at $DIR/write_write_race.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "c1c1b1fa6e38aac68424ccc67674dbbd1078602e", "filename": "src/tools/miri/tests/fail/data_race/write_write_race_stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fwrite_write_race_stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fwrite_write_race_stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fwrite_write_race_stack.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -39,7 +39,7 @@ pub fn main() {\n \n             sleep(Duration::from_millis(200));\n \n-            stack_var = 1usize; //~ ERROR: Data race detected between Write on thread `<unnamed>` and Write on thread `<unnamed>`\n+            stack_var = 1usize; //~ ERROR: Data race detected between (1) Write on thread `<unnamed>` and (2) Write on thread `<unnamed>`\n \n             // read to silence errors\n             stack_var"}, {"sha": "c501ecd11a6d14eb9ffde975b49da5575fee75cf", "filename": "src/tools/miri/tests/fail/data_race/write_write_race_stack.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fwrite_write_race_stack.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fwrite_write_race_stack.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fdata_race%2Fwrite_write_race_stack.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -1,12 +1,17 @@\n-error: Undefined Behavior: Data race detected between Write on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n+error: Undefined Behavior: Data race detected between (1) Write on thread `<unnamed>` and (2) Write on thread `<unnamed>` at ALLOC. (2) just happened here\n   --> $DIR/write_write_race_stack.rs:LL:CC\n    |\n LL |             stack_var = 1usize;\n-   |             ^^^^^^^^^^^^^^^^^^ Data race detected between Write on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n+   |             ^^^^^^^^^^^^^^^^^^ Data race detected between (1) Write on thread `<unnamed>` and (2) Write on thread `<unnamed>` at ALLOC. (2) just happened here\n    |\n+help: and (1) occurred earlier here\n+  --> $DIR/write_write_race_stack.rs:LL:CC\n+   |\n+LL |             *pointer.load(Ordering::Acquire) = 3;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside closure at $DIR/write_write_race_stack.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "09e4157b31f4fd7b2d74462076b8298195cd01e4", "filename": "src/tools/miri/tests/fail/function_calls/exported_symbol_clashing.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ffunction_calls%2Fexported_symbol_clashing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ffunction_calls%2Fexported_symbol_clashing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ffunction_calls%2Fexported_symbol_clashing.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -14,7 +14,7 @@ help: then it's defined here again, in crate `exported_symbol_clashing`\n    |\n LL | fn bar() {}\n    | ^^^^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/exported_symbol_clashing.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "0d0055bb85c8ced9b39e0087f35c6ca565011149", "filename": "src/tools/miri/tests/fail/function_calls/exported_symbol_shim_clashing.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ffunction_calls%2Fexported_symbol_shim_clashing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ffunction_calls%2Fexported_symbol_shim_clashing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ffunction_calls%2Fexported_symbol_shim_clashing.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -12,7 +12,7 @@ LL | |\n LL | |     unreachable!()\n LL | | }\n    | |_^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/exported_symbol_shim_clashing.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "b22db3eb121ee0b09daaa136a768985692620808", "filename": "src/tools/miri/tests/fail/stacked_borrows/alias_through_mutation.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Falias_through_mutation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Falias_through_mutation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Falias_through_mutation.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ help: <TAG> was later invalidated at offsets [0x0..0x4] by a write access\n    |\n LL |     *target = 13;\n    |     ^^^^^^^^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/alias_through_mutation.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "3ce39968cbb139aaa5b9a737f57fa4e63c2eccb1", "filename": "src/tools/miri/tests/fail/stacked_borrows/aliasing_mut1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Faliasing_mut1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Faliasing_mut1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Faliasing_mut1.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -16,7 +16,7 @@ help: <TAG> is this argument\n    |\n LL | pub fn safe(_x: &mut i32, _y: &mut i32) {}\n    |             ^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `safe` at $DIR/aliasing_mut1.rs:LL:CC\n note: inside `main`\n   --> $DIR/aliasing_mut1.rs:LL:CC"}, {"sha": "df4b6cf02561c3f5a33cbb48363f3bc529dc15f4", "filename": "src/tools/miri/tests/fail/stacked_borrows/aliasing_mut2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Faliasing_mut2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Faliasing_mut2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Faliasing_mut2.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -16,7 +16,7 @@ help: <TAG> is this argument\n    |\n LL | pub fn safe(_x: &i32, _y: &mut i32) {}\n    |             ^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `safe` at $DIR/aliasing_mut2.rs:LL:CC\n note: inside `main`\n   --> $DIR/aliasing_mut2.rs:LL:CC"}, {"sha": "55aaed62f4f5f8d8c9939c335fcdf4efa8548f49", "filename": "src/tools/miri/tests/fail/stacked_borrows/aliasing_mut3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Faliasing_mut3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Faliasing_mut3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Faliasing_mut3.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ help: <TAG> was later invalidated at offsets [0x0..0x4] by a Unique FnEntry reta\n    |\n LL |     safe_raw(xraw, xshr);\n    |     ^^^^^^^^^^^^^^^^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `safe` at $DIR/aliasing_mut3.rs:LL:CC\n note: inside `main`\n   --> $DIR/aliasing_mut3.rs:LL:CC"}, {"sha": "ddf197bc63955f8dd67c17416915323077fbaf18", "filename": "src/tools/miri/tests/fail/stacked_borrows/aliasing_mut4.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Faliasing_mut4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Faliasing_mut4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Faliasing_mut4.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -16,7 +16,7 @@ help: <TAG> is this argument\n    |\n LL | pub fn safe(_x: &i32, _y: &mut Cell<i32>) {}\n    |             ^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `safe` at $DIR/aliasing_mut4.rs:LL:CC\n note: inside `main`\n   --> $DIR/aliasing_mut4.rs:LL:CC"}, {"sha": "76f4e81f71ba2bdc7a96a9c703bdd874faa09677", "filename": "src/tools/miri/tests/fail/stacked_borrows/box_exclusive_violation1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fbox_exclusive_violation1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fbox_exclusive_violation1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fbox_exclusive_violation1.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ help: <TAG> was later invalidated at offsets [0x0..0x4] by a write access\n    |\n LL |     *our = 5;\n    |     ^^^^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `unknown_code_2` at $DIR/box_exclusive_violation1.rs:LL:CC\n note: inside `demo_box_advanced_unique`\n   --> $DIR/box_exclusive_violation1.rs:LL:CC"}, {"sha": "59377aeb971a83a42c530c4894a1dea5147e75ab", "filename": "src/tools/miri/tests/fail/stacked_borrows/box_noalias_violation.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fbox_noalias_violation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fbox_noalias_violation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fbox_noalias_violation.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -16,7 +16,7 @@ help: <TAG> is this argument\n    |\n LL | unsafe fn test(mut x: Box<i32>, y: *const i32) -> i32 {\n    |                ^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `test` at $DIR/box_noalias_violation.rs:LL:CC\n note: inside `main`\n   --> $DIR/box_noalias_violation.rs:LL:CC"}, {"sha": "fa3d7ca367625514f3d6da82df12a7336a3dd38e", "filename": "src/tools/miri/tests/fail/stacked_borrows/buggy_as_mut_slice.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fbuggy_as_mut_slice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fbuggy_as_mut_slice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fbuggy_as_mut_slice.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ help: <TAG> was later invalidated at offsets [0x0..0xc] by a Unique retag\n    |\n LL |         unsafe { from_raw_parts_mut(self_.as_ptr() as *mut T, self_.len()) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/buggy_as_mut_slice.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "c75d8cab3fc85b947e417960c7deaea78afd6aa2", "filename": "src/tools/miri/tests/fail/stacked_borrows/buggy_split_at_mut.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fbuggy_split_at_mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fbuggy_split_at_mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fbuggy_split_at_mut.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ help: <TAG> was later invalidated at offsets [0x0..0x10] by a Unique retag\n    |\n LL |                 from_raw_parts_mut(ptr.offset(mid as isize), len - mid),\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/buggy_split_at_mut.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "bd79b401f667f16f2593ab12e1ead2a210da3745", "filename": "src/tools/miri/tests/fail/stacked_borrows/disable_mut_does_not_merge_srw.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdisable_mut_does_not_merge_srw.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdisable_mut_does_not_merge_srw.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdisable_mut_does_not_merge_srw.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ help: <TAG> was later invalidated at offsets [0x0..0x4] by a write access\n    |\n LL |         *base = 1;\n    |         ^^^^^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/disable_mut_does_not_merge_srw.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "3d0cef241c3e619207799e2c8f6bea8924cd1ace", "filename": "src/tools/miri/tests/fail/stacked_borrows/drop_in_place_protector.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdrop_in_place_protector.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdrop_in_place_protector.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdrop_in_place_protector.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -16,7 +16,7 @@ help: <TAG> is this argument\n    |\n LL |         core::ptr::drop_in_place(x);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `<HasDrop as std::ops::Drop>::drop` at $DIR/drop_in_place_protector.rs:LL:CC\n    = note: inside `std::ptr::drop_in_place::<HasDrop> - shim(Some(HasDrop))` at RUSTLIB/core/src/ptr/mod.rs:LL:CC\n    = note: inside `std::ptr::drop_in_place::<(HasDrop, u8)> - shim(Some((HasDrop, u8)))` at RUSTLIB/core/src/ptr/mod.rs:LL:CC"}, {"sha": "7f2917e7950535e45e0a7d5ba4bf3c2dcba8658e", "filename": "src/tools/miri/tests/fail/stacked_borrows/drop_in_place_retag.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdrop_in_place_retag.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdrop_in_place_retag.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdrop_in_place_retag.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -14,7 +14,7 @@ help: <TAG> was created by a SharedReadOnly retag at offsets [0x0..0x1]\n    |\n LL |         let x = core::ptr::addr_of!(x);\n    |                 ^^^^^^^^^^^^^^^^^^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `std::ptr::drop_in_place::<u8> - shim(None)` at RUSTLIB/core/src/ptr/mod.rs:LL:CC\n note: inside `main`\n   --> $DIR/drop_in_place_retag.rs:LL:CC"}, {"sha": "e3bffde1f0176c337c1ca5fab767dcddb0291a18", "filename": "src/tools/miri/tests/fail/stacked_borrows/fnentry_invalidation.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Ffnentry_invalidation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Ffnentry_invalidation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Ffnentry_invalidation.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ help: <TAG> was later invalidated at offsets [0x0..0x4] by a Unique FnEntry reta\n    |\n LL |     x.do_bad();\n    |     ^^^^^^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/fnentry_invalidation.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "b104de4b8d94d2b02e6ea1257bbfa2ee8ee4a817", "filename": "src/tools/miri/tests/fail/stacked_borrows/fnentry_invalidation2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Ffnentry_invalidation2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Ffnentry_invalidation2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Ffnentry_invalidation2.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ help: <TAG> was later invalidated at offsets [0x0..0xc] by a Unique FnEntry reta\n    |\n LL |     let _ = t.sli.as_mut_ptr();\n    |             ^^^^^^^^^^^^^^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/fnentry_invalidation2.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "7fff60f25fbbe60315c4e409a263095ddf1cab92", "filename": "src/tools/miri/tests/fail/stacked_borrows/illegal_dealloc1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_dealloc1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_dealloc1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_dealloc1.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -16,7 +16,7 @@ help: <TAG> was later invalidated at offsets [0x0..0x1] by a write access\n    |\n LL |         ptr1.write(0);\n    |         ^^^^^^^^^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `std::alloc::dealloc` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n note: inside `main`\n   --> $DIR/illegal_deALLOC.rs:LL:CC"}, {"sha": "7a159c9d3fefce8ebfebb3641501c3137b161c17", "filename": "src/tools/miri/tests/fail/stacked_borrows/illegal_read1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_read1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_read1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_read1.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ help: <TAG> was later invalidated at offsets [0x0..0x4] by a read access\n    |\n LL |     let _val = unsafe { *xraw };\n    |                         ^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/illegal_read1.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "e3e79f6f0f05ef7bf5aa92f57c77881dd202794e", "filename": "src/tools/miri/tests/fail/stacked_borrows/illegal_read2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_read2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_read2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_read2.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ help: <TAG> was later invalidated at offsets [0x0..0x4] by a SharedReadOnly reta\n    |\n LL |     let shr = unsafe { &*xraw };\n    |                        ^^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/illegal_read2.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "3a8687ad9aa19a98f9316e8487f22834fc90c73f", "filename": "src/tools/miri/tests/fail/stacked_borrows/illegal_read3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_read3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_read3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_read3.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ help: <TAG> was later invalidated at offsets [0x0..0x4] by a read access\n    |\n LL |     let _val = unsafe { *xref1.r };\n    |                         ^^^^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/illegal_read3.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "dcf37b26901542c79604ae9fc280f6fd219bce1f", "filename": "src/tools/miri/tests/fail/stacked_borrows/illegal_read4.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_read4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_read4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_read4.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ help: <TAG> was later invalidated at offsets [0x0..0x4] by a read access\n    |\n LL |     let _val = unsafe { *xraw }; // use the raw again, this invalidates xref2 *even* with the special read except for uniq refs\n    |                         ^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/illegal_read4.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "1793798d15f6af69f55f90f057444003d347f713", "filename": "src/tools/miri/tests/fail/stacked_borrows/illegal_read5.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_read5.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_read5.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_read5.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ help: <TAG> was later invalidated at offsets [$HEX..$HEX] by a read access\n    |\n LL |     mem::forget(unsafe { ptr::read(xshr) }); // but after reading through the shared ref\n    |                          ^^^^^^^^^^^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/illegal_read5.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "17b28dee3c7caf3868267d87189a165e71479f11", "filename": "src/tools/miri/tests/fail/stacked_borrows/illegal_read6.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_read6.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_read6.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_read6.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ help: <TAG> was later invalidated at offsets [0x0..0x4] by a Unique retag\n    |\n LL |         let x = &mut *x; // kill `raw`\n    |                 ^^^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/illegal_read6.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "b76446d60f6d2bb2fe142b7969527f77ad6c5166", "filename": "src/tools/miri/tests/fail/stacked_borrows/illegal_read7.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_read7.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_read7.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_read7.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ help: <TAG> was later invalidated at offsets [0x0..0x4] by a read access\n    |\n LL |         let _val = ptr::read(raw);\n    |                    ^^^^^^^^^^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/illegal_read7.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "b43079c3b7f3b9a9ea91618c2f9ae57f51525ab2", "filename": "src/tools/miri/tests/fail/stacked_borrows/illegal_read8.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_read8.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_read8.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_read8.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ help: <TAG> was later invalidated at offsets [0x0..0x4] by a write access\n    |\n LL |         *y2 += 1;\n    |         ^^^^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/illegal_read8.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "fbd5d8b956d9794d9df99c3d5387e7c2f172b423", "filename": "src/tools/miri/tests/fail/stacked_borrows/illegal_read_despite_exposed1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_read_despite_exposed1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_read_despite_exposed1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_read_despite_exposed1.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ help: <TAG> was later invalidated at offsets [0x0..0x4] by a write access\n    |\n LL |         *exposed_ptr = 0;\n    |         ^^^^^^^^^^^^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/illegal_read_despite_exposed1.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "19e4cbdb9385521d0af0177929e9cacb05e35271", "filename": "src/tools/miri/tests/fail/stacked_borrows/illegal_read_despite_exposed2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_read_despite_exposed2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_read_despite_exposed2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_read_despite_exposed2.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ help: <TAG> was later invalidated at offsets [0x0..0x4] by a read access\n    |\n LL |         let _val = *exposed_ptr;\n    |                    ^^^^^^^^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/illegal_read_despite_exposed2.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "c1e4918146587c7b12f36830934bb8659bc81d6a", "filename": "src/tools/miri/tests/fail/stacked_borrows/illegal_write1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_write1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_write1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_write1.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -14,7 +14,7 @@ help: <TAG> was created by a SharedReadOnly retag at offsets [0x0..0x4]\n    |\n LL |         let x: *mut u32 = xref as *const _ as *mut _;\n    |                           ^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/illegal_write1.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "3e11e86eb81b36f10837798621f2a87251401b58", "filename": "src/tools/miri/tests/fail/stacked_borrows/illegal_write2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_write2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_write2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_write2.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ help: <TAG> was later invalidated at offsets [0x0..0x4] by a Unique retag\n    |\n LL |     drop(&mut *target); // reborrow\n    |          ^^^^^^^^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/illegal_write2.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "4053325821e75120ef533d18a60ef56c1d19a371", "filename": "src/tools/miri/tests/fail/stacked_borrows/illegal_write3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_write3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_write3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_write3.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -14,7 +14,7 @@ help: <TAG> was created by a SharedReadOnly retag at offsets [0x0..0x4]\n    |\n LL |     let ptr = r#ref as *const _ as *mut _; // raw ptr, with raw tag\n    |               ^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/illegal_write3.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "fceda8db4cef5a0962f1974f248c73b974fb1287", "filename": "src/tools/miri/tests/fail/stacked_borrows/illegal_write4.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_write4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_write4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_write4.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ help: <TAG> was later invalidated at offsets [0x0..0x4] by a Unique retag\n    |\n LL |     let _mut_ref: &mut i32 = unsafe { mem::transmute(raw) }; // &mut, with raw tag\n    |                                       ^^^^^^^^^^^^^^^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/illegal_write4.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "c71780b7e03e0332067d998e1de1133572209a21", "filename": "src/tools/miri/tests/fail/stacked_borrows/illegal_write5.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_write5.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_write5.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_write5.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ help: <TAG> was later invalidated at offsets [0x0..0x4] by a write access\n    |\n LL |     unsafe { *xraw = 15 };\n    |              ^^^^^^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/illegal_write5.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "3d3d2a24c2852954ff89c193517beb40dcb5112f", "filename": "src/tools/miri/tests/fail/stacked_borrows/illegal_write6.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_write6.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_write6.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_write6.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -16,7 +16,7 @@ help: <TAG> is this argument\n    |\n LL | fn foo(a: &mut u32, y: *mut u32) -> u32 {\n    |        ^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `foo` at $DIR/illegal_write6.rs:LL:CC\n note: inside `main`\n   --> $DIR/illegal_write6.rs:LL:CC"}, {"sha": "1bb3afe483ebad8c8546275e0d693ecc0fad57f8", "filename": "src/tools/miri/tests/fail/stacked_borrows/illegal_write_despite_exposed1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_write_despite_exposed1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_write_despite_exposed1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_write_despite_exposed1.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ help: <TAG> was later invalidated at offsets [0x0..0x4] by a write access\n    |\n LL |         *exposed_ptr = 0;\n    |         ^^^^^^^^^^^^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/illegal_write_despite_exposed1.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "da55e724fd81e77d19f561f28bce40fa5806811b", "filename": "src/tools/miri/tests/fail/stacked_borrows/interior_mut1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Finterior_mut1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Finterior_mut1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Finterior_mut1.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ help: <TAG> was later invalidated at offsets [0x0..0x4] by a write access\n    |\n LL |         *c.get() = UnsafeCell::new(1); // invalidates inner_shr\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/interior_mut1.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "8c8a96cbbbd639e7182cb8f868f6ca80f729eb25", "filename": "src/tools/miri/tests/fail/stacked_borrows/interior_mut2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Finterior_mut2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Finterior_mut2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Finterior_mut2.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ help: <TAG> was later invalidated at offsets [0x0..0x4] by a write access\n    |\n LL |         *c.get() = UnsafeCell::new(0); // now inner_shr gets invalidated\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/interior_mut2.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "95fa4c51d12fdad7f3d783ffc2caefa13ad23ce6", "filename": "src/tools/miri/tests/fail/stacked_borrows/invalidate_against_protector1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Finvalidate_against_protector1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Finvalidate_against_protector1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Finvalidate_against_protector1.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -16,7 +16,7 @@ help: <TAG> is this argument\n    |\n LL | fn inner(x: *mut i32, _y: &mut i32) {\n    |                       ^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `inner` at $DIR/invalidate_against_protector1.rs:LL:CC\n note: inside `main`\n   --> $DIR/invalidate_against_protector1.rs:LL:CC"}, {"sha": "8f677bd547ce356ea7c79a058ff7f0557a130749", "filename": "src/tools/miri/tests/fail/stacked_borrows/invalidate_against_protector2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Finvalidate_against_protector2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Finvalidate_against_protector2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Finvalidate_against_protector2.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -16,7 +16,7 @@ help: <TAG> is this argument\n    |\n LL | fn inner(x: *mut i32, _y: &i32) {\n    |                       ^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `inner` at $DIR/invalidate_against_protector2.rs:LL:CC\n note: inside `main`\n   --> $DIR/invalidate_against_protector2.rs:LL:CC"}, {"sha": "1648ca9e58bb11f2627dfa21ce4479876788d6dd", "filename": "src/tools/miri/tests/fail/stacked_borrows/invalidate_against_protector3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Finvalidate_against_protector3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Finvalidate_against_protector3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Finvalidate_against_protector3.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -16,7 +16,7 @@ help: <TAG> is this argument\n    |\n LL | fn inner(x: *mut i32, _y: &i32) {\n    |                       ^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `inner` at $DIR/invalidate_against_protector3.rs:LL:CC\n note: inside `main`\n   --> $DIR/invalidate_against_protector3.rs:LL:CC"}, {"sha": "7aca065ca0d701598803f6e46fe57ff056b23c38", "filename": "src/tools/miri/tests/fail/stacked_borrows/load_invalid_mut.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fload_invalid_mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fload_invalid_mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fload_invalid_mut.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ help: <TAG> was later invalidated at offsets [0x0..0x4] by a read access\n    |\n LL |     let _val = unsafe { *xraw }; // invalidate xref\n    |                         ^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/load_invalid_mut.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "7eb973ae7f2af94732dd5a84749acc95ebd24a80", "filename": "src/tools/miri/tests/fail/stacked_borrows/load_invalid_shr.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fload_invalid_shr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fload_invalid_shr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fload_invalid_shr.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ help: <TAG> was later invalidated at offsets [0x0..0x4] by a write access\n    |\n LL |     unsafe { *xraw = 42 }; // unfreeze\n    |              ^^^^^^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/load_invalid_shr.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "3e7fe11b5202a9595ad5c8b087552fbab827209f", "filename": "src/tools/miri/tests/fail/stacked_borrows/mut_exclusive_violation1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fmut_exclusive_violation1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fmut_exclusive_violation1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fmut_exclusive_violation1.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ help: <TAG> was later invalidated at offsets [0x0..0x4] by a write access\n    |\n LL |     *our = 5;\n    |     ^^^^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `unknown_code_2` at $DIR/mut_exclusive_violation1.rs:LL:CC\n note: inside `demo_mut_advanced_unique`\n   --> $DIR/mut_exclusive_violation1.rs:LL:CC"}, {"sha": "30ce698761f3da570ae4d95e573a6d87f05eeec6", "filename": "src/tools/miri/tests/fail/stacked_borrows/mut_exclusive_violation2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fmut_exclusive_violation2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fmut_exclusive_violation2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fmut_exclusive_violation2.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ help: <TAG> was later invalidated at offsets [0x0..0x4] by a Unique retag\n    |\n LL |         let _raw2 = ptr2.as_mut();\n    |                     ^^^^^^^^^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/mut_exclusive_violation2.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "0cba380ea1a30db629bf4396115dae0ede3bf224", "filename": "src/tools/miri/tests/fail/stacked_borrows/newtype_pair_retagging.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_pair_retagging.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_pair_retagging.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_pair_retagging.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -16,7 +16,7 @@ help: <TAG> is this argument\n    |\n LL | fn dealloc_while_running(_n: Newtype<'_>, dealloc: impl FnOnce()) {\n    |                          ^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `std::boxed::Box::<i32>::from_raw_in` at RUSTLIB/alloc/src/boxed.rs:LL:CC\n    = note: inside `std::boxed::Box::<i32>::from_raw` at RUSTLIB/alloc/src/boxed.rs:LL:CC\n note: inside closure"}, {"sha": "f76b6a57eaca0662e81ac56ff6d55685f9f00a20", "filename": "src/tools/miri/tests/fail/stacked_borrows/newtype_retagging.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -16,7 +16,7 @@ help: <TAG> is this argument\n    |\n LL | fn dealloc_while_running(_n: Newtype<'_>, dealloc: impl FnOnce()) {\n    |                          ^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `std::boxed::Box::<i32>::from_raw_in` at RUSTLIB/alloc/src/boxed.rs:LL:CC\n    = note: inside `std::boxed::Box::<i32>::from_raw` at RUSTLIB/alloc/src/boxed.rs:LL:CC\n note: inside closure"}, {"sha": "ad366bdabcee668b98b8edb2517efe6838232439", "filename": "src/tools/miri/tests/fail/stacked_borrows/outdated_local.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Foutdated_local.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Foutdated_local.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Foutdated_local.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ help: <TAG> was later invalidated at offsets [0x0..0x4] by a write access\n    |\n LL |     x = 1; // this invalidates y by reactivating the lowermost uniq borrow for this local\n    |     ^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/outdated_local.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "96cec327b9df53ddcf5dc461951bd58d53bafbfb", "filename": "src/tools/miri/tests/fail/stacked_borrows/pass_invalid_mut.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fpass_invalid_mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fpass_invalid_mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fpass_invalid_mut.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ help: <TAG> was later invalidated at offsets [0x0..0x4] by a read access\n    |\n LL |     let _val = unsafe { *xraw }; // invalidate xref\n    |                         ^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/pass_invalid_mut.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "5243858a91a7deb9444cabc29bd1579c72989a15", "filename": "src/tools/miri/tests/fail/stacked_borrows/pass_invalid_shr.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fpass_invalid_shr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fpass_invalid_shr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fpass_invalid_shr.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ help: <TAG> was later invalidated at offsets [0x0..0x4] by a write access\n    |\n LL |     unsafe { *xraw = 42 }; // unfreeze\n    |              ^^^^^^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/pass_invalid_shr.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "e20b5b89a2fca5e27fe17237a1408e91ce6b394a", "filename": "src/tools/miri/tests/fail/stacked_borrows/pointer_smuggling.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fpointer_smuggling.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fpointer_smuggling.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fpointer_smuggling.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ help: <TAG> was later invalidated at offsets [0x0..0x1] by a write access\n    |\n LL |     *val = 2; // this invalidates any raw ptrs `fun1` might have created.\n    |     ^^^^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `fun2` at $DIR/pointer_smuggling.rs:LL:CC\n note: inside `main`\n   --> $DIR/pointer_smuggling.rs:LL:CC"}, {"sha": "9f7e7a058dfcfac5c406722e63c812d18fb04210", "filename": "src/tools/miri/tests/fail/stacked_borrows/raw_tracking.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fraw_tracking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fraw_tracking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fraw_tracking.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ help: <TAG> was later invalidated at offsets [0x0..0x4] by a Unique retag\n    |\n LL |     let raw2 = &mut l as *mut _; // invalidates raw1\n    |                ^^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/raw_tracking.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "a63cd03366f68c7cccf2d67d0c5d885acfc668b4", "filename": "src/tools/miri/tests/fail/stacked_borrows/retag_data_race_read.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_read.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_read.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_read.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -15,7 +15,7 @@ fn thread_1(p: SendPtr) {\n fn thread_2(p: SendPtr) {\n     let p = p.0;\n     unsafe {\n-        *p = 5; //~ ERROR: Data race detected between Write on thread `<unnamed>` and Read on thread `<unnamed>`\n+        *p = 5; //~ ERROR: Data race detected between (1) Read on thread `<unnamed>` and (2) Write on thread `<unnamed>`\n     }\n }\n "}, {"sha": "c53a495b5e18b7da7842ffd4e51582e9d50e4b9b", "filename": "src/tools/miri/tests/fail/stacked_borrows/retag_data_race_read.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_read.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_read.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_read.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -1,12 +1,17 @@\n-error: Undefined Behavior: Data race detected between Write on thread `<unnamed>` and Read on thread `<unnamed>` at ALLOC\n+error: Undefined Behavior: Data race detected between (1) Read on thread `<unnamed>` and (2) Write on thread `<unnamed>` at ALLOC. (2) just happened here\n   --> $DIR/retag_data_race_read.rs:LL:CC\n    |\n LL |         *p = 5;\n-   |         ^^^^^^ Data race detected between Write on thread `<unnamed>` and Read on thread `<unnamed>` at ALLOC\n+   |         ^^^^^^ Data race detected between (1) Read on thread `<unnamed>` and (2) Write on thread `<unnamed>` at ALLOC. (2) just happened here\n    |\n+help: and (1) occurred earlier here\n+  --> $DIR/retag_data_race_read.rs:LL:CC\n+   |\n+LL |         let _r = &*p;\n+   |                  ^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `thread_2` at $DIR/retag_data_race_read.rs:LL:CC\n note: inside closure\n   --> $DIR/retag_data_race_read.rs:LL:CC"}, {"sha": "c1dded40d3c355f2a10b469708a63c20c6920f66", "filename": "src/tools/miri/tests/fail/stacked_borrows/retag_data_race_write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_write.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -15,7 +15,7 @@ fn thread_1(p: SendPtr) {\n fn thread_2(p: SendPtr) {\n     let p = p.0;\n     unsafe {\n-        *p = 5; //~ ERROR: Data race detected between Write on thread `<unnamed>` and Write on thread `<unnamed>`\n+        *p = 5; //~ ERROR: Data race detected between (1) Write on thread `<unnamed>` and (2) Write on thread `<unnamed>`\n     }\n }\n "}, {"sha": "da5af60067565680a517513f87722b2b5422572a", "filename": "src/tools/miri/tests/fail/stacked_borrows/retag_data_race_write.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_write.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_write.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_write.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -1,12 +1,17 @@\n-error: Undefined Behavior: Data race detected between Write on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n+error: Undefined Behavior: Data race detected between (1) Write on thread `<unnamed>` and (2) Write on thread `<unnamed>` at ALLOC. (2) just happened here\n   --> $DIR/retag_data_race_write.rs:LL:CC\n    |\n LL |         *p = 5;\n-   |         ^^^^^^ Data race detected between Write on thread `<unnamed>` and Write on thread `<unnamed>` at ALLOC\n+   |         ^^^^^^ Data race detected between (1) Write on thread `<unnamed>` and (2) Write on thread `<unnamed>` at ALLOC. (2) just happened here\n    |\n+help: and (1) occurred earlier here\n+  --> $DIR/retag_data_race_write.rs:LL:CC\n+   |\n+LL |         let _r = &mut *p;\n+   |                  ^^^^^^^\n    = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n    = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `thread_2` at $DIR/retag_data_race_write.rs:LL:CC\n note: inside closure\n   --> $DIR/retag_data_race_write.rs:LL:CC"}, {"sha": "2bf91b676c4c0fe0e7245853bfa190346d03279b", "filename": "src/tools/miri/tests/fail/stacked_borrows/return_invalid_mut.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ help: <TAG> was later invalidated at offsets [0x0..0x8] by a read access\n    |\n LL |     let _val = unsafe { *xraw }; // invalidate xref\n    |                         ^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `foo` at $DIR/return_invalid_mut.rs:LL:CC\n note: inside `main`\n   --> $DIR/return_invalid_mut.rs:LL:CC"}, {"sha": "ff00c54570cd30daea1f2140425ea2e04134d018", "filename": "src/tools/miri/tests/fail/stacked_borrows/return_invalid_mut_option.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_option.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_option.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_option.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ help: <TAG> was later invalidated at offsets [0x0..0x8] by a read access\n    |\n LL |     let _val = unsafe { *xraw }; // invalidate xref\n    |                         ^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `foo` at $DIR/return_invalid_mut_option.rs:LL:CC\n note: inside `main`\n   --> $DIR/return_invalid_mut_option.rs:LL:CC"}, {"sha": "61d041a8816d2d53879bf2bb2c8310054276aaa6", "filename": "src/tools/miri/tests/fail/stacked_borrows/return_invalid_mut_tuple.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_tuple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_tuple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_mut_tuple.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ help: <TAG> was later invalidated at offsets [0x0..0x8] by a read access\n    |\n LL |     let _val = unsafe { *xraw }; // invalidate xref\n    |                         ^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `foo` at $DIR/return_invalid_mut_tuple.rs:LL:CC\n note: inside `main`\n   --> $DIR/return_invalid_mut_tuple.rs:LL:CC"}, {"sha": "d3a73a00fa60549853483c9179a4dcc0f80c07ff", "filename": "src/tools/miri/tests/fail/stacked_borrows/return_invalid_shr.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ help: <TAG> was later invalidated at offsets [0x0..0x8] by a write access\n    |\n LL |     unsafe { *xraw = (42, 23) }; // unfreeze\n    |              ^^^^^^^^^^^^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `foo` at $DIR/return_invalid_shr.rs:LL:CC\n note: inside `main`\n   --> $DIR/return_invalid_shr.rs:LL:CC"}, {"sha": "f14e8b8532f55a713a7550cb03d6d786d9b9459d", "filename": "src/tools/miri/tests/fail/stacked_borrows/return_invalid_shr_option.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_option.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_option.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_option.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ help: <TAG> was later invalidated at offsets [0x0..0x8] by a write access\n    |\n LL |     unsafe { *xraw = (42, 23) }; // unfreeze\n    |              ^^^^^^^^^^^^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `foo` at $DIR/return_invalid_shr_option.rs:LL:CC\n note: inside `main`\n   --> $DIR/return_invalid_shr_option.rs:LL:CC"}, {"sha": "9ddaad4d1be30647f6715217f0c092d5c11954f9", "filename": "src/tools/miri/tests/fail/stacked_borrows/return_invalid_shr_tuple.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_tuple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_tuple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Freturn_invalid_shr_tuple.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ help: <TAG> was later invalidated at offsets [0x0..0x8] by a write access\n    |\n LL |     unsafe { *xraw = (42, 23) }; // unfreeze\n    |              ^^^^^^^^^^^^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `foo` at $DIR/return_invalid_shr_tuple.rs:LL:CC\n note: inside `main`\n   --> $DIR/return_invalid_shr_tuple.rs:LL:CC"}, {"sha": "589e1291ba731123f467dd0193ea7175bc81913c", "filename": "src/tools/miri/tests/fail/stacked_borrows/shared_rw_borrows_are_weak1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fshared_rw_borrows_are_weak1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fshared_rw_borrows_are_weak1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fshared_rw_borrows_are_weak1.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ help: <TAG> was later invalidated at offsets [0x0..0x4] by a Unique retag\n    |\n LL |         shr_rw.set(1);\n    |         ^^^^^^^^^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/shared_rw_borrows_are_weak1.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "0e37c4ffb394c7e4167c4d2100752af0cc8c99e3", "filename": "src/tools/miri/tests/fail/stacked_borrows/shared_rw_borrows_are_weak2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fshared_rw_borrows_are_weak2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fshared_rw_borrows_are_weak2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fshared_rw_borrows_are_weak2.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ help: <TAG> was later invalidated at offsets [$HEX..$HEX] by a Unique retag\n    |\n LL |         shr_rw.replace(1);\n    |         ^^^^^^^^^^^^^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/shared_rw_borrows_are_weak2.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "a69116f2afae73aeb3340edcd9f0412a5a7e8b3d", "filename": "src/tools/miri/tests/fail/stacked_borrows/shr_frozen_violation1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fshr_frozen_violation1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fshr_frozen_violation1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fshr_frozen_violation1.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -14,7 +14,7 @@ help: <TAG> was created by a SharedReadOnly retag at offsets [0x0..0x4]\n    |\n LL |         *(x as *const i32 as *mut i32) = 7;\n    |           ^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `unknown_code` at $DIR/shr_frozen_violation1.rs:LL:CC\n note: inside `foo`\n   --> $DIR/shr_frozen_violation1.rs:LL:CC"}, {"sha": "05be0d3f1e98a4cfc1db53c830f835cde85471f2", "filename": "src/tools/miri/tests/fail/stacked_borrows/track_caller.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Ftrack_caller.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Ftrack_caller.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Ftrack_caller.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -19,7 +19,7 @@ help: <TAG> was later invalidated at offsets [0x0..0x4] by a read access\n    |\n LL |     callee(xraw);\n    |     ^^^^^^^^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/track_caller.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "ac962311d42600f78f7def596ee8b75176fa51b9", "filename": "src/tools/miri/tests/fail/stacked_borrows/transmute-is-no-escape.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Ftransmute-is-no-escape.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Ftransmute-is-no-escape.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Ftransmute-is-no-escape.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -14,7 +14,7 @@ help: <TAG> was created by a SharedReadWrite retag at offsets [0x4..0x8]\n    |\n LL |     let raw = (&mut x[1] as *mut i32).wrapping_offset(-1);\n    |                ^^^^^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/transmute-is-no-escape.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "7a40d1078b3b74768f04e3b9a4ab443f890dcbd8", "filename": "src/tools/miri/tests/fail/stacked_borrows/unescaped_static.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Funescaped_static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Funescaped_static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Funescaped_static.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -14,7 +14,7 @@ help: <TAG> was created by a SharedReadOnly retag at offsets [0x0..0x1]\n    |\n LL |     let ptr_to_first = &ARRAY[0] as *const u8;\n    |                        ^^^^^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `main` at $DIR/unescaped_static.rs:LL:CC\n \n note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace"}, {"sha": "950abc4cbcf92fefae4579f24a72e57512a476e0", "filename": "src/tools/miri/tests/fail/stacked_borrows/zst_slice.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fzst_slice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fzst_slice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fzst_slice.stderr?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -14,7 +14,7 @@ help: <TAG> would have been created here, but this is a zero-size retag ([0x0..0\n    |\n LL |         assert_eq!(*s.get_unchecked(1), 2);\n    |                     ^^^^^^^^^^^^^^^^^^\n-   = note: BACKTRACE:\n+   = note: BACKTRACE (of the first span):\n    = note: inside `core::slice::<impl [i32]>::get_unchecked::<usize>` at RUSTLIB/core/src/slice/mod.rs:LL:CC\n note: inside `main`\n   --> $DIR/zst_slice.rs:LL:CC"}, {"sha": "fb060317538d38d266905c976c9309ff3c6ac8c4", "filename": "src/tools/miri/tests/pass-dep/page_size.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fpage_size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fpage_size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fpage_size.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -3,4 +3,17 @@ fn main() {\n \n     // In particular, this checks that it is not 0.\n     assert!(page_size.is_power_of_two(), \"page size not a power of two: {}\", page_size);\n+    // Most architectures have 4k pages by default\n+    #[cfg(not(any(\n+        target_arch = \"wasm32\",\n+        target_arch = \"wasm64\",\n+        all(target_arch = \"aarch64\", target_vendor = \"apple\")\n+    )))]\n+    assert!(page_size == 4 * 1024, \"non-4k default page size: {}\", page_size);\n+    // ... except aarch64-apple with 16k\n+    #[cfg(all(target_arch = \"aarch64\", target_vendor = \"apple\"))]\n+    assert!(page_size == 16 * 1024, \"aarch64 apple reports non-16k page size: {}\", page_size);\n+    // ... and wasm with 64k\n+    #[cfg(any(target_arch = \"wasm32\", target_arch = \"wasm64\"))]\n+    assert!(page_size == 64 * 1024, \"wasm reports non-64k page size: {}\", page_size);\n }"}, {"sha": "68858f38759a60461dbad4c763f780c7fd94aec3", "filename": "src/tools/miri/tests/pass-dep/page_size_override.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fpage_size_override.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fpage_size_override.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fpage_size_override.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -0,0 +1,7 @@\n+//@compile-flags: -Zmiri-force-page-size=8\n+\n+fn main() {\n+    let page_size = page_size::get();\n+\n+    assert!(page_size == 8 * 1024, \"8k page size override not respected: {}\", page_size);\n+}"}, {"sha": "ba5b269f65242427230466a2cb63d500bcf46db5", "filename": "src/tools/miri/tests/pass-dep/shims/libc-fs.rs", "status": "modified", "additions": 47, "deletions": 16, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -5,8 +5,8 @@\n #![feature(io_error_uncategorized)]\n \n use std::convert::TryInto;\n-use std::ffi::CString;\n-use std::fs::{canonicalize, remove_file, File};\n+use std::ffi::{CStr, CString};\n+use std::fs::{canonicalize, remove_dir_all, remove_file, File};\n use std::io::{Error, ErrorKind, Write};\n use std::os::unix::ffi::OsStrExt;\n use std::path::PathBuf;\n@@ -18,23 +18,26 @@ fn main() {\n     test_file_open_unix_allow_two_args();\n     test_file_open_unix_needs_three_args();\n     test_file_open_unix_extra_third_arg();\n+    #[cfg(target_os = \"linux\")]\n+    test_o_tmpfile_flag();\n }\n \n fn tmp() -> PathBuf {\n-    std::env::var(\"MIRI_TEMP\")\n-        .map(|tmp| {\n-            // MIRI_TEMP is set outside of our emulated\n-            // program, so it may have path separators that don't\n-            // correspond to our target platform. We normalize them here\n-            // before constructing a `PathBuf`\n-\n-            #[cfg(windows)]\n-            return PathBuf::from(tmp.replace(\"/\", \"\\\\\"));\n-\n-            #[cfg(not(windows))]\n-            return PathBuf::from(tmp.replace(\"\\\\\", \"/\"));\n-        })\n-        .unwrap_or_else(|_| std::env::temp_dir())\n+    let path = std::env::var(\"MIRI_TEMP\")\n+        .unwrap_or_else(|_| std::env::temp_dir().into_os_string().into_string().unwrap());\n+    // These are host paths. We need to convert them to the target.\n+    let path = CString::new(path).unwrap();\n+    let mut out = Vec::with_capacity(1024);\n+\n+    unsafe {\n+        extern \"Rust\" {\n+            fn miri_host_to_target_path(path: *const i8, out: *mut i8, out_size: usize) -> usize;\n+        }\n+        let ret = miri_host_to_target_path(path.as_ptr(), out.as_mut_ptr(), out.capacity());\n+        assert_eq!(ret, 0);\n+        let out = CStr::from_ptr(out.as_ptr()).to_str().unwrap();\n+        PathBuf::from(out)\n+    }\n }\n \n /// Prepare: compute filename and make sure the file does not exist.\n@@ -45,6 +48,15 @@ fn prepare(filename: &str) -> PathBuf {\n     path\n }\n \n+/// Prepare directory: compute directory name and make sure it does not exist.\n+#[allow(unused)]\n+fn prepare_dir(dirname: &str) -> PathBuf {\n+    let path = tmp().join(&dirname);\n+    // Clean the directory for robustness.\n+    remove_dir_all(&path).ok();\n+    path\n+}\n+\n /// Prepare like above, and also write some initial content to the file.\n fn prepare_with_content(filename: &str, content: &[u8]) -> PathBuf {\n     let path = prepare(filename);\n@@ -135,3 +147,22 @@ fn test_readlink() {\n     assert_eq!(res, -1);\n     assert_eq!(Error::last_os_error().kind(), ErrorKind::NotFound);\n }\n+\n+#[cfg(target_os = \"linux\")]\n+fn test_o_tmpfile_flag() {\n+    use std::fs::{create_dir, OpenOptions};\n+    use std::os::unix::fs::OpenOptionsExt;\n+    let dir_path = prepare_dir(\"miri_test_fs_dir\");\n+    create_dir(&dir_path).unwrap();\n+    // test that the `O_TMPFILE` custom flag gracefully errors instead of stopping execution\n+    assert_eq!(\n+        Some(libc::EOPNOTSUPP),\n+        OpenOptions::new()\n+            .read(true)\n+            .write(true)\n+            .custom_flags(libc::O_TMPFILE)\n+            .open(dir_path)\n+            .unwrap_err()\n+            .raw_os_error(),\n+    );\n+}"}, {"sha": "20e96a92c7c5fc6dc206c3cdf3db4d32a0637100", "filename": "src/tools/miri/tests/pass-dep/shims/libc-misc.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-misc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-misc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-misc.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -7,15 +7,23 @@ use std::os::unix::io::AsRawFd;\n use std::path::PathBuf;\n \n fn tmp() -> PathBuf {\n-    std::env::var(\"MIRI_TEMP\")\n-        .map(|tmp| {\n-            // MIRI_TEMP is set outside of our emulated\n-            // program, so it may have path separators that don't\n-            // correspond to our target platform. We normalize them here\n-            // before constructing a `PathBuf`\n-            return PathBuf::from(tmp.replace(\"\\\\\", \"/\"));\n-        })\n-        .unwrap_or_else(|_| std::env::temp_dir())\n+    use std::ffi::{CStr, CString};\n+\n+    let path = std::env::var(\"MIRI_TEMP\")\n+        .unwrap_or_else(|_| std::env::temp_dir().into_os_string().into_string().unwrap());\n+    // These are host paths. We need to convert them to the target.\n+    let path = CString::new(path).unwrap();\n+    let mut out = Vec::with_capacity(1024);\n+\n+    unsafe {\n+        extern \"Rust\" {\n+            fn miri_host_to_target_path(path: *const i8, out: *mut i8, out_size: usize) -> usize;\n+        }\n+        let ret = miri_host_to_target_path(path.as_ptr(), out.as_mut_ptr(), out.capacity());\n+        assert_eq!(ret, 0);\n+        let out = CStr::from_ptr(out.as_ptr()).to_str().unwrap();\n+        PathBuf::from(out)\n+    }\n }\n \n /// Test allocating variant of `realpath`."}, {"sha": "642168253c2fa54e3263e50a648dcb7c615ad912", "filename": "src/tools/miri/tests/pass-dep/tokio_mvp.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Ftokio_mvp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Ftokio_mvp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Ftokio_mvp.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -0,0 +1,6 @@\n+// Need to disable preemption to stay on the supported MVP codepath in mio.\n+//@compile-flags: -Zmiri-disable-isolation -Zmiri-permissive-provenance -Zmiri-preemption-rate=0\n+//@only-target-x86_64-unknown-linux: support for tokio exists only on linux and x86\n+\n+#[tokio::main]\n+async fn main() {}"}, {"sha": "c411f748a0602e0726693c196ae91cef421e527d", "filename": "src/tools/miri/tests/pass/provenance.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fprovenance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fprovenance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fprovenance.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -10,6 +10,7 @@ fn main() {\n     bytewise_ptr_methods();\n     bytewise_custom_memcpy();\n     bytewise_custom_memcpy_chunked();\n+    int_load_strip_provenance();\n }\n \n /// Some basic smoke tests for provenance.\n@@ -137,3 +138,9 @@ fn bytewise_custom_memcpy_chunked() {\n         assert_eq!(*ptr, 42);\n     }\n }\n+\n+fn int_load_strip_provenance() {\n+    let ptrs = [&42];\n+    let ints: [usize; 1] = unsafe { mem::transmute(ptrs) };\n+    assert_eq!(ptrs[0] as *const _ as usize, ints[0]);\n+}"}, {"sha": "ca90912eabc54c038ef506f011ce3edc2e03dd7b", "filename": "src/tools/miri/tests/pass/shims/env/current_dir.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Fenv%2Fcurrent_dir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Fenv%2Fcurrent_dir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Fenv%2Fcurrent_dir.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -3,8 +3,9 @@ use std::env;\n use std::io::ErrorKind;\n \n fn main() {\n-    // Test that `getcwd` is available\n+    // Test that `getcwd` is available and an absolute path\n     let cwd = env::current_dir().unwrap();\n+    assert!(cwd.is_absolute(), \"cwd {:?} is not absolute\", cwd);\n     // Test that changing dir to `..` actually sets the current directory to the parent of `cwd`.\n     // The only exception here is if `cwd` is the root directory, then changing directory must\n     // keep the current directory equal to `cwd`."}, {"sha": "a7d4800faecc4b973904c79b678dc3a886d90e3a", "filename": "src/tools/miri/tests/pass/shims/fs.rs", "status": "modified", "additions": 28, "deletions": 14, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -15,6 +15,7 @@ use std::io::{Error, ErrorKind, IsTerminal, Read, Result, Seek, SeekFrom, Write}\n use std::path::{Path, PathBuf};\n \n fn main() {\n+    test_path_conversion();\n     test_file();\n     test_file_clone();\n     test_file_create_new();\n@@ -30,21 +31,28 @@ fn main() {\n     test_from_raw_os_error();\n }\n \n+fn host_to_target_path(path: String) -> PathBuf {\n+    use std::ffi::{CStr, CString};\n+\n+    let path = CString::new(path).unwrap();\n+    let mut out = Vec::with_capacity(1024);\n+\n+    unsafe {\n+        extern \"Rust\" {\n+            fn miri_host_to_target_path(path: *const i8, out: *mut i8, out_size: usize) -> usize;\n+        }\n+        let ret = miri_host_to_target_path(path.as_ptr(), out.as_mut_ptr(), out.capacity());\n+        assert_eq!(ret, 0);\n+        let out = CStr::from_ptr(out.as_ptr()).to_str().unwrap();\n+        PathBuf::from(out)\n+    }\n+}\n+\n fn tmp() -> PathBuf {\n-    std::env::var(\"MIRI_TEMP\")\n-        .map(|tmp| {\n-            // MIRI_TEMP is set outside of our emulated\n-            // program, so it may have path separators that don't\n-            // correspond to our target platform. We normalize them here\n-            // before constructing a `PathBuf`\n-\n-            #[cfg(windows)]\n-            return PathBuf::from(tmp.replace(\"/\", \"\\\\\"));\n-\n-            #[cfg(not(windows))]\n-            return PathBuf::from(tmp.replace(\"\\\\\", \"/\"));\n-        })\n-        .unwrap_or_else(|_| std::env::temp_dir())\n+    let path = std::env::var(\"MIRI_TEMP\")\n+        .unwrap_or_else(|_| std::env::temp_dir().into_os_string().into_string().unwrap());\n+    // These are host paths. We need to convert them to the target.\n+    host_to_target_path(path)\n }\n \n /// Prepare: compute filename and make sure the file does not exist.\n@@ -71,6 +79,12 @@ fn prepare_with_content(filename: &str, content: &[u8]) -> PathBuf {\n     path\n }\n \n+fn test_path_conversion() {\n+    let tmp = tmp();\n+    assert!(tmp.is_absolute(), \"{:?} is not absolute\", tmp);\n+    assert!(tmp.is_dir(), \"{:?} is not a directory\", tmp);\n+}\n+\n fn test_file() {\n     let bytes = b\"Hello, World!\\n\";\n     let path = prepare(\"miri_test_fs_file.txt\");"}, {"sha": "3a6655e2ba69f5bfa5daa1394721b3011cfac622", "filename": "src/tools/miri/tests/pass/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/298d763fc0ac206cf3ae202459101e36a17071f7/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fvec.rs?ref=298d763fc0ac206cf3ae202459101e36a17071f7", "patch": "@@ -48,7 +48,7 @@ fn vec_into_iter_zst() {\n     assert_eq!(v, 0);\n \n     let mut it = vec![[0u64; 0], [0u64; 0]].into_iter();\n-    it.advance_by(1);\n+    it.advance_by(1).unwrap();\n     drop(it);\n \n     let mut it = vec![[0u64; 0], [0u64; 0]].into_iter();"}]}