{"sha": "6c67e5527023df098257c4258072bff52de95c8f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjNjdlNTUyNzAyM2RmMDk4MjU3YzQyNTgwNzJiZmY1MmRlOTVjOGY=", "commit": {"author": {"name": "The8472", "email": "git@infinite-source.de", "date": "2020-12-08T22:21:27Z"}, "committer": {"name": "The8472", "email": "git@infinite-source.de", "date": "2021-03-21T19:54:06Z"}, "message": "specialize in-place collection further via TrustedRandomAccess\n\nThis allows the optimizer to turn certain iterator pipelines such as\n\n```rust\nlet vec = vec![0usize; 100];\nvec.into_iter().map(|e| e as isize).collect::<Vec<_>>()\n```\n\ninto a noop.\n\nThe optimization only applies when iterator sources are  `T: Copy`\nsince `impl TrustedRandomAccess for IntoIter<T>`.\nNo such requirement applies to the output type (`Iterator::Item`).", "tree": {"sha": "920140a5381e5013c28cbb9ea0c072ccbb942b60", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/920140a5381e5013c28cbb9ea0c072ccbb942b60"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c67e5527023df098257c4258072bff52de95c8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c67e5527023df098257c4258072bff52de95c8f", "html_url": "https://github.com/rust-lang/rust/commit/6c67e5527023df098257c4258072bff52de95c8f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c67e5527023df098257c4258072bff52de95c8f/comments", "author": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "committer": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1a04e08428f2e2e26fd88c40141f7465f708c4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1a04e08428f2e2e26fd88c40141f7465f708c4e", "html_url": "https://github.com/rust-lang/rust/commit/a1a04e08428f2e2e26fd88c40141f7465f708c4e"}], "stats": {"total": 69, "additions": 53, "deletions": 16}, "files": [{"sha": "50882fc17673e76f40be6e4b8f22359fed8e862d", "filename": "library/alloc/src/vec/source_iter_marker.rs", "status": "modified", "additions": 53, "deletions": 16, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/6c67e5527023df098257c4258072bff52de95c8f/library%2Falloc%2Fsrc%2Fvec%2Fsource_iter_marker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c67e5527023df098257c4258072bff52de95c8f/library%2Falloc%2Fsrc%2Fvec%2Fsource_iter_marker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fsource_iter_marker.rs?ref=6c67e5527023df098257c4258072bff52de95c8f", "patch": "@@ -1,4 +1,4 @@\n-use core::iter::{InPlaceIterable, SourceIter};\n+use core::iter::{InPlaceIterable, SourceIter, TrustedRandomAccess};\n use core::mem::{self, ManuallyDrop};\n use core::ptr::{self};\n \n@@ -52,16 +52,7 @@ where\n             )\n         };\n \n-        // use try-fold since\n-        // - it vectorizes better for some iterator adapters\n-        // - unlike most internal iteration methods, it only takes a &mut self\n-        // - it lets us thread the write pointer through its innards and get it back in the end\n-        let sink = InPlaceDrop { inner: dst_buf, dst: dst_buf };\n-        let sink = iterator\n-            .try_fold::<_, _, Result<_, !>>(sink, write_in_place_with_drop(dst_end))\n-            .unwrap();\n-        // iteration succeeded, don't drop head\n-        let dst = ManuallyDrop::new(sink).dst;\n+        let len = SpecInPlaceCollect::collect_in_place(&mut iterator, dst_buf, dst_end);\n \n         let src = unsafe { iterator.as_inner().as_into_iter() };\n         // check if SourceIter contract was upheld\n@@ -72,7 +63,7 @@ where\n         // then the source pointer will stay in its initial position and we can't use it as reference\n         if src.ptr != src_ptr {\n             debug_assert!(\n-                dst as *const _ <= src.ptr,\n+                unsafe { dst_buf.add(len) as *const _ } <= src.ptr,\n                 \"InPlaceIterable contract violation, write pointer advanced beyond read pointer\"\n             );\n         }\n@@ -82,10 +73,7 @@ where\n         // but prevent drop of the allocation itself once IntoIter goes out of scope\n         src.forget_allocation();\n \n-        let vec = unsafe {\n-            let len = dst.offset_from(dst_buf) as usize;\n-            Vec::from_raw_parts(dst_buf, len, cap)\n-        };\n+        let vec = unsafe { Vec::from_raw_parts(dst_buf, len, cap) };\n \n         vec\n     }\n@@ -106,3 +94,52 @@ fn write_in_place_with_drop<T>(\n         Ok(sink)\n     }\n }\n+\n+/// Helper trait to hold specialized implementations of the in-place iterate-collect loop\n+trait SpecInPlaceCollect<T, I>: Iterator<Item = T> {\n+    /// Collects an iterator (`self`) into the destination buffer (`dst`) and returns the number of items\n+    /// collected. `end` is the last writable element of the allocation and used for bounds checks.\n+    fn collect_in_place(&mut self, dst: *mut T, end: *const T) -> usize;\n+}\n+\n+impl<T, I> SpecInPlaceCollect<T, I> for I\n+where\n+    I: Iterator<Item = T>,\n+{\n+    #[inline]\n+    default fn collect_in_place(&mut self, dst_buf: *mut T, end: *const T) -> usize {\n+        // use try-fold since\n+        // - it vectorizes better for some iterator adapters\n+        // - unlike most internal iteration methods, it only takes a &mut self\n+        // - it lets us thread the write pointer through its innards and get it back in the end\n+        let sink = InPlaceDrop { inner: dst_buf, dst: dst_buf };\n+        let sink =\n+            self.try_fold::<_, _, Result<_, !>>(sink, write_in_place_with_drop(end)).unwrap();\n+        // iteration succeeded, don't drop head\n+        unsafe { ManuallyDrop::new(sink).dst.offset_from(dst_buf) as usize }\n+    }\n+}\n+\n+impl<T, I> SpecInPlaceCollect<T, I> for I\n+where\n+    I: Iterator<Item = T> + TrustedRandomAccess,\n+{\n+    #[inline]\n+    fn collect_in_place(&mut self, dst_buf: *mut T, end: *const T) -> usize {\n+        let len = self.size();\n+        let mut drop_guard = InPlaceDrop { inner: dst_buf, dst: dst_buf };\n+        for i in 0..len {\n+            // Safety: InplaceIterable contract guarantees that for every element we read\n+            // one slot in the underlying storage will have been freed up and we can immediately\n+            // write back the result.\n+            unsafe {\n+                let dst = dst_buf.offset(i as isize);\n+                debug_assert!(dst as *const _ <= end, \"InPlaceIterable contract violation\");\n+                ptr::write(dst, self.__iterator_get_unchecked(i));\n+                drop_guard.dst = dst.add(1);\n+            }\n+        }\n+        mem::forget(drop_guard);\n+        len\n+    }\n+}"}]}