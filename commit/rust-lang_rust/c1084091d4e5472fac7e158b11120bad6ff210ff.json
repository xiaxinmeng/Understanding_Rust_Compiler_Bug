{"sha": "c1084091d4e5472fac7e158b11120bad6ff210ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxMDg0MDkxZDRlNTQ3MmZhYzdlMTU4YjExMTIwYmFkNmZmMjEwZmY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-22T04:34:30Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-22T17:29:17Z"}, "message": "libstd: Remove all uses of `pure` from libstd. rs=depure", "tree": {"sha": "745a42f03c8c88670da739313cd8050a5f1d8b37", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/745a42f03c8c88670da739313cd8050a5f1d8b37"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1084091d4e5472fac7e158b11120bad6ff210ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1084091d4e5472fac7e158b11120bad6ff210ff", "html_url": "https://github.com/rust-lang/rust/commit/c1084091d4e5472fac7e158b11120bad6ff210ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1084091d4e5472fac7e158b11120bad6ff210ff/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be9bddd46377bc982b73acf15a720365a54197a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/be9bddd46377bc982b73acf15a720365a54197a7", "html_url": "https://github.com/rust-lang/rust/commit/be9bddd46377bc982b73acf15a720365a54197a7"}], "stats": {"total": 706, "additions": 353, "deletions": 353}, "files": [{"sha": "d76438dd89bc1e4d2ed392bd493e4d41838d64f9", "filename": "src/libstd/arena.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farena.rs?ref=c1084091d4e5472fac7e158b11120bad6ff210ff", "patch": "@@ -123,7 +123,7 @@ pub fn Arena() -> Arena {\n }\n \n #[inline(always)]\n-pure fn round_up_to(base: uint, align: uint) -> uint {\n+fn round_up_to(base: uint, align: uint) -> uint {\n     (base + (align - 1)) & !(align - 1)\n }\n "}, {"sha": "ff026324404abbbb197c93e25d47f079a0ed3132", "filename": "src/libstd/base64.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbase64.rs?ref=c1084091d4e5472fac7e158b11120bad6ff210ff", "patch": "@@ -13,11 +13,11 @@ use core::str;\n use core::vec;\n \n pub trait ToBase64 {\n-    pure fn to_base64(&self) -> ~str;\n+    fn to_base64(&self) -> ~str;\n }\n \n impl ToBase64 for &'self [u8] {\n-    pure fn to_base64(&self) -> ~str {\n+    fn to_base64(&self) -> ~str {\n         let chars = str::chars(\n           ~\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n         );\n@@ -70,17 +70,17 @@ impl ToBase64 for &'self [u8] {\n }\n \n impl ToBase64 for &'self str {\n-    pure fn to_base64(&self) -> ~str {\n+    fn to_base64(&self) -> ~str {\n         str::to_bytes(*self).to_base64()\n     }\n }\n \n pub trait FromBase64 {\n-    pure fn from_base64(&self) -> ~[u8];\n+    fn from_base64(&self) -> ~[u8];\n }\n \n impl FromBase64 for ~[u8] {\n-    pure fn from_base64(&self) -> ~[u8] {\n+    fn from_base64(&self) -> ~[u8] {\n         if self.len() % 4u != 0u { fail!(~\"invalid base64 length\"); }\n \n         let len = self.len();\n@@ -142,7 +142,7 @@ impl FromBase64 for ~[u8] {\n }\n \n impl FromBase64 for ~str {\n-    pure fn from_base64(&self) -> ~[u8] {\n+    fn from_base64(&self) -> ~[u8] {\n         str::to_bytes(*self).from_base64()\n     }\n }"}, {"sha": "309925e7cf9b48e2462770baf21bb620059dd600", "filename": "src/libstd/bigint.rs", "status": "modified", "additions": 104, "deletions": 104, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbigint.rs?ref=c1084091d4e5472fac7e158b11120bad6ff210ff", "patch": "@@ -53,16 +53,16 @@ pub mod BigDigit {\n     priv const hi_mask: uint = (-1 as uint) << bits;\n     priv const lo_mask: uint = (-1 as uint) >> bits;\n \n-    priv pure fn get_hi(n: uint) -> BigDigit { (n >> bits) as BigDigit }\n-    priv pure fn get_lo(n: uint) -> BigDigit { (n & lo_mask) as BigDigit }\n+    priv fn get_hi(n: uint) -> BigDigit { (n >> bits) as BigDigit }\n+    priv fn get_lo(n: uint) -> BigDigit { (n & lo_mask) as BigDigit }\n \n     /// Split one machine sized unsigned integer into two BigDigits.\n-    pub pure fn from_uint(n: uint) -> (BigDigit, BigDigit) {\n+    pub fn from_uint(n: uint) -> (BigDigit, BigDigit) {\n         (get_hi(n), get_lo(n))\n     }\n \n     /// Join two BigDigits into one machine sized unsigned integer\n-    pub pure fn to_uint(hi: BigDigit, lo: BigDigit) -> uint {\n+    pub fn to_uint(hi: BigDigit, lo: BigDigit) -> uint {\n         (lo as uint) | ((hi as uint) << bits)\n     }\n }\n@@ -78,53 +78,53 @@ pub struct BigUint {\n }\n \n impl Eq for BigUint {\n-    pure fn eq(&self, other: &BigUint) -> bool { self.cmp(other) == 0 }\n-    pure fn ne(&self, other: &BigUint) -> bool { self.cmp(other) != 0 }\n+    fn eq(&self, other: &BigUint) -> bool { self.cmp(other) == 0 }\n+    fn ne(&self, other: &BigUint) -> bool { self.cmp(other) != 0 }\n }\n \n impl Ord for BigUint {\n-    pure fn lt(&self, other: &BigUint) -> bool { self.cmp(other) <  0 }\n-    pure fn le(&self, other: &BigUint) -> bool { self.cmp(other) <= 0 }\n-    pure fn ge(&self, other: &BigUint) -> bool { self.cmp(other) >= 0 }\n-    pure fn gt(&self, other: &BigUint) -> bool { self.cmp(other) >  0 }\n+    fn lt(&self, other: &BigUint) -> bool { self.cmp(other) <  0 }\n+    fn le(&self, other: &BigUint) -> bool { self.cmp(other) <= 0 }\n+    fn ge(&self, other: &BigUint) -> bool { self.cmp(other) >= 0 }\n+    fn gt(&self, other: &BigUint) -> bool { self.cmp(other) >  0 }\n }\n \n impl ToStr for BigUint {\n-    pure fn to_str(&self) -> ~str { self.to_str_radix(10) }\n+    fn to_str(&self) -> ~str { self.to_str_radix(10) }\n }\n \n impl from_str::FromStr for BigUint {\n-    pure fn from_str(s: &str) -> Option<BigUint> {\n+    fn from_str(s: &str) -> Option<BigUint> {\n         BigUint::from_str_radix(s, 10)\n     }\n }\n \n impl Shl<uint, BigUint> for BigUint {\n-    pure fn shl(&self, rhs: &uint) -> BigUint {\n+    fn shl(&self, rhs: &uint) -> BigUint {\n         let n_unit = *rhs / BigDigit::bits;\n         let n_bits = *rhs % BigDigit::bits;\n         return self.shl_unit(n_unit).shl_bits(n_bits);\n     }\n }\n \n impl Shr<uint, BigUint> for BigUint {\n-    pure fn shr(&self, rhs: &uint) -> BigUint {\n+    fn shr(&self, rhs: &uint) -> BigUint {\n         let n_unit = *rhs / BigDigit::bits;\n         let n_bits = *rhs % BigDigit::bits;\n         return self.shr_unit(n_unit).shr_bits(n_bits);\n     }\n }\n \n impl Zero for BigUint {\n-    pure fn zero() -> BigUint { BigUint::new(~[]) }\n+    fn zero() -> BigUint { BigUint::new(~[]) }\n }\n \n impl One for BigUint {\n-    pub pure fn one() -> BigUint { BigUint::new(~[1]) }\n+    pub fn one() -> BigUint { BigUint::new(~[1]) }\n }\n \n impl Add<BigUint, BigUint> for BigUint {\n-    pure fn add(&self, other: &BigUint) -> BigUint {\n+    fn add(&self, other: &BigUint) -> BigUint {\n         let new_len = uint::max(self.data.len(), other.data.len());\n \n         let mut carry = 0;\n@@ -143,7 +143,7 @@ impl Add<BigUint, BigUint> for BigUint {\n }\n \n impl Sub<BigUint, BigUint> for BigUint {\n-    pure fn sub(&self, other: &BigUint) -> BigUint {\n+    fn sub(&self, other: &BigUint) -> BigUint {\n         let new_len = uint::max(self.data.len(), other.data.len());\n \n         let mut borrow = 0;\n@@ -168,7 +168,7 @@ impl Sub<BigUint, BigUint> for BigUint {\n }\n \n impl Mul<BigUint, BigUint> for BigUint {\n-    pure fn mul(&self, other: &BigUint) -> BigUint {\n+    fn mul(&self, other: &BigUint) -> BigUint {\n         if self.is_zero() || other.is_zero() { return Zero::zero(); }\n \n         let s_len = self.data.len(), o_len = other.data.len();\n@@ -200,7 +200,7 @@ impl Mul<BigUint, BigUint> for BigUint {\n \n         return ll + mm.shl_unit(half_len) + hh.shl_unit(half_len * 2);\n \n-        pure fn mul_digit(a: &BigUint, n: BigDigit) -> BigUint {\n+        fn mul_digit(a: &BigUint, n: BigDigit) -> BigUint {\n             if n == 0 { return Zero::zero(); }\n             if n == 1 { return copy *a; }\n \n@@ -216,14 +216,14 @@ impl Mul<BigUint, BigUint> for BigUint {\n             return BigUint::new(prod + [carry]);\n         }\n \n-        pure fn cut_at(a: &BigUint, n: uint) -> (BigUint, BigUint) {\n+        fn cut_at(a: &BigUint, n: uint) -> (BigUint, BigUint) {\n             let mid = uint::min(a.data.len(), n);\n             return (BigUint::from_slice(vec::slice(a.data, mid,\n                                                    a.data.len())),\n                     BigUint::from_slice(vec::slice(a.data, 0, mid)));\n         }\n \n-        pure fn sub_sign(a: BigUint, b: BigUint) -> (int, BigUint) {\n+        fn sub_sign(a: BigUint, b: BigUint) -> (int, BigUint) {\n             match a.cmp(&b) {\n                 s if s < 0 => (s, b - a),\n                 s if s > 0 => (s, a - b),\n@@ -234,36 +234,36 @@ impl Mul<BigUint, BigUint> for BigUint {\n }\n \n impl Div<BigUint, BigUint> for BigUint {\n-    pure fn div(&self, other: &BigUint) -> BigUint {\n+    fn div(&self, other: &BigUint) -> BigUint {\n         let (d, _) = self.divmod(other);\n         return d;\n     }\n }\n \n impl Modulo<BigUint, BigUint> for BigUint {\n-    pure fn modulo(&self, other: &BigUint) -> BigUint {\n+    fn modulo(&self, other: &BigUint) -> BigUint {\n         let (_, m) = self.divmod(other);\n         return m;\n     }\n }\n \n impl Neg<BigUint> for BigUint {\n-    pure fn neg(&self) -> BigUint { fail!() }\n+    fn neg(&self) -> BigUint { fail!() }\n }\n \n impl IntConvertible for BigUint {\n-    pure fn to_int(&self) -> int {\n+    fn to_int(&self) -> int {\n         uint::min(self.to_uint(), int::max_value as uint) as int\n     }\n \n-    pure fn from_int(n: int) -> BigUint {\n+    fn from_int(n: int) -> BigUint {\n         if (n < 0) { Zero::zero() } else { BigUint::from_uint(n as uint) }\n     }\n }\n \n pub impl BigUint {\n     /// Creates and initializes an BigUint.\n-    pub pure fn new(v: ~[BigDigit]) -> BigUint {\n+    pub fn new(v: ~[BigDigit]) -> BigUint {\n         // omit trailing zeros\n         let new_len = v.rposition(|n| *n != 0).map_default(0, |p| *p + 1);\n \n@@ -274,7 +274,7 @@ pub impl BigUint {\n     }\n \n     /// Creates and initializes an BigUint.\n-    pub pure fn from_uint(n: uint) -> BigUint {\n+    pub fn from_uint(n: uint) -> BigUint {\n         match BigDigit::from_uint(n) {\n             (0,  0)  => Zero::zero(),\n             (0,  n0) => BigUint::new(~[n0]),\n@@ -283,18 +283,18 @@ pub impl BigUint {\n     }\n \n     /// Creates and initializes an BigUint.\n-    pub pure fn from_slice(slice: &[BigDigit]) -> BigUint {\n+    pub fn from_slice(slice: &[BigDigit]) -> BigUint {\n         return BigUint::new(vec::from_slice(slice));\n     }\n \n     /// Creates and initializes an BigUint.\n-    pub pure fn from_str_radix(s: &str, radix: uint)\n+    pub fn from_str_radix(s: &str, radix: uint)\n         -> Option<BigUint> {\n         BigUint::parse_bytes(str::to_bytes(s), radix)\n     }\n \n     /// Creates and initializes an BigUint.\n-    pub pure fn parse_bytes(buf: &[u8], radix: uint)\n+    pub fn parse_bytes(buf: &[u8], radix: uint)\n         -> Option<BigUint> {\n         let (base, unit_len) = get_radix_base(radix);\n         let base_num: BigUint = BigUint::from_uint(base);\n@@ -316,10 +316,10 @@ pub impl BigUint {\n         }\n     }\n \n-    pure fn abs(&self) -> BigUint { copy *self }\n+    fn abs(&self) -> BigUint { copy *self }\n \n     /// Compare two BigUint value.\n-    pure fn cmp(&self, other: &BigUint) -> int {\n+    fn cmp(&self, other: &BigUint) -> int {\n         let s_len = self.data.len(), o_len = other.data.len();\n         if s_len < o_len { return -1; }\n         if s_len > o_len { return  1;  }\n@@ -334,7 +334,7 @@ pub impl BigUint {\n         return 0;\n     }\n \n-    pure fn divmod(&self, other: &BigUint) -> (BigUint, BigUint) {\n+    fn divmod(&self, other: &BigUint) -> (BigUint, BigUint) {\n         if other.is_zero() { fail!() }\n         if self.is_zero() { return (Zero::zero(), Zero::zero()); }\n         if *other == One::one() { return (copy *self, Zero::zero()); }\n@@ -355,7 +355,7 @@ pub impl BigUint {\n         let (d, m) = divmod_inner(self << shift, other << shift);\n         return (d, m >> shift);\n \n-        pure fn divmod_inner(a: BigUint, b: BigUint) -> (BigUint, BigUint) {\n+        fn divmod_inner(a: BigUint, b: BigUint) -> (BigUint, BigUint) {\n             let mut r = a;\n             let mut d = Zero::zero::<BigUint>();\n             let mut n = 1;\n@@ -377,7 +377,7 @@ pub impl BigUint {\n             return (d, r);\n         }\n \n-        pure fn div_estimate(a: &BigUint, b: &BigUint, n: uint)\n+        fn div_estimate(a: &BigUint, b: &BigUint, n: uint)\n             -> (BigUint, BigUint, BigUint) {\n             if a.data.len() < n {\n                 return (Zero::zero(), Zero::zero(), copy *a);\n@@ -405,26 +405,26 @@ pub impl BigUint {\n         }\n     }\n \n-    pure fn quot(&self, other: &BigUint) -> BigUint {\n+    fn quot(&self, other: &BigUint) -> BigUint {\n         let (q, _) = self.quotrem(other);\n         return q;\n     }\n-    pure fn rem(&self, other: &BigUint) -> BigUint {\n+    fn rem(&self, other: &BigUint) -> BigUint {\n         let (_, r) = self.quotrem(other);\n         return r;\n     }\n-    pure fn quotrem(&self, other: &BigUint) -> (BigUint, BigUint) {\n+    fn quotrem(&self, other: &BigUint) -> (BigUint, BigUint) {\n         self.divmod(other)\n     }\n \n-    pure fn is_zero(&self) -> bool { self.data.is_empty() }\n-    pure fn is_not_zero(&self) -> bool { !self.data.is_empty() }\n-    pure fn is_positive(&self) -> bool { self.is_not_zero() }\n-    pure fn is_negative(&self) -> bool { false }\n-    pure fn is_nonpositive(&self) -> bool { self.is_zero() }\n-    pure fn is_nonnegative(&self) -> bool { true }\n+    fn is_zero(&self) -> bool { self.data.is_empty() }\n+    fn is_not_zero(&self) -> bool { !self.data.is_empty() }\n+    fn is_positive(&self) -> bool { self.is_not_zero() }\n+    fn is_negative(&self) -> bool { false }\n+    fn is_nonpositive(&self) -> bool { self.is_zero() }\n+    fn is_nonnegative(&self) -> bool { true }\n \n-    pure fn to_uint(&self) -> uint {\n+    fn to_uint(&self) -> uint {\n         match self.data.len() {\n             0 => 0,\n             1 => self.data[0] as uint,\n@@ -433,15 +433,15 @@ pub impl BigUint {\n         }\n     }\n \n-    pure fn to_str_radix(&self, radix: uint) -> ~str {\n+    fn to_str_radix(&self, radix: uint) -> ~str {\n         fail_unless!(1 < radix && radix <= 16);\n         let (base, max_len) = get_radix_base(radix);\n         if base == BigDigit::base {\n             return fill_concat(self.data, radix, max_len)\n         }\n         return fill_concat(convert_base(copy *self, base), radix, max_len);\n \n-        pure fn convert_base(n: BigUint, base: uint) -> ~[BigDigit] {\n+        fn convert_base(n: BigUint, base: uint) -> ~[BigDigit] {\n             let divider    = BigUint::from_uint(base);\n             let mut result = ~[];\n             let mut r      = n;\n@@ -456,7 +456,7 @@ pub impl BigUint {\n             return result;\n         }\n \n-        pure fn fill_concat(v: &[BigDigit], radix: uint, l: uint) -> ~str {\n+        fn fill_concat(v: &[BigDigit], radix: uint, l: uint) -> ~str {\n             if v.is_empty() { return ~\"0\" }\n             let s = str::concat(vec::reversed(v).map(|n| {\n                 let s = uint::to_str_radix(*n as uint, radix);\n@@ -466,13 +466,13 @@ pub impl BigUint {\n         }\n     }\n \n-    priv pure fn shl_unit(self, n_unit: uint) -> BigUint {\n+    priv fn shl_unit(self, n_unit: uint) -> BigUint {\n         if n_unit == 0 || self.is_zero() { return self; }\n \n         return BigUint::new(vec::from_elem(n_unit, 0) + self.data);\n     }\n \n-    priv pure fn shl_bits(self, n_bits: uint) -> BigUint {\n+    priv fn shl_bits(self, n_bits: uint) -> BigUint {\n         if n_bits == 0 || self.is_zero() { return self; }\n \n         let mut carry = 0;\n@@ -487,15 +487,15 @@ pub impl BigUint {\n         return BigUint::new(shifted + [carry]);\n     }\n \n-    priv pure fn shr_unit(self, n_unit: uint) -> BigUint {\n+    priv fn shr_unit(self, n_unit: uint) -> BigUint {\n         if n_unit == 0 { return self; }\n         if self.data.len() < n_unit { return Zero::zero(); }\n         return BigUint::from_slice(\n             vec::slice(self.data, n_unit, self.data.len())\n         );\n     }\n \n-    priv pure fn shr_bits(self, n_bits: uint) -> BigUint {\n+    priv fn shr_bits(self, n_bits: uint) -> BigUint {\n         if n_bits == 0 || self.data.is_empty() { return self; }\n \n         let mut borrow = 0;\n@@ -509,7 +509,7 @@ pub impl BigUint {\n }\n \n #[cfg(target_arch = \"x86_64\")]\n-priv pure fn get_radix_base(radix: uint) -> (uint, uint) {\n+priv fn get_radix_base(radix: uint) -> (uint, uint) {\n     fail_unless!(1 < radix && radix <= 16);\n     match radix {\n         2  => (4294967296, 32),\n@@ -534,7 +534,7 @@ priv pure fn get_radix_base(radix: uint) -> (uint, uint) {\n #[cfg(target_arch = \"arm\")]\n #[cfg(target_arch = \"x86\")]\n #[cfg(target_arch = \"mips\")]\n-priv pure fn get_radix_base(radix: uint) -> (uint, uint) {\n+priv fn get_radix_base(radix: uint) -> (uint, uint) {\n     fail_unless!(1 < radix && radix <= 16);\n     match radix {\n         2  => (65536, 16),\n@@ -560,20 +560,20 @@ priv pure fn get_radix_base(radix: uint) -> (uint, uint) {\n pub enum Sign { Minus, Zero, Plus }\n \n impl Eq for Sign {\n-    pure fn eq(&self, other: &Sign) -> bool { self.cmp(other) == 0 }\n-    pure fn ne(&self, other: &Sign) -> bool { self.cmp(other) != 0 }\n+    fn eq(&self, other: &Sign) -> bool { self.cmp(other) == 0 }\n+    fn ne(&self, other: &Sign) -> bool { self.cmp(other) != 0 }\n }\n \n impl Ord for Sign {\n-    pure fn lt(&self, other: &Sign) -> bool { self.cmp(other) <  0 }\n-    pure fn le(&self, other: &Sign) -> bool { self.cmp(other) <= 0 }\n-    pure fn ge(&self, other: &Sign) -> bool { self.cmp(other) >= 0 }\n-    pure fn gt(&self, other: &Sign) -> bool { self.cmp(other) >  0 }\n+    fn lt(&self, other: &Sign) -> bool { self.cmp(other) <  0 }\n+    fn le(&self, other: &Sign) -> bool { self.cmp(other) <= 0 }\n+    fn ge(&self, other: &Sign) -> bool { self.cmp(other) >= 0 }\n+    fn gt(&self, other: &Sign) -> bool { self.cmp(other) >  0 }\n }\n \n pub impl Sign {\n     /// Compare two Sign.\n-    pure fn cmp(&self, other: &Sign) -> int {\n+    fn cmp(&self, other: &Sign) -> int {\n         match (*self, *other) {\n           (Minus, Minus) | (Zero,  Zero) | (Plus, Plus) =>  0,\n           (Minus, Zero)  | (Minus, Plus) | (Zero, Plus) => -1,\n@@ -582,7 +582,7 @@ pub impl Sign {\n     }\n \n     /// Negate Sign value.\n-    pure fn neg(&self) -> Sign {\n+    fn neg(&self) -> Sign {\n         match *self {\n           Minus => Plus,\n           Zero  => Zero,\n@@ -598,53 +598,53 @@ pub struct BigInt {\n }\n \n impl Eq for BigInt {\n-    pure fn eq(&self, other: &BigInt) -> bool { self.cmp(other) == 0 }\n-    pure fn ne(&self, other: &BigInt) -> bool { self.cmp(other) != 0 }\n+    fn eq(&self, other: &BigInt) -> bool { self.cmp(other) == 0 }\n+    fn ne(&self, other: &BigInt) -> bool { self.cmp(other) != 0 }\n }\n \n impl Ord for BigInt {\n-    pure fn lt(&self, other: &BigInt) -> bool { self.cmp(other) <  0 }\n-    pure fn le(&self, other: &BigInt) -> bool { self.cmp(other) <= 0 }\n-    pure fn ge(&self, other: &BigInt) -> bool { self.cmp(other) >= 0 }\n-    pure fn gt(&self, other: &BigInt) -> bool { self.cmp(other) >  0 }\n+    fn lt(&self, other: &BigInt) -> bool { self.cmp(other) <  0 }\n+    fn le(&self, other: &BigInt) -> bool { self.cmp(other) <= 0 }\n+    fn ge(&self, other: &BigInt) -> bool { self.cmp(other) >= 0 }\n+    fn gt(&self, other: &BigInt) -> bool { self.cmp(other) >  0 }\n }\n \n impl ToStr for BigInt {\n-    pure fn to_str(&self) -> ~str { self.to_str_radix(10) }\n+    fn to_str(&self) -> ~str { self.to_str_radix(10) }\n }\n \n impl from_str::FromStr for BigInt {\n-    pure fn from_str(s: &str) -> Option<BigInt> {\n+    fn from_str(s: &str) -> Option<BigInt> {\n         BigInt::from_str_radix(s, 10)\n     }\n }\n \n impl Shl<uint, BigInt> for BigInt {\n-    pure fn shl(&self, rhs: &uint) -> BigInt {\n+    fn shl(&self, rhs: &uint) -> BigInt {\n         BigInt::from_biguint(self.sign, self.data << *rhs)\n     }\n }\n \n impl Shr<uint, BigInt> for BigInt {\n-    pure fn shr(&self, rhs: &uint) -> BigInt {\n+    fn shr(&self, rhs: &uint) -> BigInt {\n         BigInt::from_biguint(self.sign, self.data >> *rhs)\n     }\n }\n \n impl Zero for BigInt {\n-    pub pure fn zero() -> BigInt {\n+    pub fn zero() -> BigInt {\n         BigInt::from_biguint(Zero, Zero::zero())\n     }\n }\n \n impl One for BigInt {\n-    pub pure fn one() -> BigInt {\n+    pub fn one() -> BigInt {\n         BigInt::from_biguint(Plus, One::one())\n     }\n }\n \n impl Add<BigInt, BigInt> for BigInt {\n-    pure fn add(&self, other: &BigInt) -> BigInt {\n+    fn add(&self, other: &BigInt) -> BigInt {\n         match (self.sign, other.sign) {\n             (Zero, _)      => copy *other,\n             (_,    Zero)   => copy *self,\n@@ -658,7 +658,7 @@ impl Add<BigInt, BigInt> for BigInt {\n }\n \n impl Sub<BigInt, BigInt> for BigInt {\n-    pure fn sub(&self, other: &BigInt) -> BigInt {\n+    fn sub(&self, other: &BigInt) -> BigInt {\n         match (self.sign, other.sign) {\n             (Zero, _)    => -other,\n             (_,    Zero) => copy *self,\n@@ -678,7 +678,7 @@ impl Sub<BigInt, BigInt> for BigInt {\n }\n \n impl Mul<BigInt, BigInt> for BigInt {\n-    pure fn mul(&self, other: &BigInt) -> BigInt {\n+    fn mul(&self, other: &BigInt) -> BigInt {\n         match (self.sign, other.sign) {\n             (Zero, _)     | (_,     Zero)  => Zero::zero(),\n             (Plus, Plus)  | (Minus, Minus) => {\n@@ -692,27 +692,27 @@ impl Mul<BigInt, BigInt> for BigInt {\n }\n \n impl Div<BigInt, BigInt> for BigInt {\n-    pure fn div(&self, other: &BigInt) -> BigInt {\n+    fn div(&self, other: &BigInt) -> BigInt {\n         let (d, _) = self.divmod(other);\n         return d;\n     }\n }\n \n impl Modulo<BigInt, BigInt> for BigInt {\n-    pure fn modulo(&self, other: &BigInt) -> BigInt {\n+    fn modulo(&self, other: &BigInt) -> BigInt {\n         let (_, m) = self.divmod(other);\n         return m;\n     }\n }\n \n impl Neg<BigInt> for BigInt {\n-    pure fn neg(&self) -> BigInt {\n+    fn neg(&self) -> BigInt {\n         BigInt::from_biguint(self.sign.neg(), copy self.data)\n     }\n }\n \n impl IntConvertible for BigInt {\n-    pure fn to_int(&self) -> int {\n+    fn to_int(&self) -> int {\n         match self.sign {\n             Plus  => uint::min(self.to_uint(), int::max_value as uint) as int,\n             Zero  => 0,\n@@ -721,7 +721,7 @@ impl IntConvertible for BigInt {\n         }\n     }\n \n-    pure fn from_int(n: int) -> BigInt {\n+    fn from_int(n: int) -> BigInt {\n         if n > 0 {\n            return BigInt::from_biguint(Plus,  BigUint::from_uint(n as uint));\n         }\n@@ -736,37 +736,37 @@ impl IntConvertible for BigInt {\n \n pub impl BigInt {\n     /// Creates and initializes an BigInt.\n-    pub pure fn new(sign: Sign, v: ~[BigDigit]) -> BigInt {\n+    pub fn new(sign: Sign, v: ~[BigDigit]) -> BigInt {\n         BigInt::from_biguint(sign, BigUint::new(v))\n     }\n \n     /// Creates and initializes an BigInt.\n-    pub pure fn from_biguint(sign: Sign, data: BigUint) -> BigInt {\n+    pub fn from_biguint(sign: Sign, data: BigUint) -> BigInt {\n         if sign == Zero || data.is_zero() {\n             return BigInt { sign: Zero, data: Zero::zero() };\n         }\n         return BigInt { sign: sign, data: data };\n     }\n \n     /// Creates and initializes an BigInt.\n-    pub pure fn from_uint(n: uint) -> BigInt {\n+    pub fn from_uint(n: uint) -> BigInt {\n         if n == 0 { return Zero::zero(); }\n         return BigInt::from_biguint(Plus, BigUint::from_uint(n));\n     }\n \n     /// Creates and initializes an BigInt.\n-    pub pure fn from_slice(sign: Sign, slice: &[BigDigit]) -> BigInt {\n+    pub fn from_slice(sign: Sign, slice: &[BigDigit]) -> BigInt {\n         BigInt::from_biguint(sign, BigUint::from_slice(slice))\n     }\n \n     /// Creates and initializes an BigInt.\n-    pub pure fn from_str_radix(s: &str, radix: uint)\n+    pub fn from_str_radix(s: &str, radix: uint)\n         -> Option<BigInt> {\n         BigInt::parse_bytes(str::to_bytes(s), radix)\n     }\n \n     /// Creates and initializes an BigInt.\n-    pub pure fn parse_bytes(buf: &[u8], radix: uint)\n+    pub fn parse_bytes(buf: &[u8], radix: uint)\n         -> Option<BigInt> {\n         if buf.is_empty() { return None; }\n         let mut sign  = Plus;\n@@ -779,11 +779,11 @@ pub impl BigInt {\n             .map(|bu| BigInt::from_biguint(sign, *bu));\n     }\n \n-    pure fn abs(&self) -> BigInt {\n+    fn abs(&self) -> BigInt {\n         BigInt::from_biguint(Plus, copy self.data)\n     }\n \n-    pure fn cmp(&self, other: &BigInt) -> int {\n+    fn cmp(&self, other: &BigInt) -> int {\n         let ss = self.sign, os = other.sign;\n         if ss < os { return -1; }\n         if ss > os { return  1; }\n@@ -796,7 +796,7 @@ pub impl BigInt {\n         }\n     }\n \n-    pure fn divmod(&self, other: &BigInt) -> (BigInt, BigInt) {\n+    fn divmod(&self, other: &BigInt) -> (BigInt, BigInt) {\n         // m.sign == other.sign\n         let (d_ui, m_ui) = self.data.divmod(&other.data);\n         let d = BigInt::from_biguint(Plus, d_ui),\n@@ -818,16 +818,16 @@ pub impl BigInt {\n         }\n     }\n \n-    pure fn quot(&self, other: &BigInt) -> BigInt {\n+    fn quot(&self, other: &BigInt) -> BigInt {\n         let (q, _) = self.quotrem(other);\n         return q;\n     }\n-    pure fn rem(&self, other: &BigInt) -> BigInt {\n+    fn rem(&self, other: &BigInt) -> BigInt {\n         let (_, r) = self.quotrem(other);\n         return r;\n     }\n \n-    pure fn quotrem(&self, other: &BigInt) -> (BigInt, BigInt) {\n+    fn quotrem(&self, other: &BigInt) -> (BigInt, BigInt) {\n         // r.sign == self.sign\n         let (q_ui, r_ui) = self.data.quotrem(&other.data);\n         let q = BigInt::from_biguint(Plus, q_ui);\n@@ -841,22 +841,22 @@ pub impl BigInt {\n         }\n     }\n \n-    pure fn is_zero(&self) -> bool { self.sign == Zero }\n-    pure fn is_not_zero(&self) -> bool { self.sign != Zero }\n-    pure fn is_positive(&self) -> bool { self.sign == Plus }\n-    pure fn is_negative(&self) -> bool { self.sign == Minus }\n-    pure fn is_nonpositive(&self) -> bool { self.sign != Plus }\n-    pure fn is_nonnegative(&self) -> bool { self.sign != Minus }\n+    fn is_zero(&self) -> bool { self.sign == Zero }\n+    fn is_not_zero(&self) -> bool { self.sign != Zero }\n+    fn is_positive(&self) -> bool { self.sign == Plus }\n+    fn is_negative(&self) -> bool { self.sign == Minus }\n+    fn is_nonpositive(&self) -> bool { self.sign != Plus }\n+    fn is_nonnegative(&self) -> bool { self.sign != Minus }\n \n-    pure fn to_uint(&self) -> uint {\n+    fn to_uint(&self) -> uint {\n         match self.sign {\n             Plus  => self.data.to_uint(),\n             Zero  => 0,\n             Minus => 0\n         }\n     }\n \n-    pure fn to_str_radix(&self, radix: uint) -> ~str {\n+    fn to_str_radix(&self, radix: uint) -> ~str {\n         match self.sign {\n             Plus  => self.data.to_str_radix(radix),\n             Zero  => ~\"0\","}, {"sha": "270a2c1fc1b316c0c8b8b9e5ca854867b714a90e", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=c1084091d4e5472fac7e158b11120bad6ff210ff", "patch": "@@ -62,7 +62,7 @@ pub impl SmallBitv {\n     }\n \n     #[inline(always)]\n-    pure fn get(&self, i: uint) -> bool {\n+    fn get(&self, i: uint) -> bool {\n         (self.bits & (1 << i)) != 0\n     }\n \n@@ -181,7 +181,7 @@ pub impl BigBitv {\n     }\n \n     #[inline(always)]\n-    pure fn get(&self, i: uint) -> bool {\n+    fn get(&self, i: uint) -> bool {\n         let w = i / uint::bits;\n         let b = i % uint::bits;\n         let x = 1 & self.storage[w] >> b;\n@@ -299,7 +299,7 @@ pub impl Bitv {\n \n     /// Retrieve the value at index `i`\n     #[inline(always)]\n-    pure fn get(&self, i: uint) -> bool {\n+    fn get(&self, i: uint) -> bool {\n        fail_unless!((i < self.nbits));\n        match self.rep {\n          Big(ref b)   => b.get(i),\n@@ -555,13 +555,13 @@ pub fn from_fn(len: uint, f: &fn(index: uint) -> bool) -> Bitv {\n }\n \n impl ops::Index<uint,bool> for Bitv {\n-    pure fn index(&self, i: uint) -> bool {\n+    fn index(&self, i: uint) -> bool {\n         self.get(i)\n     }\n }\n \n #[inline(always)]\n-pure fn iterate_bits(base: uint, bits: uint, f: &fn(uint) -> bool) -> bool {\n+fn iterate_bits(base: uint, bits: uint, f: &fn(uint) -> bool) -> bool {\n     if bits == 0 {\n         return true;\n     }\n@@ -612,7 +612,7 @@ pub impl BitvSet {\n \n     /// Returns the capacity in bits for this bit vector. Inserting any\n     /// element less than this amount will not trigger a resizing.\n-    pure fn capacity(&self) -> uint { self.bitv.storage.len() * uint::bits }\n+    fn capacity(&self) -> uint { self.bitv.storage.len() * uint::bits }\n \n     /// Consumes this set to return the underlying bit vector\n     fn unwrap(self) -> Bitv {\n@@ -667,9 +667,9 @@ pub impl BitvSet {\n }\n \n impl BaseIter<uint> for BitvSet {\n-    pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n \n-    pure fn each(&self, blk: &fn(v: &uint) -> bool) {\n+    fn each(&self, blk: &fn(v: &uint) -> bool) {\n         for self.bitv.storage.eachi |i, &w| {\n             if !iterate_bits(i * uint::bits, w, |b| blk(&b)) {\n                 return;\n@@ -679,7 +679,7 @@ impl BaseIter<uint> for BitvSet {\n }\n \n impl cmp::Eq for BitvSet {\n-    pure fn eq(&self, other: &BitvSet) -> bool {\n+    fn eq(&self, other: &BitvSet) -> bool {\n         if self.size != other.size {\n             return false;\n         }\n@@ -696,12 +696,12 @@ impl cmp::Eq for BitvSet {\n         return true;\n     }\n \n-    pure fn ne(&self, other: &BitvSet) -> bool { !self.eq(other) }\n+    fn ne(&self, other: &BitvSet) -> bool { !self.eq(other) }\n }\n \n impl Container for BitvSet {\n-    pure fn len(&const self) -> uint { self.size }\n-    pure fn is_empty(&const self) -> bool { self.size == 0 }\n+    fn len(&const self) -> uint { self.size }\n+    fn is_empty(&const self) -> bool { self.size == 0 }\n }\n \n impl Mutable for BitvSet {\n@@ -712,7 +712,7 @@ impl Mutable for BitvSet {\n }\n \n impl Set<uint> for BitvSet {\n-    pure fn contains(&self, value: &uint) -> bool {\n+    fn contains(&self, value: &uint) -> bool {\n         *value < self.bitv.storage.len() * uint::bits && self.bitv.get(*value)\n     }\n \n@@ -748,14 +748,14 @@ impl Set<uint> for BitvSet {\n         return true;\n     }\n \n-    pure fn is_disjoint(&self, other: &BitvSet) -> bool {\n+    fn is_disjoint(&self, other: &BitvSet) -> bool {\n         for self.intersection(other) |_| {\n             return false;\n         }\n         return true;\n     }\n \n-    pure fn is_subset(&self, other: &BitvSet) -> bool {\n+    fn is_subset(&self, other: &BitvSet) -> bool {\n         for self.each_common(other) |_, w1, w2| {\n             if w1 & w2 != w1 {\n                 return false;\n@@ -774,11 +774,11 @@ impl Set<uint> for BitvSet {\n         return true;\n     }\n \n-    pure fn is_superset(&self, other: &BitvSet) -> bool {\n+    fn is_superset(&self, other: &BitvSet) -> bool {\n         other.is_subset(self)\n     }\n \n-    pure fn difference(&self, other: &BitvSet, f: &fn(&uint) -> bool) {\n+    fn difference(&self, other: &BitvSet, f: &fn(&uint) -> bool) {\n         for self.each_common(other) |i, w1, w2| {\n             if !iterate_bits(i, w1 & !w2, |b| f(&b)) {\n                 return;\n@@ -790,7 +790,7 @@ impl Set<uint> for BitvSet {\n         );\n     }\n \n-    pure fn symmetric_difference(&self, other: &BitvSet,\n+    fn symmetric_difference(&self, other: &BitvSet,\n                                  f: &fn(&uint) -> bool) {\n         for self.each_common(other) |i, w1, w2| {\n             if !iterate_bits(i, w1 ^ w2, |b| f(&b)) {\n@@ -802,15 +802,15 @@ impl Set<uint> for BitvSet {\n         );\n     }\n \n-    pure fn intersection(&self, other: &BitvSet, f: &fn(&uint) -> bool) {\n+    fn intersection(&self, other: &BitvSet, f: &fn(&uint) -> bool) {\n         for self.each_common(other) |i, w1, w2| {\n             if !iterate_bits(i, w1 & w2, |b| f(&b)) {\n                 return;\n             }\n         }\n     }\n \n-    pure fn union(&self, other: &BitvSet, f: &fn(&uint) -> bool) {\n+    fn union(&self, other: &BitvSet, f: &fn(&uint) -> bool) {\n         for self.each_common(other) |i, w1, w2| {\n             if !iterate_bits(i, w1 | w2, |b| f(&b)) {\n                 return;\n@@ -827,7 +827,7 @@ priv impl BitvSet {\n     /// both have in common. The three yielded arguments are (bit location,\n     /// w1, w2) where the bit location is the number of bits offset so far,\n     /// and w1/w2 are the words coming from the two vectors self, other.\n-    pure fn each_common(&self, other: &BitvSet,\n+    fn each_common(&self, other: &BitvSet,\n                         f: &fn(uint, uint, uint) -> bool) {\n         let min = uint::min(self.bitv.storage.len(),\n                             other.bitv.storage.len());\n@@ -845,7 +845,7 @@ priv impl BitvSet {\n     /// The yielded arguments are a bool, the bit offset, and a word. The bool\n     /// is true if the word comes from 'self', and false if it comes from\n     /// 'other'.\n-    pure fn each_outlier(&self, other: &BitvSet,\n+    fn each_outlier(&self, other: &BitvSet,\n                          f: &fn(bool, uint, uint) -> bool) {\n         let len1 = self.bitv.storage.len();\n         let len2 = other.bitv.storage.len();"}, {"sha": "1787be75e24d264183bdd84db7fe8253d9ff4e33", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=c1084091d4e5472fac7e158b11120bad6ff210ff", "patch": "@@ -141,7 +141,7 @@ pub fn set<T:Copy>(t: CVec<T>, ofs: uint, v: T) {\n  */\n \n /// Returns the length of the vector\n-pub pure fn len<T>(t: CVec<T>) -> uint { t.len }\n+pub fn len<T>(t: CVec<T>) -> uint { t.len }\n \n /// Returns a pointer to the first element of the vector\n pub unsafe fn ptr<T>(t: CVec<T>) -> *mut T { t.base }"}, {"sha": "6fd77de034262372d37969c02d94f358c3ed300f", "filename": "src/libstd/cmp.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcmp.rs?ref=c1084091d4e5472fac7e158b11120bad6ff210ff", "patch": "@@ -17,36 +17,36 @@ use core::float;\n pub const FUZZY_EPSILON: float = 1.0e-6;\n \n pub trait FuzzyEq<Eps> {\n-    pure fn fuzzy_eq(&self, other: &Self) -> bool;\n-    pure fn fuzzy_eq_eps(&self, other: &Self, epsilon: &Eps) -> bool;\n+    fn fuzzy_eq(&self, other: &Self) -> bool;\n+    fn fuzzy_eq_eps(&self, other: &Self, epsilon: &Eps) -> bool;\n }\n \n impl FuzzyEq<float> for float {\n-    pure fn fuzzy_eq(&self, other: &float) -> bool {\n+    fn fuzzy_eq(&self, other: &float) -> bool {\n         self.fuzzy_eq_eps(other, &FUZZY_EPSILON)\n     }\n \n-    pure fn fuzzy_eq_eps(&self, other: &float, epsilon: &float) -> bool {\n+    fn fuzzy_eq_eps(&self, other: &float, epsilon: &float) -> bool {\n         float::abs(*self - *other) < *epsilon\n     }\n }\n \n impl FuzzyEq<f32> for f32 {\n-    pure fn fuzzy_eq(&self, other: &f32) -> bool {\n+    fn fuzzy_eq(&self, other: &f32) -> bool {\n         self.fuzzy_eq_eps(other, &(FUZZY_EPSILON as f32))\n     }\n \n-    pure fn fuzzy_eq_eps(&self, other: &f32, epsilon: &f32) -> bool {\n+    fn fuzzy_eq_eps(&self, other: &f32, epsilon: &f32) -> bool {\n         f32::abs(*self - *other) < *epsilon\n     }\n }\n \n impl FuzzyEq<f64> for f64 {\n-    pure fn fuzzy_eq(&self, other: &f64) -> bool {\n+    fn fuzzy_eq(&self, other: &f64) -> bool {\n         self.fuzzy_eq_eps(other, &(FUZZY_EPSILON as f64))\n     }\n \n-    pure fn fuzzy_eq_eps(&self, other: &f64, epsilon: &f64) -> bool {\n+    fn fuzzy_eq_eps(&self, other: &f64, epsilon: &f64) -> bool {\n         f64::abs(*self - *other) < *epsilon\n     }\n }\n@@ -71,11 +71,11 @@ mod test_complex{\n     struct Complex { r: float, i: float }\n \n     impl FuzzyEq<float> for Complex {\n-        pure fn fuzzy_eq(&self, other: &Complex) -> bool {\n+        fn fuzzy_eq(&self, other: &Complex) -> bool {\n             self.fuzzy_eq_eps(other, &FUZZY_EPSILON)\n         }\n \n-        pure fn fuzzy_eq_eps(&self, other: &Complex,\n+        fn fuzzy_eq_eps(&self, other: &Complex,\n                              epsilon: &float) -> bool {\n             self.r.fuzzy_eq_eps(&other.r, epsilon) &&\n             self.i.fuzzy_eq_eps(&other.i, epsilon)"}, {"sha": "9f68c6762228d14347ab2c88a88d6f3ad407d6b4", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=c1084091d4e5472fac7e158b11120bad6ff210ff", "patch": "@@ -39,7 +39,7 @@ pub impl<T:Owned,U:Owned> DuplexStream<T, U> {\n     fn try_recv(&self) -> Option<U> {\n         self.port.try_recv()\n     }\n-    pure fn peek(&self) -> bool {\n+    fn peek(&self) -> bool {\n         self.port.peek()\n     }\n }\n@@ -67,13 +67,13 @@ impl<T:Owned,U:Owned> GenericPort<U> for DuplexStream<T, U> {\n }\n \n impl<T:Owned,U:Owned> Peekable<U> for DuplexStream<T, U> {\n-    pure fn peek(&self) -> bool {\n+    fn peek(&self) -> bool {\n         self.port.peek()\n     }\n }\n \n impl<T:Owned,U:Owned> Selectable for DuplexStream<T, U> {\n-    pure fn header(&self) -> *pipes::PacketHeader {\n+    fn header(&self) -> *pipes::PacketHeader {\n         self.port.header()\n     }\n }"}, {"sha": "4f61321b4e777d749e7a455d5c7f5ee740d3a67c", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=c1084091d4e5472fac7e158b11120bad6ff210ff", "patch": "@@ -25,10 +25,10 @@ pub struct Deque<T> {\n \n impl<T> Container for Deque<T> {\n     /// Return the number of elements in the deque\n-    pure fn len(&const self) -> uint { self.nelts }\n+    fn len(&const self) -> uint { self.nelts }\n \n     /// Return true if the deque contains no elements\n-    pure fn is_empty(&const self) -> bool { self.len() == 0 }\n+    fn is_empty(&const self) -> bool { self.len() == 0 }\n }\n \n impl<T> Mutable for Deque<T> {\n@@ -43,7 +43,7 @@ impl<T> Mutable for Deque<T> {\n \n pub impl<T> Deque<T> {\n     /// Create an empty Deque\n-    pure fn new() -> Deque<T> {\n+    fn new() -> Deque<T> {\n         Deque{nelts: 0, lo: 0, hi: 0,\n               elts: vec::from_fn(initial_capacity, |_| None)}\n     }"}, {"sha": "437ab561f954576ab610c76c2b6b63a335ffbfb2", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=c1084091d4e5472fac7e158b11120bad6ff210ff", "patch": "@@ -69,7 +69,7 @@ pub mod reader {\n     // ebml reading\n \n     impl ops::Index<uint,Doc> for Doc {\n-        pure fn index(&self, tag: uint) -> Doc {\n+        fn index(&self, tag: uint) -> Doc {\n             unsafe {\n                 get_doc(*self, tag)\n             }"}, {"sha": "29771fa350122670609518e1ec77599813f6a096", "filename": "src/libstd/future.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=c1084091d4e5472fac7e158b11120bad6ff210ff", "patch": "@@ -56,7 +56,7 @@ pub impl<A:Copy> Future<A> {\n \n pub impl<A> Future<A> {\n \n-    pure fn get_ref(&self) -> &'self A {\n+    fn get_ref(&self) -> &'self A {\n         /*!\n         * Executes the future's closure and then returns a borrowed\n         * pointer to the result.  The borrowed pointer lasts as long as"}, {"sha": "0973e90dad3d2b5ddccbecef914007ba2458c5e1", "filename": "src/libstd/json.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=c1084091d4e5472fac7e158b11120bad6ff210ff", "patch": "@@ -345,7 +345,7 @@ pub fn to_writer(wr: @io::Writer, json: &Json) {\n }\n \n /// Encodes a json value into a string\n-pub pure fn to_str(json: &Json) -> ~str {\n+pub fn to_str(json: &Json) -> ~str {\n     unsafe {\n         // ugh, should be safe\n         io::with_str_writer(|wr| to_writer(wr, json))\n@@ -947,7 +947,7 @@ impl serialize::Decoder for Decoder/&self {\n }\n \n impl Eq for Json {\n-    pure fn eq(&self, other: &Json) -> bool {\n+    fn eq(&self, other: &Json) -> bool {\n         match (self) {\n             &Number(f0) =>\n                 match other { &Number(f1) => f0 == f1, _ => false },\n@@ -980,12 +980,12 @@ impl Eq for Json {\n             }\n         }\n     }\n-    pure fn ne(&self, other: &Json) -> bool { !self.eq(other) }\n+    fn ne(&self, other: &Json) -> bool { !self.eq(other) }\n }\n \n /// Test if two json values are less than one another\n impl Ord for Json {\n-    pure fn lt(&self, other: &Json) -> bool {\n+    fn lt(&self, other: &Json) -> bool {\n         match (*self) {\n             Number(f0) => {\n                 match *other {\n@@ -1055,18 +1055,18 @@ impl Ord for Json {\n             }\n         }\n     }\n-    pure fn le(&self, other: &Json) -> bool { !(*other).lt(&(*self)) }\n-    pure fn ge(&self, other: &Json) -> bool { !(*self).lt(other) }\n-    pure fn gt(&self, other: &Json) -> bool { (*other).lt(&(*self))  }\n+    fn le(&self, other: &Json) -> bool { !(*other).lt(&(*self)) }\n+    fn ge(&self, other: &Json) -> bool { !(*self).lt(other) }\n+    fn gt(&self, other: &Json) -> bool { (*other).lt(&(*self))  }\n }\n \n impl Eq for Error {\n-    pure fn eq(&self, other: &Error) -> bool {\n+    fn eq(&self, other: &Error) -> bool {\n         (*self).line == other.line &&\n         (*self).col == other.col &&\n         (*self).msg == other.msg\n     }\n-    pure fn ne(&self, other: &Error) -> bool { !(*self).eq(other) }\n+    fn ne(&self, other: &Error) -> bool { !(*self).eq(other) }\n }\n \n trait ToJson { fn to_json(&self) -> Json; }\n@@ -1191,11 +1191,11 @@ impl<A:ToJson> ToJson for Option<A> {\n }\n \n impl to_str::ToStr for Json {\n-    pure fn to_str(&self) -> ~str { to_str(self) }\n+    fn to_str(&self) -> ~str { to_str(self) }\n }\n \n impl to_str::ToStr for Error {\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         fmt!(\"%u:%u: %s\", self.line, self.col, *self.msg)\n     }\n }"}, {"sha": "b918f8505c80203fbfbb36a688b20554f0fd4555", "filename": "src/libstd/list.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=c1084091d4e5472fac7e158b11120bad6ff210ff", "patch": "@@ -22,7 +22,7 @@ pub enum List<T> {\n }\n \n /// Create a list from a vector\n-pub pure fn from_vec<T:Copy>(v: &[T]) -> @List<T> {\n+pub fn from_vec<T:Copy>(v: &[T]) -> @List<T> {\n     vec::foldr(v, @Nil::<T>, |h, t| @Cons(*h, t))\n }\n \n@@ -52,7 +52,7 @@ pub fn foldl<T:Copy,U>(z: T, ls: @List<U>, f: &fn(&T, &U) -> T) -> T {\n  * When function `f` returns true then an option containing the element\n  * is returned. If `f` matches no elements then none is returned.\n  */\n-pub pure fn find<T:Copy>(ls: @List<T>, f: &fn(&T) -> bool) -> Option<T> {\n+pub fn find<T:Copy>(ls: @List<T>, f: &fn(&T) -> bool) -> Option<T> {\n     let mut ls = ls;\n     loop {\n         ls = match *ls {\n@@ -74,30 +74,30 @@ pub fn has<T:Copy + Eq>(ls: @List<T>, elt: T) -> bool {\n }\n \n /// Returns true if the list is empty\n-pub pure fn is_empty<T:Copy>(ls: @List<T>) -> bool {\n+pub fn is_empty<T:Copy>(ls: @List<T>) -> bool {\n     match *ls {\n         Nil => true,\n         _ => false\n     }\n }\n \n /// Returns the length of a list\n-pub pure fn len<T>(ls: @List<T>) -> uint {\n+pub fn len<T>(ls: @List<T>) -> uint {\n     let mut count = 0u;\n     iter(ls, |_e| count += 1u);\n     count\n }\n \n /// Returns all but the first element of a list\n-pub pure fn tail<T:Copy>(ls: @List<T>) -> @List<T> {\n+pub fn tail<T:Copy>(ls: @List<T>) -> @List<T> {\n     match *ls {\n         Cons(_, tl) => return tl,\n         Nil => fail!(~\"list empty\")\n     }\n }\n \n /// Returns the first element of a list\n-pub pure fn head<T:Copy>(ls: @List<T>) -> T {\n+pub fn head<T:Copy>(ls: @List<T>) -> T {\n     match *ls {\n       Cons(copy hd, _) => hd,\n       // makes me sad\n@@ -106,7 +106,7 @@ pub pure fn head<T:Copy>(ls: @List<T>) -> T {\n }\n \n /// Appends one list to another\n-pub pure fn append<T:Copy>(l: @List<T>, m: @List<T>) -> @List<T> {\n+pub fn append<T:Copy>(l: @List<T>, m: @List<T>) -> @List<T> {\n     match *l {\n       Nil => return m,\n       Cons(copy x, xs) => {\n@@ -119,13 +119,13 @@ pub pure fn append<T:Copy>(l: @List<T>, m: @List<T>) -> @List<T> {\n /*\n /// Push one element into the front of a list, returning a new list\n /// THIS VERSION DOESN'T ACTUALLY WORK\n-pure fn push<T:Copy>(ll: &mut @list<T>, vv: T) {\n+fn push<T:Copy>(ll: &mut @list<T>, vv: T) {\n     ll = &mut @cons(vv, *ll)\n }\n */\n \n /// Iterate over a list\n-pub pure fn iter<T>(l: @List<T>, f: &fn(&T)) {\n+pub fn iter<T>(l: @List<T>, f: &fn(&T)) {\n     let mut cur = l;\n     loop {\n         cur = match *cur {\n@@ -139,7 +139,7 @@ pub pure fn iter<T>(l: @List<T>, f: &fn(&T)) {\n }\n \n /// Iterate over a list\n-pub pure fn each<T>(l: @List<T>, f: &fn(&T) -> bool) {\n+pub fn each<T>(l: @List<T>, f: &fn(&T) -> bool) {\n     let mut cur = l;\n     loop {\n         cur = match *cur {"}, {"sha": "e20ac624278f702fb20b5d0efae5e0b93b23ea02", "filename": "src/libstd/md4.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Fmd4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Fmd4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmd4.rs?ref=c1084091d4e5472fac7e158b11120bad6ff210ff", "patch": "@@ -19,7 +19,7 @@ struct Quad {\n     d: u32\n }\n \n-pub pure fn md4(msg: &[u8]) -> Quad {\n+pub fn md4(msg: &[u8]) -> Quad {\n     // subtle: if orig_len is merely uint, then the code below\n     // which performs shifts by 32 bits or more has undefined\n     // results.\n@@ -45,7 +45,7 @@ pub pure fn md4(msg: &[u8]) -> Quad {\n     let mut c = 0x98badcfeu32;\n     let mut d = 0x10325476u32;\n \n-    pure fn rot(r: int, x: u32) -> u32 {\n+    fn rot(r: int, x: u32) -> u32 {\n         let r = r as u32;\n         (x << r) | (x >> (32u32 - r))\n     }\n@@ -103,9 +103,9 @@ pub pure fn md4(msg: &[u8]) -> Quad {\n     return Quad {a: a, b: b, c: c, d: d};\n }\n \n-pub pure fn md4_str(msg: &[u8]) -> ~str {\n+pub fn md4_str(msg: &[u8]) -> ~str {\n     let Quad {a, b, c, d} = md4(msg);\n-    pure fn app(a: u32, b: u32, c: u32, d: u32, f: &fn(u32)) {\n+    fn app(a: u32, b: u32, c: u32, d: u32, f: &fn(u32)) {\n         f(a); f(b); f(c); f(d);\n     }\n     let mut result = ~\"\";\n@@ -121,7 +121,7 @@ pub pure fn md4_str(msg: &[u8]) -> ~str {\n     result\n }\n \n-pub pure fn md4_text(msg: &str) -> ~str { md4_str(str::to_bytes(msg)) }\n+pub fn md4_text(msg: &str) -> ~str { md4_str(str::to_bytes(msg)) }\n \n #[test]\n fn test_md4() {"}, {"sha": "21b60584635fcc9418cfc353ae8f21c59345fca3", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=c1084091d4e5472fac7e158b11120bad6ff210ff", "patch": "@@ -45,7 +45,7 @@ struct UserInfo {\n pub type Query = ~[(~str, ~str)];\n \n pub impl Url {\n-    pure fn new(\n+    fn new(\n         scheme: ~str,\n         user: Option<UserInfo>,\n         host: ~str,\n@@ -67,7 +67,7 @@ pub impl Url {\n }\n \n pub impl UserInfo {\n-    pure fn new(user: ~str, pass: Option<~str>) -> UserInfo {\n+    fn new(user: ~str, pass: Option<~str>) -> UserInfo {\n         UserInfo { user: user, pass: pass }\n     }\n }\n@@ -117,7 +117,7 @@ fn encode_inner(s: &str, full_url: bool) -> ~str {\n  *\n  * This function is compliant with RFC 3986.\n  */\n-pub pure fn encode(s: &str) -> ~str {\n+pub fn encode(s: &str) -> ~str {\n     // FIXME(#3722): unsafe only because encode_inner does (string) IO\n     unsafe {encode_inner(s, true)}\n }\n@@ -129,7 +129,7 @@ pub pure fn encode(s: &str) -> ~str {\n  * This function is compliant with RFC 3986.\n  */\n \n-pub pure fn encode_component(s: &str) -> ~str {\n+pub fn encode_component(s: &str) -> ~str {\n     // FIXME(#3722): unsafe only because encode_inner does (string) IO\n     unsafe {encode_inner(s, false)}\n }\n@@ -177,15 +177,15 @@ fn decode_inner(s: &str, full_url: bool) -> ~str {\n  *\n  * This will only decode escape sequences generated by encode.\n  */\n-pub pure fn decode(s: &str) -> ~str {\n+pub fn decode(s: &str) -> ~str {\n     // FIXME(#3722): unsafe only because decode_inner does (string) IO\n     unsafe {decode_inner(s, true)}\n }\n \n /**\n  * Decode a string encoded with percent encoding.\n  */\n-pub pure fn decode_component(s: &str) -> ~str {\n+pub fn decode_component(s: &str) -> ~str {\n     // FIXME(#3722): unsafe only because decode_inner does (string) IO\n     unsafe {decode_inner(s, false)}\n }\n@@ -297,7 +297,7 @@ pub fn decode_form_urlencoded(s: &[u8]) -> LinearMap<~str, ~[~str]> {\n }\n \n \n-pure fn split_char_first(s: &str, c: char) -> (~str, ~str) {\n+fn split_char_first(s: &str, c: char) -> (~str, ~str) {\n     let len = str::len(s);\n     let mut index = len;\n     let mut mat = 0;\n@@ -324,7 +324,7 @@ pure fn split_char_first(s: &str, c: char) -> (~str, ~str) {\n     }\n }\n \n-pure fn userinfo_from_str(uinfo: &str) -> UserInfo {\n+fn userinfo_from_str(uinfo: &str) -> UserInfo {\n     let (user, p) = split_char_first(uinfo, ':');\n     let pass = if str::len(p) == 0 {\n         None\n@@ -334,14 +334,14 @@ pure fn userinfo_from_str(uinfo: &str) -> UserInfo {\n     return UserInfo::new(user, pass);\n }\n \n-pure fn userinfo_to_str(userinfo: &UserInfo) -> ~str {\n+fn userinfo_to_str(userinfo: &UserInfo) -> ~str {\n     match userinfo.pass {\n         Some(ref pass) => fmt!(\"%s:%s@\", userinfo.user, *pass),\n         None => fmt!(\"%s@\", userinfo.user),\n     }\n }\n \n-pure fn query_from_str(rawquery: &str) -> Query {\n+fn query_from_str(rawquery: &str) -> Query {\n     let mut query: Query = ~[];\n     if str::len(rawquery) != 0 {\n         for str::split_char(rawquery, '&').each |p| {\n@@ -353,7 +353,7 @@ pure fn query_from_str(rawquery: &str) -> Query {\n     return query;\n }\n \n-pub pure fn query_to_str(query: &Query) -> ~str {\n+pub fn query_to_str(query: &Query) -> ~str {\n     unsafe {\n         // FIXME(#3722): unsafe only because decode_inner does (string) IO\n         let mut strvec = ~[];\n@@ -372,7 +372,7 @@ pub pure fn query_to_str(query: &Query) -> ~str {\n }\n \n // returns the scheme and the rest of the url, or a parsing error\n-pub pure fn get_scheme(rawurl: &str) -> Result<(~str, ~str), ~str> {\n+pub fn get_scheme(rawurl: &str) -> Result<(~str, ~str), ~str> {\n     for str::each_chari(rawurl) |i,c| {\n         match c {\n           'A' .. 'Z' | 'a' .. 'z' => loop,\n@@ -406,7 +406,7 @@ enum Input {\n }\n \n // returns userinfo, host, port, and unparsed part, or an error\n-pure fn get_authority(rawurl: &str) ->\n+fn get_authority(rawurl: &str) ->\n     Result<(Option<UserInfo>, ~str, Option<~str>, ~str), ~str> {\n     if !str::starts_with(rawurl, ~\"//\") {\n         // there is no authority.\n@@ -534,7 +534,7 @@ pure fn get_authority(rawurl: &str) ->\n \n     let end = end; // make end immutable so it can be captured\n \n-    let host_is_end_plus_one: &pure fn() -> bool = || {\n+    let host_is_end_plus_one: &fn() -> bool = || {\n         end+1 == len\n             && !['?', '#', '/'].contains(&(rawurl[end] as char))\n     };\n@@ -573,7 +573,7 @@ pure fn get_authority(rawurl: &str) ->\n \n \n // returns the path and unparsed part of url, or an error\n-pure fn get_path(rawurl: &str, authority: bool) ->\n+fn get_path(rawurl: &str, authority: bool) ->\n     Result<(~str, ~str), ~str> {\n     let len = str::len(rawurl);\n     let mut end = len;\n@@ -604,7 +604,7 @@ pure fn get_path(rawurl: &str, authority: bool) ->\n }\n \n // returns the parsed query and the fragment, if present\n-pure fn get_query_fragment(rawurl: &str) ->\n+fn get_query_fragment(rawurl: &str) ->\n     Result<(Query, Option<~str>), ~str> {\n     if !str::starts_with(rawurl, ~\"?\") {\n         if str::starts_with(rawurl, ~\"#\") {\n@@ -636,7 +636,7 @@ pure fn get_query_fragment(rawurl: &str) ->\n  *\n  */\n \n-pub pure fn from_str(rawurl: &str) -> Result<Url, ~str> {\n+pub fn from_str(rawurl: &str) -> Result<Url, ~str> {\n     // scheme\n     let (scheme, rest) = match get_scheme(rawurl) {\n         Ok(val) => val,\n@@ -666,7 +666,7 @@ pub pure fn from_str(rawurl: &str) -> Result<Url, ~str> {\n }\n \n impl FromStr for Url {\n-    pure fn from_str(s: &str) -> Option<Url> {\n+    fn from_str(s: &str) -> Option<Url> {\n         match from_str(s) {\n             Ok(url) => Some(url),\n             Err(_) => None\n@@ -689,7 +689,7 @@ impl FromStr for Url {\n  * result in just \"http://somehost.com\".\n  *\n  */\n-pub pure fn to_str(url: &Url) -> ~str {\n+pub fn to_str(url: &Url) -> ~str {\n     let user = match url.user {\n         Some(ref user) => userinfo_to_str(user),\n         None => ~\"\",\n@@ -716,13 +716,13 @@ pub pure fn to_str(url: &Url) -> ~str {\n }\n \n impl to_str::ToStr for Url {\n-    pub pure fn to_str(&self) -> ~str {\n+    pub fn to_str(&self) -> ~str {\n         to_str(self)\n     }\n }\n \n impl to_bytes::IterBytes for Url {\n-    pure fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         self.to_str().iter_bytes(lsb0, f)\n     }\n }"}, {"sha": "0b688f0c67861bb3a282616c177fd1492cfc5582", "filename": "src/libstd/oldmap.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Foldmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Foldmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foldmap.rs?ref=c1084091d4e5472fac7e158b11120bad6ff210ff", "patch": "@@ -31,7 +31,7 @@ pub mod util {\n         den: int,\n     }\n \n-    pub pure fn rational_leq(x: Rational, y: Rational) -> bool {\n+    pub fn rational_leq(x: Rational, y: Rational) -> bool {\n         // NB: Uses the fact that rationals have positive denominators WLOG:\n \n         x.num * y.den <= y.num * x.den\n@@ -74,7 +74,7 @@ pub mod chained {\n     }\n \n     priv impl<K:Eq + IterBytes + Hash,V> HashMap_<K, V> {\n-        pure fn search_rem(&self, k: &K, h: uint, idx: uint,\n+        fn search_rem(&self, k: &K, h: uint, idx: uint,\n                            e_root: @Entry<K,V>) -> SearchResult<K,V> {\n             let mut e0 = e_root;\n             let mut comp = 1u;   // for logging\n@@ -100,7 +100,7 @@ pub mod chained {\n             };\n         }\n \n-        pure fn search_tbl(&self, k: &K, h: uint) -> SearchResult<K,V> {\n+        fn search_tbl(&self, k: &K, h: uint) -> SearchResult<K,V> {\n             let idx = h % vec::uniq_len(&const self.chains);\n             match copy self.chains[idx] {\n               None => {\n@@ -134,7 +134,7 @@ pub mod chained {\n     }\n \n     pub impl<K:Eq + IterBytes + Hash,V> HashMap_<K, V> {\n-        pure fn each_entry(&self, blk: &fn(@Entry<K,V>) -> bool) {\n+        fn each_entry(&self, blk: &fn(@Entry<K,V>) -> bool) {\n             // n.b. we can't use vec::iter() here because self.chains\n             // is stored in a mutable location.\n             let mut i = 0u, n = vec::uniq_len(&const self.chains);\n@@ -161,12 +161,12 @@ pub mod chained {\n     }\n \n     impl<K:Eq + IterBytes + Hash,V> Container for HashMap_<K, V> {\n-        pure fn len(&const self) -> uint { self.count }\n-        pure fn is_empty(&const self) -> bool { self.count == 0 }\n+        fn len(&const self) -> uint { self.count }\n+        fn is_empty(&const self) -> bool { self.count == 0 }\n     }\n \n     pub impl<K:Eq + IterBytes + Hash,V> HashMap_<K, V> {\n-        pure fn contains_key(@self, k: &K) -> bool {\n+        fn contains_key(@self, k: &K) -> bool {\n             let hash = k.hash_keyed(0,0) as uint;\n             match self.search_tbl(k, hash) {\n               NotFound => false,\n@@ -234,23 +234,23 @@ pub mod chained {\n             }\n         }\n \n-        pure fn each(@self, blk: &fn(key: &K, value: &V) -> bool) {\n+        fn each(@self, blk: &fn(key: &K, value: &V) -> bool) {\n             for self.each_entry |entry| {\n                 if !blk(&entry.key, &entry.value) { break; }\n             }\n         }\n \n-        pure fn each_key(@self, blk: &fn(key: &K) -> bool) {\n+        fn each_key(@self, blk: &fn(key: &K) -> bool) {\n             self.each(|k, _v| blk(k))\n         }\n \n-        pure fn each_value(@self, blk: &fn(value: &V) -> bool) {\n+        fn each_value(@self, blk: &fn(value: &V) -> bool) {\n             self.each(|_k, v| blk(v))\n         }\n     }\n \n     pub impl<K:Eq + IterBytes + Hash + Copy,V:Copy> HashMap_<K, V> {\n-        pure fn find(&self, k: &K) -> Option<V> {\n+        fn find(&self, k: &K) -> Option<V> {\n             match self.search_tbl(k, k.hash_keyed(0,0) as uint) {\n               NotFound => None,\n               FoundFirst(_, entry) => Some(entry.value),\n@@ -314,7 +314,7 @@ pub mod chained {\n             return self.update_with_key(key, newval, |_k, v, v1| ff(v,v1));\n         }\n \n-        pure fn get(&self, k: &K) -> V {\n+        fn get(&self, k: &K) -> V {\n             let opt_v = self.find(k);\n             if opt_v.is_none() {\n                 fail!(fmt!(\"Key not found in table: %?\", k));\n@@ -348,7 +348,7 @@ pub mod chained {\n \n     impl<K:Eq + IterBytes + Hash + Copy + ToStr,V:ToStr + Copy> ToStr\n             for HashMap_<K, V> {\n-        pure fn to_str(&self) -> ~str {\n+        fn to_str(&self) -> ~str {\n             unsafe {\n                 // Meh -- this should be safe\n                 do io::with_str_writer |wr| { self.to_writer(wr) }\n@@ -358,7 +358,7 @@ pub mod chained {\n \n     impl<K:Eq + IterBytes + Hash + Copy,V:Copy> ops::Index<K, V>\n             for HashMap_<K, V> {\n-        pure fn index(&self, k: K) -> V {\n+        fn index(&self, k: K) -> V {\n             self.get(&k)\n         }\n     }\n@@ -391,7 +391,7 @@ pub fn set_add<K:Eq + IterBytes + Hash + Const + Copy>(set: Set<K>, key: K)\n }\n \n /// Convert a set into a vector.\n-pub pure fn vec_from_set<T:Eq + IterBytes + Hash + Copy>(s: Set<T>) -> ~[T] {\n+pub fn vec_from_set<T:Eq + IterBytes + Hash + Copy>(s: Set<T>) -> ~[T] {\n     do vec::build_sized(s.len()) |push| {\n         for s.each_key() |&k| {\n             push(k);\n@@ -422,8 +422,8 @@ mod tests {\n     #[test]\n     fn test_simple() {\n         debug!(\"*** starting test_simple\");\n-        pure fn eq_uint(x: &uint, y: &uint) -> bool { *x == *y }\n-        pure fn uint_id(x: &uint) -> uint { *x }\n+        fn eq_uint(x: &uint, y: &uint) -> bool { *x == *y }\n+        fn uint_id(x: &uint) -> uint { *x }\n         debug!(\"uint -> uint\");\n         let hm_uu: HashMap<uint, uint> =\n             HashMap::<uint, uint>();\n@@ -491,8 +491,8 @@ mod tests {\n     fn test_growth() {\n         debug!(\"*** starting test_growth\");\n         let num_to_insert: uint = 64u;\n-        pure fn eq_uint(x: &uint, y: &uint) -> bool { *x == *y }\n-        pure fn uint_id(x: &uint) -> uint { *x }\n+        fn eq_uint(x: &uint, y: &uint) -> bool { *x == *y }\n+        fn uint_id(x: &uint) -> uint { *x }\n         debug!(\"uint -> uint\");\n         let hm_uu: HashMap<uint, uint> =\n             HashMap::<uint, uint>();"}, {"sha": "03d518f1f6300d714c60d1dc843cb75dd6151912", "filename": "src/libstd/priority_queue.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpriority_queue.rs?ref=c1084091d4e5472fac7e158b11120bad6ff210ff", "patch": "@@ -31,16 +31,16 @@ impl<T:Ord> BaseIter<T> for PriorityQueue<T> {\n     /// Visit all values in the underlying vector.\n     ///\n     /// The values are **not** visited in order.\n-    pure fn each(&self, f: &fn(&T) -> bool) { self.data.each(f) }\n-    pure fn size_hint(&self) -> Option<uint> { self.data.size_hint() }\n+    fn each(&self, f: &fn(&T) -> bool) { self.data.each(f) }\n+    fn size_hint(&self) -> Option<uint> { self.data.size_hint() }\n }\n \n impl<T:Ord> Container for PriorityQueue<T> {\n     /// Returns the length of the queue\n-    pure fn len(&const self) -> uint { vec::uniq_len(&const self.data) }\n+    fn len(&const self) -> uint { vec::uniq_len(&const self.data) }\n \n     /// Returns true if a queue contains no elements\n-    pure fn is_empty(&const self) -> bool { self.len() == 0 }\n+    fn is_empty(&const self) -> bool { self.len() == 0 }\n }\n \n impl<T:Ord> Mutable for PriorityQueue<T> {\n@@ -50,15 +50,15 @@ impl<T:Ord> Mutable for PriorityQueue<T> {\n \n pub impl <T:Ord> PriorityQueue<T> {\n     /// Returns the greatest item in the queue - fails if empty\n-    pure fn top(&self) -> &'self T { &self.data[0] }\n+    fn top(&self) -> &'self T { &self.data[0] }\n \n     /// Returns the greatest item in the queue - None if empty\n-    pure fn maybe_top(&self) -> Option<&'self T> {\n+    fn maybe_top(&self) -> Option<&'self T> {\n         if self.is_empty() { None } else { Some(self.top()) }\n     }\n \n     /// Returns the number of elements the queue can hold without reallocating\n-    pure fn capacity(&self) -> uint { vec::capacity(&self.data) }\n+    fn capacity(&self) -> uint { vec::capacity(&self.data) }\n \n     fn reserve(&mut self, n: uint) { vec::reserve(&mut self.data, n) }\n \n@@ -102,11 +102,11 @@ pub impl <T:Ord> PriorityQueue<T> {\n     }\n \n     /// Consume the PriorityQueue and return the underlying vector\n-    pure fn to_vec(self) -> ~[T] { let PriorityQueue{data: v} = self; v }\n+    fn to_vec(self) -> ~[T] { let PriorityQueue{data: v} = self; v }\n \n     /// Consume the PriorityQueue and return a vector in sorted\n     /// (ascending) order\n-    pure fn to_sorted_vec(self) -> ~[T] {\n+    fn to_sorted_vec(self) -> ~[T] {\n         let mut q = self;\n         let mut end = q.len();\n         while end > 1 {\n@@ -118,10 +118,10 @@ pub impl <T:Ord> PriorityQueue<T> {\n     }\n \n     /// Create an empty PriorityQueue\n-    pure fn new() -> PriorityQueue<T> { PriorityQueue{data: ~[],} }\n+    fn new() -> PriorityQueue<T> { PriorityQueue{data: ~[],} }\n \n     /// Create a PriorityQueue from a vector (heapify)\n-    pure fn from_vec(xs: ~[T]) -> PriorityQueue<T> {\n+    fn from_vec(xs: ~[T]) -> PriorityQueue<T> {\n         let mut q = PriorityQueue{data: xs,};\n         let mut n = q.len() / 2;\n         while n > 0 {"}, {"sha": "c9ad762880ca562141ef8310256aad0550996124", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=c1084091d4e5472fac7e158b11120bad6ff210ff", "patch": "@@ -47,7 +47,7 @@ pub type Rope = node::Root;\n  */\n \n /// Create an empty rope\n-pub pure fn empty() -> Rope {\n+pub fn empty() -> Rope {\n    return node::Empty;\n }\n \n@@ -491,7 +491,7 @@ pub mod iterator {\n  *\n  * Constant time.\n  */\n-pub pure fn height(rope: Rope) -> uint {\n+pub fn height(rope: Rope) -> uint {\n    match (rope) {\n       node::Empty      => return 0u,\n       node::Content(x) => return node::height(x)\n@@ -507,7 +507,7 @@ pub pure fn height(rope: Rope) -> uint {\n  *\n  * Constant time.\n  */\n-pub pure fn char_len(rope: Rope) -> uint {\n+pub fn char_len(rope: Rope) -> uint {\n    match (rope) {\n      node::Empty            => return 0u,\n      node::Content(x)       => return node::char_len(x)\n@@ -521,7 +521,7 @@ pub pure fn char_len(rope: Rope) -> uint {\n  *\n  * Constant time.\n  */\n-pub pure fn byte_len(rope: Rope) -> uint {\n+pub fn byte_len(rope: Rope) -> uint {\n    match (rope) {\n      node::Empty            => return 0u,\n      node::Content(x)       => return node::byte_len(x)\n@@ -761,15 +761,15 @@ pub mod node {\n         }\n     }\n \n-    pub pure fn byte_len(node: @Node) -> uint {\n+    pub fn byte_len(node: @Node) -> uint {\n         //FIXME (#2744): Could we do this without the pattern-matching?\n         match (*node) {\n           Leaf(y) => y.byte_len,\n           Concat(ref y) => y.byte_len\n         }\n     }\n \n-    pub pure fn char_len(node: @Node) -> uint {\n+    pub fn char_len(node: @Node) -> uint {\n         match (*node) {\n           Leaf(y) => y.char_len,\n           Concat(ref y) => y.char_len\n@@ -1050,7 +1050,7 @@ pub mod node {\n         })\n     }\n \n-    pub pure fn height(node: @Node) -> uint {\n+    pub fn height(node: @Node) -> uint {\n         match (*node) {\n           Leaf(_) => 0u,\n           Concat(ref x) => x.height,\n@@ -1131,7 +1131,7 @@ pub mod node {\n      * proportional to the height of the rope + the (bounded)\n      * length of the largest leaf.\n      */\n-    pub pure fn char_at(node: @Node, pos: uint) -> char {\n+    pub fn char_at(node: @Node, pos: uint) -> char {\n         let mut node    = node;\n         let mut pos     = pos;\n         loop {"}, {"sha": "50579db47072b2edb2e7572f3bb1eeb12b0f8c09", "filename": "src/libstd/semver.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Fsemver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Fsemver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsemver.rs?ref=c1084091d4e5472fac7e158b11120bad6ff210ff", "patch": "@@ -27,7 +27,7 @@ pub enum Identifier {\n \n impl cmp::Ord for Identifier {\n     #[inline(always)]\n-    pure fn lt(&self, other: &Identifier) -> bool {\n+    fn lt(&self, other: &Identifier) -> bool {\n         match (self, other) {\n             (&Numeric(a), &Numeric(b)) => a < b,\n             (&Numeric(_), _) => true,\n@@ -36,22 +36,22 @@ impl cmp::Ord for Identifier {\n         }\n     }\n     #[inline(always)]\n-    pure fn le(&self, other: &Identifier) -> bool {\n+    fn le(&self, other: &Identifier) -> bool {\n         ! (other < self)\n     }\n     #[inline(always)]\n-    pure fn gt(&self, other: &Identifier) -> bool {\n+    fn gt(&self, other: &Identifier) -> bool {\n         other < self\n     }\n     #[inline(always)]\n-    pure fn ge(&self, other: &Identifier) -> bool {\n+    fn ge(&self, other: &Identifier) -> bool {\n         ! (self < other)\n     }\n }\n \n impl ToStr for Identifier {\n     #[inline(always)]\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         match self {\n             &Numeric(n) => n.to_str(),\n             &AlphaNumeric(ref s) => s.to_str()\n@@ -71,7 +71,7 @@ pub struct Version {\n \n impl ToStr for Version {\n     #[inline(always)]\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         let s = fmt!(\"%u.%u.%u\", self.major, self.minor, self.patch);\n         let s = if self.pre.is_empty() {\n             s\n@@ -88,7 +88,7 @@ impl ToStr for Version {\n \n impl cmp::Ord for Version {\n     #[inline(always)]\n-    pure fn lt(&self, other: &Version) -> bool {\n+    fn lt(&self, other: &Version) -> bool {\n \n         self.major < other.major ||\n \n@@ -121,15 +121,15 @@ impl cmp::Ord for Version {\n     }\n \n     #[inline(always)]\n-    pure fn le(&self, other: &Version) -> bool {\n+    fn le(&self, other: &Version) -> bool {\n         ! (other < self)\n     }\n     #[inline(always)]\n-    pure fn gt(&self, other: &Version) -> bool {\n+    fn gt(&self, other: &Version) -> bool {\n         other < self\n     }\n     #[inline(always)]\n-    pure fn ge(&self, other: &Version) -> bool {\n+    fn ge(&self, other: &Version) -> bool {\n         ! (self < other)\n     }\n }"}, {"sha": "a559e7540d4146ce62cfcb39133f5d5b07143ab4", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=c1084091d4e5472fac7e158b11120bad6ff210ff", "patch": "@@ -24,7 +24,7 @@ pub struct SmallIntMap<T> {\n \n impl<V> BaseIter<(uint, &'self V)> for SmallIntMap<V> {\n     /// Visit all key-value pairs in order\n-    pure fn each(&self, it: &fn(&(uint, &'self V)) -> bool) {\n+    fn each(&self, it: &fn(&(uint, &'self V)) -> bool) {\n         for uint::range(0, self.v.len()) |i| {\n             match self.v[i] {\n               Some(ref elt) => if !it(&(i, elt)) { break },\n@@ -33,12 +33,12 @@ impl<V> BaseIter<(uint, &'self V)> for SmallIntMap<V> {\n         }\n     }\n \n-    pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n impl<V> ReverseIter<(uint, &'self V)> for SmallIntMap<V> {\n     /// Visit all key-value pairs in reverse order\n-    pure fn each_reverse(&self, it: &fn(&(uint, &'self V)) -> bool) {\n+    fn each_reverse(&self, it: &fn(&(uint, &'self V)) -> bool) {\n         for uint::range_rev(self.v.len(), 0) |i| {\n             match self.v[i - 1] {\n               Some(ref elt) => if !it(&(i - 1, elt)) { break },\n@@ -50,7 +50,7 @@ impl<V> ReverseIter<(uint, &'self V)> for SmallIntMap<V> {\n \n impl<V> Container for SmallIntMap<V> {\n     /// Return the number of elements in the map\n-    pure fn len(&const self) -> uint {\n+    fn len(&const self) -> uint {\n         let mut sz = 0;\n         for uint::range(0, vec::uniq_len(&const self.v)) |i| {\n             match self.v[i] {\n@@ -62,7 +62,7 @@ impl<V> Container for SmallIntMap<V> {\n     }\n \n     /// Return true if the map contains no elements\n-    pure fn is_empty(&const self) -> bool { self.len() == 0 }\n+    fn is_empty(&const self) -> bool { self.len() == 0 }\n }\n \n impl<V> Mutable for SmallIntMap<V> {\n@@ -72,17 +72,17 @@ impl<V> Mutable for SmallIntMap<V> {\n \n impl<V> Map<uint, V> for SmallIntMap<V> {\n     /// Return true if the map contains a value for the specified key\n-    pure fn contains_key(&self, key: &uint) -> bool {\n+    fn contains_key(&self, key: &uint) -> bool {\n         self.find(key).is_some()\n     }\n \n     /// Visit all keys in order\n-    pure fn each_key(&self, blk: &fn(key: &uint) -> bool) {\n+    fn each_key(&self, blk: &fn(key: &uint) -> bool) {\n         self.each(|&(k, _)| blk(&k))\n     }\n \n     /// Visit all values in order\n-    pure fn each_value(&self, blk: &fn(value: &V) -> bool) {\n+    fn each_value(&self, blk: &fn(value: &V) -> bool) {\n         self.each(|&(_, v)| blk(v))\n     }\n \n@@ -97,7 +97,7 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n     }\n \n     /// Iterate over the map and mutate the contained values\n-    pure fn find(&self, key: &uint) -> Option<&'self V> {\n+    fn find(&self, key: &uint) -> Option<&'self V> {\n         if *key < self.v.len() {\n             match self.v[*key] {\n               Some(ref value) => Some(value),\n@@ -135,9 +135,9 @@ impl<V> Map<uint, V> for SmallIntMap<V> {\n \n pub impl<V> SmallIntMap<V> {\n     /// Create an empty SmallIntMap\n-    pure fn new() -> SmallIntMap<V> { SmallIntMap{v: ~[]} }\n+    fn new() -> SmallIntMap<V> { SmallIntMap{v: ~[]} }\n \n-    pure fn get(&self, key: &uint) -> &'self V {\n+    fn get(&self, key: &uint) -> &'self V {\n         self.find(key).expect(\"key not present\")\n     }\n }"}, {"sha": "8ab2c40116ad7b1b0d108c8e55ea465355a24022", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=c1084091d4e5472fac7e158b11120bad6ff210ff", "patch": "@@ -16,15 +16,15 @@ use core::util;\n use core::vec::{len, push};\n use core::vec;\n \n-type Le<T> = &'self pure fn(v1: &T, v2: &T) -> bool;\n+type Le<T> = &'self fn(v1: &T, v2: &T) -> bool;\n \n /**\n  * Merge sort. Returns a new vector containing the sorted list.\n  *\n  * Has worst case O(n log n) performance, best case O(n), but\n  * is not space efficient. This is a stable sort.\n  */\n-pub pure fn merge_sort<T:Copy>(v: &[const T], le: Le<T>) -> ~[T] {\n+pub fn merge_sort<T:Copy>(v: &[const T], le: Le<T>) -> ~[T] {\n     type Slice = (uint, uint);\n \n     unsafe {return merge_sort_(v, (0u, len(v)), le);}\n@@ -259,7 +259,7 @@ fn reverse_slice<T>(v: &mut [T], start: uint, end:uint) {\n     }\n }\n \n-pure fn min_run_length(n: uint) -> uint {\n+fn min_run_length(n: uint) -> uint {\n     let mut n = n;\n     let mut r = 0;   // becomes 1 if any 1 bits are shifted off\n \n@@ -290,7 +290,7 @@ fn count_run_ascending<T:Copy + Ord>(array: &mut [T]) -> uint {\n     return run;\n }\n \n-pure fn gallop_left<T:Copy + Ord>(key: &const T, array: &[const T],\n+fn gallop_left<T:Copy + Ord>(key: &const T, array: &[const T],\n                             hint: uint) -> uint {\n     let size = array.len();\n     fail_unless!(size != 0 && hint < size);\n@@ -339,7 +339,7 @@ pure fn gallop_left<T:Copy + Ord>(key: &const T, array: &[const T],\n     return ofs;\n }\n \n-pure fn gallop_right<T:Copy + Ord>(key: &const T, array: &[const T],\n+fn gallop_right<T:Copy + Ord>(key: &const T, array: &[const T],\n                             hint: uint) -> uint {\n     let size = array.len();\n     fail_unless!(size != 0 && hint < size);\n@@ -779,7 +779,7 @@ mod test_qsort {\n \n     pub fn check_sort(v1: &mut [int], v2: &mut [int]) {\n         let len = vec::len::<int>(v1);\n-        pure fn leual(a: &int, b: &int) -> bool { *a <= *b }\n+        fn leual(a: &int, b: &int) -> bool { *a <= *b }\n         quick_sort::<int>(v1, leual);\n         let mut i = 0u;\n         while i < len {\n@@ -844,7 +844,7 @@ mod tests {\n \n     pub fn check_sort(v1: &[int], v2: &[int]) {\n         let len = vec::len::<int>(v1);\n-        pub pure fn le(a: &int, b: &int) -> bool { *a <= *b }\n+        pub fn le(a: &int, b: &int) -> bool { *a <= *b }\n         let f = le;\n         let v3 = merge_sort::<int>(v1, f);\n         let mut i = 0u;\n@@ -874,7 +874,7 @@ mod tests {\n \n     #[test]\n     pub fn test_merge_sort_mutable() {\n-        pub pure fn le(a: &int, b: &int) -> bool { *a <= *b }\n+        pub fn le(a: &int, b: &int) -> bool { *a <= *b }\n         let mut v1 = ~[3, 2, 1];\n         let v2 = merge_sort(v1, le);\n         fail_unless!(v2 == ~[1, 2, 3]);\n@@ -883,7 +883,7 @@ mod tests {\n     #[test]\n     pub fn test_merge_sort_stability() {\n         // tjc: funny that we have to use parens\n-        pure fn ile(x: &(&'static str), y: &(&'static str)) -> bool\n+        fn ile(x: &(&'static str), y: &(&'static str)) -> bool\n         {\n             unsafe // to_lower is not pure...\n             {\n@@ -917,16 +917,16 @@ mod test_tim_sort {\n     }\n \n     impl Ord for CVal {\n-        pure fn lt(&self, other: &CVal) -> bool {\n+        fn lt(&self, other: &CVal) -> bool {\n             unsafe {\n                 let rng = rand::Rng();\n                 if rng.gen_float() > 0.995 { fail!(~\"It's happening!!!\"); }\n             }\n             (*self).val < other.val\n         }\n-        pure fn le(&self, other: &CVal) -> bool { (*self).val <= other.val }\n-        pure fn gt(&self, other: &CVal) -> bool { (*self).val > other.val }\n-        pure fn ge(&self, other: &CVal) -> bool { (*self).val >= other.val }\n+        fn le(&self, other: &CVal) -> bool { (*self).val <= other.val }\n+        fn gt(&self, other: &CVal) -> bool { (*self).val > other.val }\n+        fn ge(&self, other: &CVal) -> bool { (*self).val >= other.val }\n     }\n \n     fn check_sort(v1: &mut [int], v2: &mut [int]) {\n@@ -982,10 +982,10 @@ mod test_tim_sort {\n     struct DVal { val: uint }\n \n     impl Ord for DVal {\n-        pure fn lt(&self, _x: &DVal) -> bool { true }\n-        pure fn le(&self, _x: &DVal) -> bool { true }\n-        pure fn gt(&self, _x: &DVal) -> bool { true }\n-        pure fn ge(&self, _x: &DVal) -> bool { true }\n+        fn lt(&self, _x: &DVal) -> bool { true }\n+        fn le(&self, _x: &DVal) -> bool { true }\n+        fn gt(&self, _x: &DVal) -> bool { true }\n+        fn ge(&self, _x: &DVal) -> bool { true }\n     }\n \n     #[test]\n@@ -1206,16 +1206,16 @@ mod big_tests {\n     }\n \n     impl Ord for LVal/&self {\n-        pure fn lt(&self, other: &'a LVal/&self) -> bool {\n+        fn lt(&self, other: &'a LVal/&self) -> bool {\n             (*self).val < other.val\n         }\n-        pure fn le(&self, other: &'a LVal/&self) -> bool {\n+        fn le(&self, other: &'a LVal/&self) -> bool {\n             (*self).val <= other.val\n         }\n-        pure fn gt(&self, other: &'a LVal/&self) -> bool {\n+        fn gt(&self, other: &'a LVal/&self) -> bool {\n             (*self).val > other.val\n         }\n-        pure fn ge(&self, other: &'a LVal/&self) -> bool {\n+        fn ge(&self, other: &'a LVal/&self) -> bool {\n             (*self).val >= other.val\n         }\n     }"}, {"sha": "7531992ae848546883eee3966f6c69f6d9a2a2b4", "filename": "src/libstd/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=c1084091d4e5472fac7e158b11120bad6ff210ff", "patch": "@@ -53,7 +53,7 @@ pub enum TestName {\n     DynTestName(~str)\n }\n impl ToStr for TestName {\n-    pure fn to_str(&self) -> ~str {\n+    fn to_str(&self) -> ~str {\n         match self {\n             &StaticTestName(s) => s.to_str(),\n             &DynTestName(s) => s.to_str()\n@@ -536,7 +536,7 @@ pub fn filter_tests(\n     };\n \n     // Sort the tests alphabetically\n-    pure fn lteq(t1: &TestDescAndFn, t2: &TestDescAndFn) -> bool {\n+    fn lteq(t1: &TestDescAndFn, t2: &TestDescAndFn) -> bool {\n         str::le(t1.desc.name.to_str(), t2.desc.name.to_str())\n     }\n     sort::quick_sort(filtered, lteq);"}, {"sha": "b46d58f891b6cbf51f9c99e2d71b5c6fde8a3445", "filename": "src/libstd/time.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=c1084091d4e5472fac7e158b11120bad6ff210ff", "patch": "@@ -51,27 +51,27 @@ pub struct Timespec { sec: i64, nsec: i32 }\n  * nsec: 800_000_000_i32 }`.\n  */\n pub impl Timespec {\n-    pure fn new(sec: i64, nsec: i32) -> Timespec {\n+    fn new(sec: i64, nsec: i32) -> Timespec {\n         fail_unless!(nsec >= 0 && nsec < NSEC_PER_SEC);\n         Timespec { sec: sec, nsec: nsec }\n     }\n }\n \n impl Eq for Timespec {\n-    pure fn eq(&self, other: &Timespec) -> bool {\n+    fn eq(&self, other: &Timespec) -> bool {\n         self.sec == other.sec && self.nsec == other.nsec\n     }\n-    pure fn ne(&self, other: &Timespec) -> bool { !self.eq(other) }\n+    fn ne(&self, other: &Timespec) -> bool { !self.eq(other) }\n }\n \n impl Ord for Timespec {\n-    pure fn lt(&self, other: &Timespec) -> bool {\n+    fn lt(&self, other: &Timespec) -> bool {\n         self.sec < other.sec ||\n             (self.sec == other.sec && self.nsec < other.nsec)\n     }\n-    pure fn le(&self, other: &Timespec) -> bool { !other.lt(self) }\n-    pure fn ge(&self, other: &Timespec) -> bool { !self.lt(other) }\n-    pure fn gt(&self, other: &Timespec) -> bool { !self.le(other) }\n+    fn le(&self, other: &Timespec) -> bool { !other.lt(self) }\n+    fn ge(&self, other: &Timespec) -> bool { !self.lt(other) }\n+    fn gt(&self, other: &Timespec) -> bool { !self.le(other) }\n }\n \n /**\n@@ -133,7 +133,7 @@ pub struct Tm {\n }\n \n impl Eq for Tm {\n-    pure fn eq(&self, other: &Tm) -> bool {\n+    fn eq(&self, other: &Tm) -> bool {\n         self.tm_sec == (*other).tm_sec &&\n         self.tm_min == (*other).tm_min &&\n         self.tm_hour == (*other).tm_hour &&\n@@ -147,10 +147,10 @@ impl Eq for Tm {\n         self.tm_zone == (*other).tm_zone &&\n         self.tm_nsec == (*other).tm_nsec\n     }\n-    pure fn ne(&self, other: &Tm) -> bool { !self.eq(other) }\n+    fn ne(&self, other: &Tm) -> bool { !self.eq(other) }\n }\n \n-pub pure fn empty_tm() -> Tm {\n+pub fn empty_tm() -> Tm {\n     Tm {\n         tm_sec: 0_i32,\n         tm_min: 0_i32,\n@@ -198,14 +198,14 @@ pub fn now() -> Tm {\n }\n \n /// Parses the time from the string according to the format string.\n-pub pure fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n+pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n     // unsafe only because do_strptime is annoying to make pure\n     // (it does IO with a str_reader)\n     unsafe {do_strptime(s, format)}\n }\n \n /// Formats the time according to the format string.\n-pub pure fn strftime(format: &str, tm: &Tm) -> ~str {\n+pub fn strftime(format: &str, tm: &Tm) -> ~str {\n     // unsafe only because do_strftime is annoying to make pure\n     // (it does IO with a str_reader)\n     unsafe { do_strftime(format, tm) }\n@@ -239,10 +239,10 @@ pub impl Tm {\n      * Return a string of the current time in the form\n      * \"Thu Jan  1 00:00:00 1970\".\n      */\n-    pure fn ctime(&self) -> ~str { self.strftime(~\"%c\") }\n+    fn ctime(&self) -> ~str { self.strftime(~\"%c\") }\n \n     /// Formats the time according to the format string.\n-    pure fn strftime(&self, format: &str) -> ~str {\n+    fn strftime(&self, format: &str) -> ~str {\n         strftime(format, self)\n     }\n \n@@ -252,7 +252,7 @@ pub impl Tm {\n      * local: \"Thu, 22 Mar 2012 07:53:18 PST\"\n      * utc:   \"Thu, 22 Mar 2012 14:53:18 UTC\"\n      */\n-    pure fn rfc822(&self) -> ~str {\n+    fn rfc822(&self) -> ~str {\n         if self.tm_gmtoff == 0_i32 {\n             self.strftime(~\"%a, %d %b %Y %T GMT\")\n         } else {\n@@ -266,7 +266,7 @@ pub impl Tm {\n      * local: \"Thu, 22 Mar 2012 07:53:18 -0700\"\n      * utc:   \"Thu, 22 Mar 2012 14:53:18 -0000\"\n      */\n-    pure fn rfc822z(&self) -> ~str {\n+    fn rfc822z(&self) -> ~str {\n         self.strftime(~\"%a, %d %b %Y %T %z\")\n     }\n \n@@ -276,7 +276,7 @@ pub impl Tm {\n      * local: \"2012-02-22T07:53:18-07:00\"\n      * utc:   \"2012-02-22T14:53:18Z\"\n      */\n-    pure fn rfc3339(&self) -> ~str {\n+    fn rfc3339(&self) -> ~str {\n         if self.tm_gmtoff == 0_i32 {\n             self.strftime(~\"%Y-%m-%dT%H:%M:%SZ\")\n         } else {"}, {"sha": "e42c65907244122ab887dbb42a1a4ffe8520da55", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=c1084091d4e5472fac7e158b11120bad6ff210ff", "patch": "@@ -36,7 +36,7 @@ pub struct TreeMap<K, V> {\n }\n \n impl<K: Eq + TotalOrd, V: Eq> Eq for TreeMap<K, V> {\n-    pure fn eq(&self, other: &TreeMap<K, V>) -> bool {\n+    fn eq(&self, other: &TreeMap<K, V>) -> bool {\n         if self.len() != other.len() {\n             false\n         } else {\n@@ -53,11 +53,11 @@ impl<K: Eq + TotalOrd, V: Eq> Eq for TreeMap<K, V> {\n             true\n         }\n     }\n-    pure fn ne(&self, other: &TreeMap<K, V>) -> bool { !self.eq(other) }\n+    fn ne(&self, other: &TreeMap<K, V>) -> bool { !self.eq(other) }\n }\n \n // Lexicographical comparison\n-pure fn lt<K: Ord + TotalOrd, V>(a: &TreeMap<K, V>,\n+fn lt<K: Ord + TotalOrd, V>(a: &TreeMap<K, V>,\n                                  b: &TreeMap<K, V>) -> bool {\n     let mut x = a.iter();\n     let mut y = b.iter();\n@@ -77,39 +77,39 @@ pure fn lt<K: Ord + TotalOrd, V>(a: &TreeMap<K, V>,\n \n impl<K: Ord + TotalOrd, V> Ord for TreeMap<K, V> {\n     #[inline(always)]\n-    pure fn lt(&self, other: &TreeMap<K, V>) -> bool { lt(self, other) }\n+    fn lt(&self, other: &TreeMap<K, V>) -> bool { lt(self, other) }\n     #[inline(always)]\n-    pure fn le(&self, other: &TreeMap<K, V>) -> bool { !lt(other, self) }\n+    fn le(&self, other: &TreeMap<K, V>) -> bool { !lt(other, self) }\n     #[inline(always)]\n-    pure fn ge(&self, other: &TreeMap<K, V>) -> bool { !lt(self, other) }\n+    fn ge(&self, other: &TreeMap<K, V>) -> bool { !lt(self, other) }\n     #[inline(always)]\n-    pure fn gt(&self, other: &TreeMap<K, V>) -> bool { lt(other, self) }\n+    fn gt(&self, other: &TreeMap<K, V>) -> bool { lt(other, self) }\n }\n \n impl<'self, K: TotalOrd, V> BaseIter<(&'self K, &'self V)> for TreeMap<K, V> {\n     /// Visit all key-value pairs in order\n-    pure fn each(&self, f: &fn(&(&'self K, &'self V)) -> bool) {\n+    fn each(&self, f: &fn(&(&'self K, &'self V)) -> bool) {\n         each(&self.root, f)\n     }\n-    pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n impl<'self, K: TotalOrd, V>\n     ReverseIter<(&'self K, &'self V)>\n     for TreeMap<K, V>\n {\n     /// Visit all key-value pairs in reverse order\n-    pure fn each_reverse(&self, f: &fn(&(&'self K, &'self V)) -> bool) {\n+    fn each_reverse(&self, f: &fn(&(&'self K, &'self V)) -> bool) {\n         each_reverse(&self.root, f);\n     }\n }\n \n impl<K: TotalOrd, V> Container for TreeMap<K, V> {\n     /// Return the number of elements in the map\n-    pure fn len(&const self) -> uint { self.length }\n+    fn len(&const self) -> uint { self.length }\n \n     /// Return true if the map contains no elements\n-    pure fn is_empty(&const self) -> bool { self.root.is_none() }\n+    fn is_empty(&const self) -> bool { self.root.is_none() }\n }\n \n impl<K: TotalOrd, V> Mutable for TreeMap<K, V> {\n@@ -122,15 +122,15 @@ impl<K: TotalOrd, V> Mutable for TreeMap<K, V> {\n \n impl<K: TotalOrd, V> Map<K, V> for TreeMap<K, V> {\n     /// Return true if the map contains a value for the specified key\n-    pure fn contains_key(&self, key: &K) -> bool {\n+    fn contains_key(&self, key: &K) -> bool {\n         self.find(key).is_some()\n     }\n \n     /// Visit all keys in order\n-    pure fn each_key(&self, f: &fn(&K) -> bool) { self.each(|&(k, _)| f(k)) }\n+    fn each_key(&self, f: &fn(&K) -> bool) { self.each(|&(k, _)| f(k)) }\n \n     /// Visit all values in order\n-    pure fn each_value(&self, f: &fn(&V) -> bool) {\n+    fn each_value(&self, f: &fn(&V) -> bool) {\n         self.each(|&(_, v)| f(v))\n     }\n \n@@ -140,7 +140,7 @@ impl<K: TotalOrd, V> Map<K, V> for TreeMap<K, V> {\n     }\n \n     /// Return the value corresponding to the key in the map\n-    pure fn find(&self, key: &K) -> Option<&'self V> {\n+    fn find(&self, key: &K) -> Option<&'self V> {\n         let mut current: &'self Option<~TreeNode<K, V>> = &self.root;\n         loop {\n             match *current {\n@@ -176,21 +176,21 @@ impl<K: TotalOrd, V> Map<K, V> for TreeMap<K, V> {\n \n pub impl<K: TotalOrd, V> TreeMap<K, V> {\n     /// Create an empty TreeMap\n-    pure fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n+    fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n \n     /// Visit all keys in reverse order\n-    pure fn each_key_reverse(&self, f: &fn(&K) -> bool) {\n+    fn each_key_reverse(&self, f: &fn(&K) -> bool) {\n         self.each_reverse(|&(k, _)| f(k))\n     }\n \n     /// Visit all values in reverse order\n-    pure fn each_value_reverse(&self, f: &fn(&V) -> bool) {\n+    fn each_value_reverse(&self, f: &fn(&V) -> bool) {\n         self.each_reverse(|&(_, v)| f(v))\n     }\n \n     /// Get a lazy iterator over the key-value pairs in the map.\n     /// Requires that it be frozen (immutable).\n-    pure fn iter(&self) -> TreeMapIterator/&self<K, V> {\n+    fn iter(&self) -> TreeMapIterator/&self<K, V> {\n         TreeMapIterator{stack: ~[], node: &self.root}\n     }\n }\n@@ -242,45 +242,45 @@ pub struct TreeSet<T> {\n impl<T: TotalOrd> BaseIter<T> for TreeSet<T> {\n     /// Visit all values in order\n     #[inline(always)]\n-    pure fn each(&self, f: &fn(&T) -> bool) { self.map.each_key(f) }\n+    fn each(&self, f: &fn(&T) -> bool) { self.map.each_key(f) }\n     #[inline(always)]\n-    pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n impl<T: TotalOrd> ReverseIter<T> for TreeSet<T> {\n     /// Visit all values in reverse order\n     #[inline(always)]\n-    pure fn each_reverse(&self, f: &fn(&T) -> bool) {\n+    fn each_reverse(&self, f: &fn(&T) -> bool) {\n         self.map.each_key_reverse(f)\n     }\n }\n \n impl<T: Eq + TotalOrd> Eq for TreeSet<T> {\n     #[inline(always)]\n-    pure fn eq(&self, other: &TreeSet<T>) -> bool { self.map == other.map }\n+    fn eq(&self, other: &TreeSet<T>) -> bool { self.map == other.map }\n     #[inline(always)]\n-    pure fn ne(&self, other: &TreeSet<T>) -> bool { self.map != other.map }\n+    fn ne(&self, other: &TreeSet<T>) -> bool { self.map != other.map }\n }\n \n impl<T: Ord + TotalOrd> Ord for TreeSet<T> {\n     #[inline(always)]\n-    pure fn lt(&self, other: &TreeSet<T>) -> bool { self.map < other.map }\n+    fn lt(&self, other: &TreeSet<T>) -> bool { self.map < other.map }\n     #[inline(always)]\n-    pure fn le(&self, other: &TreeSet<T>) -> bool { self.map <= other.map }\n+    fn le(&self, other: &TreeSet<T>) -> bool { self.map <= other.map }\n     #[inline(always)]\n-    pure fn ge(&self, other: &TreeSet<T>) -> bool { self.map >= other.map }\n+    fn ge(&self, other: &TreeSet<T>) -> bool { self.map >= other.map }\n     #[inline(always)]\n-    pure fn gt(&self, other: &TreeSet<T>) -> bool { self.map > other.map }\n+    fn gt(&self, other: &TreeSet<T>) -> bool { self.map > other.map }\n }\n \n impl<T: TotalOrd> Container for TreeSet<T> {\n     /// Return the number of elements in the set\n     #[inline(always)]\n-    pure fn len(&const self) -> uint { self.map.len() }\n+    fn len(&const self) -> uint { self.map.len() }\n \n     /// Return true if the set contains no elements\n     #[inline(always)]\n-    pure fn is_empty(&const self) -> bool { self.map.is_empty() }\n+    fn is_empty(&const self) -> bool { self.map.is_empty() }\n }\n \n impl<T: TotalOrd> Mutable for TreeSet<T> {\n@@ -292,7 +292,7 @@ impl<T: TotalOrd> Mutable for TreeSet<T> {\n impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     /// Return true if the set contains a value\n     #[inline(always)]\n-    pure fn contains(&self, value: &T) -> bool {\n+    fn contains(&self, value: &T) -> bool {\n         self.map.contains_key(value)\n     }\n \n@@ -308,7 +308,7 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n \n     /// Return true if the set has no elements in common with `other`.\n     /// This is equivalent to checking for an empty intersection.\n-    pure fn is_disjoint(&self, other: &TreeSet<T>) -> bool {\n+    fn is_disjoint(&self, other: &TreeSet<T>) -> bool {\n         let mut x = self.iter();\n         let mut y = other.iter();\n         unsafe { // purity workaround\n@@ -329,12 +329,12 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n \n     /// Return true if the set is a subset of another\n     #[inline(always)]\n-    pure fn is_subset(&self, other: &TreeSet<T>) -> bool {\n+    fn is_subset(&self, other: &TreeSet<T>) -> bool {\n         other.is_superset(self)\n     }\n \n     /// Return true if the set is a superset of another\n-    pure fn is_superset(&self, other: &TreeSet<T>) -> bool {\n+    fn is_superset(&self, other: &TreeSet<T>) -> bool {\n         let mut x = self.iter();\n         let mut y = other.iter();\n         unsafe { // purity workaround\n@@ -361,7 +361,7 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     }\n \n     /// Visit the values (in-order) representing the difference\n-    pure fn difference(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) {\n+    fn difference(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) {\n         let mut x = self.iter();\n         let mut y = other.iter();\n \n@@ -393,7 +393,7 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     }\n \n     /// Visit the values (in-order) representing the symmetric difference\n-    pure fn symmetric_difference(&self, other: &TreeSet<T>,\n+    fn symmetric_difference(&self, other: &TreeSet<T>,\n                                  f: &fn(&T) -> bool) {\n         let mut x = self.iter();\n         let mut y = other.iter();\n@@ -433,7 +433,7 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     }\n \n     /// Visit the values (in-order) representing the intersection\n-    pure fn intersection(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) {\n+    fn intersection(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) {\n         let mut x = self.iter();\n         let mut y = other.iter();\n \n@@ -460,7 +460,7 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     }\n \n     /// Visit the values (in-order) representing the union\n-    pure fn union(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) {\n+    fn union(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) {\n         let mut x = self.iter();\n         let mut y = other.iter();\n \n@@ -501,12 +501,12 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n pub impl <T: TotalOrd> TreeSet<T> {\n     /// Create an empty TreeSet\n     #[inline(always)]\n-    pure fn new() -> TreeSet<T> { TreeSet{map: TreeMap::new()} }\n+    fn new() -> TreeSet<T> { TreeSet{map: TreeMap::new()} }\n \n     /// Get a lazy iterator over the values in the set.\n     /// Requires that it be frozen (immutable).\n     #[inline(always)]\n-    pure fn iter(&self) -> TreeSetIterator/&self<T> {\n+    fn iter(&self) -> TreeSetIterator/&self<T> {\n         TreeSetIterator{iter: self.map.iter()}\n     }\n }\n@@ -542,20 +542,20 @@ struct TreeNode<K, V> {\n \n pub impl<K: TotalOrd, V> TreeNode<K, V> {\n     #[inline(always)]\n-    pure fn new(key: K, value: V) -> TreeNode<K, V> {\n+    fn new(key: K, value: V) -> TreeNode<K, V> {\n         TreeNode{key: key, value: value, left: None, right: None, level: 1}\n     }\n }\n \n-pure fn each<K: TotalOrd, V>(node: &'r Option<~TreeNode<K, V>>,\n+fn each<K: TotalOrd, V>(node: &'r Option<~TreeNode<K, V>>,\n                              f: &fn(&(&'r K, &'r V)) -> bool) {\n     for node.each |x| {\n         each(&x.left, f);\n         if f(&(&x.key, &x.value)) { each(&x.right, f) }\n     }\n }\n \n-pure fn each_reverse<K: TotalOrd, V>(node: &'r Option<~TreeNode<K, V>>,\n+fn each_reverse<K: TotalOrd, V>(node: &'r Option<~TreeNode<K, V>>,\n                                      f: &fn(&(&'r K, &'r V)) -> bool) {\n     for node.each |x| {\n         each_reverse(&x.right, f);"}, {"sha": "f22bdaff3a0fcd1070f11aa703aadbdcf25c1d01", "filename": "src/libstd/unicode.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funicode.rs?ref=c1084091d4e5472fac7e158b11120bad6ff210ff", "patch": "@@ -173,12 +173,12 @@ pub mod icu {\n     }\n }\n \n-pub pure fn is_XID_start(c: char) -> bool {\n+pub fn is_XID_start(c: char) -> bool {\n     return icu::libicu::u_hasBinaryProperty(c, icu::UCHAR_XID_START)\n         == icu::TRUE;\n }\n \n-pub pure fn is_XID_continue(c: char) -> bool {\n+pub fn is_XID_continue(c: char) -> bool {\n     return icu::libicu::u_hasBinaryProperty(c, icu::UCHAR_XID_START)\n         == icu::TRUE;\n }\n@@ -188,7 +188,7 @@ Function: is_digit\n \n Returns true if a character is a digit.\n */\n-pub pure fn is_digit(c: char) -> bool {\n+pub fn is_digit(c: char) -> bool {\n     return icu::libicu::u_isdigit(c) == icu::TRUE;\n }\n \n@@ -197,7 +197,7 @@ Function: is_lower\n \n Returns true if a character is a lowercase letter.\n */\n-pub pure fn is_lower(c: char) -> bool {\n+pub fn is_lower(c: char) -> bool {\n     return icu::libicu::u_islower(c) == icu::TRUE;\n }\n \n@@ -206,7 +206,7 @@ Function: is_space\n \n Returns true if a character is space.\n */\n-pub pure fn is_space(c: char) -> bool {\n+pub fn is_space(c: char) -> bool {\n     return icu::libicu::u_isspace(c) == icu::TRUE;\n }\n \n@@ -215,7 +215,7 @@ Function: is_upper\n \n Returns true if a character is an uppercase letter.\n */\n-pub pure fn is_upper(c: char) -> bool {\n+pub fn is_upper(c: char) -> bool {\n     return icu::libicu::u_isupper(c) == icu::TRUE;\n }\n "}, {"sha": "b26b4b1c3330b52383af3177fb3da393891dda1e", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1084091d4e5472fac7e158b11120bad6ff210ff/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=c1084091d4e5472fac7e158b11120bad6ff210ff", "patch": "@@ -106,7 +106,7 @@ struct WorkKey {\n \n impl to_bytes::IterBytes for WorkKey {\n     #[inline(always)]\n-    pure fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n+    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) {\n         let mut flag = true;\n         self.kind.iter_bytes(lsb0, |bytes| {flag = f(bytes); flag});\n         if !flag { return; }\n@@ -115,18 +115,18 @@ impl to_bytes::IterBytes for WorkKey {\n }\n \n impl cmp::Ord for WorkKey {\n-    pure fn lt(&self, other: &WorkKey) -> bool {\n+    fn lt(&self, other: &WorkKey) -> bool {\n         self.kind < other.kind ||\n             (self.kind == other.kind &&\n              self.name < other.name)\n     }\n-    pure fn le(&self, other: &WorkKey) -> bool {\n+    fn le(&self, other: &WorkKey) -> bool {\n         self.lt(other) || self.eq(other)\n     }\n-    pure fn ge(&self, other: &WorkKey) -> bool {\n+    fn ge(&self, other: &WorkKey) -> bool {\n         self.gt(other) || self.eq(other)\n     }\n-    pure fn gt(&self, other: &WorkKey) -> bool {\n+    fn gt(&self, other: &WorkKey) -> bool {\n         ! self.le(other)\n     }\n }"}]}