{"sha": "9f104d4213ae31f4e61b210ef34b223c81c8c3af", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmMTA0ZDQyMTNhZTMxZjRlNjFiMjEwZWYzNGIyMjNjODFjOGMzYWY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-05-12T02:45:13Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-05-14T16:23:46Z"}, "message": "rustpkg: Remove #[allow(vecs_implicitly_copyable)]", "tree": {"sha": "41003e366ad9bebe9a5cca4884b986e7dc63d020", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41003e366ad9bebe9a5cca4884b986e7dc63d020"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f104d4213ae31f4e61b210ef34b223c81c8c3af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f104d4213ae31f4e61b210ef34b223c81c8c3af", "html_url": "https://github.com/rust-lang/rust/commit/9f104d4213ae31f4e61b210ef34b223c81c8c3af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f104d4213ae31f4e61b210ef34b223c81c8c3af/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "27c228fad7d94a500866696f8c48ef1707a2507b", "url": "https://api.github.com/repos/rust-lang/rust/commits/27c228fad7d94a500866696f8c48ef1707a2507b", "html_url": "https://github.com/rust-lang/rust/commit/27c228fad7d94a500866696f8c48ef1707a2507b"}], "stats": {"total": 203, "additions": 98, "deletions": 105}, "files": [{"sha": "477a7af45504bb7250c5c245dbef35e84c937751", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9f104d4213ae31f4e61b210ef34b223c81c8c3af/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f104d4213ae31f4e61b210ef34b223c81c8c3af/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=9f104d4213ae31f4e61b210ef34b223c81c8c3af", "patch": "@@ -55,21 +55,21 @@ pub fn normalize(p: ~Path) -> ~Path {\n \n /// True if there's a directory in <workspace> with\n /// pkgid's short name\n-pub fn workspace_contains_package_id(pkgid: PkgId, workspace: &Path) -> bool {\n+pub fn workspace_contains_package_id(pkgid: &PkgId, workspace: &Path) -> bool {\n     let pkgpath = workspace.push(\"src\").push(pkgid.path.to_str());\n     os::path_is_dir(&pkgpath)\n }\n \n /// Return the directory for <pkgid>'s source files in <workspace>.\n /// Doesn't check that it exists.\n-pub fn pkgid_src_in_workspace(pkgid: PkgId, workspace: &Path) -> Path {\n+pub fn pkgid_src_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n     let result = workspace.push(\"src\");\n     result.push(pkgid.path.to_str())\n }\n \n /// Figure out what the executable name for <pkgid> in <workspace>'s build\n /// directory is, and if the file exists, return it.\n-pub fn built_executable_in_workspace(pkgid: PkgId, workspace: &Path) -> Option<Path> {\n+pub fn built_executable_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Path> {\n     let mut result = workspace.push(\"build\");\n     result = result.push_rel(&pkgid.path);\n     // should use a target-specific subdirectory\n@@ -87,7 +87,7 @@ pub fn built_executable_in_workspace(pkgid: PkgId, workspace: &Path) -> Option<P\n \n /// Figure out what the library name for <pkgid> in <workspace>'s build\n /// directory is, and if the file exists, return it.\n-pub fn built_library_in_workspace(pkgid: PkgId, workspace: &Path) -> Option<Path> {\n+pub fn built_library_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Path> {\n     let mut result = workspace.push(\"build\");\n     result = result.push_rel(&pkgid.path);\n     // should use a target-specific subdirectory\n@@ -159,31 +159,31 @@ pub fn built_library_in_workspace(pkgid: PkgId, workspace: &Path) -> Option<Path\n /// Returns the executable that would be installed for <pkgid>\n /// in <workspace>\n /// As a side effect, creates the bin-dir if it doesn't exist\n-pub fn target_executable_in_workspace(pkgid: PkgId, workspace: &Path) -> Path {\n+pub fn target_executable_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n     target_file_in_workspace(pkgid, workspace, Main)\n }\n \n \n /// Returns the executable that would be installed for <pkgid>\n /// in <workspace>\n /// As a side effect, creates the bin-dir if it doesn't exist\n-pub fn target_library_in_workspace(pkgid: PkgId, workspace: &Path) -> Path {\n+pub fn target_library_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n     target_file_in_workspace(pkgid, workspace, Lib)\n }\n \n /// Returns the test executable that would be installed for <pkgid>\n /// in <workspace>\n-pub fn target_test_in_workspace(pkgid: PkgId, workspace: &Path) -> Path {\n+pub fn target_test_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n     target_file_in_workspace(pkgid, workspace, Test)\n }\n \n /// Returns the bench executable that would be installed for <pkgid>\n /// in <workspace>\n-pub fn target_bench_in_workspace(pkgid: PkgId, workspace: &Path) -> Path {\n+pub fn target_bench_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n     target_file_in_workspace(pkgid, workspace, Bench)\n }\n \n-fn target_file_in_workspace(pkgid: PkgId, workspace: &Path,\n+fn target_file_in_workspace(pkgid: &PkgId, workspace: &Path,\n                             what: OutputType) -> Path {\n     use conditions::bad_path::cond;\n \n@@ -193,7 +193,8 @@ fn target_file_in_workspace(pkgid: PkgId, workspace: &Path,\n     let result = workspace.push(subdir);\n     if create_dir {\n         if !os::path_exists(&result) && !mkdir_recursive(&result, u_rwx) {\n-            cond.raise((result, fmt!(\"I couldn't create the %s dir\", subdir)));\n+            cond.raise((copy result,\n+                        fmt!(\"I couldn't create the %s dir\", subdir)));\n         }\n     }\n     mk_output_path(what, pkgid.path.to_str(), result)\n@@ -202,13 +203,13 @@ fn target_file_in_workspace(pkgid: PkgId, workspace: &Path,\n \n /// Return the directory for <pkgid>'s build artifacts in <workspace>.\n /// Creates it if it doesn't exist.\n-pub fn build_pkg_id_in_workspace(pkgid: PkgId, workspace: &Path) -> Path {\n+pub fn build_pkg_id_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n     use conditions::bad_path::cond;\n \n     let mut result = workspace.push(\"build\");\n     // n.b. Should actually use a target-specific\n     // subdirectory of build/\n-    result = result.push(normalize(~pkgid.path).to_str());\n+    result = result.push(normalize(~copy pkgid.path).to_str());\n     if os::path_exists(&result) || os::mkdir_recursive(&result, u_rwx) {\n         result\n     }"}, {"sha": "54713a66c0c95085e513d434bae19b17314d6a1c", "filename": "src/librustpkg/rustpkg.rc", "status": "modified", "additions": 40, "deletions": 42, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/9f104d4213ae31f4e61b210ef34b223c81c8c3af/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/9f104d4213ae31f4e61b210ef34b223c81c8c3af/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=9f104d4213ae31f4e61b210ef34b223c81c8c3af", "patch": "@@ -17,8 +17,6 @@\n \n #[license = \"MIT/ASL2\"];\n #[crate_type = \"lib\"];\n-#[allow(vecs_implicitly_copyable,\n-        non_implicitly_copyable_typarams)];\n \n extern mod std(vers = \"0.7-pre\");\n extern mod rustc(vers = \"0.7-pre\");\n@@ -52,9 +50,9 @@ pub mod usage;\n /// A PkgScript represents user-supplied custom logic for\n /// special build hooks. This only exists for packages with\n /// an explicit package script.\n-struct PkgScript {\n+struct PkgScript<'self> {\n     /// Uniquely identifies this package\n-    id: PkgId,\n+    id: &'self PkgId,\n     // Used to have this field:    deps: ~[(~str, Option<~str>)]\n     // but I think it shouldn't be stored here\n     /// The contents of the package script: either a file path,\n@@ -71,24 +69,24 @@ struct PkgScript {\n     build_dir: Path\n }\n \n-impl PkgScript {\n+impl<'self> PkgScript<'self> {\n     /// Given the path name for a package script\n     /// and a package ID, parse the package script into\n     /// a PkgScript that we can then execute\n-    fn parse(script: Path, workspace: &Path, id: PkgId) -> PkgScript {\n+    fn parse<'a>(script: Path, workspace: &Path, id: &'a PkgId) -> PkgScript<'a> {\n         // Get the executable name that was invoked\n-        let binary = os::args()[0];\n+        let binary = @copy os::args()[0];\n         // Build the rustc session data structures to pass\n         // to the compiler\n         let options = @session::options {\n-            binary: @binary,\n+            binary: binary,\n             crate_type: session::bin_crate,\n-            .. *session::basic_options()\n+            .. copy *session::basic_options()\n         };\n         let input = driver::file_input(script);\n         let sess = driver::build_session(options, diagnostic::emit);\n-        let cfg = driver::build_configuration(sess, @binary, &input);\n-        let (crate, _) = driver::compile_upto(sess, cfg, &input,\n+        let cfg = driver::build_configuration(sess, binary, &input);\n+        let (crate, _) = driver::compile_upto(sess, copy cfg, &input,\n                                               driver::cu_parse, None);\n         let work_dir = build_pkg_id_in_workspace(id, workspace);\n \n@@ -123,10 +121,10 @@ impl PkgScript {\n                 let root = r.pop().pop().pop().pop(); // :-\\\n                 debug!(\"Root is %s, calling compile_rest\", root.to_str());\n                 let exe = self.build_dir.push(~\"pkg\" + util::exe_suffix());\n-                util::compile_crate_from_input(self.input, self.id,\n-                                               Some(self.build_dir),\n+                util::compile_crate_from_input(&self.input, self.id,\n+                                               Some(copy self.build_dir),\n                                                sess, Some(crate),\n-                                               exe, os::args()[0],\n+                                               &exe, @copy os::args()[0],\n                                                driver::cu_everything);\n                 debug!(\"Running program: %s %s %s\", exe.to_str(), root.to_str(), what);\n                 let status = run::run_program(exe.to_str(), ~[root.to_str(), what]);\n@@ -188,9 +186,9 @@ impl Ctx {\n                 }\n                 // The package id is presumed to be the first command-line\n                 // argument\n-                let pkgid = PkgId::new(args[0]);\n-                for pkg_parent_workspaces(pkgid) |workspace| {\n-                    self.build(workspace, pkgid);\n+                let pkgid = PkgId::new(copy args[0]);\n+                for pkg_parent_workspaces(&pkgid) |workspace| {\n+                    self.build(workspace, &pkgid);\n                 }\n             }\n             ~\"clean\" => {\n@@ -199,16 +197,16 @@ impl Ctx {\n                 }\n                 // The package id is presumed to be the first command-line\n                 // argument\n-                let pkgid = PkgId::new(args[0]);\n+                let pkgid = PkgId::new(copy args[0]);\n                 let cwd = os::getcwd();\n-                self.clean(&cwd, pkgid); // tjc: should use workspace, not cwd\n+                self.clean(&cwd, &pkgid); // tjc: should use workspace, not cwd\n             }\n             ~\"do\" => {\n                 if args.len() < 2 {\n                     return usage::do_cmd();\n                 }\n \n-                self.do_cmd(args[0], args[1]);\n+                self.do_cmd(copy args[0], copy args[1]);\n             }\n             ~\"info\" => {\n                 self.info();\n@@ -221,16 +219,16 @@ impl Ctx {\n                 // The package id is presumed to be the first command-line\n                 // argument\n                 let pkgid = PkgId::new(args[0]);\n-                for pkg_parent_workspaces(pkgid) |workspace| {\n-                    self.install(workspace, pkgid);\n+                for pkg_parent_workspaces(&pkgid) |workspace| {\n+                    self.install(workspace, &pkgid);\n                 }\n             }\n             ~\"prefer\" => {\n                 if args.len() < 1 {\n                     return usage::uninstall();\n                 }\n \n-                let (name, vers) = sep_name_vers(args[0]);\n+                let (name, vers) = sep_name_vers(copy args[0]);\n \n                 self.prefer(name.get(), vers);\n             }\n@@ -242,7 +240,7 @@ impl Ctx {\n                     return usage::uninstall();\n                 }\n \n-                let (name, vers) = sep_name_vers(args[0]);\n+                let (name, vers) = sep_name_vers(copy args[0]);\n \n                 self.uninstall(name.get(), vers);\n             }\n@@ -251,26 +249,26 @@ impl Ctx {\n                     return usage::uninstall();\n                 }\n \n-                let (name, vers) = sep_name_vers(args[0]);\n+                let (name, vers) = sep_name_vers(copy args[0]);\n \n                 self.unprefer(name.get(), vers);\n             }\n             _ => fail!(\"reached an unhandled command\")\n         }\n     }\n \n-    fn do_cmd(&self, _cmd: ~str, _pkgname: ~str)  {\n+    fn do_cmd(&self, _cmd: &str, _pkgname: &str)  {\n         // stub\n         fail!(\"`do` not yet implemented\");\n     }\n \n-    fn build(&self, workspace: &Path, pkgid: PkgId) {\n+    fn build(&self, workspace: &Path, pkgid: &PkgId) {\n         let src_dir   = pkgid_src_in_workspace(pkgid, workspace);\n         let build_dir = build_pkg_id_in_workspace(pkgid, workspace);\n         debug!(\"Destination dir = %s\", build_dir.to_str());\n \n         // Create the package source\n-        let mut src = PkgSrc::new(&workspace.push(\"src\"), &build_dir, &pkgid);\n+        let mut src = PkgSrc::new(&workspace.push(\"src\"), &build_dir, pkgid);\n         debug!(\"Package src = %?\", src);\n \n         // Is there custom build logic? If so, use it\n@@ -311,7 +309,7 @@ impl Ctx {\n \n     }\n \n-    fn clean(&self, workspace: &Path, id: PkgId)  {\n+    fn clean(&self, workspace: &Path, id: &PkgId)  {\n         // Could also support a custom build hook in the pkg\n         // script for cleaning files rustpkg doesn't know about.\n         // Do something reasonable for now\n@@ -332,7 +330,7 @@ impl Ctx {\n         fail!(\"info not yet implemented\");\n     }\n \n-    fn install(&self, workspace: &Path, id: PkgId)  {\n+    fn install(&self, workspace: &Path, id: &PkgId)  {\n         use conditions::copy_failed::cond;\n \n         // Should use RUST_PATH in the future.\n@@ -348,13 +346,13 @@ impl Ctx {\n         for maybe_executable.each |exec| {\n             debug!(\"Copying: %s -> %s\", exec.to_str(), target_exec.to_str());\n             if !os::copy_file(exec, &target_exec) {\n-                cond.raise((*exec, target_exec));\n+                cond.raise((copy *exec, copy target_exec));\n             }\n         }\n         for maybe_library.each |lib| {\n             debug!(\"Copying: %s -> %s\", lib.to_str(), target_lib.to_str());\n             if !os::copy_file(lib, &target_lib) {\n-                cond.raise((*lib, target_lib));\n+                cond.raise((copy *lib, copy target_lib));\n             }\n         }\n     }\n@@ -387,7 +385,7 @@ impl Ctx {\n         }\n     }\n \n-    fn fetch_git(&self, dir: &Path, url: ~str, target: Option<~str>)  {\n+    fn fetch_git(&self, dir: &Path, url: ~str, mut target: Option<~str>)  {\n         util::note(fmt!(\"fetching from %s using git\", url));\n \n         // Git can't clone into a non-empty directory\n@@ -405,7 +403,7 @@ impl Ctx {\n             do util::temp_change_dir(dir) {\n                 success = run::program_output(~\"git\",\n                                               ~[~\"checkout\",\n-                                                target.get()]).status != 0\n+                                                target.swap_unwrap()]).status != 0\n             }\n \n             if !success {\n@@ -525,7 +523,7 @@ pub struct Listener {\n }\n \n pub fn run(listeners: ~[Listener]) {\n-    let rcmd = os::args()[2];\n+    let rcmd = copy os::args()[2];\n     let mut found = false;\n \n     for listeners.each |listener| {\n@@ -652,12 +650,12 @@ impl PkgSrc {\n         // tjc: Rather than erroring out, need to try downloading the\n         // contents of the path to a local directory (#5679)\n         if !os::path_exists(&dir) {\n-            cond.raise((self.id, ~\"missing package dir\"));\n+            cond.raise((copy self.id, ~\"missing package dir\"));\n         }\n \n         if !os::path_is_dir(&dir) {\n-            cond.raise((self.id, ~\"supplied path for package dir is a \\\n-                                   non-directory\"));\n+            cond.raise((copy self.id, ~\"supplied path for package dir is a \\\n+                                        non-directory\"));\n         }\n \n         dir\n@@ -681,7 +679,7 @@ impl PkgSrc {\n     /// Requires that dashes in p have already been normalized to\n     /// underscores\n     fn stem_matches(&self, p: &Path) -> bool {\n-        let self_id = normalize(~self.id.path).filestem();\n+        let self_id = normalize(~copy self.id.path).filestem();\n         if self_id == p.filestem() {\n             return true;\n         }\n@@ -737,7 +735,7 @@ impl PkgSrc {\n             util::note(~\"Couldn't infer any crates to build.\\n\\\n                          Try naming a crate `main.rs`, `lib.rs`, \\\n                          `test.rs`, or `bench.rs`.\");\n-            cond.raise(self.id);\n+            cond.raise(copy self.id);\n         }\n \n         debug!(\"found %u libs, %u mains, %u tests, %u benchs\",\n@@ -752,15 +750,15 @@ impl PkgSrc {\n                     dst_dir: &Path,\n                     src_dir: &Path,\n                     crates: &[Crate],\n-                    cfgs: ~[~str],\n+                    cfgs: &[~str],\n                     test: bool, crate_type: crate_type) {\n \n         for crates.each |&crate| {\n             let path = &src_dir.push_rel(&crate.file).normalize();\n             util::note(fmt!(\"build_crates: compiling %s\", path.to_str()));\n             util::note(fmt!(\"build_crates: destination dir is %s\", dst_dir.to_str()));\n \n-            let result = util::compile_crate(maybe_sysroot, self.id, path,\n+            let result = util::compile_crate(maybe_sysroot, &self.id, path,\n                                      dst_dir,\n                                      crate.flags,\n                                      crate.cfgs + cfgs,"}, {"sha": "779a66f63a9a1601e191da243d3731966f3b17eb", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 44, "deletions": 50, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/9f104d4213ae31f4e61b210ef34b223c81c8c3af/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f104d4213ae31f4e61b210ef34b223c81c8c3af/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=9f104d4213ae31f4e61b210ef34b223c81c8c3af", "patch": "@@ -28,6 +28,11 @@ use syntax::attr::{mk_attr};\n use rustc::back::link::output_type_exe;\n use rustc::driver::session::{lib_crate, unknown_crate, crate_type};\n \n+static Commands: &'static [&'static str] =\n+    &[\"build\", \"clean\", \"do\", \"info\", \"install\", \"prefer\", \"test\", \"uninstall\",\n+      \"unprefer\"];\n+\n+\n pub type ExitCode = int; // For now\n \n /// A version is either an exact revision,\n@@ -41,28 +46,28 @@ impl Ord for Version {\n     fn lt(&self, other: &Version) -> bool {\n         match (self, other) {\n             (&ExactRevision(f1), &ExactRevision(f2)) => f1 < f2,\n-            (&SemVersion(v1), &SemVersion(v2)) => v1 < v2,\n+            (&SemVersion(ref v1), &SemVersion(ref v2)) => v1 < v2,\n             _ => false // incomparable, really\n         }\n     }\n     fn le(&self, other: &Version) -> bool {\n         match (self, other) {\n             (&ExactRevision(f1), &ExactRevision(f2)) => f1 <= f2,\n-            (&SemVersion(v1), &SemVersion(v2)) => v1 <= v2,\n+            (&SemVersion(ref v1), &SemVersion(ref v2)) => v1 <= v2,\n             _ => false // incomparable, really\n         }\n     }\n     fn ge(&self, other: &Version) -> bool {\n         match (self, other) {\n             (&ExactRevision(f1), &ExactRevision(f2)) => f1 > f2,\n-            (&SemVersion(v1), &SemVersion(v2)) => v1 > v2,\n+            (&SemVersion(ref v1), &SemVersion(ref v2)) => v1 > v2,\n             _ => false // incomparable, really\n         }\n     }\n     fn gt(&self, other: &Version) -> bool {\n         match (self, other) {\n             (&ExactRevision(f1), &ExactRevision(f2)) => f1 >= f2,\n-            (&SemVersion(v1), &SemVersion(v2)) => v1 >= v2,\n+            (&SemVersion(ref v1), &SemVersion(ref v2)) => v1 >= v2,\n             _ => false // incomparable, really\n         }\n     }\n@@ -72,8 +77,8 @@ impl Ord for Version {\n impl ToStr for Version {\n     fn to_str(&self) -> ~str {\n         match *self {\n-            ExactRevision(n) => n.to_str(),\n-            SemVersion(v) => v.to_str()\n+            ExactRevision(ref n) => n.to_str(),\n+            SemVersion(ref v) => v.to_str()\n         }\n     }\n }\n@@ -147,11 +152,8 @@ pub fn root() -> Path {\n     }\n }\n \n-pub fn is_cmd(cmd: ~str) -> bool {\n-    let cmds = &[~\"build\", ~\"clean\", ~\"do\", ~\"info\", ~\"install\", ~\"prefer\",\n-                 ~\"test\", ~\"uninstall\", ~\"unprefer\"];\n-\n-    vec::contains(cmds, &cmd)\n+pub fn is_cmd(cmd: &str) -> bool {\n+    Commands.any(|&c| c == cmd)\n }\n \n pub fn parse_name(id: ~str) -> result::Result<~str, ~str> {\n@@ -220,7 +222,7 @@ fn fold_item(ctx: @mut ReadyCtx,\n \n         for attrs.each |attr| {\n             match attr.node.value.node {\n-                ast::meta_list(_, mis) => {\n+                ast::meta_list(_, ref mis) => {\n                     for mis.each |mi| {\n                         match mi.node {\n                             ast::meta_word(cmd) => cmds.push(copy *cmd),\n@@ -266,15 +268,14 @@ fn add_pkg_module(ctx: @mut ReadyCtx, m: ast::_mod) -> ast::_mod {\n }\n \n fn mk_listener_vec(ctx: @mut ReadyCtx) -> @ast::expr {\n-    let fns = ctx.fns;\n-    let descs = do fns.map |listener| {\n-        mk_listener_rec(ctx, *listener)\n+    let descs = do ctx.fns.map |listener| {\n+        mk_listener_rec(ctx, listener)\n     };\n     let ext_cx = ctx.ext_cx;\n     build::mk_slice_vec_e(ext_cx, dummy_sp(), descs)\n }\n \n-fn mk_listener_rec(ctx: @mut ReadyCtx, listener: ListenerFn) -> @ast::expr {\n+fn mk_listener_rec(ctx: @mut ReadyCtx, listener: &ListenerFn) -> @ast::expr {\n     let span = listener.span;\n     let cmds = do listener.cmds.map |&cmd| {\n         let ext_cx = ctx.ext_cx;\n@@ -437,11 +438,11 @@ pub fn add_pkg(pkg: &Pkg) -> bool {\n \n // FIXME (#4432): Use workcache to only compile when needed\n pub fn compile_input(sysroot: Option<@Path>,\n-                     pkg_id: PkgId,\n+                     pkg_id: &PkgId,\n                      in_file: &Path,\n                      out_dir: &Path,\n-                     flags: ~[~str],\n-                     cfgs: ~[~str],\n+                     flags: &[~str],\n+                     cfgs: &[~str],\n                      opt: bool,\n                      test: bool,\n                      crate_type: session::crate_type) -> bool {\n@@ -456,7 +457,7 @@ pub fn compile_input(sysroot: Option<@Path>,\n     // tjc: by default, use the package ID name as the link name\n     // not sure if we should support anything else\n \n-    let binary = os::args()[0];\n+    let binary = @copy os::args()[0];\n     let building_library = match crate_type {\n         lib_crate | unknown_crate => true,\n         _ => false\n@@ -485,32 +486,27 @@ pub fn compile_input(sysroot: Option<@Path>,\n                           + flags\n                           + cfgs.flat_map(|&c| { ~[~\"--cfg\", c] }),\n                           driver::optgroups()).get();\n-    let options = @session::options {\n+    let mut options = session::options {\n         crate_type: crate_type,\n         optimize: if opt { session::Aggressive } else { session::No },\n         test: test,\n         maybe_sysroot: sysroot,\n         addl_lib_search_paths: ~[copy *out_dir],\n-        .. *driver::build_session_options(@binary, &matches, diagnostic::emit)\n+        // output_type should be conditional\n+        output_type: output_type_exe, // Use this to get a library? That's weird\n+        .. copy *driver::build_session_options(binary, &matches, diagnostic::emit)\n     };\n-    let mut crate_cfg = options.cfg;\n \n     for cfgs.each |&cfg| {\n-        crate_cfg.push(attr::mk_word_item(@cfg));\n+        options.cfg.push(attr::mk_word_item(@cfg));\n     }\n \n-    let options = @session::options {\n-        cfg: vec::append(options.cfg, crate_cfg),\n-        // output_type should be conditional\n-        output_type: output_type_exe, // Use this to get a library? That's weird\n-        .. *options\n-    };\n-    let sess = driver::build_session(options, diagnostic::emit);\n+    let sess = driver::build_session(@options, diagnostic::emit);\n \n     debug!(\"calling compile_crate_from_input, out_dir = %s,\n            building_library = %?\", out_dir.to_str(), sess.building_library);\n-    let _ = compile_crate_from_input(input, pkg_id, Some(*out_dir), sess, None,\n-                                     out_file, binary,\n+    let _ = compile_crate_from_input(&input, pkg_id, Some(copy *out_dir), sess,\n+                                     None, &out_file, binary,\n                                      driver::cu_everything);\n     true\n }\n@@ -520,18 +516,19 @@ pub fn compile_input(sysroot: Option<@Path>,\n // If crate_opt is present, then finish compilation. If it's None, then\n // call compile_upto and return the crate\n // also, too many arguments\n-pub fn compile_crate_from_input(input: driver::input,\n-                                pkg_id: PkgId,\n+pub fn compile_crate_from_input(input: &driver::input,\n+                                pkg_id: &PkgId,\n                                 build_dir_opt: Option<Path>,\n                                 sess: session::Session,\n                                 crate_opt: Option<@ast::crate>,\n-                                out_file: Path,\n-                                binary: ~str,\n+                                out_file: &Path,\n+                                binary: @~str,\n                                 what: driver::compile_upto) -> @ast::crate {\n     debug!(\"Calling build_output_filenames with %? and %s\", build_dir_opt, out_file.to_str());\n-    let outputs = driver::build_output_filenames(&input, &build_dir_opt, &Some(out_file), sess);\n+    let outputs = driver::build_output_filenames(input, &build_dir_opt,\n+                                                 &Some(copy *out_file), sess);\n     debug!(\"Outputs are %? and output type = %?\", outputs, sess.opts.output_type);\n-    let cfg = driver::build_configuration(sess, @binary, &input);\n+    let cfg = driver::build_configuration(sess, binary, input);\n     match crate_opt {\n         Some(c) => {\n             debug!(\"Calling compile_rest, outputs = %?\", outputs);\n@@ -541,7 +538,7 @@ pub fn compile_crate_from_input(input: driver::input,\n         }\n         None => {\n             debug!(\"Calling compile_upto, outputs = %?\", outputs);\n-            let (crate, _) = driver::compile_upto(sess, cfg, &input,\n+            let (crate, _) = driver::compile_upto(sess, copy cfg, input,\n                                                   driver::cu_parse, Some(outputs));\n \n             debug!(\"About to inject link_meta info...\");\n@@ -552,7 +549,8 @@ pub fn compile_crate_from_input(input: driver::input,\n             debug!(\"How many attrs? %?\", attr::find_linkage_metas(crate.node.attrs).len());\n \n             if attr::find_linkage_metas(crate.node.attrs).is_empty() {\n-                crate_to_use = add_attrs(*crate, ~[mk_attr(@dummy_spanned(meta_list(@~\"link\",\n+                crate_to_use = add_attrs(copy *crate,\n+                    ~[mk_attr(@dummy_spanned(meta_list(@~\"link\",\n                                                   // change PkgId to have a <shortname> field?\n                     ~[@dummy_spanned(meta_name_value(@~\"name\",\n                                                     mk_string_lit(@pkg_id.path.filestem().get()))),\n@@ -578,20 +576,16 @@ pub fn exe_suffix() -> ~str { ~\"\" }\n \n /// Returns a copy of crate `c` with attributes `attrs` added to its\n /// attributes\n-fn add_attrs(c: ast::crate, new_attrs: ~[attribute]) -> @ast::crate {\n-    @spanned {\n-        node: crate_ {\n-            attrs: c.node.attrs + new_attrs, ..c.node\n-        },\n-        span: c.span\n-    }\n+fn add_attrs(mut c: ast::crate, new_attrs: ~[attribute]) -> @ast::crate {\n+    c.node.attrs += new_attrs;\n+    @c\n }\n \n // Called by build_crates\n // FIXME (#4432): Use workcache to only compile when needed\n-pub fn compile_crate(sysroot: Option<@Path>, pkg_id: PkgId,\n+pub fn compile_crate(sysroot: Option<@Path>, pkg_id: &PkgId,\n                      crate: &Path, dir: &Path,\n-                     flags: ~[~str], cfgs: ~[~str], opt: bool,\n+                     flags: &[~str], cfgs: &[~str], opt: bool,\n                      test: bool, crate_type: crate_type) -> bool {\n     debug!(\"compile_crate: crate=%s, dir=%s\", crate.to_str(), dir.to_str());\n     debug!(\"compile_crate: short_name = %s, flags =...\", pkg_id.to_str());"}, {"sha": "8941dbfd20eabf6565724e408b2746250a37c25c", "filename": "src/librustpkg/workspace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f104d4213ae31f4e61b210ef34b223c81c8c3af/src%2Flibrustpkg%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f104d4213ae31f4e61b210ef34b223c81c8c3af/src%2Flibrustpkg%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkspace.rs?ref=9f104d4213ae31f4e61b210ef34b223c81c8c3af", "patch": "@@ -14,7 +14,7 @@ use path_util::{rust_path, workspace_contains_package_id};\n use util::PkgId;\n use core::path::Path;\n \n-pub fn pkg_parent_workspaces(pkgid: PkgId, action: &fn(&Path) -> bool) -> bool {\n+pub fn pkg_parent_workspaces(pkgid: &PkgId, action: &fn(&Path) -> bool) -> bool {\n     // Using the RUST_PATH, find workspaces that contain\n     // this package ID\n     let workspaces = rust_path().filtered(|ws|"}]}