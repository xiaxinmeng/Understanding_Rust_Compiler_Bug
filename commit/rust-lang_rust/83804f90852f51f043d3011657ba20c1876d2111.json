{"sha": "83804f90852f51f043d3011657ba20c1876d2111", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzODA0ZjkwODUyZjUxZjA0M2QzMDExNjU3YmEyMGMxODc2ZDIxMTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-25T01:45:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-25T01:45:57Z"}, "message": "auto merge of #15704 : alexcrichton/rust/issue-15595, r=brson\n\nIf a task is spinning in an accept loop, there is currently no method of gracefully shutting it down. This PR introduces a way to do so by cloning the acceptor and implementing a close_accept method to unblocking any pending acceptor.\r\n\r\nAs with other I/O methods like this, it is `#[experimental]` from the start and sadly carries with it a good deal of code to support it. Much of the complication is from the fact that you can now concurrently accept on the same socket.\r\n\r\nI tried to add a good deal of tests for this change, but another set of eyes is always appreciated!", "tree": {"sha": "7424d32c6d1efdb5ea4dc349ddec384bd1aa105f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7424d32c6d1efdb5ea4dc349ddec384bd1aa105f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83804f90852f51f043d3011657ba20c1876d2111", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83804f90852f51f043d3011657ba20c1876d2111", "html_url": "https://github.com/rust-lang/rust/commit/83804f90852f51f043d3011657ba20c1876d2111", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83804f90852f51f043d3011657ba20c1876d2111/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "833277e2d2c7cf5fcf995ef413412a21b4756ca7", "url": "https://api.github.com/repos/rust-lang/rust/commits/833277e2d2c7cf5fcf995ef413412a21b4756ca7", "html_url": "https://github.com/rust-lang/rust/commit/833277e2d2c7cf5fcf995ef413412a21b4756ca7"}, {"sha": "fd763a5b1e736df39d878b888b1bf14f2009672c", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd763a5b1e736df39d878b888b1bf14f2009672c", "html_url": "https://github.com/rust-lang/rust/commit/fd763a5b1e736df39d878b888b1bf14f2009672c"}], "stats": {"total": 1395, "additions": 1100, "deletions": 295}, "files": [{"sha": "909b37895b7b5495036f46c027fa8ca0d8a7ccc8", "filename": "src/libnative/io/c_windows.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/83804f90852f51f043d3011657ba20c1876d2111/src%2Flibnative%2Fio%2Fc_windows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83804f90852f51f043d3011657ba20c1876d2111/src%2Flibnative%2Fio%2Fc_windows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fc_windows.rs?ref=83804f90852f51f043d3011657ba20c1876d2111", "patch": "@@ -26,6 +26,14 @@ pub static ENABLE_INSERT_MODE: libc::DWORD = 0x20;\n pub static ENABLE_LINE_INPUT: libc::DWORD = 0x2;\n pub static ENABLE_PROCESSED_INPUT: libc::DWORD = 0x1;\n pub static ENABLE_QUICK_EDIT_MODE: libc::DWORD = 0x40;\n+pub static WSA_INVALID_EVENT: WSAEVENT = 0 as WSAEVENT;\n+\n+pub static FD_ACCEPT: libc::c_long = 0x08;\n+pub static FD_MAX_EVENTS: uint = 10;\n+pub static WSA_INFINITE: libc::DWORD = libc::INFINITE;\n+pub static WSA_WAIT_TIMEOUT: libc::DWORD = libc::consts::os::extra::WAIT_TIMEOUT;\n+pub static WSA_WAIT_EVENT_0: libc::DWORD = libc::consts::os::extra::WAIT_OBJECT_0;\n+pub static WSA_WAIT_FAILED: libc::DWORD = libc::consts::os::extra::WAIT_FAILED;\n \n #[repr(C)]\n #[cfg(target_arch = \"x86\")]\n@@ -52,6 +60,16 @@ pub struct WSADATA {\n \n pub type LPWSADATA = *mut WSADATA;\n \n+#[repr(C)]\n+pub struct WSANETWORKEVENTS {\n+    pub lNetworkEvents: libc::c_long,\n+    pub iErrorCode: [libc::c_int, ..FD_MAX_EVENTS],\n+}\n+\n+pub type LPWSANETWORKEVENTS = *mut WSANETWORKEVENTS;\n+\n+pub type WSAEVENT = libc::HANDLE;\n+\n #[repr(C)]\n pub struct fd_set {\n     fd_count: libc::c_uint,\n@@ -68,6 +86,21 @@ extern \"system\" {\n     pub fn WSAStartup(wVersionRequested: libc::WORD,\n                       lpWSAData: LPWSADATA) -> libc::c_int;\n     pub fn WSAGetLastError() -> libc::c_int;\n+    pub fn WSACloseEvent(hEvent: WSAEVENT) -> libc::BOOL;\n+    pub fn WSACreateEvent() -> WSAEVENT;\n+    pub fn WSAEventSelect(s: libc::SOCKET,\n+                          hEventObject: WSAEVENT,\n+                          lNetworkEvents: libc::c_long) -> libc::c_int;\n+    pub fn WSASetEvent(hEvent: WSAEVENT) -> libc::BOOL;\n+    pub fn WSAWaitForMultipleEvents(cEvents: libc::DWORD,\n+                                    lphEvents: *const WSAEVENT,\n+                                    fWaitAll: libc::BOOL,\n+                                    dwTimeout: libc::DWORD,\n+                                    fAltertable: libc::BOOL) -> libc::DWORD;\n+    pub fn WSAEnumNetworkEvents(s: libc::SOCKET,\n+                                hEventObject: WSAEVENT,\n+                                lpNetworkEvents: LPWSANETWORKEVENTS)\n+                                -> libc::c_int;\n \n     pub fn ioctlsocket(s: libc::SOCKET, cmd: libc::c_long,\n                        argp: *mut libc::c_ulong) -> libc::c_int;\n@@ -82,6 +115,12 @@ extern \"system\" {\n                       optval: *mut libc::c_char,\n                       optlen: *mut libc::c_int) -> libc::c_int;\n \n+    pub fn SetEvent(hEvent: libc::HANDLE) -> libc::BOOL;\n+    pub fn WaitForMultipleObjects(nCount: libc::DWORD,\n+                                  lpHandles: *const libc::HANDLE,\n+                                  bWaitAll: libc::BOOL,\n+                                  dwMilliseconds: libc::DWORD) -> libc::DWORD;\n+\n     pub fn CancelIo(hFile: libc::HANDLE) -> libc::BOOL;\n     pub fn CancelIoEx(hFile: libc::HANDLE,\n                       lpOverlapped: libc::LPOVERLAPPED) -> libc::BOOL;"}, {"sha": "368b5914444ac9509f12fca2e28f23258b674cca", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 281, "deletions": 76, "changes": 357, "blob_url": "https://github.com/rust-lang/rust/blob/83804f90852f51f043d3011657ba20c1876d2111/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83804f90852f51f043d3011657ba20c1876d2111/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=83804f90852f51f043d3011657ba20c1876d2111", "patch": "@@ -11,21 +11,25 @@\n use alloc::arc::Arc;\n use libc;\n use std::mem;\n+use std::ptr;\n use std::rt::mutex;\n use std::rt::rtio;\n use std::rt::rtio::{IoResult, IoError};\n+use std::sync::atomic;\n \n use super::{retry, keep_going};\n use super::c;\n use super::util;\n \n+#[cfg(unix)] use super::process;\n+#[cfg(unix)] use super::file::FileDesc;\n+\n+pub use self::os::{init, sock_t, last_error};\n+\n ////////////////////////////////////////////////////////////////////////////////\n // sockaddr and misc bindings\n ////////////////////////////////////////////////////////////////////////////////\n \n-#[cfg(windows)] pub type sock_t = libc::SOCKET;\n-#[cfg(unix)]    pub type sock_t = super::file::fd_t;\n-\n pub fn htons(u: u16) -> u16 {\n     u.to_be()\n }\n@@ -97,7 +101,7 @@ fn socket(addr: rtio::SocketAddr, ty: libc::c_int) -> IoResult<sock_t> {\n             rtio::Ipv6Addr(..) => libc::AF_INET6,\n         };\n         match libc::socket(fam, ty, 0) {\n-            -1 => Err(super::last_error()),\n+            -1 => Err(os::last_error()),\n             fd => Ok(fd),\n         }\n     }\n@@ -111,7 +115,7 @@ fn setsockopt<T>(fd: sock_t, opt: libc::c_int, val: libc::c_int,\n                                    payload,\n                                    mem::size_of::<T>() as libc::socklen_t);\n         if ret != 0 {\n-            Err(last_error())\n+            Err(os::last_error())\n         } else {\n             Ok(())\n         }\n@@ -127,33 +131,14 @@ pub fn getsockopt<T: Copy>(fd: sock_t, opt: libc::c_int,\n                                 &mut slot as *mut _ as *mut _,\n                                 &mut len);\n         if ret != 0 {\n-            Err(last_error())\n+            Err(os::last_error())\n         } else {\n             assert!(len as uint == mem::size_of::<T>());\n             Ok(slot)\n         }\n     }\n }\n \n-#[cfg(windows)]\n-pub fn last_error() -> IoError {\n-    use std::os;\n-    let code = unsafe { c::WSAGetLastError() as uint };\n-    IoError {\n-        code: code,\n-        extra: 0,\n-        detail: Some(os::error_string(code)),\n-    }\n-}\n-\n-#[cfg(not(windows))]\n-fn last_error() -> IoError {\n-    super::last_error()\n-}\n-\n-#[cfg(windows)] unsafe fn close(sock: sock_t) { let _ = libc::closesocket(sock); }\n-#[cfg(unix)]    unsafe fn close(sock: sock_t) { let _ = libc::close(sock); }\n-\n fn sockname(fd: sock_t,\n             f: unsafe extern \"system\" fn(sock_t, *mut libc::sockaddr,\n                                          *mut libc::socklen_t) -> libc::c_int)\n@@ -167,7 +152,7 @@ fn sockname(fd: sock_t,\n                     storage as *mut libc::sockaddr,\n                     &mut len as *mut libc::socklen_t);\n         if ret != 0 {\n-            return Err(last_error())\n+            return Err(os::last_error())\n         }\n     }\n     return sockaddr_to_addr(&storage, len as uint);\n@@ -221,28 +206,6 @@ pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n     }\n }\n \n-#[cfg(unix)]\n-pub fn init() {}\n-\n-#[cfg(windows)]\n-pub fn init() {\n-\n-    unsafe {\n-        use std::rt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n-        static mut INITIALIZED: bool = false;\n-        static mut LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n-\n-        let _guard = LOCK.lock();\n-        if !INITIALIZED {\n-            let mut data: c::WSADATA = mem::zeroed();\n-            let ret = c::WSAStartup(0x202,      // version 2.2\n-                                    &mut data);\n-            assert_eq!(ret, 0);\n-            INITIALIZED = true;\n-        }\n-    }\n-}\n-\n ////////////////////////////////////////////////////////////////////////////////\n // TCP streams\n ////////////////////////////////////////////////////////////////////////////////\n@@ -289,7 +252,7 @@ impl TcpStream {\n             },\n             None => {\n                 match retry(|| unsafe { libc::connect(fd, addrp, len) }) {\n-                    -1 => Err(last_error()),\n+                    -1 => Err(os::last_error()),\n                     _ => Ok(ret),\n                 }\n             }\n@@ -435,7 +398,7 @@ impl rtio::RtioSocket for TcpStream {\n }\n \n impl Drop for Inner {\n-    fn drop(&mut self) { unsafe { close(self.fd); } }\n+    fn drop(&mut self) { unsafe { os::close(self.fd); } }\n }\n \n #[unsafe_destructor]\n@@ -471,7 +434,7 @@ impl TcpListener {\n         }\n \n         match unsafe { libc::bind(fd, addrp, len) } {\n-            -1 => Err(last_error()),\n+            -1 => Err(os::last_error()),\n             _ => Ok(ret),\n         }\n     }\n@@ -480,8 +443,44 @@ impl TcpListener {\n \n     pub fn native_listen(self, backlog: int) -> IoResult<TcpAcceptor> {\n         match unsafe { libc::listen(self.fd(), backlog as libc::c_int) } {\n-            -1 => Err(last_error()),\n-            _ => Ok(TcpAcceptor { listener: self, deadline: 0 })\n+            -1 => Err(os::last_error()),\n+\n+            #[cfg(unix)]\n+            _ => {\n+                let (reader, writer) = try!(process::pipe());\n+                try!(util::set_nonblocking(reader.fd(), true));\n+                try!(util::set_nonblocking(writer.fd(), true));\n+                try!(util::set_nonblocking(self.fd(), true));\n+                Ok(TcpAcceptor {\n+                    inner: Arc::new(AcceptorInner {\n+                        listener: self,\n+                        reader: reader,\n+                        writer: writer,\n+                        closed: atomic::AtomicBool::new(false),\n+                    }),\n+                    deadline: 0,\n+                })\n+            }\n+\n+            #[cfg(windows)]\n+            _ => {\n+                let accept = try!(os::Event::new());\n+                let ret = unsafe {\n+                    c::WSAEventSelect(self.fd(), accept.handle(), c::FD_ACCEPT)\n+                };\n+                if ret != 0 {\n+                    return Err(os::last_error())\n+                }\n+                Ok(TcpAcceptor {\n+                    inner: Arc::new(AcceptorInner {\n+                        listener: self,\n+                        abort: try!(os::Event::new()),\n+                        accept: accept,\n+                        closed: atomic::AtomicBool::new(false),\n+                    }),\n+                    deadline: 0,\n+                })\n+            }\n         }\n     }\n }\n@@ -502,31 +501,135 @@ impl rtio::RtioSocket for TcpListener {\n }\n \n pub struct TcpAcceptor {\n-    listener: TcpListener,\n+    inner: Arc<AcceptorInner>,\n     deadline: u64,\n }\n \n+#[cfg(unix)]\n+struct AcceptorInner {\n+    listener: TcpListener,\n+    reader: FileDesc,\n+    writer: FileDesc,\n+    closed: atomic::AtomicBool,\n+}\n+\n+#[cfg(windows)]\n+struct AcceptorInner {\n+    listener: TcpListener,\n+    abort: os::Event,\n+    accept: os::Event,\n+    closed: atomic::AtomicBool,\n+}\n+\n impl TcpAcceptor {\n-    pub fn fd(&self) -> sock_t { self.listener.fd() }\n+    pub fn fd(&self) -> sock_t { self.inner.listener.fd() }\n \n+    #[cfg(unix)]\n     pub fn native_accept(&mut self) -> IoResult<TcpStream> {\n-        if self.deadline != 0 {\n-            try!(util::await(self.fd(), Some(self.deadline), util::Readable));\n+        // In implementing accept, the two main concerns are dealing with\n+        // close_accept() and timeouts. The unix implementation is based on a\n+        // nonblocking accept plus a call to select(). Windows ends up having\n+        // an entirely separate implementation than unix, which is explained\n+        // below.\n+        //\n+        // To implement timeouts, all blocking is done via select() instead of\n+        // accept() by putting the socket in non-blocking mode. Because\n+        // select() takes a timeout argument, we just pass through the timeout\n+        // to select().\n+        //\n+        // To implement close_accept(), we have a self-pipe to ourselves which\n+        // is passed to select() along with the socket being accepted on. The\n+        // self-pipe is never written to unless close_accept() is called.\n+        let deadline = if self.deadline == 0 {None} else {Some(self.deadline)};\n+\n+        while !self.inner.closed.load(atomic::SeqCst) {\n+            match retry(|| unsafe {\n+                libc::accept(self.fd(), ptr::mut_null(), ptr::mut_null())\n+            }) {\n+                -1 if util::wouldblock() => {}\n+                -1 => return Err(os::last_error()),\n+                fd => return Ok(TcpStream::new(Inner::new(fd as sock_t))),\n+            }\n+            try!(util::await([self.fd(), self.inner.reader.fd()],\n+                             deadline, util::Readable));\n         }\n-        unsafe {\n-            let mut storage: libc::sockaddr_storage = mem::zeroed();\n-            let storagep = &mut storage as *mut libc::sockaddr_storage;\n-            let size = mem::size_of::<libc::sockaddr_storage>();\n-            let mut size = size as libc::socklen_t;\n-            match retry(|| {\n-                libc::accept(self.fd(),\n-                             storagep as *mut libc::sockaddr,\n-                             &mut size as *mut libc::socklen_t) as libc::c_int\n-            }) as sock_t {\n-                -1 => Err(last_error()),\n-                fd => Ok(TcpStream::new(Inner::new(fd))),\n+\n+        Err(util::eof())\n+    }\n+\n+    #[cfg(windows)]\n+    pub fn native_accept(&mut self) -> IoResult<TcpStream> {\n+        // Unlink unix, windows cannot invoke `select` on arbitrary file\n+        // descriptors like pipes, only sockets. Consequently, windows cannot\n+        // use the same implementation as unix for accept() when close_accept()\n+        // is considered.\n+        //\n+        // In order to implement close_accept() and timeouts, windows uses\n+        // event handles. An acceptor-specific abort event is created which\n+        // will only get set in close_accept(), and it will never be un-set.\n+        // Additionally, another acceptor-specific event is associated with the\n+        // FD_ACCEPT network event.\n+        //\n+        // These two events are then passed to WaitForMultipleEvents to see\n+        // which one triggers first, and the timeout passed to this function is\n+        // the local timeout for the acceptor.\n+        //\n+        // If the wait times out, then the accept timed out. If the wait\n+        // succeeds with the abort event, then we were closed, and if the wait\n+        // succeeds otherwise, then we do a nonblocking poll via `accept` to\n+        // see if we can accept a connection. The connection is candidate to be\n+        // stolen, so we do all of this in a loop as well.\n+        let events = [self.inner.abort.handle(), self.inner.accept.handle()];\n+\n+        while !self.inner.closed.load(atomic::SeqCst) {\n+            let ms = if self.deadline == 0 {\n+                c::WSA_INFINITE as u64\n+            } else {\n+                let now = ::io::timer::now();\n+                if self.deadline < now {0} else {self.deadline - now}\n+            };\n+            let ret = unsafe {\n+                c::WSAWaitForMultipleEvents(2, events.as_ptr(), libc::FALSE,\n+                                            ms as libc::DWORD, libc::FALSE)\n+            };\n+            match ret {\n+                c::WSA_WAIT_TIMEOUT => {\n+                    return Err(util::timeout(\"accept timed out\"))\n+                }\n+                c::WSA_WAIT_FAILED => return Err(os::last_error()),\n+                c::WSA_WAIT_EVENT_0 => break,\n+                n => assert_eq!(n, c::WSA_WAIT_EVENT_0 + 1),\n+            }\n+\n+            let mut wsaevents: c::WSANETWORKEVENTS = unsafe { mem::zeroed() };\n+            let ret = unsafe {\n+                c::WSAEnumNetworkEvents(self.fd(), events[1], &mut wsaevents)\n+            };\n+            if ret != 0 { return Err(os::last_error()) }\n+\n+            if wsaevents.lNetworkEvents & c::FD_ACCEPT == 0 { continue }\n+            match unsafe {\n+                libc::accept(self.fd(), ptr::mut_null(), ptr::mut_null())\n+            } {\n+                -1 if util::wouldblock() => {}\n+                -1 => return Err(os::last_error()),\n+\n+                // Accepted sockets inherit the same properties as the caller,\n+                // so we need to deregister our event and switch the socket back\n+                // to blocking mode\n+                fd => {\n+                    let stream = TcpStream::new(Inner::new(fd));\n+                    let ret = unsafe {\n+                        c::WSAEventSelect(fd, events[1], 0)\n+                    };\n+                    if ret != 0 { return Err(os::last_error()) }\n+                    try!(util::set_nonblocking(fd, false));\n+                    return Ok(stream)\n+                }\n             }\n         }\n+\n+        Err(util::eof())\n     }\n }\n \n@@ -546,6 +649,35 @@ impl rtio::RtioTcpAcceptor for TcpAcceptor {\n     fn set_timeout(&mut self, timeout: Option<u64>) {\n         self.deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n     }\n+\n+    fn clone(&self) -> Box<rtio::RtioTcpAcceptor + Send> {\n+        box TcpAcceptor {\n+            inner: self.inner.clone(),\n+            deadline: 0,\n+        } as Box<rtio::RtioTcpAcceptor + Send>\n+    }\n+\n+    #[cfg(unix)]\n+    fn close_accept(&mut self) -> IoResult<()> {\n+        self.inner.closed.store(true, atomic::SeqCst);\n+        let mut fd = FileDesc::new(self.inner.writer.fd(), false);\n+        match fd.inner_write([0]) {\n+            Ok(..) => Ok(()),\n+            Err(..) if util::wouldblock() => Ok(()),\n+            Err(e) => Err(e),\n+        }\n+    }\n+\n+    #[cfg(windows)]\n+    fn close_accept(&mut self) -> IoResult<()> {\n+        self.inner.closed.store(true, atomic::SeqCst);\n+        let ret = unsafe { c::WSASetEvent(self.inner.abort.handle()) };\n+        if ret == libc::TRUE {\n+            Ok(())\n+        } else {\n+            Err(os::last_error())\n+        }\n+    }\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -572,7 +704,7 @@ impl UdpSocket {\n         let addrp = &storage as *const _ as *const libc::sockaddr;\n \n         match unsafe { libc::bind(fd, addrp, len) } {\n-            -1 => Err(last_error()),\n+            -1 => Err(os::last_error()),\n             _ => Ok(ret),\n         }\n     }\n@@ -817,7 +949,7 @@ pub fn read<T>(fd: sock_t,\n             // With a timeout, first we wait for the socket to become\n             // readable using select(), specifying the relevant timeout for\n             // our previously set deadline.\n-            try!(util::await(fd, deadline, util::Readable));\n+            try!(util::await([fd], deadline, util::Readable));\n \n             // At this point, we're still within the timeout, and we've\n             // determined that the socket is readable (as returned by\n@@ -828,15 +960,15 @@ pub fn read<T>(fd: sock_t,\n             let _guard = lock();\n             match retry(|| read(deadline.is_some())) {\n                 -1 if util::wouldblock() => { assert!(deadline.is_some()); }\n-                -1 => return Err(last_error()),\n+                -1 => return Err(os::last_error()),\n                n => { ret = n; break }\n             }\n         }\n     }\n \n     match ret {\n         0 => Err(util::eof()),\n-        n if n < 0 => Err(last_error()),\n+        n if n < 0 => Err(os::last_error()),\n         n => Ok(n as uint)\n     }\n }\n@@ -871,7 +1003,7 @@ pub fn write<T>(fd: sock_t,\n         while written < buf.len() && (write_everything || written == 0) {\n             // As with read(), first wait for the socket to be ready for\n             // the I/O operation.\n-            match util::await(fd, deadline, util::Writable) {\n+            match util::await([fd], deadline, util::Writable) {\n                 Err(ref e) if e.code == libc::EOF as uint && written > 0 => {\n                     assert!(deadline.is_some());\n                     return Err(util::short_write(written, \"short write\"))\n@@ -887,15 +1019,88 @@ pub fn write<T>(fd: sock_t,\n             let len = buf.len() - written;\n             match retry(|| write(deadline.is_some(), ptr, len) as libc::c_int) {\n                 -1 if util::wouldblock() => {}\n-                -1 => return Err(last_error()),\n+                -1 => return Err(os::last_error()),\n                 n => { written += n as uint; }\n             }\n         }\n         ret = 0;\n     }\n     if ret < 0 {\n-        Err(last_error())\n+        Err(os::last_error())\n     } else {\n         Ok(written)\n     }\n }\n+\n+#[cfg(windows)]\n+mod os {\n+    use libc;\n+    use std::mem;\n+    use std::rt::rtio::{IoError, IoResult};\n+\n+    use io::c;\n+\n+    pub type sock_t = libc::SOCKET;\n+    pub struct Event(c::WSAEVENT);\n+\n+    impl Event {\n+        pub fn new() -> IoResult<Event> {\n+            let event = unsafe { c::WSACreateEvent() };\n+            if event == c::WSA_INVALID_EVENT {\n+                Err(last_error())\n+            } else {\n+                Ok(Event(event))\n+            }\n+        }\n+\n+        pub fn handle(&self) -> c::WSAEVENT { let Event(handle) = *self; handle }\n+    }\n+\n+    impl Drop for Event {\n+        fn drop(&mut self) {\n+            unsafe { let _ = c::WSACloseEvent(self.handle()); }\n+        }\n+    }\n+\n+    pub fn init() {\n+        unsafe {\n+            use std::rt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n+            static mut INITIALIZED: bool = false;\n+            static mut LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+\n+            let _guard = LOCK.lock();\n+            if !INITIALIZED {\n+                let mut data: c::WSADATA = mem::zeroed();\n+                let ret = c::WSAStartup(0x202,      // version 2.2\n+                                        &mut data);\n+                assert_eq!(ret, 0);\n+                INITIALIZED = true;\n+            }\n+        }\n+    }\n+\n+    pub fn last_error() -> IoError {\n+        use std::os;\n+        let code = unsafe { c::WSAGetLastError() as uint };\n+        IoError {\n+            code: code,\n+            extra: 0,\n+            detail: Some(os::error_string(code)),\n+        }\n+    }\n+\n+    pub unsafe fn close(sock: sock_t) { let _ = libc::closesocket(sock); }\n+}\n+\n+#[cfg(unix)]\n+mod os {\n+    use libc;\n+    use std::rt::rtio::IoError;\n+    use io;\n+\n+    pub type sock_t = io::file::fd_t;\n+\n+    pub fn init() {}\n+    pub fn last_error() -> IoError { io::last_error() }\n+    pub unsafe fn close(sock: sock_t) { let _ = libc::close(sock); }\n+}"}, {"sha": "a3564dfe2cc9a5905cdc9b6464787a0f8102e5da", "filename": "src/libnative/io/pipe_unix.rs", "status": "modified", "additions": 70, "deletions": 18, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/83804f90852f51f043d3011657ba20c1876d2111/src%2Flibnative%2Fio%2Fpipe_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83804f90852f51f043d3011657ba20c1876d2111/src%2Flibnative%2Fio%2Fpipe_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_unix.rs?ref=83804f90852f51f043d3011657ba20c1876d2111", "patch": "@@ -15,12 +15,14 @@ use std::mem;\n use std::rt::mutex;\n use std::rt::rtio;\n use std::rt::rtio::{IoResult, IoError};\n+use std::sync::atomic;\n \n use super::retry;\n use super::net;\n use super::util;\n use super::c;\n-use super::file::fd_t;\n+use super::process;\n+use super::file::{fd_t, FileDesc};\n \n fn unix_socket(ty: libc::c_int) -> IoResult<fd_t> {\n     match unsafe { libc::socket(libc::AF_UNIX, ty, 0) } {\n@@ -225,7 +227,23 @@ impl UnixListener {\n     pub fn native_listen(self, backlog: int) -> IoResult<UnixAcceptor> {\n         match unsafe { libc::listen(self.fd(), backlog as libc::c_int) } {\n             -1 => Err(super::last_error()),\n-            _ => Ok(UnixAcceptor { listener: self, deadline: 0 })\n+\n+            #[cfg(unix)]\n+            _ => {\n+                let (reader, writer) = try!(process::pipe());\n+                try!(util::set_nonblocking(reader.fd(), true));\n+                try!(util::set_nonblocking(writer.fd(), true));\n+                try!(util::set_nonblocking(self.fd(), true));\n+                Ok(UnixAcceptor {\n+                    inner: Arc::new(AcceptorInner {\n+                        listener: self,\n+                        reader: reader,\n+                        writer: writer,\n+                        closed: atomic::AtomicBool::new(false),\n+                    }),\n+                    deadline: 0,\n+                })\n+            }\n         }\n     }\n }\n@@ -240,29 +258,45 @@ impl rtio::RtioUnixListener for UnixListener {\n }\n \n pub struct UnixAcceptor {\n-    listener: UnixListener,\n+    inner: Arc<AcceptorInner>,\n     deadline: u64,\n }\n \n+#[cfg(unix)]\n+struct AcceptorInner {\n+    listener: UnixListener,\n+    reader: FileDesc,\n+    writer: FileDesc,\n+    closed: atomic::AtomicBool,\n+}\n+\n impl UnixAcceptor {\n-    fn fd(&self) -> fd_t { self.listener.fd() }\n+    fn fd(&self) -> fd_t { self.inner.listener.fd() }\n \n     pub fn native_accept(&mut self) -> IoResult<UnixStream> {\n-        if self.deadline != 0 {\n-            try!(util::await(self.fd(), Some(self.deadline), util::Readable));\n-        }\n-        let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n-        let storagep = &mut storage as *mut libc::sockaddr_storage;\n-        let size = mem::size_of::<libc::sockaddr_storage>();\n-        let mut size = size as libc::socklen_t;\n-        match retry(|| unsafe {\n-            libc::accept(self.fd(),\n-                         storagep as *mut libc::sockaddr,\n-                         &mut size as *mut libc::socklen_t) as libc::c_int\n-        }) {\n-            -1 => Err(super::last_error()),\n-            fd => Ok(UnixStream::new(Arc::new(Inner::new(fd))))\n+        let deadline = if self.deadline == 0 {None} else {Some(self.deadline)};\n+\n+        while !self.inner.closed.load(atomic::SeqCst) {\n+            unsafe {\n+                let mut storage: libc::sockaddr_storage = mem::zeroed();\n+                let storagep = &mut storage as *mut libc::sockaddr_storage;\n+                let size = mem::size_of::<libc::sockaddr_storage>();\n+                let mut size = size as libc::socklen_t;\n+                match retry(|| {\n+                    libc::accept(self.fd(),\n+                                 storagep as *mut libc::sockaddr,\n+                                 &mut size as *mut libc::socklen_t) as libc::c_int\n+                }) {\n+                    -1 if util::wouldblock() => {}\n+                    -1 => return Err(super::last_error()),\n+                    fd => return Ok(UnixStream::new(Arc::new(Inner::new(fd)))),\n+                }\n+            }\n+            try!(util::await([self.fd(), self.inner.reader.fd()],\n+                             deadline, util::Readable));\n         }\n+\n+        Err(util::eof())\n     }\n }\n \n@@ -273,6 +307,24 @@ impl rtio::RtioUnixAcceptor for UnixAcceptor {\n     fn set_timeout(&mut self, timeout: Option<u64>) {\n         self.deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);\n     }\n+\n+    fn clone(&self) -> Box<rtio::RtioUnixAcceptor + Send> {\n+        box UnixAcceptor {\n+            inner: self.inner.clone(),\n+            deadline: 0,\n+        } as Box<rtio::RtioUnixAcceptor + Send>\n+    }\n+\n+    #[cfg(unix)]\n+    fn close_accept(&mut self) -> IoResult<()> {\n+        self.inner.closed.store(true, atomic::SeqCst);\n+        let mut fd = FileDesc::new(self.inner.writer.fd(), false);\n+        match fd.inner_write([0]) {\n+            Ok(..) => Ok(()),\n+            Err(..) if util::wouldblock() => Ok(()),\n+            Err(e) => Err(e),\n+        }\n+    }\n }\n \n impl Drop for UnixListener {"}, {"sha": "95afa11f4a9a0c8f72712d1524dc2678a2a41089", "filename": "src/libnative/io/pipe_windows.rs", "status": "modified", "additions": 77, "deletions": 21, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/83804f90852f51f043d3011657ba20c1876d2111/src%2Flibnative%2Fio%2Fpipe_windows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83804f90852f51f043d3011657ba20c1876d2111/src%2Flibnative%2Fio%2Fpipe_windows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_windows.rs?ref=83804f90852f51f043d3011657ba20c1876d2111", "patch": "@@ -169,23 +169,30 @@ unsafe fn pipe(name: *const u16, init: bool) -> libc::HANDLE {\n }\n \n pub fn await(handle: libc::HANDLE, deadline: u64,\n-             overlapped: &mut libc::OVERLAPPED) -> bool {\n-    if deadline == 0 { return true }\n+             events: &[libc::HANDLE]) -> IoResult<uint> {\n+    use libc::consts::os::extra::{WAIT_FAILED, WAIT_TIMEOUT, WAIT_OBJECT_0};\n \n     // If we've got a timeout, use WaitForSingleObject in tandem with CancelIo\n     // to figure out if we should indeed get the result.\n-    let now = ::io::timer::now();\n-    let timeout = deadline < now || unsafe {\n-        let ms = (deadline - now) as libc::DWORD;\n-        let r = libc::WaitForSingleObject(overlapped.hEvent,\n-                                          ms);\n-        r != libc::WAIT_OBJECT_0\n-    };\n-    if timeout {\n-        unsafe { let _ = c::CancelIo(handle); }\n-        false\n+    let ms = if deadline == 0 {\n+        libc::INFINITE as u64\n     } else {\n-        true\n+        let now = ::io::timer::now();\n+        if deadline < now {0} else {deadline - now}\n+    };\n+    let ret = unsafe {\n+        c::WaitForMultipleObjects(events.len() as libc::DWORD,\n+                                  events.as_ptr(),\n+                                  libc::FALSE,\n+                                  ms as libc::DWORD)\n+    };\n+    match ret {\n+        WAIT_FAILED => Err(super::last_error()),\n+        WAIT_TIMEOUT => unsafe {\n+            let _ = c::CancelIo(handle);\n+            Err(util::timeout(\"operation timed out\"))\n+        },\n+        n => Ok((n - WAIT_OBJECT_0) as uint)\n     }\n }\n \n@@ -390,8 +397,8 @@ impl rtio::RtioPipe for UnixStream {\n         drop(guard);\n         loop {\n             // Process a timeout if one is pending\n-            let succeeded = await(self.handle(), self.read_deadline,\n-                                  &mut overlapped);\n+            let wait_succeeded = await(self.handle(), self.read_deadline,\n+                                       [overlapped.hEvent]);\n \n             let ret = unsafe {\n                 libc::GetOverlappedResult(self.handle(),\n@@ -408,7 +415,7 @@ impl rtio::RtioPipe for UnixStream {\n \n             // If the reading half is now closed, then we're done. If we woke up\n             // because the writing half was closed, keep trying.\n-            if !succeeded {\n+            if wait_succeeded.is_err() {\n                 return Err(util::timeout(\"read timed out\"))\n             }\n             if self.read_closed() {\n@@ -458,8 +465,8 @@ impl rtio::RtioPipe for UnixStream {\n                     })\n                 }\n                 // Process a timeout if one is pending\n-                let succeeded = await(self.handle(), self.write_deadline,\n-                                      &mut overlapped);\n+                let wait_succeeded = await(self.handle(), self.write_deadline,\n+                                           [overlapped.hEvent]);\n                 let ret = unsafe {\n                     libc::GetOverlappedResult(self.handle(),\n                                               &mut overlapped,\n@@ -473,7 +480,7 @@ impl rtio::RtioPipe for UnixStream {\n                     if os::errno() != libc::ERROR_OPERATION_ABORTED as uint {\n                         return Err(super::last_error())\n                     }\n-                    if !succeeded {\n+                    if !wait_succeeded.is_ok() {\n                         let amt = offset + bytes_written as uint;\n                         return if amt > 0 {\n                             Err(IoError {\n@@ -577,6 +584,10 @@ impl UnixListener {\n             listener: self,\n             event: try!(Event::new(true, false)),\n             deadline: 0,\n+            inner: Arc::new(AcceptorState {\n+                abort: try!(Event::new(true, false)),\n+                closed: atomic::AtomicBool::new(false),\n+            }),\n         })\n     }\n }\n@@ -597,11 +608,17 @@ impl rtio::RtioUnixListener for UnixListener {\n }\n \n pub struct UnixAcceptor {\n+    inner: Arc<AcceptorState>,\n     listener: UnixListener,\n     event: Event,\n     deadline: u64,\n }\n \n+struct AcceptorState {\n+    abort: Event,\n+    closed: atomic::AtomicBool,\n+}\n+\n impl UnixAcceptor {\n     pub fn native_accept(&mut self) -> IoResult<UnixStream> {\n         // This function has some funky implementation details when working with\n@@ -638,6 +655,10 @@ impl UnixAcceptor {\n         // using the original server pipe.\n         let handle = self.listener.handle;\n \n+        // If we've had an artifical call to close_accept, be sure to never\n+        // proceed in accepting new clients in the future\n+        if self.inner.closed.load(atomic::SeqCst) { return Err(util::eof()) }\n+\n         let name = try!(to_utf16(&self.listener.name));\n \n         // Once we've got a \"server handle\", we need to wait for a client to\n@@ -652,7 +673,9 @@ impl UnixAcceptor {\n \n             if err == libc::ERROR_IO_PENDING as libc::DWORD {\n                 // Process a timeout if one is pending\n-                let _ = await(handle, self.deadline, &mut overlapped);\n+                let wait_succeeded = await(handle, self.deadline,\n+                                           [self.inner.abort.handle(),\n+                                            overlapped.hEvent]);\n \n                 // This will block until the overlapped I/O is completed. The\n                 // timeout was previously handled, so this will either block in\n@@ -665,7 +688,11 @@ impl UnixAcceptor {\n                                               libc::TRUE)\n                 };\n                 if ret == 0 {\n-                    err = unsafe { libc::GetLastError() };\n+                    if wait_succeeded.is_ok() {\n+                        err = unsafe { libc::GetLastError() };\n+                    } else {\n+                        return Err(util::timeout(\"accept timed out\"))\n+                    }\n                 } else {\n                     // we succeeded, bypass the check below\n                     err = libc::ERROR_PIPE_CONNECTED as libc::DWORD;\n@@ -709,5 +736,34 @@ impl rtio::RtioUnixAcceptor for UnixAcceptor {\n     fn set_timeout(&mut self, timeout: Option<u64>) {\n         self.deadline = timeout.map(|i| i + ::io::timer::now()).unwrap_or(0);\n     }\n+\n+    fn clone(&self) -> Box<rtio::RtioUnixAcceptor + Send> {\n+        let name = to_utf16(&self.listener.name).ok().unwrap();\n+        box UnixAcceptor {\n+            inner: self.inner.clone(),\n+            event: Event::new(true, false).ok().unwrap(),\n+            deadline: 0,\n+            listener: UnixListener {\n+                name: self.listener.name.clone(),\n+                handle: unsafe {\n+                    let p = pipe(name.as_ptr(), false) ;\n+                    assert!(p != libc::INVALID_HANDLE_VALUE as libc::HANDLE);\n+                    p\n+                },\n+            },\n+        } as Box<rtio::RtioUnixAcceptor + Send>\n+    }\n+\n+    fn close_accept(&mut self) -> IoResult<()> {\n+        self.inner.closed.store(true, atomic::SeqCst);\n+        let ret = unsafe {\n+            c::SetEvent(self.inner.abort.handle())\n+        };\n+        if ret == 0 {\n+            Err(super::last_error())\n+        } else {\n+            Ok(())\n+        }\n+    }\n }\n "}, {"sha": "b8ec0cd549611dd59758d7e7b8d8de012ad4aee5", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83804f90852f51f043d3011657ba20c1876d2111/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83804f90852f51f043d3011657ba20c1876d2111/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=83804f90852f51f043d3011657ba20c1876d2111", "patch": "@@ -191,7 +191,7 @@ impl Drop for Process {\n     }\n }\n \n-fn pipe() -> IoResult<(file::FileDesc, file::FileDesc)> {\n+pub fn pipe() -> IoResult<(file::FileDesc, file::FileDesc)> {\n     #[cfg(unix)] use libc::EMFILE as ERROR;\n     #[cfg(windows)] use libc::WSAEMFILE as ERROR;\n     struct Closer { fd: libc::c_int }"}, {"sha": "078989b058180328acc784722f031cabc2fe7b66", "filename": "src/libnative/io/util.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/83804f90852f51f043d3011657ba20c1876d2111/src%2Flibnative%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83804f90852f51f043d3011657ba20c1876d2111/src%2Flibnative%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Futil.rs?ref=83804f90852f51f043d3011657ba20c1876d2111", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use libc;\n+use std::cmp;\n use std::mem;\n use std::os;\n use std::ptr;\n@@ -166,10 +167,18 @@ pub fn connect_timeout(fd: net::sock_t,\n     }\n }\n \n-pub fn await(fd: net::sock_t, deadline: Option<u64>,\n+pub fn await(fds: &[net::sock_t], deadline: Option<u64>,\n              status: SocketStatus) -> IoResult<()> {\n     let mut set: c::fd_set = unsafe { mem::zeroed() };\n-    c::fd_set(&mut set, fd);\n+    let mut max = 0;\n+    for &fd in fds.iter() {\n+        c::fd_set(&mut set, fd);\n+        max = cmp::max(max, fd + 1);\n+    }\n+    if cfg!(windows) {\n+        max = fds.len() as net::sock_t;\n+    }\n+\n     let (read, write) = match status {\n         Readable => (&mut set as *mut _, ptr::mut_null()),\n         Writable => (ptr::mut_null(), &mut set as *mut _),\n@@ -188,8 +197,9 @@ pub fn await(fd: net::sock_t, deadline: Option<u64>,\n                 &mut tv as *mut _\n             }\n         };\n-        let n = if cfg!(windows) {1} else {fd as libc::c_int + 1};\n-        let r = unsafe { c::select(n, read, write, ptr::mut_null(), tvp) };\n+        let r = unsafe {\n+            c::select(max as libc::c_int, read, write, ptr::mut_null(), tvp)\n+        };\n         r\n     }) {\n         -1 => Err(last_error()),"}, {"sha": "261d544a24149129c62ed4622221de78fb420b5e", "filename": "src/librustrt/rtio.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/83804f90852f51f043d3011657ba20c1876d2111/src%2Flibrustrt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83804f90852f51f043d3011657ba20c1876d2111/src%2Flibrustrt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Frtio.rs?ref=83804f90852f51f043d3011657ba20c1876d2111", "patch": "@@ -246,6 +246,8 @@ pub trait RtioTcpAcceptor : RtioSocket {\n     fn accept_simultaneously(&mut self) -> IoResult<()>;\n     fn dont_accept_simultaneously(&mut self) -> IoResult<()>;\n     fn set_timeout(&mut self, timeout: Option<u64>);\n+    fn clone(&self) -> Box<RtioTcpAcceptor + Send>;\n+    fn close_accept(&mut self) -> IoResult<()>;\n }\n \n pub trait RtioTcpStream : RtioSocket {\n@@ -335,6 +337,8 @@ pub trait RtioUnixListener {\n pub trait RtioUnixAcceptor {\n     fn accept(&mut self) -> IoResult<Box<RtioPipe + Send>>;\n     fn set_timeout(&mut self, timeout: Option<u64>);\n+    fn clone(&self) -> Box<RtioUnixAcceptor + Send>;\n+    fn close_accept(&mut self) -> IoResult<()>;\n }\n \n pub trait RtioTTY {"}, {"sha": "290293cf086c17968b3a82396d20705c5f80db15", "filename": "src/librustuv/access.rs", "status": "modified", "additions": 48, "deletions": 16, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/83804f90852f51f043d3011657ba20c1876d2111/src%2Flibrustuv%2Faccess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83804f90852f51f043d3011657ba20c1876d2111/src%2Flibrustuv%2Faccess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Faccess.rs?ref=83804f90852f51f043d3011657ba20c1876d2111", "patch": "@@ -22,38 +22,40 @@ use std::cell::UnsafeCell;\n \n use homing::HomingMissile;\n \n-pub struct Access {\n-    inner: Arc<UnsafeCell<Inner>>,\n+pub struct Access<T> {\n+    inner: Arc<UnsafeCell<Inner<T>>>,\n }\n \n-pub struct Guard<'a> {\n-    access: &'a mut Access,\n+pub struct Guard<'a, T> {\n+    access: &'a mut Access<T>,\n     missile: Option<HomingMissile>,\n }\n \n-struct Inner {\n+struct Inner<T> {\n     queue: Vec<(BlockedTask, uint)>,\n     held: bool,\n     closed: bool,\n+    data: T,\n }\n \n-impl Access {\n-    pub fn new() -> Access {\n+impl<T: Send> Access<T> {\n+    pub fn new(data: T) -> Access<T> {\n         Access {\n             inner: Arc::new(UnsafeCell::new(Inner {\n                 queue: vec![],\n                 held: false,\n                 closed: false,\n+                data: data,\n             }))\n         }\n     }\n \n     pub fn grant<'a>(&'a mut self, token: uint,\n-                     missile: HomingMissile) -> Guard<'a> {\n+                     missile: HomingMissile) -> Guard<'a, T> {\n         // This unsafety is actually OK because the homing missile argument\n         // guarantees that we're on the same event loop as all the other objects\n         // attempting to get access granted.\n-        let inner: &mut Inner = unsafe { &mut *self.inner.get() };\n+        let inner = unsafe { &mut *self.inner.get() };\n \n         if inner.held {\n             let t: Box<Task> = Local::take();\n@@ -69,6 +71,15 @@ impl Access {\n         Guard { access: self, missile: Some(missile) }\n     }\n \n+    pub fn unsafe_get(&self) -> *mut T {\n+        unsafe { &mut (*self.inner.get()).data  as *mut _ }\n+    }\n+\n+    // Safe version which requires proof that you are on the home scheduler.\n+    pub fn get_mut<'a>(&'a mut self, _missile: &HomingMissile) -> &'a mut T {\n+        unsafe { &mut *self.unsafe_get() }\n+    }\n+\n     pub fn close(&self, _missile: &HomingMissile) {\n         // This unsafety is OK because with a homing missile we're guaranteed to\n         // be the only task looking at the `closed` flag (and are therefore\n@@ -82,35 +93,55 @@ impl Access {\n     // is only safe to invoke while on the home event loop, and there is no\n     // guarantee that this i being invoked on the home event loop.\n     pub unsafe fn dequeue(&mut self, token: uint) -> Option<BlockedTask> {\n-        let inner: &mut Inner = &mut *self.inner.get();\n+        let inner = &mut *self.inner.get();\n         match inner.queue.iter().position(|&(_, t)| t == token) {\n             Some(i) => Some(inner.queue.remove(i).unwrap().val0()),\n             None => None,\n         }\n     }\n+\n+    /// Test whether this access is closed, using a homing missile to prove\n+    /// that it's safe\n+    pub fn is_closed(&self, _missile: &HomingMissile) -> bool {\n+        unsafe { (*self.inner.get()).closed }\n+    }\n }\n \n-impl Clone for Access {\n-    fn clone(&self) -> Access {\n+impl<T: Send> Clone for Access<T> {\n+    fn clone(&self) -> Access<T> {\n         Access { inner: self.inner.clone() }\n     }\n }\n \n-impl<'a> Guard<'a> {\n+impl<'a, T: Send> Guard<'a, T> {\n     pub fn is_closed(&self) -> bool {\n         // See above for why this unsafety is ok, it just applies to the read\n         // instead of the write.\n         unsafe { (*self.access.inner.get()).closed }\n     }\n }\n \n+impl<'a, T: Send> Deref<T> for Guard<'a, T> {\n+    fn deref<'a>(&'a self) -> &'a T {\n+        // A guard represents exclusive access to a piece of data, so it's safe\n+        // to hand out shared and mutable references\n+        unsafe { &(*self.access.inner.get()).data }\n+    }\n+}\n+\n+impl<'a, T: Send> DerefMut<T> for Guard<'a, T> {\n+    fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n+        unsafe { &mut (*self.access.inner.get()).data }\n+    }\n+}\n+\n #[unsafe_destructor]\n-impl<'a> Drop for Guard<'a> {\n+impl<'a, T> Drop for Guard<'a, T> {\n     fn drop(&mut self) {\n         // This guard's homing missile is still armed, so we're guaranteed to be\n         // on the same I/O event loop, so this unsafety should be ok.\n         assert!(self.missile.is_some());\n-        let inner: &mut Inner = unsafe {\n+        let inner: &mut Inner<T> = unsafe {\n             mem::transmute(self.access.inner.get())\n         };\n \n@@ -133,7 +164,8 @@ impl<'a> Drop for Guard<'a> {\n     }\n }\n \n-impl Drop for Inner {\n+#[unsafe_destructor]\n+impl<T> Drop for Inner<T> {\n     fn drop(&mut self) {\n         assert!(!self.held);\n         assert_eq!(self.queue.len(), 0);"}, {"sha": "84ef9deaf922fd3555dfed54e55a9a76bf049e2d", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 68, "deletions": 35, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/83804f90852f51f043d3011657ba20c1876d2111/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83804f90852f51f043d3011657ba20c1876d2111/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=83804f90852f51f043d3011657ba20c1876d2111", "patch": "@@ -22,7 +22,7 @@ use stream::StreamWatcher;\n use super::{Loop, Request, UvError, Buf, status_to_io_result,\n             uv_error_to_io_error, UvHandle, slice_to_uv_buf,\n             wait_until_woken_after, wakeup};\n-use timeout::{AccessTimeout, AcceptTimeout, ConnectCtx};\n+use timeout::{AccessTimeout, ConnectCtx, AcceptTimeout};\n use uvio::UvIoFactory;\n use uvll;\n \n@@ -158,20 +158,20 @@ pub struct TcpWatcher {\n     // stream object, so we use these access guards in order to arbitrate among\n     // multiple concurrent reads and writes. Note that libuv *can* read and\n     // write simultaneously, it just can't read and read simultaneously.\n-    read_access: AccessTimeout,\n-    write_access: AccessTimeout,\n+    read_access: AccessTimeout<()>,\n+    write_access: AccessTimeout<()>,\n }\n \n pub struct TcpListener {\n     home: HomeHandle,\n-    handle: *mut uvll::uv_pipe_t,\n-    outgoing: Sender<Result<Box<rtio::RtioTcpStream + Send>, IoError>>,\n-    incoming: Receiver<Result<Box<rtio::RtioTcpStream + Send>, IoError>>,\n+    handle: *mut uvll::uv_tcp_t,\n }\n \n pub struct TcpAcceptor {\n-    listener: Box<TcpListener>,\n-    timeout: AcceptTimeout,\n+    home: HomeHandle,\n+    handle: *mut uvll::uv_tcp_t,\n+    access: AcceptTimeout<Box<rtio::RtioTcpStream + Send>>,\n+    refcount: Refcount,\n }\n \n // TCP watchers (clients/streams)\n@@ -192,8 +192,8 @@ impl TcpWatcher {\n             handle: handle,\n             stream: StreamWatcher::new(handle, true),\n             refcount: Refcount::new(),\n-            read_access: AccessTimeout::new(),\n-            write_access: AccessTimeout::new(),\n+            read_access: AccessTimeout::new(()),\n+            write_access: AccessTimeout::new(()),\n         }\n     }\n \n@@ -291,7 +291,7 @@ impl rtio::RtioTcpStream for TcpWatcher {\n         let task = {\n             let m = self.fire_homing_missile();\n             self.read_access.access.close(&m);\n-    self.stream.cancel_read(uvll::EOF as libc::ssize_t)\n+            self.stream.cancel_read(uvll::EOF as libc::ssize_t)\n         };\n         let _ = task.map(|t| t.reawaken());\n         Ok(())\n@@ -354,12 +354,9 @@ impl TcpListener {\n         assert_eq!(unsafe {\n             uvll::uv_tcp_init(io.uv_loop(), handle)\n         }, 0);\n-        let (tx, rx) = channel();\n         let l = box TcpListener {\n             home: io.make_handle(),\n             handle: handle,\n-            outgoing: tx,\n-            incoming: rx,\n         };\n         let mut storage = unsafe { mem::zeroed() };\n         let _len = addr_to_sockaddr(address, &mut storage);\n@@ -390,17 +387,21 @@ impl rtio::RtioSocket for TcpListener {\n }\n \n impl rtio::RtioTcpListener for TcpListener {\n-    fn listen(self: Box<TcpListener>)\n+    fn listen(mut self: Box<TcpListener>)\n               -> Result<Box<rtio::RtioTcpAcceptor + Send>, IoError> {\n+        let _m = self.fire_homing_missile();\n+\n         // create the acceptor object from ourselves\n-        let mut acceptor = box TcpAcceptor {\n-            listener: self,\n-            timeout: AcceptTimeout::new(),\n-        };\n+        let acceptor = (box TcpAcceptor {\n+            handle: self.handle,\n+            home: self.home.clone(),\n+            access: AcceptTimeout::new(),\n+            refcount: Refcount::new(),\n+        }).install();\n+        self.handle = 0 as *mut _;\n \n-        let _m = acceptor.fire_homing_missile();\n         // FIXME: the 128 backlog should be configurable\n-        match unsafe { uvll::uv_listen(acceptor.listener.handle, 128, listen_cb) } {\n+        match unsafe { uvll::uv_listen(acceptor.handle, 128, listen_cb) } {\n             0 => Ok(acceptor as Box<rtio::RtioTcpAcceptor + Send>),\n             n => Err(uv_error_to_io_error(UvError(n))),\n         }\n@@ -409,7 +410,7 @@ impl rtio::RtioTcpListener for TcpListener {\n \n extern fn listen_cb(server: *mut uvll::uv_stream_t, status: c_int) {\n     assert!(status != uvll::ECANCELED);\n-    let tcp: &mut TcpListener = unsafe { UvHandle::from_uv_handle(&server) };\n+    let tcp: &mut TcpAcceptor = unsafe { UvHandle::from_uv_handle(&server) };\n     let msg = match status {\n         0 => {\n             let loop_ = Loop::wrap(unsafe {\n@@ -421,11 +422,15 @@ extern fn listen_cb(server: *mut uvll::uv_stream_t, status: c_int) {\n         }\n         n => Err(uv_error_to_io_error(UvError(n)))\n     };\n-    tcp.outgoing.send(msg);\n+\n+    // If we're running then we have exclusive access, so the unsafe_get() is ok\n+    unsafe { tcp.access.push(msg); }\n }\n \n impl Drop for TcpListener {\n     fn drop(&mut self) {\n+        if self.handle.is_null() { return }\n+\n         let _m = self.fire_homing_missile();\n         self.close();\n     }\n@@ -434,40 +439,68 @@ impl Drop for TcpListener {\n // TCP acceptors (bound servers)\n \n impl HomingIO for TcpAcceptor {\n-    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { self.listener.home() }\n+    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.home }\n }\n \n impl rtio::RtioSocket for TcpAcceptor {\n     fn socket_name(&mut self) -> Result<rtio::SocketAddr, IoError> {\n         let _m = self.fire_homing_missile();\n-        socket_name(Tcp, self.listener.handle)\n+        socket_name(Tcp, self.handle)\n     }\n }\n \n+impl UvHandle<uvll::uv_tcp_t> for TcpAcceptor {\n+    fn uv_handle(&self) -> *mut uvll::uv_tcp_t { self.handle }\n+}\n+\n impl rtio::RtioTcpAcceptor for TcpAcceptor {\n     fn accept(&mut self) -> Result<Box<rtio::RtioTcpStream + Send>, IoError> {\n-        self.timeout.accept(&self.listener.incoming)\n+        let m = self.fire_homing_missile();\n+        let loop_ = self.uv_loop();\n+        self.access.accept(m, &loop_)\n     }\n \n     fn accept_simultaneously(&mut self) -> Result<(), IoError> {\n         let _m = self.fire_homing_missile();\n         status_to_io_result(unsafe {\n-            uvll::uv_tcp_simultaneous_accepts(self.listener.handle, 1)\n+            uvll::uv_tcp_simultaneous_accepts(self.handle, 1)\n         })\n     }\n \n     fn dont_accept_simultaneously(&mut self) -> Result<(), IoError> {\n         let _m = self.fire_homing_missile();\n         status_to_io_result(unsafe {\n-            uvll::uv_tcp_simultaneous_accepts(self.listener.handle, 0)\n+            uvll::uv_tcp_simultaneous_accepts(self.handle, 0)\n         })\n     }\n \n     fn set_timeout(&mut self, ms: Option<u64>) {\n         let _m = self.fire_homing_missile();\n-        match ms {\n-            None => self.timeout.clear(),\n-            Some(ms) => self.timeout.set_timeout(ms, &mut *self.listener),\n+        let loop_ = self.uv_loop();\n+        self.access.set_timeout(ms, &loop_, &self.home);\n+    }\n+\n+    fn clone(&self) -> Box<rtio::RtioTcpAcceptor + Send> {\n+        box TcpAcceptor {\n+            refcount: self.refcount.clone(),\n+            home: self.home.clone(),\n+            handle: self.handle,\n+            access: self.access.clone(),\n+        } as Box<rtio::RtioTcpAcceptor + Send>\n+    }\n+\n+    fn close_accept(&mut self) -> Result<(), IoError> {\n+        let m = self.fire_homing_missile();\n+        self.access.close(m);\n+        Ok(())\n+    }\n+}\n+\n+impl Drop for TcpAcceptor {\n+    fn drop(&mut self) {\n+        let _m = self.fire_homing_missile();\n+        if self.refcount.decrement() {\n+            self.close();\n         }\n     }\n }\n@@ -482,8 +515,8 @@ pub struct UdpWatcher {\n \n     // See above for what these fields are\n     refcount: Refcount,\n-    read_access: AccessTimeout,\n-    write_access: AccessTimeout,\n+    read_access: AccessTimeout<()>,\n+    write_access: AccessTimeout<()>,\n \n     blocked_sender: Option<BlockedTask>,\n }\n@@ -507,8 +540,8 @@ impl UdpWatcher {\n             handle: unsafe { uvll::malloc_handle(uvll::UV_UDP) },\n             home: io.make_handle(),\n             refcount: Refcount::new(),\n-            read_access: AccessTimeout::new(),\n-            write_access: AccessTimeout::new(),\n+            read_access: AccessTimeout::new(()),\n+            write_access: AccessTimeout::new(()),\n             blocked_sender: None,\n         };\n         assert_eq!(unsafe {"}, {"sha": "9ece6525e1e82b07239e342a0e54a6811d4c76fa", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 61, "deletions": 27, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/83804f90852f51f043d3011657ba20c1876d2111/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83804f90852f51f043d3011657ba20c1876d2111/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=83804f90852f51f043d3011657ba20c1876d2111", "patch": "@@ -31,20 +31,20 @@ pub struct PipeWatcher {\n     refcount: Refcount,\n \n     // see comments in TcpWatcher for why these exist\n-    write_access: AccessTimeout,\n-    read_access: AccessTimeout,\n+    write_access: AccessTimeout<()>,\n+    read_access: AccessTimeout<()>,\n }\n \n pub struct PipeListener {\n     home: HomeHandle,\n     pipe: *mut uvll::uv_pipe_t,\n-    outgoing: Sender<IoResult<Box<rtio::RtioPipe + Send>>>,\n-    incoming: Receiver<IoResult<Box<rtio::RtioPipe + Send>>>,\n }\n \n pub struct PipeAcceptor {\n-    listener: Box<PipeListener>,\n-    timeout: AcceptTimeout,\n+    home: HomeHandle,\n+    handle: *mut uvll::uv_pipe_t,\n+    access: AcceptTimeout<Box<rtio::RtioPipe + Send>>,\n+    refcount: Refcount,\n }\n \n // PipeWatcher implementation and traits\n@@ -71,8 +71,8 @@ impl PipeWatcher {\n             home: home,\n             defused: false,\n             refcount: Refcount::new(),\n-            read_access: AccessTimeout::new(),\n-            write_access: AccessTimeout::new(),\n+            read_access: AccessTimeout::new(()),\n+            write_access: AccessTimeout::new(()),\n         }\n     }\n \n@@ -233,12 +233,9 @@ impl PipeListener {\n                 // If successful, unwrap the PipeWatcher because we control how\n                 // we close the pipe differently. We can't rely on\n                 // StreamWatcher's default close method.\n-                let (tx, rx) = channel();\n                 let p = box PipeListener {\n                     home: io.make_handle(),\n                     pipe: pipe.unwrap(),\n-                    incoming: rx,\n-                    outgoing: tx,\n                 };\n                 Ok(p.install())\n             }\n@@ -248,17 +245,21 @@ impl PipeListener {\n }\n \n impl rtio::RtioUnixListener for PipeListener {\n-    fn listen(self: Box<PipeListener>)\n+    fn listen(mut self: Box<PipeListener>)\n               -> IoResult<Box<rtio::RtioUnixAcceptor + Send>> {\n+        let _m = self.fire_homing_missile();\n+\n         // create the acceptor object from ourselves\n-        let mut acceptor = box PipeAcceptor {\n-            listener: self,\n-            timeout: AcceptTimeout::new(),\n-        };\n+        let acceptor = (box PipeAcceptor {\n+            handle: self.pipe,\n+            home: self.home.clone(),\n+            access: AcceptTimeout::new(),\n+            refcount: Refcount::new(),\n+        }).install();\n+        self.pipe = 0 as *mut _;\n \n-        let _m = acceptor.fire_homing_missile();\n         // FIXME: the 128 backlog should be configurable\n-        match unsafe { uvll::uv_listen(acceptor.listener.pipe, 128, listen_cb) } {\n+        match unsafe { uvll::uv_listen(acceptor.handle, 128, listen_cb) } {\n             0 => Ok(acceptor as Box<rtio::RtioUnixAcceptor + Send>),\n             n => Err(uv_error_to_io_error(UvError(n))),\n         }\n@@ -276,7 +277,7 @@ impl UvHandle<uvll::uv_pipe_t> for PipeListener {\n extern fn listen_cb(server: *mut uvll::uv_stream_t, status: libc::c_int) {\n     assert!(status != uvll::ECANCELED);\n \n-    let pipe: &mut PipeListener = unsafe { UvHandle::from_uv_handle(&server) };\n+    let pipe: &mut PipeAcceptor = unsafe { UvHandle::from_uv_handle(&server) };\n     let msg = match status {\n         0 => {\n             let loop_ = Loop::wrap(unsafe {\n@@ -288,11 +289,15 @@ extern fn listen_cb(server: *mut uvll::uv_stream_t, status: libc::c_int) {\n         }\n         n => Err(uv_error_to_io_error(UvError(n)))\n     };\n-    pipe.outgoing.send(msg);\n+\n+    // If we're running then we have exclusive access, so the unsafe_get() is ok\n+    unsafe { pipe.access.push(msg); }\n }\n \n impl Drop for PipeListener {\n     fn drop(&mut self) {\n+        if self.pipe.is_null() { return }\n+\n         let _m = self.fire_homing_missile();\n         self.close();\n     }\n@@ -302,19 +307,48 @@ impl Drop for PipeListener {\n \n impl rtio::RtioUnixAcceptor for PipeAcceptor {\n     fn accept(&mut self) -> IoResult<Box<rtio::RtioPipe + Send>> {\n-        self.timeout.accept(&self.listener.incoming)\n+        let m = self.fire_homing_missile();\n+        let loop_ = self.uv_loop();\n+        self.access.accept(m, &loop_)\n     }\n \n-    fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n-        match timeout_ms {\n-            None => self.timeout.clear(),\n-            Some(ms) => self.timeout.set_timeout(ms, &mut *self.listener),\n-        }\n+    fn set_timeout(&mut self, ms: Option<u64>) {\n+        let _m = self.fire_homing_missile();\n+        let loop_ = self.uv_loop();\n+        self.access.set_timeout(ms, &loop_, &self.home);\n+    }\n+\n+    fn clone(&self) -> Box<rtio::RtioUnixAcceptor + Send> {\n+        box PipeAcceptor {\n+            refcount: self.refcount.clone(),\n+            home: self.home.clone(),\n+            handle: self.handle,\n+            access: self.access.clone(),\n+        } as Box<rtio::RtioUnixAcceptor + Send>\n+    }\n+\n+    fn close_accept(&mut self) -> IoResult<()> {\n+        let m = self.fire_homing_missile();\n+        self.access.close(m);\n+        Ok(())\n     }\n }\n \n impl HomingIO for PipeAcceptor {\n-    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.listener.home }\n+    fn home<'r>(&'r mut self) -> &'r mut HomeHandle { &mut self.home }\n+}\n+\n+impl UvHandle<uvll::uv_pipe_t> for PipeAcceptor {\n+    fn uv_handle(&self) -> *mut uvll::uv_pipe_t { self.handle }\n+}\n+\n+impl Drop for PipeAcceptor {\n+    fn drop(&mut self) {\n+        let _m = self.fire_homing_missile();\n+        if self.refcount.decrement() {\n+            self.close();\n+        }\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "32d7395241675ca02a03eae5a0f3ba34e5f3bf04", "filename": "src/librustuv/timeout.rs", "status": "modified", "additions": 115, "deletions": 97, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/83804f90852f51f043d3011657ba20c1876d2111/src%2Flibrustuv%2Ftimeout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83804f90852f51f043d3011657ba20c1876d2111/src%2Flibrustuv%2Ftimeout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimeout.rs?ref=83804f90852f51f043d3011657ba20c1876d2111", "patch": "@@ -14,23 +14,23 @@ use std::rt::task::BlockedTask;\n use std::rt::rtio::IoResult;\n \n use access;\n-use homing::{HomeHandle, HomingMissile, HomingIO};\n+use homing::{HomeHandle, HomingMissile};\n use timer::TimerWatcher;\n use uvll;\n use uvio::UvIoFactory;\n use {Loop, UvError, uv_error_to_io_error, Request, wakeup};\n use {UvHandle, wait_until_woken_after};\n \n /// Management of a timeout when gaining access to a portion of a duplex stream.\n-pub struct AccessTimeout {\n+pub struct AccessTimeout<T> {\n     state: TimeoutState,\n     timer: Option<Box<TimerWatcher>>,\n-    pub access: access::Access,\n+    pub access: access::Access<T>,\n }\n \n-pub struct Guard<'a> {\n+pub struct Guard<'a, T> {\n     state: &'a mut TimeoutState,\n-    pub access: access::Guard<'a>,\n+    pub access: access::Guard<'a, T>,\n     pub can_timeout: bool,\n }\n \n@@ -49,17 +49,18 @@ enum ClientState {\n }\n \n struct TimerContext {\n-    timeout: *mut AccessTimeout,\n-    callback: fn(uint) -> Option<BlockedTask>,\n-    payload: uint,\n+    timeout: *mut AccessTimeout<()>,\n+    callback: fn(*mut AccessTimeout<()>, &TimerContext),\n+    user_unblock: fn(uint) -> Option<BlockedTask>,\n+    user_payload: uint,\n }\n \n-impl AccessTimeout {\n-    pub fn new() -> AccessTimeout {\n+impl<T: Send> AccessTimeout<T> {\n+    pub fn new(data: T) -> AccessTimeout<T> {\n         AccessTimeout {\n             state: NoTimeout,\n             timer: None,\n-            access: access::Access::new(),\n+            access: access::Access::new(data),\n         }\n     }\n \n@@ -68,7 +69,7 @@ impl AccessTimeout {\n     /// On success, Ok(Guard) is returned and access has been granted to the\n     /// stream. If a timeout occurs, then Err is returned with an appropriate\n     /// error.\n-    pub fn grant<'a>(&'a mut self, m: HomingMissile) -> IoResult<Guard<'a>> {\n+    pub fn grant<'a>(&'a mut self, m: HomingMissile) -> IoResult<Guard<'a, T>> {\n         // First, flag that we're attempting to acquire access. This will allow\n         // us to cancel the pending grant if we timeout out while waiting for a\n         // grant.\n@@ -94,6 +95,13 @@ impl AccessTimeout {\n         })\n     }\n \n+    pub fn timed_out(&self) -> bool {\n+        match self.state {\n+            TimedOut => true,\n+            _ => false,\n+        }\n+    }\n+\n     /// Sets the pending timeout to the value specified.\n     ///\n     /// The home/loop variables are used to construct a timer if one has not\n@@ -120,9 +128,10 @@ impl AccessTimeout {\n         if self.timer.is_none() {\n             let mut timer = box TimerWatcher::new_home(loop_, home.clone());\n             let mut cx = box TimerContext {\n-                timeout: self as *mut _,\n-                callback: cb,\n-                payload: data,\n+                timeout: self as *mut _ as *mut AccessTimeout<()>,\n+                callback: real_cb::<T>,\n+                user_unblock: cb,\n+                user_payload: data,\n             };\n             unsafe {\n                 timer.set_data(&mut *cx);\n@@ -135,8 +144,8 @@ impl AccessTimeout {\n         unsafe {\n             let cx = uvll::get_data_for_uv_handle(timer.handle);\n             let cx = cx as *mut TimerContext;\n-            (*cx).callback = cb;\n-            (*cx).payload = data;\n+            (*cx).user_unblock = cb;\n+            (*cx).user_payload = data;\n         }\n         timer.stop();\n         timer.start(timer_cb, ms, 0);\n@@ -146,7 +155,12 @@ impl AccessTimeout {\n             let cx: &TimerContext = unsafe {\n                 &*(uvll::get_data_for_uv_handle(timer) as *const TimerContext)\n             };\n-            let me = unsafe { &mut *cx.timeout };\n+            (cx.callback)(cx.timeout, cx);\n+        }\n+\n+        fn real_cb<T: Send>(timeout: *mut AccessTimeout<()>, cx: &TimerContext) {\n+            let timeout = timeout as *mut AccessTimeout<T>;\n+            let me = unsafe { &mut *timeout };\n \n             match mem::replace(&mut me.state, TimedOut) {\n                 TimedOut | NoTimeout => unreachable!(),\n@@ -158,7 +172,7 @@ impl AccessTimeout {\n                     }\n                 }\n                 TimeoutPending(RequestPending) => {\n-                    match (cx.callback)(cx.payload) {\n+                    match (cx.user_unblock)(cx.user_payload) {\n                         Some(task) => task.reawaken(),\n                         None => unreachable!(),\n                     }\n@@ -168,8 +182,8 @@ impl AccessTimeout {\n     }\n }\n \n-impl Clone for AccessTimeout {\n-    fn clone(&self) -> AccessTimeout {\n+impl<T: Send> Clone for AccessTimeout<T> {\n+    fn clone(&self) -> AccessTimeout<T> {\n         AccessTimeout {\n             access: self.access.clone(),\n             state: NoTimeout,\n@@ -179,7 +193,7 @@ impl Clone for AccessTimeout {\n }\n \n #[unsafe_destructor]\n-impl<'a> Drop for Guard<'a> {\n+impl<'a, T> Drop for Guard<'a, T> {\n     fn drop(&mut self) {\n         match *self.state {\n             TimeoutPending(NoWaiter) | TimeoutPending(AccessPending) =>\n@@ -193,7 +207,8 @@ impl<'a> Drop for Guard<'a> {\n     }\n }\n \n-impl Drop for AccessTimeout {\n+#[unsafe_destructor]\n+impl<T> Drop for AccessTimeout<T> {\n     fn drop(&mut self) {\n         match self.timer {\n             Some(ref timer) => unsafe {\n@@ -215,12 +230,6 @@ pub struct ConnectCtx {\n     pub timer: Option<Box<TimerWatcher>>,\n }\n \n-pub struct AcceptTimeout {\n-    timer: Option<TimerWatcher>,\n-    timeout_tx: Option<Sender<()>>,\n-    timeout_rx: Option<Receiver<()>>,\n-}\n-\n impl ConnectCtx {\n     pub fn connect<T>(\n         mut self, obj: T, timeout: Option<u64>, io: &mut UvIoFactory,\n@@ -306,88 +315,97 @@ impl ConnectCtx {\n     }\n }\n \n-impl AcceptTimeout {\n-    pub fn new() -> AcceptTimeout {\n-        AcceptTimeout { timer: None, timeout_tx: None, timeout_rx: None }\n-    }\n+pub struct AcceptTimeout<T> {\n+    access: AccessTimeout<AcceptorState<T>>,\n+}\n \n-    pub fn accept<T: Send>(&mut self, c: &Receiver<IoResult<T>>) -> IoResult<T> {\n-        match self.timeout_rx {\n-            None => c.recv(),\n-            Some(ref rx) => {\n-                use std::comm::Select;\n-\n-                // Poll the incoming channel first (don't rely on the order of\n-                // select just yet). If someone's pending then we should return\n-                // them immediately.\n-                match c.try_recv() {\n-                    Ok(data) => return data,\n-                    Err(..) => {}\n-                }\n+struct AcceptorState<T> {\n+    blocked_acceptor: Option<BlockedTask>,\n+    pending: Vec<IoResult<T>>,\n+}\n \n-                // Use select to figure out which channel gets ready first. We\n-                // do some custom handling of select to ensure that we never\n-                // actually drain the timeout channel (we'll keep seeing the\n-                // timeout message in the future).\n-                let s = Select::new();\n-                let mut timeout = s.handle(rx);\n-                let mut data = s.handle(c);\n-                unsafe {\n-                    timeout.add();\n-                    data.add();\n-                }\n-                if s.wait() == timeout.id() {\n-                    Err(uv_error_to_io_error(UvError(uvll::ECANCELED)))\n-                } else {\n-                    c.recv()\n-                }\n-            }\n+impl<T: Send> AcceptTimeout<T> {\n+    pub fn new() -> AcceptTimeout<T> {\n+        AcceptTimeout {\n+            access: AccessTimeout::new(AcceptorState {\n+                blocked_acceptor: None,\n+                pending: Vec::new(),\n+            })\n         }\n     }\n \n-    pub fn clear(&mut self) {\n-        match self.timeout_rx {\n-            Some(ref t) => { let _ = t.try_recv(); }\n-            None => {}\n+    pub fn accept(&mut self,\n+                  missile: HomingMissile,\n+                  loop_: &Loop) -> IoResult<T> {\n+        // If we've timed out but we're not closed yet, poll the state of the\n+        // queue to see if we can peel off a connection.\n+        if self.access.timed_out() && !self.access.access.is_closed(&missile) {\n+            let tmp = self.access.access.get_mut(&missile);\n+            return match tmp.pending.remove(0) {\n+                Some(msg) => msg,\n+                None => Err(uv_error_to_io_error(UvError(uvll::ECANCELED)))\n+            }\n         }\n-        match self.timer {\n-            Some(ref mut t) => t.stop(),\n+\n+        // Now that we're not polling, attempt to gain access and then peel off\n+        // a connection. If we have no pending connections, then we need to go\n+        // to sleep and wait for one.\n+        //\n+        // Note that if we're woken up for a pending connection then we're\n+        // guaranteed that the check above will not steal our connection due to\n+        // the single-threaded nature of the event loop.\n+        let mut guard = try!(self.access.grant(missile));\n+        if guard.access.is_closed() {\n+            return Err(uv_error_to_io_error(UvError(uvll::EOF)))\n+        }\n+\n+        match guard.access.pending.remove(0) {\n+            Some(msg) => return msg,\n             None => {}\n         }\n+\n+        wait_until_woken_after(&mut guard.access.blocked_acceptor, loop_, || {});\n+\n+        match guard.access.pending.remove(0) {\n+            _ if guard.access.is_closed() => {\n+                Err(uv_error_to_io_error(UvError(uvll::EOF)))\n+            }\n+            Some(msg) => msg,\n+            None => Err(uv_error_to_io_error(UvError(uvll::ECANCELED)))\n+        }\n     }\n \n-    pub fn set_timeout<U, T: UvHandle<U> + HomingIO>(\n-        &mut self, ms: u64, t: &mut T\n-    ) {\n-        // If we have a timeout, lazily initialize the timer which will be used\n-        // to fire when the timeout runs out.\n-        if self.timer.is_none() {\n-            let loop_ = Loop::wrap(unsafe {\n-                uvll::get_loop_for_uv_handle(t.uv_handle())\n-            });\n-            let mut timer = TimerWatcher::new_home(&loop_, t.home().clone());\n+    pub unsafe fn push(&mut self, t: IoResult<T>) {\n+        let state = self.access.access.unsafe_get();\n+        (*state).pending.push(t);\n+        let _ = (*state).blocked_acceptor.take().map(|t| t.reawaken());\n+    }\n+\n+    pub fn set_timeout(&mut self,\n+                       ms: Option<u64>,\n+                       loop_: &Loop,\n+                       home: &HomeHandle) {\n+        self.access.set_timeout(ms, home, loop_, cancel_accept::<T>,\n+                                self as *mut _ as uint);\n+\n+        fn cancel_accept<T: Send>(me: uint) -> Option<BlockedTask> {\n             unsafe {\n-                timer.set_data(self as *mut _);\n+                let me: &mut AcceptTimeout<T> = mem::transmute(me);\n+                (*me.access.access.unsafe_get()).blocked_acceptor.take()\n             }\n-            self.timer = Some(timer);\n         }\n+    }\n \n-        // Once we've got a timer, stop any previous timeout, reset it for the\n-        // current one, and install some new channels to send/receive data on\n-        let timer = self.timer.get_mut_ref();\n-        timer.stop();\n-        timer.start(timer_cb, ms, 0);\n-        let (tx, rx) = channel();\n-        self.timeout_tx = Some(tx);\n-        self.timeout_rx = Some(rx);\n+    pub fn close(&mut self, m: HomingMissile) {\n+        self.access.access.close(&m);\n+        let task = self.access.access.get_mut(&m).blocked_acceptor.take();\n+        drop(m);\n+        let _ = task.map(|t| t.reawaken());\n+    }\n+}\n \n-        extern fn timer_cb(timer: *mut uvll::uv_timer_t) {\n-            let acceptor: &mut AcceptTimeout = unsafe {\n-                &mut *(uvll::get_data_for_uv_handle(timer) as *mut AcceptTimeout)\n-            };\n-            // This send can never fail because if this timer is active then the\n-            // receiving channel is guaranteed to be alive\n-            acceptor.timeout_tx.get_ref().send(());\n-        }\n+impl<T: Send> Clone for AcceptTimeout<T> {\n+    fn clone(&self) -> AcceptTimeout<T> {\n+        AcceptTimeout { access: self.access.clone() }\n     }\n }"}, {"sha": "a6fdceaa3739fc75d23c435bc4ef82e2e185b980", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/83804f90852f51f043d3011657ba20c1876d2111/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83804f90852f51f043d3011657ba20c1876d2111/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=83804f90852f51f043d3011657ba20c1876d2111", "patch": "@@ -442,6 +442,53 @@ impl TcpAcceptor {\n     #[experimental = \"the type of the argument and name of this function are \\\n                       subject to change\"]\n     pub fn set_timeout(&mut self, ms: Option<u64>) { self.obj.set_timeout(ms); }\n+\n+    /// Closes the accepting capabilities of this acceptor.\n+    ///\n+    /// This function is similar to `TcpStream`'s `close_{read,write}` methods\n+    /// in that it will affect *all* cloned handles of this acceptor's original\n+    /// handle.\n+    ///\n+    /// Once this function succeeds, all future calls to `accept` will return\n+    /// immediately with an error, preventing all future calls to accept. The\n+    /// underlying socket will not be relinquished back to the OS until all\n+    /// acceptors have been deallocated.\n+    ///\n+    /// This is useful for waking up a thread in an accept loop to indicate that\n+    /// it should exit.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # #![allow(experimental)]\n+    /// use std::io::{TcpListener, Listener, Acceptor, EndOfFile};\n+    ///\n+    /// let mut a = TcpListener::bind(\"127.0.0.1\", 8482).listen().unwrap();\n+    /// let a2 = a.clone();\n+    ///\n+    /// spawn(proc() {\n+    ///     let mut a2 = a2;\n+    ///     for socket in a2.incoming() {\n+    ///         match socket {\n+    ///             Ok(s) => { /* handle s */ }\n+    ///             Err(ref e) if e.kind == EndOfFile => break, // closed\n+    ///             Err(e) => fail!(\"unexpected error: {}\", e),\n+    ///         }\n+    ///     }\n+    /// });\n+    ///\n+    /// # fn wait_for_sigint() {}\n+    /// // Now that our accept loop is running, wait for the program to be\n+    /// // requested to exit.\n+    /// wait_for_sigint();\n+    ///\n+    /// // Signal our accept loop to exit\n+    /// assert!(a.close_accept().is_ok());\n+    /// ```\n+    #[experimental]\n+    pub fn close_accept(&mut self) -> IoResult<()> {\n+        self.obj.close_accept().map_err(IoError::from_rtio_error)\n+    }\n }\n \n impl Acceptor<TcpStream> for TcpAcceptor {\n@@ -453,6 +500,25 @@ impl Acceptor<TcpStream> for TcpAcceptor {\n     }\n }\n \n+impl Clone for TcpAcceptor {\n+    /// Creates a new handle to this TCP acceptor, allowing for simultaneous\n+    /// accepts.\n+    ///\n+    /// The underlying TCP acceptor will not be closed until all handles to the\n+    /// acceptor have been deallocated. Incoming connections will be received on\n+    /// at most once acceptor, the same connection will not be accepted twice.\n+    ///\n+    /// The `close_accept` method will shut down *all* acceptors cloned from the\n+    /// same original acceptor, whereas the `set_timeout` method only affects\n+    /// the selector that it is called on.\n+    ///\n+    /// This function is useful for creating a handle to invoke `close_accept`\n+    /// on to wake up any other task blocked in `accept`.\n+    fn clone(&self) -> TcpAcceptor {\n+        TcpAcceptor { obj: self.obj.clone() }\n+    }\n+}\n+\n #[cfg(test)]\n #[allow(experimental)]\n mod test {\n@@ -1411,4 +1477,69 @@ mod test {\n         rxdone.recv();\n         rxdone.recv();\n     })\n+\n+    iotest!(fn clone_accept_smoke() {\n+        let addr = next_test_ip4();\n+        let l = TcpListener::bind(addr.ip.to_string().as_slice(), addr.port);\n+        let mut a = l.listen().unwrap();\n+        let mut a2 = a.clone();\n+\n+        spawn(proc() {\n+            let _ = TcpStream::connect(addr.ip.to_string().as_slice(), addr.port);\n+        });\n+        spawn(proc() {\n+            let _ = TcpStream::connect(addr.ip.to_string().as_slice(), addr.port);\n+        });\n+\n+        assert!(a.accept().is_ok());\n+        assert!(a2.accept().is_ok());\n+    })\n+\n+    iotest!(fn clone_accept_concurrent() {\n+        let addr = next_test_ip4();\n+        let l = TcpListener::bind(addr.ip.to_string().as_slice(), addr.port);\n+        let a = l.listen().unwrap();\n+        let a2 = a.clone();\n+\n+        let (tx, rx) = channel();\n+        let tx2 = tx.clone();\n+\n+        spawn(proc() { let mut a = a; tx.send(a.accept()) });\n+        spawn(proc() { let mut a = a2; tx2.send(a.accept()) });\n+\n+        spawn(proc() {\n+            let _ = TcpStream::connect(addr.ip.to_string().as_slice(), addr.port);\n+        });\n+        spawn(proc() {\n+            let _ = TcpStream::connect(addr.ip.to_string().as_slice(), addr.port);\n+        });\n+\n+        assert!(rx.recv().is_ok());\n+        assert!(rx.recv().is_ok());\n+    })\n+\n+    iotest!(fn close_accept_smoke() {\n+        let addr = next_test_ip4();\n+        let l = TcpListener::bind(addr.ip.to_string().as_slice(), addr.port);\n+        let mut a = l.listen().unwrap();\n+\n+        a.close_accept().unwrap();\n+        assert_eq!(a.accept().err().unwrap().kind, EndOfFile);\n+    })\n+\n+    iotest!(fn close_accept_concurrent() {\n+        let addr = next_test_ip4();\n+        let l = TcpListener::bind(addr.ip.to_string().as_slice(), addr.port);\n+        let a = l.listen().unwrap();\n+        let mut a2 = a.clone();\n+\n+        let (tx, rx) = channel();\n+        spawn(proc() {\n+            let mut a = a;\n+            tx.send(a.accept());\n+        });\n+        a2.close_accept().unwrap();\n+\n+        assert_eq!(rx.recv().err().unwrap().kind, EndOfFile);\n+    })\n }"}, {"sha": "3bd31c6a839edf2c7e89528b9703ba4885672886", "filename": "src/libstd/io/net/unix.rs", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/83804f90852f51f043d3011657ba20c1876d2111/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83804f90852f51f043d3011657ba20c1876d2111/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Funix.rs?ref=83804f90852f51f043d3011657ba20c1876d2111", "patch": "@@ -212,6 +212,15 @@ impl UnixAcceptor {\n     pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.obj.set_timeout(timeout_ms)\n     }\n+\n+    /// Closes the accepting capabilities of this acceptor.\n+    ///\n+    /// This function has the same semantics as `TcpAcceptor::close_accept`, and\n+    /// more information can be found in that documentation.\n+    #[experimental]\n+    pub fn close_accept(&mut self) -> IoResult<()> {\n+        self.obj.close_accept().map_err(IoError::from_rtio_error)\n+    }\n }\n \n impl Acceptor<UnixStream> for UnixAcceptor {\n@@ -222,6 +231,25 @@ impl Acceptor<UnixStream> for UnixAcceptor {\n     }\n }\n \n+impl Clone for UnixAcceptor {\n+    /// Creates a new handle to this unix acceptor, allowing for simultaneous\n+    /// accepts.\n+    ///\n+    /// The underlying unix acceptor will not be closed until all handles to the\n+    /// acceptor have been deallocated. Incoming connections will be received on\n+    /// at most once acceptor, the same connection will not be accepted twice.\n+    ///\n+    /// The `close_accept` method will shut down *all* acceptors cloned from the\n+    /// same original acceptor, whereas the `set_timeout` method only affects\n+    /// the selector that it is called on.\n+    ///\n+    /// This function is useful for creating a handle to invoke `close_accept`\n+    /// on to wake up any other task blocked in `accept`.\n+    fn clone(&self) -> UnixAcceptor {\n+        UnixAcceptor { obj: self.obj.clone() }\n+    }\n+}\n+\n #[cfg(test)]\n #[allow(experimental)]\n mod tests {\n@@ -702,4 +730,73 @@ mod tests {\n \n         rx2.recv();\n     })\n+\n+    #[cfg(not(windows))]\n+    iotest!(fn clone_accept_smoke() {\n+        let addr = next_test_unix();\n+        let l = UnixListener::bind(&addr);\n+        let mut a = l.listen().unwrap();\n+        let mut a2 = a.clone();\n+\n+        let addr2 = addr.clone();\n+        spawn(proc() {\n+            let _ = UnixStream::connect(&addr2);\n+        });\n+        spawn(proc() {\n+            let _ = UnixStream::connect(&addr);\n+        });\n+\n+        assert!(a.accept().is_ok());\n+        drop(a);\n+        assert!(a2.accept().is_ok());\n+    })\n+\n+    iotest!(fn clone_accept_concurrent() {\n+        let addr = next_test_unix();\n+        let l = UnixListener::bind(&addr);\n+        let a = l.listen().unwrap();\n+        let a2 = a.clone();\n+\n+        let (tx, rx) = channel();\n+        let tx2 = tx.clone();\n+\n+        spawn(proc() { let mut a = a; tx.send(a.accept()) });\n+        spawn(proc() { let mut a = a2; tx2.send(a.accept()) });\n+\n+        let addr2 = addr.clone();\n+        spawn(proc() {\n+            let _ = UnixStream::connect(&addr2);\n+        });\n+        spawn(proc() {\n+            let _ = UnixStream::connect(&addr);\n+        });\n+\n+        assert!(rx.recv().is_ok());\n+        assert!(rx.recv().is_ok());\n+    })\n+\n+    iotest!(fn close_accept_smoke() {\n+        let addr = next_test_unix();\n+        let l = UnixListener::bind(&addr);\n+        let mut a = l.listen().unwrap();\n+\n+        a.close_accept().unwrap();\n+        assert_eq!(a.accept().err().unwrap().kind, EndOfFile);\n+    })\n+\n+    iotest!(fn close_accept_concurrent() {\n+        let addr = next_test_unix();\n+        let l = UnixListener::bind(&addr);\n+        let a = l.listen().unwrap();\n+        let mut a2 = a.clone();\n+\n+        let (tx, rx) = channel();\n+        spawn(proc() {\n+            let mut a = a;\n+            tx.send(a.accept());\n+        });\n+        a2.close_accept().unwrap();\n+\n+        assert_eq!(rx.recv().err().unwrap().kind, EndOfFile);\n+    })\n }"}, {"sha": "b8470ef7b8fac1f5484b011dffa52c11fd049b03", "filename": "src/test/run-pass/tcp-accept-stress.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/83804f90852f51f043d3011657ba20c1876d2111/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83804f90852f51f043d3011657ba20c1876d2111/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs?ref=83804f90852f51f043d3011657ba20c1876d2111", "patch": "@@ -0,0 +1,94 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(phase)]\n+\n+#[phase(plugin)]\n+extern crate green;\n+extern crate native;\n+\n+use std::io::{TcpListener, Listener, Acceptor, EndOfFile, TcpStream};\n+use std::sync::{atomic, Arc};\n+use std::task::TaskBuilder;\n+use native::NativeTaskBuilder;\n+\n+static N: uint = 8;\n+static M: uint = 100;\n+\n+green_start!(main)\n+\n+fn main() {\n+    test();\n+\n+    let (tx, rx) = channel();\n+    TaskBuilder::new().native().spawn(proc() {\n+        tx.send(test());\n+    });\n+    rx.recv();\n+}\n+\n+fn test() {\n+    let mut l = TcpListener::bind(\"127.0.0.1\", 0).unwrap();\n+    let addr = l.socket_name().unwrap();\n+    let mut a = l.listen().unwrap();\n+    let cnt = Arc::new(atomic::AtomicUint::new(0));\n+\n+    let (tx, rx) = channel();\n+    for _ in range(0, N) {\n+        let a = a.clone();\n+        let cnt = cnt.clone();\n+        let tx = tx.clone();\n+        spawn(proc() {\n+            let mut a = a;\n+            let mut mycnt = 0u;\n+            loop {\n+                match a.accept() {\n+                    Ok(..) => {\n+                        mycnt += 1;\n+                        if cnt.fetch_add(1, atomic::SeqCst) == N * M - 1 {\n+                            break\n+                        }\n+                    }\n+                    Err(ref e) if e.kind == EndOfFile => break,\n+                    Err(e) => fail!(\"{}\", e),\n+                }\n+            }\n+            assert!(mycnt > 0);\n+            tx.send(());\n+        });\n+    }\n+\n+    for _ in range(0, N) {\n+        let tx = tx.clone();\n+        spawn(proc() {\n+            for _ in range(0, M) {\n+                let _s = TcpStream::connect(addr.ip.to_string().as_slice(),\n+                                            addr.port).unwrap();\n+            }\n+            tx.send(());\n+        });\n+    }\n+\n+    // wait for senders\n+    assert_eq!(rx.iter().take(N).count(), N);\n+\n+    // wait for one acceptor to die\n+    let _ = rx.recv();\n+\n+    // Notify other receivers should die\n+    a.close_accept().unwrap();\n+\n+    // wait for receivers\n+    assert_eq!(rx.iter().take(N - 1).count(), N - 1);\n+\n+    // Everything should have been accepted.\n+    assert_eq!(cnt.load(atomic::SeqCst), N * M);\n+}\n+"}]}