{"sha": "879eb972adc681cb02b84505760ccebedd7465cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3OWViOTcyYWRjNjgxY2IwMmI4NDUwNTc2MGNjZWJlZGQ3NDY1Y2Q=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2018-05-18T09:48:11Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2018-05-22T14:36:50Z"}, "message": "Add SortedMap to rustc_data_structures.", "tree": {"sha": "907c567dd14ef3d10bf095739f8506936a769bb1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/907c567dd14ef3d10bf095739f8506936a769bb1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/879eb972adc681cb02b84505760ccebedd7465cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/879eb972adc681cb02b84505760ccebedd7465cd", "html_url": "https://github.com/rust-lang/rust/commit/879eb972adc681cb02b84505760ccebedd7465cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/879eb972adc681cb02b84505760ccebedd7465cd/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc", "html_url": "https://github.com/rust-lang/rust/commit/ff8fa5cc69db5567b32ceca1ee4ac0dcfa3a81bc"}], "stats": {"total": 502, "additions": 502, "deletions": 0}, "files": [{"sha": "cd707152af6c28f91b7afda764e2911b97e143d8", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/879eb972adc681cb02b84505760ccebedd7465cd/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/879eb972adc681cb02b84505760ccebedd7465cd/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=879eb972adc681cb02b84505760ccebedd7465cd", "patch": "@@ -73,6 +73,7 @@ pub mod control_flow_graph;\n pub mod flock;\n pub mod sync;\n pub mod owning_ref;\n+pub mod sorted_map;\n \n pub struct OnDrop<F: Fn()>(pub F);\n "}, {"sha": "a8a43ebc1ad554abce252026fcf6cdb190e4f0dc", "filename": "src/librustc_data_structures/sorted_map.rs", "status": "added", "additions": 501, "deletions": 0, "changes": 501, "blob_url": "https://github.com/rust-lang/rust/blob/879eb972adc681cb02b84505760ccebedd7465cd/src%2Flibrustc_data_structures%2Fsorted_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/879eb972adc681cb02b84505760ccebedd7465cd/src%2Flibrustc_data_structures%2Fsorted_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsorted_map.rs?ref=879eb972adc681cb02b84505760ccebedd7465cd", "patch": "@@ -0,0 +1,501 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::borrow::Borrow;\n+use std::cmp::Ordering;\n+use std::convert::From;\n+use std::mem;\n+use std::ops::{RangeBounds, Bound, Index, IndexMut};\n+\n+#[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+pub struct SortedMap<K: Ord, V> {\n+    data: Vec<(K,V)>\n+}\n+\n+impl<K: Ord, V> SortedMap<K, V> {\n+\n+    #[inline]\n+    pub fn new() -> SortedMap<K, V> {\n+        SortedMap {\n+            data: vec![]\n+        }\n+    }\n+\n+    // It is up to the caller to make sure that the elements are sorted by key\n+    // and that there are no duplicates.\n+    #[inline]\n+    pub fn from_presorted_elements(elements: Vec<(K, V)>) -> SortedMap<K, V>\n+    {\n+        debug_assert!(elements.windows(2).all(|w| w[0].0 < w[1].0));\n+\n+        SortedMap {\n+            data: elements\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn insert(&mut self, key: K, mut value: V) -> Option<V> {\n+        let index = self.data.binary_search_by(|&(ref x, _)| x.cmp(&key));\n+\n+        match index {\n+            Ok(index) => {\n+                let mut slot = unsafe {\n+                    self.data.get_unchecked_mut(index)\n+                };\n+                mem::swap(&mut slot.1, &mut value);\n+                Some(value)\n+            }\n+            Err(index) => {\n+                self.data.insert(index, (key, value));\n+                None\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn remove(&mut self, key: &K) -> Option<V> {\n+        let index = self.data.binary_search_by(|&(ref x, _)| x.cmp(key));\n+\n+        match index {\n+            Ok(index) => {\n+                Some(self.data.remove(index).1)\n+            }\n+            Err(_) => {\n+                None\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn get(&self, key: &K) -> Option<&V> {\n+        let index = self.data.binary_search_by(|&(ref x, _)| x.cmp(key));\n+\n+        match index {\n+            Ok(index) => {\n+                unsafe {\n+                    Some(&self.data.get_unchecked(index).1)\n+                }\n+            }\n+            Err(_) => {\n+                None\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn get_mut(&mut self, key: &K) -> Option<&mut V> {\n+        let index = self.data.binary_search_by(|&(ref x, _)| x.cmp(key));\n+\n+        match index {\n+            Ok(index) => {\n+                unsafe {\n+                    Some(&mut self.data.get_unchecked_mut(index).1)\n+                }\n+            }\n+            Err(_) => {\n+                None\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn clear(&mut self) {\n+        self.data.clear();\n+    }\n+\n+    /// Iterate over elements, sorted by key\n+    #[inline]\n+    pub fn iter(&self) -> ::std::slice::Iter<(K, V)> {\n+        self.data.iter()\n+    }\n+\n+    /// Iterate over the keys, sorted\n+    #[inline]\n+    pub fn keys(&self) -> impl Iterator<Item=&K> + ExactSizeIterator {\n+        self.data.iter().map(|&(ref k, _)| k)\n+    }\n+\n+    /// Iterate over values, sorted by key\n+    #[inline]\n+    pub fn values(&self) -> impl Iterator<Item=&V> + ExactSizeIterator {\n+        self.data.iter().map(|&(_, ref v)| v)\n+    }\n+\n+    #[inline]\n+    pub fn len(&self) -> usize {\n+        self.data.len()\n+    }\n+\n+    #[inline]\n+    pub fn range<R>(&self, range: R) -> &[(K, V)]\n+        where R: RangeBounds<K>\n+    {\n+        let (start, end) = self.range_slice_indices(range);\n+        (&self.data[start .. end])\n+    }\n+\n+    #[inline]\n+    pub fn range_mut<R>(&mut self, range: R) -> &mut [(K, V)]\n+        where R: RangeBounds<K>\n+    {\n+        let (start, end) = self.range_slice_indices(range);\n+        (&mut self.data[start .. end])\n+    }\n+\n+    #[inline]\n+    pub fn remove_range<R>(&mut self, range: R)\n+        where R: RangeBounds<K>\n+    {\n+        let (start, end) = self.range_slice_indices(range);\n+        self.data.splice(start .. end, ::std::iter::empty());\n+    }\n+\n+    /// Mutate all keys with the given function `f`. This mutation must not\n+    /// change the sort-order of keys.\n+    #[inline]\n+    pub fn offset_keys<F>(&mut self, f: F)\n+        where F: Fn(&mut K)\n+    {\n+        self.data.iter_mut().map(|&mut (ref mut k, _)| k).for_each(f);\n+    }\n+\n+    // It is up to the caller to make sure that the elements are sorted by key\n+    // and that there are no duplicates.\n+    #[inline]\n+    pub fn insert_presorted(&mut self, mut elements: Vec<(K, V)>) {\n+        if elements.is_empty() {\n+            return\n+        }\n+\n+        debug_assert!(elements.windows(2).all(|w| w[0].0 < w[1].0));\n+\n+        let index = {\n+            let first_element = &elements[0].0;\n+            self.data.binary_search_by(|&(ref x, _)| x.cmp(first_element))\n+        };\n+\n+        let drain = match index {\n+            Ok(index) => {\n+                let mut drain = elements.drain(..);\n+                self.data[index] = drain.next().unwrap();\n+                drain\n+            }\n+            Err(index) => {\n+                if index == self.data.len() ||\n+                   elements.last().unwrap().0 < self.data[index].0 {\n+                    // We can copy the whole range without having to mix with\n+                    // existing elements.\n+                    self.data.splice(index .. index, elements.drain(..));\n+                    return\n+                }\n+\n+                let mut drain = elements.drain(..);\n+                self.data.insert(index, drain.next().unwrap());\n+                drain\n+            }\n+        };\n+\n+        // Insert the rest\n+        for (k, v) in drain {\n+            self.insert(k, v);\n+        }\n+    }\n+\n+    #[inline]\n+    fn range_slice_indices<R>(&self, range: R) -> (usize, usize)\n+        where R: RangeBounds<K>\n+    {\n+        let start = match range.start() {\n+            Bound::Included(ref k) => {\n+                match self.data.binary_search_by(|&(ref x, _)| x.cmp(k)) {\n+                    Ok(index) | Err(index) => index\n+                }\n+            }\n+            Bound::Excluded(ref k) => {\n+                match self.data.binary_search_by(|&(ref x, _)| x.cmp(k)) {\n+                    Ok(index) => index + 1,\n+                    Err(index) => index,\n+                }\n+            }\n+            Bound::Unbounded => 0,\n+        };\n+\n+        let end = match range.end() {\n+            Bound::Included(ref k) => {\n+                match self.data.binary_search_by(|&(ref x, _)| x.cmp(k)) {\n+                    Ok(index) => index + 1,\n+                    Err(index) => index,\n+                }\n+            }\n+            Bound::Excluded(ref k) => {\n+                match self.data.binary_search_by(|&(ref x, _)| x.cmp(k)) {\n+                    Ok(index) | Err(index) => index,\n+                }\n+            }\n+            Bound::Unbounded => self.data.len(),\n+        };\n+\n+        (start, end)\n+    }\n+}\n+\n+impl<K: Ord, V> IntoIterator for SortedMap<K, V> {\n+    type Item = (K, V);\n+    type IntoIter = ::std::vec::IntoIter<(K, V)>;\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.data.into_iter()\n+    }\n+}\n+\n+impl<K: Ord, V, Q: Borrow<K>> Index<Q> for SortedMap<K, V> {\n+    type Output = V;\n+    fn index(&self, index: Q) -> &Self::Output {\n+        let k: &K = index.borrow();\n+        self.get(k).unwrap()\n+    }\n+}\n+\n+impl<K: Ord, V, Q: Borrow<K>> IndexMut<Q> for SortedMap<K, V> {\n+    fn index_mut(&mut self, index: Q) -> &mut Self::Output {\n+        let k: &K = index.borrow();\n+        self.get_mut(k).unwrap()\n+    }\n+}\n+\n+impl<K: Ord, V, I: Iterator<Item=(K, V)>> From<I> for SortedMap<K, V> {\n+    fn from(data: I) -> Self {\n+        let mut data: Vec<(K, V)> = data.collect();\n+        data.sort_unstable_by(|&(ref k1, _), &(ref k2, _)| k1.cmp(k2));\n+        data.dedup_by(|&mut (ref k1, _), &mut (ref k2, _)| {\n+            k1.cmp(k2) == Ordering::Equal\n+        });\n+        SortedMap {\n+            data\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::SortedMap;\n+    use test::{self, Bencher};\n+\n+    #[test]\n+    fn test_insert_and_iter() {\n+        let mut map = SortedMap::new();\n+        let mut expected = Vec::new();\n+\n+        for x in 0 .. 100 {\n+            assert_eq!(map.iter().cloned().collect::<Vec<_>>(), expected);\n+\n+            let x = 1000 - x * 2;\n+            map.insert(x, x);\n+            expected.insert(0, (x, x));\n+        }\n+    }\n+\n+    #[test]\n+    fn test_get_and_index() {\n+        let mut map = SortedMap::new();\n+        let mut expected = Vec::new();\n+\n+        for x in 0 .. 100 {\n+            let x = 1000 - x;\n+            if x & 1 == 0 {\n+                map.insert(x, x);\n+            }\n+            expected.push(x);\n+        }\n+\n+        for mut x in expected {\n+            if x & 1 == 0 {\n+                assert_eq!(map.get(&x), Some(&x));\n+                assert_eq!(map.get_mut(&x), Some(&mut x));\n+                assert_eq!(map[&x], x);\n+                assert_eq!(&mut map[&x], &mut x);\n+            } else {\n+                assert_eq!(map.get(&x), None);\n+                assert_eq!(map.get_mut(&x), None);\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_range() {\n+        let mut map = SortedMap::new();\n+        map.insert(1, 1);\n+        map.insert(3, 3);\n+        map.insert(6, 6);\n+        map.insert(9, 9);\n+\n+        let keys = |s: &[(_, _)]| {\n+            s.into_iter().map(|e| e.0).collect::<Vec<u32>>()\n+        };\n+\n+        for start in 0 .. 11 {\n+            for end in 0 .. 11 {\n+                if end < start {\n+                    continue\n+                }\n+\n+                let mut expected = vec![1, 3, 6, 9];\n+                expected.retain(|&x| x >= start && x < end);\n+\n+                assert_eq!(keys(map.range(start..end)), expected, \"range = {}..{}\", start, end);\n+            }\n+        }\n+    }\n+\n+\n+    #[test]\n+    fn test_offset_keys() {\n+        let mut map = SortedMap::new();\n+        map.insert(1, 1);\n+        map.insert(3, 3);\n+        map.insert(6, 6);\n+\n+        map.offset_keys(|k| *k += 1);\n+\n+        let mut expected = SortedMap::new();\n+        expected.insert(2, 1);\n+        expected.insert(4, 3);\n+        expected.insert(7, 6);\n+\n+        assert_eq!(map, expected);\n+    }\n+\n+    fn keys(s: SortedMap<u32, u32>) -> Vec<u32> {\n+        s.into_iter().map(|(k, _)| k).collect::<Vec<u32>>()\n+    }\n+\n+    fn elements(s: SortedMap<u32, u32>) -> Vec<(u32, u32)> {\n+        s.into_iter().collect::<Vec<(u32, u32)>>()\n+    }\n+\n+    #[test]\n+    fn test_remove_range() {\n+        let mut map = SortedMap::new();\n+        map.insert(1, 1);\n+        map.insert(3, 3);\n+        map.insert(6, 6);\n+        map.insert(9, 9);\n+\n+        for start in 0 .. 11 {\n+            for end in 0 .. 11 {\n+                if end < start {\n+                    continue\n+                }\n+\n+                let mut expected = vec![1, 3, 6, 9];\n+                expected.retain(|&x| x < start || x >= end);\n+\n+                let mut map = map.clone();\n+                map.remove_range(start .. end);\n+\n+                assert_eq!(keys(map), expected, \"range = {}..{}\", start, end);\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_remove() {\n+        let mut map = SortedMap::new();\n+        let mut expected = Vec::new();\n+\n+        for x in 0..10 {\n+            map.insert(x, x);\n+            expected.push((x, x));\n+        }\n+\n+        for x in 0 .. 10 {\n+            let mut map = map.clone();\n+            let mut expected = expected.clone();\n+\n+            assert_eq!(map.remove(&x), Some(x));\n+            expected.remove(x as usize);\n+\n+            assert_eq!(map.iter().cloned().collect::<Vec<_>>(), expected);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_insert_presorted_non_overlapping() {\n+        let mut map = SortedMap::new();\n+        map.insert(2, 0);\n+        map.insert(8, 0);\n+\n+        map.insert_presorted(vec![(3, 0), (7, 0)]);\n+\n+        let expected = vec![2, 3, 7, 8];\n+        assert_eq!(keys(map), expected);\n+    }\n+\n+    #[test]\n+    fn test_insert_presorted_first_elem_equal() {\n+        let mut map = SortedMap::new();\n+        map.insert(2, 2);\n+        map.insert(8, 8);\n+\n+        map.insert_presorted(vec![(2, 0), (7, 7)]);\n+\n+        let expected = vec![(2, 0), (7, 7), (8, 8)];\n+        assert_eq!(elements(map), expected);\n+    }\n+\n+    #[test]\n+    fn test_insert_presorted_last_elem_equal() {\n+        let mut map = SortedMap::new();\n+        map.insert(2, 2);\n+        map.insert(8, 8);\n+\n+        map.insert_presorted(vec![(3, 3), (8, 0)]);\n+\n+        let expected = vec![(2, 2), (3, 3), (8, 0)];\n+        assert_eq!(elements(map), expected);\n+    }\n+\n+    #[test]\n+    fn test_insert_presorted_shuffle() {\n+        let mut map = SortedMap::new();\n+        map.insert(2, 2);\n+        map.insert(7, 7);\n+\n+        map.insert_presorted(vec![(1, 1), (3, 3), (8, 8)]);\n+\n+        let expected = vec![(1, 1), (2, 2), (3, 3), (7, 7), (8, 8)];\n+        assert_eq!(elements(map), expected);\n+    }\n+\n+    macro_rules! mk_bench {\n+        ($name:ident, $size:expr) => (\n+            #[bench]\n+            fn $name(b: &mut Bencher) {\n+                let mut map = SortedMap::new();\n+                for x in 0 .. $size {\n+                    map.insert(x * 3, 0);\n+                }\n+\n+                b.iter(|| {\n+                    test::black_box(map.range(..));\n+                    test::black_box(map.range( $size / 2.. $size ));\n+                    test::black_box(map.range( 0 .. $size / 3 ));\n+                    test::black_box(map.range( $size / 4 .. $size / 3 ));\n+                })\n+            }\n+        )\n+    }\n+\n+    mk_bench!(bench_range_1, 1);\n+    mk_bench!(bench_range_2, 2);\n+    mk_bench!(bench_range_5, 5);\n+    mk_bench!(bench_range_10, 10);\n+    mk_bench!(bench_range_32, 32);\n+    mk_bench!(bench_range_1000, 1000);\n+}"}]}