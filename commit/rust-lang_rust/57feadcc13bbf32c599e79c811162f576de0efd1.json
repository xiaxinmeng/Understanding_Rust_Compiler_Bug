{"sha": "57feadcc13bbf32c599e79c811162f576de0efd1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3ZmVhZGNjMTNiYmYzMmM1OTllNzljODExMTYyZjU3NmRlMGVmZDE=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-03-03T10:45:52Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-03-03T10:45:52Z"}, "message": "Replace functions taking or returning u128 or i128 with a trap\n\nThis makes it possible to remove most of 0002-Disable-u128-and-i128-in-libcore.patch.\nThe rest has to be kept because of u128 and i128 only being used in the function body.", "tree": {"sha": "451c103fa4407157e1459f7e67b62d95b584dfd8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/451c103fa4407157e1459f7e67b62d95b584dfd8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57feadcc13bbf32c599e79c811162f576de0efd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57feadcc13bbf32c599e79c811162f576de0efd1", "html_url": "https://github.com/rust-lang/rust/commit/57feadcc13bbf32c599e79c811162f576de0efd1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57feadcc13bbf32c599e79c811162f576de0efd1/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e77f1185a1b65a8c802cd84627e70a19f00e7001", "url": "https://api.github.com/repos/rust-lang/rust/commits/e77f1185a1b65a8c802cd84627e70a19f00e7001", "html_url": "https://github.com/rust-lang/rust/commit/e77f1185a1b65a8c802cd84627e70a19f00e7001"}], "stats": {"total": 1046, "additions": 67, "deletions": 979}, "files": [{"sha": "b4cd2f54be5f2c8c0ec705f8073e3f3fbfc8e51d", "filename": "patches/0002-Disable-u128-and-i128-in-libcore.patch", "status": "modified", "additions": 0, "deletions": 969, "changes": 969, "blob_url": "https://github.com/rust-lang/rust/blob/57feadcc13bbf32c599e79c811162f576de0efd1/patches%2F0002-Disable-u128-and-i128-in-libcore.patch", "raw_url": "https://github.com/rust-lang/rust/raw/57feadcc13bbf32c599e79c811162f576de0efd1/patches%2F0002-Disable-u128-and-i128-in-libcore.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/patches%2F0002-Disable-u128-and-i128-in-libcore.patch?ref=57feadcc13bbf32c599e79c811162f576de0efd1", "patch": "@@ -4,843 +4,12 @@ Date: Fri, 1 Mar 2019 18:36:21 +0100\n Subject: [PATCH] Disable u128 and i128 in libcore\n \n ---\n- src/libcore/clone.rs             |   4 +-\n- src/libcore/cmp.rs               |   6 +-\n- src/libcore/default.rs           |   2 -\n- src/libcore/fmt/num.rs           |   8 +-\n- src/libcore/hash/mod.rs          |  20 -----\n- src/libcore/iter/range.rs        |   1 -\n- src/libcore/iter/traits/accum.rs |   2 +-\n- src/libcore/lib.rs               |   2 -\n- src/libcore/marker.rs            |   4 +-\n- src/libcore/mem.rs               |   2 -\n- src/libcore/num/mod.rs           | 100 +++++++------------------\n- src/libcore/num/wrapping.rs      |  14 ++--\n- src/libcore/ops/arith.rs         |  22 +++---\n- src/libcore/ops/bit.rs           |  30 +++-----\n  src/libcore/sync/atomic.rs       |  32 --------\n  src/libcore/time.rs              | 123 -------------------------------\n- src/libstd/lib.rs                |   4 -\n- src/libstd/net/ip.rs             |  42 -----------\n  src/libstd/num.rs                |   2 +-\n  src/libstd/panic.rs              |   6 --\n  20 files changed, 63 insertions(+), 363 deletions(-)\n \n-diff --git a/src/libcore/clone.rs b/src/libcore/clone.rs\n-index ed90b7d..1739f91 100644\n---- a/src/libcore/clone.rs\n-+++ b/src/libcore/clone.rs\n-@@ -173,8 +173,8 @@ mod impls {\n-     }\n- \n-     impl_clone! {\n--        usize u8 u16 u32 u64 u128\n--        isize i8 i16 i32 i64 i128\n-+        usize u8 u16 u32 u64\n-+        isize i8 i16 i32 i64\n-         f32 f64\n-         bool char\n-     }\n-diff --git a/src/libcore/cmp.rs b/src/libcore/cmp.rs\n-index 81fcdee..749134c 100644\n---- a/src/libcore/cmp.rs\n-+++ b/src/libcore/cmp.rs\n-@@ -876,7 +876,7 @@ mod impls {\n-     }\n- \n-     partial_eq_impl! {\n--        bool char usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64\n-+        bool char usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64\n-     }\n- \n-     macro_rules! eq_impl {\n-@@ -886,7 +886,7 @@ mod impls {\n-         )*)\n-     }\n- \n--    eq_impl! { () bool char usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n-+    eq_impl! { () bool char usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n- \n-     macro_rules! partial_ord_impl {\n-         ($($t:ty)*) => ($(\n-@@ -975,7 +975,7 @@ mod impls {\n-         }\n-     }\n- \n--    ord_impl! { char usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n-+    ord_impl! { char usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n- \n-     #[unstable(feature = \"never_type\", issue = \"35121\")]\n-     impl PartialEq for ! {\n-diff --git a/src/libcore/default.rs b/src/libcore/default.rs\n-index 5ad05b3..1b5a1d1 100644\n---- a/src/libcore/default.rs\n-+++ b/src/libcore/default.rs\n-@@ -135,14 +135,12 @@ default_impl! { u8, 0, \"Returns the default value of `0`\" }\n- default_impl! { u16, 0, \"Returns the default value of `0`\" }\n- default_impl! { u32, 0, \"Returns the default value of `0`\" }\n- default_impl! { u64, 0, \"Returns the default value of `0`\" }\n--default_impl! { u128, 0, \"Returns the default value of `0`\" }\n- \n- default_impl! { isize, 0, \"Returns the default value of `0`\" }\n- default_impl! { i8, 0, \"Returns the default value of `0`\" }\n- default_impl! { i16, 0, \"Returns the default value of `0`\" }\n- default_impl! { i32, 0, \"Returns the default value of `0`\" }\n- default_impl! { i64, 0, \"Returns the default value of `0`\" }\n--default_impl! { i128, 0, \"Returns the default value of `0`\" }\n- \n- default_impl! { f32, 0.0f32, \"Returns the default value of `0.0`\" }\n- default_impl! { f64, 0.0f64, \"Returns the default value of `0.0`\" }\n-diff --git a/src/libcore/fmt/num.rs b/src/libcore/fmt/num.rs\n-index b9fa364..cd9ee01 100644\n---- a/src/libcore/fmt/num.rs\n-+++ b/src/libcore/fmt/num.rs\n-@@ -17,7 +17,6 @@ trait Int: PartialEq + PartialOrd + Div<Output=Self> + Rem<Output=Self> +\n-     fn to_u16(&self) -> u16;\n-     fn to_u32(&self) -> u32;\n-     fn to_u64(&self) -> u64;\n--    fn to_u128(&self) -> u128;\n- }\n- \n- macro_rules! doit {\n-@@ -28,10 +27,9 @@ macro_rules! doit {\n-         fn to_u16(&self) -> u16 { *self as u16 }\n-         fn to_u32(&self) -> u32 { *self as u32 }\n-         fn to_u64(&self) -> u64 { *self as u64 }\n--        fn to_u128(&self) -> u128 { *self as u128 }\n-     })*)\n- }\n--doit! { i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize }\n-+doit! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }\n- \n- /// A type that represents a specific radix\n- #[doc(hidden)]\n-@@ -176,8 +174,6 @@ integer! { i8, u8 }\n- integer! { i16, u16 }\n- integer! { i32, u32 }\n- integer! { i64, u64 }\n--integer! { i128, u128 }\n--\n- \n- static DEC_DIGITS_LUT: &[u8; 200] =\n-     b\"0001020304050607080910111213141516171819\\\n-@@ -274,5 +270,3 @@ mod imp {\n-     impl_Display!(i8, u8, i16, u16, i32, u32, isize, usize as u32 via to_u32 named fmt_u32);\n-     impl_Display!(i64, u64 as u64 via to_u64 named fmt_u64);\n- }\n--\n--impl_Display!(i128, u128 as u128 via to_u128 named fmt_u128);\n-diff --git a/src/libcore/hash/mod.rs b/src/libcore/hash/mod.rs\n-index d5d29c9..f98f382 100644\n---- a/src/libcore/hash/mod.rs\n-+++ b/src/libcore/hash/mod.rs\n-@@ -296,12 +296,6 @@ pub trait Hasher {\n-     fn write_u64(&mut self, i: u64) {\n-         self.write(&unsafe { mem::transmute::<_, [u8; 8]>(i) })\n-     }\n--    /// Writes a single `u128` into this hasher.\n--    #[inline]\n--    #[stable(feature = \"i128\", since = \"1.26.0\")]\n--    fn write_u128(&mut self, i: u128) {\n--        self.write(&unsafe { mem::transmute::<_, [u8; 16]>(i) })\n--    }\n-     /// Writes a single `usize` into this hasher.\n-     #[inline]\n-     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n-@@ -336,12 +330,6 @@ pub trait Hasher {\n-     fn write_i64(&mut self, i: i64) {\n-         self.write_u64(i as u64)\n-     }\n--    /// Writes a single `i128` into this hasher.\n--    #[inline]\n--    #[stable(feature = \"i128\", since = \"1.26.0\")]\n--    fn write_i128(&mut self, i: i128) {\n--        self.write_u128(i as u128)\n--    }\n-     /// Writes a single `isize` into this hasher.\n-     #[inline]\n-     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n-@@ -370,9 +358,6 @@ impl<H: Hasher + ?Sized> Hasher for &mut H {\n-     fn write_u64(&mut self, i: u64) {\n-         (**self).write_u64(i)\n-     }\n--    fn write_u128(&mut self, i: u128) {\n--        (**self).write_u128(i)\n--    }\n-     fn write_usize(&mut self, i: usize) {\n-         (**self).write_usize(i)\n-     }\n-@@ -388,9 +373,6 @@ impl<H: Hasher + ?Sized> Hasher for &mut H {\n-     fn write_i64(&mut self, i: i64) {\n-         (**self).write_i64(i)\n-     }\n--    fn write_i128(&mut self, i: i128) {\n--        (**self).write_i128(i)\n--    }\n-     fn write_isize(&mut self, i: isize) {\n-         (**self).write_isize(i)\n-     }\n-@@ -577,8 +559,6 @@ mod impls {\n-         (i32, write_i32),\n-         (i64, write_i64),\n-         (isize, write_isize),\n--        (u128, write_u128),\n--        (i128, write_i128),\n-     }\n- \n-     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-diff --git a/src/libcore/iter/range.rs b/src/libcore/iter/range.rs\n-index e7efd97..78e0da7 100644\n---- a/src/libcore/iter/range.rs\n-+++ b/src/libcore/iter/range.rs\n-@@ -173,7 +173,6 @@ step_impl_signed!([i64: u64]);\n- // assume here that it is less than 64-bits.\n- #[cfg(not(target_pointer_width = \"64\"))]\n- step_impl_no_between!(u64 i64);\n--step_impl_no_between!(u128 i128);\n- \n- macro_rules! range_exact_iter_impl {\n-     ($($t:ty)*) => ($(\n-diff --git a/src/libcore/iter/traits/accum.rs b/src/libcore/iter/traits/accum.rs\n-index dfe1d2a..06cc578 100644\n---- a/src/libcore/iter/traits/accum.rs\n-+++ b/src/libcore/iter/traits/accum.rs\n-@@ -111,7 +111,7 @@ macro_rules! float_sum_product {\n-     )*)\n- }\n- \n--integer_sum_product! { i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize }\n-+integer_sum_product! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }\n- float_sum_product! { f32 f64 }\n- \n- /// An iterator adapter that produces output as long as the underlying\n-diff --git a/src/libcore/lib.rs b/src/libcore/lib.rs\n-index 9516c02..9d91885 100644\n---- a/src/libcore/lib.rs\n-+++ b/src/libcore/lib.rs\n-@@ -148,14 +148,12 @@ mod uint_macros;\n- #[path = \"num/i16.rs\"]   pub mod i16;\n- #[path = \"num/i32.rs\"]   pub mod i32;\n- #[path = \"num/i64.rs\"]   pub mod i64;\n--#[path = \"num/i128.rs\"]  pub mod i128;\n- \n- #[path = \"num/usize.rs\"] pub mod usize;\n- #[path = \"num/u8.rs\"]    pub mod u8;\n- #[path = \"num/u16.rs\"]   pub mod u16;\n- #[path = \"num/u32.rs\"]   pub mod u32;\n- #[path = \"num/u64.rs\"]   pub mod u64;\n--#[path = \"num/u128.rs\"]  pub mod u128;\n- \n- #[path = \"num/f32.rs\"]   pub mod f32;\n- #[path = \"num/f64.rs\"]   pub mod f64;\n-diff --git a/src/libcore/marker.rs b/src/libcore/marker.rs\n-index 29606cb..160cca1 100644\n---- a/src/libcore/marker.rs\n-+++ b/src/libcore/marker.rs\n-@@ -673,8 +673,8 @@ mod copy_impls {\n-     }\n- \n-     impl_copy! {\n--        usize u8 u16 u32 u64 u128\n--        isize i8 i16 i32 i64 i128\n-+        usize u8 u16 u32 u64\n-+        isize i8 i16 i32 i64\n-         f32 f64\n-         bool char\n-     }\n-diff --git a/src/libcore/mem.rs b/src/libcore/mem.rs\n-index f41d293..71b5e09 100644\n---- a/src/libcore/mem.rs\n-+++ b/src/libcore/mem.rs\n-@@ -164,12 +164,10 @@ pub fn forget_unsized<T: ?Sized>(t: T) {\n- /// u16 | 2\n- /// u32 | 4\n- /// u64 | 8\n--/// u128 | 16\n- /// i8 | 1\n- /// i16 | 2\n- /// i32 | 4\n- /// i64 | 8\n--/// i128 | 16\n- /// f32 | 4\n- /// f64 | 8\n- /// char | 4\n-diff --git a/src/libcore/num/mod.rs b/src/libcore/num/mod.rs\n-index 6708a19..4066b0c 100644\n---- a/src/libcore/num/mod.rs\n-+++ b/src/libcore/num/mod.rs\n-@@ -102,13 +102,11 @@ nonzero_integers! {\n-     #[stable(feature = \"nonzero\", since = \"1.28.0\")] NonZeroU16(u16);\n-     #[stable(feature = \"nonzero\", since = \"1.28.0\")] NonZeroU32(u32);\n-     #[stable(feature = \"nonzero\", since = \"1.28.0\")] NonZeroU64(u64);\n--    #[stable(feature = \"nonzero\", since = \"1.28.0\")] NonZeroU128(u128);\n-     #[stable(feature = \"nonzero\", since = \"1.28.0\")] NonZeroUsize(usize);\n-     #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")] NonZeroI8(i8);\n-     #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")] NonZeroI16(i16);\n-     #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")] NonZeroI32(i32);\n-     #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")] NonZeroI64(i64);\n--    #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")] NonZeroI128(i128);\n-     #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")] NonZeroIsize(isize);\n- }\n- \n-@@ -2117,18 +2115,6 @@ impl i64 {\n-          \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\" }\n- }\n- \n--#[lang = \"i128\"]\n--impl i128 {\n--    int_impl! { i128, i128, u128, 128, -170141183460469231731687303715884105728,\n--        170141183460469231731687303715884105727, \"\", \"\", 16,\n--        \"0x13f40000000000000000000000004f76\", \"0x4f7613f4\", \"0x12345678901234567890123456789012\",\n--        \"0x12907856341290785634129078563412\", \"0x48091e6a2c48091e6a2c48091e6a2c48\",\n--        \"[0x12, 0x90, 0x78, 0x56, 0x34, 0x12, 0x90, 0x78, \\\n--          0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n--        \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56, \\\n--          0x78, 0x90, 0x12, 0x34, 0x56, 0x78, 0x90, 0x12]\" }\n--}\n--\n- #[cfg(target_pointer_width = \"16\")]\n- #[lang = \"isize\"]\n- impl isize {\n-@@ -4401,17 +4387,6 @@ impl u64 {\n-         \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\" }\n- }\n- \n--#[lang = \"u128\"]\n--impl u128 {\n--    uint_impl! { u128, u128, 128, 340282366920938463463374607431768211455, \"\", \"\", 16,\n--        \"0x13f40000000000000000000000004f76\", \"0x4f7613f4\", \"0x12345678901234567890123456789012\",\n--        \"0x12907856341290785634129078563412\", \"0x48091e6a2c48091e6a2c48091e6a2c48\",\n--        \"[0x12, 0x90, 0x78, 0x56, 0x34, 0x12, 0x90, 0x78, \\\n--          0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n--        \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56, \\\n--          0x78, 0x90, 0x12, 0x34, 0x56, 0x78, 0x90, 0x12]\" }\n--}\n--\n- #[cfg(target_pointer_width = \"16\")]\n- #[lang = \"usize\"]\n- impl usize {\n-@@ -4495,7 +4470,7 @@ macro_rules! from_str_radix_int_impl {\n-         }\n-     )*}\n- }\n--from_str_radix_int_impl! { isize i8 i16 i32 i64 i128 usize u8 u16 u32 u64 u128 }\n-+from_str_radix_int_impl! { isize i8 i16 i32 i64 usize u8 u16 u32 u64 }\n- \n- /// The error type returned when a checked integral type conversion fails.\n- #[stable(feature = \"try_from\", since = \"1.34.0\")]\n-@@ -4621,30 +4596,25 @@ macro_rules! rev {\n- try_from_upper_bounded!(u16, u8);\n- try_from_upper_bounded!(u32, u16, u8);\n- try_from_upper_bounded!(u64, u32, u16, u8);\n--try_from_upper_bounded!(u128, u64, u32, u16, u8);\n- \n- try_from_both_bounded!(i16, i8);\n- try_from_both_bounded!(i32, i16, i8);\n- try_from_both_bounded!(i64, i32, i16, i8);\n--try_from_both_bounded!(i128, i64, i32, i16, i8);\n- \n- // unsigned-to-signed\n- try_from_upper_bounded!(u8, i8);\n- try_from_upper_bounded!(u16, i8, i16);\n- try_from_upper_bounded!(u32, i8, i16, i32);\n- try_from_upper_bounded!(u64, i8, i16, i32, i64);\n--try_from_upper_bounded!(u128, i8, i16, i32, i64, i128);\n- \n- // signed-to-unsigned\n--try_from_lower_bounded!(i8, u8, u16, u32, u64, u128);\n--try_from_lower_bounded!(i16, u16, u32, u64, u128);\n--try_from_lower_bounded!(i32, u32, u64, u128);\n--try_from_lower_bounded!(i64, u64, u128);\n--try_from_lower_bounded!(i128, u128);\n-+try_from_lower_bounded!(i8, u8, u16, u32, u64);\n-+try_from_lower_bounded!(i16, u16, u32, u64);\n-+try_from_lower_bounded!(i32, u32, u64);\n-+try_from_lower_bounded!(i64, u64);\n- try_from_both_bounded!(i16, u8);\n- try_from_both_bounded!(i32, u16, u8);\n- try_from_both_bounded!(i64, u32, u16, u8);\n--try_from_both_bounded!(i128, u64, u32, u16, u8);\n- \n- // usize/isize\n- try_from_upper_bounded!(usize, isize);\n-@@ -4656,21 +4626,21 @@ mod ptr_try_from_impls {\n-     use convert::TryFrom;\n- \n-     try_from_upper_bounded!(usize, u8);\n--    try_from_unbounded!(usize, u16, u32, u64, u128);\n-+    try_from_unbounded!(usize, u16, u32, u64);\n-     try_from_upper_bounded!(usize, i8, i16);\n--    try_from_unbounded!(usize, i32, i64, i128);\n-+    try_from_unbounded!(usize, i32, i64);\n- \n-     try_from_both_bounded!(isize, u8);\n--    try_from_lower_bounded!(isize, u16, u32, u64, u128);\n-+    try_from_lower_bounded!(isize, u16, u32, u64);\n-     try_from_both_bounded!(isize, i8);\n--    try_from_unbounded!(isize, i16, i32, i64, i128);\n-+    try_from_unbounded!(isize, i16, i32, i64);\n- \n--    rev!(try_from_upper_bounded, usize, u32, u64, u128);\n-+    rev!(try_from_upper_bounded, usize, u32, u64);\n-     rev!(try_from_lower_bounded, usize, i8, i16);\n--    rev!(try_from_both_bounded, usize, i32, i64, i128);\n-+    rev!(try_from_both_bounded, usize, i32, i64);\n- \n--    rev!(try_from_upper_bounded, isize, u16, u32, u64, u128);\n--    rev!(try_from_both_bounded, isize, i32, i64, i128);\n-+    rev!(try_from_upper_bounded, isize, u16, u32, u64);\n-+    rev!(try_from_both_bounded, isize, i32, i64);\n- }\n- \n- #[cfg(target_pointer_width = \"32\")]\n-@@ -4679,24 +4649,24 @@ mod ptr_try_from_impls {\n-     use convert::TryFrom;\n- \n-     try_from_upper_bounded!(usize, u8, u16);\n--    try_from_unbounded!(usize, u32, u64, u128);\n-+    try_from_unbounded!(usize, u32, u64);\n-     try_from_upper_bounded!(usize, i8, i16, i32);\n--    try_from_unbounded!(usize, i64, i128);\n-+    try_from_unbounded!(usize, i64);\n- \n-     try_from_both_bounded!(isize, u8, u16);\n--    try_from_lower_bounded!(isize, u32, u64, u128);\n-+    try_from_lower_bounded!(isize, u32, u64);\n-     try_from_both_bounded!(isize, i8, i16);\n--    try_from_unbounded!(isize, i32, i64, i128);\n-+    try_from_unbounded!(isize, i32, i64);\n- \n-     rev!(try_from_unbounded, usize, u32);\n--    rev!(try_from_upper_bounded, usize, u64, u128);\n-+    rev!(try_from_upper_bounded, usize, u64);\n-     rev!(try_from_lower_bounded, usize, i8, i16, i32);\n--    rev!(try_from_both_bounded, usize, i64, i128);\n-+    rev!(try_from_both_bounded, usize, i64);\n- \n-     rev!(try_from_unbounded, isize, u16);\n--    rev!(try_from_upper_bounded, isize, u32, u64, u128);\n-+    rev!(try_from_upper_bounded, isize, u32, u64);\n-     rev!(try_from_unbounded, isize, i32);\n--    rev!(try_from_both_bounded, isize, i64, i128);\n-+    rev!(try_from_both_bounded, isize, i64);\n- }\n- \n- #[cfg(target_pointer_width = \"64\")]\n-@@ -4705,24 +4675,20 @@ mod ptr_try_from_impls {\n-     use convert::TryFrom;\n- \n-     try_from_upper_bounded!(usize, u8, u16, u32);\n--    try_from_unbounded!(usize, u64, u128);\n-+    try_from_unbounded!(usize, u64);\n-     try_from_upper_bounded!(usize, i8, i16, i32, i64);\n--    try_from_unbounded!(usize, i128);\n- \n-     try_from_both_bounded!(isize, u8, u16, u32);\n--    try_from_lower_bounded!(isize, u64, u128);\n-+    try_from_lower_bounded!(isize, u64);\n-     try_from_both_bounded!(isize, i8, i16, i32);\n--    try_from_unbounded!(isize, i64, i128);\n-+    try_from_unbounded!(isize, i64);\n- \n-     rev!(try_from_unbounded, usize, u32, u64);\n--    rev!(try_from_upper_bounded, usize, u128);\n-     rev!(try_from_lower_bounded, usize, i8, i16, i32, i64);\n--    rev!(try_from_both_bounded, usize, i128);\n- \n-     rev!(try_from_unbounded, isize, u16, u32);\n--    rev!(try_from_upper_bounded, isize, u64, u128);\n-+    rev!(try_from_upper_bounded, isize, u64);\n-     rev!(try_from_unbounded, isize, i32, i64);\n--    rev!(try_from_both_bounded, isize, i128);\n- }\n- \n- #[doc(hidden)]\n-@@ -4757,7 +4723,7 @@ macro_rules! doit {\n-         }\n-     })*)\n- }\n--doit! { i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize }\n-+doit! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }\n- \n- fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32) -> Result<T, ParseIntError> {\n-     use self::IntErrorKind::*;\n-@@ -4948,52 +4914,38 @@ impl_from_bool! { u8, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n- impl_from_bool! { u16, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n- impl_from_bool! { u32, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n- impl_from_bool! { u64, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n--impl_from_bool! { u128, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n- impl_from_bool! { usize, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n- impl_from_bool! { i8, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n- impl_from_bool! { i16, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n- impl_from_bool! { i32, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n- impl_from_bool! { i64, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n--impl_from_bool! { i128, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n- impl_from_bool! { isize, #[stable(feature = \"from_bool\", since = \"1.28.0\")] }\n- \n- // Unsigned -> Unsigned\n- impl_from! { u8, u16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n- impl_from! { u8, u32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n- impl_from! { u8, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n--impl_from! { u8, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n- impl_from! { u8, usize, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n- impl_from! { u16, u32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n- impl_from! { u16, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n--impl_from! { u16, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n- impl_from! { u32, u64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n--impl_from! { u32, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n--impl_from! { u64, u128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n- \n- // Signed -> Signed\n- impl_from! { i8, i16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n- impl_from! { i8, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n- impl_from! { i8, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n--impl_from! { i8, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n- impl_from! { i8, isize, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n- impl_from! { i16, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n- impl_from! { i16, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n--impl_from! { i16, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n- impl_from! { i32, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n--impl_from! { i32, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n--impl_from! { i64, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n- \n- // Unsigned -> Signed\n- impl_from! { u8, i16, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n- impl_from! { u8, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n- impl_from! { u8, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n--impl_from! { u8, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n- impl_from! { u16, i32, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n- impl_from! { u16, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n--impl_from! { u16, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n- impl_from! { u32, i64, #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")] }\n--impl_from! { u32, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n--impl_from! { u64, i128, #[stable(feature = \"i128\", since = \"1.26.0\")] }\n- \n- // The C99 standard defines bounds on INTPTR_MIN, INTPTR_MAX, and UINTPTR_MAX\n- // which imply that pointer-sized integers must be at least 16 bits:\n-diff --git a/src/libcore/num/wrapping.rs b/src/libcore/num/wrapping.rs\n-index 9cd5108..26c8abc 100644\n---- a/src/libcore/num/wrapping.rs\n-+++ b/src/libcore/num/wrapping.rs\n-@@ -102,19 +102,17 @@ macro_rules! sh_impl_all {\n-         //sh_impl_unsigned! { $t, u16 }\n-         //sh_impl_unsigned! { $t, u32 }\n-         //sh_impl_unsigned! { $t, u64 }\n--        //sh_impl_unsigned! { $t, u128 }\n-         sh_impl_unsigned! { $t, usize }\n- \n-         //sh_impl_signed! { $t, i8 }\n-         //sh_impl_signed! { $t, i16 }\n-         //sh_impl_signed! { $t, i32 }\n-         //sh_impl_signed! { $t, i64 }\n--        //sh_impl_signed! { $t, i128 }\n-         //sh_impl_signed! { $t, isize }\n-     )*)\n- }\n- \n--sh_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n-+sh_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n- \n- // FIXME(30524): impl Op<T> for Wrapping<T>, impl OpAssign<T> for Wrapping<T>\n- macro_rules! wrapping_impl {\n-@@ -313,7 +311,7 @@ macro_rules! wrapping_impl {\n-     )*)\n- }\n- \n--wrapping_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n-+wrapping_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n- \n- macro_rules! wrapping_int_impl {\n-     ($($t:ty)*) => ($(\n-@@ -677,7 +675,7 @@ assert_eq!(Wrapping(3i8).pow(6), Wrapping(-39));\n-     )*)\n- }\n- \n--wrapping_int_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n-+wrapping_int_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n- \n- macro_rules! wrapping_int_impl_signed {\n-     ($($t:ty)*) => ($(\n-@@ -806,7 +804,7 @@ assert!(!Wrapping(10\", stringify!($t), \").is_negative());\n-     )*)\n- }\n- \n--wrapping_int_impl_signed! { isize i8 i16 i32 i64 i128 }\n-+wrapping_int_impl_signed! { isize i8 i16 i32 i64 }\n- \n- macro_rules! wrapping_int_impl_unsigned {\n-     ($($t:ty)*) => ($(\n-@@ -883,7 +881,7 @@ assert_eq!(Wrapping(200_u8).next_power_of_two(), Wrapping(0));\n-     )*)\n- }\n- \n--wrapping_int_impl_unsigned! { usize u8 u16 u32 u64 u128 }\n-+wrapping_int_impl_unsigned! { usize u8 u16 u32 u64 }\n- \n- mod shift_max {\n-     #![allow(non_upper_case_globals)]\n-@@ -910,13 +908,11 @@ mod shift_max {\n-     pub const i16: u32 = (1 << 4) - 1;\n-     pub const i32: u32 = (1 << 5) - 1;\n-     pub const i64: u32 = (1 << 6) - 1;\n--    pub const i128: u32 = (1 << 7) - 1;\n-     pub use self::platform::isize;\n- \n-     pub const u8: u32 = i8;\n-     pub const u16: u32 = i16;\n-     pub const u32: u32 = i32;\n-     pub const u64: u32 = i64;\n--    pub const u128: u32 = i128;\n-     pub use self::platform::usize;\n- }\n-diff --git a/src/libcore/ops/arith.rs b/src/libcore/ops/arith.rs\n-index 0252ede..cb8ab3d 100644\n---- a/src/libcore/ops/arith.rs\n-+++ b/src/libcore/ops/arith.rs\n-@@ -104,7 +104,7 @@ macro_rules! add_impl {\n-     )*)\n- }\n- \n--add_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n-+add_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n- \n- /// The subtraction operator `-`.\n- ///\n-@@ -202,7 +202,7 @@ macro_rules! sub_impl {\n-     )*)\n- }\n- \n--sub_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n-+sub_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n- \n- /// The multiplication operator `*`.\n- ///\n-@@ -322,7 +322,7 @@ macro_rules! mul_impl {\n-     )*)\n- }\n- \n--mul_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n-+mul_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n- \n- /// The division operator `/`.\n- ///\n-@@ -447,7 +447,7 @@ macro_rules! div_impl_integer {\n-     )*)\n- }\n- \n--div_impl_integer! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n-+div_impl_integer! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n- \n- macro_rules! div_impl_float {\n-     ($($t:ty)*) => ($(\n-@@ -532,7 +532,7 @@ macro_rules! rem_impl_integer {\n-     )*)\n- }\n- \n--rem_impl_integer! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n-+rem_impl_integer! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n- \n- \n- macro_rules! rem_impl_float {\n-@@ -631,7 +631,7 @@ macro_rules! neg_impl_unsigned {\n- }\n- \n- // neg_impl_unsigned! { usize u8 u16 u32 u64 }\n--neg_impl_numeric! { isize i8 i16 i32 i64 i128 f32 f64 }\n-+neg_impl_numeric! { isize i8 i16 i32 i64 f32 f64 }\n- \n- /// The addition assignment operator `+=`.\n- ///\n-@@ -687,7 +687,7 @@ macro_rules! add_assign_impl {\n-     )+)\n- }\n- \n--add_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n-+add_assign_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n- \n- /// The subtraction assignment operator `-=`.\n- ///\n-@@ -743,7 +743,7 @@ macro_rules! sub_assign_impl {\n-     )+)\n- }\n- \n--sub_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n-+sub_assign_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n- \n- /// The multiplication assignment operator `*=`.\n- ///\n-@@ -790,7 +790,7 @@ macro_rules! mul_assign_impl {\n-     )+)\n- }\n- \n--mul_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n-+mul_assign_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n- \n- /// The division assignment operator `/=`.\n- ///\n-@@ -836,7 +836,7 @@ macro_rules! div_assign_impl {\n-     )+)\n- }\n- \n--div_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n-+div_assign_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n- \n- /// The remainder assignment operator `%=`.\n- ///\n-@@ -886,4 +886,4 @@ macro_rules! rem_assign_impl {\n-     )+)\n- }\n- \n--rem_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n-+rem_assign_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n-diff --git a/src/libcore/ops/bit.rs b/src/libcore/ops/bit.rs\n-index 2c9bf24..af2ab6f 100644\n---- a/src/libcore/ops/bit.rs\n-+++ b/src/libcore/ops/bit.rs\n-@@ -55,7 +55,7 @@ macro_rules! not_impl {\n-     )*)\n- }\n- \n--not_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n-+not_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n- \n- /// The bitwise AND operator `&`.\n- ///\n-@@ -139,7 +139,7 @@ macro_rules! bitand_impl {\n-     )*)\n- }\n- \n--bitand_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n-+bitand_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n- \n- /// The bitwise OR operator `|`.\n- ///\n-@@ -223,7 +223,7 @@ macro_rules! bitor_impl {\n-     )*)\n- }\n- \n--bitor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n-+bitor_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n- \n- /// The bitwise XOR operator `^`.\n- ///\n-@@ -310,7 +310,7 @@ macro_rules! bitxor_impl {\n-     )*)\n- }\n- \n--bitxor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n-+bitxor_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n- \n- /// The left shift operator `<<`. Note that because this trait is implemented\n- /// for all integer types with multiple right-hand-side types, Rust's type\n-@@ -407,19 +407,17 @@ macro_rules! shl_impl_all {\n-         shl_impl! { $t, u16 }\n-         shl_impl! { $t, u32 }\n-         shl_impl! { $t, u64 }\n--        shl_impl! { $t, u128 }\n-         shl_impl! { $t, usize }\n- \n-         shl_impl! { $t, i8 }\n-         shl_impl! { $t, i16 }\n-         shl_impl! { $t, i32 }\n-         shl_impl! { $t, i64 }\n--        shl_impl! { $t, i128 }\n-         shl_impl! { $t, isize }\n-     )*)\n- }\n- \n--shl_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 isize i128 }\n-+shl_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n- \n- /// The right shift operator `>>`. Note that because this trait is implemented\n- /// for all integer types with multiple right-hand-side types, Rust's type\n-@@ -516,19 +514,17 @@ macro_rules! shr_impl_all {\n-         shr_impl! { $t, u16 }\n-         shr_impl! { $t, u32 }\n-         shr_impl! { $t, u64 }\n--        shr_impl! { $t, u128 }\n-         shr_impl! { $t, usize }\n- \n-         shr_impl! { $t, i8 }\n-         shr_impl! { $t, i16 }\n-         shr_impl! { $t, i32 }\n-         shr_impl! { $t, i64 }\n--        shr_impl! { $t, i128 }\n-         shr_impl! { $t, isize }\n-     )*)\n- }\n- \n--shr_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n-+shr_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n- \n- /// The bitwise AND assignment operator `&=`.\n- ///\n-@@ -616,7 +612,7 @@ macro_rules! bitand_assign_impl {\n-     )+)\n- }\n- \n--bitand_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n-+bitand_assign_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n- \n- /// The bitwise OR assignment operator `|=`.\n- ///\n-@@ -665,7 +661,7 @@ macro_rules! bitor_assign_impl {\n-     )+)\n- }\n- \n--bitor_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n-+bitor_assign_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n- \n- /// The bitwise XOR assignment operator `^=`.\n- ///\n-@@ -714,7 +710,7 @@ macro_rules! bitxor_assign_impl {\n-     )+)\n- }\n- \n--bitxor_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n-+bitxor_assign_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n- \n- /// The left shift assignment operator `<<=`.\n- ///\n-@@ -770,19 +766,17 @@ macro_rules! shl_assign_impl_all {\n-         shl_assign_impl! { $t, u16 }\n-         shl_assign_impl! { $t, u32 }\n-         shl_assign_impl! { $t, u64 }\n--        shl_assign_impl! { $t, u128 }\n-         shl_assign_impl! { $t, usize }\n- \n-         shl_assign_impl! { $t, i8 }\n-         shl_assign_impl! { $t, i16 }\n-         shl_assign_impl! { $t, i32 }\n-         shl_assign_impl! { $t, i64 }\n--        shl_assign_impl! { $t, i128 }\n-         shl_assign_impl! { $t, isize }\n-     )*)\n- }\n- \n--shl_assign_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n-+shl_assign_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n- \n- /// The right shift assignment operator `>>=`.\n- ///\n-@@ -838,16 +832,14 @@ macro_rules! shr_assign_impl_all {\n-         shr_assign_impl! { $t, u16 }\n-         shr_assign_impl! { $t, u32 }\n-         shr_assign_impl! { $t, u64 }\n--        shr_assign_impl! { $t, u128 }\n-         shr_assign_impl! { $t, usize }\n- \n-         shr_assign_impl! { $t, i8 }\n-         shr_assign_impl! { $t, i16 }\n-         shr_assign_impl! { $t, i32 }\n-         shr_assign_impl! { $t, i64 }\n--        shr_assign_impl! { $t, i128 }\n-         shr_assign_impl! { $t, isize }\n-     )*)\n- }\n- \n--shr_assign_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n-+shr_assign_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n diff --git a/src/libcore/sync/atomic.rs b/src/libcore/sync/atomic.rs\n index d0ee5fa..d02c454 100644\n --- a/src/libcore/sync/atomic.rs\n@@ -888,69 +57,6 @@ diff --git a/src/libcore/time.rs b/src/libcore/time.rs\n index 91161ca..759497f 100644\n --- a/src/libcore/time.rs\n +++ b/src/libcore/time.rs\n-@@ -21,7 +21,6 @@ const NANOS_PER_MILLI: u32 = 1_000_000;\n- const NANOS_PER_MICRO: u32 = 1_000;\n- const MILLIS_PER_SEC: u64 = 1_000;\n- const MICROS_PER_SEC: u64 = 1_000_000;\n--const MAX_NANOS_F64: f64 = ((u64::MAX as u128 + 1)*(NANOS_PER_SEC as u128)) as f64;\n- \n- /// A `Duration` type to represent a span of time, typically used for system\n- /// timeouts.\n-@@ -312,54 +311,6 @@ impl Duration {\n-     #[inline]\n-     pub const fn subsec_nanos(&self) -> u32 { self.nanos }\n- \n--    /// Returns the total number of whole milliseconds contained by this `Duration`.\n--    ///\n--    /// # Examples\n--    ///\n--    /// ```\n--    /// use std::time::Duration;\n--    ///\n--    /// let duration = Duration::new(5, 730023852);\n--    /// assert_eq!(duration.as_millis(), 5730);\n--    /// ```\n--    #[stable(feature = \"duration_as_u128\", since = \"1.33.0\")]\n--    #[inline]\n--    pub const fn as_millis(&self) -> u128 {\n--        self.secs as u128 * MILLIS_PER_SEC as u128 + (self.nanos / NANOS_PER_MILLI) as u128\n--    }\n--\n--    /// Returns the total number of whole microseconds contained by this `Duration`.\n--    ///\n--    /// # Examples\n--    ///\n--    /// ```\n--    /// use std::time::Duration;\n--    ///\n--    /// let duration = Duration::new(5, 730023852);\n--    /// assert_eq!(duration.as_micros(), 5730023);\n--    /// ```\n--    #[stable(feature = \"duration_as_u128\", since = \"1.33.0\")]\n--    #[inline]\n--    pub const fn as_micros(&self) -> u128 {\n--        self.secs as u128 * MICROS_PER_SEC as u128 + (self.nanos / NANOS_PER_MICRO) as u128\n--    }\n--\n--    /// Returns the total number of nanoseconds contained by this `Duration`.\n--    ///\n--    /// # Examples\n--    ///\n--    /// ```\n--    /// use std::time::Duration;\n--    ///\n--    /// let duration = Duration::new(5, 730023852);\n--    /// assert_eq!(duration.as_nanos(), 5730023852);\n--    /// ```\n--    #[stable(feature = \"duration_as_u128\", since = \"1.33.0\")]\n--    #[inline]\n--    pub const fn as_nanos(&self) -> u128 {\n--        self.secs as u128 * NANOS_PER_SEC as u128 + self.nanos as u128\n--    }\n--\n-     /// Checked `Duration` addition. Computes `self + other`, returning [`None`]\n-     /// if overflow occurred.\n-     ///\n @@ -518,80 +469,6 @@ impl Duration {\n          (self.secs as f64) + (self.nanos as f64) / (NANOS_PER_SEC as f64)\n      }\n@@ -1032,81 +138,6 @@ index 91161ca..759497f 100644\n      /// Divide `Duration` by `Duration` and return `f64`.\n      ///\n      /// # Examples\n-diff --git a/src/libstd/lib.rs b/src/libstd/lib.rs\n-index 2b62b5b..c6515bc 100644\n---- a/src/libstd/lib.rs\n-+++ b/src/libstd/lib.rs\n-@@ -393,8 +393,6 @@ pub use core::i16;\n- pub use core::i32;\n- #[stable(feature = \"rust1\", since = \"1.0.0\")]\n- pub use core::i64;\n--#[stable(feature = \"i128\", since = \"1.26.0\")]\n--pub use core::i128;\n- #[stable(feature = \"rust1\", since = \"1.0.0\")]\n- pub use core::usize;\n- #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-@@ -427,8 +425,6 @@ pub use alloc_crate::string;\n- pub use alloc_crate::vec;\n- #[stable(feature = \"rust1\", since = \"1.0.0\")]\n- pub use core::char;\n--#[stable(feature = \"i128\", since = \"1.26.0\")]\n--pub use core::u128;\n- #[stable(feature = \"core_hint\", since = \"1.27.0\")]\n- pub use core::hint;\n- \n-diff --git a/src/libstd/net/ip.rs b/src/libstd/net/ip.rs\n-index fa256ce..42b0aa2 100644\n---- a/src/libstd/net/ip.rs\n-+++ b/src/libstd/net/ip.rs\n-@@ -1391,48 +1391,6 @@ impl FromInner<c::in6_addr> for Ipv6Addr {\n-     }\n- }\n- \n--#[stable(feature = \"i128\", since = \"1.26.0\")]\n--impl From<Ipv6Addr> for u128 {\n--    /// Convert an `Ipv6Addr` into a host byte order `u128`.\n--    ///\n--    /// # Examples\n--    ///\n--    /// ```\n--    /// use std::net::Ipv6Addr;\n--    ///\n--    /// let addr = Ipv6Addr::new(\n--    ///     0x1020, 0x3040, 0x5060, 0x7080,\n--    ///     0x90A0, 0xB0C0, 0xD0E0, 0xF00D,\n--    /// );\n--    /// assert_eq!(0x102030405060708090A0B0C0D0E0F00D_u128, u128::from(addr));\n--    /// ```\n--    fn from(ip: Ipv6Addr) -> u128 {\n--        let ip = ip.octets();\n--        u128::from_be_bytes(ip)\n--    }\n--}\n--#[stable(feature = \"i128\", since = \"1.26.0\")]\n--impl From<u128> for Ipv6Addr {\n--    /// Convert a host byte order `u128` into an `Ipv6Addr`.\n--    ///\n--    /// # Examples\n--    ///\n--    /// ```\n--    /// use std::net::Ipv6Addr;\n--    ///\n--    /// let addr = Ipv6Addr::from(0x102030405060708090A0B0C0D0E0F00D_u128);\n--    /// assert_eq!(\n--    ///     Ipv6Addr::new(\n--    ///         0x1020, 0x3040, 0x5060, 0x7080,\n--    ///         0x90A0, 0xB0C0, 0xD0E0, 0xF00D,\n--    ///     ),\n--    ///     addr);\n--    /// ```\n--    fn from(ip: u128) -> Ipv6Addr {\n--        Ipv6Addr::from(ip.to_be_bytes())\n--    }\n--}\n--\n- #[stable(feature = \"ipv6_from_octets\", since = \"1.9.0\")]\n- impl From<[u8; 16]> for Ipv6Addr {\n-     fn from(octets: [u8; 16]) -> Ipv6Addr {\n diff --git a/src/libstd/num.rs b/src/libstd/num.rs\n index 828d572..bc04fb1 100644\n --- a/src/libstd/num.rs"}, {"sha": "e41d8934c4f425c7a01abb6e67db80a48a394f15", "filename": "src/base.rs", "status": "modified", "additions": 67, "deletions": 10, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/57feadcc13bbf32c599e79c811162f576de0efd1/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57feadcc13bbf32c599e79c811162f576de0efd1/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=57feadcc13bbf32c599e79c811162f576de0efd1", "patch": "@@ -64,27 +64,84 @@ fn trans_fn<'a, 'clif, 'tcx: 'a, B: Backend + 'static>(\n     // Step 1. Get mir\n     let mir = tcx.instance_mir(instance.def);\n \n-    // Step 2. Declare function\n+    // Step 2. Check fn sig for u128 and i128 and replace those functions with a trap.\n+    {\n+        // Step 2a. Check sig for u128 and i128\n+        let fn_ty = instance.ty(tcx);\n+        let fn_sig = crate::abi::ty_fn_sig(tcx, fn_ty);\n+\n+        struct UI128Visitor<'a, 'tcx: 'a>(TyCtxt<'a, 'tcx, 'tcx>, bool);\n+\n+        impl<'a, 'tcx: 'a> rustc::ty::fold::TypeVisitor<'tcx> for UI128Visitor<'a, 'tcx> {\n+            fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+                if t.sty == self.0.types.u128.sty || t.sty == self.0.types.i128.sty {\n+                    self.1 = true;\n+                    return false; // stop visiting\n+                }\n+\n+                t.super_visit_with(self)\n+            }\n+        }\n+\n+        let mut visitor = UI128Visitor(tcx, false);\n+        fn_sig.visit_with(&mut visitor);\n+\n+        // Step 2b. If found replace function with a trap.\n+        if visitor.1 {\n+            tcx.sess.warn(\"u128 and i128 are not yet supported. \\\n+            Functions using these as args will be replaced with a trap.\");\n+\n+            // Step 2b1. Declare function with fake signature\n+            let sig = Signature {\n+                params: vec![AbiParam::new(types::INVALID)],\n+                returns: vec![],\n+                call_conv: CallConv::Fast,\n+            };\n+            let name = tcx.symbol_name(instance).as_str();\n+            let func_id = cx.module.declare_function(&*name, linkage, &sig).unwrap();\n+\n+            // Step 2b2. Create trapping function\n+            let mut func = Function::with_name_signature(ExternalName::user(0, 0), sig);\n+            let mut func_ctx = FunctionBuilderContext::new();\n+            let mut bcx = FunctionBuilder::new(&mut func, &mut func_ctx);\n+            let start_ebb = bcx.create_ebb();\n+            bcx.append_ebb_params_for_function_params(start_ebb);\n+            bcx.switch_to_block(start_ebb);\n+            crate::trap::trap_unreachable(&mut bcx);\n+            bcx.seal_all_blocks();\n+            bcx.finalize();\n+\n+            // Step 2b3. Define function\n+            cx.caches.context.func = func;\n+            cx.module\n+                .define_function(func_id, &mut cx.caches.context)\n+                .unwrap();\n+            cx.caches.context.clear();\n+            return;\n+        }\n+    }\n+\n+    // Step 3. Declare function\n     let (name, sig) = get_function_name_and_sig(tcx, instance, false);\n     let func_id = cx.module.declare_function(&name, linkage, &sig).unwrap();\n     let mut debug_context = cx\n         .debug_context\n         .as_mut()\n         .map(|debug_context| FunctionDebugContext::new(tcx, debug_context, mir, &name, &sig));\n \n-    // Step 3. Make FunctionBuilder\n+    // Step 4. Make FunctionBuilder\n     let mut func = Function::with_name_signature(ExternalName::user(0, 0), sig);\n     let mut func_ctx = FunctionBuilderContext::new();\n     let mut bcx = FunctionBuilder::new(&mut func, &mut func_ctx);\n \n-    // Step 4. Predefine ebb's\n+    // Step 5. Predefine ebb's\n     let start_ebb = bcx.create_ebb();\n     let mut ebb_map: HashMap<BasicBlock, Ebb> = HashMap::new();\n     for (bb, _bb_data) in mir.basic_blocks().iter_enumerated() {\n         ebb_map.insert(bb, bcx.create_ebb());\n     }\n \n-    // Step 5. Make FunctionCx\n+    // Step 6. Make FunctionCx\n     let pointer_type = cx.module.target_config().pointer_type();\n     let clif_comments = crate::pretty_clif::CommentWriter::new(tcx, instance);\n \n@@ -106,34 +163,34 @@ fn trans_fn<'a, 'clif, 'tcx: 'a, B: Backend + 'static>(\n         source_info_set: indexmap::IndexSet::new(),\n     };\n \n-    // Step 6. Codegen function\n+    // Step 7. Codegen function\n     with_unimpl_span(fx.mir.span, || {\n         crate::abi::codegen_fn_prelude(&mut fx, start_ebb);\n         codegen_fn_content(&mut fx);\n     });\n     let source_info_set = fx.source_info_set.clone();\n \n-    // Step 7. Write function to file for debugging\n+    // Step 8. Write function to file for debugging\n     #[cfg(debug_assertions)]\n     fx.write_clif_file();\n \n-    // Step 8. Verify function\n+    // Step 9. Verify function\n     verify_func(tcx, fx.clif_comments, &func);\n \n-    // Step 9. Define function\n+    // Step 10. Define function\n     cx.caches.context.func = func;\n     cx.module\n         .define_function(func_id, &mut cx.caches.context)\n         .unwrap();\n \n-    // Step 10. Define debuginfo for function\n+    // Step 11. Define debuginfo for function\n     let context = &cx.caches.context;\n     let isa = cx.module.isa();\n     debug_context\n         .as_mut()\n         .map(|x| x.define(tcx, context, isa, &source_info_set));\n \n-    // Step 11. Clear context to make it usable for the next function\n+    // Step 12. Clear context to make it usable for the next function\n     cx.caches.context.clear();\n }\n "}]}