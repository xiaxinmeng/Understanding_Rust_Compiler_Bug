{"sha": "b2ffb28da582d160f0689e6540a212d6d2bfabc5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyZmZiMjhkYTU4MmQxNjBmMDY4OWU2NTQwYTIxMmQ2ZDJiZmFiYzU=", "commit": {"author": {"name": "Kneasle", "email": "kneasle@gmail.com", "date": "2021-09-08T21:51:47Z"}, "committer": {"name": "Kneasle", "email": "kneasle@gmail.com", "date": "2021-09-14T15:51:09Z"}, "message": "Fix FN for collections/smart ptrs in `std`", "tree": {"sha": "eb87c7f3e4a7bbdddba1dcf2ed86bf2f5f7caa24", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb87c7f3e4a7bbdddba1dcf2ed86bf2f5f7caa24"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2ffb28da582d160f0689e6540a212d6d2bfabc5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2ffb28da582d160f0689e6540a212d6d2bfabc5", "html_url": "https://github.com/rust-lang/rust/commit/b2ffb28da582d160f0689e6540a212d6d2bfabc5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2ffb28da582d160f0689e6540a212d6d2bfabc5/comments", "author": {"login": "kneasle", "id": 32932209, "node_id": "MDQ6VXNlcjMyOTMyMjA5", "avatar_url": "https://avatars.githubusercontent.com/u/32932209?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kneasle", "html_url": "https://github.com/kneasle", "followers_url": "https://api.github.com/users/kneasle/followers", "following_url": "https://api.github.com/users/kneasle/following{/other_user}", "gists_url": "https://api.github.com/users/kneasle/gists{/gist_id}", "starred_url": "https://api.github.com/users/kneasle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kneasle/subscriptions", "organizations_url": "https://api.github.com/users/kneasle/orgs", "repos_url": "https://api.github.com/users/kneasle/repos", "events_url": "https://api.github.com/users/kneasle/events{/privacy}", "received_events_url": "https://api.github.com/users/kneasle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kneasle", "id": 32932209, "node_id": "MDQ6VXNlcjMyOTMyMjA5", "avatar_url": "https://avatars.githubusercontent.com/u/32932209?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kneasle", "html_url": "https://github.com/kneasle", "followers_url": "https://api.github.com/users/kneasle/followers", "following_url": "https://api.github.com/users/kneasle/following{/other_user}", "gists_url": "https://api.github.com/users/kneasle/gists{/gist_id}", "starred_url": "https://api.github.com/users/kneasle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kneasle/subscriptions", "organizations_url": "https://api.github.com/users/kneasle/orgs", "repos_url": "https://api.github.com/users/kneasle/repos", "events_url": "https://api.github.com/users/kneasle/events{/privacy}", "received_events_url": "https://api.github.com/users/kneasle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0090735f1d826f78ef8f27e1305038bde2da2de", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0090735f1d826f78ef8f27e1305038bde2da2de", "html_url": "https://github.com/rust-lang/rust/commit/e0090735f1d826f78ef8f27e1305038bde2da2de"}], "stats": {"total": 198, "additions": 161, "deletions": 37}, "files": [{"sha": "cb17e4dbfd0da8cdcf3930b9b32b4e88e5174a78", "filename": "clippy_lints/src/mut_key.rs", "status": "modified", "additions": 59, "deletions": 31, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/b2ffb28da582d160f0689e6540a212d6d2bfabc5/clippy_lints%2Fsrc%2Fmut_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ffb28da582d160f0689e6540a212d6d2bfabc5/clippy_lints%2Fsrc%2Fmut_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_key.rs?ref=b2ffb28da582d160f0689e6540a212d6d2bfabc5", "patch": "@@ -3,7 +3,7 @@ use clippy_utils::trait_ref_of_method;\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::TypeFoldable;\n-use rustc_middle::ty::{Adt, Array, RawPtr, Ref, Slice, Tuple, Ty, TypeAndMut};\n+use rustc_middle::ty::{Adt, Array, Ref, Slice, Tuple, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::sym;\n@@ -19,10 +19,29 @@ declare_clippy_lint! {\n     /// so having types with interior mutability is a bad idea.\n     ///\n     /// ### Known problems\n-    /// It's correct to use a struct, that contains interior mutability\n-    /// as a key, when its `Hash` implementation doesn't access any of the interior mutable types.\n-    /// However, this lint is unable to recognize this, so it causes a false positive in theses cases.\n-    /// The `bytes` crate is a great example of this.\n+    ///\n+    /// #### False Positives\n+    /// It's correct to use a struct that contains interior mutability as a key, when its\n+    /// implementation of `Hash` or `Ord` doesn't access any of the interior mutable types.\n+    /// However, this lint is unable to recognize this, so it will often cause false positives in\n+    /// theses cases.  The `bytes` crate is a great example of this.\n+    ///\n+    /// #### False Negatives\n+    /// For custom `struct`s/`enum`s, this lint is unable to check for interior mutability behind\n+    /// indirection.  For example, `struct BadKey<'a>(&'a Cell<usize>)` will be seen as immutable\n+    /// and cause a false negative if its implementation of `Hash`/`Ord` accesses the `Cell`.\n+    ///\n+    /// This lint does check a few cases for indirection.  Firstly, using some standard library\n+    /// types (`Option`, `Result`, `Box`, `Rc`, `Arc`, `Vec`, `VecDeque`, `BTreeMap` and\n+    /// `BTreeSet`) directly as keys (e.g. in `HashMap<Box<Cell<usize>>, ()>`) **will** trigger the\n+    /// lint, because the impls of `Hash`/`Ord` for these types directly call `Hash`/`Ord` on their\n+    /// contained type.\n+    ///\n+    /// Secondly, the implementations of `Hash` and `Ord` for raw pointers (`*const T` or `*mut T`)\n+    /// apply only to the **address** of the contained value.  Therefore, interior mutability\n+    /// behind raw pointers (e.g. in `HashSet<*mut Cell<usize>>`) can't impact the value of `Hash`\n+    /// or `Ord`, and therefore will not trigger this link.  For more info, see issue\n+    /// [#6745](https://github.com/rust-lang/rust-clippy/issues/6745).\n     ///\n     /// ### Example\n     /// ```rust\n@@ -103,43 +122,52 @@ fn check_sig<'tcx>(cx: &LateContext<'tcx>, item_hir_id: hir::HirId, decl: &hir::\n fn check_ty<'tcx>(cx: &LateContext<'tcx>, span: Span, ty: Ty<'tcx>) {\n     let ty = ty.peel_refs();\n     if let Adt(def, substs) = ty.kind() {\n-        let is_map_type = [sym::hashmap_type, sym::BTreeMap, sym::hashset_type, sym::BTreeMap]\n+        let is_keyed_type = [sym::hashmap_type, sym::BTreeMap, sym::hashset_type, sym::BTreeSet]\n             .iter()\n             .any(|diag_item| cx.tcx.is_diagnostic_item(*diag_item, def.did));\n-        if is_map_type && is_mutable_type(cx, substs.type_at(0), span, true) {\n+        if is_keyed_type && is_interior_mutable_type(cx, substs.type_at(0), span) {\n             span_lint(cx, MUTABLE_KEY_TYPE, span, \"mutable key type\");\n         }\n     }\n }\n \n-fn is_mutable_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span, is_top_level_type: bool) -> bool {\n+/// Determines if a type contains interior mutability which would affect its implementation of\n+/// [`Hash`] or [`Ord`].\n+fn is_interior_mutable_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span) -> bool {\n     match *ty.kind() {\n-        RawPtr(TypeAndMut { ty: inner_ty, mutbl }) => {\n-            if is_top_level_type {\n-                // Raw pointers are hashed by the address they point to, not what is pointed to.\n-                // Therefore, using a raw pointer to any type as the top-level key type is OK.\n-                // Using raw pointers _in_ the key type is not, because the wrapper type could\n-                // provide a custom `impl` for `Hash` (which could deref the raw pointer).\n-                //\n-                // see:\n-                // - clippy issue: https://github.com/rust-lang/rust-clippy/issues/6745\n-                // - std code: https://github.com/rust-lang/rust/blob/1.54.0/library/core/src/hash/mod.rs#L717-L736\n-                false\n-            } else {\n-                mutbl == hir::Mutability::Mut || is_mutable_type(cx, inner_ty, span, false)\n-            }\n-        },\n-        Ref(_, inner_ty, mutbl) => mutbl == hir::Mutability::Mut || is_mutable_type(cx, inner_ty, span, false),\n-        Slice(inner_ty) => is_mutable_type(cx, inner_ty, span, false),\n+        Ref(_, inner_ty, mutbl) => mutbl == hir::Mutability::Mut || is_interior_mutable_type(cx, inner_ty, span),\n+        Slice(inner_ty) => is_interior_mutable_type(cx, inner_ty, span),\n         Array(inner_ty, size) => {\n             size.try_eval_usize(cx.tcx, cx.param_env).map_or(true, |u| u != 0)\n-                && is_mutable_type(cx, inner_ty, span, false)\n+                && is_interior_mutable_type(cx, inner_ty, span)\n         },\n-        Tuple(..) => ty.tuple_fields().any(|ty| is_mutable_type(cx, ty, span, false)),\n-        Adt(..) => {\n-            !ty.has_escaping_bound_vars()\n-                && cx.tcx.layout_of(cx.param_env.and(ty)).is_ok()\n-                && !ty.is_freeze(cx.tcx.at(span), cx.param_env)\n+        Tuple(..) => ty.tuple_fields().any(|ty| is_interior_mutable_type(cx, ty, span)),\n+        Adt(def, substs) => {\n+            // Special case for collections in `std` who's impl of `Hash` or `Ord` delegates to\n+            // that of their type parameters.  Note: we don't include `HashSet` and `HashMap`\n+            // because they have no impl for `Hash` or `Ord`.\n+            let is_std_collection = [\n+                sym::option_type,\n+                sym::result_type,\n+                sym::LinkedList,\n+                sym::vec_type,\n+                sym::vecdeque_type,\n+                sym::BTreeMap,\n+                sym::BTreeSet,\n+                sym::Rc,\n+                sym::Arc,\n+            ]\n+            .iter()\n+            .any(|diag_item| cx.tcx.is_diagnostic_item(*diag_item, def.did));\n+            let is_box = Some(def.did) == cx.tcx.lang_items().owned_box();\n+            if is_std_collection || is_box {\n+                // The type is mutable if any of its type parameters are\n+                substs.types().any(|ty| is_interior_mutable_type(cx, ty, span))\n+            } else {\n+                !ty.has_escaping_bound_vars()\n+                    && cx.tcx.layout_of(cx.param_env.and(ty)).is_ok()\n+                    && !ty.is_freeze(cx.tcx.at(span), cx.param_env)\n+            }\n         },\n         _ => false,\n     }"}, {"sha": "1c0ba664580a40d253923a2ec937db47efac8049", "filename": "tests/ui/mut_key.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b2ffb28da582d160f0689e6540a212d6d2bfabc5/tests%2Fui%2Fmut_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2ffb28da582d160f0689e6540a212d6d2bfabc5/tests%2Fui%2Fmut_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmut_key.rs?ref=b2ffb28da582d160f0689e6540a212d6d2bfabc5", "patch": "@@ -1,7 +1,9 @@\n use std::cell::Cell;\n-use std::collections::{HashMap, HashSet};\n+use std::collections::{BTreeMap, BTreeSet, HashMap, HashSet};\n use std::hash::{Hash, Hasher};\n+use std::rc::Rc;\n use std::sync::atomic::{AtomicUsize, Ordering::Relaxed};\n+use std::sync::Arc;\n \n struct Key(AtomicUsize);\n \n@@ -64,4 +66,20 @@ fn main() {\n \n     raw_ptr_is_ok(&mut HashMap::new());\n     raw_mut_ptr_is_ok(&mut HashMap::new());\n+\n+    let _map = HashMap::<Cell<usize>, usize>::new();\n+    let _map = HashMap::<&mut Cell<usize>, usize>::new();\n+    let _map = HashMap::<&mut usize, usize>::new();\n+    // Collection types from `std` who's impl of `Hash` or `Ord` delegate their type parameters\n+    let _map = HashMap::<Vec<Cell<usize>>, usize>::new();\n+    let _map = HashMap::<BTreeMap<Cell<usize>, ()>, usize>::new();\n+    let _map = HashMap::<BTreeMap<(), Cell<usize>>, usize>::new();\n+    let _map = HashMap::<BTreeSet<Cell<usize>>, usize>::new();\n+    let _map = HashMap::<Option<Cell<usize>>, usize>::new();\n+    let _map = HashMap::<Option<Vec<Cell<usize>>>, usize>::new();\n+    let _map = HashMap::<Result<&mut usize, ()>, usize>::new();\n+    // Smart pointers from `std` who's impl of `Hash` or `Ord` delegate their type parameters\n+    let _map = HashMap::<Box<Cell<usize>>, usize>::new();\n+    let _map = HashMap::<Rc<Cell<usize>>, usize>::new();\n+    let _map = HashMap::<Arc<Cell<usize>>, usize>::new();\n }"}, {"sha": "25dd029b16eeea1e13b5e773613ddf27e106bd4e", "filename": "tests/ui/mut_key.stderr", "status": "modified", "additions": 83, "deletions": 5, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/b2ffb28da582d160f0689e6540a212d6d2bfabc5/tests%2Fui%2Fmut_key.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b2ffb28da582d160f0689e6540a212d6d2bfabc5/tests%2Fui%2Fmut_key.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmut_key.stderr?ref=b2ffb28da582d160f0689e6540a212d6d2bfabc5", "patch": "@@ -1,28 +1,106 @@\n error: mutable key type\n-  --> $DIR/mut_key.rs:28:32\n+  --> $DIR/mut_key.rs:30:32\n    |\n LL | fn should_not_take_this_arg(m: &mut HashMap<Key, usize>, _n: usize) -> HashSet<Key> {\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::mutable-key-type` implied by `-D warnings`\n \n error: mutable key type\n-  --> $DIR/mut_key.rs:28:72\n+  --> $DIR/mut_key.rs:30:72\n    |\n LL | fn should_not_take_this_arg(m: &mut HashMap<Key, usize>, _n: usize) -> HashSet<Key> {\n    |                                                                        ^^^^^^^^^^^^\n \n error: mutable key type\n-  --> $DIR/mut_key.rs:29:5\n+  --> $DIR/mut_key.rs:31:5\n    |\n LL |     let _other: HashMap<Key, bool> = HashMap::new();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: mutable key type\n-  --> $DIR/mut_key.rs:56:22\n+  --> $DIR/mut_key.rs:58:22\n    |\n LL | fn tuples_bad<U>(_m: &mut HashMap<(Key, U), bool>) {}\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 4 previous errors\n+error: mutable key type\n+  --> $DIR/mut_key.rs:70:5\n+   |\n+LL |     let _map = HashMap::<Cell<usize>, usize>::new();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: mutable key type\n+  --> $DIR/mut_key.rs:71:5\n+   |\n+LL |     let _map = HashMap::<&mut Cell<usize>, usize>::new();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: mutable key type\n+  --> $DIR/mut_key.rs:72:5\n+   |\n+LL |     let _map = HashMap::<&mut usize, usize>::new();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: mutable key type\n+  --> $DIR/mut_key.rs:74:5\n+   |\n+LL |     let _map = HashMap::<Vec<Cell<usize>>, usize>::new();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: mutable key type\n+  --> $DIR/mut_key.rs:75:5\n+   |\n+LL |     let _map = HashMap::<BTreeMap<Cell<usize>, ()>, usize>::new();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: mutable key type\n+  --> $DIR/mut_key.rs:76:5\n+   |\n+LL |     let _map = HashMap::<BTreeMap<(), Cell<usize>>, usize>::new();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: mutable key type\n+  --> $DIR/mut_key.rs:77:5\n+   |\n+LL |     let _map = HashMap::<BTreeSet<Cell<usize>>, usize>::new();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: mutable key type\n+  --> $DIR/mut_key.rs:78:5\n+   |\n+LL |     let _map = HashMap::<Option<Cell<usize>>, usize>::new();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: mutable key type\n+  --> $DIR/mut_key.rs:79:5\n+   |\n+LL |     let _map = HashMap::<Option<Vec<Cell<usize>>>, usize>::new();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: mutable key type\n+  --> $DIR/mut_key.rs:80:5\n+   |\n+LL |     let _map = HashMap::<Result<&mut usize, ()>, usize>::new();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: mutable key type\n+  --> $DIR/mut_key.rs:82:5\n+   |\n+LL |     let _map = HashMap::<Box<Cell<usize>>, usize>::new();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: mutable key type\n+  --> $DIR/mut_key.rs:83:5\n+   |\n+LL |     let _map = HashMap::<Rc<Cell<usize>>, usize>::new();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: mutable key type\n+  --> $DIR/mut_key.rs:84:5\n+   |\n+LL |     let _map = HashMap::<Arc<Cell<usize>>, usize>::new();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 17 previous errors\n "}]}