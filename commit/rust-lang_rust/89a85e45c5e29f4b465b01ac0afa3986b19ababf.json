{"sha": "89a85e45c5e29f4b465b01ac0afa3986b19ababf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5YTg1ZTQ1YzVlMjlmNGI0NjViMDFhYzBhZmEzOTg2YjE5YWJhYmY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-21T23:47:08Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-12-26T23:54:32Z"}, "message": "librustc: De-`@mut` `ScopeInfo::cleanups`", "tree": {"sha": "3f888872e6d30c773206e31a8a7106e9b31f4680", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f888872e6d30c773206e31a8a7106e9b31f4680"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89a85e45c5e29f4b465b01ac0afa3986b19ababf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89a85e45c5e29f4b465b01ac0afa3986b19ababf", "html_url": "https://github.com/rust-lang/rust/commit/89a85e45c5e29f4b465b01ac0afa3986b19ababf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89a85e45c5e29f4b465b01ac0afa3986b19ababf/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b1a7b5ca9406c2cedf24f6b14c21720e2b3b470", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b1a7b5ca9406c2cedf24f6b14c21720e2b3b470", "html_url": "https://github.com/rust-lang/rust/commit/3b1a7b5ca9406c2cedf24f6b14c21720e2b3b470"}], "stats": {"total": 135, "additions": 81, "deletions": 54}, "files": [{"sha": "ecd6258bf0f9131c49c5e40b65643f630cf4c896", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/89a85e45c5e29f4b465b01ac0afa3986b19ababf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89a85e45c5e29f4b465b01ac0afa3986b19ababf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=89a85e45c5e29f4b465b01ac0afa3986b19ababf", "patch": "@@ -971,7 +971,8 @@ pub fn need_invoke(bcx: @Block) -> bool {\n     loop {\n         cur_scope = match cur_scope {\n             Some(inf) => {\n-                for cleanup in inf.cleanups.iter() {\n+                let cleanups = inf.cleanups.borrow();\n+                for cleanup in cleanups.get().iter() {\n                     match *cleanup {\n                         clean(_, cleanup_type) | clean_temp(_, _, cleanup_type) => {\n                             if cleanup_type == normal_exit_and_unwind {\n@@ -1221,7 +1222,7 @@ pub fn simple_block_scope(parent: Option<@mut ScopeInfo>,\n         parent: parent,\n         loop_break: None,\n         loop_label: None,\n-        cleanups: ~[],\n+        cleanups: RefCell::new(~[]),\n         cleanup_paths: ~[],\n         landing_pad: None,\n         node_info: node_info,\n@@ -1251,7 +1252,7 @@ pub fn loop_scope_block(bcx: @Block,\n         parent: None,\n         loop_break: Some(loop_break),\n         loop_label: loop_label,\n-        cleanups: ~[],\n+        cleanups: RefCell::new(~[]),\n         cleanup_paths: ~[],\n         landing_pad: None,\n         node_info: opt_node_info,\n@@ -1334,7 +1335,8 @@ pub fn cleanup_and_leave(bcx: @Block,\n                         {\n                             let r = (*inf).cleanup_paths.rev_iter().find(|cp| cp.target == leave);\n                             for cp in r.iter() {\n-                                if cp.size == inf.cleanups.len() {\n+                                let cleanups = inf.cleanups.borrow();\n+                                if cp.size == cleanups.get().len() {\n                                     Br(bcx, cp.dest);\n                                     return;\n                                 }\n@@ -1345,12 +1347,13 @@ pub fn cleanup_and_leave(bcx: @Block,\n                         }\n                         let sub_cx = sub_block(bcx, \"cleanup\");\n                         Br(bcx, sub_cx.llbb);\n+                        let cleanups = inf.cleanups.borrow();\n                         inf.cleanup_paths.push(cleanup_path {\n                             target: leave,\n-                            size: inf.cleanups.len(),\n+                            size: cleanups.get().len(),\n                             dest: sub_cx.llbb\n                         });\n-                        (sub_cx, dest, inf.cleanups.tailn(skip).to_owned())\n+                        (sub_cx, dest, cleanups.get().tailn(skip).to_owned())\n                     };\n                     bcx = trans_block_cleanups_(sub_cx,\n                                                 inf_cleanups,\n@@ -1394,8 +1397,11 @@ pub fn cleanup_block(bcx: @Block, upto: Option<BasicBlockRef>) -> @Block{\n         let mut cur_scope = cur.scope.get();\n         loop {\n             cur_scope = match cur_scope {\n-                Some (inf) => {\n-                    bcx = trans_block_cleanups_(bcx, inf.cleanups.to_owned(), false);\n+                Some(inf) => {\n+                    let cleanups = inf.cleanups.borrow();\n+                    bcx = trans_block_cleanups_(bcx,\n+                                                cleanups.get().to_owned(),\n+                                                false);\n                     inf.parent\n                 }\n                 None => break\n@@ -1443,7 +1449,7 @@ pub fn with_scope(bcx: @Block,\n     let scope = simple_block_scope(bcx.scope.get(), opt_node_info);\n     bcx.scope.set(Some(scope));\n     let ret = f(bcx);\n-    let ret = trans_block_cleanups_(ret, (scope.cleanups).clone(), false);\n+    let ret = trans_block_cleanups_(ret, scope.cleanups.get(), false);\n     bcx.scope.set(scope.parent);\n     ret\n }\n@@ -1458,9 +1464,7 @@ pub fn with_scope_result(bcx: @Block,\n     let scope = simple_block_scope(bcx.scope.get(), opt_node_info);\n     bcx.scope.set(Some(scope));\n     let Result { bcx: out_bcx, val } = f(bcx);\n-    let out_bcx = trans_block_cleanups_(out_bcx,\n-                                        (scope.cleanups).clone(),\n-                                        false);\n+    let out_bcx = trans_block_cleanups_(out_bcx, scope.cleanups.get(), false);\n     bcx.scope.set(scope.parent);\n \n     rslt(out_bcx, val)"}, {"sha": "9e25756fc4976b9c4f96c1356b7feb3c9f451c72", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 65, "deletions": 42, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/89a85e45c5e29f4b465b01ac0afa3986b19ababf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89a85e45c5e29f4b465b01ac0afa3986b19ababf/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=89a85e45c5e29f4b465b01ac0afa3986b19ababf", "patch": "@@ -457,11 +457,14 @@ pub fn add_clean(bcx: @Block, val: ValueRef, t: ty::t) {\n \n     let cleanup_type = cleanup_type(bcx.tcx(), t);\n     in_scope_cx(bcx, None, |scope_info| {\n-        scope_info.cleanups.push(clean(@TypeDroppingCleanupFunction {\n-            val: val,\n-            t: t,\n-        } as @CleanupFunction,\n-        cleanup_type));\n+        {\n+            let mut cleanups = scope_info.cleanups.borrow_mut();\n+            cleanups.get().push(clean(@TypeDroppingCleanupFunction {\n+                val: val,\n+                t: t,\n+            } as @CleanupFunction,\n+            cleanup_type));\n+        }\n         grow_scope_clean(scope_info);\n     })\n }\n@@ -473,12 +476,15 @@ pub fn add_clean_temp_immediate(cx: @Block, val: ValueRef, ty: ty::t) {\n            ty.repr(cx.tcx()));\n     let cleanup_type = cleanup_type(cx.tcx(), ty);\n     in_scope_cx(cx, None, |scope_info| {\n-        scope_info.cleanups.push(clean_temp(val,\n-            @ImmediateTypeDroppingCleanupFunction {\n-                val: val,\n-                t: ty,\n-            } as @CleanupFunction,\n-            cleanup_type));\n+        {\n+            let mut cleanups = scope_info.cleanups.borrow_mut();\n+            cleanups.get().push(clean_temp(val,\n+                @ImmediateTypeDroppingCleanupFunction {\n+                    val: val,\n+                    t: ty,\n+                } as @CleanupFunction,\n+                cleanup_type));\n+        }\n         grow_scope_clean(scope_info);\n     })\n }\n@@ -502,12 +508,15 @@ pub fn add_clean_temp_mem_in_scope_(bcx: @Block, scope_id: Option<ast::NodeId>,\n            t.repr(bcx.tcx()));\n     let cleanup_type = cleanup_type(bcx.tcx(), t);\n     in_scope_cx(bcx, scope_id, |scope_info| {\n-        scope_info.cleanups.push(clean_temp(val,\n-            @TypeDroppingCleanupFunction {\n-                val: val,\n-                t: t,\n-            } as @CleanupFunction,\n-            cleanup_type));\n+        {\n+            let mut cleanups = scope_info.cleanups.borrow_mut();\n+            cleanups.get().push(clean_temp(val,\n+                @TypeDroppingCleanupFunction {\n+                    val: val,\n+                    t: t,\n+                } as @CleanupFunction,\n+                cleanup_type));\n+        }\n         grow_scope_clean(scope_info);\n     })\n }\n@@ -531,16 +540,19 @@ pub fn add_clean_return_to_mut(bcx: @Block,\n            bcx.val_to_str(frozen_val_ref),\n            bcx.val_to_str(bits_val_ref));\n     in_scope_cx(bcx, Some(scope_id), |scope_info| {\n-        scope_info.cleanups.push(clean_temp(\n-                frozen_val_ref,\n-                @WriteGuardReleasingCleanupFunction {\n-                    root_key: root_key,\n-                    frozen_val_ref: frozen_val_ref,\n-                    bits_val_ref: bits_val_ref,\n-                    filename_val: filename_val,\n-                    line_val: line_val,\n-                } as @CleanupFunction,\n-                normal_exit_only));\n+        {\n+            let mut cleanups = scope_info.cleanups.borrow_mut();\n+            cleanups.get().push(clean_temp(\n+                    frozen_val_ref,\n+                    @WriteGuardReleasingCleanupFunction {\n+                        root_key: root_key,\n+                        frozen_val_ref: frozen_val_ref,\n+                        bits_val_ref: bits_val_ref,\n+                        filename_val: filename_val,\n+                        line_val: line_val,\n+                    } as @CleanupFunction,\n+                    normal_exit_only));\n+        }\n         grow_scope_clean(scope_info);\n     })\n }\n@@ -558,9 +570,12 @@ pub fn add_clean_free(cx: @Block, ptr: ValueRef, heap: heap) {\n         }\n     };\n     in_scope_cx(cx, None, |scope_info| {\n-        scope_info.cleanups.push(clean_temp(ptr,\n-                                            free_fn,\n-                                            normal_exit_and_unwind));\n+        {\n+            let mut cleanups = scope_info.cleanups.borrow_mut();\n+            cleanups.get().push(clean_temp(ptr,\n+                                           free_fn,\n+                                           normal_exit_and_unwind));\n+        }\n         grow_scope_clean(scope_info);\n     })\n }\n@@ -571,16 +586,23 @@ pub fn add_clean_free(cx: @Block, ptr: ValueRef, heap: heap) {\n // drop glue checks whether it is zero.\n pub fn revoke_clean(cx: @Block, val: ValueRef) {\n     in_scope_cx(cx, None, |scope_info| {\n-        let cleanup_pos = scope_info.cleanups.iter().position(\n-            |cu| match *cu {\n-                clean_temp(v, _, _) if v == val => true,\n-                _ => false\n-            });\n+        let cleanup_pos = {\n+            let mut cleanups = scope_info.cleanups.borrow_mut();\n+            cleanups.get().iter().position(|cu| {\n+                match *cu {\n+                    clean_temp(v, _, _) if v == val => true,\n+                    _ => false\n+                }\n+            })\n+        };\n         for i in cleanup_pos.iter() {\n-            scope_info.cleanups =\n-                vec::append(scope_info.cleanups.slice(0u, *i).to_owned(),\n-                            scope_info.cleanups.slice(*i + 1u,\n-                                                      scope_info.cleanups.len()));\n+            let new_cleanups = {\n+                let cleanups = scope_info.cleanups.borrow();\n+                vec::append(cleanups.get().slice(0u, *i).to_owned(),\n+                            cleanups.get().slice(*i + 1u, cleanups.get()\n+                                                                  .len()))\n+            };\n+            scope_info.cleanups.set(new_cleanups);\n             shrink_scope_clean(scope_info, *i);\n         }\n     })\n@@ -589,7 +611,7 @@ pub fn revoke_clean(cx: @Block, val: ValueRef) {\n pub fn block_cleanups(bcx: &Block) -> ~[cleanup] {\n     match bcx.scope.get() {\n        None  => ~[],\n-       Some(inf) => inf.cleanups.clone(),\n+       Some(inf) => inf.cleanups.get(),\n     }\n }\n \n@@ -600,7 +622,7 @@ pub struct ScopeInfo {\n     // A list of functions that must be run at when leaving this\n     // block, cleaning up any variables that were introduced in the\n     // block.\n-    cleanups: ~[cleanup],\n+    cleanups: RefCell<~[cleanup]>,\n     // Existing cleanup paths that may be reused, indexed by destination and\n     // cleared when the set of cleanups changes.\n     cleanup_paths: ~[cleanup_path],\n@@ -612,7 +634,8 @@ pub struct ScopeInfo {\n \n impl ScopeInfo {\n     pub fn empty_cleanups(&mut self) -> bool {\n-        self.cleanups.is_empty()\n+        let cleanups = self.cleanups.borrow();\n+        cleanups.get().is_empty()\n     }\n }\n "}]}