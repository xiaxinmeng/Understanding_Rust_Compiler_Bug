{"sha": "626ad484fecc5703f46812c7916fce6fec03ace9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyNmFkNDg0ZmVjYzU3MDNmNDY4MTJjNzkxNmZjZTZmZWMwM2FjZTk=", "commit": {"author": {"name": "Jed Davis", "email": "jld@panix.com", "date": "2013-02-18T22:16:21Z"}, "committer": {"name": "Jed Davis", "email": "jld@panix.com", "date": "2013-03-07T04:37:23Z"}, "message": "Unified algebraic datatype representation implementation, initial version.\n\nLater changes on this branch adapt the rest of rustc::middle::trans\nto use this module instead of scattered hard-coded knowledge of\nrepresentations; a few of them also have improvements or cleanup for\nadt.rs (and many added comments) that weren't drastic enough to justify\nchanging history to move them into this commit.", "tree": {"sha": "9510f11d375c3cd3adead352fe3a26bf65018b7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9510f11d375c3cd3adead352fe3a26bf65018b7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/626ad484fecc5703f46812c7916fce6fec03ace9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/626ad484fecc5703f46812c7916fce6fec03ace9", "html_url": "https://github.com/rust-lang/rust/commit/626ad484fecc5703f46812c7916fce6fec03ace9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/626ad484fecc5703f46812c7916fce6fec03ace9/comments", "author": {"login": "jld", "id": 254973, "node_id": "MDQ6VXNlcjI1NDk3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/254973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jld", "html_url": "https://github.com/jld", "followers_url": "https://api.github.com/users/jld/followers", "following_url": "https://api.github.com/users/jld/following{/other_user}", "gists_url": "https://api.github.com/users/jld/gists{/gist_id}", "starred_url": "https://api.github.com/users/jld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jld/subscriptions", "organizations_url": "https://api.github.com/users/jld/orgs", "repos_url": "https://api.github.com/users/jld/repos", "events_url": "https://api.github.com/users/jld/events{/privacy}", "received_events_url": "https://api.github.com/users/jld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jld", "id": 254973, "node_id": "MDQ6VXNlcjI1NDk3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/254973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jld", "html_url": "https://github.com/jld", "followers_url": "https://api.github.com/users/jld/followers", "following_url": "https://api.github.com/users/jld/following{/other_user}", "gists_url": "https://api.github.com/users/jld/gists{/gist_id}", "starred_url": "https://api.github.com/users/jld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jld/subscriptions", "organizations_url": "https://api.github.com/users/jld/orgs", "repos_url": "https://api.github.com/users/jld/repos", "events_url": "https://api.github.com/users/jld/events{/privacy}", "received_events_url": "https://api.github.com/users/jld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b269ce278228918b95f803e1951fa60e3ef48a0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b269ce278228918b95f803e1951fa60e3ef48a0a", "html_url": "https://github.com/rust-lang/rust/commit/b269ce278228918b95f803e1951fa60e3ef48a0a"}], "stats": {"total": 381, "additions": 366, "deletions": 15}, "files": [{"sha": "21f113a08aa7701546d12ca370cbb6350ea11143", "filename": "src/librustc/middle/trans/adt.rs", "status": "added", "additions": 326, "deletions": 0, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/626ad484fecc5703f46812c7916fce6fec03ace9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/626ad484fecc5703f46812c7916fce6fec03ace9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=626ad484fecc5703f46812c7916fce6fec03ace9", "patch": "@@ -0,0 +1,326 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::option::{Option, Some, None};\n+use core::vec;\n+use lib::llvm::{ValueRef, TypeRef};\n+use middle::trans::_match;\n+use middle::trans::build::*;\n+use middle::trans::common::*;\n+use middle::trans::machine;\n+use middle::trans::type_of;\n+use middle::ty;\n+use syntax::ast;\n+use util::ppaux::ty_to_str;\n+\n+\n+// XXX: should this be done with boxed traits instead of ML-style?\n+pub enum Repr {\n+    CEnum,\n+    Univariant(Struct, Destructor),\n+    General(~[Struct])\n+}\n+\n+enum Destructor {\n+    DtorPresent,\n+    DtorAbsent,\n+    NoDtor\n+}\n+\n+struct Struct {\n+    size: u64,\n+    align: u64,\n+    fields: ~[ty::t]\n+}\n+\n+\n+pub fn represent_node(bcx: block, node: ast::node_id)\n+    -> Repr {\n+    represent_type(bcx.ccx(), node_id_type(bcx, node))\n+}\n+\n+pub fn represent_type(cx: @CrateContext, t: ty::t) -> Repr {\n+    debug!(\"Representing: %s\", ty_to_str(cx.tcx, t));\n+    // XXX: cache this\n+    match ty::get(t).sty {\n+        ty::ty_tup(ref elems) => {\n+            Univariant(mk_struct(cx, *elems), NoDtor)\n+        }\n+        ty::ty_rec(ref fields) => {\n+            // XXX: Are these in the right order?\n+            Univariant(mk_struct(cx, fields.map(|f| f.mt.ty)), DtorAbsent)\n+        }\n+        ty::ty_struct(def_id, ref substs) => {\n+            let fields = ty::lookup_struct_fields(cx.tcx, def_id);\n+            let dt = ty::ty_dtor(cx.tcx, def_id).is_present();\n+            Univariant(mk_struct(cx, fields.map(|field| {\n+                ty::lookup_field_type(cx.tcx, def_id, field.id, substs)\n+            })), if dt { DtorPresent } else { DtorAbsent })\n+        }\n+        ty::ty_enum(def_id, ref substs) => {\n+            struct Case { discr: i64, tys: ~[ty::t] };\n+\n+            let cases = do ty::enum_variants(cx.tcx, def_id).map |vi| {\n+                let arg_tys = do vi.args.map |&raw_ty| {\n+                    ty::subst(cx.tcx, substs, raw_ty)\n+                };\n+                Case { discr: vi.disr_val /*bad*/as i64, tys: arg_tys }\n+            };\n+            if cases.len() == 0 {\n+                // Uninhabitable; represent as unit\n+                Univariant(mk_struct(cx, ~[]), NoDtor)\n+            } else if cases.len() == 1 && cases[0].discr == 0 {\n+                // struct, tuple, newtype, etc.\n+                Univariant(mk_struct(cx, cases[0].tys), NoDtor)\n+            } else if cases.all(|c| c.tys.len() == 0) {\n+                CEnum\n+            } else {\n+                if !cases.alli(|i,c| c.discr == (i as i64)) {\n+                    cx.sess.bug(fmt!(\"non-C-like enum %s with specified \\\n+                                      discriminants\",\n+                                     ty::item_path_str(cx.tcx, def_id)))\n+                }\n+                General(cases.map(|c| mk_struct(cx, c.tys)))\n+            }\n+        }\n+        _ => cx.sess.bug(~\"adt::represent_type called on non-ADT type\")\n+    }\n+}\n+\n+fn mk_struct(cx: @CrateContext, tys: &[ty::t]) -> Struct {\n+    let lltys = tys.map(|&ty| type_of::sizing_type_of(cx, ty));\n+    let llty_rec = T_struct(lltys);\n+    Struct {\n+        size: machine::llsize_of_alloc(cx, llty_rec) /*bad*/as u64,\n+        align: machine::llalign_of_min(cx, llty_rec) /*bad*/as u64,\n+        fields: vec::from_slice(tys)\n+    }\n+}\n+\n+\n+pub fn sizing_fields_of(cx: @CrateContext, r: &Repr) -> ~[TypeRef] {\n+    generic_fields_of(cx, r, true)\n+}\n+pub fn fields_of(cx: @CrateContext, r: &Repr) -> ~[TypeRef] {\n+    generic_fields_of(cx, r, false)\n+}\n+fn generic_fields_of(cx: @CrateContext, r: &Repr, sizing: bool)\n+    -> ~[TypeRef] {\n+    match *r {\n+        CEnum => ~[T_enum_discrim(cx)],\n+        Univariant(ref st, dt) => {\n+            let f = if sizing {\n+                st.fields.map(|&ty| type_of::sizing_type_of(cx, ty))\n+            } else {\n+                st.fields.map(|&ty| type_of::type_of(cx, ty))\n+            };\n+            match dt {\n+                NoDtor => f,\n+                DtorAbsent => ~[T_struct(f)],\n+                DtorPresent => ~[T_struct(f), T_i8()]\n+            }\n+        }\n+        General(ref sts) => {\n+            ~[T_enum_discrim(cx),\n+              T_array(T_i8(), sts.map(|st| st.size).max() /*bad*/as uint)]\n+        }\n+    }\n+}\n+\n+pub fn trans_switch(bcx: block, r: &Repr, scrutinee: ValueRef) ->\n+    (_match::branch_kind, Option<ValueRef>) {\n+    // XXX: LoadRangeAssert\n+    match *r {\n+        CEnum => {\n+            (_match::switch, Some(Load(bcx, GEPi(bcx, scrutinee, [0, 0]))))\n+        }\n+        Univariant(*) => {\n+            (_match::single, None)\n+        }\n+        General(*) => {\n+            (_match::switch, Some(Load(bcx, GEPi(bcx, scrutinee, [0, 0]))))\n+        }\n+    }\n+}\n+\n+pub fn trans_case(bcx: block, r: &Repr, discr: int) -> _match::opt_result {\n+    match *r {\n+        CEnum => {\n+            _match::single_result(rslt(bcx, C_int(bcx.ccx(), discr)))\n+        }\n+        Univariant(*) => {\n+            bcx.ccx().sess.bug(~\"no cases for univariants or structs\")\n+        }\n+        General(*) => {\n+            _match::single_result(rslt(bcx, C_int(bcx.ccx(), discr)))\n+        }\n+    }\n+}\n+\n+pub fn trans_set_discr(bcx: block, r: &Repr, val: ValueRef, discr: int) {\n+    match *r {\n+        CEnum => {\n+            Store(bcx, C_int(bcx.ccx(), discr), GEPi(bcx, val, [0, 0]))\n+        }\n+        Univariant(_, DtorPresent) => {\n+            assert discr == 0;\n+            Store(bcx, C_u8(1), GEPi(bcx, val, [0, 1]))\n+        }\n+        Univariant(*) => {\n+            assert discr == 0;\n+        }\n+        General(*) => {\n+            Store(bcx, C_int(bcx.ccx(), discr), GEPi(bcx, val, [0, 0]))\n+        }\n+    }\n+}\n+\n+pub fn num_args(r: &Repr, discr: int) -> uint {\n+    match *r {\n+        CEnum => 0,\n+        Univariant(ref st, _dt) => { assert discr == 0; st.fields.len() }\n+        General(ref cases) => cases[discr as uint].fields.len()\n+    }\n+}\n+\n+pub fn trans_GEP(bcx: block, r: &Repr, val: ValueRef, discr: int, ix: uint)\n+    -> ValueRef {\n+    // Note: if this ever needs to generate conditionals (e.g., if we\n+    // decide to do some kind of cdr-coding-like non-unique repr\n+    // someday), it'll need to return a possibly-new bcx as well.\n+    match *r {\n+        CEnum => {\n+            bcx.ccx().sess.bug(~\"element access in C-like enum\")\n+        }\n+        Univariant(ref st, dt) => {\n+            assert discr == 0;\n+            let val = match dt {\n+                NoDtor => val,\n+                DtorPresent | DtorAbsent => GEPi(bcx, val, [0, 0])\n+            };\n+            struct_GEP(bcx, st, val, ix)\n+        }\n+        General(ref cases) => {\n+            struct_GEP(bcx, &cases[discr as uint],\n+                       GEPi(bcx, val, [0, 1]), ix)\n+        }\n+    }\n+}\n+\n+fn struct_GEP(bcx: block, st: &Struct, val: ValueRef, ix: uint)\n+    -> ValueRef {\n+    let ccx = bcx.ccx();\n+\n+    let real_llty = T_struct(st.fields.map(\n+        |&ty| type_of::type_of(ccx, ty)));\n+    let cast_val = PointerCast(bcx, val, T_ptr(real_llty));\n+\n+    GEPi(bcx, cast_val, [0, ix])\n+}\n+\n+pub fn trans_const(ccx: @CrateContext, r: &Repr, discr: int,\n+                   vals: &[ValueRef]) -> ValueRef {\n+    match *r {\n+        CEnum => {\n+            assert vals.len() == 0;\n+            C_int(ccx, discr)\n+        }\n+        Univariant(ref st, _dt) => {\n+            assert discr == 0;\n+            // consts are never destroyed, so the dtor flag is not needed\n+            C_struct(build_const_struct(ccx, st, vals))\n+        }\n+        General(ref cases) => {\n+            let case = &cases[discr as uint];\n+            let max_sz = cases.map(|s| s.size).max();\n+            let body = build_const_struct(ccx, case, vals);\n+\n+            C_struct([C_int(ccx, discr),\n+                      C_packed_struct([C_struct(body)]),\n+                      padding(max_sz - case.size)])\n+        }\n+    }\n+}\n+\n+fn padding(size: u64) -> ValueRef {\n+    C_undef(T_array(T_i8(), size /*bad*/as uint))\n+}\n+\n+fn build_const_struct(ccx: @CrateContext, st: &Struct, vals: &[ValueRef])\n+    -> ~[ValueRef] {\n+    assert vals.len() == st.fields.len();\n+\n+    let mut offset = 0;\n+    let mut cfields = ~[];\n+    for st.fields.eachi |i, &ty| {\n+        let llty = type_of::sizing_type_of(ccx, ty);\n+        let type_align = machine::llalign_of_min(ccx, llty)\n+            /*bad*/as u64;\n+        let val_align = machine::llalign_of_min(ccx, val_ty(vals[i]))\n+            /*bad*/as u64;\n+        let target_offset = roundup(offset, type_align);\n+        offset = roundup(offset, val_align);\n+        if (offset != target_offset) {\n+            cfields.push(padding(target_offset - offset));\n+            offset = target_offset;\n+        }\n+        assert !is_undef(vals[i]);\n+        // If that assert fails, could change it to wrap in a struct?\n+        cfields.push(vals[i]);\n+    }\n+\n+    return cfields;\n+}\n+\n+#[always_inline]\n+fn roundup(x: u64, a: u64) -> u64 { ((x + (a - 1)) / a) * a }\n+\n+\n+pub fn const_get_discrim(ccx: @CrateContext, r: &Repr, val: ValueRef)\n+    -> int {\n+    match *r {\n+        CEnum(*) => const_to_int(val) as int,\n+        Univariant(*) => 0,\n+        General(*) => const_to_int(const_get_elt(ccx, val, [0])) as int,\n+    }\n+}\n+\n+pub fn const_get_element(ccx: @CrateContext, r: &Repr, val: ValueRef,\n+                         _discr: int, ix: uint) -> ValueRef {\n+    // Not to be confused with common::const_get_elt.\n+    match *r {\n+        CEnum(*) => ccx.sess.bug(~\"element access in C-like enum const\"),\n+        Univariant(*) => const_struct_field(ccx, val, ix),\n+        General(*) => const_struct_field(ccx, const_get_elt(ccx, val,\n+                                                            [1, 0]), ix)\n+    }\n+}\n+\n+fn const_struct_field(ccx: @CrateContext, val: ValueRef, ix: uint)\n+    -> ValueRef {\n+    // Get the ix-th non-undef element of the struct.\n+    let mut real_ix = 0; // actual position in the struct\n+    let mut ix = ix; // logical index relative to real_ix\n+    let mut field;\n+    loop {\n+        loop {\n+            field = const_get_elt(ccx, val, [real_ix]);\n+            if !is_undef(field) {\n+                break;\n+            }\n+            real_ix = real_ix + 1;\n+        }\n+        if ix == 0 {\n+            return field;\n+        }\n+        ix = ix - 1;\n+        real_ix = real_ix + 1;\n+    }\n+}"}, {"sha": "2d06a5a5e8788530c58681dfa8a58c7e048402d1", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/626ad484fecc5703f46812c7916fce6fec03ace9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/626ad484fecc5703f46812c7916fce6fec03ace9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=626ad484fecc5703f46812c7916fce6fec03ace9", "patch": "@@ -44,7 +44,7 @@ use util::ppaux::{expr_repr, ty_to_str};\n \n use core::cast;\n use core::hash;\n-use core::libc::c_uint;\n+use core::libc::{c_uint, c_longlong, c_ulonglong};\n use core::ptr;\n use core::str;\n use core::to_bytes;\n@@ -1087,6 +1087,12 @@ pub fn C_null(t: TypeRef) -> ValueRef {\n     }\n }\n \n+pub fn C_undef(t: TypeRef) -> ValueRef {\n+    unsafe {\n+        return llvm::LLVMGetUndef(t);\n+    }\n+}\n+\n pub fn C_integral(t: TypeRef, u: u64, sign_extend: Bool) -> ValueRef {\n     unsafe {\n         return llvm::LLVMConstInt(t, u, sign_extend);\n@@ -1254,6 +1260,38 @@ pub fn get_param(fndecl: ValueRef, param: uint) -> ValueRef {\n     }\n }\n \n+pub fn const_get_elt(cx: @CrateContext, v: ValueRef, us: &[c_uint])\n+                  -> ValueRef {\n+    unsafe {\n+        let r = do vec::as_imm_buf(us) |p, len| {\n+            llvm::LLVMConstExtractValue(v, p, len as c_uint)\n+        };\n+\n+        debug!(\"const_get_elt(v=%s, us=%?, r=%s)\",\n+               val_str(cx.tn, v), us, val_str(cx.tn, r));\n+\n+        return r;\n+    }\n+}\n+\n+pub fn const_to_int(v: ValueRef) -> c_longlong {\n+    unsafe {\n+        llvm::LLVMConstIntGetSExtValue(v)\n+    }\n+}\n+\n+pub fn const_to_uint(v: ValueRef) -> c_ulonglong {\n+    unsafe {\n+        llvm::LLVMConstIntGetZExtValue(v)\n+    }\n+}\n+\n+pub fn is_undef(val: ValueRef) -> bool {\n+    unsafe {\n+        llvm::LLVMIsUndef(val) != False\n+    }\n+}\n+\n // Used to identify cached monomorphized functions and vtables\n #[deriving_eq]\n pub enum mono_param_id {"}, {"sha": "6d37c4393ab9f45b33be811c62ad548295d73cfb", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/626ad484fecc5703f46812c7916fce6fec03ace9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/626ad484fecc5703f46812c7916fce6fec03ace9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=626ad484fecc5703f46812c7916fce6fec03ace9", "patch": "@@ -103,20 +103,6 @@ pub fn const_deref(cx: @CrateContext, v: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn const_get_elt(cx: @CrateContext, v: ValueRef, us: &[c_uint])\n-                  -> ValueRef {\n-    unsafe {\n-        let r = do vec::as_imm_buf(us) |p, len| {\n-            llvm::LLVMConstExtractValue(v, p, len as c_uint)\n-        };\n-\n-        debug!(\"const_get_elt(v=%s, us=%?, r=%s)\",\n-               val_str(cx.tn, v), us, val_str(cx.tn, r));\n-\n-        return r;\n-    }\n-}\n-\n pub fn const_autoderef(cx: @CrateContext, ty: ty::t, v: ValueRef)\n     -> (ty::t, ValueRef) {\n     let mut t1 = ty;"}, {"sha": "355ecaed7d7e0a6d7ba6d8f651e35df67869fc5f", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/626ad484fecc5703f46812c7916fce6fec03ace9/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/626ad484fecc5703f46812c7916fce6fec03ace9/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=626ad484fecc5703f46812c7916fce6fec03ace9", "patch": "@@ -65,6 +65,7 @@ pub mod middle {\n         pub mod type_use;\n         pub mod reachable;\n         pub mod machine;\n+        pub mod adt;\n     }\n     pub mod ty;\n     pub mod resolve;"}]}