{"sha": "41b02b7c57092f1da63beec60358061a9579d8c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxYjAyYjdjNTcwOTJmMWRhNjNiZWVjNjAzNTgwNjFhOTU3OWQ4YzY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-05-31T08:26:05Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-05-31T08:26:05Z"}, "message": "Merge remote-tracking branch 'brson/self-describing-uniques'\n\nConflicts:\n\tsrc/snapshots.txt", "tree": {"sha": "ddf24839509ffcf50f6fc57c570b13a5b223ec87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ddf24839509ffcf50f6fc57c570b13a5b223ec87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41b02b7c57092f1da63beec60358061a9579d8c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41b02b7c57092f1da63beec60358061a9579d8c6", "html_url": "https://github.com/rust-lang/rust/commit/41b02b7c57092f1da63beec60358061a9579d8c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41b02b7c57092f1da63beec60358061a9579d8c6/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "615f5324754bdbb97998181cf1ada4c53337c7f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/615f5324754bdbb97998181cf1ada4c53337c7f3", "html_url": "https://github.com/rust-lang/rust/commit/615f5324754bdbb97998181cf1ada4c53337c7f3"}, {"sha": "3a2c92b46334d422c438061335f6f76669c8743f", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a2c92b46334d422c438061335f6f76669c8743f", "html_url": "https://github.com/rust-lang/rust/commit/3a2c92b46334d422c438061335f6f76669c8743f"}], "stats": {"total": 793, "additions": 495, "deletions": 298}, "files": [{"sha": "1065ac3f3964adee38050989dac15a2a23a3fdeb", "filename": "mk/host.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41b02b7c57092f1da63beec60358061a9579d8c6/mk%2Fhost.mk", "raw_url": "https://github.com/rust-lang/rust/raw/41b02b7c57092f1da63beec60358061a9579d8c6/mk%2Fhost.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fhost.mk?ref=41b02b7c57092f1da63beec60358061a9579d8c6", "patch": "@@ -74,7 +74,7 @@ $$(HLIB$(2)_H_$(4))/$$(CFG_STDLIB): \\\n \t@$$(call E, cp: $$@)\n \t$$(Q)cp $$< $$@\n \t$$(Q)cp -R $$(TLIB$(1)_T_$(4)_H_$(3))/$(STDLIB_GLOB) \\\n-\t\t$$(TLIB$(1)_T_$(4)_H_$(3))/$(STDLIB_DSYM_GLOB) \\\n+\t\t$$(wildcard $$(TLIB$(1)_T_$(4)_H_$(3))/$(STDLIB_DSYM_GLOB)) \\\n \t        $$(HLIB$(2)_H_$(4))\n \n $$(HLIB$(2)_H_$(4))/libcore.rlib: \\"}, {"sha": "b6e00b978aa4d8dd25d329fa2837e8ab5d906de4", "filename": "mk/target.mk", "status": "modified", "additions": 39, "deletions": 9, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/41b02b7c57092f1da63beec60358061a9579d8c6/mk%2Ftarget.mk", "raw_url": "https://github.com/rust-lang/rust/raw/41b02b7c57092f1da63beec60358061a9579d8c6/mk%2Ftarget.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftarget.mk?ref=41b02b7c57092f1da63beec60358061a9579d8c6", "patch": "@@ -8,8 +8,9 @@\n # (resp.  corelib), set this flag to 1.  It will cause stage1 to use\n # the snapshot runtime (resp. corelib) rather than the runtime\n # (resp. corelib) from the working directory.\n-USE_SNAPSHOT_RUNTIME=0\n-USE_SNAPSHOT_CORELIB=0\n+USE_SNAPSHOT_RUNTIME=1\n+USE_SNAPSHOT_CORELIB=1\n+USE_SNAPSHOT_STDLIB=1\n \n define TARGET_STAGE_N\n \n@@ -18,13 +19,6 @@ $$(TLIB$(1)_T_$(2)_H_$(3))/libmorestack.a: \\\n \t@$$(call E, cp: $$@)\n \t$$(Q)cp $$< $$@\n \n-$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_STDLIB): \\\n-\t\t$$(STDLIB_CRATE) $$(STDLIB_INPUTS) \\\n-\t        $$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_CORELIB) \\\n-\t\t$$(TSREQ$(1)_T_$(2)_H_$(3))\n-\t@$$(call E, compile_and_link: $$@)\n-\t$$(STAGE$(1)_T_$(2)_H_$(3)) -o $$@ $$< && touch $$@\n-\n $$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_RUSTLLVM): \\\n \t\trustllvm/$(2)/$$(CFG_RUSTLLVM)\n \t@$$(call E, cp: $$@)\n@@ -116,6 +110,30 @@ $$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_CORELIB): \\\n \n endef\n \n+define TARGET_STDLIB_FROM_SNAPSHOT\n+\n+$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_STDLIB): \\\n+\t\t$$(HLIB$(1)_H_$(3))/$$(CFG_STDLIB) \\\n+\t\t$$(STDLIB_INPUTS) \\\n+\t\t$$(TSREQ$(1)_T_$(2)_H_$(3))\n+\t@$$(call E, cp: $$@)\n+\t$$(Q)cp $$< $$@\n+\t$$(Q)cp $$(HLIB$(1)_H_$(3))/$$(STDLIB_GLOB) \\\n+\t\t$$(TLIB$(1)_T_$(2)_H_$(3))\n+\n+endef\n+\n+define TARGET_STDLIB_FROM_WD\n+\n+$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_STDLIB): \\\n+\t\t$$(STDLIB_CRATE) $$(STDLIB_INPUTS) \\\n+\t        $$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_CORELIB) \\\n+\t\t$$(TSREQ$(1)_T_$(2)_H_$(3))\n+\t@$$(call E, compile_and_link: $$@)\n+\t$$(STAGE$(1)_T_$(2)_H_$(3)) -o $$@ $$< && touch $$@\n+\n+endef\n+\n # In principle, each host can build each target:\n $(foreach source,$(CFG_TARGET_TRIPLES),\t\t\t\t\\\n  $(foreach target,$(CFG_TARGET_TRIPLES),\t\t\t\\\n@@ -142,11 +160,20 @@ else\n \t\t$(eval $(call TARGET_CORELIB_FROM_WD,0,$(src),$(src))))\n endif\n \n+ifeq ($(USE_SNAPSHOT_STDLIB),1)\n+    $(foreach src,$(CFG_HOST_TRIPLE),\\\n+\t\t$(eval $(call TARGET_STDLIB_FROM_SNAPSHOT,0,$(src),$(src))))\n+else\n+    $(foreach src,$(CFG_HOST_TRIPLE),\\\n+\t\t$(eval $(call TARGET_STDLIB_FROM_WD,0,$(src),$(src))))\n+endif\n+\n # Non-host triples build the stage0 runtime from the working directory\n $(foreach source,$(CFG_TARGET_TRIPLES),\t\t\t\t\\\n  $(foreach target,$(NON_HOST_TRIPLES),\t\t\t\t\\\n   $(eval $(call TARGET_RT_FROM_WD,0,$(target),$(source)))       \\\n   $(eval $(call TARGET_CORELIB_FROM_WD,0,$(target),$(source)))  \\\n+  $(eval $(call TARGET_STDLIB_FROM_WD,0,$(target),$(source)))  \\\n ))\n \n # After stage0, always build the stage0 runtime from the working directory\n@@ -158,5 +185,8 @@ $(foreach source,$(CFG_TARGET_TRIPLES),\t\t\t\t\\\n   $(eval $(call TARGET_CORELIB_FROM_WD,1,$(target),$(source)))\t\\\n   $(eval $(call TARGET_CORELIB_FROM_WD,2,$(target),$(source)))\t\\\n   $(eval $(call TARGET_CORELIB_FROM_WD,3,$(target),$(source)))\t\\\n+  $(eval $(call TARGET_STDLIB_FROM_WD,1,$(target),$(source)))\t\\\n+  $(eval $(call TARGET_STDLIB_FROM_WD,2,$(target),$(source)))\t\\\n+  $(eval $(call TARGET_STDLIB_FROM_WD,3,$(target),$(source)))\t\\\n ))\n "}, {"sha": "a743cbc55763a09654d1a4235c2a00cf639f64be", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/41b02b7c57092f1da63beec60358061a9579d8c6/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41b02b7c57092f1da63beec60358061a9579d8c6/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=41b02b7c57092f1da63beec60358061a9579d8c6", "patch": "@@ -1162,7 +1162,12 @@ impl extensions<T> for [T] {\n mod unsafe {\n     // FIXME: This should have crate visibility (#1893 blocks that)\n     #[doc = \"The internal representation of a vector\"]\n-    type vec_repr = {mut fill: uint, mut alloc: uint, data: u8};\n+    type vec_repr = {\n+        box_header: (uint, uint, uint, uint),\n+        mut fill: uint,\n+        mut alloc: uint,\n+        data: u8\n+    };\n \n     #[doc = \"\n     Constructs a vector from an unsafe pointer to a buffer"}, {"sha": "4019c8701ac373e3f795675019f426676d418902", "filename": "src/rt/rust.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41b02b7c57092f1da63beec60358061a9579d8c6/src%2Frt%2Frust.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/41b02b7c57092f1da63beec60358061a9579d8c6/src%2Frt%2Frust.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust.cpp?ref=41b02b7c57092f1da63beec60358061a9579d8c6", "patch": "@@ -13,7 +13,7 @@ command_line_args : public kernel_owned<command_line_args>\n     char **argv;\n \n     // [str] passed to rust_task::start.\n-    rust_vec *args;\n+    rust_vec_box *args;\n \n     command_line_args(rust_task *task,\n                       int sys_argc,\n@@ -47,7 +47,7 @@ command_line_args : public kernel_owned<command_line_args>\n \n     ~command_line_args() {\n         for (int i = 0; i < argc; ++i) {\n-            rust_vec *s = ((rust_vec**)&args->data)[i];\n+            rust_vec *s = ((rust_vec**)&args->body.data)[i];\n             kernel->free(s);\n         }\n         kernel->free(args);"}, {"sha": "eebb114f5fc29a3b122816c32fab1e8100faa644", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/41b02b7c57092f1da63beec60358061a9579d8c6/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/41b02b7c57092f1da63beec60358061a9579d8c6/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=41b02b7c57092f1da63beec60358061a9579d8c6", "patch": "@@ -85,7 +85,7 @@ rust_getcwd() {\n }\n \n #if defined(__WIN32__)\n-extern \"C\" CDECL rust_vec *\n+extern \"C\" CDECL rust_vec_box *\n rust_env_pairs() {\n     rust_task *task = rust_get_current_task();\n     size_t envc = 0;\n@@ -95,14 +95,14 @@ rust_env_pairs() {\n         ++envc;\n     }\n     c = ch;\n-    rust_vec *v = (rust_vec *)\n-        task->kernel->malloc(vec_size<rust_vec*>(envc),\n+    rust_vec_box *v = (rust_vec_box *)\n+        task->kernel->malloc(vec_size<rust_vec_box*>(envc),\n                        \"str vec interior\");\n-    v->fill = v->alloc = sizeof(rust_vec*) * envc;\n+    v->body.fill = v->body.alloc = sizeof(rust_vec*) * envc;\n     for (size_t i = 0; i < envc; ++i) {\n         size_t n = strlen(c);\n         rust_str *str = make_str(task->kernel, c, n, \"str\");\n-        ((rust_str**)&v->data)[i] = str;\n+        ((rust_str**)&v->body.data)[i] = str;\n         c += n + 1;\n     }\n     if (ch) {\n@@ -111,7 +111,7 @@ rust_env_pairs() {\n     return v;\n }\n #else\n-extern \"C\" CDECL rust_vec *\n+extern \"C\" CDECL rust_vec_box *\n rust_env_pairs() {\n     rust_task *task = rust_get_current_task();\n #ifdef __APPLE__\n@@ -140,14 +140,14 @@ unsupervise() {\n }\n \n extern \"C\" CDECL void\n-vec_reserve_shared(type_desc* ty, rust_vec** vp,\n+vec_reserve_shared(type_desc* ty, rust_vec_box** vp,\n                    size_t n_elts) {\n     rust_task *task = rust_get_current_task();\n     reserve_vec_exact(task, vp, n_elts * ty->size);\n }\n \n extern \"C\" CDECL void\n-str_reserve_shared(rust_vec** sp,\n+str_reserve_shared(rust_vec_box** sp,\n                    size_t n_elts) {\n     rust_task *task = rust_get_current_task();\n     reserve_vec_exact(task, sp, n_elts + 1);\n@@ -157,25 +157,26 @@ str_reserve_shared(rust_vec** sp,\n  * Copies elements in an unsafe buffer to the given interior vector. The\n  * vector must have size zero.\n  */\n-extern \"C\" CDECL rust_vec*\n+extern \"C\" CDECL rust_vec_box*\n vec_from_buf_shared(type_desc *ty, void *ptr, size_t count) {\n     rust_task *task = rust_get_current_task();\n     size_t fill = ty->size * count;\n-    rust_vec* v = (rust_vec*)task->kernel->malloc(fill + sizeof(rust_vec),\n-                                                    \"vec_from_buf\");\n-    v->fill = v->alloc = fill;\n-    memmove(&v->data[0], ptr, fill);\n+    rust_vec_box* v = (rust_vec_box*)\n+        task->kernel->malloc(fill + sizeof(rust_vec_box),\n+                             \"vec_from_buf\");\n+    v->body.fill = v->body.alloc = fill;\n+    memmove(&v->body.data[0], ptr, fill);\n     return v;\n }\n \n extern \"C\" CDECL void\n-rust_str_push(rust_vec** sp, uint8_t byte) {\n+rust_str_push(rust_vec_box** sp, uint8_t byte) {\n     rust_task *task = rust_get_current_task();\n-    size_t fill = (*sp)->fill;\n+    size_t fill = (*sp)->body.fill;\n     reserve_vec(task, sp, fill + 1);\n-    (*sp)->data[fill-1] = byte;\n-    (*sp)->data[fill] = 0;\n-    (*sp)->fill = fill + 1;\n+    (*sp)->body.data[fill-1] = byte;\n+    (*sp)->body.data[fill] = 0;\n+    (*sp)->body.fill = fill + 1;\n }\n \n extern \"C\" CDECL rust_vec*\n@@ -367,13 +368,13 @@ debug_get_stk_seg() {\n     return task->stk;\n }\n \n-extern \"C\" CDECL rust_vec*\n+extern \"C\" CDECL rust_vec_box*\n rust_list_files(rust_str *path) {\n     rust_task *task = rust_get_current_task();\n     array_list<rust_str*> strings;\n #if defined(__WIN32__)\n     WIN32_FIND_DATA FindFileData;\n-    HANDLE hFind = FindFirstFile((char*)path->data, &FindFileData);\n+    HANDLE hFind = FindFirstFile((char*)path->body.data, &FindFileData);\n     if (hFind != INVALID_HANDLE_VALUE) {\n         do {\n             rust_str *str = make_str(task->kernel, FindFileData.cFileName,\n@@ -384,25 +385,25 @@ rust_list_files(rust_str *path) {\n         FindClose(hFind);\n     }\n #else\n-    DIR *dirp = opendir((char*)path->data);\n+    DIR *dirp = opendir((char*)path->body.data);\n   if (dirp) {\n       struct dirent *dp;\n       while ((dp = readdir(dirp))) {\n-          rust_vec *str = make_str(task->kernel, dp->d_name,\n-                                    strlen(dp->d_name),\n-                                    \"list_files_str\");\n+          rust_vec_box *str = make_str(task->kernel, dp->d_name,\n+                                       strlen(dp->d_name),\n+                                       \"list_files_str\");\n           strings.push(str);\n       }\n       closedir(dirp);\n   }\n #endif\n \n-  rust_vec *vec = (rust_vec *)\n-      task->kernel->malloc(vec_size<rust_vec*>(strings.size()),\n+  rust_vec_box *vec = (rust_vec_box *)\n+      task->kernel->malloc(vec_size<rust_vec_box*>(strings.size()),\n                            \"list_files_vec\");\n   size_t alloc_sz = sizeof(rust_vec*) * strings.size();\n-  vec->fill = vec->alloc = alloc_sz;\n-  memcpy(&vec->data[0], strings.data(), alloc_sz);\n+  vec->body.fill = vec->body.alloc = alloc_sz;\n+  memcpy(&vec->body.data[0], strings.data(), alloc_sz);\n   return vec;\n }\n \n@@ -520,9 +521,9 @@ void tm_to_rust_tm(tm* in_tm, rust_tm* out_tm, int32_t gmtoff,\n     if (zone != NULL) {\n         size_t size = strlen(zone);\n         str_reserve_shared(&out_tm->tm_zone, size);\n-        memcpy(out_tm->tm_zone->data, zone, size);\n-        out_tm->tm_zone->fill = size + 1;\n-        out_tm->tm_zone->data[size] = '\\0';\n+        memcpy(out_tm->tm_zone->body.data, zone, size);\n+        out_tm->tm_zone->body.fill = size + 1;\n+        out_tm->tm_zone->body.data[size] = '\\0';\n     }\n }\n "}, {"sha": "4d6aaf02070e9793f4bad75ab9669f74f53a679c", "filename": "src/rt/rust_cc.cpp", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/41b02b7c57092f1da63beec60358061a9579d8c6/src%2Frt%2Frust_cc.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/41b02b7c57092f1da63beec60358061a9579d8c6/src%2Frt%2Frust_cc.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_cc.cpp?ref=41b02b7c57092f1da63beec60358061a9579d8c6", "patch": "@@ -117,7 +117,9 @@ class irc : public shape::data<irc,shape::ptr> {\n     }\n \n     void walk_uniq2() {\n-        shape::data<irc,shape::ptr>::walk_uniq_contents1();\n+        rust_opaque_box *box = *(rust_opaque_box**)dp;\n+        if (box)\n+            shape::data<irc,shape::ptr>::walk_uniq_contents1();\n     }\n \n     void walk_rptr2() {\n@@ -373,7 +375,9 @@ class mark : public shape::data<mark,shape::ptr> {\n     }\n \n     void walk_uniq2() {\n-        shape::data<mark,shape::ptr>::walk_uniq_contents1();\n+        rust_opaque_box *box = *(rust_opaque_box**)dp;\n+        if (box)\n+            shape::data<mark,shape::ptr>::walk_uniq_contents1();\n     }\n \n     void walk_rptr2() {"}, {"sha": "77a253d2bb76b72ee77db58b6c03c3c602aa7efa", "filename": "src/rt/rust_shape.h", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/41b02b7c57092f1da63beec60358061a9579d8c6/src%2Frt%2Frust_shape.h", "raw_url": "https://github.com/rust-lang/rust/raw/41b02b7c57092f1da63beec60358061a9579d8c6/src%2Frt%2Frust_shape.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_shape.h?ref=41b02b7c57092f1da63beec60358061a9579d8c6", "patch": "@@ -783,6 +783,11 @@ class ptr {\n         return box->td;\n     }\n \n+    inline const type_desc *uniq_body_td() const {\n+        rust_opaque_box *box = *reinterpret_cast<rust_opaque_box**>(p);\n+        return box->td;\n+    }\n+\n     inline ptr box_body() const {\n         rust_opaque_box *box = *reinterpret_cast<rust_opaque_box**>(p);\n         return make((uint8_t*)::box_body(box));\n@@ -881,6 +886,11 @@ class ptr_pair {\n         return box_fst->td;\n     }\n \n+    inline const type_desc *uniq_body_td() const {\n+        rust_opaque_box *box_fst = *reinterpret_cast<rust_opaque_box**>(fst);\n+        return box_fst->td;\n+    }\n+\n     inline ptr_pair box_body() const {\n         rust_opaque_box *box_fst = *reinterpret_cast<rust_opaque_box**>(fst);\n         rust_opaque_box *box_snd = *reinterpret_cast<rust_opaque_box**>(snd);\n@@ -1067,10 +1077,16 @@ data<T,U>::walk_box_contents1() {\n template<typename T,typename U>\n void\n data<T,U>::walk_uniq_contents1() {\n-    typename U::template data<uint8_t *>::t box_ptr = bump_dp<uint8_t *>(dp);\n-    U data_ptr(box_ptr);\n-    T sub(*static_cast<T *>(this), data_ptr);\n-    static_cast<T *>(this)->walk_uniq_contents2(sub);\n+    const type_desc *body_td = dp.uniq_body_td();\n+    if (body_td) {\n+        U body_dp(dp.box_body());\n+        arena arena;\n+        type_param *params = type_param::from_tydesc(body_td, arena);\n+        T sub(*static_cast<T *>(this), body_td->shape, params,\n+              body_td->shape_tables, body_dp);\n+        sub.align = true;\n+        static_cast<T *>(this)->walk_uniq_contents2(sub);\n+    }\n }\n \n template<typename T,typename U>\n@@ -1094,9 +1110,9 @@ data<T,U>::walk_variant1(tag_info &tinfo, tag_variant_t variant_id) {\n template<typename T,typename U>\n std::pair<uint8_t *,uint8_t *>\n data<T,U>::get_vec_data_range(ptr dp) {\n-    rust_vec* ptr = bump_dp<rust_vec*>(dp);\n-    uint8_t* data = &ptr->data[0];\n-    return std::make_pair(data, data + ptr->fill);\n+    rust_vec_box* ptr = bump_dp<rust_vec_box*>(dp);\n+    uint8_t* data = &ptr->body.data[0];\n+    return std::make_pair(data, data + ptr->body.fill);\n }\n \n template<typename T,typename U>"}, {"sha": "5299de0ed34df405db122a6baeea788bed7903b8", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/41b02b7c57092f1da63beec60358061a9579d8c6/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/41b02b7c57092f1da63beec60358061a9579d8c6/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=41b02b7c57092f1da63beec60358061a9579d8c6", "patch": "@@ -7,7 +7,6 @@\n \n #include \"rust_task.h\"\n #include \"rust_cc.h\"\n-#include \"rust_upcall.h\"\n #include \"rust_env.h\"\n #include \"rust_port.h\"\n \n@@ -130,6 +129,8 @@ cleanup_task(cleanup_args *args) {\n     }\n }\n \n+extern \"C\" CDECL void upcall_exchange_free(void *ptr);\n+\n // This runs on the Rust stack\n void task_start_wrapper(spawn_args *a)\n {\n@@ -161,7 +162,7 @@ void task_start_wrapper(spawn_args *a)\n         // free the environment (which should be a unique closure).\n         const type_desc *td = env->td;\n         td->drop_glue(NULL, NULL, td->first_param, box_body(env));\n-        upcall_shared_free(env);\n+        upcall_exchange_free(env);\n     }\n \n     // The cleanup work needs lots of stack"}, {"sha": "ac11ee7a26b734df840ce264553eb7e79b363017", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 106, "deletions": 94, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/41b02b7c57092f1da63beec60358061a9579d8c6/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/41b02b7c57092f1da63beec60358061a9579d8c6/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=41b02b7c57092f1da63beec60358061a9579d8c6", "patch": "@@ -151,6 +151,92 @@ upcall_trace(char const *msg,\n     UPCALL_SWITCH_STACK(&args, upcall_s_trace);\n }\n \n+/**********************************************************************\n+ * Allocate an object in the exchange heap\n+ */\n+\n+extern \"C\" CDECL uintptr_t\n+exchange_malloc(rust_task *task, type_desc *td, uintptr_t size) {\n+\n+    LOG(task, mem, \"upcall exchange malloc(0x%\" PRIxPTR \")\", td);\n+\n+    // Copied from boxed_region\n+    size_t header_size = sizeof(rust_opaque_box);\n+    size_t body_size = size;\n+    size_t body_align = td->align;\n+    // FIXME: This alignment calculation is suspicious. Is it right?\n+    size_t total_size = align_to(header_size, body_align) + body_size;\n+\n+    void *p = task->kernel->malloc(total_size, \"exchange malloc\");\n+\n+    rust_opaque_box *header = static_cast<rust_opaque_box*>(p);\n+    header->td = td;\n+\n+    memset(&header[1], '\\0', body_size);\n+\n+    return (uintptr_t)header;\n+}\n+\n+struct s_exchange_malloc_args {\n+    uintptr_t retval;\n+    type_desc *td;\n+};\n+\n+extern \"C\" CDECL void\n+upcall_s_exchange_malloc(s_exchange_malloc_args *args) {\n+    rust_task *task = rust_get_current_task();\n+    LOG_UPCALL_ENTRY(task);\n+\n+    uintptr_t retval = exchange_malloc(task, args->td, args->td->size);\n+    args->retval = retval;\n+}\n+\n+extern \"C\" CDECL uintptr_t\n+upcall_exchange_malloc(type_desc *td) {\n+    s_exchange_malloc_args args = {0, td};\n+    UPCALL_SWITCH_STACK(&args, upcall_s_exchange_malloc);\n+    return args.retval;\n+}\n+\n+struct s_exchange_malloc_dyn_args {\n+    uintptr_t retval;\n+    type_desc *td;\n+    uintptr_t size;\n+};\n+\n+extern \"C\" CDECL void\n+upcall_s_exchange_malloc_dyn(s_exchange_malloc_dyn_args *args) {\n+    rust_task *task = rust_get_current_task();\n+    LOG_UPCALL_ENTRY(task);\n+\n+    uintptr_t retval = exchange_malloc(task, args->td, args->size);\n+    args->retval = retval;\n+}\n+\n+extern \"C\" CDECL uintptr_t\n+upcall_exchange_malloc_dyn(type_desc *td, uintptr_t size) {\n+    s_exchange_malloc_dyn_args args = {0, td, size};\n+    UPCALL_SWITCH_STACK(&args, upcall_s_exchange_malloc_dyn);\n+    return args.retval;\n+}\n+\n+struct s_exchange_free_args {\n+    void *ptr;\n+};\n+\n+extern \"C\" CDECL void\n+upcall_s_exchange_free(s_exchange_free_args *args) {\n+    rust_task *task = rust_get_current_task();\n+    LOG_UPCALL_ENTRY(task);\n+    task->kernel->free(args->ptr);\n+}\n+\n+extern \"C\" CDECL void\n+upcall_exchange_free(void *ptr) {\n+    s_exchange_free_args args = {ptr};\n+    UPCALL_SWITCH_STACK(&args, upcall_s_exchange_free);\n+}\n+\n /**********************************************************************\n  * Allocate an object in the task-local heap.\n  */\n@@ -234,81 +320,6 @@ upcall_validate_box(rust_opaque_box* ptr) {\n     }\n }\n \n-/**********************************************************************\n- * Allocate an object in the exchange heap.\n- */\n-\n-struct s_shared_malloc_args {\n-    uintptr_t retval;\n-    size_t nbytes;\n-};\n-\n-extern \"C\" CDECL void\n-upcall_s_shared_malloc(s_shared_malloc_args *args) {\n-    rust_task *task = rust_get_current_task();\n-    LOG_UPCALL_ENTRY(task);\n-\n-    LOG(task, mem, \"upcall shared_malloc(%\" PRIdPTR \")\", args->nbytes);\n-    void *p = task->kernel->malloc(args->nbytes, \"shared malloc\");\n-    memset(p, '\\0', args->nbytes);\n-    LOG(task, mem, \"upcall shared_malloc(%\" PRIdPTR \") = 0x%\" PRIxPTR,\n-        args->nbytes, (uintptr_t)p);\n-    args->retval = (uintptr_t) p;\n-}\n-\n-extern \"C\" CDECL uintptr_t\n-upcall_shared_malloc(size_t nbytes) {\n-    s_shared_malloc_args args = {0, nbytes};\n-    UPCALL_SWITCH_STACK(&args, upcall_s_shared_malloc);\n-    return args.retval;\n-}\n-\n-/**********************************************************************\n- * Called whenever an object in the exchange heap is freed.\n- */\n-\n-struct s_shared_free_args {\n-    void *ptr;\n-};\n-\n-extern \"C\" CDECL void\n-upcall_s_shared_free(s_shared_free_args *args) {\n-    rust_task *task = rust_get_current_task();\n-    LOG_UPCALL_ENTRY(task);\n-\n-    rust_sched_loop *sched_loop = task->sched_loop;\n-    DLOG(sched_loop, mem,\n-             \"upcall shared_free(0x%\" PRIxPTR\")\",\n-             (uintptr_t)args->ptr);\n-    task->kernel->free(args->ptr);\n-}\n-\n-extern \"C\" CDECL void\n-upcall_shared_free(void* ptr) {\n-    s_shared_free_args args = {ptr};\n-    UPCALL_SWITCH_STACK(&args, upcall_s_shared_free);\n-}\n-\n-struct s_shared_realloc_args {\n-    void *retval;\n-    void *ptr;\n-    size_t size;\n-};\n-\n-extern \"C\" CDECL void\n-upcall_s_shared_realloc(s_shared_realloc_args *args) {\n-    rust_task *task = rust_get_current_task();\n-    LOG_UPCALL_ENTRY(task);\n-    args->retval = task->kernel->realloc(args->ptr, args->size);\n-}\n-\n-extern \"C\" CDECL void *\n-upcall_shared_realloc(void *ptr, size_t size) {\n-    s_shared_realloc_args args = {NULL, ptr, size};\n-    UPCALL_SWITCH_STACK(&args, upcall_s_shared_realloc);\n-    return args.retval;\n-}\n-\n /**********************************************************************/\n \n struct s_str_new_uniq_args {\n@@ -361,10 +372,10 @@ upcall_s_str_new_shared(s_str_new_shared_args *args) {\n                              vec_size<char>(str_fill),\n                              \"str_new_shared\");\n     rust_str *str = (rust_str *)box_body(args->retval);\n-    str->fill = str_fill;\n-    str->alloc = str_alloc;\n-    memcpy(&str->data, args->cstr, args->len);\n-    str->data[args->len] = '\\0';\n+    str->body.fill = str_fill;\n+    str->body.alloc = str_alloc;\n+    memcpy(&str->body.data, args->cstr, args->len);\n+    str->body.data[args->len] = '\\0';\n }\n \n extern \"C\" CDECL rust_opaque_box*\n@@ -376,7 +387,7 @@ upcall_str_new_shared(const char *cstr, size_t len) {\n \n \n struct s_vec_grow_args {\n-    rust_vec** vp;\n+    rust_vec_box** vp;\n     size_t new_sz;\n };\n \n@@ -385,37 +396,38 @@ upcall_s_vec_grow(s_vec_grow_args *args) {\n     rust_task *task = rust_get_current_task();\n     LOG_UPCALL_ENTRY(task);\n     reserve_vec(task, args->vp, args->new_sz);\n-    (*args->vp)->fill = args->new_sz;\n+    (*args->vp)->body.fill = args->new_sz;\n }\n \n extern \"C\" CDECL void\n-upcall_vec_grow(rust_vec** vp, size_t new_sz) {\n+upcall_vec_grow(rust_vec_box** vp, size_t new_sz) {\n     s_vec_grow_args args = {vp, new_sz};\n     UPCALL_SWITCH_STACK(&args, upcall_s_vec_grow);\n }\n \n struct s_str_concat_args {\n-    rust_vec* lhs;\n-    rust_vec* rhs;\n-    rust_vec* retval;\n+    rust_vec_box* lhs;\n+    rust_vec_box* rhs;\n+    rust_vec_box* retval;\n };\n \n extern \"C\" CDECL void\n upcall_s_str_concat(s_str_concat_args *args) {\n-    rust_vec *lhs = args->lhs;\n-    rust_vec *rhs = args->rhs;\n+    rust_vec *lhs = &args->lhs->body;\n+    rust_vec *rhs = &args->rhs->body;\n     rust_task *task = rust_get_current_task();\n     size_t fill = lhs->fill + rhs->fill - 1;\n-    rust_vec* v = (rust_vec*)task->kernel->malloc(fill + sizeof(rust_vec),\n-                                                  \"str_concat\");\n-    v->fill = v->alloc = fill;\n-    memmove(&v->data[0], &lhs->data[0], lhs->fill - 1);\n-    memmove(&v->data[lhs->fill - 1], &rhs->data[0], rhs->fill);\n+    rust_vec_box* v = (rust_vec_box*)\n+        task->kernel->malloc(fill + sizeof(rust_vec_box),\n+                             \"str_concat\");\n+    v->body.fill = v->body.alloc = fill;\n+    memmove(&v->body.data[0], &lhs->data[0], lhs->fill - 1);\n+    memmove(&v->body.data[lhs->fill - 1], &rhs->data[0], rhs->fill);\n     args->retval = v;\n }\n \n-extern \"C\" CDECL rust_vec*\n-upcall_str_concat(rust_vec* lhs, rust_vec* rhs) {\n+extern \"C\" CDECL rust_vec_box*\n+upcall_str_concat(rust_vec_box* lhs, rust_vec_box* rhs) {\n     s_str_concat_args args = {lhs, rhs, 0};\n     UPCALL_SWITCH_STACK(&args, upcall_s_str_concat);\n     return args.retval;"}, {"sha": "b2b2db20674c362a2d1d612862dd5daa1d995bcb", "filename": "src/rt/rust_upcall.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/41b02b7c57092f1da63beec60358061a9579d8c6/src%2Frt%2Frust_upcall.h", "raw_url": "https://github.com/rust-lang/rust/raw/41b02b7c57092f1da63beec60358061a9579d8c6/src%2Frt%2Frust_upcall.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.h?ref=41b02b7c57092f1da63beec60358061a9579d8c6", "patch": "@@ -1,9 +1,4 @@\n-\n #ifndef RUST_UPCALL_H\n #define RUST_UPCALL_H\n \n-// Upcalls used from C code on occasion:\n-\n-extern \"C\" CDECL void upcall_shared_free(void* ptr);\n-\n #endif"}, {"sha": "3a7bd0b7d71ba5fc5239fd7492e3e8b3008480d2", "filename": "src/rt/rust_util.h", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/41b02b7c57092f1da63beec60358061a9579d8c6/src%2Frt%2Frust_util.h", "raw_url": "https://github.com/rust-lang/rust/raw/41b02b7c57092f1da63beec60358061a9579d8c6/src%2Frt%2Frust_util.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_util.h?ref=41b02b7c57092f1da63beec60358061a9579d8c6", "patch": "@@ -42,9 +42,16 @@ rust_vec\n     uint8_t data[0];\n };\n \n+struct\n+rust_vec_box\n+{\n+    rust_opaque_box header;\n+    rust_vec body;\n+};\n+\n template <typename T>\n inline size_t vec_size(size_t elems) {\n-    return sizeof(rust_vec) + sizeof(T) * elems;\n+    return sizeof(rust_vec_box) + sizeof(T) * elems;\n }\n \n template <typename T>\n@@ -53,19 +60,20 @@ vec_data(rust_vec *v) {\n     return reinterpret_cast<T*>(v->data);\n }\n \n-inline void reserve_vec_exact(rust_task* task, rust_vec** vpp, size_t size) {\n-    if (size > (*vpp)->alloc) {\n-        *vpp = (rust_vec*)task->kernel\n-            ->realloc(*vpp, size + sizeof(rust_vec));\n-        (*vpp)->alloc = size;\n+inline void reserve_vec_exact(rust_task* task, rust_vec_box** vpp,\n+                              size_t size) {\n+    if (size > (*vpp)->body.alloc) {\n+        *vpp = (rust_vec_box*)task->kernel\n+            ->realloc(*vpp, size + sizeof(rust_vec_box));\n+        (*vpp)->body.alloc = size;\n     }\n }\n \n-inline void reserve_vec(rust_task* task, rust_vec** vpp, size_t size) {\n+inline void reserve_vec(rust_task* task, rust_vec_box** vpp, size_t size) {\n     reserve_vec_exact(task, vpp, next_power_of_two(size));\n }\n \n-typedef rust_vec rust_str;\n+typedef rust_vec_box rust_str;\n \n inline rust_str *\n make_str(rust_kernel* kernel, const char* c, size_t strlen,\n@@ -74,24 +82,24 @@ make_str(rust_kernel* kernel, const char* c, size_t strlen,\n     size_t str_alloc = str_fill;\n     rust_str *str = (rust_str *)\n         kernel->malloc(vec_size<char>(str_fill), name);\n-    str->fill = str_fill;\n-    str->alloc = str_alloc;\n-    memcpy(&str->data, c, strlen);\n-    str->data[strlen] = '\\0';\n+    str->body.fill = str_fill;\n+    str->body.alloc = str_alloc;\n+    memcpy(&str->body.data, c, strlen);\n+    str->body.data[strlen] = '\\0';\n     return str;\n }\n \n-inline rust_vec *\n+inline rust_vec_box *\n make_str_vec(rust_kernel* kernel, size_t nstrs, char **strs) {\n-    rust_vec *v = (rust_vec *)\n-        kernel->malloc(vec_size<rust_vec*>(nstrs),\n+    rust_vec_box *v = (rust_vec_box *)\n+        kernel->malloc(vec_size<rust_vec_box*>(nstrs),\n                        \"str vec interior\");\n-    v->fill = v->alloc = sizeof(rust_vec*) * nstrs;\n+    v->body.fill = v->body.alloc = sizeof(rust_vec_box*) * nstrs;\n     for (size_t i = 0; i < nstrs; ++i) {\n         rust_str *str = make_str(kernel, strs[i],\n                                  strlen(strs[i]),\n                                  \"str\");\n-        ((rust_str**)&v->data)[i] = str;\n+        ((rust_str**)&v->body.data)[i] = str;\n     }\n     return v;\n }"}, {"sha": "8a627795850f2ef60a9b1944ec26c23a4227c199", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/41b02b7c57092f1da63beec60358061a9579d8c6/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/41b02b7c57092f1da63beec60358061a9579d8c6/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=41b02b7c57092f1da63beec60358061a9579d8c6", "patch": "@@ -74,10 +74,6 @@ upcall_validate_box\n upcall_log_type\n upcall_malloc\n upcall_rust_personality\n-upcall_s_shared_malloc\n-upcall_shared_malloc\n-upcall_shared_free\n-upcall_shared_realloc\n upcall_vec_grow\n upcall_str_new\n upcall_str_new_uniq\n@@ -88,6 +84,9 @@ upcall_call_shim_on_rust_stack\n upcall_new_stack\n upcall_del_stack\n upcall_reset_stack_limit\n+upcall_exchange_malloc\n+upcall_exchange_malloc_dyn\n+upcall_exchange_free\n rust_uv_loop_new\n rust_uv_loop_delete\n rust_uv_loop_refcount\n@@ -161,4 +160,4 @@ rust_port_take\n rust_port_drop\n rust_port_task\n rust_task_inhibit_kill\n-rust_task_allow_kill\n\\ No newline at end of file\n+rust_task_allow_kill"}, {"sha": "33fec5fab03edd20fb678d613f86f77776b4c347", "filename": "src/rustc/back/upcall.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/41b02b7c57092f1da63beec60358061a9579d8c6/src%2Frustc%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41b02b7c57092f1da63beec60358061a9579d8c6/src%2Frustc%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Fupcall.rs?ref=41b02b7c57092f1da63beec60358061a9579d8c6", "patch": "@@ -3,19 +3,19 @@ import driver::session;\n import middle::trans::base;\n import middle::trans::common::{T_fn, T_i1, T_i8, T_i32,\n                                T_int, T_nil,\n-                               T_opaque_vec, T_ptr,\n-                               T_size_t, T_void};\n+                               T_opaque_vec, T_ptr, T_unique_ptr,\n+                               T_size_t, T_void, T_vec2};\n import lib::llvm::{type_names, ModuleRef, ValueRef, TypeRef};\n \n type upcalls =\n     {_fail: ValueRef,\n      trace: ValueRef,\n      malloc: ValueRef,\n      free: ValueRef,\n+     exchange_malloc: ValueRef,\n+     exchange_malloc_dyn: ValueRef,\n+     exchange_free: ValueRef,\n      validate_box: ValueRef,\n-     shared_malloc: ValueRef,\n-     shared_free: ValueRef,\n-     shared_realloc: ValueRef,\n      mark: ValueRef,\n      vec_grow: ValueRef,\n      str_new_uniq: ValueRef,\n@@ -49,7 +49,6 @@ fn declare_upcalls(targ_cfg: @session::config,\n \n     let int_t = T_int(targ_cfg);\n     let size_t = T_size_t(targ_cfg);\n-    let opaque_vec_t = T_opaque_vec(targ_cfg);\n \n     ret @{_fail: dv(\"fail\", [T_ptr(T_i8()),\n                              T_ptr(T_i8()),\n@@ -62,29 +61,31 @@ fn declare_upcalls(targ_cfg: @session::config,\n                         T_ptr(T_i8()))),\n           free:\n               nothrow(dv(\"free\", [T_ptr(T_i8())])),\n+          exchange_malloc:\n+              nothrow(d(\"exchange_malloc\", [T_ptr(tydesc_type)],\n+                        T_ptr(T_i8()))),\n+          exchange_malloc_dyn:\n+              nothrow(d(\"exchange_malloc_dyn\",\n+                        [T_ptr(tydesc_type), int_t],\n+                        T_ptr(T_i8()))),\n+          exchange_free:\n+              nothrow(dv(\"exchange_free\", [T_ptr(T_i8())])),\n           validate_box:\n               nothrow(dv(\"validate_box\", [T_ptr(T_i8())])),\n-          shared_malloc:\n-              nothrow(d(\"shared_malloc\", [size_t], T_ptr(T_i8()))),\n-          shared_free:\n-              nothrow(dv(\"shared_free\", [T_ptr(T_i8())])),\n-          shared_realloc:\n-              nothrow(d(\"shared_realloc\", [T_ptr(T_i8()), size_t],\n-                        T_ptr(T_i8()))),\n           mark:\n               d(\"mark\", [T_ptr(T_i8())], int_t),\n           vec_grow:\n-              nothrow(dv(\"vec_grow\", [T_ptr(T_ptr(opaque_vec_t)), int_t])),\n+              nothrow(dv(\"vec_grow\", [T_ptr(T_ptr(T_i8())), int_t])),\n           str_new_uniq:\n               nothrow(d(\"str_new_uniq\", [T_ptr(T_i8()), int_t],\n-                        T_ptr(opaque_vec_t))),\n+                        T_ptr(T_i8()))),\n           str_new_shared:\n               nothrow(d(\"str_new_shared\", [T_ptr(T_i8()), int_t],\n                         T_ptr(T_i8()))),\n           str_concat:\n-              nothrow(d(\"str_concat\", [T_ptr(opaque_vec_t),\n-                                       T_ptr(opaque_vec_t)],\n-                        T_ptr(opaque_vec_t))),\n+              nothrow(d(\"str_concat\", [T_ptr(T_i8()),\n+                                       T_ptr(T_i8())],\n+                        T_ptr(T_i8()))),\n           cmp_type:\n               dv(\"cmp_type\",\n                  [T_ptr(T_i1()), T_ptr(tydesc_type),"}, {"sha": "5c079f3010689589dee32bb3617dab1ef196d0e3", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/41b02b7c57092f1da63beec60358061a9579d8c6/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41b02b7c57092f1da63beec60358061a9579d8c6/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=41b02b7c57092f1da63beec60358061a9579d8c6", "patch": "@@ -471,7 +471,8 @@ fn compile_submatch(bcx: block, m: match, vals: [ValueRef],\n     }\n \n     if any_uniq_pat(m, col) {\n-        let unboxed = Load(bcx, val);\n+        let box = Load(bcx, val);\n+        let unboxed = GEPi(bcx, box, [0u, abi::box_field_body]);\n         compile_submatch(bcx, enter_uniq(dm, m, col, val),\n                          [unboxed] + vals_left, chk, exits);\n         ret;\n@@ -762,8 +763,10 @@ fn bind_irrefutable_pat(bcx: block, pat: @ast::pat, val: ValueRef,\n         bcx = bind_irrefutable_pat(bcx, inner, unboxed, true);\n       }\n       ast::pat_uniq(inner) {\n-        let val = Load(bcx, val);\n-        bcx = bind_irrefutable_pat(bcx, inner, val, true);\n+        let box = Load(bcx, val);\n+        let unboxed =\n+            GEPi(bcx, box, [0u, abi::box_field_body]);\n+        bcx = bind_irrefutable_pat(bcx, inner, unboxed, true);\n       }\n       ast::pat_wild | ast::pat_lit(_) | ast::pat_range(_, _) { }\n     }"}, {"sha": "a95797fd7e305fe38e52ab15720b96f49148fa67", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 74, "deletions": 17, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/41b02b7c57092f1da63beec60358061a9579d8c6/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41b02b7c57092f1da63beec60358061a9579d8c6/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=41b02b7c57092f1da63beec60358061a9579d8c6", "patch": "@@ -236,9 +236,9 @@ fn trans_free(cx: block, v: ValueRef) -> block {\n     cx\n }\n \n-fn trans_shared_free(cx: block, v: ValueRef) -> block {\n+fn trans_unique_free(cx: block, v: ValueRef) -> block {\n     let _icx = cx.insn_ctxt(\"trans_shared_free\");\n-    Call(cx, cx.ccx().upcalls.shared_free,\n+    Call(cx, cx.ccx().upcalls.exchange_free,\n          [PointerCast(cx, v, T_ptr(T_i8()))]);\n     ret cx;\n }\n@@ -326,15 +326,6 @@ fn GEP_enum(bcx: block, llblobptr: ValueRef, enum_id: ast::def_id,\n     GEPi(bcx, typed_blobptr, [0u, ix])\n }\n \n-// trans_shared_malloc: expects a type indicating which pointer type we want\n-// and a size indicating how much space we want malloc'd.\n-fn shared_malloc(cx: block, llptr_ty: TypeRef, llsize: ValueRef)\n-   -> ValueRef {\n-    let _icx = cx.insn_ctxt(\"opaque_shared_malloc\");\n-    let rval = Call(cx, cx.ccx().upcalls.shared_malloc, [llsize]);\n-    PointerCast(cx, rval, llptr_ty)\n-}\n-\n // Returns a pointer to the body for the box. The box may be an opaque\n // box. The result will be casted to the type of body_t, if it is statically\n // known.\n@@ -384,6 +375,59 @@ fn malloc_boxed(bcx: block, t: ty::t) -> {box: ValueRef, body: ValueRef} {\n     ret {box: box, body: body};\n }\n \n+fn malloc_unique_raw(bcx: block, t: ty::t) -> ValueRef {\n+    let _icx = bcx.insn_ctxt(\"malloc_unique_box_raw\");\n+    let ccx = bcx.ccx();\n+\n+    // Grab the TypeRef type of box_ptr, because that's what trans_raw_malloc\n+    // wants.\n+    let box_ptr = ty::mk_imm_uniq(ccx.tcx, t);\n+    let llty = type_of(ccx, box_ptr);\n+\n+    // Get the tydesc for the body:\n+    let mut static_ti = none;\n+    let lltydesc = get_tydesc(ccx, t, static_ti);\n+    lazily_emit_all_tydesc_glue(ccx, static_ti);\n+\n+    // Allocate space:\n+    let rval = Call(bcx, ccx.upcalls.exchange_malloc, [lltydesc]);\n+    ret PointerCast(bcx, rval, llty);\n+}\n+\n+fn malloc_unique(bcx: block, t: ty::t) -> {box: ValueRef, body: ValueRef} {\n+    let _icx = bcx.insn_ctxt(\"malloc_unique_box\");\n+    let box = malloc_unique_raw(bcx, t);\n+    let body = GEPi(bcx, box, [0u, abi::box_field_body]);\n+    ret {box: box, body: body};\n+}\n+\n+fn malloc_unique_dyn_raw(bcx: block, t: ty::t, size: ValueRef) -> ValueRef {\n+    let _icx = bcx.insn_ctxt(\"malloc_unique_box_raw\");\n+    let ccx = bcx.ccx();\n+\n+    // Grab the TypeRef type of box_ptr, because that's what trans_raw_malloc\n+    // wants.\n+    let box_ptr = ty::mk_imm_uniq(ccx.tcx, t);\n+    let llty = type_of(ccx, box_ptr);\n+\n+    // Get the tydesc for the body:\n+    let mut static_ti = none;\n+    let lltydesc = get_tydesc(ccx, t, static_ti);\n+    lazily_emit_all_tydesc_glue(ccx, static_ti);\n+\n+    // Allocate space:\n+    let rval = Call(bcx, ccx.upcalls.exchange_malloc_dyn, [lltydesc, size]);\n+    ret PointerCast(bcx, rval, llty);\n+}\n+\n+fn malloc_unique_dyn(bcx: block, t: ty::t, size: ValueRef\n+                    ) -> {box: ValueRef, body: ValueRef} {\n+    let _icx = bcx.insn_ctxt(\"malloc_unique_box\");\n+    let box = malloc_unique_dyn_raw(bcx, t, size);\n+    let body = GEPi(bcx, box, [0u, abi::box_field_body]);\n+    ret {box: box, body: body};\n+}\n+\n // Type descriptor and type glue stuff\n \n fn get_tydesc_simple(ccx: @crate_ctxt, t: ty::t) -> ValueRef {\n@@ -1754,7 +1798,7 @@ fn autoderef(cx: block, e_id: ast::node_id,\n             v1 = PointerCast(cx, body, T_ptr(llty));\n           }\n           ty::ty_uniq(_) {\n-            let derefed = uniq::autoderef(v1, t1);\n+            let derefed = uniq::autoderef(cx, v1, t1);\n             t1 = derefed.t;\n             v1 = derefed.v;\n           }\n@@ -2636,6 +2680,9 @@ fn trans_lval(cx: block, e: @ast::expr) -> lval_result {\n                 let non_gc_val = non_gc_box_cast(sub.bcx, sub.val, t);\n                 GEPi(sub.bcx, non_gc_val, [0u, abi::box_field_body])\n               }\n+              ty::ty_uniq(_) {\n+                GEPi(sub.bcx, sub.val, [0u, abi::box_field_body])\n+              }\n               ty::ty_res(_, _, _) {\n                 GEPi(sub.bcx, sub.val, [0u, 1u])\n               }\n@@ -2644,7 +2691,7 @@ fn trans_lval(cx: block, e: @ast::expr) -> lval_result {\n                 let ellty = T_ptr(type_of(ccx, ety));\n                 PointerCast(sub.bcx, sub.val, ellty)\n               }\n-              ty::ty_ptr(_) | ty::ty_uniq(_) | ty::ty_rptr(_,_) { sub.val }\n+              ty::ty_ptr(_) | ty::ty_rptr(_,_) { sub.val }\n             };\n             ret lval_owned(sub.bcx, val);\n           }\n@@ -2920,7 +2967,15 @@ fn adapt_borrowed_value(lv: lval_result, _arg: ty::arg,\n       }\n \n       ty::ty_uniq(_) {\n-        ret lv; // no change needed at runtime (I think)\n+        let box_ptr = {\n+            alt lv.kind {\n+              temporary { lv.val }\n+              owned { Load(bcx, lv.val) }\n+              owned_imm { lv.val }\n+            }\n+        };\n+        let body_ptr = GEPi(bcx, box_ptr, [0u, abi::box_field_body]);\n+        ret lval_temp(bcx, body_ptr);\n       }\n \n       ty::ty_str | ty::ty_vec(_) |\n@@ -3817,9 +3872,11 @@ fn trans_fail_expr(bcx: block, sp_opt: option<span>,\n         bcx = expr_res.bcx;\n \n         if ty::type_is_str(e_ty) {\n-            let data = tvec::get_dataptr(\n-                bcx, expr_res.val, type_of(\n-                    ccx, ty::mk_mach_uint(tcx, ast::ty_u8)));\n+            let unit_ty = ty::mk_mach_uint(tcx, ast::ty_u8);\n+            let vec_ty = ty::mk_vec(tcx, {ty: unit_ty, mutbl: ast::m_imm});\n+            let unit_llty = type_of(ccx, unit_ty);\n+            let body = tvec::get_bodyptr(bcx, expr_res.val, vec_ty);\n+            let data = tvec::get_dataptr(bcx, body, unit_llty);\n             ret trans_fail_value(bcx, sp_opt, data);\n         } else if bcx.unreachable || ty::type_is_bot(e_ty) {\n             ret bcx;"}, {"sha": "a3b2ab85d5878dbb643bb4050d2d945182e8661e", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/41b02b7c57092f1da63beec60358061a9579d8c6/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41b02b7c57092f1da63beec60358061a9579d8c6/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=41b02b7c57092f1da63beec60358061a9579d8c6", "patch": "@@ -116,7 +116,7 @@ fn ev_to_str(ccx: @crate_ctxt, ev: environment_value) -> str {\n }\n \n fn mk_tuplified_uniq_cbox_ty(tcx: ty::ctxt, cdata_ty: ty::t) -> ty::t {\n-    let cbox_ty = tuplify_cbox_ty(tcx, cdata_ty, ty::mk_type(tcx));\n+    let cbox_ty = tuplify_box_ty(tcx, cdata_ty);\n     ret ty::mk_imm_uniq(tcx, cbox_ty);\n }\n \n@@ -179,10 +179,7 @@ fn allocate_cbox(bcx: block,\n         (bcx, box)\n       }\n       ty::ck_uniq {\n-        let uniq_cbox_ty = mk_tuplified_uniq_cbox_ty(tcx, cdata_ty);\n-        let box = uniq::alloc_uniq(bcx, uniq_cbox_ty);\n-        nuke_ref_count(bcx, box);\n-        let bcx = store_tydesc(bcx, cdata_ty, box, ti);\n+        let box = malloc_unique_raw(bcx, cdata_ty);\n         (bcx, box)\n       }\n       ty::ck_block {\n@@ -557,8 +554,8 @@ fn make_opaque_cbox_take_glue(\n         let sz = Add(bcx, sz, shape::llsize_of(ccx, T_box_header(ccx)));\n \n         // Allocate memory, update original ptr, and copy existing data\n-        let malloc = ccx.upcalls.shared_malloc;\n-        let cbox_out = Call(bcx, malloc, [sz]);\n+        let malloc = ccx.upcalls.exchange_malloc;\n+        let cbox_out = Call(bcx, malloc, [tydesc]);\n         let cbox_out = PointerCast(bcx, cbox_out, llopaquecboxty);\n         call_memmove(bcx, cbox_out, cbox_in, sz);\n         Store(bcx, cbox_out, cboxptr);\n@@ -606,7 +603,7 @@ fn make_opaque_cbox_free_glue(\n       ty::ck_box | ty::ck_uniq { /* hard cases: */ }\n     }\n \n-    let ccx = bcx.ccx(), tcx = ccx.tcx;\n+    let ccx = bcx.ccx();\n     with_cond(bcx, IsNotNull(bcx, cbox)) {|bcx|\n         // Load the type descr found in the cbox\n         let lltydescty = T_ptr(ccx.tydesc_type);\n@@ -628,8 +625,7 @@ fn make_opaque_cbox_free_glue(\n             trans_free(bcx, cbox)\n           }\n           ty::ck_uniq {\n-            let bcx = free_ty(bcx, tydesc, ty::mk_type(tcx));\n-            trans_shared_free(bcx, cbox)\n+            trans_unique_free(bcx, cbox)\n           }\n         }\n     }"}, {"sha": "194a1993ce354c449bd21e51aabe13cf52369d6e", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/41b02b7c57092f1da63beec60358061a9579d8c6/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41b02b7c57092f1da63beec60358061a9579d8c6/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=41b02b7c57092f1da63beec60358061a9579d8c6", "patch": "@@ -271,7 +271,7 @@ fn add_clean_temp_mem(cx: block, val: ValueRef, ty: ty::t) {\n     }\n }\n fn add_clean_free(cx: block, ptr: ValueRef, shared: bool) {\n-    let free_fn = if shared { bind base::trans_shared_free(_, ptr) }\n+    let free_fn = if shared { bind base::trans_unique_free(_, ptr) }\n                   else { bind base::trans_free(_, ptr) };\n     in_scope_cx(cx) {|info|\n         info.cleanups += [clean_temp(ptr, free_fn,\n@@ -654,15 +654,8 @@ fn T_opaque_vec(targ_cfg: @session::config) -> TypeRef {\n // representation of @T as a tuple (i.e., the ty::t version of what T_box()\n // returns).\n fn tuplify_box_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n-    ret tuplify_cbox_ty(tcx, t, ty::mk_type(tcx));\n-}\n-\n-// As tuplify_box_ty(), but allows the caller to specify what type of type\n-// descr is embedded in the box (ty::type vs ty::send_type).  This is useful\n-// for unique closure boxes, hence the name \"cbox_ty\" (closure box type).\n-fn tuplify_cbox_ty(tcx: ty::ctxt, t: ty::t, tydesc_t: ty::t) -> ty::t {\n     let ptr = ty::mk_ptr(tcx, {ty: ty::mk_nil(tcx), mutbl: ast::m_imm});\n-    ret ty::mk_tup(tcx, [ty::mk_uint(tcx), tydesc_t,\n+    ret ty::mk_tup(tcx, [ty::mk_uint(tcx), ty::mk_type(tcx),\n                          ptr, ptr,\n                          t]);\n }\n@@ -693,6 +686,15 @@ fn T_opaque_box_ptr(cx: @crate_ctxt) -> TypeRef {\n     ret T_box_ptr(T_opaque_box(cx));\n }\n \n+fn T_unique(cx: @crate_ctxt, t: TypeRef) -> TypeRef {\n+    ret T_struct(T_box_header_fields(cx) + [t]);\n+}\n+\n+fn T_unique_ptr(t: TypeRef) -> TypeRef {\n+    const unique_addrspace: uint = 0u;\n+    ret llvm::LLVMPointerType(t, unique_addrspace as c_uint);\n+}\n+\n fn T_port(cx: @crate_ctxt, _t: TypeRef) -> TypeRef {\n     ret T_struct([cx.int_type]); // Refcount\n "}, {"sha": "e37806dccf8f1aca71d4b9bef77c5d162b21b605", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 88, "deletions": 40, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/41b02b7c57092f1da63beec60358061a9579d8c6/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41b02b7c57092f1da63beec60358061a9579d8c6/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=41b02b7c57092f1da63beec60358061a9579d8c6", "patch": "@@ -2,7 +2,7 @@ import syntax::ast;\n import driver::session::session;\n import lib::llvm::{ValueRef, TypeRef};\n import back::abi;\n-import base::{call_memmove, shared_malloc,\n+import base::{call_memmove,\n                INIT, copy_val, load_if_immediate, get_tydesc,\n                sub_block, do_spill_noroot,\n                dest, bcx_icx};\n@@ -21,6 +21,24 @@ fn set_fill(bcx: block, vptr: ValueRef, fill: ValueRef) {\n fn get_alloc(bcx: block, vptr: ValueRef) -> ValueRef {\n     Load(bcx, GEPi(bcx, vptr, [0u, abi::vec_elt_alloc]))\n }\n+\n+fn get_bodyptr(bcx: block, vptr: ValueRef, vec_ty: ty::t) -> ValueRef {\n+    let ccx = bcx.ccx();\n+    alt ty::get(vec_ty).struct {\n+      ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq)\n+      | ty::ty_vec(_) | ty::ty_str {\n+        let boxptr = PointerCast(bcx, vptr, T_ptr(T_box_header(ccx)));\n+        let bodyptr = GEPi(bcx, boxptr, [1u]);\n+        let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n+        let llunit_ty = type_of::type_of(ccx, unit_ty);\n+        PointerCast(bcx, bodyptr, T_ptr(T_vec(ccx, llunit_ty)))\n+      }\n+      _ {\n+        vptr\n+      }\n+    }\n+}\n+\n fn get_dataptr(bcx: block, vptr: ValueRef, unit_ty: TypeRef)\n     -> ValueRef {\n     let _icx = bcx.insn_ctxt(\"tvec::get_dataptr\");\n@@ -35,41 +53,55 @@ fn pointer_add(bcx: block, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n     ret PointerCast(bcx, InBoundsGEP(bcx, bptr, [bytes]), old_ty);\n }\n \n-fn alloc_uniq_raw(bcx: block, fill: ValueRef, alloc: ValueRef) -> result {\n+fn alloc_uniq_raw(bcx: block, unit_ty: ty::t,\n+                  fill: ValueRef, alloc: ValueRef) -> result {\n     let _icx = bcx.insn_ctxt(\"tvec::alloc_uniq_raw\");\n     let ccx = bcx.ccx();\n-    let llvecty = ccx.opaque_vec_type;\n+    let llunitty = type_of::type_of(ccx, unit_ty);\n+    let llvecty = T_vec(ccx, llunitty);\n     let vecsize = Add(bcx, alloc, llsize_of(ccx, llvecty));\n-    let vecptr = shared_malloc(bcx, T_ptr(llvecty), vecsize);\n-    Store(bcx, fill, GEPi(bcx, vecptr, [0u, abi::vec_elt_fill]));\n-    Store(bcx, alloc, GEPi(bcx, vecptr, [0u, abi::vec_elt_alloc]));\n-    ret {bcx: bcx, val: vecptr};\n+    let vecbodyty = unit_ty; // FIXME: This is not the correct type\n+    let {box, body} = base::malloc_unique_dyn(bcx, vecbodyty, vecsize);\n+    let boxptr = PointerCast(bcx, box,\n+                             T_unique_ptr(T_unique(bcx.ccx(), llvecty)));\n+    let bodyptr = PointerCast(bcx, body, T_ptr(llvecty));\n+    Store(bcx, fill, GEPi(bcx, bodyptr, [0u, abi::vec_elt_fill]));\n+    Store(bcx, alloc, GEPi(bcx, bodyptr, [0u, abi::vec_elt_alloc]));\n+    ret {bcx: bcx, val: boxptr};\n }\n \n-fn alloc_uniq(bcx: block, llunitty: TypeRef, elts: uint) -> result {\n+fn alloc_uniq(bcx: block, unit_ty: ty::t, elts: uint) -> result {\n     let _icx = bcx.insn_ctxt(\"tvec::alloc_uniq\");\n     let ccx = bcx.ccx();\n-    let llvecty = T_vec(ccx, llunitty);\n+    let llunitty = type_of::type_of(ccx, unit_ty);\n     let unit_sz = llsize_of(ccx, llunitty);\n \n     let fill = Mul(bcx, C_uint(ccx, elts), unit_sz);\n     let alloc = if elts < 4u { Mul(bcx, C_int(ccx, 4), unit_sz) }\n                 else { fill };\n-    let {bcx: bcx, val: vptr} = alloc_uniq_raw(bcx, fill, alloc);\n-    let vptr = PointerCast(bcx, vptr, T_ptr(llvecty));\n-\n+    let {bcx: bcx, val: vptr} = alloc_uniq_raw(bcx, unit_ty, fill, alloc);\n     ret {bcx: bcx, val: vptr};\n }\n \n fn duplicate_uniq(bcx: block, vptr: ValueRef, vec_ty: ty::t) -> result {\n     let _icx = bcx.insn_ctxt(\"tvec::duplicate_uniq\");\n     let ccx = bcx.ccx();\n-    let fill = get_fill(bcx, vptr);\n+    let body_ptr = get_bodyptr(bcx, vptr, vec_ty);\n+    let fill = get_fill(bcx, body_ptr);\n     let size = Add(bcx, fill, llsize_of(ccx, ccx.opaque_vec_type));\n-    let newptr = shared_malloc(bcx, val_ty(vptr), size);\n-    call_memmove(bcx, newptr, vptr, size);\n+\n     let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n-    Store(bcx, fill, GEPi(bcx, newptr, [0u, abi::vec_elt_alloc]));\n+    let llunitty = type_of::type_of(ccx, unit_ty);\n+    let llvecty = T_vec(ccx, llunitty);\n+    let vecbodyty = unit_ty; // FIXME: This is not the correct type\n+    let {box: newptr, body: new_body_ptr} =\n+        base::malloc_unique_dyn(bcx, vecbodyty, size);\n+    let newptr = PointerCast(bcx, newptr,\n+                             T_unique_ptr(T_unique(bcx.ccx(), llvecty)));\n+    let new_body_ptr = PointerCast(bcx, new_body_ptr, T_ptr(llvecty));\n+    call_memmove(bcx, new_body_ptr, body_ptr, size);\n+\n+    Store(bcx, fill, GEPi(bcx, new_body_ptr, [0u, abi::vec_elt_alloc]));\n     let bcx = if ty::type_needs_drop(bcx.tcx(), unit_ty) {\n         iter_vec(bcx, newptr, vec_ty, base::take_ty)\n     } else { bcx };\n@@ -83,7 +115,7 @@ fn make_free_glue(bcx: block, vptr: ValueRef, vec_ty: ty::t) ->\n         let bcx = if ty::type_needs_drop(tcx, unit_ty) {\n             iter_vec(bcx, vptr, vec_ty, base::drop_ty)\n         } else { bcx };\n-        base::trans_shared_free(bcx, vptr)\n+        base::trans_unique_free(bcx, vptr)\n     }\n }\n \n@@ -133,9 +165,10 @@ fn trans_evec(bcx: block, args: [@ast::expr],\n             {bcx: bcx, val: p, dataptr: vp}\n           }\n           ast::vstore_uniq {\n-            let {bcx, val} = alloc_uniq(bcx, llunitty, args.len());\n+            let {bcx, val} = alloc_uniq(bcx, unit_ty, args.len());\n             add_clean_free(bcx, val, true);\n-            let dataptr = get_dataptr(bcx, val, llunitty);\n+            let body = get_bodyptr(bcx, val, vec_ty);\n+            let dataptr = get_dataptr(bcx, body, llunitty);\n             {bcx: bcx, val: val, dataptr: dataptr}\n           }\n           ast::vstore_box {\n@@ -216,8 +249,9 @@ fn get_base_and_len(cx: block, v: ValueRef, e_ty: ty::t)\n         (base, len)\n       }\n       ty::vstore_uniq {\n-        let base = tvec::get_dataptr(cx, v, llunitty);\n-        let len = tvec::get_fill(cx, v);\n+        let body = tvec::get_bodyptr(cx, v, vec_ty);\n+        let base = tvec::get_dataptr(cx, body, llunitty);\n+        let len = tvec::get_fill(cx, body);\n         (base, len)\n       }\n       ty::vstore_box {\n@@ -249,7 +283,9 @@ fn trans_estr(bcx: block, s: str, vstore: ast::vstore,\n       ast::vstore_uniq {\n         let cs = PointerCast(bcx, C_cstr(ccx, s), T_ptr(T_i8()));\n         let len = C_uint(ccx, str::len(s));\n-        Call(bcx, ccx.upcalls.str_new_uniq, [cs, len])\n+        let c = Call(bcx, ccx.upcalls.str_new_uniq, [cs, len]);\n+        PointerCast(bcx, c,\n+                    T_unique_ptr(T_unique(ccx, T_vec(ccx, T_i8()))))\n       }\n \n       ast::vstore_box {\n@@ -274,19 +310,23 @@ fn trans_append(bcx: block, vec_ty: ty::t, lhsptr: ValueRef,\n \n     let lhs = Load(bcx, lhsptr);\n     let self_append = ICmp(bcx, lib::llvm::IntEQ, lhs, rhs);\n-    let lfill = get_fill(bcx, lhs);\n-    let rfill = get_fill(bcx, rhs);\n+    let lbody = get_bodyptr(bcx, lhs, vec_ty);\n+    let rbody = get_bodyptr(bcx, rhs, vec_ty);\n+    let lfill = get_fill(bcx, lbody);\n+    let rfill = get_fill(bcx, rbody);\n     let mut new_fill = Add(bcx, lfill, rfill);\n     if strings { new_fill = Sub(bcx, new_fill, C_int(ccx, 1)); }\n     let opaque_lhs = PointerCast(bcx, lhsptr,\n-                                 T_ptr(T_ptr(ccx.opaque_vec_type)));\n+                                 T_ptr(T_ptr(T_i8())));\n     Call(bcx, ccx.upcalls.vec_grow,\n          [opaque_lhs, new_fill]);\n     // Was overwritten if we resized\n     let lhs = Load(bcx, lhsptr);\n     let rhs = Select(bcx, self_append, lhs, rhs);\n \n-    let lhs_data = get_dataptr(bcx, lhs, llunitty);\n+    let lbody = get_bodyptr(bcx, lhs, vec_ty);\n+\n+    let lhs_data = get_dataptr(bcx, lbody, llunitty);\n     let mut lhs_off = lfill;\n     if strings { lhs_off = Sub(bcx, lhs_off, C_int(ccx, 1)); }\n     let write_ptr = pointer_add(bcx, lhs_data, lhs_off);\n@@ -311,18 +351,18 @@ fn trans_append_literal(bcx: block, vptrptr: ValueRef, vec_ty: ty::t,\n     let scratch = base::alloca(bcx, elt_llty);\n     for vec::each(vals) {|val|\n         bcx = base::trans_expr_save_in(bcx, val, scratch);\n-        let vptr = Load(bcx, vptrptr);\n+        let vptr = get_bodyptr(bcx, Load(bcx, vptrptr), vec_ty);\n         let old_fill = get_fill(bcx, vptr);\n         let new_fill = Add(bcx, old_fill, elt_sz);\n         let do_grow = ICmp(bcx, lib::llvm::IntUGT, new_fill,\n                            get_alloc(bcx, vptr));\n         bcx = base::with_cond(bcx, do_grow) {|bcx|\n             let pt = PointerCast(bcx, vptrptr,\n-                                 T_ptr(T_ptr(ccx.opaque_vec_type)));\n+                                 T_ptr(T_ptr(T_i8())));\n             Call(bcx, ccx.upcalls.vec_grow, [pt, new_fill]);\n             bcx\n         };\n-        let vptr = Load(bcx, vptrptr);\n+        let vptr = get_bodyptr(bcx, Load(bcx, vptrptr), vec_ty);\n         set_fill(bcx, vptr, new_fill);\n         let targetptr = pointer_add(bcx, get_dataptr(bcx, vptr, elt_llty),\n                                     old_fill);\n@@ -336,23 +376,30 @@ fn trans_add(bcx: block, vec_ty: ty::t, lhs: ValueRef,\n     let _icx = bcx.insn_ctxt(\"tvec::trans_add\");\n     let ccx = bcx.ccx();\n \n+    let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n+    let llunitty = type_of::type_of(ccx, unit_ty);\n+\n     if ty::get(vec_ty).struct == ty::ty_str {\n+        let lhs = PointerCast(bcx, lhs, T_ptr(T_i8()));\n+        let rhs = PointerCast(bcx, rhs, T_ptr(T_i8()));\n         let n = Call(bcx, ccx.upcalls.str_concat, [lhs, rhs]);\n+        let n = PointerCast(\n+            bcx, n, T_unique_ptr(T_unique(ccx, T_vec(ccx, llunitty))));\n         ret base::store_in_dest(bcx, n, dest);\n     }\n \n-    let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n-    let llunitty = type_of::type_of(ccx, unit_ty);\n+    let lhs_body = get_bodyptr(bcx, lhs, vec_ty);\n+    let rhs_body = get_bodyptr(bcx, rhs, vec_ty);\n \n-    let lhs_fill = get_fill(bcx, lhs);\n-    let rhs_fill = get_fill(bcx, rhs);\n+    let lhs_fill = get_fill(bcx, lhs_body);\n+    let rhs_fill = get_fill(bcx, rhs_body);\n     let new_fill = Add(bcx, lhs_fill, rhs_fill);\n     let mut {bcx: bcx, val: new_vec_ptr} =\n-        alloc_uniq_raw(bcx, new_fill, new_fill);\n-    new_vec_ptr = PointerCast(bcx, new_vec_ptr, T_ptr(T_vec(ccx, llunitty)));\n+        alloc_uniq_raw(bcx, unit_ty, new_fill, new_fill);\n \n+    let new_vec_body_ptr = get_bodyptr(bcx, new_vec_ptr, vec_ty);\n     let write_ptr_ptr = do_spill_noroot\n-        (bcx, get_dataptr(bcx, new_vec_ptr, llunitty));\n+        (bcx, get_dataptr(bcx, new_vec_body_ptr, llunitty));\n     let copy_fn = fn@(bcx: block, addr: ValueRef,\n                       _ty: ty::t) -> block {\n         let ccx = bcx.ccx();\n@@ -408,16 +455,17 @@ fn iter_vec_uniq(bcx: block, vptr: ValueRef, vec_ty: ty::t,\n     let ccx = bcx.ccx();\n     let unit_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n     let llunitty = type_of::type_of(ccx, unit_ty);\n-    let vptr = PointerCast(bcx, vptr, T_ptr(T_vec(ccx, llunitty)));\n-    let data_ptr = get_dataptr(bcx, vptr, llunitty);\n+    let body_ptr = get_bodyptr(bcx, vptr, vec_ty);\n+    let data_ptr = get_dataptr(bcx, body_ptr, llunitty);\n     iter_vec_raw(bcx, data_ptr, vec_ty, fill, f)\n }\n \n fn iter_vec(bcx: block, vptr: ValueRef, vec_ty: ty::t,\n             f: iter_vec_block) -> block {\n     let _icx = bcx.insn_ctxt(\"tvec::iter_vec\");\n-    let vptr = PointerCast(bcx, vptr, T_ptr(bcx.ccx().opaque_vec_type));\n-    ret iter_vec_uniq(bcx, vptr, vec_ty, get_fill(bcx, vptr), f);\n+    let body_ptr = get_bodyptr(bcx, vptr, vec_ty);\n+    let fill = get_fill(bcx, body_ptr);\n+    ret iter_vec_uniq(bcx, vptr, vec_ty, fill, f);\n }\n \n //"}, {"sha": "fedd7c713cff7b9f71c3f11398bdac9da76e9f05", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/41b02b7c57092f1da63beec60358061a9579d8c6/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41b02b7c57092f1da63beec60358061a9579d8c6/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=41b02b7c57092f1da63beec60358061a9579d8c6", "patch": "@@ -85,15 +85,19 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n           ty::ty_uint(t) { T_uint_ty(cx, t) }\n           ty::ty_float(t) { T_float_ty(cx, t) }\n           ty::ty_estr(ty::vstore_uniq) |\n-          ty::ty_str { T_ptr(T_vec(cx, T_i8())) }\n+          ty::ty_str {\n+            T_unique_ptr(T_unique(cx, T_vec(cx, T_i8())))\n+          }\n           ty::ty_enum(did, _) { type_of_enum(cx, did, t) }\n           ty::ty_estr(ty::vstore_box) { T_box_ptr(T_box(cx, T_i8())) }\n           ty::ty_evec(mt, ty::vstore_box) |\n           ty::ty_box(mt) { T_box_ptr(T_box(cx, type_of(cx, mt.ty))) }\n           ty::ty_opaque_box { T_box_ptr(T_box(cx, T_i8())) }\n-          ty::ty_uniq(mt) { T_ptr(type_of(cx, mt.ty)) }\n+          ty::ty_uniq(mt) { T_unique_ptr(T_unique(cx, type_of(cx, mt.ty))) }\n           ty::ty_evec(mt, ty::vstore_uniq) |\n-          ty::ty_vec(mt) { T_ptr(T_vec(cx, type_of(cx, mt.ty))) }\n+          ty::ty_vec(mt) {\n+            T_unique_ptr(T_unique(cx, T_vec(cx, type_of(cx, mt.ty))))\n+          }\n           ty::ty_ptr(mt) { T_ptr(type_of(cx, mt.ty)) }\n           ty::ty_rptr(_, mt) { T_ptr(type_of(cx, mt.ty)) }\n "}, {"sha": "a3325fc4904afc00d690a9e870faa0512d277878", "filename": "src/rustc/middle/trans/uniq.rs", "status": "modified", "additions": 29, "deletions": 22, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/41b02b7c57092f1da63beec60358061a9579d8c6/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41b02b7c57092f1da63beec60358061a9579d8c6/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs?ref=41b02b7c57092f1da63beec60358061a9579d8c6", "patch": "@@ -5,34 +5,28 @@ import build::*;\n import base::*;\n import shape::llsize_of;\n \n-export trans_uniq, make_free_glue, autoderef, duplicate, alloc_uniq;\n+export trans_uniq, make_free_glue, autoderef, duplicate;\n \n fn trans_uniq(bcx: block, contents: @ast::expr,\n               node_id: ast::node_id, dest: dest) -> block {\n     let _icx = bcx.insn_ctxt(\"uniq::trans_uniq\");\n     let uniq_ty = node_id_type(bcx, node_id);\n-    let llptr = alloc_uniq(bcx, uniq_ty);\n-    add_clean_free(bcx, llptr, true);\n-    let bcx = trans_expr_save_in(bcx, contents, llptr);\n-    revoke_clean(bcx, llptr);\n-    ret store_in_dest(bcx, llptr, dest);\n-}\n-\n-fn alloc_uniq(bcx: block, uniq_ty: ty::t) -> ValueRef {\n-    let _icx = bcx.insn_ctxt(\"uniq::alloc_uniq\");\n     let contents_ty = content_ty(uniq_ty);\n-    let llty = type_of::type_of(bcx.ccx(), contents_ty);\n-    let llsz = llsize_of(bcx.ccx(), llty);\n-    let llptrty = T_ptr(llty);\n-    shared_malloc(bcx, llptrty, llsz)\n+    let {box, body} = malloc_unique(bcx, contents_ty);\n+    add_clean_free(bcx, box, true);\n+    let bcx = trans_expr_save_in(bcx, contents, body);\n+    revoke_clean(bcx, box);\n+    ret store_in_dest(bcx, box, dest);\n }\n \n fn make_free_glue(bcx: block, vptr: ValueRef, t: ty::t)\n     -> block {\n     let _icx = bcx.insn_ctxt(\"uniq::make_free_glue\");\n     with_cond(bcx, IsNotNull(bcx, vptr)) {|bcx|\n-        let bcx = drop_ty(bcx, vptr, content_ty(t));\n-        trans_shared_free(bcx, vptr)\n+        let content_ty = content_ty(t);\n+        let body_ptr = opaque_box_body(bcx, content_ty, vptr);\n+        let bcx = drop_ty(bcx, body_ptr, content_ty);\n+        trans_unique_free(bcx, vptr)\n     }\n }\n \n@@ -43,18 +37,31 @@ fn content_ty(t: ty::t) -> ty::t {\n     }\n }\n \n-fn autoderef(v: ValueRef, t: ty::t) -> {v: ValueRef, t: ty::t} {\n+fn autoderef(bcx: block, v: ValueRef, t: ty::t) -> {v: ValueRef, t: ty::t} {\n     let content_ty = content_ty(t);\n+    let v = opaque_box_body(bcx, content_ty, v);\n     ret {v: v, t: content_ty};\n }\n \n fn duplicate(bcx: block, v: ValueRef, t: ty::t) -> result {\n     let _icx = bcx.insn_ctxt(\"uniq::duplicate\");\n     let content_ty = content_ty(t);\n-    let llptr = alloc_uniq(bcx, t);\n+    let {box: dst_box, body: dst_body} = malloc_unique(bcx, content_ty);\n+\n+    let src_box = v;\n+    let src_body = opaque_box_body(bcx, content_ty, src_box);\n+    let src_body = load_if_immediate(bcx, src_body, content_ty);\n+    #debug(\"ST: %?\", val_str(bcx.ccx().tn, src_body));\n+    #debug(\"DT: %?\", val_str(bcx.ccx().tn, dst_body));\n+    let bcx = copy_val(bcx, INIT, dst_body, src_body, content_ty);\n+\n+    let src_tydesc_ptr = GEPi(bcx, src_box,\n+                              [0u, back::abi::box_field_tydesc]);\n+    let dst_tydesc_ptr = GEPi(bcx, dst_box,\n+                              [0u, back::abi::box_field_tydesc]);\n+\n+    let td = Load(bcx, src_tydesc_ptr);\n+    Store(bcx, td, dst_tydesc_ptr);\n \n-    let src = load_if_immediate(bcx, v, content_ty);\n-    let dst = llptr;\n-    let bcx = copy_val(bcx, INIT, dst, src, content_ty);\n-    ret rslt(bcx, dst);\n+    ret rslt(bcx, dst_box);\n }\n\\ No newline at end of file"}, {"sha": "c8546daf2381f16c0b4a993b524bb12a731dfb0a", "filename": "src/snapshots.txt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/41b02b7c57092f1da63beec60358061a9579d8c6/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/41b02b7c57092f1da63beec60358061a9579d8c6/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=41b02b7c57092f1da63beec60358061a9579d8c6", "patch": "@@ -1,3 +1,11 @@\n+S 2012-05-30 0c0818b\n+  winnt-i386 910bc6b562e8e310e99f8174292f2b0a0d93ef6c\n+  linux-x86_64 482bfe7c000bc798945524dd750d3e06be2c0283\n+  linux-i386 f794e99472bc59773fa5281a4f9e2875e59f812f\n+  freebsd-x86_64 29ec0b56d05c59e3a6eec2a97f17e2429c1a6331\n+  macos-x86_64 d562f05c8911e7405b0a9ff5815f49fca69045d3\n+  macos-i386 4d09cc2a4882d92f125718161e3d7086531748e6\n+\n S 2012-05-30 02dde78\n   winnt-i386 b394e3db0639942a9844ce6f78d34239a90127af\n   linux-x86_64 bd3128bce34f2f131f37bc1c7077a4d2e367ff50"}]}