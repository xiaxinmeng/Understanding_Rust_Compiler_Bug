{"sha": "99433a1ffdb1724cbafeafba88d6d52fee579bd1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5NDMzYTFmZmRiMTcyNGNiYWZlYWZiYTg4ZDZkNTJmZWU1NzliZDE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-05-27T03:02:51Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-05-30T17:41:38Z"}, "message": "improve fn pointer signature check to allow some casts that should be permitted\n\nAlso properly check the \"non-capturing Fn to fn\" case", "tree": {"sha": "3662888c1af20a79d506397c6775c9faf9701d71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3662888c1af20a79d506397c6775c9faf9701d71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99433a1ffdb1724cbafeafba88d6d52fee579bd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99433a1ffdb1724cbafeafba88d6d52fee579bd1", "html_url": "https://github.com/rust-lang/rust/commit/99433a1ffdb1724cbafeafba88d6d52fee579bd1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99433a1ffdb1724cbafeafba88d6d52fee579bd1/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd6e3e643133fc1c6cdfd6067445236f9b776c7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd6e3e643133fc1c6cdfd6067445236f9b776c7c", "html_url": "https://github.com/rust-lang/rust/commit/cd6e3e643133fc1c6cdfd6067445236f9b776c7c"}], "stats": {"total": 92, "additions": 83, "deletions": 9}, "files": [{"sha": "0fea3a174be167a269c97361dc15aa9677b93f8d", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 65, "deletions": 9, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/99433a1ffdb1724cbafeafba88d6d52fee579bd1/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99433a1ffdb1724cbafeafba88d6d52fee579bd1/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=99433a1ffdb1724cbafeafba88d6d52fee579bd1", "patch": "@@ -72,15 +72,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                             ty::TyFnDef(_, _, real_sig) => {\n                                 let sig = self.erase_lifetimes(&sig);\n                                 let real_sig = self.erase_lifetimes(&real_sig);\n-                                match instance.def {\n-                                    // FIXME: this needs checks for weird transmutes\n-                                    // we need to bail here, because noncapturing closures as fn ptrs fail the checks\n-                                    ty::InstanceDef::ClosureOnceShim{..} => {}\n-                                    _ => if sig.abi != real_sig.abi ||\n-                                        sig.variadic != real_sig.variadic ||\n-                                        sig.inputs_and_output != real_sig.inputs_and_output {\n-                                        return Err(EvalError::FunctionPointerTyMismatch(real_sig, sig));\n-                                    },\n+                                if !self.check_sig_compat(sig, real_sig)? {\n+                                    return Err(EvalError::FunctionPointerTyMismatch(real_sig, sig));\n                                 }\n                             },\n                             ref other => bug!(\"instance def ty: {:?}\", other),\n@@ -138,6 +131,69 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(())\n     }\n \n+    /// Decides whether it is okay to call the method with signature `real_sig` using signature `sig`\n+    fn check_sig_compat(\n+        &mut self,\n+        sig: ty::FnSig<'tcx>,\n+        real_sig: ty::FnSig<'tcx>,\n+    ) -> EvalResult<'tcx, bool> {\n+        fn check_ty_compat<'tcx>(\n+            ty: ty::Ty<'tcx>,\n+            real_ty: ty::Ty<'tcx>,\n+        ) -> bool {\n+            if ty == real_ty { return true; } // This is actually a fast pointer comparison\n+            return match (&ty.sty, &real_ty.sty) {\n+                // Permit changing the pointer type of raw pointers and references as well as\n+                // mutability of raw pointers.\n+                // TODO: Should not be allowed when fat pointers are involved.\n+                (&TypeVariants::TyRawPtr(_), &TypeVariants::TyRawPtr(_)) => true,\n+                (&TypeVariants::TyRef(_, _), &TypeVariants::TyRef(_, _)) =>\n+                    ty.is_mutable_pointer() == real_ty.is_mutable_pointer(),\n+                // rule out everything else\n+                _ => false\n+            }\n+        }\n+\n+        if sig.abi == real_sig.abi &&\n+            sig.variadic == real_sig.variadic &&\n+            sig.inputs_and_output.len() == real_sig.inputs_and_output.len() &&\n+            sig.inputs_and_output.iter().zip(real_sig.inputs_and_output).all(|(ty, real_ty)| check_ty_compat(ty, real_ty)) {\n+            // Definitely good.\n+            return Ok(true);\n+        }\n+\n+        if sig.variadic || real_sig.variadic {\n+            // We're not touching this\n+            return Ok(false);\n+        }\n+\n+        // We need to allow what comes up when a non-capturing closure is cast to a fn().\n+        match (sig.abi, real_sig.abi) {\n+            (Abi::Rust, Abi::RustCall) // check the ABIs.  This makes the test here non-symmetric.\n+                if check_ty_compat(sig.output(), real_sig.output()) && real_sig.inputs_and_output.len() == 3 => {\n+                // First argument of real_sig must be a ZST\n+                let fst_ty = real_sig.inputs_and_output[0];\n+                let layout = self.type_layout(fst_ty)?;\n+                let size = layout.size(&self.tcx.data_layout).bytes();\n+                if size == 0 {\n+                    // Second argument must be a tuple matching the argument list of sig\n+                    let snd_ty = real_sig.inputs_and_output[1];\n+                    match snd_ty.sty {\n+                        TypeVariants::TyTuple(tys, _) if sig.inputs().len() == tys.len() =>\n+                            if sig.inputs().iter().zip(tys).all(|(ty, real_ty)| check_ty_compat(ty, real_ty)) {\n+                                return Ok(true)\n+                            },\n+                        _ => {}\n+                    }\n+                }\n+            }\n+            _ => {}\n+        };\n+\n+        // Nope, this doesn't work.\n+        return Ok(false);\n+    }\n+\n     fn eval_fn_call(\n         &mut self,\n         instance: ty::Instance<'tcx>,"}, {"sha": "5d902e1f9aaaf811f7729293bda0f9b1c69459dd", "filename": "tests/compile-fail/cast_fn_ptr2.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/99433a1ffdb1724cbafeafba88d6d52fee579bd1/tests%2Fcompile-fail%2Fcast_fn_ptr2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99433a1ffdb1724cbafeafba88d6d52fee579bd1/tests%2Fcompile-fail%2Fcast_fn_ptr2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast_fn_ptr2.rs?ref=99433a1ffdb1724cbafeafba88d6d52fee579bd1", "patch": "@@ -0,0 +1,9 @@\n+fn main() {\n+    fn f(_ : (i32,i32)) {}\n+\n+    let g = unsafe {\n+        std::mem::transmute::<fn((i32,i32)), fn(i32)>(f)\n+    };\n+\n+    g(42) //~ ERROR tried to call a function with sig fn((i32, i32)) through a function pointer of type fn(i32)\n+}"}, {"sha": "109e8dfc2a02be11da01cf14bd84ca0ccd6f9842", "filename": "tests/run-pass/cast_fn_ptr.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/99433a1ffdb1724cbafeafba88d6d52fee579bd1/tests%2Frun-pass%2Fcast_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99433a1ffdb1724cbafeafba88d6d52fee579bd1/tests%2Frun-pass%2Fcast_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fcast_fn_ptr.rs?ref=99433a1ffdb1724cbafeafba88d6d52fee579bd1", "patch": "@@ -0,0 +1,9 @@\n+fn main() {\n+    fn f(_: *const u8) {}\n+\n+    let g = unsafe {\n+        std::mem::transmute::<fn(*const u8), fn(*const i32)>(f)\n+    };\n+\n+    g(&42 as *const _);\n+}"}]}