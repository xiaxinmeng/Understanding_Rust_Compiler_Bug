{"sha": "2f8b36fc16178b298b23dfa199067ec2dd91df93", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmOGIzNmZjMTYxNzhiMjk4YjIzZGZhMTk5MDY3ZWMyZGQ5MWRmOTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-11T13:55:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-11T13:55:01Z"}, "message": "auto merge of #5819 : erickt/rust/incoming, r=erickt\n\nGood morning,\r\n\r\nThis first patch series adds support for `#[deriving(Decodable, Encodable)]`, but does not yet remove `#[auto_encode]` and `#[auto_decode]`. I need a snapshot to remove the old code. Along the way it also extends support for tuple structs and struct enum variants.\r\n\r\nAlso, it includes a minor fix to the pretty printer. We decided a while ago to use 4 spaces to indent a match arm instead of 2. This updates the pretty printer to reflect that.", "tree": {"sha": "685ecf6bd64a084a1827134c9f5966026763b2d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/685ecf6bd64a084a1827134c9f5966026763b2d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f8b36fc16178b298b23dfa199067ec2dd91df93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f8b36fc16178b298b23dfa199067ec2dd91df93", "html_url": "https://github.com/rust-lang/rust/commit/2f8b36fc16178b298b23dfa199067ec2dd91df93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f8b36fc16178b298b23dfa199067ec2dd91df93/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0defb8466e624ded66ef00f092a86b638e01152", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0defb8466e624ded66ef00f092a86b638e01152", "html_url": "https://github.com/rust-lang/rust/commit/e0defb8466e624ded66ef00f092a86b638e01152"}, {"sha": "26ecb30f550a46d52528a7d45d9327ebce938e81", "url": "https://api.github.com/repos/rust-lang/rust/commits/26ecb30f550a46d52528a7d45d9327ebce938e81", "html_url": "https://github.com/rust-lang/rust/commit/26ecb30f550a46d52528a7d45d9327ebce938e81"}], "stats": {"total": 1577, "additions": 1419, "deletions": 158}, "files": [{"sha": "f5a31879855ef2816915db2f13454c848eb31797", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/2f8b36fc16178b298b23dfa199067ec2dd91df93/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8b36fc16178b298b23dfa199067ec2dd91df93/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=2f8b36fc16178b298b23dfa199067ec2dd91df93", "patch": "@@ -556,6 +556,7 @@ trait read_method_map_entry_helper {\n                             -> method_map_entry;\n }\n \n+#[cfg(stage0)]\n fn encode_method_map_entry(ecx: @e::EncodeContext,\n                               ebml_w: writer::Encoder,\n                               mme: method_map_entry) {\n@@ -572,7 +573,27 @@ fn encode_method_map_entry(ecx: @e::EncodeContext,\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+fn encode_method_map_entry(ecx: @e::EncodeContext,\n+                              ebml_w: writer::Encoder,\n+                              mme: method_map_entry) {\n+    do ebml_w.emit_struct(\"method_map_entry\", 3) {\n+        do ebml_w.emit_struct_field(\"self_arg\", 0u) {\n+            ebml_w.emit_arg(ecx, mme.self_arg);\n+        }\n+        do ebml_w.emit_struct_field(\"explicit_self\", 2u) {\n+            mme.explicit_self.encode(&ebml_w);\n+        }\n+        do ebml_w.emit_struct_field(\"origin\", 1u) {\n+            mme.origin.encode(&ebml_w);\n+        }\n+    }\n+}\n+\n impl read_method_map_entry_helper for reader::Decoder {\n+    #[cfg(stage0)]\n     fn read_method_map_entry(&self, xcx: @ExtendedDecodeContext)\n         -> method_map_entry {\n         do self.read_struct(\"method_map_entry\", 3) {\n@@ -592,6 +613,29 @@ impl read_method_map_entry_helper for reader::Decoder {\n             }\n         }\n     }\n+\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn read_method_map_entry(&self, xcx: @ExtendedDecodeContext)\n+        -> method_map_entry {\n+        do self.read_struct(\"method_map_entry\", 3) {\n+            method_map_entry {\n+                self_arg: self.read_struct_field(\"self_arg\", 0u, || {\n+                    self.read_arg(xcx)\n+                }),\n+                explicit_self: self.read_struct_field(\"explicit_self\", 2u, || {\n+                    let self_type: ast::self_ty_ = Decodable::decode(self);\n+                    self_type\n+                }),\n+                origin: self.read_struct_field(\"origin\", 1u, || {\n+                    let method_origin: method_origin =\n+                        Decodable::decode(self);\n+                    method_origin.tr(xcx)\n+                }),\n+            }\n+        }\n+    }\n }\n \n impl tr for method_origin {\n@@ -782,6 +826,7 @@ impl ebml_writer_helpers for writer::Encoder {\n         }\n     }\n \n+    #[cfg(stage0)]\n     fn emit_tpbt(&self, ecx: @e::EncodeContext,\n                  tpbt: ty::ty_param_bounds_and_ty) {\n         do self.emit_struct(\"ty_param_bounds_and_ty\", 2) {\n@@ -804,6 +849,32 @@ impl ebml_writer_helpers for writer::Encoder {\n             }\n         }\n     }\n+\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn emit_tpbt(&self, ecx: @e::EncodeContext,\n+                 tpbt: ty::ty_param_bounds_and_ty) {\n+        do self.emit_struct(\"ty_param_bounds_and_ty\", 2) {\n+            do self.emit_struct_field(\"generics\", 0) {\n+                do self.emit_struct(\"Generics\", 2) {\n+                    do self.emit_struct_field(\"type_param_defs\", 0) {\n+                        do self.emit_from_vec(*tpbt.generics.type_param_defs)\n+                            |type_param_def|\n+                        {\n+                            self.emit_type_param_def(ecx, type_param_def);\n+                        }\n+                    }\n+                    do self.emit_struct_field(\"region_param\", 1) {\n+                        tpbt.generics.region_param.encode(self);\n+                    }\n+                }\n+            }\n+            do self.emit_struct_field(\"ty\", 1) {\n+                self.emit_ty(ecx, tpbt.ty);\n+            }\n+        }\n+    }\n }\n \n trait write_tag_and_id {\n@@ -1053,6 +1124,7 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n         }\n     }\n \n+    #[cfg(stage0)]\n     fn read_ty_param_bounds_and_ty(&self, xcx: @ExtendedDecodeContext)\n         -> ty::ty_param_bounds_and_ty\n     {\n@@ -1075,6 +1147,31 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n         }\n     }\n \n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn read_ty_param_bounds_and_ty(&self, xcx: @ExtendedDecodeContext)\n+        -> ty::ty_param_bounds_and_ty\n+    {\n+        do self.read_struct(\"ty_param_bounds_and_ty\", 2) {\n+            ty::ty_param_bounds_and_ty {\n+                generics: do self.read_struct(\"Generics\", 2) {\n+                    ty::Generics {\n+                        type_param_defs: self.read_struct_field(\"type_param_defs\", 0, || {\n+                            @self.read_to_vec(|| self.read_type_param_def(xcx))\n+                        }),\n+                        region_param: self.read_struct_field(~\"region_param\", 1, || {\n+                            Decodable::decode(self)\n+                        })\n+                    }\n+                },\n+                ty: self.read_struct_field(\"ty\", 1, || {\n+                    self.read_ty(xcx)\n+                })\n+            }\n+        }\n+    }\n+\n     fn convert_def_id(&self, xcx: @ExtendedDecodeContext,\n                       source: tydecode::DefIdSource,\n                       did: ast::def_id) -> ast::def_id {"}, {"sha": "4a3447700bc8fbbcb1ad1f4328f0f741de7c096e", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 85, "deletions": 17, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/2f8b36fc16178b298b23dfa199067ec2dd91df93/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8b36fc16178b298b23dfa199067ec2dd91df93/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=2f8b36fc16178b298b23dfa199067ec2dd91df93", "patch": "@@ -335,31 +335,61 @@ pub mod reader {\n             f()\n         }\n \n-        fn read_seq<T>(&self, f: &fn(uint) -> T) -> T {\n-            debug!(\"read_seq()\");\n-            do self.push_doc(self.next_doc(EsVec)) {\n-                let len = self._next_uint(EsVecLen);\n-                debug!(\"  len=%u\", len);\n-                f(len)\n+        fn read_enum_struct_variant<T>(&self, _names: &[&str], f: &fn(uint) -> T) -> T {\n+            debug!(\"read_enum_struct_variant()\");\n+            let idx = self._next_uint(EsEnumVid);\n+            debug!(\"  idx=%u\", idx);\n+            do self.push_doc(self.next_doc(EsEnumBody)) {\n+                f(idx)\n             }\n         }\n \n-        fn read_seq_elt<T>(&self, idx: uint, f: &fn() -> T) -> T {\n-            debug!(\"read_seq_elt(idx=%u)\", idx);\n-            self.push_doc(self.next_doc(EsVecElt), f)\n+        fn read_enum_struct_variant_field<T>(&self, name: &str, idx: uint, f: &fn() -> T) -> T {\n+            debug!(\"read_enum_struct_variant_arg(name=%?, idx=%u)\", name, idx);\n+            f()\n         }\n \n         fn read_struct<T>(&self, name: &str, _len: uint, f: &fn() -> T) -> T {\n             debug!(\"read_struct(name=%s)\", name);\n             f()\n         }\n \n+        #[cfg(stage0)]\n         fn read_field<T>(&self, name: &str, idx: uint, f: &fn() -> T) -> T {\n-            debug!(\"read_field(name=%s, idx=%u)\", name, idx);\n+            debug!(\"read_field(name=%?, idx=%u)\", name, idx);\n             self._check_label(name);\n             f()\n         }\n \n+        #[cfg(stage1)]\n+        #[cfg(stage2)]\n+        #[cfg(stage3)]\n+        fn read_struct_field<T>(&self, name: &str, idx: uint, f: &fn() -> T) -> T {\n+            debug!(\"read_struct_field(name=%?, idx=%u)\", name, idx);\n+            self._check_label(name);\n+            f()\n+        }\n+\n+        fn read_tuple<T>(&self, f: &fn(uint) -> T) -> T {\n+            debug!(\"read_tuple()\");\n+            self.read_seq(f)\n+        }\n+\n+        fn read_tuple_arg<T>(&self, idx: uint, f: &fn() -> T) -> T {\n+            debug!(\"read_tuple_arg(idx=%u)\", idx);\n+            self.read_seq_elt(idx, f)\n+        }\n+\n+        fn read_tuple_struct<T>(&self, name: &str, f: &fn(uint) -> T) -> T {\n+            debug!(\"read_tuple_struct(name=%?)\", name);\n+            self.read_tuple(f)\n+        }\n+\n+        fn read_tuple_struct_arg<T>(&self, idx: uint, f: &fn() -> T) -> T {\n+            debug!(\"read_tuple_struct_arg(idx=%u)\", idx);\n+            self.read_tuple_arg(idx, f)\n+        }\n+\n         fn read_option<T>(&self, f: &fn(bool) -> T) -> T {\n             debug!(\"read_option()\");\n             do self.read_enum(\"Option\") || {\n@@ -373,6 +403,20 @@ pub mod reader {\n             }\n         }\n \n+        fn read_seq<T>(&self, f: &fn(uint) -> T) -> T {\n+            debug!(\"read_seq()\");\n+            do self.push_doc(self.next_doc(EsVec)) {\n+                let len = self._next_uint(EsVecLen);\n+                debug!(\"  len=%u\", len);\n+                f(len)\n+            }\n+        }\n+\n+        fn read_seq_elt<T>(&self, idx: uint, f: &fn() -> T) -> T {\n+            debug!(\"read_seq_elt(idx=%u)\", idx);\n+            self.push_doc(self.next_doc(EsVecElt), f)\n+        }\n+\n         fn read_map<T>(&self, _f: &fn(uint) -> T) -> T {\n             debug!(\"read_map()\");\n             fail!(~\"read_map is unimplemented\");\n@@ -606,29 +650,42 @@ pub mod writer {\n             self._emit_label(name);\n             self.wr_tag(EsEnum as uint, f)\n         }\n+\n         fn emit_enum_variant(&self, _v_name: &str, v_id: uint, _cnt: uint,\n                              f: &fn()) {\n             self._emit_tagged_uint(EsEnumVid, v_id);\n             self.wr_tag(EsEnumBody as uint, f)\n         }\n+\n         fn emit_enum_variant_arg(&self, _idx: uint, f: &fn()) { f() }\n \n-        fn emit_seq(&self, len: uint, f: &fn()) {\n-            do self.wr_tag(EsVec as uint) {\n-                self._emit_tagged_uint(EsVecLen, len);\n-                f()\n-            }\n+        fn emit_enum_struct_variant(&self, v_name: &str, v_id: uint, cnt: uint, f: &fn()) {\n+            self.emit_enum_variant(v_name, v_id, cnt, f)\n         }\n \n-        fn emit_seq_elt(&self, _idx: uint, f: &fn()) {\n-            self.wr_tag(EsVecElt as uint, f)\n+        fn emit_enum_struct_variant_field(&self, _f_name: &str, idx: uint, f: &fn()) {\n+            self.emit_enum_variant_arg(idx, f)\n         }\n \n         fn emit_struct(&self, _name: &str, _len: uint, f: &fn()) { f() }\n+        #[cfg(stage0)]\n         fn emit_field(&self, name: &str, _idx: uint, f: &fn()) {\n             self._emit_label(name);\n             f()\n         }\n+        #[cfg(stage1)]\n+        #[cfg(stage2)]\n+        #[cfg(stage3)]\n+        fn emit_struct_field(&self, name: &str, _idx: uint, f: &fn()) {\n+            self._emit_label(name);\n+            f()\n+        }\n+\n+        fn emit_tuple(&self, len: uint, f: &fn()) { self.emit_seq(len, f) }\n+        fn emit_tuple_arg(&self, idx: uint, f: &fn()) { self.emit_seq_elt(idx, f) }\n+\n+        fn emit_tuple_struct(&self, _name: &str, len: uint, f: &fn()) { self.emit_seq(len, f) }\n+        fn emit_tuple_struct_arg(&self, idx: uint, f: &fn()) { self.emit_seq_elt(idx, f) }\n \n         fn emit_option(&self, f: &fn()) {\n             self.emit_enum(\"Option\", f);\n@@ -640,6 +697,17 @@ pub mod writer {\n             self.emit_enum_variant(\"Some\", 1, 1, f)\n         }\n \n+        fn emit_seq(&self, len: uint, f: &fn()) {\n+            do self.wr_tag(EsVec as uint) {\n+                self._emit_tagged_uint(EsVecLen, len);\n+                f()\n+            }\n+        }\n+\n+        fn emit_seq_elt(&self, _idx: uint, f: &fn()) {\n+            self.wr_tag(EsVecElt as uint, f)\n+        }\n+\n         fn emit_map(&self, _len: uint, _f: &fn()) {\n             fail!(~\"emit_map is unimplemented\");\n         }"}, {"sha": "f5cd8b4bd6830a1c1d1e0224118c28170e1999d4", "filename": "src/libstd/json.rs", "status": "modified", "additions": 154, "deletions": 43, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/2f8b36fc16178b298b23dfa199067ec2dd91df93/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8b36fc16178b298b23dfa199067ec2dd91df93/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=2f8b36fc16178b298b23dfa199067ec2dd91df93", "patch": "@@ -109,6 +109,7 @@ impl serialize::Encoder for Encoder {\n     fn emit_str(&self, v: &str) { self.wr.write_str(escape_str(v)) }\n \n     fn emit_enum(&self, _name: &str, f: &fn()) { f() }\n+\n     fn emit_enum_variant(&self, name: &str, _id: uint, cnt: uint, f: &fn()) {\n         // enums are encoded as strings or vectors:\n         // Bunny => \"Bunny\"\n@@ -126,37 +127,61 @@ impl serialize::Encoder for Encoder {\n     }\n \n     fn emit_enum_variant_arg(&self, idx: uint, f: &fn()) {\n-        if (idx != 0) {self.wr.write_char(',');}\n+        if idx != 0 {self.wr.write_char(',');}\n         f();\n     }\n \n-    fn emit_seq(&self, _len: uint, f: &fn()) {\n-        self.wr.write_char('[');\n-        f();\n-        self.wr.write_char(']');\n+    fn emit_enum_struct_variant(&self, name: &str, id: uint, cnt: uint, f: &fn()) {\n+        self.emit_enum_variant(name, id, cnt, f)\n     }\n \n-    fn emit_seq_elt(&self, idx: uint, f: &fn()) {\n-        if idx != 0 { self.wr.write_char(','); }\n-        f()\n+    fn emit_enum_struct_variant_field(&self, _field: &str, idx: uint, f: &fn()) {\n+        self.emit_enum_variant_arg(idx, f)\n     }\n \n     fn emit_struct(&self, _name: &str, _len: uint, f: &fn()) {\n         self.wr.write_char('{');\n         f();\n         self.wr.write_char('}');\n     }\n+    #[cfg(stage0)]\n     fn emit_field(&self, name: &str, idx: uint, f: &fn()) {\n         if idx != 0 { self.wr.write_char(','); }\n         self.wr.write_str(escape_str(name));\n         self.wr.write_char(':');\n         f();\n     }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn emit_struct_field(&self, name: &str, idx: uint, f: &fn()) {\n+        if idx != 0 { self.wr.write_char(','); }\n+        self.wr.write_str(escape_str(name));\n+        self.wr.write_char(':');\n+        f();\n+    }\n+\n+    fn emit_tuple(&self, len: uint, f: &fn()) { self.emit_seq(len, f) }\n+    fn emit_tuple_arg(&self, idx: uint, f: &fn()) { self.emit_seq_elt(idx, f) }\n+\n+    fn emit_tuple_struct(&self, _name: &str, len: uint, f: &fn()) { self.emit_seq(len, f) }\n+    fn emit_tuple_struct_arg(&self, idx: uint, f: &fn()) { self.emit_seq_elt(idx, f) }\n \n     fn emit_option(&self, f: &fn()) { f(); }\n     fn emit_option_none(&self) { self.emit_nil(); }\n     fn emit_option_some(&self, f: &fn()) { f(); }\n \n+    fn emit_seq(&self, _len: uint, f: &fn()) {\n+        self.wr.write_char('[');\n+        f();\n+        self.wr.write_char(']');\n+    }\n+\n+    fn emit_seq_elt(&self, idx: uint, f: &fn()) {\n+        if idx != 0 { self.wr.write_char(','); }\n+        f()\n+    }\n+\n     fn emit_map(&self, _len: uint, f: &fn()) {\n         self.wr.write_char('{');\n         f();\n@@ -216,6 +241,7 @@ impl serialize::Encoder for PrettyEncoder {\n     fn emit_str(&self, v: &str) { self.wr.write_str(escape_str(v)); }\n \n     fn emit_enum(&self, _name: &str, f: &fn()) { f() }\n+\n     fn emit_enum_variant(&self, name: &str, _id: uint, cnt: uint, f: &fn()) {\n         if cnt == 0 {\n             self.wr.write_str(escape_str(name));\n@@ -233,6 +259,7 @@ impl serialize::Encoder for PrettyEncoder {\n             self.wr.write_char(']');\n         }\n     }\n+\n     fn emit_enum_variant_arg(&self, idx: uint, f: &fn()) {\n         if idx != 0 {\n             self.wr.write_str(\",\\n\");\n@@ -241,58 +268,88 @@ impl serialize::Encoder for PrettyEncoder {\n         f()\n     }\n \n-    fn emit_seq(&self, len: uint, f: &fn()) {\n+    fn emit_enum_struct_variant(&self, name: &str, id: uint, cnt: uint, f: &fn()) {\n+        self.emit_enum_variant(name, id, cnt, f)\n+    }\n+\n+    fn emit_enum_struct_variant_field(&self, _field: &str, idx: uint, f: &fn()) {\n+        self.emit_enum_variant_arg(idx, f)\n+    }\n+\n+\n+    fn emit_struct(&self, _name: &str, len: uint, f: &fn()) {\n         if len == 0 {\n-            self.wr.write_str(\"[]\");\n+            self.wr.write_str(\"{}\");\n         } else {\n-            self.wr.write_char('[');\n+            self.wr.write_char('{');\n             self.indent += 2;\n             f();\n             self.wr.write_char('\\n');\n             self.indent -= 2;\n             self.wr.write_str(spaces(self.indent));\n-            self.wr.write_char(']');\n+            self.wr.write_char('}');\n         }\n     }\n-    fn emit_seq_elt(&self, idx: uint, f: &fn()) {\n+    #[cfg(stage0)]\n+    fn emit_field(&self, name: &str, idx: uint, f: &fn()) {\n         if idx == 0 {\n             self.wr.write_char('\\n');\n         } else {\n             self.wr.write_str(\",\\n\");\n         }\n         self.wr.write_str(spaces(self.indent));\n-        f()\n+        self.wr.write_str(escape_str(name));\n+        self.wr.write_str(\": \");\n+        f();\n+    }\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn emit_struct_field(&self, name: &str, idx: uint, f: &fn()) {\n+        if idx == 0 {\n+            self.wr.write_char('\\n');\n+        } else {\n+            self.wr.write_str(\",\\n\");\n+        }\n+        self.wr.write_str(spaces(self.indent));\n+        self.wr.write_str(escape_str(name));\n+        self.wr.write_str(\": \");\n+        f();\n     }\n \n-    fn emit_struct(&self, _name: &str, len: uint, f: &fn()) {\n+    fn emit_tuple(&self, len: uint, f: &fn()) { self.emit_seq(len, f) }\n+    fn emit_tuple_arg(&self, idx: uint, f: &fn()) { self.emit_seq_elt(idx, f) }\n+\n+    fn emit_tuple_struct(&self, _name: &str, len: uint, f: &fn()) { self.emit_seq(len, f) }\n+    fn emit_tuple_struct_arg(&self, idx: uint, f: &fn()) { self.emit_seq_elt(idx, f) }\n+\n+    fn emit_option(&self, f: &fn()) { f(); }\n+    fn emit_option_none(&self) { self.emit_nil(); }\n+    fn emit_option_some(&self, f: &fn()) { f(); }\n+\n+    fn emit_seq(&self, len: uint, f: &fn()) {\n         if len == 0 {\n-            self.wr.write_str(\"{}\");\n+            self.wr.write_str(\"[]\");\n         } else {\n-            self.wr.write_char('{');\n+            self.wr.write_char('[');\n             self.indent += 2;\n             f();\n             self.wr.write_char('\\n');\n             self.indent -= 2;\n             self.wr.write_str(spaces(self.indent));\n-            self.wr.write_char('}');\n+            self.wr.write_char(']');\n         }\n     }\n-    fn emit_field(&self, name: &str, idx: uint, f: &fn()) {\n+    fn emit_seq_elt(&self, idx: uint, f: &fn()) {\n         if idx == 0 {\n             self.wr.write_char('\\n');\n         } else {\n             self.wr.write_str(\",\\n\");\n         }\n         self.wr.write_str(spaces(self.indent));\n-        self.wr.write_str(escape_str(name));\n-        self.wr.write_str(\": \");\n-        f();\n+        f()\n     }\n \n-    fn emit_option(&self, f: &fn()) { f(); }\n-    fn emit_option_none(&self) { self.emit_nil(); }\n-    fn emit_option_some(&self, f: &fn()) { f(); }\n-\n     fn emit_map(&self, len: uint, f: &fn()) {\n         if len == 0 {\n             self.wr.write_str(\"{}\");\n@@ -827,24 +884,15 @@ impl serialize::Decoder for Decoder {\n         f()\n     }\n \n-    fn read_seq<T>(&self, f: &fn(uint) -> T) -> T {\n-        debug!(\"read_seq()\");\n-        let len = match self.stack.pop() {\n-            List(list) => {\n-                let len = list.len();\n-                do vec::consume_reverse(list) |_i, v| {\n-                    self.stack.push(v);\n-                }\n-                len\n-            }\n-            _ => fail!(~\"not a list\"),\n-        };\n-        f(len)\n+    fn read_enum_struct_variant<T>(&self, names: &[&str], f: &fn(uint) -> T) -> T {\n+        debug!(\"read_enum_struct_variant(names=%?)\", names);\n+        self.read_enum_variant(names, f)\n     }\n \n-    fn read_seq_elt<T>(&self, idx: uint, f: &fn() -> T) -> T {\n-        debug!(\"read_seq_elt(idx=%u)\", idx);\n-        f()\n+\n+    fn read_enum_struct_variant_field<T>(&self, name: &str, idx: uint, f: &fn() -> T) -> T {\n+        debug!(\"read_enum_struct_variant_field(name=%?, idx=%u)\", name, idx);\n+        self.read_enum_variant_arg(idx, f)\n     }\n \n     fn read_struct<T>(&self, name: &str, len: uint, f: &fn() -> T) -> T {\n@@ -854,8 +902,9 @@ impl serialize::Decoder for Decoder {\n         value\n     }\n \n+    #[cfg(stage0)]\n     fn read_field<T>(&self, name: &str, idx: uint, f: &fn() -> T) -> T {\n-        debug!(\"read_field(%s, idx=%u)\", name, idx);\n+        debug!(\"read_field(name=%?, idx=%u)\", name, idx);\n         match self.stack.pop() {\n             Object(obj) => {\n                 let mut obj = obj;\n@@ -873,13 +922,75 @@ impl serialize::Decoder for Decoder {\n         }\n     }\n \n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn read_struct_field<T>(&self, name: &str, idx: uint, f: &fn() -> T) -> T {\n+        debug!(\"read_struct_field(name=%?, idx=%u)\", name, idx);\n+        match self.stack.pop() {\n+            Object(obj) => {\n+                let mut obj = obj;\n+                let value = match obj.pop(&name.to_owned()) {\n+                    None => fail!(fmt!(\"no such field: %s\", name)),\n+                    Some(json) => {\n+                        self.stack.push(json);\n+                        f()\n+                    }\n+                };\n+                self.stack.push(Object(obj));\n+                value\n+            }\n+            value => fail!(fmt!(\"not an object: %?\", value))\n+        }\n+    }\n+\n+    fn read_tuple<T>(&self, f: &fn(uint) -> T) -> T {\n+        debug!(\"read_tuple()\");\n+        self.read_seq(f)\n+    }\n+\n+    fn read_tuple_arg<T>(&self, idx: uint, f: &fn() -> T) -> T {\n+        debug!(\"read_tuple_arg(idx=%u)\", idx);\n+        self.read_seq_elt(idx, f)\n+    }\n+\n+    fn read_tuple_struct<T>(&self, name: &str, f: &fn(uint) -> T) -> T {\n+        debug!(\"read_tuple_struct(name=%?)\", name);\n+        self.read_tuple(f)\n+    }\n+\n+    fn read_tuple_struct_arg<T>(&self, idx: uint, f: &fn() -> T) -> T {\n+        debug!(\"read_tuple_struct_arg(idx=%u)\", idx);\n+        self.read_tuple_arg(idx, f)\n+    }\n+\n     fn read_option<T>(&self, f: &fn(bool) -> T) -> T {\n         match self.stack.pop() {\n             Null => f(false),\n             value => { self.stack.push(value); f(true) }\n         }\n     }\n \n+    fn read_seq<T>(&self, f: &fn(uint) -> T) -> T {\n+        debug!(\"read_seq()\");\n+        let len = match self.stack.pop() {\n+            List(list) => {\n+                let len = list.len();\n+                do vec::consume_reverse(list) |_i, v| {\n+                    self.stack.push(v);\n+                }\n+                len\n+            }\n+            _ => fail!(~\"not a list\"),\n+        };\n+        f(len)\n+    }\n+\n+    fn read_seq_elt<T>(&self, idx: uint, f: &fn() -> T) -> T {\n+        debug!(\"read_seq_elt(idx=%u)\", idx);\n+        f()\n+    }\n+\n     fn read_map<T>(&self, f: &fn(uint) -> T) -> T {\n         debug!(\"read_map()\");\n         let len = match self.stack.pop() {"}, {"sha": "68ae9a6641726410abf5c2719c972b7ed2a706cd", "filename": "src/libstd/serialize.rs", "status": "modified", "additions": 40, "deletions": 11, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/2f8b36fc16178b298b23dfa199067ec2dd91df93/src%2Flibstd%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8b36fc16178b298b23dfa199067ec2dd91df93/src%2Flibstd%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialize.rs?ref=2f8b36fc16178b298b23dfa199067ec2dd91df93", "patch": "@@ -44,22 +44,36 @@ pub trait Encoder {\n     fn emit_str(&self, v: &str);\n \n     // Compound types:\n-\n     fn emit_enum(&self, name: &str, f: &fn());\n-    fn emit_enum_variant(&self, v_name: &str, v_id: uint, sz: uint, f: &fn());\n-    fn emit_enum_variant_arg(&self, idx: uint, f: &fn());\n \n-    fn emit_seq(&self, len: uint, f: &fn());\n-    fn emit_seq_elt(&self, idx: uint, f: &fn());\n+    fn emit_enum_variant(&self, v_name: &str, v_id: uint, len: uint, f: &fn());\n+    fn emit_enum_variant_arg(&self, a_idx: uint, f: &fn());\n \n-    fn emit_struct(&self, name: &str, _len: uint, f: &fn());\n+    fn emit_enum_struct_variant(&self, v_name: &str, v_id: uint, len: uint, f: &fn());\n+    fn emit_enum_struct_variant_field(&self, f_name: &str, f_idx: uint, f: &fn());\n+\n+    fn emit_struct(&self, name: &str, len: uint, f: &fn());\n+    #[cfg(stage0)]\n     fn emit_field(&self, f_name: &str, f_idx: uint, f: &fn());\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn emit_struct_field(&self, f_name: &str, f_idx: uint, f: &fn());\n+\n+    fn emit_tuple(&self, len: uint, f: &fn());\n+    fn emit_tuple_arg(&self, idx: uint, f: &fn());\n+\n+    fn emit_tuple_struct(&self, name: &str, len: uint, f: &fn());\n+    fn emit_tuple_struct_arg(&self, f_idx: uint, f: &fn());\n \n     // Specialized types:\n     fn emit_option(&self, f: &fn());\n     fn emit_option_none(&self);\n     fn emit_option_some(&self, f: &fn());\n \n+    fn emit_seq(&self, len: uint, f: &fn());\n+    fn emit_seq_elt(&self, idx: uint, f: &fn());\n+\n     fn emit_map(&self, len: uint, f: &fn());\n     fn emit_map_elt_key(&self, idx: uint, f: &fn());\n     fn emit_map_elt_val(&self, idx: uint, f: &fn());\n@@ -87,18 +101,33 @@ pub trait Decoder {\n \n     // Compound types:\n     fn read_enum<T>(&self, name: &str, f: &fn() -> T) -> T;\n+\n     fn read_enum_variant<T>(&self, names: &[&str], f: &fn(uint) -> T) -> T;\n-    fn read_enum_variant_arg<T>(&self, idx: uint, f: &fn() -> T) -> T;\n+    fn read_enum_variant_arg<T>(&self, a_idx: uint, f: &fn() -> T) -> T;\n \n-    fn read_seq<T>(&self, f: &fn(uint) -> T) -> T;\n-    fn read_seq_elt<T>(&self, idx: uint, f: &fn() -> T) -> T;\n+    fn read_enum_struct_variant<T>(&self, names: &[&str], f: &fn(uint) -> T) -> T;\n+    fn read_enum_struct_variant_field<T>(&self, &f_name: &str, f_idx: uint, f: &fn() -> T) -> T;\n+\n+    fn read_struct<T>(&self, s_name: &str, len: uint, f: &fn() -> T) -> T;\n+    #[cfg(stage0)]\n+    fn read_field<T>(&self, f_name: &str, f_idx: uint, f: &fn() -> T) -> T;\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn read_struct_field<T>(&self, f_name: &str, f_idx: uint, f: &fn() -> T) -> T;\n \n-    fn read_struct<T>(&self, name: &str, _len: uint, f: &fn() -> T) -> T;\n-    fn read_field<T>(&self, name: &str, idx: uint, f: &fn() -> T) -> T;\n+    fn read_tuple<T>(&self, f: &fn(uint) -> T) -> T;\n+    fn read_tuple_arg<T>(&self, a_idx: uint, f: &fn() -> T) -> T;\n+\n+    fn read_tuple_struct<T>(&self, s_name: &str, f: &fn(uint) -> T) -> T;\n+    fn read_tuple_struct_arg<T>(&self, a_idx: uint, f: &fn() -> T) -> T;\n \n     // Specialized types:\n     fn read_option<T>(&self, f: &fn(bool) -> T) -> T;\n \n+    fn read_seq<T>(&self, f: &fn(uint) -> T) -> T;\n+    fn read_seq_elt<T>(&self, idx: uint, f: &fn() -> T) -> T;\n+\n     fn read_map<T>(&self, f: &fn(uint) -> T) -> T;\n     fn read_map_elt_key<T>(&self, idx: uint, f: &fn() -> T) -> T;\n     fn read_map_elt_val<T>(&self, idx: uint, f: &fn() -> T) -> T;"}, {"sha": "e53a8f361b5fe47a4b909b1acb4b68342e01e124", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 31, "deletions": 9, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2f8b36fc16178b298b23dfa199067ec2dd91df93/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8b36fc16178b298b23dfa199067ec2dd91df93/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=2f8b36fc16178b298b23dfa199067ec2dd91df93", "patch": "@@ -732,12 +732,12 @@ fn mk_struct_ser_impl(\n             )\n         );\n \n-        // ast for `__s.emit_field($(name), $(idx), $(expr_lambda))`\n+        // ast for `__s.emit_struct_field($(name), $(idx), $(expr_lambda))`\n         cx.stmt(\n             cx.expr_method_call(\n                 span,\n                 cx.expr_var(span, ~\"__s\"),\n-                cx.ident_of(~\"emit_field\"),\n+                cx.ident_of(~\"emit_struct_field\"),\n                 ~[\n                     cx.lit_str(span, @cx.str_of(field.ident)),\n                     cx.lit_uint(span, idx),\n@@ -786,11 +786,11 @@ fn mk_struct_deser_impl(\n             )\n         );\n \n-        // ast for `__d.read_field($(name), $(idx), $(expr_lambda))`\n+        // ast for `__d.read_struct_field($(name), $(idx), $(expr_lambda))`\n         let expr: @ast::expr = cx.expr_method_call(\n             span,\n             cx.expr_var(span, ~\"__d\"),\n-            cx.ident_of(~\"read_field\"),\n+            cx.ident_of(~\"read_struct_field\"),\n             ~[\n                 cx.lit_str(span, @cx.str_of(field.ident)),\n                 cx.lit_uint(span, idx),\n@@ -1253,20 +1253,35 @@ mod test {\n             self.add_to_log(CallToEmitEnumVariantArg (idx)); f();\n         }\n \n-        fn emit_seq(&self, +_len: uint, f: &fn()) {\n-            self.add_unknown_to_log(); f();\n+        fn emit_enum_struct_variant(&self, name: &str, id: uint, cnt: uint, f: &fn()) {\n+            self.emit_enum_variant(name, id, cnt, f)\n         }\n-        fn emit_seq_elt(&self, +_idx: uint, f: &fn()) {\n-            self.add_unknown_to_log(); f();\n+\n+        fn emit_enum_struct_variant_field(&self, _name: &str, idx: uint, f: &fn()) {\n+            self.emit_enum_variant_arg(idx, f)\n         }\n \n         fn emit_struct(&self, name: &str, +len: uint, f: &fn()) {\n             self.add_to_log(CallToEmitStruct (name.to_str(),len)); f();\n         }\n-        fn emit_field(&self, name: &str, +idx: uint, f: &fn()) {\n+        fn emit_struct_field(&self, name: &str, +idx: uint, f: &fn()) {\n             self.add_to_log(CallToEmitField (name.to_str(),idx)); f();\n         }\n \n+        fn emit_tuple(&self, _len: uint, f: &fn()) {\n+            self.add_unknown_to_log(); f();\n+        }\n+        fn emit_tuple_arg(&self, _idx: uint, f: &fn()) {\n+            self.add_unknown_to_log(); f();\n+        }\n+\n+        fn emit_tuple_struct(&self, _name: &str, _len: uint, f: &fn()) {\n+            self.add_unknown_to_log(); f();\n+        }\n+        fn emit_tuple_struct_arg(&self, _idx: uint, f: &fn()) {\n+            self.add_unknown_to_log(); f();\n+        }\n+\n         fn emit_option(&self, f: &fn()) {\n             self.add_to_log(CallToEmitOption);\n             f();\n@@ -1279,6 +1294,13 @@ mod test {\n             f();\n         }\n \n+        fn emit_seq(&self, +_len: uint, f: &fn()) {\n+            self.add_unknown_to_log(); f();\n+        }\n+        fn emit_seq_elt(&self, +_idx: uint, f: &fn()) {\n+            self.add_unknown_to_log(); f();\n+        }\n+\n         fn emit_map(&self, _len: uint, f: &fn()) {\n             self.add_unknown_to_log(); f();\n         }"}, {"sha": "b375adef9263d32bef39ad166d094526f45e4362", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 113, "deletions": 11, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/2f8b36fc16178b298b23dfa199067ec2dd91df93/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8b36fc16178b298b23dfa199067ec2dd91df93/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=2f8b36fc16178b298b23dfa199067ec2dd91df93", "patch": "@@ -64,12 +64,7 @@ pub fn mk_unary(cx: @ext_ctxt, sp: span, op: ast::unop, e: @ast::expr)\n     mk_expr(cx, sp, ast::expr_unary(op, e))\n }\n pub fn mk_raw_path(sp: span, +idents: ~[ast::ident]) -> @ast::Path {\n-    let p = @ast::Path { span: sp,\n-                         global: false,\n-                         idents: idents,\n-                         rp: None,\n-                         types: ~[] };\n-    return p;\n+    mk_raw_path_(sp, idents, ~[])\n }\n pub fn mk_raw_path_(sp: span,\n                     +idents: ~[ast::ident],\n@@ -82,11 +77,16 @@ pub fn mk_raw_path_(sp: span,\n                  types: types }\n }\n pub fn mk_raw_path_global(sp: span, +idents: ~[ast::ident]) -> @ast::Path {\n+    mk_raw_path_global_(sp, idents, ~[])\n+}\n+pub fn mk_raw_path_global_(sp: span,\n+                           +idents: ~[ast::ident],\n+                           +types: ~[@ast::Ty]) -> @ast::Path {\n     @ast::Path { span: sp,\n                  global: true,\n                  idents: idents,\n                  rp: None,\n-                 types: ~[] }\n+                 types: types }\n }\n pub fn mk_path(cx: @ext_ctxt, sp: span, +idents: ~[ast::ident])\n             -> @ast::expr {\n@@ -271,6 +271,36 @@ pub fn mk_simple_block(cx: @ext_ctxt,\n         span: span,\n     }\n }\n+pub fn mk_lambda_(cx: @ext_ctxt,\n+                 span: span,\n+                 fn_decl: ast::fn_decl,\n+                 blk: ast::blk)\n+              -> @ast::expr {\n+    mk_expr(cx, span, ast::expr_fn_block(fn_decl, blk))\n+}\n+pub fn mk_lambda(cx: @ext_ctxt,\n+                 span: span,\n+                 fn_decl: ast::fn_decl,\n+                 expr: @ast::expr)\n+              -> @ast::expr {\n+    let blk = mk_simple_block(cx, span, expr);\n+    mk_lambda_(cx, span, fn_decl, blk)\n+}\n+pub fn mk_lambda_stmts(cx: @ext_ctxt,\n+                       span: span,\n+                       fn_decl: ast::fn_decl,\n+                       stmts: ~[@ast::stmt])\n+                    -> @ast::expr {\n+    let blk = mk_block(cx, span, ~[], stmts, None);\n+    mk_lambda(cx, span, fn_decl, blk)\n+}\n+pub fn mk_lambda_no_args(cx: @ext_ctxt,\n+                         span: span,\n+                         expr: @ast::expr)\n+                      -> @ast::expr {\n+    let fn_decl = mk_fn_decl(~[], mk_ty_infer(cx, span));\n+    mk_lambda(cx, span, fn_decl, expr)\n+}\n pub fn mk_copy(cx: @ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n     mk_expr(cx, sp, ast::expr_copy(e))\n }\n@@ -280,11 +310,20 @@ pub fn mk_managed(cx: @ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n pub fn mk_pat(cx: @ext_ctxt, span: span, +pat: ast::pat_) -> @ast::pat {\n     @ast::pat { id: cx.next_id(), node: pat, span: span }\n }\n+pub fn mk_pat_wild(cx: @ext_ctxt, span: span) -> @ast::pat {\n+    mk_pat(cx, span, ast::pat_wild)\n+}\n+pub fn mk_pat_lit(cx: @ext_ctxt,\n+                  span: span,\n+                  expr: @ast::expr) -> @ast::pat {\n+    mk_pat(cx, span, ast::pat_lit(expr))\n+}\n pub fn mk_pat_ident(cx: @ext_ctxt,\n                     span: span,\n                     ident: ast::ident) -> @ast::pat {\n     mk_pat_ident_with_binding_mode(cx, span, ident, ast::bind_by_copy)\n }\n+\n pub fn mk_pat_ident_with_binding_mode(cx: @ext_ctxt,\n                                       span: span,\n                                       ident: ast::ident,\n@@ -337,12 +376,35 @@ pub fn mk_ty_path_global(cx: @ext_ctxt,\n     let ty = @ast::Ty { id: cx.next_id(), node: ty, span: span };\n     ty\n }\n+pub fn mk_ty_rptr(cx: @ext_ctxt,\n+                  span: span,\n+                  ty: @ast::Ty,\n+                  mutbl: ast::mutability)\n+               -> @ast::Ty {\n+    @ast::Ty {\n+        id: cx.next_id(),\n+        span: span,\n+        node: ast::ty_rptr(\n+            None,\n+            ast::mt { ty: ty, mutbl: mutbl }\n+        ),\n+    }\n+}\n+pub fn mk_ty_infer(cx: @ext_ctxt, span: span) -> @ast::Ty {\n+    @ast::Ty {\n+        id: cx.next_id(),\n+        node: ast::ty_infer,\n+        span: span,\n+    }\n+}\n pub fn mk_trait_ref_global(cx: @ext_ctxt,\n                            span: span,\n                            +idents: ~[ ast::ident ])\n     -> @ast::trait_ref\n {\n-    let path = build::mk_raw_path_global(span, idents);\n+    mk_trait_ref_(cx, build::mk_raw_path_global(span, idents))\n+}\n+pub fn mk_trait_ref_(cx: @ext_ctxt, path: @ast::Path) -> @ast::trait_ref {\n     @ast::trait_ref {\n         path: path,\n         ref_id: cx.next_id()\n@@ -371,6 +433,16 @@ pub fn mk_arg(cx: @ext_ctxt,\n pub fn mk_fn_decl(+inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl {\n     ast::fn_decl { inputs: inputs, output: output, cf: ast::return_val }\n }\n+pub fn mk_trait_ty_param_bound_global(cx: @ext_ctxt,\n+                                      span: span,\n+                                      +idents: ~[ast::ident])\n+                                   -> ast::TyParamBound {\n+    ast::TraitTyParamBound(mk_trait_ref_global(cx, span, idents))\n+}\n+pub fn mk_trait_ty_param_bound_(cx: @ext_ctxt,\n+                                path: @ast::Path) -> ast::TyParamBound {\n+    ast::TraitTyParamBound(mk_trait_ref_(cx, path))\n+}\n pub fn mk_ty_param(cx: @ext_ctxt,\n                    ident: ast::ident,\n                    bounds: @OptVec<ast::TyParamBound>)\n@@ -379,8 +451,38 @@ pub fn mk_ty_param(cx: @ext_ctxt,\n }\n pub fn mk_lifetime(cx: @ext_ctxt,\n                    span: span,\n-                   ident: ast::ident) -> ast::Lifetime\n-{\n+                   ident: ast::ident)\n+                -> ast::Lifetime {\n     ast::Lifetime { id: cx.next_id(), span: span, ident: ident }\n }\n-\n+pub fn mk_arm(cx: @ext_ctxt,\n+              span: span,\n+              pats: ~[@ast::pat],\n+              expr: @ast::expr)\n+           -> ast::arm {\n+    ast::arm {\n+        pats: pats,\n+        guard: None,\n+        body: mk_simple_block(cx, span, expr)\n+    }\n+}\n+pub fn mk_unreachable(cx: @ext_ctxt, span: span) -> @ast::expr {\n+    let loc = cx.codemap().lookup_char_pos(span.lo);\n+    mk_call_global(\n+        cx,\n+        span,\n+        ~[\n+            cx.ident_of(~\"core\"),\n+            cx.ident_of(~\"sys\"),\n+            cx.ident_of(~\"begin_unwind\"),\n+        ],\n+        ~[\n+            mk_uniq_str(cx, span, ~\"internal error: entered unreachable code\"),\n+            mk_uniq_str(cx, span, loc.file.name),\n+            mk_uint(cx, span, loc.line),\n+        ]\n+    )\n+}\n+pub fn mk_unreachable_arm(cx: @ext_ctxt, span: span) -> ast::arm {\n+    mk_arm(cx, span, ~[mk_pat_wild(cx, span)], mk_unreachable(cx, span))\n+}"}, {"sha": "c8ba6b990e47a6426cbfaaaa4c402c7cc72d8436", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2f8b36fc16178b298b23dfa199067ec2dd91df93/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8b36fc16178b298b23dfa199067ec2dd91df93/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=2f8b36fc16178b298b23dfa199067ec2dd91df93", "patch": "@@ -17,6 +17,7 @@ use ext::build;\n use ext::deriving::*;\n use codemap::{span, spanned};\n use ast_util;\n+use opt_vec;\n \n use core::uint;\n \n@@ -48,12 +49,13 @@ fn create_derived_clone_impl(cx: @ext_ctxt,\n                              method: @method)\n                           -> @item {\n     let methods = [ method ];\n-    let trait_path = [\n+    let trait_path = ~[\n         cx.ident_of(~\"core\"),\n         cx.ident_of(~\"clone\"),\n         cx.ident_of(~\"Clone\"),\n     ];\n-    create_derived_impl(cx, span, type_ident, generics, methods, trait_path)\n+    let trait_path = build::mk_raw_path_global(span, trait_path);\n+    create_derived_impl(cx, span, type_ident, generics, methods, trait_path, opt_vec::Empty)\n }\n // Creates a method from the given expression conforming to the signature of\n // the `clone` method.\n@@ -188,9 +190,7 @@ fn expand_deriving_clone_struct_method(cx: @ext_ctxt,\n                 fields.push(field);\n             }\n             unnamed_field => {\n-                cx.span_bug(span,\n-                            ~\"unnamed fields in \\\n-                              expand_deriving_clone_struct_method\");\n+                cx.span_bug(span, ~\"unnamed fields in `deriving(Clone)`\");\n             }\n         }\n     }"}, {"sha": "11f492316e281768bf9f37024d2779c3807950e9", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "added", "additions": 454, "deletions": 0, "changes": 454, "blob_url": "https://github.com/rust-lang/rust/blob/2f8b36fc16178b298b23dfa199067ec2dd91df93/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8b36fc16178b298b23dfa199067ec2dd91df93/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=2f8b36fc16178b298b23dfa199067ec2dd91df93", "patch": "@@ -0,0 +1,454 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::prelude::*;\n+\n+use ast;\n+use ast::*;\n+use ext::base::ext_ctxt;\n+use ext::build;\n+use ext::deriving::*;\n+use codemap::{span, spanned};\n+use ast_util;\n+use opt_vec;\n+\n+use core::uint;\n+\n+pub fn expand_deriving_decodable(\n+    cx: @ext_ctxt,\n+    span: span,\n+    _mitem: @meta_item,\n+    in_items: ~[@item]\n+) -> ~[@item] {\n+    expand_deriving(\n+        cx,\n+        span,\n+        in_items,\n+        expand_deriving_decodable_struct_def,\n+        expand_deriving_decodable_enum_def\n+    )\n+}\n+\n+fn create_derived_decodable_impl(\n+    cx: @ext_ctxt,\n+    span: span,\n+    type_ident: ident,\n+    generics: &Generics,\n+    method: @method\n+) -> @item {\n+    let decoder_ty_param = build::mk_ty_param(\n+        cx,\n+        cx.ident_of(~\"__D\"),\n+        @opt_vec::with(\n+            build::mk_trait_ty_param_bound_global(\n+                cx,\n+                span,\n+                ~[\n+                    cx.ident_of(~\"std\"),\n+                    cx.ident_of(~\"serialize\"),\n+                    cx.ident_of(~\"Decoder\"),\n+                ]\n+            )\n+        )\n+    );\n+\n+    // All the type parameters need to bound to the trait.\n+    let generic_ty_params = opt_vec::with(decoder_ty_param);\n+\n+    let methods = [method];\n+    let trait_path = build::mk_raw_path_global_(\n+        span,\n+        ~[\n+            cx.ident_of(~\"std\"),\n+            cx.ident_of(~\"serialize\"),\n+            cx.ident_of(~\"Decodable\")\n+        ],\n+        ~[\n+            build::mk_simple_ty_path(cx, span, cx.ident_of(~\"__D\"))\n+        ]\n+    );\n+    create_derived_impl(\n+        cx,\n+        span,\n+        type_ident,\n+        generics,\n+        methods,\n+        trait_path,\n+        generic_ty_params\n+    )\n+}\n+\n+// Creates a method from the given set of statements conforming to the\n+// signature of the `decodable` method.\n+fn create_decode_method(\n+    cx: @ext_ctxt,\n+    span: span,\n+    type_ident: ast::ident,\n+    generics: &Generics,\n+    expr: @ast::expr\n+) -> @method {\n+    // Create the `e` parameter.\n+    let d_arg_type = build::mk_ty_rptr(\n+        cx,\n+        span,\n+        build::mk_simple_ty_path(cx, span, cx.ident_of(~\"__D\")),\n+        ast::m_imm\n+    );\n+    let d_ident = cx.ident_of(~\"__d\");\n+    let d_arg = build::mk_arg(cx, span, d_ident, d_arg_type);\n+\n+    // Create the type of the return value.\n+    let output_type = create_self_type_with_params(\n+        cx,\n+        span,\n+        type_ident,\n+        generics\n+    );\n+\n+    // Create the function declaration.\n+    let inputs = ~[d_arg];\n+    let fn_decl = build::mk_fn_decl(inputs, output_type);\n+\n+    // Create the body block.\n+    let body_block = build::mk_simple_block(cx, span, expr);\n+\n+    // Create the method.\n+    let self_ty = spanned { node: sty_static, span: span };\n+    let method_ident = cx.ident_of(~\"decode\");\n+    @ast::method {\n+        ident: method_ident,\n+        attrs: ~[],\n+        generics: ast_util::empty_generics(),\n+        self_ty: self_ty,\n+        purity: impure_fn,\n+        decl: fn_decl,\n+        body: body_block,\n+        id: cx.next_id(),\n+        span: span,\n+        self_id: cx.next_id(),\n+        vis: public\n+    }\n+}\n+\n+fn call_substructure_decode_method(\n+    cx: @ext_ctxt,\n+    span: span\n+) -> @ast::expr {\n+    // Call the substructure method.\n+    build::mk_call_(\n+        cx,\n+        span,\n+        build::mk_path_global(\n+            cx,\n+            span,\n+            ~[\n+                cx.ident_of(~\"std\"),\n+                cx.ident_of(~\"serialize\"),\n+                cx.ident_of(~\"Decodable\"),\n+                cx.ident_of(~\"decode\"),\n+            ]\n+        ),\n+        ~[\n+            build::mk_path(cx, span, ~[cx.ident_of(~\"__d\")])\n+        ]\n+    )\n+}\n+\n+fn expand_deriving_decodable_struct_def(\n+    cx: @ext_ctxt,\n+    span: span,\n+    struct_def: &struct_def,\n+    type_ident: ident,\n+    generics: &Generics\n+) -> @item {\n+    // Create the method.\n+    let method = expand_deriving_decodable_struct_method(\n+        cx,\n+        span,\n+        struct_def,\n+        type_ident,\n+        generics\n+    );\n+\n+    // Create the implementation.\n+    create_derived_decodable_impl(\n+        cx,\n+        span,\n+        type_ident,\n+        generics,\n+        method\n+    )\n+}\n+\n+fn expand_deriving_decodable_enum_def(\n+    cx: @ext_ctxt,\n+    span: span,\n+    enum_definition: &enum_def,\n+    type_ident: ident,\n+    generics: &Generics\n+) -> @item {\n+    // Create the method.\n+    let method = expand_deriving_decodable_enum_method(\n+        cx,\n+        span,\n+        enum_definition,\n+        type_ident,\n+        generics\n+    );\n+\n+    // Create the implementation.\n+    create_derived_decodable_impl(\n+        cx,\n+        span,\n+        type_ident,\n+        generics,\n+        method\n+    )\n+}\n+\n+fn create_read_struct_field(\n+    cx: @ext_ctxt,\n+    span: span,\n+    idx: uint,\n+    ident: ident\n+) -> build::Field {\n+    // Call the substructure method.\n+    let decode_expr = call_substructure_decode_method(cx, span);\n+\n+    let call_expr = build::mk_method_call(\n+        cx,\n+        span,\n+        build::mk_path(cx, span, ~[cx.ident_of(~\"__d\")]),\n+        cx.ident_of(~\"read_struct_field\"),\n+        ~[\n+            build::mk_base_str(cx, span, cx.str_of(ident)),\n+            build::mk_uint(cx, span, idx),\n+            build::mk_lambda_no_args(cx, span, decode_expr),\n+        ]\n+    );\n+\n+    build::Field { ident: ident, ex: call_expr }\n+}\n+\n+fn create_read_struct_arg(\n+    cx: @ext_ctxt,\n+    span: span,\n+    idx: uint,\n+    ident: ident\n+) -> build::Field {\n+    // Call the substructure method.\n+    let decode_expr = call_substructure_decode_method(cx, span);\n+\n+    let call_expr = build::mk_method_call(\n+        cx,\n+        span,\n+        build::mk_path(cx, span, ~[cx.ident_of(~\"__d\")]),\n+        cx.ident_of(~\"read_struct_arg\"),\n+        ~[\n+            build::mk_uint(cx, span, idx),\n+            build::mk_lambda_no_args(cx, span, decode_expr),\n+        ]\n+    );\n+\n+    build::Field { ident: ident, ex: call_expr }\n+}\n+\n+fn expand_deriving_decodable_struct_method(\n+    cx: @ext_ctxt,\n+    span: span,\n+    struct_def: &struct_def,\n+    type_ident: ident,\n+    generics: &Generics\n+) -> @method {\n+    // Create the body of the method.\n+    let mut i = 0;\n+    let mut fields = ~[];\n+    for struct_def.fields.each |struct_field| {\n+        match struct_field.node.kind {\n+            named_field(ident, _, _) => {\n+                fields.push(create_read_struct_field(cx, span, i, ident));\n+            }\n+            unnamed_field => {\n+                cx.span_unimpl(\n+                    span,\n+                    ~\"unnamed fields with `deriving(Decodable)`\"\n+                );\n+            }\n+        }\n+        i += 1;\n+    }\n+\n+    let read_struct_expr = build::mk_method_call(\n+        cx,\n+        span,\n+        build::mk_path(\n+            cx,\n+            span,\n+            ~[cx.ident_of(~\"__d\")]\n+        ),\n+        cx.ident_of(~\"read_struct\"),\n+        ~[\n+            build::mk_base_str(cx, span, cx.str_of(type_ident)),\n+            build::mk_uint(cx, span, fields.len()),\n+            build::mk_lambda_no_args(\n+                cx,\n+                span,\n+                build::mk_struct_e(\n+                    cx,\n+                    span,\n+                    ~[type_ident],\n+                    fields\n+                )\n+            ),\n+        ]\n+    );\n+\n+    // Create the method itself.\n+    create_decode_method(cx, span, type_ident, generics, read_struct_expr)\n+}\n+\n+fn create_read_variant_arg(\n+    cx: @ext_ctxt,\n+    span: span,\n+    idx: uint,\n+    variant: &ast::variant\n+) -> ast::arm {\n+    // Create the matching pattern.\n+    let pat = build::mk_pat_lit(cx, span, build::mk_uint(cx, span, idx));\n+\n+    // Feed each argument in this variant to the decode function\n+    // as well.\n+    let variant_arg_len = variant_arg_count(cx, span, variant);\n+\n+    let expr = if variant_arg_len == 0 {\n+        build::mk_path(cx, span, ~[variant.node.name])\n+    } else {\n+        // Feed the discriminant to the decode function.\n+        let mut args = ~[];\n+\n+        for uint::range(0, variant_arg_len) |j| {\n+            // Call the substructure method.\n+            let expr = call_substructure_decode_method(cx, span);\n+\n+            let call_expr = build::mk_method_call(\n+                cx,\n+                span,\n+                build::mk_path(cx, span, ~[cx.ident_of(~\"__d\")]),\n+                cx.ident_of(~\"read_enum_variant_arg\"),\n+                ~[\n+                    build::mk_uint(cx, span, j),\n+                    build::mk_lambda_no_args(cx, span, expr),\n+                ]\n+            );\n+\n+            args.push(call_expr);\n+        }\n+\n+        build::mk_call(\n+            cx,\n+            span,\n+            ~[variant.node.name],\n+            args\n+        )\n+    };\n+\n+    // Create the arm.\n+    build::mk_arm(cx, span, ~[pat], expr)\n+}\n+\n+fn create_read_enum_variant(\n+    cx: @ext_ctxt,\n+    span: span,\n+    enum_definition: &enum_def\n+) -> @expr {\n+    // Create a vector that contains all the variant names.\n+    let expr_arm_names = build::mk_base_vec_e(\n+        cx,\n+        span,\n+        do enum_definition.variants.map |variant| {\n+            build::mk_base_str(\n+                cx,\n+                span,\n+                cx.str_of(variant.node.name)\n+            )\n+        }\n+    );\n+\n+    // Create the arms of the match in the method body.\n+    let mut arms = do enum_definition.variants.mapi |i, variant| {\n+        create_read_variant_arg(cx, span, i, variant)\n+    };\n+\n+    // Add the impossible case arm.\n+    arms.push(build::mk_unreachable_arm(cx, span));\n+\n+    // Create the read_enum_variant expression.\n+    build::mk_method_call(\n+        cx,\n+        span,\n+        build::mk_path(cx, span, ~[cx.ident_of(~\"__d\")]),\n+        cx.ident_of(~\"read_enum_variant\"),\n+        ~[\n+            expr_arm_names,\n+            build::mk_lambda(\n+                cx,\n+                span,\n+                build::mk_fn_decl(\n+                    ~[\n+                        build::mk_arg(\n+                            cx,\n+                            span,\n+                            cx.ident_of(~\"__i\"),\n+                            build::mk_ty_infer(cx, span)\n+                        )\n+                    ],\n+                    build::mk_ty_infer(cx, span)\n+                ),\n+                build::mk_expr(\n+                    cx,\n+                    span,\n+                    ast::expr_match(\n+                        build::mk_path(cx, span, ~[cx.ident_of(~\"__i\")]),\n+                        arms\n+                    )\n+                )\n+            )\n+        ]\n+    )\n+}\n+\n+fn expand_deriving_decodable_enum_method(\n+    cx: @ext_ctxt,\n+    span: span,\n+    enum_definition: &enum_def,\n+    type_ident: ast::ident,\n+    generics: &Generics\n+) -> @method {\n+    let read_enum_variant_expr = create_read_enum_variant(\n+        cx,\n+        span,\n+        enum_definition\n+    );\n+\n+    // Create the read_enum expression\n+    let read_enum_expr = build::mk_method_call(\n+        cx,\n+        span,\n+        build::mk_path(cx, span, ~[cx.ident_of(~\"__d\")]),\n+        cx.ident_of(~\"read_enum\"),\n+        ~[\n+            build::mk_base_str(cx, span, cx.str_of(type_ident)),\n+            build::mk_lambda_no_args(cx, span, read_enum_variant_expr),\n+        ]\n+    );\n+\n+    // Create the method.\n+    create_decode_method(cx, span, type_ident, generics, read_enum_expr)\n+}"}, {"sha": "81bfb03724f30a251c6e5e1983a30d5f63ab48fc", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "added", "additions": 388, "deletions": 0, "changes": 388, "blob_url": "https://github.com/rust-lang/rust/blob/2f8b36fc16178b298b23dfa199067ec2dd91df93/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8b36fc16178b298b23dfa199067ec2dd91df93/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=2f8b36fc16178b298b23dfa199067ec2dd91df93", "patch": "@@ -0,0 +1,388 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::prelude::*;\n+\n+use ast;\n+use ast::*;\n+use ext::base::ext_ctxt;\n+use ext::build;\n+use ext::deriving::*;\n+use codemap::{span, spanned};\n+use ast_util;\n+use opt_vec;\n+\n+use core::uint;\n+\n+pub fn expand_deriving_encodable(\n+    cx: @ext_ctxt,\n+    span: span,\n+    _mitem: @meta_item,\n+    in_items: ~[@item]\n+) -> ~[@item] {\n+    expand_deriving(\n+        cx,\n+        span,\n+        in_items,\n+        expand_deriving_encodable_struct_def,\n+        expand_deriving_encodable_enum_def\n+    )\n+}\n+\n+fn create_derived_encodable_impl(\n+    cx: @ext_ctxt,\n+    span: span,\n+    type_ident: ident,\n+    generics: &Generics,\n+    method: @method\n+) -> @item {\n+    let encoder_ty_param = build::mk_ty_param(\n+        cx,\n+        cx.ident_of(~\"__E\"),\n+        @opt_vec::with(\n+            build::mk_trait_ty_param_bound_global(\n+                cx,\n+                span,\n+                ~[\n+                    cx.ident_of(~\"std\"),\n+                    cx.ident_of(~\"serialize\"),\n+                    cx.ident_of(~\"Encoder\"),\n+                ]\n+            )\n+        )\n+    );\n+\n+    // All the type parameters need to bound to the trait.\n+    let generic_ty_params = opt_vec::with(encoder_ty_param);\n+\n+    let methods = [method];\n+    let trait_path = build::mk_raw_path_global_(\n+        span,\n+        ~[\n+            cx.ident_of(~\"std\"),\n+            cx.ident_of(~\"serialize\"),\n+            cx.ident_of(~\"Encodable\")\n+        ],\n+        ~[\n+            build::mk_simple_ty_path(cx, span, cx.ident_of(~\"__E\"))\n+        ]\n+    );\n+    create_derived_impl(\n+        cx,\n+        span,\n+        type_ident,\n+        generics,\n+        methods,\n+        trait_path,\n+        generic_ty_params\n+    )\n+}\n+\n+// Creates a method from the given set of statements conforming to the\n+// signature of the `encodable` method.\n+fn create_encode_method(\n+    cx: @ext_ctxt,\n+    span: span,\n+    +statements: ~[@stmt]\n+) -> @method {\n+    // Create the `e` parameter.\n+    let e_arg_type = build::mk_ty_rptr(\n+        cx,\n+        span,\n+        build::mk_simple_ty_path(cx, span, cx.ident_of(~\"__E\")),\n+        ast::m_imm\n+    );\n+    let e_ident = cx.ident_of(~\"__e\");\n+    let e_arg = build::mk_arg(cx, span, e_ident, e_arg_type);\n+\n+    // Create the type of the return value.\n+    let output_type = @ast::Ty { id: cx.next_id(), node: ty_nil, span: span };\n+\n+    // Create the function declaration.\n+    let inputs = ~[e_arg];\n+    let fn_decl = build::mk_fn_decl(inputs, output_type);\n+\n+    // Create the body block.\n+    let body_block = build::mk_block_(cx, span, statements);\n+\n+    // Create the method.\n+    let self_ty = spanned { node: sty_region(None, m_imm), span: span };\n+    let method_ident = cx.ident_of(~\"encode\");\n+    @ast::method {\n+        ident: method_ident,\n+        attrs: ~[],\n+        generics: ast_util::empty_generics(),\n+        self_ty: self_ty,\n+        purity: impure_fn,\n+        decl: fn_decl,\n+        body: body_block,\n+        id: cx.next_id(),\n+        span: span,\n+        self_id: cx.next_id(),\n+        vis: public\n+    }\n+}\n+\n+fn call_substructure_encode_method(\n+    cx: @ext_ctxt,\n+    span: span,\n+    self_field: @expr\n+) -> @ast::expr {\n+    // Gather up the parameters we want to chain along.\n+    let e_ident = cx.ident_of(~\"__e\");\n+    let e_expr = build::mk_path(cx, span, ~[e_ident]);\n+\n+    // Call the substructure method.\n+    let encode_ident = cx.ident_of(~\"encode\");\n+    build::mk_method_call(\n+        cx,\n+        span,\n+        self_field,\n+        encode_ident,\n+        ~[e_expr]\n+    )\n+}\n+\n+fn expand_deriving_encodable_struct_def(\n+    cx: @ext_ctxt,\n+    span: span,\n+    struct_def: &struct_def,\n+    type_ident: ident,\n+    generics: &Generics\n+) -> @item {\n+    // Create the method.\n+    let method = expand_deriving_encodable_struct_method(\n+        cx,\n+        span,\n+        type_ident,\n+        struct_def\n+    );\n+\n+    // Create the implementation.\n+    create_derived_encodable_impl(\n+        cx,\n+        span,\n+        type_ident,\n+        generics,\n+        method\n+    )\n+}\n+\n+fn expand_deriving_encodable_enum_def(\n+    cx: @ext_ctxt,\n+    span: span,\n+    enum_definition: &enum_def,\n+    type_ident: ident,\n+    generics: &Generics\n+) -> @item {\n+    // Create the method.\n+    let method = expand_deriving_encodable_enum_method(\n+        cx,\n+        span,\n+        type_ident,\n+        enum_definition\n+    );\n+\n+    // Create the implementation.\n+    create_derived_encodable_impl(\n+        cx,\n+        span,\n+        type_ident,\n+        generics,\n+        method\n+    )\n+}\n+\n+fn expand_deriving_encodable_struct_method(\n+    cx: @ext_ctxt,\n+    span: span,\n+    type_ident: ident,\n+    struct_def: &struct_def\n+) -> @method {\n+    let self_ident = cx.ident_of(~\"self\");\n+\n+    // Create the body of the method.\n+    let mut idx = 0;\n+    let mut statements = ~[];\n+    for struct_def.fields.each |struct_field| {\n+        match struct_field.node.kind {\n+            named_field(ident, _, _) => {\n+                // Create the accessor for this field.\n+                let self_field = build::mk_access(\n+                    cx,\n+                    span,\n+                    ~[self_ident],\n+                    ident\n+                );\n+\n+                // Call the substructure method.\n+                let encode_expr = call_substructure_encode_method(\n+                    cx,\n+                    span,\n+                    self_field\n+                );\n+\n+                let blk_expr = build::mk_lambda(\n+                    cx,\n+                    span,\n+                    build::mk_fn_decl(~[], build::mk_ty_infer(cx, span)),\n+                    encode_expr\n+                );\n+\n+                let call_expr = build::mk_method_call(\n+                    cx,\n+                    span,\n+                    build::mk_path(cx, span, ~[cx.ident_of(~\"__e\")]),\n+                    cx.ident_of(~\"emit_struct_field\"),\n+                    ~[\n+                        build::mk_base_str(cx, span, cx.str_of(ident)),\n+                        build::mk_uint(cx, span, idx),\n+                        blk_expr\n+                    ]\n+                );\n+\n+                statements.push(build::mk_stmt(cx, span, call_expr));\n+            }\n+            unnamed_field => {\n+                cx.span_unimpl(\n+                    span,\n+                    ~\"unnamed fields with `deriving(Encodable)`\"\n+                );\n+            }\n+        }\n+        idx += 1;\n+    }\n+\n+    let emit_struct_stmt = build::mk_method_call(\n+        cx,\n+        span,\n+        build::mk_path(\n+            cx,\n+            span,\n+            ~[cx.ident_of(~\"__e\")]\n+        ),\n+        cx.ident_of(~\"emit_struct\"),\n+        ~[\n+            build::mk_base_str(cx, span, cx.str_of(type_ident)),\n+            build::mk_uint(cx, span, statements.len()),\n+            build::mk_lambda_stmts(\n+                cx,\n+                span,\n+                build::mk_fn_decl(~[], build::mk_ty_infer(cx, span)),\n+                statements\n+            ),\n+        ]\n+    );\n+\n+    let statements = ~[build::mk_stmt(cx, span, emit_struct_stmt)];\n+\n+    // Create the method itself.\n+    return create_encode_method(cx, span, statements);\n+}\n+\n+fn expand_deriving_encodable_enum_method(\n+    cx: @ext_ctxt,\n+    span: span,\n+    type_ident: ast::ident,\n+    enum_definition: &enum_def\n+) -> @method {\n+    // Create the arms of the match in the method body.\n+    let arms = do enum_definition.variants.mapi |i, variant| {\n+        // Create the matching pattern.\n+        let pat = create_enum_variant_pattern(cx, span, variant, ~\"__self\");\n+\n+        // Feed the discriminant to the encode function.\n+        let mut stmts = ~[];\n+\n+        // Feed each argument in this variant to the encode function\n+        // as well.\n+        let variant_arg_len = variant_arg_count(cx, span, variant);\n+        for uint::range(0, variant_arg_len) |j| {\n+            // Create the expression for this field.\n+            let field_ident = cx.ident_of(~\"__self\" + j.to_str());\n+            let field = build::mk_path(cx, span, ~[ field_ident ]);\n+\n+            // Call the substructure method.\n+            let expr = call_substructure_encode_method(cx, span, field);\n+\n+            let blk_expr = build::mk_lambda(\n+                cx,\n+                span,\n+                build::mk_fn_decl(~[], build::mk_ty_infer(cx, span)),\n+                expr\n+            );\n+\n+            let call_expr = build::mk_method_call(\n+                cx,\n+                span,\n+                build::mk_path(cx, span, ~[cx.ident_of(~\"__e\")]),\n+                cx.ident_of(~\"emit_enum_variant_arg\"),\n+                ~[\n+                    build::mk_uint(cx, span, j),\n+                    blk_expr,\n+                ]\n+            );\n+\n+            stmts.push(build::mk_stmt(cx, span, call_expr));\n+        }\n+\n+        // Create the pattern body.\n+        let call_expr = build::mk_method_call(\n+            cx,\n+            span,\n+            build::mk_path(cx, span, ~[cx.ident_of(~\"__e\")]),\n+            cx.ident_of(~\"emit_enum_variant\"),\n+            ~[\n+                build::mk_base_str(cx, span, cx.str_of(variant.node.name)),\n+                build::mk_uint(cx, span, i),\n+                build::mk_uint(cx, span, variant_arg_len),\n+                build::mk_lambda_stmts(\n+                    cx,\n+                    span,\n+                    build::mk_fn_decl(~[], build::mk_ty_infer(cx, span)),\n+                    stmts\n+                )\n+            ]\n+        );\n+\n+        let match_body_block = build::mk_simple_block(cx, span, call_expr);\n+\n+        // Create the arm.\n+        ast::arm {\n+            pats: ~[pat],\n+            guard: None,\n+            body: match_body_block,\n+        }\n+    };\n+\n+    // Create the method body.\n+    let lambda_expr = build::mk_lambda(\n+        cx,\n+        span,\n+        build::mk_fn_decl(~[], build::mk_ty_infer(cx, span)),\n+        expand_enum_or_struct_match(cx, span, arms)\n+    );\n+\n+    let call_expr = build::mk_method_call(\n+        cx,\n+        span,\n+        build::mk_path(cx, span, ~[cx.ident_of(~\"__e\")]),\n+        cx.ident_of(~\"emit_enum\"),\n+        ~[\n+            build::mk_base_str(cx, span, cx.str_of(type_ident)),\n+            lambda_expr,\n+        ]\n+    );\n+\n+    let stmt = build::mk_stmt(cx, span, call_expr);\n+\n+    // Create the method.\n+    create_encode_method(cx, span, ~[stmt])\n+}"}, {"sha": "c427a206c2e329d76348e66d84e3aa274b820255", "filename": "src/libsyntax/ext/deriving/eq.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f8b36fc16178b298b23dfa199067ec2dd91df93/src%2Flibsyntax%2Fext%2Fderiving%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8b36fc16178b298b23dfa199067ec2dd91df93/src%2Flibsyntax%2Fext%2Fderiving%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Feq.rs?ref=2f8b36fc16178b298b23dfa199067ec2dd91df93", "patch": "@@ -17,6 +17,7 @@ use ext::build;\n use ext::deriving::*;\n use codemap::{span, spanned};\n use ast_util;\n+use opt_vec;\n \n use core::uint;\n \n@@ -124,12 +125,13 @@ fn create_derived_eq_impl(cx: @ext_ctxt,\n                           ne_method: @method)\n                        -> @item {\n     let methods = [ eq_method, ne_method ];\n-    let trait_path = [\n+    let trait_path = ~[\n         cx.ident_of(~\"core\"),\n         cx.ident_of(~\"cmp\"),\n         cx.ident_of(~\"Eq\")\n     ];\n-    create_derived_impl(cx, span, type_ident, generics, methods, trait_path)\n+    let trait_path = build::mk_raw_path_global(span, trait_path);\n+    create_derived_impl(cx, span, type_ident, generics, methods, trait_path, opt_vec::Empty)\n }\n \n fn call_substructure_eq_method(cx: @ext_ctxt,\n@@ -289,7 +291,7 @@ fn expand_deriving_eq_struct_method(cx: @ext_ctxt,\n                                             &mut outer_expr);\n             }\n             unnamed_field => {\n-                cx.span_unimpl(span, ~\"unnamed fields with `deriving_eq`\");\n+                cx.span_unimpl(span, ~\"unnamed fields with `deriving(Eq)`\");\n             }\n         }\n     }"}, {"sha": "4124e6ee6c165ffdf45bec98e694f81cf1256025", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f8b36fc16178b298b23dfa199067ec2dd91df93/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8b36fc16178b298b23dfa199067ec2dd91df93/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=2f8b36fc16178b298b23dfa199067ec2dd91df93", "patch": "@@ -17,6 +17,7 @@ use ext::build;\n use ext::deriving::*;\n use codemap::{span, spanned};\n use ast_util;\n+use opt_vec;\n \n use core::uint;\n \n@@ -49,12 +50,13 @@ fn create_derived_iter_bytes_impl(cx: @ext_ctxt,\n                                   method: @method)\n                                -> @item {\n     let methods = [ method ];\n-    let trait_path = [\n+    let trait_path = ~[\n         cx.ident_of(~\"core\"),\n         cx.ident_of(~\"to_bytes\"),\n         cx.ident_of(~\"IterBytes\")\n     ];\n-    create_derived_impl(cx, span, type_ident, generics, methods, trait_path)\n+    let trait_path = build::mk_raw_path_global(span, trait_path);\n+    create_derived_impl(cx, span, type_ident, generics, methods, trait_path, opt_vec::Empty)\n }\n \n // Creates a method from the given set of statements conforming to the\n@@ -191,7 +193,7 @@ fn expand_deriving_iter_bytes_struct_method(cx: @ext_ctxt,\n             }\n             unnamed_field => {\n                 cx.span_unimpl(span,\n-                               ~\"unnamed fields with `deriving_iter_bytes`\");\n+                               ~\"unnamed fields with `deriving(IterBytes)`\");\n             }\n         }\n     }"}, {"sha": "63106eae48ae852d4672f8573d8dd19ab799dcef", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 22, "deletions": 28, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/2f8b36fc16178b298b23dfa199067ec2dd91df93/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8b36fc16178b298b23dfa199067ec2dd91df93/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=2f8b36fc16178b298b23dfa199067ec2dd91df93", "patch": "@@ -14,7 +14,7 @@\n use core::prelude::*;\n \n use ast;\n-use ast::{TraitTyParamBound, Ty, bind_by_ref, deref, enum_def};\n+use ast::{Ty, bind_by_ref, deref, enum_def};\n use ast::{expr, expr_match, ident, item, item_};\n use ast::{item_enum, item_impl, item_struct, Generics};\n use ast::{m_imm, meta_item, method};\n@@ -33,6 +33,8 @@ use core::uint;\n pub mod clone;\n pub mod eq;\n pub mod iter_bytes;\n+pub mod encodable;\n+pub mod decodable;\n \n type ExpandDerivingStructDefFn<'self> = &'self fn(@ext_ctxt,\n                                                   span,\n@@ -76,6 +78,10 @@ pub fn expand_meta_deriving(cx: @ext_ctxt,\n                                 titem, in_items),\n                             ~\"IterBytes\" => iter_bytes::expand_deriving_iter_bytes(cx,\n                                 titem.span, titem, in_items),\n+                            ~\"Encodable\" => encodable::expand_deriving_encodable(cx,\n+                                titem.span, titem, in_items),\n+                            ~\"Decodable\" => decodable::expand_deriving_decodable(cx,\n+                                titem.span, titem, in_items),\n                             tname => {\n                                 cx.span_err(titem.span, fmt!(\"unknown \\\n                                     `deriving` trait: `%s`\", tname));\n@@ -153,12 +159,13 @@ pub fn create_self_type_with_params(cx: @ext_ctxt,\n }\n \n pub fn create_derived_impl(cx: @ext_ctxt,\n-                       span: span,\n-                       type_ident: ident,\n-                       generics: &Generics,\n-                       methods: &[@method],\n-                       trait_path: &[ident])\n-                    -> @item {\n+                           span: span,\n+                           type_ident: ident,\n+                           generics: &Generics,\n+                           methods: &[@method],\n+                           trait_path: @ast::Path,\n+                           mut impl_ty_params: opt_vec::OptVec<ast::TyParam>)\n+                        -> @item {\n     /*!\n      *\n      * Given that we are deriving a trait `Tr` for a type `T<'a, ...,\n@@ -175,29 +182,16 @@ pub fn create_derived_impl(cx: @ext_ctxt,\n         build::mk_lifetime(cx, l.span, l.ident)\n     });\n \n-    // Create the type parameters.\n-    let impl_ty_params = generics.ty_params.map(|ty_param| {\n-        let bound = build::mk_trait_ref_global(cx,\n-                                               span,\n-                                               trait_path.map(|x| *x));\n-        let bounds = @opt_vec::with(TraitTyParamBound(bound));\n-        build::mk_ty_param(cx, ty_param.ident, bounds)\n-    });\n-\n     // Create the reference to the trait.\n-    let trait_path = ast::Path {\n-        span: span,\n-        global: true,\n-        idents: trait_path.map(|x| *x),\n-        rp: None,\n-        types: ~[]\n-    };\n-    let trait_path = @trait_path;\n-    let trait_ref = ast::trait_ref {\n-        path: trait_path,\n-        ref_id: cx.next_id()\n+    let trait_ref = build::mk_trait_ref_(cx, trait_path);\n+\n+    // Create the type parameters.\n+    for generics.ty_params.each |ty_param| {\n+        let bounds = @opt_vec::with(\n+            build::mk_trait_ty_param_bound_(cx, trait_path)\n+        );\n+        impl_ty_params.push(build::mk_ty_param(cx, ty_param.ident, bounds));\n     };\n-    let trait_ref = @trait_ref;\n \n     // Create the type of `self`.\n     let self_type = create_self_type_with_params(cx,"}, {"sha": "4e7e5144a7df2be8b3ee2d756688c1e413f02147", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2f8b36fc16178b298b23dfa199067ec2dd91df93/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8b36fc16178b298b23dfa199067ec2dd91df93/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=2f8b36fc16178b298b23dfa199067ec2dd91df93", "patch": "@@ -95,7 +95,6 @@ pub fn rust_printer(writer: @io::Writer, intr: @ident_interner) -> @ps {\n }\n \n pub static indent_unit: uint = 4u;\n-pub static match_indent_unit: uint = 2u;\n \n pub static default_columns: uint = 78u;\n \n@@ -1227,16 +1226,16 @@ pub fn print_expr(s: @ps, &&expr: @ast::expr) {\n         print_block(s, blk);\n       }\n       ast::expr_match(expr, ref arms) => {\n-        cbox(s, match_indent_unit);\n+        cbox(s, indent_unit);\n         ibox(s, 4);\n         word_nbsp(s, ~\"match\");\n         print_expr(s, expr);\n         space(s.s);\n         bopen(s);\n-        let len = (*arms).len();\n-        for (*arms).eachi |i, arm| {\n+        let len = arms.len();\n+        for arms.eachi |i, arm| {\n             space(s.s);\n-            cbox(s, match_indent_unit);\n+            cbox(s, indent_unit);\n             ibox(s, 0u);\n             let mut first = true;\n             for arm.pats.each |p| {\n@@ -1269,7 +1268,7 @@ pub fn print_expr(s: @ps, &&expr: @ast::expr) {\n                             ast::expr_block(ref blk) => {\n                                 // the block will close the pattern's ibox\n                                 print_block_unclosed_indent(\n-                                    s, blk, match_indent_unit);\n+                                    s, blk, indent_unit);\n                             }\n                             _ => {\n                                 end(s); // close the ibox for the pattern\n@@ -1286,10 +1285,10 @@ pub fn print_expr(s: @ps, &&expr: @ast::expr) {\n                 }\n             } else {\n                 // the block will close the pattern's ibox\n-                print_block_unclosed_indent(s, &arm.body, match_indent_unit);\n+                print_block_unclosed_indent(s, &arm.body, indent_unit);\n             }\n         }\n-        bclose_(s, expr.span, match_indent_unit);\n+        bclose_(s, expr.span, indent_unit);\n       }\n       ast::expr_fn_block(ref decl, ref body) => {\n         // in do/for blocks we don't want to show an empty"}, {"sha": "66ad3d558201d27b027281233367e6d3251be3f1", "filename": "src/test/pretty/alt-naked-expr-long.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f8b36fc16178b298b23dfa199067ec2dd91df93/src%2Ftest%2Fpretty%2Falt-naked-expr-long.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8b36fc16178b298b23dfa199067ec2dd91df93/src%2Ftest%2Fpretty%2Falt-naked-expr-long.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Falt-naked-expr-long.rs?ref=2f8b36fc16178b298b23dfa199067ec2dd91df93", "patch": "@@ -17,9 +17,9 @@ fn main() {\n     let x = Some(3);\n     let y =\n         match x {\n-          Some(_) =>\n-          ~\"some\" + ~\"very\" + ~\"very\" + ~\"very\" + ~\"very\" + ~\"very\" + ~\"very\"\n-              + ~\"very\" + ~\"very\" + ~\"long\" + ~\"string\",\n-          None => ~\"none\"\n+            Some(_) =>\n+            ~\"some\" + ~\"very\" + ~\"very\" + ~\"very\" + ~\"very\" + ~\"very\" +\n+                ~\"very\" + ~\"very\" + ~\"very\" + ~\"long\" + ~\"string\",\n+            None => ~\"none\"\n         };\n }"}, {"sha": "4ae129c7b7307ca30d3fea81aa7a09e693998c7f", "filename": "src/test/pretty/alt-naked-expr-medium.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f8b36fc16178b298b23dfa199067ec2dd91df93/src%2Ftest%2Fpretty%2Falt-naked-expr-medium.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8b36fc16178b298b23dfa199067ec2dd91df93/src%2Ftest%2Fpretty%2Falt-naked-expr-medium.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Falt-naked-expr-medium.rs?ref=2f8b36fc16178b298b23dfa199067ec2dd91df93", "patch": "@@ -14,7 +14,7 @@ fn main() {\n     let x = Some(3);\n     let _y =\n         match x {\n-          Some(_) => ~[~\"some(_)\", ~\"not\", ~\"SO\", ~\"long\", ~\"string\"],\n-          None => ~[~\"none\"]\n+            Some(_) => ~[~\"some(_)\", ~\"not\", ~\"SO\", ~\"long\", ~\"string\"],\n+            None => ~[~\"none\"]\n         };\n }"}, {"sha": "bfc15acaa763c52ec9b24c41984f065cb19dd1d2", "filename": "src/test/run-pass/auto-encode.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2f8b36fc16178b298b23dfa199067ec2dd91df93/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8b36fc16178b298b23dfa199067ec2dd91df93/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-encode.rs?ref=2f8b36fc16178b298b23dfa199067ec2dd91df93", "patch": "@@ -22,7 +22,7 @@ use EBWriter = std::ebml::writer;\n use core::cmp::Eq;\n use core::io::Writer;\n use std::ebml;\n-use std::serialize::{Encodable, Decodable};\n+use std::serialize::{Decodable, Encodable};\n use std::time;\n \n fn test_ebml<A:\n@@ -39,8 +39,7 @@ fn test_ebml<A:\n     assert!(*a1 == a2);\n }\n \n-#[auto_encode]\n-#[auto_decode]\n+#[deriving(Decodable, Encodable)]\n enum Expr {\n     Val(uint),\n     Plus(@Expr, @Expr),\n@@ -107,32 +106,26 @@ impl cmp::Eq for CLike {\n     fn ne(&self, other: &CLike) -> bool { !self.eq(other) }\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n+#[deriving(Decodable, Encodable, Eq)]\n struct Spanned<T> {\n     lo: uint,\n     hi: uint,\n     node: T,\n }\n \n-#[auto_encode]\n-#[auto_decode]\n+#[deriving(Decodable, Encodable)]\n struct SomeStruct { v: ~[uint] }\n \n-#[auto_encode]\n-#[auto_decode]\n+#[deriving(Decodable, Encodable)]\n struct Point {x: uint, y: uint}\n \n-#[auto_encode]\n-#[auto_decode]\n+#[deriving(Decodable, Encodable)]\n enum Quark<T> {\n     Top(T),\n     Bottom(T)\n }\n \n-#[auto_encode]\n-#[auto_decode]\n+#[deriving(Decodable, Encodable)]\n enum CLike { A, B, C }\n \n pub fn main() {"}]}