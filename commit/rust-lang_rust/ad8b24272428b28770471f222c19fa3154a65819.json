{"sha": "ad8b24272428b28770471f222c19fa3154a65819", "node_id": "C_kwDOAAsO6NoAKGFkOGIyNDI3MjQyOGIyODc3MDQ3MWYyMjJjMTlmYTMxNTRhNjU4MTk", "commit": {"author": {"name": "Nathan Whitaker", "email": "nathan.whitaker01@gmail.com", "date": "2022-10-12T22:29:08Z"}, "committer": {"name": "Nathan Whitaker", "email": "nathan.whitaker01@gmail.com", "date": "2022-10-13T00:57:32Z"}, "message": "Let chains should still drop temporaries\nby the end of the condition's execution", "tree": {"sha": "f38880c0d0afd13e96210f9ff3dfbdf027b68107", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f38880c0d0afd13e96210f9ff3dfbdf027b68107"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad8b24272428b28770471f222c19fa3154a65819", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad8b24272428b28770471f222c19fa3154a65819", "html_url": "https://github.com/rust-lang/rust/commit/ad8b24272428b28770471f222c19fa3154a65819", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad8b24272428b28770471f222c19fa3154a65819/comments", "author": {"login": "nathanwhit", "id": 17734409, "node_id": "MDQ6VXNlcjE3NzM0NDA5", "avatar_url": "https://avatars.githubusercontent.com/u/17734409?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nathanwhit", "html_url": "https://github.com/nathanwhit", "followers_url": "https://api.github.com/users/nathanwhit/followers", "following_url": "https://api.github.com/users/nathanwhit/following{/other_user}", "gists_url": "https://api.github.com/users/nathanwhit/gists{/gist_id}", "starred_url": "https://api.github.com/users/nathanwhit/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nathanwhit/subscriptions", "organizations_url": "https://api.github.com/users/nathanwhit/orgs", "repos_url": "https://api.github.com/users/nathanwhit/repos", "events_url": "https://api.github.com/users/nathanwhit/events{/privacy}", "received_events_url": "https://api.github.com/users/nathanwhit/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nathanwhit", "id": 17734409, "node_id": "MDQ6VXNlcjE3NzM0NDA5", "avatar_url": "https://avatars.githubusercontent.com/u/17734409?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nathanwhit", "html_url": "https://github.com/nathanwhit", "followers_url": "https://api.github.com/users/nathanwhit/followers", "following_url": "https://api.github.com/users/nathanwhit/following{/other_user}", "gists_url": "https://api.github.com/users/nathanwhit/gists{/gist_id}", "starred_url": "https://api.github.com/users/nathanwhit/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nathanwhit/subscriptions", "organizations_url": "https://api.github.com/users/nathanwhit/orgs", "repos_url": "https://api.github.com/users/nathanwhit/repos", "events_url": "https://api.github.com/users/nathanwhit/events{/privacy}", "received_events_url": "https://api.github.com/users/nathanwhit/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0938e1680daf66ca6aad428aedf9a920a0dab5ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/0938e1680daf66ca6aad428aedf9a920a0dab5ad", "html_url": "https://github.com/rust-lang/rust/commit/0938e1680daf66ca6aad428aedf9a920a0dab5ad"}], "stats": {"total": 108, "additions": 97, "deletions": 11}, "files": [{"sha": "104010f8d435e16829c26ef3a131541a81bdb311", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 34, "deletions": 11, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ad8b24272428b28770471f222c19fa3154a65819/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8b24272428b28770471f222c19fa3154a65819/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=ad8b24272428b28770471f222c19fa3154a65819", "patch": "@@ -388,7 +388,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         else_opt: Option<&Expr>,\n     ) -> hir::ExprKind<'hir> {\n         let lowered_cond = self.lower_expr(cond);\n-        let new_cond = self.manage_let_cond(lowered_cond);\n+        let new_cond = self.wrap_cond_in_drop_scope(lowered_cond);\n         let then_expr = self.lower_block_expr(then);\n         if let Some(rslt) = else_opt {\n             hir::ExprKind::If(new_cond, self.arena.alloc(then_expr), Some(self.lower_expr(rslt)))\n@@ -397,22 +397,45 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         }\n     }\n \n-    // If `cond` kind is `let`, returns `let`. Otherwise, wraps and returns `cond`\n-    // in a temporary block.\n-    fn manage_let_cond(&mut self, cond: &'hir hir::Expr<'hir>) -> &'hir hir::Expr<'hir> {\n+    // Wraps a condition (i.e. `cond` in `if cond` or `while cond`) in a terminating scope\n+    // so that temporaries created in the condition don't live beyond it.\n+    fn wrap_cond_in_drop_scope(&mut self, cond: &'hir hir::Expr<'hir>) -> &'hir hir::Expr<'hir> {\n         fn has_let_expr<'hir>(expr: &'hir hir::Expr<'hir>) -> bool {\n             match expr.kind {\n                 hir::ExprKind::Binary(_, lhs, rhs) => has_let_expr(lhs) || has_let_expr(rhs),\n                 hir::ExprKind::Let(..) => true,\n                 _ => false,\n             }\n         }\n-        if has_let_expr(cond) {\n-            cond\n-        } else {\n-            let reason = DesugaringKind::CondTemporary;\n-            let span_block = self.mark_span_with_reason(reason, cond.span, None);\n-            self.expr_drop_temps(span_block, cond, AttrVec::new())\n+\n+        // We have to take special care for `let` exprs in the condition, e.g. in\n+        // `if let pat = val` or `if foo && let pat = val`, as we _do_ want `val` to live beyond the\n+        // condition in this case.\n+        //\n+        // In order to mantain the drop behavior for the non `let` parts of the condition,\n+        // we still wrap them in terminating scopes, e.g. `if foo && let pat = val` essentially\n+        // gets transformed into `if { let _t = foo; _t } && let pat = val`\n+        match cond.kind {\n+            hir::ExprKind::Binary(\n+                op @ Spanned { node: hir::BinOpKind::And | hir::BinOpKind::Or, .. },\n+                lhs,\n+                rhs,\n+            ) if has_let_expr(cond) => {\n+                let lhs = self.wrap_cond_in_drop_scope(lhs);\n+                let rhs = self.wrap_cond_in_drop_scope(rhs);\n+\n+                self.arena.alloc(self.expr(\n+                    cond.span,\n+                    hir::ExprKind::Binary(op, lhs, rhs),\n+                    AttrVec::new(),\n+                ))\n+            }\n+            hir::ExprKind::Let(_) => cond,\n+            _ => {\n+                let reason = DesugaringKind::CondTemporary;\n+                let span_block = self.mark_span_with_reason(reason, cond.span, None);\n+                self.expr_drop_temps(span_block, cond, AttrVec::new())\n+            }\n         }\n     }\n \n@@ -440,7 +463,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         opt_label: Option<Label>,\n     ) -> hir::ExprKind<'hir> {\n         let lowered_cond = self.with_loop_condition_scope(|t| t.lower_expr(cond));\n-        let new_cond = self.manage_let_cond(lowered_cond);\n+        let new_cond = self.wrap_cond_in_drop_scope(lowered_cond);\n         let then = self.lower_block_expr(body);\n         let expr_break = self.expr_break(span, AttrVec::new());\n         let stmt_break = self.stmt_expr(span, expr_break);"}, {"sha": "bf740b6a9ab6730e99241d08b9e4291947ed1b10", "filename": "src/test/ui/drop/drop_order.rs", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/ad8b24272428b28770471f222c19fa3154a65819/src%2Ftest%2Fui%2Fdrop%2Fdrop_order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8b24272428b28770471f222c19fa3154a65819/src%2Ftest%2Fui%2Fdrop%2Fdrop_order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdrop%2Fdrop_order.rs?ref=ad8b24272428b28770471f222c19fa3154a65819", "patch": "@@ -1,4 +1,5 @@\n // run-pass\n+#![feature(let_chains)]\n \n use std::cell::RefCell;\n use std::convert::TryInto;\n@@ -116,6 +117,58 @@ impl DropOrderCollector {\n         }\n     }\n \n+    fn let_chain(&self) {\n+        // take the \"then\" branch\n+        if self.option_loud_drop(2).is_some() // 2\n+            && self.option_loud_drop(1).is_some() // 1\n+            && let Some(_d) = self.option_loud_drop(4) { // 4\n+            self.print(3); // 3\n+        }\n+\n+        // take the \"else\" branch\n+        if self.option_loud_drop(6).is_some() // 2\n+            && self.option_loud_drop(5).is_some() // 1\n+            && let None = self.option_loud_drop(7) { // 3\n+            unreachable!();\n+        } else {\n+            self.print(8); // 4\n+        }\n+\n+        // let exprs interspersed\n+        if self.option_loud_drop(9).is_some() // 1\n+            && let Some(_d) = self.option_loud_drop(13) // 5\n+            && self.option_loud_drop(10).is_some() // 2\n+            && let Some(_e) = self.option_loud_drop(12) { // 4\n+            self.print(11); // 3\n+        }\n+\n+        // let exprs first\n+        if let Some(_d) = self.option_loud_drop(18) // 5\n+            && let Some(_e) = self.option_loud_drop(17) // 4\n+            && self.option_loud_drop(14).is_some() // 1\n+            && self.option_loud_drop(15).is_some() { // 2\n+                self.print(16); // 3\n+            }\n+\n+        // let exprs last\n+        if self.option_loud_drop(20).is_some() // 2\n+            && self.option_loud_drop(19).is_some() // 1\n+            && let Some(_d) = self.option_loud_drop(23) // 5\n+            && let Some(_e) = self.option_loud_drop(22) { // 4\n+                self.print(21); // 3\n+        }\n+    }\n+\n+    fn while_(&self) {\n+        let mut v = self.option_loud_drop(4);\n+        while let Some(_d) = v\n+            && self.option_loud_drop(1).is_some()\n+            && self.option_loud_drop(2).is_some() {\n+            self.print(3);\n+            v = None;\n+        }\n+    }\n+\n     fn assert_sorted(self) {\n         assert!(\n             self.0\n@@ -142,4 +195,14 @@ fn main() {\n     let collector = DropOrderCollector::default();\n     collector.match_();\n     collector.assert_sorted();\n+\n+    println!(\"-- let chain --\");\n+    let collector = DropOrderCollector::default();\n+    collector.let_chain();\n+    collector.assert_sorted();\n+\n+    println!(\"-- while --\");\n+    let collector = DropOrderCollector::default();\n+    collector.while_();\n+    collector.assert_sorted();\n }"}]}