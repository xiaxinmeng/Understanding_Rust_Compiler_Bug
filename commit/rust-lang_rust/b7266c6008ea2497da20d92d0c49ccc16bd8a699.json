{"sha": "b7266c6008ea2497da20d92d0c49ccc16bd8a699", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3MjY2YzYwMDhlYTI0OTdkYTIwZDkyZDBjNDljY2MxNmJkOGE2OTk=", "commit": {"author": {"name": "Daan de Graaf", "email": "daandegraaf9@gmail.com", "date": "2018-12-24T16:52:50Z"}, "committer": {"name": "Saleem Jaffer", "email": "ssaleem1992@gmail.com", "date": "2019-05-04T09:47:26Z"}, "message": "Move pointee_info_at to TyLayoutMethods.\n\nThe original implementation is still present at\nlibrustc_codegen_llvm/abi.rs, should be removed later to prevent code\nduplication.", "tree": {"sha": "ffffa72ea89db5c87fb52bc089a930d8a15c39c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ffffa72ea89db5c87fb52bc089a930d8a15c39c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7266c6008ea2497da20d92d0c49ccc16bd8a699", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7266c6008ea2497da20d92d0c49ccc16bd8a699", "html_url": "https://github.com/rust-lang/rust/commit/b7266c6008ea2497da20d92d0c49ccc16bd8a699", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7266c6008ea2497da20d92d0c49ccc16bd8a699/comments", "author": {"login": "wildarch", "id": 8987615, "node_id": "MDQ6VXNlcjg5ODc2MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8987615?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wildarch", "html_url": "https://github.com/wildarch", "followers_url": "https://api.github.com/users/wildarch/followers", "following_url": "https://api.github.com/users/wildarch/following{/other_user}", "gists_url": "https://api.github.com/users/wildarch/gists{/gist_id}", "starred_url": "https://api.github.com/users/wildarch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wildarch/subscriptions", "organizations_url": "https://api.github.com/users/wildarch/orgs", "repos_url": "https://api.github.com/users/wildarch/repos", "events_url": "https://api.github.com/users/wildarch/events{/privacy}", "received_events_url": "https://api.github.com/users/wildarch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "saleemjaffer", "id": 19221716, "node_id": "MDQ6VXNlcjE5MjIxNzE2", "avatar_url": "https://avatars.githubusercontent.com/u/19221716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saleemjaffer", "html_url": "https://github.com/saleemjaffer", "followers_url": "https://api.github.com/users/saleemjaffer/followers", "following_url": "https://api.github.com/users/saleemjaffer/following{/other_user}", "gists_url": "https://api.github.com/users/saleemjaffer/gists{/gist_id}", "starred_url": "https://api.github.com/users/saleemjaffer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saleemjaffer/subscriptions", "organizations_url": "https://api.github.com/users/saleemjaffer/orgs", "repos_url": "https://api.github.com/users/saleemjaffer/repos", "events_url": "https://api.github.com/users/saleemjaffer/events{/privacy}", "received_events_url": "https://api.github.com/users/saleemjaffer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2326366935613816927e679d3b2dc04db44678c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2326366935613816927e679d3b2dc04db44678c", "html_url": "https://github.com/rust-lang/rust/commit/e2326366935613816927e679d3b2dc04db44678c"}], "stats": {"total": 154, "additions": 154, "deletions": 0}, "files": [{"sha": "a67aa0e41b37b9c2ce99771a6f9a4773e10ab609", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/b7266c6008ea2497da20d92d0c49ccc16bd8a699/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7266c6008ea2497da20d92d0c49ccc16bd8a699/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=b7266c6008ea2497da20d92d0c49ccc16bd8a699", "patch": "@@ -12,6 +12,7 @@ use std::iter;\n use std::mem;\n use std::ops::Bound;\n \n+use hir;\n use crate::ich::StableHashingContext;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n@@ -1545,6 +1546,7 @@ impl<'gcx, 'tcx, T: HasTyCtxt<'gcx>> HasTyCtxt<'gcx> for LayoutCx<'tcx, T> {\n pub trait MaybeResult<T> {\n     fn from_ok(x: T) -> Self;\n     fn map_same<F: FnOnce(T) -> T>(self, f: F) -> Self;\n+    fn ok(self) -> Option<T>;\n }\n \n impl<T> MaybeResult<T> for T {\n@@ -1554,6 +1556,9 @@ impl<T> MaybeResult<T> for T {\n     fn map_same<F: FnOnce(T) -> T>(self, f: F) -> Self {\n         f(self)\n     }\n+    fn ok(self) -> Option<T> {\n+        Some(self)\n+    }\n }\n \n impl<T, E> MaybeResult<T> for Result<T, E> {\n@@ -1563,6 +1568,9 @@ impl<T, E> MaybeResult<T> for Result<T, E> {\n     fn map_same<F: FnOnce(T) -> T>(self, f: F) -> Self {\n         self.map(f)\n     }\n+    fn ok(self) -> Option<T> {\n+        self.ok()\n+    }\n }\n \n pub type TyLayout<'tcx> = ::rustc_target::abi::TyLayout<'tcx, Ty<'tcx>>;\n@@ -1824,6 +1832,125 @@ impl<'a, 'tcx, C> TyLayoutMethods<'tcx, C> for Ty<'tcx>\n             }\n         })\n     }\n+\n+    fn pointee_info_at(this: TyLayout<'tcx>, cx: &C, offset: Size\n+    ) -> Option<PointeeInfo> {\n+        let mut result = None;\n+        match this.ty.sty {\n+            ty::RawPtr(mt) if offset.bytes() == 0 => {\n+                result = cx.layout_of(mt.ty).ok()\n+                    .map(|layout| PointeeInfo {\n+                        size: layout.size,\n+                        align: layout.align.abi,\n+                        safe: None,\n+                    });\n+            }\n+\n+            ty::Ref(_, ty, mt) if offset.bytes() == 0 => {\n+                let tcx = cx.tcx();\n+                let is_freeze = ty.is_freeze(tcx, ty::ParamEnv::reveal_all(), DUMMY_SP);\n+                let kind = match mt {\n+                    hir::MutImmutable => if is_freeze {\n+                        PointerKind::Frozen\n+                    } else {\n+                        PointerKind::Shared\n+                    },\n+                    hir::MutMutable => {\n+                        // Previously we would only emit noalias annotations for LLVM >= 6 or in\n+                        // panic=abort mode. That was deemed right, as prior versions had many bugs\n+                        // in conjunction with unwinding, but later versions didn\u2019t seem to have\n+                        // said issues. See issue #31681.\n+                        //\n+                        // Alas, later on we encountered a case where noalias would generate wrong\n+                        // code altogether even with recent versions of LLVM in *safe* code with no\n+                        // unwinding involved. See #54462.\n+                        //\n+                        // For now, do not enable mutable_noalias by default at all, while the\n+                        // issue is being figured out.\n+                        let mutable_noalias = tcx.sess.opts.debugging_opts.mutable_noalias\n+                            .unwrap_or(false);\n+                        if mutable_noalias {\n+                            PointerKind::UniqueBorrowed\n+                        } else {\n+                            PointerKind::Shared\n+                        }\n+                    }\n+                };\n+\n+                result = cx.layout_of(ty).ok()\n+                    .map(|layout| PointeeInfo {\n+                        size: layout.size,\n+                        align: layout.align.abi,\n+                        safe: Some(kind),\n+                    });\n+            }\n+\n+            _ => {\n+                let mut data_variant = match this.variants {\n+                    Variants::NicheFilling { dataful_variant, .. } => {\n+                        // Only the niche itthis is always initialized,\n+                        // so only check for a pointer at its offset.\n+                        //\n+                        // If the niche is a pointer, it's either valid\n+                        // (according to its type), or null (which the\n+                        // niche field's scalar validity range encodes).\n+                        // This allows using `dereferenceable_or_null`\n+                        // for e.g., `Option<&T>`, and this will continue\n+                        // to work as long as we don't start using more\n+                        // niches than just null (e.g., the first page\n+                        // of the address space, or unaligned pointers).\n+                        if this.fields.offset(0) == offset {\n+                            Some(this.for_variant(cx, dataful_variant))\n+                        } else {\n+                            None\n+                        }\n+                    }\n+                    _ => Some(this)\n+                };\n+\n+                if let Some(variant) = data_variant {\n+                    // We're not interested in any unions.\n+                    if let FieldPlacement::Union(_) = variant.fields {\n+                        data_variant = None;\n+                    }\n+                }\n+\n+                if let Some(variant) = data_variant {\n+                    let ptr_end = offset + Pointer.size(cx);\n+                    for i in 0..variant.fields.count() {\n+                        let field_start = variant.fields.offset(i);\n+                        if field_start <= offset {\n+                            let field = variant.field(cx, i);\n+                            result = field.ok()\n+                                .and_then(|field| {\n+                                    if ptr_end <= field_start + field.size {\n+                                        // We found the right field, look inside it.\n+                                        Self::pointee_info_at(field, cx, offset - field_start)\n+                                    } else {\n+                                        None\n+                                    }\n+                                });\n+                            if result.is_some() {\n+                                break;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // FIXME(eddyb) This should be for `ptr::Unique<T>`, not `Box<T>`.\n+                if let Some(ref mut pointee) = result {\n+                    if let ty::Adt(def, _) = this.ty.sty {\n+                        if def.is_box() && offset.bytes() == 0 {\n+                            pointee.safe = Some(PointerKind::UniqueOwned);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        result\n+    }\n+\n }\n \n struct Niche {"}, {"sha": "74257cb3f64809a2a2ef16eefe3dcf7fb3ab1d59", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b7266c6008ea2497da20d92d0c49ccc16bd8a699/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7266c6008ea2497da20d92d0c49ccc16bd8a699/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=b7266c6008ea2497da20d92d0c49ccc16bd8a699", "patch": "@@ -910,13 +910,40 @@ pub trait LayoutOf {\n     fn layout_of(&self, ty: Self::Ty) -> Self::TyLayout;\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq)]\n+pub enum PointerKind {\n+    /// Most general case, we know no restrictions to tell LLVM.\n+    Shared,\n+\n+    /// `&T` where `T` contains no `UnsafeCell`, is `noalias` and `readonly`.\n+    Frozen,\n+\n+    /// `&mut T`, when we know `noalias` is safe for LLVM.\n+    UniqueBorrowed,\n+\n+    /// `Box<T>`, unlike `UniqueBorrowed`, it also has `noalias` on returns.\n+    UniqueOwned\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct PointeeInfo {\n+    pub size: Size,\n+    pub align: Align,\n+    pub safe: Option<PointerKind>,\n+}\n+\n pub trait TyLayoutMethods<'a, C: LayoutOf<Ty = Self>>: Sized {\n     fn for_variant(\n         this: TyLayout<'a, Self>,\n         cx: &C,\n         variant_index: VariantIdx,\n     ) -> TyLayout<'a, Self>;\n     fn field(this: TyLayout<'a, Self>, cx: &C, i: usize) -> C::TyLayout;\n+    fn pointee_info_at(\n+        this: TyLayout<'a, Self>,\n+        cx: &C,\n+        offset: Size\n+    ) -> Option<PointeeInfo>;\n }\n \n impl<'a, Ty> TyLayout<'a, Ty> {"}]}