{"sha": "50f063c75b4d05976a1c132afd213c75913c7605", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwZjA2M2M3NWI0ZDA1OTc2YTFjMTMyYWZkMjEzYzc1OTEzYzc2MDU=", "commit": {"author": {"name": "est31", "email": "MTest31@outlook.com", "date": "2018-05-12T09:09:36Z"}, "committer": {"name": "est31", "email": "MTest31@outlook.com", "date": "2018-05-16T11:56:25Z"}, "message": "Extend error E0695 to unlabeled continue statements", "tree": {"sha": "b8d1c19ee8525c624c1d21d74ffd1e85296f09b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8d1c19ee8525c624c1d21d74ffd1e85296f09b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50f063c75b4d05976a1c132afd213c75913c7605", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50f063c75b4d05976a1c132afd213c75913c7605", "html_url": "https://github.com/rust-lang/rust/commit/50f063c75b4d05976a1c132afd213c75913c7605", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50f063c75b4d05976a1c132afd213c75913c7605/comments", "author": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "committer": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63ef53f21d326feb3b244772c452f5ac2632ef6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/63ef53f21d326feb3b244772c452f5ac2632ef6c", "html_url": "https://github.com/rust-lang/rust/commit/63ef53f21d326feb3b244772c452f5ac2632ef6c"}], "stats": {"total": 26, "additions": 17, "deletions": 9}, "files": [{"sha": "bd43cd71e416dc2dc728dc5ed20aa00fed5d16c0", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/50f063c75b4d05976a1c132afd213c75913c7605/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f063c75b4d05976a1c132afd213c75913c7605/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=50f063c75b4d05976a1c132afd213c75913c7605", "patch": "@@ -13,7 +13,7 @@ use rustc::session::Session;\n \n use rustc::hir::map::Map;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use rustc::hir;\n+use rustc::hir::{self, Destination};\n use syntax::ast;\n use syntax_pos::Span;\n \n@@ -91,6 +91,8 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n                 self.with_context(LabeledBlock, |v| v.visit_block(&b));\n             }\n             hir::ExprBreak(label, ref opt_expr) => {\n+                self.require_label_in_labeled_block(e.span, &label, \"break\");\n+\n                 let loop_id = match label.target_id.into() {\n                     Ok(loop_id) => loop_id,\n                     Err(hir::LoopIdError::OutsideLoopScope) => ast::DUMMY_NODE_ID,\n@@ -109,14 +111,6 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n                 }\n \n                 if self.cx == LabeledBlock {\n-                    if label.label.is_none() {\n-                        struct_span_err!(self.sess, e.span, E0695,\n-                                        \"unlabeled `break` inside of a labeled block\")\n-                            .span_label(e.span,\n-                                        \"`break` statements that would diverge to or through \\\n-                                        a labeled block need to bear a label\")\n-                            .emit();\n-                    }\n                     return;\n                 }\n \n@@ -156,6 +150,8 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n                 self.require_break_cx(\"break\", e.span);\n             }\n             hir::ExprAgain(label) => {\n+                self.require_label_in_labeled_block(e.span, &label, \"continue\");\n+\n                 if let Err(hir::LoopIdError::UnlabeledCfInWhileCondition) = label.target_id {\n                     self.emit_unlabled_cf_in_while_condition(e.span, \"continue\");\n                 }\n@@ -193,6 +189,18 @@ impl<'a, 'hir> CheckLoopVisitor<'a, 'hir> {\n         }\n     }\n \n+    fn require_label_in_labeled_block(&mut self, span: Span, label: &Destination, cf_type: &str) {\n+        if self.cx == LabeledBlock {\n+            if label.label.is_none() {\n+                struct_span_err!(self.sess, span, E0695,\n+                                \"unlabeled `{}` inside of a labeled block\", cf_type)\n+                    .span_label(span,\n+                                format!(\"`{}` statements that would diverge to or through \\\n+                                a labeled block need to bear a label\", cf_type))\n+                    .emit();\n+            }\n+        }\n+    }\n     fn emit_unlabled_cf_in_while_condition(&mut self, span: Span, cf_type: &str) {\n         struct_span_err!(self.sess, span, E0590,\n                          \"`break` or `continue` with no label in the condition of a `while` loop\")"}]}