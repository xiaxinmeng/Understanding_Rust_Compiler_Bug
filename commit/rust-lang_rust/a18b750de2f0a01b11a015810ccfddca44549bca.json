{"sha": "a18b750de2f0a01b11a015810ccfddca44549bca", "node_id": "C_kwDOAAsO6NoAKGExOGI3NTBkZTJmMGEwMWIxMWEwMTU4MTBjY2ZkZGNhNDQ1NDliY2E", "commit": {"author": {"name": "Raoul Strackx", "email": "raoul.strackx@fortanix.com", "date": "2023-03-29T15:47:34Z"}, "committer": {"name": "Raoul Strackx", "email": "raoul.strackx@fortanix.com", "date": "2023-05-01T08:27:37Z"}, "message": "Ensure test library issues json string line-by-line", "tree": {"sha": "a53f7711fd6fe5e356b80cb5243ff54d6e1d4977", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a53f7711fd6fe5e356b80cb5243ff54d6e1d4977"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a18b750de2f0a01b11a015810ccfddca44549bca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a18b750de2f0a01b11a015810ccfddca44549bca", "html_url": "https://github.com/rust-lang/rust/commit/a18b750de2f0a01b11a015810ccfddca44549bca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a18b750de2f0a01b11a015810ccfddca44549bca/comments", "author": {"login": "raoulstrackx", "id": 56830709, "node_id": "MDQ6VXNlcjU2ODMwNzA5", "avatar_url": "https://avatars.githubusercontent.com/u/56830709?v=4", "gravatar_id": "", "url": "https://api.github.com/users/raoulstrackx", "html_url": "https://github.com/raoulstrackx", "followers_url": "https://api.github.com/users/raoulstrackx/followers", "following_url": "https://api.github.com/users/raoulstrackx/following{/other_user}", "gists_url": "https://api.github.com/users/raoulstrackx/gists{/gist_id}", "starred_url": "https://api.github.com/users/raoulstrackx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/raoulstrackx/subscriptions", "organizations_url": "https://api.github.com/users/raoulstrackx/orgs", "repos_url": "https://api.github.com/users/raoulstrackx/repos", "events_url": "https://api.github.com/users/raoulstrackx/events{/privacy}", "received_events_url": "https://api.github.com/users/raoulstrackx/received_events", "type": "User", "site_admin": false}, "committer": {"login": "raoulstrackx", "id": 56830709, "node_id": "MDQ6VXNlcjU2ODMwNzA5", "avatar_url": "https://avatars.githubusercontent.com/u/56830709?v=4", "gravatar_id": "", "url": "https://api.github.com/users/raoulstrackx", "html_url": "https://github.com/raoulstrackx", "followers_url": "https://api.github.com/users/raoulstrackx/followers", "following_url": "https://api.github.com/users/raoulstrackx/following{/other_user}", "gists_url": "https://api.github.com/users/raoulstrackx/gists{/gist_id}", "starred_url": "https://api.github.com/users/raoulstrackx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/raoulstrackx/subscriptions", "organizations_url": "https://api.github.com/users/raoulstrackx/orgs", "repos_url": "https://api.github.com/users/raoulstrackx/repos", "events_url": "https://api.github.com/users/raoulstrackx/events{/privacy}", "received_events_url": "https://api.github.com/users/raoulstrackx/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2034b6d23ca18311a23273f2f08c381a04fa05d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/2034b6d23ca18311a23273f2f08c381a04fa05d9", "html_url": "https://github.com/rust-lang/rust/commit/2034b6d23ca18311a23273f2f08c381a04fa05d9"}], "stats": {"total": 132, "additions": 62, "deletions": 70}, "files": [{"sha": "47c4e7757e40cb96eccabdedc9acbab259d7ecea", "filename": "library/test/src/formatters/json.rs", "status": "modified", "additions": 62, "deletions": 70, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/a18b750de2f0a01b11a015810ccfddca44549bca/library%2Ftest%2Fsrc%2Fformatters%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a18b750de2f0a01b11a015810ccfddca44549bca/library%2Ftest%2Fsrc%2Fformatters%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fformatters%2Fjson.rs?ref=a18b750de2f0a01b11a015810ccfddca44549bca", "patch": "@@ -18,14 +18,10 @@ impl<T: Write> JsonFormatter<T> {\n     }\n \n     fn writeln_message(&mut self, s: &str) -> io::Result<()> {\n-        assert!(!s.contains('\\n'));\n-\n-        self.out.write_all(s.as_ref())?;\n-        self.out.write_all(b\"\\n\")\n-    }\n-\n-    fn write_message(&mut self, s: &str) -> io::Result<()> {\n-        assert!(!s.contains('\\n'));\n+        // self.out will take a lock, but that lock is released when write_all returns. This\n+        // results in a race condition and json output may not end with a new line. We avoid this\n+        // by issuing `write_all` calls line-by-line.\n+        assert_eq!(s.chars().last(), Some('\\n'));\n \n         self.out.write_all(s.as_ref())\n     }\n@@ -34,34 +30,35 @@ impl<T: Write> JsonFormatter<T> {\n         &mut self,\n         ty: &str,\n         name: &str,\n-        evt: &str,\n+        event: &str,\n         exec_time: Option<&time::TestExecTime>,\n         stdout: Option<Cow<'_, str>>,\n         extra: Option<&str>,\n     ) -> io::Result<()> {\n         // A doc test's name includes a filename which must be escaped for correct json.\n-        self.write_message(&format!(\n-            r#\"{{ \"type\": \"{}\", \"name\": \"{}\", \"event\": \"{}\"\"#,\n-            ty,\n-            EscapedString(name),\n-            evt\n-        ))?;\n-        if let Some(exec_time) = exec_time {\n-            self.write_message(&format!(r#\", \"exec_time\": {}\"#, exec_time.0.as_secs_f64()))?;\n-        }\n-        if let Some(stdout) = stdout {\n-            self.write_message(&format!(r#\", \"stdout\": \"{}\"\"#, EscapedString(stdout)))?;\n-        }\n-        if let Some(extra) = extra {\n-            self.write_message(&format!(r#\", {extra}\"#))?;\n-        }\n-        self.writeln_message(\" }\")\n+        let name = EscapedString(name);\n+        let exec_time_json = if let Some(exec_time) = exec_time {\n+            format!(r#\", \"exec_time\": {}\"#, exec_time.0.as_secs_f64())\n+        } else {\n+            String::from(\"\")\n+        };\n+        let stdout_json = if let Some(stdout) = stdout {\n+            format!(r#\", \"stdout\": \"{}\"\"#, EscapedString(stdout))\n+        } else {\n+            String::from(\"\")\n+        };\n+        let extra_json =\n+            if let Some(extra) = extra { format!(r#\", {extra}\"#) } else { String::from(\"\") };\n+        let newline = \"\\n\";\n+\n+        self.writeln_message(&format!(\n+                r#\"{{ \"type\": \"{ty}\", \"name\": \"{name}\", \"event\": \"{event}\"{exec_time_json}{stdout_json}{extra_json} }}{newline}\"#))\n     }\n }\n \n impl<T: Write> OutputFormatter for JsonFormatter<T> {\n     fn write_discovery_start(&mut self) -> io::Result<()> {\n-        self.writeln_message(&format!(r#\"{{ \"type\": \"suite\", \"event\": \"discovery\" }}\"#))\n+        self.writeln_message(concat!(r#\"{ \"type\": \"suite\", \"event\": \"discovery\" }\"#, \"\\n\"))\n     }\n \n     fn write_test_discovered(&mut self, desc: &TestDesc, test_type: &str) -> io::Result<()> {\n@@ -77,21 +74,24 @@ impl<T: Write> OutputFormatter for JsonFormatter<T> {\n             ..\n         } = desc;\n \n+        let name = EscapedString(name.as_slice());\n+        let ignore_message = ignore_message.unwrap_or(\"\");\n+        let source_path = EscapedString(source_file);\n+        let newline = \"\\n\";\n+\n         self.writeln_message(&format!(\n-            r#\"{{ \"type\": \"{test_type}\", \"event\": \"discovered\", \"name\": \"{}\", \"ignore\": {ignore}, \"ignore_message\": \"{}\", \"source_path\": \"{}\", \"start_line\": {start_line}, \"start_col\": {start_col}, \"end_line\": {end_line}, \"end_col\": {end_col} }}\"#,\n-            EscapedString(name.as_slice()),\n-            ignore_message.unwrap_or(\"\"),\n-            EscapedString(source_file),\n+            r#\"{{ \"type\": \"{test_type}\", \"event\": \"discovered\", \"name\": \"{name}\", \"ignore\": {ignore}, \"ignore_message\": \"{ignore_message}\", \"source_path\": \"{source_path}\", \"start_line\": {start_line}, \"start_col\": {start_col}, \"end_line\": {end_line}, \"end_col\": {end_col} }}{newline}\"#\n         ))\n     }\n \n     fn write_discovery_finish(&mut self, state: &ConsoleTestDiscoveryState) -> io::Result<()> {\n         let ConsoleTestDiscoveryState { tests, benchmarks, ignored, .. } = state;\n \n         let total = tests + benchmarks;\n+        let newline = \"\\n\";\n         self.writeln_message(&format!(\n-            r#\"{{ \"type\": \"suite\", \"event\": \"completed\", \"tests\": {tests}, \"benchmarks\": {benchmarks}, \"total\": {total}, \"ignored\": {ignored} }}\"#\n-        ))\n+            r#\"{{ \"type\": \"suite\", \"event\": \"completed\", \"tests\": {tests}, \"benchmarks\": {benchmarks}, \"total\": {total}, \"ignored\": {ignored} }}{newline}\"#\n+            ))\n     }\n \n     fn write_run_start(&mut self, test_count: usize, shuffle_seed: Option<u64>) -> io::Result<()> {\n@@ -100,15 +100,17 @@ impl<T: Write> OutputFormatter for JsonFormatter<T> {\n         } else {\n             String::new()\n         };\n+        let newline = \"\\n\";\n         self.writeln_message(&format!(\n-            r#\"{{ \"type\": \"suite\", \"event\": \"started\", \"test_count\": {test_count}{shuffle_seed_json} }}\"#\n-        ))\n+            r#\"{{ \"type\": \"suite\", \"event\": \"started\", \"test_count\": {test_count}{shuffle_seed_json} }}{newline}\"#\n+            ))\n     }\n \n     fn write_test_start(&mut self, desc: &TestDesc) -> io::Result<()> {\n+        let name = EscapedString(desc.name.as_slice());\n+        let newline = \"\\n\";\n         self.writeln_message(&format!(\n-            r#\"{{ \"type\": \"test\", \"event\": \"started\", \"name\": \"{}\" }}\"#,\n-            EscapedString(desc.name.as_slice())\n+            r#\"{{ \"type\": \"test\", \"event\": \"started\", \"name\": \"{name}\" }}{newline}\"#\n         ))\n     }\n \n@@ -173,53 +175,43 @@ impl<T: Write> OutputFormatter for JsonFormatter<T> {\n                 } else {\n                     format!(r#\", \"mib_per_second\": {}\"#, bs.mb_s)\n                 };\n+                let name = EscapedString(desc.name.as_slice());\n \n-                let line = format!(\n+                self.writeln_message(&format!(\n                     \"{{ \\\"type\\\": \\\"bench\\\", \\\n-                     \\\"name\\\": \\\"{}\\\", \\\n-                     \\\"median\\\": {}, \\\n-                     \\\"deviation\\\": {}{} }}\",\n-                    EscapedString(desc.name.as_slice()),\n-                    median,\n-                    deviation,\n-                    mbps\n-                );\n-\n-                self.writeln_message(&line)\n+                     \\\"name\\\": \\\"{name}\\\", \\\n+                     \\\"median\\\": {median}, \\\n+                     \\\"deviation\\\": {deviation}{mbps} }}\\n\",\n+                ))\n             }\n         }\n     }\n \n     fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()> {\n+        let name = EscapedString(desc.name.as_slice());\n+        let newline = \"\\n\";\n         self.writeln_message(&format!(\n-            r#\"{{ \"type\": \"test\", \"event\": \"timeout\", \"name\": \"{}\" }}\"#,\n-            EscapedString(desc.name.as_slice())\n+            r#\"{{ \"type\": \"test\", \"event\": \"timeout\", \"name\": \"{name}\" }}{newline}\"#,\n         ))\n     }\n \n     fn write_run_finish(&mut self, state: &ConsoleTestState) -> io::Result<bool> {\n-        self.write_message(&format!(\n-            \"{{ \\\"type\\\": \\\"suite\\\", \\\n-             \\\"event\\\": \\\"{}\\\", \\\n-             \\\"passed\\\": {}, \\\n-             \\\"failed\\\": {}, \\\n-             \\\"ignored\\\": {}, \\\n-             \\\"measured\\\": {}, \\\n-             \\\"filtered_out\\\": {}\",\n-            if state.failed == 0 { \"ok\" } else { \"failed\" },\n-            state.passed,\n-            state.failed,\n-            state.ignored,\n-            state.measured,\n-            state.filtered_out,\n-        ))?;\n-\n-        if let Some(ref exec_time) = state.exec_time {\n-            let time_str = format!(\", \\\"exec_time\\\": {}\", exec_time.0.as_secs_f64());\n-            self.write_message(&time_str)?;\n-        }\n+        let event = if state.failed == 0 { \"ok\" } else { \"failed\" };\n+        let passed = state.passed;\n+        let failed = state.failed;\n+        let ignored = state.ignored;\n+        let measured = state.measured;\n+        let filtered_out = state.filtered_out;\n+        let exec_time_json = if let Some(ref exec_time) = state.exec_time {\n+            format!(r#\", \"exec_time\": {}\"#, exec_time.0.as_secs_f64())\n+        } else {\n+            String::from(\"\")\n+        };\n+        let newline = \"\\n\";\n \n-        self.writeln_message(\" }\")?;\n+        self.writeln_message(&format!(\n+            r#\"{{ \"type\": \"suite\", \"event\": \"{event}\", \"passed\": {passed}, \"failed\": {failed}, \"ignored\": {ignored}, \"measured\": {measured}, \"filtered_out\": {filtered_out}{exec_time_json} }}{newline}\"#\n+        ))?;\n \n         Ok(state.failed == 0)\n     }"}]}