{"sha": "519b040b63a44d564982227452a64cac5de04881", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxOWIwNDBiNjNhNDRkNTY0OTgyMjI3NDUyYTY0Y2FjNWRlMDQ4ODE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-05-25T02:55:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-05-25T02:55:28Z"}, "message": "Rollup merge of #61026 - estebank:macro-eof-spans, r=petrochenkov\n\nTweak macro parse errors when reaching EOF during macro call parse\n\nAdd detail on origin of current parser when reaching EOF, stop saying \"found `<eof>`\" and point at the end of macro calls.\n\nFix #27569.", "tree": {"sha": "167593596a50dfcd945f64230a08e056ed1ea308", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/167593596a50dfcd945f64230a08e056ed1ea308"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/519b040b63a44d564982227452a64cac5de04881", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJc6K6gCRBK7hj4Ov3rIwAAdHIIAITvq7fcPpdOUCHk9S/C7SQQ\n4h2NX+z9U469sgZXbOpqGgaViMyaKh+TZ7Ry54v+8ZueLV9j282SBI8/986oOlla\nenyRDRE39/V0u7u4u3ICsSQgfuvzIAr9UUVIMehxPCDwk0bAtvyP5xwHpsVP8/a2\n6X7LF3/WhgVC6NsiH1MgVX8aYeX3P+U4rvOA/RElAIrdhLEfrG0Zfzkb4rSRvQm7\n+kJlKcbuP9LE0sNvqTIL2EVw1dOu/6slY9nVq4zucxB0C9rjnN0ERdRrFX/M4A+e\nP2kCmmweVZ8MZ8bLzeUi0FfnGRU+GRwAIAFgMPJcZqr+eKUsmP1vplpwYCr9QTQ=\n=TRXD\n-----END PGP SIGNATURE-----\n", "payload": "tree 167593596a50dfcd945f64230a08e056ed1ea308\nparent dec4c5201f88efbc3020b04ba96a5ee2c3b6cfcd\nparent ee7593e0ac83a1b18e7489b852952cd21e2a6947\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1558752928 +0200\ncommitter GitHub <noreply@github.com> 1558752928 +0200\n\nRollup merge of #61026 - estebank:macro-eof-spans, r=petrochenkov\n\nTweak macro parse errors when reaching EOF during macro call parse\n\nAdd detail on origin of current parser when reaching EOF, stop saying \"found `<eof>`\" and point at the end of macro calls.\n\nFix #27569.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/519b040b63a44d564982227452a64cac5de04881", "html_url": "https://github.com/rust-lang/rust/commit/519b040b63a44d564982227452a64cac5de04881", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/519b040b63a44d564982227452a64cac5de04881/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dec4c5201f88efbc3020b04ba96a5ee2c3b6cfcd", "url": "https://api.github.com/repos/rust-lang/rust/commits/dec4c5201f88efbc3020b04ba96a5ee2c3b6cfcd", "html_url": "https://github.com/rust-lang/rust/commit/dec4c5201f88efbc3020b04ba96a5ee2c3b6cfcd"}, {"sha": "ee7593e0ac83a1b18e7489b852952cd21e2a6947", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee7593e0ac83a1b18e7489b852952cd21e2a6947", "html_url": "https://github.com/rust-lang/rust/commit/ee7593e0ac83a1b18e7489b852952cd21e2a6947"}], "stats": {"total": 298, "additions": 184, "deletions": 114}, "files": [{"sha": "1c17ace90c2fbbc458f1ea4e8dab464da5e67ed7", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/519b040b63a44d564982227452a64cac5de04881/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/519b040b63a44d564982227452a64cac5de04881/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=519b040b63a44d564982227452a64cac5de04881", "patch": "@@ -226,12 +226,12 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n         Ok(result)\n     }\n \n-    fn verify(&self,\n-              tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-              trait_def_id: DefId,\n-              span: Span)\n-              -> Result<(), ErrorReported>\n-    {\n+    fn verify(\n+        &self,\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        trait_def_id: DefId,\n+        span: Span,\n+    ) -> Result<(), ErrorReported> {\n         let name = tcx.item_name(trait_def_id);\n         let generics = tcx.generics_of(trait_def_id);\n         let parser = Parser::new(&self.0, None, vec![], false);\n@@ -272,12 +272,12 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n         result\n     }\n \n-    pub fn format(&self,\n-                  tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                  trait_ref: ty::TraitRef<'tcx>,\n-                  options: &FxHashMap<String, String>)\n-                  -> String\n-    {\n+    pub fn format(\n+        &self,\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        trait_ref: ty::TraitRef<'tcx>,\n+        options: &FxHashMap<String, String>,\n+    ) -> String {\n         let name = tcx.item_name(trait_ref.def_id);\n         let trait_str = tcx.def_path_str(trait_ref.def_id);\n         let generics = tcx.generics_of(trait_ref.def_id);"}, {"sha": "48948e4d0d79c1829c30cbbf199319c4ab046737", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/519b040b63a44d564982227452a64cac5de04881/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/519b040b63a44d564982227452a64cac5de04881/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=519b040b63a44d564982227452a64cac5de04881", "patch": "@@ -278,7 +278,14 @@ impl Attribute {\n     pub fn parse<'a, T, F>(&self, sess: &'a ParseSess, mut f: F) -> PResult<'a, T>\n         where F: FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n     {\n-        let mut parser = Parser::new(sess, self.tokens.clone(), None, false, false);\n+        let mut parser = Parser::new(\n+            sess,\n+            self.tokens.clone(),\n+            None,\n+            false,\n+            false,\n+            Some(\"attribute\"),\n+        );\n         let result = f(&mut parser)?;\n         if parser.token != token::Eof {\n             parser.unexpected()?;"}, {"sha": "dbec379e76995cc0025b28e960ab437d54ce64f2", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/519b040b63a44d564982227452a64cac5de04881/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/519b040b63a44d564982227452a64cac5de04881/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=519b040b63a44d564982227452a64cac5de04881", "patch": "@@ -11,7 +11,7 @@ use crate::parse::{self, parser, DirectoryOwnership};\n use crate::parse::token;\n use crate::ptr::P;\n use crate::symbol::{kw, sym, Ident, Symbol};\n-use crate::ThinVec;\n+use crate::{ThinVec, MACRO_ARGUMENTS};\n use crate::tokenstream::{self, TokenStream};\n \n use errors::{DiagnosticBuilder, DiagnosticId};\n@@ -850,7 +850,7 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n     pub fn new_parser_from_tts(&self, tts: &[tokenstream::TokenTree]) -> parser::Parser<'a> {\n-        parse::stream_to_parser(self.parse_sess, tts.iter().cloned().collect())\n+        parse::stream_to_parser(self.parse_sess, tts.iter().cloned().collect(), MACRO_ARGUMENTS)\n     }\n     pub fn source_map(&self) -> &'a SourceMap { self.parse_sess.source_map() }\n     pub fn parse_sess(&self) -> &'a parse::ParseSess { self.parse_sess }"}, {"sha": "e55226b8579bda2566c2929225d8212c72343c96", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/519b040b63a44d564982227452a64cac5de04881/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/519b040b63a44d564982227452a64cac5de04881/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=519b040b63a44d564982227452a64cac5de04881", "patch": "@@ -658,7 +658,14 @@ pub fn parse(\n     recurse_into_modules: bool,\n ) -> NamedParseResult {\n     // Create a parser that can be used for the \"black box\" parts.\n-    let mut parser = Parser::new(sess, tts, directory, recurse_into_modules, true);\n+    let mut parser = Parser::new(\n+        sess,\n+        tts,\n+        directory,\n+        recurse_into_modules,\n+        true,\n+        crate::MACRO_ARGUMENTS,\n+    );\n \n     // A queue of possible matcher positions. We initialize it with the matcher position in which\n     // the \"dot\" is before the first token of the first token tree in `ms`. `inner_parse_loop` then"}, {"sha": "2debd8f048bc35a578fafd2429062c9ebfd81c0d", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/519b040b63a44d564982227452a64cac5de04881/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/519b040b63a44d564982227452a64cac5de04881/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=519b040b63a44d564982227452a64cac5de04881", "patch": "@@ -172,7 +172,7 @@ fn generic_extension<'cx>(cx: &'cx mut ExtCtxt<'_>,\n                     path: Cow::from(cx.current_expansion.module.directory.as_path()),\n                     ownership: cx.current_expansion.directory_ownership,\n                 };\n-                let mut p = Parser::new(cx.parse_sess(), tts, Some(directory), true, false);\n+                let mut p = Parser::new(cx.parse_sess(), tts, Some(directory), true, false, None);\n                 p.root_module_name = cx.current_expansion.module.mod_path.last()\n                     .map(|id| id.as_str().to_string());\n "}, {"sha": "4229121b3d0759cdf370a535e66700b1aac43679", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/519b040b63a44d564982227452a64cac5de04881/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/519b040b63a44d564982227452a64cac5de04881/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=519b040b63a44d564982227452a64cac5de04881", "patch": "@@ -31,6 +31,8 @@ pub use rustc_data_structures::thin_vec::ThinVec;\n use ast::AttrId;\n use syntax_pos::edition::Edition;\n \n+const MACRO_ARGUMENTS: Option<&'static str> = Some(\"macro arguments\");\n+\n // A variant of 'try!' that panics on an Err. This is used as a crutch on the\n // way towards a non-panic!-prone parser. It should be used for fatal parsing\n // errors; eventually we plan to convert all code using panictry to just use"}, {"sha": "810acc9cc923e25fc47c38600abceadc881f7818", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 73, "deletions": 2, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/519b040b63a44d564982227452a64cac5de04881/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/519b040b63a44d564982227452a64cac5de04881/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=519b040b63a44d564982227452a64cac5de04881", "patch": "@@ -13,7 +13,7 @@ use crate::symbol::kw;\n use crate::ThinVec;\n use errors::{Applicability, DiagnosticBuilder};\n use log::debug;\n-use syntax_pos::Span;\n+use syntax_pos::{Span, DUMMY_SP};\n \n pub trait RecoverQPath: Sized + 'static {\n     const PATH_STYLE: PathStyle = PathStyle::Expr;\n@@ -201,7 +201,7 @@ impl<'a> Parser<'a> {\n \n         let mut path = ast::Path {\n             segments: Vec::new(),\n-            span: syntax_pos::DUMMY_SP,\n+            span: DUMMY_SP,\n         };\n         self.parse_path_segments(&mut path.segments, T::PATH_STYLE)?;\n         path.span = ty_span.to(self.prev_span);\n@@ -267,6 +267,58 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    /// Create a `DiagnosticBuilder` for an unexpected token `t` and try to recover if it is a\n+    /// closing delimiter.\n+    pub fn unexpected_try_recover(\n+        &mut self,\n+        t: &token::Token,\n+    ) -> PResult<'a, bool /* recovered */> {\n+        let token_str = pprust::token_to_string(t);\n+        let this_token_str = self.this_token_descr();\n+        let (prev_sp, sp) = match (&self.token, self.subparser_name) {\n+            // Point at the end of the macro call when reaching end of macro arguments.\n+            (token::Token::Eof, Some(_)) => {\n+                let sp = self.sess.source_map().next_point(self.span);\n+                (sp, sp)\n+            }\n+            // We don't want to point at the following span after DUMMY_SP.\n+            // This happens when the parser finds an empty TokenStream.\n+            _ if self.prev_span == DUMMY_SP => (self.span, self.span),\n+            // EOF, don't want to point at the following char, but rather the last token.\n+            (token::Token::Eof, None) => (self.prev_span, self.span),\n+            _ => (self.sess.source_map().next_point(self.prev_span), self.span),\n+        };\n+        let msg = format!(\n+            \"expected `{}`, found {}\",\n+            token_str,\n+            match (&self.token, self.subparser_name) {\n+                (token::Token::Eof, Some(origin)) => format!(\"end of {}\", origin),\n+                _ => this_token_str,\n+            },\n+        );\n+        let mut err = self.struct_span_err(sp, &msg);\n+        let label_exp = format!(\"expected `{}`\", token_str);\n+        match self.recover_closing_delimiter(&[t.clone()], err) {\n+            Err(e) => err = e,\n+            Ok(recovered) => {\n+                return Ok(recovered);\n+            }\n+        }\n+        let cm = self.sess.source_map();\n+        match (cm.lookup_line(prev_sp.lo()), cm.lookup_line(sp.lo())) {\n+            (Ok(ref a), Ok(ref b)) if a.line == b.line => {\n+                // When the spans are in the same line, it means that the only content\n+                // between them is whitespace, point only at the found token.\n+                err.span_label(sp, label_exp);\n+            }\n+            _ => {\n+                err.span_label(prev_sp, label_exp);\n+                err.span_label(sp, \"unexpected token\");\n+            }\n+        }\n+        Err(err)\n+    }\n+\n     /// Consume alternative await syntaxes like `await <expr>`, `await? <expr>`, `await(<expr>)`\n     /// and `await { <expr> }`.\n     crate fn parse_incorrect_await_syntax(\n@@ -562,4 +614,23 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    crate fn expected_expression_found(&self) -> DiagnosticBuilder<'a> {\n+        let (span, msg) = match (&self.token, self.subparser_name) {\n+            (&token::Token::Eof, Some(origin)) => {\n+                let sp = self.sess.source_map().next_point(self.span);\n+                (sp, format!(\"expected expression, found end of {}\", origin))\n+            }\n+            _ => (self.span, format!(\n+                \"expected expression, found {}\",\n+                self.this_token_descr(),\n+            )),\n+        };\n+        let mut err = self.struct_span_err(span, &msg);\n+        let sp = self.sess.source_map().start_point(self.span);\n+        if let Some(sp) = self.sess.ambiguous_block_expr_parse.borrow().get(&sp) {\n+            self.sess.expr_parentheses_needed(&mut err, *sp, None);\n+        }\n+        err.span_label(span, \"expected expression\");\n+        err\n+    }\n }"}, {"sha": "f7a7aba9ecbaa1fdf3063012ebc4ed77a3d2b065", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/519b040b63a44d564982227452a64cac5de04881/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/519b040b63a44d564982227452a64cac5de04881/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=519b040b63a44d564982227452a64cac5de04881", "patch": "@@ -236,7 +236,7 @@ fn maybe_source_file_to_parser(\n ) -> Result<Parser<'_>, Vec<Diagnostic>> {\n     let end_pos = source_file.end_pos;\n     let (stream, unclosed_delims) = maybe_file_to_stream(sess, source_file, None)?;\n-    let mut parser = stream_to_parser(sess, stream);\n+    let mut parser = stream_to_parser(sess, stream, None);\n     parser.unclosed_delims = unclosed_delims;\n     if parser.token == token::Eof && parser.span.is_dummy() {\n         parser.span = Span::new(end_pos, end_pos, parser.span.ctxt());\n@@ -248,7 +248,7 @@ fn maybe_source_file_to_parser(\n // must preserve old name for now, because quote! from the *existing*\n // compiler expands into it\n pub fn new_parser_from_tts(sess: &ParseSess, tts: Vec<TokenTree>) -> Parser<'_> {\n-    stream_to_parser(sess, tts.into_iter().collect())\n+    stream_to_parser(sess, tts.into_iter().collect(), crate::MACRO_ARGUMENTS)\n }\n \n \n@@ -328,8 +328,12 @@ pub fn maybe_file_to_stream(\n }\n \n /// Given stream and the `ParseSess`, produces a parser.\n-pub fn stream_to_parser(sess: &ParseSess, stream: TokenStream) -> Parser<'_> {\n-    Parser::new(sess, stream, None, true, false)\n+pub fn stream_to_parser<'a>(\n+    sess: &'a ParseSess,\n+    stream: TokenStream,\n+    subparser_name: Option<&'static str>,\n+) -> Parser<'a> {\n+    Parser::new(sess, stream, None, true, false, subparser_name)\n }\n \n /// Given stream, the `ParseSess` and the base directory, produces a parser.\n@@ -343,10 +347,12 @@ pub fn stream_to_parser(sess: &ParseSess, stream: TokenStream) -> Parser<'_> {\n /// The main usage of this function is outside of rustc, for those who uses\n /// libsyntax as a library. Please do not remove this function while refactoring\n /// just because it is not used in rustc codebase!\n-pub fn stream_to_parser_with_base_dir<'a>(sess: &'a ParseSess,\n-                                          stream: TokenStream,\n-                                          base_dir: Directory<'a>) -> Parser<'a> {\n-    Parser::new(sess, stream, Some(base_dir), true, false)\n+pub fn stream_to_parser_with_base_dir<'a>(\n+    sess: &'a ParseSess,\n+    stream: TokenStream,\n+    base_dir: Directory<'a>,\n+) -> Parser<'a> {\n+    Parser::new(sess, stream, Some(base_dir), true, false, None)\n }\n \n /// A sequence separator."}, {"sha": "56951ae08012a5230d8ddd671c6cc40a7bd80401", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 24, "deletions": 60, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/519b040b63a44d564982227452a64cac5de04881/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/519b040b63a44d564982227452a64cac5de04881/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=519b040b63a44d564982227452a64cac5de04881", "patch": "@@ -51,7 +51,7 @@ use crate::symbol::{kw, sym, Symbol};\n use errors::{Applicability, DiagnosticBuilder, DiagnosticId, FatalError};\n use rustc_target::spec::abi::{self, Abi};\n use syntax_pos::{\n-    Span, MultiSpan, BytePos, FileName,\n+    BytePos, DUMMY_SP, FileName, MultiSpan, Span,\n     hygiene::CompilerDesugaringKind,\n };\n use log::{debug, trace};\n@@ -233,6 +233,8 @@ pub struct Parser<'a> {\n     /// error.\n     crate unclosed_delims: Vec<UnmatchedBrace>,\n     last_unexpected_token_span: Option<Span>,\n+    /// If present, this `Parser` is not parsing Rust code but rather a macro call.\n+    crate subparser_name: Option<&'static str>,\n }\n \n impl<'a> Drop for Parser<'a> {\n@@ -309,7 +311,7 @@ impl TokenCursor {\n                 self.frame = frame;\n                 continue\n             } else {\n-                return TokenAndSpan { tok: token::Eof, sp: syntax_pos::DUMMY_SP }\n+                return TokenAndSpan { tok: token::Eof, sp: DUMMY_SP }\n             };\n \n             match self.frame.last_token {\n@@ -533,17 +535,19 @@ enum TokenExpectType {\n }\n \n impl<'a> Parser<'a> {\n-    pub fn new(sess: &'a ParseSess,\n-               tokens: TokenStream,\n-               directory: Option<Directory<'a>>,\n-               recurse_into_file_modules: bool,\n-               desugar_doc_comments: bool)\n-               -> Self {\n+    pub fn new(\n+        sess: &'a ParseSess,\n+        tokens: TokenStream,\n+        directory: Option<Directory<'a>>,\n+        recurse_into_file_modules: bool,\n+        desugar_doc_comments: bool,\n+        subparser_name: Option<&'static str>,\n+    ) -> Self {\n         let mut parser = Parser {\n             sess,\n             token: token::Whitespace,\n-            span: syntax_pos::DUMMY_SP,\n-            prev_span: syntax_pos::DUMMY_SP,\n+            span: DUMMY_SP,\n+            prev_span: DUMMY_SP,\n             meta_var_span: None,\n             prev_token_kind: PrevTokenKind::Other,\n             restrictions: Restrictions::empty(),\n@@ -568,6 +572,7 @@ impl<'a> Parser<'a> {\n             max_angle_bracket_count: 0,\n             unclosed_delims: Vec::new(),\n             last_unexpected_token_span: None,\n+            subparser_name,\n         };\n \n         let tok = parser.next_tok();\n@@ -631,44 +636,13 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Expects and consumes the token `t`. Signals an error if the next token is not `t`.\n-    pub fn expect(&mut self, t: &token::Token) -> PResult<'a,  bool /* recovered */> {\n+    pub fn expect(&mut self, t: &token::Token) -> PResult<'a, bool /* recovered */> {\n         if self.expected_tokens.is_empty() {\n             if self.token == *t {\n                 self.bump();\n                 Ok(false)\n             } else {\n-                let token_str = pprust::token_to_string(t);\n-                let this_token_str = self.this_token_descr();\n-                let mut err = self.fatal(&format!(\"expected `{}`, found {}\",\n-                                                  token_str,\n-                                                  this_token_str));\n-\n-                let sp = if self.token == token::Token::Eof {\n-                    // EOF, don't want to point at the following char, but rather the last token\n-                    self.prev_span\n-                } else {\n-                    self.sess.source_map().next_point(self.prev_span)\n-                };\n-                let label_exp = format!(\"expected `{}`\", token_str);\n-                match self.recover_closing_delimiter(&[t.clone()], err) {\n-                    Err(e) => err = e,\n-                    Ok(recovered) => {\n-                        return Ok(recovered);\n-                    }\n-                }\n-                let cm = self.sess.source_map();\n-                match (cm.lookup_line(self.span.lo()), cm.lookup_line(sp.lo())) {\n-                    (Ok(ref a), Ok(ref b)) if a.line == b.line => {\n-                        // When the spans are in the same line, it means that the only content\n-                        // between them is whitespace, point only at the found token.\n-                        err.span_label(self.span, label_exp);\n-                    }\n-                    _ => {\n-                        err.span_label(sp, label_exp);\n-                        err.span_label(self.span, \"unexpected token\");\n-                    }\n-                }\n-                Err(err)\n+                self.unexpected_try_recover(t)\n             }\n         } else {\n             self.expect_one_of(slice::from_ref(t), &[])\n@@ -812,7 +786,7 @@ impl<'a> Parser<'a> {\n                     //   |                   expected one of 8 possible tokens here\n                     err.span_label(self.span, label_exp);\n                 }\n-                _ if self.prev_span == syntax_pos::DUMMY_SP => {\n+                _ if self.prev_span == DUMMY_SP => {\n                     // Account for macro context where the previous span might not be\n                     // available to avoid incorrect output (#54841).\n                     err.span_label(self.span, \"unexpected token\");\n@@ -2041,7 +2015,7 @@ impl<'a> Parser<'a> {\n             path = self.parse_path(PathStyle::Type)?;\n             path_span = path_lo.to(self.prev_span);\n         } else {\n-            path = ast::Path { segments: Vec::new(), span: syntax_pos::DUMMY_SP };\n+            path = ast::Path { segments: Vec::new(), span: DUMMY_SP };\n             path_span = self.span.to(self.span);\n         }\n \n@@ -2627,17 +2601,7 @@ impl<'a> Parser<'a> {\n                         }\n                         Err(mut err) => {\n                             self.cancel(&mut err);\n-                            let msg = format!(\"expected expression, found {}\",\n-                                              self.this_token_descr());\n-                            let mut err = self.fatal(&msg);\n-                            let sp = self.sess.source_map().start_point(self.span);\n-                            if let Some(sp) = self.sess.ambiguous_block_expr_parse.borrow()\n-                                .get(&sp)\n-                            {\n-                                self.sess.expr_parentheses_needed(&mut err, *sp, None);\n-                            }\n-                            err.span_label(self.span, \"expected expression\");\n-                            return Err(err);\n+                            return Err(self.expected_expression_found());\n                         }\n                     }\n                 }\n@@ -5592,7 +5556,7 @@ impl<'a> Parser<'a> {\n                 where_clause: WhereClause {\n                     id: ast::DUMMY_NODE_ID,\n                     predicates: Vec::new(),\n-                    span: syntax_pos::DUMMY_SP,\n+                    span: DUMMY_SP,\n                 },\n                 span: span_lo.to(self.prev_span),\n             })\n@@ -5838,7 +5802,7 @@ impl<'a> Parser<'a> {\n         let mut where_clause = WhereClause {\n             id: ast::DUMMY_NODE_ID,\n             predicates: Vec::new(),\n-            span: syntax_pos::DUMMY_SP,\n+            span: DUMMY_SP,\n         };\n \n         if !self.eat_keyword(kw::Where) {\n@@ -7005,15 +6969,15 @@ impl<'a> Parser<'a> {\n                             Ident::with_empty_ctxt(sym::warn_directory_ownership)),\n                         tokens: TokenStream::empty(),\n                         is_sugared_doc: false,\n-                        span: syntax_pos::DUMMY_SP,\n+                        span: DUMMY_SP,\n                     };\n                     attr::mark_known(&attr);\n                     attrs.push(attr);\n                 }\n                 Ok((id, ItemKind::Mod(module), Some(attrs)))\n             } else {\n                 let placeholder = ast::Mod {\n-                    inner: syntax_pos::DUMMY_SP,\n+                    inner: DUMMY_SP,\n                     items: Vec::new(),\n                     inline: false\n                 };"}, {"sha": "704665e0a84d66917d135ad035327988f7a146c7", "filename": "src/libsyntax_ext/asm.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/519b040b63a44d564982227452a64cac5de04881/src%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/519b040b63a44d564982227452a64cac5de04881/src%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fasm.rs?ref=519b040b63a44d564982227452a64cac5de04881", "patch": "@@ -138,7 +138,11 @@ fn parse_inline_asm<'a>(\n                 if p2.token != token::Eof {\n                     let mut extra_tts = p2.parse_all_token_trees()?;\n                     extra_tts.extend(tts[first_colon..].iter().cloned());\n-                    p = parse::stream_to_parser(cx.parse_sess, extra_tts.into_iter().collect());\n+                    p = parse::stream_to_parser(\n+                        cx.parse_sess,\n+                        extra_tts.into_iter().collect(),\n+                        Some(\"inline assembly\"),\n+                    );\n                 }\n \n                 asm = s;"}, {"sha": "975d96951dc5571d54d8090ca80b1362e5ecb44d", "filename": "src/libsyntax_ext/deriving/custom.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/519b040b63a44d564982227452a64cac5de04881/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/519b040b63a44d564982227452a64cac5de04881/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs?ref=519b040b63a44d564982227452a64cac5de04881", "patch": "@@ -89,7 +89,7 @@ impl MultiItemModifier for ProcMacroDerive {\n         let error_count_before = ecx.parse_sess.span_diagnostic.err_count();\n         let msg = \"proc-macro derive produced unparseable tokens\";\n \n-        let mut parser = parse::stream_to_parser(ecx.parse_sess, stream);\n+        let mut parser = parse::stream_to_parser(ecx.parse_sess, stream, Some(\"proc-macro derive\"));\n         let mut items = vec![];\n \n         loop {"}, {"sha": "fd4f93091944cd5af20d48bfad1f05a82f47584d", "filename": "src/test/ui/macros/format-parse-errors.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/519b040b63a44d564982227452a64cac5de04881/src%2Ftest%2Fui%2Fmacros%2Fformat-parse-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/519b040b63a44d564982227452a64cac5de04881/src%2Ftest%2Fui%2Fmacros%2Fformat-parse-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fformat-parse-errors.stderr?ref=519b040b63a44d564982227452a64cac5de04881", "patch": "@@ -12,17 +12,17 @@ error: expected expression, found keyword `struct`\n LL |     format!(struct);\n    |             ^^^^^^ expected expression\n \n-error: expected expression, found `<eof>`\n-  --> $DIR/format-parse-errors.rs:4:23\n+error: expected expression, found end of macro arguments\n+  --> $DIR/format-parse-errors.rs:4:24\n    |\n LL |     format!(\"s\", name =);\n-   |                       ^ expected expression\n+   |                        ^ expected expression\n \n-error: expected `=`, found `<eof>`\n-  --> $DIR/format-parse-errors.rs:5:29\n+error: expected `=`, found end of macro arguments\n+  --> $DIR/format-parse-errors.rs:5:32\n    |\n LL |     format!(\"s\", foo = foo, bar);\n-   |                             ^^^ expected `=`\n+   |                                ^ expected `=`\n \n error: expected expression, found keyword `struct`\n   --> $DIR/format-parse-errors.rs:6:24"}, {"sha": "36cc58f7e268e0b18d8a82a35db869c839fb76e0", "filename": "src/test/ui/malformed/malformed-derive-entry.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/519b040b63a44d564982227452a64cac5de04881/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-derive-entry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/519b040b63a44d564982227452a64cac5de04881/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-derive-entry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-derive-entry.rs?ref=519b040b63a44d564982227452a64cac5de04881", "patch": "@@ -1,17 +1,13 @@\n-#[derive(Copy(Bad))]\n-//~^ ERROR expected one of `)`, `,`, or `::`, found `(`\n+#[derive(Copy(Bad))] //~ ERROR expected one of `)`, `,`, or `::`, found `(`\n struct Test1;\n \n-#[derive(Copy=\"bad\")]\n-//~^ ERROR expected one of `)`, `,`, or `::`, found `=`\n+#[derive(Copy=\"bad\")] //~ ERROR expected one of `)`, `,`, or `::`, found `=`\n struct Test2;\n \n-#[derive()]\n-//~^ WARNING empty trait list\n+#[derive()] //~ WARNING empty trait list\n struct Test3;\n \n-#[derive]\n-//~^ ERROR attribute must be of the form\n+#[derive] //~ ERROR attribute must be of the form `#[derive(Trait1, Trait2, ...)]`\n struct Test4;\n \n fn main() {}"}, {"sha": "0dc18f6811117db2aee44282bec634814a8fcb40", "filename": "src/test/ui/malformed/malformed-derive-entry.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/519b040b63a44d564982227452a64cac5de04881/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-derive-entry.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/519b040b63a44d564982227452a64cac5de04881/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-derive-entry.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-derive-entry.stderr?ref=519b040b63a44d564982227452a64cac5de04881", "patch": "@@ -5,19 +5,19 @@ LL | #[derive(Copy(Bad))]\n    |              ^ expected one of `)`, `,`, or `::` here\n \n error: expected one of `)`, `,`, or `::`, found `=`\n-  --> $DIR/malformed-derive-entry.rs:5:14\n+  --> $DIR/malformed-derive-entry.rs:4:14\n    |\n LL | #[derive(Copy=\"bad\")]\n    |              ^ expected one of `)`, `,`, or `::` here\n \n warning: empty trait list in `derive`\n-  --> $DIR/malformed-derive-entry.rs:9:1\n+  --> $DIR/malformed-derive-entry.rs:7:1\n    |\n LL | #[derive()]\n    | ^^^^^^^^^^^\n \n error: attribute must be of the form `#[derive(Trait1, Trait2, ...)]`\n-  --> $DIR/malformed-derive-entry.rs:13:1\n+  --> $DIR/malformed-derive-entry.rs:10:1\n    |\n LL | #[derive]\n    | ^^^^^^^^^"}, {"sha": "4d00755aea09df5175e75a3b18cbe22f1d42d519", "filename": "src/test/ui/malformed/malformed-special-attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/519b040b63a44d564982227452a64cac5de04881/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-special-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/519b040b63a44d564982227452a64cac5de04881/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-special-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-special-attrs.rs?ref=519b040b63a44d564982227452a64cac5de04881", "patch": "@@ -1,4 +1,4 @@\n-#[cfg_attr] //~ ERROR expected `(`, found `<eof>`\n+#[cfg_attr] //~ ERROR expected `(`, found end of attribute\n struct S1;\n \n #[cfg_attr = \"\"] //~ ERROR expected `(`, found `=`"}, {"sha": "a93f03589e383ce95ab6cbe588715e4d053c98c6", "filename": "src/test/ui/malformed/malformed-special-attrs.stderr", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/519b040b63a44d564982227452a64cac5de04881/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-special-attrs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/519b040b63a44d564982227452a64cac5de04881/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-special-attrs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-special-attrs.stderr?ref=519b040b63a44d564982227452a64cac5de04881", "patch": "@@ -1,13 +1,14 @@\n-error: expected `(`, found `<eof>`\n+error: expected `(`, found end of attribute\n+  --> $DIR/malformed-special-attrs.rs:1:1\n+   |\n+LL | #[cfg_attr]\n+   | ^ expected `(`\n \n error: expected `(`, found `=`\n   --> $DIR/malformed-special-attrs.rs:4:12\n    |\n-LL | #[cfg_attr]\n-   | - expected `(`\n-...\n LL | #[cfg_attr = \"\"]\n-   |            ^ unexpected token\n+   |            ^ expected `(`\n \n error: attribute must be of the form `#[derive(Trait1, Trait2, ...)]`\n   --> $DIR/malformed-special-attrs.rs:7:1"}, {"sha": "4b6d23890653d44637f1694095c9f593451edb48", "filename": "src/test/ui/parser/macro/bad-macro-argument.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/519b040b63a44d564982227452a64cac5de04881/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fbad-macro-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/519b040b63a44d564982227452a64cac5de04881/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fbad-macro-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fbad-macro-argument.rs?ref=519b040b63a44d564982227452a64cac5de04881", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    let message = \"world\";\n+    println!(\"Hello, {}\", message/); //~ ERROR expected expression\n+}"}, {"sha": "3cd8accb662948cc4b5d90ff687c3edcee74058a", "filename": "src/test/ui/parser/macro/bad-macro-argument.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/519b040b63a44d564982227452a64cac5de04881/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fbad-macro-argument.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/519b040b63a44d564982227452a64cac5de04881/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fbad-macro-argument.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fbad-macro-argument.stderr?ref=519b040b63a44d564982227452a64cac5de04881", "patch": "@@ -0,0 +1,8 @@\n+error: expected expression, found end of macro arguments\n+  --> $DIR/bad-macro-argument.rs:3:35\n+   |\n+LL |     println!(\"Hello, {}\", message/);\n+   |                                   ^ expected expression\n+\n+error: aborting due to previous error\n+"}, {"sha": "fab98f0ce5ebe68f1411d3681d994d2049785462", "filename": "src/test/ui/proc-macro/attr-invalid-exprs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/519b040b63a44d564982227452a64cac5de04881/src%2Ftest%2Fui%2Fproc-macro%2Fattr-invalid-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/519b040b63a44d564982227452a64cac5de04881/src%2Ftest%2Fui%2Fproc-macro%2Fattr-invalid-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fattr-invalid-exprs.rs?ref=519b040b63a44d564982227452a64cac5de04881", "patch": "@@ -9,7 +9,7 @@ use attr_stmt_expr::{duplicate, no_output};\n \n fn main() {\n     let _ = #[no_output] \"Hello, world!\";\n-    //~^ ERROR expected expression, found `<eof>`\n+    //~^ ERROR expected expression, found end of macro arguments\n \n     let _ = #[duplicate] \"Hello, world!\";\n     //~^ ERROR macro expansion ignores token `,` and any following"}, {"sha": "49fe0bd0fcfe280cd9e1f9a81c6ed735ca4bdb7a", "filename": "src/test/ui/proc-macro/attr-invalid-exprs.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/519b040b63a44d564982227452a64cac5de04881/src%2Ftest%2Fui%2Fproc-macro%2Fattr-invalid-exprs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/519b040b63a44d564982227452a64cac5de04881/src%2Ftest%2Fui%2Fproc-macro%2Fattr-invalid-exprs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fattr-invalid-exprs.stderr?ref=519b040b63a44d564982227452a64cac5de04881", "patch": "@@ -1,4 +1,4 @@\n-error: expected expression, found `<eof>`\n+error: expected expression, found end of macro arguments\n   --> $DIR/attr-invalid-exprs.rs:11:13\n    |\n LL |     let _ = #[no_output] \"Hello, world!\";"}]}