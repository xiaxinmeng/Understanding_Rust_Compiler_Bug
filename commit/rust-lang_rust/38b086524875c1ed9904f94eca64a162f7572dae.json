{"sha": "38b086524875c1ed9904f94eca64a162f7572dae", "node_id": "C_kwDOAAsO6NoAKDM4YjA4NjUyNDg3NWMxZWQ5OTA0Zjk0ZWNhNjRhMTYyZjc1NzJkYWU", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-09-13T18:48:29Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-10-01T10:08:53Z"}, "message": "Recover wrong cased keywords starting functions", "tree": {"sha": "3e0e4ff517695e84392828ea42276ebaf9952b9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e0e4ff517695e84392828ea42276ebaf9952b9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38b086524875c1ed9904f94eca64a162f7572dae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38b086524875c1ed9904f94eca64a162f7572dae", "html_url": "https://github.com/rust-lang/rust/commit/38b086524875c1ed9904f94eca64a162f7572dae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38b086524875c1ed9904f94eca64a162f7572dae/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3694429d09a2586cea5c769cddee10cd70f39d84", "url": "https://api.github.com/repos/rust-lang/rust/commits/3694429d09a2586cea5c769cddee10cd70f39d84", "html_url": "https://github.com/rust-lang/rust/commit/3694429d09a2586cea5c769cddee10cd70f39d84"}], "stats": {"total": 256, "additions": 205, "deletions": 51}, "files": [{"sha": "3f7e32f4fae6601a284183967a9c90c0268ccf2a", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/38b086524875c1ed9904f94eca64a162f7572dae/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b086524875c1ed9904f94eca64a162f7572dae/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=38b086524875c1ed9904f94eca64a162f7572dae", "patch": "@@ -618,6 +618,15 @@ impl Token {\n         self.is_non_raw_ident_where(|id| id.name == kw)\n     }\n \n+    /// Returns `true` if the token is a given keyword, `kw` or if `case_insensitive` is true and this token is an identifier equal to `kw` ignoring the case.\n+    pub fn is_keyword_case(&self, kw: Symbol, case_insensitive: bool) -> bool {\n+        self.is_keyword(kw)\n+            || (case_insensitive\n+                && self.is_non_raw_ident_where(|id| {\n+                    id.name.as_str().to_lowercase() == kw.as_str().to_lowercase()\n+                }))\n+    }\n+\n     pub fn is_path_segment_keyword(&self) -> bool {\n         self.is_non_raw_ident_where(Ident::is_path_segment_keyword)\n     }"}, {"sha": "e08d09a4d9f3e6a35509695fb483ef69c7c6f231", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38b086524875c1ed9904f94eca64a162f7572dae/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b086524875c1ed9904f94eca64a162f7572dae/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=38b086524875c1ed9904f94eca64a162f7572dae", "patch": "@@ -2024,7 +2024,7 @@ impl<'a> Parser<'a> {\n             if self.eat_keyword(kw::Static) { Movability::Static } else { Movability::Movable };\n \n         let asyncness = if self.token.uninterpolated_span().rust_2018() {\n-            self.parse_asyncness()\n+            self.parse_asyncness(false)\n         } else {\n             Async::No\n         };"}, {"sha": "4e2fc513ac502c4274f9e21f5503306c96fde806", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 42, "deletions": 37, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/38b086524875c1ed9904f94eca64a162f7572dae/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b086524875c1ed9904f94eca64a162f7572dae/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=38b086524875c1ed9904f94eca64a162f7572dae", "patch": "@@ -34,7 +34,7 @@ impl<'a> Parser<'a> {\n \n     /// Parses a `mod <foo> { ... }` or `mod <foo>;` item.\n     fn parse_item_mod(&mut self, attrs: &mut AttrVec) -> PResult<'a, ItemInfo> {\n-        let unsafety = self.parse_unsafety();\n+        let unsafety = self.parse_unsafety(false);\n         self.expect_keyword(kw::Mod)?;\n         let id = self.parse_ident()?;\n         let mod_kind = if self.eat(&token::Semi) {\n@@ -215,14 +215,14 @@ impl<'a> Parser<'a> {\n         kw_case_insensitive: bool,\n     ) -> PResult<'a, Option<ItemInfo>> {\n         let def_final = def == &Defaultness::Final;\n-        let mut def = || mem::replace(def, Defaultness::Final);\n+        let mut def_ = || mem::replace(def, Defaultness::Final);\n \n         let info = if self.eat_keyword_case(kw::Use, kw_case_insensitive) {\n             self.parse_use_item()?\n-        } else if self.check_fn_front_matter(def_final) {\n+        } else if self.check_fn_front_matter(def_final, kw_case_insensitive) {\n             // FUNCTION ITEM\n             let (ident, sig, generics, body) = self.parse_fn(attrs, fn_parse_mode, lo, vis)?;\n-            (ident, ItemKind::Fn(Box::new(Fn { defaultness: def(), sig, generics, body })))\n+            (ident, ItemKind::Fn(Box::new(Fn { defaultness: def_(), sig, generics, body })))\n         } else if self.eat_keyword(kw::Extern) {\n             if self.eat_keyword(kw::Crate) {\n                 // EXTERN CRATE\n@@ -233,7 +233,7 @@ impl<'a> Parser<'a> {\n             }\n         } else if self.is_unsafe_foreign_mod() {\n             // EXTERN BLOCK\n-            let unsafety = self.parse_unsafety();\n+            let unsafety = self.parse_unsafety(false);\n             self.expect_keyword(kw::Extern)?;\n             self.parse_item_foreign_mod(attrs, unsafety)?\n         } else if self.is_static_global() {\n@@ -242,15 +242,15 @@ impl<'a> Parser<'a> {\n             let m = self.parse_mutability();\n             let (ident, ty, expr) = self.parse_item_global(Some(m))?;\n             (ident, ItemKind::Static(ty, m, expr))\n-        } else if let Const::Yes(const_span) = self.parse_constness() {\n+        } else if let Const::Yes(const_span) = self.parse_constness(false) {\n             // CONST ITEM\n             if self.token.is_keyword(kw::Impl) {\n                 // recover from `const impl`, suggest `impl const`\n-                self.recover_const_impl(const_span, attrs, def())?\n+                self.recover_const_impl(const_span, attrs, def_())?\n             } else {\n                 self.recover_const_mut(const_span);\n                 let (ident, ty, expr) = self.parse_item_global(None)?;\n-                (ident, ItemKind::Const(def(), ty, expr))\n+                (ident, ItemKind::Const(def_(), ty, expr))\n             }\n         } else if self.check_keyword(kw::Trait) || self.check_auto_or_unsafe_trait_item() {\n             // TRAIT ITEM\n@@ -259,15 +259,15 @@ impl<'a> Parser<'a> {\n             || self.check_keyword(kw::Unsafe) && self.is_keyword_ahead(1, &[kw::Impl])\n         {\n             // IMPL ITEM\n-            self.parse_item_impl(attrs, def())?\n+            self.parse_item_impl(attrs, def_())?\n         } else if self.check_keyword(kw::Mod)\n             || self.check_keyword(kw::Unsafe) && self.is_keyword_ahead(1, &[kw::Mod])\n         {\n             // MODULE ITEM\n             self.parse_item_mod(attrs)?\n         } else if self.eat_keyword(kw::Type) {\n             // TYPE ITEM\n-            self.parse_type_alias(def())?\n+            self.parse_type_alias(def_())?\n         } else if self.eat_keyword(kw::Enum) {\n             // ENUM ITEM\n             self.parse_item_enum()?\n@@ -295,16 +295,10 @@ impl<'a> Parser<'a> {\n             self.recover_missing_kw_before_item()?;\n             return Ok(None);\n         } else if self.isnt_macro_invocation() && !kw_case_insensitive {\n+            _ = def_;\n+\n             // Recover wrong cased keywords\n-            return self.parse_item_kind(\n-                attrs,\n-                macros_allowed,\n-                lo,\n-                vis,\n-                &mut def(),\n-                fn_parse_mode,\n-                true,\n-            );\n+            return self.parse_item_kind(attrs, macros_allowed, lo, vis, def, fn_parse_mode, true);\n         } else if macros_allowed && self.check_path() {\n             // MACRO INVOCATION ITEM\n             (Ident::empty(), ItemKind::MacCall(P(self.parse_item_macro(vis)?)))\n@@ -557,7 +551,7 @@ impl<'a> Parser<'a> {\n         attrs: &mut AttrVec,\n         defaultness: Defaultness,\n     ) -> PResult<'a, ItemInfo> {\n-        let unsafety = self.parse_unsafety();\n+        let unsafety = self.parse_unsafety(false);\n         self.expect_keyword(kw::Impl)?;\n \n         // First, parse generic parameters if necessary.\n@@ -571,7 +565,7 @@ impl<'a> Parser<'a> {\n             generics\n         };\n \n-        let constness = self.parse_constness();\n+        let constness = self.parse_constness(false);\n         if let Const::Yes(span) = constness {\n             self.sess.gated_spans.gate(sym::const_trait_impl, span);\n         }\n@@ -815,7 +809,7 @@ impl<'a> Parser<'a> {\n \n     /// Parses `unsafe? auto? trait Foo { ... }` or `trait Foo = Bar;`.\n     fn parse_item_trait(&mut self, attrs: &mut AttrVec, lo: Span) -> PResult<'a, ItemInfo> {\n-        let unsafety = self.parse_unsafety();\n+        let unsafety = self.parse_unsafety(false);\n         // Parse optional `auto` prefix.\n         let is_auto = if self.eat_keyword(kw::Auto) { IsAuto::Yes } else { IsAuto::No };\n \n@@ -1764,7 +1758,7 @@ impl<'a> Parser<'a> {\n         let (ident, is_raw) = self.ident_or_err()?;\n         if !is_raw && ident.is_reserved() {\n             let snapshot = self.create_snapshot_for_diagnostic();\n-            let err = if self.check_fn_front_matter(false) {\n+            let err = if self.check_fn_front_matter(false, false) {\n                 let inherited_vis = Visibility {\n                     span: rustc_span::DUMMY_SP,\n                     kind: VisibilityKind::Inherited,\n@@ -2153,7 +2147,11 @@ impl<'a> Parser<'a> {\n     ///\n     /// `check_pub` adds additional `pub` to the checks in case users place it\n     /// wrongly, can be used to ensure `pub` never comes after `default`.\n-    pub(super) fn check_fn_front_matter(&mut self, check_pub: bool) -> bool {\n+    pub(super) fn check_fn_front_matter(\n+        &mut self,\n+        check_pub: bool,\n+        kw_case_insensitive: bool,\n+    ) -> bool {\n         // We use an over-approximation here.\n         // `const const`, `fn const` won't parse, but we're not stepping over other syntax either.\n         // `pub` is added in case users got confused with the ordering like `async pub fn`,\n@@ -2163,23 +2161,30 @@ impl<'a> Parser<'a> {\n         } else {\n             &[kw::Const, kw::Async, kw::Unsafe, kw::Extern]\n         };\n-        self.check_keyword(kw::Fn) // Definitely an `fn`.\n+        self.check_keyword_case(kw::Fn, kw_case_insensitive) // Definitely an `fn`.\n             // `$qual fn` or `$qual $qual`:\n-            || quals.iter().any(|&kw| self.check_keyword(kw))\n+            || quals.iter().any(|&kw| self.check_keyword_case(kw, kw_case_insensitive))\n                 && self.look_ahead(1, |t| {\n                     // `$qual fn`, e.g. `const fn` or `async fn`.\n-                    t.is_keyword(kw::Fn)\n+                    t.is_keyword_case(kw::Fn, kw_case_insensitive)\n                     // Two qualifiers `$qual $qual` is enough, e.g. `async unsafe`.\n-                    || t.is_non_raw_ident_where(|i| quals.contains(&i.name)\n-                        // Rule out 2015 `const async: T = val`.\n-                        && i.is_reserved()\n+                    || (\n+                        (\n+                            t.is_non_raw_ident_where(|i|\n+                                quals.contains(&i.name)\n+                                    // Rule out 2015 `const async: T = val`.\n+                                    && i.is_reserved()\n+                            )\n+                            || kw_case_insensitive\n+                                && t.is_non_raw_ident_where(|i| quals.iter().any(|qual| qual.as_str() == i.name.as_str().to_lowercase()))\n+                        )\n                         // Rule out unsafe extern block.\n                         && !self.is_unsafe_foreign_mod())\n                 })\n             // `extern ABI fn`\n-            || self.check_keyword(kw::Extern)\n+            || self.check_keyword_case(kw::Extern, kw_case_insensitive)\n                 && self.look_ahead(1, |t| t.can_begin_literal_maybe_minus())\n-                && self.look_ahead(2, |t| t.is_keyword(kw::Fn))\n+                && self.look_ahead(2, |t| t.is_keyword_case(kw::Fn, kw_case_insensitive))\n     }\n \n     /// Parses all the \"front matter\" (or \"qualifiers\") for a `fn` declaration,\n@@ -2195,22 +2200,22 @@ impl<'a> Parser<'a> {\n     /// `Visibility::Inherited` when no visibility is known.\n     pub(super) fn parse_fn_front_matter(&mut self, orig_vis: &Visibility) -> PResult<'a, FnHeader> {\n         let sp_start = self.token.span;\n-        let constness = self.parse_constness();\n+        let constness = self.parse_constness(true);\n \n         let async_start_sp = self.token.span;\n-        let asyncness = self.parse_asyncness();\n+        let asyncness = self.parse_asyncness(true);\n \n         let unsafe_start_sp = self.token.span;\n-        let unsafety = self.parse_unsafety();\n+        let unsafety = self.parse_unsafety(true);\n \n         let ext_start_sp = self.token.span;\n-        let ext = self.parse_extern();\n+        let ext = self.parse_extern(true);\n \n         if let Async::Yes { span, .. } = asyncness {\n             self.ban_async_in_2015(span);\n         }\n \n-        if !self.eat_keyword(kw::Fn) {\n+        if !self.eat_keyword_case(kw::Fn, true) {\n             // It is possible for `expect_one_of` to recover given the contents of\n             // `self.expected_tokens`, therefore, do not use `self.unexpected()` which doesn't\n             // account for this."}, {"sha": "073c51ac120f6a6169d540b4e5b59213efe5816d", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 22, "deletions": 8, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/38b086524875c1ed9904f94eca64a162f7572dae/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b086524875c1ed9904f94eca64a162f7572dae/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=38b086524875c1ed9904f94eca64a162f7572dae", "patch": "@@ -604,6 +604,20 @@ impl<'a> Parser<'a> {\n         self.token.is_keyword(kw)\n     }\n \n+    fn check_keyword_case(&mut self, kw: Symbol, case_insensitive: bool) -> bool {\n+        if self.check_keyword(kw) {\n+            return true;\n+        }\n+\n+        if case_insensitive\n+        && let Some((ident, /* is_raw */ false)) = self.token.ident()\n+        && ident.as_str().to_lowercase() == kw.as_str().to_lowercase() {\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n     /// If the next token is the given keyword, eats it and returns `true`.\n     /// Otherwise, returns `false`. An expectation is also added for diagnostics purposes.\n     // Public for rustfmt usage.\n@@ -1122,8 +1136,8 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses asyncness: `async` or nothing.\n-    fn parse_asyncness(&mut self) -> Async {\n-        if self.eat_keyword(kw::Async) {\n+    fn parse_asyncness(&mut self, case_insensitive: bool) -> Async {\n+        if self.eat_keyword_case(kw::Async, case_insensitive) {\n             let span = self.prev_token.uninterpolated_span();\n             Async::Yes { span, closure_id: DUMMY_NODE_ID, return_impl_trait_id: DUMMY_NODE_ID }\n         } else {\n@@ -1132,19 +1146,19 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses unsafety: `unsafe` or nothing.\n-    fn parse_unsafety(&mut self) -> Unsafe {\n-        if self.eat_keyword(kw::Unsafe) {\n+    fn parse_unsafety(&mut self, case_insensitive: bool) -> Unsafe {\n+        if self.eat_keyword_case(kw::Unsafe, case_insensitive) {\n             Unsafe::Yes(self.prev_token.uninterpolated_span())\n         } else {\n             Unsafe::No\n         }\n     }\n \n     /// Parses constness: `const` or nothing.\n-    fn parse_constness(&mut self) -> Const {\n+    fn parse_constness(&mut self, case_insensitive: bool) -> Const {\n         // Avoid const blocks to be parsed as const items\n         if self.look_ahead(1, |t| t != &token::OpenDelim(Delimiter::Brace))\n-            && self.eat_keyword(kw::Const)\n+            && self.eat_keyword_case(kw::Const, case_insensitive)\n         {\n             Const::Yes(self.prev_token.uninterpolated_span())\n         } else {\n@@ -1399,8 +1413,8 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses `extern string_literal?`.\n-    fn parse_extern(&mut self) -> Extern {\n-        if self.eat_keyword(kw::Extern) {\n+    fn parse_extern(&mut self, case_insensitive: bool) -> Extern {\n+        if self.eat_keyword_case(kw::Extern, case_insensitive) {\n             let mut extern_span = self.prev_token.span;\n             let abi = self.parse_abi();\n             if let Some(abi) = abi {"}, {"sha": "984e303e577ec366bd7cd3d1a3b4d7f24288e048", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38b086524875c1ed9904f94eca64a162f7572dae/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b086524875c1ed9904f94eca64a162f7572dae/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=38b086524875c1ed9904f94eca64a162f7572dae", "patch": "@@ -267,15 +267,15 @@ impl<'a> Parser<'a> {\n         } else if self.eat_keyword(kw::Underscore) {\n             // A type to be inferred `_`\n             TyKind::Infer\n-        } else if self.check_fn_front_matter(false) {\n+        } else if self.check_fn_front_matter(false, false) {\n             // Function pointer type\n             self.parse_ty_bare_fn(lo, Vec::new(), recover_return_sign)?\n         } else if self.check_keyword(kw::For) {\n             // Function pointer type or bound list (trait object type) starting with a poly-trait.\n             //   `for<'lt> [unsafe] [extern \"ABI\"] fn (&'lt S) -> T`\n             //   `for<'lt> Trait1<'lt> + Trait2 + 'a`\n             let lifetime_defs = self.parse_late_bound_lifetime_defs()?;\n-            if self.check_fn_front_matter(false) {\n+            if self.check_fn_front_matter(false, false) {\n                 self.parse_ty_bare_fn(lo, lifetime_defs, recover_return_sign)?\n             } else {\n                 let path = self.parse_path(PathStyle::Type)?;"}, {"sha": "1794268f260e12969d9eb3f7cf937b1d31529c68", "filename": "src/test/ui/parser/item-kw-case-mismatch.fixed", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/38b086524875c1ed9904f94eca64a162f7572dae/src%2Ftest%2Fui%2Fparser%2Fitem-kw-case-mismatch.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/38b086524875c1ed9904f94eca64a162f7572dae/src%2Ftest%2Fui%2Fparser%2Fitem-kw-case-mismatch.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fitem-kw-case-mismatch.fixed?ref=38b086524875c1ed9904f94eca64a162f7572dae", "patch": "@@ -1,7 +1,34 @@\n // run-rustfix\n+// edition:2018\n #![allow(unused_imports)]\n \n fn main() {}\n \n use std::ptr::read;  //~ ERROR keyword `use` is written in a wrong case\n use std::ptr::write; //~ ERROR keyword `use` is written in a wrong case\n+\n+async fn _a() {}\n+//~^ ERROR keyword `fn` is written in a wrong case\n+\n+fn _b() {}\n+//~^ ERROR keyword `fn` is written in a wrong case\n+\n+async fn _c() {}\n+//~^ ERROR keyword `async` is written in a wrong case\n+//~| ERROR keyword `fn` is written in a wrong case\n+\n+async fn _d() {}\n+//~^ ERROR keyword `async` is written in a wrong case\n+\n+const unsafe fn _e() {}\n+//~^ ERROR keyword `const` is written in a wrong case\n+//~| ERROR keyword `unsafe` is written in a wrong case\n+//~| ERROR keyword `fn` is written in a wrong case\n+\n+unsafe extern fn _f() {}\n+//~^ ERROR keyword `unsafe` is written in a wrong case\n+//~| ERROR keyword `extern` is written in a wrong case\n+\n+extern \"C\" fn _g() {}\n+//~^ ERROR keyword `extern` is written in a wrong case\n+//~| ERROR keyword `fn` is written in a wrong case"}, {"sha": "ac8390efdb9a3f7f47ca25c855adc7d9e601c7f8", "filename": "src/test/ui/parser/item-kw-case-mismatch.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/38b086524875c1ed9904f94eca64a162f7572dae/src%2Ftest%2Fui%2Fparser%2Fitem-kw-case-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b086524875c1ed9904f94eca64a162f7572dae/src%2Ftest%2Fui%2Fparser%2Fitem-kw-case-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fitem-kw-case-mismatch.rs?ref=38b086524875c1ed9904f94eca64a162f7572dae", "patch": "@@ -1,7 +1,34 @@\n // run-rustfix\n+// edition:2018\n #![allow(unused_imports)]\n \n fn main() {}\n \n Use std::ptr::read;  //~ ERROR keyword `use` is written in a wrong case\n USE std::ptr::write; //~ ERROR keyword `use` is written in a wrong case\n+\n+async Fn _a() {}\n+//~^ ERROR keyword `fn` is written in a wrong case\n+\n+Fn _b() {}\n+//~^ ERROR keyword `fn` is written in a wrong case\n+\n+aSYNC fN _c() {}\n+//~^ ERROR keyword `async` is written in a wrong case\n+//~| ERROR keyword `fn` is written in a wrong case\n+\n+Async fn _d() {}\n+//~^ ERROR keyword `async` is written in a wrong case\n+\n+CONST UNSAFE FN _e() {}\n+//~^ ERROR keyword `const` is written in a wrong case\n+//~| ERROR keyword `unsafe` is written in a wrong case\n+//~| ERROR keyword `fn` is written in a wrong case\n+\n+unSAFE EXTern fn _f() {}\n+//~^ ERROR keyword `unsafe` is written in a wrong case\n+//~| ERROR keyword `extern` is written in a wrong case\n+\n+EXTERN \"C\" FN _g() {}\n+//~^ ERROR keyword `extern` is written in a wrong case\n+//~| ERROR keyword `fn` is written in a wrong case"}, {"sha": "e66dae825f9c43696e7d15a3761a4441f160e58f", "filename": "src/test/ui/parser/item-kw-case-mismatch.stderr", "status": "modified", "additions": 75, "deletions": 3, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/38b086524875c1ed9904f94eca64a162f7572dae/src%2Ftest%2Fui%2Fparser%2Fitem-kw-case-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/38b086524875c1ed9904f94eca64a162f7572dae/src%2Ftest%2Fui%2Fparser%2Fitem-kw-case-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fitem-kw-case-mismatch.stderr?ref=38b086524875c1ed9904f94eca64a162f7572dae", "patch": "@@ -1,14 +1,86 @@\n error: keyword `use` is written in a wrong case\n-  --> $DIR/item-kw-case-mismatch.rs:6:1\n+  --> $DIR/item-kw-case-mismatch.rs:7:1\n    |\n LL | Use std::ptr::read;\n    | ^^^ help: write it in the correct case (notice the capitalization): `use`\n \n error: keyword `use` is written in a wrong case\n-  --> $DIR/item-kw-case-mismatch.rs:7:1\n+  --> $DIR/item-kw-case-mismatch.rs:8:1\n    |\n LL | USE std::ptr::write;\n    | ^^^ help: write it in the correct case: `use`\n \n-error: aborting due to 2 previous errors\n+error: keyword `fn` is written in a wrong case\n+  --> $DIR/item-kw-case-mismatch.rs:10:7\n+   |\n+LL | async Fn _a() {}\n+   |       ^^ help: write it in the correct case (notice the capitalization): `fn`\n+\n+error: keyword `fn` is written in a wrong case\n+  --> $DIR/item-kw-case-mismatch.rs:13:1\n+   |\n+LL | Fn _b() {}\n+   | ^^ help: write it in the correct case (notice the capitalization): `fn`\n+\n+error: keyword `async` is written in a wrong case\n+  --> $DIR/item-kw-case-mismatch.rs:16:1\n+   |\n+LL | aSYNC fN _c() {}\n+   | ^^^^^ help: write it in the correct case: `async`\n+\n+error: keyword `fn` is written in a wrong case\n+  --> $DIR/item-kw-case-mismatch.rs:16:7\n+   |\n+LL | aSYNC fN _c() {}\n+   |       ^^ help: write it in the correct case: `fn`\n+\n+error: keyword `async` is written in a wrong case\n+  --> $DIR/item-kw-case-mismatch.rs:20:1\n+   |\n+LL | Async fn _d() {}\n+   | ^^^^^ help: write it in the correct case: `async`\n+\n+error: keyword `const` is written in a wrong case\n+  --> $DIR/item-kw-case-mismatch.rs:23:1\n+   |\n+LL | CONST UNSAFE FN _e() {}\n+   | ^^^^^ help: write it in the correct case: `const`\n+\n+error: keyword `unsafe` is written in a wrong case\n+  --> $DIR/item-kw-case-mismatch.rs:23:7\n+   |\n+LL | CONST UNSAFE FN _e() {}\n+   |       ^^^^^^ help: write it in the correct case: `unsafe`\n+\n+error: keyword `fn` is written in a wrong case\n+  --> $DIR/item-kw-case-mismatch.rs:23:14\n+   |\n+LL | CONST UNSAFE FN _e() {}\n+   |              ^^ help: write it in the correct case: `fn`\n+\n+error: keyword `unsafe` is written in a wrong case\n+  --> $DIR/item-kw-case-mismatch.rs:28:1\n+   |\n+LL | unSAFE EXTern fn _f() {}\n+   | ^^^^^^ help: write it in the correct case: `unsafe`\n+\n+error: keyword `extern` is written in a wrong case\n+  --> $DIR/item-kw-case-mismatch.rs:28:8\n+   |\n+LL | unSAFE EXTern fn _f() {}\n+   |        ^^^^^^ help: write it in the correct case: `extern`\n+\n+error: keyword `extern` is written in a wrong case\n+  --> $DIR/item-kw-case-mismatch.rs:32:1\n+   |\n+LL | EXTERN \"C\" FN _g() {}\n+   | ^^^^^^ help: write it in the correct case: `extern`\n+\n+error: keyword `fn` is written in a wrong case\n+  --> $DIR/item-kw-case-mismatch.rs:32:12\n+   |\n+LL | EXTERN \"C\" FN _g() {}\n+   |            ^^ help: write it in the correct case: `fn`\n+\n+error: aborting due to 14 previous errors\n "}]}