{"sha": "e31e8b117699a24d7758a4ec42799bf7922813c3", "node_id": "C_kwDOAAsO6NoAKGUzMWU4YjExNzY5OWEyNGQ3NzU4YTRlYzQyNzk5YmY3OTIyODEzYzM", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-12-27T07:57:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-12-27T07:57:48Z"}, "message": "Rollup merge of #106150 - estebank:issue-39232, r=compiler-errors\n\nDetect when method call on LHS might be shadowed\n\nAddress #39232.", "tree": {"sha": "9742d21b64310dbe2145fa33fa39cded7446192c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9742d21b64310dbe2145fa33fa39cded7446192c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e31e8b117699a24d7758a4ec42799bf7922813c3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjqqV8CRBK7hj4Ov3rIwAAOl8IAI37HPrMFraQTAjeZy+qxsm9\nknQ30tkQOKVn89ofo6WpGLR2dr9efiMIp1bP8U82LsshCBQ19NqvJ40NjzhIj5wI\noKH7NJcHtuXMh0JXTYwFXTC9nxs+19+L7iGbU10N2J5PqeGLBy10poUdRr0Jyqr9\nU1VrqsIaH+yGSW30n96VuMiNDEBmJGwsAALzY8s4/JcFlO8yOG5fLdNmnILmDt9q\n7ejtaVoA5wZrlfnFoeNgja6YXnNcvUdmcB5TZ9jqwVSaXPhKcMFHEE/K4lEBhy7/\nxHIDgNEgjUceYhoMWVtSK2XP3VPfItRevhHe5IgytPIOrhh7df3HHYZQ6pY7Uok=\n=HqSD\n-----END PGP SIGNATURE-----\n", "payload": "tree 9742d21b64310dbe2145fa33fa39cded7446192c\nparent bb08f37a1c086697b12aeca43e0f78bc665719da\nparent 2cc22cee968b008d81aeb05ba2bf93ec5dcd7177\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1672127868 +0100\ncommitter GitHub <noreply@github.com> 1672127868 +0100\n\nRollup merge of #106150 - estebank:issue-39232, r=compiler-errors\n\nDetect when method call on LHS might be shadowed\n\nAddress #39232.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e31e8b117699a24d7758a4ec42799bf7922813c3", "html_url": "https://github.com/rust-lang/rust/commit/e31e8b117699a24d7758a4ec42799bf7922813c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e31e8b117699a24d7758a4ec42799bf7922813c3/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb08f37a1c086697b12aeca43e0f78bc665719da", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb08f37a1c086697b12aeca43e0f78bc665719da", "html_url": "https://github.com/rust-lang/rust/commit/bb08f37a1c086697b12aeca43e0f78bc665719da"}, {"sha": "2cc22cee968b008d81aeb05ba2bf93ec5dcd7177", "url": "https://api.github.com/repos/rust-lang/rust/commits/2cc22cee968b008d81aeb05ba2bf93ec5dcd7177", "html_url": "https://github.com/rust-lang/rust/commit/2cc22cee968b008d81aeb05ba2bf93ec5dcd7177"}], "stats": {"total": 295, "additions": 289, "deletions": 6}, "files": [{"sha": "0335c45a946d55322d9fa2f52521a499442fe241", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 160, "deletions": 1, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/e31e8b117699a24d7758a4ec42799bf7922813c3/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e31e8b117699a24d7758a4ec42799bf7922813c3/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=e31e8b117699a24d7758a4ec42799bf7922813c3", "patch": "@@ -1,5 +1,6 @@\n use crate::FnCtxt;\n use rustc_ast::util::parser::PREC_POSTFIX;\n+use rustc_errors::MultiSpan;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_hir::def::CtorKind;\n@@ -30,12 +31,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n         expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n-        _error: Option<TypeError<'tcx>>,\n+        error: Option<TypeError<'tcx>>,\n     ) {\n         if expr_ty == expected {\n             return;\n         }\n \n+        self.annotate_alternative_method_deref(err, expr, error);\n+\n         // Use `||` to give these suggestions a precedence\n         let _ = self.suggest_missing_parentheses(err, expr)\n             || self.suggest_remove_last_method_call(err, expr, expected)\n@@ -316,6 +319,162 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    fn annotate_alternative_method_deref(\n+        &self,\n+        err: &mut Diagnostic,\n+        expr: &hir::Expr<'_>,\n+        error: Option<TypeError<'tcx>>,\n+    ) {\n+        let parent = self.tcx.hir().get_parent_node(expr.hir_id);\n+        let Some(TypeError::Sorts(ExpectedFound { expected, .. })) = error else {return;};\n+        let Some(hir::Node::Expr(hir::Expr {\n+                    kind: hir::ExprKind::Assign(lhs, rhs, _), ..\n+                })) = self.tcx.hir().find(parent) else {return; };\n+        if rhs.hir_id != expr.hir_id || expected.is_closure() {\n+            return;\n+        }\n+        let hir::ExprKind::Unary(hir::UnOp::Deref, deref) = lhs.kind else { return; };\n+        let hir::ExprKind::MethodCall(path, base, args, _) = deref.kind else { return; };\n+        let Some(self_ty) = self.typeck_results.borrow().expr_ty_adjusted_opt(base) else { return; };\n+\n+        let Ok(pick) = self\n+            .probe_for_name(\n+                probe::Mode::MethodCall,\n+                path.ident,\n+                probe::IsSuggestion(true),\n+                self_ty,\n+                deref.hir_id,\n+                probe::ProbeScope::TraitsInScope,\n+            ) else {\n+                return;\n+            };\n+        let in_scope_methods = self.probe_for_name_many(\n+            probe::Mode::MethodCall,\n+            path.ident,\n+            probe::IsSuggestion(true),\n+            self_ty,\n+            deref.hir_id,\n+            probe::ProbeScope::TraitsInScope,\n+        );\n+        let other_methods_in_scope: Vec<_> =\n+            in_scope_methods.iter().filter(|c| c.item.def_id != pick.item.def_id).collect();\n+\n+        let all_methods = self.probe_for_name_many(\n+            probe::Mode::MethodCall,\n+            path.ident,\n+            probe::IsSuggestion(true),\n+            self_ty,\n+            deref.hir_id,\n+            probe::ProbeScope::AllTraits,\n+        );\n+        let suggestions: Vec<_> = all_methods\n+            .into_iter()\n+            .filter(|c| c.item.def_id != pick.item.def_id)\n+            .map(|c| {\n+                let m = c.item;\n+                let substs = ty::InternalSubsts::for_item(self.tcx, m.def_id, |param, _| {\n+                    self.var_for_def(deref.span, param)\n+                });\n+                vec![\n+                    (\n+                        deref.span.until(base.span),\n+                        format!(\n+                            \"{}({}\",\n+                            with_no_trimmed_paths!(\n+                                self.tcx.def_path_str_with_substs(m.def_id, substs,)\n+                            ),\n+                            match self.tcx.fn_sig(m.def_id).input(0).skip_binder().kind() {\n+                                ty::Ref(_, _, hir::Mutability::Mut) => \"&mut \",\n+                                ty::Ref(_, _, _) => \"&\",\n+                                _ => \"\",\n+                            },\n+                        ),\n+                    ),\n+                    match &args[..] {\n+                        [] => (base.span.shrink_to_hi().with_hi(deref.span.hi()), \")\".to_string()),\n+                        [first, ..] => (base.span.between(first.span), \", \".to_string()),\n+                    },\n+                ]\n+            })\n+            .collect();\n+        if suggestions.is_empty() {\n+            return;\n+        }\n+        let mut path_span: MultiSpan = path.ident.span.into();\n+        path_span.push_span_label(\n+            path.ident.span,\n+            with_no_trimmed_paths!(format!(\n+                \"refers to `{}`\",\n+                self.tcx.def_path_str(pick.item.def_id),\n+            )),\n+        );\n+        let container_id = pick.item.container_id(self.tcx);\n+        let container = with_no_trimmed_paths!(self.tcx.def_path_str(container_id));\n+        for def_id in pick.import_ids {\n+            let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n+            path_span.push_span_label(\n+                self.tcx.hir().span(hir_id),\n+                format!(\"`{container}` imported here\"),\n+            );\n+        }\n+        let tail = with_no_trimmed_paths!(match &other_methods_in_scope[..] {\n+            [] => return,\n+            [candidate] => format!(\n+                \"the method of the same name on {} `{}`\",\n+                match candidate.kind {\n+                    probe::CandidateKind::InherentImplCandidate(..) => \"the inherent impl for\",\n+                    _ => \"trait\",\n+                },\n+                self.tcx.def_path_str(candidate.item.container_id(self.tcx))\n+            ),\n+            [.., last] if other_methods_in_scope.len() < 5 => {\n+                format!(\n+                    \"the methods of the same name on {} and `{}`\",\n+                    other_methods_in_scope[..other_methods_in_scope.len() - 1]\n+                        .iter()\n+                        .map(|c| format!(\n+                            \"`{}`\",\n+                            self.tcx.def_path_str(c.item.container_id(self.tcx))\n+                        ))\n+                        .collect::<Vec<String>>()\n+                        .join(\", \"),\n+                    self.tcx.def_path_str(last.item.container_id(self.tcx))\n+                )\n+            }\n+            _ => format!(\n+                \"the methods of the same name on {} other traits\",\n+                other_methods_in_scope.len()\n+            ),\n+        });\n+        err.span_note(\n+            path_span,\n+            &format!(\n+                \"the `{}` call is resolved to the method in `{container}`, shadowing {tail}\",\n+                path.ident,\n+            ),\n+        );\n+        if suggestions.len() > other_methods_in_scope.len() {\n+            err.note(&format!(\n+                \"additionally, there are {} other available methods that aren't in scope\",\n+                suggestions.len() - other_methods_in_scope.len()\n+            ));\n+        }\n+        err.multipart_suggestions(\n+            &format!(\n+                \"you might have meant to call {}; you can use the fully-qualified path to call {} \\\n+                 explicitly\",\n+                if suggestions.len() == 1 {\n+                    \"the other method\"\n+                } else {\n+                    \"one of the other methods\"\n+                },\n+                if suggestions.len() == 1 { \"it\" } else { \"one of them\" },\n+            ),\n+            suggestions,\n+            Applicability::MaybeIncorrect,\n+        );\n+    }\n+\n     /// If the expected type is an enum (Issue #55250) with any variants whose\n     /// sole field is of the found type, suggest such variants. (Issue #42764)\n     fn suggest_compatible_variants("}, {"sha": "6b3fa664d9c5a9d0badbe66b9445dd9d737dfac9", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e31e8b117699a24d7758a4ec42799bf7922813c3/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e31e8b117699a24d7758a4ec42799bf7922813c3/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=e31e8b117699a24d7758a4ec42799bf7922813c3", "patch": "@@ -97,7 +97,7 @@ impl<'a, 'tcx> Deref for ProbeContext<'a, 'tcx> {\n }\n \n #[derive(Debug, Clone)]\n-struct Candidate<'tcx> {\n+pub(crate) struct Candidate<'tcx> {\n     // Candidates are (I'm not quite sure, but they are mostly) basically\n     // some metadata on top of a `ty::AssocItem` (without substs).\n     //\n@@ -131,13 +131,13 @@ struct Candidate<'tcx> {\n     // if `T: Sized`.\n     xform_self_ty: Ty<'tcx>,\n     xform_ret_ty: Option<Ty<'tcx>>,\n-    item: ty::AssocItem,\n-    kind: CandidateKind<'tcx>,\n-    import_ids: SmallVec<[LocalDefId; 1]>,\n+    pub(crate) item: ty::AssocItem,\n+    pub(crate) kind: CandidateKind<'tcx>,\n+    pub(crate) import_ids: SmallVec<[LocalDefId; 1]>,\n }\n \n #[derive(Debug, Clone)]\n-enum CandidateKind<'tcx> {\n+pub(crate) enum CandidateKind<'tcx> {\n     InherentImplCandidate(\n         SubstsRef<'tcx>,\n         // Normalize obligations\n@@ -322,6 +322,36 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         )\n     }\n \n+    #[instrument(level = \"debug\", skip(self))]\n+    pub(crate) fn probe_for_name_many(\n+        &self,\n+        mode: Mode,\n+        item_name: Ident,\n+        is_suggestion: IsSuggestion,\n+        self_ty: Ty<'tcx>,\n+        scope_expr_id: hir::HirId,\n+        scope: ProbeScope,\n+    ) -> Vec<Candidate<'tcx>> {\n+        self.probe_op(\n+            item_name.span,\n+            mode,\n+            Some(item_name),\n+            None,\n+            is_suggestion,\n+            self_ty,\n+            scope_expr_id,\n+            scope,\n+            |probe_cx| {\n+                Ok(probe_cx\n+                    .inherent_candidates\n+                    .into_iter()\n+                    .chain(probe_cx.extension_candidates)\n+                    .collect())\n+            },\n+        )\n+        .unwrap()\n+    }\n+\n     fn probe_op<OP, R>(\n         &'a self,\n         span: Span,"}, {"sha": "dab99fbacd9e681b59e7eb97427bd0f4fca3f743", "filename": "src/test/ui/suggestions/shadowed-lplace-method-2.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e31e8b117699a24d7758a4ec42799bf7922813c3/src%2Ftest%2Fui%2Fsuggestions%2Fshadowed-lplace-method-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e31e8b117699a24d7758a4ec42799bf7922813c3/src%2Ftest%2Fui%2Fsuggestions%2Fshadowed-lplace-method-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fshadowed-lplace-method-2.rs?ref=e31e8b117699a24d7758a4ec42799bf7922813c3", "patch": "@@ -0,0 +1,23 @@\n+#![allow(unused)]\n+\n+struct X {\n+    x: (),\n+}\n+pub trait A {\n+    fn foo(&mut self, _: usize) -> &mut ();\n+}\n+impl A for X {\n+    fn foo(&mut self, _: usize) -> &mut () {\n+        &mut self.x\n+    }\n+}\n+impl X {\n+    fn foo(&mut self, _: usize) -> &mut Self {\n+        self\n+    }\n+}\n+\n+fn main() {\n+    let mut x = X { x: () };\n+    *x.foo(0) = (); //~ ERROR E0308\n+}"}, {"sha": "94eef15f3306e90af451340d92e1dee0b2b0b47e", "filename": "src/test/ui/suggestions/shadowed-lplace-method-2.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e31e8b117699a24d7758a4ec42799bf7922813c3/src%2Ftest%2Fui%2Fsuggestions%2Fshadowed-lplace-method-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e31e8b117699a24d7758a4ec42799bf7922813c3/src%2Ftest%2Fui%2Fsuggestions%2Fshadowed-lplace-method-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fshadowed-lplace-method-2.stderr?ref=e31e8b117699a24d7758a4ec42799bf7922813c3", "patch": "@@ -0,0 +1,25 @@\n+error[E0308]: mismatched types\n+  --> $DIR/shadowed-lplace-method-2.rs:22:17\n+   |\n+LL |     *x.foo(0) = ();\n+   |     ---------   ^^ expected struct `X`, found `()`\n+   |     |\n+   |     expected due to the type of this binding\n+   |\n+note: the `foo` call is resolved to the method in `X`, shadowing the method of the same name on trait `A`\n+  --> $DIR/shadowed-lplace-method-2.rs:22:8\n+   |\n+LL |     *x.foo(0) = ();\n+   |        ^^^ refers to `X::foo`\n+help: you might have meant to call the other method; you can use the fully-qualified path to call it explicitly\n+   |\n+LL |     *<_ as A>::foo(&mut x, 0) = ();\n+   |      ++++++++++++++++++  ~\n+help: try wrapping the expression in `X`\n+   |\n+LL |     *x.foo(0) = X { x: () };\n+   |                 ++++++    +\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "740ac77ee0c675d7fc7257dce53f4932e5947986", "filename": "src/test/ui/suggestions/shadowed-lplace-method.fixed", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e31e8b117699a24d7758a4ec42799bf7922813c3/src%2Ftest%2Fui%2Fsuggestions%2Fshadowed-lplace-method.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/e31e8b117699a24d7758a4ec42799bf7922813c3/src%2Ftest%2Fui%2Fsuggestions%2Fshadowed-lplace-method.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fshadowed-lplace-method.fixed?ref=e31e8b117699a24d7758a4ec42799bf7922813c3", "patch": "@@ -0,0 +1,10 @@\n+// run-rustfix\n+#![allow(unused_imports)]\n+use std::borrow::BorrowMut;\n+use std::cell::RefCell;\n+use std::rc::Rc;\n+\n+fn main() {\n+    let rc = Rc::new(RefCell::new(true));\n+    *std::cell::RefCell::<_>::borrow_mut(&rc) = false; //~ ERROR E0308\n+}"}, {"sha": "6bf12879e6f28dcc5c5c354b7917b78f9a083854", "filename": "src/test/ui/suggestions/shadowed-lplace-method.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e31e8b117699a24d7758a4ec42799bf7922813c3/src%2Ftest%2Fui%2Fsuggestions%2Fshadowed-lplace-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e31e8b117699a24d7758a4ec42799bf7922813c3/src%2Ftest%2Fui%2Fsuggestions%2Fshadowed-lplace-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fshadowed-lplace-method.rs?ref=e31e8b117699a24d7758a4ec42799bf7922813c3", "patch": "@@ -0,0 +1,10 @@\n+// run-rustfix\n+#![allow(unused_imports)]\n+use std::borrow::BorrowMut;\n+use std::cell::RefCell;\n+use std::rc::Rc;\n+\n+fn main() {\n+    let rc = Rc::new(RefCell::new(true));\n+    *rc.borrow_mut() = false; //~ ERROR E0308\n+}"}, {"sha": "91d0d1200d4362bd3ddae84fd9c8d2b2a3d657b5", "filename": "src/test/ui/suggestions/shadowed-lplace-method.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e31e8b117699a24d7758a4ec42799bf7922813c3/src%2Ftest%2Fui%2Fsuggestions%2Fshadowed-lplace-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e31e8b117699a24d7758a4ec42799bf7922813c3/src%2Ftest%2Fui%2Fsuggestions%2Fshadowed-lplace-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fshadowed-lplace-method.stderr?ref=e31e8b117699a24d7758a4ec42799bf7922813c3", "patch": "@@ -0,0 +1,26 @@\n+error[E0308]: mismatched types\n+  --> $DIR/shadowed-lplace-method.rs:9:24\n+   |\n+LL |     *rc.borrow_mut() = false;\n+   |     ----------------   ^^^^^ expected struct `Rc`, found `bool`\n+   |     |\n+   |     expected due to the type of this binding\n+   |\n+   = note: expected struct `Rc<RefCell<bool>>`\n+                found type `bool`\n+note: the `borrow_mut` call is resolved to the method in `std::borrow::BorrowMut`, shadowing the method of the same name on the inherent impl for `std::cell::RefCell<T>`\n+  --> $DIR/shadowed-lplace-method.rs:9:9\n+   |\n+LL | use std::borrow::BorrowMut;\n+   |     ---------------------- `std::borrow::BorrowMut` imported here\n+...\n+LL |     *rc.borrow_mut() = false;\n+   |         ^^^^^^^^^^ refers to `std::borrow::BorrowMut::borrow_mut`\n+help: you might have meant to call the other method; you can use the fully-qualified path to call it explicitly\n+   |\n+LL |     *std::cell::RefCell::<_>::borrow_mut(&rc) = false;\n+   |      +++++++++++++++++++++++++++++++++++++  ~\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}]}