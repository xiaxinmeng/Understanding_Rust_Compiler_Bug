{"sha": "2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmMWJjOTE4MDNiMDRjYWYzZTIwYjM4NDk2MzNiYjdmZmU2YjQwNzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-04T07:40:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-04T07:40:13Z"}, "message": "Auto merge of #60537 - Centril:rollup-42jxz82, r=Centril\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #60429 (Account for paths in incorrect pub qualifier help)\n - #60449 (Constrain all regions in the concrete type for an opaque type)\n - #60486 (Place related refactors)\n - #60513 (Remove -Z borrowck=compare flag)\n - #60516 (Remove TypeckMir)\n - #60517 (Reword casting message)\n - #60520 (Add rustfmt toml)\n - #60521 (Migrate tidy to rust 2018 edition)\n - #60527 (Fix async fn lowering ICE with APIT.)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "0fe4a4b339119c497a066dca4c9229b3cbde56d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0fe4a4b339119c497a066dca4c9229b3cbde56d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "html_url": "https://github.com/rust-lang/rust/commit/2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2326366935613816927e679d3b2dc04db44678c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2326366935613816927e679d3b2dc04db44678c", "html_url": "https://github.com/rust-lang/rust/commit/e2326366935613816927e679d3b2dc04db44678c"}, {"sha": "1599877c7e246dc7e7cca4830734bde7d93a3c1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/1599877c7e246dc7e7cca4830734bde7d93a3c1b", "html_url": "https://github.com/rust-lang/rust/commit/1599877c7e246dc7e7cca4830734bde7d93a3c1b"}], "stats": {"total": 1662, "additions": 562, "deletions": 1100}, "files": [{"sha": "df230cde9b7130a94e69f4e15f2cdd4d40bf5430", "filename": "rustfmt.toml", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/rustfmt.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/rustfmt.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt.toml?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -0,0 +1,6 @@\n+# Currently, most of the code in the compiler uses historical style.\n+#\n+# For new code, consider running rustfmt with this config (it should\n+# be picked up automatically).\n+version = \"Two\"\n+use_small_heuristics = \"Max\""}, {"sha": "7f1352095d936ab334d6145349e0735aaec76cdb", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -92,10 +92,12 @@ impl<'a> DefCollector<'a> {\n             visit::walk_generics(this, generics);\n \n             // Walk the generated arguments for the `async fn`.\n-            for a in arguments {\n+            for (i, a) in arguments.iter().enumerate() {\n                 use visit::Visitor;\n                 if let Some(arg) = &a.arg {\n                     this.visit_ty(&arg.ty);\n+                } else {\n+                    this.visit_ty(&decl.inputs[i].ty);\n                 }\n             }\n "}, {"sha": "2044e5ddae90e1c4fcbb93094e14f3bc3cb4a696", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -97,9 +97,8 @@ impl SuppressRegionErrors {\n             // If we're on Migrate mode, report AST region errors\n             BorrowckMode::Migrate => SuppressRegionErrors { suppressed: false },\n \n-            // If we're on MIR or Compare mode, don't report AST region errors as they should\n-            // be reported by NLL\n-            BorrowckMode::Compare | BorrowckMode::Mir => SuppressRegionErrors { suppressed: true },\n+            // If we're on MIR, don't report AST region errors as they should be reported by NLL\n+            BorrowckMode::Mir => SuppressRegionErrors { suppressed: true },\n         }\n     }\n }"}, {"sha": "f85fd524a5d9bd7f35eafaaccb4d42d0fd62b717", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 84, "deletions": 57, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -1,13 +1,14 @@\n+use rustc_data_structures::fx::FxHashMap;\n+use syntax_pos::Span;\n+\n use crate::hir::def_id::DefId;\n use crate::hir;\n use crate::hir::Node;\n use crate::infer::{self, InferCtxt, InferOk, TypeVariableOrigin};\n use crate::infer::outlives::free_region_map::FreeRegionRelations;\n-use rustc_data_structures::fx::FxHashMap;\n use crate::traits::{self, PredicateObligation};\n use crate::ty::{self, Ty, TyCtxt, GenericParamDefKind};\n-use crate::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder};\n-use crate::ty::outlives::Component;\n+use crate::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder, TypeVisitor};\n use crate::ty::subst::{Kind, InternalSubsts, SubstsRef, UnpackedKind};\n use crate::util::nodemap::DefIdMap;\n \n@@ -373,58 +374,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let least_region = least_region.unwrap_or(self.tcx.lifetimes.re_static);\n         debug!(\"constrain_opaque_types: least_region={:?}\", least_region);\n \n-        // Require that the type `concrete_ty` outlives\n-        // `least_region`, modulo any type parameters that appear\n-        // in the type, which we ignore. This is because impl\n-        // trait values are assumed to capture all the in-scope\n-        // type parameters. This little loop here just invokes\n-        // `outlives` repeatedly, draining all the nested\n-        // obligations that result.\n-        let mut types = vec![concrete_ty];\n-        let bound_region = |r| self.sub_regions(infer::CallReturn(span), least_region, r);\n-        while let Some(ty) = types.pop() {\n-            let mut components = smallvec![];\n-            self.tcx.push_outlives_components(ty, &mut components);\n-            while let Some(component) = components.pop() {\n-                match component {\n-                    Component::Region(r) => {\n-                        bound_region(r);\n-                    }\n-\n-                    Component::Param(_) => {\n-                        // ignore type parameters like `T`, they are captured\n-                        // implicitly by the `impl Trait`\n-                    }\n-\n-                    Component::UnresolvedInferenceVariable(_) => {\n-                        // we should get an error that more type\n-                        // annotations are needed in this case\n-                        self.tcx\n-                            .sess\n-                            .delay_span_bug(span, \"unresolved inf var in opaque\");\n-                    }\n-\n-                    Component::Projection(ty::ProjectionTy {\n-                        substs,\n-                        item_def_id: _,\n-                    }) => {\n-                        for k in substs {\n-                            match k.unpack() {\n-                                UnpackedKind::Lifetime(lt) => bound_region(lt),\n-                                UnpackedKind::Type(ty) => types.push(ty),\n-                                UnpackedKind::Const(_) => {\n-                                    // Const parameters don't impose constraints.\n-                                }\n-                            }\n-                        }\n-                    }\n-\n-                    Component::EscapingProjection(more_components) => {\n-                        components.extend(more_components);\n-                    }\n-                }\n-            }\n-        }\n+        concrete_ty.visit_with(&mut OpaqueTypeOutlivesVisitor {\n+            infcx: self,\n+            least_region,\n+            span,\n+        });\n     }\n \n     /// Given the fully resolved, instantiated type for an opaque\n@@ -502,6 +456,80 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n+// Visitor that requires that (almost) all regions in the type visited outlive\n+// `least_region`. We cannot use `push_outlives_components` because regions in\n+// closure signatures are not included in their outlives components. We need to\n+// ensure all regions outlive the given bound so that we don't end up with,\n+// say, `ReScope` appearing in a return type and causing ICEs when other\n+// functions end up with region constraints involving regions from other\n+// functions.\n+//\n+// We also cannot use `for_each_free_region` because for closures it includes\n+// the regions parameters from the enclosing item.\n+//\n+// We ignore any type parameters because impl trait values are assumed to\n+// capture all the in-scope type parameters.\n+struct OpaqueTypeOutlivesVisitor<'a, 'gcx, 'tcx> {\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    least_region: ty::Region<'tcx>,\n+    span: Span,\n+}\n+\n+impl<'tcx> TypeVisitor<'tcx> for OpaqueTypeOutlivesVisitor<'_, '_, 'tcx>\n+{\n+    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> bool {\n+        t.skip_binder().visit_with(self);\n+        false // keep visiting\n+    }\n+\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n+        match *r {\n+            // ignore bound regions, keep visiting\n+            ty::ReLateBound(_, _) => false,\n+            _ => {\n+                self.infcx.sub_regions(infer::CallReturn(self.span), self.least_region, r);\n+                false\n+            }\n+        }\n+    }\n+\n+    fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+        // We're only interested in types involving regions\n+        if !ty.flags.intersects(ty::TypeFlags::HAS_FREE_REGIONS) {\n+            return false; // keep visiting\n+        }\n+\n+        match ty.sty {\n+            ty::Closure(def_id, ref substs) => {\n+                // Skip lifetime parameters of the enclosing item(s)\n+\n+                for upvar_ty in substs.upvar_tys(def_id, self.infcx.tcx) {\n+                    upvar_ty.visit_with(self);\n+                }\n+\n+                substs.closure_sig_ty(def_id, self.infcx.tcx).visit_with(self);\n+            }\n+\n+            ty::Generator(def_id, ref substs, _) => {\n+                // Skip lifetime parameters of the enclosing item(s)\n+                // Also skip the witness type, because that has no free regions.\n+\n+                for upvar_ty in substs.upvar_tys(def_id, self.infcx.tcx) {\n+                    upvar_ty.visit_with(self);\n+                }\n+\n+                substs.return_ty(def_id, self.infcx.tcx).visit_with(self);\n+                substs.yield_ty(def_id, self.infcx.tcx).visit_with(self);\n+            }\n+            _ => {\n+                ty.super_visit_with(self);\n+            }\n+        }\n+\n+        false\n+    }\n+}\n+\n struct ReverseMapper<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n \n@@ -563,8 +591,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for ReverseMapper<'cx, 'gcx, 'tcx>\n             // ignore `'static`, as that can appear anywhere\n             ty::ReStatic |\n \n-            // ignore `ReScope`, as that can appear anywhere\n-            // See `src/test/run-pass/issue-49556.rs` for example.\n+            // ignore `ReScope`, which may appear in impl Trait in bindings.\n             ty::ReScope(..) => return r,\n \n             _ => { }"}, {"sha": "09e2b523fae838e4e146e4538d54cbb2c15216ca", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -2059,10 +2059,13 @@ impl<'tcx> Place<'tcx> {\n \n     /// Finds the innermost `Local` from this `Place`.\n     pub fn base_local(&self) -> Option<Local> {\n-        match self {\n-            Place::Base(PlaceBase::Local(local)) => Some(*local),\n-            Place::Projection(box Projection { base, elem: _ }) => base.base_local(),\n-            Place::Base(PlaceBase::Static(..)) => None,\n+        let mut place = self;\n+        loop {\n+            match place {\n+                Place::Projection(proj) => place = &proj.base,\n+                Place::Base(PlaceBase::Static(_)) => return None,\n+                Place::Base(PlaceBase::Local(local)) => return Some(*local),\n+            }\n         }\n     }\n "}, {"sha": "ad80e5d74bd2a4b02523f1ab414376e7208f1438", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -462,7 +462,6 @@ pub enum PrintRequest {\n #[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub enum BorrowckMode {\n     Mir,\n-    Compare,\n     Migrate,\n }\n \n@@ -471,7 +470,6 @@ impl BorrowckMode {\n     /// on the AST borrow check if the MIR-based one errors.\n     pub fn migrate(self) -> bool {\n         match self {\n-            BorrowckMode::Compare => false,\n             BorrowckMode::Mir => false,\n             BorrowckMode::Migrate => true,\n         }\n@@ -480,7 +478,6 @@ impl BorrowckMode {\n     /// Should we emit the AST-based borrow checker errors?\n     pub fn use_ast(self) -> bool {\n         match self {\n-            BorrowckMode::Compare => true,\n             BorrowckMode::Mir => false,\n             BorrowckMode::Migrate => false,\n         }\n@@ -1214,7 +1211,7 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n     identify_regions: bool = (false, parse_bool, [UNTRACKED],\n         \"make unnamed regions display as '# (where # is some non-ident unique id)\"),\n     borrowck: Option<String> = (None, parse_opt_string, [UNTRACKED],\n-        \"select which borrowck is used (`ast`, `mir`, `migrate`, or `compare`)\"),\n+        \"select which borrowck is used (`mir` or `migrate`)\"),\n     time_passes: bool = (false, parse_bool, [UNTRACKED],\n         \"measure time of each rustc pass\"),\n     time: bool = (false, parse_bool, [UNTRACKED],\n@@ -2315,7 +2312,6 @@ pub fn build_session_options_and_crate_config(\n     let borrowck_mode = match debugging_opts.borrowck.as_ref().map(|s| &s[..]) {\n         None | Some(\"migrate\") => BorrowckMode::Migrate,\n         Some(\"mir\") => BorrowckMode::Mir,\n-        Some(\"compare\") => BorrowckMode::Compare,\n         Some(m) => early_error(error_format, &format!(\"unknown borrowck mode `{}`\", m)),\n     };\n "}, {"sha": "5ced497baa1fdf9f3938e620a4d5eea93988dbd8", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -210,7 +210,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'gcx, 'tcx> {\n \n             self.insert_as_pending_if_two_phase(location, &assigned_place, kind, idx);\n \n-            if let Some(local) = borrowed_place.root_local() {\n+            if let Some(local) = borrowed_place.base_local() {\n                 self.local_map.entry(local).or_default().insert(idx);\n             }\n         }"}, {"sha": "fc1f5eb5d5a7a45a85db4fbf4d5a55a3a3216ae8", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -1831,7 +1831,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     }\n \n                     place = base;\n-                    continue;\n                 }\n             }\n         }"}, {"sha": "58a164b38f9119e0f221d4f4f914d7208561eeb4", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -47,11 +47,10 @@ pub(super) fn generate<'gcx, 'tcx>(\n         mir.local_decls.indices().collect()\n     } else {\n         let free_regions = {\n-            let borrowck_context = typeck.borrowck_context.as_ref().unwrap();\n             regions_that_outlive_free_regions(\n                 typeck.infcx.num_region_vars(),\n-                &borrowck_context.universal_regions,\n-                &borrowck_context.constraints.outlives_constraints,\n+                &typeck.borrowck_context.universal_regions,\n+                &typeck.borrowck_context.constraints.outlives_constraints,\n             )\n         };\n         compute_live_locals(typeck.tcx(), &free_regions, mir)"}, {"sha": "87e9a704fac1e60d26d5fe9b02d2a488cb2dce60", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/trace.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -517,16 +517,15 @@ impl LivenessContext<'_, '_, '_, '_, 'tcx> {\n \n         let tcx = typeck.tcx();\n         tcx.for_each_free_region(&value, |live_region| {\n-            let borrowck_context = typeck.borrowck_context.as_mut().unwrap();\n-            let live_region_vid = borrowck_context\n+            let live_region_vid = typeck.borrowck_context\n                 .universal_regions\n                 .to_region_vid(live_region);\n-            borrowck_context\n+            typeck.borrowck_context\n                 .constraints\n                 .liveness_constraints\n                 .add_elements(live_region_vid, live_at);\n \n-            if let Some(facts) = borrowck_context.all_facts {\n+            if let Some(facts) = typeck.borrowck_context.all_facts {\n                 for point in live_at.iter() {\n                     let loc = elements.to_location(point);\n                     facts.region_live_at.push((live_region_vid, location_table.start_index(loc)));"}, {"sha": "4589e4ef036a42628f7e85da9cf973557e277c4e", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 124, "deletions": 181, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -20,7 +20,6 @@ use crate::borrow_check::nll::ToRegionVid;\n use crate::dataflow::move_paths::MoveData;\n use crate::dataflow::FlowAtLocation;\n use crate::dataflow::MaybeInitializedPlaces;\n-use crate::transform::{MirPass, MirSource};\n use either::Either;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n@@ -159,16 +158,14 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n         param_env,\n         mir,\n         &region_bound_pairs,\n-        Some(implicit_region_bound),\n-        Some(&mut borrowck_context),\n-        Some(&universal_region_relations),\n-        |cx| {\n+        implicit_region_bound,\n+        &mut borrowck_context,\n+        &universal_region_relations,\n+        |mut cx| {\n             cx.equate_inputs_and_outputs(mir, universal_regions, &normalized_inputs_and_output);\n-            liveness::generate(cx, mir, elements, flow_inits, move_data, location_table);\n+            liveness::generate(&mut cx, mir, elements, flow_inits, move_data, location_table);\n \n-            cx.borrowck_context\n-                .as_mut()\n-                .map(|bcx| translate_outlives_facts(bcx));\n+            translate_outlives_facts(cx.borrowck_context);\n         },\n     );\n \n@@ -184,9 +181,9 @@ fn type_check_internal<'a, 'gcx, 'tcx, R>(\n     param_env: ty::ParamEnv<'gcx>,\n     mir: &'a Mir<'tcx>,\n     region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n-    implicit_region_bound: Option<ty::Region<'tcx>>,\n-    borrowck_context: Option<&'a mut BorrowCheckContext<'a, 'tcx>>,\n-    universal_region_relations: Option<&'a UniversalRegionRelations<'tcx>>,\n+    implicit_region_bound: ty::Region<'tcx>,\n+    borrowck_context: &'a mut BorrowCheckContext<'a, 'tcx>,\n+    universal_region_relations: &'a UniversalRegionRelations<'tcx>,\n     mut extra: impl FnMut(&mut TypeChecker<'a, 'gcx, 'tcx>) -> R,\n ) -> R where {\n     let mut checker = TypeChecker::new(\n@@ -548,15 +545,19 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         let all_facts = &mut None;\n         let mut constraints = Default::default();\n         let mut closure_bounds = Default::default();\n-        if let Some(ref mut bcx) = self.cx.borrowck_context {\n-            // Don't try to add borrow_region facts for the promoted MIR\n-            mem::swap(bcx.all_facts, all_facts);\n-\n-            // Use a new sets of constraints and closure bounds so that we can\n-            // modify their locations.\n-            mem::swap(&mut bcx.constraints.outlives_constraints, &mut constraints);\n-            mem::swap(&mut bcx.constraints.closure_bounds_mapping, &mut closure_bounds);\n-        };\n+        // Don't try to add borrow_region facts for the promoted MIR\n+        mem::swap(self.cx.borrowck_context.all_facts, all_facts);\n+\n+        // Use a new sets of constraints and closure bounds so that we can\n+        // modify their locations.\n+        mem::swap(\n+            &mut self.cx.borrowck_context.constraints.outlives_constraints,\n+            &mut constraints\n+        );\n+        mem::swap(\n+            &mut self.cx.borrowck_context.constraints.closure_bounds_mapping,\n+            &mut closure_bounds\n+        );\n \n         self.visit_mir(promoted_mir);\n \n@@ -567,40 +568,44 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n \n         self.mir = parent_mir;\n         // Merge the outlives constraints back in, at the given location.\n-        if let Some(ref mut base_bcx) = self.cx.borrowck_context {\n-            mem::swap(base_bcx.all_facts, all_facts);\n-            mem::swap(&mut base_bcx.constraints.outlives_constraints, &mut constraints);\n-            mem::swap(&mut base_bcx.constraints.closure_bounds_mapping, &mut closure_bounds);\n-\n-            let locations = location.to_locations();\n-            for constraint in constraints.iter() {\n-                let mut constraint = *constraint;\n-                constraint.locations = locations;\n-                if let ConstraintCategory::Return\n-                    | ConstraintCategory::UseAsConst\n-                    | ConstraintCategory::UseAsStatic = constraint.category\n-                {\n-                    // \"Returning\" from a promoted is an assigment to a\n-                    // temporary from the user's point of view.\n-                    constraint.category = ConstraintCategory::Boring;\n-                }\n-                base_bcx.constraints.outlives_constraints.push(constraint)\n-            }\n+        mem::swap(self.cx.borrowck_context.all_facts, all_facts);\n+        mem::swap(\n+            &mut self.cx.borrowck_context.constraints.outlives_constraints,\n+            &mut constraints\n+        );\n+        mem::swap(\n+            &mut self.cx.borrowck_context.constraints.closure_bounds_mapping,\n+            &mut closure_bounds\n+        );\n \n-            if !closure_bounds.is_empty() {\n-                let combined_bounds_mapping = closure_bounds\n-                    .into_iter()\n-                    .flat_map(|(_, value)| value)\n-                    .collect();\n-                let existing = base_bcx\n-                    .constraints\n-                    .closure_bounds_mapping\n-                    .insert(location, combined_bounds_mapping);\n-                assert!(\n-                    existing.is_none(),\n-                    \"Multiple promoteds/closures at the same location.\"\n-                );\n+        let locations = location.to_locations();\n+        for constraint in constraints.iter() {\n+            let mut constraint = *constraint;\n+            constraint.locations = locations;\n+            if let ConstraintCategory::Return\n+                | ConstraintCategory::UseAsConst\n+                | ConstraintCategory::UseAsStatic = constraint.category\n+            {\n+                // \"Returning\" from a promoted is an assigment to a\n+                // temporary from the user's point of view.\n+                constraint.category = ConstraintCategory::Boring;\n             }\n+            self.cx.borrowck_context.constraints.outlives_constraints.push(constraint)\n+        }\n+\n+        if !closure_bounds.is_empty() {\n+            let combined_bounds_mapping = closure_bounds\n+                .into_iter()\n+                .flat_map(|(_, value)| value)\n+                .collect();\n+            let existing = self.cx.borrowck_context\n+                .constraints\n+                .closure_bounds_mapping\n+                .insert(location, combined_bounds_mapping);\n+            assert!(\n+                existing.is_none(),\n+                \"Multiple promoteds/closures at the same location.\"\n+            );\n         }\n     }\n \n@@ -831,10 +836,10 @@ struct TypeChecker<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     user_type_annotations: &'a CanonicalUserTypeAnnotations<'tcx>,\n     mir_def_id: DefId,\n     region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n-    implicit_region_bound: Option<ty::Region<'tcx>>,\n+    implicit_region_bound: ty::Region<'tcx>,\n     reported_errors: FxHashSet<(Ty<'tcx>, Span)>,\n-    borrowck_context: Option<&'a mut BorrowCheckContext<'a, 'tcx>>,\n-    universal_region_relations: Option<&'a UniversalRegionRelations<'tcx>>,\n+    borrowck_context: &'a mut BorrowCheckContext<'a, 'tcx>,\n+    universal_region_relations: &'a UniversalRegionRelations<'tcx>,\n }\n \n struct BorrowCheckContext<'a, 'tcx: 'a> {\n@@ -976,9 +981,9 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         mir_def_id: DefId,\n         param_env: ty::ParamEnv<'gcx>,\n         region_bound_pairs: &'a RegionBoundPairs<'tcx>,\n-        implicit_region_bound: Option<ty::Region<'tcx>>,\n-        borrowck_context: Option<&'a mut BorrowCheckContext<'a, 'tcx>>,\n-        universal_region_relations: Option<&'a UniversalRegionRelations<'tcx>>,\n+        implicit_region_bound: ty::Region<'tcx>,\n+        borrowck_context: &'a mut BorrowCheckContext<'a, 'tcx>,\n+        universal_region_relations: &'a UniversalRegionRelations<'tcx>,\n     ) -> Self {\n         let mut checker = Self {\n             infcx,\n@@ -1092,18 +1097,16 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             locations, data\n         );\n \n-        if let Some(ref mut borrowck_context) = self.borrowck_context {\n-            constraint_conversion::ConstraintConversion::new(\n-                self.infcx,\n-                borrowck_context.universal_regions,\n-                self.region_bound_pairs,\n-                self.implicit_region_bound,\n-                self.param_env,\n-                locations,\n-                category,\n-                &mut borrowck_context.constraints,\n-            ).convert_all(&data);\n-        }\n+        constraint_conversion::ConstraintConversion::new(\n+            self.infcx,\n+            self.borrowck_context.universal_regions,\n+            self.region_bound_pairs,\n+            Some(self.implicit_region_bound),\n+            self.param_env,\n+            locations,\n+            category,\n+            &mut self.borrowck_context.constraints,\n+        ).convert_all(&data);\n     }\n \n     /// Convenient wrapper around `relate_tys::relate_types` -- see\n@@ -1123,7 +1126,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             b,\n             locations,\n             category,\n-            self.borrowck_context.as_mut().map(|x| &mut **x),\n+            Some(self.borrowck_context),\n         )\n     }\n \n@@ -1276,10 +1279,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             ),\n         )?;\n \n-        let universal_region_relations = match self.universal_region_relations {\n-            Some(rel) => rel,\n-            None => return Ok(()),\n-        };\n+        let universal_region_relations = self.universal_region_relations;\n \n         // Finally, if we instantiated the anon types successfully, we\n         // have to solve any bounds (e.g., `-> impl Iterator` needs to\n@@ -1324,14 +1324,14 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 // of lowering. Assignments to other sorts of places *are* interesting\n                 // though.\n                 let category = match *place {\n-                    Place::Base(PlaceBase::Local(RETURN_PLACE)) => if let Some(BorrowCheckContext {\n+                    Place::Base(PlaceBase::Local(RETURN_PLACE)) => if let BorrowCheckContext {\n                         universal_regions:\n                             UniversalRegions {\n                                 defining_ty: DefiningTy::Const(def_id, _),\n                                 ..\n                             },\n                         ..\n-                    }) = self.borrowck_context\n+                    } = self.borrowck_context\n                     {\n                         if tcx.is_static(*def_id) {\n                             ConstraintCategory::UseAsStatic\n@@ -1559,15 +1559,13 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 // output) types in the signature must be live, since\n                 // all the inputs that fed into it were live.\n                 for &late_bound_region in map.values() {\n-                    if let Some(ref mut borrowck_context) = self.borrowck_context {\n-                        let region_vid = borrowck_context\n-                            .universal_regions\n-                            .to_region_vid(late_bound_region);\n-                        borrowck_context\n-                            .constraints\n-                            .liveness_constraints\n-                            .add_element(region_vid, term_location);\n-                    }\n+                    let region_vid = self.borrowck_context\n+                        .universal_regions\n+                        .to_region_vid(late_bound_region);\n+                    self.borrowck_context\n+                        .constraints\n+                        .liveness_constraints\n+                        .add_element(region_vid, term_location);\n                 }\n \n                 self.check_call_inputs(mir, term, &sig, args, term_location, from_hir_call);\n@@ -1629,14 +1627,14 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 let dest_ty = dest.ty(mir, tcx).ty;\n                 let category = match *dest {\n                     Place::Base(PlaceBase::Local(RETURN_PLACE)) => {\n-                        if let Some(BorrowCheckContext {\n+                        if let BorrowCheckContext {\n                             universal_regions:\n                                 UniversalRegions {\n                                     defining_ty: DefiningTy::Const(def_id, _),\n                                     ..\n                                 },\n                             ..\n-                        }) = self.borrowck_context\n+                        } = self.borrowck_context\n                         {\n                             if tcx.is_static(*def_id) {\n                                 ConstraintCategory::UseAsStatic\n@@ -2343,10 +2341,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             all_facts,\n             constraints,\n             ..\n-        } = match self.borrowck_context {\n-            Some(ref mut borrowck_context) => borrowck_context,\n-            None => return,\n-        };\n+        } = self.borrowck_context;\n \n         // In Polonius mode, we also push a `borrow_region` fact\n         // linking the loan to the region (in some cases, though,\n@@ -2512,45 +2507,43 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             let closure_constraints =\n                 closure_region_requirements.apply_requirements(tcx, def_id, substs);\n \n-            if let Some(ref mut borrowck_context) = self.borrowck_context {\n-                let bounds_mapping = closure_constraints\n-                    .iter()\n-                    .enumerate()\n-                    .filter_map(|(idx, constraint)| {\n-                        let ty::OutlivesPredicate(k1, r2) =\n-                            constraint.no_bound_vars().unwrap_or_else(|| {\n-                                bug!(\"query_constraint {:?} contained bound vars\", constraint,);\n-                            });\n-\n-                        match k1.unpack() {\n-                            UnpackedKind::Lifetime(r1) => {\n-                                // constraint is r1: r2\n-                                let r1_vid = borrowck_context.universal_regions.to_region_vid(r1);\n-                                let r2_vid = borrowck_context.universal_regions.to_region_vid(r2);\n-                                let outlives_requirements =\n-                                    &closure_region_requirements.outlives_requirements[idx];\n-                                Some((\n-                                    (r1_vid, r2_vid),\n-                                    (\n-                                        outlives_requirements.category,\n-                                        outlives_requirements.blame_span,\n-                                    ),\n-                                ))\n-                            }\n-                            UnpackedKind::Type(_) | UnpackedKind::Const(_) => None,\n+            let bounds_mapping = closure_constraints\n+                .iter()\n+                .enumerate()\n+                .filter_map(|(idx, constraint)| {\n+                    let ty::OutlivesPredicate(k1, r2) =\n+                        constraint.no_bound_vars().unwrap_or_else(|| {\n+                            bug!(\"query_constraint {:?} contained bound vars\", constraint,);\n+                        });\n+\n+                    match k1.unpack() {\n+                        UnpackedKind::Lifetime(r1) => {\n+                            // constraint is r1: r2\n+                            let r1_vid = self.borrowck_context.universal_regions.to_region_vid(r1);\n+                            let r2_vid = self.borrowck_context.universal_regions.to_region_vid(r2);\n+                            let outlives_requirements =\n+                                &closure_region_requirements.outlives_requirements[idx];\n+                            Some((\n+                                (r1_vid, r2_vid),\n+                                (\n+                                    outlives_requirements.category,\n+                                    outlives_requirements.blame_span,\n+                                ),\n+                            ))\n                         }\n-                    })\n-                    .collect();\n-\n-                let existing = borrowck_context\n-                    .constraints\n-                    .closure_bounds_mapping\n-                    .insert(location, bounds_mapping);\n-                assert!(\n-                    existing.is_none(),\n-                    \"Multiple closures at the same location.\"\n-                );\n-            }\n+                        UnpackedKind::Type(_) | UnpackedKind::Const(_) => None,\n+                    }\n+                })\n+                .collect();\n+\n+            let existing = self.borrowck_context\n+                .constraints\n+                .closure_bounds_mapping\n+                .insert(location, bounds_mapping);\n+            assert!(\n+                existing.is_none(),\n+                \"Multiple closures at the same location.\"\n+            );\n \n             self.push_region_constraints(\n                 location.to_locations(),\n@@ -2668,56 +2661,6 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     }\n }\n \n-pub struct TypeckMir;\n-\n-impl MirPass for TypeckMir {\n-    fn run_pass<'a, 'tcx>(\n-        &self,\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        src: MirSource<'tcx>,\n-        mir: &mut Mir<'tcx>,\n-    ) {\n-        let def_id = src.def_id();\n-        debug!(\"run_pass: {:?}\", def_id);\n-\n-        // FIXME: We don't need this MIR pass anymore.\n-        if true {\n-            return;\n-        }\n-\n-        if tcx.sess.err_count() > 0 {\n-            // compiling a broken program can obviously result in a\n-            // broken MIR, so try not to report duplicate errors.\n-            return;\n-        }\n-\n-        if tcx.is_constructor(def_id) {\n-            // We just assume that the automatically generated struct/variant constructors are\n-            // correct. See the comment in the `mir_borrowck` implementation for an\n-            // explanation why we need this.\n-            return;\n-        }\n-\n-        let param_env = tcx.param_env(def_id);\n-        tcx.infer_ctxt().enter(|infcx| {\n-            type_check_internal(\n-                &infcx,\n-                def_id,\n-                param_env,\n-                mir,\n-                &vec![],\n-                None,\n-                None,\n-                None,\n-                |_| (),\n-            );\n-\n-            // For verification purposes, we just ignore the resulting\n-            // region constraint sets. Not our problem. =)\n-        });\n-    }\n-}\n-\n trait NormalizeLocation: fmt::Debug + Copy {\n     fn to_locations(self) -> Locations;\n }"}, {"sha": "cf9a6165d71a249159c6e28d500523f0cd5eb7ad", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -1,6 +1,6 @@\n use rustc::hir;\n use rustc::mir::ProjectionElem;\n-use rustc::mir::{Local, Mir, Place, PlaceBase, Mutability, Static, StaticKind};\n+use rustc::mir::{Mir, Place, PlaceBase, Mutability, Static, StaticKind};\n use rustc::ty::{self, TyCtxt};\n use crate::borrow_check::borrow_set::LocalsStateAtExit;\n \n@@ -16,10 +16,6 @@ crate trait PlaceExt<'tcx> {\n         mir: &Mir<'tcx>,\n         locals_state_at_exit: &LocalsStateAtExit,\n         ) -> bool;\n-\n-    /// If this is a place like `x.f.g`, returns the local\n-    /// `x`. Returns `None` if this is based in a static.\n-    fn root_local(&self) -> Option<Local>;\n }\n \n impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n@@ -82,15 +78,4 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n             },\n         }\n     }\n-\n-    fn root_local(&self) -> Option<Local> {\n-        let mut p = self;\n-        loop {\n-            match p {\n-                Place::Projection(pi) => p = &pi.base,\n-                Place::Base(PlaceBase::Static(_)) => return None,\n-                Place::Base(PlaceBase::Local(l)) => return Some(*l),\n-            }\n-        }\n-    }\n }"}, {"sha": "b6091644157178fd55a450481d4bb41fdb8a54cd", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -1,4 +1,3 @@\n-use crate::borrow_check::nll::type_check;\n use crate::build;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::mir::{Mir, MirPhase, Promoted};\n@@ -205,7 +204,6 @@ fn mir_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx Stea\n     run_passes(tcx, &mut mir, InstanceDef::Item(def_id), MirPhase::Const, &[\n         // What we need to do constant evaluation.\n         &simplify::SimplifyCfg::new(\"initial\"),\n-        &type_check::TypeckMir,\n         &rustc_peek::SanityCheck,\n         &uniform_array_move_out::UniformArrayMoveOut,\n     ]);"}, {"sha": "4563c9f18a3e4fa41dbb353bd826a1476485342d", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 4, "deletions": 20, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -12,26 +12,10 @@ pub enum Origin {\n }\n \n impl fmt::Display for Origin {\n-    fn fmt(&self, w: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // If the user passed `-Z borrowck=compare`, then include\n-        // origin info as part of the error report,\n-        // otherwise\n-        let display_origin = ty::tls::with_opt(|opt_tcx| {\n-            if let Some(tcx) = opt_tcx {\n-                tcx.sess.opts.borrowck_mode == BorrowckMode::Compare\n-            } else {\n-                false\n-            }\n-        });\n-        if display_origin {\n-            match *self {\n-                Origin::Mir => write!(w, \" (Mir)\"),\n-                Origin::Ast => write!(w, \" (Ast)\"),\n-            }\n-        } else {\n-            // Print no origin info\n-            Ok(())\n-        }\n+    fn fmt(&self, _w: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // FIXME(chrisvittal) remove Origin entirely\n+        // Print no origin info\n+        Ok(())\n     }\n }\n "}, {"sha": "1699447886aef89a30cb792f5b9e77baad017e3d", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -522,7 +522,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let msg = format!(\"you can convert an `{}` to `{}`\", checked_ty, expected_ty);\n         let cast_msg = format!(\"you can cast an `{} to `{}`\", checked_ty, expected_ty);\n-        let try_msg = format!(\"{} or panic if it the converted value wouldn't fit\", msg);\n+        let try_msg = format!(\"{} and panic if the converted value wouldn't fit\", msg);\n         let lit_msg = format!(\n             \"change the type of the numeric literal from `{}` to `{}`\",\n             checked_ty,"}, {"sha": "d46feeab33599773fd3713303e45f53f2beba422", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -7149,7 +7149,9 @@ impl<'a> Parser<'a> {\n             // `()` or a tuple might be allowed. For example, `struct Struct(pub (), pub (usize));`.\n             // Because of this, we only `bump` the `(` if we're assured it is appropriate to do so\n             // by the following tokens.\n-            if self.look_ahead(1, |t| t.is_keyword(keywords::Crate)) {\n+            if self.look_ahead(1, |t| t.is_keyword(keywords::Crate)) &&\n+                self.look_ahead(2, |t| t != &token::ModSep) // account for `pub(crate::foo)`\n+            {\n                 // `pub(crate)`\n                 self.bump(); // `(`\n                 self.bump(); // `crate`\n@@ -7192,7 +7194,7 @@ impl<'a> Parser<'a> {\n `pub(super)`: visible only in the current module's parent\n `pub(in path::to::module)`: visible only on the specified path\"##;\n                 let path = self.parse_path(PathStyle::Mod)?;\n-                let sp = self.prev_span;\n+                let sp = path.span;\n                 let help_msg = format!(\"make this visible only to module `{}` with `in`\", path);\n                 self.expect(&token::CloseDelim(token::Paren))?;  // `)`\n                 let mut err = struct_span_err!(self.sess.span_diagnostic, sp, E0704, \"{}\", msg);"}, {"sha": "6d22e9cd9fab98b01ab036fc6702602d53331641", "filename": "src/test/mir-opt/storage_ranges.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -7,7 +7,7 @@ fn main() {\n }\n \n // END RUST SOURCE\n-// START rustc.main.TypeckMir.before.mir\n+// START rustc.main.nll.0.mir\n //     bb0: {\n //         StorageLive(_1);\n //         _1 = const 0i32;\n@@ -31,4 +31,4 @@ fn main() {\n //         StorageDead(_1);\n //         return;\n //      }\n-// END rustc.main.TypeckMir.before.mir\n+// END rustc.main.nll.0.mir"}, {"sha": "7d4a7c708ddd73e91688d809dd1ee09d4b0d2de6", "filename": "src/test/run-pass/binding/match-pipe-binding.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Frun-pass%2Fbinding%2Fmatch-pipe-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Frun-pass%2Fbinding%2Fmatch-pipe-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbinding%2Fmatch-pipe-binding.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -1,5 +1,4 @@\n // run-pass\n-// compile-flags: -Z borrowck=compare\n \n fn test1() {\n     // from issue 6338"}, {"sha": "eff8e275bb58bd36f61090d4a3a446ab103cb00a", "filename": "src/test/run-pass/issues/issue-16671.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Frun-pass%2Fissues%2Fissue-16671.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Frun-pass%2Fissues%2Fissue-16671.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-16671.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -1,5 +1,4 @@\n // run-pass\n-//compile-flags: -Z borrowck=compare\n \n #![deny(warnings)]\n "}, {"sha": "f2f3ebff2db1839c4a0b911e73294a6f80777212", "filename": "src/test/run-pass/issues/issue-49955.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Frun-pass%2Fissues%2Fissue-49955.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Frun-pass%2Fissues%2Fissue-49955.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-49955.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -1,5 +1,4 @@\n // run-pass\n-// compile-flags: -Z borrowck=compare\n \n const ALL_THE_NUMS: [u32; 1] = [\n     1"}, {"sha": "b89a80c1307cf66364e0a20c294f8139b2ddc972", "filename": "src/test/run-pass/issues/issue-8860.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Frun-pass%2Fissues%2Fissue-8860.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Frun-pass%2Fissues%2Fissue-8860.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-8860.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -1,6 +1,5 @@\n // run-pass\n #![allow(dead_code)]\n-// compile-flags: -Z borrowck=compare\n \n static mut DROP: isize = 0;\n static mut DROP_S: isize = 0;"}, {"sha": "ea0ef95e4f1af3d5c8bf3a1ff6aa6eb10221ea1a", "filename": "src/test/run-pass/numbers-arithmetic/i128.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Frun-pass%2Fnumbers-arithmetic%2Fi128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Frun-pass%2Fnumbers-arithmetic%2Fi128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnumbers-arithmetic%2Fi128.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -3,7 +3,6 @@\n \n // ignore-emscripten i128 doesn't work\n \n-// compile-flags: -Z borrowck=compare\n \n #![feature(test)]\n "}, {"sha": "9394071632377eec0b7ec4baa72fb1d9cdeba500", "filename": "src/test/run-pass/numbers-arithmetic/u128.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Frun-pass%2Fnumbers-arithmetic%2Fu128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Frun-pass%2Fnumbers-arithmetic%2Fu128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnumbers-arithmetic%2Fu128.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -1,7 +1,6 @@\n // run-pass\n // ignore-emscripten u128 not supported\n \n-// compile-flags: -Z borrowck=compare\n \n #![feature(test)]\n "}, {"sha": "6b00293b6e52ad46a5f078c579590e6595375ddb", "filename": "src/test/run-pass/weird-exprs.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Frun-pass%2Fweird-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Frun-pass%2Fweird-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fweird-exprs.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -2,7 +2,6 @@\n #![allow(dead_code)]\n #![allow(unreachable_code)]\n #![allow(unused_parens)]\n-// compile-flags: -Z borrowck=compare\n \n #![recursion_limit = \"256\"]\n "}, {"sha": "1405cb1b4736cce98af69cf9f6a984f2d7cceb53", "filename": "src/test/ui/associated-types/associated-types-path-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-path-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-path-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-path-2.stderr?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -49,7 +49,7 @@ error[E0308]: mismatched types\n    |\n LL |     let _: i32 = f2(2i32);\n    |                  ^^^^^^^^ expected i32, found u32\n-help: you can convert an `u32` to `i32` or panic if it the converted value wouldn't fit\n+help: you can convert an `u32` to `i32` and panic if the converted value wouldn't fit\n    |\n LL |     let _: i32 = f2(2i32).try_into().unwrap();\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "f603c5bd3f9462b7e4c9027095eb346628da3e01", "filename": "src/test/ui/async-await/issue-60518.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fasync-await%2Fissue-60518.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fasync-await%2Fissue-60518.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-60518.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -0,0 +1,12 @@\n+// compile-pass\n+// edition:2018\n+\n+#![feature(async_await)]\n+\n+// This is a regression test to ensure that simple bindings (where replacement arguments aren't\n+// created during async fn lowering) that have their DefId used during HIR lowering (such as impl\n+// trait) are visited during def collection and thus have a DefId.\n+\n+async fn foo(ws: impl Iterator<Item = ()>) {}\n+\n+fn main() {}"}, {"sha": "5fe51654f3b7977ecf7c8f2024ed676403892d17", "filename": "src/test/ui/borrowck/borrowck-closures-two-mut.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-two-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-two-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-two-mut.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -2,8 +2,6 @@\n // access to the variable, whether that mutable access be used\n // for direct assignment or for taking mutable ref. Issue #6801.\n \n-// compile-flags: -Z borrowck=compare\n-\n #![feature(box_syntax)]\n \n fn to_fn_mut<F: FnMut()>(f: F) -> F { f }\n@@ -12,7 +10,6 @@ fn a() {\n     let mut x = 3;\n     let c1 = to_fn_mut(|| x = 4);\n     let c2 = to_fn_mut(|| x = 5); //~ ERROR cannot borrow `x` as mutable more than once\n-    //~| ERROR cannot borrow `x` as mutable more than once\n     drop((c1, c2));\n }\n \n@@ -24,15 +21,13 @@ fn b() {\n     let mut x = 3;\n     let c1 = to_fn_mut(|| set(&mut x));\n     let c2 = to_fn_mut(|| set(&mut x)); //~ ERROR cannot borrow `x` as mutable more than once\n-    //~| ERROR cannot borrow `x` as mutable more than once\n     drop((c1, c2));\n }\n \n fn c() {\n     let mut x = 3;\n     let c1 = to_fn_mut(|| x = 5);\n     let c2 = to_fn_mut(|| set(&mut x)); //~ ERROR cannot borrow `x` as mutable more than once\n-    //~| ERROR cannot borrow `x` as mutable more than once\n     drop((c1, c2));\n }\n \n@@ -41,7 +36,6 @@ fn d() {\n     let c1 = to_fn_mut(|| x = 5);\n     let c2 = to_fn_mut(|| { let _y = to_fn_mut(|| set(&mut x)); }); // (nested closure)\n     //~^ ERROR cannot borrow `x` as mutable more than once\n-    //~| ERROR cannot borrow `x` as mutable more than once\n     drop((c1, c2));\n }\n \n@@ -54,7 +48,6 @@ fn g() {\n     let c1 = to_fn_mut(|| set(&mut *x.f));\n     let c2 = to_fn_mut(|| set(&mut *x.f));\n     //~^ ERROR cannot borrow `x` as mutable more than once\n-    //~| ERROR cannot borrow `x` as mutable more than once\n     drop((c1, c2));\n }\n "}, {"sha": "bffb11640744c6bf7b06d900b28db9dbb7dd690b", "filename": "src/test/ui/borrowck/borrowck-closures-two-mut.stderr", "status": "modified", "additions": 13, "deletions": 91, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-two-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-two-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-closures-two-mut.stderr?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -1,80 +1,5 @@\n-error[E0499]: cannot borrow `x` as mutable more than once at a time (Ast)\n-  --> $DIR/borrowck-closures-two-mut.rs:14:24\n-   |\n-LL |     let c1 = to_fn_mut(|| x = 4);\n-   |                        -- - previous borrow occurs due to use of `x` in closure\n-   |                        |\n-   |                        first mutable borrow occurs here\n-LL |     let c2 = to_fn_mut(|| x = 5);\n-   |                        ^^ - borrow occurs due to use of `x` in closure\n-   |                        |\n-   |                        second mutable borrow occurs here\n-...\n-LL | }\n-   | - first borrow ends here\n-\n-error[E0499]: cannot borrow `x` as mutable more than once at a time (Ast)\n-  --> $DIR/borrowck-closures-two-mut.rs:26:24\n-   |\n-LL |     let c1 = to_fn_mut(|| set(&mut x));\n-   |                        --          - previous borrow occurs due to use of `x` in closure\n-   |                        |\n-   |                        first mutable borrow occurs here\n-LL |     let c2 = to_fn_mut(|| set(&mut x));\n-   |                        ^^          - borrow occurs due to use of `x` in closure\n-   |                        |\n-   |                        second mutable borrow occurs here\n-...\n-LL | }\n-   | - first borrow ends here\n-\n-error[E0499]: cannot borrow `x` as mutable more than once at a time (Ast)\n-  --> $DIR/borrowck-closures-two-mut.rs:34:24\n-   |\n-LL |     let c1 = to_fn_mut(|| x = 5);\n-   |                        -- - previous borrow occurs due to use of `x` in closure\n-   |                        |\n-   |                        first mutable borrow occurs here\n-LL |     let c2 = to_fn_mut(|| set(&mut x));\n-   |                        ^^          - borrow occurs due to use of `x` in closure\n-   |                        |\n-   |                        second mutable borrow occurs here\n-...\n-LL | }\n-   | - first borrow ends here\n-\n-error[E0499]: cannot borrow `x` as mutable more than once at a time (Ast)\n-  --> $DIR/borrowck-closures-two-mut.rs:42:24\n-   |\n-LL |     let c1 = to_fn_mut(|| x = 5);\n-   |                        -- - previous borrow occurs due to use of `x` in closure\n-   |                        |\n-   |                        first mutable borrow occurs here\n-LL |     let c2 = to_fn_mut(|| { let _y = to_fn_mut(|| set(&mut x)); }); // (nested closure)\n-   |                        ^^                                  - borrow occurs due to use of `x` in closure\n-   |                        |\n-   |                        second mutable borrow occurs here\n-...\n-LL | }\n-   | - first borrow ends here\n-\n-error[E0499]: cannot borrow `x` as mutable more than once at a time (Ast)\n-  --> $DIR/borrowck-closures-two-mut.rs:55:24\n-   |\n-LL |     let c1 = to_fn_mut(|| set(&mut *x.f));\n-   |                        --           - previous borrow occurs due to use of `x` in closure\n-   |                        |\n-   |                        first mutable borrow occurs here\n-LL |     let c2 = to_fn_mut(|| set(&mut *x.f));\n-   |                        ^^           - borrow occurs due to use of `x` in closure\n-   |                        |\n-   |                        second mutable borrow occurs here\n-...\n-LL | }\n-   | - first borrow ends here\n-\n-error[E0499]: cannot borrow `x` as mutable more than once at a time (Mir)\n-  --> $DIR/borrowck-closures-two-mut.rs:14:24\n+error[E0499]: cannot borrow `x` as mutable more than once at a time\n+  --> $DIR/borrowck-closures-two-mut.rs:12:24\n    |\n LL |     let c1 = to_fn_mut(|| x = 4);\n    |                        -- - first borrow occurs due to use of `x` in closure\n@@ -84,12 +9,11 @@ LL |     let c2 = to_fn_mut(|| x = 5);\n    |                        ^^ - second borrow occurs due to use of `x` in closure\n    |                        |\n    |                        second mutable borrow occurs here\n-LL |\n LL |     drop((c1, c2));\n    |           -- first borrow later used here\n \n-error[E0499]: cannot borrow `x` as mutable more than once at a time (Mir)\n-  --> $DIR/borrowck-closures-two-mut.rs:26:24\n+error[E0499]: cannot borrow `x` as mutable more than once at a time\n+  --> $DIR/borrowck-closures-two-mut.rs:23:24\n    |\n LL |     let c1 = to_fn_mut(|| set(&mut x));\n    |                        --          - first borrow occurs due to use of `x` in closure\n@@ -99,12 +23,11 @@ LL |     let c2 = to_fn_mut(|| set(&mut x));\n    |                        ^^          - second borrow occurs due to use of `x` in closure\n    |                        |\n    |                        second mutable borrow occurs here\n-LL |\n LL |     drop((c1, c2));\n    |           -- first borrow later used here\n \n-error[E0499]: cannot borrow `x` as mutable more than once at a time (Mir)\n-  --> $DIR/borrowck-closures-two-mut.rs:34:24\n+error[E0499]: cannot borrow `x` as mutable more than once at a time\n+  --> $DIR/borrowck-closures-two-mut.rs:30:24\n    |\n LL |     let c1 = to_fn_mut(|| x = 5);\n    |                        -- - first borrow occurs due to use of `x` in closure\n@@ -114,12 +37,11 @@ LL |     let c2 = to_fn_mut(|| set(&mut x));\n    |                        ^^          - second borrow occurs due to use of `x` in closure\n    |                        |\n    |                        second mutable borrow occurs here\n-LL |\n LL |     drop((c1, c2));\n    |           -- first borrow later used here\n \n-error[E0499]: cannot borrow `x` as mutable more than once at a time (Mir)\n-  --> $DIR/borrowck-closures-two-mut.rs:42:24\n+error[E0499]: cannot borrow `x` as mutable more than once at a time\n+  --> $DIR/borrowck-closures-two-mut.rs:37:24\n    |\n LL |     let c1 = to_fn_mut(|| x = 5);\n    |                        -- - first borrow occurs due to use of `x` in closure\n@@ -129,12 +51,12 @@ LL |     let c2 = to_fn_mut(|| { let _y = to_fn_mut(|| set(&mut x)); }); // (nes\n    |                        ^^                                  - second borrow occurs due to use of `x` in closure\n    |                        |\n    |                        second mutable borrow occurs here\n-...\n+LL |\n LL |     drop((c1, c2));\n    |           -- first borrow later used here\n \n-error[E0499]: cannot borrow `x` as mutable more than once at a time (Mir)\n-  --> $DIR/borrowck-closures-two-mut.rs:55:24\n+error[E0499]: cannot borrow `x` as mutable more than once at a time\n+  --> $DIR/borrowck-closures-two-mut.rs:49:24\n    |\n LL |     let c1 = to_fn_mut(|| set(&mut *x.f));\n    |                        --           - first borrow occurs due to use of `x` in closure\n@@ -144,10 +66,10 @@ LL |     let c2 = to_fn_mut(|| set(&mut *x.f));\n    |                        ^^           - second borrow occurs due to use of `x` in closure\n    |                        |\n    |                        second mutable borrow occurs here\n-...\n+LL |\n LL |     drop((c1, c2));\n    |           -- first borrow later used here\n \n-error: aborting due to 10 previous errors\n+error: aborting due to 5 previous errors\n \n For more information about this error, try `rustc --explain E0499`."}, {"sha": "866b3a2a8af9b485346667b1522910c8e1a79a5b", "filename": "src/test/ui/borrowck/borrowck-reinit.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-reinit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-reinit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-reinit.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -1,10 +1,7 @@\n-// compile-flags: -Z borrowck=compare\n-\n fn main() {\n     let mut x = Box::new(0);\n     let _u = x; // error shouldn't note this move\n     x = Box::new(1);\n     drop(x);\n-    let _ = (1,x); //~ ERROR use of moved value: `x` (Ast)\n-    //~^ ERROR use of moved value: `x` (Mir)\n+    let _ = (1,x); //~ ERROR use of moved value: `x`\n }"}, {"sha": "f8f14b6435f086a62704a5ff295404e41294d2e3", "filename": "src/test/ui/borrowck/borrowck-reinit.stderr", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-reinit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-reinit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-reinit.stderr?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -1,15 +1,5 @@\n-error[E0382]: use of moved value: `x` (Ast)\n-  --> $DIR/borrowck-reinit.rs:8:16\n-   |\n-LL |     drop(x);\n-   |          - value moved here\n-LL |     let _ = (1,x);\n-   |                ^ value used here after move\n-   |\n-   = note: move occurs because `x` has type `std::boxed::Box<i32>`, which does not implement the `Copy` trait\n-\n-error[E0382]: use of moved value: `x` (Mir)\n-  --> $DIR/borrowck-reinit.rs:8:16\n+error[E0382]: use of moved value: `x`\n+  --> $DIR/borrowck-reinit.rs:6:16\n    |\n LL |     let mut x = Box::new(0);\n    |         ----- move occurs because `x` has type `std::boxed::Box<i32>`, which does not implement the `Copy` trait\n@@ -19,6 +9,6 @@ LL |     drop(x);\n LL |     let _ = (1,x);\n    |                ^ value used here after move\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0382`."}, {"sha": "fe9844610425e37296c57a3c345bdedf942404af", "filename": "src/test/ui/borrowck/borrowck-storage-dead.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-storage-dead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-storage-dead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-storage-dead.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -1,5 +1,3 @@\n-// compile-flags: -Z borrowck=compare\n-\n fn ok() {\n     loop {\n         let _x = 1;\n@@ -15,8 +13,7 @@ fn also_ok() {\n fn fail() {\n     loop {\n         let x: i32;\n-        let _ = x + 1; //~ERROR (Ast) [E0381]\n-                       //~^ ERROR (Mir) [E0381]\n+        let _ = x + 1; //~ERROR [E0381]\n     }\n }\n "}, {"sha": "5b9f49c2e7c920ad80620ad263b26e4089c3cf15", "filename": "src/test/ui/borrowck/borrowck-storage-dead.stderr", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-storage-dead.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-storage-dead.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-storage-dead.stderr?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -1,15 +1,9 @@\n-error[E0381]: use of possibly uninitialized variable: `x` (Ast)\n-  --> $DIR/borrowck-storage-dead.rs:18:17\n+error[E0381]: use of possibly uninitialized variable: `x`\n+  --> $DIR/borrowck-storage-dead.rs:16:17\n    |\n LL |         let _ = x + 1;\n    |                 ^ use of possibly uninitialized `x`\n \n-error[E0381]: use of possibly uninitialized variable: `x` (Mir)\n-  --> $DIR/borrowck-storage-dead.rs:18:17\n-   |\n-LL |         let _ = x + 1;\n-   |                 ^ use of possibly uninitialized `x`\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0381`."}, {"sha": "2352d1bbe64565b78ab09e265a842878825e4fe5", "filename": "src/test/ui/borrowck/immutable-arg.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fborrowck%2Fimmutable-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fborrowck%2Fimmutable-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fimmutable-arg.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -1,9 +1,6 @@\n-//compile-flags: -Z borrowck=compare\n-\n fn foo(_x: u32) {\n     _x = 4;\n-    //~^ ERROR cannot assign to immutable argument `_x` (Mir)\n-    //~^^ ERROR cannot assign twice to immutable variable `_x` (Ast)\n+    //~^ ERROR cannot assign to immutable argument `_x`\n }\n \n fn main() {}"}, {"sha": "7255ca327e753328a56579e421fc06fe8f9cd0cb", "filename": "src/test/ui/borrowck/immutable-arg.stderr", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fborrowck%2Fimmutable-arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fborrowck%2Fimmutable-arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fimmutable-arg.stderr?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -1,19 +1,11 @@\n-error[E0384]: cannot assign twice to immutable variable `_x` (Ast)\n-  --> $DIR/immutable-arg.rs:4:5\n-   |\n-LL | fn foo(_x: u32) {\n-   |        -- first assignment to `_x`\n-LL |     _x = 4;\n-   |     ^^^^^^ cannot assign twice to immutable variable\n-\n-error[E0384]: cannot assign to immutable argument `_x` (Mir)\n-  --> $DIR/immutable-arg.rs:4:5\n+error[E0384]: cannot assign to immutable argument `_x`\n+  --> $DIR/immutable-arg.rs:2:5\n    |\n LL | fn foo(_x: u32) {\n    |        -- help: make this binding mutable: `mut _x`\n LL |     _x = 4;\n    |     ^^^^^^ cannot assign to immutable argument\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0384`."}, {"sha": "38a01b138e47dea4bbba8ff00256a5bae8d883bb", "filename": "src/test/ui/borrowck/issue-41962.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fborrowck%2Fissue-41962.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fborrowck%2Fissue-41962.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-41962.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -1,13 +1,9 @@\n-// compile-flags: -Z borrowck=compare\n-\n pub fn main(){\n     let maybe = Some(vec![true, true]);\n \n     loop {\n         if let Some(thing) = maybe {\n         }\n-        //~^^ ERROR use of partially moved value: `maybe` (Ast) [E0382]\n-        //~| ERROR use of moved value: `(maybe as std::prelude::v1::Some).0` (Ast) [E0382]\n-        //~| ERROR use of moved value (Mir) [E0382]\n+        //~^^ ERROR use of moved value [E0382]\n     }\n }"}, {"sha": "422d1605aa46b78a2b0fff91d8285f6a80c35336", "filename": "src/test/ui/borrowck/issue-41962.stderr", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fborrowck%2Fissue-41962.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fborrowck%2Fissue-41962.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-41962.stderr?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -1,29 +1,11 @@\n-error[E0382]: use of partially moved value: `maybe` (Ast)\n-  --> $DIR/issue-41962.rs:7:30\n-   |\n-LL |         if let Some(thing) = maybe {\n-   |                     -----    ^^^^^ value used here after move\n-   |                     |\n-   |                     value moved here\n-   |\n-   = note: move occurs because the value has type `std::vec::Vec<bool>`, which does not implement the `Copy` trait\n-\n-error[E0382]: use of moved value: `(maybe as std::prelude::v1::Some).0` (Ast)\n-  --> $DIR/issue-41962.rs:7:21\n-   |\n-LL |         if let Some(thing) = maybe {\n-   |                     ^^^^^ value moved here in previous iteration of loop\n-   |\n-   = note: move occurs because the value has type `std::vec::Vec<bool>`, which does not implement the `Copy` trait\n-\n-error[E0382]: use of moved value (Mir)\n-  --> $DIR/issue-41962.rs:7:21\n+error[E0382]: use of moved value\n+  --> $DIR/issue-41962.rs:5:21\n    |\n LL |         if let Some(thing) = maybe {\n    |                     ^^^^^ value moved here, in previous iteration of loop\n    |\n    = note: move occurs because value has type `std::vec::Vec<bool>`, which does not implement the `Copy` trait\n \n-error: aborting due to 3 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0382`."}, {"sha": "b643bbf3376fb8b69a8fd8fc0c89b563bbd26644", "filename": "src/test/ui/generator/yield-while-local-borrowed.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-local-borrowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-local-borrowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-local-borrowed.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -1,5 +1,3 @@\n-// compile-flags: -Z borrowck=compare\n-\n #![feature(generators, generator_trait)]\n \n use std::ops::{GeneratorState, Generator};\n@@ -13,8 +11,7 @@ fn borrow_local_inline() {\n     // `b` and gets extended by region inference.)\n     let mut b = move || {\n         let a = &mut 3;\n-        //~^ ERROR borrow may still be in use when generator yields (Ast)\n-        //~| ERROR borrow may still be in use when generator yields (Mir)\n+        //~^ ERROR borrow may still be in use when generator yields\n         yield();\n         println!(\"{}\", a);\n     };\n@@ -41,8 +38,7 @@ fn borrow_local() {\n         let a = 3;\n         {\n             let b = &a;\n-            //~^ ERROR borrow may still be in use when generator yields (Ast)\n-            //~| ERROR borrow may still be in use when generator yields (Mir)\n+            //~^ ERROR borrow may still be in use when generator yields\n             yield();\n             println!(\"{}\", b);\n         }"}, {"sha": "c1513ef9b71573fe21383d6e7e4c70d9ff0102db", "filename": "src/test/ui/generator/yield-while-local-borrowed.stderr", "status": "modified", "additions": 7, "deletions": 25, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-local-borrowed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-local-borrowed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-local-borrowed.stderr?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -1,39 +1,21 @@\n-error[E0626]: borrow may still be in use when generator yields (Ast)\n-  --> $DIR/yield-while-local-borrowed.rs:15:22\n-   |\n-LL |         let a = &mut 3;\n-   |                      ^\n-...\n-LL |         yield();\n-   |         ------- possible yield occurs here\n-\n-error[E0626]: borrow may still be in use when generator yields (Ast)\n-  --> $DIR/yield-while-local-borrowed.rs:43:22\n-   |\n-LL |             let b = &a;\n-   |                      ^\n-...\n-LL |             yield();\n-   |             ------- possible yield occurs here\n-\n-error[E0626]: borrow may still be in use when generator yields (Mir)\n-  --> $DIR/yield-while-local-borrowed.rs:15:17\n+error[E0626]: borrow may still be in use when generator yields\n+  --> $DIR/yield-while-local-borrowed.rs:13:17\n    |\n LL |         let a = &mut 3;\n    |                 ^^^^^^\n-...\n+LL |\n LL |         yield();\n    |         ------- possible yield occurs here\n \n-error[E0626]: borrow may still be in use when generator yields (Mir)\n-  --> $DIR/yield-while-local-borrowed.rs:43:21\n+error[E0626]: borrow may still be in use when generator yields\n+  --> $DIR/yield-while-local-borrowed.rs:40:21\n    |\n LL |             let b = &a;\n    |                     ^^\n-...\n+LL |\n LL |             yield();\n    |             ------- possible yield occurs here\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0626`."}, {"sha": "a982b176ecda1c280353c5246c7b4005b1b0bffb", "filename": "src/test/ui/impl-trait/can-return-unconstrained-closure.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fimpl-trait%2Fcan-return-unconstrained-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fimpl-trait%2Fcan-return-unconstrained-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fcan-return-unconstrained-closure.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -0,0 +1,19 @@\n+// Test that we are special casing \"outlives\" for opaque types.\n+//\n+// The return type of a closure is not required to outlive the closure. As such\n+// the following code would not compile if we used a standard outlives check\n+// when checking the return type, because the return type of the closure would\n+// be `&ReEmpty i32`, and we don't allow `ReEmpty` to occur in the concrete\n+// type used for an opaque type.\n+//\n+// However, opaque types are special cased to include check all regions in the\n+// concrete type against the bound, which forces the return type to be\n+// `&'static i32` here.\n+\n+// compile-pass\n+\n+fn make_identity() -> impl Sized {\n+    |x: &'static i32| x\n+}\n+\n+fn main() {}"}, {"sha": "50646edd61a8585f6de31b7dd87dc062839e21e1", "filename": "src/test/ui/impl-trait/issue-55608-captures-empty-region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55608-captures-empty-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55608-captures-empty-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55608-captures-empty-region.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -1,9 +1,9 @@\n // This used to ICE because it creates an `impl Trait` that captures a\n // hidden empty region.\n \n-#![feature(conservative_impl_trait)]\n+// compile-pass\n \n-fn server() -> impl FilterBase2 { //~ ERROR [E0700]\n+fn server() -> impl FilterBase2 {\n     segment2(|| { loop { } }).map2(|| \"\")\n }\n "}, {"sha": "6311a7f00674f86c4383f7d551ac9bc03df0f376", "filename": "src/test/ui/impl-trait/issue-55608-captures-empty-region.stderr", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e2326366935613816927e679d3b2dc04db44678c/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55608-captures-empty-region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e2326366935613816927e679d3b2dc04db44678c/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55608-captures-empty-region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55608-captures-empty-region.stderr?ref=e2326366935613816927e679d3b2dc04db44678c", "patch": "@@ -1,11 +0,0 @@\n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/issue-55608-captures-empty-region.rs:6:16\n-   |\n-LL | fn server() -> impl FilterBase2 {\n-   |                ^^^^^^^^^^^^^^^^\n-   |\n-   = note: hidden type `Map2<[closure@$DIR/issue-55608-captures-empty-region.rs:7:36: 7:41]>` captures an empty lifetime\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0700`."}, {"sha": "29e271c68ec9068562d430508509870a3728d8c6", "filename": "src/test/ui/impl-trait/issue-57464-unexpected-regions.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-57464-unexpected-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-57464-unexpected-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-57464-unexpected-regions.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -0,0 +1,22 @@\n+// Regression test for issue 57464.\n+//\n+// Closure are (surprisingly) allowed to outlive their signature. As such it\n+// was possible to end up with `ReScope`s appearing in the concrete type of an\n+// opaque type. As all regions are now required to outlive the bound in an\n+// opaque type we avoid the issue here.\n+\n+// compile-pass\n+\n+struct A<F>(F);\n+\n+unsafe impl <'a, 'b, F: Fn(&'a i32) -> &'b i32> Send for A<F> {}\n+\n+fn wrapped_closure() -> impl Sized {\n+    let f = |x| x;\n+    f(&0);\n+    A(f)\n+}\n+\n+fn main() {\n+    let x: Box<dyn Send> = Box::new(wrapped_closure());\n+}"}, {"sha": "3300db58d44c3385dfba77eed2cd58c602612d11", "filename": "src/test/ui/indexing-requires-a-uint.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Findexing-requires-a-uint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Findexing-requires-a-uint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Findexing-requires-a-uint.stderr?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -12,7 +12,7 @@ error[E0308]: mismatched types\n    |\n LL |     bar::<isize>(i);  // i should not be re-coerced back to an isize\n    |                  ^ expected isize, found usize\n-help: you can convert an `usize` to `isize` or panic if it the converted value wouldn't fit\n+help: you can convert an `usize` to `isize` and panic if the converted value wouldn't fit\n    |\n LL |     bar::<isize>(i.try_into().unwrap());  // i should not be re-coerced back to an isize\n    |                  ^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "80b601dc4394b0de8bb8d5b41d4ddc34f02d32dc", "filename": "src/test/ui/integer-literal-suffix-inference.stderr", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Finteger-literal-suffix-inference.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Finteger-literal-suffix-inference.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finteger-literal-suffix-inference.stderr?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -3,7 +3,7 @@ error[E0308]: mismatched types\n    |\n LL |     id_i8(a16);\n    |           ^^^ expected i8, found i16\n-help: you can convert an `i16` to `i8` or panic if it the converted value wouldn't fit\n+help: you can convert an `i16` to `i8` and panic if the converted value wouldn't fit\n    |\n LL |     id_i8(a16.try_into().unwrap());\n    |           ^^^^^^^^^^^^^^^^^^^^^^^\n@@ -13,7 +13,7 @@ error[E0308]: mismatched types\n    |\n LL |     id_i8(a32);\n    |           ^^^ expected i8, found i32\n-help: you can convert an `i32` to `i8` or panic if it the converted value wouldn't fit\n+help: you can convert an `i32` to `i8` and panic if the converted value wouldn't fit\n    |\n LL |     id_i8(a32.try_into().unwrap());\n    |           ^^^^^^^^^^^^^^^^^^^^^^^\n@@ -23,7 +23,7 @@ error[E0308]: mismatched types\n    |\n LL |     id_i8(a64);\n    |           ^^^ expected i8, found i64\n-help: you can convert an `i64` to `i8` or panic if it the converted value wouldn't fit\n+help: you can convert an `i64` to `i8` and panic if the converted value wouldn't fit\n    |\n LL |     id_i8(a64.try_into().unwrap());\n    |           ^^^^^^^^^^^^^^^^^^^^^^^\n@@ -42,7 +42,7 @@ error[E0308]: mismatched types\n    |\n LL |     id_i16(a32);\n    |            ^^^ expected i16, found i32\n-help: you can convert an `i32` to `i16` or panic if it the converted value wouldn't fit\n+help: you can convert an `i32` to `i16` and panic if the converted value wouldn't fit\n    |\n LL |     id_i16(a32.try_into().unwrap());\n    |            ^^^^^^^^^^^^^^^^^^^^^^^\n@@ -52,7 +52,7 @@ error[E0308]: mismatched types\n    |\n LL |     id_i16(a64);\n    |            ^^^ expected i16, found i64\n-help: you can convert an `i64` to `i16` or panic if it the converted value wouldn't fit\n+help: you can convert an `i64` to `i16` and panic if the converted value wouldn't fit\n    |\n LL |     id_i16(a64.try_into().unwrap());\n    |            ^^^^^^^^^^^^^^^^^^^^^^^\n@@ -80,7 +80,7 @@ error[E0308]: mismatched types\n    |\n LL |     id_i32(a64);\n    |            ^^^ expected i32, found i64\n-help: you can convert an `i64` to `i32` or panic if it the converted value wouldn't fit\n+help: you can convert an `i64` to `i32` and panic if the converted value wouldn't fit\n    |\n LL |     id_i32(a64.try_into().unwrap());\n    |            ^^^^^^^^^^^^^^^^^^^^^^^\n@@ -117,7 +117,7 @@ error[E0308]: mismatched types\n    |\n LL |     id_i8(c16);\n    |           ^^^ expected i8, found i16\n-help: you can convert an `i16` to `i8` or panic if it the converted value wouldn't fit\n+help: you can convert an `i16` to `i8` and panic if the converted value wouldn't fit\n    |\n LL |     id_i8(c16.try_into().unwrap());\n    |           ^^^^^^^^^^^^^^^^^^^^^^^\n@@ -127,7 +127,7 @@ error[E0308]: mismatched types\n    |\n LL |     id_i8(c32);\n    |           ^^^ expected i8, found i32\n-help: you can convert an `i32` to `i8` or panic if it the converted value wouldn't fit\n+help: you can convert an `i32` to `i8` and panic if the converted value wouldn't fit\n    |\n LL |     id_i8(c32.try_into().unwrap());\n    |           ^^^^^^^^^^^^^^^^^^^^^^^\n@@ -137,7 +137,7 @@ error[E0308]: mismatched types\n    |\n LL |     id_i8(c64);\n    |           ^^^ expected i8, found i64\n-help: you can convert an `i64` to `i8` or panic if it the converted value wouldn't fit\n+help: you can convert an `i64` to `i8` and panic if the converted value wouldn't fit\n    |\n LL |     id_i8(c64.try_into().unwrap());\n    |           ^^^^^^^^^^^^^^^^^^^^^^^\n@@ -156,7 +156,7 @@ error[E0308]: mismatched types\n    |\n LL |     id_i16(c32);\n    |            ^^^ expected i16, found i32\n-help: you can convert an `i32` to `i16` or panic if it the converted value wouldn't fit\n+help: you can convert an `i32` to `i16` and panic if the converted value wouldn't fit\n    |\n LL |     id_i16(c32.try_into().unwrap());\n    |            ^^^^^^^^^^^^^^^^^^^^^^^\n@@ -166,7 +166,7 @@ error[E0308]: mismatched types\n    |\n LL |     id_i16(c64);\n    |            ^^^ expected i16, found i64\n-help: you can convert an `i64` to `i16` or panic if it the converted value wouldn't fit\n+help: you can convert an `i64` to `i16` and panic if the converted value wouldn't fit\n    |\n LL |     id_i16(c64.try_into().unwrap());\n    |            ^^^^^^^^^^^^^^^^^^^^^^^\n@@ -194,7 +194,7 @@ error[E0308]: mismatched types\n    |\n LL |     id_i32(c64);\n    |            ^^^ expected i32, found i64\n-help: you can convert an `i64` to `i32` or panic if it the converted value wouldn't fit\n+help: you can convert an `i64` to `i32` and panic if the converted value wouldn't fit\n    |\n LL |     id_i32(c64.try_into().unwrap());\n    |            ^^^^^^^^^^^^^^^^^^^^^^^\n@@ -231,7 +231,7 @@ error[E0308]: mismatched types\n    |\n LL |     id_u8(b16);\n    |           ^^^ expected u8, found u16\n-help: you can convert an `u16` to `u8` or panic if it the converted value wouldn't fit\n+help: you can convert an `u16` to `u8` and panic if the converted value wouldn't fit\n    |\n LL |     id_u8(b16.try_into().unwrap());\n    |           ^^^^^^^^^^^^^^^^^^^^^^^\n@@ -241,7 +241,7 @@ error[E0308]: mismatched types\n    |\n LL |     id_u8(b32);\n    |           ^^^ expected u8, found u32\n-help: you can convert an `u32` to `u8` or panic if it the converted value wouldn't fit\n+help: you can convert an `u32` to `u8` and panic if the converted value wouldn't fit\n    |\n LL |     id_u8(b32.try_into().unwrap());\n    |           ^^^^^^^^^^^^^^^^^^^^^^^\n@@ -251,7 +251,7 @@ error[E0308]: mismatched types\n    |\n LL |     id_u8(b64);\n    |           ^^^ expected u8, found u64\n-help: you can convert an `u64` to `u8` or panic if it the converted value wouldn't fit\n+help: you can convert an `u64` to `u8` and panic if the converted value wouldn't fit\n    |\n LL |     id_u8(b64.try_into().unwrap());\n    |           ^^^^^^^^^^^^^^^^^^^^^^^\n@@ -270,7 +270,7 @@ error[E0308]: mismatched types\n    |\n LL |     id_u16(b32);\n    |            ^^^ expected u16, found u32\n-help: you can convert an `u32` to `u16` or panic if it the converted value wouldn't fit\n+help: you can convert an `u32` to `u16` and panic if the converted value wouldn't fit\n    |\n LL |     id_u16(b32.try_into().unwrap());\n    |            ^^^^^^^^^^^^^^^^^^^^^^^\n@@ -280,7 +280,7 @@ error[E0308]: mismatched types\n    |\n LL |     id_u16(b64);\n    |            ^^^ expected u16, found u64\n-help: you can convert an `u64` to `u16` or panic if it the converted value wouldn't fit\n+help: you can convert an `u64` to `u16` and panic if the converted value wouldn't fit\n    |\n LL |     id_u16(b64.try_into().unwrap());\n    |            ^^^^^^^^^^^^^^^^^^^^^^^\n@@ -308,7 +308,7 @@ error[E0308]: mismatched types\n    |\n LL |     id_u32(b64);\n    |            ^^^ expected u32, found u64\n-help: you can convert an `u64` to `u32` or panic if it the converted value wouldn't fit\n+help: you can convert an `u64` to `u32` and panic if the converted value wouldn't fit\n    |\n LL |     id_u32(b64.try_into().unwrap());\n    |            ^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "7cfd754f72d8e808e08f554484211b26485e2a4d", "filename": "src/test/ui/issues/issue-13359.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fissues%2Fissue-13359.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fissues%2Fissue-13359.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-13359.stderr?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -3,7 +3,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo(1*(1 as isize));\n    |         ^^^^^^^^^^^^^^ expected i16, found isize\n-help: you can convert an `isize` to `i16` or panic if it the converted value wouldn't fit\n+help: you can convert an `isize` to `i16` and panic if the converted value wouldn't fit\n    |\n LL |     foo((1*(1 as isize)).try_into().unwrap());\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -13,7 +13,7 @@ error[E0308]: mismatched types\n    |\n LL |     bar(1*(1 as usize));\n    |         ^^^^^^^^^^^^^^ expected u32, found usize\n-help: you can convert an `usize` to `u32` or panic if it the converted value wouldn't fit\n+help: you can convert an `usize` to `u32` and panic if the converted value wouldn't fit\n    |\n LL |     bar((1*(1 as usize)).try_into().unwrap());\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "e7555b958a3d4473359c7d07afc74071df3f8321", "filename": "src/test/ui/issues/issue-31910.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fissues%2Fissue-31910.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fissues%2Fissue-31910.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-31910.stderr?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -3,7 +3,7 @@ error[E0308]: mismatched types\n    |\n LL |     X = Trait::Number,\n    |         ^^^^^^^^^^^^^ expected isize, found i32\n-help: you can convert an `i32` to `isize` or panic if it the converted value wouldn't fit\n+help: you can convert an `i32` to `isize` and panic if the converted value wouldn't fit\n    |\n LL |     X = Trait::Number.try_into().unwrap(),\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "18b2ce85125f299ac14eff2fefa3ab1f971fddd2", "filename": "src/test/ui/issues/issue-44373-2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fissues%2Fissue-44373-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fissues%2Fissue-44373-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-44373-2.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -1,6 +1,5 @@\n // compile-pass\n #![allow(dead_code)]\n-// compile-flags: -Z borrowck=compare\n \n struct Foo(bool);\n "}, {"sha": "b45f1170b86c5a0c0a0e6c47cafe9c266219a85b", "filename": "src/test/ui/issues/issue-45697-1.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fissues%2Fissue-45697-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fissues%2Fissue-45697-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-45697-1.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -1,7 +1,7 @@\n // Test that assignments to an `&mut` pointer which is found in a\n // borrowed (but otherwise non-aliasable) location is illegal.\n \n-// compile-flags: -Z borrowck=compare -C overflow-checks=on\n+// compile-flags: -C overflow-checks=on\n \n struct S<'a> {\n     pointer: &'a mut isize\n@@ -18,9 +18,8 @@ fn main() {\n         let mut y = S { pointer: &mut x };\n         let z = copy_borrowed_ptr(&mut y);\n         *y.pointer += 1;\n-        //~^ ERROR cannot assign to `*y.pointer` because it is borrowed (Ast) [E0506]\n-        //~| ERROR cannot use `*y.pointer` because it was mutably borrowed (Mir) [E0503]\n-        //~| ERROR cannot assign to `*y.pointer` because it is borrowed (Mir) [E0506]\n+        //~^ ERROR cannot use `*y.pointer` because it was mutably borrowed [E0503]\n+        //~| ERROR cannot assign to `*y.pointer` because it is borrowed [E0506]\n         *z.pointer += 1;\n     }\n }"}, {"sha": "30c69f19658c84e0240bdc95a22938fd7a16133b", "filename": "src/test/ui/issues/issue-45697-1.stderr", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fissues%2Fissue-45697-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fissues%2Fissue-45697-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-45697-1.stderr?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -1,12 +1,4 @@\n-error[E0506]: cannot assign to `*y.pointer` because it is borrowed (Ast)\n-  --> $DIR/issue-45697-1.rs:20:9\n-   |\n-LL |         let z = copy_borrowed_ptr(&mut y);\n-   |                                        - borrow of `*y.pointer` occurs here\n-LL |         *y.pointer += 1;\n-   |         ^^^^^^^^^^^^^^^ assignment to borrowed `*y.pointer` occurs here\n-\n-error[E0503]: cannot use `*y.pointer` because it was mutably borrowed (Mir)\n+error[E0503]: cannot use `*y.pointer` because it was mutably borrowed\n   --> $DIR/issue-45697-1.rs:20:9\n    |\n LL |         let z = copy_borrowed_ptr(&mut y);\n@@ -17,7 +9,7 @@ LL |         *y.pointer += 1;\n LL |         *z.pointer += 1;\n    |         --------------- borrow later used here\n \n-error[E0506]: cannot assign to `*y.pointer` because it is borrowed (Mir)\n+error[E0506]: cannot assign to `*y.pointer` because it is borrowed\n   --> $DIR/issue-45697-1.rs:20:9\n    |\n LL |         let z = copy_borrowed_ptr(&mut y);\n@@ -28,7 +20,7 @@ LL |         *y.pointer += 1;\n LL |         *z.pointer += 1;\n    |         --------------- borrow later used here\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n Some errors have detailed explanations: E0503, E0506.\n For more information about an error, try `rustc --explain E0503`."}, {"sha": "db6d1d8fa2a922d73fa9014301e0f2f6bc9dc236", "filename": "src/test/ui/issues/issue-45697.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fissues%2Fissue-45697.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fissues%2Fissue-45697.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-45697.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -1,7 +1,7 @@\n // Test that assignments to an `&mut` pointer which is found in a\n // borrowed (but otherwise non-aliasable) location is illegal.\n \n-// compile-flags: -Z borrowck=compare -C overflow-checks=off\n+// compile-flags: -C overflow-checks=off\n \n struct S<'a> {\n     pointer: &'a mut isize\n@@ -18,9 +18,8 @@ fn main() {\n         let mut y = S { pointer: &mut x };\n         let z = copy_borrowed_ptr(&mut y);\n         *y.pointer += 1;\n-        //~^ ERROR cannot assign to `*y.pointer` because it is borrowed (Ast) [E0506]\n-        //~| ERROR cannot use `*y.pointer` because it was mutably borrowed (Mir) [E0503]\n-        //~| ERROR cannot assign to `*y.pointer` because it is borrowed (Mir) [E0506]\n+        //~^ ERROR cannot use `*y.pointer` because it was mutably borrowed [E0503]\n+        //~| ERROR cannot assign to `*y.pointer` because it is borrowed [E0506]\n         *z.pointer += 1;\n     }\n }"}, {"sha": "26749d36f0b7b69495db9ca915c2068788f1c65f", "filename": "src/test/ui/issues/issue-45697.stderr", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fissues%2Fissue-45697.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fissues%2Fissue-45697.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-45697.stderr?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -1,12 +1,4 @@\n-error[E0506]: cannot assign to `*y.pointer` because it is borrowed (Ast)\n-  --> $DIR/issue-45697.rs:20:9\n-   |\n-LL |         let z = copy_borrowed_ptr(&mut y);\n-   |                                        - borrow of `*y.pointer` occurs here\n-LL |         *y.pointer += 1;\n-   |         ^^^^^^^^^^^^^^^ assignment to borrowed `*y.pointer` occurs here\n-\n-error[E0503]: cannot use `*y.pointer` because it was mutably borrowed (Mir)\n+error[E0503]: cannot use `*y.pointer` because it was mutably borrowed\n   --> $DIR/issue-45697.rs:20:9\n    |\n LL |         let z = copy_borrowed_ptr(&mut y);\n@@ -17,7 +9,7 @@ LL |         *y.pointer += 1;\n LL |         *z.pointer += 1;\n    |         --------------- borrow later used here\n \n-error[E0506]: cannot assign to `*y.pointer` because it is borrowed (Mir)\n+error[E0506]: cannot assign to `*y.pointer` because it is borrowed\n   --> $DIR/issue-45697.rs:20:9\n    |\n LL |         let z = copy_borrowed_ptr(&mut y);\n@@ -28,7 +20,7 @@ LL |         *y.pointer += 1;\n LL |         *z.pointer += 1;\n    |         --------------- borrow later used here\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n Some errors have detailed explanations: E0503, E0506.\n For more information about an error, try `rustc --explain E0503`."}, {"sha": "aa161d40f702d5e7be4296e20a58f69c3a76d410", "filename": "src/test/ui/issues/issue-46471-1.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fissues%2Fissue-46471-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fissues%2Fissue-46471-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-46471-1.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -1,11 +1,8 @@\n-// compile-flags: -Z borrowck=compare\n-\n fn main() {\n     let y = {\n         let mut z = 0;\n         &mut z\n     };\n-    //~^^ ERROR `z` does not live long enough (Ast) [E0597]\n-    //~| ERROR `z` does not live long enough (Mir) [E0597]\n+    //~^^ ERROR `z` does not live long enough [E0597]\n     println!(\"{}\", y);\n }"}, {"sha": "b09f31729a5fdcc366e694af63094c94b9bac1c5", "filename": "src/test/ui/issues/issue-46471-1.stderr", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fissues%2Fissue-46471-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fissues%2Fissue-46471-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-46471-1.stderr?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -1,16 +1,5 @@\n-error[E0597]: `z` does not live long enough (Ast)\n-  --> $DIR/issue-46471-1.rs:6:14\n-   |\n-LL |         &mut z\n-   |              ^ borrowed value does not live long enough\n-LL |     };\n-   |     - `z` dropped here while still borrowed\n-...\n-LL | }\n-   | - borrowed value needs to live until here\n-\n-error[E0597]: `z` does not live long enough (Mir)\n-  --> $DIR/issue-46471-1.rs:6:9\n+error[E0597]: `z` does not live long enough\n+  --> $DIR/issue-46471-1.rs:4:9\n    |\n LL |         &mut z\n    |         ^^^^^^\n@@ -20,6 +9,6 @@ LL |         &mut z\n LL |     };\n    |     - `z` dropped here while still borrowed\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0597`."}, {"sha": "8922005d2f82c6c154efb001f187e65519618cf0", "filename": "src/test/ui/issues/issue-46471.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fissues%2Fissue-46471.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fissues%2Fissue-46471.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-46471.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -1,10 +1,7 @@\n-// compile-flags: -Z borrowck=compare\n-\n fn foo() -> &'static u32 {\n     let x = 0;\n     &x\n-    //~^ ERROR `x` does not live long enough (Ast) [E0597]\n-    //~| ERROR cannot return reference to local variable `x` (Mir) [E0515]\n+    //~^ ERROR cannot return reference to local variable `x` [E0515]\n }\n \n fn main() { }"}, {"sha": "935414c1f3f9da5dd3aade98b6f1be4dc30607e3", "filename": "src/test/ui/issues/issue-46471.stderr", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fissues%2Fissue-46471.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fissues%2Fissue-46471.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-46471.stderr?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -1,21 +1,9 @@\n-error[E0597]: `x` does not live long enough (Ast)\n-  --> $DIR/issue-46471.rs:5:6\n-   |\n-LL |     &x\n-   |      ^ borrowed value does not live long enough\n-...\n-LL | }\n-   | - borrowed value only lives until here\n-   |\n-   = note: borrowed value must be valid for the static lifetime...\n-\n-error[E0515]: cannot return reference to local variable `x` (Mir)\n-  --> $DIR/issue-46471.rs:5:5\n+error[E0515]: cannot return reference to local variable `x`\n+  --> $DIR/issue-46471.rs:3:5\n    |\n LL |     &x\n    |     ^^ returns a reference to data owned by the current function\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0515, E0597.\n-For more information about an error, try `rustc --explain E0515`.\n+For more information about this error, try `rustc --explain E0515`."}, {"sha": "b9e20e8dbcb5f119117af83f70587304d6eca5ea", "filename": "src/test/ui/issues/issue-46472.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fissues%2Fissue-46472.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fissues%2Fissue-46472.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-46472.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -1,9 +1,6 @@\n-// compile-flags: -Z borrowck=compare\n-\n fn bar<'a>() -> &'a mut u32 {\n     &mut 4\n-    //~^ ERROR borrowed value does not live long enough (Ast) [E0597]\n-    //~| ERROR cannot return reference to temporary value (Mir) [E0515]\n+    //~^ ERROR cannot return reference to temporary value [E0515]\n }\n \n fn main() { }"}, {"sha": "6e561e03a8b7a1068210869dd85737022065a7d2", "filename": "src/test/ui/issues/issue-46472.stderr", "status": "modified", "additions": 4, "deletions": 20, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fissues%2Fissue-46472.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fissues%2Fissue-46472.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-46472.stderr?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -1,28 +1,12 @@\n-error[E0597]: borrowed value does not live long enough (Ast)\n-  --> $DIR/issue-46472.rs:4:10\n-   |\n-LL |     &mut 4\n-   |          ^ temporary value does not live long enough\n-...\n-LL | }\n-   | - temporary value only lives until here\n-   |\n-note: borrowed value must be valid for the lifetime 'a as defined on the function body at 3:8...\n-  --> $DIR/issue-46472.rs:3:8\n-   |\n-LL | fn bar<'a>() -> &'a mut u32 {\n-   |        ^^\n-\n-error[E0515]: cannot return reference to temporary value (Mir)\n-  --> $DIR/issue-46472.rs:4:5\n+error[E0515]: cannot return reference to temporary value\n+  --> $DIR/issue-46472.rs:2:5\n    |\n LL |     &mut 4\n    |     ^^^^^-\n    |     |    |\n    |     |    temporary value created here\n    |     returns a reference to data owned by the current function\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0515, E0597.\n-For more information about an error, try `rustc --explain E0515`.\n+For more information about this error, try `rustc --explain E0515`."}, {"sha": "46d9e749aae2398b2f681942265d457b34fcc508", "filename": "src/test/ui/issues/issue-49556.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fissues%2Fissue-49556.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fissues%2Fissue-49556.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-49556.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -2,10 +2,10 @@\n fn iter<'a>(data: &'a [usize]) -> impl Iterator<Item = usize> + 'a {\n     data.iter()\n         .map(\n-            |x| x // fn(&'a usize) -> &'(ReScope) usize\n+            |x| x // fn(&'a usize) -> &'a usize\n         )\n         .map(\n-            |x| *x // fn(&'(ReScope) usize) -> usize\n+            |x| *x // fn(&'a usize) -> usize\n         )\n }\n "}, {"sha": "81a20c58776c840dfacd3dfb5b2cca0250bea749", "filename": "src/test/ui/lifetimes/lifetime-errors/liveness-assign-imm-local-notes.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fliveness-assign-imm-local-notes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fliveness-assign-imm-local-notes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fliveness-assign-imm-local-notes.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -1,17 +1,13 @@\n-// FIXME: Change to UI Test\n // Check notes are placed on an assignment that can actually precede the current assignment\n // Don't emit a first assignment for assignment in a loop.\n \n-// compile-flags: -Zborrowck=compare\n-\n fn test() {\n     let x;\n     if true {\n         x = 1;\n     } else {\n         x = 2;\n-        x = 3;      //~ ERROR (Ast) [E0384]\n-                    //~^ ERROR (Mir) [E0384]\n+        x = 3;      //~ ERROR [E0384]\n     }\n }\n \n@@ -22,8 +18,7 @@ fn test_in_loop() {\n             x = 1;\n         } else {\n             x = 2;\n-            x = 3;      //~ ERROR (Ast) [E0384]\n-                        //~^ ERROR (Mir) [E0384]\n+            x = 3;      //~ ERROR [E0384]\n         }\n     }\n }\n@@ -32,11 +27,9 @@ fn test_using_loop() {\n     let x;\n     loop {\n         if true {\n-            x = 1;      //~ ERROR (Ast) [E0384]\n-                        //~^ ERROR (Mir) [E0384]\n+            x = 1;      //~ ERROR [E0384]\n         } else {\n-            x = 2;      //~ ERROR (Ast) [E0384]\n-                        //~^ ERROR (Mir) [E0384]\n+            x = 2;      //~ ERROR [E0384]\n         }\n     }\n }"}, {"sha": "c646912d3b67950583d857964329692d36846745", "filename": "src/test/ui/lifetimes/lifetime-errors/liveness-assign-imm-local-notes.stderr", "status": "modified", "additions": 10, "deletions": 41, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fliveness-assign-imm-local-notes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fliveness-assign-imm-local-notes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fliveness-assign-imm-local-notes.stderr?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -1,36 +1,5 @@\n-error[E0384]: cannot assign twice to immutable variable `x` (Ast)\n-  --> $DIR/liveness-assign-imm-local-notes.rs:13:9\n-   |\n-LL |         x = 2;\n-   |         ----- first assignment to `x`\n-LL |         x = 3;\n-   |         ^^^^^ cannot assign twice to immutable variable\n-\n-error[E0384]: cannot assign twice to immutable variable `x` (Ast)\n-  --> $DIR/liveness-assign-imm-local-notes.rs:25:13\n-   |\n-LL |             x = 2;\n-   |             ----- first assignment to `x`\n-LL |             x = 3;\n-   |             ^^^^^ cannot assign twice to immutable variable\n-\n-error[E0384]: cannot assign twice to immutable variable `x` (Ast)\n-  --> $DIR/liveness-assign-imm-local-notes.rs:35:13\n-   |\n-LL |             x = 1;\n-   |             ^^^^^ cannot assign twice to immutable variable\n-\n-error[E0384]: cannot assign twice to immutable variable `x` (Ast)\n-  --> $DIR/liveness-assign-imm-local-notes.rs:38:13\n-   |\n-LL |             x = 1;\n-   |             ----- first assignment to `x`\n-...\n-LL |             x = 2;\n-   |             ^^^^^ cannot assign twice to immutable variable\n-\n-error[E0384]: cannot assign twice to immutable variable `x` (Mir)\n-  --> $DIR/liveness-assign-imm-local-notes.rs:13:9\n+error[E0384]: cannot assign twice to immutable variable `x`\n+  --> $DIR/liveness-assign-imm-local-notes.rs:10:9\n    |\n LL |     let x;\n    |         - help: make this binding mutable: `mut x`\n@@ -40,8 +9,8 @@ LL |         x = 2;\n LL |         x = 3;\n    |         ^^^^^ cannot assign twice to immutable variable\n \n-error[E0384]: cannot assign twice to immutable variable `x` (Mir)\n-  --> $DIR/liveness-assign-imm-local-notes.rs:25:13\n+error[E0384]: cannot assign twice to immutable variable `x`\n+  --> $DIR/liveness-assign-imm-local-notes.rs:21:13\n    |\n LL |         let x;\n    |             - help: make this binding mutable: `mut x`\n@@ -51,27 +20,27 @@ LL |             x = 2;\n LL |             x = 3;\n    |             ^^^^^ cannot assign twice to immutable variable\n \n-error[E0384]: cannot assign twice to immutable variable `x` (Mir)\n-  --> $DIR/liveness-assign-imm-local-notes.rs:35:13\n+error[E0384]: cannot assign twice to immutable variable `x`\n+  --> $DIR/liveness-assign-imm-local-notes.rs:30:13\n    |\n LL |     let x;\n    |         - help: make this binding mutable: `mut x`\n ...\n LL |             x = 1;\n    |             ^^^^^ cannot assign twice to immutable variable\n \n-error[E0384]: cannot assign twice to immutable variable `x` (Mir)\n-  --> $DIR/liveness-assign-imm-local-notes.rs:38:13\n+error[E0384]: cannot assign twice to immutable variable `x`\n+  --> $DIR/liveness-assign-imm-local-notes.rs:32:13\n    |\n LL |     let x;\n    |         - help: make this binding mutable: `mut x`\n ...\n LL |             x = 1;\n    |             ----- first assignment to `x`\n-...\n+LL |         } else {\n LL |             x = 2;\n    |             ^^^^^ cannot assign twice to immutable variable\n \n-error: aborting due to 8 previous errors\n+error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0384`."}, {"sha": "063a4865b1987db22a50bb319e0bd7c01b0823e7", "filename": "src/test/ui/methods/method-ambig-one-trait-unknown-int-type.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-one-trait-unknown-int-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-one-trait-unknown-int-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-ambig-one-trait-unknown-int-type.stderr?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -11,7 +11,7 @@ error[E0308]: mismatched types\n    |\n LL |     let y: usize = x.foo();\n    |                    ^^^^^^^ expected usize, found isize\n-help: you can convert an `isize` to `usize` or panic if it the converted value wouldn't fit\n+help: you can convert an `isize` to `usize` and panic if the converted value wouldn't fit\n    |\n LL |     let y: usize = x.foo().try_into().unwrap();\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "881d9fd32029eb885f2420a88780d62981f8ef6c", "filename": "src/test/ui/mismatched_types/issue-26480.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-26480.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-26480.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-26480.stderr?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -6,7 +6,7 @@ LL |                   $arr.len() * size_of($arr[0]));\n ...\n LL |     write!(hello);\n    |     -------------- in this macro invocation\n-help: you can convert an `usize` to `u64` or panic if it the converted value wouldn't fit\n+help: you can convert an `usize` to `u64` and panic if the converted value wouldn't fit\n    |\n LL |                   ($arr.len() * size_of($arr[0])).try_into().unwrap());\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "828d90cd7ac7f4b48c4e2212c388e0e0a920cd0e", "filename": "src/test/ui/moves/moves-based-on-type-tuple.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-tuple.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -1,11 +1,8 @@\n #![feature(box_syntax)]\n \n-// compile-flags: -Z borrowck=compare\n-\n fn dup(x: Box<isize>) -> Box<(Box<isize>,Box<isize>)> {\n     box (x, x)\n-    //~^ use of moved value: `x` (Ast) [E0382]\n-    //~| use of moved value: `x` (Mir) [E0382]\n+    //~^ use of moved value: `x` [E0382]\n }\n \n fn main() {"}, {"sha": "2e1ddbdf57f98cd7a97095713b2d606e60c812b1", "filename": "src/test/ui/moves/moves-based-on-type-tuple.stderr", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-tuple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-tuple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmoves%2Fmoves-based-on-type-tuple.stderr?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -1,15 +1,5 @@\n-error[E0382]: use of moved value: `x` (Ast)\n-  --> $DIR/moves-based-on-type-tuple.rs:6:13\n-   |\n-LL |     box (x, x)\n-   |          -  ^ value used here after move\n-   |          |\n-   |          value moved here\n-   |\n-   = note: move occurs because `x` has type `std::boxed::Box<isize>`, which does not implement the `Copy` trait\n-\n-error[E0382]: use of moved value: `x` (Mir)\n-  --> $DIR/moves-based-on-type-tuple.rs:6:13\n+error[E0382]: use of moved value: `x`\n+  --> $DIR/moves-based-on-type-tuple.rs:4:13\n    |\n LL | fn dup(x: Box<isize>) -> Box<(Box<isize>,Box<isize>)> {\n    |        - move occurs because `x` has type `std::boxed::Box<isize>`, which does not implement the `Copy` trait\n@@ -18,6 +8,6 @@ LL |     box (x, x)\n    |          |\n    |          value moved here\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0382`."}, {"sha": "ffac8a33da104ba4a65bc2fb40a159c3325800c4", "filename": "src/test/ui/nll/get_default.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fnll%2Fget_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fnll%2Fget_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fget_default.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -3,8 +3,6 @@\n // a variety of errors from the older, AST-based machinery (notably\n // borrowck), and then we get the NLL error at the end.\n \n-// compile-flags:-Zborrowck=compare\n-\n struct Map {\n }\n \n@@ -21,8 +19,7 @@ fn ok(map: &mut Map) -> &String {\n             }\n             None => {\n                 map.set(String::new()); // Ideally, this would not error.\n-                //~^ ERROR borrowed as immutable (Ast)\n-                //~| ERROR borrowed as immutable (Mir)\n+                //~^ ERROR borrowed as immutable\n             }\n         }\n     }\n@@ -33,14 +30,12 @@ fn err(map: &mut Map) -> &String {\n         match map.get() {\n             Some(v) => {\n                 map.set(String::new()); // Both AST and MIR error here\n-                //~^ ERROR borrowed as immutable (Mir)\n-                //~| ERROR borrowed as immutable (Ast)\n+                //~^ ERROR borrowed as immutable\n                 return v;\n             }\n             None => {\n                 map.set(String::new()); // Ideally, just AST would error here\n-                //~^ ERROR borrowed as immutable (Ast)\n-                //~| ERROR borrowed as immutable (Mir)\n+                //~^ ERROR borrowed as immutable\n             }\n         }\n     }"}, {"sha": "af79771e7e1b9acfaffaf421d3bfdb211b300ea5", "filename": "src/test/ui/nll/get_default.stderr", "status": "modified", "additions": 11, "deletions": 47, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fnll%2Fget_default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fnll%2Fget_default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fget_default.stderr?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -1,41 +1,5 @@\n-error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as immutable (Ast)\n-  --> $DIR/get_default.rs:23:17\n-   |\n-LL |         match map.get() {\n-   |               --- immutable borrow occurs here\n-...\n-LL |                 map.set(String::new()); // Ideally, this would not error.\n-   |                 ^^^ mutable borrow occurs here\n-...\n-LL | }\n-   | - immutable borrow ends here\n-\n-error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as immutable (Ast)\n-  --> $DIR/get_default.rs:35:17\n-   |\n-LL |         match map.get() {\n-   |               --- immutable borrow occurs here\n-LL |             Some(v) => {\n-LL |                 map.set(String::new()); // Both AST and MIR error here\n-   |                 ^^^ mutable borrow occurs here\n-...\n-LL | }\n-   | - immutable borrow ends here\n-\n-error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as immutable (Ast)\n-  --> $DIR/get_default.rs:41:17\n-   |\n-LL |         match map.get() {\n-   |               --- immutable borrow occurs here\n-...\n-LL |                 map.set(String::new()); // Ideally, just AST would error here\n-   |                 ^^^ mutable borrow occurs here\n-...\n-LL | }\n-   | - immutable borrow ends here\n-\n-error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as immutable (Mir)\n-  --> $DIR/get_default.rs:23:17\n+error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as immutable\n+  --> $DIR/get_default.rs:21:17\n    |\n LL | fn ok(map: &mut Map) -> &String {\n    |            - let's call the lifetime of this reference `'1`\n@@ -47,10 +11,10 @@ LL |                 return v;\n    |                        - returning this value requires that `*map` is borrowed for `'1`\n ...\n LL |                 map.set(String::new()); // Ideally, this would not error.\n-   |                 ^^^ mutable borrow occurs here\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n \n-error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as immutable (Mir)\n-  --> $DIR/get_default.rs:35:17\n+error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as immutable\n+  --> $DIR/get_default.rs:32:17\n    |\n LL | fn err(map: &mut Map) -> &String {\n    |             - let's call the lifetime of this reference `'1`\n@@ -59,13 +23,13 @@ LL |         match map.get() {\n    |               --- immutable borrow occurs here\n LL |             Some(v) => {\n LL |                 map.set(String::new()); // Both AST and MIR error here\n-   |                 ^^^ mutable borrow occurs here\n-...\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n+LL |\n LL |                 return v;\n    |                        - returning this value requires that `*map` is borrowed for `'1`\n \n-error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as immutable (Mir)\n-  --> $DIR/get_default.rs:41:17\n+error[E0502]: cannot borrow `*map` as mutable because it is also borrowed as immutable\n+  --> $DIR/get_default.rs:37:17\n    |\n LL | fn err(map: &mut Map) -> &String {\n    |             - let's call the lifetime of this reference `'1`\n@@ -77,8 +41,8 @@ LL |                 return v;\n    |                        - returning this value requires that `*map` is borrowed for `'1`\n ...\n LL |                 map.set(String::new()); // Ideally, just AST would error here\n-   |                 ^^^ mutable borrow occurs here\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0502`."}, {"sha": "acd6ec706080ddfdc7b35446e1aec1738e9df7ed", "filename": "src/test/ui/nll/loan_ends_mid_block_pair.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fnll%2Floan_ends_mid_block_pair.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fnll%2Floan_ends_mid_block_pair.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Floan_ends_mid_block_pair.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -1,5 +1,3 @@\n-// compile-flags:-Zborrowck=compare\n-\n #![allow(warnings)]\n #![feature(rustc_attrs)]\n \n@@ -12,12 +10,9 @@ fn nll_fail() {\n     let c = &mut data.0;\n     capitalize(c);\n     data.0 = 'e';\n-    //~^ ERROR (Ast) [E0506]\n-    //~| ERROR (Mir) [E0506]\n+    //~^ ERROR [E0506]\n     data.0 = 'f';\n-    //~^ ERROR (Ast) [E0506]\n     data.0 = 'g';\n-    //~^ ERROR (Ast) [E0506]\n     capitalize(c);\n }\n \n@@ -26,11 +21,8 @@ fn nll_ok() {\n     let c = &mut data.0;\n     capitalize(c);\n     data.0 = 'e';\n-    //~^ ERROR (Ast) [E0506]\n     data.0 = 'f';\n-    //~^ ERROR (Ast) [E0506]\n     data.0 = 'g';\n-    //~^ ERROR (Ast) [E0506]\n }\n \n fn capitalize(_: &mut char) {"}, {"sha": "eb8442b31d7c73b323076b65fee62c112f77bfa5", "filename": "src/test/ui/nll/loan_ends_mid_block_pair.stderr", "status": "modified", "additions": 3, "deletions": 57, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fnll%2Floan_ends_mid_block_pair.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fnll%2Floan_ends_mid_block_pair.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Floan_ends_mid_block_pair.stderr?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -1,59 +1,5 @@\n-error[E0506]: cannot assign to `data.0` because it is borrowed (Ast)\n-  --> $DIR/loan_ends_mid_block_pair.rs:14:5\n-   |\n-LL |     let c = &mut data.0;\n-   |                  ------ borrow of `data.0` occurs here\n-LL |     capitalize(c);\n-LL |     data.0 = 'e';\n-   |     ^^^^^^^^^^^^ assignment to borrowed `data.0` occurs here\n-\n-error[E0506]: cannot assign to `data.0` because it is borrowed (Ast)\n-  --> $DIR/loan_ends_mid_block_pair.rs:17:5\n-   |\n-LL |     let c = &mut data.0;\n-   |                  ------ borrow of `data.0` occurs here\n-...\n-LL |     data.0 = 'f';\n-   |     ^^^^^^^^^^^^ assignment to borrowed `data.0` occurs here\n-\n-error[E0506]: cannot assign to `data.0` because it is borrowed (Ast)\n-  --> $DIR/loan_ends_mid_block_pair.rs:19:5\n-   |\n-LL |     let c = &mut data.0;\n-   |                  ------ borrow of `data.0` occurs here\n-...\n-LL |     data.0 = 'g';\n-   |     ^^^^^^^^^^^^ assignment to borrowed `data.0` occurs here\n-\n-error[E0506]: cannot assign to `data.0` because it is borrowed (Ast)\n-  --> $DIR/loan_ends_mid_block_pair.rs:28:5\n-   |\n-LL |     let c = &mut data.0;\n-   |                  ------ borrow of `data.0` occurs here\n-LL |     capitalize(c);\n-LL |     data.0 = 'e';\n-   |     ^^^^^^^^^^^^ assignment to borrowed `data.0` occurs here\n-\n-error[E0506]: cannot assign to `data.0` because it is borrowed (Ast)\n-  --> $DIR/loan_ends_mid_block_pair.rs:30:5\n-   |\n-LL |     let c = &mut data.0;\n-   |                  ------ borrow of `data.0` occurs here\n-...\n-LL |     data.0 = 'f';\n-   |     ^^^^^^^^^^^^ assignment to borrowed `data.0` occurs here\n-\n-error[E0506]: cannot assign to `data.0` because it is borrowed (Ast)\n-  --> $DIR/loan_ends_mid_block_pair.rs:32:5\n-   |\n-LL |     let c = &mut data.0;\n-   |                  ------ borrow of `data.0` occurs here\n-...\n-LL |     data.0 = 'g';\n-   |     ^^^^^^^^^^^^ assignment to borrowed `data.0` occurs here\n-\n-error[E0506]: cannot assign to `data.0` because it is borrowed (Mir)\n-  --> $DIR/loan_ends_mid_block_pair.rs:14:5\n+error[E0506]: cannot assign to `data.0` because it is borrowed\n+  --> $DIR/loan_ends_mid_block_pair.rs:12:5\n    |\n LL |     let c = &mut data.0;\n    |             ----------- borrow of `data.0` occurs here\n@@ -64,6 +10,6 @@ LL |     data.0 = 'e';\n LL |     capitalize(c);\n    |                - borrow later used here\n \n-error: aborting due to 7 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0506`."}, {"sha": "2edcdef0af86cfbf0b6c4f7236edd9b496472e39", "filename": "src/test/ui/nll/loan_ends_mid_block_vec.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fnll%2Floan_ends_mid_block_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fnll%2Floan_ends_mid_block_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Floan_ends_mid_block_vec.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -1,5 +1,3 @@\n-// compile-flags:-Zborrowck=compare\n-\n #![allow(warnings)]\n #![feature(rustc_attrs)]\n \n@@ -11,14 +9,11 @@ fn nll_fail() {\n     let slice = &mut data;\n     capitalize(slice);\n     data.push('d');\n-    //~^ ERROR (Ast) [E0499]\n-    //~| ERROR (Mir) [E0499]\n+    //~^ ERROR [E0499]\n     data.push('e');\n-    //~^ ERROR (Ast) [E0499]\n-    //~| ERROR (Mir) [E0499]\n+    //~^ ERROR [E0499]\n     data.push('f');\n-    //~^ ERROR (Ast) [E0499]\n-    //~| ERROR (Mir) [E0499]\n+    //~^ ERROR [E0499]\n     capitalize(slice);\n }\n \n@@ -27,11 +22,8 @@ fn nll_ok() {\n     let slice = &mut data;\n     capitalize(slice);\n     data.push('d');\n-    //~^ ERROR (Ast) [E0499]\n     data.push('e');\n-    //~^ ERROR (Ast) [E0499]\n     data.push('f');\n-    //~^ ERROR (Ast) [E0499]\n }\n \n fn capitalize(_: &mut [char]) {"}, {"sha": "c0b97bea348c4b99c5b07be4ce1d53635ee7abd1", "filename": "src/test/ui/nll/loan_ends_mid_block_vec.stderr", "status": "modified", "additions": 8, "deletions": 80, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fnll%2Floan_ends_mid_block_vec.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fnll%2Floan_ends_mid_block_vec.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Floan_ends_mid_block_vec.stderr?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -1,77 +1,5 @@\n-error[E0499]: cannot borrow `data` as mutable more than once at a time (Ast)\n-  --> $DIR/loan_ends_mid_block_vec.rs:13:5\n-   |\n-LL |     let slice = &mut data;\n-   |                      ---- first mutable borrow occurs here\n-LL |     capitalize(slice);\n-LL |     data.push('d');\n-   |     ^^^^ second mutable borrow occurs here\n-...\n-LL | }\n-   | - first borrow ends here\n-\n-error[E0499]: cannot borrow `data` as mutable more than once at a time (Ast)\n-  --> $DIR/loan_ends_mid_block_vec.rs:16:5\n-   |\n-LL |     let slice = &mut data;\n-   |                      ---- first mutable borrow occurs here\n-...\n-LL |     data.push('e');\n-   |     ^^^^ second mutable borrow occurs here\n-...\n-LL | }\n-   | - first borrow ends here\n-\n-error[E0499]: cannot borrow `data` as mutable more than once at a time (Ast)\n-  --> $DIR/loan_ends_mid_block_vec.rs:19:5\n-   |\n-LL |     let slice = &mut data;\n-   |                      ---- first mutable borrow occurs here\n-...\n-LL |     data.push('f');\n-   |     ^^^^ second mutable borrow occurs here\n-...\n-LL | }\n-   | - first borrow ends here\n-\n-error[E0499]: cannot borrow `data` as mutable more than once at a time (Ast)\n-  --> $DIR/loan_ends_mid_block_vec.rs:29:5\n-   |\n-LL |     let slice = &mut data;\n-   |                      ---- first mutable borrow occurs here\n-LL |     capitalize(slice);\n-LL |     data.push('d');\n-   |     ^^^^ second mutable borrow occurs here\n-...\n-LL | }\n-   | - first borrow ends here\n-\n-error[E0499]: cannot borrow `data` as mutable more than once at a time (Ast)\n-  --> $DIR/loan_ends_mid_block_vec.rs:31:5\n-   |\n-LL |     let slice = &mut data;\n-   |                      ---- first mutable borrow occurs here\n-...\n-LL |     data.push('e');\n-   |     ^^^^ second mutable borrow occurs here\n-...\n-LL | }\n-   | - first borrow ends here\n-\n-error[E0499]: cannot borrow `data` as mutable more than once at a time (Ast)\n-  --> $DIR/loan_ends_mid_block_vec.rs:33:5\n-   |\n-LL |     let slice = &mut data;\n-   |                      ---- first mutable borrow occurs here\n-...\n-LL |     data.push('f');\n-   |     ^^^^ second mutable borrow occurs here\n-LL |\n-LL | }\n-   | - first borrow ends here\n-\n-error[E0499]: cannot borrow `data` as mutable more than once at a time (Mir)\n-  --> $DIR/loan_ends_mid_block_vec.rs:13:5\n+error[E0499]: cannot borrow `data` as mutable more than once at a time\n+  --> $DIR/loan_ends_mid_block_vec.rs:11:5\n    |\n LL |     let slice = &mut data;\n    |                 --------- first mutable borrow occurs here\n@@ -82,8 +10,8 @@ LL |     data.push('d');\n LL |     capitalize(slice);\n    |                ----- first borrow later used here\n \n-error[E0499]: cannot borrow `data` as mutable more than once at a time (Mir)\n-  --> $DIR/loan_ends_mid_block_vec.rs:16:5\n+error[E0499]: cannot borrow `data` as mutable more than once at a time\n+  --> $DIR/loan_ends_mid_block_vec.rs:13:5\n    |\n LL |     let slice = &mut data;\n    |                 --------- first mutable borrow occurs here\n@@ -94,18 +22,18 @@ LL |     data.push('e');\n LL |     capitalize(slice);\n    |                ----- first borrow later used here\n \n-error[E0499]: cannot borrow `data` as mutable more than once at a time (Mir)\n-  --> $DIR/loan_ends_mid_block_vec.rs:19:5\n+error[E0499]: cannot borrow `data` as mutable more than once at a time\n+  --> $DIR/loan_ends_mid_block_vec.rs:15:5\n    |\n LL |     let slice = &mut data;\n    |                 --------- first mutable borrow occurs here\n ...\n LL |     data.push('f');\n    |     ^^^^ second mutable borrow occurs here\n-...\n+LL |\n LL |     capitalize(slice);\n    |                ----- first borrow later used here\n \n-error: aborting due to 9 previous errors\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0499`."}, {"sha": "f67de03caf22565371603948ca2f290f4da5b38a", "filename": "src/test/ui/nll/region-ends-after-if-condition.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fnll%2Fregion-ends-after-if-condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fnll%2Fregion-ends-after-if-condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fregion-ends-after-if-condition.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -2,8 +2,6 @@\n // in the type of `p` includes the points after `&v[0]` up to (but not\n // including) the call to `use_x`. The `else` branch is not included.\n \n-// compile-flags:-Zborrowck=compare\n-\n #![allow(warnings)]\n #![feature(rustc_attrs)]\n \n@@ -17,7 +15,6 @@ fn foo1() {\n     let value = &my_struct.field;\n     if value.is_empty() {\n         my_struct.field.push_str(\"Hello, world!\");\n-        //~^ ERROR (Ast) [E0502]\n     }\n }\n \n@@ -27,8 +24,7 @@ fn foo2() {\n     let value = &my_struct.field;\n     if value.is_empty() {\n         my_struct.field.push_str(\"Hello, world!\");\n-        //~^ ERROR (Ast) [E0502]\n-        //~| ERROR (Mir) [E0502]\n+        //~^ ERROR [E0502]\n     }\n     drop(value);\n }"}, {"sha": "c03e385790616464648a63bd7b34fbac0fa54441", "filename": "src/test/ui/nll/region-ends-after-if-condition.stderr", "status": "modified", "additions": 4, "deletions": 28, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fnll%2Fregion-ends-after-if-condition.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fnll%2Fregion-ends-after-if-condition.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fregion-ends-after-if-condition.stderr?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -1,39 +1,15 @@\n-error[E0502]: cannot borrow `my_struct.field` as mutable because it is also borrowed as immutable (Ast)\n-  --> $DIR/region-ends-after-if-condition.rs:19:9\n-   |\n-LL |     let value = &my_struct.field;\n-   |                  --------------- immutable borrow occurs here\n-LL |     if value.is_empty() {\n-LL |         my_struct.field.push_str(\"Hello, world!\");\n-   |         ^^^^^^^^^^^^^^^ mutable borrow occurs here\n-...\n-LL | }\n-   | - immutable borrow ends here\n-\n-error[E0502]: cannot borrow `my_struct.field` as mutable because it is also borrowed as immutable (Ast)\n-  --> $DIR/region-ends-after-if-condition.rs:29:9\n-   |\n-LL |     let value = &my_struct.field;\n-   |                  --------------- immutable borrow occurs here\n-LL |     if value.is_empty() {\n-LL |         my_struct.field.push_str(\"Hello, world!\");\n-   |         ^^^^^^^^^^^^^^^ mutable borrow occurs here\n-...\n-LL | }\n-   | - immutable borrow ends here\n-\n-error[E0502]: cannot borrow `my_struct.field` as mutable because it is also borrowed as immutable (Mir)\n-  --> $DIR/region-ends-after-if-condition.rs:29:9\n+error[E0502]: cannot borrow `my_struct.field` as mutable because it is also borrowed as immutable\n+  --> $DIR/region-ends-after-if-condition.rs:26:9\n    |\n LL |     let value = &my_struct.field;\n    |                 ---------------- immutable borrow occurs here\n LL |     if value.is_empty() {\n LL |         my_struct.field.push_str(\"Hello, world!\");\n-   |         ^^^^^^^^^^^^^^^ mutable borrow occurs here\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n ...\n LL |     drop(value);\n    |          ----- immutable borrow later used here\n \n-error: aborting due to 3 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0502`."}, {"sha": "49541089405f2f4bc3c2ee435436db337fbb4021", "filename": "src/test/ui/nll/return_from_loop.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fnll%2Freturn_from_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fnll%2Freturn_from_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Freturn_from_loop.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -2,8 +2,6 @@\n // in the type of `p` includes the points after `&v[0]` up to (but not\n // including) the call to `use_x`. The `else` branch is not included.\n \n-// compile-flags:-Zborrowck=compare\n-\n #![allow(warnings)]\n #![feature(rustc_attrs)]\n \n@@ -20,8 +18,7 @@ fn nll_fail() {\n     let value = &mut my_struct.field;\n     loop {\n         my_struct.field.push_str(\"Hello, world!\");\n-        //~^ ERROR (Ast) [E0499]\n-        //~| ERROR (Mir) [E0499]\n+        //~^ ERROR [E0499]\n         value.len();\n         return;\n     }\n@@ -33,7 +30,6 @@ fn nll_ok() {\n     let value = &mut my_struct.field;\n     loop {\n         my_struct.field.push_str(\"Hello, world!\");\n-        //~^ ERROR (Ast) [E0499]\n         return;\n     }\n }"}, {"sha": "efd56ea2dd5423ff6cf8aaa9ee803f80f89f9eea", "filename": "src/test/ui/nll/return_from_loop.stderr", "status": "modified", "additions": 4, "deletions": 28, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fnll%2Freturn_from_loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fnll%2Freturn_from_loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Freturn_from_loop.stderr?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -1,39 +1,15 @@\n-error[E0499]: cannot borrow `my_struct.field` as mutable more than once at a time (Ast)\n-  --> $DIR/return_from_loop.rs:22:9\n-   |\n-LL |     let value = &mut my_struct.field;\n-   |                      --------------- first mutable borrow occurs here\n-LL |     loop {\n-LL |         my_struct.field.push_str(\"Hello, world!\");\n-   |         ^^^^^^^^^^^^^^^ second mutable borrow occurs here\n-...\n-LL | }\n-   | - first borrow ends here\n-\n-error[E0499]: cannot borrow `my_struct.field` as mutable more than once at a time (Ast)\n-  --> $DIR/return_from_loop.rs:35:9\n-   |\n-LL |     let value = &mut my_struct.field;\n-   |                      --------------- first mutable borrow occurs here\n-LL |     loop {\n-LL |         my_struct.field.push_str(\"Hello, world!\");\n-   |         ^^^^^^^^^^^^^^^ second mutable borrow occurs here\n-...\n-LL | }\n-   | - first borrow ends here\n-\n-error[E0499]: cannot borrow `my_struct.field` as mutable more than once at a time (Mir)\n-  --> $DIR/return_from_loop.rs:22:9\n+error[E0499]: cannot borrow `my_struct.field` as mutable more than once at a time\n+  --> $DIR/return_from_loop.rs:20:9\n    |\n LL |     let value = &mut my_struct.field;\n    |                 -------------------- first mutable borrow occurs here\n LL |     loop {\n LL |         my_struct.field.push_str(\"Hello, world!\");\n    |         ^^^^^^^^^^^^^^^ second mutable borrow occurs here\n-...\n+LL |\n LL |         value.len();\n    |         ----- first borrow later used here\n \n-error: aborting due to 3 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0499`."}, {"sha": "3f69bcc7d4a2f3a2ced0320c804a25b09bcdc719", "filename": "src/test/ui/numeric/const-scope.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fnumeric%2Fconst-scope.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fnumeric%2Fconst-scope.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumeric%2Fconst-scope.stderr?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -37,7 +37,7 @@ error[E0308]: mismatched types\n    |\n LL |     let d: i8 = c;\n    |                 ^ expected i8, found i32\n-help: you can convert an `i32` to `i8` or panic if it the converted value wouldn't fit\n+help: you can convert an `i32` to `i8` and panic if the converted value wouldn't fit\n    |\n LL |     let d: i8 = c.try_into().unwrap();\n    |                 ^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "c767bdd9bd5a5ca41fa1f5644ac4238c3451f317", "filename": "src/test/ui/numeric/len.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fnumeric%2Flen.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fnumeric%2Flen.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumeric%2Flen.stderr?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -3,7 +3,7 @@ error[E0308]: mismatched types\n    |\n LL |     test(array.len());\n    |          ^^^^^^^^^^^ expected u32, found usize\n-help: you can convert an `usize` to `u32` or panic if it the converted value wouldn't fit\n+help: you can convert an `usize` to `u32` and panic if the converted value wouldn't fit\n    |\n LL |     test(array.len().try_into().unwrap());\n    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "f58389ce96c3b6e3fa7fcdfb131bd231f061f861", "filename": "src/test/ui/numeric/numeric-cast-2.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fnumeric%2Fnumeric-cast-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fnumeric%2Fnumeric-cast-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumeric%2Fnumeric-cast-2.stderr?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -3,7 +3,7 @@ error[E0308]: mismatched types\n    |\n LL |     let x: u16 = foo();\n    |                  ^^^^^ expected u16, found i32\n-help: you can convert an `i32` to `u16` or panic if it the converted value wouldn't fit\n+help: you can convert an `i32` to `u16` and panic if the converted value wouldn't fit\n    |\n LL |     let x: u16 = foo().try_into().unwrap();\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -13,7 +13,7 @@ error[E0308]: mismatched types\n    |\n LL |     let y: i64 = x + x;\n    |                  ^^^^^ expected i64, found u16\n-help: you can convert an `u16` to `i64` or panic if it the converted value wouldn't fit\n+help: you can convert an `u16` to `i64` and panic if the converted value wouldn't fit\n    |\n LL |     let y: i64 = (x + x).try_into().unwrap();\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -23,7 +23,7 @@ error[E0308]: mismatched types\n    |\n LL |     let z: i32 = x + x;\n    |                  ^^^^^ expected i32, found u16\n-help: you can convert an `u16` to `i32` or panic if it the converted value wouldn't fit\n+help: you can convert an `u16` to `i32` and panic if the converted value wouldn't fit\n    |\n LL |     let z: i32 = (x + x).try_into().unwrap();\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "e66b83f2b39f5c38a7d5fd26fe38788c98041872", "filename": "src/test/ui/numeric/numeric-cast.stderr", "status": "modified", "additions": 78, "deletions": 78, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fnumeric%2Fnumeric-cast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fnumeric%2Fnumeric-cast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumeric%2Fnumeric-cast.stderr?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -3,7 +3,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<usize>(x_u64);\n    |                  ^^^^^ expected usize, found u64\n-help: you can convert an `u64` to `usize` or panic if it the converted value wouldn't fit\n+help: you can convert an `u64` to `usize` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<usize>(x_u64.try_into().unwrap());\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -13,7 +13,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<usize>(x_u32);\n    |                  ^^^^^ expected usize, found u32\n-help: you can convert an `u32` to `usize` or panic if it the converted value wouldn't fit\n+help: you can convert an `u32` to `usize` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<usize>(x_u32.try_into().unwrap());\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -23,7 +23,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<usize>(x_u16);\n    |                  ^^^^^ expected usize, found u16\n-help: you can convert an `u16` to `usize` or panic if it the converted value wouldn't fit\n+help: you can convert an `u16` to `usize` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<usize>(x_u16.try_into().unwrap());\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -33,7 +33,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<usize>(x_u8);\n    |                  ^^^^ expected usize, found u8\n-help: you can convert an `u8` to `usize` or panic if it the converted value wouldn't fit\n+help: you can convert an `u8` to `usize` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<usize>(x_u8.try_into().unwrap());\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -43,7 +43,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<usize>(x_isize);\n    |                  ^^^^^^^ expected usize, found isize\n-help: you can convert an `isize` to `usize` or panic if it the converted value wouldn't fit\n+help: you can convert an `isize` to `usize` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<usize>(x_isize.try_into().unwrap());\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -53,7 +53,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<usize>(x_i64);\n    |                  ^^^^^ expected usize, found i64\n-help: you can convert an `i64` to `usize` or panic if it the converted value wouldn't fit\n+help: you can convert an `i64` to `usize` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<usize>(x_i64.try_into().unwrap());\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -63,7 +63,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<usize>(x_i32);\n    |                  ^^^^^ expected usize, found i32\n-help: you can convert an `i32` to `usize` or panic if it the converted value wouldn't fit\n+help: you can convert an `i32` to `usize` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<usize>(x_i32.try_into().unwrap());\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -73,7 +73,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<usize>(x_i16);\n    |                  ^^^^^ expected usize, found i16\n-help: you can convert an `i16` to `usize` or panic if it the converted value wouldn't fit\n+help: you can convert an `i16` to `usize` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<usize>(x_i16.try_into().unwrap());\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -83,7 +83,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<usize>(x_i8);\n    |                  ^^^^ expected usize, found i8\n-help: you can convert an `i8` to `usize` or panic if it the converted value wouldn't fit\n+help: you can convert an `i8` to `usize` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<usize>(x_i8.try_into().unwrap());\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -93,7 +93,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<isize>(x_usize);\n    |                  ^^^^^^^ expected isize, found usize\n-help: you can convert an `usize` to `isize` or panic if it the converted value wouldn't fit\n+help: you can convert an `usize` to `isize` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<isize>(x_usize.try_into().unwrap());\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -103,7 +103,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<isize>(x_u64);\n    |                  ^^^^^ expected isize, found u64\n-help: you can convert an `u64` to `isize` or panic if it the converted value wouldn't fit\n+help: you can convert an `u64` to `isize` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<isize>(x_u64.try_into().unwrap());\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -113,7 +113,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<isize>(x_u32);\n    |                  ^^^^^ expected isize, found u32\n-help: you can convert an `u32` to `isize` or panic if it the converted value wouldn't fit\n+help: you can convert an `u32` to `isize` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<isize>(x_u32.try_into().unwrap());\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -123,7 +123,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<isize>(x_u16);\n    |                  ^^^^^ expected isize, found u16\n-help: you can convert an `u16` to `isize` or panic if it the converted value wouldn't fit\n+help: you can convert an `u16` to `isize` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<isize>(x_u16.try_into().unwrap());\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -133,7 +133,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<isize>(x_u8);\n    |                  ^^^^ expected isize, found u8\n-help: you can convert an `u8` to `isize` or panic if it the converted value wouldn't fit\n+help: you can convert an `u8` to `isize` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<isize>(x_u8.try_into().unwrap());\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -143,7 +143,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<isize>(x_i64);\n    |                  ^^^^^ expected isize, found i64\n-help: you can convert an `i64` to `isize` or panic if it the converted value wouldn't fit\n+help: you can convert an `i64` to `isize` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<isize>(x_i64.try_into().unwrap());\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -153,7 +153,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<isize>(x_i32);\n    |                  ^^^^^ expected isize, found i32\n-help: you can convert an `i32` to `isize` or panic if it the converted value wouldn't fit\n+help: you can convert an `i32` to `isize` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<isize>(x_i32.try_into().unwrap());\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -163,7 +163,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<isize>(x_i16);\n    |                  ^^^^^ expected isize, found i16\n-help: you can convert an `i16` to `isize` or panic if it the converted value wouldn't fit\n+help: you can convert an `i16` to `isize` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<isize>(x_i16.try_into().unwrap());\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -173,7 +173,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<isize>(x_i8);\n    |                  ^^^^ expected isize, found i8\n-help: you can convert an `i8` to `isize` or panic if it the converted value wouldn't fit\n+help: you can convert an `i8` to `isize` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<isize>(x_i8.try_into().unwrap());\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -183,7 +183,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<u64>(x_usize);\n    |                ^^^^^^^ expected u64, found usize\n-help: you can convert an `usize` to `u64` or panic if it the converted value wouldn't fit\n+help: you can convert an `usize` to `u64` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<u64>(x_usize.try_into().unwrap());\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -220,7 +220,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<u64>(x_isize);\n    |                ^^^^^^^ expected u64, found isize\n-help: you can convert an `isize` to `u64` or panic if it the converted value wouldn't fit\n+help: you can convert an `isize` to `u64` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<u64>(x_isize.try_into().unwrap());\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -230,7 +230,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<u64>(x_i64);\n    |                ^^^^^ expected u64, found i64\n-help: you can convert an `i64` to `u64` or panic if it the converted value wouldn't fit\n+help: you can convert an `i64` to `u64` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<u64>(x_i64.try_into().unwrap());\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -240,7 +240,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<u64>(x_i32);\n    |                ^^^^^ expected u64, found i32\n-help: you can convert an `i32` to `u64` or panic if it the converted value wouldn't fit\n+help: you can convert an `i32` to `u64` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<u64>(x_i32.try_into().unwrap());\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -250,7 +250,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<u64>(x_i16);\n    |                ^^^^^ expected u64, found i16\n-help: you can convert an `i16` to `u64` or panic if it the converted value wouldn't fit\n+help: you can convert an `i16` to `u64` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<u64>(x_i16.try_into().unwrap());\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -260,7 +260,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<u64>(x_i8);\n    |                ^^^^ expected u64, found i8\n-help: you can convert an `i8` to `u64` or panic if it the converted value wouldn't fit\n+help: you can convert an `i8` to `u64` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<u64>(x_i8.try_into().unwrap());\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -270,7 +270,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<i64>(x_usize);\n    |                ^^^^^^^ expected i64, found usize\n-help: you can convert an `usize` to `i64` or panic if it the converted value wouldn't fit\n+help: you can convert an `usize` to `i64` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<i64>(x_usize.try_into().unwrap());\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -280,7 +280,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<i64>(x_u64);\n    |                ^^^^^ expected i64, found u64\n-help: you can convert an `u64` to `i64` or panic if it the converted value wouldn't fit\n+help: you can convert an `u64` to `i64` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<i64>(x_u64.try_into().unwrap());\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -290,7 +290,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<i64>(x_u32);\n    |                ^^^^^ expected i64, found u32\n-help: you can convert an `u32` to `i64` or panic if it the converted value wouldn't fit\n+help: you can convert an `u32` to `i64` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<i64>(x_u32.try_into().unwrap());\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -300,7 +300,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<i64>(x_u16);\n    |                ^^^^^ expected i64, found u16\n-help: you can convert an `u16` to `i64` or panic if it the converted value wouldn't fit\n+help: you can convert an `u16` to `i64` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<i64>(x_u16.try_into().unwrap());\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -310,7 +310,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<i64>(x_u8);\n    |                ^^^^ expected i64, found u8\n-help: you can convert an `u8` to `i64` or panic if it the converted value wouldn't fit\n+help: you can convert an `u8` to `i64` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<i64>(x_u8.try_into().unwrap());\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -320,7 +320,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<i64>(x_isize);\n    |                ^^^^^^^ expected i64, found isize\n-help: you can convert an `isize` to `i64` or panic if it the converted value wouldn't fit\n+help: you can convert an `isize` to `i64` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<i64>(x_isize.try_into().unwrap());\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -357,7 +357,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<u32>(x_usize);\n    |                ^^^^^^^ expected u32, found usize\n-help: you can convert an `usize` to `u32` or panic if it the converted value wouldn't fit\n+help: you can convert an `usize` to `u32` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<u32>(x_usize.try_into().unwrap());\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -367,7 +367,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<u32>(x_u64);\n    |                ^^^^^ expected u32, found u64\n-help: you can convert an `u64` to `u32` or panic if it the converted value wouldn't fit\n+help: you can convert an `u64` to `u32` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<u32>(x_u64.try_into().unwrap());\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -395,7 +395,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<u32>(x_isize);\n    |                ^^^^^^^ expected u32, found isize\n-help: you can convert an `isize` to `u32` or panic if it the converted value wouldn't fit\n+help: you can convert an `isize` to `u32` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<u32>(x_isize.try_into().unwrap());\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -405,7 +405,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<u32>(x_i64);\n    |                ^^^^^ expected u32, found i64\n-help: you can convert an `i64` to `u32` or panic if it the converted value wouldn't fit\n+help: you can convert an `i64` to `u32` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<u32>(x_i64.try_into().unwrap());\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -415,7 +415,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<u32>(x_i32);\n    |                ^^^^^ expected u32, found i32\n-help: you can convert an `i32` to `u32` or panic if it the converted value wouldn't fit\n+help: you can convert an `i32` to `u32` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<u32>(x_i32.try_into().unwrap());\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -425,7 +425,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<u32>(x_i16);\n    |                ^^^^^ expected u32, found i16\n-help: you can convert an `i16` to `u32` or panic if it the converted value wouldn't fit\n+help: you can convert an `i16` to `u32` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<u32>(x_i16.try_into().unwrap());\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -435,7 +435,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<u32>(x_i8);\n    |                ^^^^ expected u32, found i8\n-help: you can convert an `i8` to `u32` or panic if it the converted value wouldn't fit\n+help: you can convert an `i8` to `u32` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<u32>(x_i8.try_into().unwrap());\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -445,7 +445,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<i32>(x_usize);\n    |                ^^^^^^^ expected i32, found usize\n-help: you can convert an `usize` to `i32` or panic if it the converted value wouldn't fit\n+help: you can convert an `usize` to `i32` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<i32>(x_usize.try_into().unwrap());\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -455,7 +455,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<i32>(x_u64);\n    |                ^^^^^ expected i32, found u64\n-help: you can convert an `u64` to `i32` or panic if it the converted value wouldn't fit\n+help: you can convert an `u64` to `i32` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<i32>(x_u64.try_into().unwrap());\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -465,7 +465,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<i32>(x_u32);\n    |                ^^^^^ expected i32, found u32\n-help: you can convert an `u32` to `i32` or panic if it the converted value wouldn't fit\n+help: you can convert an `u32` to `i32` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<i32>(x_u32.try_into().unwrap());\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -475,7 +475,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<i32>(x_u16);\n    |                ^^^^^ expected i32, found u16\n-help: you can convert an `u16` to `i32` or panic if it the converted value wouldn't fit\n+help: you can convert an `u16` to `i32` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<i32>(x_u16.try_into().unwrap());\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -485,7 +485,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<i32>(x_u8);\n    |                ^^^^ expected i32, found u8\n-help: you can convert an `u8` to `i32` or panic if it the converted value wouldn't fit\n+help: you can convert an `u8` to `i32` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<i32>(x_u8.try_into().unwrap());\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -495,7 +495,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<i32>(x_isize);\n    |                ^^^^^^^ expected i32, found isize\n-help: you can convert an `isize` to `i32` or panic if it the converted value wouldn't fit\n+help: you can convert an `isize` to `i32` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<i32>(x_isize.try_into().unwrap());\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -505,7 +505,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<i32>(x_i64);\n    |                ^^^^^ expected i32, found i64\n-help: you can convert an `i64` to `i32` or panic if it the converted value wouldn't fit\n+help: you can convert an `i64` to `i32` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<i32>(x_i64.try_into().unwrap());\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -533,7 +533,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<u16>(x_usize);\n    |                ^^^^^^^ expected u16, found usize\n-help: you can convert an `usize` to `u16` or panic if it the converted value wouldn't fit\n+help: you can convert an `usize` to `u16` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<u16>(x_usize.try_into().unwrap());\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -543,7 +543,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<u16>(x_u64);\n    |                ^^^^^ expected u16, found u64\n-help: you can convert an `u64` to `u16` or panic if it the converted value wouldn't fit\n+help: you can convert an `u64` to `u16` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<u16>(x_u64.try_into().unwrap());\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -553,7 +553,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<u16>(x_u32);\n    |                ^^^^^ expected u16, found u32\n-help: you can convert an `u32` to `u16` or panic if it the converted value wouldn't fit\n+help: you can convert an `u32` to `u16` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<u16>(x_u32.try_into().unwrap());\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -572,7 +572,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<u16>(x_isize);\n    |                ^^^^^^^ expected u16, found isize\n-help: you can convert an `isize` to `u16` or panic if it the converted value wouldn't fit\n+help: you can convert an `isize` to `u16` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<u16>(x_isize.try_into().unwrap());\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -582,7 +582,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<u16>(x_i64);\n    |                ^^^^^ expected u16, found i64\n-help: you can convert an `i64` to `u16` or panic if it the converted value wouldn't fit\n+help: you can convert an `i64` to `u16` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<u16>(x_i64.try_into().unwrap());\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -592,7 +592,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<u16>(x_i32);\n    |                ^^^^^ expected u16, found i32\n-help: you can convert an `i32` to `u16` or panic if it the converted value wouldn't fit\n+help: you can convert an `i32` to `u16` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<u16>(x_i32.try_into().unwrap());\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -602,7 +602,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<u16>(x_i16);\n    |                ^^^^^ expected u16, found i16\n-help: you can convert an `i16` to `u16` or panic if it the converted value wouldn't fit\n+help: you can convert an `i16` to `u16` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<u16>(x_i16.try_into().unwrap());\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -612,7 +612,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<u16>(x_i8);\n    |                ^^^^ expected u16, found i8\n-help: you can convert an `i8` to `u16` or panic if it the converted value wouldn't fit\n+help: you can convert an `i8` to `u16` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<u16>(x_i8.try_into().unwrap());\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -622,7 +622,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<i16>(x_usize);\n    |                ^^^^^^^ expected i16, found usize\n-help: you can convert an `usize` to `i16` or panic if it the converted value wouldn't fit\n+help: you can convert an `usize` to `i16` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<i16>(x_usize.try_into().unwrap());\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -632,7 +632,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<i16>(x_u64);\n    |                ^^^^^ expected i16, found u64\n-help: you can convert an `u64` to `i16` or panic if it the converted value wouldn't fit\n+help: you can convert an `u64` to `i16` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<i16>(x_u64.try_into().unwrap());\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -642,7 +642,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<i16>(x_u32);\n    |                ^^^^^ expected i16, found u32\n-help: you can convert an `u32` to `i16` or panic if it the converted value wouldn't fit\n+help: you can convert an `u32` to `i16` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<i16>(x_u32.try_into().unwrap());\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -652,7 +652,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<i16>(x_u16);\n    |                ^^^^^ expected i16, found u16\n-help: you can convert an `u16` to `i16` or panic if it the converted value wouldn't fit\n+help: you can convert an `u16` to `i16` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<i16>(x_u16.try_into().unwrap());\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -662,7 +662,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<i16>(x_u8);\n    |                ^^^^ expected i16, found u8\n-help: you can convert an `u8` to `i16` or panic if it the converted value wouldn't fit\n+help: you can convert an `u8` to `i16` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<i16>(x_u8.try_into().unwrap());\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -672,7 +672,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<i16>(x_isize);\n    |                ^^^^^^^ expected i16, found isize\n-help: you can convert an `isize` to `i16` or panic if it the converted value wouldn't fit\n+help: you can convert an `isize` to `i16` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<i16>(x_isize.try_into().unwrap());\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -682,7 +682,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<i16>(x_i64);\n    |                ^^^^^ expected i16, found i64\n-help: you can convert an `i64` to `i16` or panic if it the converted value wouldn't fit\n+help: you can convert an `i64` to `i16` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<i16>(x_i64.try_into().unwrap());\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -692,7 +692,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<i16>(x_i32);\n    |                ^^^^^ expected i16, found i32\n-help: you can convert an `i32` to `i16` or panic if it the converted value wouldn't fit\n+help: you can convert an `i32` to `i16` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<i16>(x_i32.try_into().unwrap());\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -711,7 +711,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<u8>(x_usize);\n    |               ^^^^^^^ expected u8, found usize\n-help: you can convert an `usize` to `u8` or panic if it the converted value wouldn't fit\n+help: you can convert an `usize` to `u8` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<u8>(x_usize.try_into().unwrap());\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -721,7 +721,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<u8>(x_u64);\n    |               ^^^^^ expected u8, found u64\n-help: you can convert an `u64` to `u8` or panic if it the converted value wouldn't fit\n+help: you can convert an `u64` to `u8` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<u8>(x_u64.try_into().unwrap());\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -731,7 +731,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<u8>(x_u32);\n    |               ^^^^^ expected u8, found u32\n-help: you can convert an `u32` to `u8` or panic if it the converted value wouldn't fit\n+help: you can convert an `u32` to `u8` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<u8>(x_u32.try_into().unwrap());\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -741,7 +741,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<u8>(x_u16);\n    |               ^^^^^ expected u8, found u16\n-help: you can convert an `u16` to `u8` or panic if it the converted value wouldn't fit\n+help: you can convert an `u16` to `u8` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<u8>(x_u16.try_into().unwrap());\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -751,7 +751,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<u8>(x_isize);\n    |               ^^^^^^^ expected u8, found isize\n-help: you can convert an `isize` to `u8` or panic if it the converted value wouldn't fit\n+help: you can convert an `isize` to `u8` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<u8>(x_isize.try_into().unwrap());\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -761,7 +761,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<u8>(x_i64);\n    |               ^^^^^ expected u8, found i64\n-help: you can convert an `i64` to `u8` or panic if it the converted value wouldn't fit\n+help: you can convert an `i64` to `u8` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<u8>(x_i64.try_into().unwrap());\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -771,7 +771,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<u8>(x_i32);\n    |               ^^^^^ expected u8, found i32\n-help: you can convert an `i32` to `u8` or panic if it the converted value wouldn't fit\n+help: you can convert an `i32` to `u8` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<u8>(x_i32.try_into().unwrap());\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -781,7 +781,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<u8>(x_i16);\n    |               ^^^^^ expected u8, found i16\n-help: you can convert an `i16` to `u8` or panic if it the converted value wouldn't fit\n+help: you can convert an `i16` to `u8` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<u8>(x_i16.try_into().unwrap());\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -791,7 +791,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<u8>(x_i8);\n    |               ^^^^ expected u8, found i8\n-help: you can convert an `i8` to `u8` or panic if it the converted value wouldn't fit\n+help: you can convert an `i8` to `u8` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<u8>(x_i8.try_into().unwrap());\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -801,7 +801,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<i8>(x_usize);\n    |               ^^^^^^^ expected i8, found usize\n-help: you can convert an `usize` to `i8` or panic if it the converted value wouldn't fit\n+help: you can convert an `usize` to `i8` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<i8>(x_usize.try_into().unwrap());\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -811,7 +811,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<i8>(x_u64);\n    |               ^^^^^ expected i8, found u64\n-help: you can convert an `u64` to `i8` or panic if it the converted value wouldn't fit\n+help: you can convert an `u64` to `i8` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<i8>(x_u64.try_into().unwrap());\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -821,7 +821,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<i8>(x_u32);\n    |               ^^^^^ expected i8, found u32\n-help: you can convert an `u32` to `i8` or panic if it the converted value wouldn't fit\n+help: you can convert an `u32` to `i8` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<i8>(x_u32.try_into().unwrap());\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -831,7 +831,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<i8>(x_u16);\n    |               ^^^^^ expected i8, found u16\n-help: you can convert an `u16` to `i8` or panic if it the converted value wouldn't fit\n+help: you can convert an `u16` to `i8` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<i8>(x_u16.try_into().unwrap());\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -841,7 +841,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<i8>(x_u8);\n    |               ^^^^ expected i8, found u8\n-help: you can convert an `u8` to `i8` or panic if it the converted value wouldn't fit\n+help: you can convert an `u8` to `i8` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<i8>(x_u8.try_into().unwrap());\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -851,7 +851,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<i8>(x_isize);\n    |               ^^^^^^^ expected i8, found isize\n-help: you can convert an `isize` to `i8` or panic if it the converted value wouldn't fit\n+help: you can convert an `isize` to `i8` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<i8>(x_isize.try_into().unwrap());\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -861,7 +861,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<i8>(x_i64);\n    |               ^^^^^ expected i8, found i64\n-help: you can convert an `i64` to `i8` or panic if it the converted value wouldn't fit\n+help: you can convert an `i64` to `i8` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<i8>(x_i64.try_into().unwrap());\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -871,7 +871,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<i8>(x_i32);\n    |               ^^^^^ expected i8, found i32\n-help: you can convert an `i32` to `i8` or panic if it the converted value wouldn't fit\n+help: you can convert an `i32` to `i8` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<i8>(x_i32.try_into().unwrap());\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -881,7 +881,7 @@ error[E0308]: mismatched types\n    |\n LL |     foo::<i8>(x_i16);\n    |               ^^^^^ expected i8, found i16\n-help: you can convert an `i16` to `i8` or panic if it the converted value wouldn't fit\n+help: you can convert an `i16` to `i8` and panic if the converted value wouldn't fit\n    |\n LL |     foo::<i8>(x_i16.try_into().unwrap());\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "b4bc4a08c7b6d94c1a3e2d66519d0aba355d1ce8", "filename": "src/test/ui/pub/pub-restricted.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fpub%2Fpub-restricted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fpub%2Fpub-restricted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpub%2Fpub-restricted.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -4,6 +4,8 @@ mod a {}\n \n pub (a) fn afn() {} //~ incorrect visibility restriction\n pub (b) fn bfn() {} //~ incorrect visibility restriction\n+pub (crate::a) fn cfn() {} //~ incorrect visibility restriction\n+\n pub fn privfn() {}\n mod x {\n     mod y {"}, {"sha": "596264ba16b424ef82d282278f86d1d12766e078", "filename": "src/test/ui/pub/pub-restricted.stderr", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fpub%2Fpub-restricted.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fpub%2Fpub-restricted.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpub%2Fpub-restricted.stderr?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -21,7 +21,18 @@ LL | pub (b) fn bfn() {}\n            `pub(in path::to::module)`: visible only on the specified path\n \n error[E0704]: incorrect visibility restriction\n-  --> $DIR/pub-restricted.rs:22:14\n+  --> $DIR/pub-restricted.rs:7:6\n+   |\n+LL | pub (crate::a) fn cfn() {}\n+   |      ^^^^^^^^ help: make this visible only to module `crate::a` with `in`: `in crate::a`\n+   |\n+   = help: some possible visibility restrictions are:\n+           `pub(crate)`: visible only on the current crate\n+           `pub(super)`: visible only in the current module's parent\n+           `pub(in path::to::module)`: visible only on the specified path\n+\n+error[E0704]: incorrect visibility restriction\n+  --> $DIR/pub-restricted.rs:24:14\n    |\n LL |         pub (a) invalid: usize,\n    |              ^ help: make this visible only to module `a` with `in`: `in a`\n@@ -32,7 +43,7 @@ LL |         pub (a) invalid: usize,\n            `pub(in path::to::module)`: visible only on the specified path\n \n error[E0704]: incorrect visibility restriction\n-  --> $DIR/pub-restricted.rs:31:6\n+  --> $DIR/pub-restricted.rs:33:6\n    |\n LL | pub (xyz) fn xyz() {}\n    |      ^^^ help: make this visible only to module `xyz` with `in`: `in xyz`\n@@ -43,11 +54,11 @@ LL | pub (xyz) fn xyz() {}\n            `pub(in path::to::module)`: visible only on the specified path\n \n error: visibilities can only be restricted to ancestor modules\n-  --> $DIR/pub-restricted.rs:23:17\n+  --> $DIR/pub-restricted.rs:25:17\n    |\n LL |         pub (in x) non_parent_invalid: usize,\n    |                 ^\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 6 previous errors\n \n For more information about this error, try `rustc --explain E0704`."}, {"sha": "df73ac0b182f05d553a5e4ce056cd6fcc1ec9ea4", "filename": "src/test/ui/repeat_count.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Frepeat_count.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Frepeat_count.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frepeat_count.stderr?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -42,7 +42,7 @@ error[E0308]: mismatched types\n    |\n LL |     let f = [0; -4_isize];\n    |                 ^^^^^^^^ expected usize, found isize\n-help: you can convert an `isize` to `usize` or panic if it the converted value wouldn't fit\n+help: you can convert an `isize` to `usize` and panic if the converted value wouldn't fit\n    |\n LL |     let f = [0; (-4_isize).try_into().unwrap()];\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -52,7 +52,7 @@ error[E0308]: mismatched types\n    |\n LL |     let f = [0_usize; -1_isize];\n    |                       ^^^^^^^^ expected usize, found isize\n-help: you can convert an `isize` to `usize` or panic if it the converted value wouldn't fit\n+help: you can convert an `isize` to `usize` and panic if the converted value wouldn't fit\n    |\n LL |     let f = [0_usize; (-1_isize).try_into().unwrap()];\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "409fabb951adc644967bdd161f0d5c81a668a2ac", "filename": "src/test/ui/shift-various-bad-types.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fshift-various-bad-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Fshift-various-bad-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fshift-various-bad-types.stderr?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -27,7 +27,7 @@ error[E0308]: mismatched types\n    |\n LL |     let _: i32 = 22_i64 >> 1_i32;\n    |                  ^^^^^^^^^^^^^^^ expected i32, found i64\n-help: you can convert an `i64` to `i32` or panic if it the converted value wouldn't fit\n+help: you can convert an `i64` to `i32` and panic if the converted value wouldn't fit\n    |\n LL |     let _: i32 = (22_i64 >> 1_i32).try_into().unwrap();\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "e9c28248044f9ad0f5038319e9b6b8fbdf3470f7", "filename": "src/test/ui/trivial-bounds/trivial-bounds-inconsistent-projection-error.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Ftrivial-bounds%2Ftrivial-bounds-inconsistent-projection-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Ftrivial-bounds%2Ftrivial-bounds-inconsistent-projection-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftrivial-bounds%2Ftrivial-bounds-inconsistent-projection-error.stderr?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -6,7 +6,7 @@ LL | fn global_bound_is_hidden() -> u8\n ...\n LL |     B::get_x()\n    |     ^^^^^^^^^^ expected u8, found i32\n-help: you can convert an `i32` to `u8` or panic if it the converted value wouldn't fit\n+help: you can convert an `i32` to `u8` and panic if the converted value wouldn't fit\n    |\n LL |     B::get_x().try_into().unwrap()\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "f3e1cc41cada2343b57511efced86172374a23eb", "filename": "src/test/ui/tutorial-suffix-inference-test.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Ftutorial-suffix-inference-test.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftest%2Fui%2Ftutorial-suffix-inference-test.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftutorial-suffix-inference-test.stderr?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -12,7 +12,7 @@ error[E0308]: mismatched types\n    |\n LL |     identity_u16(y);\n    |                  ^ expected u16, found i32\n-help: you can convert an `i32` to `u16` or panic if it the converted value wouldn't fit\n+help: you can convert an `i32` to `u16` and panic if the converted value wouldn't fit\n    |\n LL |     identity_u16(y.try_into().unwrap());\n    |                  ^^^^^^^^^^^^^^^^^^^^^\n@@ -22,7 +22,7 @@ error[E0308]: mismatched types\n    |\n LL |     identity_u16(a);\n    |                  ^ expected u16, found isize\n-help: you can convert an `isize` to `u16` or panic if it the converted value wouldn't fit\n+help: you can convert an `isize` to `u16` and panic if the converted value wouldn't fit\n    |\n LL |     identity_u16(a.try_into().unwrap());\n    |                  ^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "433e9264dd1dc369a8fc219358da811baa8fb940", "filename": "src/tools/tidy/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftools%2Ftidy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftools%2Ftidy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2FCargo.toml?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -2,6 +2,7 @@\n name = \"tidy\"\n version = \"0.1.0\"\n authors = [\"Alex Crichton <alex@alexcrichton.com>\"]\n+edition = \"2018\"\n \n [dependencies]\n regex = \"1\""}, {"sha": "e90737febd5bfb93af3f07f44e98dccf82e46a49", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -5,6 +5,7 @@ use std::fs;\n use std::path::Path;\n use std::process::Command;\n \n+use serde_derive::Deserialize;\n use serde_json;\n \n const LICENSES: &[&str] = &["}, {"sha": "f9f3623679e175db2a641a4ef1037a1857bf706a", "filename": "src/tools/tidy/src/features.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -18,7 +18,7 @@ use std::path::Path;\n use regex::{Regex, escape};\n \n mod version;\n-use self::version::Version;\n+use version::Version;\n \n const FEATURE_GROUP_START_PREFIX: &str = \"// feature-group-start\";\n const FEATURE_GROUP_END_PREFIX: &str = \"// feature-group-end\";"}, {"sha": "1ce9fe127dd9395984b959b0741aa49a8ac78482", "filename": "src/tools/tidy/src/features/version.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures%2Fversion.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -31,15 +31,13 @@ impl FromStr for Version {\n     fn from_str(s: &str) -> Result<Self, Self::Err> {\n         let mut iter = s.split('.').map(|part| Ok(part.parse()?));\n \n-        let parts = {\n-            let mut part = || {\n-                iter.next()\n-                    .unwrap_or(Err(ParseVersionError::WrongNumberOfParts))\n-            };\n-\n-            [part()?, part()?, part()?]\n+        let mut part = || {\n+            iter.next()\n+                .unwrap_or(Err(ParseVersionError::WrongNumberOfParts))\n         };\n \n+        let parts = [part()?, part()?, part()?];\n+\n         if let Some(_) = iter.next() {\n             // Ensure we don't have more than 3 parts.\n             return Err(ParseVersionError::WrongNumberOfParts);"}, {"sha": "d06c99725bc6a5ea228fb688b9a8bfc2855ad752", "filename": "src/tools/tidy/src/lib.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -3,13 +3,6 @@\n //! This library contains the tidy lints and exposes it\n //! to be used by tools.\n \n-#![deny(rust_2018_idioms)]\n-\n-extern crate regex;\n-extern crate serde_json;\n-#[macro_use]\n-extern crate serde_derive;\n-\n use std::fs;\n \n use std::path::Path;"}, {"sha": "eef3719043825e4b3f77635b0b6a6f1199d22e54", "filename": "src/tools/tidy/src/main.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f1bc91803b04caf3e20b3849633bb7ffe6b4074/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fmain.rs?ref=2f1bc91803b04caf3e20b3849633bb7ffe6b4074", "patch": "@@ -4,10 +4,8 @@\n //! etc. This is run by default on `make check` and as part of the auto\n //! builders.\n \n-#![deny(rust_2018_idioms)]\n #![deny(warnings)]\n \n-extern crate tidy;\n use tidy::*;\n \n use std::process;"}]}