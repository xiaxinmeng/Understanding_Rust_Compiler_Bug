{"sha": "1d4dd3d428cf6a622dc863a134ffacdb2183b6db", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkNGRkM2Q0MjhjZjZhNjIyZGM4NjNhMTM0ZmZhY2RiMjE4M2I2ZGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-22T15:50:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-22T15:50:32Z"}, "message": "Auto merge of #5439 - rokob:lock-await, r=Manishearth\n\nLint for holding locks across await points\n\nFixes #4226\n\nThis introduces the lint await_holding_lock. For async functions, we iterate\nover all types in generator_interior_types and look for types named MutexGuard,\nRwLockReadGuard, or RwLockWriteGuard. If we find one then we emit a lint.\n\nchangelog: introduce the await_holding_lock lint", "tree": {"sha": "bffcdb995d64f861ec97f92a948cf0e2a0c76827", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bffcdb995d64f861ec97f92a948cf0e2a0c76827"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d4dd3d428cf6a622dc863a134ffacdb2183b6db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d4dd3d428cf6a622dc863a134ffacdb2183b6db", "html_url": "https://github.com/rust-lang/rust/commit/1d4dd3d428cf6a622dc863a134ffacdb2183b6db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d4dd3d428cf6a622dc863a134ffacdb2183b6db/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3cb9b8376b79837ec525da017871ab1859292dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3cb9b8376b79837ec525da017871ab1859292dc", "html_url": "https://github.com/rust-lang/rust/commit/b3cb9b8376b79837ec525da017871ab1859292dc"}, {"sha": "8b052d3142fe3e335c676981c58235328268805e", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b052d3142fe3e335c676981c58235328268805e", "html_url": "https://github.com/rust-lang/rust/commit/8b052d3142fe3e335c676981c58235328268805e"}], "stats": {"total": 239, "additions": 239, "deletions": 0}, "files": [{"sha": "abd7167502b9c2ff3fa04d97debeaa0704642fbb", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1d4dd3d428cf6a622dc863a134ffacdb2183b6db/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/1d4dd3d428cf6a622dc863a134ffacdb2183b6db/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=1d4dd3d428cf6a622dc863a134ffacdb2183b6db", "patch": "@@ -1188,6 +1188,7 @@ Released 2018-09-13\n [`assertions_on_constants`]: https://rust-lang.github.io/rust-clippy/master/index.html#assertions_on_constants\n [`assign_op_pattern`]: https://rust-lang.github.io/rust-clippy/master/index.html#assign_op_pattern\n [`assign_ops`]: https://rust-lang.github.io/rust-clippy/master/index.html#assign_ops\n+[`await_holding_lock`]: https://rust-lang.github.io/rust-clippy/master/index.html#await_holding_lock\n [`bad_bit_mask`]: https://rust-lang.github.io/rust-clippy/master/index.html#bad_bit_mask\n [`blacklisted_name`]: https://rust-lang.github.io/rust-clippy/master/index.html#blacklisted_name\n [`block_in_if_condition_expr`]: https://rust-lang.github.io/rust-clippy/master/index.html#block_in_if_condition_expr"}, {"sha": "832910763e60c99e55b4adb7f1bcc00e292c556e", "filename": "clippy_lints/src/await_holding_lock.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/1d4dd3d428cf6a622dc863a134ffacdb2183b6db/clippy_lints%2Fsrc%2Fawait_holding_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d4dd3d428cf6a622dc863a134ffacdb2183b6db/clippy_lints%2Fsrc%2Fawait_holding_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fawait_holding_lock.rs?ref=1d4dd3d428cf6a622dc863a134ffacdb2183b6db", "patch": "@@ -0,0 +1,97 @@\n+use crate::utils::{match_def_path, paths, span_lint_and_note};\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::{AsyncGeneratorKind, Body, BodyId, GeneratorKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::GeneratorInteriorTypeCause;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::Span;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for calls to await while holding a\n+    /// non-async-aware MutexGuard.\n+    ///\n+    /// **Why is this bad?** The Mutex types found in syd::sync and parking_lot\n+    /// are not designed to operator in an async context across await points.\n+    ///\n+    /// There are two potential solutions. One is to use an asynx-aware Mutex\n+    /// type. Many asynchronous foundation crates provide such a Mutex type. The\n+    /// other solution is to ensure the mutex is unlocked before calling await,\n+    /// either by introducing a scope or an explicit call to Drop::drop.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust,ignore\n+    /// use std::sync::Mutex;\n+    ///\n+    /// async fn foo(x: &Mutex<u32>) {\n+    ///   let guard = x.lock().unwrap();\n+    ///   *guard += 1;\n+    ///   bar.await;\n+    /// }\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// use std::sync::Mutex;\n+    ///\n+    /// async fn foo(x: &Mutex<u32>) {\n+    ///   {\n+    ///     let guard = x.lock().unwrap();\n+    ///     *guard += 1;\n+    ///   }\n+    ///   bar.await;\n+    /// }\n+    /// ```\n+    pub AWAIT_HOLDING_LOCK,\n+    pedantic,\n+    \"Inside an async function, holding a MutexGuard while calling await\"\n+}\n+\n+declare_lint_pass!(AwaitHoldingLock => [AWAIT_HOLDING_LOCK]);\n+\n+impl LateLintPass<'_, '_> for AwaitHoldingLock {\n+    fn check_body(&mut self, cx: &LateContext<'_, '_>, body: &'_ Body<'_>) {\n+        use AsyncGeneratorKind::{Block, Closure, Fn};\n+        match body.generator_kind {\n+            Some(GeneratorKind::Async(Block))\n+            | Some(GeneratorKind::Async(Closure))\n+            | Some(GeneratorKind::Async(Fn)) => {\n+                let body_id = BodyId {\n+                    hir_id: body.value.hir_id,\n+                };\n+                let def_id = cx.tcx.hir().body_owner_def_id(body_id);\n+                let tables = cx.tcx.typeck_tables_of(def_id);\n+                check_interior_types(cx, &tables.generator_interior_types, body.value.span);\n+            },\n+            _ => {},\n+        }\n+    }\n+}\n+\n+fn check_interior_types(cx: &LateContext<'_, '_>, ty_causes: &[GeneratorInteriorTypeCause<'_>], span: Span) {\n+    for ty_cause in ty_causes {\n+        if let rustc_middle::ty::Adt(adt, _) = ty_cause.ty.kind {\n+            if is_mutex_guard(cx, adt.did) {\n+                span_lint_and_note(\n+                    cx,\n+                    AWAIT_HOLDING_LOCK,\n+                    ty_cause.span,\n+                    \"this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await.\",\n+                    ty_cause.scope_span.or(Some(span)),\n+                    \"these are all the await points this lock is held through\",\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+fn is_mutex_guard(cx: &LateContext<'_, '_>, def_id: DefId) -> bool {\n+    match_def_path(cx, def_id, &paths::MUTEX_GUARD)\n+        || match_def_path(cx, def_id, &paths::RWLOCK_READ_GUARD)\n+        || match_def_path(cx, def_id, &paths::RWLOCK_WRITE_GUARD)\n+        || match_def_path(cx, def_id, &paths::PARKING_LOT_MUTEX_GUARD)\n+        || match_def_path(cx, def_id, &paths::PARKING_LOT_RWLOCK_READ_GUARD)\n+        || match_def_path(cx, def_id, &paths::PARKING_LOT_RWLOCK_WRITE_GUARD)\n+}"}, {"sha": "dee4188b75f38d840fc6345a0a5328a782139050", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1d4dd3d428cf6a622dc863a134ffacdb2183b6db/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d4dd3d428cf6a622dc863a134ffacdb2183b6db/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=1d4dd3d428cf6a622dc863a134ffacdb2183b6db", "patch": "@@ -177,6 +177,7 @@ mod assertions_on_constants;\n mod assign_ops;\n mod atomic_ordering;\n mod attrs;\n+mod await_holding_lock;\n mod bit_mask;\n mod blacklisted_name;\n mod block_in_if_condition;\n@@ -497,6 +498,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &attrs::INLINE_ALWAYS,\n         &attrs::UNKNOWN_CLIPPY_LINTS,\n         &attrs::USELESS_ATTRIBUTE,\n+        &await_holding_lock::AWAIT_HOLDING_LOCK,\n         &bit_mask::BAD_BIT_MASK,\n         &bit_mask::INEFFECTIVE_BIT_MASK,\n         &bit_mask::VERBOSE_BIT_MASK,\n@@ -864,6 +866,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     ]);\n     // end register lints, do not remove this comment, it\u2019s used in `update_lints`\n \n+    store.register_late_pass(|| box await_holding_lock::AwaitHoldingLock);\n     store.register_late_pass(|| box serde_api::SerdeAPI);\n     store.register_late_pass(|| box utils::internal_lints::CompilerLintFunctions::new());\n     store.register_late_pass(|| box utils::internal_lints::LintWithoutLintPass::default());\n@@ -1102,6 +1105,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n \n     store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n         LintId::of(&attrs::INLINE_ALWAYS),\n+        LintId::of(&await_holding_lock::AWAIT_HOLDING_LOCK),\n         LintId::of(&checked_conversions::CHECKED_CONVERSIONS),\n         LintId::of(&copies::MATCH_SAME_ARMS),\n         LintId::of(&copies::SAME_FUNCTIONS_IN_IF_CONDITION),"}, {"sha": "7ad09eabec1516c5651f2bf3e5c38afa469cd853", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1d4dd3d428cf6a622dc863a134ffacdb2183b6db/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d4dd3d428cf6a622dc863a134ffacdb2183b6db/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=1d4dd3d428cf6a622dc863a134ffacdb2183b6db", "patch": "@@ -72,6 +72,9 @@ pub const ORD: [&str; 3] = [\"core\", \"cmp\", \"Ord\"];\n pub const OS_STRING: [&str; 4] = [\"std\", \"ffi\", \"os_str\", \"OsString\"];\n pub const OS_STRING_AS_OS_STR: [&str; 5] = [\"std\", \"ffi\", \"os_str\", \"OsString\", \"as_os_str\"];\n pub const OS_STR_TO_OS_STRING: [&str; 5] = [\"std\", \"ffi\", \"os_str\", \"OsStr\", \"to_os_string\"];\n+pub const PARKING_LOT_MUTEX_GUARD: [&str; 2] = [\"parking_lot\", \"MutexGuard\"];\n+pub const PARKING_LOT_RWLOCK_READ_GUARD: [&str; 2] = [\"parking_lot\", \"RwLockReadGuard\"];\n+pub const PARKING_LOT_RWLOCK_WRITE_GUARD: [&str; 2] = [\"parking_lot\", \"RwLockWriteGuard\"];\n pub const PATH: [&str; 3] = [\"std\", \"path\", \"Path\"];\n pub const PATH_BUF: [&str; 3] = [\"std\", \"path\", \"PathBuf\"];\n pub const PATH_BUF_AS_PATH: [&str; 4] = [\"std\", \"path\", \"PathBuf\", \"as_path\"];"}, {"sha": "2c466aa20c6753ed94fca3b8fba86fd7f5c780fc", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1d4dd3d428cf6a622dc863a134ffacdb2183b6db/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d4dd3d428cf6a622dc863a134ffacdb2183b6db/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=1d4dd3d428cf6a622dc863a134ffacdb2183b6db", "patch": "@@ -52,6 +52,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"assign_ops\",\n     },\n+    Lint {\n+        name: \"await_holding_lock\",\n+        group: \"pedantic\",\n+        desc: \"Inside an async function, holding a MutexGuard while calling await\",\n+        deprecation: None,\n+        module: \"await_holding_lock\",\n+    },\n     Lint {\n         name: \"bad_bit_mask\",\n         group: \"correctness\","}, {"sha": "5c1fdd83efb0da25f4578355532ee4101126cb11", "filename": "tests/ui/await_holding_lock.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/1d4dd3d428cf6a622dc863a134ffacdb2183b6db/tests%2Fui%2Fawait_holding_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d4dd3d428cf6a622dc863a134ffacdb2183b6db/tests%2Fui%2Fawait_holding_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fawait_holding_lock.rs?ref=1d4dd3d428cf6a622dc863a134ffacdb2183b6db", "patch": "@@ -0,0 +1,64 @@\n+// edition:2018\n+#![warn(clippy::await_holding_lock)]\n+\n+use std::sync::Mutex;\n+\n+async fn bad(x: &Mutex<u32>) -> u32 {\n+    let guard = x.lock().unwrap();\n+    baz().await\n+}\n+\n+async fn good(x: &Mutex<u32>) -> u32 {\n+    {\n+        let guard = x.lock().unwrap();\n+        let y = *guard + 1;\n+    }\n+    baz().await;\n+    let guard = x.lock().unwrap();\n+    47\n+}\n+\n+async fn baz() -> u32 {\n+    42\n+}\n+\n+async fn also_bad(x: &Mutex<u32>) -> u32 {\n+    let first = baz().await;\n+\n+    let guard = x.lock().unwrap();\n+\n+    let second = baz().await;\n+\n+    let third = baz().await;\n+\n+    first + second + third\n+}\n+\n+async fn not_good(x: &Mutex<u32>) -> u32 {\n+    let first = baz().await;\n+\n+    let second = {\n+        let guard = x.lock().unwrap();\n+        baz().await\n+    };\n+\n+    let third = baz().await;\n+\n+    first + second + third\n+}\n+\n+fn block_bad(x: &Mutex<u32>) -> impl std::future::Future<Output = u32> + '_ {\n+    async move {\n+        let guard = x.lock().unwrap();\n+        baz().await\n+    }\n+}\n+\n+fn main() {\n+    let m = Mutex::new(100);\n+    good(&m);\n+    bad(&m);\n+    also_bad(&m);\n+    not_good(&m);\n+    block_bad(&m);\n+}"}, {"sha": "8c47cb37d8c997230423bf3c4b899fa31e455ac1", "filename": "tests/ui/await_holding_lock.stderr", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/1d4dd3d428cf6a622dc863a134ffacdb2183b6db/tests%2Fui%2Fawait_holding_lock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1d4dd3d428cf6a622dc863a134ffacdb2183b6db/tests%2Fui%2Fawait_holding_lock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fawait_holding_lock.stderr?ref=1d4dd3d428cf6a622dc863a134ffacdb2183b6db", "patch": "@@ -0,0 +1,63 @@\n+error: this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await.\n+  --> $DIR/await_holding_lock.rs:7:9\n+   |\n+LL |     let guard = x.lock().unwrap();\n+   |         ^^^^^\n+   |\n+   = note: `-D clippy::await-holding-lock` implied by `-D warnings`\n+note: these are all the await points this lock is held through\n+  --> $DIR/await_holding_lock.rs:7:5\n+   |\n+LL | /     let guard = x.lock().unwrap();\n+LL | |     baz().await\n+LL | | }\n+   | |_^\n+\n+error: this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await.\n+  --> $DIR/await_holding_lock.rs:28:9\n+   |\n+LL |     let guard = x.lock().unwrap();\n+   |         ^^^^^\n+   |\n+note: these are all the await points this lock is held through\n+  --> $DIR/await_holding_lock.rs:28:5\n+   |\n+LL | /     let guard = x.lock().unwrap();\n+LL | |\n+LL | |     let second = baz().await;\n+LL | |\n+...  |\n+LL | |     first + second + third\n+LL | | }\n+   | |_^\n+\n+error: this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await.\n+  --> $DIR/await_holding_lock.rs:41:13\n+   |\n+LL |         let guard = x.lock().unwrap();\n+   |             ^^^^^\n+   |\n+note: these are all the await points this lock is held through\n+  --> $DIR/await_holding_lock.rs:41:9\n+   |\n+LL | /         let guard = x.lock().unwrap();\n+LL | |         baz().await\n+LL | |     };\n+   | |_____^\n+\n+error: this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await.\n+  --> $DIR/await_holding_lock.rs:52:13\n+   |\n+LL |         let guard = x.lock().unwrap();\n+   |             ^^^^^\n+   |\n+note: these are all the await points this lock is held through\n+  --> $DIR/await_holding_lock.rs:52:9\n+   |\n+LL | /         let guard = x.lock().unwrap();\n+LL | |         baz().await\n+LL | |     }\n+   | |_____^\n+\n+error: aborting due to 4 previous errors\n+"}]}