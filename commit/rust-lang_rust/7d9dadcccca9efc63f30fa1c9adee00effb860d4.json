{"sha": "7d9dadcccca9efc63f30fa1c9adee00effb860d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkOWRhZGNjY2NhOWVmYzYzZjMwZmExYzlhZGVlMDBlZmZiODYwZDQ=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-02-12T21:36:47Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-02-12T22:45:18Z"}, "message": "Implement `Maybe{Mut,}BorrowedLocals` analyses", "tree": {"sha": "456a103c369cb94d03114350e3ecccf707aaf491", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/456a103c369cb94d03114350e3ecccf707aaf491"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d9dadcccca9efc63f30fa1c9adee00effb860d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d9dadcccca9efc63f30fa1c9adee00effb860d4", "html_url": "https://github.com/rust-lang/rust/commit/7d9dadcccca9efc63f30fa1c9adee00effb860d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d9dadcccca9efc63f30fa1c9adee00effb860d4/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc5c2956b11e29f931cec010e3f38461ec4ac309", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc5c2956b11e29f931cec010e3f38461ec4ac309", "html_url": "https://github.com/rust-lang/rust/commit/fc5c2956b11e29f931cec010e3f38461ec4ac309"}], "stats": {"total": 271, "additions": 209, "deletions": 62}, "files": [{"sha": "519db963d1e7dc655f58eb83ab4511d4db4e955c", "filename": "src/librustc_mir/dataflow/impls/borrowed_locals.rs", "status": "modified", "additions": 208, "deletions": 60, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/7d9dadcccca9efc63f30fa1c9adee00effb860d4/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d9dadcccca9efc63f30fa1c9adee00effb860d4/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs?ref=7d9dadcccca9efc63f30fa1c9adee00effb860d4", "patch": "@@ -1,102 +1,250 @@\n pub use super::*;\n \n-use crate::dataflow::{BitDenotation, GenKillSet};\n+use crate::dataflow::generic::{AnalysisDomain, GenKill, GenKillAnalysis};\n use rustc::mir::visit::Visitor;\n use rustc::mir::*;\n+use rustc::ty::{ParamEnv, TyCtxt};\n+use rustc_span::DUMMY_SP;\n+\n+pub type MaybeMutBorrowedLocals<'mir, 'tcx> = MaybeBorrowedLocals<MutBorrow<'mir, 'tcx>>;\n+\n+/// A dataflow analysis that tracks whether a pointer or reference could possibly exist that points\n+/// to a given local.\n+///\n+/// The `K` parameter determines what kind of borrows are tracked. By default,\n+/// `MaybeBorrowedLocals` looks for *any* borrow of a local. If you are only interested in borrows\n+/// that might allow mutation, use the `MaybeMutBorrowedLocals` type alias instead.\n+///\n+/// At present, this is used as a very limited form of alias analysis. For example,\n+/// `MaybeBorrowedLocals` is used to compute which locals are live during a yield expression for\n+/// immovable generators. `MaybeMutBorrowedLocals` is used during const checking to prove that a\n+/// local has not been mutated via indirect assignment (e.g., `*p = 42`), the side-effects of a\n+/// function call or inline assembly.\n+pub struct MaybeBorrowedLocals<K = AnyBorrow> {\n+    kind: K,\n+}\n \n-/// This calculates if any part of a MIR local could have previously been borrowed.\n-/// This means that once a local has been borrowed, its bit will be set\n-/// from that point and onwards, until we see a StorageDead statement for the local,\n-/// at which points there is no memory associated with the local, so it cannot be borrowed.\n-/// This is used to compute which locals are live during a yield expression for\n-/// immovable generators.\n-#[derive(Copy, Clone)]\n-pub struct HaveBeenBorrowedLocals<'a, 'tcx> {\n-    body: &'a Body<'tcx>,\n+impl MaybeBorrowedLocals {\n+    /// A dataflow analysis that records whether a pointer or reference exists that may alias the\n+    /// given local.\n+    pub fn new() -> Self {\n+        MaybeBorrowedLocals { kind: AnyBorrow }\n+    }\n }\n \n-impl<'a, 'tcx> HaveBeenBorrowedLocals<'a, 'tcx> {\n-    pub fn new(body: &'a Body<'tcx>) -> Self {\n-        HaveBeenBorrowedLocals { body }\n+impl MaybeMutBorrowedLocals<'mir, 'tcx> {\n+    /// A dataflow analysis that records whether a pointer or reference exists that may *mutably*\n+    /// alias the given local.\n+    pub fn new_mut_only(\n+        tcx: TyCtxt<'tcx>,\n+        body: &'mir mir::Body<'tcx>,\n+        param_env: ParamEnv<'tcx>,\n+    ) -> Self {\n+        MaybeBorrowedLocals { kind: MutBorrow { body, tcx, param_env } }\n     }\n+}\n \n-    pub fn body(&self) -> &Body<'tcx> {\n-        self.body\n+impl<K> MaybeBorrowedLocals<K> {\n+    fn transfer_function<'a, T>(&'a self, trans: &'a mut T) -> TransferFunction<'a, T, K> {\n+        TransferFunction { kind: &self.kind, trans }\n     }\n }\n \n-impl<'a, 'tcx> BitDenotation<'tcx> for HaveBeenBorrowedLocals<'a, 'tcx> {\n+impl<K> AnalysisDomain<'tcx> for MaybeBorrowedLocals<K>\n+where\n+    K: BorrowAnalysisKind<'tcx>,\n+{\n     type Idx = Local;\n-    fn name() -> &'static str {\n-        \"has_been_borrowed_locals\"\n+\n+    const NAME: &'static str = K::ANALYSIS_NAME;\n+\n+    fn bits_per_block(&self, body: &mir::Body<'tcx>) -> usize {\n+        body.local_decls().len()\n+    }\n+\n+    fn initialize_start_block(&self, _: &mir::Body<'tcx>, _: &mut BitSet<Self::Idx>) {\n+        // No locals are aliased on function entry\n+    }\n+}\n+\n+impl<K> GenKillAnalysis<'tcx> for MaybeBorrowedLocals<K>\n+where\n+    K: BorrowAnalysisKind<'tcx>,\n+{\n+    fn statement_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        statement: &mir::Statement<'tcx>,\n+        location: Location,\n+    ) {\n+        self.transfer_function(trans).visit_statement(statement, location);\n     }\n-    fn bits_per_block(&self) -> usize {\n-        self.body.local_decls.len()\n+\n+    fn terminator_effect(\n+        &self,\n+        trans: &mut impl GenKill<Self::Idx>,\n+        terminator: &mir::Terminator<'tcx>,\n+        location: Location,\n+    ) {\n+        self.transfer_function(trans).visit_terminator(terminator, location);\n     }\n \n-    fn start_block_effect(&self, _on_entry: &mut BitSet<Local>) {\n-        // Nothing is borrowed on function entry\n+    fn call_return_effect(\n+        &self,\n+        _trans: &mut impl GenKill<Self::Idx>,\n+        _block: mir::BasicBlock,\n+        _func: &mir::Operand<'tcx>,\n+        _args: &[mir::Operand<'tcx>],\n+        _dest_place: &mir::Place<'tcx>,\n+    ) {\n     }\n+}\n \n-    fn statement_effect(&self, trans: &mut GenKillSet<Local>, loc: Location) {\n-        let stmt = &self.body[loc.block].statements[loc.statement_index];\n+impl<K> BottomValue for MaybeBorrowedLocals<K> {\n+    // bottom = unborrowed\n+    const BOTTOM_VALUE: bool = false;\n+}\n \n-        BorrowedLocalsVisitor { trans }.visit_statement(stmt, loc);\n+/// A `Visitor` that defines the transfer function for `MaybeBorrowedLocals`.\n+struct TransferFunction<'a, T, K> {\n+    trans: &'a mut T,\n+    kind: &'a K,\n+}\n \n-        // StorageDead invalidates all borrows and raw pointers to a local\n-        match stmt.kind {\n-            StatementKind::StorageDead(l) => trans.kill(l),\n-            _ => (),\n+impl<T, K> Visitor<'tcx> for TransferFunction<'a, T, K>\n+where\n+    T: GenKill<Local>,\n+    K: BorrowAnalysisKind<'tcx>,\n+{\n+    fn visit_statement(&mut self, stmt: &Statement<'tcx>, location: Location) {\n+        self.super_statement(stmt, location);\n+\n+        // When we reach a `StorageDead` statement, we can assume that any pointers to this memory\n+        // are now invalid.\n+        if let StatementKind::StorageDead(local) = stmt.kind {\n+            self.trans.kill(local);\n         }\n     }\n \n-    fn terminator_effect(&self, trans: &mut GenKillSet<Local>, loc: Location) {\n-        let terminator = self.body[loc.block].terminator();\n-        BorrowedLocalsVisitor { trans }.visit_terminator(terminator, loc);\n-        match &terminator.kind {\n-            // Drop terminators borrows the location\n-            TerminatorKind::Drop { location, .. }\n-            | TerminatorKind::DropAndReplace { location, .. } => {\n-                if let Some(local) = find_local(location) {\n-                    trans.gen(local);\n+    fn visit_rvalue(&mut self, rvalue: &mir::Rvalue<'tcx>, location: Location) {\n+        self.super_rvalue(rvalue, location);\n+\n+        match rvalue {\n+            mir::Rvalue::AddressOf(mt, borrowed_place) => {\n+                if !borrowed_place.is_indirect() && self.kind.in_address_of(*mt, borrowed_place) {\n+                    self.trans.gen(borrowed_place.local);\n                 }\n             }\n-            _ => (),\n+\n+            mir::Rvalue::Ref(_, kind, borrowed_place) => {\n+                if !borrowed_place.is_indirect() && self.kind.in_ref(*kind, borrowed_place) {\n+                    self.trans.gen(borrowed_place.local);\n+                }\n+            }\n+\n+            mir::Rvalue::Cast(..)\n+            | mir::Rvalue::Use(..)\n+            | mir::Rvalue::Repeat(..)\n+            | mir::Rvalue::Len(..)\n+            | mir::Rvalue::BinaryOp(..)\n+            | mir::Rvalue::CheckedBinaryOp(..)\n+            | mir::Rvalue::NullaryOp(..)\n+            | mir::Rvalue::UnaryOp(..)\n+            | mir::Rvalue::Discriminant(..)\n+            | mir::Rvalue::Aggregate(..) => {}\n         }\n     }\n \n-    fn propagate_call_return(\n-        &self,\n-        _in_out: &mut BitSet<Local>,\n-        _call_bb: mir::BasicBlock,\n-        _dest_bb: mir::BasicBlock,\n-        _dest_place: &mir::Place<'tcx>,\n-    ) {\n-        // Nothing to do when a call returns successfully\n+    fn visit_terminator(&mut self, terminator: &mir::Terminator<'tcx>, location: Location) {\n+        self.super_terminator(terminator, location);\n+\n+        match terminator.kind {\n+            // Drop terminators may call custom drop glue (`Drop::drop`), which takes `&mut self`\n+            // as a parameter. Hypothetically, a drop impl could launder that reference into the\n+            // surrounding environment through a raw pointer, thus creating a valid `*mut` pointing\n+            // to the dropped local. We are not yet willing to declare this particular case UB, so\n+            // we must treat all dropped locals as mutably borrowed for now. See discussion on\n+            // [#61069].\n+            //\n+            // [#61069]: https://github.com/rust-lang/rust/pull/61069\n+            mir::TerminatorKind::Drop { location: dropped_place, .. }\n+            | mir::TerminatorKind::DropAndReplace { location: dropped_place, .. } => {\n+                self.trans.gen(dropped_place.local);\n+            }\n+\n+            TerminatorKind::Abort\n+            | TerminatorKind::Assert { .. }\n+            | TerminatorKind::Call { .. }\n+            | TerminatorKind::FalseEdges { .. }\n+            | TerminatorKind::FalseUnwind { .. }\n+            | TerminatorKind::GeneratorDrop\n+            | TerminatorKind::Goto { .. }\n+            | TerminatorKind::Resume\n+            | TerminatorKind::Return\n+            | TerminatorKind::SwitchInt { .. }\n+            | TerminatorKind::Unreachable\n+            | TerminatorKind::Yield { .. } => {}\n+        }\n     }\n }\n \n-impl<'a, 'tcx> BottomValue for HaveBeenBorrowedLocals<'a, 'tcx> {\n-    // bottom = unborrowed\n-    const BOTTOM_VALUE: bool = false;\n+pub struct AnyBorrow;\n+\n+pub struct MutBorrow<'mir, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    body: &'mir Body<'tcx>,\n+    param_env: ParamEnv<'tcx>,\n }\n \n-struct BorrowedLocalsVisitor<'gk> {\n-    trans: &'gk mut GenKillSet<Local>,\n+impl MutBorrow<'mir, 'tcx> {\n+    // `&` and `&raw` only allow mutation if the borrowed place is `!Freeze`.\n+    //\n+    // This assumes that it is UB to take the address of a struct field whose type is\n+    // `Freeze`, then use pointer arithmetic to derive a pointer to a *different* field of\n+    // that same struct whose type is `!Freeze`. If we decide that this is not UB, we will\n+    // have to check the type of the borrowed **local** instead of the borrowed **place**\n+    // below. See [rust-lang/unsafe-code-guidelines#134].\n+    //\n+    // [rust-lang/unsafe-code-guidelines#134]: https://github.com/rust-lang/unsafe-code-guidelines/issues/134\n+    fn shared_borrow_allows_mutation(&self, place: &Place<'tcx>) -> bool {\n+        !place.ty(self.body, self.tcx).ty.is_freeze(self.tcx, self.param_env, DUMMY_SP)\n+    }\n }\n \n-fn find_local(place: &Place<'_>) -> Option<Local> {\n-    if !place.is_indirect() { Some(place.local) } else { None }\n+pub trait BorrowAnalysisKind<'tcx> {\n+    const ANALYSIS_NAME: &'static str;\n+\n+    fn in_address_of(&self, mt: Mutability, place: &Place<'tcx>) -> bool;\n+    fn in_ref(&self, kind: mir::BorrowKind, place: &Place<'tcx>) -> bool;\n }\n \n-impl<'tcx> Visitor<'tcx> for BorrowedLocalsVisitor<'_> {\n-    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n-        if let Rvalue::Ref(_, _, ref place) = *rvalue {\n-            if let Some(local) = find_local(place) {\n-                self.trans.gen(local);\n+impl BorrowAnalysisKind<'tcx> for AnyBorrow {\n+    const ANALYSIS_NAME: &'static str = \"maybe_borrowed_locals\";\n+\n+    fn in_ref(&self, _: mir::BorrowKind, _: &Place<'_>) -> bool {\n+        true\n+    }\n+    fn in_address_of(&self, _: Mutability, _: &Place<'_>) -> bool {\n+        true\n+    }\n+}\n+\n+impl BorrowAnalysisKind<'tcx> for MutBorrow<'mir, 'tcx> {\n+    const ANALYSIS_NAME: &'static str = \"maybe_mut_borrowed_locals\";\n+\n+    fn in_ref(&self, kind: mir::BorrowKind, place: &Place<'tcx>) -> bool {\n+        match kind {\n+            mir::BorrowKind::Mut { .. } => true,\n+            mir::BorrowKind::Shared | mir::BorrowKind::Shallow | mir::BorrowKind::Unique => {\n+                self.shared_borrow_allows_mutation(place)\n             }\n         }\n+    }\n \n-        self.super_rvalue(rvalue, location)\n+    fn in_address_of(&self, mt: Mutability, place: &Place<'tcx>) -> bool {\n+        match mt {\n+            Mutability::Mut => true,\n+            Mutability::Not => self.shared_borrow_allows_mutation(place),\n+        }\n     }\n }"}, {"sha": "41bac894e48ce6031f5b50def87939ffd663070b", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7d9dadcccca9efc63f30fa1c9adee00effb860d4/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d9dadcccca9efc63f30fa1c9adee00effb860d4/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=7d9dadcccca9efc63f30fa1c9adee00effb860d4", "patch": "@@ -23,8 +23,7 @@ pub(crate) use self::drop_flag_effects::*;\n pub use self::impls::borrows::Borrows;\n pub use self::impls::DefinitelyInitializedPlaces;\n pub use self::impls::EverInitializedPlaces;\n-pub use self::impls::HaveBeenBorrowedLocals;\n-pub use self::impls::IndirectlyMutableLocals;\n+pub use self::impls::{MaybeBorrowedLocals, MaybeMutBorrowedLocals};\n pub use self::impls::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n pub use self::impls::{MaybeStorageLive, RequiresStorage};\n "}]}